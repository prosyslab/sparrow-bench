/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 43 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 214 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef unsigned int size_t;
#line 152 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef int ptrdiff_t;
#line 326 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef int wchar_t;
#line 355 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef unsigned int wint_t;
#line 51 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.h"
enum __anonenum_arg_type_28 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 51 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.h"
typedef enum __anonenum_arg_type_28 arg_type;
#line 93 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.h"
union __anonunion_a_30 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 93 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.h"
struct __anonstruct_argument_29 {
   arg_type type ;
   union __anonunion_a_30 a ;
};
#line 93 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.h"
typedef struct __anonstruct_argument_29 argument;
#line 140 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.h"
struct __anonstruct_arguments_31 {
   size_t count ;
   argument *arg ;
};
#line 140 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.h"
typedef struct __anonstruct_arguments_31 arguments;
#line 45 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-parse.h"
struct __anonstruct_char_directive_32 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 45 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-parse.h"
typedef struct __anonstruct_char_directive_32 char_directive;
#line 62 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-parse.h"
struct __anonstruct_char_directives_33 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
};
#line 62 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-parse.h"
typedef struct __anonstruct_char_directives_33 char_directives;
#line 141 "/usr/include/stdint.h"
typedef unsigned long long uintmax_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 34 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 239
struct quoting_options;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_25 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_24 {
   int __count ;
   union __anonunion___value_25 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_24 __mbstate_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 48 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 680 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 139 "/usr/include/stdint.h"
typedef long long intmax_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 47 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 59 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 61
struct hash_table;
#line 63 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.h"
typedef struct hash_table Hash_table;
#line 49 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 55 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 111 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_list.h"
struct gl_list_impl;
#line 113 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_list.h"
typedef struct gl_list_impl *gl_list_t;
#line 115
struct gl_list_node_impl;
#line 119 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_list.h"
typedef struct gl_list_node_impl *gl_list_node_t;
#line 121
struct gl_list_implementation;
#line 123 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_list.h"
typedef struct gl_list_implementation  const  *gl_list_implementation_t;
#line 268 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_list.h"
struct __anonstruct_gl_list_iterator_t_1 {
   struct gl_list_implementation  const  *vtable ;
   gl_list_t list ;
   size_t count ;
   void *p ;
   void *q ;
   size_t i ;
   size_t j ;
};
#line 268 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_list.h"
typedef struct __anonstruct_gl_list_iterator_t_1 gl_list_iterator_t;
#line 375 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_list.h"
struct gl_list_implementation {
   gl_list_t (*create_empty)(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                          void const   *elt2 ) ,
                             size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                             _Bool allow_duplicates ) ;
   gl_list_t (*create)(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                    void const   *elt2 ) ,
                       size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                       _Bool allow_duplicates , size_t count , void const   **contents ) ;
   size_t (*size)(gl_list_t list ) ;
   void const   *(*node_value)(gl_list_t list , gl_list_node_t node ) ;
   void (*node_set_value)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*next_node)(gl_list_t list , gl_list_node_t node ) ;
   gl_list_node_t (*previous_node)(gl_list_t list , gl_list_node_t node ) ;
   void const   *(*get_at)(gl_list_t list , size_t position ) ;
   gl_list_node_t (*set_at)(gl_list_t list , size_t position , void const   *elt ) ;
   gl_list_node_t (*search_from_to)(gl_list_t list , size_t start_index , size_t end_index ,
                                    void const   *elt ) ;
   size_t (*indexof_from_to)(gl_list_t list , size_t start_index , size_t end_index ,
                             void const   *elt ) ;
   gl_list_node_t (*add_first)(gl_list_t list , void const   *elt ) ;
   gl_list_node_t (*add_last)(gl_list_t list , void const   *elt ) ;
   gl_list_node_t (*add_before)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*add_after)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*add_at)(gl_list_t list , size_t position , void const   *elt ) ;
   _Bool (*remove_node)(gl_list_t list , gl_list_node_t node ) ;
   _Bool (*remove_at)(gl_list_t list , size_t position ) ;
   _Bool (*remove_elt)(gl_list_t list , void const   *elt ) ;
   void (*list_free)(gl_list_t list ) ;
   gl_list_iterator_t (*iterator)(gl_list_t list ) ;
   gl_list_iterator_t (*iterator_from_to)(gl_list_t list , size_t start_index , size_t end_index ) ;
   _Bool (*iterator_next)(gl_list_iterator_t *iterator , void const   **eltp , gl_list_node_t *nodep ) ;
   void (*iterator_free)(gl_list_iterator_t *iterator ) ;
   gl_list_node_t (*sortedlist_search)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                      void const   *elt2 ) ,
                                       void const   *elt ) ;
   gl_list_node_t (*sortedlist_search_from_to)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                              void const   *elt2 ) ,
                                               size_t start_index , size_t end_index ,
                                               void const   *elt ) ;
   size_t (*sortedlist_indexof)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                               void const   *elt2 ) ,
                                void const   *elt ) ;
   size_t (*sortedlist_indexof_from_to)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                       void const   *elt2 ) ,
                                        size_t start_index , size_t end_index , void const   *elt ) ;
   gl_list_node_t (*sortedlist_add)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                   void const   *elt2 ) ,
                                    void const   *elt ) ;
   _Bool (*sortedlist_remove)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                             void const   *elt2 ) ,
                              void const   *elt ) ;
};
#line 444 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_list.h"
struct gl_list_impl_base {
   struct gl_list_implementation  const  *vtable ;
   _Bool (*equals_fn)(void const   *elt1 , void const   *elt2 ) ;
   size_t (*hashcode_fn)(void const   *elt ) ;
   void (*dispose_fn)(void const   *elt ) ;
   _Bool allow_duplicates ;
};
#line 25 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list1.h"
struct gl_list_node_impl {
   struct gl_list_node_impl *next ;
   struct gl_list_node_impl *prev ;
   void const   *value ;
};
#line 36 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list1.h"
struct gl_list_impl {
   struct gl_list_impl_base base ;
   struct gl_list_node_impl root ;
   size_t count ;
};
#line 184 "./getopt.h"
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 36 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt_int.h"
enum __anonenum___ordering_3 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 36 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __anonenum___ordering_3 __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 41 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 69 "/usr/include/errno.h"
typedef int error_t;
#line 80 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
struct argp_option {
   char const   *name ;
   int key ;
   char const   *arg ;
   int flags ;
   char const   *doc ;
   int group ;
};
#line 154
struct argp;
#line 155
struct argp_state;
#line 156
struct argp_child;
#line 228 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
struct argp {
   struct argp_option  const  *options ;
   error_t (*parser)(int key , char *arg , struct argp_state *state ) ;
   char const   *args_doc ;
   char const   *doc ;
   struct argp_child  const  *children ;
   char *(*help_filter)(int __key , char const   *__text , void *__input ) ;
   char const   *argp_domain ;
};
#line 296 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
struct argp_child {
   struct argp  const  *argp ;
   int flags ;
   char const   *header ;
   int group ;
};
#line 321 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
struct argp_state {
   struct argp  const  *root_argp ;
   int argc ;
   char **argv ;
   int next ;
   unsigned int flags ;
   unsigned int arg_num ;
   int quoted ;
   void *input ;
   void **child_inputs ;
   void *hook ;
   char *name ;
   FILE *err_stream ;
   FILE *out_stream ;
   void *pstate ;
};
#line 195 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
struct group {
   error_t (*parser)(int key , char *arg , struct argp_state *state ) ;
   struct argp  const  *argp ;
   char *short_end ;
   unsigned int args_processed ;
   struct group *parent ;
   unsigned int parent_index ;
   void *input ;
   void **child_inputs ;
   void *hook ;
};
#line 242 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
struct parser {
   struct argp  const  *argp ;
   char *short_opts ;
   struct rpl_option *long_opts ;
   struct _getopt_data opt_data ;
   struct group *groups ;
   struct group *egroup ;
   void **child_inputs ;
   int try_getopt ;
   struct argp_state state ;
   void *storage ;
};
#line 277 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
struct parser_convert_state {
   struct parser *parser ;
   char *short_end ;
   struct rpl_option *long_end ;
   void **child_inputs_end ;
};
#line 418 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
struct parser_sizes {
   size_t short_len ;
   size_t long_len ;
   size_t num_groups ;
   size_t num_child_inputs ;
};
#line 492 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
struct __anonstruct_33 {
   char c ;
   struct rpl_option x ;
};
#line 492 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
struct __anonstruct_35 {
   char c ;
   struct rpl_option x ;
};
#line 492 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
struct __anonstruct_37 {
   char c ;
   struct rpl_option x ;
};
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 94 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
struct argp_fmtstream {
   FILE *stream ;
   size_t lmargin ;
   size_t rmargin ;
   ssize_t wmargin ;
   size_t point_offs ;
   ssize_t point_col ;
   char *buf ;
   char *p ;
   char *end ;
};
#line 111 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
typedef struct argp_fmtstream *argp_fmtstream_t;
#line 79 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
struct uparams {
   int dup_args ;
   int dup_args_note ;
   int short_opt_col ;
   int long_opt_col ;
   int doc_opt_col ;
   int opt_doc_col ;
   int header_col ;
   int usage_indent ;
   int rmargin ;
   int valid ;
};
#line 113 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
struct uparam_name {
   char const   *name ;
   int is_bool ;
   size_t uparams_offs ;
};
#line 352
struct hol_cluster;
#line 354 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
struct hol_entry {
   struct argp_option  const  *opt ;
   unsigned int num ;
   char *short_options ;
   int group ;
   struct hol_cluster *cluster ;
   struct argp  const  *argp ;
   unsigned int ord ;
};
#line 385 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
struct hol_cluster {
   char const   *header ;
   int index ;
   int group ;
   struct hol_cluster *parent ;
   struct argp  const  *argp ;
   int depth ;
   struct hol_cluster *next ;
};
#line 415 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
struct hol {
   struct hol_entry *entries ;
   unsigned int num_entries ;
   char *short_options ;
   struct hol_cluster *clusters ;
};
#line 979 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
struct hol_help_state {
   struct hol_entry *prev_entry ;
   int sep_groups ;
   int suppressed_dup_arg ;
};
#line 996 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
struct pentry_state {
   struct hol_entry  const  *entry ;
   argp_fmtstream_t stream ;
   struct hol_help_state *hhstate ;
   int first ;
   struct argp_state  const  *state ;
};
#line 17 "./wordsplit.h"
struct wordsplit {
   size_t ws_wordc ;
   char **ws_wordv ;
   size_t ws_offs ;
   size_t ws_wordn ;
   int ws_flags ;
   char const   *ws_delim ;
   char const   *ws_comment ;
   char const   *ws_input ;
   size_t ws_len ;
   size_t ws_endp ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 50 "/usr/include/sys/types.h"
typedef __ino_t ino_t;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 24 "./grecs.h"
struct __anonstruct_grecs_locus_t_31 {
   char *file ;
   int line ;
};
#line 24 "./grecs.h"
typedef struct __anonstruct_grecs_locus_t_31 grecs_locus_t;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 48 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
struct input_file_ident {
   ino_t i_node ;
   dev_t device ;
};
#line 54 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
struct buffer_ctx {
   struct buffer_ctx *prev ;
   grecs_locus_t locus ;
   size_t namelen ;
   size_t xlines ;
   struct input_file_ident id ;
   FILE *infile ;
};
#line 247 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
struct file_data {
   char const   *name ;
   size_t namelen ;
   char *buf ;
   size_t buflen ;
   int found ;
};
#line 869 "/usr/include/stdio.h"
struct obstack;
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 76 "lex.yy_grecs.c"
typedef int16_t flex_int16_t;
#line 78 "lex.yy_grecs.c"
typedef int32_t flex_int32_t;
#line 201
struct yy_grecs_buffer_state;
#line 201 "lex.yy_grecs.c"
typedef struct yy_grecs_buffer_state *YY_BUFFER_STATE;
#line 238 "lex.yy_grecs.c"
typedef size_t yy_grecs_size_t;
#line 243 "lex.yy_grecs.c"
struct yy_grecs_buffer_state {
   FILE *yy_grecs_input_file ;
   char *yy_grecs_ch_buf ;
   char *yy_grecs_buf_pos ;
   yy_grecs_size_t yy_grecs_buf_size ;
   int yy_grecs_n_chars ;
   int yy_grecs_is_our_buffer ;
   int yy_grecs_is_interactive ;
   int yy_grecs_at_bol ;
   int yy_grecs_bs_lineno ;
   int yy_grecs_bs_column ;
   int yy_grecs_fill_buffer ;
   int yy_grecs_buffer_status ;
};
#line 416 "lex.yy_grecs.c"
typedef unsigned char YY_CHAR;
#line 420 "lex.yy_grecs.c"
typedef int yy_grecs_state_type;
#line 31 "./grecs.h"
enum grecs_data_type {
    grecs_type_void = 0,
    grecs_type_string = 1,
    grecs_type_short = 2,
    grecs_type_ushort = 3,
    grecs_type_int = 4,
    grecs_type_uint = 5,
    grecs_type_long = 6,
    grecs_type_ulong = 7,
    grecs_type_size = 8,
    grecs_type_uintmax = 9,
    grecs_type_intmax = 10,
    grecs_type_time = 11,
    grecs_type_bool = 12,
    grecs_type_ipv4 = 13,
    grecs_type_cidr = 14,
    grecs_type_host = 15,
    grecs_type_sockaddr = 16,
    grecs_type_section = 17
} ;
#line 58
enum grecs_callback_command {
    grecs_callback_section_begin = 0,
    grecs_callback_section_end = 1,
    grecs_callback_set_value = 2
} ;
#line 68 "./grecs.h"
struct __anonstruct_arg_34 {
   size_t c ;
   struct grecs_value *v ;
};
#line 68 "./grecs.h"
union __anonunion_v_33 {
   gl_list_t list ;
   char const   *string ;
   struct __anonstruct_arg_34 arg ;
};
#line 68 "./grecs.h"
struct grecs_value {
   int type ;
   union __anonunion_v_33 v ;
};
#line 68 "./grecs.h"
typedef struct grecs_value grecs_value_t;
#line 88 "./grecs.h"
struct grecs_keyword {
   char const   *ident ;
   char const   *argname ;
   char const   *docstring ;
   enum grecs_data_type type ;
   void *varptr ;
   size_t offset ;
   int (*callback)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
                   void * ) ;
   void *callback_data ;
   struct grecs_keyword *kwd ;
};
#line 58 "./grecs-gram.h"
union YYSTYPE {
   char *string ;
   grecs_value_t value ;
   gl_list_t list ;
   struct grecs_keyword *kw ;
};
#line 58 "./grecs-gram.h"
typedef union YYSTYPE YYSTYPE;
#line 144 "../../gnu/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 151 "../../gnu/obstack.h"
union __anonunion_temp_36 {
   int tempint ;
   void *tempptr ;
};
#line 151 "../../gnu/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_36 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 100 "./grecs.h"
struct sockaddr;
#line 100 "./grecs.h"
struct grecs_sockaddr {
   int len ;
   struct sockaddr *sa ;
};
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 92 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 92
struct sockaddr_un;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 203 "grecs-gram.c"
typedef unsigned char yy_grecstype_uint8;
#line 210 "grecs-gram.c"
typedef signed char yy_grecstype_int8;
#line 224 "grecs-gram.c"
typedef short yy_grecstype_int16;
#line 355 "grecs-gram.c"
union yy_grecsalloc {
   yy_grecstype_int16 yy_grecsss ;
   YYSTYPE yy_grecsvs ;
};
#line 712 "grecs-gram.y"
struct grecs_prop {
   size_t size ;
   _Bool (*eqfn)(void const   *elt1 , void const   *elt2 ) ;
};
#line 50 "/home/ysko/Works/test-src/pies-1.2/lib/libpies.h"
struct tokendef {
   char *name ;
   int tok ;
};
#line 28 "/home/ysko/Works/test-src/pies-1.2/lib/parsetime.c"
struct timetab {
   char *name ;
   unsigned int mul ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/grp.h"
struct group___0 {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 116 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
struct pies_privs {
   char *user ;
   int allgroups ;
   gl_list_t groups ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 159 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
struct pies_url;
#line 278 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
struct pies_url {
   char *string ;
   char *scheme ;
   char *host ;
   char *port_s ;
   int port ;
   char *proto_s ;
   int proto ;
   char *path ;
   char *user ;
   char *passwd ;
   int argc ;
   char **argv ;
};
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 35 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 245 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 263 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 43 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
union __anonunion_addr_69 {
   struct sockaddr sa ;
   struct sockaddr_in s_in ;
   struct sockaddr_un s_un ;
};
#line 285
enum __anonenum_state_70 {
    fds_init = 0,
    fds_open = 1,
    fds_connected = 2,
    fds_ready = 3
} ;
#line 18 "/home/ysko/Works/test-src/pies-1.2/src/acl.h"
struct pies_acl;
#line 18 "/home/ysko/Works/test-src/pies-1.2/src/acl.h"
typedef struct pies_acl *pies_acl_t;
#line 20 "/home/ysko/Works/test-src/pies-1.2/src/acl.h"
struct acl_input {
   struct sockaddr *addr ;
   socklen_t addrlen ;
   char const   *user ;
   char const   **groups ;
};
#line 75 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
enum redir_type {
    redir_null = 0,
    redir_syslog = 1,
    redir_file = 2
} ;
#line 82 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
union __anonunion_v_68 {
   int prio ;
   char *file ;
};
#line 82 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
struct redirector {
   enum redir_type type ;
   union __anonunion_v_68 v ;
};
#line 92
struct limits_rec;
#line 92 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
typedef struct limits_rec *limits_record_t;
#line 94
enum return_action {
    action_restart = 0,
    action_disable = 1
} ;
#line 103 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
struct action {
   struct action *next ;
   size_t nstat ;
   unsigned int *status ;
   enum return_action act ;
   char *addr ;
   char *message ;
   char *command ;
};
#line 123
enum pies_comp_mode {
    pies_comp_exec = 0,
    pies_comp_accept = 1,
    pies_comp_inetd = 2,
    pies_comp_pass_fd = 3
} ;
#line 159
struct inetd_builtin;
#line 159 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
struct component {
   enum pies_comp_mode mode ;
   char *tag ;
   char *program ;
   size_t argc ;
   char **argv ;
   char **env ;
   char *dir ;
   gl_list_t prereq ;
   gl_list_t depend ;
   int flags ;
   size_t max_instances ;
   char *rmfile ;
   struct pies_privs privs ;
   mode_t umask ;
   limits_record_t limits ;
   size_t max_rate ;
   int socket_type ;
   struct inetd_builtin *builtin ;
   char *service ;
   struct pies_url *socket_url ;
   char *pass_fd_socket ;
   unsigned int pass_fd_timeout ;
   pies_acl_t acl ;
   char *tcpmux ;
   int facility ;
   struct redirector redir[2] ;
   struct action *act_head ;
   struct action *act_tail ;
   struct action act_temp ;
};
#line 200 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
union pies_sockaddr_storage {
   struct sockaddr s ;
   struct sockaddr_in s_in ;
   struct sockaddr_un s_un ;
};
#line 248
struct pies_depmap;
#line 248 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
typedef struct pies_depmap *pies_depmap_t;
#line 249
struct pies_depmap_pos;
#line 249 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
typedef struct pies_depmap_pos *pies_depmap_pos_t;
#line 250
enum pies_depmap_direction {
    depmap_row = 0,
    depmap_col = 1
} ;
#line 348 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
struct metadef {
   char *kw ;
   char *value ;
   char const   *(*expand)(struct metadef * , void * ) ;
   char *storage ;
   void *data ;
};
#line 378 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
struct inetd_builtin {
   char const   *service ;
   int socktype ;
   int single_process ;
   int flags ;
   void (*fun)(int  , struct component  const  * ) ;
};
#line 19 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
enum prog_type {
    TYPE_COMPONENT = 0,
    TYPE_REDIRECTOR = 1,
    TYPE_COMMAND = 2
} ;
#line 26
enum prog_status {
    status_enabled = 0,
    status_disabled = 1,
    status_listener = 2,
    status_sleeping = 3,
    status_stopping = 4
} ;
#line 37 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
struct __anonstruct_p_70 {
   struct component *comp ;
   size_t idx ;
   int socket ;
   struct prog *redir[2] ;
   time_t timestamp ;
   size_t failcount ;
   enum prog_status status ;
   size_t num_instances ;
   struct prog *listener ;
   union pies_sockaddr_storage sa_storage ;
   size_t sa_len ;
};
#line 37 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
struct __anonstruct_r_71 {
   struct prog *master ;
};
#line 37 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
struct __anonstruct_c_72 {
   char *command ;
};
#line 37 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_v_69 {
   struct __anonstruct_p_70 p ;
   struct __anonstruct_r_71 r ;
   struct __anonstruct_c_72 c ;
};
#line 37 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
struct prog {
   struct prog *next ;
   struct prog *prev ;
   enum prog_type type ;
   pid_t pid ;
   char *tag ;
   char **prereq ;
   int facility ;
   union __anonunion_v_69 v ;
};
#line 1719 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 1715 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 1728 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_75 {
   int __in ;
   int __i ;
};
#line 1733 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 1739 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_77 {
   int __in ;
   int __i ;
};
#line 1744 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_78 {
   int __in ;
   int __i ;
};
#line 1738 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 1724 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 1713 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 1771 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 1776 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 1775 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 1769 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_85 {
   int __in ;
   int __i ;
};
#line 1978 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_86 {
   int __in ;
   int __i ;
};
#line 1984 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_87 {
   int __in ;
   int __i ;
};
#line 1980 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_88 {
   int __in ;
   int __i ;
};
#line 1974 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_89 {
   int __in ;
   int __i ;
};
#line 2070 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_90 {
   int __in ;
   int __i ;
};
#line 2075 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_91 {
   int __in ;
   int __i ;
};
#line 2073 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_92 {
   int __in ;
   int __i ;
};
#line 2068 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
union __anonunion_93 {
   int __in ;
   int __i ;
};
#line 51 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
enum config_syntax {
    CONF_PIES = 0,
    CONF_META1 = 1,
    CONF_INETD = 2
} ;
#line 58 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct config_file {
   struct config_file *next ;
   enum config_syntax syntax ;
   char *name ;
};
#line 67 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct config_syntax_descr {
   char const   *name ;
   enum config_syntax type ;
};
#line 1873
enum pies_status {
    pies_status_ctr = 0,
    pies_status_stale = 1,
    pies_status_noresp = 2,
    pies_status_running = 3
} ;
#line 239 "meta1lex.c"
struct yy_buffer_state;
#line 458 "meta1lex.c"
typedef int yy_state_type;
#line 56 "/home/ysko/Works/test-src/pies-1.2/src/meta1gram.h"
struct meta1_stmt;
#line 56 "/home/ysko/Works/test-src/pies-1.2/src/meta1gram.h"
union YYSTYPE___0 {
   char *string ;
   gl_list_t list ;
   grecs_value_t *value ;
   struct meta1_stmt *stmt ;
};
#line 56 "/home/ysko/Works/test-src/pies-1.2/src/meta1gram.h"
typedef union YYSTYPE___0 YYSTYPE___0;
#line 28 "meta1gram.y"
enum meta1_stmt_type {
    meta1_simple = 0,
    meta1_block = 1
} ;
#line 34 "meta1gram.y"
union __anonunion_v_69___0 {
   grecs_value_t *value ;
   struct meta1_stmt *list ;
};
#line 34 "meta1gram.y"
struct meta1_stmt {
   struct meta1_stmt *next ;
   grecs_locus_t locus ;
   enum meta1_stmt_type type ;
   char const   *ident ;
   union __anonunion_v_69___0 v ;
};
#line 228 "meta1gram.c"
typedef unsigned char yytype_uint8;
#line 235 "meta1gram.c"
typedef signed char yytype_int8;
#line 249 "meta1gram.c"
typedef short yytype_int16;
#line 380 "meta1gram.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE___0 yyvs ;
};
#line 250 "meta1gram.y"
struct node_trans {
   char *name ;
   char *new_name ;
   int (*xlat)(struct meta1_stmt *stmt , struct component *comp ) ;
};
#line 146 "/usr/include/bits/types.h"
typedef unsigned long __rlim_t;
#line 148 "/usr/include/bits/types.h"
typedef unsigned int __id_t;
#line 105 "/usr/include/sys/types.h"
typedef __id_t id_t;
#line 33 "/usr/include/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_NLIMITS = 15,
    __RLIM_NLIMITS = 15
} ;
#line 127 "/usr/include/bits/resource.h"
typedef __rlim_t rlim_t;
#line 135 "/usr/include/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 226
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 39 "/usr/include/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 41 "/usr/include/sys/resource.h"
typedef enum __priority_which __priority_which_t;
#line 32 "/home/ysko/Works/test-src/pies-1.2/src/limits.c"
struct limits_rec {
   unsigned int set ;
   rlim_t limit_as ;
   rlim_t limit_cpu ;
   rlim_t limit_data ;
   rlim_t limit_fsize ;
   rlim_t limit_nproc ;
   rlim_t limit_core ;
   rlim_t limit_memlock ;
   rlim_t limit_nofile ;
   rlim_t limit_rss ;
   rlim_t limit_stack ;
   int limit_logins ;
   int limit_prio ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 82 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
struct pies_depmap {
   size_t nrows ;
   size_t rowlen ;
   unsigned int r[1] ;
};
#line 134 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
struct pies_depmap_pos {
   enum pies_depmap_direction dir ;
   size_t coord[2] ;
};
#line 30 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
struct pies_sockaddr {
   unsigned int netmask ;
   int salen ;
   struct sockaddr sa ;
};
#line 37 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
struct acl_entry {
   grecs_locus_t locus ;
   int allow ;
   int authenticated ;
   pies_acl_t acl ;
   gl_list_t groups ;
   gl_list_t sockaddrs ;
};
#line 47 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
struct pies_acl {
   char *name ;
   grecs_locus_t locus ;
   gl_list_t list ;
};
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 51 "/home/ysko/Works/test-src/pies-1.2/gnu/xvasprintf.h"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 376 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 55 "/home/ysko/Works/test-src/pies-1.2/gnu/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 57
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 121
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 122
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 122 "/home/ysko/Works/test-src/pies-1.2/gnu/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 125
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 125
    tmp = -1;
  } else {
#line 125
    tmp = -2;
  }
#line 125
  if ((size_t )tmp / s < n) {
    {
#line 126
    xalloc_die();
    }
  }
  {
#line 127
  tmp___0 = xmalloc(n * s);
  }
#line 127
  return (tmp___0);
}
}
#line 54 "/home/ysko/Works/test-src/pies-1.2/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 60
  sum = size1 + size2;
#line 61
  if (sum >= size1) {
#line 61
    tmp = sum;
  } else {
#line 61
    tmp = 4294967295U;
  }
#line 61
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 34 "/home/ysko/Works/test-src/pies-1.2/gnu/xvasprintf.c"
__inline static char *xstrcat(size_t argcount , va_list args ) 
{ 
  char *result ;
  va_list ap ;
  size_t totalsize ;
  size_t i ;
  char *p ;
  char const   *next ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *next___0 ;
  char const   *tmp___8 ;
  size_t len ;
  size_t tmp___9 ;

  {
  {
#line 44
  totalsize = (size_t )0;
#line 45
  __builtin_va_copy(ap, args);
#line 46
  i = argcount;
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i > 0U)) {
#line 46
      goto while_break;
    }
    {
#line 48
    tmp___0 = __builtin_va_arg(ap, char const   *);
#line 48
    next = tmp___0;
#line 49
    tmp___1 = strlen(next);
#line 49
    tmp___2 = xsum(totalsize, tmp___1);
#line 49
    totalsize = (size_t )tmp___2;
#line 46
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  __builtin_va_end(ap);
  }
#line 56
  if (totalsize == 4294967295U) {
    {
#line 58
    tmp___3 = __errno_location();
#line 58
    *tmp___3 = 75;
    }
#line 59
    return ((char *)((void *)0));
  } else
#line 56
  if (totalsize > 2147483647U) {
    {
#line 58
    tmp___3 = __errno_location();
#line 58
    *tmp___3 = 75;
    }
#line 59
    return ((char *)((void *)0));
  }
#line 63
  if (sizeof(char ) == 1UL) {
    {
#line 63
    tmp___4 = xmalloc(totalsize + 1U);
#line 63
    tmp___6 = tmp___4;
    }
  } else {
    {
#line 63
    tmp___5 = xnmalloc(totalsize + 1U, (size_t )sizeof(char ));
#line 63
    tmp___6 = tmp___5;
    }
  }
#line 63
  result = (char *)tmp___6;
#line 64
  p = result;
#line 65
  i = argcount;
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 65
    if (! (i > 0U)) {
#line 65
      goto while_break___0;
    }
    {
#line 67
    tmp___8 = __builtin_va_arg(args, char const   *);
#line 67
    next___0 = tmp___8;
#line 68
    tmp___9 = strlen(next___0);
#line 68
    len = tmp___9;
#line 69
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)next___0,
           len);
#line 70
    p += len;
#line 65
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 72
  *p = (char )'\000';
#line 74
  return (result);
}
}
#line 77 "/home/ysko/Works/test-src/pies-1.2/gnu/xvasprintf.c"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args ) 
{ 
  char *result ;
  size_t argcount ;
  char const   *f ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 86
  argcount = (size_t )0;
#line 89
  f = format;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if ((int const   )*f == 0) {
      {
#line 93
      tmp = xstrcat(argcount, args);
      }
#line 93
      return (tmp);
    }
#line 94
    if ((int const   )*f != 37) {
#line 95
      goto while_break;
    }
#line 96
    f ++;
#line 97
    if ((int const   )*f != 115) {
#line 98
      goto while_break;
    }
#line 99
    f ++;
#line 100
    argcount ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  tmp___1 = vasprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)format,
                      args);
  }
#line 104
  if (tmp___1 < 0) {
    {
#line 106
    tmp___0 = __errno_location();
    }
#line 106
    if (*tmp___0 == 12) {
      {
#line 107
      xalloc_die();
      }
    }
#line 108
    return ((char *)((void *)0));
  }
#line 111
  return (result);
}
}
#line 58 "/home/ysko/Works/test-src/pies-1.2/gnu/xalloc.h"
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 59
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 60
void *xrealloc(void *p , size_t n ) ;
#line 61
void *x2realloc(void *p , size_t *pn ) ;
#line 62
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 63
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 196 "/home/ysko/Works/test-src/pies-1.2/gnu/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 199
  n = *pn;
#line 201
  if (! p) {
#line 203
    if (! n) {
#line 211
      n = 64U / s;
#line 212
      n += (size_t )(! n);
    }
  } else {
#line 221
    if (2863311530U / s <= n) {
      {
#line 222
      xalloc_die();
      }
    }
#line 223
    n += (n + 1U) / 2U;
  }
  {
#line 226
  *pn = n;
#line 227
  tmp = xrealloc(p, n * s);
  }
#line 227
  return (tmp);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 44 "/home/ysko/Works/test-src/pies-1.2/gnu/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 44 "/home/ysko/Works/test-src/pies-1.2/gnu/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 47
  tmp = malloc(n);
#line 47
  p = tmp;
  }
#line 48
  if (! p) {
#line 48
    if (n != 0U) {
      {
#line 49
      xalloc_die();
      }
    }
  }
#line 50
  return (p);
}
}
#line 56 "/home/ysko/Works/test-src/pies-1.2/gnu/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
  {
#line 59
  p = realloc(p, n);
  }
#line 60
  if (! p) {
#line 60
    if (n != 0U) {
      {
#line 61
      xalloc_die();
      }
    }
  }
#line 62
  return (p);
}
}
#line 71 "/home/ysko/Works/test-src/pies-1.2/gnu/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 74
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 74
  return (tmp);
}
}
#line 81
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 81 "/home/ysko/Works/test-src/pies-1.2/gnu/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 84
  tmp = xmalloc(s);
#line 84
  tmp___0 = memset(tmp, 0, s);
  }
#line 84
  return (tmp___0);
}
}
#line 90
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 90 "/home/ysko/Works/test-src/pies-1.2/gnu/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 98
  p = calloc(n, s);
  }
#line 98
  if (! p) {
    {
#line 100
    xalloc_die();
    }
  }
#line 101
  return (p);
}
}
#line 108
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 108 "/home/ysko/Works/test-src/pies-1.2/gnu/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 111
  tmp = xmalloc(s);
#line 111
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 111
  return (tmp___0);
}
}
#line 116
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 116 "/home/ysko/Works/test-src/pies-1.2/gnu/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 119
  tmp = strlen(string);
#line 119
  tmp___0 = xmemdup((void const   *)string, tmp + 1U);
  }
#line 119
  return ((char *)tmp___0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 49 "/home/ysko/Works/test-src/pies-1.2/gnu/xvasprintf.h"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) ;
#line 24 "/home/ysko/Works/test-src/pies-1.2/gnu/xasprintf.c"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 30
  __builtin_va_start(args, format);
#line 31
  result = xvasprintf(format, args);
#line 32
  __builtin_va_end(args);
  }
#line 34
  return (result);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 76 "/home/ysko/Works/test-src/pies-1.2/gnu/vasnprintf.h"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) ;
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 513
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 152 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 176 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 75 "/home/ysko/Works/test-src/pies-1.2/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 81
  tmp = xsum(size1, size2);
#line 81
  tmp___0 = xsum((size_t )tmp, size3);
#line 81
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
#line 81
  return (tmp___1);
}
}
#line 85 "/home/ysko/Works/test-src/pies-1.2/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 93
  if (size1 >= size2) {
#line 93
    tmp = size1;
  } else {
#line 93
    tmp = size2;
  }
#line 93
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 1479 "/home/ysko/Works/test-src/pies-1.2/gnu/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  arg_type type ;
  int flags ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  size_t n___0 ;
  char const   *mp ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  size_t n___1 ;
  char const   *mp___0 ;
  char *tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___32 ;
  size_t __attribute__((__pure__))  tmp___33 ;
  size_t __attribute__((__pure__))  tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  size_t __attribute__((__pure__))  tmp___37 ;
  int count ;
  int retcount ;
  size_t maxlen ;
  int arg___0 ;
  unsigned int arg___1 ;
  int arg___2 ;
  unsigned int arg___3 ;
  int arg___4 ;
  unsigned int arg___5 ;
  long arg___6 ;
  unsigned long arg___7 ;
  long long arg___8 ;
  unsigned long long arg___9 ;
  double arg___10 ;
  long double arg___11 ;
  int arg___12 ;
  wint_t arg___13 ;
  char const   *arg___14 ;
  wchar_t const   *arg___15 ;
  void *arg___16 ;
  size_t bigger_need ;
  size_t tmp___38 ;
  size_t __attribute__((__pure__))  tmp___39 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  int *tmp___43 ;
  size_t n___2 ;
  size_t tmp___44 ;
  size_t __attribute__((__pure__))  tmp___45 ;
  size_t __attribute__((__pure__))  tmp___46 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___50 ;
  size_t __attribute__((__pure__))  tmp___51 ;
  size_t __attribute__((__pure__))  tmp___52 ;
  void *tmp___53 ;
  void *tmp___54 ;
  size_t __attribute__((__pure__))  tmp___55 ;
  char *memory___5 ;
  void *tmp___56 ;
  int *tmp___57 ;
  int *tmp___58 ;
  void *__cil_tmp124 ;
  void *__cil_tmp125 ;
  void *__cil_tmp126 ;

  {
  {
#line 1486
  tmp = printf_parse(format, & d, & a);
  }
#line 1486
  if (tmp < 0) {
#line 1488
    return ((char *)((void *)0));
  }
  {
#line 1495
  tmp___1 = printf_fetchargs(args, & a);
  }
#line 1495
  if (tmp___1 < 0) {
    {
#line 1497
    free((void *)d.dir);
    }
#line 1497
    if (a.arg) {
      {
#line 1497
      free((void *)a.arg);
      }
    }
    {
#line 1498
    tmp___0 = __errno_location();
#line 1498
    *tmp___0 = 22;
    }
#line 1499
    return ((char *)((void *)0));
  }
  {
#line 1516
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1516
  buf_neededlength = (size_t )tmp___2;
  }
#line 1519
  if ((unsigned long )buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1521
    tmp___3 = __builtin_alloca((unsigned long )buf_neededlength * sizeof(char ));
#line 1521
    buf = (char *)tmp___3;
#line 1522
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1527
    if ((unsigned long )buf_neededlength <= 4294967295UL / sizeof(char )) {
#line 1527
      tmp___4 = (unsigned long )buf_neededlength * sizeof(char );
    } else {
#line 1527
      tmp___4 = 4294967295UL;
    }
#line 1527
    buf_memsize = (size_t )tmp___4;
#line 1528
    if (buf_memsize == 4294967295U) {
#line 1529
      goto out_of_memory_1;
    }
    {
#line 1530
    tmp___5 = malloc(buf_memsize);
#line 1530
    buf = (char *)tmp___5;
    }
#line 1531
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1532
      goto out_of_memory_1;
    }
#line 1533
    buf_malloced = buf;
  }
#line 1536
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1538
    result = resultbuf;
#line 1539
    allocated = *lengthp;
  } else {
#line 1543
    result = (char *)((void *)0);
#line 1544
    allocated = (size_t )0;
  }
#line 1546
  length = (size_t )0;
#line 1576
  cp = format;
#line 1576
  i = (size_t )0;
#line 1576
  dp = d.dir + 0;
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1578
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
#line 1580
      n = (size_t )(dp->dir_start - cp);
#line 1581
      tmp___6 = xsum(length, n);
#line 1581
      augmented_length = (size_t )tmp___6;
      }
#line 1583
      if (augmented_length > allocated) {
#line 1583
        if (allocated > 0U) {
#line 1583
          if (allocated <= 2147483647U) {
#line 1583
            tmp___7 = allocated * 2U;
          } else {
#line 1583
            tmp___7 = 4294967295U;
          }
#line 1583
          allocated = tmp___7;
        } else {
#line 1583
          allocated = (size_t )12;
        }
#line 1583
        if (augmented_length > allocated) {
#line 1583
          allocated = augmented_length;
        }
#line 1583
        if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 1583
          memory_size = (size_t )((unsigned long )allocated * sizeof(char ));
        } else {
#line 1583
          memory_size = 4294967295U;
        }
#line 1583
        if (memory_size == 4294967295U) {
#line 1583
          goto out_of_memory;
        }
#line 1583
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1583
          tmp___8 = malloc(memory_size);
#line 1583
          memory = (char *)tmp___8;
          }
        } else
#line 1583
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1583
          tmp___8 = malloc(memory_size);
#line 1583
          memory = (char *)tmp___8;
          }
        } else {
          {
#line 1583
          tmp___9 = realloc((void *)result, memory_size);
#line 1583
          memory = (char *)tmp___9;
          }
        }
#line 1583
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1583
          goto out_of_memory;
        }
#line 1583
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1583
          if (length > 0U) {
            {
#line 1583
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1583
        result = memory;
      }
#line 1587
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1589
        memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)cp,
               n);
#line 1590
        length = augmented_length;
        }
      } else {
        {
#line 1594
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1595
          tmp___10 = length;
#line 1595
          length ++;
#line 1595
          tmp___11 = cp;
#line 1595
          cp ++;
#line 1595
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
#line 1594
          n --;
#line 1594
          if (! (n > 0U)) {
#line 1594
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1599
    if (i == d.count) {
#line 1600
      goto while_break;
    }
#line 1603
    if ((int )dp->conversion == 37) {
#line 1607
      if (! (dp->arg_index == 4294967295U)) {
        {
#line 1608
        abort();
        }
      }
      {
#line 1609
      tmp___12 = xsum(length, (size_t )1);
#line 1609
      augmented_length___0 = (size_t )tmp___12;
      }
#line 1610
      if (augmented_length___0 > allocated) {
#line 1610
        if (allocated > 0U) {
#line 1610
          if (allocated <= 2147483647U) {
#line 1610
            tmp___13 = allocated * 2U;
          } else {
#line 1610
            tmp___13 = 4294967295U;
          }
#line 1610
          allocated = tmp___13;
        } else {
#line 1610
          allocated = (size_t )12;
        }
#line 1610
        if (augmented_length___0 > allocated) {
#line 1610
          allocated = augmented_length___0;
        }
#line 1610
        if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 1610
          memory_size___0 = (size_t )((unsigned long )allocated * sizeof(char ));
        } else {
#line 1610
          memory_size___0 = 4294967295U;
        }
#line 1610
        if (memory_size___0 == 4294967295U) {
#line 1610
          goto out_of_memory;
        }
#line 1610
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1610
          tmp___14 = malloc(memory_size___0);
#line 1610
          memory___0 = (char *)tmp___14;
          }
        } else
#line 1610
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1610
          tmp___14 = malloc(memory_size___0);
#line 1610
          memory___0 = (char *)tmp___14;
          }
        } else {
          {
#line 1610
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1610
          memory___0 = (char *)tmp___15;
          }
        }
#line 1610
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1610
          goto out_of_memory;
        }
#line 1610
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1610
          if (length > 0U) {
            {
#line 1610
            memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1610
        result = memory___0;
      }
#line 1611
      *(result + length) = (char )'%';
#line 1612
      length = augmented_length___0;
    } else {
#line 1616
      if (! (dp->arg_index != 4294967295U)) {
        {
#line 1617
        abort();
        }
      }
#line 1619
      if ((int )dp->conversion == 110) {
        {
#line 1623
        if ((unsigned int )(a.arg + dp->arg_index)->type == 18U) {
#line 1623
          goto case_18;
        }
#line 1626
        if ((unsigned int )(a.arg + dp->arg_index)->type == 19U) {
#line 1626
          goto case_19;
        }
#line 1629
        if ((unsigned int )(a.arg + dp->arg_index)->type == 20U) {
#line 1629
          goto case_20;
        }
#line 1632
        if ((unsigned int )(a.arg + dp->arg_index)->type == 21U) {
#line 1632
          goto case_21;
        }
#line 1636
        if ((unsigned int )(a.arg + dp->arg_index)->type == 22U) {
#line 1636
          goto case_22;
        }
#line 1640
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1624
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1625
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1627
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1628
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1630
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1631
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1633
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1634
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1637
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1638
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1641
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 4304
        type = (a.arg + dp->arg_index)->type;
#line 4305
        flags = dp->flags;
#line 4701
        fbp = buf;
#line 4702
        tmp___16 = fbp;
#line 4702
        fbp ++;
#line 4702
        *tmp___16 = (char )'%';
#line 4708
        if (flags & 1) {
#line 4709
          tmp___17 = fbp;
#line 4709
          fbp ++;
#line 4709
          *tmp___17 = (char )'\'';
        }
#line 4711
        if (flags & 2) {
#line 4712
          tmp___18 = fbp;
#line 4712
          fbp ++;
#line 4712
          *tmp___18 = (char )'-';
        }
#line 4713
        if (flags & 4) {
#line 4714
          tmp___19 = fbp;
#line 4714
          fbp ++;
#line 4714
          *tmp___19 = (char )'+';
        }
#line 4715
        if (flags & 8) {
#line 4716
          tmp___20 = fbp;
#line 4716
          fbp ++;
#line 4716
          *tmp___20 = (char )' ';
        }
#line 4717
        if (flags & 16) {
#line 4718
          tmp___21 = fbp;
#line 4718
          fbp ++;
#line 4718
          *tmp___21 = (char )'#';
        }
#line 4721
        if (flags & 32) {
#line 4722
          tmp___22 = fbp;
#line 4722
          fbp ++;
#line 4722
          *tmp___22 = (char )'0';
        }
#line 4723
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4725
          n___0 = (size_t )(dp->width_end - dp->width_start);
#line 4728
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4730
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->width_start,
                   (size_t )((unsigned long )n___0 * sizeof(char )));
#line 4731
            fbp += n___0;
            }
          } else {
#line 4735
            mp = dp->width_start;
            {
#line 4736
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4737
              tmp___23 = fbp;
#line 4737
              fbp ++;
#line 4737
              tmp___24 = mp;
#line 4737
              mp ++;
#line 4737
              *tmp___23 = (char )((unsigned char )*tmp___24);
#line 4736
              n___0 --;
#line 4736
              if (! (n___0 > 0U)) {
#line 4736
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 4744
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4746
          n___1 = (size_t )(dp->precision_end - dp->precision_start);
#line 4749
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4751
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->precision_start,
                   (size_t )((unsigned long )n___1 * sizeof(char )));
#line 4752
            fbp += n___1;
            }
          } else {
#line 4756
            mp___0 = dp->precision_start;
            {
#line 4757
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 4758
              tmp___25 = fbp;
#line 4758
              fbp ++;
#line 4758
              tmp___26 = mp___0;
#line 4758
              mp___0 ++;
#line 4758
              *tmp___25 = (char )((unsigned char )*tmp___26);
#line 4757
              n___1 --;
#line 4757
              if (! (n___1 > 0U)) {
#line 4757
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        {
#line 4768
        if ((unsigned int )type == 10U) {
#line 4768
          goto case_10;
        }
#line 4768
        if ((unsigned int )type == 9U) {
#line 4768
          goto case_10;
        }
#line 4785
        if ((unsigned int )type == 16U) {
#line 4785
          goto case_16;
        }
#line 4785
        if ((unsigned int )type == 14U) {
#line 4785
          goto case_16;
        }
#line 4785
        if ((unsigned int )type == 8U) {
#line 4785
          goto case_16;
        }
#line 4785
        if ((unsigned int )type == 7U) {
#line 4785
          goto case_16;
        }
#line 4789
        if ((unsigned int )type == 12U) {
#line 4789
          goto case_12;
        }
#line 4792
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4775
        tmp___27 = fbp;
#line 4775
        fbp ++;
#line 4775
        *tmp___27 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4787
        tmp___28 = fbp;
#line 4787
        fbp ++;
#line 4787
        *tmp___28 = (char )'l';
#line 4788
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4790
        tmp___29 = fbp;
#line 4790
        fbp ++;
#line 4790
        *tmp___29 = (char )'L';
#line 4791
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4793
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4800
        *fbp = dp->conversion;
#line 4830
        *(fbp + 1) = (char )'\000';
#line 4837
        prefix_count = 0U;
#line 4838
        if (dp->width_arg_index != 4294967295U) {
#line 4840
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4841
            abort();
            }
          }
#line 4842
          tmp___30 = prefix_count;
#line 4842
          prefix_count ++;
#line 4842
          prefixes[tmp___30] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4844
        if (dp->precision_arg_index != 4294967295U) {
#line 4846
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4847
            abort();
            }
          }
#line 4848
          tmp___31 = prefix_count;
#line 4848
          prefix_count ++;
#line 4848
          prefixes[tmp___31] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4860
        tmp___37 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
        }
#line 4860
        if (tmp___37 > (size_t __attribute__((__pure__))  )allocated) {
#line 4860
          if (allocated > 0U) {
#line 4860
            if (allocated <= 2147483647U) {
#line 4860
              tmp___32 = allocated * 2U;
            } else {
#line 4860
              tmp___32 = 4294967295U;
            }
#line 4860
            allocated = tmp___32;
          } else {
#line 4860
            allocated = (size_t )12;
          }
          {
#line 4860
          tmp___34 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
          }
#line 4860
          if (tmp___34 > (size_t __attribute__((__pure__))  )allocated) {
            {
#line 4860
            tmp___33 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
#line 4860
            allocated = (size_t )tmp___33;
            }
          }
#line 4860
          if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 4860
            memory_size___1 = (size_t )((unsigned long )allocated * sizeof(char ));
          } else {
#line 4860
            memory_size___1 = 4294967295U;
          }
#line 4860
          if (memory_size___1 == 4294967295U) {
#line 4860
            goto out_of_memory;
          }
#line 4860
          if ((unsigned long )result == (unsigned long )resultbuf) {
            {
#line 4860
            tmp___35 = malloc(memory_size___1);
#line 4860
            memory___1 = (char *)tmp___35;
            }
          } else
#line 4860
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 4860
            tmp___35 = malloc(memory_size___1);
#line 4860
            memory___1 = (char *)tmp___35;
            }
          } else {
            {
#line 4860
            tmp___36 = realloc((void *)result, memory_size___1);
#line 4860
            memory___1 = (char *)tmp___36;
            }
          }
#line 4860
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4860
            goto out_of_memory;
          }
#line 4860
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4860
            if (length > 0U) {
              {
#line 4860
              memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)result,
                     length);
              }
            }
          }
#line 4860
          result = memory___1;
        }
#line 4865
        *(result + length) = (char )'\000';
        {
#line 4868
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4870
          count = -1;
#line 4873
          retcount = 0;
#line 4874
          maxlen = allocated - length;
#line 4877
          if ((unsigned long )maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4878
            maxlen = (size_t )(2147483647UL / (sizeof(char ) / sizeof(char )));
          }
#line 4879
          maxlen = (size_t )((unsigned long )maxlen * (sizeof(char ) / sizeof(char )));
          {
#line 4923
          if ((unsigned int )type == 1U) {
#line 4923
            goto case_1;
          }
#line 4929
          if ((unsigned int )type == 2U) {
#line 4929
            goto case_2___0;
          }
#line 4935
          if ((unsigned int )type == 3U) {
#line 4935
            goto case_3;
          }
#line 4941
          if ((unsigned int )type == 4U) {
#line 4941
            goto case_4;
          }
#line 4947
          if ((unsigned int )type == 5U) {
#line 4947
            goto case_5;
          }
#line 4953
          if ((unsigned int )type == 6U) {
#line 4953
            goto case_6;
          }
#line 4959
          if ((unsigned int )type == 7U) {
#line 4959
            goto case_7___0;
          }
#line 4965
          if ((unsigned int )type == 8U) {
#line 4965
            goto case_8___0;
          }
#line 4972
          if ((unsigned int )type == 9U) {
#line 4972
            goto case_9___0;
          }
#line 4978
          if ((unsigned int )type == 10U) {
#line 4978
            goto case_10___0;
          }
#line 4985
          if ((unsigned int )type == 11U) {
#line 4985
            goto case_11;
          }
#line 4991
          if ((unsigned int )type == 12U) {
#line 4991
            goto case_12___0;
          }
#line 4997
          if ((unsigned int )type == 13U) {
#line 4997
            goto case_13;
          }
#line 5004
          if ((unsigned int )type == 14U) {
#line 5004
            goto case_14___0;
          }
#line 5011
          if ((unsigned int )type == 15U) {
#line 5011
            goto case_15;
          }
#line 5018
          if ((unsigned int )type == 16U) {
#line 5018
            goto case_16___0;
          }
#line 5025
          if ((unsigned int )type == 17U) {
#line 5025
            goto case_17;
          }
#line 5031
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 4925
          arg___0 = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 4926
          if (prefix_count == 0U) {
#line 4926
            goto case_0;
          }
#line 4926
          if (prefix_count == 1U) {
#line 4926
            goto case_1___0;
          }
#line 4926
          if (prefix_count == 2U) {
#line 4926
            goto case_2;
          }
#line 4926
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 4926
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___0, & count);
          }
#line 4926
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 4926
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___0,
                              & count);
          }
#line 4926
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 4926
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___0, & count);
          }
#line 4926
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 4926
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }
#line 4928
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 4931
          arg___1 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 4932
          if (prefix_count == 0U) {
#line 4932
            goto case_0___0;
          }
#line 4932
          if (prefix_count == 1U) {
#line 4932
            goto case_1___1;
          }
#line 4932
          if (prefix_count == 2U) {
#line 4932
            goto case_2___1;
          }
#line 4932
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 4932
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___1, & count);
          }
#line 4932
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 4932
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___1,
                              & count);
          }
#line 4932
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 4932
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___1, & count);
          }
#line 4932
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 4932
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }
#line 4934
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 4937
          arg___2 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 4938
          if (prefix_count == 0U) {
#line 4938
            goto case_0___1;
          }
#line 4938
          if (prefix_count == 1U) {
#line 4938
            goto case_1___2;
          }
#line 4938
          if (prefix_count == 2U) {
#line 4938
            goto case_2___2;
          }
#line 4938
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 4938
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___2, & count);
          }
#line 4938
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 4938
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___2,
                              & count);
          }
#line 4938
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 4938
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___2, & count);
          }
#line 4938
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 4938
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }
#line 4940
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 4943
          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 4944
          if (prefix_count == 0U) {
#line 4944
            goto case_0___2;
          }
#line 4944
          if (prefix_count == 1U) {
#line 4944
            goto case_1___3;
          }
#line 4944
          if (prefix_count == 2U) {
#line 4944
            goto case_2___3;
          }
#line 4944
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 4944
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___3, & count);
          }
#line 4944
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 4944
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___3,
                              & count);
          }
#line 4944
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 4944
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___3, & count);
          }
#line 4944
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 4944
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }
#line 4946
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 4949
          arg___4 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 4950
          if (prefix_count == 0U) {
#line 4950
            goto case_0___3;
          }
#line 4950
          if (prefix_count == 1U) {
#line 4950
            goto case_1___4;
          }
#line 4950
          if (prefix_count == 2U) {
#line 4950
            goto case_2___4;
          }
#line 4950
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 4950
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___4, & count);
          }
#line 4950
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 4950
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___4,
                              & count);
          }
#line 4950
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 4950
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___4, & count);
          }
#line 4950
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 4950
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }
#line 4952
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 4955
          arg___5 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 4956
          if (prefix_count == 0U) {
#line 4956
            goto case_0___4;
          }
#line 4956
          if (prefix_count == 1U) {
#line 4956
            goto case_1___5;
          }
#line 4956
          if (prefix_count == 2U) {
#line 4956
            goto case_2___5;
          }
#line 4956
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 4956
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___5, & count);
          }
#line 4956
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 4956
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___5,
                              & count);
          }
#line 4956
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 4956
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___5, & count);
          }
#line 4956
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 4956
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }
#line 4958
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 4961
          arg___6 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 4962
          if (prefix_count == 0U) {
#line 4962
            goto case_0___5;
          }
#line 4962
          if (prefix_count == 1U) {
#line 4962
            goto case_1___6;
          }
#line 4962
          if (prefix_count == 2U) {
#line 4962
            goto case_2___6;
          }
#line 4962
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 4962
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___6, & count);
          }
#line 4962
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 4962
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___6,
                              & count);
          }
#line 4962
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 4962
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___6, & count);
          }
#line 4962
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 4962
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }
#line 4964
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 4967
          arg___7 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 4968
          if (prefix_count == 0U) {
#line 4968
            goto case_0___6;
          }
#line 4968
          if (prefix_count == 1U) {
#line 4968
            goto case_1___7;
          }
#line 4968
          if (prefix_count == 2U) {
#line 4968
            goto case_2___7;
          }
#line 4968
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 4968
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___7, & count);
          }
#line 4968
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 4968
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___7,
                              & count);
          }
#line 4968
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 4968
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___7, & count);
          }
#line 4968
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 4968
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }
#line 4970
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 4974
          arg___8 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 4975
          if (prefix_count == 0U) {
#line 4975
            goto case_0___7;
          }
#line 4975
          if (prefix_count == 1U) {
#line 4975
            goto case_1___8;
          }
#line 4975
          if (prefix_count == 2U) {
#line 4975
            goto case_2___8;
          }
#line 4975
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 4975
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___8, & count);
          }
#line 4975
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 4975
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___8,
                              & count);
          }
#line 4975
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 4975
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___8, & count);
          }
#line 4975
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 4975
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }
#line 4977
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 4980
          arg___9 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 4981
          if (prefix_count == 0U) {
#line 4981
            goto case_0___8;
          }
#line 4981
          if (prefix_count == 1U) {
#line 4981
            goto case_1___9;
          }
#line 4981
          if (prefix_count == 2U) {
#line 4981
            goto case_2___9;
          }
#line 4981
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 4981
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___9, & count);
          }
#line 4981
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 4981
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___9,
                              & count);
          }
#line 4981
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 4981
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___9, & count);
          }
#line 4981
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 4981
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }
#line 4983
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 4987
          arg___10 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 4988
          if (prefix_count == 0U) {
#line 4988
            goto case_0___9;
          }
#line 4988
          if (prefix_count == 1U) {
#line 4988
            goto case_1___10;
          }
#line 4988
          if (prefix_count == 2U) {
#line 4988
            goto case_2___10;
          }
#line 4988
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 4988
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___10, & count);
          }
#line 4988
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 4988
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___10,
                              & count);
          }
#line 4988
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 4988
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___10, & count);
          }
#line 4988
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 4988
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }
#line 4990
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 4993
          arg___11 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 4994
          if (prefix_count == 0U) {
#line 4994
            goto case_0___10;
          }
#line 4994
          if (prefix_count == 1U) {
#line 4994
            goto case_1___11;
          }
#line 4994
          if (prefix_count == 2U) {
#line 4994
            goto case_2___11;
          }
#line 4994
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 4994
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___11, & count);
          }
#line 4994
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 4994
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___11,
                              & count);
          }
#line 4994
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 4994
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___11, & count);
          }
#line 4994
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 4994
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }
#line 4996
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 4999
          arg___12 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5000
          if (prefix_count == 0U) {
#line 5000
            goto case_0___11;
          }
#line 5000
          if (prefix_count == 1U) {
#line 5000
            goto case_1___12;
          }
#line 5000
          if (prefix_count == 2U) {
#line 5000
            goto case_2___12;
          }
#line 5000
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5000
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___12, & count);
          }
#line 5000
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5000
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___12,
                              & count);
          }
#line 5000
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5000
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___12, & count);
          }
#line 5000
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5000
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }
#line 5002
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5006
          arg___13 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5007
          if (prefix_count == 0U) {
#line 5007
            goto case_0___12;
          }
#line 5007
          if (prefix_count == 1U) {
#line 5007
            goto case_1___13;
          }
#line 5007
          if (prefix_count == 2U) {
#line 5007
            goto case_2___13;
          }
#line 5007
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___13, & count);
          }
#line 5007
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___13,
                              & count);
          }
#line 5007
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___13, & count);
          }
#line 5007
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5007
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }
#line 5009
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5013
          arg___14 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5014
          if (prefix_count == 0U) {
#line 5014
            goto case_0___13;
          }
#line 5014
          if (prefix_count == 1U) {
#line 5014
            goto case_1___14;
          }
#line 5014
          if (prefix_count == 2U) {
#line 5014
            goto case_2___14;
          }
#line 5014
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5014
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___14, & count);
          }
#line 5014
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5014
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___14,
                              & count);
          }
#line 5014
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5014
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___14, & count);
          }
#line 5014
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5014
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }
#line 5016
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5020
          arg___15 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5021
          if (prefix_count == 0U) {
#line 5021
            goto case_0___14;
          }
#line 5021
          if (prefix_count == 1U) {
#line 5021
            goto case_1___15;
          }
#line 5021
          if (prefix_count == 2U) {
#line 5021
            goto case_2___15;
          }
#line 5021
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5021
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___15, & count);
          }
#line 5021
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5021
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___15,
                              & count);
          }
#line 5021
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5021
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___15, & count);
          }
#line 5021
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5021
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }
#line 5023
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5027
          arg___16 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5028
          if (prefix_count == 0U) {
#line 5028
            goto case_0___15;
          }
#line 5028
          if (prefix_count == 1U) {
#line 5028
            goto case_1___16;
          }
#line 5028
          if (prefix_count == 2U) {
#line 5028
            goto case_2___16;
          }
#line 5028
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5028
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___16, & count);
          }
#line 5028
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5028
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___16,
                              & count);
          }
#line 5028
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5028
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___16, & count);
          }
#line 5028
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5028
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }
#line 5030
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5032
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5040
          if (count >= 0) {
#line 5044
            if ((size_t )count < maxlen) {
#line 5044
              if ((int )*((result + length) + count) != 0) {
                {
#line 5046
                abort();
                }
              }
            }
#line 5048
            if (retcount > count) {
#line 5049
              count = retcount;
            }
          } else
#line 5055
          if ((int )*(fbp + 1) != 0) {
#line 5059
            *(fbp + 1) = (char )'\000';
#line 5060
            goto __Cont;
          } else
#line 5065
          if (retcount < 0) {
#line 5072
            if (allocated <= 2147483647U) {
#line 5072
              tmp___38 = allocated * 2U;
            } else {
#line 5072
              tmp___38 = 4294967295U;
            }
            {
#line 5072
            tmp___39 = xsum(tmp___38, (size_t )12);
#line 5072
            bigger_need = (size_t )tmp___39;
            }
#line 5074
            if (bigger_need > allocated) {
#line 5074
              if (allocated > 0U) {
#line 5074
                if (allocated <= 2147483647U) {
#line 5074
                  tmp___40 = allocated * 2U;
                } else {
#line 5074
                  tmp___40 = 4294967295U;
                }
#line 5074
                allocated = tmp___40;
              } else {
#line 5074
                allocated = (size_t )12;
              }
#line 5074
              if (bigger_need > allocated) {
#line 5074
                allocated = bigger_need;
              }
#line 5074
              if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5074
                memory_size___2 = (size_t )((unsigned long )allocated * sizeof(char ));
              } else {
#line 5074
                memory_size___2 = 4294967295U;
              }
#line 5074
              if (memory_size___2 == 4294967295U) {
#line 5074
                goto out_of_memory;
              }
#line 5074
              if ((unsigned long )result == (unsigned long )resultbuf) {
                {
#line 5074
                tmp___41 = malloc(memory_size___2);
#line 5074
                memory___2 = (char *)tmp___41;
                }
              } else
#line 5074
              if ((unsigned long )result == (unsigned long )((void *)0)) {
                {
#line 5074
                tmp___41 = malloc(memory_size___2);
#line 5074
                memory___2 = (char *)tmp___41;
                }
              } else {
                {
#line 5074
                tmp___42 = realloc((void *)result, memory_size___2);
#line 5074
                memory___2 = (char *)tmp___42;
                }
              }
#line 5074
              if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 5074
                goto out_of_memory;
              }
#line 5074
              if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5074
                if (length > 0U) {
                  {
#line 5074
                  memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)result,
                         length);
                  }
                }
              }
#line 5074
              result = memory___2;
            }
#line 5075
            goto __Cont;
          } else {
#line 5078
            count = retcount;
          }
#line 5084
          if (count < 0) {
#line 5086
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5086
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                {
#line 5087
                free((void *)result);
                }
              }
            }
#line 5088
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              {
#line 5089
              free((void *)buf_malloced);
              }
            }
            {
#line 5090
            free((void *)d.dir);
            }
#line 5090
            if (a.arg) {
              {
#line 5090
              free((void *)a.arg);
              }
            }
            {
#line 5091
            tmp___43 = __errno_location();
#line 5091
            *tmp___43 = 22;
            }
#line 5092
            return ((char *)((void *)0));
          }
#line 5101
          if ((unsigned int )count + 1U >= maxlen) {
#line 5106
            if ((unsigned long )maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5107
              goto overflow;
            } else {
#line 5119
              if (allocated <= 2147483647U) {
#line 5119
                tmp___44 = allocated * 2U;
              } else {
#line 5119
                tmp___44 = 4294967295U;
              }
              {
#line 5119
              tmp___45 = xsum(length, (size_t )((((unsigned long )((unsigned int )count + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
#line 5119
              tmp___46 = xmax((size_t )tmp___45, tmp___44);
#line 5119
              n___2 = (size_t )tmp___46;
              }
#line 5126
              if (n___2 > allocated) {
#line 5126
                if (allocated > 0U) {
#line 5126
                  if (allocated <= 2147483647U) {
#line 5126
                    tmp___47 = allocated * 2U;
                  } else {
#line 5126
                    tmp___47 = 4294967295U;
                  }
#line 5126
                  allocated = tmp___47;
                } else {
#line 5126
                  allocated = (size_t )12;
                }
#line 5126
                if (n___2 > allocated) {
#line 5126
                  allocated = n___2;
                }
#line 5126
                if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5126
                  memory_size___3 = (size_t )((unsigned long )allocated * sizeof(char ));
                } else {
#line 5126
                  memory_size___3 = 4294967295U;
                }
#line 5126
                if (memory_size___3 == 4294967295U) {
#line 5126
                  goto out_of_memory;
                }
#line 5126
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 5126
                  tmp___48 = malloc(memory_size___3);
#line 5126
                  memory___3 = (char *)tmp___48;
                  }
                } else
#line 5126
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 5126
                  tmp___48 = malloc(memory_size___3);
#line 5126
                  memory___3 = (char *)tmp___48;
                  }
                } else {
                  {
#line 5126
                  tmp___49 = realloc((void *)result, memory_size___3);
#line 5126
                  memory___3 = (char *)tmp___49;
                  }
                }
#line 5126
                if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5126
                  goto out_of_memory;
                }
#line 5126
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5126
                  if (length > 0U) {
                    {
#line 5126
                    memcpy((void */* __restrict  */)memory___3, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 5126
                result = memory___3;
              }
#line 5127
              goto __Cont;
            }
          }
#line 5424
          length += (size_t )count;
#line 5425
          goto while_break___3;
          __Cont: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 1576
    cp = dp->dir_end;
#line 1576
    i ++;
#line 1576
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5432
  tmp___55 = xsum(length, (size_t )1);
  }
#line 5432
  if (tmp___55 > (size_t __attribute__((__pure__))  )allocated) {
#line 5432
    if (allocated > 0U) {
#line 5432
      if (allocated <= 2147483647U) {
#line 5432
        tmp___50 = allocated * 2U;
      } else {
#line 5432
        tmp___50 = 4294967295U;
      }
#line 5432
      allocated = tmp___50;
    } else {
#line 5432
      allocated = (size_t )12;
    }
    {
#line 5432
    tmp___52 = xsum(length, (size_t )1);
    }
#line 5432
    if (tmp___52 > (size_t __attribute__((__pure__))  )allocated) {
      {
#line 5432
      tmp___51 = xsum(length, (size_t )1);
#line 5432
      allocated = (size_t )tmp___51;
      }
    }
#line 5432
    if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5432
      memory_size___4 = (size_t )((unsigned long )allocated * sizeof(char ));
    } else {
#line 5432
      memory_size___4 = 4294967295U;
    }
#line 5432
    if (memory_size___4 == 4294967295U) {
#line 5432
      goto out_of_memory;
    }
#line 5432
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
#line 5432
      tmp___53 = malloc(memory_size___4);
#line 5432
      memory___4 = (char *)tmp___53;
      }
    } else
#line 5432
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 5432
      tmp___53 = malloc(memory_size___4);
#line 5432
      memory___4 = (char *)tmp___53;
      }
    } else {
      {
#line 5432
      tmp___54 = realloc((void *)result, memory_size___4);
#line 5432
      memory___4 = (char *)tmp___54;
      }
    }
#line 5432
    if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
#line 5432
      goto out_of_memory;
    }
#line 5432
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5432
      if (length > 0U) {
        {
#line 5432
        memcpy((void */* __restrict  */)memory___4, (void const   */* __restrict  */)result,
               length);
        }
      }
    }
#line 5432
    result = memory___4;
  }
#line 5433
  *(result + length) = (char )'\000';
#line 5435
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5435
    if (length + 1U < allocated) {
      {
#line 5440
      tmp___56 = realloc((void *)result, (size_t )((unsigned long )(length + 1U) * sizeof(char )));
#line 5440
      memory___5 = (char *)tmp___56;
      }
#line 5441
      if ((unsigned long )memory___5 != (unsigned long )((void *)0)) {
#line 5442
        result = memory___5;
      }
    }
  }
#line 5445
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5446
    free((void *)buf_malloced);
    }
  }
  {
#line 5447
  free((void *)d.dir);
  }
#line 5447
  if (a.arg) {
    {
#line 5447
    free((void *)a.arg);
    }
  }
#line 5448
  *lengthp = length;
#line 5453
  return (result);
  overflow: 
#line 5457
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5457
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5458
      free((void *)result);
      }
    }
  }
#line 5459
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5460
    free((void *)buf_malloced);
    }
  }
  {
#line 5461
  free((void *)d.dir);
  }
#line 5461
  if (a.arg) {
    {
#line 5461
    free((void *)a.arg);
    }
  }
  {
#line 5462
  tmp___57 = __errno_location();
#line 5462
  *tmp___57 = 75;
  }
#line 5463
  return ((char *)((void *)0));
  out_of_memory: 
#line 5467
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5467
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5468
      free((void *)result);
      }
    }
  }
#line 5469
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5470
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
  {
#line 5472
  free((void *)d.dir);
  }
#line 5472
  if (a.arg) {
    {
#line 5472
    free((void *)a.arg);
    }
  }
  {
#line 5473
  tmp___58 = __errno_location();
#line 5473
  *tmp___58 = 12;
  }
#line 5474
  return ((char *)((void *)0));
}
}
#line 47 "/home/ysko/Works/test-src/pies-1.2/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf ) ;
#line 31 "/home/ysko/Works/test-src/pies-1.2/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf ) 
{ 
  char *p ;

  {
#line 34
  p = buf + (((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL);
#line 35
  *p = (char)0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    p --;
#line 51
    *p = (char )(48ULL + i % 10ULL);
#line 50
    i /= 10ULL;
#line 50
    if (! (i != 0ULL)) {
#line 50
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (p);
}
}
#line 48 "/home/ysko/Works/test-src/pies-1.2/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf ) ;
#line 31 "/home/ysko/Works/test-src/pies-1.2/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf ) 
{ 
  char *p ;

  {
#line 34
  p = buf + (((sizeof(unsigned int ) * 8UL) * 146UL) / 485UL + 1UL);
#line 35
  *p = (char)0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    p --;
#line 51
    *p = (char )(48U + i % 10U);
#line 50
    i /= 10U;
#line 50
    if (! (i != 0U)) {
#line 50
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (p);
}
}
#line 69 "/home/ysko/Works/test-src/pies-1.2/gnu/dirname.h"
size_t base_len(char const   *name ) ;
#line 71
char *last_component(char const   *name ) ;
#line 73
_Bool strip_trailing_slashes(char *file ) ;
#line 31 "/home/ysko/Works/test-src/pies-1.2/gnu/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 34
  tmp = last_component((char const   *)file);
#line 34
  base = tmp;
  }
#line 40
  if (! *base) {
#line 41
    base = file;
  }
  {
#line 42
  tmp___0 = base_len((char const   *)base);
#line 42
  base_lim = base + tmp___0;
#line 43
  had_slash = (_Bool )((int )*base_lim != 0);
#line 44
  *base_lim = (char )'\000';
  }
#line 45
  return (had_slash);
}
}
#line 193 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 199
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 31 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.h"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  tolower(int __c ) ;
#line 119
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  toupper(int __c ) ;
#line 318 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    tmp___0 = len;
#line 322
    len --;
#line 322
    if (! (tmp___0 > 0U)) {
#line 322
      goto while_break;
    }
    {
#line 323
    tmp = (int )tolower((int )((unsigned char )*(src + len)));
#line 323
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return (dest);
}
}
#line 327 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    tmp___0 = len;
#line 331
    len --;
#line 331
    if (! (tmp___0 > 0U)) {
#line 331
      goto while_break;
    }
    {
#line 332
    tmp = (int )toupper((int )((unsigned char )*(src + len)));
#line 332
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return (dest);
}
}
#line 374 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ 
  int big_enough_multiple_of_7 ;

  {
#line 380
  big_enough_multiple_of_7 = 378;
#line 381
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 422 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.c"
static size_t strftime_case_(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                             struct tm  const  *tp , int ut , int ns ) 
{ 
  int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  struct tm copy ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  int padding ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  int year ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;
  void *__cil_tmp122 ;
  void *__cil_tmp123 ;
  void *__cil_tmp124 ;
  void *__cil_tmp125 ;
  void *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;

  {
#line 435
  hour12 = (int )tp->tm_hour;
#line 460
  i = (size_t )0;
#line 461
  p = s;
#line 472
  copy = *tp;
#line 473
  tp = (struct tm  const  *)(& copy);
#line 476
  zone = (char const   *)((void *)0);
#line 484
  zone = (char const   *)tp->tm_zone;
#line 502
  if (hour12 > 12) {
#line 503
    hour12 -= 12;
  } else
#line 505
  if (hour12 == 0) {
#line 506
    hour12 = 12;
  }
#line 508
  f = format;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! ((int const   )*f != 0)) {
#line 508
      goto while_break;
    }
#line 510
    pad = 0;
#line 512
    digits = 0;
#line 526
    width = -1;
#line 527
    to_lowcase = (_Bool)0;
#line 528
    to_uppcase = upcase;
#line 530
    change_case = (_Bool)0;
#line 613
    if ((int const   )*f != 37) {
      {
#line 615
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 615
        _n = 1;
#line 615
        _delta = width - _n;
#line 615
        if (_delta > 0) {
#line 615
          tmp = _delta;
        } else {
#line 615
          tmp = 0;
        }
#line 615
        _incr = _n + tmp;
#line 615
        if ((size_t )_incr >= maxsize - i) {
#line 615
          return ((size_t )0);
        }
#line 615
        if (p) {
#line 615
          if (digits == 0) {
#line 615
            if (_delta > 0) {
#line 615
              if (pad == 48) {
                {
#line 615
                memset((void *)p, '0', (size_t )_delta);
#line 615
                p += _delta;
                }
              } else {
                {
#line 615
                memset((void *)p, ' ', (size_t )_delta);
#line 615
                p += _delta;
                }
              }
            }
          }
#line 615
          *p = (char )*f;
#line 615
          p += _n;
        }
#line 615
        i += (size_t )_incr;
#line 615
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 616
      goto __Cont;
    }
    {
#line 622
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 624
      f ++;
      {
#line 629
      if ((int const   )*f == 48) {
#line 629
        goto case_48;
      }
#line 629
      if ((int const   )*f == 45) {
#line 629
        goto case_48;
      }
#line 629
      if ((int const   )*f == 95) {
#line 629
        goto case_48;
      }
#line 634
      if ((int const   )*f == 94) {
#line 634
        goto case_94;
      }
#line 637
      if ((int const   )*f == 35) {
#line 637
        goto case_35;
      }
#line 641
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 630
      pad = (int )*f;
#line 631
      goto while_continue___1;
      case_94: /* CIL Label */ 
#line 635
      to_uppcase = (_Bool)1;
#line 636
      goto while_continue___1;
      case_35: /* CIL Label */ 
#line 638
      change_case = (_Bool)1;
#line 639
      goto while_continue___1;
      switch_default: /* CIL Label */ 
#line 642
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 644
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 648
    if ((unsigned int )*f - 48U <= 9U) {
#line 650
      width = 0;
      {
#line 651
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 653
        if (width > 214748364) {
#line 656
          width = 2147483647;
        } else
#line 653
        if (width == 214748364) {
#line 653
          if ((int const   )*f - 48 > 7) {
#line 656
            width = 2147483647;
          } else {
#line 659
            width *= 10;
#line 660
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 659
          width *= 10;
#line 660
          width += (int )((int const   )*f - 48);
        }
#line 662
        f ++;
#line 651
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 651
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 671
    if ((int const   )*f == 79) {
#line 671
      goto case_79;
    }
#line 671
    if ((int const   )*f == 69) {
#line 671
      goto case_79;
    }
#line 675
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 672
    tmp___0 = f;
#line 672
    f ++;
#line 672
    modifier = (int )*tmp___0;
#line 673
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 676
    modifier = 0;
#line 677
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 681
    format_char = (int )*f;
    {
#line 704
    if (format_char == 37) {
#line 704
      goto case_37;
    }
#line 710
    if (format_char == 97) {
#line 710
      goto case_97;
    }
#line 725
    if (format_char == 65) {
#line 725
      goto case_65;
    }
#line 741
    if (format_char == 104) {
#line 741
      goto case_104;
    }
#line 741
    if (format_char == 98) {
#line 741
      goto case_104;
    }
#line 756
    if (format_char == 66) {
#line 756
      goto case_66;
    }
#line 771
    if (format_char == 99) {
#line 771
      goto case_99;
    }
#line 830
    if (format_char == 67) {
#line 830
      goto case_67;
    }
#line 859
    if (format_char == 120) {
#line 859
      goto case_120;
    }
#line 872
    if (format_char == 68) {
#line 872
      goto case_68;
    }
#line 878
    if (format_char == 100) {
#line 878
      goto case_100;
    }
#line 884
    if (format_char == 101) {
#line 884
      goto case_101;
    }
#line 1010
    if (format_char == 70) {
#line 1010
      goto case_70;
    }
#line 1016
    if (format_char == 72) {
#line 1016
      goto case_72;
    }
#line 1022
    if (format_char == 73) {
#line 1022
      goto case_73;
    }
#line 1028
    if (format_char == 107) {
#line 1028
      goto case_107;
    }
#line 1034
    if (format_char == 108) {
#line 1034
      goto case_108;
    }
#line 1040
    if (format_char == 106) {
#line 1040
      goto case_106;
    }
#line 1046
    if (format_char == 77) {
#line 1046
      goto case_77;
    }
#line 1052
    if (format_char == 109) {
#line 1052
      goto case_109;
    }
#line 1059
    if (format_char == 78) {
#line 1059
      goto case_78;
    }
#line 1077
    if (format_char == 110) {
#line 1077
      goto case_110;
    }
#line 1081
    if (format_char == 80) {
#line 1081
      goto case_80;
    }
#line 1088
    if (format_char == 112) {
#line 1088
      goto case_112;
    }
#line 1101
    if (format_char == 82) {
#line 1101
      goto case_82;
    }
#line 1105
    if (format_char == 114) {
#line 1105
      goto case_114;
    }
#line 1116
    if (format_char == 83) {
#line 1116
      goto case_83;
    }
#line 1122
    if (format_char == 115) {
#line 1122
      goto case_115;
    }
#line 1149
    if (format_char == 88) {
#line 1149
      goto case_88;
    }
#line 1162
    if (format_char == 84) {
#line 1162
      goto case_84;
    }
#line 1166
    if (format_char == 116) {
#line 1166
      goto case_116;
    }
#line 1170
    if (format_char == 117) {
#line 1170
      goto case_117;
    }
#line 1173
    if (format_char == 85) {
#line 1173
      goto case_85;
    }
#line 1181
    if (format_char == 71) {
#line 1181
      goto case_71;
    }
#line 1181
    if (format_char == 103) {
#line 1181
      goto case_71;
    }
#line 1181
    if (format_char == 86) {
#line 1181
      goto case_71;
    }
#line 1237
    if (format_char == 87) {
#line 1237
      goto case_87;
    }
#line 1243
    if (format_char == 119) {
#line 1243
      goto case_119;
    }
#line 1249
    if (format_char == 89) {
#line 1249
      goto case_89;
    }
#line 1273
    if (format_char == 121) {
#line 1273
      goto case_121;
    }
#line 1296
    if (format_char == 90) {
#line 1296
      goto case_90;
    }
#line 1325
    if (format_char == 58) {
#line 1325
      goto case_58;
    }
#line 1335
    if (format_char == 122) {
#line 1335
      goto case_122;
    }
#line 1413
    if (format_char == 0) {
#line 1413
      goto case_0___0;
    }
#line 1416
    goto bad_format;
    case_37: /* CIL Label */ 
#line 705
    if (modifier != 0) {
#line 706
      goto bad_format;
    }
    {
#line 707
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 707
      _n___0 = 1;
#line 707
      _delta___0 = width - _n___0;
#line 707
      if (_delta___0 > 0) {
#line 707
        tmp___1 = _delta___0;
      } else {
#line 707
        tmp___1 = 0;
      }
#line 707
      _incr___0 = _n___0 + tmp___1;
#line 707
      if ((size_t )_incr___0 >= maxsize - i) {
#line 707
        return ((size_t )0);
      }
#line 707
      if (p) {
#line 707
        if (digits == 0) {
#line 707
          if (_delta___0 > 0) {
#line 707
            if (pad == 48) {
              {
#line 707
              memset((void *)p, '0', (size_t )_delta___0);
#line 707
              p += _delta___0;
              }
            } else {
              {
#line 707
              memset((void *)p, ' ', (size_t )_delta___0);
#line 707
              p += _delta___0;
              }
            }
          }
        }
#line 707
        *p = (char )*f;
#line 707
        p += _n___0;
      }
#line 707
      i += (size_t )_incr___0;
#line 707
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 708
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 711
    if (modifier != 0) {
#line 712
      goto bad_format;
    }
#line 713
    if (change_case) {
#line 715
      to_uppcase = (_Bool)1;
#line 716
      to_lowcase = (_Bool)0;
    }
#line 722
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 726
    if (modifier != 0) {
#line 727
      goto bad_format;
    }
#line 728
    if (change_case) {
#line 730
      to_uppcase = (_Bool)1;
#line 731
      to_lowcase = (_Bool)0;
    }
#line 737
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 742
    if (change_case) {
#line 744
      to_uppcase = (_Bool)1;
#line 745
      to_lowcase = (_Bool)0;
    }
#line 747
    if (modifier != 0) {
#line 748
      goto bad_format;
    }
#line 753
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 757
    if (modifier != 0) {
#line 758
      goto bad_format;
    }
#line 759
    if (change_case) {
#line 761
      to_uppcase = (_Bool)1;
#line 762
      to_lowcase = (_Bool)0;
    }
#line 768
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 772
    if (modifier == 79) {
#line 773
      goto bad_format;
    }
#line 782
    goto underlying_strftime;
    subformat: 
    {
#line 787
    tmp___2 = strftime_case_(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                             tp, ut, ns);
#line 787
    len = tmp___2;
    }
    {
#line 791
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 791
      _n___1 = (int )len;
#line 791
      _delta___1 = width - _n___1;
#line 791
      if (_delta___1 > 0) {
#line 791
        tmp___3 = _delta___1;
      } else {
#line 791
        tmp___3 = 0;
      }
#line 791
      _incr___1 = _n___1 + tmp___3;
#line 791
      if ((size_t )_incr___1 >= maxsize - i) {
#line 791
        return ((size_t )0);
      }
#line 791
      if (p) {
#line 791
        if (digits == 0) {
#line 791
          if (_delta___1 > 0) {
#line 791
            if (pad == 48) {
              {
#line 791
              memset((void *)p, '0', (size_t )_delta___1);
#line 791
              p += _delta___1;
              }
            } else {
              {
#line 791
              memset((void *)p, ' ', (size_t )_delta___1);
#line 791
              p += _delta___1;
              }
            }
          }
        }
        {
#line 791
        strftime_case_(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
#line 791
        p += _n___1;
        }
      }
#line 791
      i += (size_t )_incr___1;
#line 791
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 796
    goto switch_break___1;
    underlying_strftime: 
#line 804
    u = ufmt;
#line 817
    tmp___4 = u;
#line 817
    u ++;
#line 817
    *tmp___4 = (char )' ';
#line 818
    tmp___5 = u;
#line 818
    u ++;
#line 818
    *tmp___5 = (char )'%';
#line 819
    if (modifier != 0) {
#line 820
      tmp___6 = u;
#line 820
      u ++;
#line 820
      *tmp___6 = (char )modifier;
    }
    {
#line 821
    tmp___7 = u;
#line 821
    u ++;
#line 821
    *tmp___7 = (char )format_char;
#line 822
    *u = (char )'\000';
#line 823
    len___0 = strftime((char */* __restrict  */)(ubuf), (size_t )sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 824
    if (len___0 != 0U) {
      {
#line 825
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 825
        _n___2 = (int )(len___0 - 1U);
#line 825
        _delta___2 = width - _n___2;
#line 825
        if (_delta___2 > 0) {
#line 825
          tmp___8 = _delta___2;
        } else {
#line 825
          tmp___8 = 0;
        }
#line 825
        _incr___2 = _n___2 + tmp___8;
#line 825
        if ((size_t )_incr___2 >= maxsize - i) {
#line 825
          return ((size_t )0);
        }
#line 825
        if (p) {
#line 825
          if (digits == 0) {
#line 825
            if (_delta___2 > 0) {
#line 825
              if (pad == 48) {
                {
#line 825
                memset((void *)p, '0', (size_t )_delta___2);
#line 825
                p += _delta___2;
                }
              } else {
                {
#line 825
                memset((void *)p, ' ', (size_t )_delta___2);
#line 825
                p += _delta___2;
                }
              }
            }
          }
#line 825
          if (to_lowcase) {
            {
#line 825
            memcpy_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else
#line 825
          if (to_uppcase) {
            {
#line 825
            memcpy_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else {
            {
#line 825
            memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(ubuf + 1)),
                   (size_t )_n___2);
            }
          }
#line 825
          p += _n___2;
        }
#line 825
        i += (size_t )_incr___2;
#line 825
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 827
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 831
    if (modifier == 79) {
#line 832
      goto bad_format;
    }
#line 833
    if (modifier == 69) {
#line 849
      goto underlying_strftime;
    }
#line 854
    century = (int )(tp->tm_year / 100 + 19);
#line 855
    if (tp->tm_year % 100 < 0) {
#line 855
      if (0 < century) {
#line 855
        tmp___9 = 1;
      } else {
#line 855
        tmp___9 = 0;
      }
    } else {
#line 855
      tmp___9 = 0;
    }
#line 855
    century -= tmp___9;
#line 856
    digits = 2;
#line 856
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 856
    u_number_value = (unsigned int )century;
#line 856
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 860
    if (modifier == 79) {
#line 861
      goto bad_format;
    }
#line 870
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 873
    if (modifier != 0) {
#line 874
      goto bad_format;
    }
#line 875
    subfmt = "%m/%d/%y";
#line 876
    goto subformat;
    case_100: /* CIL Label */ 
#line 879
    if (modifier == 69) {
#line 880
      goto bad_format;
    }
#line 882
    digits = 2;
#line 882
    number_value = (int )tp->tm_mday;
#line 882
    goto do_number;
    case_101: /* CIL Label */ 
#line 885
    if (modifier == 69) {
#line 886
      goto bad_format;
    }
#line 888
    digits = 2;
#line 888
    number_value = (int )tp->tm_mday;
#line 888
    goto do_number_spacepad;
    do_tz_offset: 
#line 894
    always_output_a_sign = (_Bool)1;
#line 895
    goto do_number_body;
    do_number_spacepad: 
#line 899
    if (pad != 48) {
#line 899
      if (pad != 45) {
#line 900
        pad = '_';
      }
    }
    do_number: 
#line 904
    negative_number = (_Bool )(number_value < 0);
#line 905
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 908
    always_output_a_sign = (_Bool)0;
#line 909
    tz_colon_mask = 0;
    do_number_body: 
#line 917
    if (modifier == 79) {
#line 917
      if (! negative_number) {
#line 935
        goto underlying_strftime;
      }
    }
#line 939
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 941
    if (negative_number) {
#line 942
      u_number_value = - u_number_value;
    }
    {
#line 944
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 946
      if (tz_colon_mask & 1) {
#line 947
        bufp --;
#line 947
        *bufp = (char )':';
      }
#line 948
      tz_colon_mask >>= 1;
#line 949
      bufp --;
#line 949
      *bufp = (char )(u_number_value % 10U + 48U);
#line 950
      u_number_value /= 10U;
#line 944
      if (! (u_number_value != 0U)) {
#line 944
        if (! (tz_colon_mask != 0)) {
#line 944
          goto while_break___6;
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 955
    if (digits < width) {
#line 956
      digits = width;
    }
#line 958
    if (negative_number) {
#line 958
      sign_char = (char )'-';
    } else {
#line 958
      if (always_output_a_sign) {
#line 958
        tmp___10 = '+';
      } else {
#line 958
        tmp___10 = 0;
      }
#line 958
      sign_char = (char )tmp___10;
    }
#line 962
    if (pad == 45) {
#line 964
      if (sign_char) {
        {
#line 965
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 965
          _n___3 = 1;
#line 965
          _delta___3 = width - _n___3;
#line 965
          if (_delta___3 > 0) {
#line 965
            tmp___11 = _delta___3;
          } else {
#line 965
            tmp___11 = 0;
          }
#line 965
          _incr___3 = _n___3 + tmp___11;
#line 965
          if ((size_t )_incr___3 >= maxsize - i) {
#line 965
            return ((size_t )0);
          }
#line 965
          if (p) {
#line 965
            if (digits == 0) {
#line 965
              if (_delta___3 > 0) {
#line 965
                if (pad == 48) {
                  {
#line 965
                  memset((void *)p, '0', (size_t )_delta___3);
#line 965
                  p += _delta___3;
                  }
                } else {
                  {
#line 965
                  memset((void *)p, ' ', (size_t )_delta___3);
#line 965
                  p += _delta___3;
                  }
                }
              }
            }
#line 965
            *p = sign_char;
#line 965
            p += _n___3;
          }
#line 965
          i += (size_t )_incr___3;
#line 965
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    } else {
#line 969
      padding = (int )(((long )digits - ((buf + sizeof(buf) / sizeof(buf[0])) - bufp)) - (long )(! (! sign_char)));
#line 972
      if (padding > 0) {
#line 974
        if (pad == 95) {
#line 976
          if ((size_t )padding >= maxsize - i) {
#line 977
            return ((size_t )0);
          }
#line 979
          if (p) {
            {
#line 980
            memset((void *)p, ' ', (size_t )padding);
#line 980
            p += padding;
            }
          }
#line 981
          i += (size_t )padding;
#line 982
          if (width > padding) {
#line 982
            width -= padding;
          } else {
#line 982
            width = 0;
          }
#line 983
          if (sign_char) {
            {
#line 984
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 984
              _n___4 = 1;
#line 984
              _delta___4 = width - _n___4;
#line 984
              if (_delta___4 > 0) {
#line 984
                tmp___12 = _delta___4;
              } else {
#line 984
                tmp___12 = 0;
              }
#line 984
              _incr___4 = _n___4 + tmp___12;
#line 984
              if ((size_t )_incr___4 >= maxsize - i) {
#line 984
                return ((size_t )0);
              }
#line 984
              if (p) {
#line 984
                if (digits == 0) {
#line 984
                  if (_delta___4 > 0) {
#line 984
                    if (pad == 48) {
                      {
#line 984
                      memset((void *)p, '0', (size_t )_delta___4);
#line 984
                      p += _delta___4;
                      }
                    } else {
                      {
#line 984
                      memset((void *)p, ' ', (size_t )_delta___4);
#line 984
                      p += _delta___4;
                      }
                    }
                  }
                }
#line 984
                *p = sign_char;
#line 984
                p += _n___4;
              }
#line 984
              i += (size_t )_incr___4;
#line 984
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        } else {
#line 988
          if ((size_t )digits >= maxsize - i) {
#line 989
            return ((size_t )0);
          }
#line 991
          if (sign_char) {
            {
#line 992
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 992
              _n___5 = 1;
#line 992
              _delta___5 = width - _n___5;
#line 992
              if (_delta___5 > 0) {
#line 992
                tmp___13 = _delta___5;
              } else {
#line 992
                tmp___13 = 0;
              }
#line 992
              _incr___5 = _n___5 + tmp___13;
#line 992
              if ((size_t )_incr___5 >= maxsize - i) {
#line 992
                return ((size_t )0);
              }
#line 992
              if (p) {
#line 992
                if (digits == 0) {
#line 992
                  if (_delta___5 > 0) {
#line 992
                    if (pad == 48) {
                      {
#line 992
                      memset((void *)p, '0', (size_t )_delta___5);
#line 992
                      p += _delta___5;
                      }
                    } else {
                      {
#line 992
                      memset((void *)p, ' ', (size_t )_delta___5);
#line 992
                      p += _delta___5;
                      }
                    }
                  }
                }
#line 992
                *p = sign_char;
#line 992
                p += _n___5;
              }
#line 992
              i += (size_t )_incr___5;
#line 992
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 994
          if (p) {
            {
#line 995
            memset((void *)p, '0', (size_t )padding);
#line 995
            p += padding;
            }
          }
#line 996
          i += (size_t )padding;
#line 997
          width = 0;
        }
      } else
#line 1002
      if (sign_char) {
        {
#line 1003
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1003
          _n___6 = 1;
#line 1003
          _delta___6 = width - _n___6;
#line 1003
          if (_delta___6 > 0) {
#line 1003
            tmp___14 = _delta___6;
          } else {
#line 1003
            tmp___14 = 0;
          }
#line 1003
          _incr___6 = _n___6 + tmp___14;
#line 1003
          if ((size_t )_incr___6 >= maxsize - i) {
#line 1003
            return ((size_t )0);
          }
#line 1003
          if (p) {
#line 1003
            if (digits == 0) {
#line 1003
              if (_delta___6 > 0) {
#line 1003
                if (pad == 48) {
                  {
#line 1003
                  memset((void *)p, '0', (size_t )_delta___6);
#line 1003
                  p += _delta___6;
                  }
                } else {
                  {
#line 1003
                  memset((void *)p, ' ', (size_t )_delta___6);
#line 1003
                  p += _delta___6;
                  }
                }
              }
            }
#line 1003
            *p = sign_char;
#line 1003
            p += _n___6;
          }
#line 1003
          i += (size_t )_incr___6;
#line 1003
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
    {
#line 1007
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1007
      _n___7 = (int )((buf + sizeof(buf) / sizeof(buf[0])) - bufp);
#line 1007
      _delta___7 = width - _n___7;
#line 1007
      if (_delta___7 > 0) {
#line 1007
        tmp___15 = _delta___7;
      } else {
#line 1007
        tmp___15 = 0;
      }
#line 1007
      _incr___7 = _n___7 + tmp___15;
#line 1007
      if ((size_t )_incr___7 >= maxsize - i) {
#line 1007
        return ((size_t )0);
      }
#line 1007
      if (p) {
#line 1007
        if (digits == 0) {
#line 1007
          if (_delta___7 > 0) {
#line 1007
            if (pad == 48) {
              {
#line 1007
              memset((void *)p, '0', (size_t )_delta___7);
#line 1007
              p += _delta___7;
              }
            } else {
              {
#line 1007
              memset((void *)p, ' ', (size_t )_delta___7);
#line 1007
              p += _delta___7;
              }
            }
          }
        }
#line 1007
        if (to_lowcase) {
          {
#line 1007
          memcpy_lowcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else
#line 1007
        if (to_uppcase) {
          {
#line 1007
          memcpy_uppcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else {
          {
#line 1007
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)bufp),
                 (size_t )_n___7);
          }
        }
#line 1007
        p += _n___7;
      }
#line 1007
      i += (size_t )_incr___7;
#line 1007
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1008
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 1011
    if (modifier != 0) {
#line 1012
      goto bad_format;
    }
#line 1013
    subfmt = "%Y-%m-%d";
#line 1014
    goto subformat;
    case_72: /* CIL Label */ 
#line 1017
    if (modifier == 69) {
#line 1018
      goto bad_format;
    }
#line 1020
    digits = 2;
#line 1020
    number_value = (int )tp->tm_hour;
#line 1020
    goto do_number;
    case_73: /* CIL Label */ 
#line 1023
    if (modifier == 69) {
#line 1024
      goto bad_format;
    }
#line 1026
    digits = 2;
#line 1026
    number_value = hour12;
#line 1026
    goto do_number;
    case_107: /* CIL Label */ 
#line 1029
    if (modifier == 69) {
#line 1030
      goto bad_format;
    }
#line 1032
    digits = 2;
#line 1032
    number_value = (int )tp->tm_hour;
#line 1032
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1035
    if (modifier == 69) {
#line 1036
      goto bad_format;
    }
#line 1038
    digits = 2;
#line 1038
    number_value = hour12;
#line 1038
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1041
    if (modifier == 69) {
#line 1042
      goto bad_format;
    }
#line 1044
    digits = 3;
#line 1044
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1044
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1044
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1047
    if (modifier == 69) {
#line 1048
      goto bad_format;
    }
#line 1050
    digits = 2;
#line 1050
    number_value = (int )tp->tm_min;
#line 1050
    goto do_number;
    case_109: /* CIL Label */ 
#line 1053
    if (modifier == 69) {
#line 1054
      goto bad_format;
    }
#line 1056
    digits = 2;
#line 1056
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1056
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1056
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1060
    if (modifier == 69) {
#line 1061
      goto bad_format;
    }
#line 1063
    number_value = ns;
#line 1064
    if (width == -1) {
#line 1065
      width = 9;
    } else {
#line 1070
      j = width;
      {
#line 1070
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1070
        if (! (j < 9)) {
#line 1070
          goto while_break___12;
        }
#line 1071
        number_value /= 10;
#line 1070
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1074
    digits = width;
#line 1074
    number_value = number_value;
#line 1074
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1078
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1078
      _n___8 = 1;
#line 1078
      _delta___8 = width - _n___8;
#line 1078
      if (_delta___8 > 0) {
#line 1078
        tmp___16 = _delta___8;
      } else {
#line 1078
        tmp___16 = 0;
      }
#line 1078
      _incr___8 = _n___8 + tmp___16;
#line 1078
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1078
        return ((size_t )0);
      }
#line 1078
      if (p) {
#line 1078
        if (digits == 0) {
#line 1078
          if (_delta___8 > 0) {
#line 1078
            if (pad == 48) {
              {
#line 1078
              memset((void *)p, '0', (size_t )_delta___8);
#line 1078
              p += _delta___8;
              }
            } else {
              {
#line 1078
              memset((void *)p, ' ', (size_t )_delta___8);
#line 1078
              p += _delta___8;
              }
            }
          }
        }
#line 1078
        *p = (char )'\n';
#line 1078
        p += _n___8;
      }
#line 1078
      i += (size_t )_incr___8;
#line 1078
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1079
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1082
    to_lowcase = (_Bool)1;
#line 1084
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1089
    if (change_case) {
#line 1091
      to_uppcase = (_Bool)0;
#line 1092
      to_lowcase = (_Bool)1;
    }
#line 1098
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1102
    subfmt = "%H:%M";
#line 1103
    goto subformat;
    case_114: /* CIL Label */ 
#line 1113
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1117
    if (modifier == 69) {
#line 1118
      goto bad_format;
    }
#line 1120
    digits = 2;
#line 1120
    number_value = (int )tp->tm_sec;
#line 1120
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1127
    ltm = (struct tm )*tp;
#line 1128
    t = mktime(& ltm);
#line 1133
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 1134
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1136
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1138
      d = (int )(t % 10L);
#line 1139
      t /= 10L;
#line 1140
      bufp --;
#line 1140
      if (negative_number) {
#line 1140
        tmp___17 = - d;
      } else {
#line 1140
        tmp___17 = d;
      }
#line 1140
      *bufp = (char )(tmp___17 + 48);
#line 1136
      if (! (t != 0L)) {
#line 1136
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1144
    digits = 1;
#line 1145
    always_output_a_sign = (_Bool)0;
#line 1146
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1150
    if (modifier == 79) {
#line 1151
      goto bad_format;
    }
#line 1160
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1163
    subfmt = "%H:%M:%S";
#line 1164
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1167
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1167
      _n___9 = 1;
#line 1167
      _delta___9 = width - _n___9;
#line 1167
      if (_delta___9 > 0) {
#line 1167
        tmp___18 = _delta___9;
      } else {
#line 1167
        tmp___18 = 0;
      }
#line 1167
      _incr___9 = _n___9 + tmp___18;
#line 1167
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1167
        return ((size_t )0);
      }
#line 1167
      if (p) {
#line 1167
        if (digits == 0) {
#line 1167
          if (_delta___9 > 0) {
#line 1167
            if (pad == 48) {
              {
#line 1167
              memset((void *)p, '0', (size_t )_delta___9);
#line 1167
              p += _delta___9;
              }
            } else {
              {
#line 1167
              memset((void *)p, ' ', (size_t )_delta___9);
#line 1167
              p += _delta___9;
              }
            }
          }
        }
#line 1167
        *p = (char )'\t';
#line 1167
        p += _n___9;
      }
#line 1167
      i += (size_t )_incr___9;
#line 1167
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 1168
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1171
    digits = 1;
#line 1171
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1171
    goto do_number;
    case_85: /* CIL Label */ 
#line 1174
    if (modifier == 69) {
#line 1175
      goto bad_format;
    }
#line 1177
    digits = 2;
#line 1177
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1177
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1182
    if (modifier == 69) {
#line 1183
      goto bad_format;
    }
#line 1189
    if (tp->tm_year < 0) {
#line 1189
      tmp___19 = 300;
    } else {
#line 1189
      tmp___19 = -100;
    }
    {
#line 1189
    year = (int )(tp->tm_year + (int const   )tmp___19);
#line 1193
    year_adjust = 0;
#line 1194
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1194
    days = tmp___20;
    }
#line 1196
    if (days < 0) {
#line 1199
      year_adjust = -1;
#line 1200
      if ((year - 1) % 4 == 0) {
#line 1200
        if ((year - 1) % 100 != 0) {
#line 1200
          tmp___21 = 1;
        } else
#line 1200
        if ((year - 1) % 400 == 0) {
#line 1200
          tmp___21 = 1;
        } else {
#line 1200
          tmp___21 = 0;
        }
      } else {
#line 1200
        tmp___21 = 0;
      }
      {
#line 1200
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
      }
    } else {
#line 1205
      if (year % 4 == 0) {
#line 1205
        if (year % 100 != 0) {
#line 1205
          tmp___22 = 1;
        } else
#line 1205
        if (year % 400 == 0) {
#line 1205
          tmp___22 = 1;
        } else {
#line 1205
          tmp___22 = 0;
        }
      } else {
#line 1205
        tmp___22 = 0;
      }
      {
#line 1205
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1205
      d___0 = tmp___23;
      }
#line 1207
      if (0 <= d___0) {
#line 1210
        year_adjust = 1;
#line 1211
        days = d___0;
      }
    }
    {
#line 1217
    if ((int const   )*f == 103) {
#line 1217
      goto case_103___0;
    }
#line 1227
    if ((int const   )*f == 71) {
#line 1227
      goto case_71___0;
    }
#line 1232
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1219
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1220
    digits = 2;
#line 1220
    if (0 <= yy) {
#line 1220
      number_value = yy;
    } else {
#line 1220
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1220
        tmp___24 = - yy;
      } else {
#line 1220
        tmp___24 = yy + 100;
      }
#line 1220
      number_value = tmp___24;
    }
#line 1220
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1228
    digits = 4;
#line 1228
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1228
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1228
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1233
    digits = 2;
#line 1233
    number_value = days / 7 + 1;
#line 1233
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1238
    if (modifier == 69) {
#line 1239
      goto bad_format;
    }
#line 1241
    digits = 2;
#line 1241
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1241
    goto do_number;
    case_119: /* CIL Label */ 
#line 1244
    if (modifier == 69) {
#line 1245
      goto bad_format;
    }
#line 1247
    digits = 1;
#line 1247
    number_value = (int )tp->tm_wday;
#line 1247
    goto do_number;
    case_89: /* CIL Label */ 
#line 1250
    if (modifier == 69) {
#line 1264
      goto underlying_strftime;
    }
#line 1267
    if (modifier == 79) {
#line 1268
      goto bad_format;
    } else {
#line 1270
      digits = 4;
    }
#line 1270
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1270
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1270
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1274
    if (modifier == 69) {
#line 1285
      goto underlying_strftime;
    }
#line 1290
    yy___0 = (int )(tp->tm_year % 100);
#line 1291
    if (yy___0 < 0) {
#line 1292
      if (tp->tm_year < -1900) {
#line 1292
        yy___0 = - yy___0;
      } else {
#line 1292
        yy___0 += 100;
      }
    }
#line 1293
    digits = 2;
#line 1293
    number_value = yy___0;
#line 1293
    goto do_number;
    case_90: /* CIL Label */ 
#line 1297
    if (change_case) {
#line 1299
      to_uppcase = (_Bool)0;
#line 1300
      to_lowcase = (_Bool)1;
    }
#line 1308
    if (! zone) {
#line 1309
      zone = "";
    }
    {
#line 1321
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 1321
      tmp___25 = strlen(zone);
#line 1321
      _n___10 = (int )tmp___25;
#line 1321
      _delta___10 = width - _n___10;
      }
#line 1321
      if (_delta___10 > 0) {
#line 1321
        tmp___26 = _delta___10;
      } else {
#line 1321
        tmp___26 = 0;
      }
#line 1321
      _incr___10 = _n___10 + tmp___26;
#line 1321
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1321
        return ((size_t )0);
      }
#line 1321
      if (p) {
#line 1321
        if (digits == 0) {
#line 1321
          if (_delta___10 > 0) {
#line 1321
            if (pad == 48) {
              {
#line 1321
              memset((void *)p, '0', (size_t )_delta___10);
#line 1321
              p += _delta___10;
              }
            } else {
              {
#line 1321
              memset((void *)p, ' ', (size_t )_delta___10);
#line 1321
              p += _delta___10;
              }
            }
          }
        }
#line 1321
        if (to_lowcase) {
          {
#line 1321
          memcpy_lowcase(p, zone, (size_t )_n___10);
          }
        } else
#line 1321
        if (to_uppcase) {
          {
#line 1321
          memcpy_uppcase(p, zone, (size_t )_n___10);
          }
        } else {
          {
#line 1321
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)zone),
                 (size_t )_n___10);
          }
        }
#line 1321
        p += _n___10;
      }
#line 1321
      i += (size_t )_incr___10;
#line 1321
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1323
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1328
    colons = (size_t )1;
    {
#line 1328
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1328
      if (! ((int const   )*(f + colons) == 58)) {
#line 1328
        goto while_break___17;
      }
#line 1329
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1328
      colons ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1330
    if ((int const   )*(f + colons) != 122) {
#line 1331
      goto bad_format;
    }
#line 1332
    f += colons;
#line 1333
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1336
    colons = (size_t )0;
    do_z_conversion: 
#line 1339
    if (tp->tm_isdst < 0) {
#line 1340
      goto switch_break___1;
    }
#line 1348
    diff = (int )tp->tm_gmtoff;
#line 1385
    hour_diff = (diff / 60) / 60;
#line 1386
    min_diff = (diff / 60) % 60;
#line 1387
    sec_diff = diff % 60;
    {
#line 1391
    if (colons == 0U) {
#line 1391
      goto case_0;
    }
#line 1394
    if (colons == 1U) {
#line 1394
      goto tz_hh_mm;
    }
#line 1397
    if (colons == 2U) {
#line 1397
      goto tz_hh_mm_ss;
    }
#line 1401
    if (colons == 3U) {
#line 1401
      goto case_3;
    }
#line 1408
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1392
    digits = 5;
#line 1392
    negative_number = (_Bool )(diff < 0);
#line 1392
    tz_colon_mask = 0;
#line 1392
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1392
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1395
    digits = 6;
#line 1395
    negative_number = (_Bool )(diff < 0);
#line 1395
    tz_colon_mask = 4;
#line 1395
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1395
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1398
    digits = 9;
#line 1398
    negative_number = (_Bool )(diff < 0);
#line 1398
    tz_colon_mask = 20;
#line 1398
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1398
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1402
    if (sec_diff != 0) {
#line 1403
      goto tz_hh_mm_ss;
    }
#line 1404
    if (min_diff != 0) {
#line 1405
      goto tz_hh_mm;
    }
#line 1406
    digits = 3;
#line 1406
    negative_number = (_Bool )(diff < 0);
#line 1406
    tz_colon_mask = 0;
#line 1406
    u_number_value = (unsigned int )hour_diff;
#line 1406
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1409
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1414
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1423
    flen = 1;
    {
#line 1423
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1423
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1423
        goto while_break___18;
      }
#line 1424
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1423
      flen ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1425
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1425
      _n___11 = flen;
#line 1425
      _delta___11 = width - _n___11;
#line 1425
      if (_delta___11 > 0) {
#line 1425
        tmp___27 = _delta___11;
      } else {
#line 1425
        tmp___27 = 0;
      }
#line 1425
      _incr___11 = _n___11 + tmp___27;
#line 1425
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1425
        return ((size_t )0);
      }
#line 1425
      if (p) {
#line 1425
        if (digits == 0) {
#line 1425
          if (_delta___11 > 0) {
#line 1425
            if (pad == 48) {
              {
#line 1425
              memset((void *)p, '0', (size_t )_delta___11);
#line 1425
              p += _delta___11;
              }
            } else {
              {
#line 1425
              memset((void *)p, ' ', (size_t )_delta___11);
#line 1425
              p += _delta___11;
              }
            }
          }
        }
#line 1425
        if (to_lowcase) {
          {
#line 1425
          memcpy_lowcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else
#line 1425
        if (to_uppcase) {
          {
#line 1425
          memcpy_uppcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else {
          {
#line 1425
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(f + (1 - flen))),
                 (size_t )_n___11);
          }
        }
#line 1425
        p += _n___11;
      }
#line 1425
      i += (size_t )_incr___11;
#line 1425
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1427
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 508
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1432
  if (p) {
#line 1432
    if (maxsize != 0U) {
#line 1433
      *p = (char )'\000';
    }
  }
#line 1436
  return (i);
}
}
#line 1445 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1450
  tmp = strftime_case_((_Bool)0, s, maxsize, format, tp, ut, ns);
  }
#line 1450
  return (tmp);
}
}
#line 236 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 237
enum quoting_style  const  quoting_style_vals[8] ;
#line 247
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 250
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 254
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 263
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 269
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 280
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 295
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg___0 ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 302
char *quotearg_alloc(char const   *arg___0 , size_t argsize , struct quoting_options  const  *o ) ;
#line 311
char *quotearg_alloc_mem(char const   *arg___0 , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 321
char *quotearg_n(int n , char const   *arg___0 ) ;
#line 324
char *quotearg(char const   *arg___0 ) ;
#line 329
char *quotearg_n_mem(int n , char const   *arg___0 , size_t argsize ) ;
#line 332
char *quotearg_mem(char const   *arg___0 , size_t argsize ) ;
#line 337
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg___0 ) ;
#line 342
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg___0 ,
                           size_t argsize ) ;
#line 346
char *quotearg_style(enum quoting_style s , char const   *arg___0 ) ;
#line 349
char *quotearg_style_mem(enum quoting_style s , char const   *arg___0 , size_t argsize ) ;
#line 354
char *quotearg_char(char const   *arg___0 , char ch___0 ) ;
#line 357
char *quotearg_char_mem(char const   *arg___0 , size_t argsize , char ch___0 ) ;
#line 360
char *quotearg_colon(char const   *arg___0 ) ;
#line 363
char *quotearg_colon_mem(char const   *arg___0 , size_t argsize ) ;
#line 369
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg___0 ) ;
#line 374
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg___0 , size_t argsize ) ;
#line 379
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg___0 ) ;
#line 384
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg___0 ,
                          size_t argsize ) ;
#line 389
void quotearg_free(void) ;
#line 121 "/home/ysko/Works/test-src/pies-1.2/gnu/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 233
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 234
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 234 "/home/ysko/Works/test-src/pies-1.2/gnu/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 237
  if (sizeof(char ) == 1UL) {
    {
#line 237
    tmp = xmalloc(n);
#line 237
    tmp___1 = tmp;
    }
  } else {
    {
#line 237
    tmp___0 = xnmalloc(n, (size_t )sizeof(char ));
#line 237
    tmp___1 = tmp___0;
    }
  }
#line 237
  return ((char *)tmp___1);
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 359 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 137 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 68 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 68 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 82 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 82
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 95 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 100 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 103
  tmp = __errno_location();
#line 103
  e = *tmp;
  }
#line 104
  if (o) {
#line 104
    tmp___0 = o;
  } else {
#line 104
    tmp___0 = & default_quoting_options;
  }
  {
#line 104
  tmp___1 = xmemdup((void const   *)tmp___0, (size_t )sizeof(*o));
#line 104
  p = (struct quoting_options *)tmp___1;
#line 106
  tmp___2 = __errno_location();
#line 106
  *tmp___2 = e;
  }
#line 107
  return (p);
}
}
#line 111 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 114
  if (o) {
#line 114
    tmp = o;
  } else {
#line 114
    tmp = & default_quoting_options;
  }
#line 114
  return (tmp->style);
}
}
#line 119 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 122
  if (o) {
#line 122
    tmp = o;
  } else {
#line 122
    tmp = & default_quoting_options;
  }
#line 122
  tmp->style = s;
#line 123
  return;
}
}
#line 130 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 133
  uc = (unsigned char )c;
#line 134
  if (o) {
#line 134
    tmp = o;
  } else {
#line 134
    tmp = & default_quoting_options;
  }
#line 134
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 136
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 137
  r = (int )((*p >> shift) & 1U);
#line 138
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 139
  return (r);
}
}
#line 146 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 150
  if (! o) {
#line 151
    o = & default_quoting_options;
  }
#line 152
  r = o->flags;
#line 153
  o->flags = i;
#line 154
  return (r);
}
}
#line 157 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 161
  if (! o) {
#line 162
    o = & default_quoting_options;
  }
#line 163
  o->style = (enum quoting_style )8;
#line 164
  if (! left_quote) {
    {
#line 165
    abort();
    }
  } else
#line 164
  if (! right_quote) {
    {
#line 165
    abort();
    }
  }
#line 166
  o->left_quote = left_quote;
#line 167
  o->right_quote = right_quote;
#line 168
  return;
}
}
#line 171 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 175
  o.style = style;
#line 176
  o.flags = 0;
#line 177
  memset((void *)(o.quote_these_too), 0, (size_t )sizeof(o.quote_these_too));
  }
#line 178
  return (o);
}
}
#line 183 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 186
  tmp = gettext(msgid);
#line 186
  translation = (char const   *)tmp;
  }
#line 187
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 187
    if ((unsigned int )s == 7U) {
#line 188
      translation = "\"";
    }
  }
#line 189
  return (translation);
}
}
#line 205 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg___0 ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 214
  len = (size_t )0;
#line 215
  quote_string = (char const   *)0;
#line 216
  quote_string_len = (size_t )0;
#line 217
  backslash_escapes = (_Bool)0;
#line 218
  tmp = __ctype_get_mb_cur_max();
#line 218
  unibyte_locale = (_Bool )(tmp == 1U);
#line 219
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 232
  if ((unsigned int )quoting_style == 4U) {
#line 232
    goto case_4;
  }
#line 236
  if ((unsigned int )quoting_style == 3U) {
#line 236
    goto case_3;
  }
#line 244
  if ((unsigned int )quoting_style == 5U) {
#line 244
    goto case_5;
  }
#line 251
  if ((unsigned int )quoting_style == 8U) {
#line 251
    goto case_8;
  }
#line 251
  if ((unsigned int )quoting_style == 7U) {
#line 251
    goto case_8;
  }
#line 251
  if ((unsigned int )quoting_style == 6U) {
#line 251
    goto case_8;
  }
#line 286
  if ((unsigned int )quoting_style == 1U) {
#line 286
    goto case_1;
  }
#line 290
  if ((unsigned int )quoting_style == 2U) {
#line 290
    goto case_2;
  }
#line 297
  if ((unsigned int )quoting_style == 0U) {
#line 297
    goto case_0;
  }
#line 301
  goto switch_default;
  case_4: /* CIL Label */ 
#line 233
  quoting_style = (enum quoting_style )3;
#line 234
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 237
  if (! elide_outer_quotes) {
    {
#line 238
    while (1) {
      while_continue: /* CIL Label */ ;
#line 238
      if (len < buffersize) {
#line 238
        *(buffer + len) = (char )'\"';
      }
#line 238
      len ++;
#line 238
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 239
  backslash_escapes = (_Bool)1;
#line 240
  quote_string = "\"";
#line 241
  quote_string_len = (size_t )1;
#line 242
  goto switch_break;
  case_5: /* CIL Label */ 
#line 245
  backslash_escapes = (_Bool)1;
#line 246
  elide_outer_quotes = (_Bool)0;
#line 247
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 253
  if ((unsigned int )quoting_style != 8U) {
    {
#line 274
    left_quote = gettext_quote("`", quoting_style);
#line 275
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 277
  if (! elide_outer_quotes) {
#line 278
    quote_string = left_quote;
    {
#line 278
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 278
      if (! *quote_string) {
#line 278
        goto while_break___0;
      }
      {
#line 279
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 279
        if (len < buffersize) {
#line 279
          *(buffer + len) = (char )*quote_string;
        }
#line 279
        len ++;
#line 279
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 278
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 280
  backslash_escapes = (_Bool)1;
#line 281
  quote_string = right_quote;
#line 282
  quote_string_len = strlen(quote_string);
  }
#line 284
  goto switch_break;
  case_1: /* CIL Label */ 
#line 287
  quoting_style = (enum quoting_style )2;
#line 288
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 291
  if (! elide_outer_quotes) {
    {
#line 292
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 292
      if (len < buffersize) {
#line 292
        *(buffer + len) = (char )'\'';
      }
#line 292
      len ++;
#line 292
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 293
  quote_string = "\'";
#line 294
  quote_string_len = (size_t )1;
#line 295
  goto switch_break;
  case_0: /* CIL Label */ 
#line 298
  elide_outer_quotes = (_Bool)0;
#line 299
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 302
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 305
  i = (size_t )0;
  {
#line 305
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 305
    if (argsize == 4294967295U) {
#line 305
      tmp___6 = (int const   )*(arg___0 + i) == 0;
    } else {
#line 305
      tmp___6 = i == argsize;
    }
#line 305
    if (tmp___6) {
#line 305
      goto while_break___3;
    }
#line 309
    is_right_quote = (_Bool)0;
#line 311
    if (backslash_escapes) {
#line 311
      if (quote_string_len) {
#line 311
        if (i + quote_string_len <= argsize) {
          {
#line 311
          tmp___0 = memcmp((void const   *)(arg___0 + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 311
          if (tmp___0 == 0) {
#line 316
            if (elide_outer_quotes) {
#line 317
              goto force_outer_quoting_style;
            }
#line 318
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 321
    c = (unsigned char )*(arg___0 + i);
    {
#line 324
    if ((int )c == 0) {
#line 324
      goto case_0___0;
    }
#line 350
    if ((int )c == 63) {
#line 350
      goto case_63;
    }
#line 388
    if ((int )c == 7) {
#line 388
      goto case_7___0;
    }
#line 389
    if ((int )c == 8) {
#line 389
      goto case_8___0;
    }
#line 390
    if ((int )c == 12) {
#line 390
      goto case_12;
    }
#line 391
    if ((int )c == 10) {
#line 391
      goto case_10;
    }
#line 392
    if ((int )c == 13) {
#line 392
      goto case_13;
    }
#line 393
    if ((int )c == 9) {
#line 393
      goto case_9;
    }
#line 394
    if ((int )c == 11) {
#line 394
      goto case_11;
    }
#line 395
    if ((int )c == 92) {
#line 395
      goto case_92;
    }
#line 414
    if ((int )c == 125) {
#line 414
      goto case_125;
    }
#line 414
    if ((int )c == 123) {
#line 414
      goto case_125;
    }
#line 418
    if ((int )c == 126) {
#line 418
      goto case_126;
    }
#line 418
    if ((int )c == 35) {
#line 418
      goto case_126;
    }
#line 430
    if ((int )c == 124) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 96) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 94) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 91) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 62) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 61) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 60) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 59) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 42) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 41) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 40) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 38) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 36) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 34) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 33) {
#line 430
      goto case_124;
    }
#line 430
    if ((int )c == 32) {
#line 430
      goto case_124;
    }
#line 440
    if ((int )c == 39) {
#line 440
      goto case_39___0;
    }
#line 462
    if ((int )c == 122) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 121) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 120) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 119) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 118) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 117) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 116) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 115) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 114) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 113) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 112) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 111) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 110) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 109) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 108) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 107) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 106) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 105) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 104) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 103) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 102) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 101) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 100) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 99) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 98) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 97) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 95) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 93) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 90) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 89) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 88) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 87) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 86) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 85) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 84) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 83) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 82) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 81) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 80) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 79) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 78) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 77) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 76) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 75) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 74) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 73) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 72) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 71) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 70) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 69) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 68) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 67) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 66) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 65) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 58) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 57) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 56) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 55) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 54) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 53) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 52) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 51) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 50) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 49) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 48) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 47) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 46) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 45) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 44) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 43) {
#line 462
      goto case_122;
    }
#line 462
    if ((int )c == 37) {
#line 462
      goto case_122;
    }
#line 475
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 325
    if (backslash_escapes) {
#line 327
      if (elide_outer_quotes) {
#line 328
        goto force_outer_quoting_style;
      }
      {
#line 329
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 329
        if (len < buffersize) {
#line 329
          *(buffer + len) = (char )'\\';
        }
#line 329
        len ++;
#line 329
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 335
      if (i + 1U < argsize) {
#line 335
        if (48 <= (int )*(arg___0 + (i + 1U))) {
#line 335
          if ((int const   )*(arg___0 + (i + 1U)) <= 57) {
            {
#line 337
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 337
              if (len < buffersize) {
#line 337
                *(buffer + len) = (char )'0';
              }
#line 337
              len ++;
#line 337
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 338
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 338
              if (len < buffersize) {
#line 338
                *(buffer + len) = (char )'0';
              }
#line 338
              len ++;
#line 338
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 340
      c = (unsigned char )'0';
    } else
#line 346
    if (flags & 1) {
#line 347
      goto __Cont;
    }
#line 348
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 353
    if ((unsigned int )quoting_style == 2U) {
#line 353
      goto case_2___0;
    }
#line 358
    if ((unsigned int )quoting_style == 3U) {
#line 358
      goto case_3___0;
    }
#line 383
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 354
    if (elide_outer_quotes) {
#line 355
      goto force_outer_quoting_style;
    }
#line 356
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 359
    if (flags & 4) {
#line 359
      if (i + 2U < argsize) {
#line 359
        if ((int const   )*(arg___0 + (i + 1U)) == 63) {
          {
#line 365
          if ((int const   )*(arg___0 + (i + 2U)) == 62) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2U)) == 61) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2U)) == 60) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2U)) == 47) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2U)) == 45) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2U)) == 41) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2U)) == 40) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2U)) == 39) {
#line 365
            goto case_62;
          }
#line 365
          if ((int const   )*(arg___0 + (i + 2U)) == 33) {
#line 365
            goto case_62;
          }
#line 378
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 368
          if (elide_outer_quotes) {
#line 369
            goto force_outer_quoting_style;
          }
#line 370
          c = (unsigned char )*(arg___0 + (i + 2U));
#line 371
          i += 2U;
          {
#line 372
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 372
            if (len < buffersize) {
#line 372
              *(buffer + len) = (char )'?';
            }
#line 372
            len ++;
#line 372
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 373
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 373
            if (len < buffersize) {
#line 373
              *(buffer + len) = (char )'\"';
            }
#line 373
            len ++;
#line 373
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 374
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 374
            if (len < buffersize) {
#line 374
              *(buffer + len) = (char )'\"';
            }
#line 374
            len ++;
#line 374
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 375
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 375
            if (len < buffersize) {
#line 375
              *(buffer + len) = (char )'?';
            }
#line 375
            len ++;
#line 375
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 376
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 379
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 381
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 384
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 386
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 388
    esc = (unsigned char )'a';
#line 388
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 389
    esc = (unsigned char )'b';
#line 389
    goto c_escape;
    case_12: /* CIL Label */ 
#line 390
    esc = (unsigned char )'f';
#line 390
    goto c_escape;
    case_10: /* CIL Label */ 
#line 391
    esc = (unsigned char )'n';
#line 391
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 392
    esc = (unsigned char )'r';
#line 392
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 393
    esc = (unsigned char )'t';
#line 393
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 394
    esc = (unsigned char )'v';
#line 394
    goto c_escape;
    case_92: /* CIL Label */ 
#line 395
    esc = c;
#line 398
    if (backslash_escapes) {
#line 398
      if (elide_outer_quotes) {
#line 398
        if (quote_string_len) {
#line 399
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 402
    if ((unsigned int )quoting_style == 2U) {
#line 402
      if (elide_outer_quotes) {
#line 404
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 407
    if (backslash_escapes) {
#line 409
      c = esc;
#line 410
      goto store_escape;
    }
#line 412
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 415
    if (argsize == 4294967295U) {
#line 415
      tmp___1 = (int const   )*(arg___0 + 1) == 0;
    } else {
#line 415
      tmp___1 = argsize == 1U;
    }
#line 415
    if (! tmp___1) {
#line 416
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 419
    if (i != 0U) {
#line 420
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 435
    if ((unsigned int )quoting_style == 2U) {
#line 435
      if (elide_outer_quotes) {
#line 437
        goto force_outer_quoting_style;
      }
    }
#line 438
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 441
    if ((unsigned int )quoting_style == 2U) {
#line 443
      if (elide_outer_quotes) {
#line 444
        goto force_outer_quoting_style;
      }
      {
#line 445
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 445
        if (len < buffersize) {
#line 445
          *(buffer + len) = (char )'\'';
        }
#line 445
        len ++;
#line 445
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 446
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 446
        if (len < buffersize) {
#line 446
          *(buffer + len) = (char )'\\';
        }
#line 446
        len ++;
#line 446
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 447
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 447
        if (len < buffersize) {
#line 447
          *(buffer + len) = (char )'\'';
        }
#line 447
        len ++;
#line 447
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 449
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 473
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 487
    if (unibyte_locale) {
      {
#line 489
      m = (size_t )1;
#line 490
      tmp___2 = __ctype_b_loc();
#line 490
      printable = (_Bool )(((int const   )*(*tmp___2 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 495
      memset((void *)(& mbstate), 0, (size_t )sizeof(mbstate));
#line 497
      m = (size_t )0;
#line 498
      printable = (_Bool)1;
      }
#line 499
      if (argsize == 4294967295U) {
        {
#line 500
        argsize = strlen(arg___0);
        }
      }
      {
#line 502
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 505
        tmp___3 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg___0 + (i + m)),
                          argsize - (i + m), & mbstate);
#line 505
        bytes = tmp___3;
        }
#line 507
        if (bytes == 0U) {
#line 508
          goto while_break___14;
        } else
#line 509
        if (bytes == 4294967295U) {
#line 511
          printable = (_Bool)0;
#line 512
          goto while_break___14;
        } else
#line 514
        if (bytes == 4294967294U) {
#line 516
          printable = (_Bool)0;
          {
#line 517
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 517
            if (i + m < argsize) {
#line 517
              if (! *(arg___0 + (i + m))) {
#line 517
                goto while_break___15;
              }
            } else {
#line 517
              goto while_break___15;
            }
#line 518
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 519
          goto while_break___14;
        } else {
#line 527
          if (elide_outer_quotes) {
#line 527
            if ((unsigned int )quoting_style == 2U) {
#line 531
              j = (size_t )1;
              {
#line 531
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 531
                if (! (j < bytes)) {
#line 531
                  goto while_break___16;
                }
                {
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 124) {
#line 535
                  goto case_124___0;
                }
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 96) {
#line 535
                  goto case_124___0;
                }
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 94) {
#line 535
                  goto case_124___0;
                }
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 92) {
#line 535
                  goto case_124___0;
                }
#line 535
                if ((int const   )*(arg___0 + ((i + m) + j)) == 91) {
#line 535
                  goto case_124___0;
                }
#line 538
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 536
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 539
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 531
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 543
          tmp___4 = iswprint((wint_t )w);
          }
#line 543
          if (! tmp___4) {
#line 544
            printable = (_Bool)0;
          }
#line 545
          m += bytes;
        }
        {
#line 502
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 502
        if (tmp___5) {
#line 502
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 551
    if (1U < m) {
#line 551
      goto _L___0;
    } else
#line 551
    if (backslash_escapes) {
#line 551
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 555
        ilim = i + m;
        {
#line 557
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 559
          if (backslash_escapes) {
#line 559
            if (! printable) {
#line 561
              if (elide_outer_quotes) {
#line 562
                goto force_outer_quoting_style;
              }
              {
#line 563
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 563
                if (len < buffersize) {
#line 563
                  *(buffer + len) = (char )'\\';
                }
#line 563
                len ++;
#line 563
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 564
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 564
                if (len < buffersize) {
#line 564
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 564
                len ++;
#line 564
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 565
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 565
                if (len < buffersize) {
#line 565
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 565
                len ++;
#line 565
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 566
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 559
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 568
          if (is_right_quote) {
            {
#line 570
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 570
              if (len < buffersize) {
#line 570
                *(buffer + len) = (char )'\\';
              }
#line 570
              len ++;
#line 570
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 571
            is_right_quote = (_Bool)0;
          }
#line 573
          if (ilim <= i + 1U) {
#line 574
            goto while_break___17;
          }
          {
#line 575
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 575
            if (len < buffersize) {
#line 575
              *(buffer + len) = (char )c;
            }
#line 575
            len ++;
#line 575
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 576
          i ++;
#line 576
          c = (unsigned char )*(arg___0 + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 579
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 584
    if (backslash_escapes) {
#line 584
      goto _L___3;
    } else
#line 584
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 584
      if (quote_these_too) {
#line 584
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 584
          goto _L___2;
        }
      } else {
#line 584
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 584
    if (! is_right_quote) {
#line 588
      goto store_c;
    }
    store_escape: 
#line 591
    if (elide_outer_quotes) {
#line 592
      goto force_outer_quoting_style;
    }
    {
#line 593
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 593
      if (len < buffersize) {
#line 593
        *(buffer + len) = (char )'\\';
      }
#line 593
      len ++;
#line 593
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 596
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 596
      if (len < buffersize) {
#line 596
        *(buffer + len) = (char )c;
      }
#line 596
      len ++;
#line 596
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 305
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 599
  if (len == 0U) {
#line 599
    if ((unsigned int )quoting_style == 2U) {
#line 599
      if (elide_outer_quotes) {
#line 601
        goto force_outer_quoting_style;
      }
    }
  }
#line 603
  if (quote_string) {
#line 603
    if (! elide_outer_quotes) {
      {
#line 604
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 604
        if (! *quote_string) {
#line 604
          goto while_break___25;
        }
        {
#line 605
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 605
          if (len < buffersize) {
#line 605
            *(buffer + len) = (char )*quote_string;
          }
#line 605
          len ++;
#line 605
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 604
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 607
  if (len < buffersize) {
#line 608
    *(buffer + len) = (char )'\000';
  }
#line 609
  return (len);
  force_outer_quoting_style: 
  {
#line 614
  tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg___0, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 614
  return (tmp___7);
}
}
#line 629 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg___0 ,
                       size_t argsize , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 634
  if (o) {
#line 634
    tmp = o;
  } else {
#line 634
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 634
  p = tmp;
#line 635
  tmp___0 = __errno_location();
#line 635
  e = *tmp___0;
#line 636
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg___0, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 636
  r = tmp___1;
#line 639
  tmp___2 = __errno_location();
#line 639
  *tmp___2 = e;
  }
#line 640
  return (r);
}
}
#line 644 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_alloc(char const   *arg___0 , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 648
  tmp = quotearg_alloc_mem(arg___0, argsize, (size_t *)((void *)0), o);
  }
#line 648
  return (tmp);
}
}
#line 657 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_alloc_mem(char const   *arg___0 , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 661
  if (o) {
#line 661
    tmp = o;
  } else {
#line 661
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 661
  p = tmp;
#line 662
  tmp___0 = __errno_location();
#line 662
  e = *tmp___0;
  }
#line 664
  if (size) {
#line 664
    tmp___1 = 0;
  } else {
#line 664
    tmp___1 = 1;
  }
  {
#line 664
  flags = (int )(p->flags | (int const   )tmp___1);
#line 665
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg___0, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 665
  bufsize___0 = tmp___2 + 1U;
#line 669
  tmp___3 = xcharalloc(bufsize___0);
#line 669
  buf = tmp___3;
#line 670
  quotearg_buffer_restyled(buf, bufsize___0, arg___0, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 673
  tmp___4 = __errno_location();
#line 673
  *tmp___4 = e;
  }
#line 674
  if (size) {
#line 675
    *size = bufsize___0 - 1U;
  }
#line 676
  return (buf);
}
}
#line 688 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
static char slot0[256]  ;
#line 689 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
static unsigned int nslots  =    1U;
#line 690 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
static struct slotvec slotvec0  =    {(size_t )sizeof(slot0), slot0};
#line 691 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 693 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 696
  sv = slotvec;
#line 698
  i = 1U;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (i < nslots)) {
#line 698
      goto while_break;
    }
    {
#line 699
    free((void *)(sv + i)->val);
#line 698
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 702
    free((void *)(sv + 0)->val);
#line 703
    slotvec0.size = (size_t )sizeof(slot0);
#line 704
    slotvec0.val = slot0;
    }
  }
#line 706
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 708
    free((void *)sv);
#line 709
    slotvec = & slotvec0;
    }
  }
#line 711
  nslots = 1U;
#line 712
  return;
}
}
#line 722 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg___0 , size_t argsize , struct quoting_options  const  *options___0 ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 726
  tmp = __errno_location();
#line 726
  e = *tmp;
#line 728
  n0 = (unsigned int )n;
#line 729
  sv = slotvec;
  }
#line 731
  if (n < 0) {
    {
#line 732
    abort();
    }
  }
#line 734
  if (nslots <= n0) {
#line 741
    n1 = n0 + 1U;
#line 742
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 744
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 744
      tmp___0 = -1;
    } else {
#line 744
      tmp___0 = -2;
    }
#line 744
    if ((unsigned long )((size_t )tmp___0) / sizeof(*sv) < (unsigned long )n1) {
      {
#line 745
      xalloc_die();
      }
    }
#line 747
    if (preallocated) {
#line 747
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 747
      tmp___1 = sv;
    }
    {
#line 747
    tmp___2 = xrealloc((void *)tmp___1, (size_t )((unsigned long )n1 * sizeof(*sv)));
#line 747
    sv = (struct slotvec *)tmp___2;
#line 747
    slotvec = sv;
    }
#line 748
    if (preallocated) {
#line 749
      *sv = slotvec0;
    }
    {
#line 750
    memset((void *)(sv + nslots), 0, (size_t )((unsigned long )(n1 - nslots) * sizeof(*sv)));
#line 751
    nslots = n1;
    }
  }
  {
#line 755
  size = (sv + n)->size;
#line 756
  val = (sv + n)->val;
#line 758
  flags = (int )(options___0->flags | 1);
#line 759
  tmp___3 = quotearg_buffer_restyled(val, size, arg___0, argsize, (enum quoting_style )options___0->style,
                                     flags, (unsigned int const   *)(options___0->quote_these_too),
                                     (char const   *)options___0->left_quote, (char const   *)options___0->right_quote);
#line 759
  qsize = tmp___3;
  }
#line 765
  if (size <= qsize) {
#line 767
    size = qsize + 1U;
#line 767
    (sv + n)->size = size;
#line 768
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 769
      free((void *)val);
      }
    }
    {
#line 770
    val = xcharalloc(size);
#line 770
    (sv + n)->val = val;
#line 771
    quotearg_buffer_restyled(val, size, arg___0, argsize, (enum quoting_style )options___0->style,
                             flags, (unsigned int const   *)(options___0->quote_these_too),
                             (char const   *)options___0->left_quote, (char const   *)options___0->right_quote);
    }
  }
  {
#line 777
  tmp___4 = __errno_location();
#line 777
  *tmp___4 = e;
  }
#line 778
  return (val);
}
}
#line 782 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_n(int n , char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 785
  tmp = quotearg_n_options(n, arg___0, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 785
  return (tmp);
}
}
#line 788 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 791
  tmp = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 791
  return (tmp);
}
}
#line 794 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg(char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 797
  tmp = quotearg_n(0, arg___0);
  }
#line 797
  return (tmp);
}
}
#line 800 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_mem(char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 803
  tmp = quotearg_n_mem(0, arg___0, argsize);
  }
#line 803
  return (tmp);
}
}
#line 806 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg___0 ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 809
  tmp = quoting_options_from_style(s);
#line 809
  o = tmp;
#line 810
  tmp___0 = quotearg_n_options(n, arg___0, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 810
  return (tmp___0);
}
}
#line 813 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg___0 ,
                           size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
#line 817
  tmp = quoting_options_from_style(s);
#line 817
  o = tmp;
#line 818
  tmp___0 = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& o));
  }
#line 818
  return (tmp___0);
}
}
#line 821 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 824
  tmp = quotearg_n_style(0, s, arg___0);
  }
#line 824
  return (tmp);
}
}
#line 827 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 830
  tmp = quotearg_n_style_mem(0, s, arg___0, argsize);
  }
#line 830
  return (tmp);
}
}
#line 833 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_char_mem(char const   *arg___0 , size_t argsize , char ch___0 ) 
{ 
  struct quoting_options options___0 ;
  char *tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 837
  options___0 = default_quoting_options;
#line 838
  set_char_quoting(& options___0, ch___0, 1);
#line 839
  tmp = quotearg_n_options(0, arg___0, argsize, (struct quoting_options  const  *)(& options___0));
  }
#line 839
  return (tmp);
}
}
#line 842 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_char(char const   *arg___0 , char ch___0 ) 
{ 
  char *tmp ;

  {
  {
#line 845
  tmp = quotearg_char_mem(arg___0, (size_t )-1, ch___0);
  }
#line 845
  return (tmp);
}
}
#line 848 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_colon(char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 851
  tmp = quotearg_char(arg___0, (char )':');
  }
#line 851
  return (tmp);
}
}
#line 854 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_colon_mem(char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 857
  tmp = quotearg_char_mem(arg___0, argsize, (char )':');
  }
#line 857
  return (tmp);
}
}
#line 860 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 864
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg___0, (size_t )-1);
  }
#line 864
  return (tmp);
}
}
#line 868 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg___0 , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 873
  o = default_quoting_options;
#line 874
  set_custom_quoting(& o, left_quote, right_quote);
#line 875
  tmp = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& o));
  }
#line 875
  return (tmp);
}
}
#line 878 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 882
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg___0);
  }
#line 882
  return (tmp);
}
}
#line 885 "/home/ysko/Works/test-src/pies-1.2/gnu/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg___0 ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 889
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg___0, argsize);
  }
#line 889
  return (tmp);
}
}
#line 34 "/home/ysko/Works/test-src/pies-1.2/gnu/progname.h"
char const   *program_name ;
#line 39
void set_program_name(char const   *argv0 ) ;
#line 55 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 55
extern char *program_invocation_short_name ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 35 "/home/ysko/Works/test-src/pies-1.2/gnu/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 40 "/home/ysko/Works/test-src/pies-1.2/gnu/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 53
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 56
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 58
    abort();
    }
  }
  {
#line 61
  tmp = strrchr(argv0, '/');
#line 61
  slash = (char const   *)tmp;
  }
#line 62
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 62
    base = slash + 1;
  } else {
#line 62
    base = argv0;
  }
#line 63
  if (base - argv0 >= 7L) {
    {
#line 63
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 63
    if (tmp___1 == 0) {
      {
#line 65
      argv0 = base;
#line 66
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 66
      if (tmp___0 == 0) {
#line 68
        argv0 = base + 3;
#line 72
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 86
  program_name = argv0;
#line 92
  program_invocation_name = (char *)argv0;
#line 94
  return;
}
}
#line 82 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  void *tmp ;
  char c ;
  char const   *tmp___0 ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___3 ;
  size_t __attribute__((__pure__))  tmp___4 ;
  size_t tmp___5 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___11 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t tmp___13 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;

  {
  {
#line 85
  cp = format;
#line 86
  arg_posn = (size_t )0;
#line 89
  max_width_length = (size_t )0;
#line 90
  max_precision_length = (size_t )0;
#line 92
  d->count = (size_t )0;
#line 93
  d_allocated = (size_t )1;
#line 94
  tmp = malloc((size_t )((unsigned long )d_allocated * sizeof(char_directive )));
#line 94
  d->dir = (char_directive *)tmp;
  }
#line 95
  if ((unsigned long )d->dir == (unsigned long )((void *)0)) {
#line 97
    goto out_of_memory_1;
  }
#line 99
  a->count = (size_t )0;
#line 100
  a_allocated = (size_t )0;
#line 101
  a->arg = (argument *)((void *)0);
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int const   )*cp != 0)) {
#line 135
      goto while_break;
    }
#line 137
    tmp___0 = cp;
#line 137
    cp ++;
#line 137
    c = (char )*tmp___0;
#line 138
    if ((int )c == 37) {
#line 140
      arg_index = ~ ((size_t )0);
#line 141
      dp = d->dir + d->count;
#line 144
      dp->dir_start = cp - 1;
#line 145
      dp->flags = 0;
#line 146
      dp->width_start = (char const   *)((void *)0);
#line 147
      dp->width_end = (char const   *)((void *)0);
#line 148
      dp->width_arg_index = ~ ((size_t )0);
#line 149
      dp->precision_start = (char const   *)((void *)0);
#line 150
      dp->precision_end = (char const   *)((void *)0);
#line 151
      dp->precision_arg_index = ~ ((size_t )0);
#line 152
      dp->arg_index = ~ ((size_t )0);
#line 155
      if ((int const   )*cp >= 48) {
#line 155
        if ((int const   )*cp <= 57) {
#line 159
          np = cp;
          {
#line 159
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 159
            if ((int const   )*np >= 48) {
#line 159
              if (! ((int const   )*np <= 57)) {
#line 159
                goto while_break___0;
              }
            } else {
#line 159
              goto while_break___0;
            }
#line 159
            np ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 161
          if ((int const   )*np == 36) {
#line 163
            n = (size_t )0;
#line 165
            np = cp;
            {
#line 165
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 165
              if ((int const   )*np >= 48) {
#line 165
                if (! ((int const   )*np <= 57)) {
#line 165
                  goto while_break___1;
                }
              } else {
#line 165
                goto while_break___1;
              }
#line 166
              if (n <= 429496729U) {
#line 166
                tmp___1 = n * 10U;
              } else {
#line 166
                tmp___1 = 4294967295U;
              }
              {
#line 166
              tmp___2 = xsum(tmp___1, (size_t )((int const   )*np - 48));
#line 166
              n = (size_t )tmp___2;
#line 165
              np ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 167
            if (n == 0U) {
#line 169
              goto error;
            }
#line 170
            if (n == 4294967295U) {
#line 172
              goto error;
            }
#line 173
            arg_index = n - 1U;
#line 174
            cp = np + 1;
          }
        }
      }
      {
#line 179
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 181
        if ((int const   )*cp == 39) {
#line 183
          dp->flags |= 1;
#line 184
          cp ++;
        } else
#line 186
        if ((int const   )*cp == 45) {
#line 188
          dp->flags |= 2;
#line 189
          cp ++;
        } else
#line 191
        if ((int const   )*cp == 43) {
#line 193
          dp->flags |= 4;
#line 194
          cp ++;
        } else
#line 196
        if ((int const   )*cp == 32) {
#line 198
          dp->flags |= 8;
#line 199
          cp ++;
        } else
#line 201
        if ((int const   )*cp == 35) {
#line 203
          dp->flags |= 16;
#line 204
          cp ++;
        } else
#line 206
        if ((int const   )*cp == 48) {
#line 208
          dp->flags |= 32;
#line 209
          cp ++;
        } else {
#line 212
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 216
      if ((int const   )*cp == 42) {
#line 218
        dp->width_start = cp;
#line 219
        cp ++;
#line 220
        dp->width_end = cp;
#line 221
        if (max_width_length < 1U) {
#line 222
          max_width_length = (size_t )1;
        }
#line 225
        if ((int const   )*cp >= 48) {
#line 225
          if ((int const   )*cp <= 57) {
#line 229
            np___0 = cp;
            {
#line 229
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 229
              if ((int const   )*np___0 >= 48) {
#line 229
                if (! ((int const   )*np___0 <= 57)) {
#line 229
                  goto while_break___3;
                }
              } else {
#line 229
                goto while_break___3;
              }
#line 229
              np___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 231
            if ((int const   )*np___0 == 36) {
#line 233
              n___0 = (size_t )0;
#line 235
              np___0 = cp;
              {
#line 235
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 235
                if ((int const   )*np___0 >= 48) {
#line 235
                  if (! ((int const   )*np___0 <= 57)) {
#line 235
                    goto while_break___4;
                  }
                } else {
#line 235
                  goto while_break___4;
                }
#line 236
                if (n___0 <= 429496729U) {
#line 236
                  tmp___3 = n___0 * 10U;
                } else {
#line 236
                  tmp___3 = 4294967295U;
                }
                {
#line 236
                tmp___4 = xsum(tmp___3, (size_t )((int const   )*np___0 - 48));
#line 236
                n___0 = (size_t )tmp___4;
#line 235
                np___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 237
              if (n___0 == 0U) {
#line 239
                goto error;
              }
#line 240
              if (n___0 == 4294967295U) {
#line 242
                goto error;
              }
#line 243
              dp->width_arg_index = n___0 - 1U;
#line 244
              cp = np___0 + 1;
            }
          }
        }
#line 247
        if (dp->width_arg_index == 4294967295U) {
#line 249
          tmp___5 = arg_posn;
#line 249
          arg_posn ++;
#line 249
          dp->width_arg_index = tmp___5;
#line 250
          if (dp->width_arg_index == 4294967295U) {
#line 252
            goto error;
          }
        }
#line 254
        n___1 = dp->width_arg_index;
#line 254
        if (n___1 >= a_allocated) {
#line 254
          if (a_allocated <= 2147483647U) {
#line 254
            a_allocated *= 2U;
          } else {
#line 254
            a_allocated = 4294967295U;
          }
#line 254
          if (a_allocated <= n___1) {
            {
#line 254
            tmp___6 = xsum(n___1, (size_t )1);
#line 254
            a_allocated = (size_t )tmp___6;
            }
          }
#line 254
          if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 254
            memory_size = (size_t )((unsigned long )a_allocated * sizeof(argument ));
          } else {
#line 254
            memory_size = 4294967295U;
          }
#line 254
          if (memory_size == 4294967295U) {
#line 254
            goto out_of_memory;
          }
#line 254
          if (a->arg) {
            {
#line 254
            tmp___7 = realloc((void *)a->arg, memory_size);
#line 254
            tmp___9 = tmp___7;
            }
          } else {
            {
#line 254
            tmp___8 = malloc(memory_size);
#line 254
            tmp___9 = tmp___8;
            }
          }
#line 254
          memory = (argument *)tmp___9;
#line 254
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 254
            goto out_of_memory;
          }
#line 254
          a->arg = memory;
        }
        {
#line 254
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 254
          if (! (a->count <= n___1)) {
#line 254
            goto while_break___5;
          }
#line 254
          tmp___10 = a->count;
#line 254
          (a->count) ++;
#line 254
          (a->arg + tmp___10)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 254
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 254
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 254
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 254
          goto error;
        }
      } else
#line 256
      if ((int const   )*cp >= 48) {
#line 256
        if ((int const   )*cp <= 57) {
#line 260
          dp->width_start = cp;
          {
#line 261
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 261
            if ((int const   )*cp >= 48) {
#line 261
              if (! ((int const   )*cp <= 57)) {
#line 261
                goto while_break___6;
              }
            } else {
#line 261
              goto while_break___6;
            }
#line 261
            cp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 263
          dp->width_end = cp;
#line 264
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 265
          if (max_width_length < width_length) {
#line 266
            max_width_length = width_length;
          }
        }
      }
#line 270
      if ((int const   )*cp == 46) {
#line 272
        cp ++;
#line 273
        if ((int const   )*cp == 42) {
#line 275
          dp->precision_start = cp - 1;
#line 276
          cp ++;
#line 277
          dp->precision_end = cp;
#line 278
          if (max_precision_length < 2U) {
#line 279
            max_precision_length = (size_t )2;
          }
#line 282
          if ((int const   )*cp >= 48) {
#line 282
            if ((int const   )*cp <= 57) {
#line 286
              np___1 = cp;
              {
#line 286
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 286
                if ((int const   )*np___1 >= 48) {
#line 286
                  if (! ((int const   )*np___1 <= 57)) {
#line 286
                    goto while_break___7;
                  }
                } else {
#line 286
                  goto while_break___7;
                }
#line 286
                np___1 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 288
              if ((int const   )*np___1 == 36) {
#line 290
                n___2 = (size_t )0;
#line 292
                np___1 = cp;
                {
#line 292
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 292
                  if ((int const   )*np___1 >= 48) {
#line 292
                    if (! ((int const   )*np___1 <= 57)) {
#line 292
                      goto while_break___8;
                    }
                  } else {
#line 292
                    goto while_break___8;
                  }
#line 293
                  if (n___2 <= 429496729U) {
#line 293
                    tmp___11 = n___2 * 10U;
                  } else {
#line 293
                    tmp___11 = 4294967295U;
                  }
                  {
#line 293
                  tmp___12 = xsum(tmp___11, (size_t )((int const   )*np___1 - 48));
#line 293
                  n___2 = (size_t )tmp___12;
#line 292
                  np___1 ++;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 294
                if (n___2 == 0U) {
#line 296
                  goto error;
                }
#line 297
                if (n___2 == 4294967295U) {
#line 300
                  goto error;
                }
#line 301
                dp->precision_arg_index = n___2 - 1U;
#line 302
                cp = np___1 + 1;
              }
            }
          }
#line 305
          if (dp->precision_arg_index == 4294967295U) {
#line 307
            tmp___13 = arg_posn;
#line 307
            arg_posn ++;
#line 307
            dp->precision_arg_index = tmp___13;
#line 308
            if (dp->precision_arg_index == 4294967295U) {
#line 310
              goto error;
            }
          }
#line 312
          n___3 = dp->precision_arg_index;
#line 312
          if (n___3 >= a_allocated) {
#line 312
            if (a_allocated <= 2147483647U) {
#line 312
              a_allocated *= 2U;
            } else {
#line 312
              a_allocated = 4294967295U;
            }
#line 312
            if (a_allocated <= n___3) {
              {
#line 312
              tmp___14 = xsum(n___3, (size_t )1);
#line 312
              a_allocated = (size_t )tmp___14;
              }
            }
#line 312
            if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 312
              memory_size___0 = (size_t )((unsigned long )a_allocated * sizeof(argument ));
            } else {
#line 312
              memory_size___0 = 4294967295U;
            }
#line 312
            if (memory_size___0 == 4294967295U) {
#line 312
              goto out_of_memory;
            }
#line 312
            if (a->arg) {
              {
#line 312
              tmp___15 = realloc((void *)a->arg, memory_size___0);
#line 312
              tmp___17 = tmp___15;
              }
            } else {
              {
#line 312
              tmp___16 = malloc(memory_size___0);
#line 312
              tmp___17 = tmp___16;
              }
            }
#line 312
            memory___0 = (argument *)tmp___17;
#line 312
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 312
              goto out_of_memory;
            }
#line 312
            a->arg = memory___0;
          }
          {
#line 312
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 312
            if (! (a->count <= n___3)) {
#line 312
              goto while_break___9;
            }
#line 312
            tmp___18 = a->count;
#line 312
            (a->count) ++;
#line 312
            (a->arg + tmp___18)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 312
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 312
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 312
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 312
            goto error;
          }
        } else {
#line 318
          dp->precision_start = cp - 1;
          {
#line 319
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 319
            if ((int const   )*cp >= 48) {
#line 319
              if (! ((int const   )*cp <= 57)) {
#line 319
                goto while_break___10;
              }
            } else {
#line 319
              goto while_break___10;
            }
#line 319
            cp ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 321
          dp->precision_end = cp;
#line 322
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 323
          if (max_precision_length < precision_length) {
#line 324
            max_precision_length = precision_length;
          }
        }
      }
#line 333
      flags = 0;
      {
#line 335
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 337
        if ((int const   )*cp == 104) {
#line 339
          flags |= 1 << (flags & 1);
#line 340
          cp ++;
        } else
#line 342
        if ((int const   )*cp == 76) {
#line 344
          flags |= 4;
#line 345
          cp ++;
        } else
#line 347
        if ((int const   )*cp == 108) {
#line 349
          flags += 8;
#line 350
          cp ++;
        } else
#line 352
        if ((int const   )*cp == 106) {
#line 354
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 357
            flags += 16;
          } else
#line 359
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 362
            flags += 8;
          }
#line 364
          cp ++;
        } else
#line 366
        if ((int const   )*cp == 122) {
#line 366
          goto _L;
        } else
#line 366
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 371
          if (sizeof(size_t ) > sizeof(long )) {
#line 374
            flags += 16;
          } else
#line 376
          if (sizeof(size_t ) > sizeof(int )) {
#line 379
            flags += 8;
          }
#line 381
          cp ++;
        } else
#line 383
        if ((int const   )*cp == 116) {
#line 385
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 388
            flags += 16;
          } else
#line 390
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 393
            flags += 8;
          }
#line 395
          cp ++;
        } else {
#line 436
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 440
      tmp___19 = cp;
#line 440
      cp ++;
#line 440
      c = (char )*tmp___19;
      {
#line 443
      if ((int )c == 105) {
#line 443
        goto case_105;
      }
#line 443
      if ((int )c == 100) {
#line 443
        goto case_105;
      }
#line 461
      if ((int )c == 88) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 120) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 117) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 111) {
#line 461
        goto case_88;
      }
#line 480
      if ((int )c == 65) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 97) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 71) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 103) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 69) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 101) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 70) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 102) {
#line 480
        goto case_65;
      }
#line 486
      if ((int )c == 99) {
#line 486
        goto case_99;
      }
#line 497
      if ((int )c == 67) {
#line 497
        goto case_67;
      }
#line 502
      if ((int )c == 115) {
#line 502
        goto case_115;
      }
#line 513
      if ((int )c == 83) {
#line 513
        goto case_83;
      }
#line 518
      if ((int )c == 112) {
#line 518
        goto case_112;
      }
#line 521
      if ((int )c == 110) {
#line 521
        goto case_110;
      }
#line 550
      if ((int )c == 37) {
#line 550
        goto case_37;
      }
#line 553
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 446
      if (flags >= 16) {
#line 447
        type = (arg_type )9;
      } else
#line 446
      if (flags & 4) {
#line 447
        type = (arg_type )9;
      } else
#line 452
      if (flags >= 8) {
#line 453
        type = (arg_type )7;
      } else
#line 454
      if (flags & 2) {
#line 455
        type = (arg_type )1;
      } else
#line 456
      if (flags & 1) {
#line 457
        type = (arg_type )3;
      } else {
#line 459
        type = (arg_type )5;
      }
#line 460
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 464
      if (flags >= 16) {
#line 465
        type = (arg_type )10;
      } else
#line 464
      if (flags & 4) {
#line 465
        type = (arg_type )10;
      } else
#line 470
      if (flags >= 8) {
#line 471
        type = (arg_type )8;
      } else
#line 472
      if (flags & 2) {
#line 473
        type = (arg_type )2;
      } else
#line 474
      if (flags & 1) {
#line 475
        type = (arg_type )4;
      } else {
#line 477
        type = (arg_type )6;
      }
#line 478
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 481
      if (flags >= 16) {
#line 482
        type = (arg_type )12;
      } else
#line 481
      if (flags & 4) {
#line 482
        type = (arg_type )12;
      } else {
#line 484
        type = (arg_type )11;
      }
#line 485
      goto switch_break;
      case_99: /* CIL Label */ 
#line 487
      if (flags >= 8) {
#line 489
        type = (arg_type )14;
      } else {
#line 494
        type = (arg_type )13;
      }
#line 495
      goto switch_break;
      case_67: /* CIL Label */ 
#line 498
      type = (arg_type )14;
#line 499
      c = (char )'c';
#line 500
      goto switch_break;
      case_115: /* CIL Label */ 
#line 503
      if (flags >= 8) {
#line 505
        type = (arg_type )16;
      } else {
#line 510
        type = (arg_type )15;
      }
#line 511
      goto switch_break;
      case_83: /* CIL Label */ 
#line 514
      type = (arg_type )16;
#line 515
      c = (char )'s';
#line 516
      goto switch_break;
      case_112: /* CIL Label */ 
#line 519
      type = (arg_type )17;
#line 520
      goto switch_break;
      case_110: /* CIL Label */ 
#line 524
      if (flags >= 16) {
#line 525
        type = (arg_type )22;
      } else
#line 524
      if (flags & 4) {
#line 525
        type = (arg_type )22;
      } else
#line 530
      if (flags >= 8) {
#line 531
        type = (arg_type )21;
      } else
#line 532
      if (flags & 2) {
#line 533
        type = (arg_type )18;
      } else
#line 534
      if (flags & 1) {
#line 535
        type = (arg_type )19;
      } else {
#line 537
        type = (arg_type )20;
      }
#line 538
      goto switch_break;
      case_37: /* CIL Label */ 
#line 551
      type = (arg_type )0;
#line 552
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 555
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 559
      if ((unsigned int )type != 0U) {
#line 561
        dp->arg_index = arg_index;
#line 562
        if (dp->arg_index == 4294967295U) {
#line 564
          tmp___20 = arg_posn;
#line 564
          arg_posn ++;
#line 564
          dp->arg_index = tmp___20;
#line 565
          if (dp->arg_index == 4294967295U) {
#line 567
            goto error;
          }
        }
#line 569
        n___4 = dp->arg_index;
#line 569
        if (n___4 >= a_allocated) {
#line 569
          if (a_allocated <= 2147483647U) {
#line 569
            a_allocated *= 2U;
          } else {
#line 569
            a_allocated = 4294967295U;
          }
#line 569
          if (a_allocated <= n___4) {
            {
#line 569
            tmp___21 = xsum(n___4, (size_t )1);
#line 569
            a_allocated = (size_t )tmp___21;
            }
          }
#line 569
          if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 569
            memory_size___1 = (size_t )((unsigned long )a_allocated * sizeof(argument ));
          } else {
#line 569
            memory_size___1 = 4294967295U;
          }
#line 569
          if (memory_size___1 == 4294967295U) {
#line 569
            goto out_of_memory;
          }
#line 569
          if (a->arg) {
            {
#line 569
            tmp___22 = realloc((void *)a->arg, memory_size___1);
#line 569
            tmp___24 = tmp___22;
            }
          } else {
            {
#line 569
            tmp___23 = malloc(memory_size___1);
#line 569
            tmp___24 = tmp___23;
            }
          }
#line 569
          memory___1 = (argument *)tmp___24;
#line 569
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 569
            goto out_of_memory;
          }
#line 569
          a->arg = memory___1;
        }
        {
#line 569
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 569
          if (! (a->count <= n___4)) {
#line 569
            goto while_break___12;
          }
#line 569
          tmp___25 = a->count;
#line 569
          (a->count) ++;
#line 569
          (a->arg + tmp___25)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 569
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 569
          (a->arg + n___4)->type = type;
        } else
#line 569
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 569
          goto error;
        }
      }
#line 571
      dp->conversion = c;
#line 572
      dp->dir_end = cp;
#line 575
      (d->count) ++;
#line 576
      if (d->count >= d_allocated) {
#line 581
        if (d_allocated <= 2147483647U) {
#line 581
          d_allocated *= 2U;
        } else {
#line 581
          d_allocated = 4294967295U;
        }
#line 582
        if ((unsigned long )d_allocated <= 4294967295UL / sizeof(char_directive )) {
#line 582
          memory_size___2 = (size_t )((unsigned long )d_allocated * sizeof(char_directive ));
        } else {
#line 582
          memory_size___2 = 4294967295U;
        }
#line 583
        if (memory_size___2 == 4294967295U) {
#line 585
          goto out_of_memory;
        }
        {
#line 586
        tmp___26 = realloc((void *)d->dir, memory_size___2);
#line 586
        memory___2 = (char_directive *)tmp___26;
        }
#line 587
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 589
          goto out_of_memory;
        }
#line 590
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  (d->dir + d->count)->dir_start = cp;
#line 603
  d->max_width_length = max_width_length;
#line 604
  d->max_precision_length = max_precision_length;
#line 605
  return (0);
  error: 
#line 608
  if (a->arg) {
    {
#line 609
    free((void *)a->arg);
    }
  }
#line 610
  if (d->dir) {
    {
#line 611
    free((void *)d->dir);
    }
  }
  {
#line 612
  tmp___27 = __errno_location();
#line 612
  *tmp___27 = 22;
  }
#line 613
  return (-1);
  out_of_memory: 
#line 616
  if (a->arg) {
    {
#line 617
    free((void *)a->arg);
    }
  }
#line 618
  if (d->dir) {
    {
#line 619
    free((void *)d->dir);
    }
  }
  out_of_memory_1: 
  {
#line 621
  tmp___28 = __errno_location();
#line 621
  *tmp___28 = 12;
  }
#line 622
  return (-1);
}
}
#line 115 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 38 "/home/ysko/Works/test-src/pies-1.2/gnu/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;
  char *__cil_tmp30 ;

  {
#line 44
  i = (size_t )0;
#line 44
  ap = a->arg + 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < a->count)) {
#line 44
      goto while_break;
    }
    {
#line 47
    if ((unsigned int )ap->type == 1U) {
#line 47
      goto case_1;
    }
#line 50
    if ((unsigned int )ap->type == 2U) {
#line 50
      goto case_2;
    }
#line 53
    if ((unsigned int )ap->type == 3U) {
#line 53
      goto case_3;
    }
#line 56
    if ((unsigned int )ap->type == 4U) {
#line 56
      goto case_4;
    }
#line 59
    if ((unsigned int )ap->type == 5U) {
#line 59
      goto case_5;
    }
#line 62
    if ((unsigned int )ap->type == 6U) {
#line 62
      goto case_6;
    }
#line 65
    if ((unsigned int )ap->type == 7U) {
#line 65
      goto case_7;
    }
#line 68
    if ((unsigned int )ap->type == 8U) {
#line 68
      goto case_8;
    }
#line 72
    if ((unsigned int )ap->type == 9U) {
#line 72
      goto case_9;
    }
#line 75
    if ((unsigned int )ap->type == 10U) {
#line 75
      goto case_10;
    }
#line 79
    if ((unsigned int )ap->type == 11U) {
#line 79
      goto case_11;
    }
#line 82
    if ((unsigned int )ap->type == 12U) {
#line 82
      goto case_12;
    }
#line 85
    if ((unsigned int )ap->type == 13U) {
#line 85
      goto case_13;
    }
#line 89
    if ((unsigned int )ap->type == 14U) {
#line 89
      goto case_14;
    }
#line 99
    if ((unsigned int )ap->type == 15U) {
#line 99
      goto case_15;
    }
#line 108
    if ((unsigned int )ap->type == 16U) {
#line 108
      goto case_16;
    }
#line 126
    if ((unsigned int )ap->type == 17U) {
#line 126
      goto case_17;
    }
#line 129
    if ((unsigned int )ap->type == 18U) {
#line 129
      goto case_18;
    }
#line 132
    if ((unsigned int )ap->type == 19U) {
#line 132
      goto case_19;
    }
#line 135
    if ((unsigned int )ap->type == 20U) {
#line 135
      goto case_20;
    }
#line 138
    if ((unsigned int )ap->type == 21U) {
#line 138
      goto case_21;
    }
#line 142
    if ((unsigned int )ap->type == 22U) {
#line 142
      goto case_22;
    }
#line 185
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 48
    tmp = __builtin_va_arg(args, int );
#line 48
    ap->a.a_schar = tmp;
    }
#line 49
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 51
    tmp___0 = __builtin_va_arg(args, int );
#line 51
    ap->a.a_uchar = tmp___0;
    }
#line 52
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 54
    tmp___1 = __builtin_va_arg(args, int );
#line 54
    ap->a.a_short = tmp___1;
    }
#line 55
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 57
    tmp___2 = __builtin_va_arg(args, int );
#line 57
    ap->a.a_ushort = tmp___2;
    }
#line 58
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 60
    tmp___3 = __builtin_va_arg(args, int );
#line 60
    ap->a.a_int = tmp___3;
    }
#line 61
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 63
    tmp___4 = __builtin_va_arg(args, unsigned int );
#line 63
    ap->a.a_uint = tmp___4;
    }
#line 64
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 66
    tmp___5 = __builtin_va_arg(args, long );
#line 66
    ap->a.a_longint = tmp___5;
    }
#line 67
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 69
    tmp___6 = __builtin_va_arg(args, unsigned long );
#line 69
    ap->a.a_ulongint = tmp___6;
    }
#line 70
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 73
    tmp___7 = __builtin_va_arg(args, long long );
#line 73
    ap->a.a_longlongint = tmp___7;
    }
#line 74
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 76
    tmp___8 = __builtin_va_arg(args, unsigned long long );
#line 76
    ap->a.a_ulonglongint = tmp___8;
    }
#line 77
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 80
    tmp___9 = __builtin_va_arg(args, double );
#line 80
    ap->a.a_double = tmp___9;
    }
#line 81
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 83
    tmp___10 = __builtin_va_arg(args, long double );
#line 83
    ap->a.a_longdouble = tmp___10;
    }
#line 84
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 86
    tmp___11 = __builtin_va_arg(args, int );
#line 86
    ap->a.a_char = tmp___11;
    }
#line 87
    goto switch_break;
    case_14: /* CIL Label */ 
#line 93
    if (sizeof(wint_t ) < sizeof(int )) {
      {
#line 93
      tmp___13 = __builtin_va_arg(args, int );
#line 93
      ap->a.a_wide_char = (wint_t )tmp___13;
      }
    } else {
      {
#line 93
      tmp___15 = __builtin_va_arg(args, wint_t );
#line 93
      ap->a.a_wide_char = tmp___15;
      }
    }
#line 97
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 100
    tmp___16 = __builtin_va_arg(args, char const   *);
#line 100
    ap->a.a_string = tmp___16;
    }
#line 104
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 105
      ap->a.a_string = "(NULL)";
    }
#line 106
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 109
    tmp___17 = __builtin_va_arg(args, wchar_t const   *);
#line 109
    ap->a.a_wide_string = tmp___17;
    }
#line 113
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 122
      ap->a.a_wide_string = wide_null_string;
    }
#line 124
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 127
    tmp___18 = __builtin_va_arg(args, void *);
#line 127
    ap->a.a_pointer = tmp___18;
    }
#line 128
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 130
    tmp___19 = __builtin_va_arg(args, signed char *);
#line 130
    ap->a.a_count_schar_pointer = tmp___19;
    }
#line 131
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 133
    tmp___20 = __builtin_va_arg(args, short *);
#line 133
    ap->a.a_count_short_pointer = tmp___20;
    }
#line 134
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 136
    tmp___21 = __builtin_va_arg(args, int *);
#line 136
    ap->a.a_count_int_pointer = tmp___21;
    }
#line 137
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 139
    tmp___22 = __builtin_va_arg(args, long *);
#line 139
    ap->a.a_count_longint_pointer = tmp___22;
    }
#line 140
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 143
    tmp___23 = __builtin_va_arg(args, long long *);
#line 143
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
#line 144
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 187
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 44
    i ++;
#line 44
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (0);
}
}
#line 45 "/home/ysko/Works/test-src/pies-1.2/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf ) ;
#line 31 "/home/ysko/Works/test-src/pies-1.2/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf ) 
{ 
  char *p ;

  {
#line 34
  p = buf + ((((sizeof(off_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 35
  *p = (char)0;
#line 39
  if (i < 0L) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48L - i % 10L);
#line 41
      i /= 10L;
#line 41
      if (! (i != 0L)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 50
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 51
      p --;
#line 51
      *p = (char )(48L + i % 10L);
#line 50
      i /= 10L;
#line 50
      if (! (i != 0L)) {
#line 50
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 55
  return (p);
}
}
#line 35 "/home/ysko/Works/test-src/pies-1.2/gnu/localcharset.h"
char const   *locale_charset(void) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 532
extern int __attribute__((__gnu_inline__))  getc_unlocked(FILE *__fp ) ;
#line 675
extern int ungetc(int __c , FILE *__stream ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 582 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 117 "/home/ysko/Works/test-src/pies-1.2/gnu/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 120 "/home/ysko/Works/test-src/pies-1.2/gnu/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 125
  cp = (char const   *)charset_aliases;
#line 126
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 130
    base = "charset.alias";
#line 135
    tmp = getenv("CHARSETALIASDIR");
#line 135
    dir = (char const   *)tmp;
    }
#line 136
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 137
      dir = "/usr/local/lib";
    } else
#line 136
    if ((int const   )*(dir + 0) == 0) {
#line 137
      dir = "/usr/local/lib";
    }
    {
#line 141
    tmp___0 = strlen(dir);
#line 141
    dir_len___0 = tmp___0;
#line 142
    tmp___1 = strlen(base);
#line 142
    base_len___0 = tmp___1;
    }
#line 143
    if (dir_len___0 > 0U) {
#line 143
      if (! ((int const   )*(dir + (dir_len___0 - 1U)) == 47)) {
#line 143
        tmp___2 = 1;
      } else {
#line 143
        tmp___2 = 0;
      }
    } else {
#line 143
      tmp___2 = 0;
    }
    {
#line 143
    add_slash = tmp___2;
#line 144
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1U);
#line 144
    file_name = (char *)tmp___3;
    }
#line 145
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 147
      memcpy((void */* __restrict  */)file_name, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 148
      if (add_slash) {
#line 149
        *(file_name + dir_len___0) = (char )'/';
      }
      {
#line 150
      memcpy((void */* __restrict  */)((file_name + dir_len___0) + add_slash), (void const   */* __restrict  */)base,
             base_len___0 + 1U);
      }
    }
#line 154
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 156
      cp = "";
    } else {
      {
#line 168
      fd = open((char const   *)file_name, 131072);
      }
#line 170
      if (fd < 0) {
#line 172
        cp = "";
      } else {
        {
#line 177
        fp = fdopen(fd, "r");
        }
#line 178
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 181
          close(fd);
#line 182
          cp = "";
          }
        } else {
#line 187
          res_ptr = (char *)((void *)0);
#line 188
          res_size = (size_t )0;
          {
#line 190
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 198
            c = (int )getc_unlocked(fp);
            }
#line 199
            if (c == -1) {
#line 200
              goto while_break;
            }
#line 201
            if (c == 10) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 32) {
#line 202
              goto __Cont;
            } else
#line 201
            if (c == 9) {
#line 202
              goto __Cont;
            }
#line 203
            if (c == 35) {
              {
#line 206
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 207
                c = (int )getc_unlocked(fp);
                }
#line 206
                if (c == -1) {
#line 206
                  goto while_break___0;
                } else
#line 206
                if (c == 10) {
#line 206
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 209
              if (c == -1) {
#line 210
                goto while_break;
              }
#line 211
              goto __Cont;
            }
            {
#line 213
            ungetc(c, fp);
#line 214
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 214
            if (tmp___4 < 2) {
#line 215
              goto while_break;
            }
            {
#line 216
            l1 = strlen((char const   *)(buf1));
#line 217
            l2 = strlen((char const   *)(buf2));
#line 218
            old_res_ptr = res_ptr;
            }
#line 219
            if (res_size == 0U) {
              {
#line 221
              res_size = ((l1 + 1U) + l2) + 1U;
#line 222
              tmp___5 = malloc(res_size + 1U);
#line 222
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 226
              res_size += ((l1 + 1U) + l2) + 1U;
#line 227
              tmp___6 = realloc((void *)res_ptr, res_size + 1U);
#line 227
              res_ptr = (char *)tmp___6;
              }
            }
#line 229
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
#line 232
              res_size = (size_t )0;
#line 233
              if ((unsigned long )old_res_ptr != (unsigned long )((void *)0)) {
                {
#line 234
                free((void *)old_res_ptr);
                }
              }
#line 235
              goto while_break;
            }
            {
#line 237
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1U)) - (l1 + 1U)),
                   (char const   */* __restrict  */)(buf1));
#line 238
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1U)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 240
          fclose(fp);
          }
#line 241
          if (res_size == 0U) {
#line 242
            cp = "";
          } else {
#line 245
            *(res_ptr + res_size) = (char )'\000';
#line 246
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 251
      free((void *)file_name);
      }
    }
#line 345
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 348
  return (cp);
}
}
#line 360 "/home/ysko/Works/test-src/pies-1.2/gnu/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 371
  tmp = nl_langinfo(14);
#line 371
  codeset = (char const   *)tmp;
  }
#line 513
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 515
    codeset = "";
  }
  {
#line 518
  aliases = get_charset_aliases();
  }
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 518
    if (! ((int const   )*aliases != 0)) {
#line 518
      goto while_break;
    }
    {
#line 521
    tmp___3 = strcmp(codeset, aliases);
    }
#line 521
    if (tmp___3 == 0) {
      {
#line 524
      tmp___2 = strlen(aliases);
#line 524
      codeset = (aliases + tmp___2) + 1;
      }
#line 525
      goto while_break;
    } else
#line 521
    if ((int const   )*(aliases + 0) == 42) {
#line 521
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 524
        tmp___2 = strlen(aliases);
#line 524
        codeset = (aliases + tmp___2) + 1;
        }
#line 525
        goto while_break;
      }
    }
    {
#line 518
    tmp___0 = strlen(aliases);
#line 518
    aliases += tmp___0 + 1U;
#line 518
    tmp___1 = strlen(aliases);
#line 518
    aliases += tmp___1 + 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if ((int const   )*(codeset + 0) == 0) {
#line 532
    codeset = "ASCII";
  }
#line 534
  return (codeset);
}
}
#line 46 "/home/ysko/Works/test-src/pies-1.2/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf ) ;
#line 31 "/home/ysko/Works/test-src/pies-1.2/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf ) 
{ 
  char *p ;

  {
#line 34
  p = buf + ((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 35
  *p = (char)0;
#line 39
  if (i < 0LL) {
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 42
      p --;
#line 42
      *p = (char )(48LL - i % 10LL);
#line 41
      i /= 10LL;
#line 41
      if (! (i != 0LL)) {
#line 41
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 45
    p --;
#line 45
    *p = (char )'-';
  } else {
    {
#line 50
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 51
      p --;
#line 51
      *p = (char )(48LL + i % 10LL);
#line 50
      i /= 10LL;
#line 50
      if (! (i != 0LL)) {
#line 50
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 55
  return (p);
}
}
#line 333 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 66 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table ) ;
#line 67
size_t hash_get_n_buckets_used(Hash_table const   *table ) ;
#line 68
size_t hash_get_n_entries(Hash_table const   *table ) ;
#line 69
size_t hash_get_max_bucket_length(Hash_table const   *table ) ;
#line 70
_Bool hash_table_ok(Hash_table const   *table ) ;
#line 71
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 72
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 75
void *hash_get_first(Hash_table const   *table ) ;
#line 76
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 77
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) ;
#line 78
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 81
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 82
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 83
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 86
void hash_clear(Hash_table *table ) ;
#line 87
void hash_free(Hash_table *table ) ;
#line 90
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 91
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) ;
#line 92
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 78 "/home/ysko/Works/test-src/pies-1.2/gnu/bitrotate.h"
__inline static size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 81
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 4294967295U);
}
}
#line 133 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 152 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 155
  return ((size_t )table->n_buckets);
}
}
#line 160 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 163
  return ((size_t )table->n_buckets_used);
}
}
#line 168 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 171
  return ((size_t )table->n_entries);
}
}
#line 176 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 180
  max_bucket_length = (size_t )0;
#line 182
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 182
      goto while_break;
    }
#line 184
    if (bucket->data) {
#line 186
      cursor = bucket;
#line 187
      bucket_length = (size_t )1;
      {
#line 189
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 189
        cursor = (struct hash_entry  const  *)cursor->next;
#line 189
        if (! cursor) {
#line 189
          goto while_break___0;
        }
#line 190
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 192
      if (bucket_length > max_bucket_length) {
#line 193
        max_bucket_length = bucket_length;
      }
    }
#line 182
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (max_bucket_length);
}
}
#line 203 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 207
  n_buckets_used = (size_t )0;
#line 208
  n_entries = (size_t )0;
#line 210
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 210
      goto while_break;
    }
#line 212
    if (bucket->data) {
#line 214
      cursor = bucket;
#line 217
      n_buckets_used ++;
#line 218
      n_entries ++;
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 221
        cursor = (struct hash_entry  const  *)cursor->next;
#line 221
        if (! cursor) {
#line 221
          goto while_break___0;
        }
#line 222
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 210
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 226
    if (n_entries == (size_t )table->n_entries) {
#line 227
      return ((_Bool)1);
    }
  }
#line 229
  return ((_Bool)0);
}
}
#line 232 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 235
  tmp = hash_get_n_entries(table);
#line 235
  n_entries = tmp;
#line 236
  tmp___0 = hash_get_n_buckets(table);
#line 236
  n_buckets = tmp___0;
#line 237
  tmp___1 = hash_get_n_buckets_used(table);
#line 237
  n_buckets_used = tmp___1;
#line 238
  tmp___2 = hash_get_max_bucket_length(table);
#line 238
  max_bucket_length = tmp___2;
#line 240
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          (unsigned long )n_entries);
#line 241
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          (unsigned long )n_buckets);
#line 242
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          (unsigned long )n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 245
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          (unsigned long )max_bucket_length);
  }
#line 247
  return;
}
}
#line 252 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 255
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 255
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 259
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 260
    abort();
    }
  }
#line 262
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 263
    return ((void *)0);
  }
#line 265
  cursor = bucket;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! cursor) {
#line 265
      goto while_break;
    }
#line 266
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 267
      return ((void *)cursor->data);
    } else {
      {
#line 266
      tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
      }
#line 266
      if (tmp___0) {
#line 267
        return ((void *)cursor->data);
      }
    }
#line 265
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return ((void *)0);
}
}
#line 283 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 288
  if (table->n_entries == 0U) {
#line 289
    return ((void *)0);
  }
#line 291
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 293
      abort();
      }
    } else
#line 294
    if (bucket->data) {
#line 295
      return ((void *)bucket->data);
    }
#line 291
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 302 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 305
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 305
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 309
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 310
    abort();
    }
  }
#line 313
  cursor = bucket;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! cursor) {
#line 313
      goto while_break;
    }
#line 314
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 314
      if (cursor->next) {
#line 315
        return ((cursor->next)->data);
      }
    }
#line 313
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    bucket ++;
#line 318
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 318
      goto while_break___0;
    }
#line 319
    if (bucket->data) {
#line 320
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  return ((void *)0);
}
}
#line 330 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 334
  counter = (size_t )0;
#line 338
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 338
      goto while_break;
    }
#line 340
    if (bucket->data) {
#line 342
      cursor = bucket;
      {
#line 342
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 342
        if (! cursor) {
#line 342
          goto while_break___0;
        }
#line 344
        if (counter >= buffer_size) {
#line 345
          return (counter);
        }
#line 346
        tmp = counter;
#line 346
        counter ++;
#line 346
        *(buffer + tmp) = (void *)cursor->data;
#line 342
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 338
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return (counter);
}
}
#line 362 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 366
  counter = (size_t )0;
#line 370
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 370
      goto while_break;
    }
#line 372
    if (bucket->data) {
#line 374
      cursor = bucket;
      {
#line 374
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 374
        if (! cursor) {
#line 374
          goto while_break___0;
        }
        {
#line 376
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 376
        if (! tmp) {
#line 377
          return (counter);
        }
#line 378
        counter ++;
#line 374
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 370
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return (counter);
}
}
#line 422 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch___0 ;

  {
#line 425
  value = (size_t )0;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    ch___0 = (unsigned char )*string;
#line 428
    if (! ch___0) {
#line 428
      goto while_break;
    }
#line 429
    value = (value * 31U + (size_t )ch___0) % n_buckets;
#line 428
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  return (value);
}
}
#line 438 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 441
  divisor = (size_t )3;
#line 442
  square = divisor * divisor;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if (square < candidate) {
#line 444
      if (! (candidate % divisor)) {
#line 444
        goto while_break;
      }
    } else {
#line 444
      goto while_break;
    }
#line 446
    divisor ++;
#line 447
    square += 4U * divisor;
#line 448
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  if (candidate % divisor) {
#line 451
    tmp = 1;
  } else {
#line 451
    tmp = 0;
  }
#line 451
  return ((_Bool )tmp);
}
}
#line 457 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 461
  if (candidate < 10U) {
#line 462
    candidate = (size_t )10;
  }
#line 465
  candidate |= 1U;
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (4294967295U != candidate) {
      {
#line 467
      tmp = is_prime(candidate);
      }
#line 467
      if (tmp) {
#line 467
        goto while_break;
      }
    } else {
#line 467
      goto while_break;
    }
#line 468
    candidate += 2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  return (candidate);
}
}
#line 473 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 476
  *tuning = (Hash_tuning )default_tuning;
#line 477
  return;
}
}
#line 480 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
  {
#line 488
  tmp = rotr_sz((size_t )data, 3);
#line 488
  val = tmp;
  }
#line 489
  return (val % n);
}
}
#line 493 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 496
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 506 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 509
  tuning = table->tuning;
#line 511
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 512
    return ((_Bool)1);
  }
#line 519
  epsilon = 0.1f;
#line 521
  if (epsilon < (float )tuning->growth_threshold) {
#line 521
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 521
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 521
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 521
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 521
            if (tuning->shrink_factor <= (float const   )1) {
#line 521
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 528
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 530
  table->tuning = & default_tuning;
#line 531
  return ((_Bool)0);
}
}
#line 538 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static size_t compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 541
  if (! tuning->is_n_buckets) {
#line 543
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 544
    if ((float )4294967295U <= new_candidate) {
#line 545
      return ((size_t )0);
    }
#line 546
    candidate = (size_t )new_candidate;
  }
  {
#line 548
  candidate = next_prime(candidate);
  }
#line 549
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 549
    tmp = -1;
  } else {
#line 549
    tmp = -2;
  }
#line 549
  if ((unsigned long )((size_t )tmp) / sizeof(struct hash_entry *) < (unsigned long )candidate) {
#line 550
    return ((size_t )0);
  }
#line 551
  return (candidate);
}
}
#line 588 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;

  {
#line 595
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 596
    hasher = & raw_hasher;
  }
#line 597
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 598
    comparator = & raw_comparator;
  }
  {
#line 600
  tmp = malloc((size_t )sizeof(*table));
#line 600
  table = (Hash_table *)tmp;
  }
#line 601
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 602
    return ((Hash_table *)((void *)0));
  }
#line 604
  if (! tuning) {
#line 605
    tuning = & default_tuning;
  }
  {
#line 606
  table->tuning = tuning;
#line 607
  tmp___0 = check_tuning(table);
  }
#line 607
  if (! tmp___0) {
#line 614
    goto fail;
  }
  {
#line 617
  table->n_buckets = compute_bucket_size(candidate, tuning);
  }
#line 618
  if (! table->n_buckets) {
#line 619
    goto fail;
  }
  {
#line 621
  tmp___1 = calloc(table->n_buckets, (size_t )sizeof(*(table->bucket)));
#line 621
  table->bucket = (struct hash_entry *)tmp___1;
  }
#line 622
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 623
    goto fail;
  }
#line 624
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 625
  table->n_buckets_used = (size_t )0;
#line 626
  table->n_entries = (size_t )0;
#line 628
  table->hasher = hasher;
#line 629
  table->comparator = comparator;
#line 630
  table->data_freer = data_freer;
#line 632
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 636
  return (table);
  fail: 
  {
#line 639
  free((void *)table);
  }
#line 640
  return ((Hash_table *)((void *)0));
}
}
#line 647 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 652
  bucket = table->bucket;
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 652
      goto while_break;
    }
#line 654
    if (bucket->data) {
#line 660
      cursor = bucket->next;
      {
#line 660
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 660
        if (! cursor) {
#line 660
          goto while_break___0;
        }
#line 662
        if (table->data_freer) {
          {
#line 663
          (*(table->data_freer))(cursor->data);
          }
        }
#line 664
        cursor->data = (void *)0;
#line 666
        next = cursor->next;
#line 669
        cursor->next = table->free_entry_list;
#line 670
        table->free_entry_list = cursor;
#line 660
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 674
      if (table->data_freer) {
        {
#line 675
        (*(table->data_freer))(bucket->data);
        }
      }
#line 676
      bucket->data = (void *)0;
#line 677
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 652
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 681
  table->n_buckets_used = (size_t )0;
#line 682
  table->n_entries = (size_t )0;
#line 683
  return;
}
}
#line 690 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 698
  if (table->data_freer) {
#line 698
    if (table->n_entries) {
#line 700
      bucket = table->bucket;
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
#line 700
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 700
          goto while_break;
        }
#line 702
        if (bucket->data) {
#line 704
          cursor = bucket;
          {
#line 704
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 704
            if (! cursor) {
#line 704
              goto while_break___0;
            }
            {
#line 705
            (*(table->data_freer))(cursor->data);
#line 704
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 700
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 717
  bucket = table->bucket;
  {
#line 717
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 717
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 717
      goto while_break___1;
    }
#line 719
    cursor = bucket->next;
    {
#line 719
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 719
      if (! cursor) {
#line 719
        goto while_break___2;
      }
      {
#line 721
      next = cursor->next;
#line 722
      free((void *)cursor);
#line 719
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 717
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 727
  cursor = table->free_entry_list;
  {
#line 727
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 727
    if (! cursor) {
#line 727
      goto while_break___3;
    }
    {
#line 729
    next = cursor->next;
#line 730
    free((void *)cursor);
#line 727
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 736
  free((void *)table->bucket);
#line 737
  free((void *)table);
  }
#line 738
  return;
}
}
#line 745 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 750
  if (table->free_entry_list) {
#line 752
    new = table->free_entry_list;
#line 753
    table->free_entry_list = new->next;
  } else {
    {
#line 760
    tmp = malloc((size_t )sizeof(*new));
#line 760
    new = (struct hash_entry *)tmp;
    }
  }
#line 764
  return (new);
}
}
#line 770 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 773
  entry->data = (void *)0;
#line 774
  entry->next = table->free_entry_list;
#line 775
  table->free_entry_list = entry;
#line 776
  return;
}
}
#line 784 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  size_t tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 788
  tmp = (*(table->hasher))(entry, table->n_buckets);
#line 788
  bucket = table->bucket + tmp;
  }
#line 792
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 793
    abort();
    }
  }
#line 795
  *bucket_head = bucket;
#line 798
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 799
    return ((void *)0);
  }
#line 802
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 802
    goto _L;
  } else {
    {
#line 802
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
    }
#line 802
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 804
      data = bucket->data;
#line 806
      if (delete) {
#line 808
        if (bucket->next) {
          {
#line 810
          next = bucket->next;
#line 814
          *bucket = *next;
#line 815
          free_entry(table, next);
          }
        } else {
#line 819
          bucket->data = (void *)0;
        }
      }
#line 823
      return (data);
    }
  }
#line 827
  cursor = bucket;
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! cursor->next) {
#line 827
      goto while_break;
    }
#line 829
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 829
      goto _L___0;
    } else {
      {
#line 829
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
      }
#line 829
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 832
        data___0 = (cursor->next)->data;
#line 834
        if (delete) {
          {
#line 836
          next___0 = cursor->next;
#line 840
          cursor->next = next___0->next;
#line 841
          free_entry(table, next___0);
          }
        }
#line 844
        return (data___0);
      }
    }
#line 827
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 849
  return ((void *)0);
}
}
#line 858 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  size_t tmp ;
  size_t tmp___0 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___1 ;

  {
#line 864
  bucket = src->bucket;
  {
#line 864
  while (1) {
    while_continue: /* CIL Label */ ;
#line 864
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 864
      goto while_break;
    }
#line 865
    if (bucket->data) {
#line 876
      cursor = bucket->next;
      {
#line 876
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 876
        if (! cursor) {
#line 876
          goto while_break___0;
        }
        {
#line 878
        data = cursor->data;
#line 879
        tmp = (*(dst->hasher))((void const   *)data, dst->n_buckets);
#line 879
        new_bucket = dst->bucket + tmp;
        }
#line 881
        if (! ((unsigned long )new_bucket < (unsigned long )dst->bucket_limit)) {
          {
#line 882
          abort();
          }
        }
#line 884
        next = cursor->next;
#line 886
        if (new_bucket->data) {
#line 890
          cursor->next = new_bucket->next;
#line 891
          new_bucket->next = cursor;
        } else {
          {
#line 897
          new_bucket->data = data;
#line 898
          (dst->n_buckets_used) ++;
#line 899
          free_entry(dst, cursor);
          }
        }
#line 876
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 905
      data = bucket->data;
#line 906
      bucket->next = (struct hash_entry *)((void *)0);
#line 907
      if (safe) {
#line 908
        goto __Cont;
      }
      {
#line 909
      tmp___0 = (*(dst->hasher))((void const   *)data, dst->n_buckets);
#line 909
      new_bucket = dst->bucket + tmp___0;
      }
#line 911
      if (! ((unsigned long )new_bucket < (unsigned long )dst->bucket_limit)) {
        {
#line 912
        abort();
        }
      }
#line 914
      if (new_bucket->data) {
        {
#line 918
        tmp___1 = allocate_entry(dst);
#line 918
        new_entry = tmp___1;
        }
#line 920
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 921
          return ((_Bool)0);
        }
#line 923
        new_entry->data = data;
#line 924
        new_entry->next = new_bucket->next;
#line 925
        new_bucket->next = new_entry;
      } else {
#line 930
        new_bucket->data = data;
#line 931
        (dst->n_buckets_used) ++;
      }
#line 933
      bucket->data = (void *)0;
#line 934
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 864
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return ((_Bool)1);
}
}
#line 947 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  void *__cil_tmp11 ;

  {
  {
#line 952
  tmp = compute_bucket_size(candidate, table->tuning);
#line 952
  new_size = tmp;
  }
#line 954
  if (! new_size) {
#line 955
    return ((_Bool)0);
  }
#line 956
  if (new_size == table->n_buckets) {
#line 957
    return ((_Bool)1);
  }
  {
#line 958
  new_table = & storage;
#line 959
  tmp___0 = calloc(new_size, (size_t )sizeof(*(new_table->bucket)));
#line 959
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 960
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 961
    return ((_Bool)0);
  }
  {
#line 962
  new_table->n_buckets = new_size;
#line 963
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 964
  new_table->n_buckets_used = (size_t )0;
#line 965
  new_table->n_entries = (size_t )0;
#line 966
  new_table->tuning = table->tuning;
#line 967
  new_table->hasher = table->hasher;
#line 968
  new_table->comparator = table->comparator;
#line 969
  new_table->data_freer = table->data_freer;
#line 989
  new_table->free_entry_list = table->free_entry_list;
#line 991
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
  }
#line 991
  if (tmp___1) {
    {
#line 994
    free((void *)table->bucket);
#line 995
    table->bucket = new_table->bucket;
#line 996
    table->bucket_limit = new_table->bucket_limit;
#line 997
    table->n_buckets = new_table->n_buckets;
#line 998
    table->n_buckets_used = new_table->n_buckets_used;
#line 999
    table->free_entry_list = new_table->free_entry_list;
    }
#line 1001
    return ((_Bool)1);
  }
  {
#line 1017
  table->free_entry_list = new_table->free_entry_list;
#line 1018
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
  }
#line 1018
  if (tmp___2) {
    {
#line 1018
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
    }
#line 1018
    if (! tmp___3) {
      {
#line 1020
      abort();
      }
    }
  } else {
    {
#line 1020
    abort();
    }
  }
  {
#line 1022
  free((void *)new_table->bucket);
  }
#line 1023
  return ((_Bool)0);
}
}
#line 1032 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1039
  if (! entry) {
    {
#line 1040
    abort();
    }
  }
  {
#line 1043
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 1043
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1044
    return (data);
  }
#line 1051
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 1056
    check_tuning(table);
    }
#line 1057
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1060
      tuning = table->tuning;
#line 1061
      if (tuning->is_n_buckets) {
#line 1061
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1061
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1061
      candidate = (float )tmp;
#line 1067
      if ((float )4294967295U <= candidate) {
#line 1068
        return ((void *)0);
      }
      {
#line 1071
      tmp___0 = hash_rehash(table, (size_t )candidate);
      }
#line 1071
      if (! tmp___0) {
#line 1072
        return ((void *)0);
      }
      {
#line 1075
      tmp___1 = hash_find_entry(table, entry, & bucket, (_Bool)0);
      }
#line 1075
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1076
        abort();
        }
      }
    }
  }
#line 1082
  if (bucket->data) {
    {
#line 1084
    tmp___2 = allocate_entry(table);
#line 1084
    new_entry = tmp___2;
    }
#line 1086
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1087
      return ((void *)0);
    }
#line 1091
    new_entry->data = (void *)entry;
#line 1092
    new_entry->next = bucket->next;
#line 1093
    bucket->next = new_entry;
#line 1094
    (table->n_entries) ++;
#line 1095
    return ((void *)entry);
  }
#line 1100
  bucket->data = (void *)entry;
#line 1101
  (table->n_entries) ++;
#line 1102
  (table->n_buckets_used) ++;
#line 1104
  return ((void *)entry);
}
}
#line 1111 "/home/ysko/Works/test-src/pies-1.2/gnu/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1117
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 1118
  if (! data) {
#line 1119
    return ((void *)0);
  }
#line 1121
  (table->n_entries) --;
#line 1122
  if (! bucket->data) {
#line 1124
    (table->n_buckets_used) --;
#line 1129
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1134
      check_tuning(table);
      }
#line 1135
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1138
        tuning = table->tuning;
#line 1139
        if (tuning->is_n_buckets) {
#line 1139
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1139
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1139
        candidate = (size_t )tmp;
#line 1145
        tmp___0 = hash_rehash(table, candidate);
        }
#line 1145
        if (! tmp___0) {
#line 1153
          cursor = table->free_entry_list;
          {
#line 1155
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1155
            if (! cursor) {
#line 1155
              goto while_break;
            }
            {
#line 1157
            next = cursor->next;
#line 1158
            free((void *)cursor);
#line 1159
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1161
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1168
  return (data);
}
}
#line 29 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_linked_list.h"
struct gl_list_implementation  const  gl_linked_list_implementation ;
#line 41 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_t gl_linked_create_empty(gl_list_implementation_t implementation ,
                                        _Bool (*equals_fn)(void const   *elt1 , void const   *elt2 ) ,
                                        size_t (*hashcode_fn)(void const   *elt ) ,
                                        void (*dispose_fn)(void const   *elt ) , _Bool allow_duplicates ) 
{ 
  struct gl_list_impl *list ;
  void *tmp ;

  {
  {
#line 48
  tmp = xmalloc((size_t )sizeof(struct gl_list_impl ));
#line 48
  list = (struct gl_list_impl *)tmp;
#line 50
  list->base.vtable = implementation;
#line 51
  list->base.equals_fn = equals_fn;
#line 52
  list->base.hashcode_fn = hashcode_fn;
#line 53
  list->base.dispose_fn = dispose_fn;
#line 54
  list->base.allow_duplicates = allow_duplicates;
#line 59
  list->root.next = & list->root;
#line 60
  list->root.prev = & list->root;
#line 61
  list->count = (size_t )0;
  }
#line 63
  return (list);
}
}
#line 66 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_t gl_linked_create(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                               void const   *elt2 ) ,
                                  size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                                  _Bool allow_duplicates , size_t count , void const   **contents ) 
{ 
  struct gl_list_impl *list ;
  void *tmp ;
  gl_list_node_t tail ;
  gl_list_node_t node ;
  void *tmp___0 ;

  {
  {
#line 74
  tmp = xmalloc((size_t )sizeof(struct gl_list_impl ));
#line 74
  list = (struct gl_list_impl *)tmp;
#line 77
  list->base.vtable = implementation;
#line 78
  list->base.equals_fn = equals_fn;
#line 79
  list->base.hashcode_fn = hashcode_fn;
#line 80
  list->base.dispose_fn = dispose_fn;
#line 81
  list->base.allow_duplicates = allow_duplicates;
#line 91
  list->count = count;
#line 92
  tail = & list->root;
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (count > 0U)) {
#line 93
      goto while_break;
    }
    {
#line 95
    tmp___0 = xmalloc((size_t )sizeof(struct gl_list_node_impl ));
#line 95
    node = (struct gl_list_node_impl *)tmp___0;
#line 97
    node->value = *contents;
#line 109
    node->prev = tail;
#line 110
    tail->next = node;
#line 111
    tail = node;
#line 93
    contents ++;
#line 93
    count --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  tail->next = & list->root;
#line 114
  list->root.prev = tail;
#line 116
  return (list);
}
}
#line 119 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static size_t gl_linked_size(gl_list_t list ) 
{ 


  {
#line 122
  return (list->count);
}
}
#line 125 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static void const   *gl_linked_node_value(gl_list_t list , gl_list_node_t node ) 
{ 


  {
#line 128
  return (node->value);
}
}
#line 131 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static void gl_linked_node_set_value(gl_list_t list , gl_list_node_t node , void const   *elt ) 
{ 


  {
#line 153
  node->value = elt;
#line 155
  return;
}
}
#line 157 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_next_node(gl_list_t list , gl_list_node_t node ) 
{ 
  struct gl_list_node_impl *tmp ;

  {
#line 160
  if ((unsigned long )node->next != (unsigned long )(& list->root)) {
#line 160
    tmp = node->next;
  } else {
#line 160
    tmp = (struct gl_list_node_impl *)((void *)0);
  }
#line 160
  return (tmp);
}
}
#line 163 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_previous_node(gl_list_t list , gl_list_node_t node ) 
{ 
  struct gl_list_node_impl *tmp ;

  {
#line 166
  if ((unsigned long )node->prev != (unsigned long )(& list->root)) {
#line 166
    tmp = node->prev;
  } else {
#line 166
    tmp = (struct gl_list_node_impl *)((void *)0);
  }
#line 166
  return (tmp);
}
}
#line 169 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static void const   *gl_linked_get_at(gl_list_t list , size_t position ) 
{ 
  size_t count ;
  gl_list_node_t node ;

  {
#line 172
  count = list->count;
#line 175
  if (! (position < count)) {
    {
#line 177
    abort();
    }
  }
#line 179
  if (position <= (count - 1U) / 2U) {
#line 181
    node = list->root.next;
    {
#line 182
    while (1) {
      while_continue: /* CIL Label */ ;
#line 182
      if (! (position > 0U)) {
#line 182
        goto while_break;
      }
#line 183
      node = node->next;
#line 182
      position --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 187
    position = (count - 1U) - position;
#line 188
    node = list->root.prev;
    {
#line 189
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 189
      if (! (position > 0U)) {
#line 189
        goto while_break___0;
      }
#line 190
      node = node->prev;
#line 189
      position --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 192
  return (node->value);
}
}
#line 195 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_set_at(gl_list_t list , size_t position , void const   *elt ) 
{ 
  size_t count ;
  gl_list_node_t node ;

  {
#line 198
  count = list->count;
#line 201
  if (! (position < count)) {
    {
#line 203
    abort();
    }
  }
#line 205
  if (position <= (count - 1U) / 2U) {
#line 207
    node = list->root.next;
    {
#line 208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 208
      if (! (position > 0U)) {
#line 208
        goto while_break;
      }
#line 209
      node = node->next;
#line 208
      position --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 213
    position = (count - 1U) - position;
#line 214
    node = list->root.prev;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (! (position > 0U)) {
#line 215
        goto while_break___0;
      }
#line 216
      node = node->prev;
#line 215
      position --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 237
  node->value = elt;
#line 239
  return (node);
}
}
#line 242 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_search_from_to(gl_list_t list , size_t start_index ,
                                               size_t end_index , void const   *elt ) 
{ 
  size_t count ;
  _Bool (*equals)(void const   *elt1 , void const   *elt2 ) ;
  gl_list_node_t node ;
  _Bool tmp ;

  {
#line 246
  count = list->count;
#line 248
  if (start_index <= end_index) {
#line 248
    if (! (end_index <= count)) {
      {
#line 250
      abort();
      }
    }
  } else {
    {
#line 250
    abort();
    }
  }
#line 371
  equals = list->base.equals_fn;
#line 372
  node = list->root.next;
#line 374
  end_index -= start_index;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (start_index > 0U)) {
#line 375
      goto while_break;
    }
#line 376
    node = node->next;
#line 375
    start_index --;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  if ((unsigned long )equals != (unsigned long )((void *)0)) {
    {
#line 380
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 380
      if (! (end_index > 0U)) {
#line 380
        goto while_break___0;
      }
      {
#line 381
      tmp = (*equals)(elt, node->value);
      }
#line 381
      if (tmp) {
#line 382
        return (node);
      }
#line 380
      node = node->next;
#line 380
      end_index --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 386
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 386
      if (! (end_index > 0U)) {
#line 386
        goto while_break___1;
      }
#line 387
      if ((unsigned long )elt == (unsigned long )node->value) {
#line 388
        return (node);
      }
#line 386
      node = node->next;
#line 386
      end_index --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 390
  return ((gl_list_node_t )((void *)0));
}
}
#line 395 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static size_t gl_linked_indexof_from_to(gl_list_t list , size_t start_index , size_t end_index ,
                                        void const   *elt ) 
{ 
  size_t count ;
  _Bool (*equals)(void const   *elt1 , void const   *elt2 ) ;
  size_t index ;
  gl_list_node_t node ;
  _Bool tmp ;

  {
#line 399
  count = list->count;
#line 401
  if (start_index <= end_index) {
#line 401
    if (! (end_index <= count)) {
      {
#line 403
      abort();
      }
    }
  } else {
    {
#line 403
    abort();
    }
  }
#line 494
  equals = list->base.equals_fn;
#line 495
  index = start_index;
#line 496
  node = list->root.next;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (start_index > 0U)) {
#line 498
      goto while_break;
    }
#line 499
    node = node->next;
#line 498
    start_index --;
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  if ((unsigned long )equals != (unsigned long )((void *)0)) {
    {
#line 503
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 503
      if (! (index < end_index)) {
#line 503
        goto while_break___0;
      }
      {
#line 506
      tmp = (*equals)(elt, node->value);
      }
#line 506
      if (tmp) {
#line 507
        return (index);
      }
#line 503
      node = node->next;
#line 503
      index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 511
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 511
      if (! (index < end_index)) {
#line 511
        goto while_break___1;
      }
#line 514
      if ((unsigned long )elt == (unsigned long )node->value) {
#line 515
        return (index);
      }
#line 511
      node = node->next;
#line 511
      index ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 517
  return ((size_t )-1);
}
}
#line 522 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_add_first(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t node ;
  void *tmp ;

  {
  {
#line 525
  tmp = xmalloc((size_t )sizeof(struct gl_list_node_impl ));
#line 525
  node = (struct gl_list_node_impl *)tmp;
#line 527
  node->value = elt;
#line 539
  node->prev = & list->root;
#line 540
  node->next = list->root.next;
#line 541
  (node->next)->prev = node;
#line 542
  list->root.next = node;
#line 543
  (list->count) ++;
  }
#line 549
  return (node);
}
}
#line 552 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_add_last(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t node ;
  void *tmp ;

  {
  {
#line 555
  tmp = xmalloc((size_t )sizeof(struct gl_list_node_impl ));
#line 555
  node = (struct gl_list_node_impl *)tmp;
#line 557
  node->value = elt;
#line 569
  node->next = & list->root;
#line 570
  node->prev = list->root.prev;
#line 571
  (node->prev)->next = node;
#line 572
  list->root.prev = node;
#line 573
  (list->count) ++;
  }
#line 579
  return (node);
}
}
#line 582 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_add_before(gl_list_t list , gl_list_node_t node ,
                                           void const   *elt ) 
{ 
  gl_list_node_t new_node ;
  void *tmp ;

  {
  {
#line 585
  tmp = xmalloc((size_t )sizeof(struct gl_list_node_impl ));
#line 585
  new_node = (struct gl_list_node_impl *)tmp;
#line 587
  new_node->value = elt;
#line 599
  new_node->next = node;
#line 600
  new_node->prev = node->prev;
#line 601
  (new_node->prev)->next = new_node;
#line 602
  node->prev = new_node;
#line 603
  (list->count) ++;
  }
#line 609
  return (new_node);
}
}
#line 612 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_add_after(gl_list_t list , gl_list_node_t node , void const   *elt ) 
{ 
  gl_list_node_t new_node ;
  void *tmp ;

  {
  {
#line 615
  tmp = xmalloc((size_t )sizeof(struct gl_list_node_impl ));
#line 615
  new_node = (struct gl_list_node_impl *)tmp;
#line 617
  new_node->value = elt;
#line 629
  new_node->prev = node;
#line 630
  new_node->next = node->next;
#line 631
  (new_node->next)->prev = new_node;
#line 632
  node->next = new_node;
#line 633
  (list->count) ++;
  }
#line 639
  return (new_node);
}
}
#line 642 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_add_at(gl_list_t list , size_t position , void const   *elt ) 
{ 
  size_t count ;
  gl_list_node_t new_node ;
  void *tmp ;
  gl_list_node_t node ;
  gl_list_node_t node___0 ;

  {
#line 645
  count = list->count;
#line 648
  if (! (position <= count)) {
    {
#line 650
    abort();
    }
  }
  {
#line 652
  tmp = xmalloc((size_t )sizeof(struct gl_list_node_impl ));
#line 652
  new_node = (struct gl_list_node_impl *)tmp;
#line 653
  new_node->value = elt;
  }
#line 665
  if (position <= count / 2U) {
#line 669
    node = & list->root;
    {
#line 670
    while (1) {
      while_continue: /* CIL Label */ ;
#line 670
      if (! (position > 0U)) {
#line 670
        goto while_break;
      }
#line 671
      node = node->next;
#line 670
      position --;
    }
    while_break: /* CIL Label */ ;
    }
#line 672
    new_node->prev = node;
#line 673
    new_node->next = node->next;
#line 674
    (new_node->next)->prev = new_node;
#line 675
    node->next = new_node;
  } else {
#line 681
    position = count - position;
#line 682
    node___0 = & list->root;
    {
#line 683
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 683
      if (! (position > 0U)) {
#line 683
        goto while_break___0;
      }
#line 684
      node___0 = node___0->prev;
#line 683
      position --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 685
    new_node->next = node___0;
#line 686
    new_node->prev = node___0->prev;
#line 687
    (new_node->prev)->next = new_node;
#line 688
    node___0->prev = new_node;
  }
#line 690
  (list->count) ++;
#line 696
  return (new_node);
}
}
#line 699 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static _Bool gl_linked_remove_node(gl_list_t list , gl_list_node_t node ) 
{ 
  gl_list_node_t prev ;
  gl_list_node_t next ;

  {
#line 711
  prev = node->prev;
#line 712
  next = node->next;
#line 714
  prev->next = next;
#line 715
  next->prev = prev;
#line 716
  (list->count) --;
#line 718
  if ((unsigned long )list->base.dispose_fn != (unsigned long )((void *)0)) {
    {
#line 719
    (*(list->base.dispose_fn))(node->value);
    }
  }
  {
#line 720
  free((void *)node);
  }
#line 721
  return ((_Bool)1);
}
}
#line 724 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static _Bool gl_linked_remove_at(gl_list_t list , size_t position ) 
{ 
  size_t count ;
  gl_list_node_t removed_node ;
  gl_list_node_t node ;
  gl_list_node_t after_removed ;
  gl_list_node_t node___0 ;
  gl_list_node_t before_removed ;

  {
#line 727
  count = list->count;
#line 730
  if (! (position < count)) {
    {
#line 732
    abort();
    }
  }
#line 734
  if (position <= (count - 1U) / 2U) {
#line 739
    node = & list->root;
    {
#line 740
    while (1) {
      while_continue: /* CIL Label */ ;
#line 740
      if (! (position > 0U)) {
#line 740
        goto while_break;
      }
#line 741
      node = node->next;
#line 740
      position --;
    }
    while_break: /* CIL Label */ ;
    }
#line 742
    removed_node = node->next;
#line 743
    after_removed = (node->next)->next;
#line 744
    node->next = after_removed;
#line 745
    after_removed->prev = node;
  } else {
#line 752
    position = (count - 1U) - position;
#line 753
    node___0 = & list->root;
    {
#line 754
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 754
      if (! (position > 0U)) {
#line 754
        goto while_break___0;
      }
#line 755
      node___0 = node___0->prev;
#line 754
      position --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 756
    removed_node = node___0->prev;
#line 757
    before_removed = (node___0->prev)->prev;
#line 758
    node___0->prev = before_removed;
#line 759
    before_removed->next = node___0;
  }
#line 764
  (list->count) --;
#line 766
  if ((unsigned long )list->base.dispose_fn != (unsigned long )((void *)0)) {
    {
#line 767
    (*(list->base.dispose_fn))(removed_node->value);
    }
  }
  {
#line 768
  free((void *)removed_node);
  }
#line 769
  return ((_Bool)1);
}
}
#line 772 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static _Bool gl_linked_remove(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t node ;
  gl_list_node_t tmp ;
  _Bool tmp___0 ;

  {
  {
#line 775
  tmp = gl_linked_search_from_to(list, (size_t )0, list->count, elt);
#line 775
  node = tmp;
  }
#line 777
  if ((unsigned long )node != (unsigned long )((void *)0)) {
    {
#line 778
    tmp___0 = gl_linked_remove_node(list, node);
    }
#line 778
    return (tmp___0);
  } else {
#line 780
    return ((_Bool)0);
  }
}
}
#line 783 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static void gl_linked_list_free(gl_list_t list ) 
{ 
  void (*dispose)(void const   *elt ) ;
  gl_list_node_t node ;
  gl_list_node_t next ;

  {
#line 786
  dispose = list->base.dispose_fn;
#line 789
  node = list->root.next;
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 789
      goto while_break;
    }
#line 791
    next = node->next;
#line 792
    if ((unsigned long )dispose != (unsigned long )((void *)0)) {
      {
#line 793
      (*dispose)(node->value);
      }
    }
    {
#line 794
    free((void *)node);
#line 795
    node = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 800
  free((void *)list);
  }
#line 801
  return;
}
}
#line 805 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_iterator_t gl_linked_iterator(gl_list_t list ) 
{ 
  gl_list_iterator_t result ;
  void *__cil_tmp3 ;

  {
#line 810
  result.vtable = list->base.vtable;
#line 811
  result.list = list;
#line 812
  result.p = (void *)list->root.next;
#line 813
  result.q = (void *)(& list->root);
#line 820
  return (result);
}
}
#line 823 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_iterator_t gl_linked_iterator_from_to(gl_list_t list , size_t start_index ,
                                                     size_t end_index ) 
{ 
  gl_list_iterator_t result ;
  size_t n1 ;
  size_t n2 ;
  size_t n3 ;
  gl_list_node_t node ;
  size_t i ;
  gl_list_node_t node___0 ;
  size_t i___0 ;
  gl_list_node_t node___1 ;
  size_t i___1 ;
  void *__cil_tmp14 ;

  {
#line 830
  if (start_index <= end_index) {
#line 830
    if (! (end_index <= list->count)) {
      {
#line 832
      abort();
      }
    }
  } else {
    {
#line 832
    abort();
    }
  }
#line 833
  result.vtable = list->base.vtable;
#line 834
  result.list = list;
#line 835
  n1 = start_index;
#line 836
  n2 = end_index - start_index;
#line 837
  n3 = list->count - end_index;
#line 840
  if (n1 > n2) {
#line 840
    if (n1 > n3) {
#line 846
      node = & list->root;
#line 847
      i = n3;
      {
#line 847
      while (1) {
        while_continue: /* CIL Label */ ;
#line 847
        if (! (i > 0U)) {
#line 847
          goto while_break;
        }
#line 848
        node = node->prev;
#line 847
        i --;
      }
      while_break: /* CIL Label */ ;
      }
#line 849
      result.q = (void *)node;
#line 850
      i = n2;
      {
#line 850
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 850
        if (! (i > 0U)) {
#line 850
          goto while_break___0;
        }
#line 851
        node = node->prev;
#line 850
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 852
      result.p = (void *)node;
    } else {
#line 840
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 854
  if (n2 > n3) {
#line 860
    node___0 = list->root.next;
#line 861
    i___0 = n1;
    {
#line 861
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 861
      if (! (i___0 > 0U)) {
#line 861
        goto while_break___1;
      }
#line 862
      node___0 = node___0->next;
#line 861
      i___0 --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 863
    result.p = (void *)node___0;
#line 865
    node___0 = & list->root;
#line 866
    i___0 = n3;
    {
#line 866
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 866
      if (! (i___0 > 0U)) {
#line 866
        goto while_break___2;
      }
#line 867
      node___0 = node___0->prev;
#line 866
      i___0 --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 868
    result.q = (void *)node___0;
  } else {
#line 876
    node___1 = list->root.next;
#line 877
    i___1 = n1;
    {
#line 877
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 877
      if (! (i___1 > 0U)) {
#line 877
        goto while_break___3;
      }
#line 878
      node___1 = node___1->next;
#line 877
      i___1 --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 879
    result.p = (void *)node___1;
#line 880
    i___1 = n2;
    {
#line 880
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 880
      if (! (i___1 > 0U)) {
#line 880
        goto while_break___4;
      }
#line 881
      node___1 = node___1->next;
#line 880
      i___1 --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 882
    result.q = (void *)node___1;
  }
#line 891
  return (result);
}
}
#line 894 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static _Bool gl_linked_iterator_next(gl_list_iterator_t *iterator , void const   **eltp ,
                                     gl_list_node_t *nodep ) 
{ 
  gl_list_node_t node ;

  {
#line 898
  if ((unsigned long )iterator->p != (unsigned long )iterator->q) {
#line 900
    node = (gl_list_node_t )iterator->p;
#line 901
    *eltp = node->value;
#line 902
    if ((unsigned long )nodep != (unsigned long )((void *)0)) {
#line 903
      *nodep = node;
    }
#line 904
    iterator->p = (void *)node->next;
#line 905
    return ((_Bool)1);
  } else {
#line 908
    return ((_Bool)0);
  }
}
}
#line 911 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static void gl_linked_iterator_free(gl_list_iterator_t *iterator ) 
{ 


  {
#line 914
  return;
}
}
#line 918 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_sortedlist_search(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                 void const   *elt2 ) ,
                                                  void const   *elt ) 
{ 
  gl_list_node_t node ;
  int cmp ;
  int tmp ;

  {
#line 924
  node = list->root.next;
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 924
      goto while_break;
    }
    {
#line 926
    tmp = (*compar)(node->value, elt);
#line 926
    cmp = tmp;
    }
#line 928
    if (cmp > 0) {
#line 929
      goto while_break;
    }
#line 930
    if (cmp == 0) {
#line 931
      return (node);
    }
#line 924
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 933
  return ((gl_list_node_t )((void *)0));
}
}
#line 936 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_sortedlist_search_from_to(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                         void const   *elt2 ) ,
                                                          size_t low , size_t high ,
                                                          void const   *elt ) 
{ 
  size_t count ;
  size_t position ;
  gl_list_node_t node ;
  int cmp ;
  int tmp ;

  {
#line 942
  count = list->count;
#line 944
  if (low <= high) {
#line 944
    if (! (high <= list->count)) {
      {
#line 946
      abort();
      }
    }
  } else {
    {
#line 946
    abort();
    }
  }
#line 948
  high -= low;
#line 949
  if (high > 0U) {
#line 952
    position = low;
#line 955
    if (position <= (count - 1U) / 2U) {
#line 957
      node = list->root.next;
      {
#line 958
      while (1) {
        while_continue: /* CIL Label */ ;
#line 958
        if (! (position > 0U)) {
#line 958
          goto while_break;
        }
#line 959
        node = node->next;
#line 958
        position --;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 963
      position = (count - 1U) - position;
#line 964
      node = list->root.prev;
      {
#line 965
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 965
        if (! (position > 0U)) {
#line 965
          goto while_break___0;
        }
#line 966
        node = node->prev;
#line 965
        position --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 969
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 971
      tmp = (*compar)(node->value, elt);
#line 971
      cmp = tmp;
      }
#line 973
      if (cmp > 0) {
#line 974
        goto while_break___1;
      }
#line 975
      if (cmp == 0) {
#line 976
        return (node);
      }
#line 977
      node = node->next;
#line 969
      high --;
#line 969
      if (! (high > 0U)) {
#line 969
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 981
  return ((gl_list_node_t )((void *)0));
}
}
#line 984 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static size_t gl_linked_sortedlist_indexof(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                          void const   *elt2 ) ,
                                           void const   *elt ) 
{ 
  gl_list_node_t node ;
  size_t index ;
  int cmp ;
  int tmp ;

  {
#line 991
  node = list->root.next;
#line 991
  index = (size_t )0;
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 991
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 991
      goto while_break;
    }
    {
#line 995
    tmp = (*compar)(node->value, elt);
#line 995
    cmp = tmp;
    }
#line 997
    if (cmp > 0) {
#line 998
      goto while_break;
    }
#line 999
    if (cmp == 0) {
#line 1000
      return (index);
    }
#line 991
    node = node->next;
#line 991
    index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1002
  return ((size_t )-1);
}
}
#line 1005 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static size_t gl_linked_sortedlist_indexof_from_to(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                  void const   *elt2 ) ,
                                                   size_t low , size_t high , void const   *elt ) 
{ 
  size_t count ;
  size_t index ;
  size_t position ;
  gl_list_node_t node ;
  int cmp ;
  int tmp ;

  {
#line 1011
  count = list->count;
#line 1013
  if (low <= high) {
#line 1013
    if (! (high <= list->count)) {
      {
#line 1015
      abort();
      }
    }
  } else {
    {
#line 1015
    abort();
    }
  }
#line 1017
  high -= low;
#line 1018
  if (high > 0U) {
#line 1021
    index = low;
#line 1022
    position = low;
#line 1025
    if (position <= (count - 1U) / 2U) {
#line 1027
      node = list->root.next;
      {
#line 1028
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1028
        if (! (position > 0U)) {
#line 1028
          goto while_break;
        }
#line 1029
        node = node->next;
#line 1028
        position --;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1033
      position = (count - 1U) - position;
#line 1034
      node = list->root.prev;
      {
#line 1035
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1035
        if (! (position > 0U)) {
#line 1035
          goto while_break___0;
        }
#line 1036
        node = node->prev;
#line 1035
        position --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1039
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1041
      tmp = (*compar)(node->value, elt);
#line 1041
      cmp = tmp;
      }
#line 1043
      if (cmp > 0) {
#line 1044
        goto while_break___1;
      }
#line 1045
      if (cmp == 0) {
#line 1046
        return (index);
      }
#line 1047
      node = node->next;
#line 1048
      index ++;
#line 1039
      high --;
#line 1039
      if (! (high > 0U)) {
#line 1039
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1052
  return ((size_t )-1);
}
}
#line 1055 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static gl_list_node_t gl_linked_sortedlist_add(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                              void const   *elt2 ) ,
                                               void const   *elt ) 
{ 
  gl_list_node_t node ;
  gl_list_node_t tmp ;
  int tmp___0 ;
  gl_list_node_t tmp___1 ;

  {
#line 1061
  node = list->root.next;
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1061
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 1061
      goto while_break;
    }
    {
#line 1062
    tmp___0 = (*compar)(node->value, elt);
    }
#line 1062
    if (tmp___0 >= 0) {
      {
#line 1063
      tmp = gl_linked_add_before(list, node, elt);
      }
#line 1063
      return (tmp);
    }
#line 1061
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1064
  tmp___1 = gl_linked_add_last(list, elt);
  }
#line 1064
  return (tmp___1);
}
}
#line 1067 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_anylinked_list2.h"
static _Bool gl_linked_sortedlist_remove(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                        void const   *elt2 ) ,
                                         void const   *elt ) 
{ 
  gl_list_node_t node ;
  int cmp ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 1073
  node = list->root.next;
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    if (! ((unsigned long )node != (unsigned long )(& list->root))) {
#line 1073
      goto while_break;
    }
    {
#line 1075
    tmp = (*compar)(node->value, elt);
#line 1075
    cmp = tmp;
    }
#line 1077
    if (cmp > 0) {
#line 1078
      goto while_break;
    }
#line 1079
    if (cmp == 0) {
      {
#line 1080
      tmp___0 = gl_linked_remove_node(list, node);
      }
#line 1080
      return (tmp___0);
    }
#line 1073
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1082
  return ((_Bool)0);
}
}
#line 36 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_linked_list.c"
struct gl_list_implementation  const  gl_linked_list_implementation  = 
#line 36 "/home/ysko/Works/test-src/pies-1.2/gnu/gl_linked_list.c"
     {& gl_linked_create_empty, & gl_linked_create, & gl_linked_size, & gl_linked_node_value,
    & gl_linked_node_set_value, & gl_linked_next_node, & gl_linked_previous_node,
    & gl_linked_get_at, & gl_linked_set_at, & gl_linked_search_from_to, & gl_linked_indexof_from_to,
    & gl_linked_add_first, & gl_linked_add_last, & gl_linked_add_before, & gl_linked_add_after,
    & gl_linked_add_at, & gl_linked_remove_node, & gl_linked_remove_at, & gl_linked_remove,
    & gl_linked_list_free, & gl_linked_iterator, & gl_linked_iterator_from_to, & gl_linked_iterator_next,
    & gl_linked_iterator_free, & gl_linked_sortedlist_search, & gl_linked_sortedlist_search_from_to,
    & gl_linked_sortedlist_indexof, & gl_linked_sortedlist_indexof_from_to, & gl_linked_sortedlist_add,
    & gl_linked_sortedlist_remove};
#line 231 "./getopt.h"
 __attribute__((__nothrow__)) int rpl_getopt_long(int argc , char **argv , char const   *options___0 ,
                                                  struct rpl_option  const  *long_options ,
                                                  int *opt_index ) ;
#line 235
 __attribute__((__nothrow__)) int rpl_getopt_long_only(int argc , char **argv , char const   *options___0 ,
                                                       struct rpl_option  const  *long_options ,
                                                       int *opt_index ) ;
#line 26 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt_int.h"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) ;
#line 117
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , int posixly_correct , struct _getopt_data *d ) ;
#line 123
int _getopt_long_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 128
int _getopt_long_only_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 41 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt1.c"
 __attribute__((__nothrow__)) int rpl_getopt_long(int argc , char **argv , char const   *options___0 ,
                                                  struct rpl_option  const  *long_options ,
                                                  int *opt_index ) ;
#line 41 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt1.c"
int rpl_getopt_long(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                    int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = rpl_getopt_internal(argc, argv, options___0, long_options, opt_index, 0, 0);
  }
#line 45
  return (tmp);
}
}
#line 49 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt1.c"
int _getopt_long_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 54
  tmp = _getopt_internal_r(argc, argv, options___0, long_options, opt_index, 0, 0,
                           d);
  }
#line 54
  return (tmp);
}
}
#line 63
 __attribute__((__nothrow__)) int rpl_getopt_long_only(int argc , char **argv , char const   *options___0 ,
                                                       struct rpl_option  const  *long_options ,
                                                       int *opt_index ) ;
#line 63 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt1.c"
int rpl_getopt_long_only(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                         int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 68
  tmp = rpl_getopt_internal(argc, argv, options___0, long_options, opt_index, 1, 0);
  }
#line 68
  return (tmp);
}
}
#line 72 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt1.c"
int _getopt_long_only_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 77
  tmp = _getopt_internal_r(argc, argv, options___0, long_options, opt_index, 1, 0,
                           d);
  }
#line 77
  return (tmp);
}
}
#line 137 "./getopt.h"
char *rpl_optarg  ;
#line 151
int rpl_optind ;
#line 156
int rpl_opterr ;
#line 160
int rpl_optopt ;
#line 227
 __attribute__((__nothrow__)) int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 87 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt.c"
int rpl_optind  =    1;
#line 92 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt.c"
int rpl_opterr  =    1;
#line 98 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt.c"
int rpl_optopt  =    '?';
#line 102 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt.c"
static struct _getopt_data getopt_data  ;
#line 148 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ 
  int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
#line 151
  bottom = d->__first_nonopt;
#line 152
  middle = d->__last_nonopt;
#line 153
  top = d->rpl_optind;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (top > middle) {
#line 183
      if (! (middle > bottom)) {
#line 183
        goto while_break;
      }
    } else {
#line 183
      goto while_break;
    }
#line 185
    if (top - middle > middle - bottom) {
#line 188
      len = middle - bottom;
#line 192
      i = 0;
      {
#line 192
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 192
        if (! (i < len)) {
#line 192
          goto while_break___0;
        }
#line 194
        tem = *(argv + (bottom + i));
#line 195
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
#line 196
        *(argv + ((top - (middle - bottom)) + i)) = tem;
#line 192
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 200
      top -= len;
    } else {
#line 205
      len___0 = top - middle;
#line 209
      i___0 = 0;
      {
#line 209
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 209
        if (! (i___0 < len___0)) {
#line 209
          goto while_break___1;
        }
#line 211
        tem = *(argv + (bottom + i___0));
#line 212
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
#line 213
        *(argv + (middle + i___0)) = tem;
#line 209
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 217
      bottom += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
#line 224
  d->__last_nonopt = d->rpl_optind;
#line 225
  return;
}
}
#line 229 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt.c"
static char const   *_getopt_initialize(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                                        char const   *optstring , int posixly_correct ,
                                        struct _getopt_data *d ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 238
  tmp = d->rpl_optind;
#line 238
  d->__last_nonopt = tmp;
#line 238
  d->__first_nonopt = tmp;
#line 240
  d->__nextchar = (char *)((void *)0);
#line 242
  if (posixly_correct) {
#line 242
    tmp___1 = 1;
  } else {
    {
#line 242
    tmp___0 = getenv("POSIXLY_CORRECT");
    }
#line 242
    if (tmp___0) {
#line 242
      tmp___1 = 1;
    } else {
#line 242
      tmp___1 = 0;
    }
  }
#line 242
  d->__posixly_correct = tmp___1;
#line 246
  if ((int const   )*(optstring + 0) == 45) {
#line 248
    d->__ordering = (enum __anonenum___ordering_3 )2;
#line 249
    optstring ++;
  } else
#line 251
  if ((int const   )*(optstring + 0) == 43) {
#line 253
    d->__ordering = (enum __anonenum___ordering_3 )0;
#line 254
    optstring ++;
  } else
#line 256
  if (d->__posixly_correct) {
#line 257
    d->__ordering = (enum __anonenum___ordering_3 )0;
  } else {
#line 259
    d->__ordering = (enum __anonenum___ordering_3 )1;
  }
#line 291
  return (optstring);
}
}
#line 349 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt.c"
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , int posixly_correct , struct _getopt_data *d ) 
{ 
  int print_errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *nameend ;
  struct rpl_option  const  *p ;
  struct rpl_option  const  *pfound ;
  int exact ;
  int ambig ;
  int indfound ;
  int option_index ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char c ;
  char *tmp___18 ;
  char *temp ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *nameend___0 ;
  struct rpl_option  const  *p___0 ;
  struct rpl_option  const  *pfound___0 ;
  int exact___0 ;
  int ambig___0 ;
  int indfound___0 ;
  int option_index___0 ;
  char *tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  char *tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;

  {
#line 354
  print_errors = d->rpl_opterr;
#line 355
  if ((int const   )*(optstring + 0) == 58) {
#line 356
    print_errors = 0;
  }
#line 358
  if (argc < 1) {
#line 359
    return (-1);
  }
#line 361
  d->rpl_optarg = (char *)((void *)0);
#line 363
  if (d->rpl_optind == 0) {
#line 363
    goto _L;
  } else
#line 363
  if (! d->__initialized) {
    _L: /* CIL Label */ 
#line 365
    if (d->rpl_optind == 0) {
#line 366
      d->rpl_optind = 1;
    }
    {
#line 367
    optstring = _getopt_initialize(argc, argv, optstring, posixly_correct, d);
#line 369
    d->__initialized = 1;
    }
  }
#line 384
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
#line 384
    goto _L___3;
  } else
#line 384
  if ((int )*(d->__nextchar) == 0) {
    _L___3: /* CIL Label */ 
#line 390
    if (d->__last_nonopt > d->rpl_optind) {
#line 391
      d->__last_nonopt = d->rpl_optind;
    }
#line 392
    if (d->__first_nonopt > d->rpl_optind) {
#line 393
      d->__first_nonopt = d->rpl_optind;
    }
#line 395
    if ((unsigned int )d->__ordering == 1U) {
#line 400
      if (d->__first_nonopt != d->__last_nonopt) {
#line 400
        if (d->__last_nonopt != d->rpl_optind) {
          {
#line 402
          exchange(argv, d);
          }
        } else {
#line 400
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 403
      if (d->__last_nonopt != d->rpl_optind) {
#line 404
        d->__first_nonopt = d->rpl_optind;
      }
      {
#line 409
      while (1) {
        while_continue: /* CIL Label */ ;
#line 409
        if (d->rpl_optind < argc) {
#line 409
          if (! ((int )*(*(argv + d->rpl_optind) + 0) != 45)) {
#line 409
            if (! ((int )*(*(argv + d->rpl_optind) + 1) == 0)) {
#line 409
              goto while_break;
            }
          }
        } else {
#line 409
          goto while_break;
        }
#line 410
        (d->rpl_optind) ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 411
      d->__last_nonopt = d->rpl_optind;
    }
#line 419
    if (d->rpl_optind != argc) {
      {
#line 419
      tmp = strcmp((char const   *)*(argv + d->rpl_optind), "--");
      }
#line 419
      if (! tmp) {
#line 421
        (d->rpl_optind) ++;
#line 423
        if (d->__first_nonopt != d->__last_nonopt) {
#line 423
          if (d->__last_nonopt != d->rpl_optind) {
            {
#line 425
            exchange(argv, d);
            }
          } else {
#line 423
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 426
        if (d->__first_nonopt == d->__last_nonopt) {
#line 427
          d->__first_nonopt = d->rpl_optind;
        }
#line 428
        d->__last_nonopt = argc;
#line 430
        d->rpl_optind = argc;
      }
    }
#line 436
    if (d->rpl_optind == argc) {
#line 440
      if (d->__first_nonopt != d->__last_nonopt) {
#line 441
        d->rpl_optind = d->__first_nonopt;
      }
#line 442
      return (-1);
    }
#line 448
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
#line 448
      goto _L___2;
    } else
#line 448
    if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
      _L___2: /* CIL Label */ 
#line 450
      if ((unsigned int )d->__ordering == 0U) {
#line 451
        return (-1);
      }
#line 452
      tmp___0 = d->rpl_optind;
#line 452
      (d->rpl_optind) ++;
#line 452
      d->rpl_optarg = *(argv + tmp___0);
#line 453
      return (1);
    }
#line 459
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 459
      if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 459
        tmp___1 = 1;
      } else {
#line 459
        tmp___1 = 0;
      }
    } else {
#line 459
      tmp___1 = 0;
    }
#line 459
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + tmp___1;
  }
#line 478
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 478
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 478
      goto _L___6;
    } else
#line 478
    if (long_only) {
#line 478
      if (*(*(argv + d->rpl_optind) + 2)) {
#line 478
        goto _L___6;
      } else {
        {
#line 478
        tmp___17 = strchr(optstring, (int )*(*(argv + d->rpl_optind) + 1));
        }
#line 478
        if (! tmp___17) {
          _L___6: /* CIL Label */ 
#line 485
          pfound = (struct rpl_option  const  *)((void *)0);
#line 486
          exact = 0;
#line 487
          ambig = 0;
#line 488
          indfound = -1;
#line 491
          nameend = d->__nextchar;
          {
#line 491
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 491
            if (*nameend) {
#line 491
              if (! ((int )*nameend != 61)) {
#line 491
                goto while_break___0;
              }
            } else {
#line 491
              goto while_break___0;
            }
#line 491
            nameend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 496
          p = longopts;
#line 496
          option_index = 0;
          {
#line 496
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 496
            if (! p->name) {
#line 496
              goto while_break___1;
            }
            {
#line 497
            tmp___3 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                              (size_t )(nameend - d->__nextchar));
            }
#line 497
            if (! tmp___3) {
              {
#line 499
              tmp___2 = strlen((char const   *)p->name);
              }
#line 499
              if ((unsigned int )(nameend - d->__nextchar) == tmp___2) {
#line 503
                pfound = p;
#line 504
                indfound = option_index;
#line 505
                exact = 1;
#line 506
                goto while_break___1;
              } else
#line 508
              if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 511
                pfound = p;
#line 512
                indfound = option_index;
              } else
#line 514
              if (long_only) {
#line 519
                ambig = 1;
              } else
#line 514
              if (pfound->has_arg != p->has_arg) {
#line 519
                ambig = 1;
              } else
#line 514
              if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
#line 519
                ambig = 1;
              } else
#line 514
              if (pfound->val != p->val) {
#line 519
                ambig = 1;
              }
            }
#line 496
            p ++;
#line 496
            option_index ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 522
          if (ambig) {
#line 522
            if (! exact) {
#line 524
              if (print_errors) {
                {
#line 545
                tmp___4 = gettext("%s: option `%s\' is ambiguous\n");
#line 545
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
                        *(argv + 0), *(argv + d->rpl_optind));
                }
              }
              {
#line 549
              tmp___5 = strlen((char const   *)d->__nextchar);
#line 549
              d->__nextchar += tmp___5;
#line 550
              (d->rpl_optind) ++;
#line 551
              d->rpl_optopt = 0;
              }
#line 552
              return ('?');
            }
          }
#line 555
          if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 557
            option_index = indfound;
#line 558
            (d->rpl_optind) ++;
#line 559
            if (*nameend) {
#line 563
              if (pfound->has_arg) {
#line 564
                d->rpl_optarg = nameend + 1;
              } else {
#line 567
                if (print_errors) {
#line 574
                  if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
                    {
#line 582
                    tmp___6 = gettext("%s: option `--%s\' doesn\'t allow an argument\n");
#line 582
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                            *(argv + 0), pfound->name);
                    }
                  } else {
                    {
#line 596
                    tmp___7 = gettext("%s: option `%c%s\' doesn\'t allow an argument\n");
#line 596
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
                            *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                            pfound->name);
                    }
                  }
                }
                {
#line 622
                tmp___8 = strlen((char const   *)d->__nextchar);
#line 622
                d->__nextchar += tmp___8;
#line 624
                d->rpl_optopt = (int )pfound->val;
                }
#line 625
                return ('?');
              }
            } else
#line 628
            if (pfound->has_arg == 1) {
#line 630
              if (d->rpl_optind < argc) {
#line 631
                tmp___9 = d->rpl_optind;
#line 631
                (d->rpl_optind) ++;
#line 631
                d->rpl_optarg = *(argv + tmp___9);
              } else {
#line 634
                if (print_errors) {
                  {
#line 657
                  tmp___10 = gettext("%s: option `%s\' requires an argument\n");
#line 657
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
                          *(argv + 0), *(argv + (d->rpl_optind - 1)));
                  }
                }
                {
#line 662
                tmp___11 = strlen((char const   *)d->__nextchar);
#line 662
                d->__nextchar += tmp___11;
#line 663
                d->rpl_optopt = (int )pfound->val;
                }
#line 664
                if ((int const   )*(optstring + 0) == 58) {
#line 664
                  tmp___12 = ':';
                } else {
#line 664
                  tmp___12 = '?';
                }
#line 664
                return (tmp___12);
              }
            }
            {
#line 667
            tmp___13 = strlen((char const   *)d->__nextchar);
#line 667
            d->__nextchar += tmp___13;
            }
#line 668
            if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 669
              *longind = option_index;
            }
#line 670
            if (pfound->flag) {
#line 672
              *(pfound->flag) = (int )pfound->val;
#line 673
              return (0);
            }
#line 675
            return ((int )pfound->val);
          }
#line 682
          if (! long_only) {
#line 682
            goto _L___4;
          } else
#line 682
          if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 682
            goto _L___4;
          } else {
            {
#line 682
            tmp___16 = strchr(optstring, (int )*(d->__nextchar));
            }
#line 682
            if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
              _L___4: /* CIL Label */ 
#line 685
              if (print_errors) {
#line 692
                if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
                  {
#line 699
                  tmp___14 = gettext("%s: unrecognized option `--%s\'\n");
#line 699
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___14,
                          *(argv + 0), d->__nextchar);
                  }
                } else {
                  {
#line 710
                  tmp___15 = gettext("%s: unrecognized option `%c%s\'\n");
#line 710
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
                          *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0), d->__nextchar);
                  }
                }
              }
#line 732
              d->__nextchar = (char *)"";
#line 733
              (d->rpl_optind) ++;
#line 734
              d->rpl_optopt = 0;
#line 735
              return ('?');
            }
          }
        }
      }
    }
  }
  {
#line 742
  tmp___18 = d->__nextchar;
#line 742
  (d->__nextchar) ++;
#line 742
  c = *tmp___18;
#line 743
  tmp___19 = strchr(optstring, (int )c);
#line 743
  temp = tmp___19;
  }
#line 746
  if ((int )*(d->__nextchar) == 0) {
#line 747
    (d->rpl_optind) ++;
  }
#line 749
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 749
    goto _L___7;
  } else
#line 749
  if ((int )c == 58) {
    _L___7: /* CIL Label */ 
#line 751
    if (print_errors) {
#line 758
      if (d->__posixly_correct) {
        {
#line 765
        tmp___20 = gettext("%s: illegal option -- %c\n");
#line 765
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
                *(argv + 0), (int )c);
        }
      } else {
        {
#line 774
        tmp___21 = gettext("%s: invalid option -- %c\n");
#line 774
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
                *(argv + 0), (int )c);
        }
      }
    }
#line 795
    d->rpl_optopt = (int )c;
#line 796
    return ('?');
  }
#line 799
  if ((int )*(temp + 0) == 87) {
#line 799
    if ((int )*(temp + 1) == 59) {
#line 803
      pfound___0 = (struct rpl_option  const  *)((void *)0);
#line 804
      exact___0 = 0;
#line 805
      ambig___0 = 0;
#line 806
      indfound___0 = 0;
#line 810
      if ((int )*(d->__nextchar) != 0) {
#line 812
        d->rpl_optarg = d->__nextchar;
#line 815
        (d->rpl_optind) ++;
      } else
#line 817
      if (d->rpl_optind == argc) {
#line 819
        if (print_errors) {
          {
#line 842
          tmp___22 = gettext("%s: option requires an argument -- %c\n");
#line 842
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22,
                  *(argv + 0), (int )c);
          }
        }
#line 846
        d->rpl_optopt = (int )c;
#line 847
        if ((int const   )*(optstring + 0) == 58) {
#line 848
          c = (char )':';
        } else {
#line 850
          c = (char )'?';
        }
#line 851
        return ((int )c);
      } else {
#line 856
        tmp___23 = d->rpl_optind;
#line 856
        (d->rpl_optind) ++;
#line 856
        d->rpl_optarg = *(argv + tmp___23);
      }
#line 861
      nameend___0 = d->rpl_optarg;
#line 861
      d->__nextchar = nameend___0;
      {
#line 861
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 861
        if (*nameend___0) {
#line 861
          if (! ((int )*nameend___0 != 61)) {
#line 861
            goto while_break___2;
          }
        } else {
#line 861
          goto while_break___2;
        }
#line 861
        nameend___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 867
      p___0 = longopts;
#line 867
      option_index___0 = 0;
      {
#line 867
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 867
        if (! p___0->name) {
#line 867
          goto while_break___3;
        }
        {
#line 868
        tmp___25 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                           (size_t )(nameend___0 - d->__nextchar));
        }
#line 868
        if (! tmp___25) {
          {
#line 870
          tmp___24 = strlen((char const   *)p___0->name);
          }
#line 870
          if ((unsigned int )(nameend___0 - d->__nextchar) == tmp___24) {
#line 873
            pfound___0 = p___0;
#line 874
            indfound___0 = option_index___0;
#line 875
            exact___0 = 1;
#line 876
            goto while_break___3;
          } else
#line 878
          if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
#line 881
            pfound___0 = p___0;
#line 882
            indfound___0 = option_index___0;
          } else {
#line 886
            ambig___0 = 1;
          }
        }
#line 867
        p___0 ++;
#line 867
        option_index___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 888
      if (ambig___0) {
#line 888
        if (! exact___0) {
#line 890
          if (print_errors) {
            {
#line 911
            tmp___26 = gettext("%s: option `-W %s\' is ambiguous\n");
#line 911
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___26,
                    *(argv + 0), *(argv + d->rpl_optind));
            }
          }
          {
#line 915
          tmp___27 = strlen((char const   *)d->__nextchar);
#line 915
          d->__nextchar += tmp___27;
#line 916
          (d->rpl_optind) ++;
          }
#line 917
          return ('?');
        }
      }
#line 919
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
#line 921
        option_index___0 = indfound___0;
#line 922
        if (*nameend___0) {
#line 926
          if (pfound___0->has_arg) {
#line 927
            d->rpl_optarg = nameend___0 + 1;
          } else {
#line 930
            if (print_errors) {
              {
#line 953
              tmp___28 = gettext("%s: option `-W %s\' doesn\'t allow an argument\n");
#line 953
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___28,
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 959
            tmp___29 = strlen((char const   *)d->__nextchar);
#line 959
            d->__nextchar += tmp___29;
            }
#line 960
            return ('?');
          }
        } else
#line 963
        if (pfound___0->has_arg == 1) {
#line 965
          if (d->rpl_optind < argc) {
#line 966
            tmp___30 = d->rpl_optind;
#line 966
            (d->rpl_optind) ++;
#line 966
            d->rpl_optarg = *(argv + tmp___30);
          } else {
#line 969
            if (print_errors) {
              {
#line 992
              tmp___31 = gettext("%s: option `%s\' requires an argument\n");
#line 992
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___31,
                      *(argv + 0), *(argv + (d->rpl_optind - 1)));
              }
            }
            {
#line 997
            tmp___32 = strlen((char const   *)d->__nextchar);
#line 997
            d->__nextchar += tmp___32;
            }
#line 998
            if ((int const   )*(optstring + 0) == 58) {
#line 998
              tmp___33 = ':';
            } else {
#line 998
              tmp___33 = '?';
            }
#line 998
            return (tmp___33);
          }
        }
        {
#line 1001
        tmp___34 = strlen((char const   *)d->__nextchar);
#line 1001
        d->__nextchar += tmp___34;
        }
#line 1002
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 1003
          *longind = option_index___0;
        }
#line 1004
        if (pfound___0->flag) {
#line 1006
          *(pfound___0->flag) = (int )pfound___0->val;
#line 1007
          return (0);
        }
#line 1009
        return ((int )pfound___0->val);
      }
#line 1011
      d->__nextchar = (char *)((void *)0);
#line 1012
      return ('W');
    }
  }
#line 1014
  if ((int )*(temp + 1) == 58) {
#line 1016
    if ((int )*(temp + 2) == 58) {
#line 1019
      if ((int )*(d->__nextchar) != 0) {
#line 1021
        d->rpl_optarg = d->__nextchar;
#line 1022
        (d->rpl_optind) ++;
      } else {
#line 1025
        d->rpl_optarg = (char *)((void *)0);
      }
#line 1026
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1031
      if ((int )*(d->__nextchar) != 0) {
#line 1033
        d->rpl_optarg = d->__nextchar;
#line 1036
        (d->rpl_optind) ++;
      } else
#line 1038
      if (d->rpl_optind == argc) {
#line 1040
        if (print_errors) {
          {
#line 1063
          tmp___35 = gettext("%s: option requires an argument -- %c\n");
#line 1063
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___35,
                  *(argv + 0), (int )c);
          }
        }
#line 1068
        d->rpl_optopt = (int )c;
#line 1069
        if ((int const   )*(optstring + 0) == 58) {
#line 1070
          c = (char )':';
        } else {
#line 1072
          c = (char )'?';
        }
      } else {
#line 1077
        tmp___36 = d->rpl_optind;
#line 1077
        (d->rpl_optind) ++;
#line 1077
        d->rpl_optarg = *(argv + tmp___36);
      }
#line 1078
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1081
  return ((int )c);
}
}
#line 1085 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt.c"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) 
{ 
  int result ;

  {
  {
#line 1092
  getopt_data.rpl_optind = rpl_optind;
#line 1093
  getopt_data.rpl_opterr = rpl_opterr;
#line 1095
  result = _getopt_internal_r(argc, argv, optstring, longopts, longind, long_only,
                              posixly_correct, & getopt_data);
#line 1098
  rpl_optind = getopt_data.rpl_optind;
#line 1099
  rpl_optarg = getopt_data.rpl_optarg;
#line 1100
  rpl_optopt = getopt_data.rpl_optopt;
  }
#line 1102
  return (result);
}
}
#line 1113
 __attribute__((__nothrow__)) int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 1113 "/home/ysko/Works/test-src/pies-1.2/gnu/getopt.c"
int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 1116
  tmp = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option  const  *)((void *)0),
                            (int *)((void *)0), 0, 1);
  }
#line 1116
  return (tmp);
}
}
#line 37 "/home/ysko/Works/test-src/pies-1.2/gnu/ignore-value.h"
__inline static void ignore_value(int i ) 
{ 


  {
#line 37
  return;
}
}
#line 555 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 30 "/home/ysko/Works/test-src/pies-1.2/gnu/fprintftime.h"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) ;
#line 298 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.c"
static void fwrite_lowcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    tmp___0 = len;
#line 301
    len --;
#line 301
    if (! (tmp___0 > 0U)) {
#line 301
      goto while_break;
    }
    {
#line 303
    tmp = (int )tolower((int )((unsigned char )*src));
#line 303
    fputc(tmp, fp);
#line 304
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 308 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.c"
static void fwrite_uppcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    tmp___0 = len;
#line 311
    len --;
#line 311
    if (! (tmp___0 > 0U)) {
#line 311
      goto while_break;
    }
    {
#line 313
    tmp = (int )toupper((int )((unsigned char )*src));
#line 313
    fputc(tmp, fp);
#line 314
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 422 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.c"
static size_t strftime_case____0(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                                 int ut , int ns ) 
{ 
  size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i ;
  FILE *p ;
  char const   *f ;
  struct tm copy ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  size_t _i ;
  size_t _i___0 ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  size_t _i___5 ;
  size_t _i___6 ;
  size_t tmp___9 ;
  int century ;
  int tmp___10 ;
  int tmp___11 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___12 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___13 ;
  size_t _i___10 ;
  size_t _i___11 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___14 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___15 ;
  size_t _i___15 ;
  size_t _i___16 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___16 ;
  size_t _i___17 ;
  size_t _i___18 ;
  size_t tmp___17 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___18 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___19 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___20 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year ;
  int tmp___21 ;
  int year_adjust ;
  int days ;
  int tmp___22 ;
  int tmp___23 ;
  int d___0 ;
  int tmp___24 ;
  int tmp___25 ;
  int yy ;
  int tmp___26 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___27 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___28 ;
  size_t _i___23 ;
  size_t _i___24 ;
  size_t tmp___29 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___30 ;
  size_t _i___25 ;
  size_t _i___26 ;
  size_t tmp___31 ;
  void *__cil_tmp154 ;
  void *__cil_tmp155 ;
  void *__cil_tmp156 ;
  void *__cil_tmp157 ;
  void *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;

  {
#line 432
  maxsize = (size_t )-1;
#line 435
  hour12 = (int )tp->tm_hour;
#line 460
  i = (size_t )0;
#line 461
  p = s;
#line 472
  copy = *tp;
#line 473
  tp = (struct tm  const  *)(& copy);
#line 476
  zone = (char const   *)((void *)0);
#line 484
  zone = (char const   *)tp->tm_zone;
#line 502
  if (hour12 > 12) {
#line 503
    hour12 -= 12;
  } else
#line 505
  if (hour12 == 0) {
#line 506
    hour12 = 12;
  }
#line 508
  f = format;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! ((int const   )*f != 0)) {
#line 508
      goto while_break;
    }
#line 510
    pad = 0;
#line 512
    digits = 0;
#line 526
    width = -1;
#line 527
    to_lowcase = (_Bool)0;
#line 528
    to_uppcase = upcase;
#line 530
    change_case = (_Bool)0;
#line 613
    if ((int const   )*f != 37) {
      {
#line 615
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 615
        _n = 1;
#line 615
        _delta = width - _n;
#line 615
        if (_delta > 0) {
#line 615
          tmp = _delta;
        } else {
#line 615
          tmp = 0;
        }
#line 615
        _incr = _n + tmp;
#line 615
        if ((size_t )_incr >= maxsize - i) {
#line 615
          return ((size_t )0);
        }
#line 615
        if (p) {
#line 615
          if (digits == 0) {
#line 615
            if (_delta > 0) {
#line 615
              if (pad == 48) {
                {
#line 615
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 615
                  _i = (size_t )0;
                  {
#line 615
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 615
                    if (! (_i < (size_t )_delta)) {
#line 615
                      goto while_break___2;
                    }
                    {
#line 615
                    fputc('0', p);
#line 615
                    _i ++;
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 615
                  goto while_break___1;
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                {
#line 615
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 615
                  _i___0 = (size_t )0;
                  {
#line 615
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 615
                    if (! (_i___0 < (size_t )_delta)) {
#line 615
                      goto while_break___4;
                    }
                    {
#line 615
                    fputc(' ', p);
#line 615
                    _i___0 ++;
                    }
                  }
                  while_break___4: /* CIL Label */ ;
                  }
#line 615
                  goto while_break___3;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
            }
          }
          {
#line 615
          fputc((int )*f, p);
          }
        }
#line 615
        i += (size_t )_incr;
#line 615
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 616
      goto __Cont;
    }
    {
#line 622
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 624
      f ++;
      {
#line 629
      if ((int const   )*f == 48) {
#line 629
        goto case_48;
      }
#line 629
      if ((int const   )*f == 45) {
#line 629
        goto case_48;
      }
#line 629
      if ((int const   )*f == 95) {
#line 629
        goto case_48;
      }
#line 634
      if ((int const   )*f == 94) {
#line 634
        goto case_94;
      }
#line 637
      if ((int const   )*f == 35) {
#line 637
        goto case_35;
      }
#line 641
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 630
      pad = (int )*f;
#line 631
      goto while_continue___5;
      case_94: /* CIL Label */ 
#line 635
      to_uppcase = (_Bool)1;
#line 636
      goto while_continue___5;
      case_35: /* CIL Label */ 
#line 638
      change_case = (_Bool)1;
#line 639
      goto while_continue___5;
      switch_default: /* CIL Label */ 
#line 642
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 644
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 648
    if ((unsigned int )*f - 48U <= 9U) {
#line 650
      width = 0;
      {
#line 651
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 653
        if (width > 214748364) {
#line 656
          width = 2147483647;
        } else
#line 653
        if (width == 214748364) {
#line 653
          if ((int const   )*f - 48 > 7) {
#line 656
            width = 2147483647;
          } else {
#line 659
            width *= 10;
#line 660
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 659
          width *= 10;
#line 660
          width += (int )((int const   )*f - 48);
        }
#line 662
        f ++;
#line 651
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 651
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 671
    if ((int const   )*f == 79) {
#line 671
      goto case_79;
    }
#line 671
    if ((int const   )*f == 69) {
#line 671
      goto case_79;
    }
#line 675
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 672
    tmp___0 = f;
#line 672
    f ++;
#line 672
    modifier = (int )*tmp___0;
#line 673
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 676
    modifier = 0;
#line 677
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 681
    format_char = (int )*f;
    {
#line 704
    if (format_char == 37) {
#line 704
      goto case_37;
    }
#line 710
    if (format_char == 97) {
#line 710
      goto case_97;
    }
#line 725
    if (format_char == 65) {
#line 725
      goto case_65;
    }
#line 741
    if (format_char == 104) {
#line 741
      goto case_104;
    }
#line 741
    if (format_char == 98) {
#line 741
      goto case_104;
    }
#line 756
    if (format_char == 66) {
#line 756
      goto case_66;
    }
#line 771
    if (format_char == 99) {
#line 771
      goto case_99;
    }
#line 830
    if (format_char == 67) {
#line 830
      goto case_67;
    }
#line 859
    if (format_char == 120) {
#line 859
      goto case_120;
    }
#line 872
    if (format_char == 68) {
#line 872
      goto case_68;
    }
#line 878
    if (format_char == 100) {
#line 878
      goto case_100;
    }
#line 884
    if (format_char == 101) {
#line 884
      goto case_101;
    }
#line 1010
    if (format_char == 70) {
#line 1010
      goto case_70;
    }
#line 1016
    if (format_char == 72) {
#line 1016
      goto case_72;
    }
#line 1022
    if (format_char == 73) {
#line 1022
      goto case_73;
    }
#line 1028
    if (format_char == 107) {
#line 1028
      goto case_107;
    }
#line 1034
    if (format_char == 108) {
#line 1034
      goto case_108;
    }
#line 1040
    if (format_char == 106) {
#line 1040
      goto case_106;
    }
#line 1046
    if (format_char == 77) {
#line 1046
      goto case_77;
    }
#line 1052
    if (format_char == 109) {
#line 1052
      goto case_109;
    }
#line 1059
    if (format_char == 78) {
#line 1059
      goto case_78;
    }
#line 1077
    if (format_char == 110) {
#line 1077
      goto case_110;
    }
#line 1081
    if (format_char == 80) {
#line 1081
      goto case_80;
    }
#line 1088
    if (format_char == 112) {
#line 1088
      goto case_112;
    }
#line 1101
    if (format_char == 82) {
#line 1101
      goto case_82;
    }
#line 1105
    if (format_char == 114) {
#line 1105
      goto case_114;
    }
#line 1116
    if (format_char == 83) {
#line 1116
      goto case_83;
    }
#line 1122
    if (format_char == 115) {
#line 1122
      goto case_115;
    }
#line 1149
    if (format_char == 88) {
#line 1149
      goto case_88;
    }
#line 1162
    if (format_char == 84) {
#line 1162
      goto case_84;
    }
#line 1166
    if (format_char == 116) {
#line 1166
      goto case_116;
    }
#line 1170
    if (format_char == 117) {
#line 1170
      goto case_117;
    }
#line 1173
    if (format_char == 85) {
#line 1173
      goto case_85;
    }
#line 1181
    if (format_char == 71) {
#line 1181
      goto case_71;
    }
#line 1181
    if (format_char == 103) {
#line 1181
      goto case_71;
    }
#line 1181
    if (format_char == 86) {
#line 1181
      goto case_71;
    }
#line 1237
    if (format_char == 87) {
#line 1237
      goto case_87;
    }
#line 1243
    if (format_char == 119) {
#line 1243
      goto case_119;
    }
#line 1249
    if (format_char == 89) {
#line 1249
      goto case_89;
    }
#line 1273
    if (format_char == 121) {
#line 1273
      goto case_121;
    }
#line 1296
    if (format_char == 90) {
#line 1296
      goto case_90;
    }
#line 1325
    if (format_char == 58) {
#line 1325
      goto case_58;
    }
#line 1335
    if (format_char == 122) {
#line 1335
      goto case_122;
    }
#line 1413
    if (format_char == 0) {
#line 1413
      goto case_0___0;
    }
#line 1416
    goto bad_format;
    case_37: /* CIL Label */ 
#line 705
    if (modifier != 0) {
#line 706
      goto bad_format;
    }
    {
#line 707
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 707
      _n___0 = 1;
#line 707
      _delta___0 = width - _n___0;
#line 707
      if (_delta___0 > 0) {
#line 707
        tmp___1 = _delta___0;
      } else {
#line 707
        tmp___1 = 0;
      }
#line 707
      _incr___0 = _n___0 + tmp___1;
#line 707
      if ((size_t )_incr___0 >= maxsize - i) {
#line 707
        return ((size_t )0);
      }
#line 707
      if (p) {
#line 707
        if (digits == 0) {
#line 707
          if (_delta___0 > 0) {
#line 707
            if (pad == 48) {
              {
#line 707
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 707
                _i___1 = (size_t )0;
                {
#line 707
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 707
                  if (! (_i___1 < (size_t )_delta___0)) {
#line 707
                    goto while_break___9;
                  }
                  {
#line 707
                  fputc('0', p);
#line 707
                  _i___1 ++;
                  }
                }
                while_break___9: /* CIL Label */ ;
                }
#line 707
                goto while_break___8;
              }
              while_break___8: /* CIL Label */ ;
              }
            } else {
              {
#line 707
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 707
                _i___2 = (size_t )0;
                {
#line 707
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 707
                  if (! (_i___2 < (size_t )_delta___0)) {
#line 707
                    goto while_break___11;
                  }
                  {
#line 707
                  fputc(' ', p);
#line 707
                  _i___2 ++;
                  }
                }
                while_break___11: /* CIL Label */ ;
                }
#line 707
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 707
        fputc((int )*f, p);
        }
      }
#line 707
      i += (size_t )_incr___0;
#line 707
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 708
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 711
    if (modifier != 0) {
#line 712
      goto bad_format;
    }
#line 713
    if (change_case) {
#line 715
      to_uppcase = (_Bool)1;
#line 716
      to_lowcase = (_Bool)0;
    }
#line 722
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 726
    if (modifier != 0) {
#line 727
      goto bad_format;
    }
#line 728
    if (change_case) {
#line 730
      to_uppcase = (_Bool)1;
#line 731
      to_lowcase = (_Bool)0;
    }
#line 737
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 742
    if (change_case) {
#line 744
      to_uppcase = (_Bool)1;
#line 745
      to_lowcase = (_Bool)0;
    }
#line 747
    if (modifier != 0) {
#line 748
      goto bad_format;
    }
#line 753
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 757
    if (modifier != 0) {
#line 758
      goto bad_format;
    }
#line 759
    if (change_case) {
#line 761
      to_uppcase = (_Bool)1;
#line 762
      to_lowcase = (_Bool)0;
    }
#line 768
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 772
    if (modifier == 79) {
#line 773
      goto bad_format;
    }
#line 782
    goto underlying_strftime;
    subformat: 
    {
#line 787
    tmp___2 = strftime_case____0(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut,
                                 ns);
#line 787
    len = tmp___2;
    }
    {
#line 791
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 791
      _n___1 = (int )len;
#line 791
      _delta___1 = width - _n___1;
#line 791
      if (_delta___1 > 0) {
#line 791
        tmp___3 = _delta___1;
      } else {
#line 791
        tmp___3 = 0;
      }
#line 791
      _incr___1 = _n___1 + tmp___3;
#line 791
      if ((size_t )_incr___1 >= maxsize - i) {
#line 791
        return ((size_t )0);
      }
#line 791
      if (p) {
#line 791
        if (digits == 0) {
#line 791
          if (_delta___1 > 0) {
#line 791
            if (pad == 48) {
              {
#line 791
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 791
                _i___3 = (size_t )0;
                {
#line 791
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 791
                  if (! (_i___3 < (size_t )_delta___1)) {
#line 791
                    goto while_break___14;
                  }
                  {
#line 791
                  fputc('0', p);
#line 791
                  _i___3 ++;
                  }
                }
                while_break___14: /* CIL Label */ ;
                }
#line 791
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            } else {
              {
#line 791
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 791
                _i___4 = (size_t )0;
                {
#line 791
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 791
                  if (! (_i___4 < (size_t )_delta___1)) {
#line 791
                    goto while_break___16;
                  }
                  {
#line 791
                  fputc(' ', p);
#line 791
                  _i___4 ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
#line 791
                goto while_break___15;
              }
              while_break___15: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 791
        strftime_case____0(to_uppcase, p, subfmt, tp, ut, ns);
        }
      }
#line 791
      i += (size_t )_incr___1;
#line 791
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 796
    goto switch_break___1;
    underlying_strftime: 
#line 804
    u = ufmt;
#line 817
    tmp___4 = u;
#line 817
    u ++;
#line 817
    *tmp___4 = (char )' ';
#line 818
    tmp___5 = u;
#line 818
    u ++;
#line 818
    *tmp___5 = (char )'%';
#line 819
    if (modifier != 0) {
#line 820
      tmp___6 = u;
#line 820
      u ++;
#line 820
      *tmp___6 = (char )modifier;
    }
    {
#line 821
    tmp___7 = u;
#line 821
    u ++;
#line 821
    *tmp___7 = (char )format_char;
#line 822
    *u = (char )'\000';
#line 823
    len___0 = strftime((char */* __restrict  */)(ubuf), (size_t )sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 824
    if (len___0 != 0U) {
      {
#line 825
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 825
        _n___2 = (int )(len___0 - 1U);
#line 825
        _delta___2 = width - _n___2;
#line 825
        if (_delta___2 > 0) {
#line 825
          tmp___8 = _delta___2;
        } else {
#line 825
          tmp___8 = 0;
        }
#line 825
        _incr___2 = _n___2 + tmp___8;
#line 825
        if ((size_t )_incr___2 >= maxsize - i) {
#line 825
          return ((size_t )0);
        }
#line 825
        if (p) {
#line 825
          if (digits == 0) {
#line 825
            if (_delta___2 > 0) {
#line 825
              if (pad == 48) {
                {
#line 825
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 825
                  _i___5 = (size_t )0;
                  {
#line 825
                  while (1) {
                    while_continue___19: /* CIL Label */ ;
#line 825
                    if (! (_i___5 < (size_t )_delta___2)) {
#line 825
                      goto while_break___19;
                    }
                    {
#line 825
                    fputc('0', p);
#line 825
                    _i___5 ++;
                    }
                  }
                  while_break___19: /* CIL Label */ ;
                  }
#line 825
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
              } else {
                {
#line 825
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 825
                  _i___6 = (size_t )0;
                  {
#line 825
                  while (1) {
                    while_continue___21: /* CIL Label */ ;
#line 825
                    if (! (_i___6 < (size_t )_delta___2)) {
#line 825
                      goto while_break___21;
                    }
                    {
#line 825
                    fputc(' ', p);
#line 825
                    _i___6 ++;
                    }
                  }
                  while_break___21: /* CIL Label */ ;
                  }
#line 825
                  goto while_break___20;
                }
                while_break___20: /* CIL Label */ ;
                }
              }
            }
          }
          {
#line 825
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 825
            if (to_lowcase) {
              {
#line 825
              fwrite_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
              }
            } else
#line 825
            if (to_uppcase) {
              {
#line 825
              fwrite_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
              }
            } else {
              {
#line 825
              tmp___9 = fwrite((void const   */* __restrict  */)(ubuf + 1), (size_t )_n___2,
                               (size_t )1, (FILE */* __restrict  */)p);
#line 825
              ignore_value((int )tmp___9);
              }
            }
#line 825
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
        }
#line 825
        i += (size_t )_incr___2;
#line 825
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 827
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 831
    if (modifier == 79) {
#line 832
      goto bad_format;
    }
#line 833
    if (modifier == 69) {
#line 849
      goto underlying_strftime;
    }
#line 854
    century = (int )(tp->tm_year / 100 + 19);
#line 855
    if (tp->tm_year % 100 < 0) {
#line 855
      if (0 < century) {
#line 855
        tmp___10 = 1;
      } else {
#line 855
        tmp___10 = 0;
      }
    } else {
#line 855
      tmp___10 = 0;
    }
#line 855
    century -= tmp___10;
#line 856
    digits = 2;
#line 856
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 856
    u_number_value = (unsigned int )century;
#line 856
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 860
    if (modifier == 79) {
#line 861
      goto bad_format;
    }
#line 870
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 873
    if (modifier != 0) {
#line 874
      goto bad_format;
    }
#line 875
    subfmt = "%m/%d/%y";
#line 876
    goto subformat;
    case_100: /* CIL Label */ 
#line 879
    if (modifier == 69) {
#line 880
      goto bad_format;
    }
#line 882
    digits = 2;
#line 882
    number_value = (int )tp->tm_mday;
#line 882
    goto do_number;
    case_101: /* CIL Label */ 
#line 885
    if (modifier == 69) {
#line 886
      goto bad_format;
    }
#line 888
    digits = 2;
#line 888
    number_value = (int )tp->tm_mday;
#line 888
    goto do_number_spacepad;
    do_tz_offset: 
#line 894
    always_output_a_sign = (_Bool)1;
#line 895
    goto do_number_body;
    do_number_spacepad: 
#line 899
    if (pad != 48) {
#line 899
      if (pad != 45) {
#line 900
        pad = '_';
      }
    }
    do_number: 
#line 904
    negative_number = (_Bool )(number_value < 0);
#line 905
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 908
    always_output_a_sign = (_Bool)0;
#line 909
    tz_colon_mask = 0;
    do_number_body: 
#line 917
    if (modifier == 79) {
#line 917
      if (! negative_number) {
#line 935
        goto underlying_strftime;
      }
    }
#line 939
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 941
    if (negative_number) {
#line 942
      u_number_value = - u_number_value;
    }
    {
#line 944
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 946
      if (tz_colon_mask & 1) {
#line 947
        bufp --;
#line 947
        *bufp = (char )':';
      }
#line 948
      tz_colon_mask >>= 1;
#line 949
      bufp --;
#line 949
      *bufp = (char )(u_number_value % 10U + 48U);
#line 950
      u_number_value /= 10U;
#line 944
      if (! (u_number_value != 0U)) {
#line 944
        if (! (tz_colon_mask != 0)) {
#line 944
          goto while_break___23;
        }
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 955
    if (digits < width) {
#line 956
      digits = width;
    }
#line 958
    if (negative_number) {
#line 958
      sign_char = (char )'-';
    } else {
#line 958
      if (always_output_a_sign) {
#line 958
        tmp___11 = '+';
      } else {
#line 958
        tmp___11 = 0;
      }
#line 958
      sign_char = (char )tmp___11;
    }
#line 962
    if (pad == 45) {
#line 964
      if (sign_char) {
        {
#line 965
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 965
          _n___3 = 1;
#line 965
          _delta___3 = width - _n___3;
#line 965
          if (_delta___3 > 0) {
#line 965
            tmp___12 = _delta___3;
          } else {
#line 965
            tmp___12 = 0;
          }
#line 965
          _incr___3 = _n___3 + tmp___12;
#line 965
          if ((size_t )_incr___3 >= maxsize - i) {
#line 965
            return ((size_t )0);
          }
#line 965
          if (p) {
#line 965
            if (digits == 0) {
#line 965
              if (_delta___3 > 0) {
#line 965
                if (pad == 48) {
                  {
#line 965
                  while (1) {
                    while_continue___25: /* CIL Label */ ;
#line 965
                    _i___7 = (size_t )0;
                    {
#line 965
                    while (1) {
                      while_continue___26: /* CIL Label */ ;
#line 965
                      if (! (_i___7 < (size_t )_delta___3)) {
#line 965
                        goto while_break___26;
                      }
                      {
#line 965
                      fputc('0', p);
#line 965
                      _i___7 ++;
                      }
                    }
                    while_break___26: /* CIL Label */ ;
                    }
#line 965
                    goto while_break___25;
                  }
                  while_break___25: /* CIL Label */ ;
                  }
                } else {
                  {
#line 965
                  while (1) {
                    while_continue___27: /* CIL Label */ ;
#line 965
                    _i___8 = (size_t )0;
                    {
#line 965
                    while (1) {
                      while_continue___28: /* CIL Label */ ;
#line 965
                      if (! (_i___8 < (size_t )_delta___3)) {
#line 965
                        goto while_break___28;
                      }
                      {
#line 965
                      fputc(' ', p);
#line 965
                      _i___8 ++;
                      }
                    }
                    while_break___28: /* CIL Label */ ;
                    }
#line 965
                    goto while_break___27;
                  }
                  while_break___27: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 965
            fputc((int )sign_char, p);
            }
          }
#line 965
          i += (size_t )_incr___3;
#line 965
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
      }
    } else {
#line 969
      padding = (int )(((long )digits - ((buf + sizeof(buf) / sizeof(buf[0])) - bufp)) - (long )(! (! sign_char)));
#line 972
      if (padding > 0) {
#line 974
        if (pad == 95) {
#line 976
          if ((size_t )padding >= maxsize - i) {
#line 977
            return ((size_t )0);
          }
#line 979
          if (p) {
            {
#line 980
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 980
              _i___9 = (size_t )0;
              {
#line 980
              while (1) {
                while_continue___30: /* CIL Label */ ;
#line 980
                if (! (_i___9 < (size_t )padding)) {
#line 980
                  goto while_break___30;
                }
                {
#line 980
                fputc(' ', p);
#line 980
                _i___9 ++;
                }
              }
              while_break___30: /* CIL Label */ ;
              }
#line 980
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
          }
#line 981
          i += (size_t )padding;
#line 982
          if (width > padding) {
#line 982
            width -= padding;
          } else {
#line 982
            width = 0;
          }
#line 983
          if (sign_char) {
            {
#line 984
            while (1) {
              while_continue___31: /* CIL Label */ ;
#line 984
              _n___4 = 1;
#line 984
              _delta___4 = width - _n___4;
#line 984
              if (_delta___4 > 0) {
#line 984
                tmp___13 = _delta___4;
              } else {
#line 984
                tmp___13 = 0;
              }
#line 984
              _incr___4 = _n___4 + tmp___13;
#line 984
              if ((size_t )_incr___4 >= maxsize - i) {
#line 984
                return ((size_t )0);
              }
#line 984
              if (p) {
#line 984
                if (digits == 0) {
#line 984
                  if (_delta___4 > 0) {
#line 984
                    if (pad == 48) {
                      {
#line 984
                      while (1) {
                        while_continue___32: /* CIL Label */ ;
#line 984
                        _i___10 = (size_t )0;
                        {
#line 984
                        while (1) {
                          while_continue___33: /* CIL Label */ ;
#line 984
                          if (! (_i___10 < (size_t )_delta___4)) {
#line 984
                            goto while_break___33;
                          }
                          {
#line 984
                          fputc('0', p);
#line 984
                          _i___10 ++;
                          }
                        }
                        while_break___33: /* CIL Label */ ;
                        }
#line 984
                        goto while_break___32;
                      }
                      while_break___32: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 984
                      while (1) {
                        while_continue___34: /* CIL Label */ ;
#line 984
                        _i___11 = (size_t )0;
                        {
#line 984
                        while (1) {
                          while_continue___35: /* CIL Label */ ;
#line 984
                          if (! (_i___11 < (size_t )_delta___4)) {
#line 984
                            goto while_break___35;
                          }
                          {
#line 984
                          fputc(' ', p);
#line 984
                          _i___11 ++;
                          }
                        }
                        while_break___35: /* CIL Label */ ;
                        }
#line 984
                        goto while_break___34;
                      }
                      while_break___34: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 984
                fputc((int )sign_char, p);
                }
              }
#line 984
              i += (size_t )_incr___4;
#line 984
              goto while_break___31;
            }
            while_break___31: /* CIL Label */ ;
            }
          }
        } else {
#line 988
          if ((size_t )digits >= maxsize - i) {
#line 989
            return ((size_t )0);
          }
#line 991
          if (sign_char) {
            {
#line 992
            while (1) {
              while_continue___36: /* CIL Label */ ;
#line 992
              _n___5 = 1;
#line 992
              _delta___5 = width - _n___5;
#line 992
              if (_delta___5 > 0) {
#line 992
                tmp___14 = _delta___5;
              } else {
#line 992
                tmp___14 = 0;
              }
#line 992
              _incr___5 = _n___5 + tmp___14;
#line 992
              if ((size_t )_incr___5 >= maxsize - i) {
#line 992
                return ((size_t )0);
              }
#line 992
              if (p) {
#line 992
                if (digits == 0) {
#line 992
                  if (_delta___5 > 0) {
#line 992
                    if (pad == 48) {
                      {
#line 992
                      while (1) {
                        while_continue___37: /* CIL Label */ ;
#line 992
                        _i___12 = (size_t )0;
                        {
#line 992
                        while (1) {
                          while_continue___38: /* CIL Label */ ;
#line 992
                          if (! (_i___12 < (size_t )_delta___5)) {
#line 992
                            goto while_break___38;
                          }
                          {
#line 992
                          fputc('0', p);
#line 992
                          _i___12 ++;
                          }
                        }
                        while_break___38: /* CIL Label */ ;
                        }
#line 992
                        goto while_break___37;
                      }
                      while_break___37: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 992
                      while (1) {
                        while_continue___39: /* CIL Label */ ;
#line 992
                        _i___13 = (size_t )0;
                        {
#line 992
                        while (1) {
                          while_continue___40: /* CIL Label */ ;
#line 992
                          if (! (_i___13 < (size_t )_delta___5)) {
#line 992
                            goto while_break___40;
                          }
                          {
#line 992
                          fputc(' ', p);
#line 992
                          _i___13 ++;
                          }
                        }
                        while_break___40: /* CIL Label */ ;
                        }
#line 992
                        goto while_break___39;
                      }
                      while_break___39: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 992
                fputc((int )sign_char, p);
                }
              }
#line 992
              i += (size_t )_incr___5;
#line 992
              goto while_break___36;
            }
            while_break___36: /* CIL Label */ ;
            }
          }
#line 994
          if (p) {
            {
#line 995
            while (1) {
              while_continue___41: /* CIL Label */ ;
#line 995
              _i___14 = (size_t )0;
              {
#line 995
              while (1) {
                while_continue___42: /* CIL Label */ ;
#line 995
                if (! (_i___14 < (size_t )padding)) {
#line 995
                  goto while_break___42;
                }
                {
#line 995
                fputc('0', p);
#line 995
                _i___14 ++;
                }
              }
              while_break___42: /* CIL Label */ ;
              }
#line 995
              goto while_break___41;
            }
            while_break___41: /* CIL Label */ ;
            }
          }
#line 996
          i += (size_t )padding;
#line 997
          width = 0;
        }
      } else
#line 1002
      if (sign_char) {
        {
#line 1003
        while (1) {
          while_continue___43: /* CIL Label */ ;
#line 1003
          _n___6 = 1;
#line 1003
          _delta___6 = width - _n___6;
#line 1003
          if (_delta___6 > 0) {
#line 1003
            tmp___15 = _delta___6;
          } else {
#line 1003
            tmp___15 = 0;
          }
#line 1003
          _incr___6 = _n___6 + tmp___15;
#line 1003
          if ((size_t )_incr___6 >= maxsize - i) {
#line 1003
            return ((size_t )0);
          }
#line 1003
          if (p) {
#line 1003
            if (digits == 0) {
#line 1003
              if (_delta___6 > 0) {
#line 1003
                if (pad == 48) {
                  {
#line 1003
                  while (1) {
                    while_continue___44: /* CIL Label */ ;
#line 1003
                    _i___15 = (size_t )0;
                    {
#line 1003
                    while (1) {
                      while_continue___45: /* CIL Label */ ;
#line 1003
                      if (! (_i___15 < (size_t )_delta___6)) {
#line 1003
                        goto while_break___45;
                      }
                      {
#line 1003
                      fputc('0', p);
#line 1003
                      _i___15 ++;
                      }
                    }
                    while_break___45: /* CIL Label */ ;
                    }
#line 1003
                    goto while_break___44;
                  }
                  while_break___44: /* CIL Label */ ;
                  }
                } else {
                  {
#line 1003
                  while (1) {
                    while_continue___46: /* CIL Label */ ;
#line 1003
                    _i___16 = (size_t )0;
                    {
#line 1003
                    while (1) {
                      while_continue___47: /* CIL Label */ ;
#line 1003
                      if (! (_i___16 < (size_t )_delta___6)) {
#line 1003
                        goto while_break___47;
                      }
                      {
#line 1003
                      fputc(' ', p);
#line 1003
                      _i___16 ++;
                      }
                    }
                    while_break___47: /* CIL Label */ ;
                    }
#line 1003
                    goto while_break___46;
                  }
                  while_break___46: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 1003
            fputc((int )sign_char, p);
            }
          }
#line 1003
          i += (size_t )_incr___6;
#line 1003
          goto while_break___43;
        }
        while_break___43: /* CIL Label */ ;
        }
      }
    }
    {
#line 1007
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 1007
      _n___7 = (int )((buf + sizeof(buf) / sizeof(buf[0])) - bufp);
#line 1007
      _delta___7 = width - _n___7;
#line 1007
      if (_delta___7 > 0) {
#line 1007
        tmp___16 = _delta___7;
      } else {
#line 1007
        tmp___16 = 0;
      }
#line 1007
      _incr___7 = _n___7 + tmp___16;
#line 1007
      if ((size_t )_incr___7 >= maxsize - i) {
#line 1007
        return ((size_t )0);
      }
#line 1007
      if (p) {
#line 1007
        if (digits == 0) {
#line 1007
          if (_delta___7 > 0) {
#line 1007
            if (pad == 48) {
              {
#line 1007
              while (1) {
                while_continue___49: /* CIL Label */ ;
#line 1007
                _i___17 = (size_t )0;
                {
#line 1007
                while (1) {
                  while_continue___50: /* CIL Label */ ;
#line 1007
                  if (! (_i___17 < (size_t )_delta___7)) {
#line 1007
                    goto while_break___50;
                  }
                  {
#line 1007
                  fputc('0', p);
#line 1007
                  _i___17 ++;
                  }
                }
                while_break___50: /* CIL Label */ ;
                }
#line 1007
                goto while_break___49;
              }
              while_break___49: /* CIL Label */ ;
              }
            } else {
              {
#line 1007
              while (1) {
                while_continue___51: /* CIL Label */ ;
#line 1007
                _i___18 = (size_t )0;
                {
#line 1007
                while (1) {
                  while_continue___52: /* CIL Label */ ;
#line 1007
                  if (! (_i___18 < (size_t )_delta___7)) {
#line 1007
                    goto while_break___52;
                  }
                  {
#line 1007
                  fputc(' ', p);
#line 1007
                  _i___18 ++;
                  }
                }
                while_break___52: /* CIL Label */ ;
                }
#line 1007
                goto while_break___51;
              }
              while_break___51: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1007
        while (1) {
          while_continue___53: /* CIL Label */ ;
#line 1007
          if (to_lowcase) {
            {
#line 1007
            fwrite_lowcase(p, (char const   *)bufp, (size_t )_n___7);
            }
          } else
#line 1007
          if (to_uppcase) {
            {
#line 1007
            fwrite_uppcase(p, (char const   *)bufp, (size_t )_n___7);
            }
          } else {
            {
#line 1007
            tmp___17 = fwrite((void const   */* __restrict  */)bufp, (size_t )_n___7,
                              (size_t )1, (FILE */* __restrict  */)p);
#line 1007
            ignore_value((int )tmp___17);
            }
          }
#line 1007
          goto while_break___53;
        }
        while_break___53: /* CIL Label */ ;
        }
      }
#line 1007
      i += (size_t )_incr___7;
#line 1007
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
#line 1008
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 1011
    if (modifier != 0) {
#line 1012
      goto bad_format;
    }
#line 1013
    subfmt = "%Y-%m-%d";
#line 1014
    goto subformat;
    case_72: /* CIL Label */ 
#line 1017
    if (modifier == 69) {
#line 1018
      goto bad_format;
    }
#line 1020
    digits = 2;
#line 1020
    number_value = (int )tp->tm_hour;
#line 1020
    goto do_number;
    case_73: /* CIL Label */ 
#line 1023
    if (modifier == 69) {
#line 1024
      goto bad_format;
    }
#line 1026
    digits = 2;
#line 1026
    number_value = hour12;
#line 1026
    goto do_number;
    case_107: /* CIL Label */ 
#line 1029
    if (modifier == 69) {
#line 1030
      goto bad_format;
    }
#line 1032
    digits = 2;
#line 1032
    number_value = (int )tp->tm_hour;
#line 1032
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1035
    if (modifier == 69) {
#line 1036
      goto bad_format;
    }
#line 1038
    digits = 2;
#line 1038
    number_value = hour12;
#line 1038
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1041
    if (modifier == 69) {
#line 1042
      goto bad_format;
    }
#line 1044
    digits = 3;
#line 1044
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1044
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1044
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1047
    if (modifier == 69) {
#line 1048
      goto bad_format;
    }
#line 1050
    digits = 2;
#line 1050
    number_value = (int )tp->tm_min;
#line 1050
    goto do_number;
    case_109: /* CIL Label */ 
#line 1053
    if (modifier == 69) {
#line 1054
      goto bad_format;
    }
#line 1056
    digits = 2;
#line 1056
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1056
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1056
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1060
    if (modifier == 69) {
#line 1061
      goto bad_format;
    }
#line 1063
    number_value = ns;
#line 1064
    if (width == -1) {
#line 1065
      width = 9;
    } else {
#line 1070
      j = width;
      {
#line 1070
      while (1) {
        while_continue___54: /* CIL Label */ ;
#line 1070
        if (! (j < 9)) {
#line 1070
          goto while_break___54;
        }
#line 1071
        number_value /= 10;
#line 1070
        j ++;
      }
      while_break___54: /* CIL Label */ ;
      }
    }
#line 1074
    digits = width;
#line 1074
    number_value = number_value;
#line 1074
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1078
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 1078
      _n___8 = 1;
#line 1078
      _delta___8 = width - _n___8;
#line 1078
      if (_delta___8 > 0) {
#line 1078
        tmp___18 = _delta___8;
      } else {
#line 1078
        tmp___18 = 0;
      }
#line 1078
      _incr___8 = _n___8 + tmp___18;
#line 1078
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1078
        return ((size_t )0);
      }
#line 1078
      if (p) {
#line 1078
        if (digits == 0) {
#line 1078
          if (_delta___8 > 0) {
#line 1078
            if (pad == 48) {
              {
#line 1078
              while (1) {
                while_continue___56: /* CIL Label */ ;
#line 1078
                _i___19 = (size_t )0;
                {
#line 1078
                while (1) {
                  while_continue___57: /* CIL Label */ ;
#line 1078
                  if (! (_i___19 < (size_t )_delta___8)) {
#line 1078
                    goto while_break___57;
                  }
                  {
#line 1078
                  fputc('0', p);
#line 1078
                  _i___19 ++;
                  }
                }
                while_break___57: /* CIL Label */ ;
                }
#line 1078
                goto while_break___56;
              }
              while_break___56: /* CIL Label */ ;
              }
            } else {
              {
#line 1078
              while (1) {
                while_continue___58: /* CIL Label */ ;
#line 1078
                _i___20 = (size_t )0;
                {
#line 1078
                while (1) {
                  while_continue___59: /* CIL Label */ ;
#line 1078
                  if (! (_i___20 < (size_t )_delta___8)) {
#line 1078
                    goto while_break___59;
                  }
                  {
#line 1078
                  fputc(' ', p);
#line 1078
                  _i___20 ++;
                  }
                }
                while_break___59: /* CIL Label */ ;
                }
#line 1078
                goto while_break___58;
              }
              while_break___58: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1078
        fputc('\n', p);
        }
      }
#line 1078
      i += (size_t )_incr___8;
#line 1078
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
#line 1079
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1082
    to_lowcase = (_Bool)1;
#line 1084
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1089
    if (change_case) {
#line 1091
      to_uppcase = (_Bool)0;
#line 1092
      to_lowcase = (_Bool)1;
    }
#line 1098
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1102
    subfmt = "%H:%M";
#line 1103
    goto subformat;
    case_114: /* CIL Label */ 
#line 1113
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1117
    if (modifier == 69) {
#line 1118
      goto bad_format;
    }
#line 1120
    digits = 2;
#line 1120
    number_value = (int )tp->tm_sec;
#line 1120
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1127
    ltm = (struct tm )*tp;
#line 1128
    t = mktime(& ltm);
#line 1133
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 1134
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1136
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 1138
      d = (int )(t % 10L);
#line 1139
      t /= 10L;
#line 1140
      bufp --;
#line 1140
      if (negative_number) {
#line 1140
        tmp___19 = - d;
      } else {
#line 1140
        tmp___19 = d;
      }
#line 1140
      *bufp = (char )(tmp___19 + 48);
#line 1136
      if (! (t != 0L)) {
#line 1136
        goto while_break___60;
      }
    }
    while_break___60: /* CIL Label */ ;
    }
#line 1144
    digits = 1;
#line 1145
    always_output_a_sign = (_Bool)0;
#line 1146
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1150
    if (modifier == 79) {
#line 1151
      goto bad_format;
    }
#line 1160
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1163
    subfmt = "%H:%M:%S";
#line 1164
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1167
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 1167
      _n___9 = 1;
#line 1167
      _delta___9 = width - _n___9;
#line 1167
      if (_delta___9 > 0) {
#line 1167
        tmp___20 = _delta___9;
      } else {
#line 1167
        tmp___20 = 0;
      }
#line 1167
      _incr___9 = _n___9 + tmp___20;
#line 1167
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1167
        return ((size_t )0);
      }
#line 1167
      if (p) {
#line 1167
        if (digits == 0) {
#line 1167
          if (_delta___9 > 0) {
#line 1167
            if (pad == 48) {
              {
#line 1167
              while (1) {
                while_continue___62: /* CIL Label */ ;
#line 1167
                _i___21 = (size_t )0;
                {
#line 1167
                while (1) {
                  while_continue___63: /* CIL Label */ ;
#line 1167
                  if (! (_i___21 < (size_t )_delta___9)) {
#line 1167
                    goto while_break___63;
                  }
                  {
#line 1167
                  fputc('0', p);
#line 1167
                  _i___21 ++;
                  }
                }
                while_break___63: /* CIL Label */ ;
                }
#line 1167
                goto while_break___62;
              }
              while_break___62: /* CIL Label */ ;
              }
            } else {
              {
#line 1167
              while (1) {
                while_continue___64: /* CIL Label */ ;
#line 1167
                _i___22 = (size_t )0;
                {
#line 1167
                while (1) {
                  while_continue___65: /* CIL Label */ ;
#line 1167
                  if (! (_i___22 < (size_t )_delta___9)) {
#line 1167
                    goto while_break___65;
                  }
                  {
#line 1167
                  fputc(' ', p);
#line 1167
                  _i___22 ++;
                  }
                }
                while_break___65: /* CIL Label */ ;
                }
#line 1167
                goto while_break___64;
              }
              while_break___64: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1167
        fputc('\t', p);
        }
      }
#line 1167
      i += (size_t )_incr___9;
#line 1167
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
#line 1168
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1171
    digits = 1;
#line 1171
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1171
    goto do_number;
    case_85: /* CIL Label */ 
#line 1174
    if (modifier == 69) {
#line 1175
      goto bad_format;
    }
#line 1177
    digits = 2;
#line 1177
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1177
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1182
    if (modifier == 69) {
#line 1183
      goto bad_format;
    }
#line 1189
    if (tp->tm_year < 0) {
#line 1189
      tmp___21 = 300;
    } else {
#line 1189
      tmp___21 = -100;
    }
    {
#line 1189
    year = (int )(tp->tm_year + (int const   )tmp___21);
#line 1193
    year_adjust = 0;
#line 1194
    tmp___22 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1194
    days = tmp___22;
    }
#line 1196
    if (days < 0) {
#line 1199
      year_adjust = -1;
#line 1200
      if ((year - 1) % 4 == 0) {
#line 1200
        if ((year - 1) % 100 != 0) {
#line 1200
          tmp___23 = 1;
        } else
#line 1200
        if ((year - 1) % 400 == 0) {
#line 1200
          tmp___23 = 1;
        } else {
#line 1200
          tmp___23 = 0;
        }
      } else {
#line 1200
        tmp___23 = 0;
      }
      {
#line 1200
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___23)), (int )tp->tm_wday);
      }
    } else {
#line 1205
      if (year % 4 == 0) {
#line 1205
        if (year % 100 != 0) {
#line 1205
          tmp___24 = 1;
        } else
#line 1205
        if (year % 400 == 0) {
#line 1205
          tmp___24 = 1;
        } else {
#line 1205
          tmp___24 = 0;
        }
      } else {
#line 1205
        tmp___24 = 0;
      }
      {
#line 1205
      tmp___25 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___24)),
                               (int )tp->tm_wday);
#line 1205
      d___0 = tmp___25;
      }
#line 1207
      if (0 <= d___0) {
#line 1210
        year_adjust = 1;
#line 1211
        days = d___0;
      }
    }
    {
#line 1217
    if ((int const   )*f == 103) {
#line 1217
      goto case_103___0;
    }
#line 1227
    if ((int const   )*f == 71) {
#line 1227
      goto case_71___0;
    }
#line 1232
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1219
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1220
    digits = 2;
#line 1220
    if (0 <= yy) {
#line 1220
      number_value = yy;
    } else {
#line 1220
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1220
        tmp___26 = - yy;
      } else {
#line 1220
        tmp___26 = yy + 100;
      }
#line 1220
      number_value = tmp___26;
    }
#line 1220
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1228
    digits = 4;
#line 1228
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1228
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1228
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1233
    digits = 2;
#line 1233
    number_value = days / 7 + 1;
#line 1233
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1238
    if (modifier == 69) {
#line 1239
      goto bad_format;
    }
#line 1241
    digits = 2;
#line 1241
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1241
    goto do_number;
    case_119: /* CIL Label */ 
#line 1244
    if (modifier == 69) {
#line 1245
      goto bad_format;
    }
#line 1247
    digits = 1;
#line 1247
    number_value = (int )tp->tm_wday;
#line 1247
    goto do_number;
    case_89: /* CIL Label */ 
#line 1250
    if (modifier == 69) {
#line 1264
      goto underlying_strftime;
    }
#line 1267
    if (modifier == 79) {
#line 1268
      goto bad_format;
    } else {
#line 1270
      digits = 4;
    }
#line 1270
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1270
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1270
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1274
    if (modifier == 69) {
#line 1285
      goto underlying_strftime;
    }
#line 1290
    yy___0 = (int )(tp->tm_year % 100);
#line 1291
    if (yy___0 < 0) {
#line 1292
      if (tp->tm_year < -1900) {
#line 1292
        yy___0 = - yy___0;
      } else {
#line 1292
        yy___0 += 100;
      }
    }
#line 1293
    digits = 2;
#line 1293
    number_value = yy___0;
#line 1293
    goto do_number;
    case_90: /* CIL Label */ 
#line 1297
    if (change_case) {
#line 1299
      to_uppcase = (_Bool)0;
#line 1300
      to_lowcase = (_Bool)1;
    }
#line 1308
    if (! zone) {
#line 1309
      zone = "";
    }
    {
#line 1321
    while (1) {
      while_continue___66: /* CIL Label */ ;
      {
#line 1321
      tmp___27 = strlen(zone);
#line 1321
      _n___10 = (int )tmp___27;
#line 1321
      _delta___10 = width - _n___10;
      }
#line 1321
      if (_delta___10 > 0) {
#line 1321
        tmp___28 = _delta___10;
      } else {
#line 1321
        tmp___28 = 0;
      }
#line 1321
      _incr___10 = _n___10 + tmp___28;
#line 1321
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1321
        return ((size_t )0);
      }
#line 1321
      if (p) {
#line 1321
        if (digits == 0) {
#line 1321
          if (_delta___10 > 0) {
#line 1321
            if (pad == 48) {
              {
#line 1321
              while (1) {
                while_continue___67: /* CIL Label */ ;
#line 1321
                _i___23 = (size_t )0;
                {
#line 1321
                while (1) {
                  while_continue___68: /* CIL Label */ ;
#line 1321
                  if (! (_i___23 < (size_t )_delta___10)) {
#line 1321
                    goto while_break___68;
                  }
                  {
#line 1321
                  fputc('0', p);
#line 1321
                  _i___23 ++;
                  }
                }
                while_break___68: /* CIL Label */ ;
                }
#line 1321
                goto while_break___67;
              }
              while_break___67: /* CIL Label */ ;
              }
            } else {
              {
#line 1321
              while (1) {
                while_continue___69: /* CIL Label */ ;
#line 1321
                _i___24 = (size_t )0;
                {
#line 1321
                while (1) {
                  while_continue___70: /* CIL Label */ ;
#line 1321
                  if (! (_i___24 < (size_t )_delta___10)) {
#line 1321
                    goto while_break___70;
                  }
                  {
#line 1321
                  fputc(' ', p);
#line 1321
                  _i___24 ++;
                  }
                }
                while_break___70: /* CIL Label */ ;
                }
#line 1321
                goto while_break___69;
              }
              while_break___69: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1321
        while (1) {
          while_continue___71: /* CIL Label */ ;
#line 1321
          if (to_lowcase) {
            {
#line 1321
            fwrite_lowcase(p, zone, (size_t )_n___10);
            }
          } else
#line 1321
          if (to_uppcase) {
            {
#line 1321
            fwrite_uppcase(p, zone, (size_t )_n___10);
            }
          } else {
            {
#line 1321
            tmp___29 = fwrite((void const   */* __restrict  */)zone, (size_t )_n___10,
                              (size_t )1, (FILE */* __restrict  */)p);
#line 1321
            ignore_value((int )tmp___29);
            }
          }
#line 1321
          goto while_break___71;
        }
        while_break___71: /* CIL Label */ ;
        }
      }
#line 1321
      i += (size_t )_incr___10;
#line 1321
      goto while_break___66;
    }
    while_break___66: /* CIL Label */ ;
    }
#line 1323
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1328
    colons = (size_t )1;
    {
#line 1328
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 1328
      if (! ((int const   )*(f + colons) == 58)) {
#line 1328
        goto while_break___72;
      }
#line 1329
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1328
      colons ++;
    }
    while_break___72: /* CIL Label */ ;
    }
#line 1330
    if ((int const   )*(f + colons) != 122) {
#line 1331
      goto bad_format;
    }
#line 1332
    f += colons;
#line 1333
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1336
    colons = (size_t )0;
    do_z_conversion: 
#line 1339
    if (tp->tm_isdst < 0) {
#line 1340
      goto switch_break___1;
    }
#line 1348
    diff = (int )tp->tm_gmtoff;
#line 1385
    hour_diff = (diff / 60) / 60;
#line 1386
    min_diff = (diff / 60) % 60;
#line 1387
    sec_diff = diff % 60;
    {
#line 1391
    if (colons == 0U) {
#line 1391
      goto case_0;
    }
#line 1394
    if (colons == 1U) {
#line 1394
      goto tz_hh_mm;
    }
#line 1397
    if (colons == 2U) {
#line 1397
      goto tz_hh_mm_ss;
    }
#line 1401
    if (colons == 3U) {
#line 1401
      goto case_3;
    }
#line 1408
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1392
    digits = 5;
#line 1392
    negative_number = (_Bool )(diff < 0);
#line 1392
    tz_colon_mask = 0;
#line 1392
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1392
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1395
    digits = 6;
#line 1395
    negative_number = (_Bool )(diff < 0);
#line 1395
    tz_colon_mask = 4;
#line 1395
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1395
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1398
    digits = 9;
#line 1398
    negative_number = (_Bool )(diff < 0);
#line 1398
    tz_colon_mask = 20;
#line 1398
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1398
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1402
    if (sec_diff != 0) {
#line 1403
      goto tz_hh_mm_ss;
    }
#line 1404
    if (min_diff != 0) {
#line 1405
      goto tz_hh_mm;
    }
#line 1406
    digits = 3;
#line 1406
    negative_number = (_Bool )(diff < 0);
#line 1406
    tz_colon_mask = 0;
#line 1406
    u_number_value = (unsigned int )hour_diff;
#line 1406
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1409
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1414
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1423
    flen = 1;
    {
#line 1423
    while (1) {
      while_continue___73: /* CIL Label */ ;
#line 1423
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1423
        goto while_break___73;
      }
#line 1424
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1423
      flen ++;
    }
    while_break___73: /* CIL Label */ ;
    }
    {
#line 1425
    while (1) {
      while_continue___74: /* CIL Label */ ;
#line 1425
      _n___11 = flen;
#line 1425
      _delta___11 = width - _n___11;
#line 1425
      if (_delta___11 > 0) {
#line 1425
        tmp___30 = _delta___11;
      } else {
#line 1425
        tmp___30 = 0;
      }
#line 1425
      _incr___11 = _n___11 + tmp___30;
#line 1425
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1425
        return ((size_t )0);
      }
#line 1425
      if (p) {
#line 1425
        if (digits == 0) {
#line 1425
          if (_delta___11 > 0) {
#line 1425
            if (pad == 48) {
              {
#line 1425
              while (1) {
                while_continue___75: /* CIL Label */ ;
#line 1425
                _i___25 = (size_t )0;
                {
#line 1425
                while (1) {
                  while_continue___76: /* CIL Label */ ;
#line 1425
                  if (! (_i___25 < (size_t )_delta___11)) {
#line 1425
                    goto while_break___76;
                  }
                  {
#line 1425
                  fputc('0', p);
#line 1425
                  _i___25 ++;
                  }
                }
                while_break___76: /* CIL Label */ ;
                }
#line 1425
                goto while_break___75;
              }
              while_break___75: /* CIL Label */ ;
              }
            } else {
              {
#line 1425
              while (1) {
                while_continue___77: /* CIL Label */ ;
#line 1425
                _i___26 = (size_t )0;
                {
#line 1425
                while (1) {
                  while_continue___78: /* CIL Label */ ;
#line 1425
                  if (! (_i___26 < (size_t )_delta___11)) {
#line 1425
                    goto while_break___78;
                  }
                  {
#line 1425
                  fputc(' ', p);
#line 1425
                  _i___26 ++;
                  }
                }
                while_break___78: /* CIL Label */ ;
                }
#line 1425
                goto while_break___77;
              }
              while_break___77: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1425
        while (1) {
          while_continue___79: /* CIL Label */ ;
#line 1425
          if (to_lowcase) {
            {
#line 1425
            fwrite_lowcase(p, f + (1 - flen), (size_t )_n___11);
            }
          } else
#line 1425
          if (to_uppcase) {
            {
#line 1425
            fwrite_uppcase(p, f + (1 - flen), (size_t )_n___11);
            }
          } else {
            {
#line 1425
            tmp___31 = fwrite((void const   */* __restrict  */)(f + (1 - flen)), (size_t )_n___11,
                              (size_t )1, (FILE */* __restrict  */)p);
#line 1425
            ignore_value((int )tmp___31);
            }
          }
#line 1425
          goto while_break___79;
        }
        while_break___79: /* CIL Label */ ;
        }
      }
#line 1425
      i += (size_t )_incr___11;
#line 1425
      goto while_break___74;
    }
    while_break___74: /* CIL Label */ ;
    }
#line 1427
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 508
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1436
  return (i);
}
}
#line 1445 "/home/ysko/Works/test-src/pies-1.2/gnu/strftime.c"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1450
  tmp = strftime_case____0((_Bool)0, s, format, tp, ut, ns);
  }
#line 1450
  return (tmp);
}
}
#line 20 "/home/ysko/Works/test-src/pies-1.2/gnu/exitfail.h"
int volatile   exit_failure ;
#line 26 "/home/ysko/Works/test-src/pies-1.2/gnu/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 68 "/home/ysko/Works/test-src/pies-1.2/gnu/dirname.h"
char *mdir_name(char const   *file ) ;
#line 70
size_t dir_len(char const   *file ) ;
#line 33 "/home/ysko/Works/test-src/pies-1.2/gnu/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 36
  prefix_length = (size_t )0;
#line 40
  if (prefix_length != 0U) {
#line 40
    tmp___0 = 0;
  } else {
#line 40
    if ((int const   )*(file + 0) == 47) {
#line 40
      tmp = 1;
    } else {
#line 40
      tmp = 0;
    }
#line 40
    tmp___0 = tmp;
  }
  {
#line 40
  prefix_length += (size_t )tmp___0;
#line 50
  tmp___1 = last_component(file);
#line 50
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (prefix_length < length)) {
#line 50
      goto while_break;
    }
#line 52
    if (! ((int const   )*(file + (length - 1U)) == 47)) {
#line 53
      goto while_break;
    }
#line 50
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return (length);
}
}
#line 72 "/home/ysko/Works/test-src/pies-1.2/gnu/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 75
  tmp = dir_len(file);
#line 75
  length = tmp;
  }
#line 76
  if (length == 0U) {
#line 76
    tmp___0 = 1;
  } else {
#line 76
    tmp___0 = 0;
  }
  {
#line 76
  append_dot = (_Bool )tmp___0;
#line 80
  tmp___1 = malloc((length + (size_t )append_dot) + 1U);
#line 80
  dir = (char *)tmp___1;
  }
#line 81
  if (! dir) {
#line 82
    return ((char *)((void *)0));
  }
  {
#line 83
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 84
  if (append_dot) {
#line 85
    tmp___2 = length;
#line 85
    length ++;
#line 85
    *(dir + tmp___2) = (char )'.';
  }
#line 86
  *(dir + length) = (char )'\000';
#line 87
  return (dir);
}
}
#line 49 "/home/ysko/Works/test-src/pies-1.2/gnu/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 138 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.h"
int c_tolower(int c ) ;
#line 29 "/home/ysko/Works/test-src/pies-1.2/gnu/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  } else
#line 36
  if (n == 0U) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
#line 44
    n --;
    }
#line 44
    if (n == 0U) {
#line 45
      goto while_break;
    } else
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 44 "/home/ysko/Works/test-src/pies-1.2/gnu/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 29 "/home/ysko/Works/test-src/pies-1.2/gnu/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
    }
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 123 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.h"
_Bool c_isascii(int c ) ;
#line 125
_Bool c_isalnum(int c ) ;
#line 126
_Bool c_isalpha(int c ) ;
#line 127
_Bool c_isblank(int c ) ;
#line 128
_Bool c_iscntrl(int c ) ;
#line 129
_Bool c_isdigit(int c ) ;
#line 130
_Bool c_islower(int c ) ;
#line 131
_Bool c_isgraph(int c ) ;
#line 132
_Bool c_isprint(int c ) ;
#line 133
_Bool c_ispunct(int c ) ;
#line 134
_Bool c_isspace(int c ) ;
#line 135
_Bool c_isupper(int c ) ;
#line 136
_Bool c_isxdigit(int c ) ;
#line 139
int c_toupper(int c ) ;
#line 29 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 32
  if (c >= 0) {
#line 32
    if (c <= 127) {
#line 32
      tmp = 1;
    } else {
#line 32
      tmp = 0;
    }
  } else {
#line 32
    tmp = 0;
  }
#line 32
  return ((_Bool )tmp);
}
}
#line 35 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 41
  if (c >= 48) {
#line 41
    if (c <= 57) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if ((c & -33) >= 65) {
#line 41
    if ((c & -33) <= 90) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return ((_Bool )tmp);
}
}
#line 70 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 75
  if ((c & -33) >= 65) {
#line 75
    if ((c & -33) <= 90) {
#line 75
      tmp = 1;
    } else {
#line 75
      tmp = 0;
    }
  } else {
#line 75
    tmp = 0;
  }
#line 75
  return ((_Bool )tmp);
}
}
#line 99 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 102
  if (c == 32) {
#line 102
    tmp = 1;
  } else
#line 102
  if (c == 9) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return ((_Bool )tmp);
}
}
#line 105 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 109
  if ((c & -32) == 0) {
#line 109
    tmp = 1;
  } else
#line 109
  if (c == 127) {
#line 109
    tmp = 1;
  } else {
#line 109
    tmp = 0;
  }
#line 109
  return ((_Bool )tmp);
}
}
#line 139 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 143
  if (c >= 48) {
#line 143
    if (c <= 57) {
#line 143
      tmp = 1;
    } else {
#line 143
      tmp = 0;
    }
  } else {
#line 143
    tmp = 0;
  }
#line 143
  return ((_Bool )tmp);
}
}
#line 156 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 160
  if (c >= 97) {
#line 160
    if (c <= 122) {
#line 160
      tmp = 1;
    } else {
#line 160
      tmp = 0;
    }
  } else {
#line 160
    tmp = 0;
  }
#line 160
  return ((_Bool )tmp);
}
}
#line 176 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 180
  if (c >= 33) {
#line 180
    if (c <= 126) {
#line 180
      tmp = 1;
    } else {
#line 180
      tmp = 0;
    }
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return ((_Bool )tmp);
}
}
#line 210 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 214
  if (c >= 32) {
#line 214
    if (c <= 126) {
#line 214
      tmp = 1;
    } else {
#line 214
      tmp = 0;
    }
  } else {
#line 214
    tmp = 0;
  }
#line 214
  return ((_Bool )tmp);
}
}
#line 244 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 248
  if (c >= 33) {
#line 248
    if (c <= 126) {
#line 248
      if (c >= 48) {
#line 248
        if (c <= 57) {
#line 248
          tmp = 0;
        } else {
#line 248
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 248
      if ((c & -33) >= 65) {
#line 248
        if ((c & -33) <= 90) {
#line 248
          tmp = 0;
        } else {
#line 248
          tmp = 1;
        }
      } else {
#line 248
        tmp = 1;
      }
    } else {
#line 248
      tmp = 0;
    }
  } else {
#line 248
    tmp = 0;
  }
#line 248
  return ((_Bool )tmp);
}
}
#line 268 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 271
  if (c == 32) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 9) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 10) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 11) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 12) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 13) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
#line 271
  return ((_Bool )tmp);
}
}
#line 275 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 279
  if (c >= 65) {
#line 279
    if (c <= 90) {
#line 279
      tmp = 1;
    } else {
#line 279
      tmp = 0;
    }
  } else {
#line 279
    tmp = 0;
  }
#line 279
  return ((_Bool )tmp);
}
}
#line 295 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 301
  if (c >= 48) {
#line 301
    if (c <= 57) {
#line 301
      tmp = 1;
    } else {
#line 301
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 301
  if ((c & -33) >= 65) {
#line 301
    if ((c & -33) <= 70) {
#line 301
      tmp = 1;
    } else {
#line 301
      tmp = 0;
    }
  } else {
#line 301
    tmp = 0;
  }
#line 301
  return ((_Bool )tmp);
}
}
#line 322 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 326
  if (c >= 65) {
#line 326
    if (c <= 90) {
#line 326
      tmp = (c - 65) + 97;
    } else {
#line 326
      tmp = c;
    }
  } else {
#line 326
    tmp = c;
  }
#line 326
  return (tmp);
}
}
#line 361 "/home/ysko/Works/test-src/pies-1.2/gnu/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 365
  if (c >= 97) {
#line 365
    if (c <= 122) {
#line 365
      tmp = (c - 97) + 65;
    } else {
#line 365
      tmp = c;
    }
  } else {
#line 365
    tmp = c;
  }
#line 365
  return (tmp);
}
}
#line 31 "/home/ysko/Works/test-src/pies-1.2/gnu/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 34
  base = name + 0;
#line 36
  saw_slash = (_Bool)0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! ((int const   )*base == 47)) {
#line 38
      goto while_break;
    }
#line 39
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  p = base;
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 41
    if (! *p) {
#line 41
      goto while_break___0;
    }
#line 43
    if ((int const   )*p == 47) {
#line 44
      saw_slash = (_Bool)1;
    } else
#line 45
    if (saw_slash) {
#line 47
      base = p;
#line 48
      saw_slash = (_Bool)0;
    }
#line 41
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 52
  return ((char *)base);
}
}
#line 59 "/home/ysko/Works/test-src/pies-1.2/gnu/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 63
  prefix_len = (size_t )0;
#line 65
  len = strlen(name);
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (1U < len) {
#line 65
      if (! ((int const   )*(name + (len - 1U)) == 47)) {
#line 65
        goto while_break;
      }
    } else {
#line 65
      goto while_break;
    }
#line 66
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 65
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (len);
}
}
#line 74 "/home/ysko/Works/test-src/pies-1.2/gnu/vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 27 "/home/ysko/Works/test-src/pies-1.2/gnu/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 33
  __builtin_va_start(args, format);
#line 34
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 35
  __builtin_va_end(args);
  }
#line 36
  return (result);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 417 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 418
extern int __overflow(_IO_FILE * , int  ) ;
#line 458
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 459
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 348
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 354
__inline extern int __attribute__((__gnu_inline__))  vprintf(char const   * __restrict  __fmt ,
                                                             __gnuc_va_list __arg ) ;
#line 520
__inline extern int __attribute__((__gnu_inline__))  getchar(void) ;
#line 533
__inline extern int __attribute__((__gnu_inline__))  getchar_unlocked(void) ;
#line 543
__inline extern int __attribute__((__gnu_inline__))  fgetc_unlocked(FILE *__fp ) ;
#line 562
__inline extern int __attribute__((__gnu_inline__))  putchar(int __c ) ;
#line 576
__inline extern int __attribute__((__gnu_inline__))  fputc_unlocked(int __c , FILE *__stream ) ;
#line 584
__inline extern int __attribute__((__gnu_inline__))  putc_unlocked(int __c , FILE *__stream ) ;
#line 585
__inline extern int __attribute__((__gnu_inline__))  putchar_unlocked(int __c ) ;
#line 638
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
#line 651
__inline extern __ssize_t __attribute__((__gnu_inline__))  getline(char ** __restrict  __lineptr ,
                                                                   size_t * __restrict  __n ,
                                                                   FILE * __restrict  __stream ) ;
#line 809
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  feof_unlocked(FILE *__stream ) ;
#line 810
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ferror_unlocked(FILE *__stream ) ;
#line 36 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  vprintf(char const   * __restrict  __fmt ,
                                                             __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
#line 39
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 44 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  getchar(void) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = _IO_getc(stdin);
  }
#line 47
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 53 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 56
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 56
  if (tmp___3) {
    {
#line 56
    tmp___0 = __uflow(__fp);
#line 56
    tmp___2 = tmp___0;
    }
  } else {
#line 56
    tmp___1 = __fp->_IO_read_ptr;
#line 56
    (__fp->_IO_read_ptr) ++;
#line 56
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 56
  return ((int __attribute__((__gnu_inline__))  )tmp___2);
}
}
#line 63 "/usr/include/bits/stdio.h"
extern int __attribute__((__gnu_inline__))  getc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 66
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 66
  if (tmp___3) {
    {
#line 66
    tmp___0 = __uflow(__fp);
#line 66
    tmp___2 = tmp___0;
    }
  } else {
#line 66
    tmp___1 = __fp->_IO_read_ptr;
#line 66
    (__fp->_IO_read_ptr) ++;
#line 66
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 66
  return ((int __attribute__((__gnu_inline__))  )tmp___2);
}
}
#line 70 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 73
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  }
#line 73
  if (tmp___3) {
    {
#line 73
    tmp___0 = __uflow(stdin);
#line 73
    tmp___2 = tmp___0;
    }
  } else {
#line 73
    tmp___1 = stdin->_IO_read_ptr;
#line 73
    (stdin->_IO_read_ptr) ++;
#line 73
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 73
  return ((int __attribute__((__gnu_inline__))  )tmp___2);
}
}
#line 79 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  putchar(int __c ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = _IO_putc(__c, stdout);
  }
#line 82
  return ((int __attribute__((__gnu_inline__))  )tmp);
}
}
#line 88 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 91
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
#line 91
  if (tmp___4) {
    {
#line 91
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 91
    tmp___3 = tmp___0;
    }
  } else {
#line 91
    tmp___1 = __stream->_IO_write_ptr;
#line 91
    (__stream->_IO_write_ptr) ++;
#line 91
    tmp___2 = (char )__c;
#line 91
    *tmp___1 = tmp___2;
#line 91
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 91
  return ((int __attribute__((__gnu_inline__))  )tmp___3);
}
}
#line 105 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 108
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  }
#line 108
  if (tmp___4) {
    {
#line 108
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 108
    tmp___3 = tmp___0;
    }
  } else {
#line 108
    tmp___1 = stdout->_IO_write_ptr;
#line 108
    (stdout->_IO_write_ptr) ++;
#line 108
    tmp___2 = (char )__c;
#line 108
    *tmp___1 = tmp___2;
#line 108
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 108
  return ((int __attribute__((__gnu_inline__))  )tmp___3);
}
}
#line 115 "/usr/include/bits/stdio.h"
__inline extern __ssize_t __attribute__((__gnu_inline__))  getline(char ** __restrict  __lineptr ,
                                                                   size_t * __restrict  __n ,
                                                                   FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  {
#line 118
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 118
  return ((__ssize_t __attribute__((__gnu_inline__))  )tmp);
}
}
#line 125
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  feof_unlocked(FILE *__stream ) ;
#line 125 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  feof_unlocked(FILE *__stream ) 
{ 


  {
#line 128
  return ((int __attribute__((__gnu_inline__))  )((__stream->_flags & 16) != 0));
}
}
#line 132
__inline extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  ferror_unlocked(FILE *__stream ) ;
#line 132 "/usr/include/bits/stdio.h"
__inline extern int __attribute__((__gnu_inline__))  ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 135
  return ((int __attribute__((__gnu_inline__))  )((__stream->_flags & 32) != 0));
}
}
#line 83 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 190
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
extern int __attribute__((__gnu_inline__))  tolower(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
      {
#line 193
      tmp = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 193
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 193
    tmp___0 = (__int32_t const   )__c;
  }
#line 193
  return ((int __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 196
extern  __attribute__((__nothrow__)) int __attribute__((__gnu_inline__))  toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
extern int __attribute__((__gnu_inline__))  toupper(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
      {
#line 199
      tmp = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 199
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 199
    tmp___0 = (__int32_t const   )__c;
  }
#line 199
  return ((int __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 518 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
void argp_state_help(struct argp_state  const  * __restrict  state , FILE * __restrict  stream ,
                     unsigned int flags ) ;
#line 612 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
void argp_usage(struct argp_state  const  *__state ) 
{ 


  {
  {
#line 615
  argp_state_help((struct argp_state  const  */* __restrict  */)__state, (FILE */* __restrict  */)stderr,
                  262U);
  }
#line 616
  return;
}
}
#line 618
 __attribute__((__nothrow__)) int _option_is_short(struct argp_option  const  *__opt ) ;
#line 618 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
int _option_is_short(struct argp_option  const  *__opt ) 
{ 
  int __key ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 621
  if (__opt->flags & 8) {
#line 622
    return (0);
  } else {
#line 625
    __key = (int )__opt->key;
#line 626
    if (__key > 0) {
#line 626
      if (__key <= 255) {
        {
#line 626
        tmp = __ctype_b_loc();
        }
#line 626
        if ((int const   )*(*tmp + __key) & 16384) {
#line 626
          if (__key != 58) {
#line 626
            if (__key != 43) {
#line 626
              if (__key != 45) {
#line 626
                tmp___0 = 1;
              } else {
#line 626
                tmp___0 = 0;
              }
            } else {
#line 626
              tmp___0 = 0;
            }
          } else {
#line 626
            tmp___0 = 0;
          }
        } else {
#line 626
          tmp___0 = 0;
        }
      } else {
#line 626
        tmp___0 = 0;
      }
    } else {
#line 626
      tmp___0 = 0;
    }
#line 626
    return (tmp___0);
  }
}
}
#line 631
 __attribute__((__nothrow__)) int _option_is_end(struct argp_option  const  *__opt ) ;
#line 631 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
int _option_is_end(struct argp_option  const  *__opt ) 
{ 
  int tmp ;

  {
#line 634
  if (! __opt->key) {
#line 634
    if (! __opt->name) {
#line 634
      if (! __opt->doc) {
#line 634
        if (! __opt->group) {
#line 634
          tmp = 1;
        } else {
#line 634
          tmp = 0;
        }
      } else {
#line 634
        tmp = 0;
      }
    } else {
#line 634
      tmp = 0;
    }
  } else {
#line 634
    tmp = 0;
  }
#line 634
  return (tmp);
}
}
#line 454
void (*argp_program_version_hook)(FILE * __restrict  __stream , struct argp_state * __restrict  __state ) ;
#line 32 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-pvh.c"
void (*argp_program_version_hook)(FILE * __restrict  __stream , struct argp_state * __restrict  __state )  =    (void (*)(FILE * __restrict  stream ,
             struct argp_state * __restrict  state ))((void *)0);
#line 25 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-pv.c"
char const   *argp_program_version  ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 441 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 45 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 418 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
error_t argp_parse(struct argp  const  * __restrict  argp___0 , int argc , char ** __restrict  argv ,
                   unsigned int flags , int * __restrict  end_index , void * __restrict  input ) ;
#line 534
void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  state ,
                                           char const   * __restrict  fmt  , ...) ;
#line 571
 __attribute__((__nothrow__)) void *_argp_input(struct argp  const  * __restrict  argp___0 ,
                                                struct argp_state  const  * __restrict  state ) ;
#line 75 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static int volatile   _argp_hang  ;
#line 81 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static struct argp_option  const  argp_default_options[5]  = {      {"help", '?', (char const   *)0, 0, "give this help list", -1}, 
        {"usage", -3, (char const   *)0, 0, "give a short usage message", 0}, 
        {"program-name", -2, "NAME", 2, "set the program name", 0}, 
        {"HANG", -4, "SECS", 3, "hang for SECS seconds (default 3600)", 0}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 91 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static error_t argp_default_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int volatile   tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 96
  if (key == 63) {
#line 96
    goto case_63;
  }
#line 99
  if (key == -3) {
#line 99
    goto case_neg_3;
  }
#line 104
  if (key == -2) {
#line 104
    goto case_neg_2;
  }
#line 126
  if (key == -4) {
#line 126
    goto case_neg_4;
  }
#line 132
  goto switch_default;
  case_63: /* CIL Label */ 
  {
#line 97
  argp_state_help((struct argp_state  const  */* __restrict  */)state, (FILE */* __restrict  */)state->out_stream,
                  634U);
  }
#line 98
  goto switch_break;
  case_neg_3: /* CIL Label */ 
  {
#line 100
  argp_state_help((struct argp_state  const  */* __restrict  */)state, (FILE */* __restrict  */)state->out_stream,
                  513U);
  }
#line 102
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
#line 106
  program_invocation_name = arg___0;
#line 113
  state->name = last_component((char const   *)arg___0);
#line 116
  program_invocation_short_name = state->name;
  }
#line 119
  if ((state->flags & 3U) == 1U) {
#line 122
    *(state->argv + 0) = arg___0;
  }
#line 124
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 127
  if (arg___0) {
#line 127
    tmp = (char const   *)arg___0;
  } else {
#line 127
    tmp = "3600";
  }
  {
#line 127
  tmp___0 = atoi(tmp);
#line 127
  _argp_hang = (int volatile   )tmp___0;
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    tmp___1 = _argp_hang;
#line 128
    _argp_hang -= (int volatile   )1;
#line 128
    if (! (tmp___1 > (int volatile   )0)) {
#line 128
      goto while_break;
    }
    {
#line 129
    sleep(1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 133
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 135
  return (0);
}
}
#line 138 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static struct argp  const  argp_default_argp  =    {argp_default_options, & argp_default_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    "libc"};
#line 142 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static struct argp_option  const  argp_version_options[2]  = {      {"version", 'V', (char const   *)0, 0, "print program version", -1}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 148 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static error_t argp_version_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 153
  if (key == 86) {
#line 153
    goto case_86;
  }
#line 164
  goto switch_default;
  case_86: /* CIL Label */ 
#line 154
  if (argp_program_version_hook) {
    {
#line 155
    (*argp_program_version_hook)((FILE */* __restrict  */)state->out_stream, (struct argp_state */* __restrict  */)state);
    }
  } else
#line 156
  if (argp_program_version) {
    {
#line 157
    fprintf((FILE */* __restrict  */)state->out_stream, (char const   */* __restrict  */)"%s\n",
            argp_program_version);
    }
  } else {
    {
#line 159
    tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "(PROGRAM ERROR) No version known!?");
#line 159
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)tmp);
    }
  }
#line 161
  if (! (state->flags & 32U)) {
    {
#line 162
    exit(0);
    }
  }
#line 163
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 165
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 167
  return (0);
}
}
#line 170 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static struct argp  const  argp_version_argp  =    {argp_version_options, & argp_version_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    "libc"};
#line 176 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static int find_long_option(struct rpl_option *long_options , char const   *name ) 
{ 
  struct rpl_option *l ;
  int tmp ;

  {
#line 179
  l = long_options;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )l->name != (unsigned long )((void *)0))) {
#line 180
      goto while_break;
    }
#line 181
    if ((unsigned long )name != (unsigned long )((void *)0)) {
      {
#line 181
      tmp = strcmp(l->name, name);
      }
#line 181
      if (tmp == 0) {
#line 182
        return ((int )(l - long_options));
      } else {
#line 184
        l ++;
      }
    } else {
#line 184
      l ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 186
    return ((int )(l - long_options));
  } else {
#line 188
    return (-1);
  }
}
}
#line 224 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static error_t group_parse(struct group *group , struct argp_state *state , int key ,
                           char *arg___0 ) 
{ 
  error_t err ;

  {
#line 227
  if (group->parser) {
    {
#line 230
    state->hook = group->hook;
#line 231
    state->input = group->input;
#line 232
    state->child_inputs = group->child_inputs;
#line 233
    state->arg_num = group->args_processed;
#line 234
    err = (*(group->parser))(key, arg___0, state);
#line 235
    group->hook = state->hook;
    }
#line 236
    return (err);
  } else {
#line 239
    return (7);
  }
}
}
#line 289 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static struct group *convert_options(struct argp  const  *argp___0 , struct group *parent ,
                                     unsigned int parent_index , struct group *group ,
                                     struct parser_convert_state *cvt ) 
{ 
  struct argp_option  const  *real ;
  struct argp_child  const  *children ;
  struct argp_option  const  *opt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int num_children ;
  struct group *tmp___6 ;
  unsigned int index___0 ;
  unsigned int tmp___7 ;
  struct argp_child  const  *tmp___8 ;

  {
#line 295
  real = (struct argp_option  const  *)argp___0->options;
#line 296
  children = (struct argp_child  const  *)argp___0->children;
#line 298
  if (real) {
#line 298
    goto _L;
  } else
#line 298
  if (argp___0->parser) {
    _L: /* CIL Label */ 
#line 302
    if (real) {
#line 303
      opt = real;
      {
#line 303
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 303
        tmp___5 = _option_is_end(opt);
        }
#line 303
        if (tmp___5) {
#line 303
          goto while_break;
        }
#line 305
        if (! (opt->flags & 4)) {
#line 307
          real = opt;
        }
#line 309
        if (! (real->flags & 8)) {
          {
#line 312
          tmp___2 = _option_is_short(opt);
          }
#line 312
          if (tmp___2) {
#line 315
            tmp = cvt->short_end;
#line 315
            (cvt->short_end) ++;
#line 315
            *tmp = (char )opt->key;
#line 316
            if (real->arg) {
#line 318
              tmp___0 = cvt->short_end;
#line 318
              (cvt->short_end) ++;
#line 318
              *tmp___0 = (char )':';
#line 319
              if (real->flags & 1) {
#line 320
                tmp___1 = cvt->short_end;
#line 320
                (cvt->short_end) ++;
#line 320
                *tmp___1 = (char )':';
              }
            }
#line 322
            *(cvt->short_end) = (char )'\000';
          }
#line 325
          if (opt->name) {
            {
#line 325
            tmp___4 = find_long_option((cvt->parser)->long_opts, (char const   *)opt->name);
            }
#line 325
            if (tmp___4 < 0) {
#line 329
              (cvt->long_end)->name = (char const   *)opt->name;
#line 330
              if (real->arg) {
#line 330
                if (real->flags & 1) {
#line 330
                  tmp___3 = 2;
                } else {
#line 330
                  tmp___3 = 1;
                }
#line 330
                (cvt->long_end)->has_arg = tmp___3;
              } else {
#line 330
                (cvt->long_end)->has_arg = 0;
              }
#line 336
              (cvt->long_end)->flag = (int *)0;
#line 343
              (cvt->long_end)->val = (int )((long )((opt->key | real->key) & (int const   )((1 << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)) - 1)) + (((group - (cvt->parser)->groups) + 1L) << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)));
#line 348
              (cvt->long_end) ++;
#line 348
              (cvt->long_end)->name = (char const   *)((void *)0);
            }
          }
        }
#line 303
        opt ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 353
    group->parser = (error_t (*)(int key , char *arg , struct argp_state *state ))argp___0->parser;
#line 354
    group->argp = argp___0;
#line 355
    group->short_end = cvt->short_end;
#line 356
    group->args_processed = 0U;
#line 357
    group->parent = parent;
#line 358
    group->parent_index = parent_index;
#line 359
    group->input = (void *)0;
#line 360
    group->hook = (void *)0;
#line 361
    group->child_inputs = (void **)0;
#line 363
    if (children) {
#line 367
      num_children = 0U;
      {
#line 368
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 368
        if (! (children + num_children)->argp) {
#line 368
          goto while_break___0;
        }
#line 369
        num_children ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 370
      group->child_inputs = cvt->child_inputs_end;
#line 371
      cvt->child_inputs_end += num_children;
    }
#line 374
    tmp___6 = group;
#line 374
    group ++;
#line 374
    parent = tmp___6;
  } else {
#line 377
    parent = (struct group *)0;
  }
#line 379
  if (children) {
#line 381
    index___0 = 0U;
    {
#line 382
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 382
      if (! children->argp) {
#line 382
        goto while_break___1;
      }
      {
#line 383
      tmp___7 = index___0;
#line 383
      index___0 ++;
#line 383
      tmp___8 = children;
#line 383
      children ++;
#line 383
      group = convert_options((struct argp  const  *)tmp___8->argp, parent, tmp___7,
                              group, cvt);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 387
  return (group);
}
}
#line 391 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static void parser_convert(struct parser *parser , struct argp  const  *argp___0 ,
                           int flags ) 
{ 
  struct parser_convert_state cvt ;
  char *tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;

  {
#line 396
  cvt.parser = parser;
#line 397
  cvt.short_end = parser->short_opts;
#line 398
  cvt.long_end = parser->long_opts;
#line 399
  cvt.child_inputs_end = parser->child_inputs;
#line 401
  if (flags & 8) {
#line 402
    tmp = cvt.short_end;
#line 402
    (cvt.short_end) ++;
#line 402
    *tmp = (char )'-';
  } else
#line 403
  if (flags & 4) {
#line 404
    tmp___0 = cvt.short_end;
#line 404
    (cvt.short_end) ++;
#line 404
    *tmp___0 = (char )'+';
  }
#line 405
  *(cvt.short_end) = (char )'\000';
#line 407
  (cvt.long_end)->name = (char const   *)((void *)0);
#line 409
  parser->argp = argp___0;
#line 411
  if (argp___0) {
    {
#line 412
    parser->egroup = convert_options(argp___0, (struct group *)0, 0U, parser->groups,
                                     & cvt);
    }
  } else {
#line 414
    parser->egroup = parser->groups;
  }
#line 415
  return;
}
}
#line 430 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static void calc_sizes(struct argp  const  *argp___0 , struct parser_sizes *szs ) 
{ 
  struct argp_child  const  *child ;
  struct argp_option  const  *opt ;
  int num_opts ;
  struct argp_option  const  *tmp ;
  int tmp___0 ;
  struct argp_child  const  *tmp___1 ;

  {
#line 433
  child = (struct argp_child  const  *)argp___0->children;
#line 434
  opt = (struct argp_option  const  *)argp___0->options;
#line 436
  if (opt) {
#line 436
    goto _L;
  } else
#line 436
  if (argp___0->parser) {
    _L: /* CIL Label */ 
#line 438
    (szs->num_groups) ++;
#line 439
    if (opt) {
#line 441
      num_opts = 0;
      {
#line 442
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 442
        tmp = opt;
#line 442
        opt ++;
#line 442
        tmp___0 = _option_is_end(tmp);
        }
#line 442
        if (tmp___0) {
#line 442
          goto while_break;
        }
#line 443
        num_opts ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 444
      szs->short_len += (size_t )(num_opts * 3);
#line 445
      szs->long_len += (size_t )num_opts;
    }
  }
#line 449
  if (child) {
    {
#line 450
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 450
      if (! child->argp) {
#line 450
        goto while_break___0;
      }
      {
#line 452
      tmp___1 = child;
#line 452
      child ++;
#line 452
      calc_sizes((struct argp  const  *)tmp___1->argp, szs);
#line 453
      (szs->num_child_inputs) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 455
  return;
}
}
#line 458 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static error_t parser_init(struct parser *parser , struct argp  const  *argp___0 ,
                           int argc , char **argv , int flags , void *input ) 
{ 
  error_t err ;
  struct group *group ;
  struct parser_sizes szs ;
  struct _getopt_data opt_data ;
  char *storage ;
  size_t glen ;
  size_t gsum ;
  size_t clen ;
  size_t csum ;
  size_t llen ;
  size_t lsum ;
  size_t slen ;
  size_t ssum ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
#line 462
  err = 0;
#line 465
  opt_data.rpl_optind = 1;
#line 465
  opt_data.rpl_opterr = 1;
#line 465
  opt_data.rpl_optopt = 0;
#line 465
  opt_data.rpl_optarg = (char *)0;
#line 465
  opt_data.__initialized = 0;
#line 465
  opt_data.__nextchar = (char *)0;
#line 465
  opt_data.__ordering = 0U;
#line 465
  opt_data.__posixly_correct = 0;
#line 465
  opt_data.__first_nonopt = 0;
#line 465
  opt_data.__last_nonopt = 0;
#line 472
  if (flags & 4) {
#line 472
    szs.short_len = (size_t )0;
  } else {
#line 472
    szs.short_len = (size_t )1;
  }
#line 473
  szs.long_len = (size_t )0;
#line 474
  szs.num_groups = (size_t )0;
#line 475
  szs.num_child_inputs = (size_t )0;
#line 477
  if (argp___0) {
    {
#line 478
    calc_sizes(argp___0, & szs);
    }
  }
  {
#line 481
  glen = (size_t )((unsigned long )(szs.num_groups + 1U) * sizeof(struct group ));
#line 482
  clen = (size_t )((unsigned long )szs.num_child_inputs * sizeof(void *));
#line 483
  llen = (size_t )((unsigned long )(szs.long_len + 1U) * sizeof(struct rpl_option ));
#line 484
  slen = szs.short_len + 1U;
#line 491
  gsum = glen;
#line 492
  csum = (size_t )(((((unsigned long )(gsum + clen) + (unsigned long )(& ((struct __anonstruct_33 *)0)->x)) - 1UL) / (unsigned long )(& ((struct __anonstruct_35 *)0)->x)) * (unsigned long )(& ((struct __anonstruct_37 *)0)->x));
#line 493
  lsum = csum + llen;
#line 494
  ssum = lsum + slen;
#line 496
  parser->storage = malloc(ssum);
  }
#line 497
  if (! parser->storage) {
#line 498
    return (12);
  }
  {
#line 500
  storage = (char *)parser->storage;
#line 501
  parser->groups = (struct group *)parser->storage;
#line 502
  parser->child_inputs = (void **)(storage + gsum);
#line 503
  parser->long_opts = (struct rpl_option *)(storage + csum);
#line 504
  parser->short_opts = storage + lsum;
#line 505
  parser->opt_data = opt_data;
#line 507
  memset((void *)parser->child_inputs, 0, clen);
#line 508
  parser_convert(parser, argp___0, flags);
#line 510
  memset((void *)(& parser->state), 0, (size_t )sizeof(struct argp_state ));
#line 511
  parser->state.root_argp = parser->argp;
#line 512
  parser->state.argc = argc;
#line 513
  parser->state.argv = argv;
#line 514
  parser->state.flags = (unsigned int )flags;
#line 515
  parser->state.err_stream = stderr;
#line 516
  parser->state.out_stream = stdout;
#line 517
  parser->state.next = 0;
#line 518
  parser->state.pstate = (void *)parser;
#line 520
  parser->try_getopt = 1;
  }
#line 524
  if ((unsigned long )parser->groups < (unsigned long )parser->egroup) {
#line 525
    (parser->groups)->input = input;
  }
#line 526
  group = parser->groups;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 526
      if (! (! err)) {
#line 526
        if (! (err == 7)) {
#line 526
          goto while_break;
        }
      }
    } else {
#line 526
      goto while_break;
    }
#line 530
    if (group->parent) {
#line 532
      group->input = *((group->parent)->child_inputs + group->parent_index);
    }
#line 534
    if (! group->parser) {
#line 534
      if ((group->argp)->children) {
#line 534
        if (((group->argp)->children)->argp) {
#line 539
          *(group->child_inputs + 0) = group->input;
        }
      }
    }
    {
#line 541
    err = group_parse(group, & parser->state, 16777219, (char *)0);
#line 526
    group ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  if (err == 7) {
#line 544
    err = 0;
  }
#line 546
  if (err) {
#line 547
    return (err);
  }
#line 549
  if (parser->state.flags & 2U) {
#line 551
    parser->opt_data.rpl_opterr = 0;
#line 552
    if (parser->state.flags & 1U) {
#line 555
      (parser->state.argv) --;
#line 555
      (parser->state.argc) ++;
    }
  } else {
#line 558
    parser->opt_data.rpl_opterr = 1;
  }
#line 560
  if ((unsigned long )parser->state.argv == (unsigned long )argv) {
#line 560
    if (*(argv + 0)) {
      {
#line 562
      parser->state.name = last_component((char const   *)*(argv + 0));
      }
    } else {
#line 564
      parser->state.name = program_invocation_short_name;
    }
  } else {
#line 564
    parser->state.name = program_invocation_short_name;
  }
#line 566
  return (0);
}
}
#line 570 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static error_t parser_finalize(struct parser *parser , error_t err , int arg_ebadkey ,
                               int *end_index ) 
{ 
  struct group *group ;
  char *tmp ;
  char *__cil_tmp7 ;

  {
#line 576
  if (err == 7) {
#line 576
    if (arg_ebadkey) {
#line 578
      err = 0;
    }
  }
#line 580
  if (! err) {
#line 582
    if (parser->state.next == parser->state.argc) {
#line 586
      group = parser->groups;
      {
#line 586
      while (1) {
        while_continue: /* CIL Label */ ;
#line 586
        if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 586
          if (! (! err)) {
#line 586
            if (! (err == 7)) {
#line 586
              goto while_break;
            }
          }
        } else {
#line 586
          goto while_break;
        }
#line 589
        if (group->args_processed == 0U) {
          {
#line 590
          err = group_parse(group, & parser->state, 16777218, (char *)0);
          }
        }
#line 586
        group ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 591
      group = parser->egroup - 1;
      {
#line 591
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 591
        if ((unsigned long )group >= (unsigned long )parser->groups) {
#line 591
          if (! (! err)) {
#line 591
            if (! (err == 7)) {
#line 591
              goto while_break___0;
            }
          }
        } else {
#line 591
          goto while_break___0;
        }
        {
#line 594
        err = group_parse(group, & parser->state, 16777217, (char *)0);
#line 591
        group --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 596
      if (err == 7) {
#line 597
        err = 0;
      }
#line 600
      if (end_index) {
#line 601
        *end_index = parser->state.next;
      }
    } else
#line 603
    if (end_index) {
#line 605
      *end_index = parser->state.next;
    } else {
#line 609
      if (! (parser->state.flags & 2U)) {
#line 609
        if (parser->state.err_stream) {
          {
#line 611
          tmp = dgettext((char const   *)(parser->argp)->argp_domain, "%s: Too many arguments\n");
#line 611
          fprintf((FILE */* __restrict  */)parser->state.err_stream, (char const   */* __restrict  */)tmp,
                  parser->state.name);
          }
        }
      }
#line 615
      err = 7;
    }
  }
#line 622
  if (err) {
#line 625
    if (err == 7) {
      {
#line 628
      argp_state_help((struct argp_state  const  */* __restrict  */)(& parser->state),
                      (FILE */* __restrict  */)parser->state.err_stream, 260U);
      }
    }
#line 632
    group = parser->groups;
    {
#line 632
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 632
      if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 632
        goto while_break___1;
      }
      {
#line 633
      group_parse(group, & parser->state, 16777221, (char *)0);
#line 632
      group ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 641
    group = parser->egroup - 1;
    {
#line 641
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 641
      if ((unsigned long )group >= (unsigned long )parser->groups) {
#line 641
        if (! (! err)) {
#line 641
          if (! (err == 7)) {
#line 641
            goto while_break___2;
          }
        }
      } else {
#line 641
        goto while_break___2;
      }
      {
#line 644
      err = group_parse(group, & parser->state, 16777220, (char *)0);
#line 641
      group --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 645
    if (err == 7) {
#line 646
      err = 0;
    }
  }
#line 650
  group = parser->egroup - 1;
  {
#line 650
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 650
    if (! ((unsigned long )group >= (unsigned long )parser->groups)) {
#line 650
      goto while_break___3;
    }
    {
#line 651
    group_parse(group, & parser->state, 16777223, (char *)0);
#line 650
    group --;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 653
  if (err == 7) {
#line 654
    err = 22;
  }
  {
#line 656
  free(parser->storage);
  }
#line 658
  return (err);
}
}
#line 666 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static error_t parser_parse_arg(struct parser *parser , char *val ) 
{ 
  int index___0 ;
  error_t err ;
  struct group *group ;
  int key ;

  {
#line 671
  (parser->state.next) --;
#line 671
  index___0 = parser->state.next;
#line 672
  err = 7;
#line 674
  key = 0;
#line 677
  group = parser->groups;
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 677
      if (! (err == 7)) {
#line 677
        goto while_break;
      }
    } else {
#line 677
      goto while_break;
    }
    {
#line 681
    (parser->state.next) ++;
#line 682
    key = 0;
#line 683
    err = group_parse(group, & parser->state, key, val);
    }
#line 685
    if (err == 7) {
      {
#line 688
      (parser->state.next) --;
#line 689
      key = 16777222;
#line 690
      err = group_parse(group, & parser->state, key, (char *)0);
      }
    }
#line 677
    group ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  if (! err) {
#line 696
    if (key == 16777222) {
#line 700
      parser->state.next = parser->state.argc;
    }
#line 702
    if (parser->state.next > index___0) {
#line 706
      group --;
#line 706
      group->args_processed += (unsigned int )(parser->state.next - index___0);
    } else {
#line 709
      parser->try_getopt = 1;
    }
  }
#line 712
  return (err);
}
}
#line 755
static error_t parser_parse_opt(struct parser *parser , int opt , char *val ) ;
#line 755 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static char const   bad_key_err[53]  = 
#line 755
  {      (char const   )'(',      (char const   )'P',      (char const   )'R',      (char const   )'O', 
        (char const   )'G',      (char const   )'R',      (char const   )'A',      (char const   )'M', 
        (char const   )' ',      (char const   )'E',      (char const   )'R',      (char const   )'R', 
        (char const   )'O',      (char const   )'R',      (char const   )')',      (char const   )' ', 
        (char const   )'O',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'s', 
        (char const   )'h',      (char const   )'o',      (char const   )'u',      (char const   )'l', 
        (char const   )'d',      (char const   )' ',      (char const   )'h',      (char const   )'a', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )'b', 
        (char const   )'e',      (char const   )'e',      (char const   )'n',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'o', 
        (char const   )'g',      (char const   )'n',      (char const   )'i',      (char const   )'z', 
        (char const   )'e',      (char const   )'d',      (char const   )'!',      (char const   )'?', 
        (char const   )'\000'};
#line 717 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static error_t parser_parse_opt(struct parser *parser , int opt , char *val ) 
{ 
  int group_key ;
  error_t err ;
  struct group *group ;
  char *short_index ;
  char *tmp ;
  char *tmp___0 ;
  struct rpl_option *long_opt ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 722
  group_key = opt >> (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL);
#line 723
  err = 7;
#line 725
  if (group_key == 0) {
    {
#line 731
    tmp = strchr((char const   *)parser->short_opts, opt);
#line 731
    short_index = tmp;
    }
#line 733
    if (short_index) {
#line 734
      group = parser->groups;
      {
#line 734
      while (1) {
        while_continue: /* CIL Label */ ;
#line 734
        if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 734
          goto while_break;
        }
#line 735
        if ((unsigned long )group->short_end > (unsigned long )short_index) {
          {
#line 737
          err = group_parse(group, & parser->state, opt, parser->opt_data.rpl_optarg);
          }
#line 739
          goto while_break;
        }
#line 734
        group ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 745
    err = group_parse(parser->groups + (group_key - 1), & parser->state, (opt << 8) >> 8,
                      parser->opt_data.rpl_optarg);
    }
  }
#line 750
  if (err == 7) {
#line 757
    if (group_key == 0) {
      {
#line 758
      tmp___0 = dgettext((char const   *)(parser->argp)->argp_domain, bad_key_err);
#line 758
      argp_error((struct argp_state  const  */* __restrict  */)(& parser->state),
                 (char const   */* __restrict  */)"-%c: %s", opt, tmp___0);
      }
    } else {
#line 762
      long_opt = parser->long_opts;
      {
#line 763
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 763
        if (long_opt->val != opt) {
#line 763
          if (! long_opt->name) {
#line 763
            goto while_break___0;
          }
        } else {
#line 763
          goto while_break___0;
        }
#line 764
        long_opt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 765
      tmp___1 = dgettext((char const   *)(parser->argp)->argp_domain, bad_key_err);
      }
#line 765
      if (long_opt->name) {
#line 765
        tmp___2 = long_opt->name;
      } else {
#line 765
        tmp___2 = "???";
      }
      {
#line 765
      argp_error((struct argp_state  const  */* __restrict  */)(& parser->state),
                 (char const   */* __restrict  */)"--%s: %s", tmp___2, tmp___1);
      }
    }
  }
#line 771
  return (err);
}
}
#line 778 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
static error_t parser_parse_next(struct parser *parser , int *arg_ebadkey ) 
{ 
  int opt ;
  error_t err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 782
  err = 0;
#line 784
  if (parser->state.quoted) {
#line 784
    if (parser->state.next < parser->state.quoted) {
#line 789
      parser->state.quoted = 0;
    }
  }
#line 791
  if (parser->try_getopt) {
#line 791
    if (! parser->state.quoted) {
#line 795
      parser->opt_data.rpl_optind = parser->state.next;
#line 797
      parser->opt_data.rpl_optopt = -1;
#line 798
      if (parser->state.flags & 64U) {
        {
#line 799
        opt = _getopt_long_only_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                                  (struct rpl_option  const  *)parser->long_opts,
                                  (int *)0, & parser->opt_data);
        }
      } else {
        {
#line 803
        opt = _getopt_long_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                             (struct rpl_option  const  *)parser->long_opts, (int *)0,
                             & parser->opt_data);
        }
      }
#line 807
      parser->state.next = parser->opt_data.rpl_optind;
#line 809
      if (opt == -1) {
#line 813
        parser->try_getopt = 0;
#line 814
        if (parser->state.next > 1) {
          {
#line 814
          tmp = strcmp((char const   *)*(parser->state.argv + (parser->state.next - 1)),
                       "--");
          }
#line 814
          if (tmp == 0) {
#line 821
            parser->state.quoted = parser->state.next;
          }
        }
      } else
#line 823
      if (opt == 63) {
#line 823
        if (parser->opt_data.rpl_optopt != -1) {
#line 828
          *arg_ebadkey = 0;
#line 829
          return (7);
        }
      }
    } else {
#line 833
      opt = -1;
    }
  } else {
#line 833
    opt = -1;
  }
#line 835
  if (opt == -1) {
#line 838
    if (parser->state.next >= parser->state.argc) {
#line 842
      *arg_ebadkey = 1;
#line 843
      return (7);
    } else
#line 838
    if (parser->state.flags & 4U) {
#line 842
      *arg_ebadkey = 1;
#line 843
      return (7);
    } else {
#line 848
      opt = 1;
#line 849
      tmp___0 = parser->state.next;
#line 849
      (parser->state.next) ++;
#line 849
      parser->opt_data.rpl_optarg = *(parser->state.argv + tmp___0);
    }
  }
#line 853
  if (opt == 1) {
    {
#line 855
    err = parser_parse_arg(parser, parser->opt_data.rpl_optarg);
    }
  } else {
    {
#line 857
    err = parser_parse_opt(parser, opt, parser->opt_data.rpl_optarg);
    }
  }
#line 859
  if (err == 7) {
#line 860
    if (opt == -1) {
#line 860
      tmp___1 = 1;
    } else
#line 860
    if (opt == 1) {
#line 860
      tmp___1 = 1;
    } else {
#line 860
      tmp___1 = 0;
    }
#line 860
    *arg_ebadkey = tmp___1;
  }
#line 862
  return (err);
}
}
#line 870 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
error_t argp_parse(struct argp  const  * __restrict  argp___0 , int argc , char ** __restrict  argv ,
                   unsigned int flags , int * __restrict  end_index , void * __restrict  input ) 
{ 
  error_t err ;
  struct parser parser ;
  int arg_ebadkey ;
  struct argp_child *child ;
  void *tmp ;
  struct argp *top_argp ;
  void *tmp___0 ;
  struct argp_child *tmp___1 ;
  struct argp_child *tmp___2 ;
  struct argp_child *tmp___3 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;

  {
#line 879
  arg_ebadkey = 0;
#line 882
  if (! (flags & 1U)) {
#line 885
    if (! program_invocation_name) {
#line 886
      program_invocation_name = *(argv + 0);
    }
#line 889
    if (! program_invocation_short_name) {
      {
#line 890
      program_invocation_short_name = last_component((char const   *)*(argv + 0));
      }
    }
  }
#line 895
  if (! (flags & 16U)) {
    {
#line 898
    tmp = __builtin_alloca(4UL * sizeof(struct argp_child ));
#line 898
    child = (struct argp_child *)tmp;
#line 899
    tmp___0 = __builtin_alloca(sizeof(struct argp ));
#line 899
    top_argp = (struct argp *)tmp___0;
#line 903
    memset((void *)top_argp, 0, (size_t )sizeof(*top_argp));
#line 904
    top_argp->children = (struct argp_child  const  *)child;
#line 906
    memset((void *)child, 0, (size_t )(4UL * sizeof(struct argp_child )));
    }
#line 908
    if (argp___0) {
#line 909
      tmp___1 = child;
#line 909
      child ++;
#line 909
      tmp___1->argp = (struct argp  const  *)argp___0;
    }
#line 910
    tmp___2 = child;
#line 910
    child ++;
#line 910
    tmp___2->argp = & argp_default_argp;
#line 911
    if (argp_program_version) {
#line 912
      tmp___3 = child;
#line 912
      child ++;
#line 912
      tmp___3->argp = & argp_version_argp;
    } else
#line 911
    if (argp_program_version_hook) {
#line 912
      tmp___3 = child;
#line 912
      child ++;
#line 912
      tmp___3->argp = & argp_version_argp;
    }
#line 913
    child->argp = (struct argp  const  *)0;
#line 915
    argp___0 = (struct argp  const  */* __restrict  */)top_argp;
  }
  {
#line 919
  err = parser_init(& parser, (struct argp  const  *)argp___0, argc, (char **)argv,
                    (int )flags, (void *)input);
  }
#line 921
  if (! err) {
    {
#line 924
    while (1) {
      while_continue: /* CIL Label */ ;
#line 924
      if (! (! err)) {
#line 924
        goto while_break;
      }
      {
#line 925
      err = parser_parse_next(& parser, & arg_ebadkey);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 926
    err = parser_finalize(& parser, err, arg_ebadkey, (int *)end_index);
    }
  }
#line 929
  return (err);
}
}
#line 937
 __attribute__((__nothrow__)) void *_argp_input(struct argp  const  * __restrict  argp___0 ,
                                                struct argp_state  const  * __restrict  state ) ;
#line 937 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-parse.c"
void *_argp_input(struct argp  const  * __restrict  argp___0 , struct argp_state  const  * __restrict  state ) 
{ 
  struct group *group ;
  struct parser *parser ;

  {
#line 940
  if (state) {
#line 943
    parser = (struct parser *)state->pstate;
#line 945
    group = parser->groups;
    {
#line 945
    while (1) {
      while_continue: /* CIL Label */ ;
#line 945
      if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 945
        goto while_break;
      }
#line 946
      if ((unsigned long )group->argp == (unsigned long )argp___0) {
#line 947
        return (group->input);
      }
#line 945
      group ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 950
  return ((void *)0);
}
}
#line 710 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 181 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
#line 274
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchrnul)(char const   *__s ,
                                                                                        int __c )  __attribute__((__pure__)) ;
#line 389
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) mempcpy)(void * __restrict  __dest ,
                                                                                        void const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 436
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strerror_r)(int __errnum ,
                                                                                         char *__buf ,
                                                                                         size_t __buflen ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 699 "/usr/include/stdio.h"
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 886
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 893
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 463 "/home/ysko/Works/test-src/pies-1.2/gnu/argp.h"
char const   *argp_program_bug_address ;
#line 468
error_t argp_err_exit_status ;
#line 501
void argp_help(struct argp  const  * __restrict  argp___0 , FILE * __restrict  stream ,
               unsigned int flags , char * __restrict  name ) ;
#line 549
void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  state ,
                                             int status , int errnum , char const   * __restrict  fmt 
                                             , ...) ;
#line 123 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) ;
#line 130
void argp_fmtstream_free(argp_fmtstream_t fs ) ;
#line 135
ssize_t ( /* format attribute */  argp_fmtstream_printf)(struct argp_fmtstream *fs ,
                                                         char const   *fmt  , ...) ;
#line 141
int argp_fmtstream_putc(argp_fmtstream_t __fs , int __ch ) ;
#line 144
int argp_fmtstream_puts(argp_fmtstream_t __fs , char const   *__str ) ;
#line 148
size_t argp_fmtstream_write(argp_fmtstream_t __fs , char const   *__str , size_t __len ) ;
#line 162
size_t argp_fmtstream_set_lmargin(argp_fmtstream_t __fs , size_t __lmargin ) ;
#line 174
size_t argp_fmtstream_set_wmargin(argp_fmtstream_t __fs , size_t __wmargin ) ;
#line 180
size_t argp_fmtstream_point(argp_fmtstream_t __fs ) ;
#line 105 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static struct uparams uparams  = 
#line 105 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
     {0, 1, 2, 6, 2, 29, 1, 12, 79, 0};
#line 121 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static struct uparam_name  const  uparam_names[10]  = 
#line 121
  {      {"dup-args", 1, (size_t )((unsigned long )(& ((struct uparams *)0)->dup_args))}, 
        {"dup-args-note",
      1, (size_t )((unsigned long )(& ((struct uparams *)0)->dup_args_note))}, 
        {"short-opt-col", 0, (size_t )((unsigned long )(& ((struct uparams *)0)->short_opt_col))}, 
        {"long-opt-col",
      0, (size_t )((unsigned long )(& ((struct uparams *)0)->long_opt_col))}, 
        {"doc-opt-col", 0, (size_t )((unsigned long )(& ((struct uparams *)0)->doc_opt_col))}, 
        {"opt-doc-col",
      0, (size_t )((unsigned long )(& ((struct uparams *)0)->opt_doc_col))}, 
        {"header-col", 0, (size_t )((unsigned long )(& ((struct uparams *)0)->header_col))}, 
        {"usage-indent",
      0, (size_t )((unsigned long )(& ((struct uparams *)0)->usage_indent))}, 
        {"rmargin", 0, (size_t )((unsigned long )(& ((struct uparams *)0)->rmargin))}, 
        {(char const   *)0,
      0, 0U}};
#line 135 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void validate_uparams(struct argp_state  const  *state , struct uparams *upptr ) 
{ 
  struct uparam_name  const  *up ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 140
  up = uparam_names;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! up->name) {
#line 140
      goto while_break;
    }
#line 142
    if (up->is_bool) {
#line 144
      goto __Cont;
    } else
#line 142
    if ((unsigned long )up->uparams_offs == (unsigned long )(& ((struct uparams *)0)->rmargin)) {
#line 144
      goto __Cont;
    }
#line 145
    if (*((int *)((char *)upptr + up->uparams_offs)) >= upptr->rmargin) {
      {
#line 147
      tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "ARGP_HELP_FMT: %s value is less than or equal to %s");
#line 147
      argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0, (char const   */* __restrict  */)tmp,
                   "rmargin", up->name);
      }
#line 152
      return;
    }
    __Cont: /* CIL Label */ 
#line 140
    up ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  uparams = *upptr;
#line 156
  uparams.valid = 1;
#line 157
  return;
}
}
#line 160 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void fill_in_uparams(struct argp_state  const  *state ) 
{ 
  char const   *var ;
  char *tmp ;
  struct uparams new_params ;
  unsigned short const   **tmp___0 ;
  size_t var_len ;
  struct uparam_name  const  *un ;
  int unspec ;
  int val ;
  char const   *arg___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 163
  tmp = getenv("ARGP_HELP_FMT");
#line 163
  var = (char const   *)tmp;
#line 164
  new_params = uparams;
  }
#line 168
  if (var) {
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
#line 171
      if (! *var) {
#line 171
        goto while_break;
      }
      {
#line 173
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 173
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 173
          tmp___0 = __ctype_b_loc();
          }
#line 173
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*var)) & 8192)) {
#line 173
            goto while_break___1;
          }
#line 173
          var ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 173
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 175
      tmp___13 = __ctype_b_loc();
      }
#line 175
      if ((int const   )*(*tmp___13 + (int )((unsigned char )*var)) & 1024) {
#line 179
        unspec = 0;
#line 179
        val = 0;
#line 180
        arg___0 = var;
        {
#line 182
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 182
          tmp___1 = __ctype_b_loc();
          }
#line 182
          if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*arg___0)) & 8)) {
#line 182
            if (! ((int const   )*arg___0 == 45)) {
#line 182
              if (! ((int const   )*arg___0 == 95)) {
#line 182
                goto while_break___2;
              }
            }
          }
#line 183
          arg___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 184
        var_len = (size_t )(arg___0 - var);
        {
#line 186
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 186
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 186
            tmp___2 = __ctype_b_loc();
            }
#line 186
            if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 186
              goto while_break___4;
            }
#line 186
            arg___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 186
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 188
        if ((int const   )*arg___0 == 0) {
#line 189
          unspec = 1;
        } else
#line 188
        if ((int const   )*arg___0 == 44) {
#line 189
          unspec = 1;
        } else
#line 190
        if ((int const   )*arg___0 == 61) {
#line 192
          arg___0 ++;
          {
#line 193
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 193
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 193
              tmp___3 = __ctype_b_loc();
              }
#line 193
              if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 193
                goto while_break___6;
              }
#line 193
              arg___0 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 193
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 196
        if (unspec) {
#line 198
          if ((int const   )*(var + 0) == 110) {
#line 198
            if ((int const   )*(var + 1) == 111) {
#line 198
              if ((int const   )*(var + 2) == 45) {
#line 200
                val = 0;
#line 201
                var += 3;
#line 202
                var_len -= 3U;
              } else {
#line 205
                val = 1;
              }
            } else {
#line 205
              val = 1;
            }
          } else {
#line 205
            val = 1;
          }
        } else {
          {
#line 207
          tmp___6 = __ctype_b_loc();
          }
#line 207
          if ((int const   )*(*tmp___6 + (int )((unsigned char )*arg___0)) & 2048) {
            {
#line 209
            val = atoi(arg___0);
            }
            {
#line 210
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 210
              tmp___4 = __ctype_b_loc();
              }
#line 210
              if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*arg___0)) & 2048)) {
#line 210
                goto while_break___7;
              }
#line 211
              arg___0 ++;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 212
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 212
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 212
                tmp___5 = __ctype_b_loc();
                }
#line 212
                if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 212
                  goto while_break___9;
                }
#line 212
                arg___0 ++;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 212
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        }
#line 215
        un = uparam_names;
        {
#line 215
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 215
          if (! un->name) {
#line 215
            goto while_break___10;
          }
          {
#line 216
          tmp___9 = strlen((char const   *)un->name);
          }
#line 216
          if (tmp___9 == var_len) {
            {
#line 216
            tmp___10 = strncmp(var, (char const   *)un->name, var_len);
            }
#line 216
            if (tmp___10 == 0) {
#line 219
              if (unspec) {
#line 219
                if (! un->is_bool) {
                  {
#line 220
                  tmp___7 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                     "%.*s: ARGP_HELP_FMT parameter requires a value");
#line 220
                  argp_failure((struct argp_state  const  */* __restrict  */)state,
                               0, 0, (char const   */* __restrict  */)tmp___7, (int )var_len,
                               var);
                  }
                } else {
#line 219
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 225
              if (val < 0) {
                {
#line 226
                tmp___8 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                   "%.*s: ARGP_HELP_FMT parameter must be positive");
#line 226
                argp_failure((struct argp_state  const  */* __restrict  */)state,
                             0, 0, (char const   */* __restrict  */)tmp___8, (int )var_len,
                             var);
                }
              } else {
#line 232
                *((int *)((char *)(& new_params) + un->uparams_offs)) = val;
              }
#line 233
              goto while_break___10;
            }
          }
#line 215
          un ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 235
        if (! un->name) {
          {
#line 236
          tmp___11 = dgettext((char const   *)(state->root_argp)->argp_domain, "%.*s: Unknown ARGP_HELP_FMT parameter");
#line 236
          argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0,
                       (char const   */* __restrict  */)tmp___11, (int )var_len, var);
          }
        }
#line 241
        var = arg___0;
#line 242
        if ((int const   )*var == 44) {
#line 243
          var ++;
        }
      } else
#line 245
      if (*var) {
        {
#line 247
        tmp___12 = dgettext((char const   *)(state->root_argp)->argp_domain, "Garbage in ARGP_HELP_FMT: %s");
#line 247
        argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0, (char const   */* __restrict  */)tmp___12,
                     var);
        }
#line 250
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 253
    validate_uparams(state, & new_params);
    }
  }
#line 255
  return;
}
}
#line 341 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int find_char(char ch___0 , char *beg , char *end ) 
{ 


  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((unsigned long )beg < (unsigned long )end)) {
#line 344
      goto while_break;
    }
#line 345
    if ((int )*beg == (int )ch___0) {
#line 346
      return (1);
    } else {
#line 348
      beg ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return (0);
}
}
#line 433 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static struct hol *make_hol(struct argp  const  *argp___0 , struct hol_cluster *cluster ) 
{ 
  char *so ;
  struct argp_option  const  *o ;
  struct argp_option  const  *opts ;
  struct hol_entry *entry ;
  unsigned int num_short_options ;
  struct hol *hol ;
  void *tmp ;
  int cur_group ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 438
  opts = (struct argp_option  const  *)argp___0->options;
#line 440
  num_short_options = 0U;
#line 441
  tmp = malloc((size_t )sizeof(struct hol ));
#line 441
  hol = (struct hol *)tmp;
  }
#line 443
  if (! hol) {
    {
#line 443
    __assert_fail("hol", "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c", 443U,
                  "make_hol");
    }
  }
#line 445
  hol->num_entries = 0U;
#line 446
  hol->clusters = (struct hol_cluster *)0;
#line 448
  if (opts) {
#line 450
    cur_group = 0;
#line 453
    if (! (! (opts->flags & 4))) {
      {
#line 453
      __assert_fail("! ((opts)->flags & 0x4)", "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c",
                    453U, "make_hol");
      }
    }
#line 456
    o = opts;
    {
#line 456
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 456
      tmp___1 = _option_is_end(o);
      }
#line 456
      if (tmp___1) {
#line 456
        goto while_break;
      }
#line 458
      if (! (o->flags & 4)) {
#line 459
        (hol->num_entries) ++;
      }
      {
#line 460
      tmp___0 = _option_is_short(o);
      }
#line 460
      if (tmp___0) {
#line 461
        num_short_options ++;
      }
#line 456
      o ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 464
    tmp___2 = malloc((size_t )(sizeof(struct hol_entry ) * (unsigned long )hol->num_entries));
#line 464
    hol->entries = (struct hol_entry *)tmp___2;
#line 465
    tmp___3 = malloc(num_short_options + 1U);
#line 465
    hol->short_options = (char *)tmp___3;
    }
#line 467
    if (hol->entries) {
#line 467
      if (! hol->short_options) {
        {
#line 467
        __assert_fail("hol->entries && hol->short_options", "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c",
                      467U, "make_hol");
        }
      }
    } else {
      {
#line 467
      __assert_fail("hol->entries && hol->short_options", "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c",
                    467U, "make_hol");
      }
    }
#line 469
    if (! ((unsigned long )hol->num_entries <= 4294967295UL / sizeof(struct hol_entry ))) {
      {
#line 469
      __assert_fail("hol->num_entries <= ((size_t) -1) / sizeof (struct hol_entry)",
                    "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c", 469U, "make_hol");
      }
    }
#line 472
    so = hol->short_options;
#line 473
    o = opts;
#line 473
    entry = hol->entries;
    {
#line 473
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 473
      tmp___9 = _option_is_end(o);
      }
#line 473
      if (tmp___9) {
#line 473
        goto while_break___0;
      }
#line 475
      entry->opt = o;
#line 476
      entry->num = 0U;
#line 477
      entry->short_options = so;
#line 478
      if (o->group) {
#line 478
        cur_group = (int )o->group;
      } else {
#line 478
        if (! o->name) {
#line 478
          if (! o->key) {
#line 478
            tmp___4 = cur_group + 1;
          } else {
#line 478
            tmp___4 = cur_group;
          }
        } else {
#line 478
          tmp___4 = cur_group;
        }
#line 478
        cur_group = tmp___4;
      }
#line 478
      entry->group = cur_group;
#line 484
      entry->cluster = cluster;
#line 485
      entry->argp = argp___0;
      {
#line 487
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 489
        (entry->num) ++;
#line 490
        tmp___6 = _option_is_short(o);
        }
#line 490
        if (tmp___6) {
          {
#line 490
          tmp___7 = find_char((char )o->key, hol->short_options, so);
          }
#line 490
          if (! tmp___7) {
#line 492
            tmp___5 = so;
#line 492
            so ++;
#line 492
            *tmp___5 = (char )o->key;
          }
        }
        {
#line 493
        o ++;
#line 487
        tmp___8 = _option_is_end(o);
        }
#line 487
        if (tmp___8) {
#line 487
          goto while_break___1;
        } else
#line 487
        if (! (o->flags & 4)) {
#line 487
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 473
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 497
    *so = (char )'\000';
  }
#line 500
  return (hol);
}
}
#line 506 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static struct hol_cluster *hol_add_cluster(struct hol *hol , int group , char const   *header ,
                                           int index___0 , struct hol_cluster *parent ,
                                           struct argp  const  *argp___0 ) 
{ 
  struct hol_cluster *cl ;
  void *tmp ;

  {
  {
#line 510
  tmp = malloc((size_t )sizeof(struct hol_cluster ));
#line 510
  cl = (struct hol_cluster *)tmp;
  }
#line 511
  if (cl) {
#line 513
    cl->group = group;
#line 514
    cl->header = header;
#line 516
    cl->index = index___0;
#line 517
    cl->parent = parent;
#line 518
    cl->argp = argp___0;
#line 519
    if (parent) {
#line 519
      cl->depth = parent->depth + 1;
    } else {
#line 519
      cl->depth = 0;
    }
#line 521
    cl->next = hol->clusters;
#line 522
    hol->clusters = cl;
  }
#line 524
  return (cl);
}
}
#line 528 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void hol_free(struct hol *hol ) 
{ 
  struct hol_cluster *cl ;
  struct hol_cluster *next ;

  {
#line 531
  cl = hol->clusters;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! cl) {
#line 533
      goto while_break;
    }
    {
#line 535
    next = cl->next;
#line 536
    free((void *)cl);
#line 537
    cl = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (hol->num_entries > 0U) {
    {
#line 542
    free((void *)hol->entries);
#line 543
    free((void *)hol->short_options);
    }
  }
  {
#line 546
  free((void *)hol);
  }
#line 547
  return;
}
}
#line 549 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int hol_entry_short_iterate(struct hol_entry  const  *entry , int (*func)(struct argp_option  const  *opt ,
                                                                                 struct argp_option  const  *real ,
                                                                                 char const   *domain ,
                                                                                 void *cookie ) ,
                                   char const   *domain , void *cookie ) 
{ 
  unsigned int nopts ;
  int val ;
  struct argp_option  const  *opt ;
  struct argp_option  const  *real ;
  char *so ;
  int tmp ;

  {
#line 557
  val = 0;
#line 558
  real = (struct argp_option  const  *)entry->opt;
#line 559
  so = (char *)entry->short_options;
#line 561
  opt = real;
#line 561
  nopts = (unsigned int )entry->num;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (nopts > 0U) {
#line 561
      if (! (! val)) {
#line 561
        goto while_break;
      }
    } else {
#line 561
      goto while_break;
    }
    {
#line 562
    tmp = _option_is_short(opt);
    }
#line 562
    if (tmp) {
#line 562
      if ((int )*so == (int )opt->key) {
#line 564
        if (! (opt->flags & 4)) {
#line 565
          real = opt;
        }
#line 566
        if (! (opt->flags & 2)) {
          {
#line 567
          val = (*func)(opt, real, domain, cookie);
          }
        }
#line 568
        so ++;
      }
    }
#line 561
    opt ++;
#line 561
    nopts --;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return (val);
}
}
#line 574 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
__inline static int ( __attribute__((__always_inline__)) hol_entry_long_iterate)(struct hol_entry  const  *entry ,
                                                                                 int (*func)(struct argp_option  const  *opt ,
                                                                                             struct argp_option  const  *real ,
                                                                                             char const   *domain ,
                                                                                             void *cookie ) ,
                                                                                 char const   *domain ,
                                                                                 void *cookie ) 
{ 
  unsigned int nopts ;
  int val ;
  struct argp_option  const  *opt ;
  struct argp_option  const  *real ;

  {
#line 583
  val = 0;
#line 584
  real = (struct argp_option  const  *)entry->opt;
#line 586
  opt = real;
#line 586
  nopts = (unsigned int )entry->num;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (nopts > 0U) {
#line 586
      if (! (! val)) {
#line 586
        goto while_break;
      }
    } else {
#line 586
      goto while_break;
    }
#line 587
    if (opt->name) {
#line 589
      if (! (opt->flags & 4)) {
#line 590
        real = opt;
      }
#line 591
      if (! (opt->flags & 2)) {
        {
#line 592
        val = (*func)(opt, real, domain, cookie);
        }
      }
    }
#line 586
    opt ++;
#line 586
    nopts --;
  }
  while_break: /* CIL Label */ ;
  }
#line 595
  return (val);
}
}
#line 599 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int until_short(struct argp_option  const  *opt , struct argp_option  const  *real ,
                       char const   *domain , void *cookie ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 603
  tmp___1 = _option_is_short(opt);
  }
#line 603
  if (tmp___1) {
#line 603
    tmp___0 = opt->key;
  } else {
#line 603
    tmp___0 = (int const   )0;
  }
#line 603
  return ((int )tmp___0);
}
}
#line 607 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static char hol_entry_first_short(struct hol_entry  const  *entry ) 
{ 
  int tmp ;

  {
  {
#line 610
  tmp = hol_entry_short_iterate(entry, & until_short, (char const   *)(entry->argp)->argp_domain,
                                (void *)0);
  }
#line 610
  return ((char )tmp);
}
}
#line 615 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static char const   *hol_entry_first_long(struct hol_entry  const  *entry ) 
{ 
  struct argp_option  const  *opt ;
  unsigned int num ;

  {
#line 620
  opt = (struct argp_option  const  *)entry->opt;
#line 620
  num = (unsigned int )entry->num;
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! (num > 0U)) {
#line 620
      goto while_break;
    }
#line 621
    if (opt->name) {
#line 621
      if (! (opt->flags & 2)) {
#line 622
        return ((char const   *)opt->name);
      }
    }
#line 620
    opt ++;
#line 620
    num --;
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  return ((char const   *)0);
}
}
#line 628 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static struct hol_entry *hol_find_entry(struct hol *hol , char const   *name ) 
{ 
  struct hol_entry *entry ;
  unsigned int num_entries ;
  struct argp_option  const  *opt ;
  unsigned int num_opts ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 631
  entry = hol->entries;
#line 632
  num_entries = hol->num_entries;
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    tmp___1 = num_entries;
#line 634
    num_entries --;
#line 634
    if (! (tmp___1 > 0U)) {
#line 634
      goto while_break;
    }
#line 636
    opt = entry->opt;
#line 637
    num_opts = entry->num;
    {
#line 639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 639
      tmp___0 = num_opts;
#line 639
      num_opts --;
#line 639
      if (! (tmp___0 > 0U)) {
#line 639
        goto while_break___0;
      }
#line 640
      if (opt->name) {
#line 640
        if (! (opt->flags & 2)) {
          {
#line 640
          tmp = strcmp((char const   *)opt->name, name);
          }
#line 640
          if (tmp == 0) {
#line 641
            return (entry);
          } else {
#line 643
            opt ++;
          }
        } else {
#line 643
          opt ++;
        }
      } else {
#line 643
        opt ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 645
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  return ((struct hol_entry *)0);
}
}
#line 653 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void hol_set_group(struct hol *hol , char const   *name , int group ) 
{ 
  struct hol_entry *entry ;
  struct hol_entry *tmp ;

  {
  {
#line 656
  tmp = hol_find_entry(hol, name);
#line 656
  entry = tmp;
  }
#line 657
  if (entry) {
#line 658
    entry->group = group;
  }
#line 659
  return;
}
}
#line 663 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int group_cmp(int group1 , int group2 , int eq ) 
{ 


  {
#line 666
  if (group1 == group2) {
#line 667
    return (eq);
  } else
#line 668
  if (group1 < 0) {
#line 668
    if (group2 < 0) {
#line 669
      return (group1 - group2);
    } else {
#line 668
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 668
  if (group1 >= 0) {
#line 668
    if (group2 >= 0) {
#line 669
      return (group1 - group2);
    } else {
#line 671
      return (group2 - group1);
    }
  } else {
#line 671
    return (group2 - group1);
  }
}
}
#line 676 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int hol_cluster_cmp(struct hol_cluster  const  *cl1 , struct hol_cluster  const  *cl2 ) 
{ 
  int tmp ;

  {
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (cl1->depth > cl2->depth)) {
#line 683
      goto while_break;
    }
#line 684
    cl1 = (struct hol_cluster  const  *)cl1->parent;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 685
    if (! (cl2->depth > cl1->depth)) {
#line 685
      goto while_break___0;
    }
#line 686
    cl2 = (struct hol_cluster  const  *)cl2->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 690
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 690
    if (! ((unsigned long )cl1->parent != (unsigned long )cl2->parent)) {
#line 690
      goto while_break___1;
    }
#line 691
    cl1 = (struct hol_cluster  const  *)cl1->parent;
#line 691
    cl2 = (struct hol_cluster  const  *)cl2->parent;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 693
  tmp = group_cmp((int )cl1->group, (int )cl2->group, (int )(cl2->index - cl1->index));
  }
#line 693
  return (tmp);
}
}
#line 698 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static struct hol_cluster *hol_cluster_base(struct hol_cluster *cl ) 
{ 


  {
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (! cl->parent) {
#line 701
      goto while_break;
    }
#line 702
    cl = cl->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return (cl);
}
}
#line 707 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int hol_cluster_is_child(struct hol_cluster  const  *cl1 , struct hol_cluster  const  *cl2 ) 
{ 


  {
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (cl1) {
#line 711
      if (! ((unsigned long )cl1 != (unsigned long )cl2)) {
#line 711
        goto while_break;
      }
    } else {
#line 711
      goto while_break;
    }
#line 712
    cl1 = (struct hol_cluster  const  *)cl1->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  return ((unsigned long )cl1 == (unsigned long )cl2);
}
}
#line 719 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int canon_doc_option(char const   **name ) 
{ 
  int non_opt ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 724
  if (! *name) {
#line 725
    non_opt = 1;
  } else {
    {
#line 729
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 729
      tmp = __ctype_b_loc();
      }
#line 729
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(*name))) & 8192)) {
#line 729
        goto while_break;
      }
#line 730
      (*name) ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 732
    non_opt = (int const   )*(*name) != 45;
    {
#line 734
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 734
      if (*(*name)) {
        {
#line 734
        tmp___0 = __ctype_b_loc();
        }
#line 734
        if ((int const   )*(*tmp___0 + (int )((unsigned char )*(*name))) & 8) {
#line 734
          goto while_break___0;
        }
      } else {
#line 734
        goto while_break___0;
      }
#line 735
      (*name) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 737
  return (non_opt);
}
}
#line 744 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int hol_entry_cmp(struct hol_entry  const  *entry1 , struct hol_entry  const  *entry2 ) 
{ 
  int group1 ;
  int group2 ;
  int rc ;
  struct hol_cluster *tmp ;
  int tmp___0 ;
  struct hol_cluster *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int short1 ;
  char tmp___5 ;
  int short2 ;
  char tmp___6 ;
  int doc1 ;
  int doc2 ;
  char const   *long1 ;
  char const   *tmp___7 ;
  char const   *long2 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned char first1 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned char first2 ;
  int tmp___13 ;
  int tmp___14 ;
  int lower_cmp ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 750
  group1 = (int )entry1->group;
#line 750
  group2 = (int )entry2->group;
#line 753
  if ((unsigned long )entry1->cluster != (unsigned long )entry2->cluster) {
#line 757
    if (! entry1->cluster) {
      {
#line 762
      tmp = hol_cluster_base((struct hol_cluster *)entry2->cluster);
#line 762
      tmp___0 = group_cmp(group1, tmp->group, -1);
      }
#line 762
      return (tmp___0);
    } else
#line 763
    if (! entry2->cluster) {
      {
#line 765
      tmp___1 = hol_cluster_base((struct hol_cluster *)entry1->cluster);
#line 765
      tmp___2 = group_cmp(tmp___1->group, group2, 1);
      }
#line 765
      return (tmp___2);
    } else {
      {
#line 768
      rc = hol_cluster_cmp((struct hol_cluster  const  *)entry1->cluster, (struct hol_cluster  const  *)entry2->cluster);
      }
#line 768
      if (rc) {
#line 768
        tmp___4 = rc;
      } else {
#line 768
        if (entry1->ord < entry2->ord) {
#line 768
          tmp___3 = -1;
        } else {
#line 768
          tmp___3 = 1;
        }
#line 768
        tmp___4 = tmp___3;
      }
#line 768
      return (tmp___4);
    }
  } else
#line 771
  if (group1 == group2) {
    {
#line 775
    tmp___5 = hol_entry_first_short(entry1);
#line 775
    short1 = (int )tmp___5;
#line 776
    tmp___6 = hol_entry_first_short(entry2);
#line 776
    short2 = (int )tmp___6;
#line 777
    doc1 = (int )((entry1->opt)->flags & 8);
#line 778
    doc2 = (int )((entry2->opt)->flags & 8);
#line 779
    tmp___7 = hol_entry_first_long(entry1);
#line 779
    long1 = tmp___7;
#line 780
    tmp___8 = hol_entry_first_long(entry2);
#line 780
    long2 = tmp___8;
    }
#line 782
    if (doc1) {
      {
#line 783
      doc1 = canon_doc_option(& long1);
      }
    }
#line 784
    if (doc2) {
      {
#line 785
      doc2 = canon_doc_option(& long2);
      }
    }
#line 787
    if (doc1 != doc2) {
#line 790
      return (doc1 - doc2);
    } else
#line 791
    if (! short1) {
#line 791
      if (! short2) {
#line 791
        if (long1) {
#line 791
          if (long2) {
            {
#line 793
            rc = strcasecmp(long1, long2);
            }
#line 793
            if (rc) {
#line 793
              tmp___10 = rc;
            } else {
#line 793
              if (entry1->ord < entry2->ord) {
#line 793
                tmp___9 = -1;
              } else {
#line 793
                tmp___9 = 1;
              }
#line 793
              tmp___10 = tmp___9;
            }
#line 793
            return (tmp___10);
          } else {
#line 791
            goto _L___1;
          }
        } else {
#line 791
          goto _L___1;
        }
      } else {
#line 791
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 802
      if (short1) {
#line 802
        tmp___12 = short1;
      } else {
#line 802
        if (long1) {
#line 802
          tmp___11 = (int const   )*long1;
        } else {
#line 802
          tmp___11 = (int const   )0;
        }
#line 802
        tmp___12 = (int )tmp___11;
      }
#line 802
      first1 = (unsigned char )tmp___12;
#line 803
      if (short2) {
#line 803
        tmp___14 = short2;
      } else {
#line 803
        if (long2) {
#line 803
          tmp___13 = (int const   )*long2;
        } else {
#line 803
          tmp___13 = (int const   )0;
        }
#line 803
        tmp___14 = (int )tmp___13;
      }
      {
#line 803
      first2 = (unsigned char )tmp___14;
#line 806
      tmp___15 = (int )tolower((int )first1);
#line 806
      tmp___16 = (int )tolower((int )first2);
#line 806
      lower_cmp = tmp___15 - tmp___16;
      }
#line 809
      if (lower_cmp) {
#line 809
        tmp___19 = lower_cmp;
      } else {
#line 809
        rc = (int )first2 - (int )first1;
#line 809
        if (rc) {
#line 809
          tmp___18 = rc;
        } else {
#line 809
          if (entry1->ord < entry2->ord) {
#line 809
            tmp___17 = -1;
          } else {
#line 809
            tmp___17 = 1;
          }
#line 809
          tmp___18 = tmp___17;
        }
#line 809
        tmp___19 = tmp___18;
      }
#line 809
      return (tmp___19);
    }
  } else {
#line 817
    if (entry1->ord < entry2->ord) {
#line 817
      tmp___20 = -1;
    } else {
#line 817
      tmp___20 = 1;
    }
    {
#line 817
    tmp___21 = group_cmp(group1, group2, tmp___20);
    }
#line 817
    return (tmp___21);
  }
}
}
#line 821 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int hol_entry_qcmp(void const   *entry1_v , void const   *entry2_v ) 
{ 
  int tmp ;

  {
  {
#line 824
  tmp = hol_entry_cmp((struct hol_entry  const  *)entry1_v, (struct hol_entry  const  *)entry2_v);
  }
#line 824
  return (tmp);
}
}
#line 830 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void hol_sort(struct hol *hol ) 
{ 
  unsigned int i ;
  struct hol_entry *e ;

  {
#line 833
  if (hol->num_entries > 0U) {
#line 837
    i = 0U;
#line 837
    e = hol->entries;
    {
#line 837
    while (1) {
      while_continue: /* CIL Label */ ;
#line 837
      if (! (i < hol->num_entries)) {
#line 837
        goto while_break;
      }
#line 838
      e->ord = i;
#line 837
      i ++;
#line 837
      e ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 839
    qsort((void *)hol->entries, hol->num_entries, (size_t )sizeof(struct hol_entry ),
          & hol_entry_qcmp);
    }
  }
#line 842
  return;
}
}
#line 846 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void hol_append(struct hol *hol , struct hol *more ) 
{ 
  struct hol_cluster **cl_end ;
  unsigned int left ;
  char *so ;
  char *more_so ;
  struct hol_entry *e ;
  unsigned int num_entries ;
  struct hol_entry *entries ;
  void *tmp ;
  unsigned int hol_so_len ;
  size_t tmp___0 ;
  char *short_options ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int opts_left ;
  struct argp_option  const  *opt ;
  int ch___0 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 849
  cl_end = & hol->clusters;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! *cl_end) {
#line 852
      goto while_break;
    }
#line 853
    cl_end = & (*cl_end)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  *cl_end = more->clusters;
#line 855
  more->clusters = (struct hol_cluster *)0;
#line 858
  if (more->num_entries > 0U) {
#line 860
    if (hol->num_entries == 0U) {
#line 862
      hol->num_entries = more->num_entries;
#line 863
      hol->entries = more->entries;
#line 864
      hol->short_options = more->short_options;
#line 865
      more->num_entries = 0U;
    } else {
      {
#line 874
      num_entries = hol->num_entries + more->num_entries;
#line 875
      tmp = malloc((size_t )((unsigned long )num_entries * sizeof(struct hol_entry )));
#line 875
      entries = (struct hol_entry *)tmp;
#line 877
      tmp___0 = strlen((char const   *)hol->short_options);
#line 877
      hol_so_len = tmp___0;
#line 878
      tmp___1 = strlen((char const   *)more->short_options);
#line 878
      tmp___2 = malloc((hol_so_len + tmp___1) + 1U);
#line 878
      short_options = (char *)tmp___2;
      }
#line 881
      if (entries) {
#line 881
        if (! short_options) {
          {
#line 881
          __assert_fail("entries && short_options", "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c",
                        881U, "hol_append");
          }
        }
      } else {
        {
#line 881
        __assert_fail("entries && short_options", "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c",
                      881U, "hol_append");
        }
      }
#line 883
      if (! ((unsigned long )num_entries <= 4294967295UL / sizeof(struct hol_entry ))) {
        {
#line 883
        __assert_fail("num_entries <= ((size_t) -1) / sizeof (struct hol_entry)",
                      "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c", 883U,
                      "hol_append");
        }
      }
      {
#line 885
      tmp___3 = mempcpy((void */* __restrict  */)entries, (void const   */* __restrict  */)hol->entries,
                        (size_t )((unsigned long )hol->num_entries * sizeof(struct hol_entry )));
#line 885
      mempcpy((void */* __restrict  */)tmp___3, (void const   */* __restrict  */)more->entries,
              (size_t )((unsigned long )more->num_entries * sizeof(struct hol_entry )));
#line 890
      mempcpy((void */* __restrict  */)short_options, (void const   */* __restrict  */)hol->short_options,
              hol_so_len);
#line 893
      e = entries;
#line 893
      left = hol->num_entries;
      }
      {
#line 893
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 893
        if (! (left > 0U)) {
#line 893
          goto while_break___0;
        }
#line 894
        e->short_options += short_options - hol->short_options;
#line 893
        e ++;
#line 893
        left --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 898
      so = short_options + hol_so_len;
#line 899
      more_so = more->short_options;
#line 900
      left = more->num_entries;
      {
#line 900
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 900
        if (! (left > 0U)) {
#line 900
          goto while_break___1;
        }
#line 905
        e->short_options = so;
#line 907
        opts_left = (int )e->num;
#line 907
        opt = e->opt;
        {
#line 907
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 907
          if (! opts_left) {
#line 907
            goto while_break___2;
          }
          {
#line 909
          ch___0 = (int )*more_so;
#line 910
          tmp___6 = _option_is_short(opt);
          }
#line 910
          if (tmp___6) {
#line 910
            if (ch___0 == (int )opt->key) {
              {
#line 913
              tmp___5 = find_char((char )ch___0, short_options, short_options + hol_so_len);
              }
#line 913
              if (! tmp___5) {
#line 917
                tmp___4 = so;
#line 917
                so ++;
#line 917
                *tmp___4 = (char )ch___0;
              }
#line 918
              more_so ++;
            }
          }
#line 907
          opt ++;
#line 907
          opts_left --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 900
        e ++;
#line 900
        left --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 923
      *so = (char )'\000';
#line 925
      free((void *)hol->entries);
#line 926
      free((void *)hol->short_options);
#line 928
      hol->entries = entries;
#line 929
      hol->num_entries = num_entries;
#line 930
      hol->short_options = short_options;
      }
    }
  }
  {
#line 934
  hol_free(more);
  }
#line 935
  return;
}
}
#line 938 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void indent_to(argp_fmtstream_t stream , unsigned int col ) 
{ 
  int needed ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 941
  tmp = argp_fmtstream_point(stream);
#line 941
  needed = (int )(col - tmp);
  }
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 942
    tmp___0 = needed;
#line 942
    needed --;
#line 942
    if (! (tmp___0 > 0)) {
#line 942
      goto while_break;
    }
    {
#line 943
    argp_fmtstream_putc(stream, ' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  return;
}
}
#line 948 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void space(argp_fmtstream_t stream , size_t ensure ) 
{ 
  size_t tmp ;

  {
  {
#line 951
  tmp = argp_fmtstream_point(stream);
  }
#line 951
  if (tmp + ensure >= stream->rmargin) {
    {
#line 953
    argp_fmtstream_putc(stream, '\n');
    }
  } else {
    {
#line 955
    argp_fmtstream_putc(stream, ' ');
    }
  }
#line 956
  return;
}
}
#line 961 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void arg(struct argp_option  const  *real , char const   *req_fmt , char const   *opt_fmt ,
                char const   *domain , argp_fmtstream_t stream ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 965
  if (real->arg) {
#line 967
    if (real->flags & 1) {
      {
#line 968
      tmp = dgettext(domain, (char const   *)real->arg);
#line 968
      argp_fmtstream_printf(stream, opt_fmt, tmp);
      }
    } else {
      {
#line 971
      tmp___0 = dgettext(domain, (char const   *)real->arg);
#line 971
      argp_fmtstream_printf(stream, req_fmt, tmp___0);
      }
    }
  }
#line 974
  return;
}
}
#line 1010 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static char const   *filter_doc(char const   *doc___0 , int key , struct argp  const  *argp___0 ,
                                struct argp_state  const  *state ) 
{ 
  void *input ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1014
  if (argp___0->help_filter) {
    {
#line 1017
    tmp = _argp_input((struct argp  const  */* __restrict  */)argp___0, (struct argp_state  const  */* __restrict  */)state);
#line 1017
    input = tmp;
#line 1018
    tmp___0 = (*(argp___0->help_filter))(key, doc___0, input);
    }
#line 1018
    return ((char const   *)tmp___0);
  } else {
#line 1022
    return (doc___0);
  }
}
}
#line 1030 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void print_header(char const   *str , struct argp  const  *argp___0 , struct pentry_state *pest ) 
{ 
  char const   *tstr ;
  char *tmp ;
  char const   *fstr ;
  char const   *tmp___0 ;

  {
  {
#line 1034
  tmp = dgettext((char const   *)argp___0->argp_domain, str);
#line 1034
  tstr = (char const   *)tmp;
#line 1035
  tmp___0 = filter_doc(tstr, 33554435, argp___0, pest->state);
#line 1035
  fstr = tmp___0;
  }
#line 1037
  if (fstr) {
#line 1039
    if (*fstr) {
#line 1041
      if ((pest->hhstate)->prev_entry) {
        {
#line 1043
        argp_fmtstream_putc(pest->stream, '\n');
        }
      }
      {
#line 1044
      indent_to(pest->stream, (unsigned int )uparams.header_col);
#line 1045
      argp_fmtstream_set_lmargin(pest->stream, (size_t )uparams.header_col);
#line 1046
      argp_fmtstream_set_wmargin(pest->stream, (size_t )uparams.header_col);
#line 1047
      argp_fmtstream_puts(pest->stream, fstr);
#line 1048
      argp_fmtstream_set_lmargin(pest->stream, (size_t )0);
#line 1049
      argp_fmtstream_putc(pest->stream, '\n');
      }
    }
#line 1052
    (pest->hhstate)->sep_groups = 1;
  }
#line 1055
  if ((unsigned long )fstr != (unsigned long )tstr) {
    {
#line 1056
    free((void *)((char *)fstr));
    }
  }
#line 1057
  return;
}
}
#line 1063 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void comma(unsigned int col , struct pentry_state *pest ) 
{ 
  struct hol_entry  const  *pe ;
  struct hol_cluster  const  *cl ;
  int old_wm ;
  int tmp ;
  char *__cil_tmp7 ;

  {
#line 1066
  if (pest->first) {
#line 1068
    pe = (struct hol_entry  const  *)(pest->hhstate)->prev_entry;
#line 1069
    cl = (struct hol_cluster  const  *)(pest->entry)->cluster;
#line 1071
    if ((pest->hhstate)->sep_groups) {
#line 1071
      if (pe) {
#line 1071
        if ((pest->entry)->group != pe->group) {
          {
#line 1072
          argp_fmtstream_putc(pest->stream, '\n');
          }
        }
      }
    }
#line 1074
    if (cl) {
#line 1074
      if (cl->header) {
#line 1074
        if (*(cl->header)) {
#line 1074
          if (! pe) {
            {
#line 1083
            old_wm = (pest->stream)->wmargin;
#line 1084
            print_header((char const   *)cl->header, (struct argp  const  *)cl->argp,
                         pest);
#line 1085
            argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
            }
          } else
#line 1074
          if ((unsigned long )pe->cluster != (unsigned long )cl) {
            {
#line 1074
            tmp = hol_cluster_is_child((struct hol_cluster  const  *)pe->cluster,
                                       cl);
            }
#line 1074
            if (! tmp) {
              {
#line 1083
              old_wm = (pest->stream)->wmargin;
#line 1084
              print_header((char const   *)cl->header, (struct argp  const  *)cl->argp,
                           pest);
#line 1085
              argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
              }
            }
          }
        }
      }
    }
#line 1088
    pest->first = 0;
  } else {
    {
#line 1091
    argp_fmtstream_puts(pest->stream, ", ");
    }
  }
  {
#line 1093
  indent_to(pest->stream, col);
  }
#line 1094
  return;
}
}
#line 1097 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void hol_entry_help(struct hol_entry *entry , struct argp_state  const  *state ,
                           argp_fmtstream_t stream , struct hol_help_state *hhstate ) 
{ 
  unsigned int num ;
  struct argp_option  const  *real ;
  struct argp_option  const  *opt ;
  char *so ;
  int have_long_opt ;
  int old_lm ;
  size_t tmp ;
  int old_wm ;
  struct pentry_state pest ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int first_long_opt ;
  int tmp___3 ;
  char const   *tstr ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *fstr ;
  char const   *tmp___6 ;
  unsigned int col ;
  size_t tmp___7 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 1102
  real = entry->opt;
#line 1103
  so = entry->short_options;
#line 1104
  have_long_opt = 0;
#line 1106
  tmp = argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1106
  old_lm = (int )tmp;
#line 1107
  old_wm = stream->wmargin;
#line 1112
  pest.entry = (struct hol_entry  const  *)entry;
#line 1113
  pest.stream = stream;
#line 1114
  pest.hhstate = hhstate;
#line 1115
  pest.first = 1;
#line 1116
  pest.state = state;
  }
#line 1118
  if (! (real->flags & 8)) {
#line 1119
    opt = real;
#line 1119
    num = entry->num;
    {
#line 1119
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1119
      if (! (num > 0U)) {
#line 1119
        goto while_break;
      }
#line 1120
      if (opt->name) {
#line 1120
        if (! (opt->flags & 2)) {
#line 1122
          have_long_opt = 1;
#line 1123
          goto while_break;
        }
      }
#line 1119
      opt ++;
#line 1119
      num --;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1127
  argp_fmtstream_set_wmargin(stream, (size_t )uparams.short_opt_col);
#line 1128
  opt = real;
#line 1128
  num = entry->num;
  }
  {
#line 1128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1128
    if (! (num > 0U)) {
#line 1128
      goto while_break___0;
    }
    {
#line 1129
    tmp___0 = _option_is_short(opt);
    }
#line 1129
    if (tmp___0) {
#line 1129
      if (opt->key == (int const   )*so) {
#line 1132
        if (! (opt->flags & 2)) {
          {
#line 1134
          comma((unsigned int )uparams.short_opt_col, & pest);
#line 1135
          argp_fmtstream_putc(stream, '-');
#line 1136
          argp_fmtstream_putc(stream, (int )*so);
          }
#line 1137
          if (! have_long_opt) {
            {
#line 1138
            arg(real, " %s", "[%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1137
          if (uparams.dup_args) {
            {
#line 1138
            arg(real, " %s", "[%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1139
          if (real->arg) {
#line 1140
            hhstate->suppressed_dup_arg = 1;
          }
        }
#line 1142
        so ++;
      }
    }
#line 1128
    opt ++;
#line 1128
    num --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1146
  if (real->flags & 8) {
    {
#line 1149
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.doc_opt_col);
#line 1150
    opt = real;
#line 1150
    num = entry->num;
    }
    {
#line 1150
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1150
      if (! (num > 0U)) {
#line 1150
        goto while_break___1;
      }
#line 1151
      if (opt->name) {
#line 1151
        if (*(opt->name)) {
#line 1151
          if (! (opt->flags & 2)) {
            {
#line 1153
            comma((unsigned int )uparams.doc_opt_col, & pest);
            }
#line 1157
            if (opt->flags & 32) {
#line 1157
              tmp___2 = opt->name;
            } else {
              {
#line 1157
              tmp___1 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                 (char const   *)opt->name);
#line 1157
              tmp___2 = (char const   */* const  */)tmp___1;
              }
            }
            {
#line 1157
            argp_fmtstream_puts(stream, (char const   *)tmp___2);
            }
          }
        }
      }
#line 1150
      opt ++;
#line 1150
      num --;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1167
    first_long_opt = 1;
#line 1169
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.long_opt_col);
#line 1170
    opt = real;
#line 1170
    num = entry->num;
    }
    {
#line 1170
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1170
      if (! (num > 0U)) {
#line 1170
        goto while_break___2;
      }
#line 1171
      if (opt->name) {
#line 1171
        if (! (opt->flags & 2)) {
          {
#line 1173
          comma((unsigned int )uparams.long_opt_col, & pest);
#line 1174
          argp_fmtstream_printf(stream, "--%s", opt->name);
          }
#line 1175
          if (first_long_opt) {
            {
#line 1176
            arg(real, "=%s", "[=%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1175
          if (uparams.dup_args) {
            {
#line 1176
            arg(real, "=%s", "[=%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1178
          if (real->arg) {
#line 1179
            hhstate->suppressed_dup_arg = 1;
          }
        }
      }
#line 1170
      opt ++;
#line 1170
      num --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1184
  argp_fmtstream_set_lmargin(stream, (size_t )0);
  }
#line 1186
  if (pest.first) {
    {
#line 1189
    tmp___3 = _option_is_short(real);
    }
#line 1189
    if (tmp___3) {
#line 1194
      goto cleanup;
    } else
#line 1189
    if (! real->name) {
      {
#line 1191
      print_header((char const   *)real->doc, entry->argp, & pest);
      }
    } else {
#line 1194
      goto cleanup;
    }
  } else {
#line 1198
    if (real->doc) {
      {
#line 1198
      tmp___4 = dgettext((char const   *)(state->root_argp)->argp_domain, (char const   *)real->doc);
#line 1198
      tmp___5 = tmp___4;
      }
    } else {
#line 1198
      tmp___5 = (char *)0;
    }
    {
#line 1198
    tstr = (char const   *)tmp___5;
#line 1200
    tmp___6 = filter_doc(tstr, (int )real->key, entry->argp, state);
#line 1200
    fstr = tmp___6;
    }
#line 1201
    if (fstr) {
#line 1201
      if (*fstr) {
        {
#line 1203
        tmp___7 = argp_fmtstream_point(stream);
#line 1203
        col = tmp___7;
#line 1205
        argp_fmtstream_set_lmargin(stream, (size_t )uparams.opt_doc_col);
#line 1206
        argp_fmtstream_set_wmargin(stream, (size_t )uparams.opt_doc_col);
        }
#line 1208
        if (col > (unsigned int )(uparams.opt_doc_col + 3)) {
          {
#line 1209
          argp_fmtstream_putc(stream, '\n');
          }
        } else
#line 1210
        if (col >= (unsigned int )uparams.opt_doc_col) {
          {
#line 1211
          argp_fmtstream_puts(stream, "   ");
          }
        } else {
          {
#line 1213
          indent_to(stream, (unsigned int )uparams.opt_doc_col);
          }
        }
        {
#line 1215
        argp_fmtstream_puts(stream, fstr);
        }
      }
    }
#line 1217
    if (fstr) {
#line 1217
      if ((unsigned long )fstr != (unsigned long )tstr) {
        {
#line 1218
        free((void *)((char *)fstr));
        }
      }
    }
    {
#line 1221
    argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1222
    argp_fmtstream_putc(stream, '\n');
    }
  }
#line 1225
  hhstate->prev_entry = entry;
  cleanup: 
  {
#line 1228
  argp_fmtstream_set_lmargin(stream, (size_t )old_lm);
#line 1229
  argp_fmtstream_set_wmargin(stream, (size_t )old_wm);
  }
#line 1230
  return;
}
}
#line 1233 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void hol_help(struct hol *hol , struct argp_state  const  *state , argp_fmtstream_t stream ) 
{ 
  unsigned int num ;
  struct hol_entry *entry ;
  struct hol_help_state hhstate ;
  char const   *tstr ;
  char *tmp ;
  char const   *fstr ;
  struct argp  const  *tmp___0 ;
  char const   *tmp___1 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1239
  hhstate.prev_entry = (struct hol_entry *)0;
#line 1239
  hhstate.sep_groups = 0;
#line 1239
  hhstate.suppressed_dup_arg = 0;
#line 1241
  entry = hol->entries;
#line 1241
  num = hol->num_entries;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! (num > 0U)) {
#line 1241
      goto while_break;
    }
    {
#line 1242
    hol_entry_help(entry, state, stream, & hhstate);
#line 1241
    entry ++;
#line 1241
    num --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  if (hhstate.suppressed_dup_arg) {
#line 1244
    if (uparams.dup_args_note) {
      {
#line 1246
      tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options.");
#line 1246
      tstr = (char const   *)tmp;
      }
#line 1249
      if (state) {
#line 1249
        tmp___0 = state->root_argp;
      } else {
#line 1249
        tmp___0 = (struct argp  const  */* const  */)0;
      }
      {
#line 1249
      tmp___1 = filter_doc(tstr, 33554437, (struct argp  const  *)tmp___0, state);
#line 1249
      fstr = tmp___1;
      }
#line 1251
      if (fstr) {
#line 1251
        if (*fstr) {
          {
#line 1253
          argp_fmtstream_putc(stream, '\n');
#line 1254
          argp_fmtstream_puts(stream, fstr);
#line 1255
          argp_fmtstream_putc(stream, '\n');
          }
        }
      }
#line 1257
      if (fstr) {
#line 1257
        if ((unsigned long )fstr != (unsigned long )tstr) {
          {
#line 1258
          free((void *)((char *)fstr));
          }
        }
      }
    }
  }
#line 1260
  return;
}
}
#line 1266 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int add_argless_short_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                                 char const   *domain , void *cookie ) 
{ 
  char **snao_end ;
  char *tmp ;

  {
#line 1271
  snao_end = (char **)cookie;
#line 1272
  if (! opt->arg) {
#line 1272
    if (! real->arg) {
#line 1272
      if (! ((opt->flags | real->flags) & 16)) {
#line 1274
        tmp = *snao_end;
#line 1274
        (*snao_end) ++;
#line 1274
        *tmp = (char )opt->key;
      }
    }
  }
#line 1275
  return (0);
}
}
#line 1280 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int usage_argful_short_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                                  char const   *domain , void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___0 ;
  int flags ;
  char *tmp ;
  size_t tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1285
  stream = (argp_fmtstream_t )cookie;
#line 1286
  arg___0 = (char const   *)opt->arg;
#line 1287
  flags = (int )(opt->flags | real->flags);
#line 1289
  if (! arg___0) {
#line 1290
    arg___0 = (char const   *)real->arg;
  }
#line 1292
  if (arg___0) {
#line 1292
    if (! (flags & 16)) {
      {
#line 1294
      tmp = dgettext(domain, arg___0);
#line 1294
      arg___0 = (char const   *)tmp;
      }
#line 1296
      if (flags & 1) {
        {
#line 1297
        argp_fmtstream_printf(stream, " [-%c[%s]]", opt->key, arg___0);
        }
      } else {
        {
#line 1302
        tmp___0 = strlen(arg___0);
#line 1302
        space(stream, 6U + tmp___0);
#line 1303
        argp_fmtstream_printf(stream, "[-%c %s]", opt->key, arg___0);
        }
      }
    }
  }
#line 1307
  return (0);
}
}
#line 1312 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int usage_long_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                          char const   *domain , void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___0 ;
  int flags ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1317
  stream = (argp_fmtstream_t )cookie;
#line 1318
  arg___0 = (char const   *)opt->arg;
#line 1319
  flags = (int )(opt->flags | real->flags);
#line 1321
  if (! arg___0) {
#line 1322
    arg___0 = (char const   *)real->arg;
  }
#line 1324
  if (! (flags & 16)) {
#line 1324
    if (! (opt->flags & 8)) {
#line 1326
      if (arg___0) {
        {
#line 1328
        tmp = dgettext(domain, arg___0);
#line 1328
        arg___0 = (char const   *)tmp;
        }
#line 1329
        if (flags & 1) {
          {
#line 1330
          argp_fmtstream_printf(stream, " [--%s[=%s]]", opt->name, arg___0);
          }
        } else {
          {
#line 1332
          argp_fmtstream_printf(stream, " [--%s=%s]", opt->name, arg___0);
          }
        }
      } else {
        {
#line 1335
        argp_fmtstream_printf(stream, " [--%s]", opt->name);
        }
      }
    }
  }
#line 1338
  return (0);
}
}
#line 1342 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void hol_usage(struct hol *hol , argp_fmtstream_t stream ) 
{ 
  unsigned int nentries ;
  struct hol_entry *entry ;
  char *short_no_arg_opts ;
  size_t tmp ;
  void *tmp___0 ;
  char *snao_end ;
  char *tmp___1 ;
  char *__cil_tmp10 ;

  {
#line 1345
  if (hol->num_entries > 0U) {
    {
#line 1349
    tmp = strlen((char const   *)hol->short_options);
#line 1349
    tmp___0 = __builtin_alloca((unsigned long )(tmp + 1U));
#line 1349
    short_no_arg_opts = (char *)tmp___0;
#line 1350
    snao_end = short_no_arg_opts;
#line 1353
    entry = hol->entries;
#line 1353
    nentries = hol->num_entries;
    }
    {
#line 1353
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1353
      if (! (nentries > 0U)) {
#line 1353
        goto while_break;
      }
      {
#line 1356
      hol_entry_short_iterate((struct hol_entry  const  *)entry, & add_argless_short_opt,
                              (char const   *)(entry->argp)->argp_domain, (void *)(& snao_end));
#line 1353
      entry ++;
#line 1353
      nentries --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1358
    if ((unsigned long )snao_end > (unsigned long )short_no_arg_opts) {
      {
#line 1360
      tmp___1 = snao_end;
#line 1360
      snao_end ++;
#line 1360
      *tmp___1 = (char)0;
#line 1361
      argp_fmtstream_printf(stream, " [-%s]", short_no_arg_opts);
      }
    }
#line 1365
    entry = hol->entries;
#line 1365
    nentries = hol->num_entries;
    {
#line 1365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1365
      if (! (nentries > 0U)) {
#line 1365
        goto while_break___0;
      }
      {
#line 1368
      hol_entry_short_iterate((struct hol_entry  const  *)entry, & usage_argful_short_opt,
                              (char const   *)(entry->argp)->argp_domain, (void *)stream);
#line 1365
      entry ++;
#line 1365
      nentries --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1372
    entry = hol->entries;
#line 1372
    nentries = hol->num_entries;
    {
#line 1372
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1372
      if (! (nentries > 0U)) {
#line 1372
        goto while_break___1;
      }
      {
#line 1375
      hol_entry_long_iterate((struct hol_entry  const  *)entry, & usage_long_opt,
                             (char const   *)(entry->argp)->argp_domain, (void *)stream);
#line 1372
      entry ++;
#line 1372
      nentries --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1378
  return;
}
}
#line 1382 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static struct hol *argp_hol(struct argp  const  *argp___0 , struct hol_cluster *cluster ) 
{ 
  struct argp_child  const  *child ;
  struct hol *hol ;
  struct hol *tmp ;
  struct hol_cluster *child_cluster ;
  struct hol_cluster *tmp___0 ;
  struct hol_cluster *tmp___1 ;
  struct hol *tmp___2 ;

  {
  {
#line 1385
  child = (struct argp_child  const  *)argp___0->children;
#line 1386
  tmp = make_hol(argp___0, cluster);
#line 1386
  hol = tmp;
  }
#line 1387
  if (child) {
    {
#line 1388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1388
      if (! child->argp) {
#line 1388
        goto while_break;
      }
#line 1390
      if (child->group) {
        {
#line 1390
        tmp___0 = hol_add_cluster(hol, (int )child->group, (char const   *)child->header,
                                  (int )(child - (struct argp_child  const  *)argp___0->children),
                                  cluster, argp___0);
#line 1390
        tmp___1 = tmp___0;
        }
      } else
#line 1390
      if (child->header) {
        {
#line 1390
        tmp___0 = hol_add_cluster(hol, (int )child->group, (char const   *)child->header,
                                  (int )(child - (struct argp_child  const  *)argp___0->children),
                                  cluster, argp___0);
#line 1390
        tmp___1 = tmp___0;
        }
      } else {
#line 1390
        tmp___1 = cluster;
      }
      {
#line 1390
      child_cluster = tmp___1;
#line 1397
      tmp___2 = argp_hol((struct argp  const  *)child->argp, child_cluster);
#line 1397
      hol_append(hol, tmp___2);
#line 1398
      child ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1400
  return (hol);
}
}
#line 1405 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static size_t argp_args_levels(struct argp  const  *argp___0 ) 
{ 
  size_t levels ;
  struct argp_child  const  *child ;
  char *tmp ;
  struct argp_child  const  *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1408
  levels = (size_t )0;
#line 1409
  child = (struct argp_child  const  *)argp___0->children;
#line 1411
  if (argp___0->args_doc) {
    {
#line 1411
    tmp = strchr((char const   *)argp___0->args_doc, '\n');
    }
#line 1411
    if (tmp) {
#line 1412
      levels ++;
    }
  }
#line 1414
  if (child) {
    {
#line 1415
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1415
      if (! child->argp) {
#line 1415
        goto while_break;
      }
      {
#line 1416
      tmp___0 = child;
#line 1416
      child ++;
#line 1416
      tmp___1 = argp_args_levels((struct argp  const  *)tmp___0->argp);
#line 1416
      levels += tmp___1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1418
  return (levels);
}
}
#line 1426 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int argp_args_usage(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                           char **levels , int advance , argp_fmtstream_t stream ) 
{ 
  char *our_level ;
  int multiple ;
  struct argp_child  const  *child ;
  char const   *tdoc ;
  char *tmp ;
  char const   *nl ;
  char const   *fdoc ;
  char const   *tmp___0 ;
  char const   *cp ;
  char *tmp___1 ;
  int i ;
  char *tmp___2 ;
  struct argp_child  const  *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1430
  our_level = *levels;
#line 1431
  multiple = 0;
#line 1432
  child = (struct argp_child  const  *)argp___0->children;
#line 1433
  tmp = dgettext((char const   *)argp___0->argp_domain, (char const   *)argp___0->args_doc);
#line 1433
  tdoc = (char const   *)tmp;
#line 1433
  nl = (char const   *)0;
#line 1434
  tmp___0 = filter_doc(tdoc, 33554438, argp___0, state);
#line 1434
  fdoc = tmp___0;
  }
#line 1436
  if (fdoc) {
    {
#line 1438
    cp = fdoc;
#line 1439
    tmp___1 = strchrnul(cp, '\n');
#line 1439
    nl = (char const   *)tmp___1;
    }
#line 1440
    if ((int const   )*nl != 0) {
#line 1445
      multiple = 1;
#line 1446
      i = 0;
      {
#line 1446
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1446
        if (! (i < (int )*our_level)) {
#line 1446
          goto while_break;
        }
        {
#line 1447
        cp = nl + 1;
#line 1447
        tmp___2 = strchrnul(cp, '\n');
#line 1447
        nl = (char const   *)tmp___2;
#line 1446
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1448
      (*levels) ++;
    }
    {
#line 1453
    space(stream, (size_t )((nl + 1) - cp));
#line 1455
    argp_fmtstream_write(stream, cp, (size_t )(nl - cp));
    }
  }
#line 1457
  if (fdoc) {
#line 1457
    if ((unsigned long )fdoc != (unsigned long )tdoc) {
      {
#line 1458
      free((void *)((char *)fdoc));
      }
    }
  }
#line 1460
  if (child) {
    {
#line 1461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1461
      if (! child->argp) {
#line 1461
        goto while_break___0;
      }
      {
#line 1462
      tmp___3 = child;
#line 1462
      child ++;
#line 1462
      tmp___4 = argp_args_usage((struct argp  const  *)tmp___3->argp, state, levels,
                                advance, stream);
      }
#line 1462
      if (tmp___4) {
#line 1462
        tmp___5 = 0;
      } else {
#line 1462
        tmp___5 = 1;
      }
#line 1462
      advance = tmp___5;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1464
  if (advance) {
#line 1464
    if (multiple) {
#line 1467
      if (*nl) {
#line 1470
        *our_level = (char )((int )*our_level + 1);
#line 1471
        advance = 0;
      } else
#line 1473
      if ((int )*our_level > 0) {
#line 1475
        *our_level = (char)0;
      }
    }
  }
#line 1478
  return (! advance);
}
}
#line 1488 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static int argp_doc(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                    int post , int pre_blank , int first_only , argp_fmtstream_t stream ) 
{ 
  char const   *text ;
  char const   *inp_text ;
  size_t inp_text_len ;
  char const   *trans_text ;
  void *input ;
  int anything ;
  struct argp_child  const  *child ;
  char *vt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  struct argp_child  const  *tmp___8 ;
  int tmp___9 ;

  {
#line 1495
  inp_text_len = (size_t )0;
#line 1497
  input = (void *)0;
#line 1498
  anything = 0;
#line 1499
  child = (struct argp_child  const  *)argp___0->children;
#line 1501
  if (argp___0->doc) {
    {
#line 1503
    tmp = strchr((char const   *)argp___0->doc, '\v');
#line 1503
    vt = tmp;
    }
#line 1504
    if (vt) {
#line 1506
      if (post) {
#line 1507
        inp_text = (char const   *)(vt + 1);
      } else {
        {
#line 1510
        inp_text_len = (size_t )(vt - (char *)argp___0->doc);
#line 1511
        tmp___0 = strndup((char const   *)argp___0->doc, inp_text_len);
#line 1511
        inp_text = (char const   *)tmp___0;
        }
      }
    } else
#line 1515
    if (post) {
#line 1515
      inp_text = (char const   *)0;
    } else {
#line 1515
      inp_text = (char const   *)argp___0->doc;
    }
#line 1516
    if (inp_text) {
      {
#line 1516
      tmp___1 = dgettext((char const   *)argp___0->argp_domain, inp_text);
#line 1516
      trans_text = (char const   *)tmp___1;
      }
    } else {
#line 1516
      trans_text = (char const   *)((void *)0);
    }
  } else {
#line 1519
    inp_text = (char const   *)0;
#line 1519
    trans_text = inp_text;
  }
#line 1521
  if (argp___0->help_filter) {
    {
#line 1524
    input = _argp_input((struct argp  const  */* __restrict  */)argp___0, (struct argp_state  const  */* __restrict  */)state);
    }
#line 1525
    if (post) {
#line 1525
      tmp___2 = 33554434;
    } else {
#line 1525
      tmp___2 = 33554433;
    }
    {
#line 1525
    tmp___3 = (*(argp___0->help_filter))(tmp___2, trans_text, input);
#line 1525
    text = (char const   *)tmp___3;
    }
  } else {
#line 1532
    text = trans_text;
  }
#line 1534
  if (text) {
#line 1536
    if (pre_blank) {
      {
#line 1537
      argp_fmtstream_putc(stream, '\n');
      }
    }
    {
#line 1539
    argp_fmtstream_puts(stream, text);
#line 1541
    tmp___4 = argp_fmtstream_point(stream);
    }
#line 1541
    if (tmp___4 > stream->lmargin) {
      {
#line 1542
      argp_fmtstream_putc(stream, '\n');
      }
    }
#line 1544
    anything = 1;
  }
#line 1547
  if (text) {
#line 1547
    if ((unsigned long )text != (unsigned long )trans_text) {
      {
#line 1548
      free((void *)((char *)text));
      }
    }
  }
#line 1550
  if (inp_text) {
#line 1550
    if (inp_text_len) {
      {
#line 1551
      free((void *)((char *)inp_text));
      }
    }
  }
#line 1553
  if (post) {
#line 1553
    if (argp___0->help_filter) {
      {
#line 1556
      tmp___5 = (*(argp___0->help_filter))(33554436, (char const   *)0, input);
#line 1556
      text = (char const   *)tmp___5;
      }
#line 1557
      if (text) {
#line 1559
        if (anything) {
          {
#line 1560
          argp_fmtstream_putc(stream, '\n');
          }
        } else
#line 1559
        if (pre_blank) {
          {
#line 1560
          argp_fmtstream_putc(stream, '\n');
          }
        }
        {
#line 1561
        argp_fmtstream_puts(stream, text);
#line 1562
        free((void *)((char *)text));
#line 1563
        tmp___6 = argp_fmtstream_point(stream);
        }
#line 1563
        if (tmp___6 > stream->lmargin) {
          {
#line 1565
          argp_fmtstream_putc(stream, '\n');
          }
        }
#line 1566
        anything = 1;
      }
    }
  }
#line 1570
  if (child) {
    {
#line 1571
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1571
      if (child->argp) {
#line 1571
        if (first_only) {
#line 1571
          if (anything) {
#line 1571
            goto while_break;
          }
        }
      } else {
#line 1571
        goto while_break;
      }
#line 1572
      if (anything) {
#line 1572
        tmp___7 = 1;
      } else
#line 1572
      if (pre_blank) {
#line 1572
        tmp___7 = 1;
      } else {
#line 1572
        tmp___7 = 0;
      }
      {
#line 1572
      tmp___8 = child;
#line 1572
      child ++;
#line 1572
      tmp___9 = argp_doc((struct argp  const  *)tmp___8->argp, state, post, tmp___7,
                         first_only, stream);
#line 1572
      anything |= tmp___9;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1577
  return (anything);
}
}
#line 1584 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
static void _help(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                  FILE *stream , unsigned int flags , char *name ) 
{ 
  int anything ;
  struct hol *hol ;
  argp_fmtstream_t fs ;
  int first_pattern ;
  int more_patterns ;
  size_t num_pattern_levels ;
  size_t tmp ;
  char *pattern_levels ;
  void *tmp___0 ;
  int old_lm ;
  int old_wm ;
  size_t tmp___1 ;
  char *levels ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 1588
  anything = 0;
#line 1589
  hol = (struct hol *)0;
#line 1592
  if (! stream) {
#line 1593
    return;
  }
  {
#line 1596
  flockfile(stream);
  }
#line 1599
  if (! uparams.valid) {
    {
#line 1600
    fill_in_uparams(state);
    }
  }
  {
#line 1602
  fs = argp_make_fmtstream(stream, (size_t )0, (size_t )uparams.rmargin, 0);
  }
#line 1603
  if (! fs) {
    {
#line 1606
    funlockfile(stream);
    }
#line 1608
    return;
  }
#line 1611
  if (flags & 11U) {
    {
#line 1613
    hol = argp_hol(argp___0, (struct hol_cluster *)0);
#line 1616
    hol_set_group(hol, "help", -1);
#line 1617
    hol_set_group(hol, "version", -1);
#line 1619
    hol_sort(hol);
    }
  }
#line 1622
  if (flags & 3U) {
    {
#line 1625
    first_pattern = 1;
#line 1626
    tmp = argp_args_levels(argp___0);
#line 1626
    num_pattern_levels = tmp;
#line 1627
    tmp___0 = __builtin_alloca((unsigned long )num_pattern_levels);
#line 1627
    pattern_levels = (char *)tmp___0;
#line 1629
    memset((void *)pattern_levels, 0, num_pattern_levels);
    }
    {
#line 1631
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1634
      tmp___1 = argp_fmtstream_set_wmargin(fs, (size_t )uparams.usage_indent);
#line 1634
      old_wm = (int )tmp___1;
#line 1635
      levels = pattern_levels;
      }
#line 1637
      if (first_pattern) {
        {
#line 1638
        tmp___2 = dgettext((char const   *)argp___0->argp_domain, "Usage:");
#line 1638
        argp_fmtstream_printf(fs, "%s %s", tmp___2, name);
        }
      } else {
        {
#line 1642
        tmp___3 = dgettext((char const   *)argp___0->argp_domain, "  or: ");
#line 1642
        argp_fmtstream_printf(fs, "%s %s", tmp___3, name);
        }
      }
      {
#line 1648
      tmp___4 = argp_fmtstream_set_lmargin(fs, (size_t )uparams.usage_indent);
#line 1648
      old_lm = (int )tmp___4;
      }
#line 1650
      if (flags & 2U) {
#line 1653
        if (hol->num_entries > 0U) {
          {
#line 1654
          tmp___5 = dgettext((char const   *)argp___0->argp_domain, " [OPTION...]");
#line 1654
          argp_fmtstream_puts(fs, (char const   *)tmp___5);
          }
        }
      } else {
        {
#line 1660
        hol_usage(hol, fs);
#line 1661
        flags |= 2U;
        }
      }
      {
#line 1664
      more_patterns = argp_args_usage(argp___0, state, & levels, 1, fs);
#line 1666
      argp_fmtstream_set_wmargin(fs, (size_t )old_wm);
#line 1667
      argp_fmtstream_set_lmargin(fs, (size_t )old_lm);
#line 1669
      argp_fmtstream_putc(fs, '\n');
#line 1670
      anything = 1;
#line 1672
      first_pattern = 0;
      }
#line 1631
      if (! more_patterns) {
#line 1631
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1677
  if (flags & 16U) {
    {
#line 1678
    tmp___6 = argp_doc(argp___0, state, 0, 0, 1, fs);
#line 1678
    anything |= tmp___6;
    }
  }
#line 1680
  if (flags & 4U) {
    {
#line 1682
    tmp___7 = dgettext((char const   *)argp___0->argp_domain, "Try `%s --help\' or `%s --usage\' for more information.\n");
#line 1682
    argp_fmtstream_printf(fs, (char const   *)tmp___7, name, name);
#line 1685
    anything = 1;
    }
  }
#line 1688
  if (flags & 8U) {
#line 1692
    if (hol->num_entries > 0U) {
#line 1694
      if (anything) {
        {
#line 1695
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1696
      hol_help(hol, state, fs);
#line 1697
      anything = 1;
      }
    }
  }
#line 1701
  if (flags & 32U) {
    {
#line 1703
    tmp___8 = argp_doc(argp___0, state, 1, anything, 0, fs);
#line 1703
    anything |= tmp___8;
    }
  }
#line 1705
  if (flags & 64U) {
#line 1705
    if (argp_program_bug_address) {
#line 1707
      if (anything) {
        {
#line 1708
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1709
      tmp___9 = dgettext((char const   *)argp___0->argp_domain, "Report bugs to %s.\n");
#line 1709
      argp_fmtstream_printf(fs, (char const   *)tmp___9, argp_program_bug_address);
#line 1712
      anything = 1;
      }
    }
  }
  {
#line 1716
  funlockfile(stream);
  }
#line 1719
  if (hol) {
    {
#line 1720
    hol_free(hol);
    }
  }
  {
#line 1722
  argp_fmtstream_free(fs);
  }
#line 1723
  return;
}
}
#line 1727 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
void argp_help(struct argp  const  * __restrict  argp___0 , FILE * __restrict  stream ,
               unsigned int flags , char * __restrict  name ) 
{ 
  struct argp_state state ;
  void *__cil_tmp6 ;

  {
  {
#line 1731
  memset((void *)(& state), 0, (size_t )sizeof(state));
#line 1732
  state.root_argp = (struct argp  const  *)argp___0;
#line 1733
  _help((struct argp  const  *)argp___0, (struct argp_state  const  *)(& state), (FILE *)stream,
        flags, (char *)name);
  }
#line 1734
  return;
}
}
#line 1759 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
void argp_state_help(struct argp_state  const  * __restrict  state , FILE * __restrict  stream ,
                     unsigned int flags ) 
{ 
  char *tmp ;
  struct argp  const  *tmp___0 ;

  {
#line 1762
  if (! state) {
#line 1762
    goto _L___0;
  } else
#line 1762
  if (! (state->flags & 2U)) {
    _L___0: /* CIL Label */ 
#line 1762
    if (stream) {
#line 1764
      if (state) {
#line 1764
        if (state->flags & 64U) {
#line 1765
          flags |= 128U;
        }
      }
#line 1767
      if (state) {
#line 1767
        tmp = state->name;
      } else {
#line 1767
        tmp = (char */* const  */)program_invocation_short_name;
      }
#line 1767
      if (state) {
#line 1767
        tmp___0 = state->root_argp;
      } else {
#line 1767
        tmp___0 = (struct argp  const  */* const  */)0;
      }
      {
#line 1767
      _help((struct argp  const  *)tmp___0, (struct argp_state  const  *)state, (FILE *)stream,
            flags, (char *)tmp);
      }
#line 1770
      if (! state) {
#line 1770
        goto _L;
      } else
#line 1770
      if (! (state->flags & 32U)) {
        _L: /* CIL Label */ 
#line 1772
        if (flags & 256U) {
          {
#line 1773
          exit(argp_err_exit_status);
          }
        }
#line 1774
        if (flags & 512U) {
          {
#line 1775
          exit(0);
          }
        }
      }
    }
  }
#line 1778
  return;
}
}
#line 1786 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  state ,
                                           char const   * __restrict  fmt  , ...) 
{ 
  FILE *stream ;
  struct _IO_FILE *tmp ;
  va_list ap ;
  char *tmp___0 ;

  {
#line 1789
  if (! state) {
#line 1789
    goto _L;
  } else
#line 1789
  if (! (state->flags & 2U)) {
    _L: /* CIL Label */ 
#line 1791
    if (state) {
#line 1791
      tmp = state->err_stream;
    } else {
#line 1791
      tmp = (struct _IO_FILE */* const  */)stderr;
    }
#line 1791
    stream = (FILE *)tmp;
#line 1793
    if (stream) {
      {
#line 1798
      flockfile(stream);
#line 1801
      __builtin_va_start(ap, fmt);
      }
#line 1820
      if (state) {
#line 1820
        tmp___0 = state->name;
      } else {
#line 1820
        tmp___0 = (char */* const  */)program_invocation_short_name;
      }
      {
#line 1820
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 1823
      fputc_unlocked(':', stream);
#line 1824
      fputc_unlocked(' ', stream);
#line 1826
      vfprintf((FILE */* __restrict  */)stream, fmt, ap);
#line 1828
      fputc_unlocked('\n', stream);
#line 1831
      argp_state_help(state, (FILE */* __restrict  */)stream, 260U);
#line 1833
      __builtin_va_end(ap);
#line 1836
      funlockfile(stream);
      }
    }
  }
#line 1840
  return;
}
}
#line 1853 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-help.c"
void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  state ,
                                             int status , int errnum , char const   * __restrict  fmt 
                                             , ...) 
{ 
  FILE *stream ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  va_list ap ;
  char buf[200] ;
  char const   *s ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1857
  if (! state) {
#line 1857
    goto _L;
  } else
#line 1857
  if (! (state->flags & 2U)) {
    _L: /* CIL Label */ 
#line 1859
    if (state) {
#line 1859
      tmp = state->err_stream;
    } else {
#line 1859
      tmp = (struct _IO_FILE */* const  */)stderr;
    }
#line 1859
    stream = (FILE *)tmp;
#line 1861
    if (stream) {
      {
#line 1864
      flockfile(stream);
      }
#line 1873
      if (state) {
#line 1873
        tmp___0 = state->name;
      } else {
#line 1873
        tmp___0 = (char */* const  */)program_invocation_short_name;
      }
      {
#line 1873
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
      }
#line 1877
      if (fmt) {
        {
#line 1881
        __builtin_va_start(ap, fmt);
#line 1897
        fputc_unlocked(':', stream);
#line 1898
        fputc_unlocked(' ', stream);
#line 1900
        vfprintf((FILE */* __restrict  */)stream, fmt, ap);
#line 1903
        __builtin_va_end(ap);
        }
      }
#line 1906
      if (errnum) {
        {
#line 1917
        s = (char const   *)((void *)0);
#line 1918
        fputc_unlocked(':', stream);
#line 1919
        fputc_unlocked(' ', stream);
#line 1921
        tmp___1 = strerror_r(errnum, buf, (size_t )sizeof(buf));
#line 1921
        s = (char const   *)tmp___1;
        }
#line 1927
        if (! s) {
          {
#line 1927
          tmp___3 = strerror(errnum);
#line 1927
          s = (char const   *)tmp___3;
          }
#line 1927
          if (! s) {
            {
#line 1928
            tmp___2 = dgettext((char const   *)(state->root_argp)->argp_domain, "Unknown system error");
#line 1928
            s = (char const   *)tmp___2;
            }
          }
        }
        {
#line 1931
        fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)stream);
        }
      }
      {
#line 1940
      fputc_unlocked('\n', stream);
#line 1943
      funlockfile(stream);
      }
#line 1946
      if (status) {
#line 1946
        if (! state) {
          {
#line 1947
          exit(status);
          }
        } else
#line 1946
        if (! (state->flags & 32U)) {
          {
#line 1947
          exit(status);
          }
        }
      }
    }
  }
#line 1950
  return;
}
}
#line 185 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
void _argp_fmtstream_update(argp_fmtstream_t fs ) ;
#line 187
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) ;
#line 260 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
size_t argp_fmtstream_write(argp_fmtstream_t __fs , char const   *__str , size_t __len ) 
{ 
  int tmp ;

  {
#line 264
  if ((unsigned long )(__fs->p + __len) <= (unsigned long )__fs->end) {
    {
#line 266
    memcpy((void */* __restrict  */)__fs->p, (void const   */* __restrict  */)__str,
           __len);
#line 267
    __fs->p += __len;
    }
#line 268
    return (__len);
  } else {
    {
#line 264
    tmp = _argp_fmtstream_ensure(__fs, __len);
    }
#line 264
    if (tmp) {
      {
#line 266
      memcpy((void */* __restrict  */)__fs->p, (void const   */* __restrict  */)__str,
             __len);
#line 267
      __fs->p += __len;
      }
#line 268
      return (__len);
    } else {
#line 271
      return ((size_t )0);
    }
  }
}
}
#line 274 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
int argp_fmtstream_puts(argp_fmtstream_t __fs , char const   *__str ) 
{ 
  size_t __len ;
  size_t tmp ;
  size_t __wrote ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 277
  tmp = strlen(__str);
#line 277
  __len = tmp;
  }
#line 278
  if (__len) {
    {
#line 280
    tmp___0 = argp_fmtstream_write(__fs, __str, __len);
#line 280
    __wrote = tmp___0;
    }
#line 281
    if (__wrote == __len) {
#line 281
      tmp___1 = 0;
    } else {
#line 281
      tmp___1 = -1;
    }
#line 281
    return (tmp___1);
  } else {
#line 284
    return (0);
  }
}
}
#line 287 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
int argp_fmtstream_putc(argp_fmtstream_t __fs , int __ch ) 
{ 
  char *tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
#line 290
  if ((unsigned long )__fs->p < (unsigned long )__fs->end) {
#line 291
    tmp = __fs->p;
#line 291
    (__fs->p) ++;
#line 291
    tmp___0 = (char )__ch;
#line 291
    *tmp = tmp___0;
#line 291
    return ((int )tmp___0);
  } else {
    {
#line 290
    tmp___1 = _argp_fmtstream_ensure(__fs, (size_t )1);
    }
#line 290
    if (tmp___1) {
#line 291
      tmp = __fs->p;
#line 291
      (__fs->p) ++;
#line 291
      tmp___0 = (char )__ch;
#line 291
      *tmp = tmp___0;
#line 291
      return ((int )tmp___0);
    } else {
#line 293
      return (-1);
    }
  }
}
}
#line 297 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
size_t argp_fmtstream_set_lmargin(argp_fmtstream_t __fs , size_t __lmargin ) 
{ 
  size_t __old ;

  {
#line 301
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 302
    _argp_fmtstream_update(__fs);
    }
  }
#line 303
  __old = __fs->lmargin;
#line 304
  __fs->lmargin = __lmargin;
#line 305
  return (__old);
}
}
#line 309 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
size_t argp_fmtstream_set_rmargin(argp_fmtstream_t __fs , size_t __rmargin ) 
{ 
  size_t __old ;

  {
#line 313
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 314
    _argp_fmtstream_update(__fs);
    }
  }
#line 315
  __old = __fs->rmargin;
#line 316
  __fs->rmargin = __rmargin;
#line 317
  return (__old);
}
}
#line 321 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
size_t argp_fmtstream_set_wmargin(argp_fmtstream_t __fs , size_t __wmargin ) 
{ 
  size_t __old ;

  {
#line 325
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 326
    _argp_fmtstream_update(__fs);
    }
  }
#line 327
  __old = (size_t )__fs->wmargin;
#line 328
  __fs->wmargin = (ssize_t )__wmargin;
#line 329
  return (__old);
}
}
#line 333 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.h"
size_t argp_fmtstream_point(argp_fmtstream_t __fs ) 
{ 
  ssize_t tmp ;

  {
#line 336
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 337
    _argp_fmtstream_update(__fs);
    }
  }
#line 338
  if (__fs->point_col >= 0) {
#line 338
    tmp = __fs->point_col;
  } else {
#line 338
    tmp = 0;
  }
#line 338
  return ((size_t )tmp);
}
}
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 94
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 367 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 712
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 58 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.c"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) 
{ 
  argp_fmtstream_t fs ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 64
  tmp = malloc((size_t )sizeof(struct argp_fmtstream ));
#line 64
  fs = (struct argp_fmtstream *)tmp;
  }
#line 65
  if ((unsigned long )fs != (unsigned long )((void *)0)) {
    {
#line 67
    fs->stream = stream;
#line 69
    fs->lmargin = lmargin;
#line 70
    fs->rmargin = rmargin;
#line 71
    fs->wmargin = wmargin;
#line 72
    fs->point_col = 0;
#line 73
    fs->point_offs = (size_t )0;
#line 75
    tmp___0 = malloc((size_t )200);
#line 75
    fs->buf = (char *)tmp___0;
    }
#line 76
    if (! fs->buf) {
      {
#line 78
      free((void *)fs);
#line 79
      fs = (argp_fmtstream_t )0;
      }
    } else {
#line 83
      fs->p = fs->buf;
#line 84
      fs->end = fs->buf + 200;
    }
  }
#line 88
  return (fs);
}
}
#line 98 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.c"
void argp_fmtstream_free(argp_fmtstream_t fs ) 
{ 


  {
  {
#line 101
  _argp_fmtstream_update(fs);
  }
#line 102
  if ((unsigned long )fs->p > (unsigned long )fs->buf) {
    {
#line 107
    fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                    (FILE */* __restrict  */)fs->stream);
    }
  }
  {
#line 110
  free((void *)fs->buf);
#line 111
  free((void *)fs);
  }
#line 112
  return;
}
}
#line 122 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.c"
void _argp_fmtstream_update(argp_fmtstream_t fs ) 
{ 
  char *buf ;
  char *nl ;
  size_t len ;
  size_t r ;
  size_t pad ;
  size_t i ;
  void *tmp ;
  char *p ;
  char *nextline ;
  int i___0 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t mv ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 129
  buf = fs->buf + fs->point_offs;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! ((unsigned long )buf < (unsigned long )fs->p)) {
#line 130
      goto while_break;
    }
#line 134
    if (fs->point_col == 0) {
#line 134
      if (fs->lmargin != 0U) {
#line 137
        pad = fs->lmargin;
#line 138
        if ((unsigned long )(fs->p + pad) < (unsigned long )fs->end) {
          {
#line 142
          memmove((void *)(buf + pad), (void const   *)buf, (size_t )(fs->p - buf));
#line 143
          fs->p += pad;
#line 144
          memset((void *)buf, ' ', pad);
#line 145
          buf += pad;
          }
        } else {
#line 151
          i = (size_t )0;
          {
#line 151
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 151
            if (! (i < pad)) {
#line 151
              goto while_break___0;
            }
            {
#line 158
            fputc_unlocked(' ', fs->stream);
#line 151
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 161
        fs->point_col = (ssize_t )pad;
      }
    }
    {
#line 164
    len = (size_t )(fs->p - buf);
#line 165
    tmp = memchr((void const   *)buf, '\n', len);
#line 165
    nl = (char *)tmp;
    }
#line 167
    if (fs->point_col < 0) {
#line 168
      fs->point_col = 0;
    }
#line 170
    if (! nl) {
#line 174
      if ((size_t )fs->point_col + len < fs->rmargin) {
#line 179
        fs->point_col = (ssize_t )((size_t )fs->point_col + len);
#line 180
        goto while_break;
      } else {
#line 185
        nl = fs->p;
      }
    } else
#line 187
    if ((long )fs->point_col + (nl - buf) < (long )((ssize_t )fs->rmargin)) {
#line 191
      fs->point_col = 0;
#line 192
      buf = nl + 1;
#line 193
      goto while_continue;
    }
#line 197
    r = fs->rmargin - 1U;
#line 199
    if (fs->wmargin < 0) {
#line 203
      if ((unsigned long )nl < (unsigned long )fs->p) {
        {
#line 205
        memmove((void *)(buf + (r - (size_t )fs->point_col)), (void const   *)nl,
                (size_t )(fs->p - nl));
#line 206
        fs->p -= (buf + (r - (size_t )fs->point_col)) - nl;
#line 208
        fs->point_col = 0;
#line 209
        buf += r + 1U;
        }
      } else {
#line 216
        fs->point_col = (ssize_t )((size_t )fs->point_col + len);
#line 217
        fs->p -= (size_t )fs->point_col - r;
#line 218
        goto while_break;
      }
    } else {
#line 230
      p = buf + ((r + 1U) - (size_t )fs->point_col);
      {
#line 231
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 231
        if ((unsigned long )p >= (unsigned long )buf) {
          {
#line 231
          tmp___0 = __ctype_b_loc();
          }
#line 231
          if ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 1) {
#line 231
            goto while_break___1;
          }
        } else {
#line 231
          goto while_break___1;
        }
#line 232
        p --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 233
      nextline = p + 1;
#line 235
      if ((unsigned long )nextline > (unsigned long )buf) {
#line 238
        if ((unsigned long )p >= (unsigned long )buf) {
          {
#line 239
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 240
            p --;
#line 239
            if ((unsigned long )p >= (unsigned long )buf) {
              {
#line 239
              tmp___1 = __ctype_b_loc();
              }
#line 239
              if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 1)) {
#line 239
                goto while_break___2;
              }
            } else {
#line 239
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 242
        nl = p + 1;
      } else {
#line 248
        p = buf + ((r + 1U) - (size_t )fs->point_col);
#line 250
        if ((unsigned long )p < (unsigned long )nl) {
          {
#line 251
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 252
            p ++;
#line 251
            if ((unsigned long )p < (unsigned long )nl) {
              {
#line 251
              tmp___2 = __ctype_b_loc();
              }
#line 251
              if ((int const   )*(*tmp___2 + (int )((unsigned char )*p)) & 1) {
#line 251
                goto while_break___3;
              }
            } else {
#line 251
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 254
        if ((unsigned long )p == (unsigned long )nl) {
#line 257
          fs->point_col = 0;
#line 258
          buf = nl + 1;
#line 259
          goto while_continue;
        }
#line 262
        nl = p;
        {
#line 264
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 265
          p ++;
#line 264
          tmp___3 = __ctype_b_loc();
          }
#line 264
          if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*p)) & 1)) {
#line 264
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 268
        nextline = p;
      }
#line 276
      if ((unsigned long )nextline == (unsigned long )((buf + len) + 1)) {
#line 276
        tmp___6 = fs->end - nl < (long )(fs->wmargin + 1);
      } else {
#line 276
        tmp___6 = nextline - (nl + 1) < (long )fs->wmargin;
      }
#line 276
      if (tmp___6) {
#line 276
        if ((unsigned long )fs->p > (unsigned long )nextline) {
#line 282
          if (fs->end - fs->p > (long )(fs->wmargin + 1)) {
            {
#line 285
            mv = (size_t )(fs->p - nextline);
#line 286
            memmove((void *)((nl + 1) + fs->wmargin), (void const   *)nextline, mv);
#line 287
            nextline = (nl + 1) + fs->wmargin;
#line 288
            len = (size_t )((nextline + mv) - buf);
#line 289
            tmp___4 = nl;
#line 289
            nl ++;
#line 289
            *tmp___4 = (char )'\n';
            }
          } else {
#line 298
            if ((unsigned long )nl > (unsigned long )fs->buf) {
              {
#line 299
              fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1,
                              (size_t )(nl - fs->buf), (FILE */* __restrict  */)fs->stream);
              }
            }
            {
#line 300
            fputc_unlocked('\n', fs->stream);
#line 303
            len = (size_t )((long )len + (buf - fs->buf));
#line 304
            buf = fs->buf;
#line 304
            nl = buf;
            }
          }
        } else {
#line 310
          tmp___5 = nl;
#line 310
          nl ++;
#line 310
          *tmp___5 = (char )'\n';
        }
      } else {
#line 310
        tmp___5 = nl;
#line 310
        nl ++;
#line 310
        *tmp___5 = (char )'\n';
      }
#line 312
      if (nextline - nl >= (long )fs->wmargin) {
#line 312
        goto _L;
      } else
#line 312
      if ((unsigned long )nextline == (unsigned long )((buf + len) + 1)) {
#line 312
        if (fs->end - nextline >= (long )fs->wmargin) {
          _L: /* CIL Label */ 
#line 315
          i___0 = 0;
          {
#line 315
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 315
            if (! (i___0 < fs->wmargin)) {
#line 315
              goto while_break___5;
            }
#line 316
            tmp___7 = nl;
#line 316
            nl ++;
#line 316
            *tmp___7 = (char )' ';
#line 315
            i___0 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
#line 312
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 318
        i___0 = 0;
        {
#line 318
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 318
          if (! (i___0 < fs->wmargin)) {
#line 318
            goto while_break___6;
          }
          {
#line 324
          fputc_unlocked(' ', fs->stream);
#line 318
          i___0 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 328
      if ((unsigned long )nl < (unsigned long )nextline) {
        {
#line 329
        memmove((void *)nl, (void const   *)nextline, (size_t )((buf + len) - nextline));
        }
      }
#line 330
      len = (size_t )((long )len - (nextline - buf));
#line 333
      buf = nl;
#line 336
      fs->p = nl + len;
#line 341
      if (fs->wmargin) {
#line 341
        fs->point_col = fs->wmargin;
      } else {
#line 341
        fs->point_col = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  fs->point_offs = (size_t )(fs->p - fs->buf);
#line 347
  return;
}
}
#line 351 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.c"
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) 
{ 
  ssize_t wrote ;
  size_t tmp ;
  size_t old_size ;
  size_t new_size ;
  char *new_buf ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 354
  if ((size_t )(fs->end - fs->p) < amount) {
    {
#line 359
    _argp_fmtstream_update(fs);
#line 365
    tmp = fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                          (FILE */* __restrict  */)fs->stream);
#line 365
    wrote = (ssize_t )tmp;
    }
#line 367
    if ((long )wrote == fs->p - fs->buf) {
#line 369
      fs->p = fs->buf;
#line 370
      fs->point_offs = (size_t )0;
    } else {
      {
#line 374
      fs->p -= wrote;
#line 375
      fs->point_offs -= (size_t )wrote;
#line 376
      memmove((void *)fs->buf, (void const   *)(fs->buf + wrote), (size_t )(fs->p - fs->buf));
      }
#line 377
      return (0);
    }
#line 380
    if ((size_t )(fs->end - fs->buf) < amount) {
#line 383
      old_size = (size_t )(fs->end - fs->buf);
#line 384
      new_size = old_size + amount;
#line 387
      if (new_size < old_size) {
        {
#line 389
        tmp___0 = __errno_location();
#line 389
        *tmp___0 = 12;
        }
#line 390
        return (0);
      } else {
        {
#line 387
        tmp___1 = realloc((void *)fs->buf, new_size);
#line 387
        new_buf = (char *)tmp___1;
        }
#line 387
        if (! new_buf) {
          {
#line 389
          tmp___0 = __errno_location();
#line 389
          *tmp___0 = 12;
          }
#line 390
          return (0);
        }
      }
#line 393
      fs->buf = new_buf;
#line 394
      fs->end = new_buf + new_size;
#line 395
      fs->p = fs->buf;
    }
  }
#line 399
  return (1);
}
}
#line 402 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-fmtstream.c"
ssize_t ( /* format attribute */  argp_fmtstream_printf)(struct argp_fmtstream *fs ,
                                                         char const   *fmt  , ...) 
{ 
  int out ;
  size_t avail ;
  size_t size_guess ;
  va_list args ;
  int tmp ;

  {
#line 407
  size_guess = (size_t )150;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 413
    tmp = _argp_fmtstream_ensure(fs, size_guess);
    }
#line 413
    if (! tmp) {
#line 414
      return (-1);
    }
    {
#line 416
    __builtin_va_start(args, fmt);
#line 417
    avail = (size_t )(fs->end - fs->p);
#line 418
    out = vsnprintf((char */* __restrict  */)fs->p, avail, (char const   */* __restrict  */)fmt,
                    args);
#line 419
    __builtin_va_end(args);
    }
#line 420
    if ((size_t )out >= avail) {
#line 421
      size_guess = (size_t )(out + 1);
    }
#line 409
    if (! ((size_t )out >= avail)) {
#line 409
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  fs->p += out;
#line 427
  return (out);
}
}
#line 32 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-eexst.c"
error_t argp_err_exit_status  =    64;
#line 26 "/home/ysko/Works/test-src/pies-1.2/gnu/argp-ba.c"
char const   *argp_program_bug_address  ;
#line 78 "./wordsplit.h"
int wordsplit(char const   *command___0 , struct wordsplit *ws , int flags ) ;
#line 79
void wordsplit_free(struct wordsplit *ws ) ;
#line 81
int wordsplit_unquote_char(int c ) ;
#line 82
int wordsplit_quote_char(int c ) ;
#line 83
size_t wordsplit_quoted_length(char const   *str , int quote_hex , int *quote ) ;
#line 84
void wordsplit_unquote_copy(char *dst , char const   *src , size_t n ) ;
#line 85
void wordsplit_quote_copy(char *dst , char const   *src , int quote_hex ) ;
#line 44 "../../gnu/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 44 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
static int wordsplit_init(struct wordsplit *wsp , char const   *input , size_t len ,
                          int flags ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 48
  wsp->ws_flags = flags;
#line 49
  if ((wsp->ws_flags & 68) != 68) {
#line 52
    if (wsp->ws_flags & 16) {
      {
#line 53
      tmp = gettext("variable expansion and command substitution are not yet supported");
#line 53
      error(0, 0, (char const   *)tmp);
      }
    }
    {
#line 56
    tmp___0 = __errno_location();
#line 56
    *tmp___0 = 22;
    }
#line 57
    return (1);
  }
#line 60
  wsp->ws_input = input;
#line 61
  wsp->ws_len = len;
#line 63
  if (! (wsp->ws_flags & 2)) {
#line 64
    wsp->ws_offs = (size_t )0;
  }
#line 66
  if (! (wsp->ws_flags & 8192)) {
#line 67
    wsp->ws_delim = " ";
  }
#line 69
  if (! (wsp->ws_flags & 16384)) {
#line 70
    wsp->ws_comment = (char const   *)((void *)0);
  }
#line 72
  if (wsp->ws_flags & 8) {
#line 74
    wsp->ws_wordn = wsp->ws_wordc + 1U;
#line 75
    if (! (wsp->ws_flags & 1)) {
#line 76
      wsp->ws_wordc = (size_t )0;
    }
  } else {
#line 80
    wsp->ws_wordv = (char **)((void *)0);
#line 81
    wsp->ws_wordc = (size_t )0;
#line 82
    wsp->ws_wordn = (size_t )0;
  }
#line 84
  if (wsp->ws_flags & 2) {
#line 85
    wsp->ws_wordn += wsp->ws_offs;
  }
#line 87
  wsp->ws_endp = (size_t )0;
#line 88
  return (0);
}
}
#line 91 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
static int alloc_space(struct wordsplit *wsp ) 
{ 
  size_t offs ;
  size_t tmp ;
  char **ptr ;
  size_t newalloc ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp10 ;

  {
#line 94
  if (wsp->ws_flags & 2) {
#line 94
    tmp = wsp->ws_offs;
  } else {
#line 94
    tmp = (size_t )0;
  }
#line 94
  offs = tmp;
#line 98
  if ((unsigned long )wsp->ws_wordv == (unsigned long )((void *)0)) {
    {
#line 100
    newalloc = offs + 128U;
#line 101
    tmp___0 = calloc(newalloc, (size_t )sizeof(*(ptr + 0)));
#line 101
    ptr = (char **)tmp___0;
    }
  } else
#line 103
  if (wsp->ws_wordn < (offs + wsp->ws_wordc) + 1U) {
    {
#line 105
    newalloc = (offs + wsp->ws_wordc) + 128U;
#line 106
    tmp___1 = realloc((void *)wsp->ws_wordv, (size_t )((unsigned long )newalloc * sizeof(*(ptr + 0))));
#line 106
    ptr = (char **)tmp___1;
    }
  } else {
#line 109
    return (0);
  }
#line 111
  if (ptr) {
#line 113
    wsp->ws_wordn = newalloc;
#line 114
    wsp->ws_wordv = ptr;
  } else {
#line 118
    if (wsp->ws_flags & 128) {
      {
#line 119
      xalloc_die();
      }
    } else
#line 120
    if (wsp->ws_flags & 16) {
      {
#line 121
      tmp___2 = gettext("memory exhausted");
#line 121
      error(0, 0, (char const   *)tmp___2);
      }
    }
    {
#line 122
    tmp___3 = __errno_location();
#line 122
    *tmp___3 = 12;
    }
#line 123
    return (1);
  }
#line 125
  return (0);
}
}
#line 128 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
static int skip_sed_expr(char const   *command___0 , size_t i , size_t len ) 
{ 
  int state ;
  int delim ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if ((int const   )*(command___0 + i) == 59) {
#line 138
      i ++;
    }
#line 139
    if ((int const   )*(command___0 + i) == 115) {
#line 139
      if (i + 3U < len) {
        {
#line 139
        tmp = c_ispunct((int )*(command___0 + (i + 1U)));
        }
#line 139
        if (! tmp) {
#line 140
          goto while_break;
        }
      } else {
#line 140
        goto while_break;
      }
    } else {
#line 140
      goto while_break;
    }
#line 142
    i ++;
#line 142
    delim = (int )*(command___0 + i);
#line 143
    state = 1;
#line 144
    i ++;
    {
#line 144
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 144
      if (! (i < len)) {
#line 144
        goto while_break___0;
      }
#line 146
      if (state == 3) {
#line 148
        if ((int const   )*(command___0 + i) == (int const   )delim) {
#line 149
          goto while_break___0;
        } else {
          {
#line 148
          tmp___0 = c_isalnum((int )*(command___0 + i));
          }
#line 148
          if (! tmp___0) {
#line 149
            goto while_break___0;
          }
        }
      } else
#line 151
      if ((int const   )*(command___0 + i) == 92) {
#line 152
        i ++;
      } else
#line 153
      if ((int const   )*(command___0 + i) == (int const   )delim) {
#line 154
        state ++;
      }
#line 144
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 133
    if (state == 3) {
#line 133
      if (i < len) {
#line 133
        if (! ((int const   )*(command___0 + i) == 59)) {
#line 133
          goto while_break;
        }
      } else {
#line 133
        goto while_break;
      }
    } else {
#line 133
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return ((int )i);
}
}
#line 161 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
static size_t skip_delim(struct wordsplit *wsp ) 
{ 
  size_t start ;
  char *tmp ;

  {
#line 164
  start = wsp->ws_endp;
#line 165
  if (wsp->ws_flags & 1024) {
    {
#line 167
    while (1) {
      while_continue: /* CIL Label */ ;
#line 168
      start ++;
#line 167
      if (start < wsp->ws_len) {
        {
#line 167
        tmp = strchr(wsp->ws_delim, (int )*(wsp->ws_input + start));
        }
#line 167
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 167
          goto while_break;
        }
      } else {
#line 167
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 171
    start --;
  }
#line 174
  if (! (wsp->ws_flags & 2048)) {
#line 175
    start ++;
  }
#line 177
  return (start);
}
}
#line 183 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
static int scan_word(struct wordsplit *wsp , size_t *pstart , size_t *pend ) 
{ 
  size_t start ;
  size_t len ;
  char const   *command___0 ;
  char const   *delim ;
  char const   *comment ;
  size_t i ;
  int tmp ;
  size_t j ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t j___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  char *__cil_tmp19 ;

  {
#line 186
  start = *pstart;
#line 187
  len = wsp->ws_len;
#line 188
  command___0 = wsp->ws_input;
#line 189
  delim = wsp->ws_delim;
#line 190
  comment = wsp->ws_comment;
#line 192
  i = start;
#line 194
  if (i >= len) {
#line 195
    return (0);
  }
#line 197
  if (wsp->ws_flags & 256) {
    {
#line 200
    while (1) {
      while_continue: /* CIL Label */ ;
#line 200
      if (! ((int const   )*(command___0 + i) == 32)) {
#line 200
        if (! ((int const   )*(command___0 + i) == 9)) {
#line 200
          if (! ((int const   )*(command___0 + i) == 10)) {
#line 200
            goto while_break;
          }
        }
      }
#line 201
      i ++;
#line 201
      if (i == len) {
#line 202
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 205
  start = i;
#line 207
  wsp->ws_flags &= -983041;
#line 209
  if (wsp->ws_flags & 4096) {
#line 209
    if ((int const   )*(command___0 + i) == 115) {
#line 209
      if (i + 3U < len) {
        {
#line 209
        tmp___5 = c_ispunct((int )*(command___0 + (i + 1U)));
        }
#line 209
        if (tmp___5) {
          {
#line 212
          wsp->ws_flags |= 65536;
#line 213
          tmp = skip_sed_expr(command___0, i, len);
#line 213
          i = (size_t )tmp;
          }
        } else {
#line 209
          goto _L___4;
        }
      } else {
#line 209
        goto _L___4;
      }
    } else {
#line 209
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    {
#line 215
    tmp___4 = strchr(delim, (int )*(command___0 + i));
    }
#line 215
    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 267
      if (wsp->ws_flags & 2048) {
#line 268
        i ++;
      }
    } else {
      {
#line 217
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 217
        if (! (i < len)) {
#line 217
          goto while_break___0;
        }
#line 219
        if (comment) {
          {
#line 219
          tmp___1 = strchr(comment, (int )*(command___0 + i));
          }
#line 219
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 222
            j = i + 1U;
            {
#line 222
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 222
              if (j < len) {
#line 222
                if (! ((int const   )*(command___0 + j) != 10)) {
#line 222
                  goto while_break___1;
                }
              } else {
#line 222
                goto while_break___1;
              }
#line 222
              j ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 224
            *pstart = start;
#line 225
            *pend = i;
#line 226
            wsp->ws_endp = j;
#line 227
            if (i > start) {
#line 227
              tmp___0 = 1;
            } else {
#line 227
              tmp___0 = 2;
            }
#line 227
            return (tmp___0);
          }
        }
#line 230
        if (wsp->ws_flags & 512) {
#line 232
          if ((int const   )*(command___0 + i) == 92) {
#line 234
            i ++;
#line 234
            if (i == len) {
#line 235
              goto while_break___0;
            }
#line 236
            i ++;
#line 237
            goto while_continue___0;
          }
#line 240
          if ((int const   )*(command___0 + i) == 39) {
#line 240
            goto _L___0;
          } else
#line 240
          if ((int const   )*(command___0 + i) == 34) {
            _L___0: /* CIL Label */ 
#line 243
            j___0 = i + 1U;
            {
#line 243
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 243
              if (j___0 < len) {
#line 243
                if (! ((int const   )*(command___0 + j___0) != (int const   )*(command___0 + i))) {
#line 243
                  goto while_break___2;
                }
              } else {
#line 243
                goto while_break___2;
              }
#line 244
              if ((int const   )*(command___0 + j___0) == 92) {
#line 245
                j___0 ++;
              }
#line 243
              j___0 ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 246
            if (j___0 < len) {
#line 246
              if ((int const   )*(command___0 + j___0) == (int const   )*(command___0 + i)) {
#line 247
                i = j___0 + 1U;
              } else {
#line 246
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 250
              wsp->ws_endp = i;
#line 251
              if (wsp->ws_flags & 16) {
                {
#line 252
                tmp___2 = gettext("missing closing %c (start near #%lu)");
#line 252
                error(0, 0, (char const   *)tmp___2, (int const   )*(command___0 + i),
                      (unsigned long )i);
                }
              }
#line 255
              return (1);
            }
          }
        }
#line 260
        if (wsp->ws_flags & 256) {
#line 260
          if ((int const   )*(command___0 + i) == 32) {
#line 262
            goto while_break___0;
          } else
#line 260
          if ((int const   )*(command___0 + i) == 9) {
#line 262
            goto while_break___0;
          } else
#line 260
          if ((int const   )*(command___0 + i) == 10) {
#line 262
            goto while_break___0;
          } else {
#line 260
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 260
          tmp___3 = strchr(delim, (int )*(command___0 + i));
          }
#line 260
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 262
            goto while_break___0;
          } else {
#line 264
            i ++;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 270
  *pstart = start;
#line 271
  *pend = i;
#line 272
  wsp->ws_endp = i;
#line 274
  return (1);
}
}
#line 277 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
static char quote_transtab[17]  = 
#line 277
  {      (char )'\\',      (char )'\\',      (char )'a',      (char )'\a', 
        (char )'b',      (char )'\b',      (char )'f',      (char )'\f', 
        (char )'n',      (char )'\n',      (char )'r',      (char )'\r', 
        (char )'t',      (char )'\t',      (char )'v',      (char )'\v', 
        (char )'\000'};
#line 279 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
int wordsplit_unquote_char(int c ) 
{ 
  char *p ;

  {
#line 284
  p = quote_transtab;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! *p) {
#line 284
      goto while_break;
    }
#line 286
    if ((int )*p == c) {
#line 287
      return ((int )*(p + 1));
    }
#line 284
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  return (c);
}
}
#line 292 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
int wordsplit_quote_char(int c ) 
{ 
  char *p ;

  {
#line 297
  p = (quote_transtab + sizeof(quote_transtab)) - 2;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! ((unsigned long )p > (unsigned long )(quote_transtab))) {
#line 297
      goto while_break;
    }
#line 300
    if ((int )*p == c) {
#line 301
      return ((int )*(p + -1));
    }
#line 297
    p -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return (-1);
}
}
#line 309 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
static int xtonum(int *pval , char const   *src , int base , int cnt ) 
{ 
  int i ;
  int val ;
  int n ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 314
  i = 0;
#line 314
  val = 0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < cnt)) {
#line 314
      goto while_break;
    }
#line 316
    n = (int )*((unsigned char *)src);
#line 317
    if (n > 127) {
#line 318
      goto while_break;
    } else {
      {
#line 317
      tmp___4 = __ctype_b_loc();
      }
#line 317
      if ((int const   )*(*tmp___4 + n) & 2048) {
#line 317
        n -= 48;
      } else {
        {
#line 317
        tmp___3 = __ctype_b_loc();
        }
#line 317
        if ((int const   )*(*tmp___3 + n) & 4096) {
          {
#line 317
          tmp___1 = (int )toupper(n);
#line 317
          tmp___2 = (tmp___1 - 65) + 10;
          }
        } else {
#line 317
          tmp___2 = 255;
        }
#line 317
        n = tmp___2;
      }
#line 317
      if (n >= base) {
#line 318
        goto while_break;
      }
    }
#line 319
    val = val * base + n;
#line 314
    i ++;
#line 314
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  *pval = val;
#line 322
  return (i);
}
}
#line 325 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
size_t wordsplit_quoted_length(char const   *str , int quote_hex , int *quote ) 
{ 
  size_t len ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 328
  len = (size_t )0;
#line 330
  *quote = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! *str) {
#line 331
      goto while_break;
    }
#line 333
    if ((int const   )*str == 32) {
#line 335
      len ++;
#line 336
      *quote = 1;
    } else
#line 338
    if ((int const   )*str == 34) {
#line 340
      len += 2U;
#line 341
      *quote = 1;
    } else
#line 343
    if ((int const   )*str != 9) {
#line 343
      if ((int const   )*str != 92) {
        {
#line 343
        tmp___0 = __ctype_b_loc();
        }
#line 343
        if ((int const   )*(*tmp___0 + (int )*str) & 16384) {
#line 344
          len ++;
        } else {
#line 343
          goto _L___0;
        }
      } else {
#line 343
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 345
    if (quote_hex) {
#line 346
      len += 3U;
    } else {
      {
#line 349
      tmp = wordsplit_quote_char((int )*str);
      }
#line 349
      if (tmp != -1) {
#line 350
        len += 2U;
      } else {
#line 352
        len += 4U;
      }
    }
#line 331
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (len);
}
}
#line 358 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
void wordsplit_unquote_copy(char *dst , char const   *src , size_t n ) 
{ 
  int i ;
  int c ;
  int expect_delim ;
  char const   *p ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int off ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int off___0 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned short const   **tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;

  {
#line 361
  i = 0;
#line 363
  expect_delim = 0;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! ((size_t )i < n)) {
#line 365
      goto while_break;
    }
    {
#line 370
    if ((int const   )*(src + i) == 34) {
#line 370
      goto case_34;
    }
#line 370
    if ((int const   )*(src + i) == 39) {
#line 370
      goto case_34;
    }
#line 389
    if ((int const   )*(src + i) == 92) {
#line 389
      goto case_92;
    }
#line 439
    goto switch_default;
    case_34: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 371
    if (! expect_delim) {
#line 375
      p = (src + i) + 1;
      {
#line 375
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 375
        if (*p) {
#line 375
          if (! ((int const   )*p != (int const   )*(src + i))) {
#line 375
            goto while_break___0;
          }
        } else {
#line 375
          goto while_break___0;
        }
#line 376
        if ((int const   )*p == 92) {
#line 377
          p ++;
        }
#line 375
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 378
      if (*p) {
#line 379
        tmp = i;
#line 379
        i ++;
#line 379
        expect_delim = (int )*(src + tmp);
      } else {
#line 381
        tmp___0 = dst;
#line 381
        dst ++;
#line 381
        tmp___1 = i;
#line 381
        i ++;
#line 381
        *tmp___0 = (char )*(src + tmp___1);
      }
    } else
#line 383
    if (expect_delim == (int )*(src + i)) {
#line 384
      i ++;
    } else {
#line 386
      tmp___2 = dst;
#line 386
      dst ++;
#line 386
      tmp___3 = i;
#line 386
      i ++;
#line 386
      *tmp___2 = (char )*(src + tmp___3);
    }
#line 387
    goto switch_break;
    case_92: /* CIL Label */ 
#line 390
    i ++;
#line 391
    if ((int const   )*(src + i) == 120) {
#line 391
      goto _L___0;
    } else
#line 391
    if ((int const   )*(src + i) == 88) {
      _L___0: /* CIL Label */ 
#line 393
      if (n - (size_t )i < 2U) {
#line 395
        tmp___4 = dst;
#line 395
        dst ++;
#line 395
        *tmp___4 = (char )'\\';
#line 396
        tmp___5 = dst;
#line 396
        dst ++;
#line 396
        tmp___6 = i;
#line 396
        i ++;
#line 396
        *tmp___5 = (char )*(src + tmp___6);
      } else {
        {
#line 400
        tmp___7 = xtonum(& c, (src + i) + 1, 16, 2);
#line 400
        off = tmp___7;
        }
#line 401
        if (off == 0) {
#line 403
          tmp___8 = dst;
#line 403
          dst ++;
#line 403
          *tmp___8 = (char )'\\';
#line 404
          tmp___9 = dst;
#line 404
          dst ++;
#line 404
          tmp___10 = i;
#line 404
          i ++;
#line 404
          *tmp___9 = (char )*(src + tmp___10);
        } else {
#line 408
          tmp___11 = dst;
#line 408
          dst ++;
#line 408
          *tmp___11 = (char )c;
#line 409
          i += off + 1;
        }
      }
    } else
#line 413
    if ((int )((unsigned char )*(src + i)) < 128) {
      {
#line 413
      tmp___23 = __ctype_b_loc();
      }
#line 413
      if ((int const   )*(*tmp___23 + (int )*(src + i)) & 2048) {
#line 415
        if (n - (size_t )i < 1U) {
#line 417
          tmp___12 = dst;
#line 417
          dst ++;
#line 417
          *tmp___12 = (char )'\\';
#line 418
          tmp___13 = dst;
#line 418
          dst ++;
#line 418
          tmp___14 = i;
#line 418
          i ++;
#line 418
          *tmp___13 = (char )*(src + tmp___14);
        } else {
          {
#line 422
          tmp___15 = xtonum(& c, src + i, 8, 3);
#line 422
          off___0 = tmp___15;
          }
#line 423
          if (off___0 == 0) {
#line 425
            tmp___16 = dst;
#line 425
            dst ++;
#line 425
            *tmp___16 = (char )'\\';
#line 426
            tmp___17 = dst;
#line 426
            dst ++;
#line 426
            tmp___18 = i;
#line 426
            i ++;
#line 426
            *tmp___17 = (char )*(src + tmp___18);
          } else {
#line 430
            tmp___19 = dst;
#line 430
            dst ++;
#line 430
            *tmp___19 = (char )c;
#line 431
            i += off___0;
          }
        }
      } else {
#line 413
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 436
      tmp___20 = dst;
#line 436
      dst ++;
#line 436
      tmp___21 = i;
#line 436
      i ++;
#line 436
      tmp___22 = wordsplit_unquote_char((int )*(src + tmp___21));
#line 436
      *tmp___20 = (char )tmp___22;
      }
    }
#line 437
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 440
    tmp___24 = dst;
#line 440
    dst ++;
#line 440
    tmp___25 = i;
#line 440
    i ++;
#line 440
    *tmp___24 = (char )*(src + tmp___25);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  *dst = (char)0;
#line 444
  return;
}
}
#line 446 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
void wordsplit_quote_copy(char *dst , char const   *src , int quote_hex ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char tmp___2[4] ;
  int c ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! *src) {
#line 449
      goto while_break;
    }
#line 451
    if ((int const   )*src == 34) {
#line 453
      tmp = dst;
#line 453
      dst ++;
#line 453
      *tmp = (char )'\\';
#line 454
      tmp___0 = dst;
#line 454
      dst ++;
#line 454
      *tmp___0 = (char )*src;
    } else
#line 456
    if ((int const   )*src != 9) {
#line 456
      if ((int const   )*src != 92) {
        {
#line 456
        tmp___6 = __ctype_b_loc();
        }
#line 456
        if ((int const   )*(*tmp___6 + (int )*src) & 16384) {
#line 457
          tmp___1 = dst;
#line 457
          dst ++;
#line 457
          *tmp___1 = (char )*src;
        } else {
#line 456
          goto _L___0;
        }
      } else {
#line 456
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 462
    if (quote_hex) {
      {
#line 464
      snprintf((char */* __restrict  */)(tmp___2), (size_t )sizeof(tmp___2), (char const   */* __restrict  */)"%%%02X",
               (int )*((unsigned char *)src));
#line 465
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(tmp___2),
             (size_t )3);
#line 466
      dst += 3;
      }
    } else {
      {
#line 470
      tmp___3 = wordsplit_quote_char((int )*src);
#line 470
      c = tmp___3;
#line 471
      tmp___4 = dst;
#line 471
      dst ++;
#line 471
      *tmp___4 = (char )'\\';
      }
#line 472
      if (c != -1) {
#line 473
        tmp___5 = dst;
#line 473
        dst ++;
#line 473
        *tmp___5 = (char )c;
      } else {
        {
#line 476
        snprintf((char */* __restrict  */)(tmp___2), (size_t )sizeof(tmp___2), (char const   */* __restrict  */)"%03o",
                 (int )*((unsigned char *)src));
#line 477
        memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(tmp___2),
               (size_t )3);
#line 478
        dst += 3;
        }
      }
    }
#line 449
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  return;
}
}
#line 485 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
int wordsplit_len(char const   *command___0 , size_t len , struct wordsplit *wsp ,
                  int flags ) 
{ 
  int rc ;
  size_t start ;
  size_t end ;
  int unquote ;
  size_t n ;
  char *p ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp16 ;

  {
  {
#line 490
  start = (size_t )0;
#line 490
  end = (size_t )0;
#line 492
  rc = wordsplit_init(wsp, command___0, len, flags);
  }
#line 493
  if (rc) {
#line 494
    return (rc);
  }
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 496
    rc = scan_word(wsp, & start, & end);
    }
#line 496
    if (! (rc > 0)) {
#line 496
      goto while_break;
    }
#line 498
    unquote = 1;
#line 502
    if (rc == 2) {
#line 503
      goto __Cont;
    }
    {
#line 505
    tmp = alloc_space(wsp);
    }
#line 505
    if (tmp) {
#line 506
      return (2);
    }
#line 508
    n = end - start;
#line 510
    if (wsp->ws_flags & 512) {
#line 510
      if (! (wsp->ws_flags & 65536)) {
#line 513
        if (start < end) {
#line 513
          if ((int const   )*(command___0 + start) == 34) {
#line 513
            goto _L;
          } else
#line 513
          if ((int const   )*(command___0 + start) == 39) {
            _L: /* CIL Label */ 
#line 513
            if ((int const   )*(command___0 + (end - 1U)) == (int const   )*(command___0 + start)) {
#line 517
              unquote = (int const   )*(command___0 + start) == 34;
#line 518
              start ++;
#line 519
              n -= 2U;
            }
          }
        }
      } else {
#line 523
        unquote = 0;
      }
    } else {
#line 523
      unquote = 0;
    }
    {
#line 525
    tmp___0 = malloc(n + 1U);
#line 525
    p = (char *)tmp___0;
    }
#line 526
    if (! p) {
#line 528
      if (wsp->ws_flags & 128) {
        {
#line 529
        xalloc_die();
        }
      }
#line 530
      if (wsp->ws_flags & 16) {
        {
#line 531
        tmp___1 = gettext("memory exhausted");
#line 531
        error(0, 0, (char const   *)tmp___1);
        }
      }
#line 532
      if (! (wsp->ws_flags & 8)) {
        {
#line 533
        wordsplit_free(wsp);
        }
      }
      {
#line 534
      tmp___2 = __errno_location();
#line 534
      *tmp___2 = 12;
      }
#line 535
      return (2);
    }
#line 538
    if (unquote) {
      {
#line 539
      wordsplit_unquote_copy(p, command___0 + start, n);
      }
    } else {
      {
#line 542
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(command___0 + start),
             n);
#line 543
      *(p + n) = (char)0;
      }
    }
#line 545
    *(wsp->ws_wordv + (wsp->ws_offs + wsp->ws_wordc)) = p;
#line 546
    (wsp->ws_wordc) ++;
    __Cont: /* CIL Label */ 
    {
#line 496
    start = skip_delim(wsp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 550
  tmp___3 = alloc_space(wsp);
  }
#line 550
  if (tmp___3) {
#line 551
    return (2);
  }
#line 552
  *(wsp->ws_wordv + (wsp->ws_offs + wsp->ws_wordc)) = (char *)((void *)0);
#line 554
  return (rc);
}
}
#line 557 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
int wordsplit(char const   *command___0 , struct wordsplit *ws , int flags ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 560
  tmp = strlen(command___0);
#line 560
  tmp___0 = wordsplit_len(command___0, tmp, ws, flags);
  }
#line 560
  return (tmp___0);
}
}
#line 563 "/home/ysko/Works/test-src/pies-1.2/grecs/src/wordsplit.c"
void wordsplit_free(struct wordsplit *ws ) 
{ 


  {
  {
#line 566
  free((void *)ws->ws_wordv);
#line 567
  ws->ws_wordv = (char **)((void *)0);
  }
#line 568
  return;
}
}
#line 149 "./grecs.h"
char *grecs_install_text(char const   *str ) ;
#line 150
void grecs_destroy_text(void) ;
#line 25 "/home/ysko/Works/test-src/pies-1.2/grecs/src/text.c"
static Hash_table *text_table  ;
#line 28 "/home/ysko/Works/test-src/pies-1.2/grecs/src/text.c"
static size_t text_hasher(void const   *data , size_t n_buckets ) 
{ 
  size_t tmp ;

  {
  {
#line 31
  tmp = hash_string((char const   *)data, n_buckets);
  }
#line 31
  return (tmp);
}
}
#line 35 "/home/ysko/Works/test-src/pies-1.2/grecs/src/text.c"
static _Bool text_compare(void const   *data1 , void const   *data2 ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = strcmp((char const   *)data1, (char const   *)data2);
  }
#line 38
  return ((_Bool )(tmp == 0));
}
}
#line 41 "/home/ysko/Works/test-src/pies-1.2/grecs/src/text.c"
static void text_free(void *data ) 
{ 


  {
  {
#line 44
  free(data);
  }
#line 45
  return;
}
}
#line 48 "/home/ysko/Works/test-src/pies-1.2/grecs/src/text.c"
char *grecs_install_text(char const   *str ) 
{ 
  char *text ;
  char *s ;
  void *tmp ;

  {
  {
#line 53
  s = xstrdup(str);
  }
#line 55
  if (text_table) {
#line 55
    goto _L;
  } else {
    {
#line 55
    text_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & text_hasher,
                                 & text_compare, & text_free);
    }
#line 55
    if (text_table) {
      _L: /* CIL Label */ 
      {
#line 55
      tmp = hash_insert(text_table, (void const   *)s);
#line 55
      text = (char *)tmp;
      }
#line 55
      if (! text) {
        {
#line 61
        xalloc_die();
        }
      }
    } else {
      {
#line 61
      xalloc_die();
      }
    }
  }
#line 63
  if ((unsigned long )s != (unsigned long )text) {
    {
#line 64
    free((void *)s);
    }
  }
#line 65
  return (text);
}
}
#line 68 "/home/ysko/Works/test-src/pies-1.2/grecs/src/text.c"
void grecs_destroy_text(void) 
{ 


  {
#line 71
  if (text_table) {
    {
#line 72
    hash_free(text_table);
    }
  }
#line 73
  return;
}
}
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 414
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 765
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 985
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 249 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 382
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 846
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 852
extern int pclose(FILE *__stream ) ;
#line 460 "../../gnu/gl_list.h"
__inline static gl_list_t gl_list_create_empty_inline(gl_list_implementation_t implementation ,
                                                      _Bool (*equals_fn)(void const   *elt1 ,
                                                                         void const   *elt2 ) ,
                                                      size_t (*hashcode_fn)(void const   *elt ) ,
                                                      void (*dispose_fn)(void const   *elt ) ,
                                                      _Bool allow_duplicates ) 
{ 
  gl_list_t tmp ;

  {
  {
#line 467
  tmp = (*(implementation->create_empty))(implementation, equals_fn, hashcode_fn,
                                          dispose_fn, allow_duplicates);
  }
#line 467
  return (tmp);
}
}
#line 603 "../../gnu/gl_list.h"
__inline static gl_list_node_t gl_list_add_last_inline(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 606
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->add_last))(list,
                                                                            elt);
  }
#line 606
  return (tmp);
}
}
#line 635 "../../gnu/gl_list.h"
__inline static _Bool gl_list_remove_node_inline(gl_list_t list , gl_list_node_t node ) 
{ 
  _Bool tmp ;

  {
  {
#line 638
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->remove_node))(list,
                                                                               node);
  }
#line 638
  return (tmp);
}
}
#line 666 "../../gnu/gl_list.h"
__inline static gl_list_iterator_t gl_list_iterator_inline(gl_list_t list ) 
{ 
  gl_list_iterator_t tmp ;
  void *__cil_tmp3 ;

  {
  {
#line 669
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->iterator))(list);
  }
#line 669
  return (tmp);
}
}
#line 682 "../../gnu/gl_list.h"
__inline static _Bool gl_list_iterator_next_inline(gl_list_iterator_t *iterator ,
                                                   void const   **eltp , gl_list_node_t *nodep ) 
{ 
  _Bool tmp ;

  {
  {
#line 686
  tmp = (*((iterator->vtable)->iterator_next))(iterator, eltp, nodep);
  }
#line 686
  return (tmp);
}
}
#line 690 "../../gnu/gl_list.h"
__inline static void gl_list_iterator_free_inline(gl_list_iterator_t *iterator ) 
{ 


  {
  {
#line 693
  (*((iterator->vtable)->iterator_free))(iterator);
  }
#line 694
  return;
}
}
#line 111 "./grecs.h"
void ( /* format attribute */  grecs_error)(grecs_locus_t *locus , int errcode , char const   *fmt 
                                            , ...) ;
#line 136
char const   *grecs_preprocessor ;
#line 137
_Bool grecs_log_to_stderr ;
#line 138
void (*grecs_log_setup_hook)() ;
#line 140
size_t grecs_preproc_fill_buffer(char *buf , size_t size ) ;
#line 141
void grecs_preproc_add_include_dir(char *dir ) ;
#line 142
int grecs_preproc_init(char const   *name ) ;
#line 143
void grecs_preproc_done(void) ;
#line 144
int grecs_preproc_run(char const   *config_file , char const   *extpp ) ;
#line 146
FILE *grecs_preproc_extrn_start(char const   *file_name , pid_t *ppid ) ;
#line 147
void grecs_preproc_extrn_shutdown(pid_t pid ) ;
#line 152
void grecs_include_path_setup(char const   *dir  , ...) ;
#line 153
void grecs_include_path_setup_v(char **dirs ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 45 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
_Bool grecs_log_to_stderr  =    (_Bool)1;
#line 46 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
void (*grecs_log_setup_hook)()  =    (void (*)())((void *)0);
#line 64
int yy_grecs_flex_debug ;
#line 65 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static struct buffer_ctx *context_stack  ;
#line 70 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static char *linebuf  ;
#line 71 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static size_t bufsize  ;
#line 72 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static char *putback_buffer  ;
#line 73 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static size_t putback_size  ;
#line 74 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static size_t putback_max  ;
#line 76
static int push_source(char const   *name , int once ) ;
#line 77
static int pop_source(void) ;
#line 78
static int parse_include(char const   *text , int once ) ;
#line 80 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static void putback(char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 85
  if (! *str) {
#line 86
    return;
  }
  {
#line 87
  tmp = strlen(str);
#line 87
  len = tmp + 1U;
  }
#line 88
  if (len > putback_max) {
    {
#line 90
    putback_max = len;
#line 91
    tmp___0 = xrealloc((void *)putback_buffer, putback_max);
#line 91
    putback_buffer = (char *)tmp___0;
    }
  }
  {
#line 93
  strcpy((char */* __restrict  */)putback_buffer, (char const   */* __restrict  */)str);
#line 94
  putback_size = len - 1U;
  }
#line 95
  return;
}
}
#line 101 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static size_t pp_line_stmt_size(void) 
{ 
  char lbuf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char xbuf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *lp ;
  char *xp ;
  size_t tmp ;
  size_t tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 108
  lp = umaxtostr((uintmax_t )context_stack->locus.line, lbuf);
#line 109
  xp = umaxtostr((uintmax_t )(context_stack->xlines + 1U), xbuf);
  }
#line 110
  if (context_stack->namelen == 0U) {
    {
#line 111
    context_stack->namelen = strlen((char const   *)context_stack->locus.file);
    }
  }
  {
#line 114
  tmp = strlen((char const   *)lp);
#line 114
  tmp___0 = strlen((char const   *)xp);
  }
#line 114
  return (((11U + tmp) + tmp___0) + context_stack->namelen);
}
}
#line 117 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static void pp_line_stmt(void) 
{ 
  char *p ;
  size_t ls_size ;
  size_t tmp ;
  size_t pb_size ;
  void *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 121
  tmp = pp_line_stmt_size();
#line 121
  ls_size = tmp;
#line 122
  pb_size = (putback_size + ls_size) + 1U;
  }
#line 124
  if (pb_size > putback_max) {
    {
#line 126
    putback_max = pb_size;
#line 127
    tmp___0 = xrealloc((void *)putback_buffer, putback_max);
#line 127
    putback_buffer = (char *)tmp___0;
    }
  }
  {
#line 130
  p = putback_buffer + putback_size;
#line 131
  (context_stack->xlines) ++;
#line 132
  snprintf((char */* __restrict  */)p, putback_max - putback_size, (char const   */* __restrict  */)"#line %lu \"%s\" %lu\n",
           (unsigned long )context_stack->locus.line, context_stack->locus.file, (unsigned long )context_stack->xlines);
#line 136
  putback_size += ls_size;
  }
#line 137
  return;
}
}
#line 143 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static int next_line(void) 
{ 
  ssize_t rc ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (putback_size) {
#line 152
      if (putback_size + 1U > bufsize) {
        {
#line 154
        bufsize = putback_size + 1U;
#line 155
        tmp = xrealloc((void *)linebuf, bufsize);
#line 155
        linebuf = (char *)tmp;
        }
      }
      {
#line 157
      strcpy((char */* __restrict  */)linebuf, (char const   */* __restrict  */)putback_buffer);
#line 158
      rc = (ssize_t )putback_size;
#line 159
      putback_size = (size_t )0;
      }
    } else
#line 161
    if (! context_stack) {
#line 162
      return (0);
    } else {
      {
#line 164
      rc = (ssize_t )getline((char **/* __restrict  */)(& linebuf), (size_t */* __restrict  */)(& bufsize),
                             (FILE */* __restrict  */)context_stack->infile);
      }
    }
#line 148
    if (rc == -1) {
      {
#line 148
      tmp___0 = pop_source();
      }
#line 148
      if (! (tmp___0 == 0)) {
#line 148
        goto while_break;
      }
    } else {
#line 148
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return (rc);
}
}
#line 170 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
size_t grecs_preproc_fill_buffer(char *buf , size_t size ) 
{ 
  size_t bufsize___0 ;
  char *p ;
  size_t len ;
  int is_line ;
  unsigned short const   **tmp ;
  size_t l ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 173
  bufsize___0 = size;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 175
    tmp___9 = next_line();
    }
#line 175
    if (! (tmp___9 > 0)) {
#line 175
      goto while_break;
    }
#line 179
    is_line = 0;
#line 181
    p = linebuf;
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if (*p) {
        {
#line 181
        tmp = __ctype_b_loc();
        }
#line 181
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 181
          goto while_break___0;
        }
      } else {
#line 181
        goto while_break___0;
      }
#line 181
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 183
    if ((int )*p == 35) {
#line 186
      p ++;
      {
#line 186
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 186
        if (*p) {
          {
#line 186
          tmp___0 = __ctype_b_loc();
          }
#line 186
          if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 186
            goto while_break___1;
          }
        } else {
#line 186
          goto while_break___1;
        }
#line 186
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 188
      l = strlen((char const   *)p);
      }
#line 189
      if ((unsigned long )l >= sizeof("include_once")) {
        {
#line 189
        tmp___7 = memcmp((void const   *)p, (void const   *)"include_once", (size_t )(sizeof("include_once") - 1UL));
        }
#line 189
        if (tmp___7 == 0) {
          {
#line 189
          tmp___8 = __ctype_b_loc();
          }
#line 189
          if ((int const   )*(*tmp___8 + (int )*(p + (sizeof("include_once") - 1UL))) & 8192) {
            {
#line 191
            tmp___1 = parse_include((char const   *)linebuf, 1);
            }
#line 191
            if (tmp___1) {
              {
#line 192
              putback("/*include_once*/\n");
              }
            }
#line 193
            goto while_continue;
          } else {
#line 189
            goto _L___2;
          }
        } else {
#line 189
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 195
      if ((unsigned long )l >= sizeof("include")) {
        {
#line 195
        tmp___5 = memcmp((void const   *)p, (void const   *)"include", (size_t )(sizeof("include") - 1UL));
        }
#line 195
        if (tmp___5 == 0) {
          {
#line 195
          tmp___6 = __ctype_b_loc();
          }
#line 195
          if ((int const   )*(*tmp___6 + (int )*(p + (sizeof("include") - 1UL))) & 8192) {
            {
#line 197
            tmp___2 = parse_include((char const   *)linebuf, 0);
            }
#line 197
            if (tmp___2) {
              {
#line 198
              putback("/*include*/\n");
              }
            }
#line 199
            goto while_continue;
          } else {
#line 195
            goto _L___0;
          }
        } else {
#line 195
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 201
      if ((unsigned long )l >= sizeof("line")) {
        {
#line 201
        tmp___3 = memcmp((void const   *)p, (void const   *)"line", (size_t )(sizeof("line") - 1UL));
        }
#line 201
        if (tmp___3 == 0) {
          {
#line 201
          tmp___4 = __ctype_b_loc();
          }
#line 201
          if ((int const   )*(*tmp___4 + (int )*(p + (sizeof("line") - 1UL))) & 8192) {
#line 202
            is_line = 1;
          }
        }
      }
    }
    {
#line 205
    len = strlen((char const   *)linebuf);
    }
#line 207
    if (len > size) {
#line 208
      len = size;
    }
    {
#line 210
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)linebuf,
           len);
#line 211
    buf += len;
#line 212
    size -= len;
    }
#line 214
    if (size == 0U) {
      {
#line 216
      putback((char const   *)(linebuf + len));
      }
#line 217
      goto while_break;
    }
#line 220
    if (! is_line) {
#line 220
      if (len > 0U) {
#line 220
        if ((int )*(linebuf + (len - 1U)) == 10) {
#line 221
          (context_stack->locus.line) ++;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return (bufsize___0 - size);
}
}
#line 229 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static struct buffer_ctx *ctx_lookup(struct stat *st ) 
{ 
  struct buffer_ctx *ctx ;

  {
#line 234
  if (! context_stack) {
#line 235
    return ((struct buffer_ctx *)((void *)0));
  }
#line 237
  ctx = context_stack->prev;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! ctx) {
#line 237
      goto while_break;
    }
#line 238
    if (ctx->id.i_node == st->st_ino) {
#line 238
      if (ctx->id.device == st->st_dev) {
#line 239
        goto while_break;
      }
    }
#line 237
    ctx = ctx->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return (ctx);
}
}
#line 243 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
char const   *grecs_preprocessor  =    (char const   *)((void *)0);
#line 244 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static gl_list_t include_path  ;
#line 245 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static gl_list_t std_include_path  ;
#line 256 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static int pp_list_find(gl_list_t list , struct file_data *dptr ) 
{ 
  void const   *p ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp ;
  char const   *dir ;
  size_t size ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 260
  tmp = gl_list_iterator_inline(list);
#line 260
  itr = tmp;
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! dptr->found) {
      {
#line 262
      tmp___3 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
      }
#line 262
      if (! tmp___3) {
#line 262
        goto while_break;
      }
    } else {
#line 262
      goto while_break;
    }
    {
#line 264
    dir = (char const   *)p;
#line 265
    tmp___0 = strlen(dir);
#line 265
    size = ((tmp___0 + 1U) + dptr->namelen) + 1U;
    }
#line 266
    if (size > dptr->buflen) {
      {
#line 268
      dptr->buflen = size;
#line 269
      tmp___1 = xrealloc((void *)dptr->buf, dptr->buflen);
#line 269
      dptr->buf = (char *)tmp___1;
      }
    }
    {
#line 271
    strcpy((char */* __restrict  */)dptr->buf, (char const   */* __restrict  */)dir);
#line 272
    strcat((char */* __restrict  */)dptr->buf, (char const   */* __restrict  */)"/");
#line 273
    strcat((char */* __restrict  */)dptr->buf, (char const   */* __restrict  */)dptr->name);
#line 274
    tmp___2 = access((char const   *)dptr->buf, 0);
#line 274
    dptr->found = tmp___2 == 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  gl_list_iterator_free_inline(& itr);
  }
#line 277
  return (dptr->found);
}
}
#line 280 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
gl_list_t pp_list_create(void) 
{ 
  gl_list_t tmp ;

  {
  {
#line 283
  tmp = gl_list_create_empty_inline(& gl_linked_list_implementation, (_Bool (*)(void const   *elt1 ,
                                                                                void const   *elt2 ))((void *)0),
                                    (size_t (*)(void const   *elt ))((void *)0), (void (*)(void const   *elt ))((void *)0),
                                    (_Bool)0);
  }
#line 283
  return (tmp);
}
}
#line 290 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
void grecs_include_path_setup_v(char **dirs ) 
{ 
  int i ;
  char *tmp ;

  {
#line 293
  if (! include_path) {
    {
#line 294
    include_path = pp_list_create();
    }
  }
  {
#line 295
  std_include_path = pp_list_create();
  }
#line 296
  if (dirs) {
#line 299
    i = 0;
    {
#line 299
    while (1) {
      while_continue: /* CIL Label */ ;
#line 299
      if (! *(dirs + i)) {
#line 299
        goto while_break;
      }
      {
#line 301
      tmp = xstrdup((char const   *)*(dirs + i));
#line 301
      gl_list_add_last_inline(std_include_path, (void const   *)tmp);
#line 299
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 303
  return;
}
}
#line 305 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
void grecs_include_path_setup(char const   *dir  , ...) 
{ 
  char const   *p ;
  char **argv ;
  size_t argc ;
  size_t argi ;
  va_list ap ;
  void *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 309
  argv = (char **)((void *)0);
#line 310
  argc = (size_t )0;
#line 311
  argi = (size_t )0;
#line 314
  __builtin_va_start(ap, dir);
#line 315
  p = dir;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (argi == argc) {
#line 320
      if (argc == 0U) {
#line 321
        argc = (size_t )16;
      }
      {
#line 322
      tmp = x2nrealloc((void *)argv, & argc, (size_t )sizeof(*(argv + 0)));
#line 322
      argv = (char **)tmp;
      }
    }
#line 324
    tmp___0 = argi;
#line 324
    argi ++;
#line 324
    *(argv + tmp___0) = (char *)p;
#line 325
    if (! p) {
#line 326
      goto while_break;
    }
    {
#line 327
    tmp___1 = __builtin_va_arg(ap, char const   *);
#line 327
    p = tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 329
  grecs_include_path_setup_v(argv);
#line 330
  free((void *)argv);
#line 331
  __builtin_va_end(ap);
  }
#line 332
  return;
}
}
#line 334 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
void grecs_preproc_add_include_dir(char *dir ) 
{ 


  {
#line 337
  if (! include_path) {
    {
#line 338
    include_path = pp_list_create();
    }
  }
  {
#line 339
  gl_list_add_last_inline(include_path, (void const   *)dir);
  }
#line 340
  return;
}
}
#line 342 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static Hash_table *incl_sources  ;
#line 345 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static size_t incl_hasher(void const   *data , size_t n_buckets ) 
{ 
  struct input_file_ident  const  *id ;

  {
#line 348
  id = (struct input_file_ident  const  *)data;
#line 349
  return ((size_t )(((dev_t const   )id->i_node + id->device) % (unsigned long long const   )n_buckets));
}
}
#line 353 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static _Bool incl_compare(void const   *data1 , void const   *data2 ) 
{ 
  struct input_file_ident  const  *id1 ;
  struct input_file_ident  const  *id2 ;
  int tmp ;

  {
#line 356
  id1 = (struct input_file_ident  const  *)data1;
#line 357
  id2 = (struct input_file_ident  const  *)data2;
#line 358
  if (id1->device == id2->device) {
#line 358
    if (id1->i_node == id2->i_node) {
#line 358
      tmp = 1;
    } else {
#line 358
      tmp = 0;
    }
  } else {
#line 358
    tmp = 0;
  }
#line 358
  return ((_Bool )tmp);
}
}
#line 361 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static void incl_free(void *data ) 
{ 


  {
  {
#line 364
  free(data);
  }
#line 365
  return;
}
}
#line 367 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static int source_lookup(struct stat *st ) 
{ 
  struct input_file_ident *sample ;
  void *tmp ;
  struct input_file_ident *id ;
  void *tmp___0 ;

  {
  {
#line 370
  tmp = xmalloc((size_t )sizeof(*sample));
#line 370
  sample = (struct input_file_ident *)tmp;
#line 372
  sample->i_node = st->st_ino;
#line 373
  sample->device = st->st_dev;
  }
#line 375
  if (incl_sources) {
#line 375
    goto _L;
  } else {
    {
#line 375
    incl_sources = hash_initialize((size_t )0, (Hash_tuning const   *)0, & incl_hasher,
                                   & incl_compare, & incl_free);
    }
#line 375
    if (incl_sources) {
      _L: /* CIL Label */ 
      {
#line 375
      tmp___0 = hash_insert(incl_sources, (void const   *)sample);
#line 375
      id = (struct input_file_ident *)tmp___0;
      }
#line 375
      if (! id) {
        {
#line 381
        xalloc_die();
        }
      }
    } else {
      {
#line 381
      xalloc_die();
      }
    }
  }
#line 383
  if ((unsigned long )id != (unsigned long )sample) {
    {
#line 385
    free((void *)sample);
    }
#line 386
    return (1);
  }
#line 388
  return (0);
}
}
#line 392 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static int push_source(char const   *name , int once ) 
{ 
  FILE *fp ;
  struct buffer_ctx *ctx ;
  struct stat st ;
  int rc ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  void *tmp___11 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 398
  tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
#line 398
  rc = tmp;
  }
#line 400
  if (context_stack) {
#line 402
    if (rc) {
      {
#line 404
      tmp___0 = gettext("Cannot stat `%s\'");
#line 404
      tmp___1 = __errno_location();
#line 404
      grecs_error(& context_stack->locus, *tmp___1, (char const   *)tmp___0, name);
      }
#line 405
      return (1);
    }
#line 408
    if (context_stack->locus.file) {
#line 408
      if (context_stack->id.i_node == st.st_ino) {
#line 408
        if (context_stack->id.device == st.st_dev) {
          {
#line 410
          tmp___2 = gettext("Recursive inclusion");
#line 410
          grecs_error(& context_stack->locus, 0, (char const   *)tmp___2);
          }
#line 411
          return (1);
        }
      }
    }
    {
#line 414
    ctx = ctx_lookup(& st);
    }
#line 414
    if (ctx) {
      {
#line 416
      tmp___3 = gettext("Recursive inclusion");
#line 416
      grecs_error(& context_stack->locus, 0, (char const   *)tmp___3);
      }
#line 417
      if (ctx->prev) {
        {
#line 418
        tmp___4 = gettext("`%s\' already included here");
#line 418
        grecs_error(& (ctx->prev)->locus, 0, (char const   *)tmp___4, name);
        }
      } else {
        {
#line 421
        tmp___5 = gettext("`%s\' already included at top level");
#line 421
        grecs_error(& context_stack->locus, 0, (char const   *)tmp___5, name);
        }
      }
#line 423
      return (1);
    }
  } else
#line 426
  if (rc) {
    {
#line 428
    tmp___6 = gettext("Cannot stat `%s\'");
#line 428
    tmp___7 = __errno_location();
#line 428
    grecs_error((grecs_locus_t *)((void *)0), *tmp___7, (char const   *)tmp___6, name);
    }
#line 429
    return (1);
  }
#line 432
  if (once) {
    {
#line 432
    tmp___8 = source_lookup(& st);
    }
#line 432
    if (tmp___8) {
#line 433
      return (-1);
    }
  }
  {
#line 435
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 436
  if (! fp) {
    {
#line 438
    tmp___9 = gettext("Cannot open `%s\'");
#line 438
    tmp___10 = __errno_location();
#line 438
    grecs_error(& context_stack->locus, *tmp___10, (char const   *)tmp___9, name);
    }
#line 439
    return (1);
  }
  {
#line 443
  tmp___11 = xmalloc((size_t )sizeof(*ctx));
#line 443
  ctx = (struct buffer_ctx *)tmp___11;
#line 444
  ctx->locus.file = grecs_install_text(name);
#line 445
  ctx->locus.line = 1;
#line 446
  ctx->xlines = (size_t )0;
#line 447
  ctx->namelen = strlen((char const   *)ctx->locus.file);
#line 448
  ctx->id.i_node = st.st_ino;
#line 449
  ctx->id.device = st.st_dev;
#line 450
  ctx->infile = fp;
#line 451
  ctx->prev = context_stack;
#line 452
  context_stack = ctx;
  }
#line 454
  if (yy_grecs_flex_debug) {
    {
#line 455
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Processing file `%s\'\n",
            name);
    }
  }
  {
#line 457
  pp_line_stmt();
  }
#line 459
  return (0);
}
}
#line 462 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static int pop_source(void) 
{ 
  struct buffer_ctx *ctx ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 467
  if (! context_stack) {
#line 468
    return (1);
  }
  {
#line 470
  fclose(context_stack->infile);
#line 473
  ctx = context_stack->prev;
#line 474
  free((void *)context_stack);
#line 475
  context_stack = ctx;
  }
#line 477
  if (! context_stack) {
#line 479
    if (yy_grecs_flex_debug) {
      {
#line 480
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"End of input\n");
      }
    }
#line 481
    return (1);
  }
#line 484
  (context_stack->locus.line) ++;
#line 486
  if (yy_grecs_flex_debug) {
    {
#line 487
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Resuming file `%s\' at line %lu\n",
            context_stack->locus.file, (unsigned long )context_stack->locus.line);
    }
  }
  {
#line 490
  pp_line_stmt();
  }
#line 492
  return (0);
}
}
#line 498
static int try_file(char const   *name , int allow_cwd , int err_not_found , char **newp ) ;
#line 498 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static char *cwd  =    (char *)".";
#line 495 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static int try_file(char const   *name , int allow_cwd , int err_not_found , char **newp ) 
{ 
  struct file_data fd ;
  gl_list_node_t node ;
  gl_list_node_t tmp ;
  char *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 501
  fd.name = name;
#line 502
  fd.namelen = strlen(name);
#line 503
  fd.buf = (char *)((void *)0);
#line 504
  fd.buflen = (size_t )0;
#line 505
  fd.found = 0;
  }
#line 507
  if (! include_path) {
    {
#line 508
    grecs_include_path_setup((char const   *)((void *)0));
    }
  }
#line 509
  if (allow_cwd) {
    {
#line 511
    tmp = gl_list_add_last_inline(include_path, (void const   *)cwd);
#line 511
    node = tmp;
#line 512
    pp_list_find(include_path, & fd);
#line 513
    gl_list_remove_node_inline(include_path, node);
    }
  } else {
    {
#line 516
    pp_list_find(include_path, & fd);
    }
  }
#line 518
  if (! fd.found) {
    {
#line 520
    pp_list_find(std_include_path, & fd);
    }
#line 522
    if (! fd.found) {
#line 522
      if (err_not_found) {
        {
#line 524
        tmp___0 = gettext("%s: No such file or directory");
#line 524
        grecs_error(& context_stack->locus, 0, (char const   *)tmp___0, name);
#line 525
        *newp = (char *)((void *)0);
        }
      }
    }
  }
#line 528
  if (fd.found) {
#line 529
    *newp = fd.buf;
  }
#line 530
  return (fd.found);
}
}
#line 533 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
static int parse_include(char const   *text , int once ) 
{ 
  struct wordsplit ws ;
  char *tmp ;
  char *p ;
  int rc ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t len ;
  int allow_cwd ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 537
  tmp = (char *)((void *)0);
#line 538
  p = (char *)((void *)0);
#line 539
  rc = 1;
#line 541
  tmp___3 = wordsplit(text, & ws, 1860);
  }
#line 541
  if (tmp___3) {
    {
#line 542
    tmp___0 = gettext("Cannot parse include line");
#line 542
    grecs_error(& context_stack->locus, 0, (char const   *)tmp___0);
    }
  } else
#line 543
  if (ws.ws_wordc != 2U) {
    {
#line 545
    wordsplit_free(& ws);
#line 546
    tmp___1 = gettext("invalid include statement");
#line 546
    grecs_error(& context_stack->locus, 0, (char const   *)tmp___1);
    }
  } else {
    {
#line 553
    p = *(ws.ws_wordv + 1);
#line 554
    len = strlen((char const   *)p);
    }
#line 556
    if ((int )*(p + 0) == 60) {
#line 556
      if ((int )*(p + (len - 1U)) == 62) {
#line 558
        allow_cwd = 0;
#line 559
        *(p + (len - 1U)) = (char)0;
#line 560
        p ++;
      } else {
#line 563
        allow_cwd = 1;
      }
    } else {
#line 563
      allow_cwd = 1;
    }
#line 565
    if ((int )*(p + 0) != 47) {
      {
#line 565
      tmp___2 = try_file((char const   *)p, allow_cwd, 1, & tmp);
      }
#line 565
      if (tmp___2) {
#line 566
        p = tmp;
      }
    }
  }
#line 569
  if (p) {
    {
#line 570
    rc = push_source((char const   *)p, once);
    }
  }
  {
#line 571
  free((void *)tmp);
#line 572
  wordsplit_free(& ws);
  }
#line 573
  return (rc);
}
}
#line 576 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
int grecs_preproc_init(char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 579
  tmp = push_source(name, 0);
  }
#line 579
  return (tmp);
}
}
#line 582 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
void grecs_preproc_done(void) 
{ 


  {
#line 585
  if (incl_sources) {
    {
#line 586
    hash_free(incl_sources);
    }
  }
  {
#line 587
  free((void *)linebuf);
#line 588
  free((void *)putback_buffer);
  }
#line 589
  return;
}
}
#line 591 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
int grecs_preproc_run(char const   *config_file , char const   *extpp ) 
{ 
  size_t i ;
  char buffer[512] ;
  int tmp ;
  FILE *outfile ;
  char *setup_file ;
  char *cmd ;
  int tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 597
  tmp = grecs_preproc_init(config_file);
  }
#line 597
  if (tmp) {
#line 598
    return (1);
  }
#line 599
  if (extpp) {
    {
#line 605
    tmp___0 = try_file("pp-setup", 1, 0, & setup_file);
    }
#line 605
    if (tmp___0) {
      {
#line 607
      asprintf((char **/* __restrict  */)(& cmd), (char const   */* __restrict  */)"%s %s -",
               extpp, setup_file);
#line 608
      free((void *)setup_file);
      }
    } else {
      {
#line 611
      cmd = xstrdup(extpp);
      }
    }
    {
#line 613
    outfile = popen((char const   *)cmd, "w");
    }
#line 614
    if (! outfile) {
      {
#line 616
      tmp___1 = gettext("Unable to start external preprocessor `%s\'");
#line 616
      tmp___2 = __errno_location();
#line 616
      grecs_error((grecs_locus_t *)((void *)0), *tmp___2, (char const   *)tmp___1,
                  cmd);
#line 618
      free((void *)cmd);
      }
#line 619
      return (1);
    }
    {
#line 622
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 622
      i = grecs_preproc_fill_buffer(buffer, (size_t )sizeof(buffer));
      }
#line 622
      if (! i) {
#line 622
        goto while_break;
      }
      {
#line 623
      fwrite((void const   */* __restrict  */)(buffer), (size_t )1, i, (FILE */* __restrict  */)outfile);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 624
    pclose(outfile);
#line 625
    free((void *)cmd);
    }
  } else {
    {
#line 629
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 629
      i = grecs_preproc_fill_buffer(buffer, (size_t )sizeof(buffer));
      }
#line 629
      if (! i) {
#line 629
        goto while_break___0;
      }
      {
#line 630
      fwrite((void const   */* __restrict  */)(buffer), (size_t )1, i, (FILE */* __restrict  */)stdout);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 632
  grecs_preproc_done();
  }
#line 633
  return (0);
}
}
#line 636 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
FILE *grecs_preproc_extrn_start(char const   *file_name , pid_t *ppid ) 
{ 
  int pout[2] ;
  pid_t pid ;
  int i ;
  FILE *fp ;
  int p[2] ;
  char *buf ;
  size_t size ;
  FILE *fp___0 ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  __ssize_t tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 642
  fp = (FILE *)((void *)0);
#line 646
  pipe((int *)(pout));
#line 647
  pid = fork();
  }
  {
#line 650
  if (pid == 0) {
#line 650
    goto case_0;
  }
#line 709
  if (pid == -1) {
#line 709
    goto case_neg_1___0;
  }
#line 714
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 651
  if (pout[1] != 1) {
    {
#line 653
    close(1);
#line 654
    dup2(pout[1], 1);
    }
  }
  {
#line 658
  i = getdtablesize();
  }
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (i > 2)) {
#line 658
      goto while_break;
    }
    {
#line 659
    close(i);
#line 658
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 661
  if (! grecs_log_to_stderr) {
    {
#line 664
    buf = (char *)((void *)0);
#line 665
    size = (size_t )0;
#line 668
    signal(17, (void (*)(int  ))0);
#line 669
    pipe((int *)(p));
#line 670
    pid = fork();
    }
    {
#line 673
    if (pid == 0) {
#line 673
      goto case_0___0;
    }
#line 685
    if (pid == -1) {
#line 685
      goto case_neg_1;
    }
#line 693
    goto switch_default;
    case_0___0: /* CIL Label */ 
#line 674
    if (p[1] != 2) {
      {
#line 676
      close(2);
#line 677
      dup2(p[1], 2);
      }
    }
    {
#line 679
    close(p[0]);
#line 681
    tmp = grecs_preproc_run(file_name, grecs_preprocessor);
    }
#line 681
    if (tmp) {
      {
#line 682
      exit(127);
      }
    }
    {
#line 683
    exit(0);
    }
    case_neg_1: /* CIL Label */ 
#line 687
    if (grecs_log_setup_hook) {
      {
#line 688
      (*grecs_log_setup_hook)();
      }
    }
    {
#line 689
    tmp___0 = gettext("Cannot run `%s\'");
#line 689
    tmp___1 = __errno_location();
#line 689
    grecs_error((grecs_locus_t *)((void *)0), *tmp___1, (char const   *)tmp___0, grecs_preprocessor);
#line 691
    exit(127);
    }
    switch_default: /* CIL Label */ 
    {
#line 695
    close(p[1]);
#line 696
    fp___0 = fdopen(p[0], "r");
    }
#line 697
    if (grecs_log_setup_hook) {
      {
#line 698
      (*grecs_log_setup_hook)();
      }
    }
    {
#line 699
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 699
      tmp___2 = (__ssize_t )getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& size),
                                    (FILE */* __restrict  */)fp___0);
      }
#line 699
      if (! (tmp___2 > 0)) {
#line 699
        goto while_break___0;
      }
      {
#line 700
      grecs_error((grecs_locus_t *)((void *)0), 0, "%s", buf);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 705
    grecs_preproc_run(file_name, grecs_preprocessor);
    }
  }
  {
#line 707
  exit(0);
  }
  case_neg_1___0: /* CIL Label */ 
  {
#line 711
  tmp___3 = gettext("Cannot run `%s\'");
#line 711
  tmp___4 = __errno_location();
#line 711
  grecs_error((grecs_locus_t *)((void *)0), *tmp___4, (char const   *)tmp___3, grecs_preprocessor);
  }
#line 712
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 715
  close(pout[1]);
#line 716
  fp = fdopen(pout[0], "r");
  }
#line 717
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 719
  *ppid = pid;
#line 720
  return (fp);
}
}
#line 723 "/home/ysko/Works/test-src/pies-1.2/grecs/src/preproc.c"
void grecs_preproc_extrn_shutdown(pid_t pid ) 
{ 
  int status ;

  {
  {
#line 727
  waitpid(pid, & status, 0);
  }
#line 728
  return;
}
}
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 282 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 205 "lex.yy_grecs.c"
int yy_grecsleng  ;
#line 210
FILE *yy_grecsin ;
#line 210
FILE *yy_grecsout ;
#line 317 "lex.yy_grecs.c"
static size_t yy_grecs_buffer_stack_top  =    (size_t )0;
#line 318 "lex.yy_grecs.c"
static size_t yy_grecs_buffer_stack_max  =    (size_t )0;
#line 319 "lex.yy_grecs.c"
static YY_BUFFER_STATE *yy_grecs_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 346 "lex.yy_grecs.c"
static char yy_grecs_hold_char  ;
#line 347 "lex.yy_grecs.c"
static int yy_grecs_n_chars  ;
#line 351 "lex.yy_grecs.c"
static char *yy_grecs_c_buf_p  =    (char *)0;
#line 352 "lex.yy_grecs.c"
static int yy_grecs_init  =    0;
#line 353 "lex.yy_grecs.c"
static int yy_grecs_start  =    0;
#line 358 "lex.yy_grecs.c"
static int yy_grecs_did_buffer_switch_on_eof  ;
#line 363
void yy_grecsrestart(FILE *input_file ) ;
#line 364
void yy_grecs_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 365
YY_BUFFER_STATE yy_grecs_create_buffer(FILE *file , int size ) ;
#line 366
void yy_grecs_delete_buffer(YY_BUFFER_STATE b ) ;
#line 367
void yy_grecs_flush_buffer(YY_BUFFER_STATE b ) ;
#line 368
void yy_grecspush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 369
void yy_grecspop_buffer_state(void) ;
#line 371
static void yy_grecsensure_buffer_stack(void) ;
#line 372
static void yy_grecs_load_buffer_state(void) ;
#line 373
static void yy_grecs_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 377
YY_BUFFER_STATE yy_grecs_scan_buffer(char *base , yy_grecs_size_t size ) ;
#line 378
YY_BUFFER_STATE yy_grecs_scan_string(char const   *yy_grecsstr ) ;
#line 379
YY_BUFFER_STATE yy_grecs_scan_bytes(char const   *yy_grecsbytes , int _yy_grecsbytes_len ) ;
#line 383
void *yy_grecsalloc(yy_grecs_size_t size ) ;
#line 384
void *yy_grecsrealloc(void *ptr , yy_grecs_size_t size ) ;
#line 385
void yy_grecsfree(void *ptr ) ;
#line 418 "lex.yy_grecs.c"
FILE *yy_grecsin  =    (FILE *)0;
#line 418 "lex.yy_grecs.c"
FILE *yy_grecsout  =    (FILE *)0;
#line 422
int yy_grecslineno ;
#line 424 "lex.yy_grecs.c"
int yy_grecslineno  =    1;
#line 426 "lex.yy_grecs.c"
char *yy_grecstext  ;
#line 431
static yy_grecs_state_type yy_grecs_get_previous_state(void) ;
#line 432
static yy_grecs_state_type yy_grecs_try_NUL_trans(yy_grecs_state_type yy_grecs_current_state ) ;
#line 433
static int yy_grecs_get_next_buffer(void) ;
#line 434
static void yy_grecs_fatal_error(char const   *msg ) ;
#line 460 "lex.yy_grecs.c"
static flex_int16_t const   yy_grecs_accept[132]  = 
#line 460
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )2, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )33,      (flex_int16_t const   )31,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )31,      (flex_int16_t const   )9,      (flex_int16_t const   )30, 
        (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )31,      (flex_int16_t const   )13, 
        (flex_int16_t const   )28,      (flex_int16_t const   )9,      (flex_int16_t const   )2,      (flex_int16_t const   )4, 
        (flex_int16_t const   )3,      (flex_int16_t const   )32,      (flex_int16_t const   )27,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )19,      (flex_int16_t const   )32, 
        (flex_int16_t const   )28,      (flex_int16_t const   )0,      (flex_int16_t const   )14,      (flex_int16_t const   )0, 
        (flex_int16_t const   )9,      (flex_int16_t const   )8,      (flex_int16_t const   )13,      (flex_int16_t const   )1, 
        (flex_int16_t const   )11,      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )28, 
        (flex_int16_t const   )0,      (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )9, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )5, 
        (flex_int16_t const   )0,      (flex_int16_t const   )27,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )19,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )17,      (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )11, 
        (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )9, 
        (flex_int16_t const   )0,      (flex_int16_t const   )18,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )22,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )9,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )20,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )9,      (flex_int16_t const   )6,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )25, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )21, 
        (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )9,      (flex_int16_t const   )7,      (flex_int16_t const   )0,      (flex_int16_t const   )26, 
        (flex_int16_t const   )0,      (flex_int16_t const   )23,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )7,      (flex_int16_t const   )0,      (flex_int16_t const   )24,      (flex_int16_t const   )0};
#line 479 "lex.yy_grecs.c"
static flex_int32_t const   yy_grecs_ec[256]  = 
#line 479
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )1, 
        (flex_int32_t const   )8,      (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )11,      (flex_int32_t const   )8, 
        (flex_int32_t const   )15,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )11,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )17,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )16, 
        (flex_int32_t const   )1,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )18,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )19,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )20,      (flex_int32_t const   )16,      (flex_int32_t const   )21,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )8, 
        (flex_int32_t const   )1,      (flex_int32_t const   )8,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 511 "lex.yy_grecs.c"
static flex_int32_t const   yy_grecs_meta[22]  = 
#line 511
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )1, 
        (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8};
#line 518 "lex.yy_grecs.c"
static flex_int16_t const   yy_grecs_base[163]  = 
#line 518
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )21,      (flex_int16_t const   )268,      (flex_int16_t const   )25,      (flex_int16_t const   )28, 
        (flex_int16_t const   )30,      (flex_int16_t const   )264,      (flex_int16_t const   )447,      (flex_int16_t const   )33, 
        (flex_int16_t const   )447,      (flex_int16_t const   )33,      (flex_int16_t const   )259,      (flex_int16_t const   )447, 
        (flex_int16_t const   )0,      (flex_int16_t const   )31,      (flex_int16_t const   )219,      (flex_int16_t const   )37, 
        (flex_int16_t const   )49,      (flex_int16_t const   )55,      (flex_int16_t const   )0,      (flex_int16_t const   )447, 
        (flex_int16_t const   )32,      (flex_int16_t const   )201,      (flex_int16_t const   )447,      (flex_int16_t const   )39, 
        (flex_int16_t const   )46,      (flex_int16_t const   )447,      (flex_int16_t const   )186,      (flex_int16_t const   )0, 
        (flex_int16_t const   )60,      (flex_int16_t const   )49,      (flex_int16_t const   )447,      (flex_int16_t const   )199, 
        (flex_int16_t const   )198,      (flex_int16_t const   )447,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )75,      (flex_int16_t const   )91,      (flex_int16_t const   )59,      (flex_int16_t const   )0, 
        (flex_int16_t const   )107,      (flex_int16_t const   )0,      (flex_int16_t const   )126,      (flex_int16_t const   )95, 
        (flex_int16_t const   )0,      (flex_int16_t const   )90,      (flex_int16_t const   )91,      (flex_int16_t const   )447, 
        (flex_int16_t const   )196,      (flex_int16_t const   )447,      (flex_int16_t const   )101,      (flex_int16_t const   )55, 
        (flex_int16_t const   )447,      (flex_int16_t const   )0,      (flex_int16_t const   )180,      (flex_int16_t const   )190, 
        (flex_int16_t const   )447,      (flex_int16_t const   )447,      (flex_int16_t const   )447,      (flex_int16_t const   )189, 
        (flex_int16_t const   )447,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )142, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )158, 
        (flex_int16_t const   )172,      (flex_int16_t const   )104,      (flex_int16_t const   )0,      (flex_int16_t const   )102, 
        (flex_int16_t const   )103,      (flex_int16_t const   )447,      (flex_int16_t const   )0,      (flex_int16_t const   )185, 
        (flex_int16_t const   )171,      (flex_int16_t const   )120,      (flex_int16_t const   )0,      (flex_int16_t const   )167, 
        (flex_int16_t const   )110,      (flex_int16_t const   )112,      (flex_int16_t const   )116,      (flex_int16_t const   )180, 
        (flex_int16_t const   )182,      (flex_int16_t const   )447,      (flex_int16_t const   )179,      (flex_int16_t const   )169, 
        (flex_int16_t const   )174,      (flex_int16_t const   )161,      (flex_int16_t const   )126,      (flex_int16_t const   )130, 
        (flex_int16_t const   )139,      (flex_int16_t const   )132,      (flex_int16_t const   )193,      (flex_int16_t const   )174, 
        (flex_int16_t const   )447,      (flex_int16_t const   )172,      (flex_int16_t const   )164,      (flex_int16_t const   )147, 
        (flex_int16_t const   )149,      (flex_int16_t const   )152,      (flex_int16_t const   )447,      (flex_int16_t const   )158, 
        (flex_int16_t const   )165,      (flex_int16_t const   )164,      (flex_int16_t const   )0,      (flex_int16_t const   )447, 
        (flex_int16_t const   )154,      (flex_int16_t const   )144,      (flex_int16_t const   )146,      (flex_int16_t const   )447, 
        (flex_int16_t const   )159,      (flex_int16_t const   )447,      (flex_int16_t const   )163,      (flex_int16_t const   )142, 
        (flex_int16_t const   )140,      (flex_int16_t const   )447,      (flex_int16_t const   )135,      (flex_int16_t const   )447, 
        (flex_int16_t const   )108,      (flex_int16_t const   )447,      (flex_int16_t const   )104,      (flex_int16_t const   )71, 
        (flex_int16_t const   )447,      (flex_int16_t const   )70,      (flex_int16_t const   )447,      (flex_int16_t const   )447, 
        (flex_int16_t const   )205,      (flex_int16_t const   )214,      (flex_int16_t const   )223,      (flex_int16_t const   )232, 
        (flex_int16_t const   )241,      (flex_int16_t const   )247,      (flex_int16_t const   )252,      (flex_int16_t const   )260, 
        (flex_int16_t const   )269,      (flex_int16_t const   )278,      (flex_int16_t const   )287,      (flex_int16_t const   )296, 
        (flex_int16_t const   )305,      (flex_int16_t const   )314,      (flex_int16_t const   )321,      (flex_int16_t const   )330, 
        (flex_int16_t const   )59,      (flex_int16_t const   )335,      (flex_int16_t const   )18,      (flex_int16_t const   )339, 
        (flex_int16_t const   )347,      (flex_int16_t const   )356,      (flex_int16_t const   )365,      (flex_int16_t const   )374, 
        (flex_int16_t const   )383,      (flex_int16_t const   )392,      (flex_int16_t const   )401,      (flex_int16_t const   )410, 
        (flex_int16_t const   )419,      (flex_int16_t const   )428,      (flex_int16_t const   )437};
#line 540 "lex.yy_grecs.c"
static flex_int16_t const   yy_grecs_def[163]  = 
#line 540
  {      (flex_int16_t const   )0,      (flex_int16_t const   )131,      (flex_int16_t const   )1,      (flex_int16_t const   )132, 
        (flex_int16_t const   )132,      (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )134, 
        (flex_int16_t const   )134,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )135,      (flex_int16_t const   )136,      (flex_int16_t const   )131, 
        (flex_int16_t const   )137,      (flex_int16_t const   )137,      (flex_int16_t const   )131,      (flex_int16_t const   )138, 
        (flex_int16_t const   )131,      (flex_int16_t const   )136,      (flex_int16_t const   )139,      (flex_int16_t const   )131, 
        (flex_int16_t const   )140,      (flex_int16_t const   )141,      (flex_int16_t const   )131,      (flex_int16_t const   )141, 
        (flex_int16_t const   )142,      (flex_int16_t const   )131,      (flex_int16_t const   )143,      (flex_int16_t const   )144, 
        (flex_int16_t const   )131,      (flex_int16_t const   )135,      (flex_int16_t const   )131,      (flex_int16_t const   )145, 
        (flex_int16_t const   )136,      (flex_int16_t const   )131,      (flex_int16_t const   )137,      (flex_int16_t const   )137, 
        (flex_int16_t const   )131,      (flex_int16_t const   )146,      (flex_int16_t const   )138,      (flex_int16_t const   )20, 
        (flex_int16_t const   )131,      (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )136, 
        (flex_int16_t const   )139,      (flex_int16_t const   )140,      (flex_int16_t const   )140,      (flex_int16_t const   )131, 
        (flex_int16_t const   )141,      (flex_int16_t const   )131,      (flex_int16_t const   )141,      (flex_int16_t const   )142, 
        (flex_int16_t const   )131,      (flex_int16_t const   )144,      (flex_int16_t const   )143,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )147, 
        (flex_int16_t const   )131,      (flex_int16_t const   )40,      (flex_int16_t const   )148,      (flex_int16_t const   )146, 
        (flex_int16_t const   )149,      (flex_int16_t const   )150,      (flex_int16_t const   )44,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )136, 
        (flex_int16_t const   )141,      (flex_int16_t const   )131,      (flex_int16_t const   )151,      (flex_int16_t const   )67, 
        (flex_int16_t const   )149,      (flex_int16_t const   )131,      (flex_int16_t const   )71,      (flex_int16_t const   )131, 
        (flex_int16_t const   )152,      (flex_int16_t const   )136,      (flex_int16_t const   )141,      (flex_int16_t const   )151, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )153,      (flex_int16_t const   )131, 
        (flex_int16_t const   )154,      (flex_int16_t const   )131,      (flex_int16_t const   )152,      (flex_int16_t const   )155, 
        (flex_int16_t const   )136,      (flex_int16_t const   )141,      (flex_int16_t const   )131,      (flex_int16_t const   )153, 
        (flex_int16_t const   )131,      (flex_int16_t const   )156,      (flex_int16_t const   )154,      (flex_int16_t const   )157, 
        (flex_int16_t const   )131,      (flex_int16_t const   )155,      (flex_int16_t const   )131,      (flex_int16_t const   )155, 
        (flex_int16_t const   )158,      (flex_int16_t const   )159,      (flex_int16_t const   )98,      (flex_int16_t const   )131, 
        (flex_int16_t const   )160,      (flex_int16_t const   )131,      (flex_int16_t const   )156,      (flex_int16_t const   )131, 
        (flex_int16_t const   )157,      (flex_int16_t const   )131,      (flex_int16_t const   )157,      (flex_int16_t const   )161, 
        (flex_int16_t const   )158,      (flex_int16_t const   )131,      (flex_int16_t const   )159,      (flex_int16_t const   )131, 
        (flex_int16_t const   )160,      (flex_int16_t const   )131,      (flex_int16_t const   )162,      (flex_int16_t const   )161, 
        (flex_int16_t const   )131,      (flex_int16_t const   )162,      (flex_int16_t const   )131,      (flex_int16_t const   )0, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131};
#line 562 "lex.yy_grecs.c"
static flex_int16_t const   yy_grecs_nxt[469]  = 
#line 562
  {      (flex_int16_t const   )0,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )12, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16, 
        (flex_int16_t const   )17,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )10,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )20,      (flex_int16_t const   )68,      (flex_int16_t const   )21, 
        (flex_int16_t const   )26,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )29, 
        (flex_int16_t const   )27,      (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )32, 
        (flex_int16_t const   )30,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )34, 
        (flex_int16_t const   )39,      (flex_int16_t const   )50,      (flex_int16_t const   )53,      (flex_int16_t const   )40, 
        (flex_int16_t const   )51,      (flex_int16_t const   )31,      (flex_int16_t const   )38,      (flex_int16_t const   )31, 
        (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )35,      (flex_int16_t const   )43, 
        (flex_int16_t const   )56,      (flex_int16_t const   )32,      (flex_int16_t const   )43,      (flex_int16_t const   )34, 
        (flex_int16_t const   )44,      (flex_int16_t const   )45,      (flex_int16_t const   )37,      (flex_int16_t const   )54, 
        (flex_int16_t const   )45,      (flex_int16_t const   )56,      (flex_int16_t const   )32,      (flex_int16_t const   )57, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )35,      (flex_int16_t const   )78, 
        (flex_int16_t const   )38,      (flex_int16_t const   )46,      (flex_int16_t const   )38,      (flex_int16_t const   )38, 
        (flex_int16_t const   )57,      (flex_int16_t const   )130,      (flex_int16_t const   )128,      (flex_int16_t const   )47, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )64,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65, 
        (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )63,      (flex_int16_t const   )65, 
        (flex_int16_t const   )63,      (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65, 
        (flex_int16_t const   )65,      (flex_int16_t const   )66,      (flex_int16_t const   )37,      (flex_int16_t const   )131, 
        (flex_int16_t const   )50,      (flex_int16_t const   )67,      (flex_int16_t const   )131,      (flex_int16_t const   )51, 
        (flex_int16_t const   )53,      (flex_int16_t const   )37,      (flex_int16_t const   )53,      (flex_int16_t const   )130, 
        (flex_int16_t const   )69,      (flex_int16_t const   )70,      (flex_int16_t const   )84,      (flex_int16_t const   )125, 
        (flex_int16_t const   )70,      (flex_int16_t const   )37,      (flex_int16_t const   )75,      (flex_int16_t const   )37, 
        (flex_int16_t const   )95,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )53, 
        (flex_int16_t const   )76,      (flex_int16_t const   )71,      (flex_int16_t const   )81,      (flex_int16_t const   )85, 
        (flex_int16_t const   )86,      (flex_int16_t const   )81,      (flex_int16_t const   )92,      (flex_int16_t const   )72, 
        (flex_int16_t const   )73,      (flex_int16_t const   )37,      (flex_int16_t const   )96,      (flex_int16_t const   )73, 
        (flex_int16_t const   )95,      (flex_int16_t const   )106,      (flex_int16_t const   )97,      (flex_int16_t const   )53, 
        (flex_int16_t const   )107,      (flex_int16_t const   )109,      (flex_int16_t const   )123,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )108,      (flex_int16_t const   )37,      (flex_int16_t const   )121, 
        (flex_int16_t const   )108,      (flex_int16_t const   )128,      (flex_int16_t const   )36,      (flex_int16_t const   )79, 
        (flex_int16_t const   )66,      (flex_int16_t const   )115,      (flex_int16_t const   )117,      (flex_int16_t const   )119, 
        (flex_int16_t const   )131,      (flex_int16_t const   )118,      (flex_int16_t const   )119,      (flex_int16_t const   )106, 
        (flex_int16_t const   )126,      (flex_int16_t const   )125,      (flex_int16_t const   )107,      (flex_int16_t const   )69, 
        (flex_int16_t const   )81,      (flex_int16_t const   )106,      (flex_int16_t const   )117,      (flex_int16_t const   )81, 
        (flex_int16_t const   )107,      (flex_int16_t const   )118,      (flex_int16_t const   )117,      (flex_int16_t const   )123, 
        (flex_int16_t const   )121,      (flex_int16_t const   )118,      (flex_int16_t const   )103,      (flex_int16_t const   )82, 
        (flex_int16_t const   )82,      (flex_int16_t const   )88,      (flex_int16_t const   )89,      (flex_int16_t const   )115, 
        (flex_int16_t const   )88,      (flex_int16_t const   )100,      (flex_int16_t const   )90,      (flex_int16_t const   )104, 
        (flex_int16_t const   )103,      (flex_int16_t const   )101,      (flex_int16_t const   )100,      (flex_int16_t const   )91, 
        (flex_int16_t const   )88,      (flex_int16_t const   )89,      (flex_int16_t const   )98,      (flex_int16_t const   )88, 
        (flex_int16_t const   )93,      (flex_int16_t const   )90,      (flex_int16_t const   )131,      (flex_int16_t const   )83, 
        (flex_int16_t const   )64,      (flex_int16_t const   )77,      (flex_int16_t const   )91,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )59,      (flex_int16_t const   )110,      (flex_int16_t const   )53, 
        (flex_int16_t const   )112,      (flex_int16_t const   )37,      (flex_int16_t const   )62,      (flex_int16_t const   )59, 
        (flex_int16_t const   )53,      (flex_int16_t const   )113,      (flex_int16_t const   )22,      (flex_int16_t const   )22, 
        (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )22, 
        (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )28, 
        (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )28, 
        (flex_int16_t const   )28,      (flex_int16_t const   )33,      (flex_int16_t const   )41,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )38, 
        (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )38, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )48,      (flex_int16_t const   )37,      (flex_int16_t const   )48, 
        (flex_int16_t const   )131,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )49,      (flex_int16_t const   )26, 
        (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )49, 
        (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )52, 
        (flex_int16_t const   )52,      (flex_int16_t const   )52,      (flex_int16_t const   )52,      (flex_int16_t const   )52, 
        (flex_int16_t const   )52,      (flex_int16_t const   )52,      (flex_int16_t const   )52,      (flex_int16_t const   )52, 
        (flex_int16_t const   )55,      (flex_int16_t const   )131,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )58,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )60,      (flex_int16_t const   )131, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )68,      (flex_int16_t const   )131,      (flex_int16_t const   )68,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )80,      (flex_int16_t const   )131,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )87,      (flex_int16_t const   )131,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94, 
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94, 
        (flex_int16_t const   )94,      (flex_int16_t const   )99,      (flex_int16_t const   )99,      (flex_int16_t const   )99, 
        (flex_int16_t const   )99,      (flex_int16_t const   )99,      (flex_int16_t const   )99,      (flex_int16_t const   )99, 
        (flex_int16_t const   )99,      (flex_int16_t const   )99,      (flex_int16_t const   )102,      (flex_int16_t const   )131, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )105, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )105, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )105, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )120,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )122, 
        (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )122, 
        (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )122, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127, 
        (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127, 
        (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )9, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131};
#line 617 "lex.yy_grecs.c"
static flex_int16_t const   yy_grecs_chk[469]  = 
#line 617
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )2,      (flex_int16_t const   )150,      (flex_int16_t const   )2, 
        (flex_int16_t const   )6,      (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )7, 
        (flex_int16_t const   )6,      (flex_int16_t const   )8,      (flex_int16_t const   )7,      (flex_int16_t const   )11, 
        (flex_int16_t const   )8,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )13, 
        (flex_int16_t const   )17,      (flex_int16_t const   )24,      (flex_int16_t const   )27,      (flex_int16_t const   )17, 
        (flex_int16_t const   )24,      (flex_int16_t const   )7,      (flex_int16_t const   )19,      (flex_int16_t const   )8, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )13,      (flex_int16_t const   )20, 
        (flex_int16_t const   )28,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )33, 
        (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )27, 
        (flex_int16_t const   )21,      (flex_int16_t const   )55,      (flex_int16_t const   )32,      (flex_int16_t const   )28, 
        (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )148, 
        (flex_int16_t const   )42,      (flex_int16_t const   )21,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )55,      (flex_int16_t const   )129,      (flex_int16_t const   )127,      (flex_int16_t const   )21, 
        (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )41,      (flex_int16_t const   )47,      (flex_int16_t const   )49, 
        (flex_int16_t const   )50,      (flex_int16_t const   )41,      (flex_int16_t const   )49,      (flex_int16_t const   )50, 
        (flex_int16_t const   )54,      (flex_int16_t const   )75,      (flex_int16_t const   )76,      (flex_int16_t const   )126, 
        (flex_int16_t const   )41,      (flex_int16_t const   )44,      (flex_int16_t const   )73,      (flex_int16_t const   )124, 
        (flex_int16_t const   )44,      (flex_int16_t const   )84,      (flex_int16_t const   )47,      (flex_int16_t const   )85, 
        (flex_int16_t const   )84,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )86, 
        (flex_int16_t const   )54,      (flex_int16_t const   )44,      (flex_int16_t const   )81,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )81,      (flex_int16_t const   )81,      (flex_int16_t const   )44, 
        (flex_int16_t const   )46,      (flex_int16_t const   )94,      (flex_int16_t const   )85,      (flex_int16_t const   )46, 
        (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )86,      (flex_int16_t const   )97, 
        (flex_int16_t const   )95,      (flex_int16_t const   )97,      (flex_int16_t const   )122,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )120, 
        (flex_int16_t const   )96,      (flex_int16_t const   )119,      (flex_int16_t const   )46,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )114,      (flex_int16_t const   )103,      (flex_int16_t const   )104, 
        (flex_int16_t const   )67,      (flex_int16_t const   )103,      (flex_int16_t const   )104,      (flex_int16_t const   )105, 
        (flex_int16_t const   )113,      (flex_int16_t const   )112,      (flex_int16_t const   )105,      (flex_int16_t const   )67, 
        (flex_int16_t const   )71,      (flex_int16_t const   )107,      (flex_int16_t const   )116,      (flex_int16_t const   )71, 
        (flex_int16_t const   )107,      (flex_int16_t const   )116,      (flex_int16_t const   )118,      (flex_int16_t const   )109, 
        (flex_int16_t const   )108,      (flex_int16_t const   )118,      (flex_int16_t const   )102,      (flex_int16_t const   )71, 
        (flex_int16_t const   )71,      (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )101, 
        (flex_int16_t const   )80,      (flex_int16_t const   )99,      (flex_int16_t const   )80,      (flex_int16_t const   )93, 
        (flex_int16_t const   )92,      (flex_int16_t const   )91,      (flex_int16_t const   )90,      (flex_int16_t const   )80, 
        (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )87,      (flex_int16_t const   )88, 
        (flex_int16_t const   )83,      (flex_int16_t const   )88,      (flex_int16_t const   )79,      (flex_int16_t const   )72, 
        (flex_int16_t const   )63,      (flex_int16_t const   )59,      (flex_int16_t const   )88,      (flex_int16_t const   )98, 
        (flex_int16_t const   )98,      (flex_int16_t const   )58,      (flex_int16_t const   )98,      (flex_int16_t const   )52, 
        (flex_int16_t const   )98,      (flex_int16_t const   )36,      (flex_int16_t const   )35,      (flex_int16_t const   )30, 
        (flex_int16_t const   )25,      (flex_int16_t const   )98,      (flex_int16_t const   )132,      (flex_int16_t const   )132, 
        (flex_int16_t const   )132,      (flex_int16_t const   )132,      (flex_int16_t const   )132,      (flex_int16_t const   )132, 
        (flex_int16_t const   )132,      (flex_int16_t const   )132,      (flex_int16_t const   )132,      (flex_int16_t const   )133, 
        (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )133, 
        (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )133, 
        (flex_int16_t const   )134,      (flex_int16_t const   )134,      (flex_int16_t const   )134,      (flex_int16_t const   )134, 
        (flex_int16_t const   )134,      (flex_int16_t const   )134,      (flex_int16_t const   )134,      (flex_int16_t const   )134, 
        (flex_int16_t const   )134,      (flex_int16_t const   )135,      (flex_int16_t const   )18,      (flex_int16_t const   )135, 
        (flex_int16_t const   )135,      (flex_int16_t const   )135,      (flex_int16_t const   )135,      (flex_int16_t const   )135, 
        (flex_int16_t const   )135,      (flex_int16_t const   )135,      (flex_int16_t const   )136,      (flex_int16_t const   )136, 
        (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )136, 
        (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )137, 
        (flex_int16_t const   )137,      (flex_int16_t const   )137,      (flex_int16_t const   )137,      (flex_int16_t const   )137, 
        (flex_int16_t const   )138,      (flex_int16_t const   )138,      (flex_int16_t const   )138,      (flex_int16_t const   )138, 
        (flex_int16_t const   )138,      (flex_int16_t const   )139,      (flex_int16_t const   )14,      (flex_int16_t const   )139, 
        (flex_int16_t const   )9,      (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )139, 
        (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )140,      (flex_int16_t const   )5, 
        (flex_int16_t const   )140,      (flex_int16_t const   )140,      (flex_int16_t const   )140,      (flex_int16_t const   )140, 
        (flex_int16_t const   )140,      (flex_int16_t const   )140,      (flex_int16_t const   )140,      (flex_int16_t const   )141, 
        (flex_int16_t const   )141,      (flex_int16_t const   )141,      (flex_int16_t const   )141,      (flex_int16_t const   )141, 
        (flex_int16_t const   )141,      (flex_int16_t const   )141,      (flex_int16_t const   )141,      (flex_int16_t const   )141, 
        (flex_int16_t const   )142,      (flex_int16_t const   )0,      (flex_int16_t const   )142,      (flex_int16_t const   )142, 
        (flex_int16_t const   )142,      (flex_int16_t const   )142,      (flex_int16_t const   )142,      (flex_int16_t const   )142, 
        (flex_int16_t const   )142,      (flex_int16_t const   )143,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )144,      (flex_int16_t const   )0, 
        (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )144, 
        (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )145, 
        (flex_int16_t const   )145,      (flex_int16_t const   )145,      (flex_int16_t const   )145,      (flex_int16_t const   )145, 
        (flex_int16_t const   )145,      (flex_int16_t const   )145,      (flex_int16_t const   )145,      (flex_int16_t const   )145, 
        (flex_int16_t const   )146,      (flex_int16_t const   )0,      (flex_int16_t const   )146,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )146,      (flex_int16_t const   )146,      (flex_int16_t const   )147, 
        (flex_int16_t const   )147,      (flex_int16_t const   )147,      (flex_int16_t const   )147,      (flex_int16_t const   )147, 
        (flex_int16_t const   )147,      (flex_int16_t const   )147,      (flex_int16_t const   )147,      (flex_int16_t const   )147, 
        (flex_int16_t const   )149,      (flex_int16_t const   )0,      (flex_int16_t const   )149,      (flex_int16_t const   )149, 
        (flex_int16_t const   )151,      (flex_int16_t const   )0,      (flex_int16_t const   )151,      (flex_int16_t const   )151, 
        (flex_int16_t const   )152,      (flex_int16_t const   )152,      (flex_int16_t const   )152,      (flex_int16_t const   )152, 
        (flex_int16_t const   )152,      (flex_int16_t const   )152,      (flex_int16_t const   )152,      (flex_int16_t const   )152, 
        (flex_int16_t const   )152,      (flex_int16_t const   )153,      (flex_int16_t const   )153,      (flex_int16_t const   )153, 
        (flex_int16_t const   )153,      (flex_int16_t const   )153,      (flex_int16_t const   )153,      (flex_int16_t const   )153, 
        (flex_int16_t const   )153,      (flex_int16_t const   )153,      (flex_int16_t const   )154,      (flex_int16_t const   )0, 
        (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )154, 
        (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )155, 
        (flex_int16_t const   )155,      (flex_int16_t const   )155,      (flex_int16_t const   )155,      (flex_int16_t const   )155, 
        (flex_int16_t const   )155,      (flex_int16_t const   )155,      (flex_int16_t const   )155,      (flex_int16_t const   )155, 
        (flex_int16_t const   )156,      (flex_int16_t const   )156,      (flex_int16_t const   )156,      (flex_int16_t const   )156, 
        (flex_int16_t const   )156,      (flex_int16_t const   )156,      (flex_int16_t const   )156,      (flex_int16_t const   )156, 
        (flex_int16_t const   )156,      (flex_int16_t const   )157,      (flex_int16_t const   )157,      (flex_int16_t const   )157, 
        (flex_int16_t const   )157,      (flex_int16_t const   )157,      (flex_int16_t const   )157,      (flex_int16_t const   )157, 
        (flex_int16_t const   )157,      (flex_int16_t const   )157,      (flex_int16_t const   )158,      (flex_int16_t const   )158, 
        (flex_int16_t const   )158,      (flex_int16_t const   )158,      (flex_int16_t const   )158,      (flex_int16_t const   )158, 
        (flex_int16_t const   )158,      (flex_int16_t const   )158,      (flex_int16_t const   )158,      (flex_int16_t const   )159, 
        (flex_int16_t const   )159,      (flex_int16_t const   )159,      (flex_int16_t const   )159,      (flex_int16_t const   )159, 
        (flex_int16_t const   )159,      (flex_int16_t const   )159,      (flex_int16_t const   )159,      (flex_int16_t const   )159, 
        (flex_int16_t const   )160,      (flex_int16_t const   )160,      (flex_int16_t const   )160,      (flex_int16_t const   )160, 
        (flex_int16_t const   )160,      (flex_int16_t const   )160,      (flex_int16_t const   )160,      (flex_int16_t const   )160, 
        (flex_int16_t const   )160,      (flex_int16_t const   )161,      (flex_int16_t const   )161,      (flex_int16_t const   )161, 
        (flex_int16_t const   )161,      (flex_int16_t const   )161,      (flex_int16_t const   )161,      (flex_int16_t const   )161, 
        (flex_int16_t const   )161,      (flex_int16_t const   )161,      (flex_int16_t const   )162,      (flex_int16_t const   )162, 
        (flex_int16_t const   )162,      (flex_int16_t const   )162,      (flex_int16_t const   )162,      (flex_int16_t const   )162, 
        (flex_int16_t const   )162,      (flex_int16_t const   )162,      (flex_int16_t const   )162,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )131};
#line 672 "lex.yy_grecs.c"
static yy_grecs_state_type yy_grecs_last_accepting_state  ;
#line 673 "lex.yy_grecs.c"
static char *yy_grecs_last_accepting_cpos  ;
#line 676 "lex.yy_grecs.c"
int yy_grecs_flex_debug  =    1;
#line 678 "lex.yy_grecs.c"
static flex_int16_t const   yy_grecs_rule_linenum[32]  = 
#line 678
  {      (flex_int16_t const   )0,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )96, 
        (flex_int16_t const   )97,      (flex_int16_t const   )98,      (flex_int16_t const   )100,      (flex_int16_t const   )103, 
        (flex_int16_t const   )106,      (flex_int16_t const   )107,      (flex_int16_t const   )108,      (flex_int16_t const   )109, 
        (flex_int16_t const   )111,      (flex_int16_t const   )113,      (flex_int16_t const   )118,      (flex_int16_t const   )122, 
        (flex_int16_t const   )123,      (flex_int16_t const   )126,      (flex_int16_t const   )127,      (flex_int16_t const   )128, 
        (flex_int16_t const   )134,      (flex_int16_t const   )135,      (flex_int16_t const   )136,      (flex_int16_t const   )137, 
        (flex_int16_t const   )138,      (flex_int16_t const   )139,      (flex_int16_t const   )144,      (flex_int16_t const   )145, 
        (flex_int16_t const   )158,      (flex_int16_t const   )160,      (flex_int16_t const   )161,      (flex_int16_t const   )162};
#line 787 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 105 "./grecs.h"
grecs_value_t *grecs_value_dup(grecs_value_t *input___0 ) ;
#line 109
void ( /* format attribute */  grecs_warning)(grecs_locus_t *locus , int errcode ,
                                              char const   *fmt  , ...) ;
#line 115
void grecs_lex_trace(int n ) ;
#line 117
int grecs_lex_begin(char const   *name ) ;
#line 118
void grecs_lex_end(void) ;
#line 121
void grecs_line_begin(void) ;
#line 122
void grecs_line_add(char const   *text , size_t len ) ;
#line 123
char *grecs_line_finish(void) ;
#line 132 "./grecs.h"
grecs_locus_t grecs_current_locus  ;
#line 74 "grecs-gram.h"
YYSTYPE yy_grecslval ;
#line 182 "../../gnu/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 183
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 45 "grecs-lex.l"
static char *multiline_delimiter  ;
#line 46 "grecs-lex.l"
static size_t multiline_delimiter_len  ;
#line 47 "grecs-lex.l"
static int multiline_unescape  ;
#line 48 "grecs-lex.l"
static int (*char_to_strip)(char  )  ;
#line 59 "grecs-lex.l"
static size_t xlines  ;
#line 60 "grecs-lex.l"
static struct obstack stk  ;
#line 62
static void multiline_begin(char *p ) ;
#line 63
static void multiline_add(char *s ) ;
#line 64
static char *multiline_strip_tabs(char *text ) ;
#line 65
static void line_add_unescape_last(char *text , size_t len ) ;
#line 66
static int ident(void) ;
#line 67
static int isemptystr(int off ) ;
#line 69
static void parse_line(char *text , grecs_locus_t *ploc , size_t *pxlines ) ;
#line 70
static void parse_line_cpp(char *text , grecs_locus_t *ploc , size_t *pxlines ) ;
#line 801 "lex.yy_grecs.c"
static int yy_grecs_init_globals(void) ;
#line 811
int yy_grecslex_destroy(void) ;
#line 813
int yy_grecsget_debug(void) ;
#line 815
void yy_grecsset_debug(int bdebug ) ;
#line 821
FILE *yy_grecsget_in(void) ;
#line 823
void yy_grecsset_in(FILE *in_str ) ;
#line 825
FILE *yy_grecsget_out(void) ;
#line 827
void yy_grecsset_out(FILE *out_str ) ;
#line 829
int yy_grecsget_leng(void) ;
#line 831
char *yy_grecsget_text(void) ;
#line 833
int yy_grecsget_lineno(void) ;
#line 835
void yy_grecsset_lineno(int line_number ) ;
#line 848
int yy_grecswrap(void) ;
#line 984
int yy_grecslex(void) ;
#line 1015 "lex.yy_grecs.c"
int yy_grecslex(void) 
{ 
  register yy_grecs_state_type yy_grecs_current_state ;
  register char *yy_grecs_cp ;
  register char *yy_grecs_bp ;
  register int yy_grecs_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_grecs_c ;
  int tmp___0 ;
  char *p ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  int yy_grecs_amount_of_matched_text ;
  yy_grecs_state_type yy_grecs_next_state ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 1027
  if (! yy_grecs_init) {
#line 1029
    yy_grecs_init = 1;
#line 1035
    if (! yy_grecs_start) {
#line 1036
      yy_grecs_start = 1;
    }
#line 1038
    if (! yy_grecsin) {
#line 1040
      yy_grecsin = stdin;
    }
#line 1045
    if (! yy_grecsout) {
#line 1047
      yy_grecsout = stdout;
    }
#line 1052
    if (yy_grecs_buffer_stack) {
#line 1052
      tmp = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
    } else {
#line 1052
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1052
    if (! tmp) {
      {
#line 1053
      yy_grecsensure_buffer_stack();
#line 1054
      *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top) = yy_grecs_create_buffer(yy_grecsin,
                                                                                    16384);
      }
    }
    {
#line 1058
    yy_grecs_load_buffer_state();
    }
  }
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1064
    yy_grecs_cp = yy_grecs_c_buf_p;
#line 1067
    *yy_grecs_cp = yy_grecs_hold_char;
#line 1072
    yy_grecs_bp = yy_grecs_cp;
#line 1075
    yy_grecs_current_state = yy_grecs_start;
#line 1076
    yy_grecs_current_state += (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol;
    yy_grecs_match: 
    {
#line 1078
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1080
      yy_grecs_c = (YY_CHAR )yy_grecs_ec[(unsigned int )((unsigned char )*yy_grecs_cp)];
#line 1081
      if (yy_grecs_accept[yy_grecs_current_state]) {
#line 1083
        yy_grecs_last_accepting_state = yy_grecs_current_state;
#line 1084
        yy_grecs_last_accepting_cpos = yy_grecs_cp;
      }
      {
#line 1086
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1086
        if (! ((int const   )yy_grecs_chk[(int const   )yy_grecs_base[yy_grecs_current_state] + (int const   )yy_grecs_c] != (int const   )yy_grecs_current_state)) {
#line 1086
          goto while_break___1;
        }
#line 1088
        yy_grecs_current_state = (int )yy_grecs_def[yy_grecs_current_state];
#line 1089
        if (yy_grecs_current_state >= 132) {
#line 1090
          yy_grecs_c = (YY_CHAR )yy_grecs_meta[(unsigned int )yy_grecs_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1092
      yy_grecs_current_state = (yy_grecs_state_type )yy_grecs_nxt[(unsigned int )yy_grecs_base[yy_grecs_current_state] + (unsigned int )yy_grecs_c];
#line 1093
      yy_grecs_cp ++;
#line 1078
      if (! ((int const   )yy_grecs_base[yy_grecs_current_state] != 447)) {
#line 1078
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_grecs_find_action: 
#line 1099
    yy_grecs_act = (int )yy_grecs_accept[yy_grecs_current_state];
#line 1100
    if (yy_grecs_act == 0) {
#line 1102
      yy_grecs_cp = yy_grecs_last_accepting_cpos;
#line 1103
      yy_grecs_current_state = yy_grecs_last_accepting_state;
#line 1104
      yy_grecs_act = (int )yy_grecs_accept[yy_grecs_current_state];
    }
#line 1107
    yy_grecstext = yy_grecs_bp;
#line 1107
    yy_grecsleng = (int )((size_t )(yy_grecs_cp - yy_grecs_bp));
#line 1107
    yy_grecs_hold_char = *yy_grecs_cp;
#line 1107
    *yy_grecs_cp = (char )'\000';
#line 1107
    yy_grecs_c_buf_p = yy_grecs_cp;
    do_action: 
#line 1114
    if (yy_grecs_flex_debug) {
#line 1116
      if (yy_grecs_act == 0) {
        {
#line 1117
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--scanner backing up\n");
        }
      } else
#line 1118
      if (yy_grecs_act < 32) {
        {
#line 1119
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting rule at line %ld (\"%s\")\n",
                (long )yy_grecs_rule_linenum[yy_grecs_act], yy_grecstext);
        }
      } else
#line 1121
      if (yy_grecs_act == 32) {
        {
#line 1122
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting default rule (\"%s\")\n",
                yy_grecstext);
        }
      } else
#line 1124
      if (yy_grecs_act == 33) {
        {
#line 1125
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 1127
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--EOF (start condition %d)\n",
                (yy_grecs_start - 1) / 2);
        }
      }
    }
    {
#line 1133
    if (yy_grecs_act == 0) {
#line 1133
      goto case_0;
    }
#line 1140
    if (yy_grecs_act == 1) {
#line 1140
      goto case_1;
    }
#line 96
    if (yy_grecs_act == 2) {
#line 96 "grecs-lex.l"
      goto case_2;
    }
#line 97
    if (yy_grecs_act == 3) {
#line 97
      goto case_3;
    }
#line 98
    if (yy_grecs_act == 4) {
#line 98
      goto case_4;
    }
#line 99
    if (yy_grecs_act == 5) {
#line 99
      goto case_5;
    }
#line 101
    if (yy_grecs_act == 6) {
#line 101
      goto case_6;
    }
#line 104
    if (yy_grecs_act == 7) {
#line 104
      goto case_7;
    }
#line 107
    if (yy_grecs_act == 8) {
#line 107
      goto case_8;
    }
#line 108
    if (yy_grecs_act == 9) {
#line 108
      goto case_9;
    }
#line 109
    if (yy_grecs_act == 10) {
#line 109
      goto case_10;
    }
#line 110
    if (yy_grecs_act == 11) {
#line 110
      goto case_11;
    }
#line 112
    if (yy_grecs_act == 12) {
#line 112
      goto case_12;
    }
#line 114
    if (yy_grecs_act == 13) {
#line 114
      goto case_13;
    }
#line 119
    if (yy_grecs_act == 14) {
#line 119
      goto case_14;
    }
#line 123
    if (yy_grecs_act == 16) {
#line 123
      goto case_16;
    }
#line 123
    if (yy_grecs_act == 15) {
#line 123
      goto case_16;
    }
#line 127
    if (yy_grecs_act == 18) {
#line 127
      goto case_18;
    }
#line 127
    if (yy_grecs_act == 17) {
#line 127
      goto case_18;
    }
#line 129
    if (yy_grecs_act == 19) {
#line 129
      goto case_19;
    }
#line 139
    if (yy_grecs_act == 25) {
#line 139
      goto case_25;
    }
#line 139
    if (yy_grecs_act == 24) {
#line 139
      goto case_25;
    }
#line 139
    if (yy_grecs_act == 23) {
#line 139
      goto case_25;
    }
#line 139
    if (yy_grecs_act == 22) {
#line 139
      goto case_25;
    }
#line 139
    if (yy_grecs_act == 21) {
#line 139
      goto case_25;
    }
#line 139
    if (yy_grecs_act == 20) {
#line 139
      goto case_25;
    }
#line 145
    if (yy_grecs_act == 26) {
#line 145
      goto case_26;
    }
#line 146
    if (yy_grecs_act == 27) {
#line 146
      goto case_27;
    }
#line 159
    if (yy_grecs_act == 28) {
#line 159
      goto case_28;
    }
#line 161
    if (yy_grecs_act == 29) {
#line 161
      goto case_29;
    }
#line 162
    if (yy_grecs_act == 30) {
#line 162
      goto case_30;
    }
#line 163
    if (yy_grecs_act == 31) {
#line 163
      goto case_31;
    }
#line 168
    if (yy_grecs_act == 32) {
#line 168
      goto case_32;
    }
#line 1341
    if (yy_grecs_act == 37) {
#line 1341 "lex.yy_grecs.c"
      goto case_37;
    }
#line 1341
    if (yy_grecs_act == 36) {
#line 1341
      goto case_37;
    }
#line 1341
    if (yy_grecs_act == 35) {
#line 1341
      goto case_37;
    }
#line 1341
    if (yy_grecs_act == 34) {
#line 1341
      goto case_37;
    }
#line 1344
    if (yy_grecs_act == 33) {
#line 1344
      goto case_33;
    }
#line 1467
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1135
    *yy_grecs_cp = yy_grecs_hold_char;
#line 1136
    yy_grecs_cp = yy_grecs_last_accepting_cpos;
#line 1137
    yy_grecs_current_state = yy_grecs_last_accepting_state;
#line 1138
    goto yy_grecs_find_action;
    case_1: /* CIL Label */ 
#line 1141
    if (yy_grecsleng > 0) {
#line 1141
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 94 "grecs-lex.l"
    yy_grecs_start = 3;
#line 95
    goto switch_break;
    case_2: /* CIL Label */ 
#line 97
    if (yy_grecsleng > 0) {
#line 97
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 96
    goto switch_break;
    case_3: /* CIL Label */ 
#line 98
    if (yy_grecsleng > 0) {
#line 98
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 97
    goto switch_break;
    case_4: /* CIL Label */ 
#line 100
    if (yy_grecsleng > 0) {
#line 100
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 97
    (grecs_current_locus.line) ++;
#line 98
    goto switch_break;
    case_5: /* CIL Label */ 
#line 100
    if (yy_grecsleng > 0) {
#line 100
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 98
    yy_grecs_start = 1;
#line 99
    goto switch_break;
    case_6: /* CIL Label */ 
#line 103
    if (yy_grecsleng > 0) {
#line 103
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 100
    parse_line_cpp(yy_grecstext, & grecs_current_locus, & xlines);
    }
#line 103
    goto switch_break;
    case_7: /* CIL Label */ 
#line 106
    if (yy_grecsleng > 0) {
#line 106
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 103
    parse_line(yy_grecstext, & grecs_current_locus, & xlines);
    }
#line 105
    goto switch_break;
    case_8: /* CIL Label */ 
#line 109
    if (yy_grecsleng > 0) {
#line 109
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 106
    (grecs_current_locus.line) ++;
#line 107
    goto switch_break;
    case_9: /* CIL Label */ 
#line 109
    if (yy_grecsleng > 0) {
#line 109
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 108
    goto switch_break;
    case_10: /* CIL Label */ 
#line 111
    if (yy_grecsleng > 0) {
#line 111
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 108
    (grecs_current_locus.line) ++;
#line 109
    goto switch_break;
    case_11: /* CIL Label */ 
#line 111
    if (yy_grecsleng > 0) {
#line 111
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 110
    goto switch_break;
    case_12: /* CIL Label */ 
#line 113
    if (yy_grecsleng > 0) {
#line 113
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 111
    tmp___0 = ident();
    }
#line 111
    return (tmp___0);
#line 112
    goto switch_break;
    case_13: /* CIL Label */ 
#line 115
    if (yy_grecsleng > 0) {
#line 115
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 113
    grecs_line_begin();
#line 114
    grecs_line_add((char const   *)yy_grecstext, (size_t )yy_grecsleng);
#line 115
    yy_grecslval.string = grecs_line_finish();
    }
#line 116
    return (259);
#line 117
    goto switch_break;
    case_14: /* CIL Label */ 
#line 120
    if (yy_grecsleng > 0) {
#line 120
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 118
    grecs_line_begin();
#line 119
    grecs_line_add((char const   *)(yy_grecstext + 1), (size_t )(yy_grecsleng - 2));
#line 120
    yy_grecslval.string = grecs_line_finish();
    }
#line 121
    return (260);
#line 122
    goto switch_break;
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
#line 125
    if (yy_grecsleng > 0) {
#line 125
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 123
    yy_grecs_start = 7;
#line 124
    grecs_line_begin();
#line 125
    line_add_unescape_last(yy_grecstext + 1, (size_t )(yy_grecsleng - 1));
    }
#line 126
    goto switch_break;
    case_18: /* CIL Label */ 
    case_17: /* CIL Label */ 
#line 129
    if (yy_grecsleng > 0) {
#line 129
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 127
    line_add_unescape_last(yy_grecstext, (size_t )yy_grecsleng);
    }
#line 128
    goto switch_break;
    case_19: /* CIL Label */ 
#line 130
    if (yy_grecsleng > 0) {
#line 130
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 128
    yy_grecs_start = 1;
#line 129
    if (yy_grecsleng > 1) {
      {
#line 130
      grecs_line_add((char const   *)yy_grecstext, (size_t )(yy_grecsleng - 1));
      }
    }
    {
#line 131
    yy_grecslval.string = grecs_line_finish();
    }
#line 132
    return (260);
#line 133
    goto switch_break;
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_20: /* CIL Label */ 
#line 141
    if (yy_grecsleng > 0) {
#line 141
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 140
    yy_grecs_start = 5;
#line 141
    multiline_begin(yy_grecstext + 2);
#line 142
    (grecs_current_locus.line) ++;
    }
#line 143
    goto switch_break;
    case_26: /* CIL Label */ 
#line 147
    if (yy_grecsleng > 0) {
#line 147
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 144
    (grecs_current_locus.line) ++;
#line 145
    goto switch_break;
    case_27: /* CIL Label */ 
#line 148
    if (yy_grecsleng > 0) {
#line 148
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 145
    tmp___1 = multiline_strip_tabs(yy_grecstext);
#line 145
    p = tmp___1;
#line 147
    tmp___2 = strncmp((char const   *)p, (char const   *)multiline_delimiter, multiline_delimiter_len);
    }
#line 147
    if (! tmp___2) {
      {
#line 147
      tmp___3 = isemptystr((int )((p + multiline_delimiter_len) - yy_grecstext));
      }
#line 147
      if (tmp___3) {
        {
#line 150
        free((void *)multiline_delimiter);
#line 151
        multiline_delimiter = (char *)((void *)0);
#line 152
        yy_grecs_start = 1;
#line 153
        yy_grecslval.string = grecs_line_finish();
        }
#line 154
        return (261);
      }
    }
    {
#line 156
    (grecs_current_locus.line) ++;
#line 157
    multiline_add(p);
    }
#line 158
    goto switch_break;
    case_28: /* CIL Label */ 
#line 160
    if (yy_grecsleng > 0) {
#line 160
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 159
    goto switch_break;
    case_29: /* CIL Label */ 
#line 163
    if (yy_grecsleng > 0) {
#line 163
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 160
    (grecs_current_locus.line) ++;
#line 161
    goto switch_break;
    case_30: /* CIL Label */ 
#line 163
    if (yy_grecsleng > 0) {
#line 163
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 161
    return ((int )*(yy_grecstext + 0));
#line 162
    goto switch_break;
    case_31: /* CIL Label */ 
#line 164
    if (yy_grecsleng > 0) {
#line 164
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
#line 162
    if (((int )*(yy_grecstext + 0) & -128) == 0) {
      {
#line 162
      tmp___6 = __ctype_b_loc();
      }
#line 162
      if ((int const   )*(*tmp___6 + (int )*(yy_grecstext + 0)) & 16384) {
        {
#line 163
        tmp___4 = gettext("stray character %c");
#line 163
        grecs_error(& grecs_current_locus, 0, (char const   *)tmp___4, (int )*(yy_grecstext + 0));
        }
      } else {
        {
#line 165
        tmp___5 = gettext("stray character \\%03o");
#line 165
        grecs_error(& grecs_current_locus, 0, (char const   *)tmp___5, (int )((unsigned char )*(yy_grecstext + 0)));
        }
      }
    } else {
      {
#line 165
      tmp___5 = gettext("stray character \\%03o");
#line 165
      grecs_error(& grecs_current_locus, 0, (char const   *)tmp___5, (int )((unsigned char )*(yy_grecstext + 0)));
      }
    }
#line 167
    goto switch_break;
    case_32: /* CIL Label */ 
#line 169
    if (yy_grecsleng > 0) {
#line 169
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol = (int )*(yy_grecstext + (yy_grecsleng - 1)) == 10;
    }
    {
#line 167
    fwrite((void const   */* __restrict  */)yy_grecstext, (size_t )yy_grecsleng, (size_t )1,
           (FILE */* __restrict  */)yy_grecsout);
    }
#line 168
    goto switch_break;
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 1342 "lex.yy_grecs.c"
    return (0);
    case_33: /* CIL Label */ 
#line 1347
    yy_grecs_amount_of_matched_text = (int )(yy_grecs_cp - yy_grecstext) - 1;
#line 1350
    *yy_grecs_cp = yy_grecs_hold_char;
#line 1353
    if ((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buffer_status == 0) {
#line 1364
      yy_grecs_n_chars = (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_n_chars;
#line 1365
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_input_file = yy_grecsin;
#line 1366
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buffer_status = 1;
    }
#line 1376
    if ((unsigned long )yy_grecs_c_buf_p <= (unsigned long )((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf + yy_grecs_n_chars)) {
      {
#line 1380
      yy_grecs_c_buf_p = yy_grecstext + yy_grecs_amount_of_matched_text;
#line 1382
      yy_grecs_current_state = yy_grecs_get_previous_state();
#line 1393
      yy_grecs_next_state = yy_grecs_try_NUL_trans(yy_grecs_current_state);
#line 1395
      yy_grecs_bp = yy_grecstext + 0;
      }
#line 1397
      if (yy_grecs_next_state) {
#line 1400
        yy_grecs_c_buf_p ++;
#line 1400
        yy_grecs_cp = yy_grecs_c_buf_p;
#line 1401
        yy_grecs_current_state = yy_grecs_next_state;
#line 1402
        goto yy_grecs_match;
      } else {
#line 1408
        yy_grecs_cp = yy_grecs_c_buf_p;
#line 1409
        goto yy_grecs_find_action;
      }
    } else {
      {
#line 1413
      tmp___7 = yy_grecs_get_next_buffer();
      }
      {
#line 1415
      if (tmp___7 == 1) {
#line 1415
        goto case_1___0;
      }
#line 1444
      if (tmp___7 == 0) {
#line 1444
        goto case_0___0;
      }
#line 1454
      if (tmp___7 == 2) {
#line 1454
        goto case_2___0;
      }
#line 1413
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1417
      yy_grecs_did_buffer_switch_on_eof = 0;
#line 1419
      tmp___8 = yy_grecswrap();
      }
#line 1419
      if (tmp___8) {
#line 1430
        yy_grecs_c_buf_p = yy_grecstext + 0;
#line 1432
        yy_grecs_act = (33 + (yy_grecs_start - 1) / 2) + 1;
#line 1433
        goto do_action;
      } else
#line 1438
      if (! yy_grecs_did_buffer_switch_on_eof) {
        {
#line 1439
        yy_grecsrestart(yy_grecsin);
        }
      }
#line 1441
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1445
      yy_grecs_c_buf_p = yy_grecstext + yy_grecs_amount_of_matched_text;
#line 1448
      yy_grecs_current_state = yy_grecs_get_previous_state();
#line 1450
      yy_grecs_cp = yy_grecs_c_buf_p;
#line 1451
      yy_grecs_bp = yy_grecstext + 0;
      }
#line 1452
      goto yy_grecs_match;
      case_2___0: /* CIL Label */ 
      {
#line 1455
      yy_grecs_c_buf_p = (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf + yy_grecs_n_chars;
#line 1458
      yy_grecs_current_state = yy_grecs_get_previous_state();
#line 1460
      yy_grecs_cp = yy_grecs_c_buf_p;
#line 1461
      yy_grecs_bp = yy_grecstext + 0;
      }
#line 1462
      goto yy_grecs_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1464
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1468
    yy_grecs_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1490 "lex.yy_grecs.c"
static int yy_grecs_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_grecs_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  yy_grecs_size_t new_size___0 ;
  void *tmp___5 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1495
  dest = (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf;
#line 1496
  source = yy_grecstext;
#line 1500
  if ((unsigned long )yy_grecs_c_buf_p > (unsigned long )((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf + (yy_grecs_n_chars + 1))) {
    {
#line 1501
    yy_grecs_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1504
  if ((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_fill_buffer == 0) {
#line 1506
    if (yy_grecs_c_buf_p - yy_grecstext == 1L) {
#line 1511
      return (1);
    } else {
#line 1519
      return (2);
    }
  }
#line 1526
  number_to_move = (int )(yy_grecs_c_buf_p - yy_grecstext) - 1;
#line 1528
  i = 0;
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if (! (i < number_to_move)) {
#line 1528
      goto while_break;
    }
#line 1529
    tmp = dest;
#line 1529
    dest ++;
#line 1529
    tmp___0 = source;
#line 1529
    source ++;
#line 1529
    *tmp = *tmp___0;
#line 1528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1531
  if ((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buffer_status == 2) {
#line 1535
    yy_grecs_n_chars = 0;
#line 1535
    (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_n_chars = yy_grecs_n_chars;
  } else {
#line 1539
    num_to_read = (int )(((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buf_size - (yy_grecs_size_t )number_to_move) - 1U);
    {
#line 1542
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1542
      if (! (num_to_read <= 0)) {
#line 1542
        goto while_break___0;
      }
#line 1546
      if (yy_grecs_buffer_stack) {
#line 1546
        tmp___1 = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
      } else {
#line 1546
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1546
      b = tmp___1;
#line 1548
      yy_grecs_c_buf_p_offset = (int )(yy_grecs_c_buf_p - b->yy_grecs_ch_buf);
#line 1551
      if (b->yy_grecs_is_our_buffer) {
#line 1553
        new_size = (int )(b->yy_grecs_buf_size * 2U);
#line 1555
        if (new_size <= 0) {
#line 1556
          b->yy_grecs_buf_size += b->yy_grecs_buf_size / 8U;
        } else {
#line 1558
          b->yy_grecs_buf_size *= 2U;
        }
        {
#line 1560
        tmp___2 = yy_grecsrealloc((void *)b->yy_grecs_ch_buf, b->yy_grecs_buf_size + 2U);
#line 1560
        b->yy_grecs_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1566
        b->yy_grecs_ch_buf = (char *)0;
      }
#line 1568
      if (! b->yy_grecs_ch_buf) {
        {
#line 1569
        yy_grecs_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1572
      yy_grecs_c_buf_p = b->yy_grecs_ch_buf + yy_grecs_c_buf_p_offset;
#line 1574
      num_to_read = (int )(((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buf_size - (yy_grecs_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1579
    if (num_to_read > 8192) {
#line 1580
      num_to_read = 8192;
    }
    {
#line 1583
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1583
      if (grecs_preprocessor) {
        {
#line 1583
        tmp___3 = fread((void */* __restrict  */)((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yy_grecsin);
#line 1583
        yy_grecs_n_chars = (int )tmp___3;
        }
      } else {
        {
#line 1583
        tmp___4 = grecs_preproc_fill_buffer((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf + number_to_move,
                                            (size_t )num_to_read);
#line 1583
        yy_grecs_n_chars = (int )tmp___4;
        }
      }
#line 1583
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1586
    (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_n_chars = yy_grecs_n_chars;
  }
#line 1589
  if (yy_grecs_n_chars == 0) {
#line 1591
    if (number_to_move == 0) {
      {
#line 1593
      ret_val = 1;
#line 1594
      yy_grecsrestart(yy_grecsin);
      }
    } else {
#line 1599
      ret_val = 2;
#line 1600
      (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buffer_status = 2;
    }
  } else {
#line 1606
    ret_val = 0;
  }
#line 1608
  if ((yy_grecs_size_t )(yy_grecs_n_chars + number_to_move) > (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buf_size) {
    {
#line 1610
    new_size___0 = (yy_grecs_size_t )((yy_grecs_n_chars + number_to_move) + (yy_grecs_n_chars >> 1));
#line 1611
    tmp___5 = yy_grecsrealloc((void *)(*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf,
                              new_size___0);
#line 1611
    (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf = (char *)tmp___5;
    }
#line 1612
    if (! (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf) {
      {
#line 1613
      yy_grecs_fatal_error("out of dynamic memory in yy_grecs_get_next_buffer()");
      }
    }
  }
#line 1616
  yy_grecs_n_chars += number_to_move;
#line 1617
  *((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf + yy_grecs_n_chars) = (char)0;
#line 1618
  *((*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf + (yy_grecs_n_chars + 1)) = (char)0;
#line 1620
  yy_grecstext = (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_ch_buf + 0;
#line 1622
  return (ret_val);
}
}
#line 1630 "lex.yy_grecs.c"
static yy_grecs_state_type yy_grecs_get_previous_state(void) 
{ 
  register yy_grecs_state_type yy_grecs_current_state ;
  register char *yy_grecs_cp ;
  register YY_CHAR yy_grecs_c ;
  flex_int32_t tmp ;

  {
#line 1639
  yy_grecs_current_state = yy_grecs_start;
#line 1640
  yy_grecs_current_state += (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_at_bol;
#line 1642
  yy_grecs_cp = yy_grecstext + 0;
  {
#line 1642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1642
    if (! ((unsigned long )yy_grecs_cp < (unsigned long )yy_grecs_c_buf_p)) {
#line 1642
      goto while_break;
    }
#line 1645
    if (*yy_grecs_cp) {
#line 1645
      tmp = yy_grecs_ec[(unsigned int )((unsigned char )*yy_grecs_cp)];
    } else {
#line 1645
      tmp = (flex_int32_t const   )1;
    }
#line 1645
    yy_grecs_c = (YY_CHAR )tmp;
#line 1646
    if (yy_grecs_accept[yy_grecs_current_state]) {
#line 1648
      yy_grecs_last_accepting_state = yy_grecs_current_state;
#line 1649
      yy_grecs_last_accepting_cpos = yy_grecs_cp;
    }
    {
#line 1651
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1651
      if (! ((int const   )yy_grecs_chk[(int const   )yy_grecs_base[yy_grecs_current_state] + (int const   )yy_grecs_c] != (int const   )yy_grecs_current_state)) {
#line 1651
        goto while_break___0;
      }
#line 1653
      yy_grecs_current_state = (int )yy_grecs_def[yy_grecs_current_state];
#line 1654
      if (yy_grecs_current_state >= 132) {
#line 1655
        yy_grecs_c = (YY_CHAR )yy_grecs_meta[(unsigned int )yy_grecs_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1657
    yy_grecs_current_state = (yy_grecs_state_type )yy_grecs_nxt[(unsigned int )yy_grecs_base[yy_grecs_current_state] + (unsigned int )yy_grecs_c];
#line 1642
    yy_grecs_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1660
  return (yy_grecs_current_state);
}
}
#line 1669 "lex.yy_grecs.c"
static yy_grecs_state_type yy_grecs_try_NUL_trans(yy_grecs_state_type yy_grecs_current_state ) 
{ 
  register int yy_grecs_is_jam ;
  register char *yy_grecs_cp ;
  register YY_CHAR yy_grecs_c ;
  int tmp ;

  {
#line 1676
  yy_grecs_cp = yy_grecs_c_buf_p;
#line 1678
  yy_grecs_c = (YY_CHAR )1;
#line 1679
  if (yy_grecs_accept[yy_grecs_current_state]) {
#line 1681
    yy_grecs_last_accepting_state = yy_grecs_current_state;
#line 1682
    yy_grecs_last_accepting_cpos = yy_grecs_cp;
  }
  {
#line 1684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1684
    if (! ((int const   )yy_grecs_chk[(int const   )yy_grecs_base[yy_grecs_current_state] + (int const   )yy_grecs_c] != (int const   )yy_grecs_current_state)) {
#line 1684
      goto while_break;
    }
#line 1686
    yy_grecs_current_state = (int )yy_grecs_def[yy_grecs_current_state];
#line 1687
    if (yy_grecs_current_state >= 132) {
#line 1688
      yy_grecs_c = (YY_CHAR )yy_grecs_meta[(unsigned int )yy_grecs_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1690
  yy_grecs_current_state = (yy_grecs_state_type )yy_grecs_nxt[(unsigned int )yy_grecs_base[yy_grecs_current_state] + (unsigned int )yy_grecs_c];
#line 1691
  yy_grecs_is_jam = yy_grecs_current_state == 131;
#line 1693
  if (yy_grecs_is_jam) {
#line 1693
    tmp = 0;
  } else {
#line 1693
    tmp = yy_grecs_current_state;
  }
#line 1693
  return (tmp);
}
}
#line 1832 "lex.yy_grecs.c"
void yy_grecsrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1838
  if (yy_grecs_buffer_stack) {
#line 1838
    tmp = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 1838
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1838
  if (! tmp) {
    {
#line 1839
    yy_grecsensure_buffer_stack();
#line 1840
    *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top) = yy_grecs_create_buffer(yy_grecsin,
                                                                                  16384);
    }
  }
#line 1844
  if (yy_grecs_buffer_stack) {
#line 1844
    tmp___0 = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 1844
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1844
  yy_grecs_init_buffer(tmp___0, input_file);
#line 1845
  yy_grecs_load_buffer_state();
  }
#line 1846
  return;
}
}
#line 1853 "lex.yy_grecs.c"
void yy_grecs_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1864
  yy_grecsensure_buffer_stack();
  }
#line 1865
  if (yy_grecs_buffer_stack) {
#line 1865
    tmp = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 1865
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1865
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1866
    return;
  }
#line 1868
  if (yy_grecs_buffer_stack) {
#line 1868
    tmp___0 = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 1868
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1868
  if (tmp___0) {
#line 1871
    *yy_grecs_c_buf_p = yy_grecs_hold_char;
#line 1872
    (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buf_pos = yy_grecs_c_buf_p;
#line 1873
    (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_n_chars = yy_grecs_n_chars;
  }
  {
#line 1876
  *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top) = new_buffer;
#line 1877
  yy_grecs_load_buffer_state();
#line 1884
  yy_grecs_did_buffer_switch_on_eof = 1;
  }
#line 1885
  return;
}
}
#line 1888 "lex.yy_grecs.c"
static void yy_grecs_load_buffer_state(void) 
{ 


  {
#line 1893
  yy_grecs_n_chars = (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_n_chars;
#line 1894
  yy_grecs_c_buf_p = (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buf_pos;
#line 1894
  yy_grecstext = yy_grecs_c_buf_p;
#line 1895
  yy_grecsin = (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_input_file;
#line 1896
  yy_grecs_hold_char = *yy_grecs_c_buf_p;
#line 1897
  return;
}
}
#line 1906 "lex.yy_grecs.c"
YY_BUFFER_STATE yy_grecs_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1913
  tmp = yy_grecsalloc((yy_grecs_size_t )sizeof(struct yy_grecs_buffer_state ));
#line 1913
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1914
  if (! b) {
    {
#line 1915
    yy_grecs_fatal_error("out of dynamic memory in yy_grecs_create_buffer()");
    }
  }
  {
#line 1917
  b->yy_grecs_buf_size = (yy_grecs_size_t )size;
#line 1922
  tmp___0 = yy_grecsalloc(b->yy_grecs_buf_size + 2U);
#line 1922
  b->yy_grecs_ch_buf = (char *)tmp___0;
  }
#line 1923
  if (! b->yy_grecs_ch_buf) {
    {
#line 1924
    yy_grecs_fatal_error("out of dynamic memory in yy_grecs_create_buffer()");
    }
  }
  {
#line 1926
  b->yy_grecs_is_our_buffer = 1;
#line 1928
  yy_grecs_init_buffer(b, file);
  }
#line 1930
  return (b);
}
}
#line 1938 "lex.yy_grecs.c"
void yy_grecs_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1944
  if (! b) {
#line 1945
    return;
  }
#line 1947
  if (yy_grecs_buffer_stack) {
#line 1947
    tmp = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 1947
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1947
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1948
    *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1950
  if (b->yy_grecs_is_our_buffer) {
    {
#line 1951
    yy_grecsfree((void *)b->yy_grecs_ch_buf);
    }
  }
  {
#line 1953
  yy_grecsfree((void *)b);
  }
#line 1954
  return;
}
}
#line 1972 "lex.yy_grecs.c"
static void yy_grecs_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1978
  tmp = __errno_location();
#line 1978
  oerrno = *tmp;
#line 1980
  yy_grecs_flush_buffer(b);
#line 1982
  b->yy_grecs_input_file = file;
#line 1983
  b->yy_grecs_fill_buffer = 1;
  }
#line 1989
  if (yy_grecs_buffer_stack) {
#line 1989
    tmp___0 = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 1989
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1989
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1990
    b->yy_grecs_bs_lineno = 1;
#line 1991
    b->yy_grecs_bs_column = 0;
  }
#line 1996
  if (file) {
    {
#line 1996
    tmp___1 = fileno(file);
#line 1996
    tmp___2 = isatty(tmp___1);
#line 1996
    b->yy_grecs_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1996
    b->yy_grecs_is_interactive = 0;
  }
  {
#line 2001
  tmp___3 = __errno_location();
#line 2001
  *tmp___3 = oerrno;
  }
#line 2002
  return;
}
}
#line 2009 "lex.yy_grecs.c"
void yy_grecs_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 2014
  if (! b) {
#line 2015
    return;
  }
#line 2017
  b->yy_grecs_n_chars = 0;
#line 2023
  *(b->yy_grecs_ch_buf + 0) = (char)0;
#line 2024
  *(b->yy_grecs_ch_buf + 1) = (char)0;
#line 2026
  b->yy_grecs_buf_pos = b->yy_grecs_ch_buf + 0;
#line 2028
  b->yy_grecs_at_bol = 1;
#line 2029
  b->yy_grecs_buffer_status = 0;
#line 2031
  if (yy_grecs_buffer_stack) {
#line 2031
    tmp = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 2031
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2031
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2032
    yy_grecs_load_buffer_state();
    }
  }
#line 2033
  return;
}
}
#line 2043 "lex.yy_grecs.c"
void yy_grecspush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2048
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2049
    return;
  }
  {
#line 2051
  yy_grecsensure_buffer_stack();
  }
#line 2054
  if (yy_grecs_buffer_stack) {
#line 2054
    tmp = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 2054
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2054
  if (tmp) {
#line 2057
    *yy_grecs_c_buf_p = yy_grecs_hold_char;
#line 2058
    (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_buf_pos = yy_grecs_c_buf_p;
#line 2059
    (*(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top))->yy_grecs_n_chars = yy_grecs_n_chars;
  }
#line 2063
  if (yy_grecs_buffer_stack) {
#line 2063
    tmp___0 = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 2063
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2063
  if (tmp___0) {
#line 2064
    yy_grecs_buffer_stack_top ++;
  }
  {
#line 2065
  *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top) = new_buffer;
#line 2068
  yy_grecs_load_buffer_state();
#line 2069
  yy_grecs_did_buffer_switch_on_eof = 1;
  }
#line 2070
  return;
}
}
#line 2079 "lex.yy_grecs.c"
void yy_grecspop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2084
  if (yy_grecs_buffer_stack) {
#line 2084
    tmp = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 2084
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2084
  if (! tmp) {
#line 2085
    return;
  }
#line 2087
  if (yy_grecs_buffer_stack) {
#line 2087
    tmp___0 = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 2087
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2087
  yy_grecs_delete_buffer(tmp___0);
#line 2088
  *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2089
  if (yy_grecs_buffer_stack_top > 0U) {
#line 2090
    yy_grecs_buffer_stack_top --;
  }
#line 2092
  if (yy_grecs_buffer_stack) {
#line 2092
    tmp___1 = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
  } else {
#line 2092
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2092
  if (tmp___1) {
    {
#line 2093
    yy_grecs_load_buffer_state();
#line 2094
    yy_grecs_did_buffer_switch_on_eof = 1;
    }
  }
#line 2096
  return;
}
}
#line 2104 "lex.yy_grecs.c"
static void yy_grecsensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2111
  if (! yy_grecs_buffer_stack) {
    {
#line 2117
    num_to_alloc = 1;
#line 2118
    tmp = yy_grecsalloc((yy_grecs_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_grecs_buffer_state *)));
#line 2118
    yy_grecs_buffer_stack = (struct yy_grecs_buffer_state **)tmp;
    }
#line 2121
    if (! yy_grecs_buffer_stack) {
      {
#line 2122
      yy_grecs_fatal_error("out of dynamic memory in yy_grecsensure_buffer_stack()");
      }
    }
    {
#line 2124
    memset((void *)yy_grecs_buffer_stack, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_grecs_buffer_state *)));
#line 2126
    yy_grecs_buffer_stack_max = (size_t )num_to_alloc;
#line 2127
    yy_grecs_buffer_stack_top = (size_t )0;
    }
#line 2128
    return;
  }
#line 2131
  if (yy_grecs_buffer_stack_top >= yy_grecs_buffer_stack_max - 1U) {
    {
#line 2134
    grow_size = 8;
#line 2136
    num_to_alloc = (int )(yy_grecs_buffer_stack_max + (size_t )grow_size);
#line 2137
    tmp___0 = yy_grecsrealloc((void *)yy_grecs_buffer_stack, (yy_grecs_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_grecs_buffer_state *)));
#line 2137
    yy_grecs_buffer_stack = (struct yy_grecs_buffer_state **)tmp___0;
    }
#line 2141
    if (! yy_grecs_buffer_stack) {
      {
#line 2142
      yy_grecs_fatal_error("out of dynamic memory in yy_grecsensure_buffer_stack()");
      }
    }
    {
#line 2145
    memset((void *)(yy_grecs_buffer_stack + yy_grecs_buffer_stack_max), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_grecs_buffer_state *)));
#line 2146
    yy_grecs_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2148
  return;
}
}
#line 2158 "lex.yy_grecs.c"
YY_BUFFER_STATE yy_grecs_scan_buffer(char *base , yy_grecs_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 2162
  if (size < 2U) {
#line 2166
    return ((YY_BUFFER_STATE )0);
  } else
#line 2162
  if ((int )*(base + (size - 2U)) != 0) {
#line 2166
    return ((YY_BUFFER_STATE )0);
  } else
#line 2162
  if ((int )*(base + (size - 1U)) != 0) {
#line 2166
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2168
  tmp = yy_grecsalloc((yy_grecs_size_t )sizeof(struct yy_grecs_buffer_state ));
#line 2168
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2169
  if (! b) {
    {
#line 2170
    yy_grecs_fatal_error("out of dynamic memory in yy_grecs_scan_buffer()");
    }
  }
  {
#line 2172
  b->yy_grecs_buf_size = size - 2U;
#line 2173
  tmp___0 = base;
#line 2173
  b->yy_grecs_ch_buf = tmp___0;
#line 2173
  b->yy_grecs_buf_pos = tmp___0;
#line 2174
  b->yy_grecs_is_our_buffer = 0;
#line 2175
  b->yy_grecs_input_file = (FILE *)0;
#line 2176
  b->yy_grecs_n_chars = (int )b->yy_grecs_buf_size;
#line 2177
  b->yy_grecs_is_interactive = 0;
#line 2178
  b->yy_grecs_at_bol = 1;
#line 2179
  b->yy_grecs_fill_buffer = 0;
#line 2180
  b->yy_grecs_buffer_status = 0;
#line 2182
  yy_grecs_switch_to_buffer(b);
  }
#line 2184
  return (b);
}
}
#line 2197 "lex.yy_grecs.c"
YY_BUFFER_STATE yy_grecs_scan_string(char const   *yy_grecsstr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2200
  tmp = strlen(yy_grecsstr);
#line 2200
  tmp___0 = yy_grecs_scan_bytes(yy_grecsstr, (int )tmp);
  }
#line 2200
  return (tmp___0);
}
}
#line 2212 "lex.yy_grecs.c"
YY_BUFFER_STATE yy_grecs_scan_bytes(char const   *yy_grecsbytes , int _yy_grecsbytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_grecs_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2220
  n = (yy_grecs_size_t )(_yy_grecsbytes_len + 2);
#line 2221
  tmp = yy_grecsalloc(n);
#line 2221
  buf = (char *)tmp;
  }
#line 2222
  if (! buf) {
    {
#line 2223
    yy_grecs_fatal_error("out of dynamic memory in yy_grecs_scan_bytes()");
    }
  }
#line 2225
  i = 0;
  {
#line 2225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2225
    if (! (i < _yy_grecsbytes_len)) {
#line 2225
      goto while_break;
    }
#line 2226
    *(buf + i) = (char )*(yy_grecsbytes + i);
#line 2225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2228
  tmp___0 = (char)0;
#line 2228
  *(buf + (_yy_grecsbytes_len + 1)) = tmp___0;
#line 2228
  *(buf + _yy_grecsbytes_len) = tmp___0;
#line 2230
  b = yy_grecs_scan_buffer(buf, n);
  }
#line 2231
  if (! b) {
    {
#line 2232
    yy_grecs_fatal_error("bad buffer in yy_grecs_scan_bytes()");
    }
  }
#line 2237
  b->yy_grecs_is_our_buffer = 1;
#line 2239
  return (b);
}
}
#line 2248 "lex.yy_grecs.c"
static void yy_grecs_fatal_error(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 2250
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2251
  exit(2);
  }
}
}
#line 2283 "lex.yy_grecs.c"
int yy_grecsget_lineno(void) 
{ 


  {
#line 2286
  return (yy_grecslineno);
}
}
#line 2292 "lex.yy_grecs.c"
FILE *yy_grecsget_in(void) 
{ 


  {
#line 2294
  return (yy_grecsin);
}
}
#line 2300 "lex.yy_grecs.c"
FILE *yy_grecsget_out(void) 
{ 


  {
#line 2302
  return (yy_grecsout);
}
}
#line 2308 "lex.yy_grecs.c"
int yy_grecsget_leng(void) 
{ 


  {
#line 2310
  return (yy_grecsleng);
}
}
#line 2317 "lex.yy_grecs.c"
char *yy_grecsget_text(void) 
{ 


  {
#line 2319
  return (yy_grecstext);
}
}
#line 2329 "lex.yy_grecs.c"
void yy_grecsset_lineno(int line_number ) 
{ 


  {
#line 2332
  yy_grecslineno = line_number;
#line 2333
  return;
}
}
#line 2341 "lex.yy_grecs.c"
void yy_grecsset_in(FILE *in_str ) 
{ 


  {
#line 2343
  yy_grecsin = in_str;
#line 2344
  return;
}
}
#line 2346 "lex.yy_grecs.c"
void yy_grecsset_out(FILE *out_str ) 
{ 


  {
#line 2348
  yy_grecsout = out_str;
#line 2349
  return;
}
}
#line 2351 "lex.yy_grecs.c"
int yy_grecsget_debug(void) 
{ 


  {
#line 2353
  return (yy_grecs_flex_debug);
}
}
#line 2356 "lex.yy_grecs.c"
void yy_grecsset_debug(int bdebug ) 
{ 


  {
#line 2358
  yy_grecs_flex_debug = bdebug;
#line 2359
  return;
}
}
#line 2369 "lex.yy_grecs.c"
static int yy_grecs_init_globals(void) 
{ 


  {
#line 2375
  yy_grecs_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2376
  yy_grecs_buffer_stack_top = (size_t )0;
#line 2377
  yy_grecs_buffer_stack_max = (size_t )0;
#line 2378
  yy_grecs_c_buf_p = (char *)0;
#line 2379
  yy_grecs_init = 0;
#line 2380
  yy_grecs_start = 0;
#line 2387
  yy_grecsin = (FILE *)0;
#line 2388
  yy_grecsout = (FILE *)0;
#line 2394
  return (0);
}
}
#line 2400 "lex.yy_grecs.c"
int yy_grecslex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2404
    if (yy_grecs_buffer_stack) {
#line 2404
      tmp___0 = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
    } else {
#line 2404
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2404
    if (! tmp___0) {
#line 2404
      goto while_break;
    }
#line 2405
    if (yy_grecs_buffer_stack) {
#line 2405
      tmp = *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top);
    } else {
#line 2405
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2405
    yy_grecs_delete_buffer(tmp);
#line 2406
    *(yy_grecs_buffer_stack + yy_grecs_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2407
    yy_grecspop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2411
  yy_grecsfree((void *)yy_grecs_buffer_stack);
#line 2412
  yy_grecs_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2416
  yy_grecs_init_globals();
  }
#line 2420
  return (0);
}
}
#line 2448 "lex.yy_grecs.c"
void *yy_grecsalloc(yy_grecs_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2450
  tmp = malloc(size);
  }
#line 2450
  return (tmp);
}
}
#line 2453 "lex.yy_grecs.c"
void *yy_grecsrealloc(void *ptr , yy_grecs_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2462
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2462
  return (tmp);
}
}
#line 2465 "lex.yy_grecs.c"
void yy_grecsfree(void *ptr ) 
{ 


  {
  {
#line 2467
  free((void *)((char *)ptr));
  }
#line 2468
  return;
}
}
#line 170 "grecs-lex.l"
pid_t grecs_preproc_pid  ;
#line 172 "grecs-lex.l"
int yy_grecswrap(void) 
{ 


  {
#line 175
  if (yy_grecsin) {
    {
#line 176
    grecs_preproc_extrn_shutdown(grecs_preproc_pid);
    }
  } else {
    {
#line 178
    grecs_preproc_done();
    }
  }
#line 179
  grecs_current_locus.file = (char *)((void *)0);
#line 180
  return (1);
}
}
#line 183 "grecs-lex.l"
int grecs_lex_begin(char const   *name ) 
{ 
  int fd ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 186
  if (yy_grecs_flex_debug > 0) {
#line 187
    yy_grecs_flex_debug = 0;
  }
  {
#line 188
  _obstack_begin(& stk, 0, 0, (void *(*)(long  ))(& malloc), & free);
  }
#line 189
  if (grecs_preprocessor) {
    {
#line 193
    fd = open(name, 0);
    }
#line 194
    if (fd == -1) {
      {
#line 196
      tmp = gettext("Cannot open `%s\'");
#line 196
      tmp___0 = __errno_location();
#line 196
      grecs_error((grecs_locus_t *)((void *)0), *tmp___0, (char const   *)tmp, name);
      }
#line 197
      return (1);
    }
    {
#line 199
    close(fd);
#line 201
    yy_grecsin = grecs_preproc_extrn_start(name, & grecs_preproc_pid);
    }
#line 202
    if (! yy_grecsin) {
      {
#line 204
      tmp___1 = gettext("Unable to start external preprocessor `%s\'");
#line 204
      tmp___2 = __errno_location();
#line 204
      grecs_error((grecs_locus_t *)((void *)0), *tmp___2, (char const   *)tmp___1,
                  grecs_preprocessor);
      }
#line 207
      return (1);
    }
  } else {
    {
#line 211
    tmp___3 = grecs_preproc_init(name);
    }
#line 211
    return (tmp___3);
  }
#line 213
  return (0);
}
}
#line 216 "grecs-lex.l"
void grecs_lex_end(void) 
{ 


  {
#line 219
  return;
}
}
#line 221 "grecs-lex.l"
static int isemptystr(int off ) 
{ 
  unsigned short const   **tmp ;
  int i ;
  unsigned short const   **tmp___0 ;
  int yy_grecsless_macro_arg ;

  {
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (*(yy_grecstext + off)) {
      {
#line 224
      tmp = __ctype_b_loc();
      }
#line 224
      if (! ((int const   )*(*tmp + (int )*(yy_grecstext + off)) & 8192)) {
#line 224
        goto while_break;
      }
    } else {
#line 224
      goto while_break;
    }
#line 224
    off ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  if ((int )*(yy_grecstext + off) == 59) {
#line 229
    i = off + 1;
    {
#line 229
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 229
      if (! *(yy_grecstext + i)) {
#line 229
        goto while_break___0;
      }
      {
#line 230
      tmp___0 = __ctype_b_loc();
      }
#line 230
      if (! ((int const   )*(*tmp___0 + (int )*(yy_grecstext + i)) & 8192)) {
#line 231
        return (0);
      }
#line 229
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 232
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 232
      yy_grecsless_macro_arg = off;
#line 232
      *(yy_grecstext + yy_grecsleng) = yy_grecs_hold_char;
#line 232
      yy_grecs_c_buf_p = yy_grecstext + yy_grecsless_macro_arg;
#line 232
      yy_grecs_hold_char = *yy_grecs_c_buf_p;
#line 232
      *yy_grecs_c_buf_p = (char )'\000';
#line 232
      yy_grecsleng = yy_grecsless_macro_arg;
#line 232
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 233
    return (1);
  }
#line 235
  return ((int )*(yy_grecstext + off) == 0);
}
}
#line 238 "grecs-lex.l"
static char *multiline_strip_tabs(char *text ) 
{ 
  int tmp ;

  {
#line 241
  if (char_to_strip) {
    {
#line 242
    while (1) {
      while_continue: /* CIL Label */ ;
#line 242
      if (*text) {
        {
#line 242
        tmp = (*char_to_strip)(*text);
        }
#line 242
        if (! tmp) {
#line 242
          goto while_break;
        }
      } else {
#line 242
        goto while_break;
      }
#line 242
      text ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 244
  return (text);
}
}
#line 250
static int unquote_char(int c ) ;
#line 250 "grecs-lex.l"
static char quote_transtab___0[19]  = 
#line 250
  {      (char )'\\',      (char )'\\',      (char )'\"',      (char )'\"', 
        (char )'a',      (char )'\a',      (char )'b',      (char )'\b', 
        (char )'f',      (char )'\f',      (char )'n',      (char )'\n', 
        (char )'r',      (char )'\r',      (char )'t',      (char )'\t', 
        (char )'v',      (char )'\v',      (char )'\000'};
#line 247 "grecs-lex.l"
static int unquote_char(int c ) 
{ 
  char *p ;

  {
#line 254
  p = quote_transtab___0;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! *p) {
#line 254
      goto while_break;
    }
#line 256
    if ((int )*p == c) {
#line 257
      return ((int )*(p + 1));
    }
#line 254
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return (-1);
}
}
#line 262 "grecs-lex.l"
static void unescape_to_obstack(int c ) 
{ 
  int t ;
  int tmp ;
  struct obstack *__o ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 265
  if (c != 10) {
    {
#line 267
    tmp = unquote_char(c);
#line 267
    t = tmp;
    }
#line 268
    if (t != -1) {
#line 269
      __o = & stk;
#line 269
      if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
        {
#line 269
        _obstack_newchunk(__o, 1);
        }
      }
#line 269
      tmp___0 = __o->next_free;
#line 269
      (__o->next_free) ++;
#line 269
      *tmp___0 = (char )t;
    } else {
      {
#line 272
      tmp___1 = gettext("unknown escape sequence \'\\%c\'");
#line 272
      grecs_warning(& grecs_current_locus, 0, (char const   *)tmp___1, c);
#line 275
      __o___0 = & stk;
      }
#line 275
      if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
        {
#line 275
        _obstack_newchunk(__o___0, 1);
        }
      }
#line 275
      tmp___2 = __o___0->next_free;
#line 275
      (__o___0->next_free) ++;
#line 275
      *tmp___2 = (char )c;
    }
  }
#line 278
  return;
}
}
#line 280 "grecs-lex.l"
void grecs_line_add(char const   *text , size_t len ) 
{ 
  struct obstack *__o ;
  int __len ;

  {
#line 283
  __o = & stk;
#line 283
  __len = (int )len;
#line 283
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 283
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 283
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)text,
         (size_t )__len);
#line 283
  __o->next_free += __len;
  }
#line 284
  return;
}
}
#line 287 "grecs-lex.l"
static void line_add_unescape_last(char *text , size_t len ) 
{ 
  struct obstack *__o ;
  int __len ;

  {
#line 290
  __o = & stk;
#line 290
  __len = (int )(len - 2U);
#line 290
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 290
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 290
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)text,
         (size_t )__len);
#line 290
  __o->next_free += __len;
#line 291
  unescape_to_obstack((int )*(text + (len - 1U)));
  }
#line 292
  return;
}
}
#line 294 "grecs-lex.l"
static void multiline_add(char *s ) 
{ 
  struct obstack *__o ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 297
  if (multiline_unescape) {
    {
#line 299
    while (1) {
      while_continue: /* CIL Label */ ;
#line 299
      if (! *s) {
#line 299
        goto while_break;
      }
#line 301
      if ((int )*s == 92) {
        {
#line 303
        unescape_to_obstack((int )*(s + 1));
#line 304
        s ++;
        }
      } else {
#line 307
        __o = & stk;
#line 307
        if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
          {
#line 307
          _obstack_newchunk(__o, 1);
          }
        }
#line 307
        tmp = __o->next_free;
#line 307
        (__o->next_free) ++;
#line 307
        *tmp = *s;
      }
#line 299
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 311
    tmp___0 = strlen((char const   *)s);
#line 311
    grecs_line_add((char const   *)s, tmp___0);
    }
  }
#line 312
  return;
}
}
#line 314 "grecs-lex.l"
void grecs_line_begin(void) 
{ 


  {
#line 318
  return;
}
}
#line 320 "grecs-lex.l"
static int is_tab(char c ) 
{ 


  {
#line 323
  return ((int )c == 9);
}
}
#line 326 "grecs-lex.l"
static int is_ws(char c ) 
{ 
  int tmp ;

  {
#line 329
  if ((int )c == 9) {
#line 329
    tmp = 1;
  } else
#line 329
  if ((int )c == 32) {
#line 329
    tmp = 1;
  } else {
#line 329
    tmp = 0;
  }
#line 329
  return (tmp);
}
}
#line 332 "grecs-lex.l"
static void multiline_begin(char *p ) 
{ 
  char *q ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
#line 335
  if ((int )*p == 45) {
#line 337
    p ++;
#line 337
    if ((int )*p == 32) {
#line 339
      char_to_strip = & is_ws;
#line 340
      p ++;
    } else {
#line 343
      char_to_strip = & is_tab;
    }
  } else {
#line 346
    char_to_strip = (int (*)(char  ))((void *)0);
  }
#line 347
  if ((int )*p == 92) {
#line 349
    p ++;
#line 350
    multiline_unescape = 0;
  } else
#line 352
  if ((int )*p == 34) {
    {
#line 356
    p ++;
#line 357
    multiline_unescape = 0;
#line 358
    q = strchr((char const   *)p, '\"');
#line 359
    multiline_delimiter_len = (size_t )(q - p);
    }
  } else {
    {
#line 363
    multiline_delimiter_len = strcspn((char const   *)p, " \t");
#line 364
    multiline_unescape = 1;
    }
  }
  {
#line 368
  multiline_delimiter_len --;
#line 369
  tmp = xmalloc(multiline_delimiter_len + 1U);
#line 369
  multiline_delimiter = (char *)tmp;
#line 370
  memcpy((void */* __restrict  */)multiline_delimiter, (void const   */* __restrict  */)p,
         multiline_delimiter_len);
#line 371
  *(multiline_delimiter + multiline_delimiter_len) = (char)0;
#line 372
  grecs_line_begin();
  }
#line 373
  return;
}
}
#line 375 "grecs-lex.l"
char *grecs_line_finish(void) 
{ 
  struct obstack *__o ;
  char *tmp ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 378
  __o = & stk;
#line 378
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 378
    _obstack_newchunk(__o, 1);
    }
  }
#line 378
  tmp = __o->next_free;
#line 378
  (__o->next_free) ++;
#line 378
  *tmp = (char)0;
#line 379
  __o1 = & stk;
#line 379
  __value = (void *)__o1->object_base;
#line 379
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 379
    __o1->maybe_empty_object = 1U;
  }
#line 379
  if (sizeof(int ) < sizeof(void *)) {
#line 379
    tmp___0 = __o1->object_base;
  } else {
#line 379
    tmp___0 = (char *)0;
  }
#line 379
  if (sizeof(int ) < sizeof(void *)) {
#line 379
    tmp___1 = __o1->object_base;
  } else {
#line 379
    tmp___1 = (char *)0;
  }
#line 379
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 379
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 379
    __o1->next_free = __o1->chunk_limit;
  }
#line 379
  __o1->object_base = __o1->next_free;
#line 379
  return ((char *)__value);
}
}
#line 382 "grecs-lex.l"
static int ident(void) 
{ 
  char *p ;
  unsigned short const   **tmp ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  struct obstack *__o___0 ;
  char *tmp___1 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 387
  p = yy_grecstext;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (*p) {
      {
#line 387
      tmp = __ctype_b_loc();
      }
#line 387
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 387
        goto while_break;
      }
    } else {
#line 387
      goto while_break;
    }
#line 387
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  __o = & stk;
#line 389
  tmp___0 = strlen((char const   *)p);
#line 389
  __len = (int )tmp___0;
  }
#line 389
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 389
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 389
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)p,
         (size_t )__len);
#line 389
  __o->next_free += __len;
#line 390
  __o___0 = & stk;
  }
#line 390
  if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
    {
#line 390
    _obstack_newchunk(__o___0, 1);
    }
  }
#line 390
  tmp___1 = __o___0->next_free;
#line 390
  (__o___0->next_free) ++;
#line 390
  *tmp___1 = (char)0;
#line 391
  __o1 = & stk;
#line 391
  __value = (void *)__o1->object_base;
#line 391
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 391
    __o1->maybe_empty_object = 1U;
  }
#line 391
  if (sizeof(int ) < sizeof(void *)) {
#line 391
    tmp___2 = __o1->object_base;
  } else {
#line 391
    tmp___2 = (char *)0;
  }
#line 391
  if (sizeof(int ) < sizeof(void *)) {
#line 391
    tmp___3 = __o1->object_base;
  } else {
#line 391
    tmp___3 = (char *)0;
  }
#line 391
  __o1->next_free = tmp___2 + (((__o1->next_free - tmp___3) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 391
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 391
    __o1->next_free = __o1->chunk_limit;
  }
#line 391
  __o1->object_base = __o1->next_free;
#line 391
  yy_grecslval.string = (char *)__value;
#line 392
  return (258);
}
}
#line 395 "grecs-lex.l"
void grecs_lex_trace(int n ) 
{ 


  {
#line 398
  yy_grecs_flex_debug = - n;
#line 399
  return;
}
}
#line 401 "grecs-lex.l"
grecs_value_t *grecs_value_dup(grecs_value_t *input___0 ) 
{ 
  grecs_value_t *ptr ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 404
  __h = & stk;
#line 404
  __o = __h;
#line 404
  __len = (int )sizeof(*ptr);
#line 404
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 404
    _obstack_newchunk(__o, __len);
    }
  }
#line 404
  __o->next_free += __len;
#line 404
  __o1 = __h;
#line 404
  __value = (void *)__o1->object_base;
#line 404
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 404
    __o1->maybe_empty_object = 1U;
  }
#line 404
  if (sizeof(int ) < sizeof(void *)) {
#line 404
    tmp = __o1->object_base;
  } else {
#line 404
    tmp = (char *)0;
  }
#line 404
  if (sizeof(int ) < sizeof(void *)) {
#line 404
    tmp___0 = __o1->object_base;
  } else {
#line 404
    tmp___0 = (char *)0;
  }
#line 404
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 404
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 404
    __o1->next_free = __o1->chunk_limit;
  }
#line 404
  __o1->object_base = __o1->next_free;
#line 404
  ptr = (grecs_value_t *)__value;
#line 405
  *ptr = *input___0;
#line 406
  return (ptr);
}
}
#line 410 "grecs-lex.l"
static int assign_locus(grecs_locus_t *ploc , char *name , char *line , size_t *pxlines ) 
{ 
  char *p ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;

  {
#line 415
  if (name) {
#line 417
    if (pxlines) {
#line 417
      if (! ploc->file) {
#line 418
        *pxlines = (size_t )0;
      } else {
        {
#line 417
        tmp = strcmp((char const   *)name, (char const   *)ploc->file);
        }
#line 417
        if (tmp) {
#line 418
          *pxlines = (size_t )0;
        }
      }
    }
    {
#line 419
    ploc->file = grecs_install_text((char const   *)name);
    }
  }
  {
#line 421
  tmp___0 = strtoul((char const   */* __restrict  */)line, (char **/* __restrict  */)(& p),
                    10);
  }
#line 421
  if (pxlines) {
#line 421
    tmp___1 = *pxlines;
  } else {
#line 421
    tmp___1 = (size_t )0;
  }
#line 421
  ploc->line = (int )(tmp___0 - (unsigned long )tmp___1);
#line 422
  return ((int )*p != 0);
}
}
#line 425 "grecs-lex.l"
static void parse_line(char *text , grecs_locus_t *ploc , size_t *pxlines ) 
{ 
  int rc ;
  struct wordsplit ws ;
  char *tmp ;
  char *p ;
  unsigned long x ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 428
  rc = 1;
#line 431
  tmp___3 = wordsplit((char const   *)text, & ws, 1860);
  }
#line 431
  if (tmp___3) {
    {
#line 432
    tmp = gettext("cannot parse #line line");
#line 432
    grecs_error(ploc, 0, (char const   *)tmp);
    }
  } else {
#line 435
    if (ws.ws_wordc == 2U) {
      {
#line 436
      rc = assign_locus(ploc, (char *)((void *)0), *(ws.ws_wordv + 1), pxlines);
      }
    } else
#line 437
    if (ws.ws_wordc == 3U) {
      {
#line 438
      rc = assign_locus(ploc, *(ws.ws_wordv + 2), *(ws.ws_wordv + 1), pxlines);
      }
    } else
#line 439
    if (ws.ws_wordc == 4U) {
      {
#line 441
      rc = assign_locus(ploc, *(ws.ws_wordv + 2), *(ws.ws_wordv + 1), (size_t *)0);
      }
#line 442
      if (rc == 0) {
        {
#line 445
        tmp___0 = strtoul((char const   */* __restrict  */)*(ws.ws_wordv + 3), (char **/* __restrict  */)(& p),
                          10);
#line 445
        x = tmp___0;
#line 446
        rc = (int )*p != 0;
        }
#line 447
        if (rc == 0) {
#line 448
          *pxlines = (size_t )x;
        }
      }
    } else {
      {
#line 452
      tmp___1 = gettext("invalid #line statement");
#line 452
      grecs_error(ploc, 0, (char const   *)tmp___1);
      }
    }
#line 454
    if (rc) {
      {
#line 455
      tmp___2 = gettext("malformed #line statement");
#line 455
      grecs_error(ploc, 0, (char const   *)tmp___2);
      }
    }
    {
#line 456
    wordsplit_free(& ws);
    }
  }
#line 458
  return;
}
}
#line 460 "grecs-lex.l"
static void parse_line_cpp(char *text , grecs_locus_t *ploc , size_t *pxlines ) 
{ 
  struct wordsplit ws ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 465
  tmp___3 = wordsplit((char const   *)text, & ws, 1860);
  }
#line 465
  if (tmp___3) {
    {
#line 467
    tmp = gettext("cannot parse #line line");
#line 467
    grecs_error(ploc, 0, (char const   *)tmp);
    }
#line 468
    return;
  } else
#line 470
  if (ws.ws_wordc < 3U) {
    {
#line 471
    tmp___0 = gettext("invalid #line statement");
#line 471
    grecs_error(ploc, 0, (char const   *)tmp___0);
    }
  } else {
    {
#line 474
    tmp___2 = assign_locus(ploc, *(ws.ws_wordv + 2), *(ws.ws_wordv + 1), pxlines);
    }
#line 474
    if (tmp___2) {
      {
#line 475
      tmp___1 = gettext("malformed #line statement");
#line 475
      grecs_error(ploc, 0, (char const   *)tmp___1);
      }
    }
  }
  {
#line 477
  wordsplit_free(& ws);
  }
#line 478
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 485 "../../gnu/gl_list.h"
__inline static size_t gl_list_size_inline(gl_list_t list ) 
{ 
  size_t tmp ;

  {
  {
#line 488
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->size))(list);
  }
#line 488
  return (tmp);
}
}
#line 525 "../../gnu/gl_list.h"
__inline static void const   *gl_list_get_at_inline(gl_list_t list , size_t position ) 
{ 
  void const   *tmp ;

  {
  {
#line 528
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->get_at))(list, position);
  }
#line 528
  return (tmp);
}
}
#line 595 "../../gnu/gl_list.h"
__inline static gl_list_node_t gl_list_add_first_inline(gl_list_t list , void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 598
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->add_first))(list,
                                                                             elt);
  }
#line 598
  return (tmp);
}
}
#line 643 "../../gnu/gl_list.h"
__inline static _Bool gl_list_remove_at_inline(gl_list_t list , size_t position ) 
{ 
  _Bool tmp ;

  {
  {
#line 646
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->remove_at))(list,
                                                                             position);
  }
#line 646
  return (tmp);
}
}
#line 659 "../../gnu/gl_list.h"
__inline static void gl_list_free_inline(gl_list_t list ) 
{ 


  {
  {
#line 662
  (*((((struct gl_list_impl_base  const  *)list)->vtable)->list_free))(list);
  }
#line 663
  return;
}
}
#line 107 "./grecs.h"
void grecs_print_diag(grecs_locus_t *locus , int err , int errcode , char const   *msg ) ;
#line 113
void grecs_set_keywords(struct grecs_keyword *kwd ) ;
#line 114
void grecs_gram_trace(int n ) ;
#line 119
int grecs_parse(char const   *name ) ;
#line 125
int grecs_string_convert(void *target , enum grecs_data_type type , char const   *string ,
                         grecs_locus_t *locus ) ;
#line 127
void grecs_process_ident(struct grecs_keyword *kwp , grecs_value_t *value , void *base ,
                         grecs_locus_t *locus ) ;
#line 133 "./grecs.h"
int grecs_error_count  ;
#line 134
int grecs_default_port ;
#line 74 "grecs-gram.h"
YYSTYPE yy_grecslval  ;
#line 370 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 74 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
#line 143 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 289
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 305 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  __nptr ,
                                                        char ** __restrict  __endptr ,
                                                        int __base ) ;
#line 309
extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  __nptr ,
                                                         char ** __restrict  __endptr ,
                                                         int __base ) ;
#line 51 "grecs-gram.y"
static struct grecs_keyword config_keywords  ;
#line 52 "grecs-gram.y"
static struct grecs_keyword *cursect  ;
#line 54 "grecs-gram.y"
static gl_list_t sections  ;
#line 57 "grecs-gram.y"
int grecs_default_port  =    0;
#line 59
static void *target_ptr(struct grecs_keyword *kwp , char *base ) ;
#line 60
static void stmt_begin(struct grecs_keyword *kwp , grecs_value_t tag ) ;
#line 61
static void stmt_end(struct grecs_keyword *kwp ) ;
#line 62
static struct grecs_keyword *find_keyword(char const   *ident___0 ) ;
#line 64
static void process_ident(struct grecs_keyword *kwp , grecs_value_t *value ) ;
#line 65
static gl_list_t simple_list_create(_Bool dispose ) ;
#line 428 "grecs-gram.c"
static yy_grecstype_uint8 const   yy_grecstranslate[262]  = 
#line 428 "grecs-gram.c"
  {      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )10,      (yy_grecstype_uint8 const   )11,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )12,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )7, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )8, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )9,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )4, 
        (yy_grecstype_uint8 const   )5,      (yy_grecstype_uint8 const   )6};
#line 462 "grecs-gram.c"
static yy_grecstype_uint8 const   yy_grecsprhs[32]  = 
#line 462
  {      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )5, 
        (yy_grecstype_uint8 const   )7,      (yy_grecstype_uint8 const   )10,      (yy_grecstype_uint8 const   )12,      (yy_grecstype_uint8 const   )14, 
        (yy_grecstype_uint8 const   )18,      (yy_grecstype_uint8 const   )19,      (yy_grecstype_uint8 const   )27,      (yy_grecstype_uint8 const   )29, 
        (yy_grecstype_uint8 const   )30,      (yy_grecstype_uint8 const   )32,      (yy_grecstype_uint8 const   )34,      (yy_grecstype_uint8 const   )36, 
        (yy_grecstype_uint8 const   )39,      (yy_grecstype_uint8 const   )41,      (yy_grecstype_uint8 const   )43,      (yy_grecstype_uint8 const   )45, 
        (yy_grecstype_uint8 const   )47,      (yy_grecstype_uint8 const   )49,      (yy_grecstype_uint8 const   )51,      (yy_grecstype_uint8 const   )53, 
        (yy_grecstype_uint8 const   )55,      (yy_grecstype_uint8 const   )58,      (yy_grecstype_uint8 const   )61,      (yy_grecstype_uint8 const   )65, 
        (yy_grecstype_uint8 const   )70,      (yy_grecstype_uint8 const   )72,      (yy_grecstype_uint8 const   )76,      (yy_grecstype_uint8 const   )77};
#line 471 "grecs-gram.c"
static yy_grecstype_int8 const   yy_grecsrhs[79]  = 
#line 471
  {      (yy_grecstype_int8 const   )14,      (yy_grecstype_int8 const   )0,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )15, 
        (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )16,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )15, 
        (yy_grecstype_int8 const   )16,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )17,      (yy_grecstype_int8 const   )-1, 
        (yy_grecstype_int8 const   )18,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )20,      (yy_grecstype_int8 const   )22, 
        (yy_grecstype_int8 const   )7,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )20, 
        (yy_grecstype_int8 const   )21,      (yy_grecstype_int8 const   )19,      (yy_grecstype_int8 const   )8,      (yy_grecstype_int8 const   )15, 
        (yy_grecstype_int8 const   )9,      (yy_grecstype_int8 const   )30,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )3, 
        (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )24,      (yy_grecstype_int8 const   )-1, 
        (yy_grecstype_int8 const   )23,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )24,      (yy_grecstype_int8 const   )-1, 
        (yy_grecstype_int8 const   )23,      (yy_grecstype_int8 const   )24,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )25, 
        (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )28,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )6, 
        (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )4,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )3, 
        (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )26,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )27, 
        (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )5,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )27, 
        (yy_grecstype_int8 const   )5,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )10,      (yy_grecstype_int8 const   )11, 
        (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )10,      (yy_grecstype_int8 const   )29,      (yy_grecstype_int8 const   )11, 
        (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )10,      (yy_grecstype_int8 const   )29,      (yy_grecstype_int8 const   )12, 
        (yy_grecstype_int8 const   )11,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )24,      (yy_grecstype_int8 const   )-1, 
        (yy_grecstype_int8 const   )29,      (yy_grecstype_int8 const   )12,      (yy_grecstype_int8 const   )24,      (yy_grecstype_int8 const   )-1, 
        (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )7,      (yy_grecstype_int8 const   )-1};
#line 484 "grecs-gram.c"
static yy_grecstype_uint8 const   yy_grecsrline[32]  = 
#line 484
  {      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )84,      (yy_grecstype_uint8 const   )84,      (yy_grecstype_uint8 const   )87, 
        (yy_grecstype_uint8 const   )88,      (yy_grecstype_uint8 const   )91,      (yy_grecstype_uint8 const   )92,      (yy_grecstype_uint8 const   )95, 
        (yy_grecstype_uint8 const   )101,      (yy_grecstype_uint8 const   )101,      (yy_grecstype_uint8 const   )107,      (yy_grecstype_uint8 const   )116, 
        (yy_grecstype_uint8 const   )120,      (yy_grecstype_uint8 const   )123,      (yy_grecstype_uint8 const   )145,      (yy_grecstype_uint8 const   )150, 
        (yy_grecstype_uint8 const   )156,      (yy_grecstype_uint8 const   )161,      (yy_grecstype_uint8 const   )166,      (yy_grecstype_uint8 const   )173, 
        (yy_grecstype_uint8 const   )174,      (yy_grecstype_uint8 const   )175,      (yy_grecstype_uint8 const   )178,      (yy_grecstype_uint8 const   )192, 
        (yy_grecstype_uint8 const   )197,      (yy_grecstype_uint8 const   )204,      (yy_grecstype_uint8 const   )208,      (yy_grecstype_uint8 const   )212, 
        (yy_grecstype_uint8 const   )218,      (yy_grecstype_uint8 const   )223,      (yy_grecstype_uint8 const   )230,      (yy_grecstype_uint8 const   )231};
#line 496 "grecs-gram.c"
static char const   * const  yy_grecstname[32]  = 
#line 496
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"IDENT", 
        (char const   */* const  */)"STRING",      (char const   */* const  */)"QSTRING",      (char const   */* const  */)"MSTRING",      (char const   */* const  */)"\';\'", 
        (char const   */* const  */)"\'{\'",      (char const   */* const  */)"\'}\'",      (char const   */* const  */)"\'(\'",      (char const   */* const  */)"\')\'", 
        (char const   */* const  */)"\',\'",      (char const   */* const  */)"$accept",      (char const   */* const  */)"input",      (char const   */* const  */)"stmtlist", 
        (char const   */* const  */)"stmt",      (char const   */* const  */)"simple",      (char const   */* const  */)"block",      (char const   */* const  */)"@1", 
        (char const   */* const  */)"ident",      (char const   */* const  */)"tag",      (char const   */* const  */)"vallist",      (char const   */* const  */)"vlist", 
        (char const   */* const  */)"value",      (char const   */* const  */)"string",      (char const   */* const  */)"slist",      (char const   */* const  */)"slist0", 
        (char const   */* const  */)"list",      (char const   */* const  */)"values",      (char const   */* const  */)"opt_sc",      (char const   */* const  */)0};
#line 516 "grecs-gram.c"
static yy_grecstype_uint8 const   yy_grecsr1[32]  = 
#line 516
  {      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )13,      (yy_grecstype_uint8 const   )14,      (yy_grecstype_uint8 const   )15, 
        (yy_grecstype_uint8 const   )15,      (yy_grecstype_uint8 const   )16,      (yy_grecstype_uint8 const   )16,      (yy_grecstype_uint8 const   )17, 
        (yy_grecstype_uint8 const   )19,      (yy_grecstype_uint8 const   )18,      (yy_grecstype_uint8 const   )20,      (yy_grecstype_uint8 const   )21, 
        (yy_grecstype_uint8 const   )21,      (yy_grecstype_uint8 const   )22,      (yy_grecstype_uint8 const   )23,      (yy_grecstype_uint8 const   )23, 
        (yy_grecstype_uint8 const   )24,      (yy_grecstype_uint8 const   )24,      (yy_grecstype_uint8 const   )24,      (yy_grecstype_uint8 const   )25, 
        (yy_grecstype_uint8 const   )25,      (yy_grecstype_uint8 const   )25,      (yy_grecstype_uint8 const   )26,      (yy_grecstype_uint8 const   )27, 
        (yy_grecstype_uint8 const   )27,      (yy_grecstype_uint8 const   )28,      (yy_grecstype_uint8 const   )28,      (yy_grecstype_uint8 const   )28, 
        (yy_grecstype_uint8 const   )29,      (yy_grecstype_uint8 const   )29,      (yy_grecstype_uint8 const   )30,      (yy_grecstype_uint8 const   )30};
#line 525 "grecs-gram.c"
static yy_grecstype_uint8 const   yy_grecsr2[32]  = 
#line 525
  {      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )3, 
        (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )7,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )0, 
        (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1, 
        (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )1, 
        (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )2,      (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )4, 
        (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )1};
#line 536 "grecs-gram.c"
static yy_grecstype_uint8 const   yy_grecsdefact[39]  = 
#line 536
  {      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )10,      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )2, 
        (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )5,      (yy_grecstype_uint8 const   )6,      (yy_grecstype_uint8 const   )11, 
        (yy_grecstype_uint8 const   )1,      (yy_grecstype_uint8 const   )4,      (yy_grecstype_uint8 const   )20,      (yy_grecstype_uint8 const   )19, 
        (yy_grecstype_uint8 const   )23,      (yy_grecstype_uint8 const   )18,      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )8, 
        (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )13,      (yy_grecstype_uint8 const   )14,      (yy_grecstype_uint8 const   )16, 
        (yy_grecstype_uint8 const   )21,      (yy_grecstype_uint8 const   )22,      (yy_grecstype_uint8 const   )17,      (yy_grecstype_uint8 const   )25, 
        (yy_grecstype_uint8 const   )28,      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )7, 
        (yy_grecstype_uint8 const   )15,      (yy_grecstype_uint8 const   )24,      (yy_grecstype_uint8 const   )26,      (yy_grecstype_uint8 const   )0, 
        (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )27,      (yy_grecstype_uint8 const   )29,      (yy_grecstype_uint8 const   )0, 
        (yy_grecstype_uint8 const   )30,      (yy_grecstype_uint8 const   )31,      (yy_grecstype_uint8 const   )9};
#line 545 "grecs-gram.c"
static yy_grecstype_int8 const   yy_grecsdefgoto[18]  = 
#line 545
  {      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )2,      (yy_grecstype_int8 const   )3,      (yy_grecstype_int8 const   )4, 
        (yy_grecstype_int8 const   )5,      (yy_grecstype_int8 const   )6,      (yy_grecstype_int8 const   )26,      (yy_grecstype_int8 const   )7, 
        (yy_grecstype_int8 const   )15,      (yy_grecstype_int8 const   )16,      (yy_grecstype_int8 const   )17,      (yy_grecstype_int8 const   )18, 
        (yy_grecstype_int8 const   )19,      (yy_grecstype_int8 const   )20,      (yy_grecstype_int8 const   )21,      (yy_grecstype_int8 const   )22, 
        (yy_grecstype_int8 const   )25,      (yy_grecstype_int8 const   )38};
#line 554 "grecs-gram.c"
static yy_grecstype_int8 const   yy_grecspact[39]  = 
#line 554
  {      (yy_grecstype_int8 const   )16,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )27,      (yy_grecstype_int8 const   )16, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )20, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )2,      (yy_grecstype_int8 const   )-14, 
        (yy_grecstype_int8 const   )-5,      (yy_grecstype_int8 const   )20,      (yy_grecstype_int8 const   )12,      (yy_grecstype_int8 const   )-14, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )23,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-1,      (yy_grecstype_int8 const   )21,      (yy_grecstype_int8 const   )-14, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )11, 
        (yy_grecstype_int8 const   )16,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )0, 
        (yy_grecstype_int8 const   )24,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14};
#line 563 "grecs-gram.c"
static yy_grecstype_int8 const   yy_grecspgoto[18]  = 
#line 563
  {      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )1,      (yy_grecstype_int8 const   )-3, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-13, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14, 
        (yy_grecstype_int8 const   )-14,      (yy_grecstype_int8 const   )-14};
#line 574 "grecs-gram.c"
static yy_grecstype_int8 const   yy_grecstable[34]  = 
#line 574
  {      (yy_grecstype_int8 const   )9,      (yy_grecstype_int8 const   )24,      (yy_grecstype_int8 const   )27,      (yy_grecstype_int8 const   )1, 
        (yy_grecstype_int8 const   )28,      (yy_grecstype_int8 const   )10,      (yy_grecstype_int8 const   )11,      (yy_grecstype_int8 const   )12, 
        (yy_grecstype_int8 const   )13,      (yy_grecstype_int8 const   )36,      (yy_grecstype_int8 const   )30,      (yy_grecstype_int8 const   )31, 
        (yy_grecstype_int8 const   )14,      (yy_grecstype_int8 const   )23,      (yy_grecstype_int8 const   )10,      (yy_grecstype_int8 const   )11, 
        (yy_grecstype_int8 const   )12,      (yy_grecstype_int8 const   )13,      (yy_grecstype_int8 const   )34,      (yy_grecstype_int8 const   )1, 
        (yy_grecstype_int8 const   )-12,      (yy_grecstype_int8 const   )14,      (yy_grecstype_int8 const   )33,      (yy_grecstype_int8 const   )10, 
        (yy_grecstype_int8 const   )11,      (yy_grecstype_int8 const   )12,      (yy_grecstype_int8 const   )13,      (yy_grecstype_int8 const   )8, 
        (yy_grecstype_int8 const   )29,      (yy_grecstype_int8 const   )32,      (yy_grecstype_int8 const   )14,      (yy_grecstype_int8 const   )37, 
        (yy_grecstype_int8 const   )9,      (yy_grecstype_int8 const   )35};
#line 582 "grecs-gram.c"
static yy_grecstype_uint8 const   yy_grecscheck[34]  = 
#line 582
  {      (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )14,      (yy_grecstype_uint8 const   )7,      (yy_grecstype_uint8 const   )3, 
        (yy_grecstype_uint8 const   )17,      (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )4,      (yy_grecstype_uint8 const   )5, 
        (yy_grecstype_uint8 const   )6,      (yy_grecstype_uint8 const   )9,      (yy_grecstype_uint8 const   )11,      (yy_grecstype_uint8 const   )12, 
        (yy_grecstype_uint8 const   )10,      (yy_grecstype_uint8 const   )11,      (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )4, 
        (yy_grecstype_uint8 const   )5,      (yy_grecstype_uint8 const   )6,      (yy_grecstype_uint8 const   )31,      (yy_grecstype_uint8 const   )3, 
        (yy_grecstype_uint8 const   )8,      (yy_grecstype_uint8 const   )10,      (yy_grecstype_uint8 const   )11,      (yy_grecstype_uint8 const   )3, 
        (yy_grecstype_uint8 const   )4,      (yy_grecstype_uint8 const   )5,      (yy_grecstype_uint8 const   )6,      (yy_grecstype_uint8 const   )0, 
        (yy_grecstype_uint8 const   )5,      (yy_grecstype_uint8 const   )8,      (yy_grecstype_uint8 const   )10,      (yy_grecstype_uint8 const   )7, 
        (yy_grecstype_uint8 const   )35,      (yy_grecstype_uint8 const   )32};
#line 592 "grecs-gram.c"
static yy_grecstype_uint8 const   yy_grecsstos[39]  = 
#line 592
  {      (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )14,      (yy_grecstype_uint8 const   )15, 
        (yy_grecstype_uint8 const   )16,      (yy_grecstype_uint8 const   )17,      (yy_grecstype_uint8 const   )18,      (yy_grecstype_uint8 const   )20, 
        (yy_grecstype_uint8 const   )0,      (yy_grecstype_uint8 const   )16,      (yy_grecstype_uint8 const   )3,      (yy_grecstype_uint8 const   )4, 
        (yy_grecstype_uint8 const   )5,      (yy_grecstype_uint8 const   )6,      (yy_grecstype_uint8 const   )10,      (yy_grecstype_uint8 const   )21, 
        (yy_grecstype_uint8 const   )22,      (yy_grecstype_uint8 const   )23,      (yy_grecstype_uint8 const   )24,      (yy_grecstype_uint8 const   )25, 
        (yy_grecstype_uint8 const   )26,      (yy_grecstype_uint8 const   )27,      (yy_grecstype_uint8 const   )28,      (yy_grecstype_uint8 const   )11, 
        (yy_grecstype_uint8 const   )24,      (yy_grecstype_uint8 const   )29,      (yy_grecstype_uint8 const   )19,      (yy_grecstype_uint8 const   )7, 
        (yy_grecstype_uint8 const   )24,      (yy_grecstype_uint8 const   )5,      (yy_grecstype_uint8 const   )11,      (yy_grecstype_uint8 const   )12, 
        (yy_grecstype_uint8 const   )8,      (yy_grecstype_uint8 const   )11,      (yy_grecstype_uint8 const   )24,      (yy_grecstype_uint8 const   )15, 
        (yy_grecstype_uint8 const   )9,      (yy_grecstype_uint8 const   )7,      (yy_grecstype_uint8 const   )30};
#line 723 "grecs-gram.c"
static void yy_grecs_symbol_value_print(FILE *yy_grecsoutput , int yy_grecstype ,
                                        YYSTYPE const   * const  yy_grecsvaluep ) 
{ 


  {
#line 733
  if (! yy_grecsvaluep) {
#line 734
    return;
  }
  {
#line 743
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 744
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 746
  return;
}
}
#line 755 "grecs-gram.c"
static void yy_grecs_symbol_print(FILE *yy_grecsoutput , int yy_grecstype , YYSTYPE const   * const  yy_grecsvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 765
  if (yy_grecstype < 13) {
    {
#line 766
    fprintf((FILE */* __restrict  */)yy_grecsoutput, (char const   */* __restrict  */)"token %s (",
            yy_grecstname[yy_grecstype]);
    }
  } else {
    {
#line 768
    fprintf((FILE */* __restrict  */)yy_grecsoutput, (char const   */* __restrict  */)"nterm %s (",
            yy_grecstname[yy_grecstype]);
    }
  }
  {
#line 770
  yy_grecs_symbol_value_print(yy_grecsoutput, yy_grecstype, yy_grecsvaluep);
#line 771
  fprintf((FILE */* __restrict  */)yy_grecsoutput, (char const   */* __restrict  */)")");
  }
#line 772
  return;
}
}
#line 781 "grecs-gram.c"
static void yy_grecs_stack_print(yy_grecstype_int16 *bottom , yy_grecstype_int16 *top ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 790
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 791
    if (! ((unsigned long )bottom <= (unsigned long )top)) {
#line 791
      goto while_break;
    }
    {
#line 792
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            (int )*bottom);
#line 791
    bottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 793
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 794
  return;
}
}
#line 809 "grecs-gram.c"
static void yy_grecs_reduce_print(YYSTYPE *yy_grecsvsp , int yy_grecsrule ) 
{ 
  int yy_grecsnrhs ;
  int yy_grecsi ;
  unsigned long yy_grecslno ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 818
  yy_grecsnrhs = (int )yy_grecsr2[yy_grecsrule];
#line 820
  yy_grecslno = (unsigned long )yy_grecsrline[yy_grecsrule];
#line 821
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          yy_grecsrule - 1, yy_grecslno);
#line 824
  yy_grecsi = 0;
  }
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! (yy_grecsi < yy_grecsnrhs)) {
#line 824
      goto while_break;
    }
    {
#line 826
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yy_grecsi + 1);
#line 827
    yy_grecs_symbol_print(stderr, (int )yy_grecsrhs[(int const   )yy_grecsprhs[yy_grecsrule] + (int const   )yy_grecsi],
                          (YYSTYPE const   */* const  */)(yy_grecsvsp + ((yy_grecsi + 1) - yy_grecsnrhs)));
#line 830
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 824
    yy_grecsi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 832
  return;
}
}
#line 842 "grecs-gram.c"
int yy_grecsdebug  ;
#line 1087 "grecs-gram.c"
static void yy_grecsdestruct(char const   *yy_grecsmsg , int yy_grecstype , YYSTYPE *yy_grecsvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1099
  if (! yy_grecsmsg) {
#line 1100
    yy_grecsmsg = "Deleting";
  }
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1101
    if (yy_grecsdebug) {
      {
#line 1101
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yy_grecsmsg);
#line 1101
      yy_grecs_symbol_print(stderr, yy_grecstype, (YYSTYPE const   */* const  */)yy_grecsvaluep);
#line 1101
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1101
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1106
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1107
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1109
  return;
}
}
#line 1122
int yy_grecsparse(void) ;
#line 1131 "grecs-gram.c"
int yy_grecschar  ;
#line 1137 "grecs-gram.c"
int yy_grecsnerrs  ;
#line 1615
int yy_grecserror(char *s ) ;
#line 1158 "grecs-gram.c"
int yy_grecsparse(void) 
{ 
  int yy_grecsstate ;
  int yy_grecsn ;
  int yy_grecsresult ;
  int yy_grecserrstatus ;
  int yy_grecstoken ;
  yy_grecstype_int16 yy_grecsssa[200] ;
  yy_grecstype_int16 *yy_grecsss ;
  yy_grecstype_int16 *yy_grecsssp ;
  YYSTYPE yy_grecsvsa[200] ;
  YYSTYPE *yy_grecsvs ;
  YYSTYPE *yy_grecsvsp ;
  unsigned int yy_grecsstacksize ;
  YYSTYPE yy_grecsval ;
  int yy_grecslen ;
  unsigned int yy_grecssize ;
  yy_grecstype_int16 *yy_grecsss1 ;
  union yy_grecsalloc *yy_grecsptr ;
  void *tmp ;
  unsigned int yy_grecsnewbytes ;
  unsigned int yy_grecsnewbytes___0 ;
  char *tmp___0 ;
  size_t n ;
  void const   *tmp___1 ;
  size_t i ;
  void *tmp___2 ;
  void const   *tmp___3 ;
  grecs_value_t *tmp___4 ;
  grecs_value_t *tmp___5 ;
  void const   *p ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  grecs_value_t *tmp___9 ;
  grecs_value_t *tmp___10 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
#line 1174
  yy_grecstoken = 0;
#line 1192
  yy_grecsss = yy_grecsssa;
#line 1197
  yy_grecsvs = yy_grecsvsa;
#line 1204
  yy_grecsstacksize = 200U;
#line 1213
  yy_grecslen = 0;
  {
#line 1215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1215
    if (yy_grecsdebug) {
      {
#line 1215
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1215
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1217
  yy_grecsstate = 0;
#line 1218
  yy_grecserrstatus = 0;
#line 1219
  yy_grecsnerrs = 0;
#line 1220
  yy_grecschar = -2;
#line 1227
  yy_grecsssp = yy_grecsss;
#line 1228
  yy_grecsvsp = yy_grecsvs;
#line 1230
  goto yy_grecssetstate;
  yy_grecsnewstate: 
#line 1238
  yy_grecsssp ++;
  yy_grecssetstate: 
#line 1241
  *yy_grecsssp = (yy_grecstype_int16 )yy_grecsstate;
#line 1243
  if ((unsigned long )((yy_grecsss + yy_grecsstacksize) - 1) <= (unsigned long )yy_grecsssp) {
#line 1246
    yy_grecssize = (unsigned int )((yy_grecsssp - yy_grecsss) + 1L);
#line 1275
    if (10000U <= yy_grecsstacksize) {
#line 1276
      goto yy_grecsexhaustedlab;
    }
#line 1277
    yy_grecsstacksize *= 2U;
#line 1278
    if (10000U < yy_grecsstacksize) {
#line 1279
      yy_grecsstacksize = 10000U;
    }
    {
#line 1282
    yy_grecsss1 = yy_grecsss;
#line 1283
    tmp = malloc((size_t )((unsigned long )yy_grecsstacksize * (sizeof(yy_grecstype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yy_grecsalloc ) - 1UL)));
#line 1283
    yy_grecsptr = (union yy_grecsalloc *)tmp;
    }
#line 1285
    if (! yy_grecsptr) {
#line 1286
      goto yy_grecsexhaustedlab;
    }
    {
#line 1287
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1287
      __builtin_memcpy((void *)(& yy_grecsptr->yy_grecsss), (void const   *)yy_grecsss,
                       (unsigned long )yy_grecssize * sizeof(*yy_grecsss));
#line 1287
      yy_grecsss = & yy_grecsptr->yy_grecsss;
#line 1287
      yy_grecsnewbytes = (unsigned int )((unsigned long )yy_grecsstacksize * sizeof(*yy_grecsss) + (sizeof(union yy_grecsalloc ) - 1UL));
#line 1287
      yy_grecsptr += (unsigned long )yy_grecsnewbytes / sizeof(*yy_grecsptr);
      }
#line 1287
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1288
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1288
      __builtin_memcpy((void *)(& yy_grecsptr->yy_grecsvs), (void const   *)yy_grecsvs,
                       (unsigned long )yy_grecssize * sizeof(*yy_grecsvs));
#line 1288
      yy_grecsvs = & yy_grecsptr->yy_grecsvs;
#line 1288
      yy_grecsnewbytes___0 = (unsigned int )((unsigned long )yy_grecsstacksize * sizeof(*yy_grecsvs) + (sizeof(union yy_grecsalloc ) - 1UL));
#line 1288
      yy_grecsptr += (unsigned long )yy_grecsnewbytes___0 / sizeof(*yy_grecsptr);
      }
#line 1288
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1291
    if ((unsigned long )yy_grecsss1 != (unsigned long )(yy_grecsssa)) {
      {
#line 1292
      free((void *)yy_grecsss1);
      }
    }
#line 1297
    yy_grecsssp = (yy_grecsss + yy_grecssize) - 1;
#line 1298
    yy_grecsvsp = (yy_grecsvs + yy_grecssize) - 1;
    {
#line 1301
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1301
      if (yy_grecsdebug) {
        {
#line 1301
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                (unsigned long )yy_grecsstacksize);
        }
      }
#line 1301
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1304
    if ((unsigned long )((yy_grecsss + yy_grecsstacksize) - 1) <= (unsigned long )yy_grecsssp) {
#line 1305
      goto yy_grecsabortlab;
    }
  }
  {
#line 1308
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1308
    if (yy_grecsdebug) {
      {
#line 1308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              yy_grecsstate);
      }
    }
#line 1308
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1310
  goto yy_grecsbackup;
  yy_grecsbackup: 
#line 1321
  yy_grecsn = (int )yy_grecspact[yy_grecsstate];
#line 1322
  if (yy_grecsn == -14) {
#line 1323
    goto yy_grecsdefault;
  }
#line 1328
  if (yy_grecschar == -2) {
    {
#line 1330
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1330
      if (yy_grecsdebug) {
        {
#line 1330
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1330
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1331
    yy_grecschar = yy_grecslex();
    }
  }
#line 1334
  if (yy_grecschar <= 0) {
#line 1336
    yy_grecstoken = 0;
#line 1336
    yy_grecschar = yy_grecstoken;
    {
#line 1337
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1337
      if (yy_grecsdebug) {
        {
#line 1337
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1337
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1341
    if ((unsigned int )yy_grecschar <= 261U) {
#line 1341
      yy_grecstoken = (int )yy_grecstranslate[yy_grecschar];
    } else {
#line 1341
      yy_grecstoken = 2;
    }
    {
#line 1342
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1342
      if (yy_grecsdebug) {
        {
#line 1342
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1342
        yy_grecs_symbol_print(stderr, yy_grecstoken, (YYSTYPE const   */* const  */)(& yy_grecslval));
#line 1342
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1342
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1347
  yy_grecsn += yy_grecstoken;
#line 1348
  if (yy_grecsn < 0) {
#line 1349
    goto yy_grecsdefault;
  } else
#line 1348
  if (33 < yy_grecsn) {
#line 1349
    goto yy_grecsdefault;
  } else
#line 1348
  if ((int const   )yy_grecscheck[yy_grecsn] != (int const   )yy_grecstoken) {
#line 1349
    goto yy_grecsdefault;
  }
#line 1350
  yy_grecsn = (int )yy_grecstable[yy_grecsn];
#line 1351
  if (yy_grecsn <= 0) {
#line 1353
    if (yy_grecsn == 0) {
#line 1354
      goto yy_grecserrlab;
    } else
#line 1353
    if (yy_grecsn == -13) {
#line 1354
      goto yy_grecserrlab;
    }
#line 1355
    yy_grecsn = - yy_grecsn;
#line 1356
    goto yy_grecsreduce;
  }
#line 1359
  if (yy_grecsn == 8) {
#line 1360
    goto yy_grecsacceptlab;
  }
#line 1364
  if (yy_grecserrstatus) {
#line 1365
    yy_grecserrstatus --;
  }
  {
#line 1368
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1368
    if (yy_grecsdebug) {
      {
#line 1368
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1368
      yy_grecs_symbol_print(stderr, yy_grecstoken, (YYSTYPE const   */* const  */)(& yy_grecslval));
#line 1368
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1368
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1371
  if (yy_grecschar != 0) {
#line 1372
    yy_grecschar = -2;
  }
#line 1374
  yy_grecsstate = yy_grecsn;
#line 1375
  yy_grecsvsp ++;
#line 1375
  *yy_grecsvsp = yy_grecslval;
#line 1377
  goto yy_grecsnewstate;
  yy_grecsdefault: 
#line 1384
  yy_grecsn = (int )yy_grecsdefact[yy_grecsstate];
#line 1385
  if (yy_grecsn == 0) {
#line 1386
    goto yy_grecserrlab;
  }
#line 1387
  goto yy_grecsreduce;
  yy_grecsreduce: 
#line 1395
  yy_grecslen = (int )yy_grecsr2[yy_grecsn];
#line 1405
  yy_grecsval = *(yy_grecsvsp + (1 - yy_grecslen));
  {
#line 1408
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1408
    if (yy_grecsdebug) {
      {
#line 1408
      yy_grecs_reduce_print(yy_grecsvsp, yy_grecsn);
      }
    }
#line 1408
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1411
  if (yy_grecsn == 7) {
#line 1411
    goto case_7;
  }
#line 101
  if (yy_grecsn == 8) {
#line 101 "grecs-gram.y"
    goto case_8;
  }
#line 104
  if (yy_grecsn == 9) {
#line 104
    goto case_9;
  }
#line 107
  if (yy_grecsn == 10) {
#line 107
    goto case_10;
  }
#line 115
  if (yy_grecsn == 11) {
#line 115
    goto case_11;
  }
#line 122
  if (yy_grecsn == 13) {
#line 122
    goto case_13;
  }
#line 145
  if (yy_grecsn == 14) {
#line 145
    goto case_14;
  }
#line 152
  if (yy_grecsn == 15) {
#line 152
    goto case_15;
  }
#line 156
  if (yy_grecsn == 16) {
#line 156
    goto case_16;
  }
#line 163
  if (yy_grecsn == 17) {
#line 163
    goto case_17;
  }
#line 168
  if (yy_grecsn == 18) {
#line 168
    goto case_18;
  }
#line 173
  if (yy_grecsn == 22) {
#line 173
    goto case_22;
  }
#line 192
  if (yy_grecsn == 23) {
#line 192
    goto case_23;
  }
#line 199
  if (yy_grecsn == 24) {
#line 199
    goto case_24;
  }
#line 204
  if (yy_grecsn == 25) {
#line 204
    goto case_25;
  }
#line 210
  if (yy_grecsn == 26) {
#line 210
    goto case_26;
  }
#line 214
  if (yy_grecsn == 27) {
#line 214
    goto case_27;
  }
#line 218
  if (yy_grecsn == 28) {
#line 218
    goto case_28;
  }
#line 225
  if (yy_grecsn == 29) {
#line 225
    goto case_29;
  }
#line 1580 "grecs-gram.c"
  goto switch_default;
  case_7: /* CIL Label */ 
  {
#line 97 "grecs-gram.y"
  process_ident((yy_grecsvsp + -2)->kw, & (yy_grecsvsp + -1)->value);
  }
#line 99
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 101
  stmt_begin((yy_grecsvsp + -1)->kw, (yy_grecsvsp + 0)->value);
  }
#line 102
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 103
  stmt_end((yy_grecsvsp + -6)->kw);
  }
#line 105
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 109
  yy_grecsval.kw = find_keyword((char const   *)(yy_grecsvsp + 0)->string);
  }
#line 110
  if (! yy_grecsval.kw) {
    {
#line 111
    tmp___0 = gettext("Unknown keyword");
#line 111
    grecs_error(& grecs_current_locus, 0, (char const   *)tmp___0);
    }
  }
#line 113
  goto switch_break;
  case_11: /* CIL Label */ 
#line 117
  yy_grecsval.value.type = 0;
#line 118
  yy_grecsval.value.v.string = (char const   *)((void *)0);
#line 120
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 127
  n = gl_list_size_inline((yy_grecsvsp + 0)->list);
  }
#line 127
  if (n == 1U) {
    {
#line 129
    tmp___1 = gl_list_get_at_inline((yy_grecsvsp + 0)->list, (size_t )0);
#line 129
    yy_grecsval.value = *((grecs_value_t *)tmp___1);
    }
  } else {
    {
#line 135
    yy_grecsval.value.type = 2;
#line 136
    yy_grecsval.value.v.arg.c = n;
#line 137
    tmp___2 = xcalloc(n, (size_t )sizeof(*(yy_grecsval.value.v.arg.v + 0)));
#line 137
    yy_grecsval.value.v.arg.v = (struct grecs_value *)tmp___2;
#line 138
    i = (size_t )0;
    }
    {
#line 138
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 138
      if (! (i < n)) {
#line 138
        goto while_break___9;
      }
      {
#line 139
      tmp___3 = gl_list_get_at_inline((yy_grecsvsp + 0)->list, i);
#line 139
      *(yy_grecsval.value.v.arg.v + i) = *((grecs_value_t *)tmp___3);
#line 138
      i ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  {
#line 141
  gl_list_free_inline((yy_grecsvsp + 0)->list);
  }
#line 143
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 147
  yy_grecsval.list = simple_list_create((_Bool)0);
#line 148
  tmp___4 = grecs_value_dup(& (yy_grecsvsp + 0)->value);
#line 148
  gl_list_add_last_inline(yy_grecsval.list, (void const   *)tmp___4);
  }
#line 150
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 152
  tmp___5 = grecs_value_dup(& (yy_grecsvsp + 0)->value);
#line 152
  gl_list_add_last_inline((yy_grecsvsp + -1)->list, (void const   *)tmp___5);
  }
#line 154
  goto switch_break;
  case_16: /* CIL Label */ 
#line 158
  yy_grecsval.value.type = 0;
#line 159
  yy_grecsval.value.v.string = (char const   *)(yy_grecsvsp + 0)->string;
#line 161
  goto switch_break;
  case_17: /* CIL Label */ 
#line 163
  yy_grecsval.value.type = 1;
#line 164
  yy_grecsval.value.v.list = (yy_grecsvsp + 0)->list;
#line 166
  goto switch_break;
  case_18: /* CIL Label */ 
#line 168
  yy_grecsval.value.type = 0;
#line 169
  yy_grecsval.value.v.string = (char const   *)(yy_grecsvsp + 0)->string;
#line 171
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 181
  tmp___6 = gl_list_iterator_inline((yy_grecsvsp + 0)->list);
#line 181
  itr = tmp___6;
#line 183
  grecs_line_begin();
  }
  {
#line 184
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 184
    tmp___8 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
    }
#line 184
    if (! tmp___8) {
#line 184
      goto while_break___10;
    }
    {
#line 185
    tmp___7 = strlen((char const   *)p);
#line 185
    grecs_line_add((char const   *)p, tmp___7);
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 186
  yy_grecsval.string = grecs_line_finish();
#line 187
  gl_list_iterator_free_inline(& itr);
#line 188
  gl_list_free_inline((yy_grecsvsp + 0)->list);
  }
#line 190
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 194
  yy_grecsval.list = simple_list_create((_Bool)0);
#line 195
  gl_list_add_last_inline(yy_grecsval.list, (void const   *)(yy_grecsvsp + 0)->string);
  }
#line 197
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 199
  gl_list_add_last_inline((yy_grecsvsp + -1)->list, (void const   *)(yy_grecsvsp + 0)->string);
#line 200
  yy_grecsval.list = (yy_grecsvsp + -1)->list;
  }
#line 202
  goto switch_break;
  case_25: /* CIL Label */ 
#line 206
  yy_grecsval.list = (gl_list_t )((void *)0);
#line 208
  goto switch_break;
  case_26: /* CIL Label */ 
#line 210
  yy_grecsval.list = (yy_grecsvsp + -1)->list;
#line 212
  goto switch_break;
  case_27: /* CIL Label */ 
#line 214
  yy_grecsval.list = (yy_grecsvsp + -2)->list;
#line 216
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 220
  yy_grecsval.list = simple_list_create((_Bool)0);
#line 221
  tmp___9 = grecs_value_dup(& (yy_grecsvsp + 0)->value);
#line 221
  gl_list_add_last_inline(yy_grecsval.list, (void const   *)tmp___9);
  }
#line 223
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 225
  tmp___10 = grecs_value_dup(& (yy_grecsvsp + 0)->value);
#line 225
  gl_list_add_last_inline((yy_grecsvsp + -2)->list, (void const   *)tmp___10);
#line 226
  yy_grecsval.list = (yy_grecsvsp + -2)->list;
  }
#line 228
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1580 "grecs-gram.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1582
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1582
    if (yy_grecsdebug) {
      {
#line 1582
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 1582
      yy_grecs_symbol_print(stderr, (int )yy_grecsr1[yy_grecsn], (YYSTYPE const   */* const  */)(& yy_grecsval));
#line 1582
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1582
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1584
  yy_grecsvsp -= yy_grecslen;
#line 1584
  yy_grecsssp -= yy_grecslen;
#line 1585
  yy_grecslen = 0;
  {
#line 1586
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1586
    if (yy_grecsdebug) {
      {
#line 1586
      yy_grecs_stack_print(yy_grecsss, yy_grecsssp);
      }
    }
#line 1586
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1588
  yy_grecsvsp ++;
#line 1588
  *yy_grecsvsp = yy_grecsval;
#line 1595
  yy_grecsn = (int )yy_grecsr1[yy_grecsn];
#line 1597
  yy_grecsstate = (int )((int const   )yy_grecspgoto[yy_grecsn - 13] + (int const   )*yy_grecsssp);
#line 1598
  if (0 <= yy_grecsstate) {
#line 1598
    if (yy_grecsstate <= 33) {
#line 1598
      if ((int const   )yy_grecscheck[yy_grecsstate] == (int const   )*yy_grecsssp) {
#line 1599
        yy_grecsstate = (int )yy_grecstable[yy_grecsstate];
      } else {
#line 1601
        yy_grecsstate = (int )yy_grecsdefgoto[yy_grecsn - 13];
      }
    } else {
#line 1601
      yy_grecsstate = (int )yy_grecsdefgoto[yy_grecsn - 13];
    }
  } else {
#line 1601
    yy_grecsstate = (int )yy_grecsdefgoto[yy_grecsn - 13];
  }
#line 1603
  goto yy_grecsnewstate;
  yy_grecserrlab: 
#line 1611
  if (! yy_grecserrstatus) {
    {
#line 1613
    yy_grecsnerrs ++;
#line 1615
    yy_grecserror("syntax error");
    }
  }
#line 1653
  if (yy_grecserrstatus == 3) {
#line 1658
    if (yy_grecschar <= 0) {
#line 1661
      if (yy_grecschar == 0) {
#line 1662
        goto yy_grecsabortlab;
      }
    } else {
      {
#line 1666
      yy_grecsdestruct("Error: discarding", yy_grecstoken, & yy_grecslval);
#line 1668
      yy_grecschar = -2;
      }
    }
  }
#line 1674
  goto yy_grecserrlab1;
#line 1690
  yy_grecsvsp -= yy_grecslen;
#line 1690
  yy_grecsssp -= yy_grecslen;
#line 1691
  yy_grecslen = 0;
  {
#line 1692
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1692
    if (yy_grecsdebug) {
      {
#line 1692
      yy_grecs_stack_print(yy_grecsss, yy_grecsssp);
      }
    }
#line 1692
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 1693
  yy_grecsstate = (int )*yy_grecsssp;
#line 1694
  goto yy_grecserrlab1;
  yy_grecserrlab1: 
#line 1701
  yy_grecserrstatus = 3;
  {
#line 1703
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 1705
    yy_grecsn = (int )yy_grecspact[yy_grecsstate];
#line 1706
    if (yy_grecsn != -14) {
#line 1708
      yy_grecsn ++;
#line 1709
      if (0 <= yy_grecsn) {
#line 1709
        if (yy_grecsn <= 33) {
#line 1709
          if ((int const   )yy_grecscheck[yy_grecsn] == 1) {
#line 1711
            yy_grecsn = (int )yy_grecstable[yy_grecsn];
#line 1712
            if (0 < yy_grecsn) {
#line 1713
              goto while_break___14;
            }
          }
        }
      }
    }
#line 1718
    if ((unsigned long )yy_grecsssp == (unsigned long )yy_grecsss) {
#line 1719
      goto yy_grecsabortlab;
    }
    {
#line 1722
    yy_grecsdestruct("Error: popping", (int )yy_grecsstos[yy_grecsstate], yy_grecsvsp);
#line 1724
    yy_grecsvsp --;
#line 1724
    yy_grecsssp --;
#line 1725
    yy_grecsstate = (int )*yy_grecsssp;
    }
    {
#line 1726
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1726
      if (yy_grecsdebug) {
        {
#line 1726
        yy_grecs_stack_print(yy_grecsss, yy_grecsssp);
        }
      }
#line 1726
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 1729
  if (yy_grecsn == 8) {
#line 1730
    goto yy_grecsacceptlab;
  }
#line 1732
  yy_grecsvsp ++;
#line 1732
  *yy_grecsvsp = yy_grecslval;
  {
#line 1736
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1736
    if (yy_grecsdebug) {
      {
#line 1736
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1736
      yy_grecs_symbol_print(stderr, (int )yy_grecsstos[yy_grecsn], (YYSTYPE const   */* const  */)yy_grecsvsp);
#line 1736
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1736
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1738
  yy_grecsstate = yy_grecsn;
#line 1739
  goto yy_grecsnewstate;
  yy_grecsacceptlab: 
#line 1746
  yy_grecsresult = 0;
#line 1747
  goto yy_grecsreturn;
  yy_grecsabortlab: 
#line 1753
  yy_grecsresult = 1;
#line 1754
  goto yy_grecsreturn;
  yy_grecsexhaustedlab: 
  {
#line 1761
  yy_grecserror("memory exhausted");
#line 1762
  yy_grecsresult = 2;
  }
  yy_grecsreturn: 
#line 1767
  if (yy_grecschar != 0) {
#line 1767
    if (yy_grecschar != -2) {
      {
#line 1768
      yy_grecsdestruct("Cleanup: discarding lookahead", yy_grecstoken, & yy_grecslval);
      }
    }
  }
#line 1772
  yy_grecsvsp -= yy_grecslen;
#line 1772
  yy_grecsssp -= yy_grecslen;
  {
#line 1773
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 1773
    if (yy_grecsdebug) {
      {
#line 1773
      yy_grecs_stack_print(yy_grecsss, yy_grecsssp);
      }
    }
#line 1773
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 1774
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 1774
    if (! ((unsigned long )yy_grecsssp != (unsigned long )yy_grecsss)) {
#line 1774
      goto while_break___18;
    }
    {
#line 1776
    yy_grecsdestruct("Cleanup: popping", (int )yy_grecsstos[*yy_grecsssp], yy_grecsvsp);
#line 1778
    yy_grecsvsp --;
#line 1778
    yy_grecsssp --;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 1781
  if ((unsigned long )yy_grecsss != (unsigned long )(yy_grecsssa)) {
    {
#line 1782
    free((void *)yy_grecsss);
    }
  }
#line 1789
  return (yy_grecsresult);
}
}
#line 236 "grecs-gram.y"
int yy_grecserror(char *s ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 239
  grecs_error(& grecs_current_locus, 0, "%s", s);
  }
#line 240
  return (0);
}
}
#line 243 "grecs-gram.y"
static void listel_dispose(void const   *el ) 
{ 


  {
  {
#line 246
  free((void *)el);
  }
#line 247
  return;
}
}
#line 249 "grecs-gram.y"
static gl_list_t simple_list_create(_Bool dispose ) 
{ 
  void (*tmp)(void const   *el ) ;
  gl_list_t tmp___0 ;

  {
#line 252
  if (dispose) {
#line 252
    tmp = & listel_dispose;
  } else {
#line 252
    tmp = (void (*)(void const   *el ))((void *)0);
  }
  {
#line 252
  tmp___0 = gl_list_create_empty_inline(& gl_linked_list_implementation, (_Bool (*)(void const   *elt1 ,
                                                                                    void const   *elt2 ))((void *)0),
                                        (size_t (*)(void const   *elt ))((void *)0),
                                        tmp, (_Bool)0);
  }
#line 252
  return (tmp___0);
}
}
#line 260 "grecs-gram.y"
void ( /* format attribute */  grecs_warning)(grecs_locus_t *locus , int errcode ,
                                              char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *buf ;

  {
  {
#line 264
  buf = (char *)((void *)0);
#line 266
  __builtin_va_start(ap, fmt);
#line 267
  vasprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)fmt,
            ap);
#line 268
  __builtin_va_end(ap);
#line 269
  grecs_print_diag(locus, 0, errcode, (char const   *)buf);
#line 270
  free((void *)buf);
  }
#line 271
  return;
}
}
#line 273 "grecs-gram.y"
void ( /* format attribute */  grecs_error)(grecs_locus_t *locus , int errcode , char const   *fmt 
                                            , ...) 
{ 
  va_list ap ;
  char *buf ;

  {
  {
#line 277
  buf = (char *)((void *)0);
#line 279
  __builtin_va_start(ap, fmt);
#line 280
  vasprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)fmt,
            ap);
#line 281
  __builtin_va_end(ap);
#line 282
  grecs_print_diag(locus, 1, errcode, (char const   *)buf);
#line 283
  free((void *)buf);
#line 284
  grecs_error_count ++;
  }
#line 285
  return;
}
}
#line 287 "grecs-gram.y"
void grecs_set_keywords(struct grecs_keyword *kwd ) 
{ 


  {
#line 290
  config_keywords.kwd = kwd;
#line 291
  return;
}
}
#line 293 "grecs-gram.y"
int grecs_parse(char const   *name ) 
{ 
  int rc ;
  int tmp ;

  {
  {
#line 297
  tmp = grecs_lex_begin(name);
  }
#line 297
  if (tmp) {
#line 298
    return (1);
  }
#line 299
  cursect = & config_keywords;
#line 300
  if (sections) {
    {
#line 302
    gl_list_free_inline(sections);
#line 303
    sections = (gl_list_t )((void *)0);
    }
  }
  {
#line 305
  rc = yy_grecsparse();
#line 306
  grecs_lex_end();
  }
#line 307
  if (grecs_error_count) {
#line 308
    rc = 1;
  }
#line 309
  return (rc);
}
}
#line 312 "grecs-gram.y"
void grecs_gram_trace(int n ) 
{ 


  {
#line 315
  yy_grecsdebug = n;
#line 316
  return;
}
}
#line 320 "grecs-gram.y"
static void *target_ptr(struct grecs_keyword *kwp , char *base ) 
{ 


  {
#line 323
  if (kwp->varptr) {
#line 324
    base = (char *)kwp->varptr + kwp->offset;
  } else
#line 325
  if (base) {
#line 326
    base += kwp->offset;
  }
#line 328
  return ((void *)base);
}
}
#line 331 "grecs-gram.y"
static int fake_callback(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                         void *varptr , grecs_value_t *value , void *cb_data ) 
{ 


  {
#line 338
  return (0);
}
}
#line 341 "grecs-gram.y"
static struct grecs_keyword fake  = 
#line 341
     {"*", (char const   *)((void *)0), (char const   *)((void *)0), (enum grecs_data_type )0,
    (void *)0, (size_t )0, & fake_callback, (void *)0, & fake};
#line 353 "grecs-gram.y"
static void stmt_begin(struct grecs_keyword *kwp , grecs_value_t tag ) 
{ 
  void *target ;
  void *tmp ;
  int tmp___0 ;

  {
#line 358
  if (! sections) {
    {
#line 359
    sections = simple_list_create((_Bool)0);
    }
  }
  {
#line 360
  gl_list_add_first_inline(sections, (void const   *)cursect);
  }
#line 361
  if (kwp) {
#line 363
    if (cursect) {
#line 363
      tmp = cursect->callback_data;
    } else {
#line 363
      tmp = (void *)0;
    }
    {
#line 363
    target = target_ptr(kwp, (char *)tmp);
#line 364
    cursect = kwp;
    }
#line 365
    if (kwp->callback) {
      {
#line 365
      tmp___0 = (*(kwp->callback))((enum grecs_callback_command )0, & grecs_current_locus,
                                   target, & tag, (void *)(& kwp->callback_data));
      }
#line 365
      if (tmp___0) {
#line 370
        cursect = & fake;
      }
    }
  } else {
#line 374
    cursect = kwp;
  }
#line 375
  return;
}
}
#line 377 "grecs-gram.y"
static void stmt_end(struct grecs_keyword *kwp ) 
{ 
  int (*callback)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
                  void * ) ;
  void *dataptr ;
  size_t tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 380
  callback = (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * ,
                      grecs_value_t * , void * ))((void *)0);
#line 381
  dataptr = (void *)0;
#line 383
  if (cursect) {
#line 383
    if (cursect->callback) {
#line 385
      callback = cursect->callback;
#line 386
      dataptr = (void *)(& cursect->callback_data);
    }
  }
  {
#line 389
  tmp = gl_list_size_inline(sections);
  }
#line 389
  if (tmp == 0U) {
    {
#line 390
    abort();
    }
  }
  {
#line 391
  tmp___0 = gl_list_get_at_inline(sections, (size_t )0);
#line 391
  cursect = (struct grecs_keyword *)tmp___0;
#line 392
  gl_list_remove_at_inline(sections, (size_t )0);
  }
#line 393
  if (callback) {
#line 394
    if (kwp) {
#line 394
      if (cursect) {
#line 394
        tmp___1 = cursect->callback_data;
      } else {
#line 394
        tmp___1 = (void *)0;
      }
      {
#line 394
      tmp___2 = target_ptr(kwp, (char *)tmp___1);
#line 394
      tmp___3 = tmp___2;
      }
    } else {
#line 394
      tmp___3 = (void *)0;
    }
    {
#line 394
    (*callback)((enum grecs_callback_command )1, & grecs_current_locus, tmp___3, (grecs_value_t *)((void *)0),
                dataptr);
    }
  }
#line 400
  return;
}
}
#line 402 "grecs-gram.y"
static struct grecs_keyword *find_keyword(char const   *ident___0 ) 
{ 
  struct grecs_keyword *kwp ;
  int tmp ;

  {
#line 407
  if (cursect) {
#line 407
    if ((unsigned long )cursect != (unsigned long )(& fake)) {
#line 409
      kwp = cursect->kwd;
      {
#line 409
      while (1) {
        while_continue: /* CIL Label */ ;
#line 409
        if (! kwp->ident) {
#line 409
          goto while_break;
        }
        {
#line 410
        tmp = strcmp(kwp->ident, ident___0);
        }
#line 410
        if (tmp == 0) {
#line 411
          return (kwp);
        }
#line 409
        kwp ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 415
      return (& fake);
    }
  } else {
#line 415
    return (& fake);
  }
#line 417
  return ((struct grecs_keyword *)((void *)0));
}
}
#line 420 "grecs-gram.y"
static int string_to_signed(intmax_t *sval , char const   *string , intmax_t minval ,
                            intmax_t maxval , grecs_locus_t *locus ) 
{ 
  intmax_t t ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 427
  t = strtoimax((char const   */* __restrict  */)string, (char **/* __restrict  */)(& p),
                0);
  }
#line 428
  if (*p) {
    {
#line 430
    tmp = gettext("cannot convert `%s\' to number");
#line 430
    grecs_error(locus, 0, (char const   *)tmp, string);
    }
#line 432
    return (1);
  } else
#line 434
  if (t < minval) {
    {
#line 436
    tmp___0 = gettext("%s: value out of allowed range %lli..%lli");
#line 436
    grecs_error(locus, 0, (char const   *)tmp___0, string, minval, maxval);
    }
#line 439
    return (1);
  } else
#line 434
  if (t > maxval) {
    {
#line 436
    tmp___0 = gettext("%s: value out of allowed range %lli..%lli");
#line 436
    grecs_error(locus, 0, (char const   *)tmp___0, string, minval, maxval);
    }
#line 439
    return (1);
  }
#line 441
  *sval = t;
#line 442
  return (0);
}
}
#line 445 "grecs-gram.y"
static int string_to_unsigned(uintmax_t *sval , char const   *string , uintmax_t maxval ,
                              grecs_locus_t *locus ) 
{ 
  uintmax_t t ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 452
  t = strtoumax((char const   */* __restrict  */)string, (char **/* __restrict  */)(& p),
                0);
  }
#line 453
  if (*p) {
    {
#line 455
    tmp = gettext("cannot convert `%s\' to number");
#line 455
    grecs_error(locus, 0, (char const   *)tmp, string);
    }
#line 457
    return (1);
  } else
#line 459
  if (t > maxval) {
    {
#line 461
    tmp___0 = gettext("%s: value out of allowed range 0..%llu");
#line 461
    grecs_error(locus, 0, (char const   *)tmp___0, string, maxval);
    }
#line 464
    return (1);
  }
#line 466
  *sval = t;
#line 467
  return (0);
}
}
#line 470 "grecs-gram.y"
static int string_to_bool(char const   *string , int *pval , grecs_locus_t *locus ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 473
  tmp___4 = strcmp(string, "yes");
  }
#line 473
  if (tmp___4 == 0) {
#line 477
    *pval = 1;
  } else {
    {
#line 473
    tmp___5 = strcmp(string, "true");
    }
#line 473
    if (tmp___5 == 0) {
#line 477
      *pval = 1;
    } else {
      {
#line 473
      tmp___6 = strcmp(string, "t");
      }
#line 473
      if (tmp___6 == 0) {
#line 477
        *pval = 1;
      } else {
        {
#line 473
        tmp___7 = strcmp(string, "1");
        }
#line 473
        if (tmp___7 == 0) {
#line 477
          *pval = 1;
        } else {
          {
#line 478
          tmp___0 = strcmp(string, "no");
          }
#line 478
          if (tmp___0 == 0) {
#line 482
            *pval = 0;
          } else {
            {
#line 478
            tmp___1 = strcmp(string, "false");
            }
#line 478
            if (tmp___1 == 0) {
#line 482
              *pval = 0;
            } else {
              {
#line 478
              tmp___2 = strcmp(string, "nil");
              }
#line 478
              if (tmp___2 == 0) {
#line 482
                *pval = 0;
              } else {
                {
#line 478
                tmp___3 = strcmp(string, "0");
                }
#line 478
                if (tmp___3 == 0) {
#line 482
                  *pval = 0;
                } else {
                  {
#line 485
                  tmp = gettext("%s: not a valid boolean value");
#line 485
                  grecs_error(locus, 0, (char const   *)tmp, string);
                  }
#line 486
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 488
  return (0);
}
}
#line 491 "grecs-gram.y"
static int string_to_host(struct in_addr *in , char const   *string , grecs_locus_t *locus ) 
{ 
  struct hostent *hp ;
  int tmp ;

  {
  {
#line 494
  tmp = inet_aton(string, in);
  }
#line 494
  if (tmp == 0) {
    {
#line 498
    hp = gethostbyname(string);
    }
#line 499
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 500
      return (1);
    }
    {
#line 501
    memcpy((void */* __restrict  */)in, (void const   */* __restrict  */)*(hp->h_addr_list + 0),
           (size_t )sizeof(struct in_addr ));
    }
  }
#line 503
  return (0);
}
}
#line 506 "grecs-gram.y"
static int string_to_sockaddr(struct grecs_sockaddr *sp , char const   *string , grecs_locus_t *locus ) 
{ 
  struct sockaddr_un s_un ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *p ;
  char *tmp___2 ;
  size_t len ;
  struct sockaddr_in sa ;
  char *host ;
  void *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  struct servent *serv ;
  unsigned long l ;
  char *q ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 510
  if ((int const   )*(string + 0) == 47) {
    {
#line 513
    tmp___0 = strlen(string);
    }
#line 513
    if ((unsigned long )tmp___0 >= sizeof(s_un.sun_path)) {
      {
#line 515
      tmp = gettext("%s: UNIX socket name too long");
#line 515
      grecs_error(locus, 0, (char const   *)tmp, string);
      }
#line 516
      return (1);
    }
    {
#line 518
    s_un.sun_family = (sa_family_t )1;
#line 519
    strcpy((char */* __restrict  */)(s_un.sun_path), (char const   */* __restrict  */)string);
#line 520
    sp->len = (int )sizeof(s_un);
#line 521
    tmp___1 = xmalloc((size_t )sp->len);
#line 521
    sp->sa = (struct sockaddr *)tmp___1;
#line 522
    memcpy((void */* __restrict  */)sp->sa, (void const   */* __restrict  */)(& s_un),
           (size_t )sp->len);
    }
  } else {
    {
#line 526
    tmp___2 = strchr(string, ':');
#line 526
    p = tmp___2;
#line 530
    sa.sin_family = (sa_family_t )2;
    }
#line 531
    if (p) {
#line 532
      len = (size_t )(p - (char *)string);
    } else {
      {
#line 534
      len = strlen(string);
      }
    }
#line 536
    if (len == 0U) {
#line 537
      sa.sin_addr.s_addr = (in_addr_t )0;
    } else {
      {
#line 540
      tmp___3 = xmalloc(len + 1U);
#line 540
      host = (char *)tmp___3;
#line 541
      memcpy((void */* __restrict  */)host, (void const   */* __restrict  */)string,
             len);
#line 542
      *(host + len) = (char)0;
#line 544
      tmp___5 = string_to_host(& sa.sin_addr, (char const   *)host, locus);
      }
#line 544
      if (tmp___5) {
        {
#line 546
        tmp___4 = gettext("%s: not a valid IP address or hostname");
#line 546
        grecs_error(locus, 0, (char const   *)tmp___4, host);
#line 549
        free((void *)host);
        }
#line 550
        return (1);
      }
      {
#line 552
      free((void *)host);
      }
    }
#line 555
    if (p) {
      {
#line 559
      p ++;
#line 560
      serv = getservbyname((char const   *)p, "tcp");
      }
#line 561
      if ((unsigned long )serv != (unsigned long )((void *)0)) {
#line 562
        sa.sin_port = (in_port_t )serv->s_port;
      } else {
        {
#line 569
        l = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& q),
                    0);
        }
#line 571
        if (*q) {
          {
#line 573
          tmp___6 = gettext("%s: not a valid port number");
#line 573
          grecs_error(locus, 0, (char const   *)tmp___6, p);
          }
#line 575
          return (1);
        } else
#line 571
        if (l > 65535UL) {
          {
#line 573
          tmp___6 = gettext("%s: not a valid port number");
#line 573
          grecs_error(locus, 0, (char const   *)tmp___6, p);
          }
#line 575
          return (1);
        }
        {
#line 577
        sa.sin_port = htons((uint16_t )l);
        }
      }
    } else
#line 580
    if (grecs_default_port) {
#line 581
      sa.sin_port = (in_port_t )grecs_default_port;
    } else {
      {
#line 584
      tmp___7 = gettext("missing port number");
#line 584
      grecs_error(locus, 0, (char const   *)tmp___7);
      }
#line 585
      return (1);
    }
    {
#line 587
    sp->len = (int )sizeof(sa);
#line 588
    tmp___8 = xmalloc((size_t )sp->len);
#line 588
    sp->sa = (struct sockaddr *)tmp___8;
#line 589
    memcpy((void */* __restrict  */)sp->sa, (void const   */* __restrict  */)(& sa),
           (size_t )sp->len);
    }
  }
#line 591
  return (0);
}
}
#line 594 "grecs-gram.y"
int grecs_string_convert(void *target , enum grecs_data_type type , char const   *string ,
                         grecs_locus_t *locus ) 
{ 
  uintmax_t uval ;
  intmax_t sval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 603
  if ((unsigned int )type == 0U) {
#line 603
    goto case_0;
  }
#line 606
  if ((unsigned int )type == 1U) {
#line 606
    goto case_1;
  }
#line 610
  if ((unsigned int )type == 2U) {
#line 610
    goto case_2;
  }
#line 617
  if ((unsigned int )type == 3U) {
#line 617
    goto case_3;
  }
#line 624
  if ((unsigned int )type == 12U) {
#line 624
    goto case_12;
  }
#line 627
  if ((unsigned int )type == 4U) {
#line 627
    goto case_4;
  }
#line 634
  if ((unsigned int )type == 5U) {
#line 634
    goto case_5;
  }
#line 641
  if ((unsigned int )type == 6U) {
#line 641
    goto case_6;
  }
#line 648
  if ((unsigned int )type == 7U) {
#line 648
    goto case_7;
  }
#line 655
  if ((unsigned int )type == 8U) {
#line 655
    goto case_8;
  }
#line 662
  if ((unsigned int )type == 10U) {
#line 662
    goto case_10;
  }
#line 666
  if ((unsigned int )type == 9U) {
#line 666
    goto case_9;
  }
#line 670
  if ((unsigned int )type == 11U) {
#line 670
    goto case_11;
  }
#line 678
  if ((unsigned int )type == 13U) {
#line 678
    goto case_13;
  }
#line 686
  if ((unsigned int )type == 15U) {
#line 686
    goto case_15;
  }
#line 695
  if ((unsigned int )type == 16U) {
#line 695
    goto case_16;
  }
#line 700
  if ((unsigned int )type == 14U) {
#line 700
    goto case_14;
  }
#line 704
  if ((unsigned int )type == 17U) {
#line 704
    goto case_17;
  }
#line 601
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 604
  abort();
  }
  case_1: /* CIL Label */ 
#line 607
  *((char const   **)target) = string;
#line 608
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 611
  tmp = string_to_signed(& sval, string, (intmax_t )-32768, (intmax_t )32767, locus);
  }
#line 611
  if (tmp == 0) {
#line 612
    *((short *)target) = (short )sval;
  } else {
#line 614
    return (1);
  }
#line 615
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 618
  tmp___0 = string_to_unsigned(& uval, string, (uintmax_t )65535, locus);
  }
#line 618
  if (tmp___0 == 0) {
#line 619
    *((unsigned short *)target) = (unsigned short )uval;
  } else {
#line 621
    return (1);
  }
#line 622
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 625
  tmp___1 = string_to_bool(string, (int *)target, locus);
  }
#line 625
  return (tmp___1);
  case_4: /* CIL Label */ 
  {
#line 628
  tmp___2 = string_to_signed(& sval, string, (intmax_t )(-0x7FFFFFFF-1), (intmax_t )2147483647,
                             locus);
  }
#line 628
  if (tmp___2 == 0) {
#line 629
    *((int *)target) = (int )sval;
  } else {
#line 631
    return (1);
  }
#line 632
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 635
  tmp___3 = string_to_unsigned(& uval, string, (uintmax_t )4294967295U, locus);
  }
#line 635
  if (tmp___3 == 0) {
#line 636
    *((unsigned int *)target) = (unsigned int )uval;
  } else {
#line 638
    return (1);
  }
#line 639
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 642
  tmp___4 = string_to_signed(& sval, string, (intmax_t )(-0x7FFFFFFF-1), (intmax_t )2147483647L,
                             locus);
  }
#line 642
  if (tmp___4 == 0) {
#line 643
    *((long *)target) = (long )sval;
  } else {
#line 645
    return (1);
  }
#line 646
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 649
  tmp___5 = string_to_unsigned(& uval, string, (uintmax_t )4294967295UL, locus);
  }
#line 649
  if (tmp___5 == 0) {
#line 650
    *((unsigned long *)target) = (unsigned long )uval;
  } else {
#line 652
    return (1);
  }
#line 653
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 656
  tmp___6 = string_to_unsigned(& uval, string, (uintmax_t )4294967295U, locus);
  }
#line 656
  if (tmp___6 == 0) {
#line 657
    *((size_t *)target) = (size_t )uval;
  } else {
#line 659
    return (1);
  }
#line 660
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 663
  tmp___7 = string_to_signed((intmax_t *)target, string, (-0x7FFFFFFFFFFFFFFF-1),
                             9223372036854775807LL, locus);
  }
#line 663
  return (tmp___7);
  case_9: /* CIL Label */ 
  {
#line 667
  tmp___8 = string_to_unsigned((uintmax_t *)target, string, 0xffffffffffffffffULL,
                               locus);
  }
#line 667
  return (tmp___8);
  case_11: /* CIL Label */ 
  {
#line 672
  tmp___9 = string_to_unsigned(& uval, string, (uintmax_t )((time_t )-1), locus);
  }
#line 672
  if (tmp___9 == 0) {
#line 673
    *((time_t *)target) = (time_t )uval;
  } else {
#line 675
    return (1);
  }
#line 676
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 679
  tmp___11 = inet_aton(string, (struct in_addr *)target);
  }
#line 679
  if (tmp___11) {
    {
#line 681
    tmp___10 = gettext("%s: not a valid IP address");
#line 681
    grecs_error(locus, 0, (char const   *)tmp___10, string);
    }
#line 682
    return (1);
  }
#line 684
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 687
  tmp___13 = string_to_host((struct in_addr *)target, string, locus);
  }
#line 687
  if (tmp___13) {
    {
#line 689
    tmp___12 = gettext("%s: not a valid IP address or hostname");
#line 689
    grecs_error(locus, 0, (char const   *)tmp___12, string);
    }
#line 691
    return (1);
  }
#line 693
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 696
  tmp___14 = string_to_sockaddr((struct grecs_sockaddr *)target, string, locus);
  }
#line 696
  return (tmp___14);
  case_14: /* CIL Label */ 
  {
#line 701
  tmp___15 = gettext("INTERNAL ERROR at %s:%d");
#line 701
  grecs_error(locus, 0, (char const   *)tmp___15, "grecs-gram.y", 701);
#line 702
  abort();
  }
  case_17: /* CIL Label */ 
  {
#line 705
  tmp___16 = gettext("invalid use of block statement");
#line 705
  grecs_error(locus, 0, (char const   *)tmp___16);
  }
#line 707
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 709
  return (0);
}
}
#line 718 "grecs-gram.y"
static _Bool string_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 721
  tmp = strcmp((char const   *)elt1, (char const   *)elt2);
  }
#line 721
  return ((_Bool )(tmp == 0));
}
}
#line 734 "grecs-gram.y"
static _Bool short_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 734
  tmp = memcmp(elt1, elt2, (size_t )sizeof(short ));
  }
#line 734
  return ((_Bool )(tmp == 0));
}
}
#line 735 "grecs-gram.y"
static _Bool int_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 735
  tmp = memcmp(elt1, elt2, (size_t )sizeof(int ));
  }
#line 735
  return ((_Bool )(tmp == 0));
}
}
#line 736 "grecs-gram.y"
static _Bool long_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 736
  tmp = memcmp(elt1, elt2, (size_t )sizeof(long ));
  }
#line 736
  return ((_Bool )(tmp == 0));
}
}
#line 737 "grecs-gram.y"
static _Bool size_t_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 737
  tmp = memcmp(elt1, elt2, (size_t )sizeof(size_t ));
  }
#line 737
  return ((_Bool )(tmp == 0));
}
}
#line 738 "grecs-gram.y"
static _Bool uintmax_t_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 738
  tmp = memcmp(elt1, elt2, (size_t )sizeof(uintmax_t ));
  }
#line 738
  return ((_Bool )(tmp == 0));
}
}
#line 739 "grecs-gram.y"
static _Bool intmax_t_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 739
  tmp = memcmp(elt1, elt2, (size_t )sizeof(intmax_t ));
  }
#line 739
  return ((_Bool )(tmp == 0));
}
}
#line 740 "grecs-gram.y"
static _Bool time_t_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 740
  tmp = memcmp(elt1, elt2, (size_t )sizeof(time_t ));
  }
#line 740
  return ((_Bool )(tmp == 0));
}
}
#line 741 "grecs-gram.y"
static _Bool in_addr_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 741
  tmp = memcmp(elt1, elt2, (size_t )sizeof(struct in_addr ));
  }
#line 741
  return ((_Bool )(tmp == 0));
}
}
#line 742 "grecs-gram.y"
static _Bool grecs_sockaddr_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 742
  tmp = memcmp(elt1, elt2, (size_t )sizeof(struct grecs_sockaddr ));
  }
#line 742
  return ((_Bool )(tmp == 0));
}
}
#line 744 "grecs-gram.y"
struct grecs_prop grecs_prop_tab[18]  = 
#line 744
  {      {(size_t )0, (_Bool (*)(void const   *elt1 , void const   *elt2 ))((void *)0)}, 
        {(size_t )sizeof(char *),
      & string_eq}, 
        {(size_t )sizeof(short ), & short_eq}, 
        {(size_t )sizeof(unsigned short ), & short_eq}, 
        {(size_t )sizeof(int ), & int_eq}, 
        {(size_t )sizeof(unsigned int ), & int_eq}, 
        {(size_t )sizeof(long ), & long_eq}, 
        {(size_t )sizeof(unsigned long ), & long_eq}, 
        {(size_t )sizeof(size_t ), & size_t_eq}, 
        {(size_t )sizeof(uintmax_t ), & uintmax_t_eq}, 
        {(size_t )sizeof(intmax_t ), & intmax_t_eq}, 
        {(size_t )sizeof(time_t ), & time_t_eq}, 
        {(size_t )sizeof(int ), & int_eq}, 
        {(size_t )sizeof(struct in_addr ), & in_addr_eq}, 
        {(size_t )0, (_Bool (*)(void const   *elt1 , void const   *elt2 ))((void *)0)}, 
        {(size_t )sizeof(struct in_addr ),
      & in_addr_eq}, 
        {(size_t )sizeof(struct grecs_sockaddr ), & grecs_sockaddr_eq}, 
        {(size_t )0, (_Bool (*)(void const   *elt1 , void const   *elt2 ))((void *)0)}};
#line 769 "grecs-gram.y"
void grecs_process_ident(struct grecs_keyword *kwp , grecs_value_t *value , void *base ,
                         grecs_locus_t *locus ) 
{ 
  void *target ;
  char *tmp ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp___0 ;
  enum grecs_data_type type ;
  int num ;
  void const   *p ;
  gl_list_t list ;
  size_t size ;
  char *tmp___1 ;
  grecs_value_t const   *vp ;
  char *tmp___2 ;
  void *ptr ;
  void *tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  gl_list_t list___0 ;
  enum grecs_data_type type___0 ;
  size_t size___0 ;
  void *ptr___0 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 775
  if (! kwp) {
#line 776
    return;
  }
  {
#line 778
  target = target_ptr(kwp, (char *)base);
  }
#line 780
  if (kwp->callback) {
    {
#line 781
    (*(kwp->callback))((enum grecs_callback_command )2, locus, target, value, (void *)(& kwp->callback_data));
    }
  } else
#line 786
  if (value->type == 2) {
    {
#line 788
    tmp = gettext("too many arguments to `%s\'; missing semicolon?");
#line 788
    grecs_error(locus, 0, (char const   *)tmp, kwp->ident);
    }
#line 791
    return;
  } else
#line 793
  if (value->type == 1) {
#line 795
    if ((unsigned int )kwp->type & 32768U) {
      {
#line 797
      tmp___0 = gl_list_iterator_inline(value->v.list);
#line 797
      itr = tmp___0;
#line 798
      type = (enum grecs_data_type )((unsigned int )kwp->type & 255U);
#line 799
      num = 1;
      }
#line 804
      if ((unsigned long )type >= sizeof(grecs_prop_tab) / sizeof(grecs_prop_tab[0])) {
        {
#line 807
        tmp___1 = gettext("INTERNAL ERROR at %s:%d: unhandled data type %d");
#line 807
        grecs_error(locus, 0, (char const   *)tmp___1, "grecs-gram.y", 810, (unsigned int )type);
#line 811
        abort();
        }
      } else {
#line 804
        size = grecs_prop_tab[type].size;
#line 804
        if (size == 0U) {
          {
#line 807
          tmp___1 = gettext("INTERNAL ERROR at %s:%d: unhandled data type %d");
#line 807
          grecs_error(locus, 0, (char const   *)tmp___1, "grecs-gram.y", 810, (unsigned int )type);
#line 811
          abort();
          }
        }
      }
      {
#line 814
      list = gl_list_create_empty_inline(& gl_linked_list_implementation, grecs_prop_tab[type].eqfn,
                                         (size_t (*)(void const   *elt ))((void *)0),
                                         (void (*)(void const   *elt ))((void *)0),
                                         (_Bool)0);
      }
      {
#line 820
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 820
        tmp___5 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
        }
#line 820
        if (! tmp___5) {
#line 820
          goto while_break;
        }
#line 822
        vp = (grecs_value_t const   *)p;
#line 824
        if (vp->type != 0) {
          {
#line 825
          tmp___2 = gettext("%s: incompatible data type in list item #%d");
#line 825
          grecs_error(locus, 0, (char const   *)tmp___2, kwp->ident, num);
          }
        } else
#line 828
        if ((unsigned int )type == 1U) {
          {
#line 829
          gl_list_add_last_inline(list, (void const   *)vp->v.string);
          }
        } else {
          {
#line 832
          tmp___3 = xmalloc(size);
#line 832
          ptr = tmp___3;
#line 833
          tmp___4 = grecs_string_convert(ptr, type, (char const   *)vp->v.string,
                                         locus);
          }
#line 833
          if (tmp___4 == 0) {
            {
#line 835
            gl_list_add_last_inline(list, (void const   *)ptr);
            }
          } else {
            {
#line 837
            free(ptr);
            }
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 840
      gl_list_iterator_free_inline(& itr);
#line 841
      *((gl_list_t *)target) = list;
      }
    } else {
      {
#line 845
      tmp___6 = gettext("incompatible data type for `%s\'");
#line 845
      grecs_error(locus, 0, (char const   *)tmp___6, kwp->ident);
      }
#line 848
      return;
    }
  } else
#line 851
  if ((unsigned int )kwp->type & 32768U) {
#line 854
    type___0 = (enum grecs_data_type )((unsigned int )kwp->type & 255U);
#line 858
    if ((unsigned long )type___0 >= sizeof(grecs_prop_tab) / sizeof(grecs_prop_tab[0])) {
      {
#line 861
      tmp___7 = gettext("INTERNAL ERROR at %s:%d: unhandled data type %d");
#line 861
      grecs_error(locus, 0, (char const   *)tmp___7, "grecs-gram.y", 863, (unsigned int )type___0);
#line 864
      abort();
      }
    } else {
#line 858
      size___0 = grecs_prop_tab[type___0].size;
#line 858
      if (size___0 == 0U) {
        {
#line 861
        tmp___7 = gettext("INTERNAL ERROR at %s:%d: unhandled data type %d");
#line 861
        grecs_error(locus, 0, (char const   *)tmp___7, "grecs-gram.y", 863, (unsigned int )type___0);
#line 864
        abort();
        }
      }
    }
    {
#line 867
    list___0 = gl_list_create_empty_inline(& gl_linked_list_implementation, grecs_prop_tab[type___0].eqfn,
                                           (size_t (*)(void const   *elt ))((void *)0),
                                           & listel_dispose, (_Bool)0);
    }
#line 872
    if ((unsigned int )type___0 == 1U) {
      {
#line 873
      gl_list_add_last_inline(list___0, (void const   *)value->v.string);
      }
    } else {
      {
#line 876
      ptr___0 = xmalloc(size___0);
#line 877
      tmp___8 = grecs_string_convert(ptr___0, type___0, value->v.string, locus);
      }
#line 877
      if (tmp___8) {
        {
#line 879
        free(ptr___0);
#line 880
        gl_list_free_inline(list___0);
        }
#line 881
        return;
      }
      {
#line 883
      gl_list_add_last_inline(list___0, (void const   *)ptr___0);
      }
    }
#line 885
    *((gl_list_t *)target) = list___0;
  } else {
    {
#line 888
    grecs_string_convert(target, (enum grecs_data_type )((unsigned int )kwp->type & 255U),
                         value->v.string, locus);
    }
  }
#line 890
  return;
}
}
#line 892 "grecs-gram.y"
static void process_ident(struct grecs_keyword *kwp , grecs_value_t *value ) 
{ 
  void *tmp ;

  {
#line 895
  if (cursect) {
#line 895
    tmp = cursect->callback_data;
  } else {
#line 895
    tmp = (void *)0;
  }
  {
#line 895
  grecs_process_ident(kwp, value, (void *)((char *)tmp), & grecs_current_locus);
  }
#line 896
  return;
}
}
#line 155 "./grecs.h"
char const   *grecs_data_type_string(enum grecs_data_type type ) ;
#line 156
void grecs_format_docstring(FILE *stream , char const   *docstring___0 , unsigned int level ) ;
#line 158
void grecs_format_simple_statement(FILE *stream , struct grecs_keyword *kwp , unsigned int level ) ;
#line 160
void grecs_format_block_statement(FILE *stream , struct grecs_keyword *kwp , unsigned int level ) ;
#line 162
void grecs_format_statement_array(FILE *stream , struct grecs_keyword *kwp , unsigned int n ,
                                  unsigned int level ) ;
#line 35 "/home/ysko/Works/test-src/pies-1.2/grecs/src/format.c"
char const   *grecs_data_type_string(enum grecs_data_type type ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 40
  if ((unsigned int )type == 0U) {
#line 40
    goto case_0;
  }
#line 43
  if ((unsigned int )type == 1U) {
#line 43
    goto case_1;
  }
#line 55
  if ((unsigned int )type == 10U) {
#line 55
    goto case_10;
  }
#line 55
  if ((unsigned int )type == 9U) {
#line 55
    goto case_10;
  }
#line 55
  if ((unsigned int )type == 8U) {
#line 55
    goto case_10;
  }
#line 55
  if ((unsigned int )type == 7U) {
#line 55
    goto case_10;
  }
#line 55
  if ((unsigned int )type == 6U) {
#line 55
    goto case_10;
  }
#line 55
  if ((unsigned int )type == 5U) {
#line 55
    goto case_10;
  }
#line 55
  if ((unsigned int )type == 4U) {
#line 55
    goto case_10;
  }
#line 55
  if ((unsigned int )type == 3U) {
#line 55
    goto case_10;
  }
#line 55
  if ((unsigned int )type == 2U) {
#line 55
    goto case_10;
  }
#line 58
  if ((unsigned int )type == 11U) {
#line 58
    goto case_11;
  }
#line 61
  if ((unsigned int )type == 12U) {
#line 61
    goto case_12;
  }
#line 64
  if ((unsigned int )type == 13U) {
#line 64
    goto case_13;
  }
#line 67
  if ((unsigned int )type == 14U) {
#line 67
    goto case_14;
  }
#line 70
  if ((unsigned int )type == 15U) {
#line 70
    goto case_15;
  }
#line 73
  if ((unsigned int )type == 16U) {
#line 73
    goto case_16;
  }
#line 76
  if ((unsigned int )type == 17U) {
#line 76
    goto case_17;
  }
#line 38
  goto switch_break;
  case_0: /* CIL Label */ 
#line 41
  return ("void");
  case_1: /* CIL Label */ 
#line 44
  return ("string");
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 56
  return ("number");
  case_11: /* CIL Label */ 
#line 59
  return ("time");
  case_12: /* CIL Label */ 
#line 62
  return ("boolean");
  case_13: /* CIL Label */ 
#line 65
  return ("IPv4");
  case_14: /* CIL Label */ 
#line 68
  return ("CIDR");
  case_15: /* CIL Label */ 
#line 71
  return ("hostname");
  case_16: /* CIL Label */ 
#line 74
  return ("sock-addr");
  case_17: /* CIL Label */ 
#line 77
  return ("section");
  switch_break: /* CIL Label */ ;
  }
#line 79
  return ("UNKNOWN?");
}
}
#line 82 "/home/ysko/Works/test-src/pies-1.2/grecs/src/format.c"
static void format_level(FILE *stream , unsigned int level ) 
{ 
  unsigned int tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    tmp = level;
#line 85
    level --;
#line 85
    if (! tmp) {
#line 85
      goto while_break;
    }
    {
#line 86
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 89 "/home/ysko/Works/test-src/pies-1.2/grecs/src/format.c"
void grecs_format_docstring(FILE *stream , char const   *docstring___0 , unsigned int level ) 
{ 
  size_t len ;
  size_t tmp ;
  int width ;
  size_t seglen ;
  char const   *p ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp11 ;

  {
  {
#line 92
  tmp = strlen(docstring___0);
#line 92
  len = tmp;
#line 93
  width = (int )(78U - level * 2U);
  }
#line 95
  if (width < 0) {
#line 97
    width = 78;
#line 98
    level = 0U;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! len) {
#line 101
      goto while_break;
    }
#line 106
    seglen = (size_t )0;
#line 106
    p = docstring___0;
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if ((unsigned long )p < (unsigned long )(docstring___0 + width)) {
#line 106
        if (! *p) {
#line 106
          goto while_break___0;
        }
      } else {
#line 106
        goto while_break___0;
      }
#line 108
      if ((int const   )*p == 10) {
#line 110
        seglen = (size_t )(p - docstring___0);
#line 111
        goto while_break___0;
      }
      {
#line 113
      tmp___0 = __ctype_b_loc();
      }
#line 113
      if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 114
        seglen = (size_t )(p - docstring___0);
      }
#line 106
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    if (seglen == 0U) {
#line 117
      seglen = (size_t )(p - docstring___0);
    } else
#line 116
    if ((int const   )*p == 0) {
#line 117
      seglen = (size_t )(p - docstring___0);
    }
    {
#line 119
    format_level(stream, level);
#line 120
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# ");
#line 121
    fwrite((void const   */* __restrict  */)docstring___0, seglen, (size_t )1, (FILE */* __restrict  */)stream);
#line 122
    fputc('\n', stream);
#line 123
    len -= seglen;
#line 124
    docstring___0 += seglen;
    }
#line 125
    if ((int const   )*docstring___0 == 10) {
#line 127
      docstring___0 ++;
#line 128
      len --;
    } else {
      {
#line 131
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 131
        if (*docstring___0) {
          {
#line 131
          tmp___1 = __ctype_b_loc();
          }
#line 131
          if (! ((int const   )*(*tmp___1 + (int )*docstring___0) & 8192)) {
#line 131
            goto while_break___1;
          }
        } else {
#line 131
          goto while_break___1;
        }
#line 133
        docstring___0 ++;
#line 134
        len --;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return;
}
}
#line 139 "/home/ysko/Works/test-src/pies-1.2/grecs/src/format.c"
void grecs_format_simple_statement(FILE *stream , struct grecs_keyword *kwp , unsigned int level ) 
{ 
  char const   *argstr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 145
  if (kwp->docstring) {
    {
#line 146
    grecs_format_docstring(stream, kwp->docstring, level);
    }
  }
  {
#line 147
  format_level(stream, level);
  }
#line 149
  if (kwp->argname) {
#line 150
    argstr = kwp->argname;
  } else {
#line 152
    argstr = "arg";
  }
  {
#line 154
  tmp___7 = strchr("<[", (int )*(argstr + 0));
  }
#line 154
  if (tmp___7) {
    {
#line 155
    tmp = gettext(argstr);
#line 155
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s;\n",
            kwp->ident, tmp);
    }
  } else {
    {
#line 156
    tmp___6 = strchr(argstr, ':');
    }
#line 156
    if (tmp___6) {
      {
#line 157
      tmp___0 = gettext(argstr);
#line 157
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s <%s>;\n",
              kwp->ident, tmp___0);
      }
    } else {
      {
#line 160
      tmp___1 = gettext(argstr);
#line 160
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s <%s: ",
              kwp->ident, tmp___1);
      }
#line 161
      if ((unsigned int )kwp->type & 32768U) {
        {
#line 162
        tmp___2 = grecs_data_type_string((enum grecs_data_type )((unsigned int )kwp->type & 255U));
#line 162
        tmp___3 = gettext(tmp___2);
#line 162
        fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"list of %s",
                tmp___3);
        }
      } else {
        {
#line 165
        tmp___4 = grecs_data_type_string(kwp->type);
#line 165
        tmp___5 = gettext(tmp___4);
#line 165
        fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                tmp___5);
        }
      }
      {
#line 166
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)">;\n");
      }
    }
  }
#line 168
  return;
}
}
#line 170 "/home/ysko/Works/test-src/pies-1.2/grecs/src/format.c"
void grecs_format_block_statement(FILE *stream , struct grecs_keyword *kwp , unsigned int level ) 
{ 
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 174
  if (kwp->docstring) {
    {
#line 175
    grecs_format_docstring(stream, kwp->docstring, level);
    }
  }
  {
#line 176
  format_level(stream, level);
#line 177
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
          kwp->ident);
  }
#line 178
  if (kwp->argname) {
    {
#line 179
    tmp = gettext(kwp->argname);
#line 179
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" <%s>",
            tmp);
    }
  }
  {
#line 180
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" {\n");
#line 181
  grecs_format_statement_array(stream, kwp->kwd, 0U, level + 1U);
#line 182
  format_level(stream, level);
#line 183
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"}\n");
  }
#line 184
  return;
}
}
#line 186 "/home/ysko/Works/test-src/pies-1.2/grecs/src/format.c"
void grecs_format_statement_array(FILE *stream , struct grecs_keyword *kwp , unsigned int n ,
                                  unsigned int level ) 
{ 


  {
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! kwp->ident) {
#line 191
      goto while_break;
    }
#line 193
    if (n) {
      {
#line 194
      fputc('\n', stream);
      }
    }
#line 195
    if ((unsigned int )kwp->type == 17U) {
      {
#line 196
      grecs_format_block_statement(stream, kwp, level);
      }
    } else {
      {
#line 198
      grecs_format_simple_statement(stream, kwp, level);
      }
    }
#line 191
    kwp ++;
#line 191
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return;
}
}
#line 56 "/home/ysko/Works/test-src/pies-1.2/lib/libpies.h"
int strtotok_len(struct tokendef *tab___0 , char const   *str , size_t len , int *pres ) ;
#line 58
int strtotok_len_ci(struct tokendef *tab___0 , char const   *str , size_t len , int *pres ) ;
#line 60
int strtotok(struct tokendef *tab___0 , char const   *str , int *pres ) ;
#line 61
int strtotok_ci(struct tokendef *tab___0 , char const   *str , int *pres ) ;
#line 62
int toktostr(struct tokendef *tab___0 , int tok , char const   **pres ) ;
#line 25 "/home/ysko/Works/test-src/pies-1.2/lib/strtotok.c"
int strtotok_len(struct tokendef *tab___0 , char const   *str , size_t len , int *pres ) 
{ 
  size_t kwlen ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! tab___0->name) {
#line 28
      goto while_break;
    }
    {
#line 30
    tmp = strlen((char const   *)tab___0->name);
#line 30
    kwlen = tmp;
    }
#line 31
    if (kwlen == len) {
      {
#line 31
      tmp___0 = memcmp((void const   *)tab___0->name, (void const   *)str, len);
      }
#line 31
      if (tmp___0 == 0) {
#line 33
        *pres = tab___0->tok;
#line 34
        return (0);
      }
    }
#line 28
    tab___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return (1);
}
}
#line 40 "/home/ysko/Works/test-src/pies-1.2/lib/strtotok.c"
int strtotok_len_ci(struct tokendef *tab___0 , char const   *str , size_t len , int *pres ) 
{ 
  size_t kwlen ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! tab___0->name) {
#line 43
      goto while_break;
    }
    {
#line 45
    tmp = strlen((char const   *)tab___0->name);
#line 45
    kwlen = tmp;
    }
#line 46
    if (kwlen == len) {
      {
#line 46
      tmp___0 = c_strncasecmp((char const   *)tab___0->name, str, len);
      }
#line 46
      if (tmp___0 == 0) {
#line 48
        *pres = tab___0->tok;
#line 49
        return (0);
      }
    }
#line 43
    tab___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (1);
}
}
#line 55 "/home/ysko/Works/test-src/pies-1.2/lib/strtotok.c"
int strtotok(struct tokendef *tab___0 , char const   *str , int *pres ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 58
  tmp = strlen(str);
#line 58
  tmp___0 = strtotok_len(tab___0, str, tmp, pres);
  }
#line 58
  return (tmp___0);
}
}
#line 61 "/home/ysko/Works/test-src/pies-1.2/lib/strtotok.c"
int strtotok_ci(struct tokendef *tab___0 , char const   *str , int *pres ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 64
  tmp = strlen(str);
#line 64
  tmp___0 = strtotok_len_ci(tab___0, str, tmp, pres);
  }
#line 64
  return (tmp___0);
}
}
#line 67 "/home/ysko/Works/test-src/pies-1.2/lib/strtotok.c"
int toktostr(struct tokendef *tab___0 , int tok , char const   **pres ) 
{ 


  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! tab___0->name) {
#line 70
      goto while_break;
    }
#line 71
    if (tab___0->tok == tok) {
#line 73
      *pres = (char const   *)tab___0->name;
#line 74
      return (0);
    }
#line 70
    tab___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (1);
}
}
#line 540 "/usr/include/unistd.h"
extern char **environ ;
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 39 "/home/ysko/Works/test-src/pies-1.2/lib/proctitle.c"
static int move_env(char **env ) 
{ 
  size_t size ;
  int i ;
  char **p ;
  size_t tmp ;
  void *tmp___0 ;
  int j ;
  char *tmp___1 ;

  {
#line 46
  size = (size_t )0;
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! *(env + i)) {
#line 47
      goto while_break;
    }
    {
#line 48
    tmp = strlen((char const   *)*(env + i));
#line 48
    size += tmp + 1U;
#line 47
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  tmp___0 = calloc((size_t )(i + 1), (size_t )sizeof(*p));
#line 50
  p = (char **)tmp___0;
  }
#line 51
  if (! p) {
#line 52
    return (1);
  }
#line 54
  i = 0;
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! *(env + i)) {
#line 54
      goto while_break___0;
    }
    {
#line 55
    tmp___1 = strdup((char const   *)*(env + i));
#line 55
    *(p + i) = tmp___1;
    }
#line 55
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 58
      j = 0;
      {
#line 58
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 58
        if (! (j < i)) {
#line 58
          goto while_break___1;
        }
        {
#line 59
        free((void *)*(p + i));
#line 58
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 60
      free((void *)p);
      }
#line 61
      return (1);
    }
#line 54
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  *(p + i) = (char *)((void *)0);
#line 64
  environ = p;
#line 65
  return (0);
}
}
#line 68 "/home/ysko/Works/test-src/pies-1.2/lib/proctitle.c"
static int orig_argc  ;
#line 69 "/home/ysko/Works/test-src/pies-1.2/lib/proctitle.c"
static char **orig_argv  ;
#line 70 "/home/ysko/Works/test-src/pies-1.2/lib/proctitle.c"
static char *orig_argv_end  ;
#line 71 "/home/ysko/Works/test-src/pies-1.2/lib/proctitle.c"
static char *proctitle_buffer  ;
#line 73
extern char *__progname ;
#line 74
extern char *__progname_full ;
#line 79 "/home/ysko/Works/test-src/pies-1.2/lib/proctitle.c"
void mf_proctitle_init(int argc , char **argv , char **env ) 
{ 
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 84
  move_env(env);
#line 86
  orig_argc = argc;
#line 87
  orig_argv = argv;
#line 88
  tmp = strlen((char const   *)*(argv + 0));
#line 88
  orig_argv_end = *(argv + 0) + tmp;
#line 89
  __progname = strrchr((char const   *)*(argv + 0), '/');
  }
#line 90
  if (__progname) {
#line 91
    __progname ++;
  } else {
#line 93
    __progname = *(argv + 0);
  }
  {
#line 94
  __progname = strdup((char const   *)__progname);
#line 96
  __progname_full = strdup((char const   *)*(argv + 0));
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < orig_argc)) {
#line 99
      goto while_break;
    }
#line 100
    if ((unsigned long )(orig_argv_end + 1) == (unsigned long )*(argv + i)) {
      {
#line 101
      tmp___0 = strlen((char const   *)*(argv + i));
#line 101
      orig_argv_end = *(argv + i) + tmp___0;
      }
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! *(env + i)) {
#line 104
      goto while_break___0;
    }
#line 105
    if ((unsigned long )(orig_argv_end + 1) == (unsigned long )*(env + i)) {
      {
#line 106
      tmp___1 = strlen((char const   *)*(env + i));
#line 106
      orig_argv_end = *(env + i) + tmp___1;
      }
    }
#line 104
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 110 "/home/ysko/Works/test-src/pies-1.2/lib/proctitle.c"
static void mf_proctitle_flush(void) 
{ 
  size_t argv_size ;
  size_t len ;
  size_t tmp ;

  {
  {
#line 121
  argv_size = (size_t )((orig_argv_end - *(orig_argv + 0)) - 2L);
#line 122
  tmp = strlen((char const   *)proctitle_buffer);
#line 122
  len = tmp;
#line 123
  memset((void *)*(orig_argv + 0), 0, argv_size);
  }
#line 124
  if (len > argv_size) {
#line 125
    len = argv_size;
  }
  {
#line 126
  memcpy((void */* __restrict  */)*(orig_argv + 0), (void const   */* __restrict  */)proctitle_buffer,
         len);
#line 127
  *(*(orig_argv + 0) + len) = (char)0;
  }
#line 136
  return;
}
}
#line 138 "/home/ysko/Works/test-src/pies-1.2/lib/proctitle.c"
void mf_proctitle_format(char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 142
  tmp = (char *)((void *)0);
#line 144
  if (! orig_argc) {
#line 145
    return;
  }
  {
#line 146
  __builtin_va_start(ap, fmt);
#line 147
  vasprintf((char **/* __restrict  */)(& tmp), (char const   */* __restrict  */)fmt,
            ap);
#line 148
  __builtin_va_end(ap);
  }
#line 149
  if (tmp) {
    {
#line 150
    free((void *)proctitle_buffer);
#line 156
    asprintf((char **/* __restrict  */)(& proctitle_buffer), (char const   */* __restrict  */)"%s: %s",
             __progname, tmp);
    }
#line 157
    if (proctitle_buffer) {
      {
#line 158
      free((void *)tmp);
      }
    } else {
#line 160
      proctitle_buffer = tmp;
    }
    {
#line 162
    mf_proctitle_flush();
    }
  }
#line 164
  return;
}
}
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 28 "/home/ysko/Works/test-src/pies-1.2/lib/parsetime.c"
static int time_multiplier(char const   *str , unsigned int *m , unsigned int *plen ) ;
#line 28 "/home/ysko/Works/test-src/pies-1.2/lib/parsetime.c"
static struct timetab tab[7]  = {      {(char *)"seconds", 1U}, 
        {(char *)"minutes", 60U}, 
        {(char *)"hours", 3600U}, 
        {(char *)"days", 86400U}, 
        {(char *)"weeks", 604800U}, 
        {(char *)"months", 18748800U}, 
        {(char *)((void *)0), 0U}};
#line 25 "/home/ysko/Works/test-src/pies-1.2/lib/parsetime.c"
static int time_multiplier(char const   *str , unsigned int *m , unsigned int *plen ) 
{ 
  struct timetab *p ;
  int slen ;
  _Bool tmp ;
  int nlen ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 43
  slen = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! *(str + slen)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tmp = c_isspace((int )*(str + slen));
    }
#line 44
    if (tmp) {
#line 45
      goto while_break;
    }
#line 43
    slen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  p = tab;
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 47
    if (! p->name) {
#line 47
      goto while_break___0;
    }
    {
#line 48
    tmp___2 = c_tolower((int )*(str + 0));
    }
#line 48
    if ((int )*(p->name + 0) == tmp___2) {
      {
#line 49
      tmp___0 = strlen((char const   *)p->name);
#line 49
      nlen = (int )tmp___0;
      }
#line 51
      if (nlen > slen) {
#line 52
        nlen = slen;
      }
      {
#line 54
      tmp___1 = strncasecmp((char const   *)p->name, str, (size_t )nlen);
      }
#line 54
      if (tmp___1 == 0) {
#line 55
        *m = p->mul;
#line 56
        if (plen) {
#line 57
          *plen = (unsigned int )nlen;
        }
#line 58
        return (0);
      }
    }
#line 47
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 62
  return (1);
}
}
#line 65 "/home/ysko/Works/test-src/pies-1.2/lib/parsetime.c"
int parse_time_interval(char const   *str , time_t *pint , char const   **endp ) 
{ 
  int rc ;
  time_t interval ;
  char *p ;
  unsigned long n ;
  unsigned int mul ;
  unsigned int len ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;

  {
#line 68
  rc = 0;
#line 69
  interval = (time_t )0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! *str) {
#line 71
      goto while_break;
    }
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if (*str) {
        {
#line 76
        tmp = c_isspace((int )*str);
        }
#line 76
        if (! tmp) {
#line 76
          goto while_break___0;
        }
      } else {
#line 76
        goto while_break___0;
      }
#line 77
      str ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 79
    tmp___2 = c_isdigit((int )*str);
    }
#line 79
    if (tmp___2) {
      _L: /* CIL Label */ 
      {
#line 83
      n = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& p),
                  10);
      }
#line 84
      if (*p) {
        {
#line 84
        tmp___0 = c_isspace((int )*p);
        }
#line 84
        if (! tmp___0) {
#line 85
          str = (char const   *)p;
#line 86
          rc = 1;
#line 87
          goto while_break;
        }
      }
      {
#line 90
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 90
        if (*p) {
          {
#line 90
          tmp___1 = c_isspace((int )*p);
          }
#line 90
          if (! tmp___1) {
#line 90
            goto while_break___1;
          }
        } else {
#line 90
          goto while_break___1;
        }
#line 91
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 93
      str = (char const   *)p;
#line 94
      if (*str) {
        {
#line 95
        rc = time_multiplier(str, & mul, & len);
        }
#line 95
        if (rc) {
#line 96
          goto while_break;
        }
#line 97
        str += len;
      } else {
#line 99
        mul = 1U;
      }
    } else {
      {
#line 79
      tmp___3 = time_multiplier(str, & mul, & len);
      }
#line 79
      if (tmp___3 == 0) {
#line 80
        n = 1UL;
#line 81
        str += len;
      } else {
#line 79
        goto _L;
      }
    }
#line 101
    interval = (time_t )((unsigned long )interval + n * (unsigned long )mul);
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (rc) {
#line 104
    if (endp) {
#line 105
      *endp = str;
    }
  }
#line 106
  *pint = interval;
#line 107
  return (rc);
}
}
#line 117 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 63 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 69
extern void endgrent(void) ;
#line 75
extern struct group___0 *getgrent(void) ;
#line 109
extern struct group___0 *getgrnam(char const   *__name ) ;
#line 178
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 684 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 687
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 693
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 709
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 719
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 726
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 736
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 327 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
void logmsg(int prio , char const   *fmt  , ...) ;
#line 369
int switch_to_privs(uid_t uid , gid_t gid , gl_list_t retain_groups ) ;
#line 371
void pies_priv_setup(struct pies_privs *privs ) ;
#line 372
void pies_epriv_setup(struct pies_privs *privs ) ;
#line 29 "/home/ysko/Works/test-src/pies-1.2/src/userprivs.c"
static _Bool str_eq(void const   *elt1 , void const   *elt2 ) 
{ 
  int tmp ;

  {
  {
#line 32
  tmp = strcmp((char const   *)elt1, (char const   *)elt2);
  }
#line 32
  return ((_Bool )(tmp == 0));
}
}
#line 35 "/home/ysko/Works/test-src/pies-1.2/src/userprivs.c"
void str_dispose(void const   *elt ) 
{ 


  {
  {
#line 38
  free((void *)elt);
  }
#line 39
  return;
}
}
#line 41 "/home/ysko/Works/test-src/pies-1.2/src/userprivs.c"
gl_list_t get_user_groups(gl_list_t init_list , char const   *user ) 
{ 
  int rc ;
  struct group___0 *gr ;
  gl_list_t list ;
  void const   *p ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp ;
  char *s ;
  char *tmp___0 ;
  gl_list_node_t tmp___1 ;
  _Bool tmp___2 ;
  char **p___0 ;
  char *s___0 ;
  char *tmp___3 ;
  gl_list_node_t tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 48
  list = gl_list_create_empty_inline(& gl_linked_list_implementation, & str_eq, (size_t (*)(void const   *elt ))((void *)0),
                                     & str_dispose, (_Bool)0);
  }
#line 54
  if (init_list) {
    {
#line 57
    tmp = gl_list_iterator_inline(init_list);
#line 57
    itr = tmp;
    }
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 58
      tmp___2 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
      }
#line 58
      if (! tmp___2) {
#line 58
        goto while_break;
      }
      {
#line 60
      tmp___0 = xstrdup((char const   *)p);
#line 60
      s = tmp___0;
#line 61
      tmp___1 = gl_list_add_last_inline(list, (void const   *)s);
      }
#line 61
      if (! tmp___1) {
        {
#line 62
        free((void *)s);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 64
    gl_list_iterator_free_inline(& itr);
    }
  }
  {
#line 67
  setgrent();
#line 68
  rc = 0;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (rc == 0) {
      {
#line 68
      gr = getgrent();
      }
#line 68
      if (! gr) {
#line 68
        goto while_break___0;
      }
    } else {
#line 68
      goto while_break___0;
    }
#line 71
    p___0 = gr->gr_mem;
    {
#line 71
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 71
      if (! *p___0) {
#line 71
        goto while_break___1;
      }
      {
#line 72
      tmp___5 = strcmp((char const   *)*p___0, user);
      }
#line 72
      if (tmp___5 == 0) {
        {
#line 74
        tmp___3 = xstrdup((char const   *)gr->gr_name);
#line 74
        s___0 = tmp___3;
#line 75
        tmp___4 = gl_list_add_last_inline(list, (void const   *)s___0);
        }
#line 75
        if (! tmp___4) {
          {
#line 76
          free((void *)s___0);
          }
        }
#line 77
        goto while_break___1;
      }
#line 71
      p___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 80
  endgrent();
  }
#line 81
  return (list);
}
}
#line 85 "/home/ysko/Works/test-src/pies-1.2/src/userprivs.c"
int switch_to_privs(uid_t uid , gid_t gid , gl_list_t retain_groups ) 
{ 
  int rc ;
  gid_t *emptygidset ;
  size_t size ;
  size_t j ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  __gid_t tmp___2 ;
  void const   *p ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp___3 ;
  struct group___0 *group ;
  struct group___0 *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  _Bool tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  __uid_t tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  __gid_t tmp___16 ;
  char *tmp___17 ;
  __gid_t tmp___18 ;
  uid_t euid ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  __uid_t tmp___23 ;
  __uid_t tmp___24 ;
  __uid_t tmp___25 ;
  __uid_t tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
#line 88
  rc = 0;
#line 90
  size = (size_t )1;
#line 90
  j = (size_t )1;
#line 93
  if (retain_groups) {
    {
#line 93
    tmp = gl_list_size_inline(retain_groups);
#line 93
    tmp___0 = tmp;
    }
  } else {
#line 93
    tmp___0 = (size_t )0;
  }
  {
#line 93
  size = 1U + tmp___0;
#line 94
  tmp___1 = xcalloc(size, (size_t )sizeof(*(emptygidset + 0)));
#line 94
  emptygidset = (gid_t *)tmp___1;
  }
#line 95
  if (gid) {
#line 95
    *(emptygidset + 0) = gid;
  } else {
    {
#line 95
    tmp___2 = getegid();
#line 95
    *(emptygidset + 0) = tmp___2;
    }
  }
#line 97
  if (retain_groups) {
    {
#line 100
    tmp___3 = gl_list_iterator_inline(retain_groups);
#line 100
    itr = tmp___3;
    }
    {
#line 101
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 101
      tmp___7 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
      }
#line 101
      if (! tmp___7) {
#line 101
        goto while_break;
      }
      {
#line 103
      tmp___4 = getgrnam((char const   *)p);
#line 103
      group = tmp___4;
      }
#line 104
      if (! group) {
        {
#line 106
        tmp___5 = gettext("unknown group: %s");
#line 106
        logmsg(3, (char const   *)tmp___5, (char const   *)p);
#line 107
        free((void *)emptygidset);
        }
#line 108
        return (1);
      }
#line 110
      tmp___6 = j;
#line 110
      j ++;
#line 110
      *(emptygidset + tmp___6) = group->gr_gid;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 112
    gl_list_iterator_free_inline(& itr);
    }
  }
  {
#line 116
  tmp___11 = geteuid();
  }
#line 116
  if (tmp___11 == 0U) {
    {
#line 116
    tmp___12 = setgroups(j, (__gid_t const   *)emptygidset);
    }
#line 116
    if (tmp___12) {
      {
#line 118
      tmp___8 = __errno_location();
#line 118
      tmp___9 = strerror(*tmp___8);
#line 118
      tmp___10 = gettext("setgroups(1, %lu) failed: %s");
#line 118
      logmsg(3, (char const   *)tmp___10, (unsigned long )*(emptygidset + 0), tmp___9);
#line 120
      rc = 1;
      }
    }
  }
  {
#line 122
  free((void *)emptygidset);
  }
#line 142
  if (rc == 0) {
#line 142
    if (gid != 0U) {
      {
#line 144
      rc = setgid(gid);
      }
#line 144
      if (rc < 0) {
        {
#line 144
        tmp___16 = getegid();
        }
#line 144
        if (tmp___16 != gid) {
          {
#line 145
          tmp___13 = __errno_location();
#line 145
          tmp___14 = strerror(*tmp___13);
#line 145
          tmp___15 = gettext("setgid(%lu) failed: %s");
#line 145
          logmsg(3, (char const   *)tmp___15, (unsigned long )gid, tmp___14);
          }
        }
      }
#line 147
      if (rc == 0) {
        {
#line 147
        tmp___18 = getegid();
        }
#line 147
        if (tmp___18 != gid) {
          {
#line 149
          tmp___17 = gettext("cannot set effective gid to %lu");
#line 149
          logmsg(3, (char const   *)tmp___17, (unsigned long )gid);
#line 151
          rc = 1;
          }
        }
      }
    }
  }
#line 156
  if (rc == 0) {
#line 156
    if (uid != 0U) {
      {
#line 160
      tmp___22 = setuid(uid);
      }
#line 160
      if (tmp___22) {
        {
#line 184
        tmp___19 = __errno_location();
#line 184
        tmp___20 = strerror(*tmp___19);
#line 184
        tmp___21 = gettext("setuid(%lu) failed: %s");
#line 184
        logmsg(3, (char const   *)tmp___21, (unsigned long )uid, tmp___20);
#line 186
        rc = 1;
        }
      } else {
        {
#line 160
        tmp___23 = geteuid();
        }
#line 160
        if (tmp___23 != uid) {
          {
#line 184
          tmp___19 = __errno_location();
#line 184
          tmp___20 = strerror(*tmp___19);
#line 184
          tmp___21 = gettext("setuid(%lu) failed: %s");
#line 184
          logmsg(3, (char const   *)tmp___21, (unsigned long )uid, tmp___20);
#line 186
          rc = 1;
          }
        } else {
          {
#line 160
          tmp___24 = getuid();
          }
#line 160
          if (tmp___24 != uid) {
            {
#line 160
            tmp___25 = geteuid();
            }
#line 160
            if (tmp___25 == 0U) {
              {
#line 184
              tmp___19 = __errno_location();
#line 184
              tmp___20 = strerror(*tmp___19);
#line 184
              tmp___21 = gettext("setuid(%lu) failed: %s");
#line 184
              logmsg(3, (char const   *)tmp___21, (unsigned long )uid, tmp___20);
#line 186
              rc = 1;
              }
            } else {
              {
#line 160
              tmp___26 = getuid();
              }
#line 160
              if (tmp___26 == 0U) {
                {
#line 184
                tmp___19 = __errno_location();
#line 184
                tmp___20 = strerror(*tmp___19);
#line 184
                tmp___21 = gettext("setuid(%lu) failed: %s");
#line 184
                logmsg(3, (char const   *)tmp___21, (unsigned long )uid, tmp___20);
#line 186
                rc = 1;
                }
              }
            }
          }
        }
      }
      {
#line 190
      euid = geteuid();
      }
#line 191
      if (uid != 0U) {
        {
#line 191
        tmp___30 = setuid((__uid_t )0);
        }
#line 191
        if (tmp___30 == 0) {
          {
#line 193
          tmp___27 = gettext("seteuid(0) succeeded when it should not");
#line 193
          logmsg(3, (char const   *)tmp___27);
#line 194
          rc = 1;
          }
        } else {
#line 191
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 196
      if (uid != euid) {
        {
#line 196
        tmp___29 = setuid(euid);
        }
#line 196
        if (tmp___29 == 0) {
          {
#line 198
          tmp___28 = gettext("cannot drop non-root setuid privileges");
#line 198
          logmsg(3, (char const   *)tmp___28);
#line 199
          rc = 1;
          }
        }
      }
    }
  }
#line 204
  return (rc);
}
}
#line 208 "/home/ysko/Works/test-src/pies-1.2/src/userprivs.c"
void pies_priv_setup(struct pies_privs *privs ) 
{ 
  struct passwd *pw ;
  gl_list_t grplist ;
  char *tmp ;
  gl_list_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 212
  grplist = (gl_list_t )0;
#line 214
  if (! privs) {
#line 215
    return;
  } else
#line 214
  if (! privs->user) {
#line 215
    return;
  }
  {
#line 217
  pw = getpwnam((char const   *)privs->user);
  }
#line 218
  if (! pw) {
    {
#line 220
    tmp = gettext("no such user: %s");
#line 220
    logmsg(3, (char const   *)tmp, privs->user);
#line 221
    exit(78);
    }
  }
#line 224
  if (privs->allgroups) {
    {
#line 225
    grplist = get_user_groups(privs->groups, (char const   *)privs->user);
    }
  }
#line 226
  if (grplist) {
#line 226
    tmp___0 = grplist;
  } else {
#line 226
    tmp___0 = privs->groups;
  }
  {
#line 226
  tmp___1 = switch_to_privs(pw->pw_uid, pw->pw_gid, tmp___0);
  }
#line 226
  if (tmp___1) {
    {
#line 228
    exit(70);
    }
  }
#line 229
  if (grplist) {
    {
#line 230
    gl_list_free_inline(grplist);
    }
  }
#line 231
  return;
}
}
#line 234 "/home/ysko/Works/test-src/pies-1.2/src/userprivs.c"
void pies_epriv_setup(struct pies_privs *privs ) 
{ 
  uid_t uid ;
  gid_t gid ;
  struct passwd *pw ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 240
  if (privs) {
#line 243
    if (! privs->user) {
#line 244
      return;
    }
    {
#line 246
    pw = getpwnam((char const   *)privs->user);
    }
#line 247
    if (! pw) {
      {
#line 249
      tmp = gettext("no such user: %s");
#line 249
      logmsg(3, (char const   *)tmp, privs->user);
#line 250
      exit(78);
      }
    }
#line 252
    uid = pw->pw_uid;
#line 253
    gid = pw->pw_gid;
  } else {
#line 257
    uid = (uid_t )0;
#line 258
    gid = (gid_t )0;
  }
  {
#line 261
  tmp___3 = setegid(gid);
  }
#line 261
  if (tmp___3) {
    {
#line 263
    tmp___0 = __errno_location();
#line 263
    tmp___1 = strerror(*tmp___0);
#line 263
    tmp___2 = gettext("cannot switch to EGID %lu: %s");
#line 263
    logmsg(3, (char const   *)tmp___2, (unsigned long )gid, tmp___1);
#line 265
    exit(64);
    }
  }
  {
#line 267
  tmp___7 = seteuid(uid);
  }
#line 267
  if (tmp___7) {
    {
#line 269
    tmp___4 = __errno_location();
#line 269
    tmp___5 = strerror(*tmp___4);
#line 269
    tmp___6 = gettext("cannot switch to EUID %lu: %s");
#line 269
    logmsg(3, (char const   *)tmp___6, (unsigned long )uid, tmp___5);
#line 271
    exit(64);
    }
  }
#line 273
  return;
}
}
#line 366 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 357 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 294 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
int pies_url_create(struct pies_url **purl , char const   *str ) ;
#line 295
void pies_url_destroy(struct pies_url **purl ) ;
#line 296
char const   *pies_url_get_arg(struct pies_url *url , char const   *argname ) ;
#line 29 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
static int alloc_string_len(char **sptr , char const   *start , size_t len ) 
{ 
  void *tmp ;

  {
  {
#line 32
  tmp = malloc(len + 1U);
#line 32
  *sptr = (char *)tmp;
  }
#line 33
  if (! *sptr) {
#line 34
    return (1);
  }
  {
#line 35
  memcpy((void */* __restrict  */)*sptr, (void const   */* __restrict  */)start, len);
#line 36
  *(*sptr + len) = (char)0;
  }
#line 37
  return (0);
}
}
#line 40 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
static int alloc_string(char **sptr , char const   *start , char const   *end ) 
{ 
  size_t len ;
  size_t tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 43
  if (end) {
#line 43
    tmp___0 = end - start;
  } else {
    {
#line 43
    tmp = strlen(start);
#line 43
    tmp___0 = (long )tmp;
    }
  }
  {
#line 43
  len = (size_t )tmp___0;
#line 44
  tmp___1 = alloc_string_len(sptr, start, len);
  }
#line 44
  return (tmp___1);
}
}
#line 47 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
static int url_parse_args(struct pies_url *url , char **str ) 
{ 
  struct wordsplit ws ;
  int tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 52
  ws.ws_delim = ";";
#line 53
  tmp = wordsplit((char const   *)*str, & ws, 8260);
  }
#line 53
  if (tmp) {
#line 54
    return (1);
  }
#line 55
  url->argc = (int )ws.ws_wordc;
#line 56
  url->argv = ws.ws_wordv;
#line 57
  return (0);
}
}
#line 60 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
static int url_parse_path(struct pies_url *url , char **str ) 
{ 
  char *p ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 65
  p = strchr((char const   *)*str, ';');
  }
#line 66
  if (! p) {
    {
#line 67
    tmp = strlen((char const   *)*str);
#line 67
    p = *str + tmp;
    }
  }
  {
#line 68
  tmp___0 = alloc_string(& url->path, (char const   *)*str, (char const   *)p);
  }
#line 68
  if (tmp___0) {
#line 69
    return (1);
  }
#line 70
  *str = p;
#line 71
  if (*p) {
#line 72
    (*str) ++;
  }
  {
#line 73
  tmp___1 = url_parse_args(url, str);
  }
#line 73
  return (tmp___1);
}
}
#line 77 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
static int url_parse_host(struct pies_url *url , char **str ) 
{ 
  char *s ;
  size_t len ;
  size_t tmp ;
  char *start ;
  char *q ;
  unsigned long n ;
  unsigned long tmp___0 ;
  char *proto ;
  char const   *tmp___1 ;
  size_t size ;
  size_t tmp___2 ;
  struct servent *serv ;
  uint16_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 80
  s = *str;
#line 81
  tmp = strcspn((char const   *)s, "/:");
#line 81
  len = tmp;
  }
#line 83
  if ((int )*(s + len) == 58) {
    {
#line 85
    start = (s + len) + 1;
#line 87
    tmp___0 = strtoul((char const   */* __restrict  */)start, (char **/* __restrict  */)(& q),
                      10);
#line 87
    n = tmp___0;
    }
#line 88
    if (n > 65535UL) {
#line 89
      return (1);
    }
#line 90
    if (*q) {
      {
#line 90
      tmp___4 = strchr("/;", (int )*q);
      }
#line 90
      if (tmp___4) {
        {
#line 105
        alloc_string_len(& url->port_s, (char const   *)start, (size_t )(q - start));
#line 106
        url->port = (int )n;
#line 107
        *str = q;
        }
      } else {
#line 92
        if (url->proto_s) {
#line 92
          tmp___1 = (char const   *)url->proto_s;
        } else {
#line 92
          tmp___1 = "tcp";
        }
        {
#line 92
        proto = (char *)tmp___1;
#line 93
        tmp___2 = strcspn((char const   *)start, "/;");
#line 93
        size = tmp___2;
#line 96
        alloc_string_len(& url->port_s, (char const   *)start, size);
#line 97
        serv = getservbyname((char const   *)url->port_s, (char const   *)proto);
        }
#line 98
        if (! serv) {
#line 99
          return (1);
        }
        {
#line 100
        tmp___3 = ntohs((uint16_t )serv->s_port);
#line 100
        url->port = (int )tmp___3;
#line 101
        *str = start + size;
        }
      }
    } else {
      {
#line 105
      alloc_string_len(& url->port_s, (char const   *)start, (size_t )(q - start));
#line 106
      url->port = (int )n;
#line 107
      *str = q;
      }
    }
  } else {
#line 111
    *str = s + len;
  }
  {
#line 112
  tmp___5 = alloc_string_len(& url->host, (char const   *)s, len);
  }
#line 112
  if (tmp___5) {
#line 113
    return (1);
  }
#line 114
  if (*(*str)) {
#line 116
    tmp___8 = *str;
#line 116
    (*str) ++;
#line 116
    if ((int )*tmp___8 == 47) {
      {
#line 117
      tmp___6 = url_parse_path(url, str);
      }
#line 117
      return (tmp___6);
    } else {
      {
#line 119
      tmp___7 = url_parse_args(url, str);
      }
#line 119
      return (tmp___7);
    }
  }
#line 121
  return (0);
}
}
#line 125 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
static int url_parse_user(struct pies_url *url , char **str ) 
{ 
  int tmp ;
  size_t len ;
  size_t tmp___0 ;
  char *p ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 128
  if ((int )*(*str) == 47) {
    {
#line 129
    tmp = url_parse_path(url, str);
    }
#line 129
    return (tmp);
  } else {
    {
#line 132
    tmp___0 = strcspn((char const   *)*str, ":;@/");
#line 132
    len = tmp___0;
#line 133
    p = *str + len;
    }
    {
#line 138
    if ((int )*p == 58) {
#line 138
      goto case_58;
    }
#line 138
    if ((int )*p == 59) {
#line 138
      goto case_58;
    }
#line 150
    if ((int )*p == 64) {
#line 150
      goto case_64;
    }
#line 135
    goto switch_break;
    case_58: /* CIL Label */ 
    case_59: /* CIL Label */ 
    {
#line 139
    len = strcspn((char const   *)(p + 1), "@/:");
    }
#line 140
    if ((int )*(p + (len + 1U)) == 64) {
      {
#line 142
      tmp___1 = alloc_string_len(& url->passwd, (char const   *)(p + 1), len);
      }
#line 142
      if (tmp___1) {
#line 143
        return (1);
      }
      {
#line 144
      tmp___2 = alloc_string(& url->user, (char const   *)*str, (char const   *)p);
      }
#line 144
      if (tmp___2) {
#line 145
        return (1);
      }
#line 146
      *str = (p + len) + 2;
    }
#line 148
    goto switch_break;
    case_64: /* CIL Label */ 
    {
#line 151
    tmp___3 = alloc_string(& url->user, (char const   *)*str, (char const   *)p);
    }
#line 151
    if (tmp___3) {
#line 152
      return (1);
    }
#line 153
    url->passwd = (char *)((void *)0);
#line 154
    *str = p + 1;
    switch_break: /* CIL Label */ ;
    }
    {
#line 156
    tmp___4 = url_parse_host(url, str);
    }
#line 156
    return (tmp___4);
  }
}
}
#line 160 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
static int url_parse_scheme(struct pies_url *url , char const   *str ) 
{ 
  size_t len ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  struct protoent *proto ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 166
  if (! str) {
    {
#line 168
    tmp = __errno_location();
#line 168
    *tmp = 22;
    }
#line 169
    return (1);
  }
  {
#line 172
  len = strcspn(str, ":+");
  }
#line 173
  if (! *(str + len)) {
    {
#line 175
    tmp___0 = __errno_location();
#line 175
    *tmp___0 = 22;
    }
#line 176
    return (1);
  }
  {
#line 179
  alloc_string_len(& url->scheme, str, len);
#line 181
  str += len;
  }
#line 183
  if ((int const   )*str == 43) {
    {
#line 187
    str ++;
#line 187
    len = strcspn(str, ":");
    }
#line 188
    if ((int const   )*(str + len) == 0) {
      {
#line 190
      tmp___1 = __errno_location();
#line 190
      *tmp___1 = 22;
      }
#line 191
      return (1);
    }
    {
#line 193
    alloc_string_len(& url->proto_s, str, len);
#line 194
    str += len;
#line 195
    proto = getprotobyname((char const   *)url->proto_s);
    }
#line 196
    if (! proto) {
      {
#line 198
      tmp___2 = __errno_location();
#line 198
      *tmp___2 = 22;
      }
#line 199
      return (1);
    }
#line 201
    url->proto = proto->p_proto;
  } else {
#line 204
    url->proto = 0;
  }
  {
#line 207
  p = (char *)str + 1;
#line 208
  tmp___4 = memcmp((void const   *)p, (void const   *)"//", (size_t )2);
  }
#line 208
  if (tmp___4) {
    {
#line 210
    tmp___3 = __errno_location();
#line 210
    *tmp___3 = 22;
    }
#line 211
    return (1);
  }
  {
#line 213
  p += 2;
#line 214
  tmp___5 = url_parse_user(url, & p);
  }
#line 214
  return (tmp___5);
}
}
#line 217 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
void pies_url_destroy(struct pies_url **purl ) 
{ 
  int i ;
  struct pies_url *url ;

  {
#line 221
  if (purl) {
#line 221
    if (*purl) {
      {
#line 223
      url = *purl;
#line 225
      free((void *)url->string);
#line 226
      free((void *)url->scheme);
#line 227
      free((void *)url->host);
#line 228
      free((void *)url->port_s);
#line 229
      free((void *)url->proto_s);
#line 230
      free((void *)url->path);
#line 231
      free((void *)url->user);
#line 232
      free((void *)url->passwd);
#line 233
      i = 0;
      }
      {
#line 233
      while (1) {
        while_continue: /* CIL Label */ ;
#line 233
        if (! (i < url->argc)) {
#line 233
          goto while_break;
        }
        {
#line 234
        free((void *)*(url->argv + i));
#line 233
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 235
      free((void *)url->argv);
#line 236
      free((void *)url);
#line 237
      *purl = (struct pies_url *)((void *)0);
      }
    }
  }
#line 239
  return;
}
}
#line 241 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
int pies_url_create(struct pies_url **purl , char const   *str ) 
{ 
  int rc ;
  struct pies_url *url ;
  void *tmp ;

  {
  {
#line 247
  tmp = malloc((size_t )sizeof(*url));
#line 247
  url = (struct pies_url *)tmp;
  }
#line 248
  if (! url) {
#line 249
    return (1);
  }
  {
#line 250
  memset((void *)url, 0, (size_t )sizeof(*url));
#line 251
  rc = url_parse_scheme(url, str);
  }
#line 252
  if (rc) {
    {
#line 253
    pies_url_destroy(& url);
    }
  } else {
    {
#line 256
    url->string = strdup(str);
#line 257
    *purl = url;
    }
  }
#line 259
  return (rc);
}
}
#line 262 "/home/ysko/Works/test-src/pies-1.2/src/url.c"
char const   *pies_url_get_arg(struct pies_url *url , char const   *argname ) 
{ 
  int i ;
  size_t arglen ;
  size_t tmp ;
  size_t len ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 266
  tmp = strlen(argname);
#line 266
  arglen = tmp;
#line 267
  i = 0;
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (i < url->argc)) {
#line 267
      goto while_break;
    }
    {
#line 269
    tmp___0 = strcspn((char const   *)*(url->argv + i), "=");
#line 269
    len = tmp___0;
    }
#line 270
    if (len == arglen) {
      {
#line 270
      tmp___1 = memcmp((void const   *)*(url->argv + i), (void const   *)argname,
                       arglen);
      }
#line 270
      if (tmp___1 == 0) {
#line 271
        return ((char const   *)((*(url->argv + i) + len) + 1));
      }
    }
#line 267
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return ((char const   *)((void *)0));
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 176
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 197
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 204
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 312 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 834 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 230 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
int progman_accept(int socket___0 ) ;
#line 298
void pies_pause(void) ;
#line 299
int register_socket(int socktype , int fd ) ;
#line 300
int pass_fd(char const   *socket_name , int fd , unsigned int maxtime ) ;
#line 301
int create_socket(struct pies_url *url , int socket_type , char const   *user , mode_t umaskval ) ;
#line 303
void disable_socket(int fd ) ;
#line 304
void enable_socket(int fd ) ;
#line 328
void logmsg_printf(int prio , char const   *fmt  , ...) ;
#line 331
unsigned int debug_level ;
#line 332
int source_info_option ;
#line 333
void debug_msg(char const   *fmt  , ...) ;
#line 19 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
static void switch_eids(uid_t *puid , gid_t *pgid , mode_t *pumask ) 
{ 
  uid_t ouid ;
  __uid_t tmp ;
  gid_t ogid ;
  __gid_t tmp___0 ;
  mode_t omask ;
  __mode_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 22
  tmp = geteuid();
#line 22
  ouid = tmp;
#line 23
  tmp___0 = getegid();
#line 23
  ogid = tmp___0;
#line 24
  tmp___1 = umask(*pumask);
#line 24
  omask = tmp___1;
#line 26
  tmp___5 = setegid(*pgid);
  }
#line 26
  if (tmp___5) {
    {
#line 27
    tmp___2 = __errno_location();
#line 27
    tmp___3 = strerror(*tmp___2);
#line 27
    tmp___4 = gettext("cannot switch to EGID %lu: %s");
#line 27
    logmsg(3, (char const   *)tmp___4, (unsigned long )*pgid, tmp___3);
    }
  }
  {
#line 29
  tmp___9 = seteuid(*puid);
  }
#line 29
  if (tmp___9) {
    {
#line 30
    tmp___6 = __errno_location();
#line 30
    tmp___7 = strerror(*tmp___6);
#line 30
    tmp___8 = gettext("cannot switch to EUID %lu: %s");
#line 30
    logmsg(3, (char const   *)tmp___8, (unsigned long )*puid, tmp___7);
    }
  }
#line 32
  *puid = ouid;
#line 33
  *pgid = ogid;
#line 34
  *pumask = omask;
#line 35
  return;
}
}
#line 37 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
int create_socket(struct pies_url *url , int socket_type , char const   *user , mode_t umaskval ) 
{ 
  int rc ;
  int fd ;
  union __anonunion_addr_69 addr ;
  socklen_t socklen ;
  uid_t uid ;
  gid_t gid ;
  int switch_back ;
  struct stat st ;
  char const   *group ;
  size_t i ;
  char const   *arg___0 ;
  size_t len ;
  size_t tmp ;
  char *p ;
  unsigned long n ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *p___0 ;
  unsigned long n___0 ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct passwd *pw ;
  struct passwd *tmp___10 ;
  char *tmp___11 ;
  struct group___0 *grp ;
  struct group___0 *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char const   *host ;
  short port ;
  struct hostent *hp ;
  struct hostent *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;
  void *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;

  {
  {
#line 50
  uid = (uid_t )0;
#line 51
  gid = (gid_t )0;
#line 54
  tmp___31 = strcmp((char const   *)url->scheme, "unix");
  }
#line 54
  if (tmp___31 == 0) {
#line 54
    goto _L;
  } else {
    {
#line 54
    tmp___32 = strcmp((char const   *)url->scheme, "file");
    }
#line 54
    if (tmp___32 == 0) {
#line 54
      goto _L;
    } else {
      {
#line 54
      tmp___33 = strcmp((char const   *)url->scheme, "socket");
      }
#line 54
      if (tmp___33 == 0) {
        _L: /* CIL Label */ 
#line 59
        group = (char const   *)((void *)0);
#line 61
        user = (char const   *)url->user;
#line 62
        if (url->argc) {
#line 65
          i = (size_t )0;
          {
#line 65
          while (1) {
            while_continue: /* CIL Label */ ;
#line 65
            if (! (i < (size_t )url->argc)) {
#line 65
              goto while_break;
            }
            {
#line 67
            arg___0 = (char const   *)*(url->argv + i);
#line 68
            tmp = strcspn(arg___0, "=");
#line 68
            len = tmp;
#line 69
            tmp___9 = strncmp(arg___0, "user", len);
            }
#line 69
            if (tmp___9 == 0) {
#line 70
              user = (arg___0 + len) + 1;
            } else {
              {
#line 71
              tmp___8 = strncmp(arg___0, "group", len);
              }
#line 71
              if (tmp___8 == 0) {
#line 72
                group = (arg___0 + len) + 1;
              } else {
                {
#line 73
                tmp___7 = strncmp(arg___0, "umask", len);
                }
#line 73
                if (tmp___7 == 0) {
                  {
#line 76
                  tmp___0 = strtoul((char const   */* __restrict  */)((arg___0 + len) + 1),
                                    (char **/* __restrict  */)(& p), 8);
#line 76
                  n = tmp___0;
                  }
#line 77
                  if (*p) {
                    {
#line 78
                    tmp___1 = gettext("%s: invalid octal number (%s)");
#line 78
                    logmsg(3, (char const   *)tmp___1, url->string, (arg___0 + len) + 1);
                    }
                  } else
#line 80
                  if (n & 0xfffffffffffffe00UL) {
                    {
#line 81
                    tmp___2 = gettext("%s: invalid umask (%s)");
#line 81
                    logmsg(3, (char const   *)tmp___2, url->string, (arg___0 + len) + 1);
                    }
                  } else {
#line 84
                    umaskval = (mode_t )(n & 511UL);
                  }
                } else {
                  {
#line 86
                  tmp___6 = strncmp(arg___0, "mode", len);
                  }
#line 86
                  if (tmp___6 == 0) {
                    {
#line 89
                    tmp___3 = strtoul((char const   */* __restrict  */)((arg___0 + len) + 1),
                                      (char **/* __restrict  */)(& p___0), 8);
#line 89
                    n___0 = tmp___3;
                    }
#line 90
                    if (*p___0) {
                      {
#line 91
                      tmp___4 = gettext("%s: invalid octal number (%s)");
#line 91
                      logmsg(3, (char const   *)tmp___4, url->string, (arg___0 + len) + 1);
                      }
                    } else
#line 93
                    if (n___0 & 0xfffffffffffffe00UL) {
                      {
#line 94
                      tmp___5 = gettext("%s: invalid mode (%s)");
#line 94
                      logmsg(3, (char const   *)tmp___5, url->string, (arg___0 + len) + 1);
                      }
                    } else {
#line 97
                      umaskval = (mode_t )(511UL & ~ n___0);
                    }
                  }
                }
              }
            }
#line 65
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 102
        if (user) {
          {
#line 104
          tmp___10 = getpwnam(user);
#line 104
          pw = tmp___10;
          }
#line 105
          if (! pw) {
            {
#line 107
            tmp___11 = gettext("no such user: %s");
#line 107
            logmsg(3, (char const   *)tmp___11, user);
            }
#line 108
            return (-1);
          }
#line 110
          uid = pw->pw_uid;
#line 111
          gid = pw->pw_gid;
        }
#line 114
        if (group) {
          {
#line 116
          tmp___12 = getgrnam(group);
#line 116
          grp = tmp___12;
          }
#line 117
          if (! grp) {
            {
#line 119
            tmp___13 = gettext("no such group: %s");
#line 119
            logmsg(3, (char const   *)tmp___13, user);
            }
#line 120
            return (-1);
          }
#line 122
          gid = grp->gr_gid;
        }
        {
#line 125
        tmp___16 = strlen((char const   *)url->path);
        }
#line 125
        if ((unsigned long )tmp___16 > sizeof(addr.s_un.sun_path)) {
          {
#line 127
          tmp___14 = __errno_location();
#line 127
          *tmp___14 = 22;
#line 128
          tmp___15 = gettext("%s: UNIX socket name too long");
#line 128
          logmsg(3, (char const   *)tmp___15, url->path);
          }
#line 129
          return (-1);
        }
        {
#line 131
        addr.sa.sa_family = (sa_family_t )1;
#line 132
        socklen = (socklen_t )sizeof(addr.s_un);
#line 133
        strcpy((char */* __restrict  */)(addr.s_un.sun_path), (char const   */* __restrict  */)url->path);
#line 134
        tmp___26 = stat((char const   */* __restrict  */)url->path, (struct stat */* __restrict  */)(& st));
        }
#line 134
        if (tmp___26) {
          {
#line 136
          tmp___20 = __errno_location();
          }
#line 136
          if (*tmp___20 != 2) {
            {
#line 138
            tmp___17 = __errno_location();
#line 138
            tmp___18 = strerror(*tmp___17);
#line 138
            tmp___19 = gettext("%s: cannot stat socket: %s");
#line 138
            logmsg(3, (char const   *)tmp___19, url->string, tmp___18);
            }
#line 140
            return (-1);
          }
        } else {
#line 146
          if (! ((st.st_mode & 61440U) == 49152U)) {
            {
#line 148
            tmp___21 = gettext("%s: not a socket");
#line 148
            logmsg(3, (char const   *)tmp___21, url->string);
            }
#line 149
            return (-1);
          }
          {
#line 151
          tmp___25 = unlink((char const   *)url->path);
          }
#line 151
          if (tmp___25) {
            {
#line 153
            tmp___22 = __errno_location();
#line 153
            tmp___23 = strerror(*tmp___22);
#line 153
            tmp___24 = gettext("%s: cannot unlink: %s");
#line 153
            logmsg(3, (char const   *)tmp___24, url->path, tmp___23);
            }
#line 155
            return (-1);
          }
        }
      } else {
        {
#line 159
        tmp___30 = strcmp((char const   *)url->scheme, "inet");
        }
#line 159
        if (tmp___30 == 0) {
#line 161
          host = (char const   *)url->host;
#line 162
          port = (short )url->port;
#line 164
          addr.sa.sa_family = (sa_family_t )2;
#line 165
          socklen = (socklen_t )sizeof(addr.s_in);
#line 167
          if (! host) {
#line 168
            addr.s_in.sin_addr.s_addr = (in_addr_t )0;
          } else {
            {
#line 171
            tmp___27 = gethostbyname(host);
#line 171
            hp = tmp___27;
            }
#line 172
            if (! hp) {
              {
#line 174
              tmp___28 = gettext("%s: unknown host name %s");
#line 174
              logmsg(3, (char const   *)tmp___28, url->string, host);
              }
#line 176
              return (-1);
            }
#line 178
            addr.sa.sa_family = (sa_family_t )hp->h_addrtype;
            {
#line 181
            if (hp->h_addrtype == 2) {
#line 181
              goto case_2;
            }
#line 186
            goto switch_default;
            case_2: /* CIL Label */ 
            {
#line 182
            memmove((void *)(& addr.s_in.sin_addr), (void const   *)*(hp->h_addr_list + 0),
                    (size_t )4);
#line 183
            addr.s_in.sin_port = htons((uint16_t )port);
            }
#line 184
            goto switch_break;
            switch_default: /* CIL Label */ 
            {
#line 187
            tmp___29 = gettext("%s: unsupported address family");
#line 187
            logmsg(3, (char const   *)tmp___29, url->string);
            }
#line 189
            return (-1);
            switch_break: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 195
          logmsg(3, "%s: unknown scheme", url->string);
          }
#line 196
          return (-1);
        }
      }
    }
  }
  {
#line 199
  fd = socket((int )addr.sa.sa_family, socket_type, url->proto);
  }
#line 200
  if (fd == -1) {
    {
#line 202
    tmp___34 = __errno_location();
#line 202
    tmp___35 = strerror(*tmp___34);
#line 202
    tmp___36 = gettext("%s: cannot create socket: %s");
#line 202
    logmsg(3, (char const   *)tmp___36, url->string, tmp___35);
    }
#line 204
    return (-1);
  }
#line 207
  rc = 1;
#line 208
  if ((int )addr.sa.sa_family != 1) {
    {
#line 208
    tmp___40 = setsockopt(fd, 1, 2, (void const   *)((void *)(& rc)), (socklen_t )sizeof(rc));
    }
#line 208
    if (tmp___40 == -1) {
      {
#line 212
      tmp___37 = __errno_location();
#line 212
      tmp___38 = strerror(*tmp___37);
#line 212
      tmp___39 = gettext("%s: set reuseaddr failed (%s)");
#line 212
      logmsg(3, (char const   *)tmp___39, url->string, tmp___38);
#line 214
      close(fd);
      }
#line 215
      return (-1);
    }
  }
#line 218
  if (uid) {
    {
#line 220
    switch_eids(& uid, & gid, & umaskval);
#line 221
    switch_back = 1;
    }
  } else
#line 218
  if (gid) {
    {
#line 220
    switch_eids(& uid, & gid, & umaskval);
#line 221
    switch_back = 1;
    }
  } else
#line 218
  if (umaskval) {
    {
#line 220
    switch_eids(& uid, & gid, & umaskval);
#line 221
    switch_back = 1;
    }
  } else {
#line 224
    switch_back = 0;
  }
  {
#line 225
  rc = bind(fd, (struct sockaddr  const  */* __restrict  */)(& addr.sa), socklen);
  }
#line 226
  if (switch_back) {
    {
#line 227
    switch_eids(& uid, & gid, & umaskval);
    }
  }
#line 228
  if (rc < 0) {
    {
#line 230
    tmp___41 = __errno_location();
#line 230
    tmp___42 = strerror(*tmp___41);
#line 230
    tmp___43 = gettext("%s: cannot bind: %s");
#line 230
    logmsg(3, (char const   *)tmp___43, url->string, tmp___42);
#line 232
    close(fd);
    }
#line 233
    return (-1);
  }
#line 235
  return (fd);
}
}
#line 238 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
static int pass_fd0(int fd , int payload ) 
{ 
  struct msghdr msg ;
  struct iovec iov[1] ;
  char control[(((sizeof(int ) + sizeof(size_t )) - 1UL) & (unsigned long )((size_t )(~ (sizeof(size_t ) - 1UL)))) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & (unsigned long )((size_t )(~ (sizeof(size_t ) - 1UL))))] ;
  struct cmsghdr *cmptr ;
  ssize_t tmp ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 255
  msg.msg_control = (void *)(control);
#line 256
  msg.msg_controllen = (size_t )((((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & (unsigned long )((size_t )(~ (sizeof(size_t ) - 1UL)))) + sizeof(int ));
#line 258
  if ((unsigned long )msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 258
    cmptr = (struct cmsghdr *)msg.msg_control;
  } else {
#line 258
    cmptr = (struct cmsghdr *)0;
  }
  {
#line 259
  cmptr->cmsg_len = (size_t )((((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & (unsigned long )((size_t )(~ (sizeof(size_t ) - 1UL)))) + sizeof(int ));
#line 260
  cmptr->cmsg_level = 1;
#line 261
  cmptr->cmsg_type = 1;
#line 262
  *((int *)(cmptr->__cmsg_data)) = payload;
#line 271
  msg.msg_name = (void *)0;
#line 272
  msg.msg_namelen = (socklen_t )0;
#line 274
  iov[0].iov_base = (void *)"";
#line 275
  iov[0].iov_len = (size_t )1;
#line 276
  msg.msg_iov = iov;
#line 277
  msg.msg_iovlen = (size_t )1;
#line 279
  tmp = sendmsg(fd, (struct msghdr  const  *)(& msg), 0);
  }
#line 279
  return (tmp == -1);
}
}
#line 286 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
static char *fds_descr[4]  = {      (char *)"init",      (char *)"open",      (char *)"connected",      (char *)"ready"};
#line 282 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
int pass_fd(char const   *socket_name , int fd , unsigned int maxtime ) 
{ 
  enum __anonenum_state_70 state ;
  time_t start ;
  time_t tmp ;
  int sockfd ;
  int res ;
  struct sockaddr_un addr ;
  char *tmp___0 ;
  size_t tmp___1 ;
  time_t now ;
  time_t tmp___2 ;
  char *tmp___3 ;
  struct stat st ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int rc ;
  fd_set fds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
#line 285
  state = (enum __anonenum_state_70 )0;
#line 287
  tmp = time((time_t *)((void *)0));
#line 287
  start = tmp;
#line 288
  sockfd = -1;
#line 289
  res = -1;
#line 292
  tmp___1 = strlen(socket_name);
  }
#line 292
  if ((unsigned long )tmp___1 > sizeof(addr.sun_path)) {
    {
#line 294
    tmp___0 = gettext("%s: UNIX socket name too long");
#line 294
    logmsg(3, (char const   *)tmp___0, socket_name);
    }
#line 295
    return (-1);
  }
  {
#line 297
  addr.sun_family = (sa_family_t )1;
#line 298
  strcpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)socket_name);
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 302
    tmp___2 = time((time_t *)((void *)0));
#line 302
    now = tmp___2;
    }
#line 304
    if (now - start > (time_t )maxtime) {
      {
#line 306
      tmp___3 = gettext("pass-fd timed out in state %s");
#line 306
      logmsg(3, (char const   *)tmp___3, fds_descr[state]);
      }
#line 308
      goto while_break;
    }
#line 311
    if ((unsigned int )state == 0U) {
      {
#line 315
      tmp___12 = stat((char const   */* __restrict  */)socket_name, (struct stat */* __restrict  */)(& st));
      }
#line 315
      if (tmp___12 == 0) {
#line 317
        if (! ((st.st_mode & 61440U) == 49152U)) {
          {
#line 319
          tmp___4 = gettext("%s: not a socket");
#line 319
          logmsg(3, (char const   *)tmp___4, socket_name);
          }
#line 320
          goto while_break;
        }
        {
#line 323
        sockfd = socket(1, 1, 0);
        }
#line 324
        if (sockfd == -1) {
          {
#line 326
          tmp___5 = __errno_location();
          }
#line 326
          if (*tmp___5 == 4) {
#line 327
            goto __Cont;
          }
          {
#line 328
          tmp___6 = __errno_location();
#line 328
          tmp___7 = strerror(*tmp___6);
#line 328
          logmsg(3, "socket: %s", tmp___7);
          }
#line 329
          goto while_break;
        }
#line 331
        state = (enum __anonenum_state_70 )1;
      } else {
        {
#line 333
        tmp___11 = __errno_location();
        }
#line 333
        if (*tmp___11 != 2) {
          {
#line 335
          tmp___8 = __errno_location();
#line 335
          tmp___9 = strerror(*tmp___8);
#line 335
          tmp___10 = gettext("cannot stat %s: %s");
#line 335
          logmsg(3, (char const   *)tmp___10, socket_name, tmp___9);
          }
#line 337
          goto while_break;
        }
      }
    }
#line 341
    if ((unsigned int )state == 1U) {
      {
#line 343
      tmp___17 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
                         (socklen_t )sizeof(addr));
      }
#line 343
      if (tmp___17) {
        {
#line 345
        tmp___13 = __errno_location();
        }
        {
#line 349
        if (*tmp___13 == 11) {
#line 349
          goto case_11;
        }
#line 349
        if (*tmp___13 == 111) {
#line 349
          goto case_11;
        }
#line 349
        if (*tmp___13 == 4) {
#line 349
          goto case_11;
        }
#line 345
        goto switch_break;
        case_11: /* CIL Label */ 
        case_111: /* CIL Label */ 
        case_4: /* CIL Label */ 
#line 350
        goto __Cont;
        switch_break: /* CIL Label */ ;
        }
        {
#line 352
        tmp___14 = __errno_location();
#line 352
        tmp___15 = strerror(*tmp___14);
#line 352
        tmp___16 = gettext("%s: connect failed: %s");
#line 352
        logmsg(3, (char const   *)tmp___16, socket_name, tmp___15);
        }
#line 354
        goto while_break;
      }
#line 356
      state = (enum __anonenum_state_70 )2;
    }
#line 359
    if ((unsigned int )state == 2U) {
      {
#line 365
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 365
        __asm__  volatile   ("cld; rep; "
                             "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fds.fds_bits[0]): "memory");
#line 365
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 366
      __asm__  volatile   ("btsl"
                           " %1,%0": "=m" (fds.fds_bits[(unsigned long )sockfd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )sockfd % (8UL * sizeof(__fd_mask ))): "cc",
                           "memory");
#line 367
      tv.tv_usec = (__suseconds_t )0;
#line 368
      tv.tv_sec = (time_t )maxtime - (now - start);
#line 369
      rc = select(sockfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& fds),
                  (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 370
      if (rc == 0) {
#line 371
        goto __Cont;
      }
#line 372
      if (rc < 0) {
        {
#line 374
        tmp___18 = __errno_location();
        }
#line 374
        if (*tmp___18 == 4) {
#line 375
          goto __Cont;
        }
        {
#line 376
        tmp___19 = __errno_location();
#line 376
        tmp___20 = strerror(*tmp___19);
#line 376
        tmp___21 = gettext("select failed: %s");
#line 376
        logmsg(3, (char const   *)tmp___21, tmp___20);
        }
#line 377
        goto while_break;
      }
#line 379
      state = (enum __anonenum_state_70 )3;
    }
#line 382
    if ((unsigned int )state == 3U) {
      {
#line 384
      res = pass_fd0(sockfd, fd);
      }
#line 385
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (sockfd >= 0) {
    {
#line 390
    close(sockfd);
    }
  }
#line 391
  return (res);
}
}
#line 395 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
fd_set listenset  ;
#line 396 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
int fd_max  ;
#line 398 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
int register_socket(int socktype , int fd ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 401
  if (socktype == 1) {
    {
#line 401
    tmp___1 = listen(fd, 8);
    }
#line 401
    if (tmp___1 == -1) {
      {
#line 403
      tmp = __errno_location();
#line 403
      tmp___0 = strerror(*tmp);
#line 403
      logmsg(3, "listen: %s", tmp___0);
      }
#line 404
      return (1);
    }
  }
#line 406
  __asm__  volatile   ("btsl"
                       " %1,%0": "=m" (listenset.fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 407
  if (fd > fd_max) {
#line 408
    fd_max = fd;
  }
#line 409
  return (0);
}
}
#line 412 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
void disable_socket(int fd ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 415
  if (fd < 0) {
#line 416
    return;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (debug_level >= 2U) {
#line 417
      if (source_info_option) {
        {
#line 417
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/socket.c",
                      417, "disable_socket");
        }
      }
      {
#line 417
      tmp = gettext("disabling fd %d");
#line 417
      debug_msg((char const   *)tmp, fd);
      }
    }
#line 417
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  __asm__  volatile   ("btrl"
                       " %1,%0": "=m" (listenset.fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 419
  return;
}
}
#line 421 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
void enable_socket(int fd ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 424
  if (fd < 0) {
#line 425
    return;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (debug_level >= 2U) {
#line 426
      if (source_info_option) {
        {
#line 426
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/socket.c",
                      426, "enable_socket");
        }
      }
      {
#line 426
      tmp = gettext("enabling fd %d");
#line 426
      debug_msg((char const   *)tmp, fd);
      }
    }
#line 426
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  __asm__  volatile   ("btsl"
                       " %1,%0": "=m" (listenset.fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 428
  return;
}
}
#line 430 "/home/ysko/Works/test-src/pies-1.2/src/socket.c"
void pies_pause(void) 
{ 
  fd_set rdset ;
  int rc ;
  int tmp ;
  int i ;
  register char __result ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    rdset = listenset;
#line 436
    tmp = select(fd_max + 1, (fd_set */* __restrict  */)(& rdset), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
#line 436
    rc = tmp;
    }
#line 437
    if (rc > 0) {
#line 440
      i = 0;
      {
#line 440
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 440
        if (! (i <= fd_max)) {
#line 440
          goto while_break___0;
        }
#line 442
        __asm__  volatile   ("btl"
                             " %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned long )i % (8UL * sizeof(__fd_mask ))),
                             "m" (rdset.fds_bits[(unsigned long )i / (8UL * sizeof(__fd_mask ))]): "cc");
#line 442
        if (__result) {
          {
#line 443
          progman_accept(i);
          }
        }
#line 440
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 445
      goto while_break;
    } else
#line 447
    if (rc < 0) {
      {
#line 449
      tmp___2 = __errno_location();
      }
#line 449
      if (*tmp___2 != 4) {
        {
#line 450
        tmp___0 = __errno_location();
#line 450
        tmp___1 = strerror(*tmp___0);
#line 450
        logmsg(3, "select: %s", tmp___1);
        }
      }
#line 451
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  return;
}
}
#line 119 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 126 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 138
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 136 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 157 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 429
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 469
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 493
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 558
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execv)(char const   *__path ,
                                                                                  char * const  *__argv ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execvp)(char const   *__file ,
                                                                                   char * const  *__argv ) ;
#line 590
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 606
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 615
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 181 "/usr/include/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 237 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 29 "/home/ysko/Works/test-src/pies-1.2/src/acl.h"
int pies_acl_check(pies_acl_t acl , struct acl_input *input , int result ) ;
#line 62 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *ngettext(char const   *__msgid1 , char const   *__msgid2 ,
                                                    unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 207 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
char *log_tag ;
#line 209
unsigned long shutdown_timeout ;
#line 210
struct component default_component ;
#line 211
pies_acl_t pies_acl ;
#line 212
limits_record_t pies_limits ;
#line 213
char *mailer_program ;
#line 215
int mailer_argc ;
#line 216
char **mailer_argv ;
#line 217
size_t default_max_rate ;
#line 220
void register_prog(struct component *comp ) ;
#line 221
size_t progman_running_count(void) ;
#line 222
void progman_start(void) ;
#line 223
void progman_wake_sleeping(int onalrm ) ;
#line 224
void progman_stop(void) ;
#line 225
void progman_cleanup(int expect_term ) ;
#line 226
void progman_stop_component(char const   *name ) ;
#line 227
void progman_dump_stats(char const   *filename ) ;
#line 228
void progman_dump_prereq(void) ;
#line 229
void progman_dump_depmap(void) ;
#line 231
int progman_build_depmap(void) ;
#line 232
void progman_create_sockets(void) ;
#line 233
struct component *progman_lookup_component(char const   *tag ) ;
#line 234
struct component *progman_lookup_tcpmux(char const   *service , char const   *master ) ;
#line 237
void progman_run_comp(struct component *comp , int fd , union pies_sockaddr_storage *sa ,
                      socklen_t salen ) ;
#line 240
void progman_iterate_comp(int (*fun)(struct component * , void * ) , void *data ) ;
#line 243
int check_acl(pies_acl_t acl , struct sockaddr *s , socklen_t salen ) ;
#line 246
void signal_setup(void (*sf)(int  ) ) ;
#line 256
pies_depmap_t depmap_alloc(size_t count ) ;
#line 257
pies_depmap_t depmap_copy(pies_depmap_t dpm ) ;
#line 258
void depmap_set(pies_depmap_t dmap , size_t row , size_t col ) ;
#line 259
int depmap_isset(pies_depmap_t dmap , size_t row , size_t col ) ;
#line 260
void depmap_tc(pies_depmap_t dmap ) ;
#line 261
size_t depmap_first(pies_depmap_t dmap , enum pies_depmap_direction dir , size_t coord ,
                    pies_depmap_pos_t *ppos ) ;
#line 263
size_t depmap_next(pies_depmap_t dmap , pies_depmap_pos_t pos ) ;
#line 269
int socket_type_to_str(int socket_type , char const   **pres ) ;
#line 308
int set_limits(char const   *name , struct limits_rec *lrec ) ;
#line 321
int diag_output ;
#line 325
void diag_setup(int flags ) ;
#line 357
char *meta_expand_string(char const   *string , struct metadef *def , void *data ) ;
#line 365
char *sockaddr_to_astr(struct sockaddr  const  *sa , int salen ) ;
#line 78 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static size_t numcomp  ;
#line 79 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static struct prog *proghead  ;
#line 79 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static struct prog *progtail  ;
#line 80 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static pies_depmap_t depmap  ;
#line 81 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int recompute_alarm  ;
#line 83 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_iterate_comp(int (*fun)(struct component * , void * ) , void *data ) 
{ 
  struct prog *prog ;
  int tmp ;

  {
#line 88
  prog = proghead;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! prog) {
#line 88
      goto while_break;
    }
#line 89
    if ((unsigned int )prog->type == 0U) {
#line 89
      if ((unsigned int )(prog->v.p.comp)->mode == 2U) {
#line 89
        if (! prog->v.p.listener) {
#line 89
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 89
        tmp = (*fun)(prog->v.p.comp, data);
        }
#line 89
        if (tmp) {
#line 93
          goto while_break;
        }
      }
    }
#line 88
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 96 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static struct prog *prog_lookup_by_pid(pid_t pid ) 
{ 
  struct prog *prog ;

  {
#line 101
  prog = proghead;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! prog) {
#line 101
      goto while_break;
    }
#line 102
    if (prog->pid == pid) {
#line 103
      goto while_break;
    }
#line 101
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (prog);
}
}
#line 107 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static struct prog *prog_lookup_by_socket(int fd ) 
{ 
  struct prog *prog ;

  {
#line 112
  prog = proghead;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! prog) {
#line 112
      goto while_break;
    }
#line 113
    if ((unsigned int )prog->type == 0U) {
#line 113
      if (prog->v.p.socket == fd) {
#line 114
        goto while_break;
      }
    }
#line 112
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (prog);
}
}
#line 118 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
struct prog *prog_lookup_by_tag(char const   *tag ) 
{ 
  struct prog *prog ;
  int tmp ;

  {
#line 122
  prog = proghead;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! prog) {
#line 122
      goto while_break;
    }
    {
#line 123
    tmp = strcmp((char const   *)prog->tag, tag);
    }
#line 123
    if (tmp == 0) {
#line 124
      goto while_break;
    }
#line 122
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (prog);
}
}
#line 128 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
struct prog *prog_lookup_by_service(char const   *service ) 
{ 
  struct prog *prog ;
  int tmp ;

  {
#line 132
  prog = proghead;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! prog) {
#line 132
      goto while_break;
    }
#line 133
    if ((unsigned int )prog->type == 0U) {
#line 133
      if ((prog->v.p.comp)->service) {
        {
#line 133
        tmp = strcmp((char const   *)(prog->v.p.comp)->service, service);
        }
#line 133
        if (tmp == 0) {
#line 136
          goto while_break;
        }
      }
    }
#line 132
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return (prog);
}
}
#line 140 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
struct component *progman_lookup_component(char const   *tag ) 
{ 
  struct prog *prog ;
  int tmp ;

  {
#line 144
  prog = proghead;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! prog) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned int )prog->type == 0U) {
      {
#line 145
      tmp = strcmp((char const   *)prog->tag, tag);
      }
#line 145
      if (tmp == 0) {
#line 146
        return (prog->v.p.comp);
      }
    }
#line 144
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return ((struct component *)((void *)0));
}
}
#line 150 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
struct component *progman_lookup_tcpmux(char const   *service , char const   *master ) 
{ 
  struct prog *prog ;
  int tmp ;
  int tmp___0 ;

  {
#line 154
  prog = proghead;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! prog) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned int )prog->type == 0U) {
#line 155
      if ((prog->v.p.comp)->flags & 24) {
#line 155
        if (! ((prog->v.p.comp)->flags & 1)) {
#line 155
          if ((prog->v.p.comp)->service) {
            {
#line 155
            tmp = strcasecmp((char const   *)(prog->v.p.comp)->service, service);
            }
#line 155
            if (tmp == 0) {
#line 155
              if ((prog->v.p.comp)->tcpmux) {
                {
#line 155
                tmp___0 = strcmp((char const   *)(prog->v.p.comp)->tcpmux, master);
                }
#line 155
                if (tmp___0 == 0) {
#line 162
                  return (prog->v.p.comp);
                }
              }
            }
          }
        }
      }
    }
#line 154
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return ((struct component *)((void *)0));
}
}
#line 166 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
struct prog *prog_lookup_by_idx(unsigned int idx ) 
{ 
  struct prog *prog ;

  {
#line 170
  prog = proghead;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! prog) {
#line 170
      goto while_break;
    }
#line 171
    if ((unsigned int )prog->type == 0U) {
#line 171
      if (prog->v.p.idx == idx) {
#line 172
        goto while_break;
      }
    }
#line 170
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (prog);
}
}
#line 176
static void prog_stop(struct prog *prog , int sig ) ;
#line 177
static int prog_start_prerequisites(struct prog *prog ) ;
#line 179 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void link_prog(struct prog *pp , int prepend ) 
{ 


  {
#line 182
  if (prepend) {
#line 184
    if (proghead) {
#line 185
      proghead->prev = pp;
    }
#line 186
    pp->prev = (struct prog *)((void *)0);
#line 187
    pp->next = proghead;
#line 188
    proghead = pp;
#line 189
    if (! progtail) {
#line 190
      progtail = pp;
    }
  } else {
#line 194
    pp->next = (struct prog *)((void *)0);
#line 195
    pp->prev = progtail;
#line 196
    if (progtail) {
#line 197
      progtail->next = pp;
    } else {
#line 199
      proghead = pp;
    }
#line 200
    progtail = pp;
  }
#line 202
  return;
}
}
#line 204 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void unlink_prog(struct prog *pp ) 
{ 
  struct prog *x ;

  {
#line 208
  x = pp->prev;
#line 208
  if (x) {
#line 209
    x->next = pp->next;
  } else {
#line 211
    proghead = pp->next;
  }
#line 212
  x = pp->next;
#line 212
  if (x) {
#line 213
    x->prev = pp->prev;
  } else {
#line 215
    progtail = pp->prev;
  }
#line 216
  return;
}
}
#line 218 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void destroy_prog(struct prog **pp ) 
{ 
  struct prog *p ;
  struct prog *master ;

  {
#line 221
  p = *pp;
  {
#line 224
  if ((unsigned int )p->type == 0U) {
#line 224
    goto case_0;
  }
#line 227
  if ((unsigned int )p->type == 1U) {
#line 227
    goto case_1;
  }
#line 239
  if ((unsigned int )p->type == 2U) {
#line 239
    goto case_2;
  }
#line 222
  goto switch_break;
  case_0: /* CIL Label */ 
#line 225
  goto switch_break;
  case_1: /* CIL Label */ 
#line 229
  master = p->v.r.master;
#line 230
  if ((unsigned long )p == (unsigned long )master->v.p.redir[0]) {
#line 231
    master->v.p.redir[0] = (struct prog *)((void *)0);
  } else
#line 232
  if ((unsigned long )p == (unsigned long )master->v.p.redir[1]) {
#line 233
    master->v.p.redir[1] = (struct prog *)((void *)0);
  }
#line 237
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 240
  free((void *)p->v.c.command);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 242
  unlink_prog(*pp);
#line 243
  free((void *)*pp);
#line 244
  *pp = (struct prog *)((void *)0);
  }
#line 245
  return;
}
}
#line 250
static char *redir_tag(struct prog *master , int type ) ;
#line 250 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static char *redirstr[2]  = {      (char *)"stdout",      (char *)"stderr"};
#line 247 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static char *redir_tag(struct prog *master , int type ) 
{ 
  char *str ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 252
  if ((unsigned long )type < sizeof(redirstr) / sizeof(redirstr[0])) {
    {
#line 253
    str = xasprintf("%s/%s", master->tag, redirstr[type]);
    }
  } else {
    {
#line 255
    str = xasprintf("%s/%d", master->tag, type);
    }
  }
#line 256
  return (str);
}
}
#line 259 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static struct prog *register_redir(int type , struct prog *master ) 
{ 
  char *tag ;
  char *tmp ;
  char *pstr ;
  struct prog *pp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 262
  tmp = redir_tag(master, type);
#line 262
  tag = tmp;
#line 264
  tmp___0 = strlen((char const   *)tag);
#line 264
  tmp___1 = xzalloc((size_t )(((sizeof(*pp) + (unsigned long )tmp___0) + 1UL) + 2UL * sizeof(char **)));
#line 264
  pp = (struct prog *)tmp___1;
#line 267
  pp->type = (enum prog_type )1;
#line 268
  pstr = (char *)(pp + 1);
#line 269
  pp->tag = pstr;
#line 270
  strcpy((char */* __restrict  */)pp->tag, (char const   */* __restrict  */)tag);
#line 271
  tmp___2 = strlen((char const   *)pp->tag);
#line 271
  pstr += tmp___2 + 1U;
#line 272
  free((void *)tag);
#line 273
  pp->v.r.master = master;
#line 274
  pp->prereq = (char **)pstr;
#line 275
  *(pp->prereq + 0) = master->tag;
#line 276
  *(pp->prereq + 1) = (char *)((void *)0);
#line 277
  link_prog(pp, 1);
  }
#line 278
  return (pp);
}
}
#line 281 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void update_redir(int type , struct prog *master , pid_t pid ) 
{ 
  struct prog *pp ;

  {
#line 285
  if (master->v.p.redir[type]) {
    {
#line 287
    pp = master->v.p.redir[type];
#line 288
    prog_stop(pp, 9);
    }
  }
  {
#line 291
  pp = register_redir(type, master);
#line 292
  master->v.p.redir[type] = pp;
#line 293
  pp->pid = pid;
  }
#line 294
  return;
}
}
#line 296 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static struct prog *register_prog0(struct component *comp , unsigned int index___0 ) 
{ 
  struct prog *newp ;
  void *tmp ;

  {
  {
#line 301
  tmp = xzalloc((size_t )sizeof(*newp));
#line 301
  newp = (struct prog *)tmp;
#line 302
  newp->type = (enum prog_type )0;
#line 303
  newp->tag = comp->tag;
#line 304
  newp->pid = 0;
#line 305
  newp->facility = comp->facility;
#line 306
  newp->v.p.comp = comp;
#line 307
  newp->v.p.idx = index___0;
#line 308
  newp->v.p.socket = -1;
  }
#line 309
  if (comp->flags & 1) {
#line 310
    newp->v.p.status = (enum prog_status )1;
  } else
#line 311
  if ((unsigned int )comp->mode == 2U) {
#line 312
    newp->v.p.status = (enum prog_status )2;
  }
#line 314
  if ((unsigned int )comp->mode != 0U) {
#line 315
    comp->redir[0].type = (enum redir_type )0;
  }
  {
#line 317
  link_prog(newp, 0);
  }
#line 318
  return (newp);
}
}
#line 321 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void register_prog(struct component *comp ) 
{ 
  size_t tmp ;

  {
  {
#line 324
  tmp = numcomp;
#line 324
  numcomp ++;
#line 324
  register_prog0(comp, tmp);
  }
#line 325
  return;
}
}
#line 327 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void register_command(char *tag , char *command___0 , pid_t pid ) 
{ 
  struct prog *newp ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 330
  tmp = xzalloc((size_t )sizeof(*newp));
#line 330
  newp = (struct prog *)tmp;
#line 331
  tmp___0 = xzalloc((size_t )sizeof(*newp));
#line 331
  newp = (struct prog *)tmp___0;
#line 332
  newp->type = (enum prog_type )2;
#line 333
  newp->tag = tag;
#line 334
  newp->pid = pid;
#line 335
  newp->v.c.command = command___0;
#line 336
  link_prog(newp, 0);
  }
#line 337
  return;
}
}
#line 339 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void prog_rebuild_prerequisites(struct prog *prog ) 
{ 
  struct component *comp ;
  struct prog *p ;
  int dep_all ;
  size_t depc ;
  char const   *item ;
  void const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void const   *p___0 ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp___4 ;
  size_t tmp___5 ;
  _Bool tmp___6 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 342
  comp = prog->v.p.comp;
#line 344
  dep_all = 0;
#line 345
  depc = (size_t )0;
#line 347
  if (comp->prereq) {
    {
#line 349
    depc = gl_list_size_inline(comp->prereq);
    }
#line 350
    if (depc == 1U) {
      {
#line 352
      tmp = gl_list_get_at_inline(comp->prereq, (size_t )0);
#line 352
      item = (char const   *)tmp;
#line 353
      tmp___1 = strcmp(item, "all");
      }
#line 353
      if (tmp___1 == 0) {
#line 355
        dep_all = 1;
#line 356
        p = proghead;
        {
#line 356
        while (1) {
          while_continue: /* CIL Label */ ;
#line 356
          if (! p) {
#line 356
            goto while_break;
          }
#line 357
          if ((unsigned int )p->type == 0U) {
#line 358
            depc ++;
          }
#line 356
          p = p->next;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
        {
#line 360
        tmp___0 = strcmp(item, "none");
        }
#line 360
        if (tmp___0 == 0) {
          {
#line 362
          gl_list_free_inline(comp->prereq);
#line 363
          comp->prereq = (gl_list_t )((void *)0);
          }
        }
      }
    }
  }
#line 368
  if (depc == 0U) {
#line 369
    return;
  }
  {
#line 371
  tmp___2 = xcalloc(depc + 1U, (size_t )sizeof(*(prog->prereq + 0)));
#line 371
  prog->prereq = (char **)tmp___2;
#line 373
  depc = (size_t )0;
  }
#line 374
  if (comp->prereq) {
#line 376
    if (dep_all) {
#line 378
      p = proghead;
      {
#line 378
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 378
        if (! p) {
#line 378
          goto while_break___0;
        }
#line 379
        if ((unsigned int )p->type == 0U) {
#line 380
          tmp___3 = depc;
#line 380
          depc ++;
#line 380
          *(prog->prereq + tmp___3) = p->tag;
        }
#line 378
        p = p->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 385
      tmp___4 = gl_list_iterator_inline(comp->prereq);
#line 385
      itr = tmp___4;
      }
      {
#line 386
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 386
        tmp___6 = gl_list_iterator_next_inline(& itr, & p___0, (gl_list_node_t *)((void *)0));
        }
#line 386
        if (! tmp___6) {
#line 386
          goto while_break___1;
        }
#line 388
        tmp___5 = depc;
#line 388
        depc ++;
#line 388
        *(prog->prereq + tmp___5) = (char *)p___0;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 390
      gl_list_iterator_free_inline(& itr);
      }
    }
  }
#line 393
  *(prog->prereq + depc) = (char *)((void *)0);
#line 394
  return;
}
}
#line 396 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
size_t progman_running_count(void) 
{ 
  size_t size ;
  struct prog *prog ;

  {
#line 399
  size = (size_t )0;
#line 402
  prog = proghead;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! prog) {
#line 402
      goto while_break;
    }
#line 403
    if (prog->pid > 0) {
#line 404
      size ++;
    }
#line 402
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return (size);
}
}
#line 408 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void redir_exit(int sig ) 
{ 


  {
  {
#line 411
  _exit(0);
  }
}
}
#line 414 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
int redirect_to_file(struct prog *master , int stream ) 
{ 
  struct passwd *pw ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 418
  tmp = open((char const   *)(master->v.p.comp)->redir[stream].v.file, 66, 420U & ~ (master->v.p.comp)->umask);
#line 418
  fd = tmp;
  }
#line 420
  if (fd == -1) {
    {
#line 422
    tmp___0 = __errno_location();
#line 422
    tmp___1 = strerror(*tmp___0);
#line 422
    tmp___2 = gettext("cannot open output file %s: %s");
#line 422
    logmsg(3, (char const   *)tmp___2, (master->v.p.comp)->redir[stream].v.file, tmp___1);
    }
#line 425
    return (-1);
  }
#line 428
  if ((master->v.p.comp)->privs.user) {
    {
#line 428
    pw = getpwnam((char const   *)(master->v.p.comp)->privs.user);
    }
#line 428
    if ((unsigned long )pw != (unsigned long )((void *)0)) {
      {
#line 430
      chown((char const   *)(master->v.p.comp)->redir[stream].v.file, pw->pw_uid,
            pw->pw_gid);
      }
    }
  }
#line 431
  return (fd);
}
}
#line 434 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void close_fds(fd_set *fdset ) 
{ 
  int i ;
  long tmp ;
  register char __result ;

  {
  {
#line 439
  tmp = sysconf(4);
#line 439
  i = (int )tmp;
  }
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! (i >= 0)) {
#line 439
      goto while_break;
    }
#line 441
    if (fdset) {
#line 441
      __asm__  volatile   ("btl"
                           " %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned long )i % (8UL * sizeof(__fd_mask ))),
                           "m" (fdset->fds_bits[(unsigned long )i / (8UL * sizeof(__fd_mask ))]): "cc");
#line 441
      if (__result) {
#line 442
        goto __Cont;
      }
    }
    {
#line 443
    close(i);
    }
    __Cont: /* CIL Label */ 
#line 439
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return;
}
}
#line 447 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
int open_redirector(struct prog *master , int stream ) 
{ 
  int p[2] ;
  FILE *fp ;
  char *buf ;
  size_t size ;
  pid_t pid ;
  int prio ;
  char *tag ;
  fd_set fdset ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  __ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 452
  buf = (char *)((void *)0);
#line 453
  size = (size_t )0;
  {
#line 461
  if ((unsigned int )(master->v.p.comp)->redir[stream].type == 0U) {
#line 461
    goto case_0;
  }
#line 464
  if ((unsigned int )(master->v.p.comp)->redir[stream].type == 2U) {
#line 464
    goto case_2;
  }
#line 467
  if ((unsigned int )(master->v.p.comp)->redir[stream].type == 1U) {
#line 467
    goto case_1;
  }
#line 459
  goto switch_break;
  case_0: /* CIL Label */ 
#line 462
  return (-1);
  case_2: /* CIL Label */ 
  {
#line 465
  tmp = redirect_to_file(master, stream);
  }
#line 465
  return (tmp);
  case_1: /* CIL Label */ 
#line 468
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 471
  pipe((int *)(p));
#line 472
  pid = fork();
  }
  {
#line 474
  if (pid == 0) {
#line 474
    goto case_0___0;
  }
#line 497
  if (pid == -1) {
#line 497
    goto case_neg_1;
  }
#line 503
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 476
  tag = redir_tag(master, stream);
#line 477
  mf_proctitle_format("%s redirector", tag);
#line 478
  free((void *)tag);
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.fds_bits[0]): "memory");
#line 480
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 481
  __asm__  volatile   ("btsl"
                       " %1,%0": "=m" (fdset.fds_bits[(unsigned long )p[0] / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )p[0] % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 482
  close_fds(& fdset);
#line 484
  diag_setup(0);
#line 485
  signal_setup(& redir_exit);
#line 487
  close(p[1]);
#line 488
  fp = fdopen(p[0], "r");
  }
#line 489
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 490
    _exit(1);
    }
  }
  {
#line 491
  openlog((char const   *)master->tag, 1, master->facility);
#line 492
  prio = (master->v.p.comp)->redir[stream].v.prio;
  }
  {
#line 493
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 493
    tmp___0 = (__ssize_t )getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& size),
                                  (FILE */* __restrict  */)fp);
    }
#line 493
    if (! (tmp___0 > 0)) {
#line 493
      goto while_break___0;
    }
    {
#line 494
    syslog(prio, "%s", buf);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 495
  _exit(0);
  }
  case_neg_1: /* CIL Label */ 
  {
#line 498
  tmp___1 = __errno_location();
#line 498
  tmp___2 = strerror(*tmp___1);
#line 498
  tmp___3 = gettext("cannot run redirector `%s\': fork failed: %s");
#line 498
  logmsg(2, (char const   *)tmp___3, master->tag, tmp___2);
  }
#line 501
  return (-1);
  switch_default: /* CIL Label */ 
  {
#line 504
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 504
    if (debug_level >= 1U) {
#line 504
      if (source_info_option) {
        {
#line 504
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      505, "open_redirector");
        }
      }
      {
#line 504
      tmp___4 = gettext("redirector for %s started, pid=%lu");
#line 504
      debug_msg((char const   *)tmp___4, master->tag, (unsigned long )pid);
      }
    }
#line 504
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 506
  update_redir(stream, master, pid);
#line 507
  close(p[0]);
  }
#line 508
  return (p[1]);
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 514 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static size_t envsize  ;
#line 526 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static char *sockenv_hint[9]  = 
#line 526
  {      (char *)"-PROTO",      (char *)"-SOCKTYPE",      (char *)"-LOCALIP",      (char *)"-LOCALPORT", 
        (char *)"-LOCALHOST",      (char *)"-REMOTEIP",      (char *)"-REMOTEPORT",      (char *)"-REMOTEHOST", 
        (char *)((void *)0)};
#line 550 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void add_env(char const   *name , char const   *value ) 
{ 
  size_t i ;
  size_t namelen ;
  size_t tmp ;
  char *p ;
  int tmp___0 ;
  char **new_env ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp14 ;

  {
  {
#line 554
  tmp = strlen(name);
#line 554
  namelen = tmp;
#line 557
  i = (size_t )0;
  }
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! *(environ + i)) {
#line 557
      goto while_break;
    }
    {
#line 559
    tmp___0 = strncmp((char const   *)*(environ + i), name, namelen);
    }
#line 559
    if (! tmp___0) {
#line 559
      if ((int )*(*(environ + i) + namelen) == 61) {
#line 560
        goto while_break;
      }
    }
#line 557
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  if ((unsigned long )*(environ + i) == (unsigned long )((void *)0)) {
#line 565
    if (envsize == 0U) {
      {
#line 569
      envsize = i + 4U;
#line 570
      tmp___1 = xcalloc(envsize, (size_t )sizeof(*(new_env + 0)));
#line 570
      new_env = (char **)tmp___1;
#line 571
      i = (size_t )0;
      }
      {
#line 571
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 571
        tmp___2 = *(environ + i);
#line 571
        *(new_env + i) = tmp___2;
#line 571
        if (! tmp___2) {
#line 571
          goto while_break___0;
        }
#line 571
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 573
      environ = new_env;
    } else
#line 575
    if (i == envsize) {
      {
#line 577
      envsize += 4U;
#line 578
      tmp___3 = xrealloc((void *)environ, (size_t )((unsigned long )envsize * sizeof(*(environ + 0))));
#line 578
      environ = (char **)tmp___3;
      }
    }
#line 581
    *(environ + (i + 1U)) = (char *)((void *)0);
  }
#line 584
  if (! value) {
#line 585
    value = "";
  }
  {
#line 586
  tmp___4 = strlen(value);
#line 586
  tmp___5 = xmalloc(((namelen + 1U) + tmp___4) + 1U);
#line 586
  p = (char *)tmp___5;
#line 587
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)name);
#line 588
  *(p + namelen) = (char )'=';
#line 589
  strcpy((char */* __restrict  */)((p + namelen) + 1), (char const   */* __restrict  */)value);
#line 590
  *(environ + i) = p;
  }
#line 591
  return;
}
}
#line 593 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static char *find_env(char const   *name , int val ) 
{ 
  int nlen ;
  size_t tmp ;
  int i ;
  size_t elen ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 596
  if (environ) {
    {
#line 598
    tmp = strcspn(name, "+=");
#line 598
    nlen = (int )tmp;
#line 601
    i = 0;
    }
    {
#line 601
    while (1) {
      while_continue: /* CIL Label */ ;
#line 601
      if (! *(environ + i)) {
#line 601
        goto while_break;
      }
      {
#line 603
      tmp___0 = strcspn((char const   *)*(environ + i), "=");
#line 603
      elen = tmp___0;
      }
#line 604
      if (elen == (size_t )nlen) {
        {
#line 604
        tmp___2 = memcmp((void const   *)name, (void const   *)*(environ + i), (size_t )nlen);
        }
#line 604
        if (tmp___2 == 0) {
#line 605
          if (val) {
#line 605
            tmp___1 = (*(environ + i) + elen) + 1;
          } else {
#line 605
            tmp___1 = *(environ + i);
          }
#line 605
          return (tmp___1);
        }
      }
#line 601
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 608
  return ((char *)((void *)0));
}
}
#line 611 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int locate_unset(char **env , char const   *name ) 
{ 
  int i ;
  int nlen ;
  size_t tmp ;
  size_t elen ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 615
  tmp = strcspn(name, "=");
#line 615
  nlen = (int )tmp;
#line 617
  i = 0;
  }
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! *(env + i)) {
#line 617
      goto while_break;
    }
#line 619
    if ((int )*(*(env + i) + 0) == 45) {
      {
#line 621
      tmp___0 = strcspn((char const   *)(*(env + i) + 1), "=");
#line 621
      elen = tmp___0;
      }
#line 622
      if (elen == (size_t )nlen) {
        {
#line 622
        tmp___2 = memcmp((void const   *)name, (void const   *)(*(env + i) + 1), (size_t )nlen);
        }
#line 622
        if (tmp___2 == 0) {
#line 624
          if (*(*(env + i) + (nlen + 1))) {
            {
#line 625
            tmp___1 = strcmp(name + nlen, (char const   *)((*(env + i) + 1) + nlen));
            }
#line 625
            return (tmp___1 == 0);
          } else {
#line 627
            return (1);
          }
        }
      }
    }
#line 617
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  return (0);
}
}
#line 634 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static char *env_concat(char const   *name , size_t namelen , char const   *a , char const   *b ) 
{ 
  char *res ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  _Bool tmp___2 ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  void *tmp___5 ;

  {
#line 640
  if (a) {
#line 640
    if (b) {
      {
#line 642
      tmp = strlen(a);
#line 642
      tmp___0 = strlen(b);
#line 642
      tmp___1 = xmalloc((((namelen + 1U) + tmp) + tmp___0) + 1U);
#line 642
      res = (char *)tmp___1;
#line 643
      strcpy((char */* __restrict  */)((res + namelen) + 1), (char const   */* __restrict  */)a);
#line 644
      strcat((char */* __restrict  */)res, (char const   */* __restrict  */)b);
      }
    } else {
#line 640
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 646
  if (a) {
    {
#line 648
    len = strlen(a);
#line 649
    tmp___2 = c_ispunct((int )*(a + (len - 1U)));
    }
#line 649
    if (tmp___2) {
#line 650
      len --;
    }
    {
#line 651
    tmp___3 = xmalloc(((namelen + 1U) + len) + 1U);
#line 651
    res = (char *)tmp___3;
#line 652
    memcpy((void */* __restrict  */)((res + namelen) + 1), (void const   */* __restrict  */)a,
           len);
#line 653
    *(res + ((namelen + 1U) + len)) = (char)0;
    }
  } else {
    {
#line 657
    tmp___4 = c_ispunct((int )*(b + 0));
    }
#line 657
    if (tmp___4) {
#line 658
      b ++;
    }
    {
#line 659
    tmp___5 = xmalloc(((namelen + 1U) + len) + 1U);
#line 659
    res = (char *)tmp___5;
#line 660
    strcpy((char */* __restrict  */)((res + namelen) + 1), (char const   */* __restrict  */)b);
    }
  }
  {
#line 662
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)name, namelen);
#line 663
  *(res + namelen) = (char )'=';
  }
#line 664
  return (res);
}
}
#line 667 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void environ_setup(char **hint ) 
{ 
  char **old_env ;
  char **new_env ;
  size_t count ;
  size_t i ;
  size_t n ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *p ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *__cil_tmp18 ;

  {
#line 670
  old_env = environ;
#line 674
  if (! hint) {
#line 675
    return;
  }
  {
#line 677
  tmp = strcmp((char const   *)*(hint + 0), "-");
  }
#line 677
  if (tmp == 0) {
#line 679
    old_env = (char **)((void *)0);
#line 680
    hint ++;
  }
#line 684
  count = (size_t )0;
#line 685
  if (old_env) {
#line 686
    i = (size_t )0;
    {
#line 686
    while (1) {
      while_continue: /* CIL Label */ ;
#line 686
      if (! *(old_env + i)) {
#line 686
        goto while_break;
      }
#line 687
      count ++;
#line 686
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 689
  i = (size_t )0;
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (! *(hint + i)) {
#line 689
      goto while_break___0;
    }
#line 690
    count ++;
#line 689
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 693
  tmp___0 = xcalloc(count + 1U, (size_t )sizeof(*(new_env + 0)));
#line 693
  new_env = (char **)tmp___0;
#line 696
  n = (size_t )0;
  }
#line 698
  if (old_env) {
#line 699
    i = (size_t )0;
    {
#line 699
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 699
      if (! *(old_env + i)) {
#line 699
        goto while_break___1;
      }
      {
#line 701
      tmp___2 = locate_unset(hint, (char const   *)*(old_env + i));
      }
#line 701
      if (! tmp___2) {
#line 702
        tmp___1 = n;
#line 702
        n ++;
#line 702
        *(new_env + tmp___1) = *(old_env + i);
      }
#line 699
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 705
  i = (size_t )0;
  {
#line 705
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 705
    if (! *(hint + i)) {
#line 705
      goto while_break___2;
    }
#line 709
    if ((int )*(*(hint + i) + 0) == 45) {
#line 712
      goto __Cont;
    }
    {
#line 714
    p = strchr((char const   *)*(hint + i), '=');
    }
#line 714
    if (p) {
#line 716
      if ((unsigned long )p == (unsigned long )*(hint + i)) {
#line 717
        goto __Cont;
      }
#line 718
      if ((int )*(p + -1) == 43) {
        {
#line 719
        tmp___3 = n;
#line 719
        n ++;
#line 719
        tmp___4 = find_env((char const   *)*(hint + i), 1);
#line 719
        *(new_env + tmp___3) = env_concat((char const   *)*(hint + i), (size_t )((p - *(hint + i)) - 1L),
                                          (char const   *)tmp___4, (char const   *)(p + 1));
        }
      } else
#line 721
      if ((int )*(p + 1) == 43) {
        {
#line 722
        tmp___5 = n;
#line 722
        n ++;
#line 722
        tmp___6 = find_env((char const   *)*(hint + i), 1);
#line 722
        *(new_env + tmp___5) = env_concat((char const   *)*(hint + i), (size_t )(p - *(hint + i)),
                                          (char const   *)(p + 2), (char const   *)tmp___6);
        }
      } else {
#line 725
        tmp___7 = n;
#line 725
        n ++;
#line 725
        *(new_env + tmp___7) = *(hint + i);
      }
    } else {
      {
#line 729
      p = find_env((char const   *)*(hint + i), 0);
      }
#line 730
      if (p) {
#line 731
        tmp___8 = n;
#line 731
        n ++;
#line 731
        *(new_env + tmp___8) = p;
      }
    }
    __Cont: /* CIL Label */ 
#line 705
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 734
  *(new_env + n) = (char *)((void *)0);
#line 736
  if (envsize) {
    {
#line 737
    free((void *)environ);
    }
  }
#line 739
  environ = new_env;
#line 740
  envsize = count + 1U;
#line 741
  return;
}
}
#line 744 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void prog_sockenv(struct prog *prog ) 
{ 
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *p ;
  struct hostent *host ;
  union pies_sockaddr_storage sa_server ;
  socklen_t len ;
  union pies_sockaddr_storage *sa_client ;
  socklen_t cltlen ;
  char const   *proto ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  uint16_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  uint16_t tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int i ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 751
  len = (socklen_t )sizeof(sa_server);
#line 752
  sa_client = & prog->v.p.sa_storage;
#line 753
  cltlen = prog->v.p.sa_len;
#line 754
  proto = (char const   *)((void *)0);
#line 756
  if (! ((prog->v.p.comp)->flags & 64)) {
#line 757
    return;
  }
  {
#line 759
  tmp___0 = socket_type_to_str((prog->v.p.comp)->socket_type, & proto);
  }
#line 759
  if (tmp___0) {
    {
#line 760
    tmp = umaxtostr((uintmax_t )(prog->v.p.comp)->socket_type, buf);
#line 760
    proto = (char const   *)tmp;
    }
  }
  {
#line 761
  add_env("SOCKTYPE", proto);
  }
#line 763
  if ((prog->v.p.comp)->socket_url) {
#line 764
    proto = (char const   *)((prog->v.p.comp)->socket_url)->proto_s;
  } else
#line 765
  if (prog->v.p.listener) {
#line 766
    proto = (char const   *)(((prog->v.p.listener)->v.p.comp)->socket_url)->proto_s;
  } else
#line 767
  if ((prog->v.p.comp)->flags & 24) {
#line 768
    proto = "TCP";
  }
  {
#line 770
  add_env("PROTO", proto);
#line 772
  tmp___6 = getsockname(prog->v.p.socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sa_server)),
                        (socklen_t */* __restrict  */)(& len));
  }
#line 772
  if (tmp___6 < 0) {
    {
#line 774
    tmp___1 = __errno_location();
#line 774
    tmp___2 = strerror(*tmp___1);
#line 774
    logmsg(4, "getsockname(): %s", tmp___2);
    }
  } else
#line 775
  if ((int )sa_server.s.sa_family == 2) {
    {
#line 777
    p = inet_ntoa(sa_server.s_in.sin_addr);
    }
#line 778
    if (p) {
      {
#line 779
      add_env("LOCALIP", (char const   *)p);
      }
    }
    {
#line 781
    tmp___3 = ntohs(sa_server.s_in.sin_port);
#line 781
    p = umaxtostr((uintmax_t )tmp___3, buf);
#line 782
    add_env("LOCALPORT", (char const   *)p);
    }
#line 784
    if ((prog->v.p.comp)->flags & 128) {
      {
#line 786
      host = gethostbyaddr((void const   *)((char *)(& sa_server.s_in.sin_addr)),
                           (__socklen_t )sizeof(sa_server.s_in.sin_addr), 2);
      }
#line 786
      if ((unsigned long )host == (unsigned long )((void *)0)) {
        {
#line 789
        tmp___4 = __errno_location();
#line 789
        tmp___5 = strerror(*tmp___4);
#line 789
        logmsg(4, "gethostbyaddr: %s", tmp___5);
        }
      } else {
        {
#line 791
        add_env("LOCALHOST", (char const   *)host->h_name);
        }
      }
    }
  }
#line 795
  if (cltlen > 0U) {
#line 795
    if ((int )sa_client->s.sa_family == 2) {
      {
#line 797
      p = inet_ntoa(sa_client->s_in.sin_addr);
      }
#line 798
      if (p) {
        {
#line 799
        add_env("REMOTEIP", (char const   *)p);
        }
      }
      {
#line 801
      tmp___7 = ntohs(sa_client->s_in.sin_port);
#line 801
      p = umaxtostr((uintmax_t )tmp___7, buf);
#line 802
      add_env("REMOTEPORT", (char const   *)p);
      }
#line 804
      if ((prog->v.p.comp)->flags & 128) {
        {
#line 806
        host = gethostbyaddr((void const   *)((char *)(& sa_client->s_in.sin_addr)),
                             (__socklen_t )sizeof(sa_client->s_in.sin_addr), 2);
        }
#line 806
        if ((unsigned long )host == (unsigned long )((void *)0)) {
          {
#line 809
          tmp___8 = __errno_location();
#line 809
          tmp___9 = strerror(*tmp___8);
#line 809
          logmsg(4, "gethostbyaddr: %s", tmp___9);
          }
        } else {
          {
#line 812
          add_env("REMOTEHOST", (char const   *)host->h_name);
          }
        }
      }
    }
  }
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (debug_level >= 4U) {
      {
#line 816
      logmsg_printf(7, "environment: ");
#line 816
      i = 0;
      }
      {
#line 816
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 816
        if (! *(environ + i)) {
#line 816
          goto while_break___0;
        }
        {
#line 816
        logmsg_printf(7, "%s ", *(environ + i));
#line 816
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 816
      logmsg_printf(7, "\n");
      }
    }
#line 816
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 817
  return;
}
}
#line 819 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int check_rate(struct prog *prog , unsigned int testtime , size_t max_count ) 
{ 
  time_t now ;

  {
  {
#line 824
  time(& now);
  }
#line 826
  if (prog->v.p.timestamp + (time_t )testtime > now) {
#line 827
    (prog->v.p.failcount) ++;
  } else {
#line 830
    prog->v.p.failcount = (size_t )0;
#line 831
    prog->v.p.timestamp = now;
  }
#line 834
  if (prog->v.p.failcount > max_count) {
#line 836
    prog->v.p.timestamp = now;
#line 837
    prog->v.p.status = (enum prog_status )3;
#line 838
    recompute_alarm = 1;
#line 839
    return (1);
  }
#line 842
  return (0);
}
}
#line 845 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int check_spawn_rate(struct prog *prog ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 848
  tmp___0 = check_rate(prog, 120U, (size_t )10);
  }
#line 848
  if (tmp___0) {
    {
#line 850
    tmp = ngettext("%s is respawning too fast, disabled for %d minute", "%s is respawning too fast, disabled for %d minutes",
                   5UL);
#line 850
    logmsg(5, (char const   *)tmp, prog->tag, 5);
    }
#line 855
    return (1);
  }
#line 857
  return (0);
}
}
#line 860 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int check_connection_rate(struct prog *prog ) 
{ 
  size_t max_rate ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 863
  if ((prog->v.p.comp)->max_rate) {
#line 863
    tmp = (prog->v.p.comp)->max_rate;
  } else {
#line 863
    tmp = default_max_rate;
  }
#line 863
  max_rate = tmp;
#line 865
  if (max_rate) {
    {
#line 865
    tmp___1 = check_rate(prog, 60U, max_rate);
    }
#line 865
    if (tmp___1) {
      {
#line 867
      tmp___0 = ngettext("%s is starting too often, disabled for %d minute", "%s is starting too often, disabled for %d minutes",
                         5UL);
#line 867
      logmsg(5, (char const   *)tmp___0, prog->tag, 5);
      }
#line 872
      return (1);
    }
  }
#line 874
  return (0);
}
}
#line 878 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int prog_open_socket(struct prog *prog ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;

  {
  {
#line 881
  prog->v.p.socket = create_socket((prog->v.p.comp)->socket_url, (prog->v.p.comp)->socket_type,
                                   (char const   *)(prog->v.p.comp)->privs.user, (prog->v.p.comp)->umask);
  }
#line 885
  if (prog->v.p.socket == -1) {
#line 887
    prog->v.p.status = (enum prog_status )1;
#line 888
    return (1);
  }
  {
#line 890
  tmp___1 = listen(prog->v.p.socket, 8);
  }
#line 890
  if (tmp___1) {
    {
#line 892
    tmp = __errno_location();
#line 892
    tmp___0 = strerror(*tmp);
#line 892
    logmsg(3, "listen: %s", tmp___0);
#line 893
    close(prog->v.p.socket);
#line 894
    prog->v.p.socket = -1;
#line 895
    prog->v.p.status = (enum prog_status )1;
    }
#line 896
    return (1);
  }
#line 898
  return (0);
}
}
#line 901 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void prog_start_prologue(struct prog *prog ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  char **tmp___5 ;
  int i ;
  limits_record_t tmp___6 ;
  int i___0 ;
  struct component *comp ;
  char *tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 904
  if ((prog->v.p.comp)->dir) {
    {
#line 906
    while (1) {
      while_continue: /* CIL Label */ ;
#line 906
      if (debug_level >= 1U) {
#line 906
        if (source_info_option) {
          {
#line 906
          logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                        906, "prog_start_prologue");
          }
        }
        {
#line 906
        tmp = gettext("chdir %s");
#line 906
        debug_msg((char const   *)tmp, (prog->v.p.comp)->dir);
        }
      }
#line 906
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 907
    tmp___3 = chdir((char const   *)(prog->v.p.comp)->dir);
    }
#line 907
    if (tmp___3) {
      {
#line 908
      tmp___0 = __errno_location();
#line 908
      tmp___1 = strerror(*tmp___0);
#line 908
      tmp___2 = gettext("%s: cannot change to directory %s: %s");
#line 908
      logmsg(3, (char const   *)tmp___2, prog->tag, (prog->v.p.comp)->dir, tmp___1);
      }
    }
  }
#line 912
  if ((prog->v.p.comp)->env) {
#line 912
    tmp___5 = (prog->v.p.comp)->env;
  } else {
#line 912
    if ((prog->v.p.comp)->flags & 64) {
#line 912
      tmp___4 = sockenv_hint;
    } else {
#line 912
      tmp___4 = (char **)((void *)0);
    }
#line 912
    tmp___5 = tmp___4;
  }
  {
#line 912
  environ_setup(tmp___5);
  }
  {
#line 915
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 915
    if (debug_level >= 4U) {
      {
#line 915
      logmsg_printf(7, "environment: ");
#line 915
      i = 0;
      }
      {
#line 915
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 915
        if (! *(environ + i)) {
#line 915
          goto while_break___1;
        }
        {
#line 915
        logmsg_printf(7, "%s ", *(environ + i));
#line 915
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 915
      logmsg_printf(7, "\n");
      }
    }
#line 915
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 917
  pies_priv_setup(& (prog->v.p.comp)->privs);
  }
#line 918
  if ((prog->v.p.comp)->umask) {
    {
#line 919
    umask((prog->v.p.comp)->umask);
    }
  }
#line 921
  if ((prog->v.p.comp)->limits) {
#line 921
    tmp___6 = (prog->v.p.comp)->limits;
  } else {
#line 921
    tmp___6 = pies_limits;
  }
  {
#line 921
  set_limits((char const   *)prog->tag, tmp___6);
  }
#line 925
  if (debug_level >= 1U) {
    {
#line 928
    comp = prog->v.p.comp;
#line 930
    logmsg_printf(7, "executing");
#line 931
    i___0 = 0;
    }
    {
#line 931
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 931
      if (! ((size_t )i___0 < comp->argc)) {
#line 931
        goto while_break___2;
      }
      {
#line 932
      tmp___7 = quotearg((char const   *)*(comp->argv + i___0));
#line 932
      logmsg_printf(7, " %s", tmp___7);
#line 931
      i___0 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 934
    logmsg_printf(7, "\n");
    }
  }
#line 936
  return;
}
}
#line 938 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void prog_execute(struct prog *prog ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 941
  if ((prog->v.p.comp)->builtin) {
    {
#line 943
    mf_proctitle_format("inetd %s", ((prog->v.p.comp)->builtin)->service);
#line 945
    (*(((prog->v.p.comp)->builtin)->fun))(0, (struct component  const  *)prog->v.p.comp);
#line 946
    _exit(0);
    }
  }
#line 949
  if ((prog->v.p.comp)->program) {
#line 949
    tmp = (prog->v.p.comp)->program;
  } else {
#line 949
    tmp = *((prog->v.p.comp)->argv + 0);
  }
  {
#line 949
  execvp((char const   *)tmp, (char * const  *)(prog->v.p.comp)->argv);
#line 952
  openlog((char const   *)log_tag, 1, (prog->v.p.comp)->facility);
#line 953
  tmp___0 = __errno_location();
#line 953
  tmp___1 = strerror(*tmp___0);
#line 953
  tmp___2 = gettext("cannot start `%s\': %s");
#line 953
  syslog(2, (char const   *)tmp___2, prog->tag, tmp___1);
#line 955
  _exit(70);
  }
}
}
#line 958 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_run_comp(struct component *comp , int fd , union pies_sockaddr_storage *sa ,
                      socklen_t salen ) 
{ 
  struct prog *prog ;
  struct prog *tmp ;

  {
  {
#line 962
  tmp = register_prog0(comp, 4294967295U);
#line 962
  prog = tmp;
#line 963
  prog->v.p.socket = fd;
#line 964
  prog->v.p.sa_storage = *sa;
#line 965
  prog->v.p.sa_len = salen;
#line 966
  prog_start_prologue(prog);
#line 967
  prog_sockenv(prog);
#line 968
  prog_execute(prog);
  }
#line 969
  return;
}
}
#line 971 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void prog_start(struct prog *prog ) 
{ 
  pid_t pid ;
  int redir[2] ;
  fd_set fdset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int __d0 ;
  int __d1 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  unsigned int tmp___21 ;
  char *tmp___22 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 978
  if (prog->pid > 0) {
#line 979
    return;
  } else
#line 978
  if (! ((unsigned int )prog->type == 0U)) {
#line 979
    return;
  }
  {
#line 986
  tmp = prog_start_prerequisites(prog);
  }
#line 986
  if (tmp) {
#line 987
    return;
  }
  {
#line 991
  if ((unsigned int )(prog->v.p.comp)->mode == 0U) {
#line 991
    goto case_0;
  }
#line 996
  if ((unsigned int )(prog->v.p.comp)->mode == 3U) {
#line 996
    goto case_3;
  }
#line 1011
  if ((unsigned int )(prog->v.p.comp)->mode == 1U) {
#line 1011
    goto case_1;
  }
#line 1018
  if ((unsigned int )(prog->v.p.comp)->mode == 2U) {
#line 1018
    goto case_2;
  }
#line 989
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 992
  tmp___0 = check_spawn_rate(prog);
  }
#line 992
  if (tmp___0) {
#line 993
    return;
  }
#line 994
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 997
  tmp___1 = check_spawn_rate(prog);
  }
#line 997
  if (tmp___1) {
#line 998
    return;
  }
  {
#line 999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 999
    if (debug_level >= 1U) {
#line 999
      if (source_info_option) {
        {
#line 999
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      999, "prog_start");
        }
      }
      {
#line 999
      tmp___2 = gettext("unlinking %s");
#line 999
      debug_msg((char const   *)tmp___2, (prog->v.p.comp)->pass_fd_socket);
      }
    }
#line 999
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1000
  tmp___6 = unlink((char const   *)(prog->v.p.comp)->pass_fd_socket);
  }
#line 1000
  if (tmp___6) {
    {
#line 1000
    tmp___7 = __errno_location();
    }
#line 1000
    if (*tmp___7 != 2) {
      {
#line 1002
      tmp___3 = __errno_location();
#line 1002
      tmp___4 = strerror(*tmp___3);
#line 1002
      tmp___5 = gettext("cannot unlink %s: %s");
#line 1002
      logmsg(3, (char const   *)tmp___5, (prog->v.p.comp)->pass_fd_socket, tmp___4);
      }
#line 1005
      return;
    }
  }
  {
#line 1007
  tmp___8 = prog_open_socket(prog);
  }
#line 1007
  if (tmp___8) {
#line 1008
    return;
  }
#line 1009
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1012
  tmp___9 = check_spawn_rate(prog);
  }
#line 1012
  if (tmp___9) {
#line 1013
    return;
  }
  {
#line 1014
  tmp___10 = prog_open_socket(prog);
  }
#line 1014
  if (tmp___10) {
#line 1015
    return;
  }
#line 1016
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1020
  if (prog->v.p.socket == -1) {
#line 1021
    return;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1024
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1024
    if (debug_level >= 1U) {
#line 1024
      if (source_info_option) {
        {
#line 1024
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1024, "prog_start");
        }
      }
      {
#line 1024
      tmp___11 = gettext("starting %s");
#line 1024
      debug_msg((char const   *)tmp___11, prog->tag);
      }
    }
#line 1024
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1026
  if ((prog->v.p.comp)->rmfile) {
    {
#line 1028
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1028
      if (debug_level >= 1U) {
#line 1028
        if (source_info_option) {
          {
#line 1028
          logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                        1028, "prog_start");
          }
        }
        {
#line 1028
        tmp___12 = gettext("unlinking %s");
#line 1028
        debug_msg((char const   *)tmp___12, (prog->v.p.comp)->rmfile);
        }
      }
#line 1028
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1029
    tmp___16 = unlink((char const   *)(prog->v.p.comp)->rmfile);
    }
#line 1029
    if (tmp___16) {
      {
#line 1029
      tmp___17 = __errno_location();
      }
#line 1029
      if (*tmp___17 != 2) {
        {
#line 1030
        tmp___13 = __errno_location();
#line 1030
        tmp___14 = strerror(*tmp___13);
#line 1030
        tmp___15 = gettext("%s: cannot remove file `%s\': %s");
#line 1030
        logmsg(3, (char const   *)tmp___15, prog->tag, (prog->v.p.comp)->rmfile, tmp___14);
        }
      }
    }
  }
#line 1034
  if ((prog->v.p.comp)->builtin) {
#line 1034
    if (((prog->v.p.comp)->builtin)->single_process) {
      {
#line 1036
      (*(((prog->v.p.comp)->builtin)->fun))(prog->v.p.socket, (struct component  const  *)prog->v.p.comp);
      }
#line 1037
      return;
    }
  }
  {
#line 1040
  redir[0] = open_redirector(prog, 0);
#line 1041
  redir[1] = open_redirector(prog, 1);
#line 1043
  pid = fork();
  }
  {
#line 1046
  if (pid == 0) {
#line 1046
    goto case_0___0;
  }
#line 1100
  if (pid == -1) {
#line 1100
    goto case_neg_1;
  }
#line 1106
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 1047
  signal_setup((void (*)(int  ))0);
#line 1048
  prog_start_prologue(prog);
  }
  {
#line 1052
  if ((unsigned int )(prog->v.p.comp)->mode == 0U) {
#line 1052
    goto case_0___1;
  }
#line 1052
  if ((unsigned int )(prog->v.p.comp)->mode == 3U) {
#line 1052
    goto case_0___1;
  }
#line 1065
  if ((unsigned int )(prog->v.p.comp)->mode == 2U) {
#line 1065
    goto case_2___0;
  }
#line 1065
  if ((unsigned int )(prog->v.p.comp)->mode == 1U) {
#line 1065
    goto case_2___0;
  }
#line 1049
  goto switch_break___1;
  case_0___1: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
#line 1053
  if (redir[0] == -1) {
    {
#line 1055
    close(1);
#line 1056
    open("/dev/null", 1);
    }
  } else
#line 1058
  if (redir[0] != 1) {
    {
#line 1060
    dup2(redir[0], 1);
    }
  }
#line 1062
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  {
#line 1066
  prog_sockenv(prog);
#line 1068
  dup2(prog->v.p.socket, 0);
#line 1069
  dup2(prog->v.p.socket, 1);
#line 1070
  close(prog->v.p.socket);
#line 1071
  prog->v.p.socket = -1;
  }
#line 1072
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1075
  if (redir[1] == -1) {
#line 1077
    if (! (diag_output & 2)) {
      {
#line 1079
      close(2);
#line 1080
      open("/dev/null", 1);
      }
    }
  } else
#line 1083
  if (redir[1] != 1) {
    {
#line 1085
    dup2(redir[1], 2);
    }
  }
  {
#line 1089
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1089
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.fds_bits[0]): "memory");
#line 1089
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1090
  __asm__  volatile   ("btsl"
                       " %1,%0": "=m" (fdset.fds_bits[0UL / (8UL * sizeof(__fd_mask ))]): "r" (0UL % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 1091
  __asm__  volatile   ("btsl"
                       " %1,%0": "=m" (fdset.fds_bits[1UL / (8UL * sizeof(__fd_mask ))]): "r" (1UL % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 1092
  __asm__  volatile   ("btsl"
                       " %1,%0": "=m" (fdset.fds_bits[2UL / (8UL * sizeof(__fd_mask ))]): "r" (2UL % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 1093
  if ((unsigned int )(prog->v.p.comp)->mode == 3U) {
#line 1094
    __asm__  volatile   ("btsl"
                         " %1,%0": "=m" (fdset.fds_bits[(unsigned long )prog->v.p.socket / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )prog->v.p.socket % (8UL * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
  {
#line 1095
  close_fds(& fdset);
#line 1097
  prog_execute(prog);
  }
  case_neg_1: /* CIL Label */ 
  {
#line 1101
  tmp___18 = __errno_location();
#line 1101
  tmp___19 = strerror(*tmp___18);
#line 1101
  tmp___20 = gettext("cannot run `%s\': fork failed: %s");
#line 1101
  logmsg(2, (char const   *)tmp___20, prog->tag, tmp___19);
  }
#line 1104
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1107
  if ((unsigned int )(prog->v.p.comp)->mode == 3U) {
#line 1109
    if ((prog->v.p.comp)->pass_fd_timeout) {
#line 1109
      tmp___21 = (prog->v.p.comp)->pass_fd_timeout;
    } else {
#line 1109
      tmp___21 = 5U;
    }
    {
#line 1109
    pass_fd((char const   *)(prog->v.p.comp)->pass_fd_socket, prog->v.p.socket, tmp___21);
    }
  }
#line 1114
  if ((prog->v.p.comp)->flags & 4) {
    {
#line 1116
    disable_socket(prog->v.p.socket);
    }
  } else
#line 1118
  if ((unsigned int )(prog->v.p.comp)->mode != 0U) {
    {
#line 1119
    close(prog->v.p.socket);
    }
  }
#line 1120
  prog->pid = pid;
#line 1121
  prog->v.p.status = (enum prog_status )0;
  {
#line 1122
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1122
    if (debug_level >= 1U) {
#line 1122
      if (source_info_option) {
        {
#line 1122
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1122, "prog_start");
        }
      }
      {
#line 1122
      tmp___22 = gettext("%s started, pid=%lu");
#line 1122
      debug_msg((char const   *)tmp___22, prog->tag, (unsigned long )pid);
      }
    }
#line 1122
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 1124
  return;
}
}
#line 1126 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
int check_acl(pies_acl_t acl , struct sockaddr *s , socklen_t salen ) 
{ 
  struct acl_input input ;
  int rc ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1132
  if (! acl) {
#line 1133
    return (0);
  }
  {
#line 1135
  input.addr = s;
#line 1136
  input.addrlen = salen;
#line 1137
  input.user = (char const   *)((void *)0);
#line 1138
  input.groups = (char const   **)((void *)0);
#line 1140
  rc = pies_acl_check(acl, & input, 1);
  }
#line 1141
  if (rc == 0) {
    {
#line 1143
    tmp = sockaddr_to_astr((struct sockaddr  const  *)s, (int )salen);
#line 1143
    p = tmp;
#line 1144
    tmp___0 = gettext("access from %s blocked");
#line 1144
    logmsg(3, (char const   *)tmp___0, p);
#line 1145
    free((void *)p);
    }
#line 1146
    return (1);
  }
#line 1149
  return (0);
}
}
#line 1152 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int _prog_accept(struct prog *p ) 
{ 
  int fd ;
  struct prog *pinst ;
  union pies_sockaddr_storage addr ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *s ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *s___0 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 1158
  addrlen = (socklen_t )sizeof(addr);
#line 1160
  fd = accept(p->v.p.socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
              (socklen_t */* __restrict  */)(& addrlen));
  }
#line 1161
  if (fd == -1) {
    {
#line 1163
    tmp = __errno_location();
#line 1163
    tmp___0 = strerror(*tmp);
#line 1163
    tmp___1 = gettext("accept failed: %s");
#line 1163
    logmsg(3, (char const   *)tmp___1, tmp___0);
    }
#line 1164
    return (1);
  }
#line 1167
  if (debug_level >= 1U) {
    {
#line 1169
    tmp___2 = sockaddr_to_astr((struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                               (int )addrlen);
#line 1169
    s = tmp___2;
#line 1170
    tmp___3 = gettext("%s wants %s");
#line 1170
    logmsg(7, (char const   *)tmp___3, s, p->tag);
#line 1171
    free((void *)s);
    }
  }
  {
#line 1174
  tmp___4 = check_acl((p->v.p.comp)->acl, (struct sockaddr *)(& addr), addrlen);
  }
#line 1174
  if (tmp___4) {
    {
#line 1177
    close(fd);
    }
#line 1178
    return (1);
  } else {
    {
#line 1174
    tmp___5 = check_acl(pies_acl, (struct sockaddr *)(& addr), addrlen);
    }
#line 1174
    if (tmp___5) {
      {
#line 1177
      close(fd);
      }
#line 1178
      return (1);
    }
  }
#line 1181
  if ((p->v.p.comp)->max_instances) {
#line 1181
    if (p->v.p.num_instances >= (p->v.p.comp)->max_instances) {
      {
#line 1184
      tmp___6 = sockaddr_to_astr((struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                                 (int )addrlen);
#line 1184
      s___0 = tmp___6;
#line 1185
      tmp___7 = gettext("%s: too many instances running, access from %s denied");
#line 1185
      logmsg(3, (char const   *)tmp___7, p->tag, s___0);
#line 1188
      free((void *)s___0);
#line 1189
      close(fd);
      }
#line 1190
      return (1);
    }
  }
  {
#line 1193
  tmp___8 = check_connection_rate(p);
  }
#line 1193
  if (tmp___8) {
    {
#line 1195
    disable_socket(p->v.p.socket);
#line 1196
    close(fd);
    }
#line 1197
    return (1);
  }
  {
#line 1200
  pinst = register_prog0(p->v.p.comp, 4294967295U);
#line 1201
  pinst->v.p.socket = fd;
#line 1202
  pinst->v.p.listener = p;
#line 1203
  pinst->v.p.sa_storage = addr;
#line 1204
  pinst->v.p.sa_len = addrlen;
#line 1205
  prog_start(pinst);
#line 1206
  close(fd);
#line 1207
  pinst->v.p.socket = -1;
#line 1209
  (p->v.p.num_instances) ++;
  }
#line 1210
  return (0);
}
}
#line 1213 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int _prog_wait(struct prog *p ) 
{ 
  struct prog *pinst ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1218
    if (debug_level >= 1U) {
#line 1218
      if (source_info_option) {
        {
#line 1218
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1218, "_prog_wait");
        }
      }
      {
#line 1218
      tmp = gettext("someone wants %s");
#line 1218
      debug_msg((char const   *)tmp, p->tag);
      }
    }
#line 1218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1220
  if ((p->v.p.comp)->max_instances) {
#line 1220
    if (p->v.p.num_instances >= (p->v.p.comp)->max_instances) {
      {
#line 1223
      tmp___0 = gettext("%s: too many instances running, dropping connection");
#line 1223
      logmsg(3, (char const   *)tmp___0, p->tag);
      }
#line 1226
      return (1);
    }
  }
  {
#line 1229
  pinst = register_prog0(p->v.p.comp, 4294967295U);
#line 1230
  pinst->v.p.socket = p->v.p.socket;
#line 1231
  pinst->v.p.listener = p;
#line 1232
  prog_start(pinst);
#line 1234
  pinst->v.p.socket = -1;
#line 1236
  (p->v.p.num_instances) ++;
  }
#line 1237
  return (0);
}
}
#line 1240 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
int progman_accept(int socket___0 ) 
{ 
  struct prog *p ;
  struct prog *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 1243
  tmp = prog_lookup_by_socket(socket___0);
#line 1243
  p = tmp;
  }
#line 1244
  if (! p) {
    {
#line 1246
    tmp___0 = gettext("INTERNAL ERROR: no matching prog for fd %d");
#line 1246
    logmsg(0, (char const   *)tmp___0, socket___0);
    }
#line 1248
    return (1);
  }
#line 1251
  if ((p->v.p.comp)->socket_type == 1) {
#line 1251
    if (! ((p->v.p.comp)->flags & 4)) {
      {
#line 1253
      tmp___1 = _prog_accept(p);
      }
#line 1253
      return (tmp___1);
    }
  }
  {
#line 1255
  tmp___2 = _prog_wait(p);
  }
#line 1255
  return (tmp___2);
}
}
#line 1259 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void component_fixup_depend(struct component *comp ) 
{ 
  void const   *p ;
  gl_list_iterator_t itr ;
  char const   *tag ;
  struct component *tgt ;
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1265
  if ((unsigned long )comp->depend == (unsigned long )((void *)0)) {
#line 1266
    return;
  }
  {
#line 1268
  itr = gl_list_iterator_inline(comp->depend);
  }
  {
#line 1269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1269
    tmp___1 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
    }
#line 1269
    if (! tmp___1) {
#line 1269
      goto while_break;
    }
    {
#line 1271
    tag = (char const   *)p;
#line 1274
    tgt = progman_lookup_component(tag);
    }
#line 1275
    if (! tgt) {
      {
#line 1277
      tmp = gettext("component %s declares dependency target %s, which is not declared");
#line 1277
      logmsg(3, (char const   *)tmp, comp->tag, tag);
      }
#line 1281
      goto while_continue;
    }
#line 1283
    if (! tgt->prereq) {
      {
#line 1285
      tgt->prereq = gl_list_create_empty_inline(& gl_linked_list_implementation, (_Bool (*)(void const   *elt1 ,
                                                                                            void const   *elt2 ))((void *)0),
                                                (size_t (*)(void const   *elt ))((void *)0),
                                                (void (*)(void const   *elt ))((void *)0),
                                                (_Bool)0);
      }
    }
    {
#line 1292
    tmp___0 = xstrdup((char const   *)comp->tag);
#line 1292
    gl_list_add_last_inline(tgt->prereq, (void const   *)tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1294
  gl_list_free_inline(comp->depend);
#line 1295
  comp->depend = (gl_list_t )((void *)0);
  }
#line 1296
  return;
}
}
#line 1298 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void fixup_prerequisites(void) 
{ 
  struct prog *prog ;

  {
#line 1303
  prog = proghead;
  {
#line 1303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1303
    if (! prog) {
#line 1303
      goto while_break;
    }
#line 1304
    if ((unsigned int )prog->type == 0U) {
      {
#line 1305
      component_fixup_depend(prog->v.p.comp);
      }
    }
#line 1303
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1306
  return;
}
}
#line 1308 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void rebuild_prerequisites(void) 
{ 
  struct prog *prog ;

  {
#line 1312
  prog = proghead;
  {
#line 1312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1312
    if (! prog) {
#line 1312
      goto while_break;
    }
#line 1313
    if ((unsigned int )prog->type == 0U) {
      {
#line 1314
      prog_rebuild_prerequisites(prog);
      }
    }
#line 1312
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1315
  return;
}
}
#line 1317 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void print_dep(struct prog *prog ) 
{ 
  pies_depmap_pos_t pos ;
  size_t n ;
  struct prog *dp ;
  struct prog *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1323
  logmsg_printf(5, "%s -> ", prog->tag);
#line 1324
  n = depmap_first(depmap, (enum pies_depmap_direction )1, prog->v.p.idx, & pos);
  }
  {
#line 1324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1324
    if (! (n != 4294967295U)) {
#line 1324
      goto while_break;
    }
    {
#line 1328
    tmp = prog_lookup_by_idx(n);
#line 1328
    dp = tmp;
#line 1329
    logmsg_printf(5, "%s -> ", dp->tag);
#line 1324
    n = depmap_next(depmap, pos);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1331
  logmsg_printf(5, "%s\n", prog->tag);
  }
#line 1332
  return;
}
}
#line 1334 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_dump_prereq(void) 
{ 
  struct prog *prog ;
  int i ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1338
  prog = proghead;
  {
#line 1338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1338
    if (! prog) {
#line 1338
      goto while_break;
    }
#line 1339
    if (prog->prereq) {
      {
#line 1342
      printf((char const   */* __restrict  */)"%s:", prog->tag);
#line 1343
      i = 0;
      }
      {
#line 1343
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1343
        if (! *(prog->prereq + i)) {
#line 1343
          goto while_break___0;
        }
        {
#line 1344
        printf((char const   */* __restrict  */)" %s", *(prog->prereq + i));
#line 1343
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1345
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 1338
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1347
  return;
}
}
#line 1349 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_dump_depmap(void) 
{ 
  struct prog *prog ;
  size_t i ;
  size_t j ;
  char *tmp ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 1355
  tmp = gettext("Dependency map");
#line 1355
  printf((char const   */* __restrict  */)"%s:\n", tmp);
#line 1356
  printf((char const   */* __restrict  */)"  ");
#line 1357
  i = (size_t )0;
  }
  {
#line 1357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1357
    if (! (i < numcomp)) {
#line 1357
      goto while_break;
    }
    {
#line 1358
    printf((char const   */* __restrict  */)" %2lu", (unsigned long )i);
#line 1357
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1359
  printf((char const   */* __restrict  */)"\n");
#line 1360
  i = (size_t )0;
  }
  {
#line 1360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1360
    if (! (i < numcomp)) {
#line 1360
      goto while_break___0;
    }
    {
#line 1362
    printf((char const   */* __restrict  */)"%2lu ", (unsigned long )i);
#line 1363
    j = (size_t )0;
    }
    {
#line 1363
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1363
      if (! (j < numcomp)) {
#line 1363
        goto while_break___1;
      }
      {
#line 1364
      tmp___2 = depmap_isset(depmap, i, j);
      }
#line 1364
      if (tmp___2) {
#line 1364
        tmp___1 = 'X';
      } else {
#line 1364
        tmp___1 = ' ';
      }
      {
#line 1364
      printf((char const   */* __restrict  */)" %c ", tmp___1);
#line 1363
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1365
    printf((char const   */* __restrict  */)"\n");
#line 1360
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1367
  tmp___3 = gettext("Legend");
#line 1367
  printf((char const   */* __restrict  */)"\n%s:\n", tmp___3);
#line 1368
  i = (size_t )0;
  }
  {
#line 1368
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1368
    if (! (i < numcomp)) {
#line 1368
      goto while_break___2;
    }
    {
#line 1370
    prog = prog_lookup_by_idx(i);
    }
#line 1371
    if (prog) {
      {
#line 1372
      printf((char const   */* __restrict  */)"%2lu: %s\n", (unsigned long )i, prog->tag);
      }
    }
#line 1368
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1374
  return;
}
}
#line 1376 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
int progman_build_depmap(void) 
{ 
  int rc ;
  size_t i ;
  struct prog *prog ;
  pies_depmap_t dp ;
  struct prog *dep ;
  struct prog *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1379
  rc = 0;
#line 1384
  fixup_prerequisites();
#line 1385
  rebuild_prerequisites();
#line 1386
  depmap = depmap_alloc(numcomp);
#line 1387
  prog = proghead;
  }
  {
#line 1387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1387
    if (! prog) {
#line 1387
      goto while_break;
    }
#line 1388
    if (prog->prereq) {
#line 1390
      i = (size_t )0;
      {
#line 1390
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1390
        if (! *(prog->prereq + i)) {
#line 1390
          goto while_break___0;
        }
        {
#line 1392
        tmp = prog_lookup_by_tag((char const   *)*(prog->prereq + i));
#line 1392
        dep = tmp;
        }
#line 1393
        if (! dep) {
          {
#line 1395
          prog->v.p.status = (enum prog_status )1;
#line 1396
          tmp___0 = gettext("component %s depends on %s, which is not declared");
#line 1396
          logmsg(3, (char const   *)tmp___0, prog->tag, *(prog->prereq + i));
#line 1399
          rc ++;
          }
        } else {
          {
#line 1402
          depmap_set(depmap, prog->v.p.idx, dep->v.p.idx);
          }
        }
#line 1390
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1387
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1405
  dp = depmap_copy(depmap);
#line 1406
  depmap_tc(dp);
#line 1407
  i = (size_t )0;
  }
  {
#line 1407
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1407
    if (! (i < numcomp)) {
#line 1407
      goto while_break___1;
    }
    {
#line 1408
    tmp___2 = depmap_isset(dp, i, i);
    }
#line 1408
    if (tmp___2) {
      {
#line 1410
      prog = prog_lookup_by_idx(i);
#line 1411
      tmp___1 = gettext("component %s depends on itself");
#line 1411
      logmsg(3, (char const   *)tmp___1, prog->tag);
#line 1412
      print_dep(prog);
#line 1413
      prog->v.p.status = (enum prog_status )1;
#line 1414
      rc ++;
      }
    }
#line 1407
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1416
  free((void *)dp);
  }
#line 1417
  return (rc);
}
}
#line 1421 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_create_sockets(void) 
{ 
  struct prog *prog ;
  struct component *comp ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
#line 1426
  prog = proghead;
  {
#line 1426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1426
    if (! prog) {
#line 1426
      goto while_break;
    }
#line 1428
    if ((unsigned int )prog->type == 0U) {
#line 1430
      comp = prog->v.p.comp;
#line 1431
      if ((unsigned int )comp->mode == 2U) {
#line 1431
        if (! (comp->flags & 24)) {
          {
#line 1433
          tmp = create_socket(comp->socket_url, comp->socket_type, (char const   *)comp->privs.user,
                              comp->umask);
#line 1433
          fd = tmp;
          }
#line 1436
          if (fd == -1) {
#line 1437
            prog->v.p.status = (enum prog_status )1;
          } else {
            {
#line 1438
            tmp___0 = register_socket(comp->socket_type, fd);
            }
#line 1438
            if (tmp___0) {
              {
#line 1440
              close(fd);
#line 1441
              prog->v.p.status = (enum prog_status )1;
              }
            } else {
#line 1444
              prog->v.p.socket = fd;
            }
          }
        }
      }
    }
#line 1426
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1448
  return;
}
}
#line 1451 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_recompute_alarm(void) 
{ 
  struct prog *prog ;
  time_t now ;
  time_t tmp ;
  time_t alarm_time ;
  time_t x ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1455
  tmp = time((time_t *)((void *)0));
#line 1455
  now = tmp;
#line 1456
  alarm_time = (time_t )0;
#line 1458
  recompute_alarm = 0;
  }
  {
#line 1459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1459
    if (debug_level >= 2U) {
#line 1459
      if (source_info_option) {
        {
#line 1459
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1459, "progman_recompute_alarm");
        }
      }
      {
#line 1459
      debug_msg("Recomputing alarm settings");
      }
    }
#line 1459
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1460
  prog = proghead;
  {
#line 1460
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1460
    if (! prog) {
#line 1460
      goto while_break___0;
    }
#line 1461
    if ((unsigned int )prog->type == 0U) {
      {
#line 1465
      if ((unsigned int )prog->v.p.status == 3U) {
#line 1465
        goto case_3;
      }
#line 1471
      if ((unsigned int )prog->v.p.status == 4U) {
#line 1471
        goto case_4;
      }
#line 1477
      goto switch_default;
      case_3: /* CIL Label */ 
#line 1466
      x = 300L - (now - prog->v.p.timestamp);
#line 1467
      if (alarm_time == 0L) {
#line 1468
        alarm_time = x;
      } else
#line 1467
      if (x < alarm_time) {
#line 1468
        alarm_time = x;
      }
#line 1469
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1472
      x = (time_t )(shutdown_timeout - (unsigned long )(now - prog->v.p.timestamp));
#line 1473
      if (alarm_time == 0L) {
#line 1474
        alarm_time = x;
      } else
#line 1473
      if (x < alarm_time) {
#line 1474
        alarm_time = x;
      }
#line 1475
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1478
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1460
    prog = prog->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1481
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1481
    if (debug_level >= 2U) {
#line 1481
      if (source_info_option) {
        {
#line 1481
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1481, "progman_recompute_alarm");
        }
      }
      {
#line 1481
      debug_msg("alarm=%lu", (unsigned long )alarm_time);
      }
    }
#line 1481
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1482
  if (alarm_time) {
    {
#line 1483
    alarm((unsigned int )alarm_time);
    }
  }
#line 1484
  return;
}
}
#line 1488 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_start(void) 
{ 
  struct prog *prog ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1493
  recompute_alarm = 0;
  {
#line 1494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1494
    if (debug_level >= 1U) {
#line 1494
      if (source_info_option) {
        {
#line 1494
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1494, "progman_start");
        }
      }
      {
#line 1494
      debug_msg("starting components");
      }
    }
#line 1494
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1495
  prog = proghead;
  {
#line 1495
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1495
    if (! prog) {
#line 1495
      goto while_break___0;
    }
#line 1496
    if ((unsigned int )prog->type == 0U) {
#line 1498
      if ((unsigned int )(prog->v.p.comp)->mode == 2U) {
#line 1500
        if ((prog->v.p.comp)->flags & 1) {
          {
#line 1501
          disable_socket(prog->v.p.socket);
          }
        } else {
          {
#line 1504
          prog->v.p.status = (enum prog_status )2;
#line 1505
          enable_socket(prog->v.p.socket);
          }
        }
      } else
#line 1508
      if ((unsigned int )prog->v.p.status == 0U) {
#line 1508
        if (prog->pid == 0) {
          {
#line 1510
          prog_start(prog);
          }
        } else {
#line 1508
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1508
      if ((unsigned int )prog->v.p.status == 3U) {
        {
#line 1510
        prog_start(prog);
        }
      }
    }
#line 1495
    prog = prog->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1512
  return;
}
}
#line 1514 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void check_stopping(struct prog *prog , time_t now ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 1517
  if ((unsigned long )(now - prog->v.p.timestamp) >= shutdown_timeout) {
#line 1519
    if (prog->pid == 0) {
      {
#line 1520
      tmp = gettext("INTERNAL ERROR: attempting to kill unexisting process %s");
#line 1520
      logmsg(0, (char const   *)tmp, prog->tag);
      }
    } else {
      {
#line 1524
      kill(prog->pid, 9);
      }
    }
  } else {
#line 1527
    recompute_alarm = 1;
  }
#line 1528
  return;
}
}
#line 1530 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_wake_sleeping(int onalrm ) 
{ 
  struct prog *prog ;
  time_t now ;
  time_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1534
  tmp = time((time_t *)((void *)0));
#line 1534
  now = tmp;
  }
  {
#line 1536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1536
    if (debug_level >= 1U) {
#line 1536
      if (source_info_option) {
        {
#line 1536
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1536, "progman_wake_sleeping");
        }
      }
      {
#line 1536
      tmp___0 = gettext("managing sleeping/stopping components");
#line 1536
      debug_msg((char const   *)tmp___0);
      }
    }
#line 1536
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1538
  prog = proghead;
  {
#line 1538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1538
    if (! prog) {
#line 1538
      goto while_break___0;
    }
#line 1539
    if ((unsigned int )prog->type == 0U) {
      {
#line 1543
      if ((unsigned int )prog->v.p.status == 3U) {
#line 1543
        goto case_3;
      }
#line 1565
      if ((unsigned int )prog->v.p.status == 4U) {
#line 1565
        goto case_4;
      }
#line 1569
      if ((unsigned int )prog->v.p.status == 0U) {
#line 1569
        goto case_0;
      }
#line 1574
      goto switch_default;
      case_3: /* CIL Label */ 
#line 1544
      if (now - prog->v.p.timestamp >= 300L) {
#line 1546
        if ((unsigned int )(prog->v.p.comp)->mode == 2U) {
          {
#line 1548
          prog->v.p.status = (enum prog_status )2;
#line 1549
          enable_socket(prog->v.p.socket);
          }
        } else {
          {
#line 1553
          prog->v.p.status = (enum prog_status )0;
#line 1554
          prog->v.p.failcount = (size_t )0;
#line 1555
          prog->v.p.timestamp = (time_t )0;
#line 1556
          prog_start(prog);
          }
        }
      }
#line 1561
      if (onalrm) {
#line 1562
        recompute_alarm = 1;
      }
#line 1563
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 1566
      check_stopping(prog, now);
      }
#line 1567
      goto switch_break;
      case_0: /* CIL Label */ 
#line 1570
      if (prog->pid == 0) {
        {
#line 1571
        prog_start(prog);
        }
      }
#line 1572
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1575
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1538
    prog = prog->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1578
  if (recompute_alarm) {
    {
#line 1579
    progman_recompute_alarm();
    }
  }
#line 1580
  return;
}
}
#line 1582 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int prog_start_prerequisites(struct prog *prog ) 
{ 
  int i ;
  int ret ;
  struct prog *dp ;
  struct prog *tmp ;
  time_t tmp___0 ;
  struct prog *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1588
  if (! prog->prereq) {
#line 1589
    return (0);
  }
  {
#line 1590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1590
    if (debug_level >= 1U) {
#line 1590
      if (source_info_option) {
        {
#line 1590
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1590, "prog_start_prerequisites");
        }
      }
      {
#line 1590
      debug_msg("starting prerequisites of %s", prog->tag);
      }
    }
#line 1590
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1591
  ret = 0;
#line 1592
  i = 0;
  {
#line 1592
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1592
    if (! *(prog->prereq + i)) {
#line 1592
      goto while_break___0;
    }
    {
#line 1594
    tmp = prog_lookup_by_tag((char const   *)*(prog->prereq + i));
#line 1594
    dp = tmp;
    }
#line 1595
    if (! ((unsigned int )dp->type == 0U)) {
#line 1596
      goto __Cont;
    }
#line 1597
    if ((prog->v.p.comp)->flags & 2) {
#line 1598
      goto __Cont;
    }
    {
#line 1601
    if ((unsigned int )dp->v.p.status == 0U) {
#line 1601
      goto case_0;
    }
#line 1606
    if ((unsigned int )dp->v.p.status == 1U) {
#line 1606
      goto case_1;
    }
#line 1610
    if ((unsigned int )dp->v.p.status == 2U) {
#line 1610
      goto case_2;
    }
#line 1613
    if ((unsigned int )dp->v.p.status == 3U) {
#line 1613
      goto case_3;
    }
#line 1617
    if ((unsigned int )dp->v.p.status == 4U) {
#line 1617
      goto case_4;
    }
#line 1599
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1602
    if (prog->pid != 0) {
#line 1603
      goto __Cont;
    }
#line 1604
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1607
    prog->v.p.status = (enum prog_status )1;
#line 1608
    return (1);
    case_2: /* CIL Label */ 
#line 1611
    goto __Cont;
    case_3: /* CIL Label */ 
#line 1615
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1618
    tmp___0 = time((time_t *)((void *)0));
#line 1618
    check_stopping(dp, tmp___0);
#line 1619
    ret = 1;
    }
#line 1620
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1622
    tmp___1 = prog_lookup_by_tag((char const   *)*(prog->prereq + i));
#line 1622
    prog_start(tmp___1);
    }
#line 1623
    if ((unsigned int )dp->v.p.status == 0U) {
#line 1623
      if (! dp->pid) {
#line 1624
        ret = 1;
      }
    } else {
#line 1624
      ret = 1;
    }
    __Cont: /* CIL Label */ 
#line 1592
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1626
  return (ret);
}
}
#line 1629 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void prog_stop_redirectors(struct prog *prog ) 
{ 


  {
#line 1632
  if (prog->v.p.redir[0]) {
    {
#line 1633
    prog_stop(prog->v.p.redir[0], 15);
    }
  }
#line 1634
  if (prog->v.p.redir[1]) {
    {
#line 1635
    prog_stop(prog->v.p.redir[1], 15);
    }
  }
#line 1636
  return;
}
}
#line 1638 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void prog_stop_dependents(struct prog *prog ) 
{ 
  pies_depmap_pos_t pos ;
  size_t n ;
  int warned ;
  struct prog *dp ;
  struct prog *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1643
  warned = 0;
#line 1645
  prog_stop_redirectors(prog);
#line 1646
  n = depmap_first(depmap, (enum pies_depmap_direction )0, prog->v.p.idx, & pos);
  }
  {
#line 1646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1646
    if (! (n != 4294967295U)) {
#line 1646
      goto while_break;
    }
    {
#line 1650
    tmp = prog_lookup_by_idx(n);
#line 1650
    dp = tmp;
    }
#line 1651
    if (! dp) {
#line 1652
      goto __Cont;
    }
#line 1653
    if (! warned) {
#line 1653
      if (dp->pid) {
        {
#line 1655
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1655
          if (debug_level >= 1U) {
#line 1655
            if (source_info_option) {
              {
#line 1655
              logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                            1655, "prog_stop_dependents");
              }
            }
            {
#line 1655
            debug_msg("stopping dependencies of %s", prog->tag);
            }
          }
#line 1655
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1656
        warned = 1;
      }
    }
    {
#line 1658
    prog_stop(dp, 15);
    }
    __Cont: /* CIL Label */ 
    {
#line 1646
    n = depmap_next(depmap, pos);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1660
  free((void *)pos);
  }
#line 1661
  return;
}
}
#line 1663 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void prog_stop(struct prog *prog , int sig ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1666
  if (prog->pid == 0) {
#line 1667
    return;
  }
#line 1668
  if ((unsigned int )prog->type == 0U) {
#line 1670
    if ((unsigned int )prog->v.p.status == 0U) {
      {
#line 1672
      prog->v.p.status = (enum prog_status )4;
#line 1673
      prog->v.p.timestamp = time((time_t *)((void *)0));
#line 1674
      recompute_alarm = 1;
      }
    }
  }
  {
#line 1677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1677
    if (debug_level >= 1U) {
#line 1677
      if (source_info_option) {
        {
#line 1677
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1677, "prog_stop");
        }
      }
      {
#line 1677
      debug_msg("stopping %s (%lu)", prog->tag, (unsigned long )prog->pid);
      }
    }
#line 1677
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1678
  kill(prog->pid, sig);
  }
#line 1679
  return;
}
}
#line 1681 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void prog_stop_all(int sig ) 
{ 
  struct prog *prog ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1686
    if (debug_level >= 1U) {
#line 1686
      if (source_info_option) {
        {
#line 1686
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1686, "prog_stop_all");
        }
      }
      {
#line 1686
      debug_msg("stopping all components (signal %d)", sig);
      }
    }
#line 1686
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1687
  prog = progtail;
  {
#line 1687
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1687
    if (! prog) {
#line 1687
      goto while_break___0;
    }
#line 1688
    if ((unsigned int )prog->type == 0U) {
#line 1688
      if ((unsigned int )prog->v.p.status == 0U) {
        {
#line 1691
        prog_stop(prog, sig);
        }
      } else
#line 1688
      if ((unsigned int )prog->v.p.status == 4U) {
        {
#line 1691
        prog_stop(prog, sig);
        }
      }
    }
#line 1687
    prog = prog->prev;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1692
  return;
}
}
#line 1694 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_stop(void) 
{ 
  unsigned long i ;
  size_t tmp ;

  {
  {
#line 1699
  prog_stop_all(15);
#line 1700
  i = 0UL;
  }
  {
#line 1700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1700
    if (! (i < shutdown_timeout)) {
#line 1700
      goto while_break;
    }
    {
#line 1702
    progman_cleanup(1);
#line 1703
    tmp = progman_running_count();
    }
#line 1703
    if (tmp == 0U) {
#line 1704
      return;
    }
    {
#line 1705
    sleep(1U);
#line 1700
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1707
  prog_stop_all(9);
  }
#line 1708
  return;
}
}
#line 1710 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void print_status(char *tag , pid_t pid , int status , int expect_term ) 
{ 
  char *tmp ;
  union __anonunion_73 __constr_expr_0 ;
  char *tmp___0 ;
  union __anonunion_74 __constr_expr_1 ;
  int prio ;
  union __anonunion_75 __constr_expr_2 ;
  union __anonunion_76 __constr_expr_3 ;
  char *tmp___1 ;
  union __anonunion_77 __constr_expr_4 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  union __anonunion_78 __constr_expr_5 ;
  union __anonunion_79 __constr_expr_6 ;
  union __anonunion_80 __constr_expr_7 ;
  union __anonunion_81 __constr_expr_8 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 1713
  __constr_expr_8.__in = status;
#line 1713
  if ((__constr_expr_8.__i & 127) == 0) {
#line 1715
    __constr_expr_1.__in = status;
#line 1715
    if ((__constr_expr_1.__i & 65280) >> 8 == 0) {
      {
#line 1716
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1716
        if (debug_level >= 1U) {
#line 1716
          if (source_info_option) {
            {
#line 1716
            logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                          1717, "print_status");
            }
          }
          {
#line 1716
          tmp = gettext("%s (%lu) exited successfully");
#line 1716
          debug_msg((char const   *)tmp, tag, (unsigned long )pid);
          }
        }
#line 1716
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1719
      __constr_expr_0.__in = status;
#line 1719
      tmp___0 = gettext("%s (%lu) failed with status %d");
#line 1719
      logmsg(3, (char const   *)tmp___0, tag, (unsigned long )pid, (__constr_expr_0.__i & 65280) >> 8);
      }
    }
  } else {
#line 1724
    __constr_expr_7.__in = status;
#line 1724
    if ((int )((signed char )((__constr_expr_7.__i & 127) + 1)) >> 1 > 0) {
#line 1728
      if (expect_term) {
#line 1728
        __constr_expr_2.__in = status;
#line 1728
        if ((__constr_expr_2.__i & 127) == 15) {
#line 1729
          prio = 7;
        } else {
#line 1731
          prio = 3;
        }
      } else {
#line 1731
        prio = 3;
      }
      {
#line 1733
      __constr_expr_3.__in = status;
#line 1733
      tmp___1 = gettext("%s (%lu) terminated on signal %d");
#line 1733
      logmsg(prio, (char const   *)tmp___1, tag, (unsigned long )pid, __constr_expr_3.__i & 127);
      }
    } else {
#line 1738
      __constr_expr_6.__in = status;
#line 1738
      if ((__constr_expr_6.__i & 255) == 127) {
        {
#line 1739
        __constr_expr_4.__in = status;
#line 1739
        tmp___2 = gettext("%s (%lu) stopped on signal %d");
#line 1739
        logmsg(3, (char const   *)tmp___2, tag, (unsigned long )pid, (__constr_expr_4.__i & 65280) >> 8);
        }
      } else {
#line 1744
        __constr_expr_5.__in = status;
#line 1744
        if (__constr_expr_5.__i & 128) {
          {
#line 1745
          tmp___3 = gettext("%s (%lu) dumped core");
#line 1745
          logmsg(3, (char const   *)tmp___3, tag, (unsigned long )pid);
          }
        } else {
          {
#line 1750
          tmp___4 = gettext("%s (%lu) terminated with unrecognized status");
#line 1750
          logmsg(3, (char const   *)tmp___4, tag, (unsigned long )pid);
          }
        }
      }
    }
  }
#line 1753
  return;
}
}
#line 1755
static  __attribute__((__noreturn__)) void propagate_child_exit(pid_t pid ) ;
#line 1757
static  __attribute__((__noreturn__)) void propagate_child_exit(pid_t pid ) ;
#line 1757 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void propagate_child_exit(pid_t pid ) 
{ 
  int wait_status ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  __pid_t tmp___3 ;
  int sig ;
  union __anonunion_82 __constr_expr_9 ;
  union __anonunion_83 __constr_expr_10 ;
  union __anonunion_84 __constr_expr_11 ;
  union __anonunion_85 __constr_expr_12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1762
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1762
    tmp___3 = waitpid(pid, & wait_status, 0);
    }
#line 1762
    if (! (tmp___3 == -1)) {
#line 1762
      goto while_break;
    }
    {
#line 1763
    tmp___2 = __errno_location();
    }
#line 1763
    if (*tmp___2 != 4) {
      {
#line 1765
      tmp = __errno_location();
#line 1765
      tmp___0 = strerror(*tmp);
#line 1765
      tmp___1 = gettext("waitpid failed: %s");
#line 1765
      logmsg(3, (char const   *)tmp___1, tmp___0);
#line 1766
      exit(71);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1769
  __constr_expr_12.__in = wait_status;
#line 1769
  if ((int )((signed char )((__constr_expr_12.__i & 127) + 1)) >> 1 > 0) {
    {
#line 1771
    __constr_expr_9.__in = wait_status;
#line 1771
    sig = __constr_expr_9.__i & 127;
#line 1772
    signal(sig, (void (*)(int  ))0);
#line 1773
    raise(sig);
    }
  } else {
#line 1775
    __constr_expr_11.__in = wait_status;
#line 1775
    if ((__constr_expr_11.__i & 127) == 0) {
      {
#line 1776
      __constr_expr_10.__in = wait_status;
#line 1776
      exit((__constr_expr_10.__i & 65280) >> 8);
      }
    }
  }
  {
#line 1777
  exit(127);
  }
}
}
#line 1780 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
char *wordsplit_string(struct wordsplit  const  *ws ) 
{ 
  char *ret ;
  char *p ;
  size_t count ;
  char **argv ;
  void *tmp ;
  size_t i ;
  size_t len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1784
  count = (size_t )(ws->ws_wordc + ws->ws_offs);
#line 1785
  tmp = xcalloc(count, (size_t )sizeof(*(argv + 0)));
#line 1785
  argv = (char **)tmp;
#line 1787
  len = (size_t )0;
#line 1789
  i = (size_t )0;
  }
  {
#line 1789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1789
    if (! (i < count)) {
#line 1789
      goto while_break;
    }
    {
#line 1791
    *(argv + i) = quotearg_n((int )i, (char const   *)*(ws->ws_wordv + i));
#line 1792
    tmp___0 = strlen((char const   *)*(argv + i));
#line 1792
    len += tmp___0;
#line 1789
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1794
  len += count;
#line 1795
  tmp___1 = xmalloc(len);
#line 1795
  ret = (char *)tmp___1;
#line 1797
  i = (size_t )0;
#line 1797
  p = ret;
  }
  {
#line 1797
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1797
    if (! (i < count)) {
#line 1797
      goto while_break___0;
    }
    {
#line 1799
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)*(argv + i));
#line 1800
    tmp___2 = strlen((char const   *)*(argv + i));
#line 1800
    p += tmp___2;
#line 1801
    tmp___3 = p;
#line 1801
    p ++;
#line 1801
    *tmp___3 = (char )' ';
#line 1797
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1803
  *(p + -1) = (char)0;
#line 1804
  free((void *)argv);
  }
#line 1805
  return (ret);
}
}
#line 1808 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void send_msg(char *rcpts , char const   *msg_text ) 
{ 
  int i ;
  int j ;
  int k ;
  pid_t child_pid ;
  pid_t grand_child_pid ;
  struct wordsplit ws ;
  int p[2] ;
  size_t size ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *arg___0 ;
  size_t len ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *cmd ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  ssize_t rc ;
  ssize_t tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
#line 1817
  ws.ws_offs = (size_t )mailer_argc;
#line 1818
  ws.ws_delim = ",";
#line 1819
  tmp___0 = wordsplit((char const   *)rcpts, & ws, 8262);
  }
#line 1819
  if (tmp___0) {
    {
#line 1822
    tmp = gettext("cannot parse recipient address list (%s)");
#line 1822
    logmsg(3, (char const   *)tmp, rcpts);
    }
#line 1825
    return;
  }
  {
#line 1828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1828
    if (debug_level >= 1U) {
#line 1828
      if (source_info_option) {
        {
#line 1828
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      1828, "send_msg");
        }
      }
      {
#line 1828
      tmp___1 = gettext("sending notification to %s");
#line 1828
      debug_msg((char const   *)tmp___1, rcpts);
      }
    }
#line 1828
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1831
  i = 0;
  {
#line 1831
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1831
    if (! (i < mailer_argc)) {
#line 1831
      goto while_break___0;
    }
#line 1832
    *(ws.ws_wordv + i) = *(mailer_argv + i);
#line 1831
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1840
  j = 0;
#line 1840
  k = i;
  {
#line 1840
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1840
    if (! ((size_t )j < ws.ws_wordc)) {
#line 1840
      goto while_break___1;
    }
#line 1842
    arg___0 = *(ws.ws_wordv + i);
    {
#line 1845
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1845
      if (*arg___0) {
        {
#line 1845
        tmp___2 = c_isblank((int )*arg___0);
        }
#line 1845
        if (! tmp___2) {
#line 1845
          goto while_break___2;
        }
      } else {
#line 1845
        goto while_break___2;
      }
#line 1846
      arg___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1847
    len = strlen((char const   *)arg___0);
    }
#line 1848
    if (len > 0U) {
      {
#line 1850
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1850
        if (len > 0U) {
          {
#line 1850
          tmp___3 = c_isblank((int )*(arg___0 + (len - 1U)));
          }
#line 1850
          if (! tmp___3) {
#line 1850
            goto while_break___3;
          }
        } else {
#line 1850
          goto while_break___3;
        }
#line 1851
        len --;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1853
    if (len == 0U) {
#line 1854
      goto __Cont;
    }
#line 1855
    if ((int )*(arg___0 + 0) == 60) {
#line 1855
      if ((int )*(arg___0 + (len - 1U)) == 62) {
#line 1857
        arg___0 ++;
#line 1858
        len -= 2U;
      }
    }
#line 1860
    if (len == 0U) {
#line 1861
      goto __Cont;
    }
    {
#line 1862
    memmove((void *)*(ws.ws_wordv + k), (void const   *)arg___0, len);
#line 1863
    *(*(ws.ws_wordv + k) + len) = (char)0;
#line 1864
    k ++;
    }
    __Cont: /* CIL Label */ 
#line 1840
    j ++;
#line 1840
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1866
  *(ws.ws_wordv + k) = (char *)((void *)0);
#line 1869
  child_pid = fork();
  }
#line 1871
  if (child_pid < 0) {
    {
#line 1873
    wordsplit_free(& ws);
#line 1874
    tmp___4 = __errno_location();
#line 1874
    tmp___5 = strerror(*tmp___4);
#line 1874
    tmp___6 = gettext("cannot send mail: fork failed: %s");
#line 1874
    logmsg(3, (char const   *)tmp___6, tmp___5);
    }
#line 1876
    return;
  }
#line 1879
  if (child_pid) {
    {
#line 1881
    tmp___7 = wordsplit_string((struct wordsplit  const  *)(& ws));
#line 1881
    cmd = tmp___7;
#line 1882
    wordsplit_free(& ws);
    }
    {
#line 1883
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1883
      if (debug_level >= 1U) {
#line 1883
        if (source_info_option) {
          {
#line 1883
          logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                        1884, "send_msg");
          }
        }
        {
#line 1883
        tmp___8 = gettext("started mailer: %s, pid=%lu");
#line 1883
        debug_msg((char const   *)tmp___8, cmd, (unsigned long )child_pid);
        }
      }
#line 1883
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1885
    register_command(mailer_program, cmd, child_pid);
    }
#line 1886
    return;
  }
  {
#line 1891
  signal_setup((void (*)(int  ))0);
#line 1893
  tmp___12 = pipe((int *)(p));
  }
#line 1893
  if (tmp___12) {
    {
#line 1895
    tmp___9 = __errno_location();
#line 1895
    tmp___10 = strerror(*tmp___9);
#line 1895
    tmp___11 = gettext("cannot send mail: pipe failed: %s");
#line 1895
    logmsg(3, (char const   *)tmp___11, tmp___10);
#line 1897
    wordsplit_free(& ws);
#line 1898
    exit(71);
    }
  }
  {
#line 1901
  grand_child_pid = fork();
  }
#line 1902
  if (grand_child_pid < 0) {
    {
#line 1904
    tmp___13 = __errno_location();
#line 1904
    tmp___14 = strerror(*tmp___13);
#line 1904
    tmp___15 = gettext("cannot send mail: fork failed: %s");
#line 1904
    logmsg(3, (char const   *)tmp___15, tmp___14);
    }
#line 1906
    return;
  }
#line 1909
  if (grand_child_pid == 0) {
#line 1913
    if (p[0] != 0) {
#line 1913
      if (p[1] != 0) {
        {
#line 1914
        close(0);
        }
      }
    }
    {
#line 1915
    close(p[1]);
#line 1916
    dup2(p[0], 0);
#line 1917
    execv((char const   *)mailer_program, (char * const  *)ws.ws_wordv);
#line 1918
    exit(127);
    }
  }
  {
#line 1922
  close(p[0]);
#line 1924
  size = strlen(msg_text);
  }
  {
#line 1925
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1925
    if (! size) {
#line 1925
      goto while_break___5;
    }
    {
#line 1927
    tmp___16 = write(p[1], (void const   *)msg_text, size);
#line 1927
    rc = tmp___16;
    }
#line 1928
    if (rc <= 0) {
#line 1930
      if (rc == 0) {
#line 1930
        tmp___19 = "EOF";
      } else {
        {
#line 1930
        tmp___17 = __errno_location();
#line 1930
        tmp___18 = strerror(*tmp___17);
#line 1930
        tmp___19 = (char const   *)tmp___18;
        }
      }
      {
#line 1930
      tmp___20 = gettext("cannot write to pipe: %s");
#line 1930
      logmsg(3, (char const   *)tmp___20, tmp___19);
      }
#line 1932
      goto while_break___5;
    }
#line 1934
    size -= (size_t )rc;
#line 1935
    msg_text += rc;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1937
  close(p[1]);
#line 1939
  propagate_child_exit(grand_child_pid);
  }
}
}
#line 1942 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static char const   default_termination_message[129]  = 
#line 1942
  {      (char const   )'F',      (char const   )'r',      (char const   )'o',      (char const   )'m', 
        (char const   )':',      (char const   )' ',      (char const   )'<',      (char const   )'>', 
        (char const   )'\n',      (char const   )'X',      (char const   )'-',      (char const   )'A', 
        (char const   )'g',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )':',      (char const   )' ',      (char const   )'$',      (char const   )'{', 
        (char const   )'c',      (char const   )'a',      (char const   )'n',      (char const   )'o', 
        (char const   )'n',      (char const   )'i',      (char const   )'c',      (char const   )'a', 
        (char const   )'l',      (char const   )'-',      (char const   )'p',      (char const   )'r', 
        (char const   )'o',      (char const   )'g',      (char const   )'r',      (char const   )'a', 
        (char const   )'m',      (char const   )'-',      (char const   )'n',      (char const   )'a', 
        (char const   )'m',      (char const   )'e',      (char const   )'}',      (char const   )' ', 
        (char const   )'(',      (char const   )'$',      (char const   )'{',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'k',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )'}',      (char const   )' ', 
        (char const   )'$',      (char const   )'{',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'}',      (char const   )')',      (char const   )'\n', 
        (char const   )'S',      (char const   )'u',      (char const   )'b',      (char const   )'j', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )':', 
        (char const   )' ',      (char const   )'C',      (char const   )'o',      (char const   )'m', 
        (char const   )'p',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'$', 
        (char const   )'{',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'p',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )'}',      (char const   )' ', 
        (char const   )'$',      (char const   )'{',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'m',      (char const   )'i',      (char const   )'n', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'}',      (char const   )' ',      (char const   )'$', 
        (char const   )'{',      (char const   )'r',      (char const   )'e',      (char const   )'t', 
        (char const   )'c',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )'}',      (char const   )'.',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'\000'};
#line 1948 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void notify(char const   *tag , int status , struct action *act ) 
{ 
  struct metadef mdef[9] ;
  char *msg_text ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *tmp ;
  union __anonunion_86 __constr_expr_13 ;
  char *tmp___0 ;
  union __anonunion_87 __constr_expr_14 ;
  union __anonunion_88 __constr_expr_15 ;
  union __anonunion_89 __constr_expr_16 ;
  char const   *tmp___1 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 1951
  mdef[0].kw = (char *)"canonical-program-name";
#line 1951
  mdef[0].value = (char *)"pies";
#line 1951
  mdef[0].expand = (char const   *(*)(struct metadef * , void * ))0;
#line 1951
  mdef[0].storage = (char *)0;
#line 1951
  mdef[0].data = (void *)0;
#line 1951
  mdef[1].kw = (char *)"package";
#line 1951
  mdef[1].value = (char *)"pies";
#line 1951
  mdef[1].expand = (char const   *(*)(struct metadef * , void * ))0;
#line 1951
  mdef[1].storage = (char *)0;
#line 1951
  mdef[1].data = (void *)0;
#line 1951
  mdef[2].kw = (char *)"version";
#line 1951
  mdef[2].value = (char *)"1.2";
#line 1951
  mdef[2].expand = (char const   *(*)(struct metadef * , void * ))0;
#line 1951
  mdef[2].storage = (char *)0;
#line 1951
  mdef[2].data = (void *)0;
#line 1951
  mdef[3].kw = (char *)"component";
#line 1951
  mdef[3].value = (char *)((void *)0);
#line 1951
  mdef[3].expand = (char const   *(*)(struct metadef * , void * ))0;
#line 1951
  mdef[3].storage = (char *)0;
#line 1951
  mdef[3].data = (void *)0;
#line 1951
  mdef[4].kw = (char *)"termination";
#line 1951
  mdef[4].value = (char *)((void *)0);
#line 1951
  mdef[4].expand = (char const   *(*)(struct metadef * , void * ))0;
#line 1951
  mdef[4].storage = (char *)0;
#line 1951
  mdef[4].data = (void *)0;
#line 1951
  mdef[5].kw = (char *)"retcode";
#line 1951
  mdef[5].value = (char *)((void *)0);
#line 1951
  mdef[5].expand = (char const   *(*)(struct metadef * , void * ))0;
#line 1951
  mdef[5].storage = (char *)0;
#line 1951
  mdef[5].data = (void *)0;
#line 1951
  mdef[6].kw = (char *)"program-name";
#line 1951
  mdef[6].value = (char *)((void *)0);
#line 1951
  mdef[6].expand = (char const   *(*)(struct metadef * , void * ))0;
#line 1951
  mdef[6].storage = (char *)0;
#line 1951
  mdef[6].data = (void *)0;
#line 1951
  mdef[7].kw = (char *)"instance";
#line 1951
  mdef[7].value = (char *)((void *)0);
#line 1951
  mdef[7].expand = (char const   *(*)(struct metadef * , void * ))0;
#line 1951
  mdef[7].storage = (char *)0;
#line 1951
  mdef[7].data = (void *)0;
#line 1951
  mdef[8].kw = (char *)((void *)0);
#line 1951
  mdef[8].value = (char *)0;
#line 1951
  mdef[8].expand = (char const   *(*)(struct metadef * , void * ))0;
#line 1951
  mdef[8].storage = (char *)0;
#line 1951
  mdef[8].data = (void *)0;
#line 1969
  msg_text = (char *)((void *)0);
#line 1972
  mdef[3].value = (char *)tag;
#line 1973
  mdef[7].value = (char *)tag;
#line 1974
  __constr_expr_16.__in = status;
#line 1974
  if ((__constr_expr_16.__i & 127) == 0) {
    {
#line 1977
    tmp = gettext("exited with code");
#line 1977
    mdef[4].value = tmp;
#line 1978
    __constr_expr_13.__in = status;
#line 1978
    mdef[5].value = umaxtostr((uintmax_t )((__constr_expr_13.__i & 65280) >> 8), buf);
    }
  } else {
#line 1980
    __constr_expr_15.__in = status;
#line 1980
    if ((int )((signed char )((__constr_expr_15.__i & 127) + 1)) >> 1 > 0) {
      {
#line 1983
      tmp___0 = gettext("terminated on signal");
#line 1983
      mdef[4].value = tmp___0;
#line 1984
      __constr_expr_14.__in = status;
#line 1984
      mdef[5].value = umaxtostr((uintmax_t )(__constr_expr_14.__i & 127), buf);
      }
    } else {
#line 1988
      mdef[4].value = (char *)"UNKNOWN";
#line 1989
      mdef[5].value = (char *)"UNKNOWN";
    }
  }
#line 1991
  mdef[6].value = (char *)program_name;
#line 1992
  if (act->message) {
#line 1992
    tmp___1 = (char const   *)act->message;
  } else {
#line 1992
    tmp___1 = default_termination_message;
  }
  {
#line 1992
  msg_text = meta_expand_string(tmp___1, mdef, (void *)0);
#line 1996
  send_msg(act->addr, (char const   *)msg_text);
#line 1997
  free((void *)msg_text);
  }
#line 1998
  return;
}
}
#line 2000 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static int status_matches_p(struct action *act , unsigned int status ) 
{ 
  int i ;

  {
#line 2005
  if (act->nstat == 0U) {
#line 2006
    return (1);
  }
#line 2007
  i = 0;
  {
#line 2007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2007
    if (! ((size_t )i < act->nstat)) {
#line 2007
      goto while_break;
    }
#line 2008
    if (*(act->status + i) == status) {
#line 2009
      return (1);
    }
#line 2007
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  return (0);
}
}
#line 2013 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void run_command(struct action *act , struct prog *prog , unsigned int retcode ,
                        pid_t child_pid ) 
{ 
  pid_t pid ;
  char *argv[4] ;
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 2022
  pid = fork();
  }
#line 2024
  if (pid == -1) {
    {
#line 2026
    tmp = __errno_location();
#line 2026
    tmp___0 = strerror(*tmp);
#line 2026
    logmsg(3, "fork: %s", tmp___0);
    }
#line 2027
    return;
  }
#line 2030
  if (pid == 0) {
    {
#line 2032
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2032
      if (debug_level >= 1U) {
#line 2032
        if (source_info_option) {
          {
#line 2032
          logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                        2032, "run_command");
          }
        }
        {
#line 2032
        tmp___1 = gettext("executing %s");
#line 2032
        debug_msg((char const   *)tmp___1, act->command);
        }
      }
#line 2032
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2034
    setenv("PIES_VERSION", "1.2", 1);
#line 2035
    setenv("PIES_COMPONENT", (char const   *)prog->tag, 1);
#line 2036
    tmp___2 = umaxtostr((uintmax_t )child_pid, buf);
#line 2036
    setenv("PIES_PID", (char const   *)tmp___2, 1);
    }
#line 2037
    if (retcode & 2147483648U) {
      {
#line 2038
      tmp___3 = umaxtostr((uintmax_t )(retcode & 2147483647U), buf);
#line 2038
      setenv("PIES_SIGNAL", (char const   *)tmp___3, 1);
      }
    } else {
      {
#line 2040
      tmp___4 = umaxtostr((uintmax_t )(retcode & 2147483647U), buf);
#line 2040
      setenv("PIES_STATUS", (char const   *)tmp___4, 1);
      }
    }
    {
#line 2042
    close_fds((fd_set *)((void *)0));
#line 2044
    argv[0] = (char *)"/bin/sh";
#line 2045
    argv[1] = (char *)"-c";
#line 2046
    argv[2] = act->command;
#line 2047
    argv[3] = (char *)((void *)0);
#line 2049
    execv((char const   *)argv[0], (char * const  *)(argv));
#line 2050
    exit(127);
    }
  }
  {
#line 2054
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2054
    if (debug_level >= 1U) {
#line 2054
      if (source_info_option) {
        {
#line 2054
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                      2055, "run_command");
        }
      }
      {
#line 2054
      tmp___5 = gettext("started command: %s, pid=%lu");
#line 2054
      debug_msg((char const   *)tmp___5, act->command, (unsigned long )pid);
      }
    }
#line 2054
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2056
  tmp___6 = xstrdup((char const   *)act->command);
#line 2056
  tmp___7 = gettext("[action]");
#line 2056
  register_command(tmp___7, tmp___6, pid);
  }
#line 2057
  return;
}
}
#line 2059 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
static void react(struct prog *prog , int status , pid_t pid ) 
{ 
  unsigned int retcode ;
  struct action *act ;
  union __anonunion_90 __constr_expr_17 ;
  char *tmp ;
  union __anonunion_91 __constr_expr_18 ;
  char *tmp___0 ;
  char *tmp___1 ;
  union __anonunion_92 __constr_expr_19 ;
  union __anonunion_93 __constr_expr_20 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 2063
  act = (prog->v.p.comp)->act_head;
#line 2065
  if (! act) {
#line 2066
    act = default_component.act_head;
  }
#line 2068
  __constr_expr_20.__in = status;
#line 2068
  if ((__constr_expr_20.__i & 127) == 0) {
#line 2070
    __constr_expr_17.__in = status;
#line 2070
    retcode = (unsigned int )((__constr_expr_17.__i & 65280) >> 8);
    {
#line 2071
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2071
      if (debug_level >= 1U) {
#line 2071
        if (source_info_option) {
          {
#line 2071
          logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                        2071, "react");
          }
        }
        {
#line 2071
        tmp = gettext("%s: terminated with code %d");
#line 2071
        debug_msg((char const   *)tmp, prog->tag, retcode);
        }
      }
#line 2071
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2073
    __constr_expr_19.__in = status;
#line 2073
    if ((int )((signed char )((__constr_expr_19.__i & 127) + 1)) >> 1 > 0) {
#line 2075
      __constr_expr_18.__in = status;
#line 2075
      retcode = (unsigned int )(__constr_expr_18.__i & 127);
      {
#line 2076
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2076
        if (debug_level >= 1U) {
#line 2076
          if (source_info_option) {
            {
#line 2076
            logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                          2076, "react");
            }
          }
          {
#line 2076
          tmp___0 = gettext("%s: terminated on signal %d");
#line 2076
          debug_msg((char const   *)tmp___0, prog->tag, retcode);
          }
        }
#line 2076
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2077
      retcode |= 2147483648U;
    } else {
      {
#line 2081
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2081
        if (debug_level >= 1U) {
#line 2081
          if (source_info_option) {
            {
#line 2081
            logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                          2081, "react");
            }
          }
          {
#line 2081
          tmp___1 = gettext("%s: unrecognized termination status");
#line 2081
          debug_msg((char const   *)tmp___1, prog->tag);
          }
        }
#line 2081
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2083
      act = (struct action *)((void *)0);
    }
  }
  {
#line 2086
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2086
    if (! act) {
#line 2086
      goto while_break___2;
    }
    {
#line 2088
    tmp___3 = status_matches_p(act, retcode);
    }
#line 2088
    if (tmp___3) {
#line 2090
      if (act->command) {
        {
#line 2092
        run_command(act, prog, retcode, pid);
        }
      }
      {
#line 2097
      if ((unsigned int )act->act == 0U) {
#line 2097
        goto case_0;
      }
#line 2102
      if ((unsigned int )act->act == 1U) {
#line 2102
        goto case_1;
      }
#line 2095
      goto switch_break;
      case_0: /* CIL Label */ 
#line 2098
      if ((unsigned int )(prog->v.p.comp)->mode != 2U) {
        {
#line 2099
        prog_start(prog);
        }
      }
#line 2100
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 2103
      tmp___2 = gettext("disabling component %s");
#line 2103
      logmsg(5, (char const   *)tmp___2, prog->tag);
#line 2104
      prog->v.p.status = (enum prog_status )1;
      }
      switch_break: /* CIL Label */ ;
      }
#line 2110
      if (act->addr) {
        {
#line 2111
        notify((char const   *)prog->tag, status, act);
        }
      }
#line 2112
      goto while_break___2;
    }
#line 2086
    act = act->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2116
  if (! act) {
#line 2116
    if ((unsigned int )(prog->v.p.comp)->mode != 2U) {
      {
#line 2118
      prog_start(prog);
      }
    }
  }
#line 2119
  return;
}
}
#line 2122 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_cleanup(int expect_term ) 
{ 
  pid_t pid ;
  int status ;
  struct prog *prog ;
  struct prog *tmp ;
  char *tmp___0 ;
  struct prog *listener ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 2127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2127
    pid = waitpid(-1, & status, 1);
    }
#line 2127
    if (! (pid > 0)) {
#line 2127
      goto while_break;
    }
    {
#line 2129
    tmp = prog_lookup_by_pid(pid);
#line 2129
    prog = tmp;
    }
#line 2130
    if (! prog) {
      {
#line 2132
      tmp___0 = gettext("subprocess");
#line 2132
      print_status(tmp___0, pid, status, expect_term);
      }
#line 2138
      goto while_continue;
    }
#line 2140
    prog->pid = 0;
    {
#line 2143
    if ((unsigned int )prog->type == 0U) {
#line 2143
      goto case_0;
    }
#line 2165
    if ((unsigned int )prog->type == 1U) {
#line 2165
      goto case_1;
    }
#line 2176
    if ((unsigned int )prog->type == 2U) {
#line 2176
      goto case_2;
    }
#line 2141
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 2144
    print_status(prog->tag, pid, status, expect_term);
    }
#line 2145
    if ((unsigned int )(prog->v.p.comp)->mode == 2U) {
      {
#line 2147
      listener = prog->v.p.listener;
#line 2149
      (listener->v.p.num_instances) --;
#line 2150
      prog_stop_redirectors(prog);
#line 2151
      destroy_prog(& prog);
#line 2152
      react(listener, status, pid);
      }
#line 2153
      if ((listener->v.p.comp)->flags & 4) {
        {
#line 2154
        enable_socket(listener->v.p.socket);
        }
      }
    } else {
      {
#line 2158
      prog->v.p.status = (enum prog_status )0;
#line 2159
      prog_stop_dependents(prog);
      }
#line 2160
      if (! expect_term) {
        {
#line 2161
        react(prog, status, pid);
        }
      }
    }
#line 2163
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2167
    if (expect_term) {
#line 2167
      tmp___1 = 1;
    } else
#line 2167
    if (prog->v.r.master) {
#line 2167
      if ((unsigned int )(prog->v.r.master)->v.p.status == 4U) {
#line 2167
        tmp___1 = 1;
      } else {
#line 2167
        tmp___1 = 0;
      }
    } else {
#line 2167
      tmp___1 = 0;
    }
    {
#line 2167
    print_status(prog->tag, pid, status, tmp___1);
    }
    {
#line 2171
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2171
      if (debug_level >= 1U) {
#line 2171
        if (source_info_option) {
          {
#line 2171
          logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/progman.c",
                        2172, "progman_cleanup");
          }
        }
        {
#line 2171
        tmp___2 = gettext("removing redirector %s, pid=%lu");
#line 2171
        debug_msg((char const   *)tmp___2, prog->tag, (unsigned long )pid);
        }
      }
#line 2171
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2173
    destroy_prog(& prog);
    }
#line 2174
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 2177
    print_status(prog->tag, pid, status, expect_term);
#line 2178
    destroy_prog(& prog);
    }
#line 2179
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2183
  if (! expect_term) {
    {
#line 2185
    progman_wake_sleeping(0);
    }
  }
#line 2186
  return;
}
}
#line 2188 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_stop_component(char const   *name ) 
{ 
  struct prog *prog ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 2193
  tmp = gettext("stopping component `%s\'");
#line 2193
  logmsg(6, (char const   *)tmp, name);
#line 2194
  prog = proghead;
  }
  {
#line 2194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2194
    if (! prog) {
#line 2194
      goto while_break;
    }
#line 2195
    if ((unsigned int )prog->type == 0U) {
      {
#line 2195
      tmp___1 = strcmp((char const   *)prog->tag, name);
      }
#line 2195
      if (tmp___1 == 0) {
        {
#line 2200
        if ((unsigned int )prog->v.p.status == 2U) {
#line 2200
          goto case_2;
        }
#line 2200
        if ((unsigned int )prog->v.p.status == 0U) {
#line 2200
          goto case_2;
        }
#line 2204
        if ((unsigned int )prog->v.p.status == 1U) {
#line 2204
          goto case_1;
        }
#line 2209
        if ((unsigned int )prog->v.p.status == 3U) {
#line 2209
          goto case_3;
        }
#line 2213
        goto switch_default;
        case_2: /* CIL Label */ 
        case_0: /* CIL Label */ 
        {
#line 2201
        prog_stop(prog, 15);
        }
#line 2202
        goto switch_break;
        case_1: /* CIL Label */ 
#line 2205
        if (! ((prog->v.p.comp)->flags & 1)) {
#line 2206
          prog->v.p.status = (enum prog_status )0;
        }
#line 2207
        goto switch_break;
        case_3: /* CIL Label */ 
#line 2210
        prog->v.p.failcount = (size_t )0;
#line 2211
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 2214
        tmp___0 = gettext("stopping component `%s\': component not started");
#line 2214
        logmsg(6, (char const   *)tmp___0, name);
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 2194
    prog = prog->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2219
  return;
}
}
#line 2221 "/home/ysko/Works/test-src/pies-1.2/src/progman.c"
void progman_dump_stats(char const   *filename ) 
{ 
  FILE *fp ;
  struct prog *prog ;
  char *tmpfile___0 ;
  __pid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int i ;
  char fbuf[5] ;
  int fidx ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  time_t t ;
  struct tm *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
  {
#line 2226
  tmpfile___0 = (char *)((void *)0);
#line 2228
  tmp = getpid();
#line 2228
  asprintf((char **/* __restrict  */)(& tmpfile___0), (char const   */* __restrict  */)"%s.%lu",
           filename, (unsigned long )tmp);
  }
#line 2229
  if (! tmpfile___0) {
    {
#line 2231
    tmp___0 = strerror(12);
#line 2231
    logmsg(3, "%s", tmp___0);
    }
#line 2232
    return;
  }
  {
#line 2234
  tmp___1 = gettext("dumping statistics to `%s\'");
#line 2234
  logmsg(6, (char const   *)tmp___1, tmpfile___0);
#line 2235
  fp = fopen((char const   */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)"w");
  }
#line 2236
  if (! fp) {
    {
#line 2238
    tmp___2 = __errno_location();
#line 2238
    tmp___3 = strerror(*tmp___2);
#line 2238
    tmp___4 = gettext("cannot open file `%s\' for writing: %s");
#line 2238
    logmsg(3, (char const   *)tmp___4, tmpfile___0, tmp___3);
    }
#line 2240
    return;
  }
#line 2243
  prog = proghead;
  {
#line 2243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2243
    if (! prog) {
#line 2243
      goto while_break;
    }
    {
#line 2247
    fidx = 0;
#line 2249
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-16s ",
            prog->tag);
    }
    {
#line 2252
    if ((unsigned int )prog->type == 0U) {
#line 2252
      goto case_0;
    }
#line 2294
    if ((unsigned int )prog->type == 1U) {
#line 2294
      goto case_1___1;
    }
#line 2298
    if ((unsigned int )prog->type == 2U) {
#line 2298
      goto case_2___1;
    }
#line 2250
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 2255
    if ((unsigned int )(prog->v.p.comp)->mode == 0U) {
#line 2255
      goto case_0___0;
    }
#line 2259
    if ((unsigned int )(prog->v.p.comp)->mode == 1U) {
#line 2259
      goto case_1;
    }
#line 2263
    if ((unsigned int )(prog->v.p.comp)->mode == 2U) {
#line 2263
      goto case_2;
    }
#line 2267
    if ((unsigned int )(prog->v.p.comp)->mode == 3U) {
#line 2267
      goto case_3;
    }
#line 2253
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 2256
    tmp___5 = fidx;
#line 2256
    fidx ++;
#line 2256
    fbuf[tmp___5] = (char )'C';
#line 2257
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 2260
    tmp___6 = fidx;
#line 2260
    fidx ++;
#line 2260
    fbuf[tmp___6] = (char )'A';
#line 2261
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 2264
    tmp___7 = fidx;
#line 2264
    fidx ++;
#line 2264
    fbuf[tmp___7] = (char )'I';
#line 2265
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 2268
    tmp___8 = fidx;
#line 2268
    fidx ++;
#line 2268
    fbuf[tmp___8] = (char )'P';
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 2273
    if ((unsigned int )prog->v.p.status == 0U) {
#line 2273
      goto case_0___1;
    }
#line 2277
    if ((unsigned int )prog->v.p.status == 1U) {
#line 2277
      goto case_1___0;
    }
#line 2281
    if ((unsigned int )prog->v.p.status == 2U) {
#line 2281
      goto case_2___0;
    }
#line 2285
    if ((unsigned int )prog->v.p.status == 3U) {
#line 2285
      goto case_3___0;
    }
#line 2289
    if ((unsigned int )prog->v.p.status == 4U) {
#line 2289
      goto case_4;
    }
#line 2271
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 2274
    tmp___9 = fidx;
#line 2274
    fidx ++;
#line 2274
    if (prog->pid != 0) {
#line 2274
      fbuf[tmp___9] = (char )'R';
    } else {
#line 2274
      fbuf[tmp___9] = (char )' ';
    }
#line 2275
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
#line 2278
    tmp___10 = fidx;
#line 2278
    fidx ++;
#line 2278
    fbuf[tmp___10] = (char )'D';
#line 2279
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
#line 2282
    tmp___11 = fidx;
#line 2282
    fidx ++;
#line 2282
    fbuf[tmp___11] = (char )'L';
#line 2283
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 2286
    tmp___12 = fidx;
#line 2286
    fidx ++;
#line 2286
    fbuf[tmp___12] = (char )'s';
#line 2287
    goto switch_break___1;
    case_4: /* CIL Label */ 
#line 2290
    tmp___13 = fidx;
#line 2290
    fidx ++;
#line 2290
    fbuf[tmp___13] = (char )'S';
    switch_break___1: /* CIL Label */ ;
    }
#line 2292
    goto switch_break;
    case_1___1: /* CIL Label */ 
#line 2295
    tmp___14 = fidx;
#line 2295
    fidx ++;
#line 2295
    fbuf[tmp___14] = (char )'R';
#line 2296
    goto switch_break;
    case_2___1: /* CIL Label */ 
#line 2299
    tmp___15 = fidx;
#line 2299
    fidx ++;
#line 2299
    fbuf[tmp___15] = (char )'E';
    switch_break: /* CIL Label */ ;
    }
    {
#line 2301
    tmp___16 = fidx;
#line 2301
    fidx ++;
#line 2301
    fbuf[tmp___16] = (char)0;
#line 2302
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-8.8s ",
            fbuf);
    }
    {
#line 2306
    if ((unsigned int )prog->type == 0U) {
#line 2306
      goto case_0___2;
    }
#line 2325
    if ((unsigned int )prog->type == 1U) {
#line 2325
      goto case_1___2;
    }
#line 2329
    if ((unsigned int )prog->type == 2U) {
#line 2329
      goto case_2___2;
    }
#line 2304
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
#line 2307
    if (prog->pid) {
      {
#line 2308
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%10lu ",
              (unsigned long )prog->pid);
      }
    } else
#line 2309
    if ((unsigned int )prog->v.p.status == 2U) {
#line 2309
      if ((prog->v.p.comp)->socket_url) {
        {
#line 2311
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-10s ",
                ((prog->v.p.comp)->socket_url)->string);
        }
      } else {
        {
#line 2313
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-10s ",
                "N/A");
        }
      }
    } else {
      {
#line 2313
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%-10s ",
              "N/A");
      }
    }
#line 2315
    if ((unsigned int )prog->v.p.status == 3U) {
      {
#line 2317
      t = prog->v.p.timestamp + 300L;
#line 2318
      tmp___17 = localtime((time_t const   *)(& t));
#line 2318
      fprintftime(fp, "%H:%M:%S", (struct tm  const  *)tmp___17, 0, 0);
      }
    }
#line 2321
    i = 0;
    {
#line 2321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2321
      if (! ((size_t )i < (prog->v.p.comp)->argc)) {
#line 2321
        goto while_break___0;
      }
      {
#line 2322
      tmp___18 = quotearg((char const   *)*((prog->v.p.comp)->argv + i));
#line 2322
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s",
              tmp___18);
#line 2321
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2323
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
    {
#line 2326
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%10lu ",
            (unsigned long )prog->pid);
    }
#line 2327
    goto switch_break___2;
    case_2___2: /* CIL Label */ 
    {
#line 2330
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", prog->v.c.command);
    }
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 2332
    fputc('\n', fp);
#line 2243
    prog = prog->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2334
  fclose(fp);
#line 2335
  unlink(filename);
#line 2336
  tmp___22 = rename((char const   *)tmpfile___0, filename);
  }
#line 2336
  if (tmp___22) {
    {
#line 2338
    tmp___19 = __errno_location();
#line 2338
    tmp___20 = strerror(*tmp___19);
#line 2338
    tmp___21 = gettext("cannot rename %s to %s: %s");
#line 2338
    logmsg(3, (char const   *)tmp___21, tmpfile___0, filename, tmp___20);
#line 2340
    unlink((char const   *)tmpfile___0);
    }
  }
  {
#line 2342
  free((void *)tmpfile___0);
  }
#line 2343
  return;
}
}
#line 513 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 526 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 945
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 35 "/home/ysko/Works/test-src/pies-1.2/src/acl.h"
int assert_grecs_value_type(grecs_locus_t *locus , grecs_value_t const   *value ,
                            int type ) ;
#line 38
struct grecs_keyword acl_keywords[3] ;
#line 39
int acl_section_parser(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                       grecs_value_t *value , void *cb_data ) ;
#line 44
int defacl_section_parser(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                          void *varptr , grecs_value_t *value , void *cb_data ) ;
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 207 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
char *log_tag  ;
#line 208
int log_facility ;
#line 210 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
struct component default_component  ;
#line 211 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
pies_acl_t pies_acl  ;
#line 212 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
limits_record_t pies_limits  ;
#line 214
char *mailer_command_line ;
#line 215 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
int mailer_argc  ;
#line 216 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
char **mailer_argv  ;
#line 217 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
size_t default_max_rate  ;
#line 218 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
char *qotdfile  ;
#line 268
int str_to_socket_type(char const   *str , int *pres ) ;
#line 271
struct component *component_create(char const   *name ) ;
#line 273
void component_finish(struct component *comp , grecs_locus_t *locus ) ;
#line 274
struct grecs_keyword *find_component_keyword(char const   *ident___0 ) ;
#line 307
int parse_limits(limits_record_t *plrec , char *str , char **endp ) ;
#line 375
int inetd_parse_conf(char const   *file ) ;
#line 387
struct inetd_builtin *inetd_builtin_lookup(char const   *service , int socktype ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 19 "/home/ysko/Works/test-src/pies-1.2/src/meta1lex.h"
char *meta1_queue_dir ;
#line 28
int meta1_config_parse(char const   *name ) ;
#line 22 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int preprocess_only  ;
#line 23 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int lint_mode  ;
#line 24 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int log_to_stderr_only  ;
#line 25 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int log_facility  =    1 << 3;
#line 27 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct pies_privs pies_privs  ;
#line 28 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int foreground  ;
#line 29 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int command  ;
#line 30 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char *statedir  =    (char *)"/usr/local/var/pies";
#line 31 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char *instance  ;
#line 32 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char *pidfile  ;
#line 33 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char *ctlfile  ;
#line 34 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char *statfile  ;
#line 36 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int inetd_mode  ;
#line 37 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
mode_t pies_umask  =    (mode_t )0;
#line 38 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
unsigned long shutdown_timeout  =    5UL;
#line 42 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int force_option  ;
#line 43 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char *mailer_program  =    (char *)"/usr/sbin/sendmail";
#line 44 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char *mailer_command_line  =    (char *)"/usr/sbin/sendmail -oi -t";
#line 47 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct obstack pp_stk  ;
#line 48 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct quoting_options *pp_qopt  ;
#line 65 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct config_file *conf_head  ;
#line 65 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct config_file *conf_tail  ;
#line 73 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct config_syntax_descr config_syntax_tab[4]  = {      {"pies", (enum config_syntax )0}, 
        {"meta1", (enum config_syntax )1}, 
        {"inetd", (enum config_syntax )2}, 
        {(char const   *)((void *)0), 0U}};
#line 80 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int str_to_config_syntax(char const   *str , enum config_syntax *psynt ) 
{ 
  struct config_syntax_descr *p ;
  int tmp ;

  {
#line 84
  p = config_syntax_tab;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! p->name) {
#line 84
      goto while_break;
    }
    {
#line 85
    tmp = strcmp(p->name, str);
    }
#line 85
    if (tmp == 0) {
#line 87
      *psynt = p->type;
#line 88
      return (0);
    }
#line 84
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (1);
}
}
#line 93 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void add_config(enum config_syntax syntax , char const   *name ) 
{ 
  struct config_file *file ;
  void *tmp ;

  {
  {
#line 96
  tmp = xmalloc((size_t )sizeof(*(file + 0)));
#line 96
  file = (struct config_file *)tmp;
#line 97
  file->next = (struct config_file *)((void *)0);
#line 98
  file->syntax = syntax;
#line 99
  file->name = xstrdup(name);
  }
#line 100
  if (conf_tail) {
#line 101
    conf_tail->next = file;
  } else {
#line 103
    conf_head = file;
  }
#line 104
  conf_tail = file;
#line 105
  return;
}
}
#line 108 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static void add_pp_option(char const   *opt , char const   *arg___0 ) 
{ 
  struct obstack *__o ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  int __len ;
  size_t tmp___1 ;
  char *qarg ;
  size_t qlen ;
  size_t tmp___2 ;
  struct obstack *__o___1 ;
  int __len___0 ;

  {
#line 117
  __o = & pp_stk;
#line 117
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 117
    _obstack_newchunk(__o, 1);
    }
  }
  {
#line 117
  tmp___0 = __o->next_free;
#line 117
  (__o->next_free) ++;
#line 117
  *tmp___0 = (char )' ';
#line 118
  __o___0 = & pp_stk;
#line 118
  tmp___1 = strlen(opt);
#line 118
  __len = (int )tmp___1;
  }
#line 118
  if ((unsigned long )(__o___0->next_free + __len) > (unsigned long )__o___0->chunk_limit) {
    {
#line 118
    _obstack_newchunk(__o___0, __len);
    }
  }
  {
#line 118
  memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)opt,
         (size_t )__len);
#line 118
  __o___0->next_free += __len;
  }
#line 119
  if (arg___0) {
#line 124
    if (! pp_qopt) {
      {
#line 126
      pp_qopt = clone_quoting_options((struct quoting_options *)((void *)0));
#line 127
      set_quoting_style(pp_qopt, (enum quoting_style )1);
      }
    }
    {
#line 129
    tmp___2 = strlen(arg___0);
#line 129
    qarg = quotearg_alloc_mem(arg___0, tmp___2, & qlen, (struct quoting_options  const  *)pp_qopt);
#line 130
    __o___1 = & pp_stk;
#line 130
    __len___0 = (int )qlen;
    }
#line 130
    if ((unsigned long )(__o___1->next_free + __len___0) > (unsigned long )__o___1->chunk_limit) {
      {
#line 130
      _obstack_newchunk(__o___1, __len___0);
      }
    }
    {
#line 130
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)qarg,
           (size_t )__len___0);
#line 130
    __o___1->next_free += __len___0;
#line 131
    free((void *)qarg);
    }
  }
#line 133
  return;
}
}
#line 137 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int stderr_closed_p(void) 
{ 
  int fd ;
  int tmp ;

  {
  {
#line 140
  tmp = dup(0);
#line 140
  fd = tmp;
  }
#line 141
  if (fd < 0) {
#line 142
    return (1);
  }
  {
#line 143
  close(fd);
  }
#line 144
  return (fd <= 2);
}
}
#line 151 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int assert_grecs_value_type(grecs_locus_t *locus , grecs_value_t const   *value ,
                            int type ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 155
  if (! value) {
    {
#line 157
    tmp = grecs_data_type_string((enum grecs_data_type )type);
#line 157
    tmp___0 = gettext("expected %s");
#line 157
    grecs_error(locus, 0, (char const   *)tmp___0, tmp);
    }
#line 159
    return (1);
  } else
#line 155
  if (value->type == 0) {
#line 155
    if (! value->v.string) {
      {
#line 157
      tmp = grecs_data_type_string((enum grecs_data_type )type);
#line 157
      tmp___0 = gettext("expected %s");
#line 157
      grecs_error(locus, 0, (char const   *)tmp___0, tmp);
      }
#line 159
      return (1);
    }
  }
#line 161
  if (value->type != (int const   )type) {
    {
#line 163
    tmp___1 = grecs_data_type_string((enum grecs_data_type )value->type);
#line 163
    tmp___2 = grecs_data_type_string((enum grecs_data_type )type);
#line 163
    tmp___3 = gettext("expected %s, but found %s");
#line 163
    grecs_error(locus, 0, (char const   *)tmp___3, tmp___2, tmp___1);
    }
#line 166
    return (1);
  }
#line 168
  return (0);
}
}
#line 171 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int assert_scalar_stmt(grecs_locus_t *locus , enum grecs_callback_command cmd ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 174
  if ((unsigned int )cmd != 2U) {
    {
#line 176
    tmp = gettext("unexpected block statement");
#line 176
    grecs_error(locus, 0, (char const   *)tmp);
    }
#line 177
    return (1);
  }
#line 179
  return (0);
}
}
#line 189
static int _cb_action(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                      grecs_value_t *value , void *cb_data ) ;
#line 189 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct tokendef actab[3]  = {      {(char *)"disable", 1}, 
        {(char *)"restart", 0}, 
        {(char *)((void *)0), 0}};
#line 183 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_action(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                      grecs_value_t *value , void *cb_data ) 
{ 
  enum return_action *pact ;
  int res ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;

  {
  {
#line 188
  pact = (enum return_action *)varptr;
#line 196
  tmp = assert_scalar_stmt(locus, cmd);
  }
#line 196
  if (tmp) {
#line 198
    return (1);
  } else {
    {
#line 196
    tmp___0 = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
    }
#line 196
    if (tmp___0) {
#line 198
      return (1);
    }
  }
  {
#line 199
  tmp___2 = strtotok(actab, value->v.string, & res);
  }
#line 199
  if (tmp___2) {
    {
#line 201
    tmp___1 = gettext("unknown action code: %s");
#line 201
    grecs_error(locus, 0, (char const   *)tmp___1, value->v.string);
    }
#line 202
    return (1);
  }
#line 204
  *pact = (enum return_action )res;
#line 205
  return (0);
}
}
#line 208 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct grecs_keyword return_code_keywords[5]  = {      {"action", "arg: {disable | restart}", "Specifies action to take when a component finishes with this return code.",
      (enum grecs_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->act_temp.act)),
      & _cb_action, (void *)0, (struct grecs_keyword *)0}, 
        {"notify", "arg: emails", "Notify this address when a component terminates.",
      (enum grecs_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->act_temp.addr)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))0, (void *)0, (struct grecs_keyword *)0}, 
        {"message", (char const   *)((void *)0), "Notification message text (with headers).",
      (enum grecs_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->act_temp.message)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"exec", (char const   *)((void *)0), "Execute this command.", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->act_temp.command)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {(char const   *)((void *)0), (char const   *)0, (char const   *)0, 0U, (void *)0,
      0U, (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
                   void * ))0, (void *)0, (struct grecs_keyword *)0}};
#line 238 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct tokendef ex_tokendef[17]  = 
#line 238
  {      {(char *)"EX_OK", 0}, 
        {(char *)"EX_USAGE", 64}, 
        {(char *)"EX_DATAERR", 65}, 
        {(char *)"EX_NOINPUT", 66}, 
        {(char *)"EX_NOUSER", 67}, 
        {(char *)"EX_NOHOST", 68}, 
        {(char *)"EX_UNAVAILABLE", 69}, 
        {(char *)"EX_SOFTWARE", 70}, 
        {(char *)"EX_OSERR", 71}, 
        {(char *)"EX_OSFILE", 72}, 
        {(char *)"EX_CANTCREAT", 73}, 
        {(char *)"EX_IOERR", 74}, 
        {(char *)"EX_TEMPFAIL", 75}, 
        {(char *)"EX_PROTOCOL", 76}, 
        {(char *)"EX_NOPERM", 77}, 
        {(char *)"EX_CONFIG", 78}, 
        {(char *)((void *)0), 0}};
#line 258 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct tokendef sig_tokendef[34]  = 
#line 258
  {      {(char *)"SIGHUP", 1}, 
        {(char *)"SIGINT", 2}, 
        {(char *)"SIGQUIT", 3}, 
        {(char *)"SIGILL", 4}, 
        {(char *)"SIGTRAP", 5}, 
        {(char *)"SIGABRT", 6}, 
        {(char *)"SIGIOT", 6}, 
        {(char *)"SIGBUS", 7}, 
        {(char *)"SIGFPE", 8}, 
        {(char *)"SIGKILL", 9}, 
        {(char *)"SIGUSR1", 10}, 
        {(char *)"SIGSEGV", 11}, 
        {(char *)"SIGUSR2", 12}, 
        {(char *)"SIGPIPE", 13}, 
        {(char *)"SIGALRM", 14}, 
        {(char *)"SIGTERM", 15}, 
        {(char *)"SIGSTKFLT", 16}, 
        {(char *)"SIGCHLD", 17}, 
        {(char *)"SIGCONT", 18}, 
        {(char *)"SIGSTOP", 19}, 
        {(char *)"SIGTSTP", 20}, 
        {(char *)"SIGTTIN", 21}, 
        {(char *)"SIGTTOU", 22}, 
        {(char *)"SIGURG", 23}, 
        {(char *)"SIGXCPU", 24}, 
        {(char *)"SIGXFSZ", 25}, 
        {(char *)"SIGVTALRM", 26}, 
        {(char *)"SIGPROF", 27}, 
        {(char *)"SIGWINCH", 28}, 
        {(char *)"SIGPOLL", 29}, 
        {(char *)"SIGIO", 29}, 
        {(char *)"SIGPWR", 30}, 
        {(char *)"SIGSYS", 31}, 
        {(char *)((void *)0), 0}};
#line 319 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct action *create_action(struct component *comp , grecs_locus_t *locus ,
                                    grecs_value_t *val , int argc , char const   *(*getarg)(grecs_value_t * ,
                                                                                            int  ,
                                                                                            grecs_locus_t * ) ) 
{ 
  int i ;
  unsigned int *retv ;
  int retc ;
  int allflag ;
  struct action *act ;
  void *tmp ;
  unsigned int n ;
  char const   *arg___0 ;
  char const   *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *p ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  char *p___0 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 327
  retc = 0;
#line 328
  allflag = 0;
#line 331
  tmp = xcalloc((size_t )argc, (size_t )sizeof(*retv));
#line 331
  retv = (unsigned int *)tmp;
  }
#line 332
  if (argc == 0) {
#line 333
    allflag = 1;
  } else
#line 332
  if (argc == 1) {
    {
#line 332
    tmp___13 = (*getarg)(val, 0, locus);
#line 332
    tmp___14 = strcmp(tmp___13, "*");
    }
#line 332
    if (tmp___14 == 0) {
#line 333
      allflag = 1;
    } else {
#line 332
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 336
    i = 0;
    {
#line 336
    while (1) {
      while_continue: /* CIL Label */ ;
#line 336
      if (! (i < argc)) {
#line 336
        goto while_break;
      }
      {
#line 339
      tmp___0 = (*getarg)(val, i, locus);
#line 339
      arg___0 = tmp___0;
#line 340
      tmp___1 = strlen(arg___0);
#line 340
      len = tmp___1;
#line 342
      tmp___11 = __ctype_b_loc();
      }
#line 342
      if ((int const   )*(*tmp___11 + (int )*(arg___0 + 0)) & 2048) {
        {
#line 345
        tmp___2 = strtoul((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)(& p),
                          0);
#line 345
        n = (unsigned int )tmp___2;
        }
#line 346
        if (*p) {
          {
#line 348
          tmp___3 = gettext("%s: not a number");
#line 348
          grecs_error(locus, 0, (char const   *)tmp___3, p);
          }
#line 349
          goto __Cont;
        }
      } else
#line 352
      if (len > 3U) {
        {
#line 352
        tmp___10 = memcmp((void const   *)arg___0, (void const   *)"SIG", (size_t )3);
        }
#line 352
        if (tmp___10 == 0) {
#line 354
          if ((int const   )*(arg___0 + 4) == 43) {
            {
#line 357
            tmp___4 = strtoul((char const   */* __restrict  */)(arg___0 + 4), (char **/* __restrict  */)(& p___0),
                              0);
#line 357
            n = (unsigned int )tmp___4;
            }
#line 358
            if (*p___0) {
              {
#line 360
              tmp___5 = gettext("%s: not a number");
#line 360
              grecs_error(locus, 0, (char const   *)tmp___5, p___0);
              }
#line 361
              goto __Cont;
            }
          } else {
            {
#line 364
            tmp___7 = strtotok_ci(sig_tokendef, arg___0, (int *)(& n));
            }
#line 364
            if (tmp___7) {
              {
#line 366
              tmp___6 = gettext("%s: not a signal code");
#line 366
              grecs_error(locus, 0, (char const   *)tmp___6, arg___0);
              }
#line 367
              goto __Cont;
            }
          }
#line 369
          n |= 2147483648U;
        } else {
#line 352
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 371
        tmp___9 = strtotok_ci(ex_tokendef, arg___0, (int *)(& n));
        }
#line 371
        if (tmp___9) {
          {
#line 373
          tmp___8 = gettext("%s: not a return code");
#line 373
          grecs_error(locus, 0, (char const   *)tmp___8, arg___0);
          }
#line 374
          goto __Cont;
        }
      }
#line 378
      tmp___12 = retc;
#line 378
      retc ++;
#line 378
      *(retv + tmp___12) = n;
      __Cont: /* CIL Label */ 
#line 336
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 382
  if (retc == 0) {
#line 382
    if (! allflag) {
      {
#line 384
      free((void *)retv);
      }
#line 385
      return ((struct action *)((void *)0));
    }
  }
  {
#line 388
  tmp___15 = xzalloc((size_t )sizeof(*act));
#line 388
  act = (struct action *)tmp___15;
  }
#line 389
  if (! allflag) {
#line 391
    act->nstat = (size_t )retc;
#line 392
    act->status = retv;
  }
#line 394
  if (comp->act_tail) {
#line 395
    (comp->act_tail)->next = act;
  } else {
#line 397
    comp->act_head = act;
  }
#line 398
  comp->act_tail = act;
#line 399
  return (act);
}
}
#line 402 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char const   *_get_string_arg(grecs_value_t *val , int num , grecs_locus_t *locus ) 
{ 


  {
#line 405
  if (num != 0) {
#line 406
    return ((char const   *)((void *)0));
  }
#line 407
  return (val->v.string);
}
}
#line 410 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char const   *_get_array_arg(grecs_value_t *val , int num , grecs_locus_t *locus ) 
{ 
  int tmp ;

  {
#line 413
  if ((size_t )num < val->v.arg.c) {
    {
#line 415
    tmp = assert_grecs_value_type(locus, (grecs_value_t const   *)(val->v.arg.v + num),
                                  0);
    }
#line 415
    if (tmp == 0) {
#line 417
      return ((val->v.arg.v + num)->v.string);
    }
  }
#line 419
  return ((char const   *)((void *)0));
}
}
#line 422 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char const   *_get_list_arg(grecs_value_t *val , int num , grecs_locus_t *locus ) 
{ 
  grecs_value_t *elt ;
  void const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 425
  tmp = gl_list_get_at_inline(val->v.list, (size_t )num);
#line 425
  elt = (grecs_value_t *)tmp;
  }
#line 426
  if (! elt) {
    {
#line 428
    tmp___0 = gettext("cannot get list item");
#line 428
    grecs_error(locus, 0, (char const   *)tmp___0);
    }
  } else {
    {
#line 430
    tmp___1 = assert_grecs_value_type(locus, (grecs_value_t const   *)elt, 0);
    }
#line 430
    if (tmp___1 == 0) {
#line 431
      return (elt->v.string);
    }
  }
#line 432
  return ((char const   *)((void *)0));
}
}
#line 435 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int return_code_section_parser(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                                      void *varptr , grecs_value_t *value , void *cb_data ) 
{ 
  struct component *comp ;
  size_t count ;
  struct action *act ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 441
  comp = (struct component *)varptr;
  {
#line 447
  if ((unsigned int )cmd == 0U) {
#line 447
    goto case_0;
  }
#line 475
  if ((unsigned int )cmd == 1U) {
#line 475
    goto case_1___0;
  }
#line 483
  if ((unsigned int )cmd == 2U) {
#line 483
    goto case_2___0;
  }
#line 445
  goto switch_break;
  case_0: /* CIL Label */ 
#line 448
  if (! value) {
    {
#line 450
    tmp = gettext("missing tag");
#line 450
    grecs_error(locus, 0, (char const   *)tmp);
    }
#line 451
    return (1);
  } else
#line 448
  if (value->type == 0) {
#line 448
    if (! value->v.string) {
      {
#line 450
      tmp = gettext("missing tag");
#line 450
      grecs_error(locus, 0, (char const   *)tmp);
      }
#line 451
      return (1);
    }
  }
  {
#line 456
  if (value->type == 0) {
#line 456
    goto case_0___0;
  }
#line 460
  if (value->type == 2) {
#line 460
    goto case_2;
  }
#line 465
  if (value->type == 1) {
#line 465
    goto case_1;
  }
#line 454
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 457
  act = create_action(comp, locus, value, 1, & _get_string_arg);
  }
#line 458
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 461
  act = create_action(comp, locus, value, (int )value->v.arg.c, & _get_array_arg);
  }
#line 463
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 466
  count = gl_list_size_inline(value->v.list);
#line 467
  act = create_action(comp, locus, value, (int )count, & _get_list_arg);
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 469
  *((struct component **)cb_data) = comp;
#line 470
  if (! act) {
#line 471
    return (1);
  }
  {
#line 472
  memset((void *)(& comp->act_temp), 0, (size_t )sizeof(comp->act_temp));
  }
#line 473
  goto switch_break;
  case_1___0: /* CIL Label */ 
#line 476
  act = comp->act_tail;
#line 477
  act->act = comp->act_temp.act;
#line 478
  act->addr = comp->act_temp.addr;
#line 479
  act->message = comp->act_temp.message;
#line 480
  act->command = comp->act_temp.command;
#line 481
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 484
  tmp___0 = gettext("invalid use of block statement");
#line 484
  grecs_error(locus, 0, (char const   *)tmp___0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 486
  return (0);
}
}
#line 489 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static char **config_array_to_argv(grecs_value_t *val , grecs_locus_t *locus , size_t *pargc ) 
{ 
  int i ;
  int j ;
  int argc ;
  char **argv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 496
  argc = (int )val->v.arg.c;
#line 497
  tmp = xcalloc((size_t )(argc + 1), (size_t )sizeof(*(argv + 0)));
#line 497
  argv = (char **)tmp;
#line 498
  j = 0;
#line 498
  i = j;
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (i < argc)) {
#line 498
      goto while_break;
    }
    {
#line 500
    tmp___1 = assert_grecs_value_type(locus, (grecs_value_t const   *)(val->v.arg.v + i),
                                      0);
    }
#line 500
    if (tmp___1 == 0) {
      {
#line 502
      tmp___0 = j;
#line 502
      j ++;
#line 502
      *(argv + tmp___0) = xstrdup((val->v.arg.v + i)->v.string);
      }
    }
#line 498
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  *(argv + j) = (char *)((void *)0);
#line 505
  if (pargc) {
#line 506
    *pargc = (size_t )argc;
  }
#line 507
  return (argv);
}
}
#line 510 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_command(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                       grecs_value_t *value , void *cb_data ) 
{ 
  struct component *comp ;
  struct wordsplit ws ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 515
  comp = (struct component *)varptr;
  {
#line 520
  if (value->type == 0) {
#line 520
    goto case_0;
  }
#line 530
  if (value->type == 2) {
#line 530
    goto case_2;
  }
#line 534
  if (value->type == 1) {
#line 534
    goto case_1;
  }
#line 518
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 521
  tmp___1 = wordsplit(value->v.string, & ws, 1860);
  }
#line 521
  if (tmp___1) {
    {
#line 523
    tmp = __errno_location();
#line 523
    tmp___0 = strerror(*tmp);
#line 523
    grecs_error(locus, 0, "wordsplit: %s", tmp___0);
    }
#line 524
    return (1);
  }
#line 526
  comp->argc = ws.ws_wordc;
#line 527
  comp->argv = ws.ws_wordv;
#line 528
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 531
  comp->argv = config_array_to_argv(value, locus, & comp->argc);
  }
#line 532
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 535
  tmp___2 = gettext("unexpected list");
#line 535
  grecs_error(locus, 0, (char const   *)tmp___2);
  }
#line 536
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 538
  return (0);
}
}
#line 541 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_umask(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                     grecs_value_t *value , void *cb_data ) 
{ 
  mode_t *pmode ;
  char *p ;
  unsigned long n ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp12 ;

  {
  {
#line 546
  pmode = (mode_t *)varptr;
#line 550
  tmp = assert_scalar_stmt(locus, cmd);
  }
#line 550
  if (tmp) {
#line 552
    return (1);
  } else {
    {
#line 550
    tmp___0 = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
    }
#line 550
    if (tmp___0) {
#line 552
      return (1);
    }
  }
  {
#line 553
  n = strtoul((char const   */* __restrict  */)value->v.string, (char **/* __restrict  */)(& p),
              8);
  }
#line 554
  if (*p) {
    {
#line 556
    tmp___1 = gettext("invalid octal number");
#line 556
    grecs_error(locus, 0, (char const   *)tmp___1);
    }
#line 557
    return (1);
  }
#line 559
  *pmode = (mode_t )n;
#line 560
  return (0);
}
}
#line 563 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_env(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                   grecs_value_t *value , void *cb_data ) 
{ 
  int argc ;
  char **argv ;
  char ***penv ;
  struct wordsplit ws ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 570
  penv = (char ***)varptr;
  {
#line 575
  if (value->type == 0) {
#line 575
    goto case_0;
  }
#line 586
  if (value->type == 2) {
#line 586
    goto case_2;
  }
#line 590
  if (value->type == 1) {
#line 590
    goto case_1;
  }
#line 573
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 576
  tmp___1 = wordsplit(value->v.string, & ws, 1860);
  }
#line 576
  if (tmp___1) {
    {
#line 578
    tmp = __errno_location();
#line 578
    tmp___0 = strerror(*tmp);
#line 578
    grecs_error(locus, 0, "wordsplit: %s", tmp___0);
    }
#line 579
    return (1);
  }
#line 581
  argc = (int )ws.ws_wordc;
#line 582
  argv = ws.ws_wordv;
#line 583
  ws.ws_wordv = (char **)((void *)0);
#line 584
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 587
  argv = config_array_to_argv(value, locus, (size_t *)((void *)0));
  }
#line 588
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 591
  tmp___2 = gettext("unexpected list");
#line 591
  grecs_error(locus, 0, (char const   *)tmp___2);
  }
#line 592
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 595
  *penv = argv;
#line 596
  return (0);
}
}
#line 603
int string_to_syslog_priority(char const   *key , int *pres ) ;
#line 603 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct tokendef tokdef_prio[9]  = 
#line 603
  {      {(char *)"EMERG", 0}, 
        {(char *)"ALERT", 1}, 
        {(char *)"CRIT", 2}, 
        {(char *)"ERR", 3}, 
        {(char *)"WARNING", 4}, 
        {(char *)"NOTICE", 5}, 
        {(char *)"INFO", 6}, 
        {(char *)"DEBUG", 7}, 
        {(char *)((void *)0), 0}};
#line 600 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int string_to_syslog_priority(char const   *key , int *pres ) 
{ 
  int tmp ;

  {
  {
#line 615
  tmp = strtotok_ci(tokdef_prio, key, pres);
  }
#line 615
  return (tmp);
}
}
#line 621
int string_to_syslog_facility(char const   *key , int *pres ) ;
#line 621 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct tokendef tokdef_fac[21]  = 
#line 621
  {      {(char *)"auth", 4 << 3}, 
        {(char *)"authpriv", 10 << 3}, 
        {(char *)"cron", 9 << 3}, 
        {(char *)"daemon", 3 << 3}, 
        {(char *)"ftp", 11 << 3}, 
        {(char *)"kern", 0}, 
        {(char *)"lpr", 6 << 3}, 
        {(char *)"mail", 2 << 3}, 
        {(char *)"news", 7 << 3}, 
        {(char *)"syslog", 5 << 3}, 
        {(char *)"user", 1 << 3}, 
        {(char *)"uucp", 8 << 3}, 
        {(char *)"local0", 16 << 3}, 
        {(char *)"local1", 17 << 3}, 
        {(char *)"local2", 18 << 3}, 
        {(char *)"local3", 19 << 3}, 
        {(char *)"local4", 20 << 3}, 
        {(char *)"local5", 21 << 3}, 
        {(char *)"local6", 22 << 3}, 
        {(char *)"local7", 23 << 3}, 
        {(char *)((void *)0), 0}};
#line 618 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int string_to_syslog_facility(char const   *key , int *pres ) 
{ 
  int tmp ;

  {
  {
#line 645
  tmp = strtotok_ci(tokdef_fac, key, pres);
  }
#line 645
  return (tmp);
}
}
#line 648 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int cb_syslog_facility(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                              void *varptr , grecs_value_t *value , void *cb_data ) 
{ 
  char const   *str ;
  int tmp ;
  char *p ;
  int n ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 655
  tmp = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
  }
#line 655
  if (tmp) {
#line 656
    return (1);
  }
  {
#line 657
  str = value->v.string;
#line 658
  tmp___4 = c_isdigit((int )*(str + 0));
  }
#line 658
  if (tmp___4) {
    {
#line 661
    tmp___0 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& p),
                      10);
#line 661
    n = (int )tmp___0;
    }
#line 662
    if (*p) {
      {
#line 663
      tmp___1 = gettext("expected facility number or symbolic name");
#line 663
      grecs_error(locus, 0, (char const   *)tmp___1);
      }
    } else {
#line 666
      *((int *)varptr) = n;
    }
  } else {
    {
#line 668
    tmp___3 = string_to_syslog_facility(str, (int *)varptr);
    }
#line 668
    if (tmp___3) {
      {
#line 669
      tmp___2 = gettext("unknown syslog facility `%s\'");
#line 669
      grecs_error(locus, 0, (char const   *)tmp___2, str);
      }
    }
  }
#line 670
  return (0);
}
}
#line 679
static int _cb_redir(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                     grecs_value_t *value , void *cb_data ) ;
#line 679 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct tokendef redirtab[4]  = {      {(char *)"null", 0}, 
        {(char *)"syslog", 1}, 
        {(char *)"file", 2}, 
        {(char *)((void *)0), 0}};
#line 673 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_redir(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                     grecs_value_t *value , void *cb_data ) 
{ 
  struct redirector *rp ;
  int res ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 678
  rp = (struct redirector *)varptr;
  {
#line 689
  if (value->type == 0) {
#line 689
    goto case_0;
  }
#line 704
  if (value->type == 2) {
#line 704
    goto case_2;
  }
#line 749
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 690
  tmp = strcmp(value->v.string, "null");
  }
#line 690
  if (tmp == 0) {
#line 692
    rp->type = (enum redir_type )0;
#line 693
    goto switch_break;
  }
  {
#line 695
  rp->type = (enum redir_type )1;
#line 696
  tmp___1 = string_to_syslog_priority(value->v.string, & rp->v.prio);
  }
#line 696
  if (tmp___1) {
    {
#line 698
    tmp___0 = gettext("unknown syslog priority `%s\'");
#line 698
    grecs_error(locus, 0, (char const   *)tmp___0, value->v.string);
    }
#line 700
    return (0);
  }
#line 702
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 705
  tmp___2 = assert_grecs_value_type(locus, (grecs_value_t const   *)(value->v.arg.v + 0),
                                    0);
  }
#line 705
  if (tmp___2) {
#line 707
    return (0);
  }
  {
#line 708
  tmp___8 = strtotok(redirtab, (value->v.arg.v + 0)->v.string, & res);
  }
#line 708
  if (tmp___8) {
    {
#line 709
    tmp___3 = gettext("%s: unrecognised redirector type");
#line 709
    grecs_error(locus, 0, (char const   *)tmp___3, (value->v.arg.v + 0)->v.string);
    }
  } else {
#line 713
    if (res != 0) {
#line 715
      if (value->v.arg.c != 2U) {
        {
#line 717
        tmp___4 = gettext("wrong number of arguments");
#line 717
        grecs_error(locus, 0, (char const   *)tmp___4);
        }
#line 718
        return (0);
      }
      {
#line 720
      tmp___5 = assert_grecs_value_type(locus, (grecs_value_t const   *)(value->v.arg.v + 1),
                                        0);
      }
#line 720
      if (tmp___5) {
#line 722
        return (0);
      }
      {
#line 726
      if (res == 0) {
#line 726
        goto case_0___0;
      }
#line 729
      if (res == 1) {
#line 729
        goto case_1;
      }
#line 740
      if (res == 2) {
#line 740
        goto case_2___0;
      }
#line 724
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 727
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 730
      tmp___7 = string_to_syslog_priority((value->v.arg.v + 1)->v.string, & rp->v.prio);
      }
#line 730
      if (tmp___7) {
        {
#line 733
        tmp___6 = gettext("unknown syslog priority `%s\'");
#line 733
        grecs_error(locus, 0, (char const   *)tmp___6, (value->v.arg.v + 1)->v.string);
        }
#line 736
        return (0);
      }
#line 738
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 741
      rp->v.file = xstrdup((value->v.arg.v + 1)->v.string);
      }
#line 742
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 745
    rp->type = (enum redir_type )res;
  }
#line 747
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 750
  tmp___9 = gettext("unexpected list");
#line 750
  grecs_error(locus, 0, (char const   *)tmp___9);
  }
  switch_break: /* CIL Label */ ;
  }
#line 753
  return (0);
}
}
#line 756 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_url(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                   grecs_value_t *value , void *cb_data ) 
{ 
  struct pies_url *url ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;

  {
  {
#line 763
  tmp = assert_scalar_stmt(locus, cmd);
  }
#line 763
  if (tmp) {
#line 765
    return (1);
  } else {
    {
#line 763
    tmp___0 = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
    }
#line 763
    if (tmp___0) {
#line 765
      return (1);
    }
  }
  {
#line 766
  tmp___4 = pies_url_create(& url, value->v.string);
  }
#line 766
  if (tmp___4) {
    {
#line 768
    tmp___1 = __errno_location();
#line 768
    tmp___2 = strerror(*tmp___1);
#line 768
    tmp___3 = gettext("%s: cannot create URL: %s");
#line 768
    grecs_error(locus, 0, (char const   *)tmp___3, value->v.string, tmp___2);
    }
#line 770
    return (0);
  }
#line 772
  *((struct pies_url **)varptr) = url;
#line 773
  return (0);
}
}
#line 776 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct tokendef socktype_xtab[7]  = {      {(char *)"stream", 1}, 
        {(char *)"dgram", 2}, 
        {(char *)"seqpacket", 5}, 
        {(char *)"raw", 3}, 
        {(char *)"rdm", 4}, 
        {(char *)"packet", 10}, 
        {(char *)((void *)0), 0}};
#line 788 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int str_to_socket_type(char const   *str , int *pres ) 
{ 
  int tmp ;

  {
  {
#line 791
  tmp = strtotok(socktype_xtab, str, pres);
  }
#line 791
  return (tmp);
}
}
#line 794 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int socket_type_to_str(int socket_type , char const   **pres ) 
{ 
  int tmp ;

  {
  {
#line 797
  tmp = toktostr(socktype_xtab, socket_type, pres);
  }
#line 797
  return (tmp);
}
}
#line 800 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_socket_type(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                           void *varptr , grecs_value_t *value , void *cb_data ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;

  {
  {
#line 805
  tmp = assert_scalar_stmt(locus, cmd);
  }
#line 805
  if (tmp) {
#line 807
    return (1);
  } else {
    {
#line 805
    tmp___0 = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
    }
#line 805
    if (tmp___0) {
#line 807
      return (1);
    }
  }
  {
#line 809
  tmp___2 = str_to_socket_type(value->v.string, (int *)varptr);
  }
#line 809
  if (tmp___2) {
    {
#line 810
    tmp___1 = gettext("bad socket type");
#line 810
    grecs_error(locus, 0, (char const   *)tmp___1);
    }
  }
#line 811
  return (0);
}
}
#line 814 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct tokendef modetab[8]  = 
#line 814
  {      {(char *)"exec", 0}, 
        {(char *)"wait", 0}, 
        {(char *)"accept", 1}, 
        {(char *)"inetd", 2}, 
        {(char *)"nostartaccept", 2}, 
        {(char *)"pass-fd", 3}, 
        {(char *)"pass", 3}, 
        {(char *)((void *)0), 0}};
#line 825 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_mode(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                    grecs_value_t *value , void *cb_data ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;

  {
  {
#line 832
  tmp = assert_scalar_stmt(locus, cmd);
  }
#line 832
  if (tmp) {
#line 834
    return (1);
  } else {
    {
#line 832
    tmp___0 = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
    }
#line 832
    if (tmp___0) {
#line 834
      return (1);
    }
  }
  {
#line 835
  tmp___2 = strtotok(modetab, value->v.string, & res);
  }
#line 835
  if (tmp___2) {
    {
#line 836
    tmp___1 = gettext("%s: unrecognised mode");
#line 836
    grecs_error(locus, 0, (char const   *)tmp___1, value->v.string);
    }
  } else {
#line 838
    *((enum pies_comp_mode *)varptr) = (enum pies_comp_mode )res;
  }
#line 839
  return (0);
}
}
#line 842 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_limits(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                      grecs_value_t *value , void *cb_data ) 
{ 
  limits_record_t *plrec ;
  char *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;

  {
  {
#line 847
  plrec = (limits_record_t *)varptr;
#line 850
  tmp = assert_scalar_stmt(locus, cmd);
  }
#line 850
  if (tmp) {
#line 852
    return (1);
  } else {
    {
#line 850
    tmp___0 = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
    }
#line 850
    if (tmp___0) {
#line 852
      return (1);
    }
  }
  {
#line 853
  tmp___2 = parse_limits(plrec, (char *)value->v.string, & p);
  }
#line 853
  if (tmp___2) {
    {
#line 854
    tmp___1 = gettext("invalid limit string (near %s)");
#line 854
    grecs_error(locus, 0, (char const   *)tmp___1, p);
    }
  }
#line 855
  return (0);
}
}
#line 865
int str_to_cf(char const   *string , int *flags ) ;
#line 865 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct tokendef cf_tab[9]  = 
#line 865
  {      {(char *)"disable", 1}, 
        {(char *)"precious", 2}, 
        {(char *)"wait", 4}, 
        {(char *)"tcpmux", 8}, 
        {(char *)"tcpmuxplus", 16}, 
        {(char *)"internal", 32}, 
        {(char *)"sockenv", 64}, 
        {(char *)"resolve", 128}, 
        {(char *)((void *)0), 0}};
#line 858 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int str_to_cf(char const   *string , int *flags ) 
{ 
  size_t len ;
  size_t tmp ;
  int neg ;
  int mask ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 861
  tmp = strlen(string);
#line 861
  len = tmp;
#line 862
  neg = 0;
  }
#line 877
  if (len > 2U) {
    {
#line 877
    tmp___0 = memcmp((void const   *)string, (void const   *)"no", (size_t )2);
    }
#line 877
    if (tmp___0 == 0) {
#line 879
      neg ++;
#line 880
      string += 2;
    }
  }
  {
#line 883
  tmp___1 = strtotok(cf_tab, string, & mask);
  }
#line 883
  if (tmp___1) {
#line 884
    return (1);
  }
#line 886
  if (neg) {
#line 887
    *flags &= ~ mask;
  } else {
#line 889
    *flags |= mask;
  }
#line 890
  return (0);
}
}
#line 893 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_flags(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                     grecs_value_t *value , void *cb_data ) 
{ 
  int *flags ;
  char *tmp ;
  int tmp___0 ;
  void const   *p ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp___1 ;
  grecs_value_t const   *vp ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 898
  flags = (int *)varptr;
  {
#line 902
  if (value->type == 0) {
#line 902
    goto case_0;
  }
#line 910
  if (value->type == 1) {
#line 910
    goto case_1;
  }
#line 930
  if (value->type == 2) {
#line 930
    goto case_2;
  }
#line 900
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 903
  tmp___0 = str_to_cf(value->v.string, flags);
  }
#line 903
  if (tmp___0) {
    {
#line 905
    tmp = gettext("%s: unrecognised flag");
#line 905
    grecs_error(locus, 0, (char const   *)tmp, value->v.string);
    }
#line 906
    return (1);
  }
#line 908
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 913
  tmp___1 = gl_list_iterator_inline(value->v.list);
#line 913
  itr = tmp___1;
  }
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 915
    tmp___5 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
    }
#line 915
    if (! tmp___5) {
#line 915
      goto while_break;
    }
    {
#line 917
    vp = (grecs_value_t const   *)p;
#line 918
    tmp___2 = assert_grecs_value_type(locus, vp, 0);
    }
#line 918
    if (tmp___2) {
#line 919
      return (1);
    }
    {
#line 920
    tmp___4 = str_to_cf((char const   *)vp->v.string, flags);
    }
#line 920
    if (tmp___4) {
      {
#line 922
      tmp___3 = gettext("%s: unrecognised flag");
#line 922
      grecs_error(locus, 0, (char const   *)tmp___3, vp->v.string);
      }
#line 924
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 928
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 931
  tmp___6 = gettext("too many arguments");
#line 931
  grecs_error(locus, 0, (char const   *)tmp___6);
  }
#line 932
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 934
  return (0);
}
}
#line 938 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct grecs_keyword component_keywords[28]  = 
#line 938
  {      {"mode", "mode: {exec | wait | accept | inetd | nostartaccept | pass-fd | pass}",
      "Component execution mode.", (enum grecs_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->mode)),
      & _cb_mode, (void *)0, (struct grecs_keyword *)0}, 
        {"program", (char const   *)((void *)0), "Full name of the program.", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->program)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"command", (char const   *)((void *)0), "Command line.", (enum grecs_data_type )1,
      (void *)0, (size_t )0, & _cb_command, (void *)0, (struct grecs_keyword *)0}, 
        {"prerequisites",
      "list", "List of prerequisites.", (enum grecs_data_type )32769, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->prereq)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"dependents", "list", "List of components for which this one is a prerequisite.",
      (enum grecs_data_type )32769, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->depend)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"flags", "list", "List of flags.", (enum grecs_data_type )32769, (void *)0,
      (size_t )((unsigned long )(& ((struct component *)0)->flags)), & _cb_flags,
      (void *)0, (struct grecs_keyword *)0}, 
        {"pass-fd-timeout", (char const   *)((void *)0), "Time to wait for pass-fd socket to become available.",
      (enum grecs_data_type )5, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->pass_fd_timeout)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"max-instances", (char const   *)((void *)0), "Maximum number of running instances.",
      (enum grecs_data_type )8, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->max_instances)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"max-rate", (char const   *)((void *)0), "Maximum number of times an inetd component can be invoked in one minute.",
      (enum grecs_data_type )8, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->max_rate)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"socket", "url: string", "Listen on the given url.", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->socket_url)),
      & _cb_url, (void *)0, (struct grecs_keyword *)0}, 
        {"socket-type", "type: {stream | dgram | raw | rdm | seqpacket}", "Set socket type.",
      (enum grecs_data_type )4, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->socket_type)),
      & _cb_socket_type, (void *)0, (struct grecs_keyword *)0}, 
        {"pass-fd-socket", "name", "Pass fd through this socket.", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->pass_fd_socket)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"acl", "name: string", "Set ACL.", (enum grecs_data_type )17, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->acl)),
      & acl_section_parser, (void *)0, acl_keywords}, 
        {"remove-file", "file", "Remove file before starting the component.", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->rmfile)), (int (*)(enum grecs_callback_command cmd ,
                                                                                          grecs_locus_t * ,
                                                                                          void * ,
                                                                                          grecs_value_t * ,
                                                                                          void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"facility", "arg", "Override default syslog facility for this component.", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->facility)),
      & cb_syslog_facility, (void *)0, (struct grecs_keyword *)0}, 
        {"stdout", "type: {file | syslog}> <channel: string", "Redirect program\'s standard output to the given file or syslog priority.",
      (enum grecs_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->redir[0])),
      & _cb_redir, (void *)0, (struct grecs_keyword *)0}, 
        {"stderr", "type: {file | syslog}> <channel: string", "Redirect program\'s standard error to the given file or syslog priority.",
      (enum grecs_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->redir[1])),
      & _cb_redir, (void *)0, (struct grecs_keyword *)0}, 
        {"user", (char const   *)((void *)0), "Run with this user privileges.", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->privs.user)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"group", (char const   *)((void *)0), "Retain supplementary group.", (enum grecs_data_type )32769,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->privs.groups)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"allgroups", (char const   *)((void *)0), "Retain all supplementary groups of which user is a member.",
      (enum grecs_data_type )12, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->privs.allgroups)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"umask", "arg: number", "Force this umask.", (enum grecs_data_type )1, (void *)0,
      (size_t )((unsigned long )(& ((struct component *)0)->umask)), & _cb_umask,
      (void *)0, (struct grecs_keyword *)0}, 
        {"limits", (char const   *)((void *)0), "Set system limits", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->limits)), & _cb_limits,
      (void *)0, (struct grecs_keyword *)0}, 
        {"env", "arg: list", "Set program environment.  Argument is a list of assignments separated by white space.",
      (enum grecs_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->env)),
      & _cb_env, (void *)0, (struct grecs_keyword *)0}, 
        {"chdir", "dir", "Change to this directory before executing the component.",
      (enum grecs_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->dir)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"return-code", "tag: exit-code-list", "Define what to do when the component finishes.",
      (enum grecs_data_type )17, (void *)0, (size_t )0, & return_code_section_parser,
      (void *)0, return_code_keywords}, 
        {"service", "name", "Service name for inetd component.", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->service)),
      (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
               void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"tcpmux-master", "tag", "Tag of master TCPMUX component.", (enum grecs_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct component *)0)->tcpmux)), (int (*)(enum grecs_callback_command cmd ,
                                                                                          grecs_locus_t * ,
                                                                                          void * ,
                                                                                          grecs_value_t * ,
                                                                                          void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {(char const   *)((void *)0), (char const   *)0, (char const   *)0, 0U, (void *)0,
      0U, (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
                   void * ))0, (void *)0, (struct grecs_keyword *)0}};
#line 1113 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct grecs_keyword *find_component_keyword(char const   *ident___0 ) 
{ 
  struct grecs_keyword *kwp ;
  int tmp ;

  {
#line 1118
  kwp = component_keywords;
  {
#line 1118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1118
    if (! kwp->ident) {
#line 1118
      goto while_break;
    }
    {
#line 1119
    tmp = strcmp(kwp->ident, ident___0);
    }
#line 1119
    if (tmp == 0) {
#line 1120
      return (kwp);
    }
#line 1118
    kwp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1121
  return ((struct grecs_keyword *)((void *)0));
}
}
#line 1124 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static char *make_full_name(char const   *dir , char const   *file ) 
{ 
  char *p ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1128
  tmp = strlen(dir);
#line 1128
  len = tmp;
  }
  {
#line 1130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1130
    if (len > 0U) {
#line 1130
      if (! ((int const   )*(dir + (len - 1U)) == 47)) {
#line 1130
        goto while_break;
      }
    } else {
#line 1130
      goto while_break;
    }
#line 1131
    len --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1132
  tmp___0 = strlen(file);
#line 1132
  tmp___1 = xmalloc(((len + 1U) + tmp___0) + 1U);
#line 1132
  p = (char *)tmp___1;
#line 1133
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)dir, len);
#line 1134
  tmp___2 = len;
#line 1134
  len ++;
#line 1134
  *(p + tmp___2) = (char )'/';
#line 1135
  strcpy((char */* __restrict  */)(p + len), (char const   */* __restrict  */)file);
  }
#line 1136
  return (p);
}
}
#line 1139 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int component_verify(struct component *comp , grecs_locus_t *locus ) 
{ 
  int header ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *p ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *p___0 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;

  {
#line 1142
  header = 0;
#line 1156
  if (comp->flags & 32) {
#line 1158
    comp->mode = (enum pies_comp_mode )2;
#line 1159
    if (! comp->service) {
      {
#line 1161
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1161
        if (! header) {
          {
#line 1161
          tmp = gettext("in component %s:");
#line 1161
          grecs_warning(locus, 0, (char const   *)tmp, comp->tag);
#line 1161
          header = 1;
          }
        }
        {
#line 1161
        tmp___0 = gettext("`internal\' used without `service\'");
#line 1161
        grecs_error(locus, 0, "%s", tmp___0);
        }
#line 1161
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1165
      comp->builtin = inetd_builtin_lookup((char const   *)comp->service, comp->socket_type);
      }
#line 1167
      if (! comp->builtin) {
        {
#line 1168
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1168
          if (! header) {
            {
#line 1168
            tmp___1 = gettext("in component %s:");
#line 1168
            grecs_warning(locus, 0, (char const   *)tmp___1, comp->tag);
#line 1168
            header = 1;
            }
          }
          {
#line 1168
          tmp___2 = gettext("unknown internal service");
#line 1168
          grecs_error(locus, 0, "%s", tmp___2);
          }
#line 1168
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1170
      if (comp->argv) {
        {
#line 1173
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1173
          if (! header) {
            {
#line 1173
            tmp___3 = gettext("in component %s:");
#line 1173
            grecs_warning(locus, 0, (char const   *)tmp___3, comp->tag);
#line 1173
            header = 1;
            }
          }
          {
#line 1173
          tmp___4 = gettext("`internal\' used with `command\'");
#line 1173
          grecs_error(locus, 0, "%s", tmp___4);
          }
#line 1173
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  } else
#line 1177
  if (! comp->argv) {
    {
#line 1178
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1178
      if (! header) {
        {
#line 1178
        tmp___5 = gettext("in component %s:");
#line 1178
        grecs_warning(locus, 0, (char const   *)tmp___5, comp->tag);
#line 1178
        header = 1;
        }
      }
      {
#line 1178
      tmp___6 = gettext("missing command line");
#line 1178
      grecs_error(locus, 0, "%s", tmp___6);
      }
#line 1178
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1181
  if (comp->flags & 24) {
#line 1183
    comp->mode = (enum pies_comp_mode )2;
#line 1184
    if ((comp->flags & 24) == 24) {
      {
#line 1186
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1186
        if (! header) {
          {
#line 1186
          tmp___7 = gettext("in component %s:");
#line 1186
          grecs_warning(locus, 0, (char const   *)tmp___7, comp->tag);
#line 1186
          header = 1;
          }
        }
        {
#line 1186
        tmp___8 = gettext("both `tcpmux\' and `tcpmuxplus\' used");
#line 1186
        grecs_error(locus, 0, "%s", tmp___8);
        }
#line 1186
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 1188
    if (! comp->service) {
      {
#line 1190
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1190
        if (! header) {
          {
#line 1190
          tmp___9 = gettext("in component %s:");
#line 1190
          grecs_warning(locus, 0, (char const   *)tmp___9, comp->tag);
#line 1190
          header = 1;
          }
        }
        {
#line 1190
        tmp___10 = gettext("`internal\' used without `service\'");
#line 1190
        grecs_error(locus, 0, "%s", tmp___10);
        }
#line 1190
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1194
  if (comp->pass_fd_socket) {
#line 1194
    if ((unsigned int )comp->mode != 3U) {
      {
#line 1195
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1195
        if (! header) {
          {
#line 1195
          tmp___11 = gettext("in component %s:");
#line 1195
          grecs_warning(locus, 0, (char const   *)tmp___11, comp->tag);
#line 1195
          header = 1;
          }
        }
        {
#line 1195
        tmp___12 = gettext("pass-fd-socket ignored: wrong mode");
#line 1195
        grecs_error(locus, 0, "%s", tmp___12);
        }
#line 1195
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
  {
#line 1199
  if ((unsigned int )comp->mode == 0U) {
#line 1199
    goto case_0;
  }
#line 1205
  if ((unsigned int )comp->mode == 3U) {
#line 1205
    goto case_3;
  }
#line 1224
  if ((unsigned int )comp->mode == 1U) {
#line 1224
    goto case_1;
  }
#line 1234
  if ((unsigned int )comp->mode == 2U) {
#line 1234
    goto case_2;
  }
#line 1197
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1200
  if (comp->socket_url) {
    {
#line 1201
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1201
      if (! header) {
        {
#line 1201
        tmp___13 = gettext("in component %s:");
#line 1201
        grecs_warning(locus, 0, (char const   *)tmp___13, comp->tag);
#line 1201
        header = 1;
        }
      }
      {
#line 1201
      tmp___14 = gettext("socket ignored: wrong mode");
#line 1201
      grecs_error(locus, 0, "%s", tmp___14);
      }
#line 1201
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1203
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1206
  if (! comp->pass_fd_socket) {
    {
#line 1207
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1207
      if (! header) {
        {
#line 1207
        tmp___15 = gettext("in component %s:");
#line 1207
        grecs_warning(locus, 0, (char const   *)tmp___15, comp->tag);
#line 1207
        header = 1;
        }
      }
      {
#line 1207
      tmp___16 = gettext("must supply pass-fd-socket in this mode");
#line 1207
      grecs_error(locus, 0, "%s", tmp___16);
      }
#line 1207
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else
#line 1209
  if ((int )*(comp->pass_fd_socket + 0) != 47) {
#line 1211
    if (comp->dir) {
      {
#line 1213
      tmp___17 = make_full_name((char const   *)comp->dir, (char const   *)comp->pass_fd_socket);
#line 1213
      p = tmp___17;
#line 1215
      comp->pass_fd_socket = p;
      }
    } else {
      {
#line 1218
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1218
        if (! header) {
          {
#line 1218
          tmp___18 = gettext("in component %s:");
#line 1218
          grecs_warning(locus, 0, (char const   *)tmp___18, comp->tag);
#line 1218
          header = 1;
          }
        }
        {
#line 1218
        tmp___19 = gettext("pass-fd-socket must be an absolute file name or chdir must be specified");
#line 1218
        grecs_error(locus, 0, "%s", tmp___19);
        }
#line 1218
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
  case_1: /* CIL Label */ 
#line 1225
  if (! comp->socket_url) {
    {
#line 1227
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1227
      if (! header) {
        {
#line 1227
        tmp___20 = gettext("in component %s:");
#line 1227
        grecs_warning(locus, 0, (char const   *)tmp___20, comp->tag);
#line 1227
        header = 1;
        }
      }
      {
#line 1227
      tmp___21 = gettext("socket must be specified in this mode");
#line 1227
      grecs_error(locus, 0, "%s", tmp___21);
      }
#line 1227
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1230
    return (1);
  }
#line 1232
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1235
  if (comp->flags & 24) {
    {
#line 1237
    pies_url_destroy(& comp->socket_url);
    }
#line 1238
    if (! comp->tcpmux) {
      {
#line 1240
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1240
        if (! header) {
          {
#line 1240
          tmp___22 = gettext("in component %s:");
#line 1240
          grecs_warning(locus, 0, (char const   *)tmp___22, comp->tag);
#line 1240
          header = 1;
          }
        }
        {
#line 1240
        tmp___23 = gettext("TCPMUX master not specified, assuming \"tcpmux\"");
#line 1240
        grecs_warning(locus, 0, "%s", tmp___23);
        }
#line 1240
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1243
      comp->tcpmux = xstrdup("tcpmux");
      }
    }
  } else
#line 1246
  if (comp->tcpmux) {
    {
#line 1248
    comp->flags |= 8;
#line 1249
    pies_url_destroy(& comp->socket_url);
    }
  } else
#line 1251
  if (! comp->socket_url) {
    {
#line 1253
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1253
      if (! header) {
        {
#line 1253
        tmp___24 = gettext("in component %s:");
#line 1253
        grecs_warning(locus, 0, (char const   *)tmp___24, comp->tag);
#line 1253
        header = 1;
        }
      }
      {
#line 1253
      tmp___25 = gettext("socket must be specified in this mode");
#line 1253
      grecs_error(locus, 0, "%s", tmp___25);
      }
#line 1253
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1256
    return (1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1260
  if ((unsigned int )comp->mode == 2U) {
#line 1262
    if (comp->flags & 4) {
#line 1262
      if (comp->socket_type == 1) {
#line 1264
        if (comp->max_instances) {
          {
#line 1265
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 1265
            if (! header) {
              {
#line 1265
              tmp___26 = gettext("in component %s:");
#line 1265
              grecs_warning(locus, 0, (char const   *)tmp___26, comp->tag);
#line 1265
              header = 1;
              }
            }
            {
#line 1265
            tmp___27 = gettext("max-instances ignored");
#line 1265
            grecs_error(locus, 0, "%s", tmp___27);
            }
#line 1265
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        } else {
#line 1267
          comp->max_instances = (size_t )1;
        }
      }
    }
  } else
#line 1270
  if (comp->flags & 4) {
    {
#line 1273
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1273
      if (! header) {
        {
#line 1273
        tmp___28 = gettext("in component %s:");
#line 1273
        grecs_warning(locus, 0, (char const   *)tmp___28, comp->tag);
#line 1273
        header = 1;
        }
      }
      {
#line 1273
      tmp___29 = gettext("wait is useless in this mode");
#line 1273
      grecs_error(locus, 0, "%s", tmp___29);
      }
#line 1273
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1274
    comp->flags &= -5;
  }
#line 1277
  if ((unsigned int )comp->mode != 0U) {
#line 1277
    if ((unsigned int )comp->redir[0].type != 0U) {
      {
#line 1280
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1280
        if (! header) {
          {
#line 1280
          tmp___30 = gettext("in component %s:");
#line 1280
          grecs_warning(locus, 0, (char const   *)tmp___30, comp->tag);
#line 1280
          header = 1;
          }
        }
        {
#line 1280
        tmp___31 = gettext("stdout translation invalid in this mode");
#line 1280
        grecs_error(locus, 0, "%s", tmp___31);
        }
#line 1280
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 1282
      comp->redir[0].type = (enum redir_type )0;
    }
  }
#line 1285
  i = 0;
  {
#line 1285
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 1285
    if (! (i <= 1)) {
#line 1285
      goto while_break___15;
    }
#line 1287
    if ((unsigned int )comp->redir[i].type == 2U) {
#line 1287
      if ((int )*(comp->redir[i].v.file + 0) != 47) {
#line 1290
        if (comp->dir) {
          {
#line 1292
          tmp___32 = make_full_name((char const   *)comp->dir, (char const   *)comp->redir[i].v.file);
#line 1292
          p___0 = tmp___32;
#line 1293
          free((void *)comp->redir[i].v.file);
#line 1294
          comp->redir[i].v.file = p___0;
          }
        } else {
          {
#line 1297
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 1297
            if (! header) {
              {
#line 1297
              tmp___33 = gettext("in component %s:");
#line 1297
              grecs_warning(locus, 0, (char const   *)tmp___33, comp->tag);
#line 1297
              header = 1;
              }
            }
            {
#line 1297
            tmp___34 = gettext("%s: must be an absolute file name or chdir must be specified");
#line 1297
            grecs_error(locus, 0, (char const   *)tmp___34, comp->redir[i].v.file);
            }
#line 1297
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
      }
    }
#line 1285
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 1304
  return (header);
}
}
#line 1308 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct component *component_create(char const   *name ) 
{ 
  struct component *comp ;
  struct component *tmp ;
  void *tmp___0 ;
  enum redir_type tmp___1 ;

  {
  {
#line 1311
  tmp = progman_lookup_component(name);
#line 1311
  comp = tmp;
  }
#line 1312
  if (! comp) {
    {
#line 1314
    tmp___0 = xzalloc((size_t )sizeof(*comp));
#line 1314
    comp = (struct component *)tmp___0;
#line 1315
    comp->facility = log_facility;
#line 1316
    tmp___1 = (enum redir_type )0;
#line 1316
    comp->redir[1].type = tmp___1;
#line 1316
    comp->redir[0].type = tmp___1;
#line 1317
    comp->tag = xstrdup(name);
#line 1318
    comp->socket_type = 1;
    }
  }
#line 1320
  return (comp);
}
}
#line 1323 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void component_finish(struct component *comp , grecs_locus_t *locus ) 
{ 
  struct component *tmp ;
  int tmp___0 ;

  {
  {
#line 1326
  tmp___0 = component_verify(comp, locus);
  }
#line 1326
  if (tmp___0 == 0) {
    {
#line 1330
    tmp = progman_lookup_component((char const   *)comp->tag);
    }
#line 1330
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 1331
      register_prog(comp);
      }
    }
  }
#line 1333
  return;
}
}
#line 1335 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int component_section_parser(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                                    void *varptr , grecs_value_t *value , void *cb_data ) 
{ 
  struct component *comp ;
  void **section_data ;
  int tmp ;
  char *tmp___0 ;
  char *__cil_tmp10 ;

  {
#line 1341
  section_data = (void **)cb_data;
  {
#line 1345
  if ((unsigned int )cmd == 0U) {
#line 1345
    goto case_0;
  }
#line 1352
  if ((unsigned int )cmd == 1U) {
#line 1352
    goto case_1;
  }
#line 1357
  if ((unsigned int )cmd == 2U) {
#line 1357
    goto case_2;
  }
#line 1343
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1346
  tmp = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
  }
#line 1346
  if (tmp) {
#line 1347
    return (1);
  }
  {
#line 1348
  comp = component_create(value->v.string);
#line 1349
  *section_data = (void *)comp;
  }
#line 1350
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1353
  comp = *((struct component **)section_data);
#line 1354
  component_finish(comp, locus);
  }
#line 1355
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1358
  tmp___0 = gettext("expected block statement");
#line 1358
  grecs_error(locus, 0, (char const   *)tmp___0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1360
  return (0);
}
}
#line 1365 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct grecs_keyword syslog_kw[3]  = {      {"facility", "name", "Set syslog facility. Arg is one of the following: user, daemon, auth, authpriv, mail, cron, local0 through local7 (case-insensitive), or a facility number.",
      (enum grecs_data_type )1, (void *)(& log_facility), (size_t )0, & cb_syslog_facility,
      (void *)0, (struct grecs_keyword *)0}, 
        {"tag", "string", "Tag syslog messages with this string", (enum grecs_data_type )1,
      (void *)(& log_tag), 0U, (int (*)(enum grecs_callback_command cmd , grecs_locus_t * ,
                                        void * , grecs_value_t * , void * ))0, (void *)0,
      (struct grecs_keyword *)0}, 
        {(char const   *)((void *)0), (char const   *)0, (char const   *)0, 0U, (void *)0,
      0U, (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
                   void * ))0, (void *)0, (struct grecs_keyword *)0}};
#line 1386 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_include_meta1(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                             void *varptr , grecs_value_t *value , void *cb_data ) 
{ 
  int tmp ;

  {
  {
#line 1391
  tmp = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
  }
#line 1391
  if (tmp) {
#line 1392
    return (1);
  }
  {
#line 1393
  meta1_config_parse(value->v.string);
  }
#line 1394
  return (0);
}
}
#line 1397 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static int _cb_include_inetd(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                             void *varptr , grecs_value_t *value , void *cb_data ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1402
  tmp = assert_grecs_value_type(locus, (grecs_value_t const   *)value, 0);
  }
#line 1402
  if (tmp) {
#line 1403
    return (1);
  }
  {
#line 1404
  tmp___0 = inetd_parse_conf(value->v.string);
  }
#line 1404
  return (tmp___0);
}
}
#line 1407 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
struct grecs_keyword pies_keywords[24]  = 
#line 1407
  {      {"component", "tag: string", "Define a component", (enum grecs_data_type )17,
      (void *)0, (size_t )0, & component_section_parser, (void *)0, component_keywords}, 
        {"syslog",
      (char const   *)((void *)0), "Configure syslog logging", (enum grecs_data_type )17,
      (void *)0, (size_t )0, (int (*)(enum grecs_callback_command cmd , grecs_locus_t * ,
                                      void * , grecs_value_t * , void * ))((void *)0),
      (void *)0, syslog_kw}, 
        {"debug", (char const   *)((void *)0), "Set debug verbosity level.", (enum grecs_data_type )5,
      (void *)(& debug_level), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                    grecs_locus_t * , void * , grecs_value_t * ,
                                                    void * ))((void *)0), (void *)0,
      (struct grecs_keyword *)0}, 
        {"source-info", (char const   *)((void *)0), "Show source info with debugging messages.",
      (enum grecs_data_type )12, (void *)(& source_info_option), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                                                      grecs_locus_t * ,
                                                                                      void * ,
                                                                                      grecs_value_t * ,
                                                                                      void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"state-directory", (char const   *)((void *)0), "Full file name of the program state directory.",
      (enum grecs_data_type )1, (void *)(& statedir), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                                           grecs_locus_t * ,
                                                                           void * ,
                                                                           grecs_value_t * ,
                                                                           void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"pidfile", (char const   *)((void *)0), "Write PID to this file.", (enum grecs_data_type )1,
      (void *)(& pidfile), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                grecs_locus_t * , void * , grecs_value_t * ,
                                                void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"control-file",
      (char const   *)((void *)0), "Set location of the control file.", (enum grecs_data_type )1,
      (void *)(& ctlfile), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                grecs_locus_t * , void * , grecs_value_t * ,
                                                void * ))((void *)0), (void *)0, (struct grecs_keyword *)0}, 
        {"stat-file",
      (char const   *)((void *)0), "Set location of the statistics output file.",
      (enum grecs_data_type )1, (void *)(& statfile), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                                           grecs_locus_t * ,
                                                                           void * ,
                                                                           grecs_value_t * ,
                                                                           void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"qotd-file", (char const   *)((void *)0), "Set location of the QOTD file.",
      (enum grecs_data_type )1, (void *)(& qotdfile), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                                           grecs_locus_t * ,
                                                                           void * ,
                                                                           grecs_value_t * ,
                                                                           void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"user", (char const   *)((void *)0), "Run with this user privileges.", (enum grecs_data_type )1,
      (void *)(& pies_privs.user), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                        grecs_locus_t * , void * ,
                                                        grecs_value_t * , void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"group", (char const   *)((void *)0), "Retain supplementary group.", (enum grecs_data_type )32769,
      (void *)(& pies_privs.groups), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                          grecs_locus_t * , void * ,
                                                          grecs_value_t * , void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"allgroups", (char const   *)((void *)0), "Retain all supplementary groups of which user is a member.",
      (enum grecs_data_type )12, (void *)(& pies_privs.allgroups), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                                                        grecs_locus_t * ,
                                                                                        void * ,
                                                                                        grecs_value_t * ,
                                                                                        void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"umask", "arg: number", "Force this umask.", (enum grecs_data_type )1, (void *)(& pies_umask),
      (size_t )0, & _cb_umask, (void *)0, (struct grecs_keyword *)0}, 
        {"limits", (char const   *)((void *)0), "Set global system limits.", (enum grecs_data_type )1,
      (void *)(& pies_limits), (size_t )0, & _cb_limits, (void *)0, (struct grecs_keyword *)0}, 
        {"shutdown-timeout",
      "n", "Wait <n> seconds for all components to shut down.", (enum grecs_data_type )5,
      (void *)(& shutdown_timeout), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                         grecs_locus_t * , void * ,
                                                         grecs_value_t * , void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"return-code", "tag: exit-code-list", "Define what to do when the component finishes.",
      (enum grecs_data_type )17, (void *)(& default_component), (size_t )0, & return_code_section_parser,
      (void *)0, return_code_keywords}, 
        {"acl", "name: string", "Set global ACL.", (enum grecs_data_type )17, (void *)(& pies_acl),
      (size_t )0, & acl_section_parser, (void *)0, acl_keywords}, 
        {"defacl", "name: string", "Define an ACL.", (enum grecs_data_type )17, (void *)0,
      (size_t )0, & defacl_section_parser, (void *)0, acl_keywords}, 
        {"include-inetd", "file-or-dir: string", "Include inetd configuration file or directory",
      (enum grecs_data_type )1, (void *)0, (size_t )0, & _cb_include_inetd, (void *)0,
      (struct grecs_keyword *)0}, 
        {"include-meta1", "file: string", "Include components from the specified MeTA1 configuration file.",
      (enum grecs_data_type )1, (void *)0, (size_t )0, & _cb_include_meta1, (void *)0,
      (struct grecs_keyword *)0}, 
        {"meta1-queue-dir", (char const   *)((void *)0), "Set the name of MeTA1 queue directory (default /var/spool/meta1).",
      (enum grecs_data_type )1, (void *)(& meta1_queue_dir), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                                                  grecs_locus_t * ,
                                                                                  void * ,
                                                                                  grecs_value_t * ,
                                                                                  void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"mailer-program", (char const   *)((void *)0), "Full path to the mailer binary.",
      (enum grecs_data_type )1, (void *)(& mailer_program), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                                                 grecs_locus_t * ,
                                                                                 void * ,
                                                                                 grecs_value_t * ,
                                                                                 void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {"mailer-command-line", (char const   *)((void *)0), "Mailer command line (without recipient addresses).",
      (enum grecs_data_type )1, (void *)(& mailer_command_line), (size_t )0, (int (*)(enum grecs_callback_command cmd ,
                                                                                      grecs_locus_t * ,
                                                                                      void * ,
                                                                                      grecs_value_t * ,
                                                                                      void * ))((void *)0),
      (void *)0, (struct grecs_keyword *)0}, 
        {(char const   *)((void *)0), (char const   *)0, (char const   *)0, 0U, (void *)0,
      0U, (int (*)(enum grecs_callback_command cmd , grecs_locus_t * , void * , grecs_value_t * ,
                   void * ))0, (void *)0, (struct grecs_keyword *)0}};
#line 1534 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void config_init(void) 
{ 
  struct obstack *__o ;
  int __len ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1537
  grecs_set_keywords(pies_keywords);
#line 1538
  grecs_include_path_setup("/usr/local/share/pies/1.2/include", "/usr/local/share/pies/include",
                           (void *)0);
#line 1540
  grecs_log_to_stderr = (_Bool )log_to_stderr_only;
  }
#line 1541
  if ("/usr/bin/m4 -s") {
    {
#line 1543
    _obstack_begin(& pp_stk, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 1544
    __o = & pp_stk;
#line 1544
    __len = (int )(sizeof("/usr/bin/m4 -s") - 1UL);
    }
#line 1544
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 1544
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 1544
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)"/usr/bin/m4 -s",
           (size_t )__len);
#line 1544
    __o->next_free += __len;
    }
  }
#line 1547
  return;
}
}
#line 1552
void config_help(void) ;
#line 1552 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static char docstring[92]  = 
#line 1552
  {      (char )'C',      (char )'o',      (char )'n',      (char )'f', 
        (char )'i',      (char )'g',      (char )'u',      (char )'r', 
        (char )'a',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'s', 
        (char )'t',      (char )'r',      (char )'u',      (char )'c', 
        (char )'t',      (char )'u',      (char )'r',      (char )'e', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'p',      (char )'i',      (char )'e', 
        (char )'s',      (char )'.',      (char )'\n',      (char )'F', 
        (char )'o',      (char )'r',      (char )' ',      (char )'m', 
        (char )'o',      (char )'r',      (char )'e',      (char )' ', 
        (char )'i',      (char )'n',      (char )'f',      (char )'o', 
        (char )'r',      (char )'m',      (char )'a',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )',', 
        (char )' ',      (char )'u',      (char )'s',      (char )'e', 
        (char )' ',      (char )'`',      (char )'i',      (char )'n', 
        (char )'f',      (char )'o',      (char )' ',      (char )'p', 
        (char )'i',      (char )'e',      (char )'s',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'f', 
        (char )'i',      (char )'g',      (char )'u',      (char )'r', 
        (char )'a',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'\'',      (char )'.',      (char )'\000'};
#line 1549 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void config_help(void) 
{ 


  {
  {
#line 1556
  grecs_format_docstring(stdout, (char const   *)(docstring), 0U);
#line 1557
  grecs_format_statement_array(stdout, pies_keywords, 1U, 0U);
  }
#line 1558
  return;
}
}
#line 1561 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char const   *program_version  =    "pies (GNU Pies 1.2)";
#line 1562 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char const   *argp_program_bug_address  =    "<bug-pies@gnu.org.ua>";
#line 1563 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static char doc[52]  = 
#line 1563
  {      (char )'p',      (char )'i',      (char )'e',      (char )'s', 
        (char )' ',      (char )'-',      (char )'-',      (char )' ', 
        (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'e',      (char )'s',      (char )'s',      (char )' ', 
        (char )'i',      (char )'n',      (char )'v',      (char )'o', 
        (char )'c',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'e', 
        (char )'x',      (char )'e',      (char )'c',      (char )'u', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'s',      (char )'u',      (char )'p', 
        (char )'e',      (char )'r',      (char )'v',      (char )'i', 
        (char )'s',      (char )'o',      (char )'r',      (char )'\000'};
#line 1564 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static char args_doc[1]  = {      (char )'\000'};
#line 1586 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct argp_option options[28]  = 
#line 1586
  {      {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Operation Mode",
      0}, 
        {"foreground", 256, (char const   *)0, 0, "remain in foreground", 1}, 
        {"stderr", 259, (char const   *)((void *)0), 0, "log to stderr", 0}, 
        {"syslog", 258, (char const   *)((void *)0), 0, "log to syslog", 0}, 
        {"force", 262, (char const   *)((void *)0), 0, "force startup even if another instance may be running",
      1}, 
        {"lint", 't', (char const   *)((void *)0), 0, "parse configuration file and exit",
      1}, 
        {(char const   *)((void *)0), 'E', (char const   *)((void *)0), 0, "preprocess config and exit",
      1}, 
        {"inetd", 'i', (char const   *)((void *)0), 0, "run in inetd mode", 1}, 
        {"config-file", 'c', "FILE", 0, "use FILE instead of the default configuration",
      1}, 
        {"config-help", 263, (char const   *)((void *)0), 0, "show configuration file summary",
      1}, 
        {"syntax", 257, "{pies|inetd|meta1}", 0, "expect configuration files in the given syntax",
      1}, 
        {"rate", 265, "NUMBER", 0, "set default maximum rate for inetd-style components",
      1}, 
        {"instance", 266, "NAME", 0, "set instance name", 1}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Preprocessor",
      5}, 
        {"define", 'D', "NAME[=VALUE]", 0, "define a preprocessor symbol NAME as having VALUE, or empty",
      6}, 
        {"undefine", 'U', "NAME", 0, "undefine a preprocessor symbol NAME", 6}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Component Management",
      10}, 
        {"restart-component", 'R', (char const   *)((void *)0), 0, "restart components named in the command line",
      11}, 
        {"reload", 'r', (char const   *)((void *)0), 0, "reload the running instance of pies ",
      11}, 
        {"hup", 0, (char const   *)((void *)0), 4, (char const   *)0, 0}, 
        {"status", 's', (char const   *)((void *)0), 0, "display info about the running instance ",
      11}, 
        {"stop", 'S', (char const   *)((void *)0), 0, "stop the running instance ", 11}, 
        {(char const   *)((void *)0),
      0, (char const   *)((void *)0), 0, "Debugging and Additional Diagnostics", 20}, 
        {"debug",
      'x', "LEVEL", 0, "set debug verbosity level", 21}, 
        {"source-info", 264, (char const   *)((void *)0), 0, "show source info with debugging messages",
      21}, 
        {"dump-prereq", 260, (char const   *)((void *)0), 0, "dump prerequisite charts",
      21}, 
        {"dump-depmap", 261, (char const   *)((void *)0), 0, "dump dependency map", 21}, 
        {(char const   *)((void *)0),
      0, (char const   *)0, 0, (char const   *)0, 0}};
#line 1649 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static enum config_syntax current_syntax  =    (enum config_syntax )0;
#line 1651 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static error_t parse_opt(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char *p ;
  char *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1658
  if (key == 99) {
#line 1658
    goto case_99;
  }
#line 1662
  if (key == 68) {
#line 1662
    goto case_68;
  }
#line 1666
  if (key == 85) {
#line 1666
    goto case_85;
  }
#line 1670
  if (key == 69) {
#line 1670
    goto case_69;
  }
#line 1674
  if (key == 105) {
#line 1674
    goto case_105;
  }
#line 1681
  if (key == 116) {
#line 1681
    goto case_116;
  }
#line 1686
  if (key == 263) {
#line 1686
    goto case_263;
  }
#line 1690
  if (key == 256) {
#line 1690
    goto case_256;
  }
#line 1695
  if (key == 266) {
#line 1695
    goto case_266;
  }
#line 1699
  if (key == 257) {
#line 1699
    goto case_257;
  }
#line 1712
  if (key == 261) {
#line 1712
    goto case_261;
  }
#line 1712
  if (key == 260) {
#line 1712
    goto case_261;
  }
#line 1712
  if (key == 82) {
#line 1712
    goto case_261;
  }
#line 1712
  if (key == 83) {
#line 1712
    goto case_261;
  }
#line 1712
  if (key == 115) {
#line 1712
    goto case_261;
  }
#line 1712
  if (key == 114) {
#line 1712
    goto case_261;
  }
#line 1717
  if (key == 258) {
#line 1717
    goto case_258;
  }
#line 1721
  if (key == 259) {
#line 1721
    goto case_259;
  }
#line 1725
  if (key == 120) {
#line 1725
    goto case_120;
  }
#line 1729
  if (key == 265) {
#line 1729
    goto case_265;
  }
#line 1738
  if (key == 264) {
#line 1738
    goto case_264;
  }
#line 1742
  if (key == 262) {
#line 1742
    goto case_262;
  }
#line 1746
  if (key == 16777219) {
#line 1746
    goto case_16777219;
  }
#line 1749
  if (key == 16777223) {
#line 1749
    goto case_16777223;
  }
#line 1752
  goto switch_default;
  case_99: /* CIL Label */ 
  {
#line 1659
  add_config(current_syntax, (char const   *)arg___0);
  }
#line 1660
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 1663
  add_pp_option("-D", (char const   *)arg___0);
  }
#line 1664
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 1667
  add_pp_option("-U", (char const   *)arg___0);
  }
#line 1668
  goto switch_break;
  case_69: /* CIL Label */ 
#line 1671
  preprocess_only = 1;
#line 1672
  goto switch_break;
  case_105: /* CIL Label */ 
#line 1675
  if (! instance) {
#line 1676
    instance = (char *)"inetd";
  }
#line 1677
  current_syntax = (enum config_syntax )2;
#line 1678
  inetd_mode = 1;
#line 1679
  goto switch_break;
  case_116: /* CIL Label */ 
#line 1682
  log_to_stderr_only = 1;
#line 1683
  lint_mode = 1;
#line 1684
  goto switch_break;
  case_263: /* CIL Label */ 
  {
#line 1687
  config_help();
#line 1688
  exit(0);
  }
  case_256: /* CIL Label */ 
#line 1691
  log_to_stderr_only = 1;
#line 1692
  foreground = 1;
#line 1693
  goto switch_break;
  case_266: /* CIL Label */ 
#line 1696
  instance = arg___0;
#line 1697
  goto switch_break;
  case_257: /* CIL Label */ 
  {
#line 1700
  tmp___0 = str_to_config_syntax((char const   *)arg___0, & current_syntax);
  }
#line 1700
  if (tmp___0) {
    {
#line 1702
    tmp = gettext("unknown syntax type: %s");
#line 1702
    logmsg(3, (char const   *)tmp, arg___0);
#line 1703
    exit(64);
    }
  }
#line 1705
  goto switch_break;
  case_261: /* CIL Label */ 
  case_260: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
#line 1713
  log_to_stderr_only = 1;
#line 1714
  command = key;
#line 1715
  goto switch_break;
  case_258: /* CIL Label */ 
#line 1718
  log_to_stderr_only = 0;
#line 1719
  goto switch_break;
  case_259: /* CIL Label */ 
#line 1722
  log_to_stderr_only = 1;
#line 1723
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 1726
  tmp___1 = strtoul((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)((void *)0),
                    0);
#line 1726
  debug_level = (unsigned int )tmp___1;
  }
#line 1727
  goto switch_break;
  case_265: /* CIL Label */ 
  {
#line 1730
  tmp___2 = strtoul((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)(& p),
                    10);
#line 1730
  default_max_rate = (size_t )tmp___2;
  }
#line 1731
  if (*p) {
    {
#line 1733
    tmp___3 = gettext("not a number: %s");
#line 1733
    logmsg(3, (char const   *)tmp___3, arg___0);
#line 1734
    exit(64);
    }
  }
#line 1736
  goto switch_break;
  case_264: /* CIL Label */ 
#line 1739
  source_info_option = 1;
#line 1740
  goto switch_break;
  case_262: /* CIL Label */ 
#line 1743
  force_option = 1;
#line 1744
  goto switch_break;
  case_16777219: /* CIL Label */ 
#line 1747
  goto switch_break;
  case_16777223: /* CIL Label */ 
#line 1750
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1753
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 1755
  return (0);
}
}
#line 1758 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static struct argp argp  =    {(struct argp_option  const  *)(options), & parse_opt, (char const   *)(args_doc),
    (char const   *)(doc), (struct argp_child  const  *)((void *)0), (char *(*)(int __key ,
                                                                                char const   *__text ,
                                                                                void *__input ))((void *)0),
    (char const   *)((void *)0)};
#line 1775 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int action  =    0;
#line 1776 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int children_cleanup  =    0;
#line 1777 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int got_alarm  =    0;
#line 1779 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void sig_handler(int sig ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1784
  if (sig == 17) {
#line 1784
    goto case_17;
  }
#line 1790
  if (sig == 3) {
#line 1790
    goto case_3;
  }
#line 1790
  if (sig == 2) {
#line 1790
    goto case_3;
  }
#line 1790
  if (sig == 15) {
#line 1790
    goto case_3;
  }
#line 1795
  if (sig == 1) {
#line 1795
    goto case_1;
  }
#line 1800
  if (sig == 14) {
#line 1800
    goto case_14;
  }
#line 1804
  if (sig == 10) {
#line 1804
    goto case_10;
  }
#line 1808
  if (sig == 12) {
#line 1808
    goto case_12;
  }
#line 1782
  goto switch_break;
  case_17: /* CIL Label */ 
#line 1785
  children_cleanup = 1;
#line 1786
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_15: /* CIL Label */ 
  {
#line 1791
  action = 1;
#line 1792
  logmsg(5, "received signal %d", sig);
  }
#line 1793
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1796
  logmsg(5, "received signal %d", sig);
#line 1797
  action = 2;
  }
#line 1798
  goto switch_break;
  case_14: /* CIL Label */ 
#line 1801
  got_alarm = 1;
#line 1802
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1805
  action = 3;
#line 1806
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1809
  action = 4;
#line 1810
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1812
  signal(sig, & sig_handler);
  }
#line 1813
  return;
}
}
#line 1815 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void signal_setup(void (*sf)(int  ) ) 
{ 


  {
  {
#line 1818
  signal(17, sf);
#line 1819
  signal(15, sf);
#line 1820
  signal(3, sf);
#line 1821
  signal(2, sf);
#line 1822
  signal(1, sf);
#line 1823
  signal(14, sf);
#line 1824
  signal(10, sf);
#line 1825
  signal(12, sf);
  }
#line 1826
  return;
}
}
#line 1829 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
pid_t pidfile_read(int must_exist ) 
{ 
  int c ;
  pid_t n ;
  FILE *fp ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 1833
  n = 0;
#line 1834
  tmp = fopen((char const   */* __restrict  */)pidfile, (char const   */* __restrict  */)"r");
#line 1834
  fp = tmp;
  }
#line 1835
  if (! fp) {
#line 1837
    if (must_exist) {
      {
#line 1837
      tmp___3 = __errno_location();
      }
#line 1837
      if (*tmp___3 != 2) {
        {
#line 1838
        tmp___0 = __errno_location();
#line 1838
        tmp___1 = strerror(*tmp___0);
#line 1838
        tmp___2 = gettext("cannot open pid file `%s\': %s");
#line 1838
        logmsg(3, (char const   *)tmp___2, pidfile, tmp___1);
        }
      }
    }
#line 1841
    return (-1);
  }
  {
#line 1844
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1844
    c = fgetc(fp);
    }
#line 1844
    if (! (c != -1)) {
#line 1844
      goto while_break;
    }
    {
#line 1846
    tmp___5 = __ctype_b_loc();
    }
#line 1846
    if ((int const   )*(*tmp___5 + c) & 2048) {
#line 1847
      n = (n * 10 + c) - 48;
    } else
#line 1848
    if (c == 10) {
#line 1849
      goto while_break;
    } else {
      {
#line 1852
      tmp___4 = gettext("unexpected character %#03o in pidfile `%s\'");
#line 1852
      logmsg(3, (char const   *)tmp___4, c, pidfile);
      }
#line 1855
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1858
  fclose(fp);
  }
#line 1859
  if (n) {
    {
#line 1859
    tmp___11 = kill(n, 0);
    }
#line 1859
    if (tmp___11) {
      {
#line 1861
      tmp___9 = __errno_location();
      }
#line 1861
      if (*tmp___9 != 3) {
        {
#line 1862
        tmp___6 = __errno_location();
#line 1862
        tmp___7 = strerror(*tmp___6);
#line 1862
        tmp___8 = gettext("cannot signal master process %lu: %s");
#line 1862
        logmsg(3, (char const   *)tmp___8, (unsigned long )n, tmp___7);
        }
      }
      {
#line 1865
      tmp___10 = __errno_location();
      }
#line 1865
      if (*tmp___10 == 1) {
#line 1866
        return (n);
      }
#line 1867
      return (-1);
    }
  }
#line 1869
  return (n);
}
}
#line 1881 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
enum pies_status pies_check_status(pid_t *ppid ) 
{ 
  pid_t pid ;
  pid_t tmp ;
  int i ;
  int rc ;
  int tmp___0 ;

  {
  {
#line 1884
  tmp = pidfile_read(0);
#line 1884
  pid = tmp;
  }
#line 1888
  if (pid <= 0) {
#line 1889
    return ((enum pies_status )0);
  }
  {
#line 1891
  *ppid = pid;
#line 1893
  tmp___0 = kill(pid, 12);
  }
#line 1893
  if (tmp___0) {
#line 1894
    return ((enum pies_status )1);
  }
#line 1896
  i = 0;
  {
#line 1896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1896
    if (i < 4) {
      {
#line 1896
      rc = access((char const   *)statfile, 4);
      }
#line 1896
      if (! rc) {
#line 1896
        goto while_break;
      }
    } else {
#line 1896
      goto while_break;
    }
    {
#line 1897
    sleep(1U);
#line 1896
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1899
  if (rc) {
#line 1900
    return ((enum pies_status )2);
  }
#line 1901
  return ((enum pies_status )3);
}
}
#line 1905 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void stop_components(void) 
{ 
  FILE *fp ;
  size_t size ;
  char *buf ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t len ;
  size_t tmp___7 ;
  __ssize_t tmp___8 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 1909
  size = (size_t )0;
#line 1910
  buf = (char *)((void *)0);
#line 1912
  tmp = gettext("stopping components");
#line 1912
  logmsg(6, (char const   *)tmp);
#line 1914
  fp = fopen((char const   */* __restrict  */)ctlfile, (char const   */* __restrict  */)"r");
  }
#line 1915
  if (! fp) {
    {
#line 1917
    tmp___0 = __errno_location();
#line 1917
    tmp___1 = strerror(*tmp___0);
#line 1917
    tmp___2 = gettext("cannot open control file `%s\': %s");
#line 1917
    logmsg(3, (char const   *)tmp___2, ctlfile, tmp___1);
    }
#line 1919
    return;
  }
  {
#line 1921
  tmp___6 = unlink((char const   *)ctlfile);
  }
#line 1921
  if (tmp___6) {
    {
#line 1923
    tmp___3 = __errno_location();
#line 1923
    tmp___4 = strerror(*tmp___3);
#line 1923
    tmp___5 = gettext("cannot unlink control file `%s\': %s");
#line 1923
    logmsg(3, (char const   *)tmp___5, ctlfile, tmp___4);
#line 1925
    fclose(fp);
    }
#line 1926
    return;
  }
  {
#line 1929
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1929
    tmp___8 = (__ssize_t )getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& size),
                                  (FILE */* __restrict  */)fp);
    }
#line 1929
    if (! (tmp___8 > 0)) {
#line 1929
      goto while_break;
    }
    {
#line 1931
    tmp___7 = strlen((char const   *)buf);
#line 1931
    len = tmp___7;
    }
#line 1932
    if (len == 0U) {
#line 1933
      goto while_continue;
    }
#line 1934
    if ((int )*(buf + (len - 1U)) == 10) {
#line 1935
      *(buf + (len - 1U)) = (char)0;
    }
    {
#line 1936
    progman_stop_component((char const   *)buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1939
  free((void *)buf);
#line 1940
  fclose(fp);
  }
#line 1941
  return;
}
}
#line 1943 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int request_restart_components(char **argv ) 
{ 
  FILE *fp ;
  pid_t pid ;
  pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1947
  tmp = pidfile_read(1);
#line 1947
  pid = tmp;
  }
#line 1949
  if (pid == -1) {
#line 1950
    return (1);
  }
  {
#line 1952
  fp = fopen((char const   */* __restrict  */)ctlfile, (char const   */* __restrict  */)"w");
  }
#line 1953
  if (! fp) {
    {
#line 1955
    tmp___0 = __errno_location();
#line 1955
    tmp___1 = strerror(*tmp___0);
#line 1955
    tmp___2 = gettext("cannot open control file `%s\': %s");
#line 1955
    logmsg(3, (char const   *)tmp___2, ctlfile, tmp___1);
    }
#line 1957
    return (1);
  }
  {
#line 1959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1959
    if (! *argv) {
#line 1959
      goto while_break;
    }
    {
#line 1960
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
            *argv);
#line 1959
    argv ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1961
  fclose(fp);
#line 1963
  kill(pid, 10);
  }
#line 1964
  return (0);
}
}
#line 1968 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int pies_reload(void) 
{ 
  pid_t pid ;
  pid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1971
  tmp = pidfile_read(1);
#line 1971
  pid = tmp;
  }
#line 1973
  if (pid == -1) {
    {
#line 1975
    tmp___0 = gettext("pies is not running");
#line 1975
    logmsg(2, (char const   *)tmp___0);
    }
#line 1976
    return (1);
  }
  {
#line 1979
  tmp___1 = gettext("reloading pies at PID %lu");
#line 1979
  logmsg(6, (char const   *)tmp___1, (unsigned long )pid);
#line 1980
  tmp___4 = kill(pid, 1);
  }
#line 1980
  if (tmp___4) {
#line 1980
    tmp___3 = 70;
  } else {
#line 1980
    tmp___3 = 0;
  }
#line 1980
  return (tmp___3);
}
}
#line 1983 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int pies_status(void) 
{ 
  pid_t pid ;
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  enum pies_status tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char c ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 1989
  tmp___2 = unlink((char const   *)statfile);
  }
#line 1989
  if (tmp___2) {
    {
#line 1989
    tmp___3 = __errno_location();
    }
#line 1989
    if (*tmp___3 != 2) {
      {
#line 1990
      tmp = __errno_location();
#line 1990
      tmp___0 = strerror(*tmp);
#line 1990
      tmp___1 = gettext("cannot unlink statfile `%s\': %s");
#line 1990
      logmsg(3, (char const   *)tmp___1, statfile, tmp___0);
      }
    }
  }
  {
#line 1992
  tmp___4 = pies_check_status(& pid);
  }
  {
#line 1994
  if ((unsigned int )tmp___4 == 0U) {
#line 1994
    goto case_0;
  }
#line 1998
  if ((unsigned int )tmp___4 == 1U) {
#line 1998
    goto case_1;
  }
#line 2004
  if ((unsigned int )tmp___4 == 2U) {
#line 2004
    goto case_2;
  }
#line 2013
  if ((unsigned int )tmp___4 == 3U) {
#line 2013
    goto case_3;
  }
#line 1992
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1995
  tmp___5 = gettext("pies is not running");
#line 1995
  logmsg(6, (char const   *)tmp___5);
  }
#line 1996
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1999
  tmp___6 = gettext("pies is not running, but a pidfile is found (pid %lu)");
#line 1999
  logmsg(6, (char const   *)tmp___6, (unsigned long )pid);
  }
#line 2002
  return (1);
  case_2: /* CIL Label */ 
  {
#line 2005
  tmp___7 = gettext("pies seems to run with pid %lu, but is not responding");
#line 2005
  logmsg(6, (char const   *)tmp___7, (unsigned long )pid);
#line 2008
  tmp___11 = unlink((char const   *)statfile);
  }
#line 2008
  if (tmp___11) {
    {
#line 2009
    tmp___8 = __errno_location();
#line 2009
    tmp___9 = strerror(*tmp___8);
#line 2009
    tmp___10 = gettext("cannot unlink statfile `%s\': %s");
#line 2009
    logmsg(3, (char const   *)tmp___10, statfile, tmp___9);
    }
  }
#line 2011
  return (2);
  case_3: /* CIL Label */ 
  {
#line 2014
  fp = fopen((char const   */* __restrict  */)statfile, (char const   */* __restrict  */)"r");
  }
#line 2015
  if (! fp) {
    {
#line 2016
    tmp___12 = __errno_location();
#line 2016
    tmp___13 = strerror(*tmp___12);
#line 2016
    tmp___14 = gettext("cannot open statfile `%s\': %s");
#line 2016
    logmsg(3, (char const   *)tmp___14, statfile, tmp___13);
    }
  } else {
    {
#line 2022
    tmp___18 = unlink((char const   *)statfile);
    }
#line 2022
    if (tmp___18) {
      {
#line 2023
      tmp___15 = __errno_location();
#line 2023
      tmp___16 = strerror(*tmp___15);
#line 2023
      tmp___17 = gettext("cannot unlink statfile `%s\': %s");
#line 2023
      logmsg(3, (char const   *)tmp___17, statfile, tmp___16);
      }
    }
    {
#line 2025
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2025
      tmp___19 = fgetc(fp);
#line 2025
      c = (char )tmp___19;
      }
#line 2025
      if (! ((int )c != -1)) {
#line 2025
        goto while_break;
      }
      {
#line 2026
      fputc((int )c, stdout);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2027
    fclose(fp);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 2030
  return (0);
}
}
#line 2033 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int pies_stop(void) 
{ 
  pid_t pid ;
  pid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2036
  tmp = pidfile_read(1);
#line 2036
  pid = tmp;
  }
#line 2038
  if (pid == -1) {
    {
#line 2040
    tmp___0 = gettext("pies is not running");
#line 2040
    logmsg(2, (char const   *)tmp___0);
    }
#line 2041
    return (64);
  }
  {
#line 2044
  tmp___1 = gettext("stopping pies at PID %lu");
#line 2044
  logmsg(6, (char const   *)tmp___1, (unsigned long )pid);
#line 2045
  tmp___4 = kill(pid, 15);
  }
#line 2045
  if (tmp___4) {
#line 2045
    tmp___3 = 70;
  } else {
#line 2045
    tmp___3 = 0;
  }
#line 2045
  return (tmp___3);
}
}
#line 2052 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void check_pidfile(char *name ) 
{ 
  unsigned long pid ;
  FILE *fp ;
  FILE *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 2056
  tmp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
#line 2056
  fp = tmp;
  }
#line 2057
  if (! fp) {
    {
#line 2059
    tmp___0 = __errno_location();
    }
#line 2059
    if (*tmp___0 == 2) {
#line 2060
      return;
    }
    {
#line 2061
    tmp___1 = __errno_location();
#line 2061
    tmp___2 = strerror(*tmp___1);
#line 2061
    tmp___3 = gettext("cannot open pidfile `%s\': %s");
#line 2061
    logmsg(3, (char const   *)tmp___3, name, tmp___2);
#line 2063
    exit(75);
    }
  }
  {
#line 2065
  tmp___6 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu",
                   & pid);
  }
#line 2065
  if (tmp___6 != 1) {
    {
#line 2067
    logmsg(3, "cannot get pid from pidfile `%s\'", name);
    }
  } else {
    {
#line 2071
    tmp___5 = kill((__pid_t )pid, 0);
    }
#line 2071
    if (tmp___5 == 0) {
      {
#line 2073
      tmp___4 = gettext("%s appears to run with pid %lu. If it does not, remove `%s\' and retry.");
#line 2073
      logmsg(3, (char const   *)tmp___4, program_name, pid, name);
#line 2077
      exit(64);
      }
    }
  }
  {
#line 2080
  fclose(fp);
#line 2081
  tmp___10 = unlink((char const   *)pidfile);
  }
#line 2081
  if (tmp___10) {
    {
#line 2083
    tmp___7 = __errno_location();
#line 2083
    tmp___8 = strerror(*tmp___7);
#line 2083
    tmp___9 = gettext("cannot unlink pidfile `%s\': %s");
#line 2083
    logmsg(3, (char const   *)tmp___9, name, tmp___8);
#line 2085
    exit(64);
    }
  }
#line 2087
  return;
}
}
#line 2089 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void create_pidfile(char *name ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  __pid_t tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2092
  tmp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"w");
#line 2092
  fp = tmp;
  }
#line 2093
  if (! fp) {
    {
#line 2095
    tmp___0 = __errno_location();
#line 2095
    tmp___1 = strerror(*tmp___0);
#line 2095
    tmp___2 = gettext("cannot create pidfile `%s\': %s");
#line 2095
    logmsg(3, (char const   *)tmp___2, name, tmp___1);
#line 2097
    exit(75);
    }
  }
  {
#line 2099
  tmp___3 = getpid();
#line 2099
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu", (unsigned long )tmp___3);
#line 2100
  fclose(fp);
  }
#line 2101
  return;
}
}
#line 2103 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void remove_pidfile(char *name ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 2106
  tmp___2 = unlink((char const   *)name);
  }
#line 2106
  if (tmp___2) {
    {
#line 2107
    tmp = __errno_location();
#line 2107
    tmp___0 = strerror(*tmp);
#line 2107
    tmp___1 = gettext("cannot unlink pidfile `%s\': %s");
#line 2107
    logmsg(3, (char const   *)tmp___1, name, tmp___0);
    }
  }
#line 2109
  return;
}
}
#line 2112 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static void set_mailer_argcv(void) 
{ 
  int i ;
  struct wordsplit ws ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2118
  tmp___2 = wordsplit((char const   *)mailer_command_line, & ws, 1860);
  }
#line 2118
  if (tmp___2) {
    {
#line 2120
    tmp = __errno_location();
#line 2120
    tmp___0 = strerror(*tmp);
#line 2120
    tmp___1 = gettext("cannot parse mailer command line: %s");
#line 2120
    logmsg(2, (char const   *)tmp___1, tmp___0);
#line 2122
    exit(78);
    }
  }
  {
#line 2124
  mailer_argc = (int )ws.ws_wordc;
#line 2125
  tmp___3 = xcalloc((size_t )(mailer_argc + 1), (size_t )sizeof(*(mailer_argv + 0)));
#line 2125
  mailer_argv = (char **)tmp___3;
#line 2126
  i = 0;
  }
  {
#line 2126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2126
    if (! (i < mailer_argc)) {
#line 2126
      goto while_break;
    }
    {
#line 2127
    *(mailer_argv + i) = xstrdup((char const   *)*(ws.ws_wordv + i));
#line 2126
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2128
  *(mailer_argv + i) = (char *)((void *)0);
#line 2129
  wordsplit_free(& ws);
  }
#line 2130
  return;
}
}
#line 2133 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
char const   version_etc_copyright[36]  = 
#line 2133
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'9',      (char const   )' ',      (char const   )'S',      (char const   )'e', 
        (char const   )'r',      (char const   )'g',      (char const   )'e',      (char const   )'y', 
        (char const   )' ',      (char const   )'P',      (char const   )'o',      (char const   )'z', 
        (char const   )'n',      (char const   )'y',      (char const   )'a',      (char const   )'k', 
        (char const   )'o',      (char const   )'f',      (char const   )'f',      (char const   )'\000'};
#line 2139 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static void version(FILE *stream , struct argp_state *state ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 2142
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
          "pies", "GNU Pies", "1.2");
#line 2146
  tmp = gettext("(C)");
#line 2146
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp);
#line 2148
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 2148
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 2158
  tmp___1 = gettext("Written by %s.\n");
#line 2158
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          "Sergey Poznyakoff");
  }
#line 2159
  return;
}
}
#line 2161 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static char *mkfilename(char const   *dir , char const   *name , char const   *suf ) 
{ 
  size_t dirlen ;
  size_t tmp ;
  char *s ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp10 ;

  {
  {
#line 2164
  tmp = strlen(dir);
#line 2164
  dirlen = tmp;
  }
  {
#line 2167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2167
    if (dirlen > 0U) {
#line 2167
      if (! ((int const   )*(dir + (dirlen - 1U)) == 47)) {
#line 2167
        goto while_break;
      }
    } else {
#line 2167
      goto while_break;
    }
#line 2168
    dirlen --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2170
  tmp___0 = strlen(name);
#line 2170
  tmp___1 = strlen(suf);
#line 2170
  tmp___2 = xmalloc((((dirlen + 1U) + tmp___0) + tmp___1) + 1U);
#line 2170
  s = (char *)tmp___2;
#line 2171
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)dir);
#line 2172
  strcat((char */* __restrict  */)s, (char const   */* __restrict  */)"/");
#line 2173
  strcat((char */* __restrict  */)s, (char const   */* __restrict  */)name);
#line 2174
  strcat((char */* __restrict  */)s, (char const   */* __restrict  */)suf);
  }
#line 2175
  return (s);
}
}
#line 2178 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static void set_conf_file_names(char const   *base ) 
{ 
  char *name ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 2181
  if (! conf_head) {
    {
#line 2183
    tmp = mkfilename("/usr/local/etc", base, ".conf");
#line 2183
    name = tmp;
#line 2184
    add_config(current_syntax, (char const   *)name);
#line 2185
    free((void *)name);
    }
  }
#line 2187
  return;
}
}
#line 2189 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
static void set_state_file_names(char const   *base ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 2192
  if (! pidfile) {
    {
#line 2193
    pidfile = mkfilename((char const   *)statedir, base, ".pid");
    }
  }
#line 2194
  if (! ctlfile) {
    {
#line 2195
    ctlfile = mkfilename((char const   *)statedir, base, ".ctl");
    }
  }
#line 2196
  if (! statfile) {
    {
#line 2197
    statfile = mkfilename((char const   *)statedir, base, ".stat");
    }
  }
#line 2198
  if (! qotdfile) {
    {
#line 2199
    qotdfile = mkfilename((char const   *)statedir, base, ".qotd");
    }
  }
#line 2200
  return;
}
}
#line 2202 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
int main(int argc , char **argv ) 
{ 
  int index___0 ;
  pid_t pid ;
  struct config_file *file ;
  int tmp___0 ;
  int tmp___1 ;
  error_t tmp___2 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  enum pies_status tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int minfd ;
  int tmp___22 ;
  int i ;
  long tmp___23 ;
  char *tmp___24 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 2210
  set_program_name((char const   *)*(argv + 0));
#line 2212
  setlocale(6, "");
#line 2213
  bindtextdomain("pies", "/usr/local/share/locale");
#line 2214
  bindtextdomain("mailfromd", "/usr/local/share/locale");
#line 2215
  textdomain("pies");
#line 2217
  mf_proctitle_init(argc, argv, environ);
#line 2219
  set_quoting_style((struct quoting_options *)((void *)0), (enum quoting_style )1);
#line 2222
  tmp___1 = stderr_closed_p();
  }
#line 2222
  if (tmp___1) {
#line 2222
    tmp___0 = 0;
  } else {
#line 2222
    tmp___0 = 2;
  }
  {
#line 2222
  diag_setup(1 | tmp___0);
#line 2224
  config_init();
#line 2225
  argp_program_version_hook = (void (*)(FILE * __restrict  __stream , struct argp_state * __restrict  __state ))(& version);
#line 2226
  tmp___2 = argp_parse((struct argp  const  */* __restrict  */)(& argp), argc, (char **/* __restrict  */)argv,
                       0U, (int */* __restrict  */)(& index___0), (void */* __restrict  */)((void *)0));
  }
#line 2226
  if (tmp___2) {
    {
#line 2227
    exit(64);
    }
  }
#line 2229
  if (! instance) {
    {
#line 2231
    instance = strrchr(program_name, '/');
    }
#line 2232
    if (! instance) {
#line 2233
      instance = (char *)program_name;
    } else {
#line 2235
      instance ++;
    }
  }
  {
#line 2238
  log_tag = instance;
#line 2240
  set_conf_file_names((char const   *)instance);
#line 2246
  __o1 = & pp_stk;
#line 2246
  __value = (void *)__o1->object_base;
  }
#line 2246
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 2246
    __o1->maybe_empty_object = 1U;
  }
#line 2246
  if (sizeof(int ) < sizeof(void *)) {
#line 2246
    tmp___3 = __o1->object_base;
  } else {
#line 2246
    tmp___3 = (char *)0;
  }
#line 2246
  if (sizeof(int ) < sizeof(void *)) {
#line 2246
    tmp___4 = __o1->object_base;
  } else {
#line 2246
    tmp___4 = (char *)0;
  }
#line 2246
  __o1->next_free = tmp___3 + (((__o1->next_free - tmp___4) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 2246
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 2246
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 2246
  __o1->object_base = __o1->next_free;
#line 2246
  grecs_preprocessor = (char const   *)__value;
#line 2247
  free((void *)pp_qopt);
  }
#line 2250
  if (preprocess_only) {
#line 2252
    file = conf_head;
    {
#line 2252
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2252
      if (! file) {
#line 2252
        goto while_break;
      }
#line 2254
      if ((unsigned int )file->syntax == 0U) {
        {
#line 2254
        tmp___5 = grecs_preproc_run((char const   *)file->name, grecs_preprocessor);
        }
#line 2254
        if (tmp___5) {
          {
#line 2256
          exit(78);
          }
        }
      }
#line 2252
      file = file->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2258
    exit(0);
    }
  } else {
#line 2261
    file = conf_head;
    {
#line 2261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2261
      if (! file) {
#line 2261
        goto while_break___0;
      }
      {
#line 2265
      if ((unsigned int )file->syntax == 0U) {
#line 2265
        goto case_0;
      }
#line 2270
      if ((unsigned int )file->syntax == 2U) {
#line 2270
        goto case_2;
      }
#line 2275
      if ((unsigned int )file->syntax == 1U) {
#line 2275
        goto case_1;
      }
#line 2263
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 2266
      tmp___6 = grecs_parse((char const   *)file->name);
      }
#line 2266
      if (tmp___6) {
        {
#line 2267
        exit(78);
        }
      }
#line 2268
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 2271
      tmp___7 = inetd_parse_conf((char const   *)file->name);
      }
#line 2271
      if (tmp___7) {
        {
#line 2272
        exit(78);
        }
      }
#line 2273
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 2276
      tmp___8 = meta1_config_parse((char const   *)file->name);
      }
#line 2276
      if (tmp___8) {
        {
#line 2277
        exit(78);
        }
      }
#line 2278
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2261
      file = file->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2282
  set_state_file_names((char const   *)instance);
#line 2283
  set_mailer_argcv();
  }
#line 2285
  if (lint_mode) {
    {
#line 2287
    progman_build_depmap();
#line 2288
    exit(0);
    }
  }
#line 2292
  if (log_to_stderr_only) {
#line 2292
    tmp___9 = 2;
  } else {
#line 2292
    tmp___9 = 0;
  }
  {
#line 2292
  diag_setup(tmp___9);
  }
#line 2294
  if (argc != index___0) {
#line 2294
    if (command != 82) {
      {
#line 2296
      logmsg(3, "extra command line arguments");
#line 2297
      exit(78);
      }
    }
  }
  {
#line 2300
  progman_build_depmap();
  }
  {
#line 2303
  if (command == 82) {
#line 2303
    goto case_82;
  }
#line 2309
  if (command == 114) {
#line 2309
    goto case_114;
  }
#line 2312
  if (command == 115) {
#line 2312
    goto case_115;
  }
#line 2315
  if (command == 83) {
#line 2315
    goto case_83;
  }
#line 2318
  if (command == 260) {
#line 2318
    goto case_260;
  }
#line 2322
  if (command == 261) {
#line 2322
    goto case_261;
  }
#line 2326
  goto switch_default;
  case_82: /* CIL Label */ 
  {
#line 2304
  pies_priv_setup(& pies_privs);
  }
#line 2305
  if (pies_umask) {
    {
#line 2306
    umask(pies_umask);
    }
  }
  {
#line 2307
  tmp___10 = request_restart_components(argv + index___0);
#line 2307
  exit(tmp___10);
  }
  case_114: /* CIL Label */ 
  {
#line 2310
  tmp___11 = pies_reload();
#line 2310
  exit(tmp___11);
  }
  case_115: /* CIL Label */ 
  {
#line 2313
  tmp___12 = pies_status();
#line 2313
  exit(tmp___12);
  }
  case_83: /* CIL Label */ 
  {
#line 2316
  tmp___13 = pies_stop();
#line 2316
  exit(tmp___13);
  }
  case_260: /* CIL Label */ 
  {
#line 2319
  progman_dump_prereq();
#line 2320
  exit(0);
  }
  case_261: /* CIL Label */ 
  {
#line 2323
  progman_dump_depmap();
#line 2324
  exit(0);
  }
  switch_default: /* CIL Label */ 
  {
#line 2327
  pies_priv_setup(& pies_privs);
  }
#line 2328
  if (pies_umask) {
    {
#line 2329
    umask(pies_umask);
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 2332
  tmp___14 = pies_check_status(& pid);
  }
  {
#line 2334
  if ((unsigned int )tmp___14 == 0U) {
#line 2334
    goto case_0___0;
  }
#line 2337
  if ((unsigned int )tmp___14 == 2U) {
#line 2337
    goto case_2___0;
  }
#line 2337
  if ((unsigned int )tmp___14 == 1U) {
#line 2337
    goto case_2___0;
  }
#line 2347
  if ((unsigned int )tmp___14 == 3U) {
#line 2347
    goto case_3;
  }
#line 2332
  goto switch_break___1;
  case_0___0: /* CIL Label */ 
#line 2335
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 2338
  if (! force_option) {
    {
#line 2340
    tmp___15 = gettext("another pies instance may be running (pid %lu), use --force to override");
#line 2340
    logmsg(3, (char const   *)tmp___15, (unsigned long )pid);
#line 2343
    exit(64);
    }
  }
#line 2345
  goto switch_break___1;
  case_3: /* CIL Label */ 
  {
#line 2348
  tmp___16 = gettext("another pies instance already running (pid %lu)");
#line 2348
  logmsg(3, (char const   *)tmp___16, (unsigned long )pid);
#line 2350
  exit(64);
  }
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 2353
  tmp___17 = gettext("%s starting");
#line 2353
  logmsg(6, (char const   *)tmp___17, program_version);
  }
#line 2355
  if (! foreground) {
    {
#line 2357
    check_pidfile(pidfile);
#line 2358
    tmp___21 = daemon(0, 0);
    }
#line 2358
    if (tmp___21 == -1) {
      {
#line 2360
      tmp___18 = __errno_location();
#line 2360
      tmp___19 = strerror(*tmp___18);
#line 2360
      tmp___20 = gettext("cannot become a daemon: %s");
#line 2360
      logmsg(3, (char const   *)tmp___20, tmp___19);
#line 2361
      exit(70);
      }
    }
    {
#line 2363
    diag_setup(1);
    }
  }
  {
#line 2366
  create_pidfile(pidfile);
  }
#line 2368
  if ((int )*(*(argv + 0) + 0) != 47) {
    {
#line 2369
    logmsg(5, "not started as an absolute pathname; SIGHUP will not work");
    }
  }
  {
#line 2373
  signal_setup(& sig_handler);
#line 2375
  progman_create_sockets();
#line 2376
  progman_start();
  }
  {
#line 2378
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2380
    if (! children_cleanup) {
      {
#line 2381
      pies_pause();
      }
    }
    {
#line 2384
    if (action == 3) {
#line 2384
      goto case_3___0;
    }
#line 2391
    if (action == 4) {
#line 2391
      goto case_4;
    }
#line 2382
    goto switch_break___2;
    case_3___0: /* CIL Label */ 
    {
#line 2385
    stop_components();
#line 2386
    progman_cleanup(0);
#line 2387
    progman_start();
#line 2388
    action = 0;
    }
#line 2389
    goto switch_break___2;
    case_4: /* CIL Label */ 
    {
#line 2392
    progman_dump_stats((char const   *)statfile);
#line 2393
    action = 0;
    }
#line 2394
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 2396
    if (action == 0) {
#line 2398
      if (children_cleanup) {
        {
#line 2400
        children_cleanup = 0;
#line 2401
        progman_cleanup(0);
        }
      }
#line 2403
      if (got_alarm) {
        {
#line 2405
        progman_wake_sleeping(1);
#line 2406
        got_alarm = 0;
        }
      }
    }
#line 2378
    if (! (action == 0)) {
#line 2378
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2412
  progman_stop();
  }
#line 2414
  if (action == 2) {
#line 2414
    if ((int )*(*(argv + 0) + 0) == 47) {
#line 2416
      if (diag_output & 2) {
#line 2416
        tmp___22 = 2;
      } else {
#line 2416
        tmp___22 = 0;
      }
      {
#line 2416
      minfd = tmp___22;
#line 2419
      tmp___23 = sysconf(4);
#line 2419
      i = (int )tmp___23;
      }
      {
#line 2419
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2419
        if (! (i > minfd)) {
#line 2419
          goto while_break___2;
        }
        {
#line 2420
        close(i);
#line 2419
        i --;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2422
      remove_pidfile(pidfile);
#line 2423
      signal_setup((void (*)(int  ))0);
#line 2425
      execv((char const   *)*(argv + 0), (char * const  *)argv);
      }
    }
  }
  {
#line 2428
  tmp___24 = gettext("%s terminated");
#line 2428
  logmsg(6, (char const   *)tmp___24, program_version);
#line 2429
  exit(0);
  }
}
}
#line 2432
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 2432 "/home/ysko/Works/test-src/pies-1.2/src/pies.c"
void xalloc_die(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 2435
  tmp = gettext("not enough memory");
#line 2435
  logmsg(2, (char const   *)tmp);
#line 2436
  abort();
  }
}
}
#line 799 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 243 "meta1lex.c"
int meta1leng  ;
#line 248
FILE *meta1in ;
#line 248
FILE *meta1out ;
#line 355 "meta1lex.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 356 "meta1lex.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 357 "meta1lex.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 384 "meta1lex.c"
static char yy_hold_char  ;
#line 385 "meta1lex.c"
static int yy_n_chars  ;
#line 389 "meta1lex.c"
static char *yy_c_buf_p  =    (char *)0;
#line 390 "meta1lex.c"
static int yy_init  =    0;
#line 391 "meta1lex.c"
static int yy_start  =    0;
#line 396 "meta1lex.c"
static int yy_did_buffer_switch_on_eof  ;
#line 401
void meta1restart(FILE *input_file ) ;
#line 402
void meta1_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 403
YY_BUFFER_STATE meta1_create_buffer(FILE *file , int size ) ;
#line 404
void meta1_delete_buffer(YY_BUFFER_STATE b ) ;
#line 405
void meta1_flush_buffer(YY_BUFFER_STATE b ) ;
#line 406
void meta1push_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 407
void meta1pop_buffer_state(void) ;
#line 409
static void meta1ensure_buffer_stack(void) ;
#line 410
static void meta1_load_buffer_state(void) ;
#line 411
static void meta1_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 415
YY_BUFFER_STATE meta1_scan_buffer(char *base , yy_grecs_size_t size ) ;
#line 416
YY_BUFFER_STATE meta1_scan_string(char const   *yystr ) ;
#line 417
YY_BUFFER_STATE meta1_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 421
void *meta1alloc(yy_grecs_size_t size ) ;
#line 422
void *meta1realloc(void *ptr , yy_grecs_size_t size ) ;
#line 423
void meta1free(void *ptr ) ;
#line 456 "meta1lex.c"
FILE *meta1in  =    (FILE *)0;
#line 456 "meta1lex.c"
FILE *meta1out  =    (FILE *)0;
#line 460
int meta1lineno ;
#line 462 "meta1lex.c"
int meta1lineno  =    1;
#line 464 "meta1lex.c"
char *meta1text  ;
#line 469
static yy_state_type yy_get_previous_state(void) ;
#line 470
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 471
static int yy_get_next_buffer(void) ;
#line 472
static void yy_fatal_error(char const   *msg ) ;
#line 498 "meta1lex.c"
static flex_int16_t const   yy_accept[54]  = 
#line 498
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )2, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )24, 
        (flex_int16_t const   )22,      (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )22, 
        (flex_int16_t const   )7,      (flex_int16_t const   )11,      (flex_int16_t const   )21,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )2,      (flex_int16_t const   )4, 
        (flex_int16_t const   )3,      (flex_int16_t const   )23,      (flex_int16_t const   )18,      (flex_int16_t const   )17, 
        (flex_int16_t const   )23,      (flex_int16_t const   )19,      (flex_int16_t const   )0,      (flex_int16_t const   )12, 
        (flex_int16_t const   )0,      (flex_int16_t const   )7,      (flex_int16_t const   )6,      (flex_int16_t const   )11, 
        (flex_int16_t const   )1,      (flex_int16_t const   )9,      (flex_int16_t const   )11,      (flex_int16_t const   )10, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )5, 
        (flex_int16_t const   )0,      (flex_int16_t const   )18,      (flex_int16_t const   )17,      (flex_int16_t const   )0, 
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )14,      (flex_int16_t const   )14, 
        (flex_int16_t const   )8,      (flex_int16_t const   )15,      (flex_int16_t const   )13,      (flex_int16_t const   )15, 
        (flex_int16_t const   )13,      (flex_int16_t const   )0};
#line 508 "meta1lex.c"
static flex_int32_t const   yy_ec[256]  = 
#line 508
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )5, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )1, 
        (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11, 
        (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11, 
        (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )8,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )14,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )1, 
        (flex_int32_t const   )15,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )8, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )16,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 540 "meta1lex.c"
static flex_int32_t const   yy_meta[17]  = 
#line 540
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4};
#line 546 "meta1lex.c"
static flex_int16_t const   yy_base[68]  = 
#line 546
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )19,      (flex_int16_t const   )32,      (flex_int16_t const   )60, 
        (flex_int16_t const   )136,      (flex_int16_t const   )51,      (flex_int16_t const   )136,      (flex_int16_t const   )15, 
        (flex_int16_t const   )48,      (flex_int16_t const   )0,      (flex_int16_t const   )136,      (flex_int16_t const   )44, 
        (flex_int16_t const   )38,      (flex_int16_t const   )45,      (flex_int16_t const   )0,      (flex_int16_t const   )136, 
        (flex_int16_t const   )18,      (flex_int16_t const   )55,      (flex_int16_t const   )136,      (flex_int16_t const   )136, 
        (flex_int16_t const   )30,      (flex_int16_t const   )43,      (flex_int16_t const   )22,      (flex_int16_t const   )136, 
        (flex_int16_t const   )28,      (flex_int16_t const   )40,      (flex_int16_t const   )136,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )18,      (flex_int16_t const   )61,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )136, 
        (flex_int16_t const   )72,      (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )24, 
        (flex_int16_t const   )136,      (flex_int16_t const   )0,      (flex_int16_t const   )136,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )136, 
        (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )87,      (flex_int16_t const   )92, 
        (flex_int16_t const   )97,      (flex_int16_t const   )102,      (flex_int16_t const   )105,      (flex_int16_t const   )110, 
        (flex_int16_t const   )115,      (flex_int16_t const   )120,      (flex_int16_t const   )125,      (flex_int16_t const   )130, 
        (flex_int16_t const   )28,      (flex_int16_t const   )27,      (flex_int16_t const   )26,      (flex_int16_t const   )20};
#line 557 "meta1lex.c"
static flex_int16_t const   yy_def[68]  = 
#line 557
  {      (flex_int16_t const   )0,      (flex_int16_t const   )53,      (flex_int16_t const   )1,      (flex_int16_t const   )54, 
        (flex_int16_t const   )54,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )56, 
        (flex_int16_t const   )57,      (flex_int16_t const   )58,      (flex_int16_t const   )53,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )59,      (flex_int16_t const   )53, 
        (flex_int16_t const   )60,      (flex_int16_t const   )61,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )62,      (flex_int16_t const   )53,      (flex_int16_t const   )56,      (flex_int16_t const   )53, 
        (flex_int16_t const   )63,      (flex_int16_t const   )57,      (flex_int16_t const   )53,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )17, 
        (flex_int16_t const   )59,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )53, 
        (flex_int16_t const   )61,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )62, 
        (flex_int16_t const   )53,      (flex_int16_t const   )64,      (flex_int16_t const   )53,      (flex_int16_t const   )65, 
        (flex_int16_t const   )34,      (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )0,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53};
#line 568 "meta1lex.c"
static flex_int16_t const   yy_nxt[153]  = 
#line 568
  {      (flex_int16_t const   )0,      (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )13,      (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17, 
        (flex_int16_t const   )17,      (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )8, 
        (flex_int16_t const   )13,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )27, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )22,      (flex_int16_t const   )23, 
        (flex_int16_t const   )38,      (flex_int16_t const   )52,      (flex_int16_t const   )27,      (flex_int16_t const   )39, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )28,      (flex_int16_t const   )51, 
        (flex_int16_t const   )50,      (flex_int16_t const   )49,      (flex_int16_t const   )24,      (flex_int16_t const   )22, 
        (flex_int16_t const   )23,      (flex_int16_t const   )28,      (flex_int16_t const   )53,      (flex_int16_t const   )38, 
        (flex_int16_t const   )45,      (flex_int16_t const   )53,      (flex_int16_t const   )39,      (flex_int16_t const   )30, 
        (flex_int16_t const   )47,      (flex_int16_t const   )25,      (flex_int16_t const   )45,      (flex_int16_t const   )24, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )32,      (flex_int16_t const   )30, 
        (flex_int16_t const   )34,      (flex_int16_t const   )25,      (flex_int16_t const   )34,      (flex_int16_t const   )35, 
        (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )41,      (flex_int16_t const   )42, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )43,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )41, 
        (flex_int16_t const   )42,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )43, 
        (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )21, 
        (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )26,      (flex_int16_t const   )53, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )36, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )37,      (flex_int16_t const   )53,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )44,      (flex_int16_t const   )53, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )46, 
        (flex_int16_t const   )53,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )7,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53};
#line 589 "meta1lex.c"
static flex_int16_t const   yy_chk[153]  = 
#line 589
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )11, 
        (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )5, 
        (flex_int16_t const   )20,      (flex_int16_t const   )67,      (flex_int16_t const   )26,      (flex_int16_t const   )20, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )11,      (flex_int16_t const   )66, 
        (flex_int16_t const   )65,      (flex_int16_t const   )64,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )6,      (flex_int16_t const   )26,      (flex_int16_t const   )37,      (flex_int16_t const   )38, 
        (flex_int16_t const   )43,      (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )29, 
        (flex_int16_t const   )28,      (flex_int16_t const   )25,      (flex_int16_t const   )24,      (flex_int16_t const   )6, 
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )15,      (flex_int16_t const   )12, 
        (flex_int16_t const   )16,      (flex_int16_t const   )9,      (flex_int16_t const   )16,      (flex_int16_t const   )17, 
        (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )21,      (flex_int16_t const   )21, 
        (flex_int16_t const   )7,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )21,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )40, 
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54, 
        (flex_int16_t const   )54,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )0, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )57, 
        (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )57, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )59, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )59,      (flex_int16_t const   )59, 
        (flex_int16_t const   )60,      (flex_int16_t const   )0,      (flex_int16_t const   )60,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )62,      (flex_int16_t const   )0, 
        (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )62,      (flex_int16_t const   )63, 
        (flex_int16_t const   )0,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53};
#line 610 "meta1lex.c"
static yy_state_type yy_last_accepting_state  ;
#line 611 "meta1lex.c"
static char *yy_last_accepting_cpos  ;
#line 613
int meta1_flex_debug ;
#line 614 "meta1lex.c"
int meta1_flex_debug  =    1;
#line 616 "meta1lex.c"
static flex_int16_t const   yy_rule_linenum[23]  = 
#line 616
  {      (flex_int16_t const   )0,      (flex_int16_t const   )45,      (flex_int16_t const   )46,      (flex_int16_t const   )47, 
        (flex_int16_t const   )48,      (flex_int16_t const   )49,      (flex_int16_t const   )51,      (flex_int16_t const   )52, 
        (flex_int16_t const   )54,      (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )61, 
        (flex_int16_t const   )66,      (flex_int16_t const   )70,      (flex_int16_t const   )74,      (flex_int16_t const   )77, 
        (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )84,      (flex_int16_t const   )90, 
        (flex_int16_t const   )91,      (flex_int16_t const   )92,      (flex_int16_t const   )93};
#line 311 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
void meta1_parser_set_debug(void) ;
#line 312
int meta1lex(void) ;
#line 314
int meta1parse(void) ;
#line 329
void logmsg_vprintf(int prio , char const   *fmt , va_list ap ) ;
#line 72 "meta1gram.h"
YYSTYPE___0 meta1lval ;
#line 17 "/home/ysko/Works/test-src/pies-1.2/src/meta1lex.h"
grecs_locus_t meta1_locus  ;
#line 18 "/home/ysko/Works/test-src/pies-1.2/src/meta1lex.h"
size_t meta1_error_count  ;
#line 19 "/home/ysko/Works/test-src/pies-1.2/src/meta1lex.h"
char *meta1_queue_dir  ;
#line 21
char *meta1_string(char const   *str , size_t len ) ;
#line 22
void meta1_line_add(char const   *text , size_t len ) ;
#line 23
void meta1_line_add_unescape_last(char const   *text , size_t len ) ;
#line 24
void meta1_line_add_unescape_hex(char const   *text , size_t len ) ;
#line 25
void meta1_line_begin(void) ;
#line 26
char *meta1_line_finish(void) ;
#line 27
void meta1_parse_error(char const   *fmt  , ...) ;
#line 34 "meta1lex.l"
struct obstack meta1_stk  ;
#line 35 "meta1lex.l"
int meta1_stk_init  ;
#line 673 "meta1lex.c"
static int yy_init_globals(void) ;
#line 683
int meta1lex_destroy(void) ;
#line 685
int meta1get_debug(void) ;
#line 687
void meta1set_debug(int bdebug ) ;
#line 693
FILE *meta1get_in(void) ;
#line 695
void meta1set_in(FILE *in_str ) ;
#line 697
FILE *meta1get_out(void) ;
#line 699
void meta1set_out(FILE *out_str ) ;
#line 701
int meta1get_leng(void) ;
#line 703
char *meta1get_text(void) ;
#line 705
int meta1get_lineno(void) ;
#line 707
void meta1set_lineno(int line_number ) ;
#line 720
int meta1wrap(void) ;
#line 884 "meta1lex.c"
int meta1lex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 896
  if (! yy_init) {
#line 898
    yy_init = 1;
#line 904
    if (! yy_start) {
#line 905
      yy_start = 1;
    }
#line 907
    if (! meta1in) {
#line 909
      meta1in = stdin;
    }
#line 914
    if (! meta1out) {
#line 916
      meta1out = stdout;
    }
#line 921
    if (yy_buffer_stack) {
#line 921
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 921
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 921
    if (! tmp) {
      {
#line 922
      meta1ensure_buffer_stack();
#line 923
      *(yy_buffer_stack + yy_buffer_stack_top) = meta1_create_buffer(meta1in, 16384);
      }
    }
    {
#line 927
    meta1_load_buffer_state();
    }
  }
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 933
    yy_cp = yy_c_buf_p;
#line 936
    *yy_cp = yy_hold_char;
#line 941
    yy_bp = yy_cp;
#line 944
    yy_current_state = yy_start;
    yy_match: 
    {
#line 946
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 948
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 949
      if (yy_accept[yy_current_state]) {
#line 951
        yy_last_accepting_state = yy_current_state;
#line 952
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 954
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 954
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 954
          goto while_break___1;
        }
#line 956
        yy_current_state = (int )yy_def[yy_current_state];
#line 957
        if (yy_current_state >= 54) {
#line 958
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 960
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 961
      yy_cp ++;
#line 946
      if (! ((int const   )yy_base[yy_current_state] != 136)) {
#line 946
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 967
    yy_act = (int )yy_accept[yy_current_state];
#line 968
    if (yy_act == 0) {
#line 970
      yy_cp = yy_last_accepting_cpos;
#line 971
      yy_current_state = yy_last_accepting_state;
#line 972
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 975
    meta1text = yy_bp;
#line 975
    meta1leng = (int )((size_t )(yy_cp - yy_bp));
#line 975
    yy_hold_char = *yy_cp;
#line 975
    *yy_cp = (char )'\000';
#line 975
    yy_c_buf_p = yy_cp;
    do_action: 
#line 982
    if (meta1_flex_debug) {
#line 984
      if (yy_act == 0) {
        {
#line 985
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--scanner backing up\n");
        }
      } else
#line 986
      if (yy_act < 23) {
        {
#line 987
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting rule at line %ld (\"%s\")\n",
                (long )yy_rule_linenum[yy_act], meta1text);
        }
      } else
#line 989
      if (yy_act == 23) {
        {
#line 990
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting default rule (\"%s\")\n",
                meta1text);
        }
      } else
#line 992
      if (yy_act == 24) {
        {
#line 993
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 995
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--EOF (start condition %d)\n",
                (yy_start - 1) / 2);
        }
      }
    }
    {
#line 1001
    if (yy_act == 0) {
#line 1001
      goto case_0;
    }
#line 1008
    if (yy_act == 1) {
#line 1008
      goto case_1;
    }
#line 47
    if (yy_act == 2) {
#line 47 "meta1lex.l"
      goto case_2;
    }
#line 48
    if (yy_act == 3) {
#line 48
      goto case_3;
    }
#line 49
    if (yy_act == 4) {
#line 49
      goto case_4;
    }
#line 50
    if (yy_act == 5) {
#line 50
      goto case_5;
    }
#line 52
    if (yy_act == 6) {
#line 52
      goto case_6;
    }
#line 53
    if (yy_act == 7) {
#line 53
      goto case_7;
    }
#line 56
    if (yy_act == 10) {
#line 56
      goto case_10;
    }
#line 56
    if (yy_act == 9) {
#line 56
      goto case_10;
    }
#line 56
    if (yy_act == 8) {
#line 56
      goto case_10;
    }
#line 62
    if (yy_act == 11) {
#line 62
      goto case_11;
    }
#line 67
    if (yy_act == 12) {
#line 67
      goto case_12;
    }
#line 71
    if (yy_act == 13) {
#line 71
      goto case_13;
    }
#line 75
    if (yy_act == 14) {
#line 75
      goto case_14;
    }
#line 78
    if (yy_act == 15) {
#line 78
      goto case_15;
    }
#line 79
    if (yy_act == 16) {
#line 79
      goto case_16;
    }
#line 80
    if (yy_act == 17) {
#line 80
      goto case_17;
    }
#line 85
    if (yy_act == 18) {
#line 85
      goto case_18;
    }
#line 91
    if (yy_act == 19) {
#line 91
      goto case_19;
    }
#line 92
    if (yy_act == 20) {
#line 92
      goto case_20;
    }
#line 93
    if (yy_act == 21) {
#line 93
      goto case_21;
    }
#line 94
    if (yy_act == 22) {
#line 94
      goto case_22;
    }
#line 99
    if (yy_act == 23) {
#line 99
      goto case_23;
    }
#line 1155
    if (yy_act == 27) {
#line 1155 "meta1lex.c"
      goto case_27;
    }
#line 1155
    if (yy_act == 26) {
#line 1155
      goto case_27;
    }
#line 1155
    if (yy_act == 25) {
#line 1155
      goto case_27;
    }
#line 1158
    if (yy_act == 24) {
#line 1158
      goto case_24;
    }
#line 1281
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1003
    *yy_cp = yy_hold_char;
#line 1004
    yy_cp = yy_last_accepting_cpos;
#line 1005
    yy_current_state = yy_last_accepting_state;
#line 1006
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 45 "meta1lex.l"
    yy_start = 3;
#line 46
    goto switch_break;
    case_2: /* CIL Label */ 
#line 47
    goto switch_break;
    case_3: /* CIL Label */ 
#line 48
    goto switch_break;
    case_4: /* CIL Label */ 
#line 48
    (meta1_locus.line) ++;
#line 49
    goto switch_break;
    case_5: /* CIL Label */ 
#line 49
    yy_start = 1;
#line 50
    goto switch_break;
    case_6: /* CIL Label */ 
#line 51
    (meta1_locus.line) ++;
#line 52
    goto switch_break;
    case_7: /* CIL Label */ ;
#line 53
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    {
#line 56
    meta1_line_begin();
#line 57
    meta1_line_add((char const   *)meta1text, (size_t )meta1leng);
#line 58
    meta1lval.string = meta1_line_finish();
    }
#line 59
    return (260);
#line 60
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 61
    meta1_line_begin();
#line 62
    meta1_line_add((char const   *)meta1text, (size_t )meta1leng);
#line 63
    meta1lval.string = meta1_line_finish();
    }
#line 64
    return (258);
#line 65
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 66
    meta1_line_begin();
#line 67
    meta1_line_add((char const   *)(meta1text + 1), (size_t )(meta1leng - 2));
#line 68
    meta1lval.string = meta1_line_finish();
    }
#line 69
    return (259);
#line 70
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 70
    yy_start = 5;
#line 71
    meta1_line_begin();
#line 72
    meta1_line_add_unescape_hex((char const   *)(meta1text + 1), (size_t )(meta1leng - 1));
    }
#line 74
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 74
    yy_start = 5;
#line 75
    meta1_line_begin();
#line 76
    meta1_line_add_unescape_last((char const   *)(meta1text + 1), (size_t )(meta1leng - 1));
    }
#line 77
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 77
    meta1_line_add_unescape_hex((char const   *)meta1text, (size_t )meta1leng);
    }
#line 78
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 78
    meta1_line_add_unescape_last((char const   *)meta1text, (size_t )meta1leng);
    }
#line 79
    goto switch_break;
    case_17: /* CIL Label */ 
#line 79
    yy_start = 1;
#line 80
    if (meta1leng > 1) {
      {
#line 81
      meta1_line_add((char const   *)meta1text, (size_t )(meta1leng - 1));
      }
    }
    {
#line 82
    meta1lval.string = meta1_line_finish();
    }
#line 83
    return (259);
#line 84
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 84
    yy_start = 1;
#line 85
    tmp___0 = gettext("newline in a string");
#line 85
    meta1_parse_error((char const   *)tmp___0);
#line 86
    meta1_line_add((char const   *)meta1text, (size_t )(meta1leng - 1));
#line 87
    meta1lval.string = meta1_line_finish();
    }
#line 88
    return (259);
#line 89
    goto switch_break;
    case_19: /* CIL Label */ ;
#line 91
    goto switch_break;
    case_20: /* CIL Label */ 
#line 91
    (meta1_locus.line) ++;
#line 92
    goto switch_break;
    case_21: /* CIL Label */ 
#line 92
    return ((int )*(meta1text + 0));
#line 93
    goto switch_break;
    case_22: /* CIL Label */ 
#line 93
    if (((int )*(meta1text + 0) & -128) == 0) {
      {
#line 93
      tmp___3 = __ctype_b_loc();
      }
#line 93
      if ((int const   )*(*tmp___3 + (int )*(meta1text + 0)) & 16384) {
        {
#line 94
        tmp___1 = gettext("stray character %c");
#line 94
        meta1_parse_error((char const   *)tmp___1, (int )*(meta1text + 0));
        }
      } else {
        {
#line 96
        tmp___2 = gettext("stray character \\%03o");
#line 96
        meta1_parse_error((char const   *)tmp___2, (int )((unsigned char )*(meta1text + 0)));
        }
      }
    } else {
      {
#line 96
      tmp___2 = gettext("stray character \\%03o");
#line 96
      meta1_parse_error((char const   *)tmp___2, (int )((unsigned char )*(meta1text + 0)));
      }
    }
#line 98
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 98
    fwrite((void const   */* __restrict  */)meta1text, (size_t )meta1leng, (size_t )1,
           (FILE */* __restrict  */)meta1out);
    }
#line 99
    goto switch_break;
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
#line 1156 "meta1lex.c"
    return (0);
    case_24: /* CIL Label */ 
#line 1161
    yy_amount_of_matched_text = (int )(yy_cp - meta1text) - 1;
#line 1164
    *yy_cp = yy_hold_char;
#line 1167
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buffer_status == 0) {
#line 1178
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_n_chars;
#line 1179
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_input_file = meta1in;
#line 1180
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buffer_status = 1;
    }
#line 1190
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf + yy_n_chars)) {
      {
#line 1194
      yy_c_buf_p = meta1text + yy_amount_of_matched_text;
#line 1196
      yy_current_state = yy_get_previous_state();
#line 1207
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1209
      yy_bp = meta1text + 0;
      }
#line 1211
      if (yy_next_state) {
#line 1214
        yy_c_buf_p ++;
#line 1214
        yy_cp = yy_c_buf_p;
#line 1215
        yy_current_state = yy_next_state;
#line 1216
        goto yy_match;
      } else {
#line 1222
        yy_cp = yy_c_buf_p;
#line 1223
        goto yy_find_action;
      }
    } else {
      {
#line 1227
      tmp___4 = yy_get_next_buffer();
      }
      {
#line 1229
      if (tmp___4 == 1) {
#line 1229
        goto case_1___0;
      }
#line 1258
      if (tmp___4 == 0) {
#line 1258
        goto case_0___0;
      }
#line 1268
      if (tmp___4 == 2) {
#line 1268
        goto case_2___0;
      }
#line 1227
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1231
      yy_did_buffer_switch_on_eof = 0;
#line 1233
      tmp___5 = meta1wrap();
      }
#line 1233
      if (tmp___5) {
#line 1244
        yy_c_buf_p = meta1text + 0;
#line 1246
        yy_act = (24 + (yy_start - 1) / 2) + 1;
#line 1247
        goto do_action;
      } else
#line 1252
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1253
        meta1restart(meta1in);
        }
      }
#line 1255
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1259
      yy_c_buf_p = meta1text + yy_amount_of_matched_text;
#line 1262
      yy_current_state = yy_get_previous_state();
#line 1264
      yy_cp = yy_c_buf_p;
#line 1265
      yy_bp = meta1text + 0;
      }
#line 1266
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1269
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf + yy_n_chars;
#line 1272
      yy_current_state = yy_get_previous_state();
#line 1274
      yy_cp = yy_c_buf_p;
#line 1275
      yy_bp = meta1text + 0;
      }
#line 1276
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1278
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1282
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1304 "meta1lex.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_grecs_size_t new_size___0 ;
  void *tmp___10 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1309
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf;
#line 1310
  source = meta1text;
#line 1314
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf + (yy_n_chars + 1))) {
    {
#line 1315
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1318
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_fill_buffer == 0) {
#line 1320
    if (yy_c_buf_p - meta1text == 1L) {
#line 1325
      return (1);
    } else {
#line 1333
      return (2);
    }
  }
#line 1340
  number_to_move = (int )(yy_c_buf_p - meta1text) - 1;
#line 1342
  i = 0;
  {
#line 1342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1342
    if (! (i < number_to_move)) {
#line 1342
      goto while_break;
    }
#line 1343
    tmp = dest;
#line 1343
    dest ++;
#line 1343
    tmp___0 = source;
#line 1343
    source ++;
#line 1343
    *tmp = *tmp___0;
#line 1342
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1345
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buffer_status == 2) {
#line 1349
    yy_n_chars = 0;
#line 1349
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_n_chars = yy_n_chars;
  } else {
#line 1353
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buf_size - (yy_grecs_size_t )number_to_move) - 1U);
    {
#line 1356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1356
      if (! (num_to_read <= 0)) {
#line 1356
        goto while_break___0;
      }
#line 1360
      if (yy_buffer_stack) {
#line 1360
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1360
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1360
      b = tmp___1;
#line 1362
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_grecs_ch_buf);
#line 1365
      if (b->yy_grecs_is_our_buffer) {
#line 1367
        new_size = (int )(b->yy_grecs_buf_size * 2U);
#line 1369
        if (new_size <= 0) {
#line 1370
          b->yy_grecs_buf_size += b->yy_grecs_buf_size / 8U;
        } else {
#line 1372
          b->yy_grecs_buf_size *= 2U;
        }
        {
#line 1374
        tmp___2 = meta1realloc((void *)b->yy_grecs_ch_buf, b->yy_grecs_buf_size + 2U);
#line 1374
        b->yy_grecs_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1380
        b->yy_grecs_ch_buf = (char *)0;
      }
#line 1382
      if (! b->yy_grecs_ch_buf) {
        {
#line 1383
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1386
      yy_c_buf_p = b->yy_grecs_ch_buf + yy_c_buf_p_offset;
#line 1388
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buf_size - (yy_grecs_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1393
    if (num_to_read > 8192) {
#line 1394
      num_to_read = 8192;
    }
#line 1397
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_is_interactive) {
#line 1397
      c = '*';
#line 1397
      n = 0;
      {
#line 1397
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1397
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 1397
          c = _IO_getc(meta1in);
          }
#line 1397
          if (c != -1) {
#line 1397
            if (! (c != 10)) {
#line 1397
              goto while_break___1;
            }
          } else {
#line 1397
            goto while_break___1;
          }
        } else {
#line 1397
          goto while_break___1;
        }
#line 1397
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf + number_to_move) + n) = (char )c;
#line 1397
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1397
      if (c == 10) {
#line 1397
        tmp___3 = n;
#line 1397
        n ++;
#line 1397
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1397
      if (c == -1) {
        {
#line 1397
        tmp___4 = ferror(meta1in);
        }
#line 1397
        if (tmp___4) {
          {
#line 1397
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1397
      yy_n_chars = n;
    } else {
      {
#line 1397
      tmp___5 = __errno_location();
#line 1397
      *tmp___5 = 0;
      }
      {
#line 1397
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1397
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)meta1in);
#line 1397
        yy_n_chars = (int )tmp___8;
        }
#line 1397
        if (yy_n_chars == 0) {
          {
#line 1397
          tmp___9 = ferror(meta1in);
          }
#line 1397
          if (! tmp___9) {
#line 1397
            goto while_break___2;
          }
        } else {
#line 1397
          goto while_break___2;
        }
        {
#line 1397
        tmp___6 = __errno_location();
        }
#line 1397
        if (*tmp___6 != 4) {
          {
#line 1397
          yy_fatal_error("input in flex scanner failed");
          }
#line 1397
          goto while_break___2;
        }
        {
#line 1397
        tmp___7 = __errno_location();
#line 1397
        *tmp___7 = 0;
#line 1397
        clearerr(meta1in);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1400
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_n_chars = yy_n_chars;
  }
#line 1403
  if (yy_n_chars == 0) {
#line 1405
    if (number_to_move == 0) {
      {
#line 1407
      ret_val = 1;
#line 1408
      meta1restart(meta1in);
      }
    } else {
#line 1413
      ret_val = 2;
#line 1414
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buffer_status = 2;
    }
  } else {
#line 1420
    ret_val = 0;
  }
#line 1422
  if ((yy_grecs_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buf_size) {
    {
#line 1424
    new_size___0 = (yy_grecs_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1425
    tmp___10 = meta1realloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf,
                            new_size___0);
#line 1425
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf = (char *)tmp___10;
    }
#line 1426
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf) {
      {
#line 1427
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1430
  yy_n_chars += number_to_move;
#line 1431
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf + yy_n_chars) = (char)0;
#line 1432
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1434
  meta1text = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_ch_buf + 0;
#line 1436
  return (ret_val);
}
}
#line 1444 "meta1lex.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1453
  yy_current_state = yy_start;
#line 1455
  yy_cp = meta1text + 0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1455
      goto while_break;
    }
#line 1458
    if (*yy_cp) {
#line 1458
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1458
      tmp = (flex_int32_t const   )1;
    }
#line 1458
    yy_c = (YY_CHAR )tmp;
#line 1459
    if (yy_accept[yy_current_state]) {
#line 1461
      yy_last_accepting_state = yy_current_state;
#line 1462
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1464
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1464
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1464
        goto while_break___0;
      }
#line 1466
      yy_current_state = (int )yy_def[yy_current_state];
#line 1467
      if (yy_current_state >= 54) {
#line 1468
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1470
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1455
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1473
  return (yy_current_state);
}
}
#line 1482 "meta1lex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1489
  yy_cp = yy_c_buf_p;
#line 1491
  yy_c = (YY_CHAR )1;
#line 1492
  if (yy_accept[yy_current_state]) {
#line 1494
    yy_last_accepting_state = yy_current_state;
#line 1495
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1497
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1497
      goto while_break;
    }
#line 1499
    yy_current_state = (int )yy_def[yy_current_state];
#line 1500
    if (yy_current_state >= 54) {
#line 1501
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1503
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1504
  yy_is_jam = yy_current_state == 53;
#line 1506
  if (yy_is_jam) {
#line 1506
    tmp = 0;
  } else {
#line 1506
    tmp = yy_current_state;
  }
#line 1506
  return (tmp);
}
}
#line 1644 "meta1lex.c"
void meta1restart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1650
  if (yy_buffer_stack) {
#line 1650
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1650
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1650
  if (! tmp) {
    {
#line 1651
    meta1ensure_buffer_stack();
#line 1652
    *(yy_buffer_stack + yy_buffer_stack_top) = meta1_create_buffer(meta1in, 16384);
    }
  }
#line 1656
  if (yy_buffer_stack) {
#line 1656
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1656
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1656
  meta1_init_buffer(tmp___0, input_file);
#line 1657
  meta1_load_buffer_state();
  }
#line 1658
  return;
}
}
#line 1665 "meta1lex.c"
void meta1_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1676
  meta1ensure_buffer_stack();
  }
#line 1677
  if (yy_buffer_stack) {
#line 1677
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1677
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1677
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1678
    return;
  }
#line 1680
  if (yy_buffer_stack) {
#line 1680
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1680
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1680
  if (tmp___0) {
#line 1683
    *yy_c_buf_p = yy_hold_char;
#line 1684
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buf_pos = yy_c_buf_p;
#line 1685
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_n_chars = yy_n_chars;
  }
  {
#line 1688
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1689
  meta1_load_buffer_state();
#line 1696
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1697
  return;
}
}
#line 1700 "meta1lex.c"
static void meta1_load_buffer_state(void) 
{ 


  {
#line 1705
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_n_chars;
#line 1706
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buf_pos;
#line 1706
  meta1text = yy_c_buf_p;
#line 1707
  meta1in = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_input_file;
#line 1708
  yy_hold_char = *yy_c_buf_p;
#line 1709
  return;
}
}
#line 1718 "meta1lex.c"
YY_BUFFER_STATE meta1_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1725
  tmp = meta1alloc((yy_grecs_size_t )sizeof(struct yy_grecs_buffer_state ));
#line 1725
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1726
  if (! b) {
    {
#line 1727
    yy_fatal_error("out of dynamic memory in meta1_create_buffer()");
    }
  }
  {
#line 1729
  b->yy_grecs_buf_size = (yy_grecs_size_t )size;
#line 1734
  tmp___0 = meta1alloc(b->yy_grecs_buf_size + 2U);
#line 1734
  b->yy_grecs_ch_buf = (char *)tmp___0;
  }
#line 1735
  if (! b->yy_grecs_ch_buf) {
    {
#line 1736
    yy_fatal_error("out of dynamic memory in meta1_create_buffer()");
    }
  }
  {
#line 1738
  b->yy_grecs_is_our_buffer = 1;
#line 1740
  meta1_init_buffer(b, file);
  }
#line 1742
  return (b);
}
}
#line 1750 "meta1lex.c"
void meta1_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1756
  if (! b) {
#line 1757
    return;
  }
#line 1759
  if (yy_buffer_stack) {
#line 1759
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1759
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1759
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1760
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1762
  if (b->yy_grecs_is_our_buffer) {
    {
#line 1763
    meta1free((void *)b->yy_grecs_ch_buf);
    }
  }
  {
#line 1765
  meta1free((void *)b);
  }
#line 1766
  return;
}
}
#line 1784 "meta1lex.c"
static void meta1_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1790
  tmp = __errno_location();
#line 1790
  oerrno = *tmp;
#line 1792
  meta1_flush_buffer(b);
#line 1794
  b->yy_grecs_input_file = file;
#line 1795
  b->yy_grecs_fill_buffer = 1;
  }
#line 1801
  if (yy_buffer_stack) {
#line 1801
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1801
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1801
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1802
    b->yy_grecs_bs_lineno = 1;
#line 1803
    b->yy_grecs_bs_column = 0;
  }
#line 1808
  if (file) {
    {
#line 1808
    tmp___1 = fileno(file);
#line 1808
    tmp___2 = isatty(tmp___1);
#line 1808
    b->yy_grecs_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1808
    b->yy_grecs_is_interactive = 0;
  }
  {
#line 1813
  tmp___3 = __errno_location();
#line 1813
  *tmp___3 = oerrno;
  }
#line 1814
  return;
}
}
#line 1821 "meta1lex.c"
void meta1_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1826
  if (! b) {
#line 1827
    return;
  }
#line 1829
  b->yy_grecs_n_chars = 0;
#line 1835
  *(b->yy_grecs_ch_buf + 0) = (char)0;
#line 1836
  *(b->yy_grecs_ch_buf + 1) = (char)0;
#line 1838
  b->yy_grecs_buf_pos = b->yy_grecs_ch_buf + 0;
#line 1840
  b->yy_grecs_at_bol = 1;
#line 1841
  b->yy_grecs_buffer_status = 0;
#line 1843
  if (yy_buffer_stack) {
#line 1843
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1843
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1843
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1844
    meta1_load_buffer_state();
    }
  }
#line 1845
  return;
}
}
#line 1855 "meta1lex.c"
void meta1push_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1860
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1861
    return;
  }
  {
#line 1863
  meta1ensure_buffer_stack();
  }
#line 1866
  if (yy_buffer_stack) {
#line 1866
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1866
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1866
  if (tmp) {
#line 1869
    *yy_c_buf_p = yy_hold_char;
#line 1870
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_buf_pos = yy_c_buf_p;
#line 1871
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_grecs_n_chars = yy_n_chars;
  }
#line 1875
  if (yy_buffer_stack) {
#line 1875
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1875
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1875
  if (tmp___0) {
#line 1876
    yy_buffer_stack_top ++;
  }
  {
#line 1877
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1880
  meta1_load_buffer_state();
#line 1881
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1882
  return;
}
}
#line 1891 "meta1lex.c"
void meta1pop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1896
  if (yy_buffer_stack) {
#line 1896
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1896
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1896
  if (! tmp) {
#line 1897
    return;
  }
#line 1899
  if (yy_buffer_stack) {
#line 1899
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1899
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1899
  meta1_delete_buffer(tmp___0);
#line 1900
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1901
  if (yy_buffer_stack_top > 0U) {
#line 1902
    yy_buffer_stack_top --;
  }
#line 1904
  if (yy_buffer_stack) {
#line 1904
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1904
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1904
  if (tmp___1) {
    {
#line 1905
    meta1_load_buffer_state();
#line 1906
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1908
  return;
}
}
#line 1916 "meta1lex.c"
static void meta1ensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1923
  if (! yy_buffer_stack) {
    {
#line 1929
    num_to_alloc = 1;
#line 1930
    tmp = meta1alloc((yy_grecs_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_grecs_buffer_state *)));
#line 1930
    yy_buffer_stack = (struct yy_grecs_buffer_state **)tmp;
    }
#line 1933
    if (! yy_buffer_stack) {
      {
#line 1934
      yy_fatal_error("out of dynamic memory in meta1ensure_buffer_stack()");
      }
    }
    {
#line 1936
    memset((void *)yy_buffer_stack, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_grecs_buffer_state *)));
#line 1938
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1939
    yy_buffer_stack_top = (size_t )0;
    }
#line 1940
    return;
  }
#line 1943
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1U) {
    {
#line 1946
    grow_size = 8;
#line 1948
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1949
    tmp___0 = meta1realloc((void *)yy_buffer_stack, (yy_grecs_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_grecs_buffer_state *)));
#line 1949
    yy_buffer_stack = (struct yy_grecs_buffer_state **)tmp___0;
    }
#line 1953
    if (! yy_buffer_stack) {
      {
#line 1954
      yy_fatal_error("out of dynamic memory in meta1ensure_buffer_stack()");
      }
    }
    {
#line 1957
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_grecs_buffer_state *)));
#line 1958
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1960
  return;
}
}
#line 1970 "meta1lex.c"
YY_BUFFER_STATE meta1_scan_buffer(char *base , yy_grecs_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 1974
  if (size < 2U) {
#line 1978
    return ((YY_BUFFER_STATE )0);
  } else
#line 1974
  if ((int )*(base + (size - 2U)) != 0) {
#line 1978
    return ((YY_BUFFER_STATE )0);
  } else
#line 1974
  if ((int )*(base + (size - 1U)) != 0) {
#line 1978
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1980
  tmp = meta1alloc((yy_grecs_size_t )sizeof(struct yy_grecs_buffer_state ));
#line 1980
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1981
  if (! b) {
    {
#line 1982
    yy_fatal_error("out of dynamic memory in meta1_scan_buffer()");
    }
  }
  {
#line 1984
  b->yy_grecs_buf_size = size - 2U;
#line 1985
  tmp___0 = base;
#line 1985
  b->yy_grecs_ch_buf = tmp___0;
#line 1985
  b->yy_grecs_buf_pos = tmp___0;
#line 1986
  b->yy_grecs_is_our_buffer = 0;
#line 1987
  b->yy_grecs_input_file = (FILE *)0;
#line 1988
  b->yy_grecs_n_chars = (int )b->yy_grecs_buf_size;
#line 1989
  b->yy_grecs_is_interactive = 0;
#line 1990
  b->yy_grecs_at_bol = 1;
#line 1991
  b->yy_grecs_fill_buffer = 0;
#line 1992
  b->yy_grecs_buffer_status = 0;
#line 1994
  meta1_switch_to_buffer(b);
  }
#line 1996
  return (b);
}
}
#line 2009 "meta1lex.c"
YY_BUFFER_STATE meta1_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2012
  tmp = strlen(yystr);
#line 2012
  tmp___0 = meta1_scan_bytes(yystr, (int )tmp);
  }
#line 2012
  return (tmp___0);
}
}
#line 2024 "meta1lex.c"
YY_BUFFER_STATE meta1_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_grecs_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2032
  n = (yy_grecs_size_t )(_yybytes_len + 2);
#line 2033
  tmp = meta1alloc(n);
#line 2033
  buf = (char *)tmp;
  }
#line 2034
  if (! buf) {
    {
#line 2035
    yy_fatal_error("out of dynamic memory in meta1_scan_bytes()");
    }
  }
#line 2037
  i = 0;
  {
#line 2037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2037
    if (! (i < _yybytes_len)) {
#line 2037
      goto while_break;
    }
#line 2038
    *(buf + i) = (char )*(yybytes + i);
#line 2037
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2040
  tmp___0 = (char)0;
#line 2040
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2040
  *(buf + _yybytes_len) = tmp___0;
#line 2042
  b = meta1_scan_buffer(buf, n);
  }
#line 2043
  if (! b) {
    {
#line 2044
    yy_fatal_error("bad buffer in meta1_scan_bytes()");
    }
  }
#line 2049
  b->yy_grecs_is_our_buffer = 1;
#line 2051
  return (b);
}
}
#line 2060 "meta1lex.c"
static void yy_fatal_error(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 2062
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2063
  exit(2);
  }
}
}
#line 2095 "meta1lex.c"
int meta1get_lineno(void) 
{ 


  {
#line 2098
  return (meta1lineno);
}
}
#line 2104 "meta1lex.c"
FILE *meta1get_in(void) 
{ 


  {
#line 2106
  return (meta1in);
}
}
#line 2112 "meta1lex.c"
FILE *meta1get_out(void) 
{ 


  {
#line 2114
  return (meta1out);
}
}
#line 2120 "meta1lex.c"
int meta1get_leng(void) 
{ 


  {
#line 2122
  return (meta1leng);
}
}
#line 2129 "meta1lex.c"
char *meta1get_text(void) 
{ 


  {
#line 2131
  return (meta1text);
}
}
#line 2141 "meta1lex.c"
void meta1set_lineno(int line_number ) 
{ 


  {
#line 2144
  meta1lineno = line_number;
#line 2145
  return;
}
}
#line 2153 "meta1lex.c"
void meta1set_in(FILE *in_str ) 
{ 


  {
#line 2155
  meta1in = in_str;
#line 2156
  return;
}
}
#line 2158 "meta1lex.c"
void meta1set_out(FILE *out_str ) 
{ 


  {
#line 2160
  meta1out = out_str;
#line 2161
  return;
}
}
#line 2163 "meta1lex.c"
int meta1get_debug(void) 
{ 


  {
#line 2165
  return (meta1_flex_debug);
}
}
#line 2168 "meta1lex.c"
void meta1set_debug(int bdebug ) 
{ 


  {
#line 2170
  meta1_flex_debug = bdebug;
#line 2171
  return;
}
}
#line 2181 "meta1lex.c"
static int yy_init_globals(void) 
{ 


  {
#line 2187
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2188
  yy_buffer_stack_top = (size_t )0;
#line 2189
  yy_buffer_stack_max = (size_t )0;
#line 2190
  yy_c_buf_p = (char *)0;
#line 2191
  yy_init = 0;
#line 2192
  yy_start = 0;
#line 2199
  meta1in = (FILE *)0;
#line 2200
  meta1out = (FILE *)0;
#line 2206
  return (0);
}
}
#line 2212 "meta1lex.c"
int meta1lex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2216
    if (yy_buffer_stack) {
#line 2216
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2216
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2216
    if (! tmp___0) {
#line 2216
      goto while_break;
    }
#line 2217
    if (yy_buffer_stack) {
#line 2217
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2217
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2217
    meta1_delete_buffer(tmp);
#line 2218
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2219
    meta1pop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2223
  meta1free((void *)yy_buffer_stack);
#line 2224
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2228
  yy_init_globals();
  }
#line 2232
  return (0);
}
}
#line 2260 "meta1lex.c"
void *meta1alloc(yy_grecs_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2262
  tmp = malloc(size);
  }
#line 2262
  return (tmp);
}
}
#line 2265 "meta1lex.c"
void *meta1realloc(void *ptr , yy_grecs_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2274
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2274
  return (tmp);
}
}
#line 2277 "meta1lex.c"
void meta1free(void *ptr ) 
{ 


  {
  {
#line 2279
  free((void *)((char *)ptr));
  }
#line 2280
  return;
}
}
#line 101 "meta1lex.l"
int meta1wrap(void) 
{ 


  {
#line 104
  return (1);
}
}
#line 107 "meta1lex.l"
void meta1_line_add(char const   *text , size_t len ) 
{ 
  struct obstack *__o ;
  int __len ;

  {
#line 110
  __o = & meta1_stk;
#line 110
  __len = (int )len;
#line 110
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 110
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 110
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)text,
         (size_t )__len);
#line 110
  __o->next_free += __len;
  }
#line 111
  return;
}
}
#line 113 "meta1lex.l"
static char quote_transtab___1[19]  = 
#line 113
  {      (char )'\\',      (char )'\\',      (char )'\"',      (char )'\"', 
        (char )'a',      (char )'\a',      (char )'b',      (char )'\b', 
        (char )'f',      (char )'\f',      (char )'n',      (char )'\n', 
        (char )'r',      (char )'\r',      (char )'t',      (char )'\t', 
        (char )'v',      (char )'\v',      (char )'\000'};
#line 115 "meta1lex.l"
static int unescape_char(int c ) 
{ 
  char *p ;

  {
#line 120
  p = quote_transtab___1;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! *p) {
#line 120
      goto while_break;
    }
#line 122
    if ((int )*p == c) {
#line 123
      return ((int )*(p + 1));
    }
#line 120
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (c);
}
}
#line 128 "meta1lex.l"
static void unescape_to_line(int c ) 
{ 
  char t ;
  int tmp ;
  char *tmp___0 ;
  struct obstack *__o ;
  char *tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 133
  if (c == 118) {
#line 134
    t = (char )'\v';
  } else {
    {
#line 137
    tmp = unescape_char(c);
#line 137
    t = (char )tmp;
    }
#line 138
    if ((int )t == c) {
#line 138
      if ((int )t != 92) {
#line 138
        if ((int )t != 34) {
          {
#line 139
          tmp___0 = gettext("unknown escape sequence \'\\%c\'");
#line 139
          meta1_parse_error((char const   *)tmp___0, c);
          }
        }
      }
    }
  }
#line 141
  __o = & meta1_stk;
#line 141
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 141
    _obstack_newchunk(__o, 1);
    }
  }
#line 141
  tmp___1 = __o->next_free;
#line 141
  (__o->next_free) ++;
#line 141
  *tmp___1 = t;
#line 142
  return;
}
}
#line 144 "meta1lex.l"
void meta1_line_add_unescape_last(char const   *text , size_t len ) 
{ 
  struct obstack *__o ;
  int __len ;

  {
#line 147
  __o = & meta1_stk;
#line 147
  __len = (int )(len - 2U);
#line 147
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 147
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 147
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)text,
         (size_t )__len);
#line 147
  __o->next_free += __len;
#line 148
  unescape_to_line((int )*(text + (len - 1U)));
  }
#line 149
  return;
}
}
#line 151 "meta1lex.l"
void meta1_line_add_unescape_hex(char const   *text , size_t len ) 
{ 
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  char *tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if ((int const   )*(text + (len - 1U)) != 120) {
#line 154
      if (! (len > 0U)) {
#line 154
        goto while_break;
      }
    } else {
#line 154
      goto while_break;
    }
#line 154
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  __o = & meta1_stk;
#line 156
  __len = (int )(len - 2U);
#line 156
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 156
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 156
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)text,
         (size_t )__len);
#line 156
  __o->next_free += __len;
#line 157
  __o___0 = & meta1_stk;
  }
#line 157
  if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
    {
#line 157
    _obstack_newchunk(__o___0, 1);
    }
  }
  {
#line 157
  tmp = __o___0->next_free;
#line 157
  (__o___0->next_free) ++;
#line 157
  tmp___0 = strtoul((char const   */* __restrict  */)(text + len), (char **/* __restrict  */)((void *)0),
                    16);
#line 157
  *tmp = (char )tmp___0;
  }
#line 158
  return;
}
}
#line 160 "meta1lex.l"
void meta1_line_begin(void) 
{ 


  {
#line 163
  if (! meta1_stk_init) {
    {
#line 165
    _obstack_begin(& meta1_stk, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 166
    meta1_stk_init = 1;
    }
  }
#line 168
  return;
}
}
#line 170 "meta1lex.l"
char *meta1_line_finish(void) 
{ 
  struct obstack *__o ;
  char *tmp ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 173
  __o = & meta1_stk;
#line 173
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 173
    _obstack_newchunk(__o, 1);
    }
  }
#line 173
  tmp = __o->next_free;
#line 173
  (__o->next_free) ++;
#line 173
  *tmp = (char)0;
#line 174
  __o1 = & meta1_stk;
#line 174
  __value = (void *)__o1->object_base;
#line 174
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 174
    __o1->maybe_empty_object = 1U;
  }
#line 174
  if (sizeof(int ) < sizeof(void *)) {
#line 174
    tmp___0 = __o1->object_base;
  } else {
#line 174
    tmp___0 = (char *)0;
  }
#line 174
  if (sizeof(int ) < sizeof(void *)) {
#line 174
    tmp___1 = __o1->object_base;
  } else {
#line 174
    tmp___1 = (char *)0;
  }
#line 174
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 174
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 174
    __o1->next_free = __o1->chunk_limit;
  }
#line 174
  __o1->object_base = __o1->next_free;
#line 174
  return ((char *)__value);
}
}
#line 177 "meta1lex.l"
char *meta1_string(char const   *str , size_t len ) 
{ 
  char *tmp ;

  {
  {
#line 180
  meta1_line_begin();
#line 181
  meta1_line_add(str, len);
#line 182
  tmp = meta1_line_finish();
  }
#line 182
  return (tmp);
}
}
#line 185 "meta1lex.l"
void meta1_parse_error(char const   *fmt  , ...) 
{ 
  va_list ap ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 190
  logmsg_printf(3, "%s:%lu: ", meta1_locus.file, (unsigned long )meta1_locus.line);
#line 192
  __builtin_va_start(ap, fmt);
#line 193
  logmsg_vprintf(3, fmt, ap);
#line 194
  __builtin_va_end(ap);
#line 195
  logmsg_printf(3, "\n");
#line 196
  meta1_error_count ++;
  }
#line 197
  return;
}
}
#line 199 "meta1lex.l"
void meta1_lexer_set_debug(void) 
{ 
  char *p ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 202
  tmp = getenv("META1_DEBUG_LEX");
#line 202
  p = tmp;
  }
#line 203
  if (p) {
#line 203
    if ((int )*p - 48 > 0) {
#line 203
      tmp___0 = 1;
    } else {
#line 203
      tmp___0 = 0;
    }
  } else {
#line 203
    tmp___0 = 0;
  }
#line 203
  meta1_flex_debug = tmp___0;
#line 204
  return;
}
}
#line 208 "meta1lex.l"
int meta1_config_parse(char const   *name ) 
{ 
  int rc ;
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 214
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 215
  if (! fp) {
    {
#line 217
    tmp = __errno_location();
#line 217
    tmp___0 = strerror(*tmp);
#line 217
    tmp___1 = gettext("%s: cannot open file: %s");
#line 217
    logmsg(3, (char const   *)tmp___1, name, tmp___0);
    }
#line 219
    return (1);
  }
  {
#line 221
  tmp___2 = strlen(name);
#line 221
  meta1_locus.file = meta1_string(name, tmp___2);
#line 222
  meta1_locus.line = 1;
#line 223
  meta1_lexer_set_debug();
#line 224
  meta1_parser_set_debug();
#line 226
  meta1restart(fp);
#line 227
  rc = meta1parse();
#line 228
  fclose(fp);
  }
#line 229
  if (meta1_error_count) {
#line 230
    rc = 1;
  }
#line 231
  return (rc);
}
}
#line 313 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
int meta1error(char *s ) ;
#line 47 "meta1gram.y"
struct meta1_stmt *meta1_stmt_create(enum meta1_stmt_type type , char const   *ident___0 ) 
{ 
  struct meta1_stmt *p ;
  void *tmp ;

  {
  {
#line 50
  tmp = xmalloc((size_t )sizeof(*p));
#line 50
  p = (struct meta1_stmt *)tmp;
#line 51
  p->next = (struct meta1_stmt *)((void *)0);
#line 52
  p->type = type;
#line 53
  p->ident = ident___0;
#line 54
  p->locus = meta1_locus;
  }
#line 55
  return (p);
}
}
#line 58 "meta1gram.y"
static struct meta1_stmt *_reverse(struct meta1_stmt *list , struct meta1_stmt **root ) 
{ 
  struct meta1_stmt *next ;

  {
#line 63
  if ((unsigned long )list->next == (unsigned long )((void *)0)) {
#line 65
    *root = list;
#line 66
    return (list);
  }
  {
#line 68
  next = _reverse(list->next, root);
#line 69
  next->next = list;
#line 70
  list->next = (struct meta1_stmt *)((void *)0);
  }
#line 71
  return (list);
}
}
#line 74 "meta1gram.y"
static struct meta1_stmt *reverse(struct meta1_stmt *in ) 
{ 
  struct meta1_stmt *root ;

  {
#line 78
  if (! in) {
#line 79
    return (in);
  }
  {
#line 80
  _reverse(in, & root);
  }
#line 81
  return (root);
}
}
#line 84
static void meta1_translate(struct meta1_stmt *stmt ) ;
#line 453 "meta1gram.c"
static yytype_uint8 const   yytranslate[261]  = 
#line 453 "meta1gram.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )6,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )8,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5};
#line 487 "meta1gram.c"
static yytype_uint8 const   yyprhs[25]  = 
#line 487
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )33,      (yytype_uint8 const   )35,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )41,      (yytype_uint8 const   )43,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )55,      (yytype_uint8 const   )57,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62};
#line 495 "meta1gram.c"
static yytype_int8 const   yyrhs[64]  = 
#line 495
  {      (yytype_int8 const   )12,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )13, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )-1,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )-1,      (yytype_int8 const   )15,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )16,      (yytype_int8 const   )-1,      (yytype_int8 const   )18,      (yytype_int8 const   )6, 
        (yytype_int8 const   )19,      (yytype_int8 const   )24,      (yytype_int8 const   )-1,      (yytype_int8 const   )18, 
        (yytype_int8 const   )17,      (yytype_int8 const   )7,      (yytype_int8 const   )13,      (yytype_int8 const   )8, 
        (yytype_int8 const   )24,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )20, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )22,      (yytype_int8 const   )-1,      (yytype_int8 const   )5, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )21, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )21, 
        (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )7,      (yytype_int8 const   )23, 
        (yytype_int8 const   )8,      (yytype_int8 const   )-1,      (yytype_int8 const   )7,      (yytype_int8 const   )23, 
        (yytype_int8 const   )9,      (yytype_int8 const   )8,      (yytype_int8 const   )-1,      (yytype_int8 const   )19, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )23,      (yytype_int8 const   )9,      (yytype_int8 const   )19, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )10,      (yytype_int8 const   )-1};
#line 507 "meta1gram.c"
static yytype_uint8 const   yyrline[25]  = 
#line 507
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )120,      (yytype_uint8 const   )121,      (yytype_uint8 const   )124, 
        (yytype_uint8 const   )131,      (yytype_uint8 const   )138,      (yytype_uint8 const   )139,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )145,      (yytype_uint8 const   )151,      (yytype_uint8 const   )157,      (yytype_uint8 const   )165, 
        (yytype_uint8 const   )166,      (yytype_uint8 const   )179,      (yytype_uint8 const   )188,      (yytype_uint8 const   )195, 
        (yytype_uint8 const   )199,      (yytype_uint8 const   )205,      (yytype_uint8 const   )214,      (yytype_uint8 const   )221, 
        (yytype_uint8 const   )222};
#line 518 "meta1gram.c"
static char const   * const  yytname[26]  = 
#line 518
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"META1_IDENT", 
        (char const   */* const  */)"META1_STRING",      (char const   */* const  */)"META1_NUMBER",      (char const   */* const  */)"\'=\'",      (char const   */* const  */)"\'{\'", 
        (char const   */* const  */)"\'}\'",      (char const   */* const  */)"\',\'",      (char const   */* const  */)"\';\'",      (char const   */* const  */)"$accept", 
        (char const   */* const  */)"input",      (char const   */* const  */)"stmtlist",      (char const   */* const  */)"stmt",      (char const   */* const  */)"simple", 
        (char const   */* const  */)"block",      (char const   */* const  */)"tag",      (char const   */* const  */)"ident",      (char const   */* const  */)"value", 
        (char const   */* const  */)"string",      (char const   */* const  */)"slist",      (char const   */* const  */)"list",      (char const   */* const  */)"values", 
        (char const   */* const  */)"opt_sc",      (char const   */* const  */)0};
#line 538 "meta1gram.c"
static yytype_uint8 const   yyr1[25]  = 
#line 538
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )19,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )24};
#line 546 "meta1gram.c"
static yytype_uint8 const   yyr2[25]  = 
#line 546
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1};
#line 556 "meta1gram.c"
static yytype_uint8 const   yydefact[34]  = 
#line 556
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )10,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )15,      (yytype_uint8 const   )17,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )12,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )0,      (yytype_uint8 const   )21,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )7,      (yytype_uint8 const   )18,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )8};
#line 565 "meta1gram.c"
static yytype_int8 const   yydefgoto[14]  = 
#line 565
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )12,      (yytype_int8 const   )7, 
        (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )23,      (yytype_int8 const   )25};
#line 574 "meta1gram.c"
static yytype_int8 const   yypact[34]  = 
#line 574
  {      (yytype_int8 const   )14,      (yytype_int8 const   )-16,      (yytype_int8 const   )18,      (yytype_int8 const   )14, 
        (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )13, 
        (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )8, 
        (yytype_int8 const   )15,      (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )-16, 
        (yytype_int8 const   )8,      (yytype_int8 const   )10,      (yytype_int8 const   )-16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )-16,      (yytype_int8 const   )14,      (yytype_int8 const   )-16,      (yytype_int8 const   )0, 
        (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )2, 
        (yytype_int8 const   )-16,      (yytype_int8 const   )-1,      (yytype_int8 const   )10,      (yytype_int8 const   )-16, 
        (yytype_int8 const   )-16,      (yytype_int8 const   )-16};
#line 583 "meta1gram.c"
static yytype_int8 const   yypgoto[14]  = 
#line 583
  {      (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )4,      (yytype_int8 const   )-3, 
        (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )-16, 
        (yytype_int8 const   )-15,      (yytype_int8 const   )-16,      (yytype_int8 const   )-16,      (yytype_int8 const   )-16, 
        (yytype_int8 const   )-16,      (yytype_int8 const   )-7};
#line 594 "meta1gram.c"
static yytype_uint8 const   yytable[26]  = 
#line 594
  {      (yytype_uint8 const   )9,      (yytype_uint8 const   )22,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )1,      (yytype_uint8 const   )16,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )32,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )1,      (yytype_uint8 const   )8,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )26,      (yytype_uint8 const   )21,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )27};
#line 601 "meta1gram.c"
static yytype_uint8 const   yycheck[26]  = 
#line 601
  {      (yytype_uint8 const   )3,      (yytype_uint8 const   )16,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )8,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )29,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )21};
#line 610 "meta1gram.c"
static yytype_uint8 const   yystos[34]  = 
#line 610
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )14,      (yytype_uint8 const   )3,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )7,      (yytype_uint8 const   )19,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )24,      (yytype_uint8 const   )4,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )24};
#line 741 "meta1gram.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , YYSTYPE___0 const   * const  yyvaluep ) 
{ 


  {
#line 751
  if (! yyvaluep) {
#line 752
    return;
  }
  {
#line 761
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 762
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 764
  return;
}
}
#line 773 "meta1gram.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , YYSTYPE___0 const   * const  yyvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 783
  if (yytype < 11) {
    {
#line 784
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname[yytype]);
    }
  } else {
    {
#line 786
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname[yytype]);
    }
  }
  {
#line 788
  yy_symbol_value_print(yyoutput, yytype, yyvaluep);
#line 789
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 790
  return;
}
}
#line 799 "meta1gram.c"
static void yy_stack_print(yytype_int16 *bottom , yytype_int16 *top ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 808
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 809
    if (! ((unsigned long )bottom <= (unsigned long )top)) {
#line 809
      goto while_break;
    }
    {
#line 810
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            (int )*bottom);
#line 809
    bottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 811
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 812
  return;
}
}
#line 827 "meta1gram.c"
static void yy_reduce_print(YYSTYPE___0 *yyvsp , int yyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 836
  yynrhs = (int )yyr2[yyrule];
#line 838
  yylno = (unsigned long )yyrline[yyrule];
#line 839
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          yyrule - 1, yylno);
#line 842
  yyi = 0;
  }
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 842
    if (! (yyi < yynrhs)) {
#line 842
      goto while_break;
    }
    {
#line 844
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 845
    yy_symbol_print(stderr, (int )yyrhs[(int const   )yyprhs[yyrule] + (int const   )yyi],
                    (YYSTYPE___0 const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)));
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 842
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return;
}
}
#line 860 "meta1gram.c"
int meta1debug  ;
#line 1105 "meta1gram.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE___0 *yyvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1117
  if (! yymsg) {
#line 1118
    yymsg = "Deleting";
  }
  {
#line 1119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1119
    if (meta1debug) {
      {
#line 1119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 1119
      yy_symbol_print(stderr, yytype, (YYSTYPE___0 const   */* const  */)yyvaluep);
#line 1119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1124
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1127
  return;
}
}
#line 1149 "meta1gram.c"
int meta1char  ;
#line 1152 "meta1gram.c"
YYSTYPE___0 meta1lval  ;
#line 1155 "meta1gram.c"
int meta1nerrs  ;
#line 1176 "meta1gram.c"
int meta1parse(void) 
{ 
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE___0 yyvsa[200] ;
  YYSTYPE___0 *yyvs ;
  YYSTYPE___0 *yyvsp ;
  unsigned int yystacksize ;
  YYSTYPE___0 yyval ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  struct meta1_stmt *stmt ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void const   *p ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp___3 ;
  size_t tmp___4 ;
  _Bool tmp___5 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
#line 1192
  yytoken = 0;
#line 1210
  yyss = yyssa;
#line 1215
  yyvs = yyvsa;
#line 1222
  yystacksize = 200U;
#line 1231
  yylen = 0;
  {
#line 1233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1233
    if (meta1debug) {
      {
#line 1233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1233
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  yystate = 0;
#line 1236
  yyerrstatus = 0;
#line 1237
  meta1nerrs = 0;
#line 1238
  meta1char = -2;
#line 1245
  yyssp = yyss;
#line 1246
  yyvsp = yyvs;
#line 1248
  goto yysetstate;
  yynewstate: 
#line 1256
  yyssp ++;
  yysetstate: 
#line 1259
  *yyssp = (yytype_int16 )yystate;
#line 1261
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1264
    yysize = (unsigned int )((yyssp - yyss) + 1L);
#line 1293
    if (10000U <= yystacksize) {
#line 1294
      goto yyexhaustedlab;
    }
#line 1295
    yystacksize *= 2U;
#line 1296
    if (10000U < yystacksize) {
#line 1297
      yystacksize = 10000U;
    }
    {
#line 1300
    yyss1 = yyss;
#line 1301
    tmp = malloc((size_t )((unsigned long )yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE___0 )) + (sizeof(union yyalloc ) - 1UL)));
#line 1301
    yyptr = (union yyalloc *)tmp;
    }
#line 1303
    if (! yyptr) {
#line 1304
      goto yyexhaustedlab;
    }
    {
#line 1305
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1305
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
#line 1305
      yyss = & yyptr->yyss;
#line 1305
      yynewbytes = (unsigned int )((unsigned long )yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL));
#line 1305
      yyptr += (unsigned long )yynewbytes / sizeof(*yyptr);
      }
#line 1305
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1306
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1306
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
#line 1306
      yyvs = & yyptr->yyvs;
#line 1306
      yynewbytes___0 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL));
#line 1306
      yyptr += (unsigned long )yynewbytes___0 / sizeof(*yyptr);
      }
#line 1306
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1309
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1310
      free((void *)yyss1);
      }
    }
#line 1315
    yyssp = (yyss + yysize) - 1;
#line 1316
    yyvsp = (yyvs + yysize) - 1;
    {
#line 1319
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1319
      if (meta1debug) {
        {
#line 1319
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                (unsigned long )yystacksize);
        }
      }
#line 1319
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1322
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1323
      goto yyabortlab;
    }
  }
  {
#line 1326
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1326
    if (meta1debug) {
      {
#line 1326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              yystate);
      }
    }
#line 1326
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1328
  goto yybackup;
  yybackup: 
#line 1339
  yyn = (int )yypact[yystate];
#line 1340
  if (yyn == -16) {
#line 1341
    goto yydefault;
  }
#line 1346
  if (meta1char == -2) {
    {
#line 1348
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1348
      if (meta1debug) {
        {
#line 1348
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1348
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1349
    meta1char = meta1lex();
    }
  }
#line 1352
  if (meta1char <= 0) {
#line 1354
    yytoken = 0;
#line 1354
    meta1char = yytoken;
    {
#line 1355
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1355
      if (meta1debug) {
        {
#line 1355
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1355
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1359
    if ((unsigned int )meta1char <= 260U) {
#line 1359
      yytoken = (int )yytranslate[meta1char];
    } else {
#line 1359
      yytoken = 2;
    }
    {
#line 1360
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1360
      if (meta1debug) {
        {
#line 1360
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1360
        yy_symbol_print(stderr, yytoken, (YYSTYPE___0 const   */* const  */)(& meta1lval));
#line 1360
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1360
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1365
  yyn += yytoken;
#line 1366
  if (yyn < 0) {
#line 1367
    goto yydefault;
  } else
#line 1366
  if (25 < yyn) {
#line 1367
    goto yydefault;
  } else
#line 1366
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1367
    goto yydefault;
  }
#line 1368
  yyn = (int )yytable[yyn];
#line 1369
  if (yyn <= 0) {
#line 1371
    if (yyn == 0) {
#line 1372
      goto yyerrlab;
    } else
#line 1371
    if (yyn == -1) {
#line 1372
      goto yyerrlab;
    }
#line 1373
    yyn = - yyn;
#line 1374
    goto yyreduce;
  }
#line 1377
  if (yyn == 8) {
#line 1378
    goto yyacceptlab;
  }
#line 1382
  if (yyerrstatus) {
#line 1383
    yyerrstatus --;
  }
  {
#line 1386
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1386
    if (meta1debug) {
      {
#line 1386
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1386
      yy_symbol_print(stderr, yytoken, (YYSTYPE___0 const   */* const  */)(& meta1lval));
#line 1386
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1386
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1389
  if (meta1char != 0) {
#line 1390
    meta1char = -2;
  }
#line 1392
  yystate = yyn;
#line 1393
  yyvsp ++;
#line 1393
  *yyvsp = meta1lval;
#line 1395
  goto yynewstate;
  yydefault: 
#line 1402
  yyn = (int )yydefact[yystate];
#line 1403
  if (yyn == 0) {
#line 1404
    goto yyerrlab;
  }
#line 1405
  goto yyreduce;
  yyreduce: 
#line 1413
  yylen = (int )yyr2[yyn];
#line 1423
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1426
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1426
    if (meta1debug) {
      {
#line 1426
      yy_reduce_print(yyvsp, yyn);
      }
    }
#line 1426
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1429
  if (yyn == 2) {
#line 1429
    goto case_2;
  }
#line 109
  if (yyn == 3) {
#line 109 "meta1gram.y"
    goto case_3;
  }
#line 115
  if (yyn == 4) {
#line 115
    goto case_4;
  }
#line 120
  if (yyn == 7) {
#line 120
    goto case_7;
  }
#line 131
  if (yyn == 8) {
#line 131
    goto case_8;
  }
#line 138
  if (yyn == 12) {
#line 138
    goto case_12;
  }
#line 153
  if (yyn == 13) {
#line 153
    goto case_13;
  }
#line 159
  if (yyn == 14) {
#line 159
    goto case_14;
  }
#line 165
  if (yyn == 16) {
#line 165
    goto case_16;
  }
#line 179
  if (yyn == 17) {
#line 179
    goto case_17;
  }
#line 190
  if (yyn == 18) {
#line 190
    goto case_18;
  }
#line 195
  if (yyn == 19) {
#line 195
    goto case_19;
  }
#line 201
  if (yyn == 20) {
#line 201
    goto case_20;
  }
#line 205
  if (yyn == 21) {
#line 205
    goto case_21;
  }
#line 216
  if (yyn == 22) {
#line 216
    goto case_22;
  }
#line 1567 "meta1gram.c"
  goto switch_default;
  case_2: /* CIL Label */ 
#line 104 "meta1gram.y"
  stmt = (yyvsp + 0)->stmt;
  {
#line 104
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 104
    if (! stmt) {
#line 104
      goto while_break___9;
    }
    {
#line 105
    meta1_translate(stmt);
#line 104
    stmt = stmt->next;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
#line 111
  yyval.stmt = (yyvsp + 0)->stmt;
#line 113
  goto switch_break;
  case_4: /* CIL Label */ 
#line 115
  ((yyvsp + 0)->stmt)->next = (yyvsp + -1)->stmt;
#line 116
  yyval.stmt = (yyvsp + 0)->stmt;
#line 118
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 126
  yyval.stmt = meta1_stmt_create((enum meta1_stmt_type )0, (char const   *)(yyvsp + -3)->string);
#line 127
  (yyval.stmt)->v.value = (yyvsp + -1)->value;
  }
#line 129
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 133
  yyval.stmt = meta1_stmt_create((enum meta1_stmt_type )1, (char const   *)(yyvsp + -5)->string);
#line 134
  (yyval.stmt)->v.list = reverse((yyvsp + -2)->stmt);
  }
#line 136
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 147
  tmp___0 = xmalloc((size_t )sizeof(*(yyval.value)));
#line 147
  yyval.value = (grecs_value_t *)tmp___0;
#line 148
  (yyval.value)->type = 0;
#line 149
  (yyval.value)->v.string = (char const   *)(yyvsp + 0)->string;
  }
#line 151
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 153
  tmp___1 = xmalloc((size_t )sizeof(*(yyval.value)));
#line 153
  yyval.value = (grecs_value_t *)tmp___1;
#line 154
  (yyval.value)->type = 1;
#line 155
  (yyval.value)->v.list = (yyvsp + 0)->list;
  }
#line 157
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 159
  tmp___2 = xmalloc((size_t )sizeof(*(yyval.value)));
#line 159
  yyval.value = (grecs_value_t *)tmp___2;
#line 160
  (yyval.value)->type = 0;
#line 161
  (yyval.value)->v.string = (char const   *)(yyvsp + 0)->string;
  }
#line 163
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 169
  tmp___3 = gl_list_iterator_inline((yyvsp + 0)->list);
#line 169
  itr = tmp___3;
#line 171
  meta1_line_begin();
  }
  {
#line 172
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 172
    tmp___5 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
    }
#line 172
    if (! tmp___5) {
#line 172
      goto while_break___10;
    }
    {
#line 173
    tmp___4 = strlen((char const   *)p);
#line 173
    meta1_line_add((char const   *)p, tmp___4);
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 174
  gl_list_iterator_free_inline(& itr);
#line 175
  yyval.string = meta1_line_finish();
  }
#line 177
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 181
  yyval.list = gl_list_create_empty_inline(& gl_linked_list_implementation, (_Bool (*)(void const   *elt1 ,
                                                                                       void const   *elt2 ))((void *)0),
                                           (size_t (*)(void const   *elt ))((void *)0),
                                           (void (*)(void const   *elt ))((void *)0),
                                           (_Bool)1);
#line 186
  gl_list_add_last_inline(yyval.list, (void const   *)(yyvsp + 0)->string);
  }
#line 188
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 190
  gl_list_add_last_inline((yyvsp + -1)->list, (void const   *)(yyvsp + 0)->string);
#line 191
  yyval.list = (yyvsp + -1)->list;
  }
#line 193
  goto switch_break;
  case_19: /* CIL Label */ 
#line 197
  yyval.list = (yyvsp + -1)->list;
#line 199
  goto switch_break;
  case_20: /* CIL Label */ 
#line 201
  yyval.list = (yyvsp + -2)->list;
#line 203
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 207
  yyval.list = gl_list_create_empty_inline(& gl_linked_list_implementation, (_Bool (*)(void const   *elt1 ,
                                                                                       void const   *elt2 ))((void *)0),
                                           (size_t (*)(void const   *elt ))((void *)0),
                                           (void (*)(void const   *elt ))((void *)0),
                                           (_Bool)1);
#line 212
  gl_list_add_last_inline(yyval.list, (void const   *)(yyvsp + 0)->value);
  }
#line 214
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 216
  gl_list_add_last_inline((yyvsp + -2)->list, (void const   *)(yyvsp + 0)->value);
#line 217
  yyval.list = (yyvsp + -2)->list;
  }
#line 219
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1567 "meta1gram.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1569
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1569
    if (meta1debug) {
      {
#line 1569
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 1569
      yy_symbol_print(stderr, (int )yyr1[yyn], (YYSTYPE___0 const   */* const  */)(& yyval));
#line 1569
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1569
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1571
  yyvsp -= yylen;
#line 1571
  yyssp -= yylen;
#line 1572
  yylen = 0;
  {
#line 1573
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1573
    if (meta1debug) {
      {
#line 1573
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1573
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1575
  yyvsp ++;
#line 1575
  *yyvsp = yyval;
#line 1582
  yyn = (int )yyr1[yyn];
#line 1584
  yystate = (int )((int const   )yypgoto[yyn - 11] + (int const   )*yyssp);
#line 1585
  if (0 <= yystate) {
#line 1585
    if (yystate <= 25) {
#line 1585
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1586
        yystate = (int )yytable[yystate];
      } else {
#line 1588
        yystate = (int )yydefgoto[yyn - 11];
      }
    } else {
#line 1588
      yystate = (int )yydefgoto[yyn - 11];
    }
  } else {
#line 1588
    yystate = (int )yydefgoto[yyn - 11];
  }
#line 1590
  goto yynewstate;
  yyerrlab: 
#line 1598
  if (! yyerrstatus) {
    {
#line 1600
    meta1nerrs ++;
#line 1602
    meta1error((char *)"syntax error");
    }
  }
#line 1640
  if (yyerrstatus == 3) {
#line 1645
    if (meta1char <= 0) {
#line 1648
      if (meta1char == 0) {
#line 1649
        goto yyabortlab;
      }
    } else {
      {
#line 1653
      yydestruct("Error: discarding", yytoken, & meta1lval);
#line 1655
      meta1char = -2;
      }
    }
  }
#line 1661
  goto yyerrlab1;
#line 1677
  yyvsp -= yylen;
#line 1677
  yyssp -= yylen;
#line 1678
  yylen = 0;
  {
#line 1679
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1679
    if (meta1debug) {
      {
#line 1679
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1679
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 1680
  yystate = (int )*yyssp;
#line 1681
  goto yyerrlab1;
  yyerrlab1: 
#line 1688
  yyerrstatus = 3;
  {
#line 1690
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 1692
    yyn = (int )yypact[yystate];
#line 1693
    if (yyn != -16) {
#line 1695
      yyn ++;
#line 1696
      if (0 <= yyn) {
#line 1696
        if (yyn <= 25) {
#line 1696
          if ((int const   )yycheck[yyn] == 1) {
#line 1698
            yyn = (int )yytable[yyn];
#line 1699
            if (0 < yyn) {
#line 1700
              goto while_break___14;
            }
          }
        }
      }
    }
#line 1705
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1706
      goto yyabortlab;
    }
    {
#line 1709
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 1711
    yyvsp --;
#line 1711
    yyssp --;
#line 1712
    yystate = (int )*yyssp;
    }
    {
#line 1713
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1713
      if (meta1debug) {
        {
#line 1713
        yy_stack_print(yyss, yyssp);
        }
      }
#line 1713
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 1716
  if (yyn == 8) {
#line 1717
    goto yyacceptlab;
  }
#line 1719
  yyvsp ++;
#line 1719
  *yyvsp = meta1lval;
  {
#line 1723
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1723
    if (meta1debug) {
      {
#line 1723
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1723
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE___0 const   */* const  */)yyvsp);
#line 1723
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1723
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1725
  yystate = yyn;
#line 1726
  goto yynewstate;
  yyacceptlab: 
#line 1733
  yyresult = 0;
#line 1734
  goto yyreturn;
  yyabortlab: 
#line 1740
  yyresult = 1;
#line 1741
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 1748
  meta1error((char *)"memory exhausted");
#line 1749
  yyresult = 2;
  }
  yyreturn: 
#line 1754
  if (meta1char != 0) {
#line 1754
    if (meta1char != -2) {
      {
#line 1755
      yydestruct("Cleanup: discarding lookahead", yytoken, & meta1lval);
      }
    }
  }
#line 1759
  yyvsp -= yylen;
#line 1759
  yyssp -= yylen;
  {
#line 1760
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 1760
    if (meta1debug) {
      {
#line 1760
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1760
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 1761
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 1761
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 1761
      goto while_break___18;
    }
    {
#line 1763
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 1765
    yyvsp --;
#line 1765
    yyssp --;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 1768
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 1769
    free((void *)yyss);
    }
  }
#line 1776
  return (yyresult);
}
}
#line 226 "meta1gram.y"
int meta1error(char *s ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 229
  meta1_parse_error("%s", s);
  }
#line 230
  return (0);
}
}
#line 233 "meta1gram.y"
void meta1_parser_set_debug(void) 
{ 
  char *p ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 236
  tmp = getenv("META1_DEBUG_YACC");
#line 236
  p = tmp;
  }
#line 237
  if (p) {
#line 237
    if ((int )*p - 48 > 0) {
#line 237
      tmp___0 = 1;
    } else {
#line 237
      tmp___0 = 0;
    }
  } else {
#line 237
    tmp___0 = 0;
  }
#line 237
  meta1debug = tmp___0;
#line 238
  return;
}
}
#line 240 "meta1gram.y"
static struct meta1_stmt *find_stmt(struct meta1_stmt *stmt , char const   *ident___0 ) 
{ 
  int tmp ;

  {
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! stmt) {
#line 243
      goto while_break;
    }
    {
#line 244
    tmp = strcmp(stmt->ident, ident___0);
    }
#line 244
    if (tmp == 0) {
#line 245
      goto while_break;
    }
#line 243
    stmt = stmt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return (stmt);
}
}
#line 257 "meta1gram.y"
static struct node_trans *find_node_trans(struct node_trans *tab___0 , char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! tab___0->name) {
#line 260
      goto while_break;
    }
    {
#line 261
    tmp = strcmp((char const   *)tab___0->name, name);
    }
#line 261
    if (tmp == 0) {
#line 262
      return (tab___0);
    }
#line 260
    tab___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return ((struct node_trans *)((void *)0));
}
}
#line 266 "meta1gram.y"
static int xlat_listen_socket(struct meta1_stmt *stmt , struct component *comp ) 
{ 
  struct meta1_stmt *p ;
  grecs_value_t *val ;
  size_t tmp ;
  char const   *addr ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 272
  p = find_stmt(stmt->v.list, "type");
  }
#line 273
  if (! p) {
#line 274
    return (1);
  } else
#line 273
  if (! p->v.value) {
#line 274
    return (1);
  } else
#line 273
  if ((p->v.value)->type != 0) {
#line 274
    return (1);
  }
  {
#line 275
  meta1_line_begin();
#line 276
  tmp = strlen((p->v.value)->v.string);
#line 276
  meta1_line_add((p->v.value)->v.string, tmp);
#line 277
  meta1_line_add("://", (size_t )3);
#line 278
  tmp___7 = strcmp((p->v.value)->v.string, "inet");
  }
#line 278
  if (tmp___7 == 0) {
    {
#line 281
    p = find_stmt(stmt->v.list, "address");
    }
#line 282
    if (p) {
#line 284
      if ((p->v.value)->type != 0) {
#line 285
        return (1);
      }
#line 286
      addr = (p->v.value)->v.string;
    } else {
#line 289
      addr = "0.0.0.0";
    }
    {
#line 290
    tmp___0 = strlen(addr);
#line 290
    meta1_line_add(addr, tmp___0);
#line 291
    meta1_line_add(":", (size_t )1);
#line 292
    p = find_stmt(stmt->v.list, "port");
    }
#line 293
    if ((p->v.value)->type != 0) {
#line 294
      return (1);
    }
    {
#line 295
    tmp___1 = strlen((p->v.value)->v.string);
#line 295
    meta1_line_add((p->v.value)->v.string, tmp___1);
    }
  } else {
    {
#line 297
    tmp___6 = strcmp((p->v.value)->v.string, "unix");
    }
#line 297
    if (tmp___6 == 0) {
      {
#line 307
      p = find_stmt(stmt->v.list, "path");
      }
#line 308
      if (! p) {
#line 309
        return (1);
      } else
#line 308
      if ((p->v.value)->type != 0) {
#line 309
        return (1);
      }
      {
#line 310
      tmp___2 = strlen((p->v.value)->v.string);
#line 310
      meta1_line_add((p->v.value)->v.string, tmp___2);
#line 312
      p = find_stmt(stmt->v.list, "user");
      }
#line 313
      if (p) {
#line 313
        if ((p->v.value)->type == 0) {
          {
#line 315
          meta1_line_add(";user=", (size_t )6);
#line 316
          tmp___3 = strlen((p->v.value)->v.string);
#line 316
          meta1_line_add((p->v.value)->v.string, tmp___3);
          }
        }
      }
      {
#line 319
      p = find_stmt(stmt->v.list, "group");
      }
#line 320
      if (p) {
#line 320
        if ((p->v.value)->type == 0) {
          {
#line 322
          meta1_line_add(";group=", (size_t )7);
#line 323
          tmp___4 = strlen((p->v.value)->v.string);
#line 323
          meta1_line_add((p->v.value)->v.string, tmp___4);
          }
        }
      }
      {
#line 326
      p = find_stmt(stmt->v.list, "umask");
      }
#line 327
      if (p) {
#line 327
        if ((p->v.value)->type == 0) {
          {
#line 329
          meta1_line_add(";umask=", (size_t )7);
#line 330
          tmp___5 = strlen((p->v.value)->v.string);
#line 330
          meta1_line_add((p->v.value)->v.string, tmp___5);
          }
        }
      }
    }
  }
  {
#line 333
  tmp___8 = xmalloc((size_t )sizeof(*val));
#line 333
  val = (grecs_value_t *)tmp___8;
#line 334
  val->type = 0;
#line 335
  tmp___9 = meta1_line_finish();
#line 335
  val->v.string = (char const   *)tmp___9;
#line 336
  stmt->type = (enum meta1_stmt_type )0;
#line 337
  stmt->v.value = val;
  }
#line 338
  return (0);
}
}
#line 342 "meta1gram.y"
static struct node_trans root_node_trans[8]  = 
#line 342
  {      {(char *)"listen_socket", (char *)"socket", & xlat_listen_socket}, 
        {(char *)"start_action", (char *)"mode", (int (*)(struct meta1_stmt *stmt , struct component *comp ))0}, 
        {(char *)"pass_fd_socket",
      (char *)"pass-fd-socket", (int (*)(struct meta1_stmt *stmt , struct component *comp ))0}, 
        {(char *)"user",
      (char *)"user", (int (*)(struct meta1_stmt *stmt , struct component *comp ))0}, 
        {(char *)"path",
      (char *)"program", (int (*)(struct meta1_stmt *stmt , struct component *comp ))0}, 
        {(char *)"arguments",
      (char *)"command", (int (*)(struct meta1_stmt *stmt , struct component *comp ))0}, 
        {(char *)"restart_dependencies",
      (char *)"dependents", (int (*)(struct meta1_stmt *stmt , struct component *comp ))0}, 
        {(char *)((void *)0),
      (char *)0, (int (*)(struct meta1_stmt *stmt , struct component *comp ))0}};
#line 353 "meta1gram.y"
static void meta1_translate_stmt(struct meta1_stmt *stmt , struct component *comp ) 
{ 
  struct grecs_keyword *kwp ;
  struct node_trans *nt ;
  struct node_trans *tmp ;
  int tmp___0 ;

  {
  {
#line 358
  tmp = find_node_trans(root_node_trans, stmt->ident);
#line 358
  nt = tmp;
  }
#line 359
  if (! nt) {
#line 360
    return;
  }
  {
#line 362
  kwp = find_component_keyword((char const   *)nt->new_name);
  }
#line 363
  if (! kwp) {
    {
#line 364
    abort();
    }
  }
#line 366
  if (nt->xlat) {
    {
#line 366
    tmp___0 = (*(nt->xlat))(stmt, comp);
    }
#line 366
    if (tmp___0) {
#line 367
      return;
    }
  }
  {
#line 369
  grecs_process_ident(kwp, stmt->v.value, (void *)comp, & stmt->locus);
  }
#line 370
  return;
}
}
#line 372 "meta1gram.y"
static void meta1_translate(struct meta1_stmt *stmt ) 
{ 
  struct component *comp ;
  struct meta1_stmt *p ;
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 378
  if ((unsigned int )stmt->type != 1U) {
#line 379
    return;
  }
  {
#line 381
  comp = component_create(stmt->ident);
#line 382
  p = stmt->v.list;
  }
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! p) {
#line 382
      goto while_break;
    }
    {
#line 384
    meta1_translate_stmt(p, comp);
#line 382
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 386
  comp->privs.allgroups = 1;
#line 387
  if (meta1_queue_dir) {
#line 387
    comp->dir = meta1_queue_dir;
  } else {
#line 387
    comp->dir = (char *)"/var/spool/meta1";
  }
#line 388
  comp->redir[1].type = (enum redir_type )2;
#line 389
  if (meta1_queue_dir) {
#line 389
    tmp = (char const   *)meta1_queue_dir;
  } else {
#line 389
    tmp = "/var/spool/meta1";
  }
  {
#line 389
  comp->redir[1].v.file = xasprintf("%s/%s.log", tmp, comp->tag);
#line 392
  component_finish(comp, & stmt->locus);
  }
#line 393
  return;
}
}
#line 195 "../gnu/obstack.h"
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 358 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
void meta_free(struct metadef *def ) ;
#line 20 "/home/ysko/Works/test-src/pies-1.2/src/meta.c"
static char const   *meta_expand(struct metadef *def , void *data ) 
{ 
  char const   *tmp ;
  char *__cil_tmp4 ;

  {
#line 23
  if (! def->value) {
#line 25
    if (def->expand) {
      {
#line 26
      tmp = (*(def->expand))(def, data);
      }
#line 26
      return (tmp);
    }
#line 27
    def->value = (char *)"INTERNAL ERROR: NONEXPANDABLE DATA";
  }
#line 29
  return ((char const   *)def->value);
}
}
#line 32 "/home/ysko/Works/test-src/pies-1.2/src/meta.c"
static char const   *find_expansion_char(int c , struct metadef *def , void *data ) 
{ 
  char const   *tmp ;

  {
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! def->kw) {
#line 35
      goto while_break;
    }
#line 36
    if ((int )*(def->kw + 1) == 0) {
#line 36
      if ((int )*(def->kw + 0) == c) {
        {
#line 37
        tmp = meta_expand(def, data);
        }
#line 37
        return (tmp);
      }
    }
#line 35
    def ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return ((char const   *)((void *)0));
}
}
#line 41 "/home/ysko/Works/test-src/pies-1.2/src/meta.c"
static char const   *find_expansion_word(char const   *kw , size_t len , struct metadef *def ,
                                         void *data ) 
{ 
  char const   *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! def->kw) {
#line 45
      goto while_break;
    }
    {
#line 46
    tmp___0 = strlen((char const   *)def->kw);
    }
#line 46
    if (tmp___0 == len) {
      {
#line 46
      tmp___1 = memcmp((void const   *)def->kw, (void const   *)kw, len);
      }
#line 46
      if (tmp___1 == 0) {
        {
#line 47
        tmp = meta_expand(def, data);
        }
#line 47
        return (tmp);
      }
    }
#line 45
    def ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return ((char const   *)((void *)0));
}
}
#line 51 "/home/ysko/Works/test-src/pies-1.2/src/meta.c"
char *meta_expand_string(char const   *string , struct metadef *def , void *data ) 
{ 
  char const   *p ;
  char const   *s ;
  char *res ;
  struct obstack stk___0 ;
  char *e ;
  size_t len ;
  size_t tmp ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o___1 ;
  int __len___1 ;
  size_t tmp___0 ;
  struct obstack *__o___2 ;
  int __len___2 ;
  struct obstack *__o___3 ;
  int __len___3 ;
  struct obstack *__o___4 ;
  int __len___4 ;
  struct obstack *__o___5 ;
  char *tmp___1 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct obstack *__o___6 ;
  void *__obj ;
  char *tmp___4 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 58
  if (! string) {
#line 59
    return ((char *)((void *)0));
  }
  {
#line 61
  _obstack_begin(& stk___0, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 63
  p = string;
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! *p) {
#line 63
      goto while_break;
    }
    {
#line 66
    tmp = strcspn(p, "$");
#line 66
    len = tmp;
#line 68
    __o = & stk___0;
#line 68
    __len = (int )len;
    }
#line 68
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 68
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 68
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)p,
           (size_t )__len);
#line 68
    __o->next_free += __len;
#line 69
    p += len;
    }
#line 70
    if ((int const   )*p == 36) {
#line 72
      p ++;
      {
#line 74
      if ((int const   )*p == 36) {
#line 74
        goto case_36;
      }
#line 79
      if ((int const   )*p == 123) {
#line 79
        goto case_123;
      }
#line 93
      goto switch_default;
      case_36: /* CIL Label */ 
#line 75
      __o___0 = & stk___0;
#line 75
      __len___0 = 1;
#line 75
      if ((unsigned long )(__o___0->next_free + __len___0) > (unsigned long )__o___0->chunk_limit) {
        {
#line 75
        _obstack_newchunk(__o___0, __len___0);
        }
      }
      {
#line 75
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)p,
             (size_t )__len___0);
#line 75
      __o___0->next_free += __len___0;
#line 76
      p ++;
      }
#line 77
      goto switch_break;
      case_123: /* CIL Label */ 
      {
#line 80
      e = strchr(p + 1, '}');
      }
#line 81
      if (e) {
        {
#line 81
        s = find_expansion_word(p + 1, (size_t )((e - (char *)p) - 1L), def, data);
        }
#line 81
        if (s) {
          {
#line 83
          __o___1 = & stk___0;
#line 83
          tmp___0 = strlen(s);
#line 83
          __len___1 = (int )tmp___0;
          }
#line 83
          if ((unsigned long )(__o___1->next_free + __len___1) > (unsigned long )__o___1->chunk_limit) {
            {
#line 83
            _obstack_newchunk(__o___1, __len___1);
            }
          }
          {
#line 83
          memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)s,
                 (size_t )__len___1);
#line 83
          __o___1->next_free += __len___1;
#line 84
          p = (char const   *)(e + 1);
          }
        } else {
#line 81
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 88
        __o___2 = & stk___0;
#line 88
        __len___2 = 2;
#line 88
        if ((unsigned long )(__o___2->next_free + __len___2) > (unsigned long )__o___2->chunk_limit) {
          {
#line 88
          _obstack_newchunk(__o___2, __len___2);
          }
        }
        {
#line 88
        memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)(p - 1),
               (size_t )__len___2);
#line 88
        __o___2->next_free += __len___2;
#line 89
        p ++;
        }
      }
#line 91
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 94
      s = find_expansion_char((int )*p, def, data);
      }
#line 94
      if ((unsigned long )s != (unsigned long )((void *)0)) {
        {
#line 95
        len = strlen(s);
        }
      } else {
#line 98
        s = p - 1;
#line 99
        len = (size_t )1;
      }
#line 102
      __o___3 = & stk___0;
#line 102
      __len___3 = (int )len;
#line 102
      if ((unsigned long )(__o___3->next_free + __len___3) > (unsigned long )__o___3->chunk_limit) {
        {
#line 102
        _obstack_newchunk(__o___3, __len___3);
        }
      }
      {
#line 102
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)s,
             (size_t )__len___3);
#line 102
      __o___3->next_free += __len___3;
#line 103
      p ++;
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 107
      __o___4 = & stk___0;
#line 107
      __len___4 = 1;
#line 107
      if ((unsigned long )(__o___4->next_free + __len___4) > (unsigned long )__o___4->chunk_limit) {
        {
#line 107
        _obstack_newchunk(__o___4, __len___4);
        }
      }
      {
#line 107
      memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)p,
             (size_t )__len___4);
#line 107
      __o___4->next_free += __len___4;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  __o___5 = & stk___0;
#line 109
  if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
    {
#line 109
    _obstack_newchunk(__o___5, 1);
    }
  }
#line 109
  tmp___1 = __o___5->next_free;
#line 109
  (__o___5->next_free) ++;
#line 109
  *tmp___1 = (char)0;
#line 110
  __o1 = & stk___0;
#line 110
  __value = (void *)__o1->object_base;
#line 110
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 110
    __o1->maybe_empty_object = 1U;
  }
#line 110
  if (sizeof(int ) < sizeof(void *)) {
#line 110
    tmp___2 = __o1->object_base;
  } else {
#line 110
    tmp___2 = (char *)0;
  }
#line 110
  if (sizeof(int ) < sizeof(void *)) {
#line 110
    tmp___3 = __o1->object_base;
  } else {
#line 110
    tmp___3 = (char *)0;
  }
#line 110
  __o1->next_free = tmp___2 + (((__o1->next_free - tmp___3) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 110
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 110
    __o1->next_free = __o1->chunk_limit;
  }
  {
#line 110
  __o1->object_base = __o1->next_free;
#line 110
  res = xstrdup((char const   *)__value);
#line 111
  __o___6 = & stk___0;
#line 111
  __obj = (void *)0;
  }
#line 111
  if ((unsigned long )__obj > (unsigned long )((void *)__o___6->chunk)) {
#line 111
    if ((unsigned long )__obj < (unsigned long )((void *)__o___6->chunk_limit)) {
#line 111
      tmp___4 = (char *)__obj;
#line 111
      __o___6->object_base = tmp___4;
#line 111
      __o___6->next_free = tmp___4;
    } else {
      {
#line 111
      obstack_free(__o___6, __obj);
      }
    }
  } else {
    {
#line 111
    obstack_free(__o___6, __obj);
    }
  }
#line 112
  return (res);
}
}
#line 115 "/home/ysko/Works/test-src/pies-1.2/src/meta.c"
void meta_free(struct metadef *def ) 
{ 
  char *tmp ;

  {
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! def->kw) {
#line 118
      goto while_break;
    }
#line 120
    if (def->storage) {
      {
#line 122
      free((void *)def->storage);
#line 123
      tmp = (char *)((void *)0);
#line 123
      def->storage = tmp;
#line 123
      def->value = tmp;
      }
    }
#line 118
    def ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 70 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
#line 98
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 48 "/home/ysko/Works/test-src/pies-1.2/src/limits.c"
int do_set_limit(int rlimit , rlim_t limit ) 
{ 
  struct rlimit rlim ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (debug_level >= 1U) {
#line 53
      if (source_info_option) {
        {
#line 53
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/limits.c",
                      53, "do_set_limit");
        }
      }
      {
#line 53
      debug_msg("setting limit %d to %lu", rlimit, limit);
      }
    }
#line 53
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  rlim.rlim_cur = limit;
#line 55
  rlim.rlim_max = limit;
#line 57
  tmp___2 = setrlimit((__rlimit_resource_t )rlimit, (struct rlimit  const  *)(& rlim));
  }
#line 57
  if (tmp___2) {
    {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    tmp___1 = gettext("error setting limit: %s");
#line 59
    logmsg(5, (char const   *)tmp___1, tmp___0);
    }
#line 61
    return (1);
  }
#line 63
  return (0);
}
}
#line 66 "/home/ysko/Works/test-src/pies-1.2/src/limits.c"
static int set_prio(int prio ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (debug_level >= 2U) {
#line 69
      if (source_info_option) {
        {
#line 69
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/limits.c",
                      69, "set_prio");
        }
      }
      {
#line 69
      debug_msg("Setting priority to %d", prio);
      }
    }
#line 69
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  tmp___2 = setpriority((__priority_which_t )0, (id_t )0, prio);
  }
#line 70
  if (tmp___2) {
    {
#line 72
    tmp = __errno_location();
#line 72
    tmp___0 = strerror(*tmp);
#line 72
    tmp___1 = gettext("error setting priority: %s");
#line 72
    logmsg(5, (char const   *)tmp___1, tmp___0);
    }
#line 74
    return (1);
  }
#line 76
  return (0);
}
}
#line 80 "/home/ysko/Works/test-src/pies-1.2/src/limits.c"
static int check_logins(char const   *name , int limit ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 83
  tmp = gettext("L limit is not implemented");
#line 83
  logmsg(5, (char const   *)tmp);
  }
#line 84
  return (0);
}
}
#line 87 "/home/ysko/Works/test-src/pies-1.2/src/limits.c"
int set_limits(char const   *name , struct limits_rec *lrec ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 90
  rc = 0;
#line 92
  if (! lrec) {
#line 93
    return (0);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (debug_level >= 2U) {
#line 95
      if (source_info_option) {
        {
#line 95
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/limits.c",
                      95, "set_limits");
        }
      }
      {
#line 95
      debug_msg("setting limits for %s", name);
      }
    }
#line 95
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (lrec->set & 1U) {
    {
#line 99
    tmp = do_set_limit(9, lrec->limit_as);
#line 99
    rc |= tmp;
    }
  }
#line 102
  if (lrec->set & 2U) {
    {
#line 103
    tmp___0 = do_set_limit(0, lrec->limit_cpu);
#line 103
    rc |= tmp___0;
    }
  }
#line 106
  if (lrec->set & 4U) {
    {
#line 107
    tmp___1 = do_set_limit(2, lrec->limit_data);
#line 107
    rc |= tmp___1;
    }
  }
#line 110
  if (lrec->set & 8U) {
    {
#line 111
    tmp___2 = do_set_limit(1, lrec->limit_fsize);
#line 111
    rc |= tmp___2;
    }
  }
#line 114
  if (lrec->set & 16U) {
    {
#line 115
    tmp___3 = do_set_limit(6, lrec->limit_nproc);
#line 115
    rc |= tmp___3;
    }
  }
#line 118
  if (lrec->set & 32U) {
    {
#line 119
    tmp___4 = do_set_limit(4, lrec->limit_core);
#line 119
    rc |= tmp___4;
    }
  }
#line 122
  if (lrec->set & 64U) {
    {
#line 123
    tmp___5 = do_set_limit(8, lrec->limit_memlock);
#line 123
    rc |= tmp___5;
    }
  }
#line 126
  if (lrec->set & 128U) {
    {
#line 127
    tmp___6 = do_set_limit(7, lrec->limit_nofile);
#line 127
    rc |= tmp___6;
    }
  }
#line 130
  if (lrec->set & 256U) {
    {
#line 131
    tmp___7 = do_set_limit(5, lrec->limit_rss);
#line 131
    rc |= tmp___7;
    }
  }
#line 134
  if (lrec->set & 512U) {
    {
#line 135
    tmp___8 = do_set_limit(3, lrec->limit_stack);
#line 135
    rc |= tmp___8;
    }
  }
#line 137
  if (lrec->set & 1024U) {
    {
#line 138
    tmp___9 = check_logins(name, lrec->limit_logins);
#line 138
    rc |= tmp___9;
    }
  }
#line 139
  if (lrec->set & 2048U) {
    {
#line 140
    tmp___10 = set_prio(lrec->limit_logins);
#line 140
    rc |= tmp___10;
    }
  }
#line 141
  return (rc);
}
}
#line 144 "/home/ysko/Works/test-src/pies-1.2/src/limits.c"
int getlimit(char **ptr , rlim_t *rlim , int mul ) 
{ 
  unsigned long val ;

  {
#line 147
  if ((int )*(*ptr) == 45) {
#line 149
    *rlim = ~ 0UL;
#line 150
    (*ptr) ++;
  } else {
    {
#line 156
    val = strtoul((char const   */* __restrict  */)*ptr, (char **/* __restrict  */)ptr,
                  10);
    }
#line 157
    if (val == 0UL) {
#line 158
      return (1);
    }
#line 159
    *rlim = val * (unsigned long )mul;
  }
#line 161
  return (0);
}
}
#line 192 "/home/ysko/Works/test-src/pies-1.2/src/limits.c"
int parse_limits(limits_record_t *plrec , char *str , char **endp ) 
{ 
  int c ;
  struct limits_rec *lrec ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 196
  tmp = xmalloc((size_t )sizeof(*lrec));
#line 196
  lrec = (struct limits_rec *)tmp;
#line 197
  *plrec = lrec;
#line 198
  lrec->set = 0U;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    tmp___12 = str;
#line 199
    str ++;
#line 199
    c = (int )*tmp___12;
#line 199
    if (! c) {
#line 199
      goto while_break;
    }
#line 201
    if (c == 32) {
#line 202
      goto while_continue;
    } else
#line 201
    if (c == 9) {
#line 202
      goto while_continue;
    }
    {
#line 206
    if (c == 65) {
#line 206
      goto case_65;
    }
#line 206
    if (c == 97) {
#line 206
      goto case_65;
    }
#line 213
    if (c == 84) {
#line 213
      goto case_84;
    }
#line 213
    if (c == 116) {
#line 213
      goto case_84;
    }
#line 220
    if (c == 68) {
#line 220
      goto case_68;
    }
#line 220
    if (c == 100) {
#line 220
      goto case_68;
    }
#line 227
    if (c == 70) {
#line 227
      goto case_70;
    }
#line 227
    if (c == 102) {
#line 227
      goto case_70;
    }
#line 234
    if (c == 85) {
#line 234
      goto case_85;
    }
#line 234
    if (c == 117) {
#line 234
      goto case_85;
    }
#line 241
    if (c == 67) {
#line 241
      goto case_67;
    }
#line 241
    if (c == 99) {
#line 241
      goto case_67;
    }
#line 248
    if (c == 77) {
#line 248
      goto case_77;
    }
#line 248
    if (c == 109) {
#line 248
      goto case_77;
    }
#line 257
    if (c == 78) {
#line 257
      goto case_78;
    }
#line 257
    if (c == 110) {
#line 257
      goto case_78;
    }
#line 264
    if (c == 82) {
#line 264
      goto case_82;
    }
#line 264
    if (c == 114) {
#line 264
      goto case_82;
    }
#line 271
    if (c == 83) {
#line 271
      goto case_83;
    }
#line 271
    if (c == 115) {
#line 271
      goto case_83;
    }
#line 278
    if (c == 76) {
#line 278
      goto case_76;
    }
#line 278
    if (c == 108) {
#line 278
      goto case_76;
    }
#line 285
    if (c == 80) {
#line 285
      goto case_80;
    }
#line 285
    if (c == 112) {
#line 285
      goto case_80;
    }
#line 291
    goto switch_default;
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
    {
#line 208
    tmp___0 = getlimit(& str, & lrec->limit_as, 1024);
    }
#line 208
    if (! tmp___0) {
#line 209
      lrec->set |= 1U;
    }
#line 210
    goto switch_break;
    case_84: /* CIL Label */ 
    case_116: /* CIL Label */ 
    {
#line 215
    tmp___1 = getlimit(& str, & lrec->limit_cpu, 60);
    }
#line 215
    if (! tmp___1) {
#line 216
      lrec->set |= 2U;
    }
#line 217
    goto switch_break;
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
    {
#line 222
    tmp___2 = getlimit(& str, & lrec->limit_data, 1024);
    }
#line 222
    if (! tmp___2) {
#line 223
      lrec->set |= 4U;
    }
#line 224
    goto switch_break;
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
    {
#line 229
    tmp___3 = getlimit(& str, & lrec->limit_fsize, 1024);
    }
#line 229
    if (! tmp___3) {
#line 230
      lrec->set |= 8U;
    }
#line 231
    goto switch_break;
    case_85: /* CIL Label */ 
    case_117: /* CIL Label */ 
    {
#line 236
    tmp___4 = getlimit(& str, & lrec->limit_nproc, 1);
    }
#line 236
    if (! tmp___4) {
#line 237
      lrec->set |= 16U;
    }
#line 238
    goto switch_break;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
    {
#line 243
    tmp___5 = getlimit(& str, & lrec->limit_core, 1024);
    }
#line 243
    if (! tmp___5) {
#line 244
      lrec->set |= 32U;
    }
#line 245
    goto switch_break;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
    {
#line 252
    tmp___6 = getlimit(& str, & lrec->limit_memlock, 1024);
    }
#line 252
    if (! tmp___6) {
#line 253
      lrec->set |= 64U;
    }
#line 254
    goto switch_break;
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
    {
#line 259
    tmp___7 = getlimit(& str, & lrec->limit_nofile, 1);
    }
#line 259
    if (! tmp___7) {
#line 260
      lrec->set |= 128U;
    }
#line 261
    goto switch_break;
    case_82: /* CIL Label */ 
    case_114: /* CIL Label */ 
    {
#line 266
    tmp___8 = getlimit(& str, & lrec->limit_rss, 1024);
    }
#line 266
    if (! tmp___8) {
#line 267
      lrec->set |= 256U;
    }
#line 268
    goto switch_break;
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
    {
#line 273
    tmp___9 = getlimit(& str, & lrec->limit_stack, 1024);
    }
#line 273
    if (! tmp___9) {
#line 274
      lrec->set |= 512U;
    }
#line 275
    goto switch_break;
    case_76: /* CIL Label */ 
    case_108: /* CIL Label */ 
    {
#line 279
    tmp___10 = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& str),
                      10);
#line 279
    lrec->limit_logins = (int )tmp___10;
    }
#line 280
    if (lrec->limit_logins >= 0) {
#line 281
      lrec->set |= 1024U;
    }
#line 282
    goto switch_break;
    case_80: /* CIL Label */ 
    case_112: /* CIL Label */ 
    {
#line 286
    tmp___11 = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& str),
                      10);
#line 286
    lrec->limit_prio = (int )tmp___11;
    }
#line 287
    if (lrec->limit_prio > 0) {
#line 288
      lrec->set |= 2048U;
    }
#line 289
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 292
    *endp = str - 1;
#line 293
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return (0);
}
}
#line 133 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 155
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 166
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 368 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 357 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 258 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 23 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void echo_stream(int fd , struct component  const  *comp ) 
{ 
  int rc ;
  char buffer[8192] ;
  ssize_t tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 29
    rc = read(fd, (void *)(buffer), (size_t )sizeof(buffer));
    }
#line 29
    if (rc > 0) {
      {
#line 29
      tmp = write(fd, (void const   *)(buffer), (size_t )rc);
      }
#line 29
      if (! (tmp > 0)) {
#line 29
        goto while_break;
      }
    } else {
#line 29
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  return;
}
}
#line 34 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void echo_dg(int fd , struct component  const  *comp ) 
{ 
  int rc ;
  char buffer[8192] ;
  struct sockaddr sa ;
  socklen_t size ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 40
  size = (socklen_t )sizeof(sa);
#line 42
  rc = recvfrom(fd, (void */* __restrict  */)(buffer), (size_t )sizeof(buffer), 0,
                (struct sockaddr */* __restrict  */)(& sa), (socklen_t */* __restrict  */)(& size));
  }
#line 43
  if (rc < 0) {
#line 44
    return;
  }
  {
#line 45
  sendto(fd, (void const   *)(buffer), (size_t )rc, 0, (struct sockaddr  const  */* __restrict  */)(& sa),
         (socklen_t )sizeof(sa));
  }
#line 46
  return;
}
}
#line 49 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void discard_stream(int fd , struct component  const  *comp ) 
{ 
  int rc ;
  char buffer[8192] ;
  int *tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 57
      rc = read(fd, (void *)(buffer), (size_t )sizeof(buffer));
      }
#line 57
      if (! (rc > 0)) {
#line 57
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 59
    if (rc == 0) {
#line 60
      goto while_break;
    } else {
      {
#line 59
      tmp = __errno_location();
      }
#line 59
      if (*tmp != 4) {
#line 60
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 64 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void discard_dg(int fd , struct component  const  *comp ) 
{ 
  char buffer[8192] ;
  void *__cil_tmp4 ;

  {
  {
#line 68
  read(fd, (void *)(buffer), (size_t )sizeof(buffer));
  }
#line 69
  return;
}
}
#line 79 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static unsigned long time_since_1900(void) 
{ 
  struct timeval tv ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 84
  tmp___1 = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 84
  if (tmp___1 < 0) {
    {
#line 86
    tmp = __errno_location();
#line 86
    tmp___0 = strerror(*tmp);
#line 86
    logmsg(3, "gettimeofday: %s", tmp___0);
    }
#line 87
    return (0UL);
  }
  {
#line 89
  tmp___2 = htonl((uint32_t )((long )((unsigned long )tv.tv_sec + 2208988800UL)));
  }
#line 89
  return ((unsigned long )tmp___2);
}
}
#line 92 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void time_stream(int fd , struct component  const  *comp ) 
{ 
  unsigned long result ;
  unsigned long tmp ;

  {
  {
#line 95
  tmp = time_since_1900();
#line 95
  result = tmp;
#line 96
  write(fd, (void const   *)((char *)(& result)), (size_t )sizeof(result));
  }
#line 97
  return;
}
}
#line 99 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void time_dg(int fd , struct component  const  *comp ) 
{ 
  unsigned long result ;
  struct sockaddr sa ;
  socklen_t size ;
  ssize_t tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 104
  size = (socklen_t )sizeof(sa);
#line 106
  tmp = recvfrom(fd, (void */* __restrict  */)((char *)(& result)), (size_t )sizeof(result),
                 0, (struct sockaddr */* __restrict  */)(& sa), (socklen_t */* __restrict  */)(& size));
  }
#line 106
  if (tmp < 0) {
#line 107
    return;
  }
  {
#line 108
  result = time_since_1900();
#line 109
  sendto(fd, (void const   *)((char *)(& result)), (size_t )sizeof(result), 0, (struct sockaddr  const  */* __restrict  */)(& sa),
         (socklen_t )sizeof(sa));
  }
#line 110
  return;
}
}
#line 113 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void daytime_stream(int fd , struct component  const  *comp ) 
{ 
  char buffer[27] ;
  time_t now ;
  char *tmp ;
  size_t tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 119
  time(& now);
#line 120
  tmp = ctime((time_t const   *)(& now));
#line 120
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%.24s\r\n",
          tmp);
#line 121
  tmp___0 = strlen((char const   *)(buffer));
#line 121
  write(fd, (void const   *)(buffer), tmp___0);
  }
#line 122
  return;
}
}
#line 124 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void daytime_dg(int fd , struct component  const  *comp ) 
{ 
  char buffer[27] ;
  time_t now ;
  struct sockaddr sa ;
  socklen_t size ;
  ssize_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 130
  size = (socklen_t )sizeof(sa);
#line 132
  time(& now);
#line 134
  tmp = recvfrom(fd, (void */* __restrict  */)(buffer), (size_t )sizeof(buffer), 0,
                 (struct sockaddr */* __restrict  */)(& sa), (socklen_t */* __restrict  */)(& size));
  }
#line 134
  if (tmp < 0) {
#line 135
    return;
  }
  {
#line 136
  tmp___0 = ctime((time_t const   *)(& now));
#line 136
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%.24s\r\n",
          tmp___0);
#line 137
  tmp___1 = strlen((char const   *)(buffer));
#line 137
  sendto(fd, (void const   *)(buffer), tmp___1, 0, (struct sockaddr  const  */* __restrict  */)(& sa),
         (socklen_t )sizeof(sa));
  }
#line 138
  return;
}
}
#line 147
static void chargen_next_line(char *text ) ;
#line 147 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static int ch  =    0;
#line 144 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void chargen_next_line(char *text ) 
{ 
  int i ;
  int c ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    ch = (ch + 1) % 128;
#line 150
    tmp = c_isprint(ch);
    }
#line 150
    if (tmp) {
#line 150
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  i = 0;
#line 154
  c = ch;
  {
#line 154
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 154
    if (! (i < 72)) {
#line 154
      goto while_break___0;
    }
    {
#line 156
    tmp___1 = c_isprint(c);
    }
#line 156
    if (tmp___1) {
#line 157
      tmp___0 = i;
#line 157
      i ++;
#line 157
      *(text + tmp___0) = (char )c;
    }
#line 158
    c = (c + 1) % 128;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 162 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void chargen_stream(int fd , struct component  const  *comp ) 
{ 
  char text[74] ;
  ssize_t tmp ;
  void *__cil_tmp5 ;

  {
#line 167
  text[72] = (char )'\r';
#line 168
  text[73] = (char )'\n';
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 172
    chargen_next_line(text);
#line 173
    tmp = write(fd, (void const   *)(text), (size_t )sizeof(text));
    }
#line 173
    if ((unsigned long )tmp != sizeof(text)) {
#line 174
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 178 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void chargen_dg(int fd , struct component  const  *comp ) 
{ 
  struct sockaddr sa ;
  socklen_t size ;
  char text[74] ;
  ssize_t tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 182
  size = (socklen_t )sizeof(sa);
#line 185
  tmp = recvfrom(fd, (void */* __restrict  */)(text), (size_t )sizeof(text), 0, (struct sockaddr */* __restrict  */)(& sa),
                 (socklen_t */* __restrict  */)(& size));
  }
#line 185
  if (tmp < 0) {
#line 186
    return;
  }
  {
#line 187
  text[72] = (char )'\r';
#line 188
  text[73] = (char )'\n';
#line 189
  chargen_next_line(text);
#line 190
  sendto(fd, (void const   *)(text), (size_t )sizeof(text), 0, (struct sockaddr  const  */* __restrict  */)(& sa),
         (socklen_t )sizeof(sa));
  }
#line 191
  return;
}
}
#line 199 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static size_t trnl(char *text , size_t size ) 
{ 
  size_t off ;

  {
#line 202
  off = size;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (off > 0U)) {
#line 204
      goto while_break;
    }
#line 205
    if ((int )*(text + off) == 10) {
#line 207
      if ((int )*(text + (off - 1U)) == 13) {
#line 208
        off --;
      } else {
#line 211
        if (size == 512U) {
#line 212
          size --;
        }
        {
#line 213
        memmove((void *)((text + off) + 1), (void const   *)(text + off), size - off);
#line 214
        *(text + off) = (char )'\r';
#line 215
        size ++;
        }
      }
    }
#line 204
    off --;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return (size);
}
}
#line 221 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static size_t qotd_read(char *text ) 
{ 
  ssize_t rc ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 225
  tmp = open((char const   *)qotdfile, 0);
#line 225
  fd = tmp;
  }
#line 226
  if (fd == -1) {
    {
#line 228
    tmp___0 = __errno_location();
#line 228
    tmp___1 = strerror(*tmp___0);
#line 228
    tmp___2 = gettext("cannot open %s: %s");
#line 228
    logmsg(3, (char const   *)tmp___2, qotdfile, tmp___1);
#line 229
    strncpy((char */* __restrict  */)text, (char const   */* __restrict  */)"Quote of the Day\r\n",
            (size_t )512);
#line 230
    rc = 512;
    }
  } else {
    {
#line 234
    rc = read(fd, (void *)text, (size_t )512);
    }
#line 235
    if (rc >= 0) {
      {
#line 236
      tmp___3 = trnl(text, (size_t )rc);
#line 236
      rc = (ssize_t )tmp___3;
      }
    } else {
      {
#line 239
      tmp___4 = __errno_location();
#line 239
      tmp___5 = strerror(*tmp___4);
#line 239
      tmp___6 = gettext("error reading %s: %s");
#line 239
      logmsg(3, (char const   *)tmp___6, qotdfile, tmp___5);
#line 241
      strncpy((char */* __restrict  */)text, (char const   */* __restrict  */)"Quote of the Day\r\n",
              (size_t )512);
#line 242
      rc = 512;
      }
    }
  }
  {
#line 245
  close(fd);
  }
#line 246
  return ((size_t )rc);
}
}
#line 249 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void qotd_stream(int fd , struct component  const  *comp ) 
{ 
  char text[512] ;
  size_t len ;
  size_t tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 253
  tmp = qotd_read(text);
#line 253
  len = tmp;
#line 254
  write(fd, (void const   *)(text), len);
  }
#line 255
  return;
}
}
#line 257 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void qotd_dg(int fd , struct component  const  *comp ) 
{ 
  char text[512] ;
  struct sockaddr sa ;
  socklen_t size ;
  size_t len ;
  ssize_t tmp ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 262
  size = (socklen_t )sizeof(sa);
#line 264
  tmp = recvfrom(fd, (void */* __restrict  */)(text), (size_t )sizeof(text), 0, (struct sockaddr */* __restrict  */)(& sa),
                 (socklen_t */* __restrict  */)(& size));
  }
#line 264
  if (tmp < 0) {
#line 265
    return;
  }
  {
#line 266
  len = qotd_read(text);
#line 267
  sendto(fd, (void const   *)(text), len, 0, (struct sockaddr  const  */* __restrict  */)(& sa),
         (socklen_t )sizeof(sa));
  }
#line 268
  return;
}
}
#line 274 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static int fd_getline(int fd , char *buf , int len ) 
{ 
  int count ;
  int n ;

  {
#line 277
  count = 0;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 281
    n = read(fd, (void *)buf, (size_t )(len - count));
    }
#line 282
    if (n == 0) {
#line 283
      return (count);
    }
#line 284
    if (n < 0) {
#line 285
      return (-1);
    }
    {
#line 286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 286
      n --;
#line 286
      if (! (n >= 0)) {
#line 286
        goto while_break___0;
      }
#line 288
      if ((int )*buf == 13) {
#line 289
        return (count);
      } else
#line 288
      if ((int )*buf == 10) {
#line 289
        return (count);
      } else
#line 288
      if ((int )*buf == 0) {
#line 289
        return (count);
      }
#line 290
      count ++;
#line 291
      buf ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 279
    if (! (count < len)) {
#line 279
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return (count);
}
}
#line 298 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static int fd_write(int fd , char const   *text ) 
{ 
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 301
  tmp = strlen(text);
#line 301
  tmp___0 = write(fd, (void const   *)text, tmp);
  }
#line 301
  return (tmp___0);
}
}
#line 304 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static int tcpmux_help(struct component *comp , void *data ) 
{ 
  int *pfd ;
  char *__cil_tmp4 ;

  {
#line 307
  pfd = (int *)data;
#line 309
  if (! (comp->flags & 1)) {
#line 309
    if (comp->flags & 24) {
      {
#line 311
      fd_write(*pfd, (char const   *)comp->service);
#line 312
      fd_write(*pfd, "\r\n");
      }
    }
  }
#line 314
  return (0);
}
}
#line 317 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
static void tcpmux(int fd , struct component  const  *comp ) 
{ 
  char service[259] ;
  size_t len ;
  struct component *srv_comp ;
  union pies_sockaddr_storage sa ;
  socklen_t salen ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 324
  salen = (socklen_t )sizeof(sa);
#line 328
  tmp = fd_getline(fd, service, 258);
#line 328
  len = (size_t )tmp;
  }
#line 328
  if (len < 0U) {
    {
#line 330
    fd_write(fd, "-Error reading service name\r\n");
    }
#line 331
    return;
  }
#line 333
  service[len] = (char)0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (debug_level >= 2U) {
#line 335
      if (source_info_option) {
        {
#line 335
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c",
                      335, "tcpmux");
        }
      }
      {
#line 335
      debug_msg("tcpmux: someone wants %s", service);
      }
    }
#line 335
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 337
  tmp___0 = strcasecmp((char const   *)(service), "help");
  }
#line 337
  if (! tmp___0) {
    {
#line 339
    progman_iterate_comp(& tcpmux_help, (void *)(& fd));
    }
#line 340
    return;
  }
  {
#line 343
  srv_comp = progman_lookup_tcpmux((char const   *)(service), (char const   *)comp->tag);
  }
#line 344
  if (! srv_comp) {
    {
#line 346
    fd_write(fd, "-Service not available\r\n");
    }
#line 347
    return;
  }
  {
#line 350
  rc = getpeername(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sa)),
                   (socklen_t */* __restrict  */)(& salen));
  }
#line 351
  if (rc) {
    {
#line 352
    tmp___1 = __errno_location();
#line 352
    tmp___2 = strerror(*tmp___1);
#line 352
    tmp___3 = gettext("%s: cannot get peer name: %s");
#line 352
    logmsg(3, (char const   *)tmp___3, comp->tag, tmp___2);
    }
  }
#line 355
  if (comp->acl) {
#line 357
    if (rc) {
      {
#line 359
      fd_write(fd, "-Service not available\r\n");
      }
#line 360
      return;
    }
    {
#line 363
    tmp___4 = check_acl((pies_acl_t )comp->acl, (struct sockaddr *)(& sa), salen);
    }
#line 363
    if (tmp___4) {
      {
#line 365
      fd_write(fd, "-Service not available\r\n");
      }
#line 366
      return;
    }
  }
#line 370
  if (srv_comp->flags & 16) {
    {
#line 371
    fd_write(fd, "+Go\r\n");
    }
  }
  {
#line 373
  progman_run_comp(srv_comp, fd, & sa, salen);
  }
#line 374
  return;
}
}
#line 377 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
struct inetd_builtin inetd_builtin_tab[14]  = 
#line 377
  {      {"echo", 1, 0, 0, & echo_stream}, 
        {"echo", 2, 1, 0, & echo_dg}, 
        {"discard", 1, 0, 0, & discard_stream}, 
        {"discard", 2, 1, 0, & discard_dg}, 
        {"time", 1, 1, 0, & time_stream}, 
        {"time", 2, 1, 0, & time_dg}, 
        {"daytime", 1, 1, 0, & daytime_stream}, 
        {"daytime", 2, 1, 0, & daytime_dg}, 
        {"chargen", 1, 0, 0, & chargen_stream}, 
        {"chargen", 2, 1, 0, & chargen_dg}, 
        {"qotd", 1, 0, 0, & qotd_stream}, 
        {"qotd", 2, 1, 0, & qotd_dg}, 
        {"tcpmux", 1, 0, 0, & tcpmux}, 
        {(char const   *)((void *)0), 0, 0, 0, (void (*)(int  , struct component  const  * ))((void *)0)}};
#line 401 "/home/ysko/Works/test-src/pies-1.2/src/inetd-bi.c"
struct inetd_builtin *inetd_builtin_lookup(char const   *service , int socktype ) 
{ 
  struct inetd_builtin *bp ;
  int tmp ;

  {
#line 406
  bp = inetd_builtin_tab;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! bp->service) {
#line 406
      goto while_break;
    }
#line 407
    if (bp->socktype == socktype) {
      {
#line 407
      tmp = strcmp(bp->service, service);
      }
#line 407
      if (tmp == 0) {
#line 408
        return (bp);
      }
    }
#line 406
    bp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  return ((struct inetd_builtin *)((void *)0));
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 32 "/home/ysko/Works/test-src/pies-1.2/src/inetd.c"
static void listel_dispose___0(void const   *el ) 
{ 


  {
  {
#line 35
  free((void *)el);
  }
#line 36
  return;
}
}
#line 41 "/home/ysko/Works/test-src/pies-1.2/src/inetd.c"
static int tcpmux_service(char const   *service , char **psrv , int *pflag ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 44
  tmp = strncmp(service, "tcpmux/", (size_t )(sizeof("tcpmux/") - 1UL));
  }
#line 44
  if (tmp == 0) {
#line 46
    service += sizeof("tcpmux/") - 1UL;
#line 47
    if ((int const   )*service == 43) {
#line 49
      *pflag |= 16;
#line 50
      service ++;
    } else {
#line 53
      *pflag |= 8;
    }
#line 54
    *psrv = (char *)service;
#line 55
    return (1);
  }
#line 57
  return (0);
}
}
#line 60 "/home/ysko/Works/test-src/pies-1.2/src/inetd.c"
static char *mktag(char const   *address , char const   *service ) 
{ 
  char *str ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 65
  if (address) {
    {
#line 67
    tmp = strlen(address);
#line 67
    tmp___0 = strlen(service);
#line 67
    tmp___1 = xmalloc(((tmp + 1U) + tmp___0) + 1U);
#line 67
    str = (char *)tmp___1;
#line 68
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)address);
#line 69
    strcat((char */* __restrict  */)str, (char const   */* __restrict  */)":");
#line 70
    strcat((char */* __restrict  */)str, (char const   */* __restrict  */)service);
    }
  } else {
    {
#line 73
    str = xstrdup(service);
    }
  }
#line 74
  return (str);
}
}
#line 78 "/home/ysko/Works/test-src/pies-1.2/src/inetd.c"
static int inetd_conf_file(char const   *file ) 
{ 
  FILE *fp ;
  size_t size ;
  char *buf ;
  size_t line_no ;
  struct wordsplit ws ;
  char *dfl_address ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *p ;
  struct component *comp ;
  int socket_type ;
  struct pies_url *url ;
  size_t max_rate ;
  int flags ;
  char *str ;
  char *user ;
  char *group ;
  char *address ;
  char *service ;
  size_t len ;
  struct inetd_builtin *builtin ;
  char *tag ;
  _Bool tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t len___0 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t n ;
  char *tmp___18 ;
  unsigned long tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  size_t i ;
  size_t j ;
  void *tmp___26 ;
  void *tmp___27 ;
  struct component *tmp___28 ;
  __ssize_t tmp___29 ;
  void *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
  {
#line 82
  size = (size_t )0;
#line 83
  buf = (char *)((void *)0);
#line 84
  line_no = (size_t )0;
#line 86
  dfl_address = (char *)((void *)0);
#line 88
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 89
  if (! fp) {
    {
#line 91
    tmp = __errno_location();
#line 91
    tmp___0 = strerror(*tmp);
#line 91
    tmp___1 = gettext("cannot open configuration file %s: %s");
#line 91
    logmsg(3, (char const   *)tmp___1, file, tmp___0);
    }
#line 94
    return (1);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    tmp___29 = (__ssize_t )getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& size),
                                   (FILE */* __restrict  */)fp);
    }
#line 97
    if (! (tmp___29 >= 0)) {
#line 97
      goto while_break;
    }
#line 103
    max_rate = (size_t )0;
#line 104
    flags = 0;
#line 106
    user = (char *)((void *)0);
#line 107
    group = (char *)((void *)0);
#line 114
    if (line_no) {
      {
#line 115
      wordsplit_free(& ws);
      }
    }
#line 117
    line_no ++;
#line 118
    p = buf;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (*p) {
        {
#line 118
        tmp___2 = c_isblank((int )*p);
        }
#line 118
        if (! tmp___2) {
#line 118
          goto while_break___0;
        }
      } else {
#line 118
        goto while_break___0;
      }
#line 118
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 121
    if (! p) {
#line 122
      goto while_continue;
    } else
#line 121
    if ((int )*p == 10) {
#line 122
      goto while_continue;
    } else
#line 121
    if ((int )*p == 35) {
#line 122
      goto while_continue;
    }
    {
#line 124
    tmp___5 = wordsplit((char const   *)p, & ws, 1348);
    }
#line 124
    if (tmp___5) {
      {
#line 128
      tmp___3 = __errno_location();
#line 128
      tmp___4 = strerror(*tmp___3);
#line 128
      logmsg(3, "wordsplit: %s", tmp___4);
      }
#line 129
      goto while_continue;
    }
#line 132
    if (ws.ws_wordc == 1U) {
      {
#line 134
      tmp___6 = strlen((char const   *)*(ws.ws_wordv + 0));
#line 134
      len___0 = tmp___6;
      }
#line 135
      if (len___0 > 0U) {
#line 135
        if ((int )*(*(ws.ws_wordv + 0) + (len___0 - 1U)) == 58) {
          {
#line 137
          free((void *)dfl_address);
          }
#line 139
          if (len___0 == 2U) {
#line 139
            if ((int )*(*(ws.ws_wordv + 0) + 0) == 42) {
#line 140
              dfl_address = (char *)((void *)0);
            } else {
              {
#line 143
              tmp___7 = xmalloc(len___0);
#line 143
              dfl_address = (char *)tmp___7;
#line 144
              memcpy((void */* __restrict  */)dfl_address, (void const   */* __restrict  */)*(ws.ws_wordv + 0),
                     len___0 - 1U);
#line 145
              *(dfl_address + (len___0 - 1U)) = (char)0;
              }
            }
          } else {
            {
#line 143
            tmp___7 = xmalloc(len___0);
#line 143
            dfl_address = (char *)tmp___7;
#line 144
            memcpy((void */* __restrict  */)dfl_address, (void const   */* __restrict  */)*(ws.ws_wordv + 0),
                   len___0 - 1U);
#line 145
            *(dfl_address + (len___0 - 1U)) = (char)0;
            }
          }
#line 147
          goto while_continue;
        }
      }
    }
#line 151
    if (ws.ws_wordc < 6U) {
      {
#line 153
      logmsg(3, "%s:%lu: too few fields", file, line_no);
      }
#line 154
      goto while_continue;
    }
    {
#line 158
    str = strchr((char const   *)*(ws.ws_wordv + 0), ':');
    }
#line 159
    if (str) {
#line 161
      tmp___8 = str;
#line 161
      str ++;
#line 161
      *tmp___8 = (char)0;
#line 162
      address = *(ws.ws_wordv + 0);
#line 163
      service = str;
    } else {
#line 167
      address = dfl_address;
#line 168
      service = *(ws.ws_wordv + 0);
    }
    {
#line 172
    tmp___10 = str_to_socket_type((char const   *)*(ws.ws_wordv + 1), & socket_type);
    }
#line 172
    if (tmp___10) {
      {
#line 174
      tmp___9 = gettext("bad socket type");
#line 174
      logmsg(3, "%s:%lu: %s", file, line_no, tmp___9);
      }
#line 176
      goto while_continue;
    }
    {
#line 179
    tag = service;
#line 181
    tmp___17 = tcpmux_service((char const   *)service, & service, & flags);
    }
#line 181
    if (tmp___17) {
      {
#line 183
      tmp___12 = strncmp((char const   *)*(ws.ws_wordv + 2), "tcp", (size_t )3);
      }
#line 183
      if (tmp___12) {
        {
#line 185
        tmp___11 = gettext("bad protocol for tcpmux service");
#line 185
        logmsg(3, "%s:%lu: %s", file, line_no, tmp___11);
        }
#line 187
        goto while_continue;
      }
#line 189
      if (socket_type != 1) {
        {
#line 191
        tmp___13 = gettext("bad socket type for tcpmux service");
#line 191
        logmsg(3, "%s:%lu: %s", file, line_no, tmp___13);
        }
#line 193
        goto while_continue;
      }
#line 195
      url = (struct pies_url *)((void *)0);
    } else {
#line 200
      if (address) {
#line 200
        tmp___14 = (char const   *)address;
      } else {
#line 200
        tmp___14 = "0.0.0.0";
      }
      {
#line 200
      str = xasprintf("inet+%s://%s:%s", *(ws.ws_wordv + 2), tmp___14, service);
#line 204
      tmp___16 = pies_url_create(& url, (char const   *)str);
      }
#line 204
      if (tmp___16) {
        {
#line 207
        tmp___15 = gettext("invalid socket address");
#line 207
        logmsg(3, "%s:%lu: %s", file, line_no, tmp___15);
        }
#line 209
        goto while_continue;
      }
      {
#line 211
      free((void *)str);
      }
    }
    {
#line 215
    str = strchr((char const   *)*(ws.ws_wordv + 3), '.');
    }
#line 216
    if (str) {
      {
#line 220
      tmp___18 = str;
#line 220
      str ++;
#line 220
      *tmp___18 = (char)0;
#line 221
      tmp___19 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& p),
                         10);
#line 221
      n = (size_t )tmp___19;
      }
#line 222
      if (*p) {
        {
#line 223
        logmsg(4, "%s:%lu: invalid number (near %s)", file, line_no, p);
        }
      } else {
#line 226
        max_rate = n;
      }
    }
    {
#line 229
    tmp___22 = strcmp((char const   *)*(ws.ws_wordv + 3), "wait");
    }
#line 229
    if (tmp___22 == 0) {
#line 230
      flags |= 4;
    } else {
      {
#line 231
      tmp___21 = strcmp((char const   *)*(ws.ws_wordv + 3), "nowait");
      }
#line 231
      if (tmp___21) {
        {
#line 233
        tmp___20 = gettext("invalid wait field");
#line 233
        logmsg(3, "%s:%lu: %s", file, line_no, tmp___20);
#line 235
        pies_url_destroy(& url);
        }
#line 236
        goto while_continue;
      }
    }
    {
#line 240
    len = strcspn((char const   *)*(ws.ws_wordv + 4), ":.");
    }
#line 241
    if (*(*(ws.ws_wordv + 4) + len)) {
#line 243
      *(*(ws.ws_wordv + 4) + len) = (char)0;
#line 244
      group = (*(ws.ws_wordv + 4) + len) + 1;
    }
    {
#line 246
    user = *(ws.ws_wordv + 4);
#line 249
    tmp___24 = strcmp((char const   *)*(ws.ws_wordv + 5), "internal");
    }
#line 249
    if (tmp___24 == 0) {
      {
#line 251
      builtin = inetd_builtin_lookup((char const   *)service, socket_type);
      }
#line 252
      if (! builtin) {
        {
#line 254
        tmp___23 = gettext("unknown internal service");
#line 254
        logmsg(3, "%s:%lu: %s", file, line_no, tmp___23);
        }
#line 256
        goto while_continue;
      }
    } else {
#line 260
      builtin = (struct inetd_builtin *)((void *)0);
    }
    {
#line 263
    str = mktag((char const   *)address, (char const   *)tag);
#line 264
    comp = component_create((char const   *)str);
#line 265
    free((void *)str);
#line 267
    comp->mode = (enum pies_comp_mode )2;
#line 268
    comp->socket_type = socket_type;
#line 269
    comp->socket_url = url;
#line 270
    comp->max_rate = max_rate;
    }
#line 271
    if (builtin) {
#line 273
      comp->builtin = builtin;
#line 274
      comp->flags = builtin->flags;
    } else {
#line 277
      comp->flags = flags;
    }
#line 278
    if (comp->flags & 24) {
      {
#line 279
      comp->tcpmux = mktag((char const   *)address, "tcpmux");
      }
    }
    {
#line 280
    comp->service = xstrdup((char const   *)service);
#line 281
    comp->privs.user = xstrdup((char const   *)user);
    }
#line 282
    if (group) {
      {
#line 284
      comp->privs.groups = gl_list_create_empty_inline(& gl_linked_list_implementation,
                                                       (_Bool (*)(void const   *elt1 ,
                                                                  void const   *elt2 ))((void *)0),
                                                       (size_t (*)(void const   *elt ))((void *)0),
                                                       & listel_dispose___0, (_Bool)1);
#line 290
      tmp___25 = xstrdup((char const   *)group);
#line 290
      gl_list_add_last_inline(comp->privs.groups, (void const   *)tmp___25);
      }
    }
    {
#line 293
    comp->program = xstrdup((char const   *)*(ws.ws_wordv + 5));
    }
#line 295
    if (ws.ws_wordc > 6U) {
      {
#line 299
      comp->argc = ws.ws_wordc - 6U;
#line 300
      tmp___26 = xcalloc(comp->argc + 1U, (size_t )sizeof(*(comp->argv + 0)));
#line 300
      comp->argv = (char **)tmp___26;
#line 301
      i = (size_t )6;
#line 301
      j = (size_t )0;
      }
      {
#line 301
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 301
        if (! (i < ws.ws_wordc)) {
#line 301
          goto while_break___1;
        }
        {
#line 302
        *(comp->argv + j) = xstrdup((char const   *)*(ws.ws_wordv + i));
#line 301
        i ++;
#line 301
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 306
      comp->argc = (size_t )1;
#line 307
      tmp___27 = xcalloc(comp->argc + 1U, (size_t )sizeof(*(comp->argv + 0)));
#line 307
      comp->argv = (char **)tmp___27;
#line 308
      *(comp->argv + 0) = xstrdup((char const   *)comp->program);
      }
    }
    {
#line 311
    tmp___28 = progman_lookup_component((char const   *)comp->tag);
    }
#line 311
    if ((unsigned long )tmp___28 == (unsigned long )((void *)0)) {
      {
#line 312
      register_prog(comp);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  if (line_no) {
    {
#line 316
    wordsplit_free(& ws);
    }
  }
  {
#line 317
  free((void *)dfl_address);
#line 318
  free((void *)buf);
#line 319
  fclose(fp);
  }
#line 320
  return (0);
}
}
#line 328 "/home/ysko/Works/test-src/pies-1.2/src/inetd.c"
static int inetd_conf_dir(char const   *name ) 
{ 
  DIR *dir ;
  struct dirent *ent ;
  int errs ;
  char *namebuf ;
  size_t namebufsize ;
  size_t namelen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  struct stat st ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t len ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 333
  errs = 0;
#line 338
  dir = opendir(name);
  }
#line 339
  if (! dir) {
    {
#line 341
    tmp = __errno_location();
#line 341
    tmp___0 = strerror(*tmp);
#line 341
    tmp___1 = gettext("cannot open directory %s: %s");
#line 341
    logmsg(3, (char const   *)tmp___1, name, tmp___0);
    }
#line 343
    return (1);
  }
  {
#line 346
  namelen = strlen(name);
#line 347
  namebufsize = namelen;
  }
#line 348
  if ((int const   )*(name + (namelen - 1U)) != 47) {
#line 349
    namebufsize ++;
  }
  {
#line 350
  namebufsize += 16U;
#line 351
  tmp___2 = xmalloc(namebufsize);
#line 351
  namebuf = (char *)tmp___2;
#line 352
  memcpy((void */* __restrict  */)namebuf, (void const   */* __restrict  */)name,
         namelen);
  }
#line 353
  if ((int const   )*(name + (namelen - 1U)) != 47) {
#line 354
    tmp___3 = namelen;
#line 354
    namelen ++;
#line 354
    *(namebuf + tmp___3) = (char)0;
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 356
    ent = readdir(dir);
    }
#line 356
    if (! ent) {
#line 356
      goto while_break;
    }
    {
#line 360
    tmp___10 = stat((char const   */* __restrict  */)(ent->d_name), (struct stat */* __restrict  */)(& st));
    }
#line 360
    if (tmp___10) {
      {
#line 362
      tmp___4 = __errno_location();
#line 362
      tmp___5 = strerror(*tmp___4);
#line 362
      tmp___6 = gettext("cannot stat %s/%s: %s");
#line 362
      logmsg(3, (char const   *)tmp___6, name, ent->d_name, tmp___5);
#line 364
      errs |= 1;
      }
    } else
#line 366
    if ((st.st_mode & 61440U) == 32768U) {
#line 366
      goto _L;
    } else
#line 366
    if ((st.st_mode & 61440U) == 40960U) {
      _L: /* CIL Label */ 
      {
#line 368
      tmp___7 = strlen((char const   *)(ent->d_name));
#line 368
      len = tmp___7;
      }
#line 369
      if (namelen + len >= namebufsize) {
        {
#line 371
        namebufsize = (namelen + len) + 1U;
#line 372
        tmp___8 = xrealloc((void *)namebuf, namebufsize);
#line 372
        namebuf = (char *)tmp___8;
        }
      }
      {
#line 374
      strcpy((char */* __restrict  */)(namebuf + namelen), (char const   */* __restrict  */)(ent->d_name));
#line 375
      tmp___9 = inetd_conf_file((char const   *)namebuf);
#line 375
      errs |= tmp___9;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 378
  free((void *)namebuf);
#line 379
  closedir(dir);
  }
#line 380
  return (errs);
}
}
#line 383 "/home/ysko/Works/test-src/pies-1.2/src/inetd.c"
int inetd_parse_conf(char const   *file ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 388
  tmp___2 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 388
  if (tmp___2) {
    {
#line 390
    tmp = __errno_location();
#line 390
    tmp___0 = strerror(*tmp);
#line 390
    tmp___1 = gettext("cannot stat %s: %s");
#line 390
    logmsg(3, (char const   *)tmp___1, file, tmp___0);
    }
#line 391
    return (1);
  }
#line 393
  if ((st.st_mode & 61440U) == 16384U) {
    {
#line 394
    tmp___3 = inetd_conf_dir(file);
    }
#line 394
    return (tmp___3);
  }
  {
#line 396
  tmp___4 = inetd_conf_file(file);
  }
#line 396
  return (tmp___4);
}
}
#line 200 "/usr/include/sys/syslog.h"
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 331 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
unsigned int debug_level  ;
#line 332 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
int source_info_option  ;
#line 22 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
int diag_output  =    2;
#line 24 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
void diag_setup(int flags ) 
{ 


  {
#line 27
  if (flags) {
#line 28
    diag_output = flags;
  }
#line 29
  if (diag_output & 1) {
    {
#line 30
    openlog((char const   *)log_tag, 1, log_facility);
    }
  }
#line 31
  return;
}
}
#line 33 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
void syslog_printer(int prio , char const   *fmt , va_list ap ) 
{ 


  {
  {
#line 37
  vsyslog(prio, fmt, ap);
  }
#line 43
  return;
}
}
#line 45 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
void vlogmsg(int prio , char const   *fmt , va_list ap ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 48
  if (diag_output & 2) {
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_name);
#line 51
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             ap);
#line 52
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 54
  if (diag_output & 1) {
    {
#line 55
    syslog_printer(prio, fmt, ap);
    }
  }
#line 56
  return;
}
}
#line 58 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
void logmsg(int prio , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 62
  __builtin_va_start(ap, fmt);
#line 63
  vlogmsg(prio, fmt, ap);
#line 64
  __builtin_va_end(ap);
  }
#line 65
  return;
}
}
#line 67 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
void debug_msg(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 71
  __builtin_va_start(ap, fmt);
#line 72
  vlogmsg(7, fmt, ap);
#line 73
  __builtin_va_end(ap);
  }
#line 74
  return;
}
}
#line 77 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
static struct obstack log_stk  ;
#line 78 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
static int log_stk_init  ;
#line 80 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
void logmsg_vprintf(int prio , char const   *fmt , va_list ap ) 
{ 
  char *str ;
  char *p ;
  size_t len ;
  size_t tmp ;
  struct obstack *__o ;
  int __len ;
  char *msg ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct obstack *__o___1 ;
  void *__obj ;
  char *tmp___3 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 85
  str = xvasprintf(fmt, ap);
  }
#line 87
  if (! log_stk_init) {
    {
#line 89
    _obstack_begin(& log_stk, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
#line 90
    log_stk_init = 1;
    }
  }
#line 92
  p = str;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! *p) {
#line 92
      goto while_break;
    }
    {
#line 94
    tmp = strcspn((char const   *)p, "\n");
#line 94
    len = tmp;
    }
#line 95
    if (len) {
#line 96
      __o = & log_stk;
#line 96
      __len = (int )len;
#line 96
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 96
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 96
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)p,
             (size_t )__len);
#line 96
      __o->next_free += __len;
      }
    }
#line 97
    p += len;
#line 98
    if (*p) {
#line 102
      __o___0 = & log_stk;
#line 102
      if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
        {
#line 102
        _obstack_newchunk(__o___0, 1);
        }
      }
#line 102
      tmp___0 = __o___0->next_free;
#line 102
      (__o___0->next_free) ++;
#line 102
      *tmp___0 = (char)0;
#line 103
      __o1 = & log_stk;
#line 103
      __value = (void *)__o1->object_base;
#line 103
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 103
        __o1->maybe_empty_object = 1U;
      }
#line 103
      if (sizeof(int ) < sizeof(void *)) {
#line 103
        tmp___1 = __o1->object_base;
      } else {
#line 103
        tmp___1 = (char *)0;
      }
#line 103
      if (sizeof(int ) < sizeof(void *)) {
#line 103
        tmp___2 = __o1->object_base;
      } else {
#line 103
        tmp___2 = (char *)0;
      }
#line 103
      __o1->next_free = tmp___1 + (((__o1->next_free - tmp___2) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 103
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 103
        __o1->next_free = __o1->chunk_limit;
      }
      {
#line 103
      __o1->object_base = __o1->next_free;
#line 103
      msg = (char *)__value;
#line 104
      logmsg(prio, "%s", msg);
#line 105
      __o___1 = & log_stk;
#line 105
      __obj = (void *)msg;
      }
#line 105
      if ((unsigned long )__obj > (unsigned long )((void *)__o___1->chunk)) {
#line 105
        if ((unsigned long )__obj < (unsigned long )((void *)__o___1->chunk_limit)) {
#line 105
          tmp___3 = (char *)__obj;
#line 105
          __o___1->object_base = tmp___3;
#line 105
          __o___1->next_free = tmp___3;
        } else {
          {
#line 105
          obstack_free(__o___1, __obj);
          }
        }
      } else {
        {
#line 105
        obstack_free(__o___1, __obj);
        }
      }
#line 106
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  free((void *)str);
  }
#line 110
  return;
}
}
#line 112 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
void logmsg_printf(int prio , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 116
  __builtin_va_start(ap, fmt);
#line 117
  logmsg_vprintf(prio, fmt, ap);
#line 118
  __builtin_va_end(ap);
  }
#line 119
  return;
}
}
#line 121 "/home/ysko/Works/test-src/pies-1.2/src/diag.c"
void grecs_print_diag(grecs_locus_t *locus , int err , int errcode , char const   *msg ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 124
  if (locus) {
#line 126
    if (errcode) {
      {
#line 127
      tmp = strerror(errcode);
      }
#line 127
      if (err) {
#line 127
        tmp___0 = 3;
      } else {
#line 127
        tmp___0 = 4;
      }
      {
#line 127
      logmsg(tmp___0, "%s:%lu: %s: %s", locus->file, (unsigned long )locus->line,
             msg, tmp);
      }
    } else {
#line 131
      if (err) {
#line 131
        tmp___1 = 3;
      } else {
#line 131
        tmp___1 = 4;
      }
      {
#line 131
      logmsg(tmp___1, "%s:%lu: %s", locus->file, (unsigned long )locus->line, msg);
      }
    }
  } else
#line 136
  if (errcode) {
    {
#line 137
    tmp___2 = strerror(errcode);
    }
#line 137
    if (err) {
#line 137
      tmp___3 = 3;
    } else {
#line 137
      tmp___3 = 4;
    }
    {
#line 137
    logmsg(tmp___3, "%s: %s", msg, tmp___2);
    }
  } else {
#line 140
    if (err) {
#line 140
      tmp___4 = 3;
    } else {
#line 140
      tmp___4 = 4;
    }
    {
#line 140
    logmsg(tmp___4, "%s", msg);
    }
  }
#line 142
  return;
}
}
#line 29 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
void TC(unsigned int *R , int n ) 
{ 
  register int rowsize ;
  register unsigned int mask ;
  register unsigned int *rowj ;
  register unsigned int *rp ;
  register unsigned int *rend ;
  register unsigned int *ccol ;
  unsigned int *relend ;
  unsigned int *cword ;
  unsigned int *rowi ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
#line 43
  rowsize = (int )(((((unsigned long )n + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) * sizeof(unsigned int ));
#line 44
  relend = (unsigned int *)((char *)R + n * rowsize);
#line 46
  cword = R;
#line 47
  mask = 1U;
#line 48
  rowi = R;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! ((unsigned long )rowi < (unsigned long )relend)) {
#line 49
      goto while_break;
    }
#line 51
    ccol = cword;
#line 52
    rowj = R;
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 54
      if (! ((unsigned long )rowj < (unsigned long )relend)) {
#line 54
        goto while_break___0;
      }
#line 56
      if (*ccol & mask) {
#line 58
        rp = rowi;
#line 59
        rend = (unsigned int *)((char *)rowj + rowsize);
        {
#line 61
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 61
          if (! ((unsigned long )rowj < (unsigned long )rend)) {
#line 61
            goto while_break___1;
          }
#line 62
          tmp = rowj;
#line 62
          rowj ++;
#line 62
          tmp___0 = rp;
#line 62
          rp ++;
#line 62
          *tmp |= *tmp___0;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 66
        rowj = (unsigned int *)((char *)rowj + rowsize);
      }
#line 69
      ccol = (unsigned int *)((char *)ccol + rowsize);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 72
    mask <<= 1;
#line 73
    if (mask == 0U) {
#line 75
      mask = 1U;
#line 76
      cword ++;
    }
#line 78
    rowi = (unsigned int *)((char *)rowi + rowsize);
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 89 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
pies_depmap_t depmap_alloc(size_t count ) 
{ 
  size_t size ;
  pies_depmap_t dmap ;
  void *tmp ;

  {
  {
#line 92
  size = (size_t )((((unsigned long )count + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL));
#line 93
  tmp = xzalloc((size_t )((sizeof(*dmap) - 1UL) + (unsigned long )(count * size) * sizeof(unsigned int )));
#line 93
  dmap = (pies_depmap_t )tmp;
#line 95
  dmap->nrows = count;
#line 96
  dmap->rowlen = size;
  }
#line 97
  return (dmap);
}
}
#line 100 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
pies_depmap_t depmap_copy(pies_depmap_t dpm ) 
{ 
  pies_depmap_t copy ;
  pies_depmap_t tmp ;

  {
  {
#line 103
  tmp = depmap_alloc(dpm->nrows);
#line 103
  copy = tmp;
#line 104
  memcpy((void */* __restrict  */)(copy->r), (void const   */* __restrict  */)(dpm->r),
         (size_t )((unsigned long )(dpm->nrows * dpm->rowlen) * sizeof(unsigned int )));
  }
#line 105
  return (copy);
}
}
#line 108 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
static unsigned int *depmap_rowptr(pies_depmap_t dmap , size_t row ) 
{ 


  {
#line 111
  return (dmap->r + dmap->rowlen * row);
}
}
#line 114 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
void depmap_set(pies_depmap_t dmap , size_t row , size_t col ) 
{ 
  unsigned int *rptr ;
  unsigned int *tmp ;

  {
  {
#line 117
  tmp = depmap_rowptr(dmap, row);
#line 117
  rptr = tmp;
#line 118
  *(rptr + (unsigned long )col / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << (unsigned long )col % (sizeof(unsigned int ) * 8UL));
  }
#line 119
  return;
}
}
#line 121 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
int depmap_isset(pies_depmap_t dmap , size_t row , size_t col ) 
{ 
  unsigned int *rptr ;
  unsigned int *tmp ;

  {
  {
#line 124
  tmp = depmap_rowptr(dmap, row);
#line 124
  rptr = tmp;
  }
#line 125
  return ((*(rptr + (unsigned long )col / (sizeof(unsigned int ) * 8UL)) & (unsigned int )(1 << (unsigned long )col % (sizeof(unsigned int ) * 8UL))) != 0U);
}
}
#line 128 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
void depmap_tc(pies_depmap_t dmap ) 
{ 


  {
  {
#line 131
  TC(dmap->r, (int )dmap->nrows);
  }
#line 132
  return;
}
}
#line 140 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
size_t depmap_next(pies_depmap_t dmap , pies_depmap_pos_t pos ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
#line 143
  (pos->coord[pos->dir]) ++;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (pos->coord[pos->dir] < dmap->nrows)) {
#line 143
      goto while_break;
    }
    {
#line 145
    tmp = depmap_isset(dmap, pos->coord[0], pos->coord[1]);
    }
#line 145
    if (tmp) {
#line 146
      goto while_break;
    }
#line 143
    (pos->coord[pos->dir]) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  if (pos->coord[pos->dir] == dmap->nrows) {
#line 148
    tmp___0 = (size_t )-1;
  } else {
#line 148
    tmp___0 = pos->coord[pos->dir];
  }
#line 148
  return (tmp___0);
}
}
#line 152 "/home/ysko/Works/test-src/pies-1.2/src/depmap.c"
size_t depmap_first(pies_depmap_t dmap , enum pies_depmap_direction dir , size_t coord ,
                    pies_depmap_pos_t *ppos ) 
{ 
  pies_depmap_pos_t pos ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 156
  tmp = xmalloc((size_t )sizeof(*pos));
#line 156
  pos = (pies_depmap_pos_t )tmp;
#line 157
  *ppos = pos;
#line 158
  pos->dir = dir;
#line 159
  pos->coord[! pos->dir] = coord;
#line 160
  pos->coord[pos->dir] = (size_t )-1;
#line 161
  tmp___0 = depmap_next(dmap, pos);
  }
#line 161
  return (tmp___0);
}
}
#line 362 "/home/ysko/Works/test-src/pies-1.2/src/pies.h"
void sockaddr_to_str(struct sockaddr  const  *sa , int salen , char *bufptr , size_t buflen ,
                     size_t *plen ) ;
#line 29 "/home/ysko/Works/test-src/pies-1.2/src/addrfmt.c"
int str2port(char *str ) 
{ 
  struct servent *serv ;
  char *p ;
  int port ;
  uint16_t tmp ;
  unsigned long l ;
  char *__cil_tmp7 ;

  {
  {
#line 37
  serv = getservbyname((char const   *)str, "tcp");
  }
#line 39
  if ((unsigned long )serv != (unsigned long )((void *)0)) {
    {
#line 40
    tmp = ntohs((uint16_t )serv->s_port);
#line 40
    port = (int )tmp;
    }
  } else {
    {
#line 45
    l = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& p),
                0);
    }
#line 47
    if (*p) {
#line 48
      return (-1);
    } else
#line 47
    if (l < 0UL) {
#line 48
      return (-1);
    } else
#line 47
    if (l > 65535UL) {
#line 48
      return (-1);
    }
#line 50
    port = (int )l;
  }
#line 53
  return (port);
}
}
#line 56 "/home/ysko/Works/test-src/pies-1.2/src/addrfmt.c"
static size_t _my_stpcpy(char **pbuf , size_t *psize , char const   *src ) 
{ 
  size_t slen ;
  size_t tmp ;
  char *buf ;
  size_t size ;

  {
  {
#line 59
  tmp = strlen(src);
#line 59
  slen = tmp;
  }
#line 60
  if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
#line 61
    return (slen);
  } else
#line 60
  if ((unsigned long )*pbuf == (unsigned long )((void *)0)) {
#line 61
    return (slen);
  } else {
#line 64
    buf = *pbuf;
#line 65
    size = *psize;
#line 66
    if (size > slen) {
#line 67
      size = slen;
    }
    {
#line 68
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)src, size);
#line 69
    *psize -= size;
#line 70
    *pbuf += size;
    }
#line 71
    if (*psize) {
#line 72
      *(*pbuf) = (char)0;
    } else {
#line 74
      *(*pbuf + -1) = (char)0;
    }
#line 75
    return (size);
  }
}
}
#line 82 "/home/ysko/Works/test-src/pies-1.2/src/addrfmt.c"
void sockaddr_to_str(struct sockaddr  const  *sa , int salen , char *bufptr , size_t buflen ,
                     size_t *plen ) 
{ 
  char buf[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  size_t len ;
  struct sockaddr_in s_in ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  uint16_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  struct sockaddr_un *s_un ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 88
  len = (size_t )0;
  {
#line 91
  if ((int const   )sa->sa_family == 2) {
#line 91
    goto case_2;
  }
#line 101
  if ((int const   )sa->sa_family == 1) {
#line 101
    goto case_1;
  }
#line 114
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 93
  s_in = *((struct sockaddr_in *)sa);
#line 94
  tmp = inet_ntoa(s_in.sin_addr);
#line 94
  tmp___0 = _my_stpcpy(& bufptr, & buflen, (char const   *)tmp);
#line 94
  len += tmp___0;
#line 95
  tmp___1 = _my_stpcpy(& bufptr, & buflen, ":");
#line 95
  len += tmp___1;
#line 96
  tmp___2 = ntohs(s_in.sin_port);
#line 96
  tmp___3 = umaxtostr((uintmax_t )tmp___2, buf);
#line 96
  tmp___4 = _my_stpcpy(& bufptr, & buflen, (char const   *)tmp___3);
#line 96
  len += tmp___4;
  }
#line 98
  goto switch_break;
  case_1: /* CIL Label */ 
#line 103
  s_un = (struct sockaddr_un *)sa;
#line 104
  if ((unsigned long )salen < (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)) {
#line 104
    tmp___8 = "";
  } else {
#line 104
    tmp___8 = (char const   *)(s_un->sun_path);
  }
#line 104
  if ((int const   )*(tmp___8 + 0) == 0) {
    {
#line 105
    tmp___5 = _my_stpcpy(& bufptr, & buflen, "anonymous socket");
#line 105
    len += tmp___5;
    }
  } else {
    {
#line 108
    tmp___6 = _my_stpcpy(& bufptr, & buflen, "socket ");
#line 108
    len += tmp___6;
#line 109
    tmp___7 = _my_stpcpy(& bufptr, & buflen, (char const   *)(s_un->sun_path));
#line 109
    len += tmp___7;
    }
  }
#line 111
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 115
  tmp___9 = _my_stpcpy(& bufptr, & buflen, "{Unsupported family: ");
#line 115
  len += tmp___9;
#line 116
  tmp___10 = umaxtostr((uintmax_t )sa->sa_family, buf);
#line 116
  tmp___11 = _my_stpcpy(& bufptr, & buflen, (char const   *)tmp___10);
#line 116
  len += tmp___11;
#line 117
  tmp___12 = _my_stpcpy(& bufptr, & buflen, "}");
#line 117
  len += tmp___12;
  }
  switch_break: /* CIL Label */ ;
  }
#line 119
  if (plen) {
#line 120
    *plen = len + 1U;
  }
#line 121
  return;
}
}
#line 123 "/home/ysko/Works/test-src/pies-1.2/src/addrfmt.c"
char *sockaddr_to_astr(struct sockaddr  const  *sa , int salen ) 
{ 
  size_t size ;
  char *p ;
  void *tmp ;

  {
  {
#line 129
  sockaddr_to_str(sa, salen, (char *)((void *)0), (size_t )0, & size);
#line 130
  tmp = xmalloc(size);
#line 130
  p = (char *)tmp;
#line 131
  sockaddr_to_str(sa, salen, p, size, (size_t *)((void *)0));
  }
#line 132
  return (p);
}
}
#line 365 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
#line 28 "/home/ysko/Works/test-src/pies-1.2/src/acl.h"
pies_acl_t pies_acl_create(char const   *name , grecs_locus_t *locus ) ;
#line 30
int parse_acl_line(grecs_locus_t *locus , int allow , pies_acl_t acl , grecs_value_t *value ) ;
#line 32
pies_acl_t pies_acl_lookup(char const   *name ) ;
#line 33
int pies_acl_install(pies_acl_t acl , grecs_locus_t *locus ) ;
#line 58 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
pies_acl_t pies_acl_create(char const   *name , grecs_locus_t *locus ) 
{ 
  pies_acl_t acl ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 61
  tmp = xmalloc((size_t )sizeof(*(acl + 0)));
#line 61
  acl = (pies_acl_t )tmp;
  }
#line 62
  if (name) {
    {
#line 62
    tmp___0 = xstrdup(name);
#line 62
    acl->name = tmp___0;
    }
  } else {
#line 62
    acl->name = (char *)((void *)0);
  }
  {
#line 63
  acl->locus = *locus;
#line 64
  acl->list = gl_list_create_empty_inline(& gl_linked_list_implementation, (_Bool (*)(void const   *elt1 ,
                                                                                      void const   *elt2 ))((void *)0),
                                          (size_t (*)(void const   *elt ))((void *)0),
                                          (void (*)(void const   *elt ))((void *)0),
                                          (_Bool)0);
  }
#line 69
  return (acl);
}
}
#line 72 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static struct pies_sockaddr *create_acl_sockaddr(int family , int len ) 
{ 
  struct pies_sockaddr *p ;
  void *tmp ;

  {
  {
#line 75
  tmp = xzalloc((size_t )sizeof(*p));
#line 75
  p = (struct pies_sockaddr *)tmp;
#line 76
  p->salen = len;
#line 77
  p->sa.sa_family = (sa_family_t )family;
  }
#line 78
  return (p);
}
}
#line 84 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int _parse_token(struct acl_entry *entry , grecs_value_t const   *value ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 87
  tmp___1 = strcmp((char const   *)value->v.string, "all");
  }
#line 87
  if (! (tmp___1 == 0)) {
    {
#line 87
    tmp___2 = strcmp((char const   *)value->v.string, "any");
    }
#line 87
    if (! (tmp___2 == 0)) {
      {
#line 90
      tmp = strcmp((char const   *)value->v.string, "auth");
      }
#line 90
      if (tmp == 0) {
#line 92
        entry->authenticated = 1;
      } else {
        {
#line 90
        tmp___0 = strcmp((char const   *)value->v.string, "authenticated");
        }
#line 90
        if (tmp___0 == 0) {
#line 92
          entry->authenticated = 1;
        } else {
#line 94
          return (1);
        }
      }
    }
  }
#line 95
  return (0);
}
}
#line 98 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int _parse_sockaddr(struct acl_entry *entry , grecs_value_t const   *value ) 
{ 
  struct pies_sockaddr *sptr ;
  char const   *string ;
  int tmp ;
  size_t len ;
  struct sockaddr_un *s_un ;
  char *tmp___0 ;
  struct in_addr addr ;
  struct sockaddr_in *s_in ;
  char *p ;
  char *tmp___1 ;
  struct hostent *hp ;
  struct hostent *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *q ;
  unsigned int netlen ;
  unsigned long tmp___6 ;
  struct in_addr addr___0 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 104
  tmp = assert_grecs_value_type(& entry->locus, value, 0);
  }
#line 104
  if (tmp) {
#line 105
    return (1);
  }
#line 107
  string = (char const   *)value->v.string;
#line 109
  if ((int const   )*(string + 0) == 47) {
    {
#line 114
    len = strlen(string);
    }
#line 115
    if ((unsigned long )len >= sizeof(s_un->sun_path)) {
      {
#line 117
      tmp___0 = gettext("socket name too long: `%s\'");
#line 117
      grecs_error(& entry->locus, 0, (char const   *)tmp___0, string);
      }
#line 119
      return (1);
    }
    {
#line 121
    sptr = create_acl_sockaddr(1, (int )sizeof(s_un));
#line 122
    s_un = (struct sockaddr_un *)(& sptr->sa);
#line 123
    memcpy((void */* __restrict  */)(s_un->sun_path), (void const   */* __restrict  */)string,
           len);
#line 124
    s_un->sun_path[len] = (char)0;
    }
  } else {
    {
#line 130
    tmp___1 = strchr(string, '/');
#line 130
    p = tmp___1;
    }
#line 132
    if (p) {
#line 133
      *p = (char)0;
    }
    {
#line 135
    tmp___4 = inet_aton(string, & addr);
    }
#line 135
    if (tmp___4 == 0) {
      {
#line 137
      tmp___2 = gethostbyname(string);
#line 137
      hp = tmp___2;
      }
#line 138
      if (! hp) {
        {
#line 140
        tmp___3 = gettext("cannot resolve host name: `%s\'");
#line 140
        grecs_error(& entry->locus, 0, (char const   *)tmp___3, string);
        }
#line 142
        if (p) {
#line 143
          *p = (char )'/';
        }
#line 144
        return (1);
      }
      {
#line 146
      memcpy((void */* __restrict  */)(& addr.s_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
             (size_t )sizeof(addr.s_addr));
      }
    }
    {
#line 148
    addr.s_addr = ntohl(addr.s_addr);
#line 150
    sptr = create_acl_sockaddr(2, (int )sizeof(s_in));
#line 151
    s_in = (struct sockaddr_in *)(& sptr->sa);
#line 152
    s_in->sin_addr = addr;
    }
#line 154
    if (p) {
      {
#line 156
      tmp___5 = p;
#line 156
      p ++;
#line 156
      *tmp___5 = (char )'/';
#line 160
      tmp___6 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& q),
                        10);
#line 160
      netlen = (unsigned int )tmp___6;
      }
#line 161
      if ((int )*q == 0) {
#line 163
        if (netlen == 0U) {
#line 164
          sptr->netmask = 0U;
        } else {
#line 167
          sptr->netmask = (unsigned int )(4294967295UL >> (32U - netlen));
#line 168
          sptr->netmask <<= 32U - netlen;
        }
      } else
#line 171
      if ((int )*q == 46) {
        {
#line 175
        tmp___8 = inet_aton((char const   *)p, & addr___0);
        }
#line 175
        if (tmp___8 == 0) {
          {
#line 177
          tmp___7 = gettext("invalid netmask: `%s\'");
#line 177
          grecs_error(& entry->locus, 0, (char const   *)tmp___7, p);
          }
#line 179
          return (1);
        }
#line 181
        sptr->netmask = addr___0.s_addr;
      } else {
        {
#line 185
        tmp___9 = gettext("invalid netmask: `%s\'");
#line 185
        grecs_error(& entry->locus, 0, (char const   *)tmp___9, p);
        }
#line 186
        return (1);
      }
    } else {
#line 190
      sptr->netmask = 4294967295U;
    }
  }
  {
#line 192
  gl_list_add_last_inline(entry->sockaddrs, (void const   *)sptr);
  }
#line 193
  return (0);
}
}
#line 196 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int _parse_from(struct acl_entry *entry , size_t argc , grecs_value_t const   *argv ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp___4 ;
  void const   *p ;
  int rc ;
  int tmp___5 ;
  _Bool tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 199
  if (argc == 0U) {
#line 200
    return (0);
  } else
#line 201
  if (argv->type == 1) {
    {
#line 203
    tmp = gettext("expected `from\', but found list");
#line 203
    grecs_error(& entry->locus, 0, (char const   *)tmp);
    }
#line 204
    return (1);
  } else {
    {
#line 206
    tmp___1 = strcmp((char const   *)argv->v.string, "from");
    }
#line 206
    if (tmp___1) {
      {
#line 208
      tmp___0 = gettext("expected `from\', but found `%s\'");
#line 208
      grecs_error(& entry->locus, 0, (char const   *)tmp___0, argv->v.string);
      }
#line 210
      return (1);
    }
  }
#line 212
  argc --;
#line 213
  argv ++;
#line 215
  if (argc == 0U) {
    {
#line 217
    tmp___2 = gettext("unexpected end of statement after `from\'");
#line 217
    grecs_error(& entry->locus, 0, (char const   *)tmp___2);
    }
#line 219
    return (1);
  }
  {
#line 222
  entry->sockaddrs = gl_list_create_empty_inline(& gl_linked_list_implementation,
                                                 (_Bool (*)(void const   *elt1 , void const   *elt2 ))((void *)0),
                                                 (size_t (*)(void const   *elt ))((void *)0),
                                                 (void (*)(void const   *elt ))((void *)0),
                                                 (_Bool)0);
  }
#line 227
  if (argv->type == 0) {
    {
#line 229
    tmp___3 = _parse_sockaddr(entry, argv);
    }
#line 229
    if (tmp___3) {
#line 230
      return (1);
    }
  } else {
    {
#line 234
    tmp___4 = gl_list_iterator_inline((gl_list_t )argv->v.list);
#line 234
    itr = tmp___4;
#line 236
    rc = 0;
    }
    {
#line 237
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 237
      tmp___6 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
      }
#line 237
      if (! tmp___6) {
#line 237
        goto while_break;
      }
      {
#line 238
      tmp___5 = _parse_sockaddr(entry, (grecs_value_t const   *)p);
#line 238
      rc += tmp___5;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 239
    gl_list_iterator_free_inline(& itr);
    }
#line 240
    if (rc) {
#line 241
      return (rc);
    }
  }
#line 244
  if (argc - 1U) {
    {
#line 246
    tmp___7 = gettext("junk after `from\' list");
#line 246
    grecs_warning(& entry->locus, 0, (char const   *)tmp___7);
    }
#line 247
    return (1);
  }
#line 249
  return (0);
}
}
#line 252 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int _parse_sub_acl(struct acl_entry *entry , size_t argc , grecs_value_t *argv ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 255
  if (argc == 0U) {
#line 256
    return (0);
  }
  {
#line 257
  tmp___2 = strcmp(argv->v.string, "acl");
  }
#line 257
  if (tmp___2 == 0) {
#line 259
    argc --;
#line 260
    argv ++;
#line 261
    if (argc == 0U) {
      {
#line 263
      tmp = gettext("expected ACL name, but found end of statement");
#line 263
      grecs_error(& entry->locus, 0, (char const   *)tmp);
      }
#line 265
      return (1);
    }
#line 268
    if (argv->type != 0) {
      {
#line 270
      tmp___0 = gettext("expected string, but found list");
#line 270
      grecs_error(& entry->locus, 0, (char const   *)tmp___0);
      }
#line 272
      return (1);
    }
    {
#line 275
    entry->acl = pies_acl_lookup(argv->v.string);
    }
#line 277
    if (! entry->acl) {
      {
#line 279
      tmp___1 = gettext("ACL not defined: `%s\'");
#line 279
      grecs_error(& entry->locus, 0, (char const   *)tmp___1, argv->v.string);
      }
#line 281
      return (1);
    }
#line 283
    argc --;
#line 284
    argv ++;
  }
  {
#line 286
  tmp___3 = _parse_from(entry, argc, (grecs_value_t const   *)argv);
  }
#line 286
  return (tmp___3);
}
}
#line 289 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int _parse_group(struct acl_entry *entry , size_t argc , grecs_value_t *argv ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 292
  tmp___0 = strcmp(argv->v.string, "group");
  }
#line 292
  if (tmp___0 == 0) {
#line 294
    argc --;
#line 295
    argv ++;
#line 296
    if (argc == 0U) {
      {
#line 298
      tmp = gettext("expected group list, but found end of statement");
#line 298
      grecs_error(& entry->locus, 0, (char const   *)tmp);
      }
#line 300
      return (1);
    }
#line 302
    if (argv->type == 0) {
      {
#line 304
      entry->groups = gl_list_create_empty_inline(& gl_linked_list_implementation,
                                                  (_Bool (*)(void const   *elt1 ,
                                                             void const   *elt2 ))((void *)0),
                                                  (size_t (*)(void const   *elt ))((void *)0),
                                                  (void (*)(void const   *elt ))((void *)0),
                                                  (_Bool)0);
#line 309
      gl_list_add_last_inline(entry->groups, (void const   *)((void *)argv->v.string));
      }
    } else {
#line 312
      entry->groups = argv->v.list;
    }
#line 313
    argc --;
#line 314
    argv ++;
  }
  {
#line 316
  tmp___1 = _parse_sub_acl(entry, argc, argv);
  }
#line 316
  return (tmp___1);
}
}
#line 319 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int _parse_acl(struct acl_entry *entry , size_t argc , grecs_value_t *argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 322
  tmp___2 = assert_grecs_value_type(& entry->locus, (grecs_value_t const   *)argv,
                                    0);
  }
#line 322
  if (tmp___2) {
#line 323
    return (1);
  } else {
    {
#line 324
    tmp___1 = _parse_token(entry, (grecs_value_t const   *)argv);
    }
#line 324
    if (tmp___1 == 0) {
      {
#line 325
      tmp = _parse_sub_acl(entry, argc - 1U, argv + 1);
      }
#line 325
      return (tmp);
    } else {
      {
#line 327
      tmp___0 = _parse_group(entry, argc, argv);
      }
#line 327
      return (tmp___0);
    }
  }
}
}
#line 330 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
int parse_acl_line(grecs_locus_t *locus , int allow , pies_acl_t acl , grecs_value_t *value ) 
{ 
  struct acl_entry *entry ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 334
  tmp = xzalloc((size_t )sizeof(*entry));
#line 334
  entry = (struct acl_entry *)tmp;
#line 336
  entry->locus = *locus;
#line 337
  entry->allow = allow;
  }
  {
#line 341
  if (value->type == 0) {
#line 341
    goto case_0;
  }
#line 350
  if (value->type == 2) {
#line 350
    goto case_2;
  }
#line 355
  if (value->type == 1) {
#line 355
    goto case_1;
  }
#line 339
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 342
  tmp___1 = _parse_token(entry, (grecs_value_t const   *)value);
  }
#line 342
  if (tmp___1) {
    {
#line 344
    tmp___0 = gettext("unknown word `%s\'");
#line 344
    grecs_error(& entry->locus, 0, (char const   *)tmp___0, value->v.string);
    }
#line 346
    return (1);
  }
#line 348
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 351
  tmp___2 = _parse_acl(entry, value->v.arg.c, value->v.arg.v);
  }
#line 351
  if (tmp___2) {
#line 352
    return (1);
  }
#line 353
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 356
  tmp___3 = gettext("unexpected list");
#line 356
  grecs_error(locus, 0, (char const   *)tmp___3);
  }
#line 357
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 359
  gl_list_add_last_inline(acl->list, (void const   *)entry);
  }
#line 360
  return (0);
}
}
#line 368 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
int _acl_common_section_parser(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                               grecs_value_t *value , pies_acl_t *pacl , int flag ) 
{ 
  pies_acl_t acl ;
  grecs_locus_t defn_loc ;
  char const   *tag ;
  int has_value ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 377
  tag = (char const   *)((void *)0);
#line 378
  has_value = 0;
  {
#line 382
  if ((unsigned int )cmd == 0U) {
#line 382
    goto case_0;
  }
#line 429
  if ((unsigned int )cmd == 2U) {
#line 429
    goto case_2___0;
  }
#line 429
  if ((unsigned int )cmd == 1U) {
#line 429
    goto case_2___0;
  }
#line 380
  goto switch_break;
  case_0: /* CIL Label */ 
#line 383
  if (value) {
#line 385
    if (value->type != 0) {
      {
#line 387
      tmp = gettext("ACL name must be a string");
#line 387
      grecs_error(locus, 0, (char const   *)tmp);
      }
#line 388
      return (1);
    }
#line 390
    has_value = (unsigned long )value->v.string != (unsigned long )((void *)0);
  }
#line 392
  if (has_value) {
    {
#line 396
    if (flag == 0) {
#line 396
      goto case_0___0;
    }
#line 400
    if (flag == 1) {
#line 400
      goto case_1;
    }
#line 405
    if (flag == 3) {
#line 405
      goto case_3;
    }
#line 405
    if (flag == 2) {
#line 405
      goto case_3;
    }
#line 394
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 397
    tmp___0 = gettext("ACL name is not expected");
#line 397
    grecs_error(locus, 0, (char const   *)tmp___0);
    }
#line 398
    return (1);
    case_1: /* CIL Label */ 
    {
#line 401
    tmp___1 = gettext("ACL name is ignored");
#line 401
    grecs_warning(locus, 0, (char const   *)tmp___1);
    }
#line 402
    goto switch_break___0;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 406
    tag = value->v.string;
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 409
  if (flag == 3) {
    {
#line 411
    tmp___2 = gettext("missing ACL name");
#line 411
    grecs_error(locus, 0, (char const   *)tmp___2);
    }
#line 412
    return (1);
  }
  {
#line 414
  acl = pies_acl_create(tag, locus);
  }
#line 415
  if (tag) {
    {
#line 415
    tmp___5 = pies_acl_install(acl, & defn_loc);
    }
#line 415
    if (tmp___5) {
      {
#line 417
      tmp___3 = gettext("redefinition of ACL %s");
#line 417
      grecs_error(locus, 0, (char const   *)tmp___3, value->v.string);
#line 420
      tmp___4 = gettext("location of the previous definition");
#line 420
      grecs_error(& defn_loc, 0, (char const   *)tmp___4);
      }
#line 422
      return (1);
    }
  }
#line 424
  if (pacl) {
#line 425
    *pacl = acl;
  }
#line 426
  goto switch_break;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 430
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 432
  return (0);
}
}
#line 435 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
int acl_section_parser(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                       grecs_value_t *value , void *cb_data ) 
{ 
  int rc ;
  int tmp ;

  {
  {
#line 442
  tmp = _acl_common_section_parser(cmd, locus, value, (pies_acl_t *)varptr, 0);
#line 442
  rc = tmp;
  }
#line 444
  if (rc == 0) {
#line 445
    *((void **)cb_data) = (void *)*((pies_acl_t *)varptr);
  }
#line 446
  return (rc);
}
}
#line 449 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
int defacl_section_parser(enum grecs_callback_command cmd , grecs_locus_t *locus ,
                          void *varptr , grecs_value_t *value , void *cb_data ) 
{ 
  int tmp ;

  {
  {
#line 456
  tmp = _acl_common_section_parser(cmd, locus, value, (pies_acl_t *)cb_data, 3);
  }
#line 456
  return (tmp);
}
}
#line 460 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int allow_cb(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                    grecs_value_t *value , void *cb_data ) 
{ 
  pies_acl_t acl ;
  char *tmp ;
  char *__cil_tmp8 ;

  {
#line 467
  acl = (pies_acl_t )varptr;
#line 469
  if ((unsigned int )cmd != 2U) {
    {
#line 471
    tmp = gettext("unexpected block statement");
#line 471
    grecs_error(locus, 0, (char const   *)tmp);
    }
#line 472
    return (1);
  }
  {
#line 474
  parse_acl_line(locus, 1, acl, value);
  }
#line 475
  return (0);
}
}
#line 478 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int deny_cb(enum grecs_callback_command cmd , grecs_locus_t *locus , void *varptr ,
                   grecs_value_t *value , void *cb_data ) 
{ 
  pies_acl_t acl ;
  char *tmp ;
  char *__cil_tmp8 ;

  {
#line 485
  acl = (pies_acl_t )varptr;
#line 486
  if ((unsigned int )cmd != 2U) {
    {
#line 488
    tmp = gettext("unexpected block statement");
#line 488
    grecs_error(locus, 0, (char const   *)tmp);
    }
#line 489
    return (1);
  }
  {
#line 491
  parse_acl_line(locus, 0, acl, value);
  }
#line 492
  return (0);
}
}
#line 495 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
struct grecs_keyword acl_keywords[3]  = {      {"allow", "[all|authenticated|group <grp: list>] [from <addr: list>]", "Allow access",
      (enum grecs_data_type )1, (void *)0, (size_t )0, & allow_cb, (void *)0, (struct grecs_keyword *)0}, 
        {"deny",
      "[all|authenticated|group <grp: list>] [from <addr: list>]", "Deny access",
      (enum grecs_data_type )1, (void *)0, (size_t )0, & deny_cb, (void *)0, (struct grecs_keyword *)0}, 
        {(char const   *)((void *)0),
      (char const   *)0, (char const   *)0, 0U, (void *)0, 0U, (int (*)(enum grecs_callback_command cmd ,
                                                                        grecs_locus_t * ,
                                                                        void * , grecs_value_t * ,
                                                                        void * ))0,
      (void *)0, (struct grecs_keyword *)0}};
#line 517 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int _check_sockaddr(struct pies_sockaddr *sptr , struct acl_input *input ) 
{ 
  struct sockaddr_in *sin_clt ;
  struct sockaddr_in *sin_item ;
  uint32_t tmp ;
  struct sockaddr_un *sun_clt ;
  struct sockaddr_un *sun_item ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 520
  if ((int )sptr->sa.sa_family != (int )(input->addr)->sa_family) {
#line 521
    return (0);
  }
  {
#line 525
  if ((int )sptr->sa.sa_family == 2) {
#line 525
    goto case_2;
  }
#line 536
  if ((int )sptr->sa.sa_family == 1) {
#line 536
    goto case_1;
  }
#line 523
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 527
  sin_clt = (struct sockaddr_in *)input->addr;
#line 528
  sin_item = (struct sockaddr_in *)(& sptr->sa);
#line 530
  tmp = ntohl(sin_clt->sin_addr.s_addr);
  }
#line 530
  if (sin_item->sin_addr.s_addr == (tmp & sptr->netmask)) {
#line 532
    return (1);
  }
#line 533
  goto switch_break;
  case_1: /* CIL Label */ 
#line 538
  sun_clt = (struct sockaddr_un *)input->addr;
#line 539
  sun_item = (struct sockaddr_un *)(& sptr->sa);
#line 541
  if ((unsigned long )input->addrlen < (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)) {
#line 541
    tmp___0 = "";
  } else {
#line 541
    tmp___0 = (char const   *)(sun_clt->sun_path);
  }
#line 541
  if (*(tmp___0 + 0)) {
#line 541
    if ((unsigned long )sptr->salen < (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)) {
#line 541
      tmp___1 = "";
    } else {
#line 541
      tmp___1 = (char const   *)(sun_item->sun_path);
    }
#line 541
    if (*(tmp___1 + 0)) {
      {
#line 541
      tmp___2 = strcmp((char const   *)(sun_clt->sun_path), (char const   *)(sun_item->sun_path));
      }
#line 541
      if (tmp___2 == 0) {
#line 544
        return (1);
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 547
  return (0);
}
}
#line 550 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int match_group(char const   **groups , char const   *arg___0 ) 
{ 
  int tmp ;

  {
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if (! *groups) {
#line 553
      goto while_break;
    }
    {
#line 554
    tmp = strcmp(*groups, arg___0);
    }
#line 554
    if (tmp == 0) {
#line 555
      return (1);
    }
#line 553
    groups ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return (0);
}
}
#line 559 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int _acl_check(struct acl_entry *ent , struct acl_input *input ) 
{ 
  int result ;
  void const   *p ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp ;
  _Bool tmp___0 ;
  void const   *p___0 ;
  gl_list_iterator_t itr___0 ;
  gl_list_iterator_t tmp___1 ;
  _Bool tmp___2 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 562
  result = 1;
#line 564
  if (ent->authenticated) {
#line 566
    result = (unsigned long )input->user != (unsigned long )((void *)0);
#line 567
    if (! result) {
#line 568
      return (result);
    }
  }
#line 571
  if (ent->groups) {
    {
#line 574
    tmp = gl_list_iterator_inline(ent->groups);
#line 574
    itr = tmp;
    }
    {
#line 575
    while (1) {
      while_continue: /* CIL Label */ ;
#line 575
      if (result) {
        {
#line 575
        tmp___0 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
        }
#line 575
        if (! tmp___0) {
#line 575
          goto while_break;
        }
      } else {
#line 575
        goto while_break;
      }
      {
#line 576
      result = match_group(input->groups, (char const   *)p);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 577
    gl_list_iterator_free_inline(& itr);
    }
#line 578
    if (! result) {
#line 579
      return (result);
    }
  }
  {
#line 582
  result = pies_acl_check(ent->acl, input, 1);
  }
#line 583
  if (! result) {
#line 584
    return (result);
  }
#line 586
  if (ent->sockaddrs) {
    {
#line 589
    tmp___1 = gl_list_iterator_inline(ent->sockaddrs);
#line 589
    itr___0 = tmp___1;
#line 590
    result = 0;
    }
    {
#line 591
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 591
      tmp___2 = gl_list_iterator_next_inline(& itr___0, & p___0, (gl_list_node_t *)((void *)0));
      }
#line 591
      if (! tmp___2) {
#line 591
        goto while_break___0;
      }
      {
#line 593
      result = _check_sockaddr((struct pies_sockaddr *)p___0, input);
      }
#line 594
      if (result) {
#line 595
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 597
    gl_list_iterator_free_inline(& itr___0);
    }
  }
#line 600
  return (result);
}
}
#line 603 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static int _acl_check_cb(struct acl_entry *ent , struct acl_input *input , int *pres ) 
{ 
  int result ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 606
  tmp = _acl_check(ent, input);
#line 606
  result = tmp;
  }
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if (debug_level >= 1U) {
#line 607
      if (source_info_option) {
        {
#line 607
        logmsg_printf(7, "%s:%lu:%s: ", "/home/ysko/Works/test-src/pies-1.2/src/acl.c",
                      610, "_acl_check_cb");
        }
      }
#line 607
      if (result) {
        {
#line 607
        tmp___0 = gettext("MATCHES");
#line 607
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 607
        tmp___1 = gettext("does not match");
#line 607
        tmp___2 = tmp___1;
        }
      }
      {
#line 607
      debug_msg("%s:%d: %s", ent->locus.file, ent->locus.line, tmp___2);
      }
    }
#line 607
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 612
  if (result) {
#line 614
    *pres = ent->allow;
#line 615
    return (1);
  }
#line 617
  return (0);
}
}
#line 620 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
int pies_acl_check(pies_acl_t acl , struct acl_input *input , int result ) 
{ 
  void const   *p ;
  gl_list_iterator_t itr ;
  gl_list_iterator_t tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
#line 623
  if (acl) {
    {
#line 626
    tmp = gl_list_iterator_inline(acl->list);
#line 626
    itr = tmp;
    }
    {
#line 627
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 627
      tmp___0 = gl_list_iterator_next_inline(& itr, & p, (gl_list_node_t *)((void *)0));
      }
#line 627
      if (tmp___0) {
        {
#line 627
        tmp___1 = _acl_check_cb((struct acl_entry *)p, input, & result);
        }
#line 627
        if (tmp___1) {
#line 627
          goto while_break;
        }
      } else {
#line 627
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 630
    gl_list_iterator_free_inline(& itr);
    }
  }
#line 632
  return (result);
}
}
#line 638 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static Hash_table *acl_table  ;
#line 641 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static size_t acl_hasher(void const   *data , size_t n_buckets ) 
{ 
  struct pies_acl  const  *p ;
  size_t tmp ;

  {
  {
#line 644
  p = (struct pies_acl  const  *)data;
#line 645
  tmp = hash_string((char const   *)p->name, n_buckets);
  }
#line 645
  return (tmp);
}
}
#line 649 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
static _Bool acl_compare(void const   *data1 , void const   *data2 ) 
{ 
  struct pies_acl  const  *p1 ;
  struct pies_acl  const  *p2 ;
  int tmp ;

  {
  {
#line 652
  p1 = (struct pies_acl  const  *)data1;
#line 653
  p2 = (struct pies_acl  const  *)data2;
#line 654
  tmp = strcasecmp((char const   *)p1->name, (char const   *)p2->name);
  }
#line 654
  return ((_Bool )(tmp == 0));
}
}
#line 657 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
int pies_acl_install(pies_acl_t acl , grecs_locus_t *locus ) 
{ 
  pies_acl_t ret ;
  void *tmp ;

  {
#line 661
  if (acl_table) {
#line 661
    goto _L;
  } else {
    {
#line 661
    acl_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & acl_hasher,
                                & acl_compare, (void (*)(void * ))0);
    }
#line 661
    if (acl_table) {
      _L: /* CIL Label */ 
      {
#line 661
      tmp = hash_insert(acl_table, (void const   *)acl);
#line 661
      ret = (pies_acl_t )tmp;
      }
#line 661
      if (! ret) {
        {
#line 666
        xalloc_die();
        }
      }
    } else {
      {
#line 666
      xalloc_die();
      }
    }
  }
#line 668
  if ((unsigned long )ret != (unsigned long )acl) {
#line 670
    if (locus) {
#line 671
      *locus = ret->locus;
    }
#line 672
    return (1);
  }
#line 674
  return (0);
}
}
#line 677 "/home/ysko/Works/test-src/pies-1.2/src/acl.c"
pies_acl_t pies_acl_lookup(char const   *name ) 
{ 
  struct pies_acl samp ;
  void *tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
#line 681
  if (! acl_table) {
#line 682
    return ((pies_acl_t )((void *)0));
  }
  {
#line 683
  samp.name = (char *)name;
#line 684
  tmp = hash_lookup((Hash_table const   *)acl_table, (void const   *)(& samp));
  }
#line 684
  return ((pies_acl_t )tmp);
}
}
