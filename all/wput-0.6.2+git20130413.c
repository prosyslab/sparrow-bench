/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 27 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.h"
struct _proxy_settings {
   unsigned int ip ;
   unsigned short port ;
   char *user ;
   char *pass ;
   unsigned int bind : 1 ;
   unsigned int type : 2 ;
};
#line 27 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.h"
typedef struct _proxy_settings proxy_settings;
#line 36 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.h"
struct _wput_socket {
   int fd ;
};
#line 36 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.h"
typedef struct _wput_socket wput_socket;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
struct _ftp_reply {
   unsigned short code ;
   char *reply ;
   char *message ;
};
#line 7 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
typedef struct _ftp_reply ftp_reply;
#line 13 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
struct _host_type {
   unsigned int ip ;
   char *hostname ;
   unsigned short port ;
};
#line 13 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
typedef struct _host_type host_t;
#line 19
enum stype {
    ST_UNIX = 0,
    ST_VMS = 1,
    ST_WINNT = 2,
    ST_MACOS = 3,
    ST_OS400 = 4,
    ST_OTHER = 5,
    ST_UNDEFINED = 6
} ;
#line 30
enum ftype {
    FT_PLAINFILE = 0,
    FT_DIRECTORY = 1,
    FT_SYMLINK = 2,
    FT_UNKNOWN = 3
} ;
#line 38 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
struct fileinfo {
   enum ftype type ;
   char *name ;
   off_t size ;
   time_t tstamp ;
   int perms ;
   char *linkto ;
   struct fileinfo *prev ;
   struct fileinfo *next ;
};
#line 50 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
struct _directory_list {
   char *name ;
   struct fileinfo *list ;
   struct _directory_list *next ;
};
#line 50 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
typedef struct _directory_list directory_list;
#line 56 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
struct _ftp_connection {
   host_t *host ;
   char *user ;
   char *pass ;
   wput_socket *sock ;
   wput_socket *datasock ;
   wput_socket *servsock ;
   ftp_reply r ;
   char *sbuf ;
   int sbuflen ;
   proxy_settings *ps ;
   directory_list *directorylist ;
   char *current_directory ;
   unsigned int local_ip ;
   unsigned int bindaddr ;
   unsigned char needcwd : 1 ;
   unsigned char loggedin : 1 ;
   unsigned char portmode : 1 ;
   char current_type : 2 ;
   unsigned char secure : 2 ;
   enum stype OS ;
};
#line 56 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
typedef struct _ftp_connection ftp_con;
#line 7 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.h"
struct __resume_table {
   unsigned char small_large : 1 ;
   unsigned char large_large : 1 ;
   unsigned char large_small : 2 ;
};
#line 7 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.h"
typedef struct __resume_table _resume_table;
#line 16 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.h"
struct ftp_session {
   char *user ;
   char *pass ;
   host_t *host ;
   ftp_con *ftp ;
   char *local_fname ;
   char *target_dname ;
   char *target_fname ;
   off_t local_fsize ;
   off_t target_fsize ;
   time_t local_ftime ;
   time_t target_ftime ;
   short retry ;
   _resume_table *resume_table ;
   unsigned char done : 1 ;
   char binary : 2 ;
   struct fileinfo *directory ;
   struct ftp_session *next ;
};
#line 16 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.h"
typedef struct ftp_session _fsession;
#line 65 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.h"
struct _skipd_list {
   int ip ;
   char *host ;
   unsigned short port ;
   char *user ;
   char *pass ;
   char *dir ;
   struct _skipd_list *next ;
};
#line 65 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.h"
typedef struct _skipd_list skipd_list;
#line 75 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.h"
struct _password_list {
   char *host ;
   char *user ;
   char *pass ;
   struct _password_list *next ;
};
#line 75 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.h"
typedef struct _password_list password_list;
#line 82
struct wput_timer;
#line 82 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.h"
struct global_options {
   char *sbuf ;
   int sbuflen ;
   unsigned int bindaddr ;
   proxy_settings ps ;
   ftp_con *curftp ;
   char *email_address ;
   skipd_list *skipdlist ;
   char *last_url ;
   password_list *pl ;
   _resume_table resume_table ;
   unsigned char random_wait : 1 ;
   unsigned char portmode : 1 ;
   char binary : 2 ;
   unsigned char proxy : 2 ;
   unsigned char sorturls : 1 ;
   unsigned char unlink : 1 ;
   unsigned char proxy_bind : 1 ;
   unsigned char timestamping : 1 ;
   char time_offset : 6 ;
   unsigned char background : 1 ;
   unsigned char barstyle : 1 ;
   unsigned char verbose : 3 ;
   unsigned char tls : 2 ;
   unsigned char no_directories : 1 ;
   short time_deviation ;
   char *basename ;
   FILE *output ;
   FILE *input ;
   char *input_pipe ;
   short wait ;
   short retry ;
   mode_t chmod ;
   unsigned char wdel ;
   struct wput_timer *session_start ;
   off_t transfered_bytes ;
   int files_transfered ;
   unsigned short transfered ;
   unsigned short failed ;
   unsigned short skipped ;
   unsigned short retry_interval ;
   unsigned int speed_limit ;
};
#line 25 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/netrc.h"
struct _acc_t {
   char *host ;
   char *acc ;
   char *passwd ;
   struct _acc_t *next ;
};
#line 25 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/netrc.h"
typedef struct _acc_t acc_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 41 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
struct input_queue {
   char *url ;
   char *file ;
   struct input_queue *next ;
};
#line 41 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
typedef struct input_queue _queue;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 111 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/netrc.c"
enum __anonenum_last_token_56 {
    tok_nothing = 0,
    tok_account = 1,
    tok_login = 2,
    tok_macdef = 3,
    tok_machine = 4,
    tok_password = 5
} ;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 64 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
typedef struct timeval wput_sys_time;
#line 75 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
struct wput_timer {
   wput_sys_time start ;
};
#line 199 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
struct _bar {
   unsigned short bytes_per_dot ;
   unsigned short dots_per_line ;
   unsigned char spacing ;
   unsigned short dots ;
   char *last_rate ;
   char *last_eta ;
   unsigned long transfered ;
   int last_transfered[24] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 667 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 120
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.h"
void socket_set_default_timeout(int timeout ) ;
#line 58
int get_ip_addr(char *hostname , unsigned int *ip ) ;
#line 92 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
void ftp_quit(ftp_con *self ) ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.h"
int fsession_process_file(_fsession *fsession , ftp_con *ftp ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 82 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.h"
struct global_options opt  ;
#line 145
_fsession *fsession_queue_entry_point ;
#line 155
void readwputrc(char *f ) ;
#line 156
void read_password_file(char *f ) ;
#line 157
int read_urls(void) ;
#line 158
int set_option(char *com , char *val ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/netrc.h"
acc_t *parse_netrc(char const   *path ) ;
#line 35
void free_netrc(acc_t *l ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.h"
struct wput_timer *wtimer_alloc(void) ;
#line 17
void wtimer_reset(struct wput_timer *wt ) ;
#line 18
double wtimer_elapsed(struct wput_timer *wt ) ;
#line 20
char *time_str(void) ;
#line 27
char *calculate_transfer_rate(double time_diff , off_t tbytes , unsigned char sp ) ;
#line 5 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/_queue.h"
void queue_add_file(char *filename ) ;
#line 6
void queue_add_url(char *url ) ;
#line 8
void wdel_queue_add_entry(char *file , char *url ) ;
#line 9
void wdel_queue_add_file(char *filename ) ;
#line 10
void separate_urls(void) ;
#line 12
void queue_process(int force ) ;
#line 13
void process_missing(void) ;
#line 23
void skiplist_free(skipd_list *K ) ;
#line 24
void free_fsession(_fsession *F ) ;
#line 27
password_list *password_list_add(password_list *K , char *host , char *user , char *pass ) ;
#line 29
void password_list_free(password_list *K ) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.h"
int isspace(int c ) ;
#line 23
char *home_dir(void) ;
#line 24
int file_exists(char const   *filename ) ;
#line 25
char *read_line(FILE *fp ) ;
#line 30
void Abort(char *msg ) ;
#line 31
void printout(unsigned char verbose , char const   *fmt  , ...) ;
#line 38
char *cpy(char *s ) ;
#line 43
char *legible(off_t l ) ;
#line 50
void parse_proxy(char *url ) ;
#line 62 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
static char const   *version  =    "0.6.2";
#line 65 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
_fsession *fsession_queue_entry_point  =    (_fsession *)((void *)0);
#line 67
void commandlineoptions(int argc , char **argv ) ;
#line 71
void read_netrc_file(void) ;
#line 73 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
int main(int argc , char **argv ) 
{ 
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __pid_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int res ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  double tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;

  {
  {
#line 88
  signal(13, (void (*)(int  ))1);
#line 94
  setlocale(5, "");
#line 95
  setlocale(0, "");
#line 100
  bindtextdomain("wput", "/usr/local/share/locale");
#line 101
  textdomain("wput");
#line 106
  memset((void *)(& opt), 0, sizeof(opt));
#line 113
  tmp = malloc((size_t )82);
#line 113
  opt.sbuf = (char *)tmp;
#line 114
  opt.retry = (short)-1;
#line 115
  opt.retry_interval = (unsigned short)10;
#line 116
  opt.time_deviation = (short)10;
#line 117
  opt.binary = (char)-1;
#line 118
  opt.chmod = (mode_t )0;
#line 119
  opt.output = stdout;
#line 121
  opt.verbose = (unsigned char)2;
#line 122
  opt.bindaddr = (in_addr_t )0;
#line 123
  opt.barstyle = (unsigned char)1;
#line 124
  opt.ps.bind = 1U;
#line 125
  opt.session_start = wtimer_alloc();
#line 127
  opt.resume_table.small_large = (unsigned char)1;
#line 128
  opt.resume_table.large_large = (unsigned char)0;
#line 129
  opt.resume_table.large_small = (unsigned char)2;
#line 131
  opt.email_address = cpy((char *)"wput@localhost.com");
#line 133
  tmp___0 = strlen((char const   *)*(argv + 0));
#line 133
  tmp___1 = strncmp((char const   *)(*(argv + 0) + (tmp___0 - 4UL)), "wdel", (size_t )5);
  }
#line 133
  if (! tmp___1) {
#line 134
    opt.wdel = (unsigned char)1;
  }
  {
#line 138
  readwputrc((char *)"/etc/wputrc");
#line 140
  readwputrc((char *)((void *)0));
#line 141
  tmp___2 = getenv("WPUTRC");
#line 141
  readwputrc(tmp___2);
#line 143
  tmp___3 = getenv("ftp_proxy");
#line 143
  parse_proxy(tmp___3);
#line 145
  read_netrc_file();
#line 146
  tmp___4 = getenv("PASSWORDFILE");
#line 146
  read_password_file(tmp___4);
#line 148
  wtimer_reset(opt.session_start);
#line 150
  commandlineoptions(argc, argv);
  }
#line 154
  if (opt.background) {
#line 155
    if ((unsigned long )opt.output == (unsigned long )stdout) {
      {
#line 156
      tmp___5 = gettext("Resuming in background. Logging output to \'wput-log\'.\n");
#line 156
      printout((unsigned char)1, (char const   *)tmp___5);
#line 157
      opt.output = fopen((char const   */* __restrict  */)"wput-log", (char const   */* __restrict  */)"a");
      }
#line 158
      if ((unsigned long )opt.output == (unsigned long )((void *)0)) {
        {
#line 158
        tmp___6 = gettext("Unable to open logfile");
#line 158
        perror((char const   *)tmp___6);
#line 158
        exit(4);
        }
      }
#line 159
      opt.barstyle = (unsigned char)0;
    } else {
      {
#line 161
      puts("Resuming in background.\n");
      }
    }
    {
#line 163
    tmp___7 = fork();
    }
#line 163
    if (tmp___7 > 0) {
      {
#line 163
      exit(0);
      }
    }
#line 165
    if (opt.input_pipe) {
      {
#line 166
      tmp___8 = gettext("Warning: ");
#line 166
      printout((unsigned char)2, (char const   *)tmp___8);
#line 167
      tmp___9 = gettext("background-mode might not work correctly, if the input-pipe needs to read from stdin (like cat -).\n");
#line 167
      printout((unsigned char)2, (char const   *)tmp___9);
      }
    }
#line 169
    if ((unsigned long )opt.input != (unsigned long )stdin) {
      {
#line 171
      setsid();
#line 172
      freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
              (FILE */* __restrict  */)stdin);
#line 173
      freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
              (FILE */* __restrict  */)stdout);
#line 174
      freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
              (FILE */* __restrict  */)stderr);
      }
    } else {
      {
#line 176
      tmp___10 = gettext("Warning: ");
#line 176
      printout((unsigned char)2, (char const   *)tmp___10);
#line 177
      tmp___11 = gettext("reading urls from stdin, while running in background-mode is not reliable.\n");
#line 177
      printout((unsigned char)2, (char const   *)tmp___11);
      }
    }
  }
#line 182
  if (opt.barstyle) {
    {
#line 182
    tmp___12 = fileno(stdout);
#line 182
    tmp___13 = isatty(tmp___12);
    }
#line 182
    if (! tmp___13) {
#line 183
      opt.barstyle = (unsigned char)0;
    }
  }
#line 185
  if (opt.ps.ip == 0U) {
#line 185
    goto _L;
  } else
#line 185
  if ((int )opt.ps.port == 0) {
    _L: /* CIL Label */ 
#line 185
    if (opt.ps.type != 0U) {
      {
#line 186
      tmp___14 = gettext("Warning: ");
#line 186
      printout((unsigned char)2, (char const   *)tmp___14);
#line 187
      tmp___15 = gettext("Ignoring request to turn proxy-usage on, since no proxy is configured.\n");
#line 187
      printout((unsigned char)2, (char const   *)tmp___15);
#line 188
      opt.ps.type = 0U;
      }
    }
  }
#line 192
  if (opt.wdel) {
    {
#line 192
    separate_urls();
    }
  }
#line 195
  if (! opt.wdel) {
    {
#line 195
    queue_process(0);
    }
  }
#line 198
  if ((unsigned long )opt.input != (unsigned long )((FILE *)0)) {
    {
#line 198
    read_urls();
    }
  }
#line 201
  if (! opt.wdel) {
    {
#line 201
    process_missing();
    }
  } else {
    {
#line 202
    queue_process(0);
    }
  }
#line 205
  if (opt.sorturls) {
    {
#line 206
    printout((unsigned char)4, "Transmitting sorted fsessions\n");
    }
    {
#line 207
    while (1) {
      while_continue: /* CIL Label */ ;
#line 207
      if (! ((unsigned long )fsession_queue_entry_point != (unsigned long )((void *)0))) {
#line 207
        goto while_break;
      }
      {
#line 208
      tmp___16 = fsession_process_file(fsession_queue_entry_point, opt.curftp);
#line 208
      res = tmp___16;
      }
#line 209
      if (res == -1) {
#line 209
        opt.failed = (unsigned short )((int )opt.failed + 1);
      } else
#line 210
      if (res == -2) {
#line 210
        opt.skipped = (unsigned short )((int )opt.skipped + 1);
      }
      {
#line 211
      opt.curftp = fsession_queue_entry_point->ftp;
#line 212
      free_fsession(fsession_queue_entry_point);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 217
  if (opt.curftp) {
    {
#line 217
    ftp_quit(opt.curftp);
    }
  }
#line 219
  if ((int )opt.transfered == 0) {
#line 219
    if ((int )opt.skipped == 0) {
#line 219
      if ((int )opt.failed == 0) {
        {
#line 220
        tmp___17 = gettext("Nothing done. Try `%s --help\'.\n");
#line 220
        printout((unsigned char)2, (char const   *)tmp___17, *(argv + 0));
        }
      } else {
        {
#line 222
        tmp___18 = time_str();
#line 222
        tmp___19 = gettext("FINISHED --%s--\n");
#line 222
        printout((unsigned char)2, (char const   *)tmp___19, tmp___18);
        }
      }
    } else {
      {
#line 222
      tmp___18 = time_str();
#line 222
      tmp___19 = gettext("FINISHED --%s--\n");
#line 222
      printout((unsigned char)2, (char const   *)tmp___19, tmp___18);
      }
    }
  } else {
    {
#line 222
    tmp___18 = time_str();
#line 222
    tmp___19 = gettext("FINISHED --%s--\n");
#line 222
    printout((unsigned char)2, (char const   *)tmp___19, tmp___18);
    }
  }
#line 224
  if ((int )opt.transfered > 0) {
#line 225
    if (! opt.wdel) {
      {
#line 226
      tmp___20 = wtimer_elapsed(opt.session_start);
#line 226
      tmp___21 = calculate_transfer_rate(tmp___20, opt.transfered_bytes, (unsigned char)0);
#line 226
      tmp___22 = legible(opt.transfered_bytes);
      }
#line 226
      if ((int )opt.transfered == 1) {
        {
#line 226
        tmp___23 = gettext("Transfered %s bytes in %d file at %s\n");
#line 226
        tmp___25 = tmp___23;
        }
      } else {
        {
#line 226
        tmp___24 = gettext("Transfered %s bytes in %d files at %s\n");
#line 226
        tmp___25 = tmp___24;
        }
      }
      {
#line 226
      printout((unsigned char)2, (char const   *)tmp___25, tmp___22, (int )opt.transfered,
               tmp___21);
      }
    } else {
#line 237
      if ((int )opt.transfered == 1) {
        {
#line 237
        tmp___26 = gettext("Deleted %d file\n");
#line 237
        tmp___28 = tmp___26;
        }
      } else {
        {
#line 237
        tmp___27 = gettext("Deleted %d files\n");
#line 237
        tmp___28 = tmp___27;
        }
      }
      {
#line 237
      printout((unsigned char)2, (char const   *)tmp___28, (int )opt.transfered);
      }
    }
  }
#line 244
  if ((int )opt.skipped > 0) {
#line 245
    if ((int )opt.skipped == 1) {
      {
#line 245
      tmp___29 = gettext("Skipped %d file.\n");
#line 245
      tmp___31 = tmp___29;
      }
    } else {
      {
#line 245
      tmp___30 = gettext("Skipped %d files.\n");
#line 245
      tmp___31 = tmp___30;
      }
    }
    {
#line 245
    printout((unsigned char)2, (char const   *)tmp___31, (int )opt.skipped);
    }
  }
#line 246
  if ((int )opt.failed > 0) {
#line 247
    if (! opt.wdel) {
#line 247
      if ((int )opt.failed == 1) {
        {
#line 247
        tmp___32 = gettext("Transmission of %d file failed.\n");
#line 247
        tmp___34 = tmp___32;
        }
      } else {
        {
#line 247
        tmp___33 = gettext("Transmission of %d files failed.\n");
#line 247
        tmp___34 = tmp___33;
        }
      }
#line 247
      tmp___38 = tmp___34;
    } else {
#line 247
      if ((int )opt.failed == 1) {
        {
#line 247
        tmp___35 = gettext("Deletion of %d file failed.\n");
#line 247
        tmp___37 = tmp___35;
        }
      } else {
        {
#line 247
        tmp___36 = gettext("Deletion of %d files failed.\n");
#line 247
        tmp___37 = tmp___36;
        }
      }
#line 247
      tmp___38 = tmp___37;
    }
    {
#line 247
    printout((unsigned char)2, (char const   *)tmp___38, (int )opt.failed);
    }
  }
  {
#line 252
  free((void *)opt.session_start);
#line 253
  free((void *)opt.email_address);
#line 254
  free((void *)opt.sbuf);
  }
#line 256
  if (opt.ps.pass) {
    {
#line 256
    free((void *)opt.ps.pass);
    }
  }
#line 257
  if (opt.ps.user) {
    {
#line 257
    free((void *)opt.ps.user);
    }
  }
#line 258
  if (opt.last_url) {
    {
#line 258
    free((void *)opt.last_url);
    }
  }
#line 260
  if (opt.pl) {
    {
#line 260
    password_list_free(opt.pl);
    }
  }
  {
#line 261
  skiplist_free(opt.skipdlist);
  }
#line 267
  return (((int )opt.failed != 0) * 2 | ((int )opt.skipped != 0));
}
}
#line 270 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
int read_urls(void) 
{ 
  char *url ;
  char *p ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 273
    p = read_line(opt.input);
#line 273
    url = p;
    }
#line 273
    if (! url) {
#line 273
      goto while_break;
    }
    {
#line 275
    printout((unsigned char)4, "read `%s\'\n", p);
    }
    {
#line 277
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 277
      tmp = isspace((int )*p);
      }
#line 277
      if (! tmp) {
#line 277
        goto while_break___0;
      }
#line 277
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 278
    if ((int )*p == 35) {
      {
#line 279
      free((void *)url);
      }
#line 280
      goto while_continue;
    }
    {
#line 284
    tmp___1 = strlen((char const   *)url);
    }
#line 284
    if ((int )*(url + (tmp___1 - 2UL)) == 13) {
      {
#line 285
      tmp___0 = strlen((char const   *)url);
#line 285
      *(url + (tmp___0 - 2UL)) = (char)0;
      }
    }
    {
#line 286
    tmp___2 = strlen((char const   *)url);
#line 286
    *(url + (tmp___2 - 1UL)) = (char)0;
#line 288
    tmp___7 = strncmp((char const   *)p, "ftp://", (size_t )6);
    }
#line 288
    if (tmp___7) {
#line 291
      if (opt.wdel) {
        {
#line 291
        tmp___6 = cpy(p);
#line 291
        wdel_queue_add_file(tmp___6);
        }
      } else {
        {
#line 291
        tmp___5 = cpy(p);
#line 291
        queue_add_file(tmp___5);
        }
      }
    } else
#line 289
    if (opt.wdel) {
      {
#line 289
      tmp___4 = cpy(p);
#line 289
      wdel_queue_add_entry((char *)((void *)0), tmp___4);
      }
    } else {
      {
#line 289
      tmp___3 = cpy(p);
#line 289
      queue_add_url(tmp___3);
      }
    }
    {
#line 293
    free((void *)url);
#line 295
    queue_process(0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return (0);
}
}
#line 300 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
int set_option(char *com , char *val ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *endptr ;
  mode_t m ;
  unsigned long tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char *levels[5] ;
  int i ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;

  {
  {
#line 301
  printout((unsigned char)4, "Setting option \'%s\' to \'%s\'\n", com, val);
  }
  {
#line 305
  if ((int )*com == 50) {
#line 305
    goto case_50;
  }
#line 305
  if ((int )*com == 49) {
#line 305
    goto case_50;
  }
#line 318
  if ((int )*com == 98) {
#line 318
    goto case_98;
  }
#line 328
  if ((int )*com == 99) {
#line 328
    goto case_99;
  }
#line 355
  if ((int )*com == 109) {
#line 355
    goto case_109;
  }
#line 360
  if ((int )*com == 112) {
#line 360
    goto case_112;
  }
#line 389
  if ((int )*com == 114) {
#line 389
    goto case_114;
  }
#line 403
  if ((int )*com == 115) {
#line 403
    goto case_115;
  }
#line 411
  if ((int )*com == 116) {
#line 411
    goto case_116;
  }
#line 429
  if ((int )*com == 118) {
#line 429
    goto case_118;
  }
#line 440
  if ((int )*com == 119) {
#line 440
    goto case_119;
  }
#line 303
  goto switch_break;
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  {
#line 306
  tmp___8 = strncmp((char const   *)com, "2_1", (size_t )4);
  }
#line 306
  if (tmp___8) {
    {
#line 311
    tmp___7 = strncmp((char const   *)com, "2_2", (size_t )4);
    }
#line 311
    if (tmp___7) {
      {
#line 313
      tmp___6 = strncmp((char const   *)com, "1_2", (size_t )4);
      }
#line 313
      if (tmp___6) {
#line 316
        return (-1);
      } else {
        {
#line 314
        tmp___5 = strncasecmp((char const   *)val, "UPLOAD", (size_t )7);
        }
#line 314
        if (tmp___5) {
#line 314
          opt.resume_table.small_large = (unsigned char)0;
        } else {
#line 314
          opt.resume_table.small_large = (unsigned char)1;
        }
      }
    } else {
      {
#line 312
      tmp___3 = strncasecmp((char const   *)val, "UPLOAD", (size_t )7);
      }
#line 312
      if (tmp___3) {
#line 312
        opt.resume_table.large_large = (unsigned char)0;
      } else {
#line 312
        opt.resume_table.large_large = (unsigned char)1;
      }
    }
  } else {
    {
#line 307
    tmp___1 = strncasecmp((char const   *)val, "SKIP", (size_t )5);
    }
#line 307
    if (tmp___1) {
      {
#line 310
      tmp___0 = strncasecmp((char const   *)val, "UPLOAD", (size_t )7);
      }
#line 310
      if (tmp___0) {
#line 310
        opt.resume_table.large_small = (unsigned char)2;
      } else {
#line 310
        opt.resume_table.large_small = (unsigned char)1;
      }
    } else {
#line 308
      opt.resume_table.large_small = (unsigned char)0;
    }
  }
#line 317
  return (0);
  case_98: /* CIL Label */ 
  {
#line 319
  tmp___13 = strncasecmp((char const   *)com, "bind-address", (size_t )13);
  }
#line 319
  if (tmp___13) {
#line 327
    return (-1);
  } else {
    {
#line 320
    tmp___12 = get_ip_addr(optarg, & opt.bindaddr);
    }
#line 320
    if (tmp___12 == -1) {
      {
#line 321
      tmp___9 = gettext("Error: ");
#line 321
      printout((unsigned char)3, (char const   *)tmp___9);
#line 322
      tmp___10 = gettext("`%s\' could not be resolved. ");
#line 322
      printout((unsigned char)3, (char const   *)tmp___10, optarg);
#line 323
      tmp___11 = gettext("Exiting.\n");
#line 323
      printout((unsigned char)1, (char const   *)tmp___11);
#line 324
      exit(4);
      }
    }
#line 326
    return (0);
  }
  case_99: /* CIL Label */ 
  {
#line 329
  tmp___18 = strncasecmp((char const   *)com, "connection_mode", (size_t )16);
  }
#line 329
  if (tmp___18) {
    {
#line 336
    tmp___17 = strncasecmp((char const   *)com, "chmod", (size_t )6);
    }
#line 336
    if (tmp___17) {
#line 345
      return (-1);
    } else {
#line 337
      if (opt.wdel) {
#line 337
        return (0);
      }
      {
#line 341
      tmp___16 = strtoul((char const   */* __restrict  */)val, (char **/* __restrict  */)(& endptr),
                         8);
#line 341
      m = (mode_t )tmp___16;
      }
#line 342
      if ((int )*endptr == 0) {
#line 342
        if ((m & 262143U) == m) {
#line 343
          opt.chmod = m;
        } else {
#line 344
          return (-2);
        }
      } else {
#line 344
        return (-2);
      }
    }
  } else {
    {
#line 330
    tmp___15 = strncasecmp((char const   *)val, "pasv", (size_t )5);
    }
#line 330
    if (tmp___15) {
      {
#line 332
      tmp___14 = strncasecmp((char const   *)val, "port", (size_t )4);
      }
#line 332
      if (tmp___14) {
#line 334
        return (-1);
      } else {
#line 333
        opt.portmode = (unsigned char)1;
      }
    } else {
#line 331
      opt.portmode = (unsigned char)0;
    }
  }
#line 346
  return (0);
  case_109: /* CIL Label */ 
  {
#line 356
  tmp___19 = strncmp((char const   *)com, "email_address", (size_t )13);
  }
#line 356
  if (tmp___19) {
#line 358
    return (-1);
  } else {
    {
#line 357
    opt.email_address = cpy(val);
    }
  }
#line 359
  return (0);
  case_112: /* CIL Label */ 
  {
#line 361
  tmp___36 = strncasecmp((char const   *)com, "proxy", (size_t )6);
  }
#line 361
  if (tmp___36) {
    {
#line 369
    tmp___35 = strncasecmp((char const   *)com, "proxy_host", (size_t )11);
    }
#line 369
    if (tmp___35) {
      {
#line 377
      tmp___34 = strncasecmp((char const   *)com, "proxy_port", (size_t )11);
      }
#line 377
      if (tmp___34) {
        {
#line 379
        tmp___33 = strncasecmp((char const   *)com, "proxy_user", (size_t )11);
        }
#line 379
        if (tmp___33) {
          {
#line 381
          tmp___32 = strncasecmp((char const   *)com, "proxy_pass", (size_t )11);
          }
#line 381
          if (tmp___32) {
            {
#line 383
            tmp___31 = strncasecmp((char const   *)com, "proxy_bind", (size_t )11);
            }
#line 383
            if (tmp___31) {
              {
#line 385
              tmp___29 = strncasecmp((char const   *)com, "passwordfile", (size_t )13);
              }
#line 385
              if (tmp___29) {
                {
#line 385
                tmp___30 = strncasecmp((char const   *)com, "password_file", (size_t )14);
                }
#line 385
                if (tmp___30) {
#line 387
                  return (-1);
                } else {
                  {
#line 386
                  read_password_file(val);
                  }
                }
              } else {
                {
#line 386
                read_password_file(val);
                }
              }
            } else {
              {
#line 384
              tmp___27 = strncasecmp((char const   *)val, "on", (size_t )3);
              }
#line 384
              if (tmp___27) {
#line 384
                tmp___28 = 0;
              } else {
#line 384
                tmp___28 = 1;
              }
#line 384
              opt.ps.bind = (unsigned int )tmp___28;
            }
          } else {
            {
#line 382
            opt.ps.pass = cpy(val);
            }
          }
        } else {
          {
#line 380
          opt.ps.user = cpy(val);
          }
        }
      } else {
        {
#line 378
        tmp___26 = atoi((char const   *)val);
#line 378
        opt.ps.port = (unsigned short )tmp___26;
        }
      }
    } else {
      {
#line 370
      tmp___25 = get_ip_addr(val, & opt.ps.ip);
      }
#line 370
      if (tmp___25 == -1) {
        {
#line 371
        tmp___22 = gettext("Warning: ");
#line 371
        printout((unsigned char)1, (char const   *)tmp___22);
#line 372
        tmp___23 = gettext("`%s\' could not be resolved. ");
#line 372
        printout((unsigned char)1, (char const   *)tmp___23, val);
#line 373
        tmp___24 = gettext("Disabling proxy support.\n");
#line 373
        printout((unsigned char)1, (char const   *)tmp___24);
#line 374
        opt.ps.type = 0U;
        }
      }
    }
  } else {
    {
#line 362
    tmp___21 = strncmp((char const   *)val, "http", (size_t )5);
    }
#line 362
    if (tmp___21) {
      {
#line 364
      tmp___20 = strncasecmp((char const   *)val, "socks", (size_t )6);
      }
#line 364
      if (tmp___20) {
#line 367
        opt.ps.type = 0U;
      } else {
#line 365
        opt.ps.type = 1U;
      }
    } else {
#line 363
      opt.ps.type = 2U;
    }
  }
#line 388
  return (0);
  case_114: /* CIL Label */ 
  {
#line 390
  tmp___40 = strncasecmp((char const   *)com, "rate", (size_t )5);
  }
#line 390
  if (tmp___40) {
    {
#line 399
    tmp___39 = strncasecmp((char const   *)com, "retry_count", (size_t )12);
    }
#line 399
    if (tmp___39) {
#line 401
      return (-1);
    } else {
      {
#line 400
      tmp___38 = atoi((char const   *)val);
#line 400
      opt.retry = (short )tmp___38;
      }
    }
  } else {
#line 391
    if (opt.wdel) {
#line 391
      return (0);
    }
    {
#line 392
    tmp___37 = atoi((char const   *)val);
#line 392
    opt.speed_limit = (unsigned int )tmp___37;
    }
    {
#line 393
    while (1) {
      while_continue: /* CIL Label */ ;
#line 393
      if (! *val) {
#line 393
        goto while_break;
      }
#line 394
      if ((int )*val == 75) {
#line 394
        opt.speed_limit *= 1024U;
      }
#line 395
      if ((int )*val == 77) {
#line 395
        opt.speed_limit *= 1048576U;
      }
#line 396
      val ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 398
    printout((unsigned char)4, "Rate-Limit is set to %d Bytes per second\n", opt.speed_limit);
    }
  }
#line 402
  return (0);
  case_115: /* CIL Label */ 
  {
#line 407
  tmp___43 = strncasecmp((char const   *)com, "sort_urls", (size_t )10);
  }
#line 407
  if (tmp___43) {
#line 409
    return (-1);
  } else {
    {
#line 408
    tmp___41 = strncasecmp((char const   *)val, "on", (size_t )3);
    }
#line 408
    if (tmp___41) {
#line 408
      tmp___42 = 0;
    } else {
#line 408
      tmp___42 = 1;
    }
#line 408
    opt.sorturls = (unsigned char )tmp___42;
  }
#line 410
  return (0);
  case_116: /* CIL Label */ 
  {
#line 412
  tmp___56 = strncasecmp((char const   *)com, "timeout", (size_t )8);
  }
#line 412
  if (tmp___56) {
    {
#line 414
    tmp___55 = strncasecmp((char const   *)com, "timestamping", (size_t )13);
    }
#line 414
    if (tmp___55) {
      {
#line 417
      tmp___54 = strncasecmp((char const   *)com, "timeoffset", (size_t )11);
      }
#line 417
      if (tmp___54) {
        {
#line 419
        tmp___53 = strncasecmp((char const   *)com, "timedeviation", (size_t )14);
        }
#line 419
        if (tmp___53) {
          {
#line 421
          tmp___52 = strncasecmp((char const   *)com, "transfer_type", (size_t )14);
          }
#line 421
          if (tmp___52) {
#line 427
            return (-1);
          } else {
#line 422
            if (opt.wdel) {
#line 422
              return (0);
            }
            {
#line 423
            tmp___51 = strncasecmp((char const   *)val, "auto", (size_t )5);
            }
#line 423
            if (tmp___51) {
              {
#line 424
              tmp___50 = strncasecmp((char const   *)val, "ascii", (size_t )6);
              }
#line 424
              if (tmp___50) {
                {
#line 425
                tmp___49 = strncasecmp((char const   *)val, "binary", (size_t )7);
                }
#line 425
                if (tmp___49) {
#line 426
                  return (-2);
                } else {
#line 425
                  opt.binary = (char)1;
                }
              } else {
#line 424
                opt.binary = (char)0;
              }
            } else {
#line 423
              opt.binary = (char)-1;
            }
          }
        } else {
          {
#line 420
          tmp___48 = atoi((char const   *)val);
#line 420
          opt.time_deviation = (short )tmp___48;
          }
        }
      } else {
        {
#line 418
        tmp___47 = atoi((char const   *)val);
#line 418
        opt.time_offset = (char )tmp___47;
        }
      }
    } else {
#line 415
      if (opt.wdel) {
#line 415
        return (0);
      }
      {
#line 416
      tmp___45 = strncasecmp((char const   *)val, "on", (size_t )3);
      }
#line 416
      if (tmp___45) {
#line 416
        tmp___46 = 0;
      } else {
#line 416
        tmp___46 = 1;
      }
#line 416
      opt.timestamping = (unsigned char )tmp___46;
    }
  } else {
    {
#line 413
    tmp___44 = atoi((char const   *)val);
#line 413
    socket_set_default_timeout(tmp___44);
    }
  }
#line 428
  return (0);
  case_118: /* CIL Label */ 
  {
#line 430
  tmp___58 = strncasecmp((char const   *)com, "verbosity", (size_t )10);
  }
#line 430
  if (tmp___58) {
#line 439
    return (-1);
  } else {
#line 431
    levels[0] = (char *)"quite";
#line 431
    levels[1] = (char *)"less";
#line 431
    levels[2] = (char *)"normal";
#line 431
    levels[3] = (char *)"more";
#line 431
    levels[4] = (char *)"debug";
#line 433
    i = 0;
    {
#line 433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 433
      if (! (i < 5)) {
#line 433
        goto while_break___0;
      }
      {
#line 434
      tmp___57 = strcasecmp((char const   *)val, (char const   *)levels[i]);
      }
#line 434
      if (! tmp___57) {
#line 435
        opt.verbose = (unsigned char )i;
#line 436
        return (0);
      }
#line 433
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 438
    return (-2);
  }
  case_119: /* CIL Label */ 
  {
#line 441
  tmp___60 = strncasecmp((char const   *)com, "wait_retry", (size_t )11);
  }
#line 441
  if (tmp___60) {
#line 443
    return (-1);
  } else {
    {
#line 442
    tmp___59 = atoi((char const   *)val);
#line 442
    opt.retry_interval = (unsigned short )tmp___59;
    }
  }
#line 444
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 446
  return (-1);
}
}
#line 452 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
void read_netrc_file(void) 
{ 
  char *path ;
  char *home ;
  acc_t *netrc_list ;
  acc_t *l ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 457
  home = home_dir();
  }
#line 458
  if (! home) {
#line 459
    return;
  }
  {
#line 461
  tmp = strlen((char const   *)home);
#line 461
  tmp___0 = strlen(".netrc");
#line 461
  tmp___1 = malloc(((tmp + 1UL) + tmp___0) + 1UL);
#line 461
  path = (char *)tmp___1;
  }
#line 463
  if (! path) {
#line 464
    return;
  }
  {
#line 466
  sprintf((char */* __restrict  */)path, (char const   */* __restrict  */)"%s/%s",
          home, ".netrc");
#line 467
  free((void *)home);
#line 469
  tmp___3 = file_exists((char const   *)path);
  }
#line 469
  if (! tmp___3) {
    {
#line 470
    tmp___2 = gettext("netrc file \'%s\' cannot be read. skipping\n");
#line 470
    printout((unsigned char)3, (char const   *)tmp___2, path);
    }
#line 471
    return;
  }
  {
#line 474
  printout((unsigned char)4, "Reading netrc file \'%s\'", path);
#line 475
  netrc_list = parse_netrc((char const   *)path);
#line 476
  free((void *)path);
  }
#line 479
  if (! netrc_list) {
#line 480
    return;
  }
#line 482
  l = netrc_list;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! l) {
#line 482
      goto while_break;
    }
#line 483
    if (! l->host) {
#line 484
      goto __Cont;
    }
#line 485
    if (l->passwd) {
      {
#line 485
      tmp___4 = cpy(l->passwd);
#line 485
      tmp___5 = tmp___4;
      }
    } else {
#line 485
      tmp___5 = (char *)((void *)0);
    }
#line 485
    if (l->acc) {
      {
#line 485
      tmp___6 = cpy(l->acc);
#line 485
      tmp___7 = tmp___6;
      }
    } else {
#line 485
      tmp___7 = (char *)((void *)0);
    }
    {
#line 485
    tmp___8 = cpy(l->host);
#line 485
    opt.pl = password_list_add(opt.pl, tmp___8, tmp___7, tmp___5);
#line 486
    printout((unsigned char)4, "added %s:%s@%s to the password-list (%x)\n", l->acc,
             l->passwd, l->host, opt.pl);
    }
    __Cont: /* CIL Label */ 
#line 482
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 489
  free_netrc(netrc_list);
  }
#line 490
  return;
}
}
#line 493 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
void read_password_file(char *f ) 
{ 
  FILE *fp ;
  char *line ;
  char *tmp ;
  char *user ;
  char *pass ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 499
  tmp___1 = file_exists((char const   *)f);
  }
#line 499
  if (! tmp___1) {
    {
#line 500
    tmp___0 = gettext("password_file \'%s\' cannot be read. skipping\n");
#line 500
    printout((unsigned char)3, (char const   *)tmp___0, f);
    }
#line 501
    return;
  }
  {
#line 503
  tmp___2 = gettext("Warning: You are using a wput password file. This is deprecated!\n         Please consider switch to the widely used netrc-files.\n");
#line 503
  printout((unsigned char)2, (char const   *)tmp___2);
#line 505
  printout((unsigned char)4, "Reading password-file \'%s\'", f);
#line 506
  fp = fopen((char const   */* __restrict  */)f, (char const   */* __restrict  */)"r");
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 507
    line = read_line(fp);
#line 507
    tmp = line;
    }
#line 507
    if (! tmp) {
#line 507
      goto while_break;
    }
    {
#line 508
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 508
      tmp___3 = isspace((int )*tmp);
      }
#line 508
      if (tmp___3) {
#line 508
        if (! *tmp) {
#line 508
          goto while_break___0;
        }
      } else {
#line 508
        goto while_break___0;
      }
#line 508
      tmp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 509
    strtok((char */* __restrict  */)tmp, (char const   */* __restrict  */)"\t");
#line 510
    user = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t");
#line 511
    pass = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\t");
    }
#line 512
    if ((int )*tmp == 0) {
      {
#line 513
      free((void *)line);
      }
#line 514
      goto while_continue;
    } else
#line 512
    if ((int )*tmp == 35) {
      {
#line 513
      free((void *)line);
      }
#line 514
      goto while_continue;
    } else
#line 512
    if ((unsigned long )user == (unsigned long )((void *)0)) {
      {
#line 513
      free((void *)line);
      }
#line 514
      goto while_continue;
    } else
#line 512
    if ((unsigned long )pass == (unsigned long )((void *)0)) {
      {
#line 513
      free((void *)line);
      }
#line 514
      goto while_continue;
    }
    {
#line 516
    tmp___7 = strlen((char const   *)pass);
    }
#line 516
    if ((int )*(pass + (tmp___7 - 2UL)) == 13) {
      {
#line 516
      tmp___4 = strlen((char const   *)pass);
#line 516
      *(pass + (tmp___4 - 2UL)) = (char)0;
      }
    } else {
      {
#line 517
      tmp___6 = strlen((char const   *)pass);
      }
#line 517
      if ((int )*(pass + (tmp___6 - 1UL)) == 10) {
        {
#line 517
        tmp___5 = strlen((char const   *)pass);
#line 517
        *(pass + (tmp___5 - 1UL)) = (char)0;
        }
      }
    }
    {
#line 518
    tmp___8 = cpy(pass);
#line 518
    tmp___9 = cpy(user);
#line 518
    tmp___10 = cpy(tmp);
#line 518
    opt.pl = password_list_add(opt.pl, tmp___10, tmp___9, tmp___8);
#line 519
    printout((unsigned char)4, "added %s:%s@%s to the password-list (%x)\n", user,
             pass, tmp, opt.pl);
#line 520
    free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
void readwputrc(char *f ) 
{ 
  FILE *fp ;
  char *file ;
  char *line ;
  int ln ;
  char *home ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int itmp ;
  char *com ;
  char *val ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 528
  ln = 1;
#line 530
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 531
    tmp = home_dir();
#line 531
    home = tmp;
#line 532
    tmp___0 = strlen((char const   *)home);
#line 532
    tmp___1 = malloc(tmp___0 + 10UL);
#line 532
    file = (char *)tmp___1;
#line 533
    sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)"%s/%s",
            home, ".wputrc");
#line 534
    free((void *)home);
    }
  } else {
    {
#line 535
    file = cpy(f);
    }
  }
  {
#line 537
  printout((unsigned char)4, "Reading wputrc-file: %s\n", file);
#line 539
  tmp___2 = file_exists((char const   *)file);
  }
#line 539
  if (! tmp___2) {
    {
#line 540
    printout((unsigned char)4, "wputrc-file \'%s\' is not readable. skipping.\n",
             file);
#line 541
    free((void *)file);
    }
#line 542
    return;
  }
  {
#line 545
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 546
  if (! fp) {
    {
#line 547
    tmp___3 = __errno_location();
#line 547
    tmp___4 = strerror(*tmp___3);
#line 547
    tmp___5 = gettext("Fatal error while opening \'%s\': %s\n");
#line 547
    printout((unsigned char)1, (char const   *)tmp___5, file, tmp___4);
#line 548
    free((void *)file);
    }
#line 549
    return;
  }
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 552
    line = read_line(fp);
    }
#line 552
    if (! line) {
#line 552
      goto while_break;
    }
#line 553
    tmp___6 = line;
    {
#line 558
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 558
      tmp___7 = isspace((int )*tmp___6);
      }
#line 558
      if (tmp___7) {
#line 558
        if (! *tmp___6) {
#line 558
          goto while_break___0;
        }
      } else {
#line 558
        goto while_break___0;
      }
#line 558
      tmp___6 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 561
    if ((int )*tmp___6 == 35) {
      {
#line 562
      free((void *)line);
      }
#line 563
      goto while_continue;
    } else
#line 561
    if ((int )*tmp___6 == 59) {
      {
#line 562
      free((void *)line);
      }
#line 563
      goto while_continue;
    } else
#line 561
    if ((int )*tmp___6 == 0) {
      {
#line 562
      free((void *)line);
      }
#line 563
      goto while_continue;
    }
#line 565
    com = tmp___6;
    {
#line 568
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 568
      tmp___8 = isspace((int )*tmp___6);
      }
#line 568
      if (tmp___8) {
#line 568
        goto while_break___1;
      } else
#line 568
      if (*tmp___6) {
#line 568
        if (! ((int )*tmp___6 != 61)) {
#line 568
          goto while_break___1;
        }
      } else {
#line 568
        goto while_break___1;
      }
#line 568
      tmp___6 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 569
    tmp___9 = tmp___6;
#line 569
    tmp___6 ++;
#line 569
    *tmp___9 = (char)0;
    {
#line 571
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 571
      tmp___10 = isspace((int )*tmp___6);
      }
#line 571
      if (tmp___10) {
#line 571
        goto _L;
      } else
#line 571
      if ((int )*tmp___6 == 61) {
        _L: /* CIL Label */ 
#line 571
        if (! *tmp___6) {
#line 571
          goto while_break___2;
        }
      } else {
#line 571
        goto while_break___2;
      }
#line 571
      tmp___6 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 572
    val = tmp___6;
    {
#line 575
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 575
      if ((int )*tmp___6 != 0) {
#line 575
        if (! ((int )*tmp___6 != 10)) {
#line 575
          goto while_break___3;
        }
      } else {
#line 575
        goto while_break___3;
      }
#line 575
      tmp___6 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 576
    if ((int )*(tmp___6 - 1) == 13) {
#line 576
      *(tmp___6 - 1) = (char)0;
    } else {
#line 577
      *tmp___6 = (char)0;
    }
    {
#line 579
    itmp = set_option(com, val);
    }
#line 580
    if (itmp == -1) {
      {
#line 580
      tmp___11 = gettext("%s#%d: Option \'%s\' not recognized\n");
#line 580
      printout((unsigned char)1, (char const   *)tmp___11, file, ln, com);
      }
    }
#line 581
    if (itmp == -2) {
      {
#line 581
      tmp___12 = gettext("%s#%d: Unknow value \'%s\' for \'%s\'\n");
#line 581
      printout((unsigned char)1, (char const   *)tmp___12, file, ln, val, com);
      }
    }
    {
#line 582
    free((void *)line);
#line 583
    ln ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 585
  free((void *)file);
  }
#line 586
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
static struct option long_options[41]  = 
#line 596
  {      {"append-output", 1, (int *)0, 'a'}, 
        {"ascii", 0, (int *)0, 'A'}, 
        {"background", 0, (int *)0, 'b'}, 
        {"basename", 1, (int *)0, 0}, 
        {"binary", 0, (int *)0, 'B'}, 
        {"bind-address", 1, (int *)0, 0}, 
        {"compile-options", 0, (int *)0, 0}, 
        {"debug", 0, (int *)0, 'd'}, 
        {"dont-continue", 0, (int *)0, 0}, 
        {"force-tls", 0, (int *)0, 0}, 
        {"help", 0, (int *)0, 'h'}, 
        {"input-file", 1, (int *)0, 'i'}, 
        {"input-pipe", 1, (int *)0, 'I'}, 
        {"less-verbose", 0, (int *)0, 0}, 
        {"limit-rate", 1, (int *)0, 'l'}, 
        {"no-directories", 0, (int *)0, 0}, 
        {"output-file", 1, (int *)0, 'o'}, 
        {"port-mode", 0, (int *)0, 'p'}, 
        {"proxy", 1, (int *)0, 'Y'}, 
        {"proxy-user", 1, (int *)0, 0}, 
        {"proxy-pass", 1, (int *)0, 0}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"random-wait", 0, (int *)0, 0}, 
        {"remove-source-files", 0, (int *)0, 'R'}, 
        {"reupload", 0, (int *)0, 'u'}, 
        {"script", 1, (int *)0, 'S'}, 
        {"skip-existing", 0, (int *)0, 0}, 
        {"skip-larger", 0, (int *)0, 0}, 
        {"sort", 0, (int *)0, 's'}, 
        {"timeoffset", 1, (int *)0, 0}, 
        {"timeout", 1, (int *)0, 'T'}, 
        {"timestamping", 0, (int *)0, 'N'}, 
        {"tries", 1, (int *)0, 't'}, 
        {"use-proxy", 1, (int *)0, 'Y'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"wait", 1, (int *)0, 'w'}, 
        {"waitretry", 1, (int *)0, 0}, 
        {"chmod", 2, (int *)0, 'm'}, 
        {"disable-tls", 0, (int *)0, 0}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 589 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/wput.c"
void commandlineoptions(int argc , char **argv ) 
{ 
  int c ;
  int option_index ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;

  {
#line 595
  option_index = 0;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 642
    c = getopt_long(argc, (char * const  *)argv, "Y:Vhbo:a:dqvn:i:I:t:NT:w:Rl:pABsS:um::",
                    (struct option  const  *)(long_options), & option_index);
    }
#line 645
    if (c == -1) {
#line 646
      goto while_break;
    }
    {
#line 650
    if (c == 0) {
#line 650
      goto case_0;
    }
#line 700
    if (c == 97) {
#line 700
      goto case_97;
    }
#line 700
    if (c == 111) {
#line 700
      goto case_97;
    }
#line 705
    if (c == 98) {
#line 705
      goto case_98;
    }
#line 707
    if (c == 116) {
#line 707
      goto case_116;
    }
#line 711
    if (c == 84) {
#line 711
      goto case_84;
    }
#line 713
    if (c == 112) {
#line 713
      goto case_112;
    }
#line 714
    if (c == 110) {
#line 714
      goto case_110;
    }
#line 721
    if (c == 117) {
#line 721
      goto case_117;
    }
#line 722
    if (c == 78) {
#line 722
      goto case_78;
    }
#line 723
    if (c == 118) {
#line 723
      goto case_118;
    }
#line 724
    if (c == 113) {
#line 724
      goto case_113;
    }
#line 725
    if (c == 100) {
#line 725
      goto case_100;
    }
#line 726
    if (c == 119) {
#line 726
      goto case_119;
    }
#line 727
    if (c == 65) {
#line 727
      goto case_65;
    }
#line 728
    if (c == 66) {
#line 728
      goto case_66;
    }
#line 729
    if (c == 115) {
#line 729
      goto case_115;
    }
#line 730
    if (c == 83) {
#line 730
      goto case_83;
    }
#line 731
    if (c == 108) {
#line 731
      goto case_108;
    }
#line 732
    if (c == 105) {
#line 732
      goto case_105;
    }
#line 745
    if (c == 73) {
#line 745
      goto case_73;
    }
#line 751
    if (c == 82) {
#line 751
      goto case_82;
    }
#line 752
    if (c == 89) {
#line 752
      goto case_89;
    }
#line 753
    if (c == 109) {
#line 753
      goto case_109;
    }
#line 759
    if (c == 86) {
#line 759
      goto case_86;
    }
#line 763
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 652
    if (option_index == 13) {
#line 652
      goto case_13;
    }
#line 654
    if (option_index == 5) {
#line 654
      goto case_5;
    }
#line 655
    if (option_index == 8) {
#line 655
      goto case_8;
    }
#line 659
    if (option_index == 22) {
#line 659
      goto case_22;
    }
#line 661
    if (option_index == 17) {
#line 661
      goto case_17;
    }
#line 663
    if (option_index == 19) {
#line 663
      goto case_19;
    }
#line 664
    if (option_index == 20) {
#line 664
      goto case_20;
    }
#line 665
    if (option_index == 6) {
#line 665
      goto case_6;
    }
#line 675
    if (option_index == 27) {
#line 675
      goto case_27;
    }
#line 677
    if (option_index == 26) {
#line 677
      goto case_26;
    }
#line 681
    if (option_index == 29) {
#line 681
      goto case_29;
    }
#line 687
    if (option_index == 15) {
#line 687
      goto case_15;
    }
#line 689
    if (option_index == 3) {
#line 689
      goto case_3;
    }
#line 691
    if (option_index == 37) {
#line 691
      goto case_37;
    }
#line 693
    if (option_index == 39) {
#line 693
      goto case_39;
    }
#line 695
    goto switch_default;
    case_13: /* CIL Label */ 
#line 653
    opt.verbose = (unsigned char )((int )opt.verbose - 1);
#line 653
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 654
    set_option((char *)"bind-address", optarg);
    }
#line 654
    goto switch_break___0;
    case_8: /* CIL Label */ 
#line 656
    if ((int )opt.resume_table.large_small == 2) {
#line 657
      opt.resume_table.large_small = (unsigned char)1;
    }
#line 658
    goto switch_break___0;
    case_22: /* CIL Label */ 
#line 660
    opt.random_wait = (unsigned char)1;
#line 660
    goto switch_break___0;
    case_17: /* CIL Label */ 
#line 662
    opt.portmode = (unsigned char)1;
#line 662
    goto switch_break___0;
    case_19: /* CIL Label */ 
    {
#line 663
    set_option((char *)"proxy_user", optarg);
    }
#line 663
    goto switch_break___0;
    case_20: /* CIL Label */ 
    {
#line 664
    set_option((char *)"proxy_pass", optarg);
    }
#line 664
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 666
    fprintf((FILE */* __restrict  */)opt.output, (char const   */* __restrict  */)"wput version: %s\n\n#defined options:\n",
            version);
#line 668
    fprintf((FILE */* __restrict  */)opt.output, (char const   */* __restrict  */)"TIMER_GETTIMEOFDAY\n");
#line 673
    fprintf((FILE */* __restrict  */)opt.output, (char const   */* __restrict  */)"\nUsing %d-Bytes for off_t\n",
            (int )sizeof(off_t ));
#line 674
    exit(0);
    }
    case_27: /* CIL Label */ 
#line 676
    opt.resume_table.small_large = (unsigned char)0;
#line 676
    goto switch_break___0;
    case_26: /* CIL Label */ 
#line 678
    opt.resume_table.large_small = (unsigned char)0;
#line 679
    opt.resume_table.large_large = (unsigned char)0;
#line 680
    opt.resume_table.small_large = (unsigned char)0;
#line 680
    goto switch_break___0;
    case_29: /* CIL Label */ 
    {
#line 682
    set_option((char *)"timeoffset", optarg);
    }
#line 682
    goto switch_break___0;
    case_15: /* CIL Label */ 
#line 688
    opt.no_directories = (unsigned char)1;
#line 688
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 690
    opt.basename = optarg;
#line 690
    goto switch_break___0;
    case_37: /* CIL Label */ 
    {
#line 692
    tmp = atoi((char const   *)optarg);
#line 692
    opt.retry_interval = (unsigned short )tmp;
    }
#line 692
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 694
    opt.tls = (unsigned char)2;
#line 694
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 696
    tmp___0 = gettext("Option %s should not appear here :|\n");
#line 696
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            long_options[option_index].name);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 698
    goto switch_break;
    case_97: /* CIL Label */ 
    case_111: /* CIL Label */ 
#line 700
    if (c == 111) {
#line 700
      tmp___1 = "w";
    } else {
#line 700
      tmp___1 = "a";
    }
    {
#line 700
    opt.output = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)tmp___1);
    }
#line 701
    if ((unsigned long )opt.output == (unsigned long )((void *)0)) {
      {
#line 701
      tmp___2 = gettext("Unable to open logfile");
#line 701
      perror((char const   *)tmp___2);
#line 701
      exit(4);
      }
    }
#line 702
    opt.barstyle = (unsigned char)0;
#line 703
    goto switch_break;
    case_98: /* CIL Label */ 
#line 705
    opt.background = (unsigned char)1;
#line 705
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 708
    tmp___3 = atoi((char const   *)optarg);
#line 708
    opt.retry = (short )(tmp___3 + 1);
    }
#line 709
    if ((int )opt.retry <= 0) {
#line 709
      opt.retry = (short)-1;
    }
#line 710
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 711
    tmp___4 = atoi((char const   *)optarg);
#line 711
    socket_set_default_timeout(tmp___4);
    }
#line 712
    goto switch_break;
    case_112: /* CIL Label */ 
#line 713
    opt.portmode = (unsigned char)1;
#line 713
    goto switch_break;
    case_110: /* CIL Label */ 
#line 715
    if ((int )*(optarg + 0) == 118) {
#line 715
      opt.verbose = (unsigned char )((int )opt.verbose - 1);
    }
#line 716
    if ((int )*(optarg + 0) == 100) {
#line 716
      opt.no_directories = (unsigned char)1;
    }
#line 717
    if ((int )*(optarg + 0) == 99) {
#line 718
      if ((int )opt.resume_table.large_small == 2) {
#line 719
        opt.resume_table.large_small = (unsigned char)1;
      }
    }
#line 720
    goto switch_break;
    case_117: /* CIL Label */ 
#line 721
    opt.resume_table.large_large = (unsigned char)1;
#line 721
    goto switch_break;
    case_78: /* CIL Label */ 
#line 722
    opt.timestamping = (unsigned char)1;
#line 722
    goto switch_break;
    case_118: /* CIL Label */ 
#line 723
    opt.verbose = (unsigned char )((int )opt.verbose + 1);
#line 723
    goto switch_break;
    case_113: /* CIL Label */ 
#line 724
    opt.verbose = (unsigned char)0;
#line 724
    goto switch_break;
    case_100: /* CIL Label */ 
#line 725
    opt.verbose = (unsigned char)4;
#line 725
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 726
    tmp___5 = atoi((char const   *)optarg);
#line 726
    opt.wait = (short )tmp___5;
    }
#line 726
    goto switch_break;
    case_65: /* CIL Label */ 
#line 727
    opt.binary = (char)0;
#line 727
    goto switch_break;
    case_66: /* CIL Label */ 
#line 728
    opt.binary = (char)1;
#line 728
    goto switch_break;
    case_115: /* CIL Label */ 
#line 729
    opt.sorturls = (unsigned char)1;
#line 729
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 730
    Abort((char *)"TODO SCRIPTING\n");
    }
#line 730
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 731
    set_option((char *)"rate", optarg);
    }
#line 731
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 733
    tmp___6 = strncmp((char const   *)optarg, "-", (size_t )2);
    }
#line 733
    if (tmp___6) {
      {
#line 737
      printout((unsigned char)4, "Reading URLs from `%s\'\n", optarg);
#line 738
      opt.input = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"r");
      }
#line 739
      if ((unsigned long )opt.input == (unsigned long )((void *)0)) {
        {
#line 740
        perror((char const   *)optarg);
#line 741
        exit(4);
        }
      }
    } else {
      {
#line 734
      printout((unsigned char)4, "Reading URLs from stdin\n");
#line 735
      opt.input = stdin;
      }
    }
#line 744
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 745
    tmp___7 = gettext("Warning: ");
#line 745
    printout((unsigned char)2, (char const   *)tmp___7);
#line 746
    tmp___8 = gettext("You supplied an input-pipe. This is only to be used as fallback, if no filename can be found from the URL. This might not be the desired behavour. TODO\n");
#line 746
    printout((unsigned char)2, (char const   *)tmp___8);
#line 750
    opt.input_pipe = optarg;
    }
#line 750
    goto switch_break;
    case_82: /* CIL Label */ 
#line 751
    opt.unlink = (unsigned char)1;
#line 751
    goto switch_break;
    case_89: /* CIL Label */ 
    {
#line 752
    set_option((char *)"proxy", optarg);
    }
#line 752
    goto switch_break;
    case_109: /* CIL Label */ 
#line 754
    if (optarg) {
      {
#line 755
      set_option((char *)"chmod", optarg);
      }
    } else {
      {
#line 757
      set_option((char *)"chmod", (char *)"1");
      }
    }
#line 758
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 760
    tmp___9 = gettext("wput version: %s\n");
#line 760
    fprintf((FILE */* __restrict  */)opt.output, (char const   */* __restrict  */)tmp___9,
            version);
#line 761
    exit(0);
    }
    switch_default___0: /* CIL Label */ 
    {
#line 764
    tmp___10 = gettext("Usage: wput [options] [file]... [url]...\n  url        ftp://[username[:password]@]hostname[:port][/[path/][file]]\n\nStartup:\n  -V, --version         Display the version of wput and exit.\n  -h, --help            Print this help-screen\n");
#line 764
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10);
#line 770
    tmp___11 = gettext("  -b, --background      go to background after startup\n");
#line 770
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11);
#line 773
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 775
    tmp___12 = gettext("Logging and input file:\n  -o,  --output-file=FILE      log messages to FILE\n  -a,  --append-output=FILE    append log messages to FILE\n  -q,  --quiet                 quiet (no output)\n  -v,  --verbose               be verbose\n  -d,  --debug                 debug output\n  -nv, --less-verbose          be less verbose\n  -i,  --input-file=FILE       read the URLs from FILE\n  -s,  --sort                  sorts all input URLs by server-ip and path\n       --basename=PATH         snip PATH off each file when appendig to an URL\n  -I,  --input-pipe=COMMAND    take the output of COMMAND as data-source\n  -R,  --remove-source-files   unlink files upon successful upload\n\n");
#line 775
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12);
#line 791
    tmp___13 = gettext("Connection:\n       --bind-address=ADDR     bind to ADDR (hostname or IP) on local host\n  -t,  --tries=NUMBER          set retry count to NUMBER (-1 means infinite)\n  -nc, --dont-continue         do not resume partially-uploaded files\n  -u,  --reupload              do not skip already completed files\n       --skip-larger           do not upload files if remote size is larger\n       --skip-existing         do not upload files that exist remotely\n  -N,  --timestamping          don\'t re-upload files unless newer than remote\n  -T,  --timeout=10th-SECONDS  set various timeouts to 10th-SECONDS\n  -w,  --wait=10th-SECONDS     wait 10th-SECONDS between uploads. (default: 0)\n       --random-wait           wait from 0...2*WAIT secs between uploads.\n       --waitretry=SECONDS     wait SECONDS between retries of an upload\n  -l,  --limit-rate=RATE       limit upload rate to RATE\n  -nd, --no-directories        do not create any directories\n  -Y,  --proxy=http/socks/off  set proxy type or turn off\n       --proxy-user=NAME       set the proxy-username to NAME\n       --proxy-pass=PASS       set the proxy-password to PASS\n\n");
#line 791
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13);
#line 810
    tmp___14 = gettext("FTP-Options:\n  -p,  --port-mode             no-passive, turn on port mode ftp (def. pasv)\n  -A,  --ascii                 force ASCII  mode-transfer\n  -B,  --binary                force BINARY mode-transfer\n  -m,  --chmod                 change mode of transferred files ([0-7]{3})\n");
#line 810
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___14);
#line 824
    tmp___15 = gettext("\nSee wput(1) for more detailed descriptions of the options.\nReport bugs and suggestions via SourceForge at\nhttp://sourceforge.net/tracker/?group_id=141519\n");
#line 824
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15);
#line 829
    exit(0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 834
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 834
    if (! (optind < argc)) {
#line 834
      goto while_break___0;
    }
    {
#line 835
    tmp___20 = strncmp((char const   *)*(argv + optind), "ftp://", (size_t )6);
    }
#line 835
    if (tmp___20) {
#line 838
      if (opt.wdel) {
        {
#line 838
        tmp___19 = cpy(*(argv + optind));
#line 838
        wdel_queue_add_file(tmp___19);
        }
      } else {
        {
#line 838
        tmp___18 = cpy(*(argv + optind));
#line 838
        queue_add_file(tmp___18);
        }
      }
    } else
#line 836
    if (opt.wdel) {
      {
#line 836
      tmp___17 = cpy(*(argv + optind));
#line 836
      wdel_queue_add_entry((char *)((void *)0), tmp___17);
      }
    } else {
      {
#line 836
      tmp___16 = cpy(*(argv + optind));
#line 836
      queue_add_url(tmp___16);
      }
    }
    {
#line 840
    tmp___21 = strlen((char const   *)*(argv + optind));
#line 840
    memset((void *)*(argv + optind), ' ', tmp___21);
#line 842
    optind ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 844
  return;
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
void ftp_free_host(host_t *host ) ;
#line 4 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/_queue.h"
void queue_add_entry(char *file , char *url ) ;
#line 15
int queue_add_dir(char *dname , char *url , _fsession *fsession ) ;
#line 18
_fsession *fsession_insert(_fsession *K , _fsession *F ) ;
#line 19
_fsession *build_fsession(char *file , char *url ) ;
#line 21
skipd_list *skiplist_add_entry(skipd_list *K , int ip , char *host , unsigned short port ,
                               char *user , char *pass , char *dir ) ;
#line 22
int skiplist_find_entry(int ip , char *host , unsigned short port , char *user , char *pass ,
                        char *dir ) ;
#line 28
password_list *password_list_find(password_list *K , char *host , char *user ) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.h"
char *basename(char *p ) ;
#line 41
char *unescape(char *str ) ;
#line 45
char *printip(unsigned char *ip ) ;
#line 49
int parse_url(_fsession *fsession , char *url ) ;
#line 51
char *snip_basename(char *file ) ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
_queue *queue_entry_point  =    (_queue *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void printqueue(_queue *K ) 
{ 


  {
#line 50
  if ((unsigned long )K == (unsigned long )((void *)0)) {
#line 50
    return;
  }
  {
#line 51
  printout((unsigned char)4, "File: `%s\'\nURL : `%s\'\n", K->file, K->url);
#line 52
  printqueue(K->next);
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void queue_add_file(char *filename ) 
{ 
  _queue *K ;

  {
  {
#line 56
  K = queue_entry_point;
#line 58
  printout((unsigned char)4, "Added file `%s\' to queue.\n", filename);
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if ((unsigned long )K != (unsigned long )((void *)0)) {
#line 60
      if (! ((unsigned long )K->file != (unsigned long )((void *)0))) {
#line 60
        goto while_break;
      }
    } else {
#line 60
      goto while_break;
    }
#line 60
    K = K->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if ((unsigned long )K != (unsigned long )((void *)0)) {
#line 62
    K->file = filename;
  } else {
    {
#line 63
    queue_add_entry(filename, (char *)((void *)0));
    }
  }
#line 65
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void queue_add_url(char *url ) 
{ 
  _queue *K ;

  {
  {
#line 68
  K = queue_entry_point;
#line 70
  printout((unsigned char)4, "Added URL `%s\' to queue.\n", url);
  }
#line 75
  if (opt.last_url) {
    {
#line 75
    free((void *)opt.last_url);
    }
  }
  {
#line 76
  opt.last_url = cpy(url);
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if ((unsigned long )K != (unsigned long )((void *)0)) {
#line 78
      if (! ((unsigned long )K->url != (unsigned long )((void *)0))) {
#line 78
        goto while_break;
      }
    } else {
#line 78
      goto while_break;
    }
#line 78
    K = K->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  if ((unsigned long )K != (unsigned long )((void *)0)) {
#line 80
    K->url = url;
  } else {
    {
#line 81
    queue_add_entry((char *)((void *)0), url);
    }
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void queue_add_entry(char *file , char *url ) 
{ 
  _queue *K ;
  _queue *M ;
  void *tmp ;

  {
  {
#line 85
  K = queue_entry_point;
#line 86
  tmp = malloc(sizeof(_queue ));
#line 86
  M = (_queue *)tmp;
#line 88
  M->url = url;
#line 89
  M->file = file;
#line 90
  M->next = (struct input_queue *)((void *)0);
  }
#line 92
  if ((unsigned long )K == (unsigned long )((void *)0)) {
#line 92
    queue_entry_point = M;
  } else {
#line 94
    K = queue_entry_point;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! ((unsigned long )K->next != (unsigned long )((void *)0))) {
#line 95
        goto while_break;
      }
#line 95
      K = K->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 96
    K->next = M;
  }
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void wdel_queue_add_entry(char *file , char *url ) 
{ 
  _queue *K ;
  _queue *M ;
  void *tmp ;

  {
  {
#line 101
  K = queue_entry_point;
#line 102
  tmp = malloc(sizeof(_queue ));
#line 102
  M = (_queue *)tmp;
  }
#line 104
  if ((unsigned long )url != (unsigned long )((void *)0)) {
    {
#line 105
    M->url = url;
#line 106
    printout((unsigned char)4, "Added URL `%s\' to queue.\n", M->url);
    }
#line 110
    if (opt.last_url) {
      {
#line 110
      free((void *)opt.last_url);
      }
    }
    {
#line 111
    opt.last_url = cpy(M->url);
    }
  } else {
    {
#line 113
    M->url = cpy(opt.last_url);
    }
  }
#line 115
  M->file = file;
#line 116
  M->next = (struct input_queue *)((void *)0);
#line 118
  if ((unsigned long )K == (unsigned long )((void *)0)) {
#line 118
    queue_entry_point = M;
  } else {
#line 120
    K = queue_entry_point;
    {
#line 121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 121
      if (! ((unsigned long )K->next != (unsigned long )((void *)0))) {
#line 121
        goto while_break;
      }
#line 121
      K = K->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 122
    K->next = M;
  }
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void wdel_queue_add_file(char *filename ) 
{ 
  _queue *K ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 127
  K = queue_entry_point;
#line 129
  if ((unsigned long )K == (unsigned long )((void *)0)) {
    {
#line 130
    tmp = gettext("Error: Please specify a url first.\n");
#line 130
    printout((unsigned char)1, (char const   *)tmp);
#line 131
    exit(4);
    }
  }
  {
#line 135
  tmp___1 = strlen((char const   *)filename);
  }
#line 135
  if ((int )*((filename + tmp___1) - 1) == 47) {
    {
#line 136
    tmp___0 = strlen((char const   *)filename);
#line 136
    *((filename + tmp___0) - 1) = (char )'\000';
    }
  }
  {
#line 138
  printout((unsigned char)4, "Added file `%s\' to queue.\n", filename);
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )K->next != (unsigned long )((void *)0))) {
#line 140
      goto while_break;
    }
#line 140
    K = K->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if ((unsigned long )K->file == (unsigned long )((void *)0)) {
#line 142
    K->file = filename;
  } else {
    {
#line 143
    wdel_queue_add_entry(filename, (char *)((void *)0));
    }
  }
#line 144
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void separate_urls(void) 
{ 
  _queue *K ;
  size_t tmp ;
  size_t tmp___0 ;
  char *d ;
  char *tmp___1 ;
  int len ;
  char *tmpurl ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;

  {
#line 148
  K = queue_entry_point;
#line 150
  if ((unsigned long )queue_entry_point == (unsigned long )((void *)0)) {
#line 150
    return;
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! ((unsigned long )K != (unsigned long )((void *)0))) {
#line 151
      goto while_break;
    }
#line 152
    if ((unsigned long )K->file == (unsigned long )((void *)0)) {
      {
#line 156
      tmp___0 = strlen((char const   *)K->url);
      }
#line 156
      if ((int )*((K->url + tmp___0) - 1) == 47) {
        {
#line 157
        tmp = strlen((char const   *)K->url);
#line 157
        *((K->url + tmp) - 1) = (char )'\000';
        }
      }
      {
#line 158
      tmp___1 = strrchr((char const   *)(K->url + 6), '/');
#line 158
      d = tmp___1;
      }
#line 159
      if (d) {
        {
#line 160
        len = (int )((d - K->url) + 1L);
#line 161
        tmp___2 = malloc((size_t )(len + 1));
#line 161
        tmpurl = (char *)tmp___2;
#line 162
        strncpy((char */* __restrict  */)tmpurl, (char const   */* __restrict  */)K->url,
                (size_t )len);
#line 163
        *(tmpurl + len) = (char )'\000';
#line 164
        K->file = cpy(d + 1);
#line 165
        free((void *)K->url);
#line 166
        K->url = tmpurl;
        }
      }
    } else {
      {
#line 168
      tmp___5 = strlen((char const   *)K->url);
      }
#line 168
      if ((int )*((K->url + tmp___5) - 1) != 47) {
        {
#line 169
        tmp___3 = strlen((char const   *)K->url);
#line 169
        tmp___4 = realloc((void *)K->url, tmp___3 + 2UL);
#line 169
        K->url = (char *)tmp___4;
#line 170
        strcat((char */* __restrict  */)K->url, (char const   */* __restrict  */)"/");
        }
      }
    }
#line 172
    K = K->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void queue_process(int force ) 
{ 
  _queue *P ;
  int res ;
  _fsession *F ;
  _fsession *tmp ;

  {
  {
#line 182
  printout((unsigned char)4, "processing queue:\n");
  }
#line 183
  if ((int )opt.verbose >= 4) {
    {
#line 184
    printqueue(queue_entry_point);
    }
  }
#line 186
  if ((unsigned long )queue_entry_point == (unsigned long )((void *)0)) {
#line 186
    return;
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if ((unsigned long )queue_entry_point != (unsigned long )((void *)0)) {
#line 187
      if ((unsigned long )queue_entry_point->url != (unsigned long )((void *)0)) {
#line 187
        if (! ((unsigned long )queue_entry_point->file != (unsigned long )((void *)0))) {
#line 187
          if (! force) {
#line 187
            goto while_break;
          }
        }
      } else {
#line 187
        goto while_break;
      }
    } else {
#line 187
      goto while_break;
    }
    {
#line 188
    tmp = build_fsession(queue_entry_point->file, queue_entry_point->url);
#line 188
    F = tmp;
    }
#line 189
    if (F) {
#line 189
      if ((unsigned long )F != (unsigned long )((void *)-2)) {
#line 190
        if (! opt.sorturls) {
          {
#line 191
          res = fsession_process_file(F, opt.curftp);
          }
#line 192
          if (res == -1) {
#line 193
            opt.failed = (unsigned short )((int )opt.failed + 1);
#line 194
            opt.curftp = (ftp_con *)((void *)0);
          } else
#line 196
          if (res == -2) {
#line 196
            opt.skipped = (unsigned short )((int )opt.skipped + 1);
          }
#line 197
          if (F->ftp) {
#line 198
            opt.curftp = F->ftp;
          }
          {
#line 199
          free_fsession(F);
          }
        } else {
          {
#line 201
          fsession_queue_entry_point = fsession_insert(F, fsession_queue_entry_point);
          }
        }
      } else {
        {
#line 203
        printout((unsigned char)4, "ignoring unbuild fsession\n");
        }
      }
    } else {
      {
#line 203
      printout((unsigned char)4, "ignoring unbuild fsession\n");
      }
    }
    {
#line 204
    P = queue_entry_point;
#line 205
    queue_entry_point = queue_entry_point->next;
#line 208
    free((void *)P->url);
#line 209
    free((void *)P);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void process_missing(void) 
{ 
  _queue *K ;

  {
#line 214
  K = queue_entry_point;
#line 215
  if (opt.last_url) {
    {
#line 216
    while (1) {
      while_continue: /* CIL Label */ ;
#line 216
      if (! ((unsigned long )K != (unsigned long )((void *)0))) {
#line 216
        goto while_break;
      }
#line 217
      if (! K->url) {
        {
#line 218
        K->url = cpy(opt.last_url);
        }
      }
#line 219
      K = K->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 222
  queue_process(1);
  }
#line 223
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
int queue_add_dir(char *dname , char *url , _fsession *fsession ) 
{ 
  char *fname ;
  char *tmpbuf ;
  struct stat statbuf ;
  struct dirent *dent ;
  DIR *hSearch ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 241
  fname = (char *)0;
#line 260
  tmp = strlen((char const   *)dname);
#line 260
  tmp___0 = malloc(tmp + 2UL);
#line 260
  tmpbuf = (char *)tmp___0;
#line 262
  strcpy((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)dname);
#line 283
  tmp___1 = strlen((char const   *)tmpbuf);
  }
#line 283
  if ((int )*(tmpbuf + (tmp___1 - 1UL)) != 47) {
    {
#line 284
    strcat((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)"/");
    }
  }
  {
#line 291
  hSearch = opendir((char const   *)tmpbuf);
  }
#line 291
  if (hSearch) {
    {
#line 292
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 292
      dent = readdir(hSearch);
      }
#line 292
      if (! ((unsigned long )dent != (unsigned long )((struct dirent *)0))) {
#line 292
        goto while_break;
      }
      {
#line 295
      printout((unsigned char)4, "Dir entry name: %s\n", dent->d_name);
#line 297
      tmp___2 = strcmp((char const   *)(dent->d_name), ".");
      }
#line 297
      if (tmp___2) {
        {
#line 297
        tmp___3 = strcmp((char const   *)(dent->d_name), "..");
        }
#line 297
        if (! tmp___3) {
#line 297
          goto while_continue;
        }
      } else {
#line 297
        goto while_continue;
      }
#line 299
      if (fname) {
        {
#line 299
        free((void *)fname);
        }
      }
      {
#line 308
      tmp___4 = strlen((char const   *)tmpbuf);
#line 308
      tmp___5 = strlen((char const   *)(dent->d_name));
#line 308
      tmp___6 = malloc((tmp___4 + tmp___5) + 1UL);
#line 308
      fname = (char *)tmp___6;
#line 309
      strcpy((char */* __restrict  */)fname, (char const   */* __restrict  */)tmpbuf);
#line 310
      tmp___7 = strlen((char const   *)tmpbuf);
#line 310
      strcpy((char */* __restrict  */)(fname + tmp___7), (char const   */* __restrict  */)(dent->d_name));
#line 319
      tmp___12 = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& statbuf));
      }
#line 319
      if (tmp___12 == 0) {
#line 320
        if ((statbuf.st_mode & 61440U) == 32768U) {
          {
#line 323
          printout((unsigned char)4, "fname: %s (url: %s)\n", fname, url);
#line 326
          tmp___8 = cpy(url);
#line 326
          tmp___9 = cpy(fname);
#line 326
          queue_add_entry(tmp___9, tmp___8);
          }
        } else
#line 329
        if ((statbuf.st_mode & 61440U) == 16384U) {
          {
#line 331
          queue_add_dir(fname, url, fsession);
          }
        }
      } else {
        {
#line 337
        tmp___10 = gettext("Warning: ");
#line 337
        printout((unsigned char)1, (char const   *)tmp___10);
#line 338
        tmp___11 = gettext("Error encountered but ignored during stat of `%s\'.\n");
#line 338
        printout((unsigned char)1, (char const   *)tmp___11, fname);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 341
    closedir(hSearch);
    }
  } else {
    {
#line 344
    tmp___13 = gettext("Warning: ");
#line 344
    printout((unsigned char)1, (char const   *)tmp___13);
#line 345
    tmp___14 = gettext("Error encountered but ignored during opendir of `%s\'.\n");
#line 345
    printout((unsigned char)1, (char const   *)tmp___14, fname);
    }
  }
#line 347
  if (fname) {
    {
#line 347
    free((void *)fname);
    }
  }
  {
#line 349
  free((void *)tmpbuf);
  }
#line 351
  return (0);
}
}
#line 353 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
int fsession_compare(_fsession *A , _fsession *B ) 
{ 
  int a ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 356
  if ((A->host)->ip > (B->host)->ip) {
#line 356
    return (1);
  }
#line 357
  if ((A->host)->ip < (B->host)->ip) {
#line 357
    return (0);
  }
#line 358
  if ((A->host)->hostname) {
#line 358
    if ((B->host)->hostname) {
      {
#line 359
      a = strcmp((char const   *)(A->host)->hostname, (char const   *)(B->host)->hostname);
      }
#line 360
      if (a > 0) {
#line 360
        return (1);
      }
#line 361
      if (a < 0) {
#line 361
        return (0);
      }
    }
  }
#line 363
  if ((int )(A->host)->port > (int )(B->host)->port) {
#line 363
    return (1);
  }
#line 364
  if ((int )(A->host)->port < (int )(B->host)->port) {
#line 364
    return (0);
  }
#line 365
  if (A->user) {
#line 365
    if (B->user) {
      {
#line 366
      a = strcmp((char const   *)A->user, (char const   *)B->user);
      }
#line 367
      if (a > 0) {
#line 367
        return (1);
      }
#line 368
      if (a < 0) {
#line 368
        return (0);
      }
    }
  }
#line 370
  if (A->pass) {
#line 370
    if (B->pass) {
      {
#line 371
      a = strcmp((char const   *)A->pass, (char const   *)B->pass);
      }
#line 372
      if (a > 0) {
#line 372
        return (1);
      }
#line 373
      if (a < 0) {
#line 373
        return (0);
      }
    }
  }
#line 375
  if (A->target_dname) {
#line 375
    if (B->target_dname) {
      {
#line 376
      a = strcmp((char const   *)A->target_dname, (char const   *)B->target_dname);
      }
#line 377
      if (a > 0) {
#line 377
        return (1);
      }
#line 378
      if (a < 0) {
#line 378
        return (0);
      }
    }
  }
#line 380
  if (A->target_fname) {
#line 380
    if (B->target_fname) {
      {
#line 381
      a = strcmp((char const   *)A->target_fname, (char const   *)B->target_fname);
      }
#line 382
      if (a > 0) {
#line 382
        return (1);
      }
#line 383
      if (a < 0) {
#line 383
        return (0);
      }
    }
  }
  {
#line 385
  tmp = gettext("Warning: ");
#line 385
  printout((unsigned char)1, (char const   *)tmp);
#line 386
  tmp___0 = gettext("Seems as though there are two equivalent entries to upload.\n");
#line 386
  printout((unsigned char)1, (char const   *)tmp___0);
  }
#line 387
  return (0);
}
}
#line 391 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
_fsession *fsession_insert(_fsession *K , _fsession *F ) 
{ 
  int tmp ;

  {
#line 392
  if ((unsigned long )F == (unsigned long )((void *)0)) {
#line 393
    return (K);
  }
  {
#line 394
  tmp = fsession_compare(F, K);
  }
#line 394
  if (tmp) {
#line 395
    K->next = F;
#line 396
    return (K);
  }
  {
#line 398
  F->next = fsession_insert(K, F->next);
  }
#line 399
  return (F);
}
}
#line 415 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void free_fsession(_fsession *F ) 
{ 


  {
  {
#line 416
  fsession_queue_entry_point = F->next;
#line 417
  ftp_free_host(F->host);
  }
#line 418
  if (F->local_fname) {
    {
#line 418
    free((void *)F->local_fname);
    }
  }
#line 419
  if (F->target_dname) {
    {
#line 419
    free((void *)F->target_dname);
    }
  }
#line 420
  if (F->target_fname) {
    {
#line 420
    free((void *)F->target_fname);
    }
  }
#line 421
  if (F->user) {
    {
#line 421
    free((void *)F->pass);
    }
  }
#line 422
  if (F->pass) {
    {
#line 422
    free((void *)F->user);
    }
  }
  {
#line 423
  free((void *)F);
  }
#line 424
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
_fsession *build_fsession(char *file , char *url ) 
{ 
  _fsession *fsession ;
  void *tmp ;
  struct stat statbuf ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int slashlen ;
  char *tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;

  {
  {
#line 430
  tmp = malloc(sizeof(_fsession ));
#line 430
  fsession = (_fsession *)tmp;
#line 434
  memset((void *)fsession, 0, sizeof(_fsession ));
#line 436
  fsession->binary = opt.binary;
#line 437
  fsession->retry = opt.retry;
#line 438
  fsession->resume_table = & opt.resume_table;
#line 440
  tmp___2 = parse_url(fsession, url);
  }
#line 440
  if (tmp___2 == -1) {
    {
#line 441
    tmp___0 = gettext("Error: ");
#line 441
    printout((unsigned char)1, (char const   *)tmp___0);
#line 442
    tmp___1 = gettext("the url `%s\' could not be parsed\n");
#line 442
    printout((unsigned char)1, (char const   *)tmp___1, url);
    }
#line 443
    if (file) {
      {
#line 443
      free((void *)file);
      }
    }
    {
#line 444
    free_fsession(fsession);
#line 445
    printout((unsigned char)4, "fsession free()d\n");
#line 446
    opt.failed = (unsigned short )((int )opt.failed + 1);
    }
#line 447
    return ((_fsession *)((void *)0));
  }
  {
#line 450
  printout((unsigned char)4, "PRE_GUESS: local_file: %s\nremote_path: %s\tremote_file: %s (%x)\n",
           file, fsession->target_dname, fsession->target_fname, fsession->target_fname);
  }
#line 454
  if (! file) {
#line 461
    if (! fsession->target_dname) {
#line 461
      if (! fsession->target_fname) {
        {
#line 462
        tmp___4 = gettext("Warning: ");
#line 462
        printout((unsigned char)1, (char const   *)tmp___4);
#line 463
        tmp___5 = gettext("Neither a remote location nor a local filename has been specified. Assuming you want to upload the current working directory to the remote server.\n");
#line 463
        printout((unsigned char)1, (char const   *)tmp___5);
#line 466
        file = cpy((char *)".");
        }
      } else {
#line 461
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 469
      if (fsession->target_dname) {
        {
#line 469
        tmp___6 = strlen((char const   *)fsession->target_dname);
#line 469
        tmp___7 = tmp___6;
        }
      } else {
#line 469
        tmp___7 = (size_t )0;
      }
#line 469
      if (fsession->target_fname) {
        {
#line 469
        tmp___8 = strlen((char const   *)fsession->target_fname);
#line 469
        tmp___9 = tmp___8;
        }
      } else {
#line 469
        tmp___9 = (size_t )0;
      }
      {
#line 469
      tmp___10 = malloc(((tmp___7 + 1UL) + tmp___9) + 1UL);
#line 469
      file = (char *)tmp___10;
#line 469
      tmp___3 = file;
#line 472
      *(file + 0) = (char)0;
#line 473
      printout((unsigned char)4, "computing local_fname: %s\n", tmp___3);
      }
#line 474
      if (fsession->target_dname) {
        {
#line 475
        strcpy((char */* __restrict  */)file, (char const   */* __restrict  */)fsession->target_dname);
#line 476
        strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
        }
      }
#line 478
      if (fsession->target_fname) {
        {
#line 478
        strcat((char */* __restrict  */)file, (char const   */* __restrict  */)fsession->target_fname);
        }
      }
      {
#line 481
      unescape(file);
#line 490
      printout((unsigned char)4, "Trying to stat \'%s\'... ", file);
      }
      {
#line 492
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 492
        tmp___14 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& statbuf));
        }
#line 492
        if (! (tmp___14 != 0)) {
#line 492
          goto while_break;
        }
        {
#line 493
        file = strchr((char const   *)file, '/');
        }
#line 494
        if (! file) {
#line 497
          if (! fsession->target_fname) {
            {
#line 498
            tmp___11 = gettext("Warning: ");
#line 498
            printout((unsigned char)2, (char const   *)tmp___11);
#line 499
            tmp___12 = gettext("No local file specified and no file found from URL.\nAssuming the current working directory is to be uploaded to the remote server.\n");
#line 499
            printout((unsigned char)2, (char const   *)tmp___12);
#line 502
            file = (char *)".";
            }
#line 503
            goto while_break;
          } else {
#line 505
            file = (char *)"";
#line 506
            goto while_break;
          }
        } else {
#line 509
          file ++;
        }
        {
#line 510
        tmp___13 = __errno_location();
#line 510
        printout((unsigned char)4, "failed! (errno: %d)\nTrying to stat \'%s\'... ",
                 *tmp___13, file);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 512
      file = cpy(file);
#line 513
      printout((unsigned char)4, "file: %s, url: %s\n", file, url);
      }
#line 514
      if ((statbuf.st_mode & 61440U) == 16384U) {
        {
#line 515
        printout((unsigned char)4, "IS_DIR! ");
#line 516
        tmp___15 = strlen((char const   *)url);
#line 516
        tmp___16 = strlen((char const   *)file);
#line 516
        *(url + (tmp___15 - tmp___16)) = (char)0;
        }
      }
      {
#line 519
      printout((unsigned char)4, "done. Found \'%s\' -> %s\n", file, url);
#line 520
      free((void *)tmp___3);
      }
    }
  }
#line 529
  if (! opt.wdel) {
    {
#line 530
    tmp___21 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& statbuf));
    }
#line 530
    if (tmp___21 != 0) {
#line 531
      if (opt.input_pipe) {
        {
#line 533
        tmp___17 = gettext("Warning: ");
#line 533
        printout((unsigned char)3, (char const   *)tmp___17);
#line 534
        tmp___18 = gettext("File `%s\' does not exist. Assuming you supply its input using the -I flag.\n");
#line 534
        printout((unsigned char)3, (char const   *)tmp___18, file);
#line 535
        fsession->local_fname = (char *)((void *)0);
        }
#line 536
        if (! fsession->target_fname) {
          {
#line 537
          printout((unsigned char)2, "TODO USS this might be buggy. Do we know, where to upload?\n");
#line 538
          fsession->target_fname = basename(file);
          }
        }
        {
#line 540
        free((void *)file);
        }
#line 541
        return (fsession);
      } else {
        {
#line 543
        tmp___19 = gettext("Error: ");
#line 543
        printout((unsigned char)1, (char const   *)tmp___19);
#line 544
        tmp___20 = gettext("File `%s\' does not exist. Don\'t know what to do about this URL.\n");
#line 544
        printout((unsigned char)1, (char const   *)tmp___20, file);
#line 545
        free((void *)file);
#line 546
        free_fsession(fsession);
        }
#line 547
        return ((_fsession *)((void *)0));
      }
    } else
#line 552
    if ((statbuf.st_mode & 61440U) == 16384U) {
      {
#line 553
      queue_add_dir(file, url, fsession);
#line 554
      printout((unsigned char)4, "directory added successful\n");
#line 555
      free_fsession(fsession);
#line 556
      printout((unsigned char)4, "fsession free()d\n");
#line 557
      free((void *)file);
      }
#line 558
      return ((_fsession *)((void *)-2));
    }
  }
  {
#line 562
  fsession->local_fname = file;
#line 563
  file = snip_basename(file);
  }
#line 565
  if (! opt.wdel) {
#line 566
    fsession->local_fsize = statbuf.st_size;
#line 569
    fsession->local_ftime = statbuf.st_mtim.tv_sec;
  }
#line 572
  if (! fsession->target_fname) {
    {
#line 572
    tmp___27 = strchr((char const   *)file, '/');
    }
#line 572
    if (tmp___27) {
      {
#line 573
      tmp___22 = strrchr((char const   *)file, '/');
#line 573
      slashlen = (int )(tmp___22 - file);
      }
#line 574
      if (fsession->target_dname) {
        {
#line 575
        tmp___23 = strlen((char const   *)fsession->target_dname);
#line 575
        tmp___24 = realloc((void *)fsession->target_dname, ((tmp___23 + 1UL) + (size_t )slashlen) + 1UL);
#line 575
        fsession->target_dname = (char *)tmp___24;
#line 578
        strcat((char */* __restrict  */)fsession->target_dname, (char const   */* __restrict  */)"/");
        }
      } else {
        {
#line 580
        tmp___25 = malloc((size_t )(slashlen + 1));
#line 580
        fsession->target_dname = (char *)tmp___25;
#line 581
        *(fsession->target_dname) = (char)0;
        }
      }
      {
#line 589
      strncat((char */* __restrict  */)fsession->target_dname, (char const   */* __restrict  */)file,
              (size_t )slashlen);
#line 590
      tmp___26 = basename(file);
#line 590
      fsession->target_fname = cpy(tmp___26);
      }
    } else {
#line 572
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 591
  if (! fsession->target_fname) {
    {
#line 592
    fsession->target_fname = cpy(file);
    }
  }
  {
#line 594
  printout((unsigned char)4, "POST_GUESS: local_file: %s\nremote_path: %s\tremote_file: %s\n",
           fsession->local_fname, fsession->target_dname, fsession->target_fname);
  }
#line 598
  return (fsession);
}
}
#line 605 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void makeskip(_fsession *fsession , char *tmp ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 615
  tmp___0 = cpy(tmp);
  }
#line 615
  if (fsession->pass) {
    {
#line 615
    tmp___1 = cpy(fsession->pass);
#line 615
    tmp___2 = tmp___1;
    }
  } else {
#line 615
    tmp___2 = (char *)((void *)0);
  }
  {
#line 615
  tmp___3 = cpy(fsession->user);
  }
#line 615
  if ((fsession->host)->hostname) {
    {
#line 615
    tmp___4 = cpy((fsession->host)->hostname);
#line 615
    tmp___5 = tmp___4;
    }
  } else {
#line 615
    tmp___5 = (char *)((void *)0);
  }
  {
#line 615
  opt.skipdlist = skiplist_add_entry(opt.skipdlist, (int )(fsession->host)->ip, tmp___5,
                                     (fsession->host)->port, tmp___3, tmp___2, tmp___0);
  }
#line 618
  return;
}
}
#line 620 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void skiplist_free(skipd_list *K ) 
{ 
  skipd_list *N ;

  {
#line 622
  if ((unsigned long )K == (unsigned long )((void *)0)) {
#line 622
    return;
  }
#line 623
  N = K->next;
#line 624
  if (K->host) {
    {
#line 624
    free((void *)K->host);
    }
  }
#line 625
  if (K->dir) {
    {
#line 625
    free((void *)K->dir);
    }
  }
#line 626
  if (K->user) {
    {
#line 626
    free((void *)K->user);
    }
  }
#line 627
  if (K->pass) {
    {
#line 627
    free((void *)K->pass);
    }
  }
  {
#line 628
  free((void *)K);
#line 629
  skiplist_free(N);
  }
#line 630
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
skipd_list *skiplist_add_entry(skipd_list *K , int ip , char *host , unsigned short port ,
                               char *user , char *pass , char *dir ) 
{ 
  skipd_list *N ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 632
  if ((unsigned long )K == (unsigned long )((void *)0)) {
    {
#line 633
    tmp = malloc(sizeof(skipd_list ));
#line 633
    N = (skipd_list *)tmp;
#line 634
    N->ip = ip;
#line 635
    N->host = host;
#line 636
    N->port = port;
#line 637
    N->user = user;
#line 638
    N->pass = pass;
#line 639
    N->dir = dir;
#line 640
    N->next = (struct _skipd_list *)((void *)0);
    }
#line 642
    if (ip) {
      {
#line 642
      tmp___0 = printip((unsigned char *)(& ip));
#line 642
      tmp___1 = tmp___0;
      }
    } else {
#line 642
      tmp___1 = host;
    }
    {
#line 642
    printout((unsigned char)4, "Added skip_entry ftp://%s:%s@%s:%d/%s\n", user, pass,
             tmp___1, (int )port, dir);
    }
#line 645
    return (N);
  }
  {
#line 647
  K->next = skiplist_add_entry(K->next, ip, host, port, user, pass, dir);
  }
#line 648
  return (K);
}
}
#line 651 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
int skiplist_find_entry(int ip , char *host , unsigned short port , char *user , char *pass ,
                        char *dir ) 
{ 
  skipd_list *K ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
#line 652
  K = opt.skipdlist;
#line 653
  if (ip) {
    {
#line 653
    tmp = printip((unsigned char *)(& ip));
#line 653
    tmp___0 = tmp;
    }
  } else {
#line 653
    tmp___0 = host;
  }
  {
#line 653
  printout((unsigned char)4, "Searching for skip_entry ftp://%s:%s@%s:%d/%s\n", user,
           pass, tmp___0, (int )port, dir);
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (! ((unsigned long )K != (unsigned long )((void *)0))) {
#line 655
      goto while_break;
    }
#line 657
    if (ip) {
      {
#line 657
      tmp___1 = printip((unsigned char *)(& K->ip));
#line 657
      tmp___2 = tmp___1;
      }
    } else {
#line 657
      tmp___2 = host;
    }
    {
#line 657
    printout((unsigned char)4, "Checking skip_entry ftp://%s:%s@%s:%d/%s\n", K->user,
             K->pass, tmp___2, (int )K->port, K->dir);
    }
#line 660
    if (K->ip == ip) {
#line 660
      if (ip != 0) {
#line 660
        goto _L___0;
      } else {
#line 660
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 660
    if (K->host) {
#line 660
      if (host) {
        {
#line 660
        tmp___3 = strcmp((char const   *)K->host, (char const   *)host);
        }
#line 660
        if (! tmp___3) {
          _L___0: /* CIL Label */ 
#line 660
          if ((int )K->port == (int )port) {
            {
#line 660
            tmp___4 = strcmp((char const   *)K->user, (char const   *)user);
            }
#line 660
            if (! tmp___4) {
#line 660
              if ((unsigned long )pass == (unsigned long )K->pass) {
#line 660
                goto _L;
              } else
#line 660
              if (K->pass) {
#line 660
                if (pass) {
                  {
#line 660
                  tmp___5 = strcmp((char const   *)K->pass, (char const   *)pass);
                  }
#line 660
                  if (! tmp___5) {
                    _L: /* CIL Label */ 
#line 660
                    if ((unsigned long )K->dir == (unsigned long )((void *)0)) {
#line 666
                      goto while_break;
                    } else
#line 660
                    if (dir) {
                      {
#line 660
                      tmp___6 = strlen((char const   *)K->dir);
#line 660
                      tmp___7 = strncmp((char const   *)K->dir, (char const   *)dir,
                                        tmp___6);
                      }
#line 660
                      if (! tmp___7) {
#line 666
                        goto while_break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 667
    K = K->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 669
  if ((unsigned long )K == (unsigned long )((void *)0)) {
#line 669
    return (0);
  }
#line 670
  return (1);
}
}
#line 674 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
password_list *password_list_add(password_list *K , char *host , char *user , char *pass ) 
{ 
  void *tmp ;

  {
#line 675
  if ((unsigned long )K == (unsigned long )((void *)0)) {
    {
#line 676
    tmp = malloc(sizeof(password_list ));
#line 676
    K = (password_list *)tmp;
#line 677
    K->host = host;
#line 678
    K->user = user;
#line 679
    K->pass = pass;
#line 680
    K->next = (struct _password_list *)((void *)0);
    }
  } else {
    {
#line 682
    K->next = password_list_add(K->next, host, user, pass);
    }
  }
#line 683
  return (K);
}
}
#line 688 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
password_list *password_list_find(password_list *K , char *host , char *user ) 
{ 
  password_list *R ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 689
  R = (password_list *)((void *)0);
#line 690
  if (! K) {
#line 690
    return (R);
  }
  {
#line 691
  tmp = strcmp((char const   *)K->host, (char const   *)host);
  }
#line 691
  if (! tmp) {
#line 691
    if (! user) {
#line 692
      return (K);
    } else {
      {
#line 691
      tmp___0 = strcmp((char const   *)K->user, (char const   *)user);
      }
#line 691
      if (! tmp___0) {
#line 692
        return (K);
      }
    }
  }
  {
#line 693
  R = password_list_find(K->next, host, user);
#line 694
  tmp___1 = strcmp((char const   *)K->host, (char const   *)host);
  }
#line 694
  if (! tmp___1) {
#line 694
    if (! R) {
#line 695
      return (K);
    }
  }
#line 696
  return (R);
}
}
#line 698 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/queue.c"
void password_list_free(password_list *K ) 
{ 


  {
#line 699
  if (K->next) {
    {
#line 699
    password_list_free(K->next);
    }
  }
  {
#line 700
  free((void *)K->host);
#line 701
  free((void *)K->user);
#line 702
  free((void *)K->pass);
#line 703
  free((void *)K);
  }
#line 704
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 20 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.h"
unsigned char get_filemode(char *filename ) ;
#line 21
char *get_port_fmt(int ip , unsigned int port ) ;
#line 27
void clear_path(char *path ) ;
#line 28
char *get_relative_path(char *src , char *dst ) ;
#line 35
char *int64toa(off_t num , char *buf___2 , int con_unit ) ;
#line 44
int numdigit(long number ) ;
#line 47
void retry_wait(_fsession *fsession ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
unsigned char get_filemode(char *filename ) 
{ 
  char *txtfiles[36] ;
  int i ;
  int k ;
  char *suffix ;
  int dotpos ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 29
  txtfiles[0] = (char *)"txt";
#line 29
  txtfiles[1] = (char *)"c";
#line 29
  txtfiles[2] = (char *)"java";
#line 29
  txtfiles[3] = (char *)"cpp";
#line 29
  txtfiles[4] = (char *)"sh";
#line 29
  txtfiles[5] = (char *)"f";
#line 29
  txtfiles[6] = (char *)"f90";
#line 29
  txtfiles[7] = (char *)"f77";
#line 29
  txtfiles[8] = (char *)"f95";
#line 29
  txtfiles[9] = (char *)"bas";
#line 29
  txtfiles[10] = (char *)"pro";
#line 29
  txtfiles[11] = (char *)"csh";
#line 29
  txtfiles[12] = (char *)"ksh";
#line 29
  txtfiles[13] = (char *)"conf";
#line 29
  txtfiles[14] = (char *)"htm";
#line 29
  txtfiles[15] = (char *)"html";
#line 29
  txtfiles[16] = (char *)"php";
#line 29
  txtfiles[17] = (char *)"pl";
#line 29
  txtfiles[18] = (char *)"cgi";
#line 29
  txtfiles[19] = (char *)"inf";
#line 29
  txtfiles[20] = (char *)"js";
#line 29
  txtfiles[21] = (char *)"asp";
#line 29
  txtfiles[22] = (char *)"bat";
#line 29
  txtfiles[23] = (char *)"cfm";
#line 29
  txtfiles[24] = (char *)"css";
#line 29
  txtfiles[25] = (char *)"dhtml";
#line 29
  txtfiles[26] = (char *)"diz";
#line 29
  txtfiles[27] = (char *)"h";
#line 29
  txtfiles[28] = (char *)"hpp";
#line 29
  txtfiles[29] = (char *)"ini";
#line 29
  txtfiles[30] = (char *)"mak";
#line 29
  txtfiles[31] = (char *)"nfo";
#line 29
  txtfiles[32] = (char *)"shtml";
#line 29
  txtfiles[33] = (char *)"shtm";
#line 29
  txtfiles[34] = (char *)"tcl";
#line 29
  txtfiles[35] = (char *)"pas";
#line 35
  tmp = strlen((char const   *)filename);
#line 35
  dotpos = (int )tmp;
#line 36
  tmp___0 = strchr((char const   *)filename, '.');
  }
#line 36
  if (tmp___0) {
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      dotpos --;
#line 37
      if (! ((int )*(filename + dotpos) != 46)) {
#line 37
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 40
  dotpos ++;
#line 40
  suffix = filename + dotpos;
#line 41
  tmp___1 = strlen((char const   *)suffix);
#line 41
  k = (int )tmp___1;
#line 42
  i = 0;
  }
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 42
    if (k > 0) {
#line 42
      if (! (i < 14)) {
#line 42
        goto while_break___0;
      }
    } else {
#line 42
      goto while_break___0;
    }
    {
#line 43
    tmp___2 = strncasecmp((char const   *)suffix, (char const   *)txtfiles[i], (size_t )k);
    }
#line 43
    if (tmp___2 == 0) {
#line 44
      return ((unsigned char)0);
    }
#line 42
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 45
  return ((unsigned char)1);
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
void Abort(char *msg ) 
{ 


  {
  {
#line 48
  fprintf((FILE */* __restrict  */)opt.output, (char const   */* __restrict  */)"%s",
          msg);
#line 49
  exit(1);
  }
}
}
#line 56 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *int64toa(off_t num , char *buf___2 , int con_unit ) 
{ 
  off_t tmp ;

  {
#line 57
  tmp = num;
#line 58
  if (num == 0L) {
#line 59
    *(buf___2 + 0) = (char )'0';
#line 59
    *(buf___2 + 1) = (char)0;
#line 61
    return (buf___2);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (tmp > 0L)) {
#line 63
      goto while_break;
    }
#line 64
    buf___2 ++;
#line 65
    tmp /= (off_t )con_unit;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  *buf___2 = (char)0;
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (num > 0L)) {
#line 68
      goto while_break___0;
    }
#line 69
    buf___2 --;
#line 69
    *buf___2 = (char )(48 + (int )((char )(num % (long )con_unit)));
#line 70
    num /= (off_t )con_unit;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 72
  return (buf___2);
}
}
#line 77 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
static char buf[24]  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *get_port_fmt(int ip , unsigned int port ) 
{ 
  unsigned char b[6] ;
  uint16_t tmp ;

  {
  {
#line 79
  *((int *)(b)) = ip;
#line 80
  tmp = htons((uint16_t )port);
#line 80
  *((unsigned int *)(b + 4)) = (unsigned int )tmp;
#line 81
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d,%d,%d,%d,%d,%d",
          (int )b[0], (int )b[1], (int )b[2], (int )b[3], (int )b[4], (int )b[5]);
  }
#line 82
  return (buf);
}
}
#line 85 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
void printout(unsigned char verbose , char const   *fmt  , ...) 
{ 
  va_list argp ;
  char const   *p ;
  off_t i ;
  char *s ;
  char fmtbuf[256] ;
  off_t tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  char *tmp___2 ;
  off_t tmp___3 ;
  off_t tmp___4 ;
  off_t tmp___5 ;

  {
#line 94
  if ((int )opt.verbose >= (int )verbose) {
    {
#line 97
    __builtin_va_start(argp, fmt);
#line 99
    p = fmt;
    }
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;
#line 99
      if (! ((int const   )*p != 0)) {
#line 99
        goto while_break;
      }
#line 101
      if ((int const   )*p != 37) {
        {
#line 103
        _IO_putc((int )*p, opt.output);
        }
#line 104
        goto __Cont;
      }
#line 107
      p ++;
      {
#line 109
      if ((int const   )*p == 99) {
#line 109
        goto case_99;
      }
#line 115
      if ((int const   )*p == 100) {
#line 115
        goto case_100;
      }
#line 115
      if ((int const   )*p == 108) {
#line 115
        goto case_100;
      }
#line 124
      if ((int const   )*p == 115) {
#line 124
        goto case_115;
      }
#line 130
      if ((int const   )*p == 120) {
#line 130
        goto case_120;
      }
#line 137
      if ((int const   )*p == 42) {
#line 137
        goto case_42;
      }
#line 144
      if ((int const   )*p == 37) {
#line 144
        goto case_37;
      }
#line 107
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 110
      tmp = __builtin_va_arg(argp, int );
#line 110
      i = tmp;
#line 111
      _IO_putc((int )i, opt.output);
      }
#line 112
      goto switch_break;
      case_100: /* CIL Label */ 
      case_108: /* CIL Label */ 
#line 116
      if ((int const   )*p == 108) {
        {
#line 117
        tmp___0 = __builtin_va_arg(argp, off_t );
#line 117
        i = tmp___0;
        }
      } else {
        {
#line 119
        tmp___1 = __builtin_va_arg(argp, int );
#line 119
        i = tmp___1;
        }
      }
      {
#line 120
      s = int64toa(i, fmtbuf, 10);
#line 121
      fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)opt.output);
      }
#line 122
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 125
      tmp___2 = __builtin_va_arg(argp, char *);
#line 125
      s = tmp___2;
      }
#line 126
      if ((unsigned long )s != (unsigned long )((void *)0)) {
        {
#line 127
        fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)opt.output);
        }
      }
#line 128
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 131
      tmp___3 = __builtin_va_arg(argp, int );
#line 131
      i = tmp___3;
#line 132
      sprintf((char */* __restrict  */)(fmtbuf), (char const   */* __restrict  */)"%x",
              (int )i);
#line 134
      fputs((char const   */* __restrict  */)(fmtbuf), (FILE */* __restrict  */)opt.output);
      }
#line 135
      goto switch_break;
      case_42: /* CIL Label */ 
      {
#line 138
      tmp___4 = __builtin_va_arg(argp, int );
#line 138
      i = tmp___4;
#line 139
      p ++;
      }
      {
#line 140
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 140
        tmp___5 = i;
#line 140
        i --;
#line 140
        if (! (tmp___5 > 0L)) {
#line 140
          goto while_break___0;
        }
        {
#line 141
        _IO_putc((int )*p, opt.output);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 142
      goto switch_break;
      case_37: /* CIL Label */ 
      {
#line 145
      _IO_putc('%', opt.output);
      }
#line 146
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 99
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 150
    __builtin_va_end(argp);
#line 151
    fflush(opt.output);
    }
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
int file_exists(char const   *filename ) 
{ 
  struct stat buf___2 ;
  int tmp ;

  {
#line 162
  if (! filename) {
#line 162
    return (0);
  }
  {
#line 163
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& buf___2));
  }
#line 163
  return (tmp >= 0);
}
}
#line 167 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *home_dir(void) 
{ 
  char *home ;
  char *tmp ;
  struct passwd *pwd ;
  __uid_t tmp___0 ;
  struct passwd *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 169
  tmp = getenv("HOME");
#line 169
  home = tmp;
  }
#line 171
  if (! home) {
    {
#line 176
    tmp___0 = getuid();
#line 176
    tmp___1 = getpwuid(tmp___0);
#line 176
    pwd = tmp___1;
    }
#line 177
    if (! pwd) {
#line 178
      return ((char *)((void *)0));
    } else
#line 177
    if (! pwd->pw_dir) {
#line 178
      return ((char *)((void *)0));
    }
#line 179
    home = pwd->pw_dir;
  }
#line 186
  if (home) {
    {
#line 186
    tmp___2 = cpy(home);
#line 186
    tmp___3 = tmp___2;
    }
  } else {
#line 186
    tmp___3 = (char *)((void *)0);
  }
#line 186
  return (tmp___3);
}
}
#line 189 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *read_line(FILE *fp ) 
{ 
  int length ;
  int bufsize ;
  char *line ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 191
  length = 0;
#line 192
  bufsize = 82;
#line 193
  tmp = malloc((size_t )bufsize);
#line 193
  line = (char *)tmp;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    tmp___2 = fgets((char */* __restrict  */)(line + length), bufsize - length, (FILE */* __restrict  */)fp);
    }
#line 195
    if (! tmp___2) {
#line 195
      goto while_break;
    }
    {
#line 197
    tmp___0 = strlen((char const   *)(line + length));
#line 197
    length = (int )((size_t )length + tmp___0);
    }
#line 199
    if ((int )*(line + (length - 1)) == 10) {
#line 200
      goto while_break;
    }
    {
#line 205
    bufsize <<= 1;
#line 206
    tmp___1 = realloc((void *)line, (size_t )bufsize);
#line 206
    line = (char *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  if (length == 0) {
    {
#line 210
    free((void *)line);
    }
#line 211
    return ((char *)((void *)0));
  } else {
    {
#line 208
    tmp___3 = ferror(fp);
    }
#line 208
    if (tmp___3) {
      {
#line 210
      free((void *)line);
      }
#line 211
      return ((char *)((void *)0));
    }
  }
#line 213
  if (length + 1 < bufsize) {
    {
#line 218
    tmp___4 = realloc((void *)line, (size_t )(length + 1));
#line 218
    line = (char *)tmp___4;
    }
  }
#line 219
  return (line);
}
}
#line 223 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
int isspace(int c ) 
{ 


  {
  {
#line 228
  if (c == 10) {
#line 228
    goto case_10;
  }
#line 228
  if (c == 13) {
#line 228
    goto case_10;
  }
#line 228
  if (c == 9) {
#line 228
    goto case_10;
  }
#line 228
  if (c == 32) {
#line 228
    goto case_10;
  }
#line 224
  goto switch_break;
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 228
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 230
  return (0);
}
}
#line 236 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
static char rv[16]  ;
#line 235 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *printip(unsigned char *ip ) 
{ 


  {
  {
#line 237
  sprintf((char */* __restrict  */)(rv), (char const   */* __restrict  */)"%d.%d.%d.%d",
          (int )*(ip + 0), (int )*(ip + 1), (int )*(ip + 2), (int )*(ip + 3));
  }
#line 238
  return (rv);
}
}
#line 240 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
int hextoi(char h ) 
{ 
  char *tmp ;

  {
#line 241
  if ((int )h >= 65) {
#line 241
    if ((int )h <= 70) {
#line 242
      return (((int )h - 65) + 10);
    }
  }
#line 243
  if ((int )h >= 97) {
#line 243
    if ((int )h <= 102) {
#line 244
      return (((int )h - 97) + 10);
    }
  }
#line 245
  if ((int )h >= 48) {
#line 245
    if ((int )h <= 57) {
#line 246
      return ((int )h - 48);
    }
  }
  {
#line 247
  tmp = gettext("parse-error in escaped character: %c is not a hexadecimal character\n");
#line 247
  printout((unsigned char)3, (char const   *)tmp, (int )h);
#line 249
  exit(1);
  }
}
}
#line 253 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *unescape(char *str ) 
{ 
  char *ptr ;
  char *org ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 254
  ptr = str;
#line 255
  org = str;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! *ptr) {
#line 256
      goto while_break;
    }
#line 257
    if ((int )*ptr == 37) {
      {
#line 258
      ptr += 2;
#line 259
      tmp = hextoi(*(ptr - 1));
#line 259
      tmp___0 = hextoi(*ptr);
#line 259
      *ptr = (char )((tmp << 4) + tmp___0);
      }
    }
#line 261
    tmp___1 = str;
#line 261
    str ++;
#line 261
    tmp___2 = ptr;
#line 261
    ptr ++;
#line 261
    *tmp___1 = *tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  *str = *ptr;
#line 264
  return (org);
}
}
#line 268 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
void retry_wait(_fsession *fsession ) 
{ 
  char *tmp ;

  {
#line 269
  if ((int )fsession->retry > 0) {
#line 269
    fsession->retry = (short )((int )fsession->retry - 1);
  }
#line 270
  if ((int )fsession->retry > 0) {
    {
#line 271
    tmp = gettext("Waiting %d seconds... ");
#line 271
    printout((unsigned char)1, (char const   *)tmp, (int )opt.retry_interval);
#line 272
    sleep((unsigned int )opt.retry_interval);
    }
  } else
#line 270
  if ((int )fsession->retry == -1) {
    {
#line 271
    tmp = gettext("Waiting %d seconds... ");
#line 271
    printout((unsigned char)1, (char const   *)tmp, (int )opt.retry_interval);
#line 272
    sleep((unsigned int )opt.retry_interval);
    }
  }
#line 274
  return;
}
}
#line 279 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
void parse_proxy(char *url ) 
{ 
  char *p ;
  char *host ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 281
  if (! url) {
#line 281
    return;
  }
  {
#line 283
  tmp___1 = strncmp((char const   *)url, "http://", (size_t )7);
  }
#line 283
  if (tmp___1 != 0) {
    {
#line 284
    tmp = gettext("Warning: ");
#line 284
    printout((unsigned char)3, (char const   *)tmp);
#line 285
    tmp___0 = gettext("No http-header found. Assuming socks-proxy $host:$port for `%s\'\n");
#line 285
    printout((unsigned char)3, (char const   *)tmp___0, url);
#line 286
    opt.ps.type = 1U;
#line 287
    url = cpy(url);
    }
  } else {
    {
#line 289
    url = cpy(url + 7);
#line 290
    opt.ps.type = 2U;
    }
  }
  {
#line 293
  p = strchr((char const   *)url, '@');
  }
#line 294
  if (p) {
#line 295
    tmp___2 = p;
#line 295
    p ++;
#line 295
    *tmp___2 = (char)0;
#line 295
    host = p;
  } else {
#line 297
    host = url;
  }
#line 299
  if (p) {
    {
#line 300
    p = strchr((char const   *)url, ':');
    }
#line 301
    if (p) {
      {
#line 302
      tmp___3 = p;
#line 302
      p ++;
#line 302
      *tmp___3 = (char)0;
#line 303
      tmp___4 = unescape(p);
#line 303
      set_option((char *)"proxy_pass", tmp___4);
      }
    }
    {
#line 305
    tmp___5 = unescape(url);
#line 305
    set_option((char *)"proxy_user", tmp___5);
    }
  }
  {
#line 308
  p = strchr((char const   *)host, ':');
  }
#line 309
  if (! p) {
#line 310
    if (opt.ps.type == 1U) {
#line 310
      opt.ps.port = (unsigned short)1080;
    } else {
#line 310
      opt.ps.port = (unsigned short)3128;
    }
    {
#line 311
    tmp___6 = gettext("Warning: ");
#line 311
    printout((unsigned char)3, (char const   *)tmp___6);
#line 312
    tmp___7 = gettext("No port specified. Assuming default port %d.\n");
#line 312
    printout((unsigned char)3, (char const   *)tmp___7, (int )opt.ps.port);
    }
  } else {
    {
#line 314
    set_option((char *)"proxy_port", p + 1);
#line 315
    *p = (char)0;
    }
  }
  {
#line 317
  set_option((char *)"proxy_host", host);
#line 318
  free((void *)url);
  }
#line 319
  return;
}
}
#line 328 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
static char outbuf[48]  ;
#line 325 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
static char *legible_1(char const   *repr ) 
{ 
  int i ;
  int i1 ;
  int mod ;
  char *outptr ;
  char const   *inptr ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 334
  outptr = outbuf;
#line 335
  inptr = repr;
#line 339
  if ((int const   )*inptr == 45) {
#line 341
    tmp = outptr;
#line 341
    outptr ++;
#line 341
    *tmp = (char )'-';
#line 342
    inptr ++;
  }
  {
#line 345
  tmp___0 = strlen(inptr);
#line 345
  mod = (int )(tmp___0 % 3UL);
#line 347
  i = 0;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (i < mod)) {
#line 347
      goto while_break;
    }
#line 348
    tmp___1 = outptr;
#line 348
    outptr ++;
#line 348
    *tmp___1 = (char )*(inptr + i);
#line 347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  i1 = i;
#line 351
  i = 0;
  {
#line 351
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 351
    if (! *(inptr + i1)) {
#line 351
      goto while_break___0;
    }
#line 353
    if (i % 3 == 0) {
#line 353
      if (i1 != 0) {
#line 354
        tmp___2 = outptr;
#line 354
        outptr ++;
#line 354
        *tmp___2 = (char )',';
      }
    }
#line 355
    tmp___3 = outptr;
#line 355
    outptr ++;
#line 355
    *tmp___3 = (char )*(inptr + i1);
#line 351
    i ++;
#line 351
    i1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 358
  *outptr = (char )'\000';
#line 359
  return (outbuf);
}
}
#line 363 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *legible(off_t l ) 
{ 
  char inbuf[24] ;
  char *tmp ;

  {
  {
#line 368
  int64toa(l, inbuf, 10);
#line 369
  tmp = legible_1((char const   *)(inbuf));
  }
#line 369
  return (tmp);
}
}
#line 373 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
int numdigit(long number ) 
{ 
  int cnt ;

  {
#line 375
  cnt = 1;
#line 376
  if (number < 0L) {
#line 378
    number = - number;
#line 379
    cnt ++;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    number /= 10L;
#line 381
    if (! (number > 0L)) {
#line 381
      goto while_break;
    }
#line 382
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return (cnt);
}
}
#line 388 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *cpy(char *s ) 
{ 
  char *t ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 389
  tmp = strlen((char const   *)s);
#line 389
  tmp___0 = malloc(tmp + 1UL);
#line 389
  t = (char *)tmp___0;
#line 390
  strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)s);
  }
#line 391
  return (t);
}
}
#line 396 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *basename(char *p ) 
{ 
  char *t ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 397
  tmp = strlen((char const   *)p);
#line 397
  t = p + tmp;
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if ((int )*t != 47) {
#line 398
      if (! ((unsigned long )t != (unsigned long )p)) {
#line 398
        goto while_break;
      }
    } else {
#line 398
      goto while_break;
    }
#line 398
    t --;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  if ((unsigned long )t == (unsigned long )p) {
#line 399
    tmp___0 = t;
  } else {
#line 399
    tmp___0 = t + 1;
  }
#line 399
  return (tmp___0);
}
}
#line 402 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *snip_basename(char *file ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 403
  if (opt.basename) {
#line 403
    if (file) {
      {
#line 404
      tmp___3 = strlen((char const   *)opt.basename);
#line 404
      tmp___4 = strncmp((char const   *)opt.basename, (char const   *)file, tmp___3);
      }
#line 404
      if (tmp___4) {
#line 406
        if ((int )*(file + 0) == 46) {
#line 406
          if ((int )*(file + 1) == 47) {
            {
#line 406
            tmp___1 = strlen((char const   *)opt.basename);
#line 406
            tmp___2 = strncmp((char const   *)opt.basename, (char const   *)(file + 2),
                              tmp___1);
            }
#line 406
            if (! tmp___2) {
              {
#line 407
              tmp___0 = strlen((char const   *)opt.basename);
              }
#line 407
              return ((file + 2) + tmp___0);
            }
          }
        }
      } else {
        {
#line 405
        tmp = strlen((char const   *)opt.basename);
        }
#line 405
        return (file + tmp);
      }
    }
  }
#line 409
  return (file);
}
}
#line 415 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
void clear_path(char *path ) 
{ 
  char *src ;
  char *dst ;
  char *org ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 416
  src = path;
#line 417
  dst = path;
#line 418
  org = path;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! *src) {
#line 419
      goto while_break;
    }
#line 420
    if ((int )*(src + 0) == 47) {
#line 420
      if ((int )*(src + 1) == 46) {
#line 420
        if ((int )*(src + 2) == 46) {
#line 420
          if ((int )*(src + 3) == 47) {
#line 420
            goto _L___4;
          } else
#line 420
          if ((int )*(src + 3) == 0) {
#line 420
            goto _L___4;
          } else {
#line 420
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 420
        if ((int )*(src + 2) == 47) {
#line 420
          goto _L___4;
        } else
#line 420
        if ((int )*(src + 2) == 0) {
          _L___4: /* CIL Label */ 
#line 420
          if ((unsigned long )dst != (unsigned long )org) {
#line 421
            if ((int )*(src + 2) == 46) {
#line 421
              if ((int )*(src + 3) == 47) {
#line 421
                goto _L___1;
              } else
#line 421
              if ((int )*(src + 3) == 0) {
                _L___1: /* CIL Label */ 
#line 422
                if ((unsigned long )(dst - 2) == (unsigned long )org) {
                  {
#line 422
                  tmp___1 = strncmp((char const   *)(dst - 2), "..", (size_t )2);
                  }
#line 422
                  if (tmp___1) {
#line 422
                    goto _L;
                  } else {
#line 422
                    tmp = dst;
#line 422
                    dst ++;
#line 422
                    tmp___0 = src;
#line 422
                    src ++;
#line 422
                    *tmp = *tmp___0;
                  }
                } else {
                  _L: /* CIL Label */ 
                  {
#line 422
                  tmp___2 = strncmp((char const   *)(dst - 3), "/..", (size_t )3);
                  }
#line 422
                  if (tmp___2) {
                    {
#line 424
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 424
                      if ((unsigned long )dst >= (unsigned long )org) {
#line 424
                        dst --;
#line 424
                        if (! ((int )*dst != 47)) {
#line 424
                          goto while_break___0;
                        }
                      } else {
#line 424
                        goto while_break___0;
                      }
                    }
                    while_break___0: /* CIL Label */ ;
                    }
#line 425
                    if ((unsigned long )dst < (unsigned long )org) {
#line 425
                      dst ++;
                    }
#line 426
                    src += 3;
                  } else {
#line 422
                    tmp = dst;
#line 422
                    dst ++;
#line 422
                    tmp___0 = src;
#line 422
                    src ++;
#line 422
                    *tmp = *tmp___0;
                  }
                }
              } else {
#line 421
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 428
            if ((int )*(src + 2) == 47) {
#line 429
              src += 2;
            } else
#line 428
            if ((int )*(src + 2) == 0) {
#line 429
              src += 2;
            }
          } else {
#line 420
            goto _L___6;
          }
        } else {
#line 420
          goto _L___6;
        }
      } else {
#line 420
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 431
      if ((int )*src == 47) {
#line 431
        if ((unsigned long )dst == (unsigned long )org) {
#line 431
          src ++;
        }
      }
#line 432
      tmp___3 = dst;
#line 432
      dst ++;
#line 432
      tmp___4 = src;
#line 432
      src ++;
#line 432
      *tmp___3 = *tmp___4;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  *dst = (char)0;
#line 436
  return;
}
}
#line 441 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/utils.c"
char *get_relative_path(char *src , char *dst ) 
{ 
  char *tmp ;
  char *mark_src ;
  char *mark_dst ;
  int counter ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
#line 442
  tmp = dst;
#line 443
  mark_src = src;
#line 444
  mark_dst = dst;
#line 445
  counter = 1;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if ((int )*src != 0) {
#line 448
      if ((int )*dst != 0) {
#line 448
        if (! ((int )*src == (int )*dst)) {
#line 448
          goto while_break;
        }
      } else {
#line 448
        goto while_break;
      }
    } else {
#line 448
      goto while_break;
    }
#line 449
    if ((int )*src == 47) {
#line 450
      mark_src = src + 1;
#line 451
      mark_dst = dst + 1;
    }
#line 453
    src ++;
#line 453
    dst ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if ((int )*src == 47) {
#line 456
    if ((int )*dst == 0) {
#line 457
      mark_src = src + 1;
#line 458
      mark_dst = dst;
    }
  }
#line 461
  if ((int )*src == 0) {
#line 461
    if ((int )*dst == 47) {
      {
#line 461
      tmp___0 = cpy(dst + 1);
      }
#line 461
      return (tmp___0);
    }
  }
#line 464
  tmp = mark_src;
  {
#line 465
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 465
    tmp___1 = tmp;
#line 465
    tmp ++;
#line 465
    if (! ((int )*tmp___1 != 0)) {
#line 465
      goto while_break___0;
    }
#line 465
    if ((int )*tmp == 47) {
#line 465
      counter ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 466
  tmp___2 = strlen((char const   *)mark_dst);
#line 466
  tmp___3 = malloc(((size_t )(counter * 3) + tmp___2) + 1UL);
#line 466
  tmp = (char *)tmp___3;
#line 467
  *tmp = (char)0;
  }
  {
#line 468
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 468
    tmp___4 = counter;
#line 468
    counter --;
#line 468
    if (! (tmp___4 > 0)) {
#line 468
      goto while_break___1;
    }
    {
#line 469
    strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)"../");
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 470
  strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)mark_dst);
#line 472
  tmp___6 = strlen((char const   *)tmp);
  }
#line 472
  if ((int )*(tmp + (tmp___6 - 1UL)) == 47) {
    {
#line 472
    tmp___5 = strlen((char const   *)tmp);
#line 472
    *(tmp + (tmp___5 - 1UL)) = (char)0;
    }
  }
#line 473
  return (tmp);
}
}
#line 49 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.h"
void socket_close(wput_socket *sock ) ;
#line 56
int socket_write(wput_socket *sock , void *buf___2 , size_t len ) ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
host_t *ftp_new_host(unsigned int ip , char *hostname , unsigned short port ) ;
#line 88
ftp_con *ftp_new(host_t *host , int secure ) ;
#line 95
int ftp_get_msg(ftp_con *self ) ;
#line 99
int ftp_connect(ftp_con *self , proxy_settings *ps ) ;
#line 100
int ftp_login(ftp_con *self , char *user , char *pass ) ;
#line 106
int ftp_do_abor(ftp_con *self ) ;
#line 107
void ftp_do_quit(ftp_con *self ) ;
#line 108
int ftp_do_cwd(ftp_con *self , char *directory ) ;
#line 109
int ftp_do_mkd(ftp_con *self , char *directory ) ;
#line 110
int ftp_do_chmod(ftp_con *self , char *lfile , char *rfile ) ;
#line 112
int ftp_get_modification_time(ftp_con *self , char *filename , time_t *timestamp ) ;
#line 113
int ftp_get_filesize(ftp_con *self , char *filename , off_t *filesize ) ;
#line 114
int ftp_get_fileinfo(ftp_con *self , char *filename , struct fileinfo **info ) ;
#line 115
int ftp_set_type(ftp_con *self , int type ) ;
#line 118
int ftp_get_list(ftp_con *self ) ;
#line 119
int ftp_do_rest(ftp_con *self , off_t filesize ) ;
#line 120
int ftp_do_stor(ftp_con *self , char *filename ) ;
#line 121
int ftp_do_dele(ftp_con *self , char *filename ) ;
#line 122
int ftp_do_rmd(ftp_con *self , char *dirname ) ;
#line 124
int ftp_establish_data_connection(ftp_con *self ) ;
#line 125
int ftp_complete_data_connection(ftp_con *self ) ;
#line 134
struct fileinfo *ftp_get_current_directory_list(ftp_con *self ) ;
#line 43 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.h"
int do_cwd(_fsession *fsession , char *targetdir ) ;
#line 44
int long_do_cwd(_fsession *fsession ) ;
#line 45
int try_do_cwd(ftp_con *ftp , char *path , int mkd ) ;
#line 47
int do_send(_fsession *fsession ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 873 "/usr/include/stdio.h"
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.h"
void bar_create(_fsession *fsession ) ;
#line 26
void bar_update(_fsession *fsession , off_t transfered , int transfered_last , struct wput_timer *last ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
int long_do_cwd(_fsession *fsession ) 
{ 
  int res ;
  char *unescaped ;
  char *tmp ;
  char *tmpbuf ;
  char *ptr ;
  char *tmp___0 ;

  {
  {
#line 35
  res = 0;
#line 37
  tmp = cpy(fsession->target_dname);
#line 37
  unescaped = tmp;
#line 38
  tmpbuf = unescaped;
#line 41
  clear_path(unescaped);
  }
#line 42
  if ((fsession->ftp)->current_directory) {
    {
#line 43
    unescaped = get_relative_path((fsession->ftp)->current_directory, unescaped);
#line 44
    free((void *)tmpbuf);
#line 45
    tmpbuf = unescaped;
    }
  }
  {
#line 53
  tmpbuf = strtok((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)"/");
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! tmpbuf) {
#line 54
      goto while_break;
    }
    {
#line 56
    tmp___0 = cpy(tmpbuf);
#line 56
    ptr = unescape(tmp___0);
#line 57
    res = try_do_cwd(fsession->ftp, ptr, res);
#line 58
    free((void *)ptr);
    }
#line 59
    if (res == -1) {
      {
#line 60
      ptr = cpy(fsession->target_dname);
#line 61
      tmpbuf = strtok((char */* __restrict  */)ptr, (char const   */* __restrict  */)tmpbuf);
      }
#line 62
      if (tmpbuf) {
        {
#line 63
        makeskip(fsession, tmpbuf);
        }
#line 64
        if ((fsession->ftp)->current_directory) {
          {
#line 65
          free((void *)(fsession->ftp)->current_directory);
          }
        }
        {
#line 66
        tmpbuf = strrchr((char const   *)ptr, '/');
        }
#line 67
        if (! tmpbuf) {
#line 67
          tmpbuf = ptr;
        }
        {
#line 68
        *tmpbuf = (char)0;
#line 69
        (fsession->ftp)->current_directory = cpy(ptr);
        }
      }
      {
#line 71
      free((void *)ptr);
      }
    }
#line 74
    if (res == -2) {
      {
#line 75
      makeskip(fsession, (char *)"");
#line 76
      res = -1;
      }
    }
#line 78
    if (res == -8) {
      {
#line 79
      free((void *)unescaped);
      }
#line 80
      return (res);
    } else
#line 78
    if (res == -1) {
      {
#line 79
      free((void *)unescaped);
      }
#line 80
      return (res);
    }
    {
#line 82
    tmpbuf = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  free((void *)unescaped);
  }
#line 85
  return (0);
}
}
#line 91 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
int try_do_cwd(ftp_con *ftp , char *path , int mkd ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 92
  res = 0;
#line 93
  tmp = strcmp((char const   *)path, ".");
  }
#line 93
  if (! tmp) {
#line 94
    return (mkd);
  }
  {
#line 95
  tmp___0 = strcmp((char const   *)path, "..");
  }
#line 95
  if (! tmp___0) {
#line 96
    mkd = 0;
  }
#line 100
  if (! mkd) {
    {
#line 101
    res = ftp_do_cwd(ftp, path);
    }
#line 102
    if (res == -8) {
#line 103
      return (-8);
    } else
#line 102
    if (res == -9) {
#line 103
      return (-8);
    }
  }
#line 105
  if (res < 0) {
#line 105
    if (opt.no_directories) {
#line 106
      return (-1);
    }
  }
#line 108
  if (res < 0) {
#line 108
    goto _L;
  } else
#line 108
  if (mkd) {
    _L: /* CIL Label */ 
#line 110
    if ((int )*(path + 0) == 47) {
      {
#line 111
      res = ftp_do_cwd(ftp, (char *)"/");
      }
#line 112
      if (res == -8) {
#line 113
        return (-8);
      } else
#line 112
      if (res == -9) {
#line 113
        return (-8);
      }
#line 115
      if (res < 0) {
#line 116
        return (-2);
      }
#line 117
      path ++;
    }
    {
#line 122
    res = ftp_do_mkd(ftp, path);
    }
#line 123
    if (res == -8) {
#line 124
      return (-8);
    } else
#line 123
    if (res == -9) {
#line 124
      return (-8);
    }
#line 125
    if (res < 0) {
#line 125
      return (-1);
    }
    {
#line 127
    mkd = 1;
#line 129
    res = ftp_do_cwd(ftp, path);
    }
#line 130
    if (res == -8) {
#line 131
      return (-8);
    } else
#line 130
    if (res == -9) {
#line 131
      return (-8);
    }
#line 132
    if (res < 0) {
#line 132
      return (-1);
    }
  }
#line 135
  return (mkd);
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
int do_cwd(_fsession *fsession , char *targetdir ) 
{ 
  int res ;
  char *unescaped ;
  char *tmp ;
  char *relative ;

  {
  {
#line 147
  tmp = cpy(targetdir);
#line 147
  unescaped = tmp;
#line 149
  clear_path(unescaped);
#line 150
  unescape(unescaped);
  }
#line 151
  if ((fsession->ftp)->current_directory) {
    {
#line 151
    clear_path((fsession->ftp)->current_directory);
    }
  }
  {
#line 153
  printout((unsigned char)4, "previous directory: %s\ttarget: %s\n", (fsession->ftp)->current_directory,
           unescaped);
  }
#line 154
  if ((fsession->ftp)->current_directory) {
    {
#line 155
    relative = get_relative_path((fsession->ftp)->current_directory, unescaped);
#line 156
    free((void *)unescaped);
#line 157
    unescaped = relative;
    }
  }
  {
#line 160
  res = ftp_do_cwd(fsession->ftp, unescaped);
#line 161
  free((void *)unescaped);
  }
#line 162
  return (res);
}
}
#line 167 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
void set_resuming(_fsession *fsession ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 168
  if (fsession->local_fsize < fsession->target_fsize) {
#line 168
    if ((int )opt.resume_table.small_large == 1) {
      {
#line 169
      fsession->target_fsize = (off_t )-1;
#line 170
      tmp = gettext("Remote file size is bigger than local size. Restarting at 0\n");
#line 170
      printout((unsigned char)3, (char const   *)tmp);
      }
    } else {
#line 168
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 172
  if (fsession->local_fsize == fsession->target_fsize) {
#line 172
    if (fsession->local_fname) {
#line 172
      if ((int )opt.resume_table.large_large == 1) {
        {
#line 173
        fsession->target_fsize = (off_t )-1;
#line 174
        tmp___0 = gettext("Remote file size is equal to local size. Restarting at 0\n");
#line 174
        printout((unsigned char)3, (char const   *)tmp___0);
        }
      } else {
#line 172
        goto _L___0;
      }
    } else {
#line 172
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 176
  if (fsession->local_fsize > fsession->target_fsize) {
#line 176
    if ((int )opt.resume_table.large_small == 1) {
      {
#line 177
      fsession->target_fsize = (off_t )-1;
#line 178
      tmp___1 = gettext("Remote file size is smaller than local size. Restarting at 0.\n");
#line 178
      printout((unsigned char)3, (char const   *)tmp___1);
      }
    }
  }
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
int check_timestamp(_fsession *fsession ) 
{ 
  int res ;
  int tmp ;
  struct tm *tmp___0 ;
  time_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 183
  tmp = ftp_get_modification_time(fsession->ftp, fsession->target_fname, & fsession->target_ftime);
#line 183
  res = tmp;
  }
#line 184
  if (res == -8) {
#line 184
    return (res);
  } else
#line 184
  if (res == -9) {
#line 184
    return (res);
  }
  {
#line 190
  tmp___0 = gmtime((time_t const   *)(& fsession->local_ftime));
#line 190
  tmp___1 = mktime(tmp___0);
#line 190
  fsession->local_ftime = (tmp___1 - (time_t )opt.time_deviation) + (time_t )((int )opt.time_offset * 3600);
#line 191
  printout((unsigned char)4, "timestamping: local: %d seconds\n             remote: %d seconds; diff: %d\n",
           (int )fsession->local_ftime, (int )fsession->target_ftime, (int )(fsession->local_ftime - fsession->target_ftime));
#line 195
  tmp___2 = ctime((time_t const   *)(& fsession->local_ftime));
#line 195
  printout((unsigned char)4, "timestamping: local: %s", tmp___2);
#line 196
  tmp___3 = ctime((time_t const   *)(& fsession->target_ftime));
#line 196
  printout((unsigned char)4, "              remote: %s", tmp___3);
  }
#line 197
  if (fsession->target_ftime > fsession->local_ftime) {
    {
#line 198
    printout((unsigned char)1, "-- Skipping file: %s (remote is newer)\n", fsession->local_fname);
#line 199
    fsession->done = (unsigned char)1;
    }
#line 200
    return (1);
  }
#line 202
  return (0);
}
}
#line 205 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
int open_input_file(_fsession *fsession ) 
{ 
  int fd ;
  int oflags ;
  char *cmd ;
  FILE *pipe___0 ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 206
  fd = 0;
#line 207
  oflags = 0;
#line 212
  if (fsession->local_fname) {
    {
#line 218
    fd = open((char const   *)fsession->local_fname, oflags);
    }
#line 218
    if (fd == -1) {
      {
#line 219
      tmp = gettext("Error: ");
#line 219
      printout((unsigned char)1, (char const   *)tmp);
#line 220
      tmp___0 = gettext("Cannot open local source file to read\n");
#line 220
      printout((unsigned char)1, (char const   *)tmp___0);
#line 221
      fsession->done = (unsigned char)1;
      }
#line 222
      return (-1);
    }
  } else
#line 224
  if (opt.input_pipe) {
    {
#line 225
    tmp___1 = strlen((char const   *)opt.input_pipe);
#line 225
    tmp___2 = strlen((char const   *)fsession->user);
    }
#line 225
    if ((fsession->host)->ip) {
#line 225
      tmp___4 = (size_t )15;
    } else {
      {
#line 225
      tmp___3 = strlen((char const   *)(fsession->host)->hostname);
#line 225
      tmp___4 = tmp___3;
      }
    }
#line 225
    if (fsession->target_dname) {
      {
#line 225
      tmp___5 = strlen((char const   *)fsession->target_dname);
#line 225
      tmp___6 = tmp___5;
      }
    } else {
#line 225
      tmp___6 = (size_t )0;
    }
    {
#line 225
    tmp___7 = strlen((char const   *)fsession->target_fname);
#line 225
    tmp___8 = malloc((((((tmp___1 + tmp___2) + tmp___4) + 5UL) + tmp___6) + tmp___7) + 18UL);
#line 225
    cmd = (char *)tmp___8;
    }
#line 232
    if (fsession->target_dname) {
#line 232
      tmp___9 = (char const   *)fsession->target_dname;
    } else {
#line 232
      tmp___9 = "";
    }
#line 232
    if ((fsession->host)->ip) {
      {
#line 232
      tmp___10 = printip((unsigned char *)(& (fsession->host)->ip));
#line 232
      tmp___11 = tmp___10;
      }
    } else {
#line 232
      tmp___11 = (fsession->host)->hostname;
    }
    {
#line 232
    sprintf((char */* __restrict  */)cmd, (char const   */* __restrict  */)"%s ftp \"%s\" \"%s\" %d \"%s\" \"%s\"",
            opt.input_pipe, fsession->user, tmp___11, (int )(fsession->host)->port,
            tmp___9, fsession->target_fname);
#line 237
    pipe___0 = popen((char const   *)cmd, "r");
#line 238
    free((void *)cmd);
    }
#line 239
    if ((unsigned long )pipe___0 == (unsigned long )((void *)0)) {
      {
#line 240
      tmp___12 = gettext("Error: ");
#line 240
      printout((unsigned char)1, (char const   *)tmp___12);
#line 241
      tmp___13 = __errno_location();
#line 241
      tmp___14 = strerror(*tmp___13);
#line 241
      tmp___15 = gettext("opening the input-pipe failed: %s\n");
#line 241
      printout((unsigned char)1, (char const   *)tmp___15, tmp___14);
#line 242
      fsession->done = (unsigned char)1;
      }
#line 243
      return (-1);
    }
    {
#line 245
    fd = fileno(pipe___0);
#line 251
    fsession->local_fsize = (off_t )2146435072;
#line 252
    opt.barstyle = (unsigned char)0;
    }
  }
#line 256
  return (fd);
}
}
#line 262 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
int do_send(_fsession *fsession ) 
{ 
  char databuf[1024] ;
  int fd ;
  int tmp ;
  int readbytes ;
  int res ;
  off_t transfered_size ;
  int transfered_last ;
  unsigned char backupbarstyle ;
  struct wput_timer *timers[2] ;
  char *d ;
  char *p ;
  int convertbytes ;
  char convertbuf[1024] ;
  int crcount ;
  char *tmp___0 ;
  off_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  double elapsed_time ;
  double tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  ssize_t tmp___17 ;
  off_t tmp___18 ;
  double tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;

  {
  {
#line 265
  tmp = open_input_file(fsession);
#line 265
  fd = tmp;
#line 266
  readbytes = 0;
#line 267
  res = 0;
#line 268
  transfered_size = (off_t )0;
#line 269
  transfered_last = 0;
#line 270
  backupbarstyle = opt.barstyle;
#line 274
  d = (char *)((void *)0);
#line 275
  p = (char *)((void *)0);
#line 276
  convertbytes = 0;
#line 278
  crcount = 0;
#line 281
  res = ftp_establish_data_connection(fsession->ftp);
  }
#line 282
  if (res < 0) {
#line 282
    return (res);
  }
#line 285
  if ((int )fsession->binary == 0) {
    {
#line 286
    tmp___0 = gettext("Disabling resuming due to ascii-mode transfer\n");
#line 286
    printout((unsigned char)3, (char const   *)tmp___0);
#line 287
    fsession->target_fsize = (off_t )-1;
    }
  }
#line 290
  if (fsession->target_fsize > 0L) {
    {
#line 291
    res = ftp_do_rest(fsession->ftp, fsession->target_fsize);
    }
#line 292
    if (res == -8) {
#line 292
      return (res);
    } else
#line 292
    if (res == -9) {
#line 292
      return (res);
    }
#line 293
    if (res == -1) {
#line 294
      fsession->target_fsize = (off_t )-1;
    }
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 298
    res = ftp_do_stor(fsession->ftp, fsession->target_fname);
    }
#line 299
    if (res == 1) {
#line 300
      if (fsession->target_fsize == -1L) {
#line 301
        res = -1;
#line 302
        goto while_break;
      } else {
        {
#line 305
        tmp___1 = (off_t )-1;
#line 305
        fsession->target_fsize = tmp___1;
#line 305
        res = ftp_do_rest(fsession->ftp, tmp___1);
        }
#line 306
        if (res == -8) {
#line 306
          return (res);
        } else
#line 306
        if (res == -9) {
#line 306
          return (res);
        }
      }
    } else
#line 308
    if (res == -3) {
#line 308
      if ((int )fsession->retry > 0) {
        {
#line 309
        retry_wait(fsession);
        }
      } else
#line 308
      if ((int )fsession->retry == -1) {
        {
#line 309
        retry_wait(fsession);
        }
      } else {
#line 310
        goto while_break;
      }
    } else {
#line 310
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  if (res == -1) {
#line 313
    fsession->done = (unsigned char)1;
  }
#line 314
  if (res < 0) {
#line 314
    return (res);
  }
  {
#line 317
  tmp___2 = ftp_complete_data_connection(fsession->ftp);
  }
#line 317
  if (tmp___2 == -1) {
#line 317
    return (-1);
  }
#line 321
  if (fsession->target_fsize == -1L) {
#line 321
    fsession->target_fsize = (off_t )0;
  }
  {
#line 323
  bar_create(fsession);
#line 326
  timers[0] = wtimer_alloc();
#line 327
  timers[1] = wtimer_alloc();
#line 328
  wtimer_reset(timers[0]);
#line 329
  wtimer_reset(timers[1]);
  }
#line 331
  if (fsession->target_fsize > 0L) {
    {
#line 342
    lseek(fd, fsession->target_fsize, 0);
#line 343
    transfered_size = fsession->target_fsize;
    }
  }
  {
#line 346
  memset((void *)(databuf), 0, (size_t )1024);
  }
  {
#line 347
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 347
    tmp___17 = read(fd, (void *)(databuf), (size_t )1024);
#line 347
    readbytes = (int )tmp___17;
    }
#line 347
    if (! (readbytes != 0)) {
#line 347
      goto while_break___0;
    }
#line 348
    if (readbytes == -1) {
      {
#line 349
      tmp___3 = gettext("Error: ");
#line 349
      printout((unsigned char)1, (char const   *)tmp___3);
#line 350
      tmp___4 = __errno_location();
#line 350
      tmp___5 = strerror(*tmp___4);
#line 350
      tmp___6 = gettext("local file could not be read: %s\n");
#line 350
      printout((unsigned char)1, (char const   *)tmp___6, tmp___5);
#line 351
      free((void *)timers[0]);
#line 352
      free((void *)timers[1]);
      }
#line 353
      return (-1);
    }
#line 359
    if (opt.speed_limit > 0U) {
      {
#line 360
      tmp___7 = wtimer_elapsed(timers[0]);
#line 360
      elapsed_time = tmp___7;
      }
      {
#line 361
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 361
        if (elapsed_time > (double )0) {
#line 361
          if (! ((double )(transfered_size - fsession->target_fsize) / (elapsed_time / (double )1000) > (double )opt.speed_limit)) {
#line 361
            goto while_break___1;
          }
        } else {
#line 361
          goto while_break___1;
        }
        {
#line 362
        usleep((__useconds_t )200000);
#line 363
        elapsed_time = wtimer_elapsed(timers[0]);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 367
    if ((int )fsession->binary == 0) {
#line 368
      d = databuf;
#line 369
      p = convertbuf;
#line 370
      crcount = 0;
      {
#line 374
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 374
        if (! ((unsigned long )d < (unsigned long )(databuf + readbytes))) {
#line 374
          goto while_break___2;
        }
        {
#line 375
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 375
          if ((unsigned long )p < (unsigned long )(convertbuf + 1024)) {
#line 375
            if (! ((unsigned long )d < (unsigned long )(databuf + readbytes))) {
#line 375
              goto while_break___3;
            }
          } else {
#line 375
            goto while_break___3;
          }
#line 376
          if ((int )*d == 10) {
#line 376
            if ((int )*(d - 1) != 13) {
#line 377
              tmp___8 = p;
#line 377
              p ++;
#line 377
              *tmp___8 = (char )'\r';
#line 378
              crcount ++;
            }
          }
#line 380
          tmp___9 = p;
#line 380
          p ++;
#line 380
          tmp___10 = d;
#line 380
          d ++;
#line 380
          *tmp___9 = *tmp___10;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 383
        convertbytes = (int )(p - convertbuf);
#line 385
        res = socket_write((fsession->ftp)->datasock, (void *)(convertbuf), (size_t )convertbytes);
        }
#line 386
        if (res != convertbytes) {
          {
#line 387
          tmp___11 = gettext("Error: ");
#line 387
          printout((unsigned char)1, (char const   *)tmp___11);
#line 388
          tmp___12 = gettext("Error encountered during uploading data\n");
#line 388
          printout((unsigned char)1, (char const   *)tmp___12);
#line 389
          free((void *)timers[0]);
#line 390
          free((void *)timers[1]);
#line 391
          opt.transfered_bytes += transfered_size - fsession->target_fsize;
#line 392
          res = ftp_do_abor(fsession->ftp);
          }
#line 393
          if (res == -8) {
#line 393
            return (-8);
          } else
#line 393
          if (res == -9) {
#line 393
            return (-8);
          }
#line 394
          return (-1);
        }
#line 397
        p = convertbuf;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 399
      transfered_size += (off_t )(crcount + readbytes);
#line 400
      transfered_last += crcount + readbytes;
    } else {
      {
#line 403
      transfered_size += (off_t )readbytes;
#line 404
      transfered_last += readbytes;
#line 405
      res = socket_write((fsession->ftp)->datasock, (void *)(databuf), (size_t )readbytes);
      }
#line 406
      if (res != readbytes) {
        {
#line 407
        tmp___13 = gettext("Error: ");
#line 407
        printout((unsigned char)1, (char const   *)tmp___13);
#line 408
        tmp___14 = __errno_location();
#line 408
        tmp___15 = strerror(*tmp___14);
#line 408
        tmp___16 = gettext("Error encountered during uploading data (%s)\n");
#line 408
        printout((unsigned char)1, (char const   *)tmp___16, tmp___15);
#line 409
        free((void *)timers[0]);
#line 410
        free((void *)timers[1]);
#line 411
        opt.transfered_bytes += transfered_size - fsession->target_fsize;
#line 412
        res = ftp_do_abor(fsession->ftp);
        }
#line 413
        if (res == -8) {
#line 413
          return (-8);
        } else
#line 413
        if (res == -9) {
#line 413
          return (-8);
        }
#line 414
        return (-1);
      }
    }
#line 417
    if ((int )opt.verbose >= 2) {
      {
#line 418
      bar_update(fsession, transfered_size, transfered_last, timers[1]);
#line 419
      transfered_last = 0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 427
  if (fd != -1) {
    {
#line 428
    close(fd);
    }
  }
#line 430
  if ((fsession->ftp)->datasock) {
    {
#line 431
    socket_close((fsession->ftp)->datasock);
#line 432
    (fsession->ftp)->datasock = (wput_socket *)((void *)0);
    }
  }
  {
#line 437
  printout((unsigned char)2, "\n");
  }
  {
#line 438
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 438
    res = ftp_get_msg(fsession->ftp);
    }
#line 438
    if (! (res == -2)) {
#line 438
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 440
  if (fsession->local_fname) {
#line 440
    tmp___18 = fsession->local_fsize;
  } else {
#line 440
    tmp___18 = transfered_size;
  }
  {
#line 440
  tmp___19 = wtimer_elapsed(timers[0]);
#line 440
  tmp___20 = calculate_transfer_rate(tmp___19, transfered_size - fsession->target_fsize,
                                     (unsigned char)0);
#line 440
  tmp___21 = time_str();
#line 440
  printout((unsigned char)2, "%s (%s) - `%s\' [%l]\n\n", tmp___21, fsession->target_fname,
           tmp___20, tmp___18);
#line 448
  free((void *)timers[0]);
#line 449
  free((void *)timers[1]);
#line 451
  opt.transfered_bytes += transfered_size - fsession->target_fsize;
#line 452
  opt.transfered = (unsigned short )((int )opt.transfered + 1);
  }
#line 454
  if (transfered_size == fsession->local_fsize) {
#line 455
    fsession->done = (unsigned char)1;
  } else
#line 454
  if ((int )fsession->binary == 0) {
#line 455
    fsession->done = (unsigned char)1;
  } else
#line 454
  if (! fsession->local_fname) {
#line 455
    fsession->done = (unsigned char)1;
  }
#line 457
  if (res == -3) {
#line 457
    return (-3);
  }
#line 458
  if (res == -3) {
#line 458
    return (-1);
  } else
#line 458
  if (res == -4) {
#line 458
    return (-1);
  }
#line 459
  if (res == -8) {
#line 459
    return (res);
  } else
#line 459
  if (res == -9) {
#line 459
    return (res);
  }
#line 461
  if (fsession->local_fname) {
#line 461
    if (transfered_size == fsession->local_fsize) {
#line 461
      goto _L;
    } else
#line 461
    if ((int )fsession->binary == 0) {
      _L: /* CIL Label */ 
#line 461
      if (opt.unlink) {
        {
#line 464
        tmp___22 = gettext("Removing source file `%s\'\n");
#line 464
        printout((unsigned char)3, (char const   *)tmp___22, fsession->local_fname);
#line 465
        unlink((char const   *)fsession->local_fname);
        }
      }
    }
  }
#line 468
  opt.barstyle = backupbarstyle;
#line 470
  return (0);
}
}
#line 478 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
int do_delete(_fsession *fsession , char *filename ) 
{ 
  int res ;
  struct fileinfo *finfo ;
  char *tmp ;
  char *tmp___0 ;
  char *oldpath ;
  char *tmp___1 ;
  char *newpath ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  struct fileinfo *dl ;
  struct fileinfo *tmp___6 ;
  char *tmp___7 ;
  struct fileinfo *curr_entry ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 479
  res = 0;
#line 481
  finfo = (struct fileinfo *)((void *)0);
#line 482
  res = ftp_get_fileinfo(fsession->ftp, filename, & finfo);
  }
#line 483
  if (res == -1) {
    {
#line 484
    tmp = gettext("No such file or directory: %s\n");
#line 484
    printout((unsigned char)1, (char const   *)tmp, filename);
#line 485
    fsession->done = (unsigned char)1;
    }
#line 486
    return (-1);
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if ((unsigned int )finfo->type == 1U) {
      {
#line 491
      printout((unsigned char)4, "%s is a directory, using RMD\n", filename);
#line 492
      res = ftp_do_rmd(fsession->ftp, filename);
      }
#line 493
      if (res == -1) {
        {
#line 494
        tmp___0 = gettext("RMD of directory %s failed, probably not empty; deleting recursively\n");
#line 494
        printout((unsigned char)4, (char const   *)tmp___0, filename);
#line 497
        tmp___1 = cpy((fsession->ftp)->current_directory);
#line 497
        oldpath = tmp___1;
#line 498
        tmp___2 = strlen((char const   *)(fsession->ftp)->current_directory);
#line 498
        tmp___3 = strlen((char const   *)filename);
#line 498
        tmp___4 = malloc(((tmp___2 + 1UL) + tmp___3) + 1UL);
#line 498
        newpath = (char *)tmp___4;
#line 499
        *newpath = (char )'\000';
#line 500
        strcat((char */* __restrict  */)newpath, (char const   */* __restrict  */)(fsession->ftp)->current_directory);
#line 501
        strcat((char */* __restrict  */)newpath, (char const   */* __restrict  */)"/");
#line 502
        strcat((char */* __restrict  */)newpath, (char const   */* __restrict  */)filename);
#line 504
        res = do_cwd(fsession, newpath);
        }
#line 505
        if (res == -1) {
          {
#line 506
          (fsession->ftp)->needcwd = (unsigned char)1;
#line 507
          tmp___5 = gettext("Failed to change to target directory. Skipping this file/dir.\n");
#line 507
          printout((unsigned char)1, (char const   *)tmp___5);
#line 508
          fsession->done = (unsigned char)1;
          }
#line 509
          return (-1);
        }
#line 511
        (fsession->ftp)->needcwd = (unsigned char)0;
#line 512
        if ((fsession->ftp)->current_directory) {
          {
#line 513
          free((void *)(fsession->ftp)->current_directory);
          }
        }
        {
#line 514
        (fsession->ftp)->current_directory = cpy(newpath);
#line 516
        tmp___6 = ftp_get_current_directory_list(fsession->ftp);
#line 516
        dl = tmp___6;
        }
#line 518
        if (! dl) {
          {
#line 519
          res = ftp_get_list(fsession->ftp);
          }
#line 520
          if (res == -8) {
#line 520
            goto while_break;
          } else
#line 520
          if (res == -9) {
#line 520
            goto while_break;
          } else
#line 520
          if (res == -1) {
#line 520
            goto while_break;
          }
          {
#line 521
          dl = ftp_get_current_directory_list(fsession->ftp);
          }
        }
#line 523
        if (! dl) {
          {
#line 524
          tmp___7 = gettext("Directory empty, deletion failed.\n");
#line 524
          printout((unsigned char)1, (char const   *)tmp___7);
#line 525
          res = -1;
          }
#line 526
          goto while_break;
        } else {
          {
#line 528
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 528
            if (! ((unsigned long )dl != (unsigned long )((void *)0))) {
#line 528
              goto while_break___0;
            }
            {
#line 530
            curr_entry = dl;
#line 531
            do_delete(fsession, curr_entry->name);
#line 532
            dl = dl->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 536
        do_cwd(fsession, oldpath);
        }
#line 537
        if (res == -1) {
          {
#line 538
          (fsession->ftp)->needcwd = (unsigned char)1;
#line 539
          tmp___8 = gettext("Failed to change to parent directory. Skipping this file/dir.\n");
#line 539
          printout((unsigned char)1, (char const   *)tmp___8);
          }
#line 540
          return (-1);
        }
#line 542
        (fsession->ftp)->needcwd = (unsigned char)0;
#line 543
        if ((fsession->ftp)->current_directory) {
          {
#line 544
          free((void *)(fsession->ftp)->current_directory);
          }
        }
        {
#line 545
        (fsession->ftp)->current_directory = cpy(oldpath);
#line 546
        res = ftp_do_rmd(fsession->ftp, filename);
        }
      }
    } else {
      {
#line 549
      printout((unsigned char)4, "%s is a file, symlink or unknown; using DELE\n",
               filename);
#line 550
      res = ftp_do_dele(fsession->ftp, filename);
      }
    }
#line 552
    if (res == -3) {
#line 552
      if ((int )fsession->retry > 0) {
        {
#line 553
        retry_wait(fsession);
        }
      } else
#line 552
      if ((int )fsession->retry == -1) {
        {
#line 553
        retry_wait(fsession);
        }
      } else {
#line 554
        goto while_break;
      }
    } else {
#line 554
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  if (res == -1) {
#line 557
    fsession->done = (unsigned char)1;
  }
#line 558
  if (res < 0) {
#line 558
    return (res);
  }
#line 560
  if (res == -3) {
#line 560
    return (-3);
  }
#line 561
  if (res == -3) {
#line 561
    return (-1);
  } else
#line 561
  if (res == -4) {
#line 561
    return (-1);
  }
#line 562
  if (res == -8) {
#line 562
    return (res);
  } else
#line 562
  if (res == -9) {
#line 562
    return (res);
  }
#line 564
  if ((unsigned long )filename == (unsigned long )fsession->target_fname) {
    {
#line 565
    tmp___9 = gettext("\n%s deleted.\n\n");
#line 565
    printout((unsigned char)2, (char const   *)tmp___9, filename);
    }
  }
#line 567
  opt.transfered = (unsigned short )((int )opt.transfered + 1);
#line 568
  fsession->done = (unsigned char)1;
#line 570
  return (0);
}
}
#line 583 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
int fsession_process_file(_fsession *fsession , ftp_con *ftp ) 
{ 
  int res ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  host_t *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  unsigned char tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  float tmp___31 ;

  {
  {
#line 584
  res = 0;
#line 590
  tmp___0 = skiplist_find_entry((int )(fsession->host)->ip, (fsession->host)->hostname,
                                (fsession->host)->port, fsession->user, fsession->pass,
                                fsession->target_dname);
  }
#line 590
  if (tmp___0) {
    {
#line 593
    tmp = gettext("-- Skipping file: `%s\'\n");
#line 593
    printout((unsigned char)1, (char const   *)tmp, fsession->local_fname);
    }
#line 594
    return (-1);
  }
#line 597
  if (! opt.wdel) {
#line 598
    if (fsession->target_dname) {
#line 598
      tmp___1 = "/";
    } else {
#line 598
      tmp___1 = "";
    }
#line 598
    if ((fsession->host)->ip) {
      {
#line 598
      tmp___2 = printip((unsigned char *)(& (fsession->host)->ip));
#line 598
      tmp___3 = tmp___2;
      }
    } else {
#line 598
      tmp___3 = (fsession->host)->hostname;
    }
    {
#line 598
    tmp___4 = time_str();
#line 598
    printout((unsigned char)1, "--%s-- `%s\'\n    => ftp://%s:xxxxx@%s:%d/%s%s%s\n",
             tmp___4, fsession->local_fname, fsession->user, tmp___3, (int )(fsession->host)->port,
             fsession->target_dname, tmp___1, fsession->target_fname);
    }
  } else {
#line 610
    if (fsession->target_dname) {
#line 610
      tmp___5 = "/";
    } else {
#line 610
      tmp___5 = "";
    }
#line 610
    if ((fsession->host)->ip) {
      {
#line 610
      tmp___6 = printip((unsigned char *)(& (fsession->host)->ip));
#line 610
      tmp___7 = tmp___6;
      }
    } else {
#line 610
      tmp___7 = (fsession->host)->hostname;
    }
    {
#line 610
    tmp___8 = time_str();
#line 610
    tmp___9 = gettext("--%s-- Deleting file/dir: ftp://%s:xxxxx@%s:%d/%s%s%s\n");
#line 610
    printout((unsigned char)1, (char const   *)tmp___9, tmp___8, fsession->user, tmp___7,
             (int )(fsession->host)->port, fsession->target_dname, tmp___5, fsession->target_fname);
    }
  }
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! fsession->done) {
#line 620
      if (! ((int )fsession->retry > 0)) {
#line 620
        if (! ((int )fsession->retry == -1)) {
#line 620
          goto while_break;
        }
      }
    } else {
#line 620
      goto while_break;
    }
    {
#line 621
    printout((unsigned char)4, "starting again\n");
    }
#line 624
    if (ftp) {
#line 625
      if ((ftp->host)->ip == (fsession->host)->ip) {
#line 625
        if ((int )(ftp->host)->port == (int )(fsession->host)->port) {
#line 625
          if (! (ftp->host)->hostname) {
#line 625
            if (! (fsession->host)->hostname) {
#line 628
              fsession->ftp = ftp;
            } else {
#line 625
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 625
          if ((ftp->host)->hostname) {
#line 625
            if ((fsession->host)->hostname) {
              {
#line 625
              tmp___10 = strcmp((char const   *)(ftp->host)->hostname, (char const   *)(fsession->host)->hostname);
              }
#line 625
              if (tmp___10) {
                {
#line 630
                ftp_quit(ftp);
                }
              } else {
#line 628
                fsession->ftp = ftp;
              }
            } else {
              {
#line 630
              ftp_quit(ftp);
              }
            }
          } else {
            {
#line 630
            ftp_quit(ftp);
            }
          }
        } else {
          {
#line 630
          ftp_quit(ftp);
          }
        }
      } else {
        {
#line 630
        ftp_quit(ftp);
        }
      }
    }
#line 632
    if (! fsession->ftp) {
      {
#line 633
      tmp___11 = ftp_new_host((fsession->host)->ip, (fsession->host)->hostname, (fsession->host)->port);
#line 633
      fsession->ftp = ftp_new(tmp___11, (int )opt.tls);
      }
    }
#line 636
    if (! (fsession->ftp)->sock) {
      {
#line 637
      tmp___12 = ftp_connect(fsession->ftp, & opt.ps);
      }
#line 637
      if (tmp___12 == -1) {
        {
#line 638
        retry_wait(fsession);
#line 639
        ftp_quit(fsession->ftp);
#line 640
        ftp = (ftp_con *)((void *)0);
#line 640
        fsession->ftp = ftp;
#line 641
        res = -1;
        }
#line 642
        goto while_continue;
      }
#line 645
      (fsession->ftp)->portmode = opt.portmode;
#line 646
      (fsession->ftp)->bindaddr = opt.bindaddr;
    }
    {
#line 650
    res = ftp_login(fsession->ftp, fsession->user, fsession->pass);
    }
#line 652
    if (res == -8) {
#line 652
      goto _L___0;
    } else
#line 652
    if (res == -9) {
      _L___0: /* CIL Label */ 
      {
#line 652
      res = -1;
#line 652
      retry_wait(fsession);
#line 652
      ftp_quit(fsession->ftp);
#line 652
      ftp = (ftp_con *)((void *)0);
#line 652
      fsession->ftp = ftp;
      }
#line 652
      goto while_continue;
    }
#line 654
    if (res < 0) {
      {
#line 655
      tmp___13 = gettext("Skipping all files from this account...\n");
#line 655
      printout((unsigned char)1, (char const   *)tmp___13);
      }
#line 656
      if (fsession->pass) {
        {
#line 656
        tmp___14 = cpy(fsession->pass);
#line 656
        tmp___15 = tmp___14;
        }
      } else {
#line 656
        tmp___15 = (char *)((void *)0);
      }
      {
#line 656
      tmp___16 = cpy(fsession->user);
      }
#line 656
      if ((fsession->host)->hostname) {
        {
#line 656
        tmp___17 = cpy((fsession->host)->hostname);
#line 656
        tmp___18 = tmp___17;
        }
      } else {
#line 656
        tmp___18 = (char *)((void *)0);
      }
      {
#line 656
      opt.skipdlist = skiplist_add_entry(opt.skipdlist, (int )(fsession->host)->ip,
                                         tmp___18, (fsession->host)->port, tmp___16,
                                         tmp___15, (char *)((void *)0));
#line 660
      ftp_do_quit(fsession->ftp);
#line 661
      fsession->ftp = (ftp_con *)((void *)0);
      }
#line 662
      return (-1);
    }
#line 673
    if (fsession->target_dname) {
      {
#line 674
      clear_path(fsession->target_dname);
      }
    }
#line 676
    if (fsession->target_dname) {
#line 676
      if ((fsession->ftp)->needcwd) {
#line 676
        goto _L___2;
      } else
#line 676
      if ((fsession->ftp)->current_directory) {
        {
#line 676
        tmp___20 = strcmp((char const   *)(fsession->ftp)->current_directory, (char const   *)fsession->target_dname);
        }
#line 676
        if (tmp___20) {
          _L___2: /* CIL Label */ 
          {
#line 680
          res = do_cwd(fsession, fsession->target_dname);
          }
#line 681
          if (res == -1) {
            {
#line 683
            res = long_do_cwd(fsession);
            }
#line 684
            if (res == -1) {
              {
#line 687
              (fsession->ftp)->needcwd = (unsigned char)1;
#line 688
              tmp___19 = gettext("Failed to change to target directory. Skipping this file/dir.\n");
#line 688
              printout((unsigned char)1, (char const   *)tmp___19);
              }
#line 689
              return (-1);
            }
          }
#line 692
          if (res == -8) {
#line 692
            goto _L___1;
          } else
#line 692
          if (res == -9) {
            _L___1: /* CIL Label */ 
            {
#line 692
            res = -1;
#line 692
            retry_wait(fsession);
#line 692
            ftp_quit(fsession->ftp);
#line 692
            ftp = (ftp_con *)((void *)0);
#line 692
            fsession->ftp = ftp;
            }
#line 692
            goto while_continue;
          }
#line 695
          (fsession->ftp)->needcwd = (unsigned char)0;
#line 696
          if ((fsession->ftp)->current_directory) {
            {
#line 697
            free((void *)(fsession->ftp)->current_directory);
            }
          }
          {
#line 698
          (fsession->ftp)->current_directory = cpy(fsession->target_dname);
          }
        }
      }
    }
#line 705
    if ((int )fsession->binary == -1) {
      {
#line 706
      tmp___21 = get_filemode(fsession->target_fname);
#line 706
      fsession->binary = (char )tmp___21;
      }
    }
#line 709
    if (! opt.wdel) {
#line 714
      if ((int )(fsession->resume_table)->small_large == 1) {
#line 714
        if ((int )(fsession->resume_table)->large_large == 1) {
#line 714
          if ((int )(fsession->resume_table)->large_small == 1) {
#line 717
            fsession->target_fsize = (off_t )-1;
          } else {
#line 714
            goto _L___6;
          }
        } else {
#line 714
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 719
      if (fsession->local_fname) {
        {
#line 720
        res = ftp_set_type(fsession->ftp, (int )fsession->binary);
        }
#line 721
        if (res == -8) {
#line 721
          goto _L___3;
        } else
#line 721
        if (res == -9) {
          _L___3: /* CIL Label */ 
          {
#line 721
          res = -1;
#line 721
          retry_wait(fsession);
#line 721
          ftp_quit(fsession->ftp);
#line 721
          ftp = (ftp_con *)((void *)0);
#line 721
          fsession->ftp = ftp;
          }
#line 721
          goto while_continue;
        }
#line 722
        if (res == -1) {
          {
#line 723
          tmp___22 = gettext("Unable to set transfer mode. Assuming binary\n");
#line 723
          printout((unsigned char)3, (char const   *)tmp___22);
          }
        }
        {
#line 725
        res = ftp_get_filesize(fsession->ftp, fsession->target_fname, & fsession->target_fsize);
        }
#line 726
        if (res == -1) {
#line 726
          fsession->target_fsize = (off_t )-1;
        }
#line 727
        if (res == -8) {
#line 727
          goto _L___4;
        } else
#line 727
        if (res == -9) {
          _L___4: /* CIL Label */ 
          {
#line 727
          res = -1;
#line 727
          retry_wait(fsession);
#line 727
          ftp_quit(fsession->ftp);
#line 727
          ftp = (ftp_con *)((void *)0);
#line 727
          fsession->ftp = ftp;
          }
#line 727
          goto while_continue;
        }
#line 730
        if (fsession->target_fsize > 0L) {
#line 730
          if (fsession->target_fsize != fsession->local_fsize) {
#line 731
            fsession->target_fsize = (fsession->target_fsize - 511L) & -512L;
          }
        }
      }
      {
#line 734
      printout((unsigned char)4, "local_fsize: %d\ntarget_fsize: %d\n", (int )fsession->local_fsize,
               (int )fsession->target_fsize);
#line 737
      printout((unsigned char)4, "resume_table: %d,%d,%d\n", (int )(fsession->resume_table)->small_large,
               (int )(fsession->resume_table)->large_large, (int )(fsession->resume_table)->large_small);
      }
#line 740
      if (fsession->local_fname) {
#line 740
        if (fsession->local_fsize < fsession->target_fsize) {
#line 740
          if ((int )(fsession->resume_table)->small_large == 0) {
#line 740
            goto _L___7;
          } else {
#line 740
            goto _L___9;
          }
        } else
        _L___9: /* CIL Label */ 
#line 740
        if (fsession->local_fsize == fsession->target_fsize) {
#line 740
          if ((int )(fsession->resume_table)->large_large == 0) {
#line 740
            goto _L___7;
          } else {
#line 740
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 740
        if (fsession->local_fsize > fsession->target_fsize) {
#line 740
          if ((int )(fsession->resume_table)->large_small == 0) {
            _L___7: /* CIL Label */ 
            {
#line 745
            res = -2;
#line 746
            fsession->done = (unsigned char)1;
#line 747
            tmp___23 = gettext("Skipping this file due to resume/upload/skip rules.\n");
#line 747
            printout((unsigned char)3, (char const   *)tmp___23);
#line 748
            tmp___24 = gettext("-- Skipping file: %s\n");
#line 748
            printout((unsigned char)1, (char const   *)tmp___24, fsession->local_fname);
            }
#line 749
            goto while_break;
          }
        }
      }
      {
#line 752
      set_resuming(fsession);
      }
#line 755
      if (opt.timestamping) {
        {
#line 756
        tmp___25 = check_timestamp(fsession);
        }
#line 756
        if (tmp___25) {
#line 757
          res = -2;
#line 758
          fsession->done = (unsigned char)1;
#line 759
          goto while_break;
        }
      }
      {
#line 763
      res = ftp_set_type(fsession->ftp, (int )fsession->binary);
      }
#line 764
      if (res == -8) {
#line 764
        goto _L___10;
      } else
#line 764
      if (res == -9) {
        _L___10: /* CIL Label */ 
        {
#line 764
        res = -1;
#line 764
        retry_wait(fsession);
#line 764
        ftp_quit(fsession->ftp);
#line 764
        ftp = (ftp_con *)((void *)0);
#line 764
        fsession->ftp = ftp;
        }
#line 764
        goto while_continue;
      }
#line 766
      if (res == -1) {
        {
#line 767
        tmp___26 = gettext("Unable to set transfer mode. Assuming binary\n");
#line 767
        printout((unsigned char)3, (char const   *)tmp___26);
        }
      }
    }
#line 770
    if (! opt.wdel) {
      {
#line 772
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 772
        res = do_send(fsession);
        }
#line 772
        if (! (res == -3)) {
#line 772
          goto while_break___0;
        }
        {
#line 773
        retry_wait(fsession);
        }
#line 774
        if (! ((int )fsession->retry > 0)) {
#line 774
          if (! ((int )fsession->retry == -1)) {
#line 775
            res = -1;
#line 776
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 782
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 782
        res = do_delete(fsession, fsession->target_fname);
        }
#line 782
        if (! (res == -3)) {
#line 782
          goto while_break___1;
        }
        {
#line 783
        retry_wait(fsession);
        }
#line 784
        if (! ((int )fsession->retry > 0)) {
#line 784
          if (! ((int )fsession->retry == -1)) {
#line 785
            res = -1;
#line 786
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 790
    if (res == -8) {
#line 790
      goto _L___11;
    } else
#line 790
    if (res == -9) {
      _L___11: /* CIL Label */ 
      {
#line 790
      res = -1;
#line 790
      retry_wait(fsession);
#line 790
      ftp_quit(fsession->ftp);
#line 790
      ftp = (ftp_con *)((void *)0);
#line 790
      fsession->ftp = ftp;
      }
#line 790
      goto while_continue;
    }
#line 792
    if (res == -1) {
#line 793
      if (! opt.wdel) {
        {
#line 794
        tmp___27 = gettext("Send Failed (%s) ");
#line 794
        printout((unsigned char)1, (char const   *)tmp___27, (fsession->ftp)->r.message);
        }
      } else {
        {
#line 796
        tmp___28 = gettext("Delete Failed. ");
#line 796
        printout((unsigned char)1, (char const   *)tmp___28);
        }
      }
#line 797
      if (fsession->done) {
        {
#line 798
        tmp___29 = gettext("Skipping this file\n");
#line 798
        printout((unsigned char)1, (char const   *)tmp___29);
        }
#line 799
        goto while_break;
      } else {
        {
#line 801
        retry_wait(fsession);
#line 804
        (fsession->ftp)->needcwd = (unsigned char)1;
        }
#line 805
        goto while_continue;
      }
    }
#line 809
    if (res == 0) {
#line 809
      if (opt.chmod) {
        {
#line 810
        ftp_do_chmod(fsession->ftp, fsession->local_fname, fsession->target_fname);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  if (opt.wait) {
#line 831
    if (opt.random_wait) {
      {
#line 831
      tmp___30 = rand();
#line 831
      tmp___31 = ((float )2 * (float )tmp___30) / (float )2147483647;
      }
    } else {
#line 831
      tmp___31 = (float )1;
    }
    {
#line 831
    usleep((__useconds_t )(((tmp___31 * (float )1000) * (float )100) * (float )opt.wait));
    }
  }
#line 835
  return (res);
}
}
#line 840 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.c"
int parse_url(_fsession *fsession , char *url ) 
{ 
  char *d ;
  char *host ;
  char *path ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  password_list *P ;
  password_list *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 842
  host = (char *)((void *)0);
#line 843
  path = (char *)((void *)0);
#line 848
  url = cpy(url + 6);
#line 849
  d = strchr((char const   *)url, '/');
  }
#line 850
  if (d) {
#line 850
    *d = (char)0;
#line 850
    path = d + 1;
  }
  {
#line 853
  d = strrchr((char const   *)url, '@');
  }
#line 854
  if (d) {
#line 854
    *d = (char)0;
#line 854
    host = d + 1;
  } else {
#line 855
    host = url;
  }
#line 858
  if (d) {
    {
#line 859
    d = strchr((char const   *)url, ':');
    }
#line 860
    if (d) {
      {
#line 861
      *d = (char)0;
#line 862
      tmp = unescape(url);
#line 862
      fsession->user = cpy(tmp);
#line 863
      tmp___0 = unescape(d + 1);
#line 863
      fsession->pass = cpy(tmp___0);
      }
    } else {
      {
#line 865
      tmp___1 = unescape(url);
#line 865
      fsession->user = cpy(tmp___1);
      }
    }
  }
  {
#line 867
  fsession->host = ftp_new_host(0U, (char *)((void *)0), (unsigned short)21);
#line 870
  d = strchr((char const   *)host, ':');
  }
#line 871
  if (d) {
    {
#line 872
    *d = (char)0;
#line 872
    tmp___2 = atoi((char const   *)(d + 1));
#line 872
    (fsession->host)->port = (unsigned short )tmp___2;
    }
  }
  {
#line 876
  tmp___9 = get_ip_addr(host, & (fsession->host)->ip);
  }
#line 876
  if (tmp___9 == -1) {
#line 877
    if (opt.ps.type != 0U) {
      {
#line 878
      (fsession->host)->hostname = cpy(host);
#line 879
      tmp___3 = gettext("Warning: ");
#line 879
      printout((unsigned char)3, (char const   *)tmp___3);
#line 880
      tmp___4 = gettext("`%s\' could not be resolved. ");
#line 880
      printout((unsigned char)3, (char const   *)tmp___4, host);
#line 881
      tmp___5 = gettext("Assuming the proxy to do the task.\n");
#line 881
      printout((unsigned char)3, (char const   *)tmp___5);
      }
    } else {
      {
#line 883
      tmp___6 = gettext("Error: ");
#line 883
      printout((unsigned char)2, (char const   *)tmp___6);
#line 884
      tmp___7 = gettext("`%s\' could not be resolved. ");
#line 884
      printout((unsigned char)2, (char const   *)tmp___7, host);
#line 885
      tmp___8 = gettext("Skipping this URL.\n");
#line 885
      printout((unsigned char)1, (char const   *)tmp___8);
#line 886
      free((void *)url);
      }
#line 887
      return (-1);
    }
  }
#line 892
  if (! fsession->pass) {
    {
#line 893
    tmp___10 = password_list_find(opt.pl, host, fsession->user);
#line 893
    P = tmp___10;
    }
#line 894
    if (P) {
#line 895
      if (! fsession->user) {
        {
#line 895
        fsession->user = cpy(P->user);
        }
      }
      {
#line 896
      fsession->pass = cpy(P->pass);
      }
    } else
#line 897
    if (! fsession->user) {
      {
#line 898
      fsession->user = cpy((char *)"anonymous");
#line 899
      fsession->pass = cpy(opt.email_address);
      }
    }
  }
#line 904
  if (! path) {
    {
#line 905
    free((void *)url);
    }
#line 906
    return (0);
  }
  {
#line 910
  d = strrchr((char const   *)path, '/');
  }
#line 911
  if (d) {
    {
#line 912
    *d = (char)0;
#line 912
    fsession->target_dname = cpy(path);
    }
  } else {
#line 915
    d = path - 1;
  }
#line 917
  d ++;
#line 917
  if (*d) {
    {
#line 918
    tmp___13 = strchr((char const   *)d, '#');
    }
#line 918
    if (tmp___13) {
      {
#line 919
      tmp___11 = gettext("Warning: ");
#line 919
      printout((unsigned char)2, (char const   *)tmp___11);
#line 920
      tmp___12 = gettext("URL: # or ? functions unimplemented. Assuming they are part of the filename.\n");
#line 920
      printout((unsigned char)2, (char const   *)tmp___12);
      }
    } else {
      {
#line 918
      tmp___14 = strchr((char const   *)d, '?');
      }
#line 918
      if (tmp___14) {
        {
#line 919
        tmp___11 = gettext("Warning: ");
#line 919
        printout((unsigned char)2, (char const   *)tmp___11);
#line 920
        tmp___12 = gettext("URL: # or ? functions unimplemented. Assuming they are part of the filename.\n");
#line 920
        printout((unsigned char)2, (char const   *)tmp___12);
        }
      }
    }
    {
#line 922
    tmp___15 = unescape(d);
#line 922
    fsession->target_fname = cpy(tmp___15);
    }
  }
  {
#line 924
  free((void *)url);
  }
#line 925
  return (0);
}
}
#line 46 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.h"
wput_socket *socket_connect(unsigned int const   ip , unsigned short const   port ) ;
#line 47
wput_socket *socket_listen(unsigned int bindaddr , unsigned short *s_port ) ;
#line 48
wput_socket *socket_accept(wput_socket *sock ) ;
#line 54
char *socket_read_line(wput_socket *sock ) ;
#line 55
int socket_read(wput_socket *sock , void *buf___2 , size_t len ) ;
#line 59
int get_local_ip(int sockfd , char *local_ip ) ;
#line 62
int socket_is_data_writeable(int s , int timeout ) ;
#line 66
wput_socket *proxy_listen(proxy_settings *ps , unsigned int *ip , unsigned short *port ) ;
#line 67
wput_socket *proxy_accept(wput_socket *server ) ;
#line 68
wput_socket *proxy_connect(proxy_settings *ps , unsigned int ip , unsigned short port ,
                           char const   *hostname ) ;
#line 96 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.h"
void ftp_issue_cmd(ftp_con *self , char *cmd , char *value ) ;
#line 105
int ftp_do_syst(ftp_con *self ) ;
#line 117
int ftp_do_list(ftp_con *self ) ;
#line 127
int ftp_do_passive(ftp_con *self ) ;
#line 128
int ftp_do_port(ftp_con *self ) ;
#line 130
directory_list *directory_add_dir(char *current_directory , directory_list *A , struct fileinfo *K ) ;
#line 131
struct fileinfo *fileinfo_find_file(struct fileinfo *F , char *name ) ;
#line 133
void ftp_fileinfo_free(ftp_con *self ) ;
#line 136
void parse_passive_string(char *msg , unsigned int *ip , unsigned short *port ) ;
#line 209 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp.h"
struct fileinfo *ftp_parse_ls(char const   *file , enum stype  const  system_type ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
host_t *ftp_new_host(unsigned int ip , char *hostname , unsigned short port ) 
{ 
  host_t *h ;
  void *tmp ;

  {
  {
#line 35
  tmp = malloc(sizeof(host_t ));
#line 35
  h = (host_t *)tmp;
#line 36
  h->ip = ip;
#line 37
  h->hostname = hostname;
#line 38
  h->port = port;
  }
#line 39
  return (h);
}
}
#line 42 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
ftp_con *ftp_new(host_t *host , int secure ) 
{ 
  ftp_con *self ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 43
  tmp = malloc(sizeof(ftp_con ));
#line 43
  self = (ftp_con *)tmp;
#line 44
  memset((void *)self, 0, sizeof(ftp_con ));
#line 45
  self->host = host;
#line 46
  self->secure = (unsigned char )secure;
#line 47
  tmp___0 = malloc((size_t )82);
#line 47
  self->sbuf = (char *)tmp___0;
#line 48
  self->sbuflen = 82;
  }
#line 49
  return (self);
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
void ftp_free_host(host_t *host ) 
{ 


  {
#line 53
  if (host->hostname) {
    {
#line 53
    free((void *)host->hostname);
    }
  }
  {
#line 54
  free((void *)host);
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
void ftp_quit(ftp_con *self ) 
{ 
  char *tmp ;

  {
  {
#line 58
  ftp_free_host(self->host);
#line 59
  ftp_do_quit(self);
  }
#line 60
  if (self->current_directory) {
    {
#line 60
    free((void *)self->current_directory);
    }
  }
#line 61
  if (self->r.reply) {
    {
#line 61
    free((void *)self->r.reply);
    }
  }
#line 62
  if (self->user) {
    {
#line 62
    free((void *)self->user);
    }
  }
#line 63
  if (self->pass) {
    {
#line 63
    free((void *)self->pass);
    }
  }
  {
#line 64
  tmp = (char *)((void *)0);
#line 64
  self->r.reply = tmp;
#line 64
  self->current_directory = tmp;
#line 65
  free((void *)self->sbuf);
#line 67
  ftp_fileinfo_free(self);
#line 68
  free((void *)self);
  }
#line 69
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
static int multi_line  =    0;
#line 86 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_get_msg(ftp_con *self ) 
{ 
  char *msg ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 87
  tmp = socket_read_line(self->sock);
#line 87
  msg = tmp;
  }
#line 89
  if (self->r.reply) {
    {
#line 90
    free((void *)self->r.reply);
#line 91
    self->r.reply = (char *)((void *)0);
    }
  }
#line 93
  if (! msg) {
    {
#line 94
    tmp___0 = gettext("Receive-Error: Connection broke down.\n");
#line 94
    printout((unsigned char)1, (char const   *)tmp___0);
    }
#line 95
    return (-8);
  }
#line 97
  if ((unsigned long )msg == (unsigned long )((char *)-9)) {
#line 98
    return (-9);
  }
  {
#line 99
  tmp___5 = strlen((char const   *)msg);
  }
#line 99
  if (tmp___5 < 4UL) {
#line 99
    goto _L___0;
  } else
#line 99
  if ((int )*(msg + 0) >= 48) {
#line 99
    if ((int )*(msg + 0) <= 57) {
#line 99
      if ((int )*(msg + 1) >= 48) {
#line 99
        if ((int )*(msg + 1) <= 57) {
#line 99
          if ((int )*(msg + 2) >= 48) {
#line 99
            if (! ((int )*(msg + 2) <= 57)) {
#line 99
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 100
            if (multi_line) {
              {
#line 101
              printout((unsigned char)3, "# %s\n", msg);
#line 102
              free((void *)msg);
#line 103
              tmp___1 = ftp_get_msg(self);
              }
#line 103
              return (tmp___1);
            }
            {
#line 105
            tmp___2 = strlen((char const   *)msg);
#line 105
            tmp___3 = gettext("Receive-Error: Invalid FTP-answer (%d bytes): %s\n");
#line 105
            printout((unsigned char)1, (char const   *)tmp___3, tmp___2, msg);
#line 106
            free((void *)msg);
#line 107
            tmp___4 = gettext("Reconnecting to be sure, nothing went wrong\n");
#line 107
            printout((unsigned char)1, (char const   *)tmp___4);
            }
#line 108
            return (-8);
          }
        } else {
#line 99
          goto _L___0;
        }
      } else {
#line 99
        goto _L___0;
      }
    } else {
#line 99
      goto _L___0;
    }
  } else {
#line 99
    goto _L___0;
  }
#line 110
  if ((int )*(msg + 3) == 45) {
    {
#line 113
    multi_line = 1;
#line 114
    printout((unsigned char)3, "# %s\n", msg + 4);
#line 115
    free((void *)msg);
#line 116
    tmp___6 = ftp_get_msg(self);
    }
#line 116
    return (tmp___6);
  }
  {
#line 118
  multi_line = 0;
#line 119
  *(msg + 3) = (char)0;
#line 120
  tmp___7 = atoi((char const   *)msg);
#line 120
  self->r.code = (unsigned short )tmp___7;
#line 121
  self->r.reply = msg;
#line 122
  self->r.message = msg + 4;
#line 123
  printout((unsigned char)4, "[%d] \'%s\'\n", (int )self->r.code, self->r.message);
  }
#line 129
  if ((int )*(self->r.reply + 0) == 49) {
#line 130
    return (-2);
  }
#line 132
  if ((int )*(self->r.reply + 0) == 50) {
#line 133
    return (0);
  } else
#line 132
  if ((int )*(self->r.reply + 0) == 51) {
#line 133
    return (0);
  }
#line 136
  if ((int )*(self->r.reply + 0) == 52) {
#line 137
    return (-3);
  }
#line 139
  if ((int )*(self->r.reply + 0) == 53) {
#line 140
    return (-4);
  }
  {
#line 143
  printout((unsigned char)1, "Dead code reached by FTP-reply:\n%d %s\n", (int )self->r.code,
           self->r.message);
  }
#line 145
  return (0);
}
}
#line 149 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
void ftp_send_msg(ftp_con *self ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 150
  tmp = strncmp((char const   *)self->sbuf, "PASS", (size_t )4);
  }
#line 150
  if (tmp != 0) {
    {
#line 151
    printout((unsigned char)4, "---->%s", self->sbuf);
    }
  }
  {
#line 152
  tmp___0 = strlen((char const   *)self->sbuf);
#line 152
  socket_write(self->sock, (void *)self->sbuf, tmp___0);
  }
#line 153
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
void ftp_issue_cmd(ftp_con *self , char *cmd , char *value ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int pos ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 157
  tmp = strlen((char const   *)cmd);
  }
#line 157
  if (value) {
    {
#line 157
    tmp___0 = strlen((char const   *)value);
#line 157
    tmp___1 = tmp___0 + 1UL;
    }
  } else {
#line 157
    tmp___1 = (size_t )0;
  }
#line 157
  len = (int )(((tmp + tmp___1) + 2UL) + 1UL);
#line 163
  if (self->sbuflen < len) {
    {
#line 164
    tmp___2 = realloc((void *)self->sbuf, (size_t )len);
#line 164
    self->sbuf = (char *)tmp___2;
#line 165
    self->sbuflen = len;
    }
  }
  {
#line 167
  memset((void *)self->sbuf, 0, (size_t )self->sbuflen);
#line 170
  strcpy((char */* __restrict  */)self->sbuf, (char const   */* __restrict  */)cmd);
  }
#line 171
  if (value) {
    {
#line 172
    tmp___3 = strlen((char const   *)cmd);
#line 172
    pos = (int )tmp___3;
#line 173
    *(self->sbuf + pos) = (char )' ';
#line 174
    strcpy((char */* __restrict  */)((self->sbuf + pos) + 1), (char const   */* __restrict  */)value);
    }
  }
  {
#line 176
  tmp___4 = strlen((char const   *)self->sbuf);
#line 176
  strncpy((char */* __restrict  */)(self->sbuf + tmp___4), (char const   */* __restrict  */)"\r\n\000",
          (size_t )3);
#line 178
  ftp_send_msg(self);
  }
#line 179
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_connect(ftp_con *self , proxy_settings *ps ) 
{ 
  int res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 188
  res = 0;
#line 191
  if ((self->host)->ip) {
    {
#line 191
    tmp = printip((unsigned char *)(& (self->host)->ip));
#line 191
    tmp___0 = tmp;
    }
  } else {
#line 191
    tmp___0 = (self->host)->hostname;
  }
  {
#line 191
  tmp___1 = gettext("Connecting to %s:%d... ");
#line 191
  printout((unsigned char)2, (char const   *)tmp___1, tmp___0, (int )(self->host)->port);
  }
#line 195
  if (ps->type != 0U) {
    {
#line 196
    self->sock = proxy_connect(ps, (self->host)->ip, (self->host)->port, (char const   *)(self->host)->hostname);
    }
  } else {
    {
#line 198
    self->sock = socket_connect((unsigned int const   )(self->host)->ip, (unsigned short const   )(self->host)->port);
    }
  }
#line 200
  if (! self->sock) {
    {
#line 201
    tmp___2 = gettext("failed!\n");
#line 201
    printout((unsigned char)2, (char const   *)tmp___2);
    }
#line 202
    return (-1);
  }
  {
#line 204
  tmp___3 = gettext("connected");
#line 204
  printout((unsigned char)2, (char const   *)tmp___3);
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 211
    res = ftp_get_msg(self);
    }
#line 210
    if (! (res == -2)) {
#line 210
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  if (res == -8) {
#line 214
    return (-1);
  } else
#line 213
  if (res == -9) {
#line 214
    return (-1);
  }
#line 215
  if ((int )self->r.code != 220) {
    {
#line 216
    tmp___4 = gettext("Connection failed (%s)\n");
#line 216
    printout((unsigned char)2, (char const   *)tmp___4, self->r.message);
    }
#line 217
    return (-1);
  }
  {
#line 220
  printout((unsigned char)2, "! ");
#line 223
  self->loggedin = (unsigned char)0;
#line 224
  self->needcwd = (unsigned char)1;
#line 225
  self->OS = (enum stype )6;
#line 226
  self->current_type = (char)-1;
#line 227
  self->ps = ps;
#line 241
  printout((unsigned char)2, "\n");
  }
#line 242
  return (0);
}
}
#line 247 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_login(ftp_con *self , char *user , char *pass ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 248
  res = 0;
#line 251
  if (self->loggedin) {
#line 251
    if (! user) {
#line 251
      if (! self->user) {
#line 251
        goto _L___0;
      } else {
#line 251
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 251
    if (user) {
#line 251
      if (self->user) {
        {
#line 251
        tmp = strcmp((char const   *)user, (char const   *)self->user);
        }
#line 251
        if (! tmp) {
          _L___0: /* CIL Label */ 
#line 251
          if (! pass) {
#line 251
            if (! self->pass) {
#line 252
              return (0);
            } else {
#line 251
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 251
          if (pass) {
#line 251
            if (self->pass) {
              {
#line 251
              tmp___0 = strcmp((char const   *)pass, (char const   *)self->pass);
              }
#line 251
              if (! tmp___0) {
#line 252
                return (0);
              }
            }
          }
        }
      }
    }
  }
  {
#line 254
  tmp___1 = gettext("Logging in as %s ... ");
#line 254
  printout((unsigned char)2, (char const   *)tmp___1, user);
#line 256
  ftp_issue_cmd(self, (char *)"USER", user);
#line 257
  res = ftp_get_msg(self);
  }
#line 258
  if (res == -8) {
#line 258
    return (res);
  } else
#line 258
  if (res == -9) {
#line 258
    return (res);
  }
#line 263
  if ((int )self->r.code >= 300) {
#line 268
    if ((int )self->r.code == 331) {
#line 269
      if (! pass) {
        {
#line 270
        tmp___2 = gettext("Warning: ");
#line 270
        printout((unsigned char)3, (char const   *)tmp___2);
#line 271
        tmp___3 = gettext("remote server requires a password, but none set. Using an empty one.\n");
#line 271
        printout((unsigned char)3, (char const   *)tmp___3);
        }
      }
#line 273
      if (pass) {
#line 273
        tmp___4 = (char const   *)pass;
      } else {
#line 273
        tmp___4 = "";
      }
      {
#line 273
      ftp_issue_cmd(self, (char *)"PASS", (char *)tmp___4);
#line 274
      res = ftp_get_msg(self);
      }
#line 275
      if (res == -8) {
#line 275
        return (res);
      } else
#line 275
      if (res == -9) {
#line 275
        return (res);
      }
    }
#line 278
    if ((int )self->r.code == 332) {
      {
#line 279
      tmp___5 = gettext("Error: ");
#line 279
      printout((unsigned char)1, (char const   *)tmp___5);
#line 280
      tmp___6 = gettext("Server requires account login, which is not supported.\n");
#line 280
      printout((unsigned char)1, (char const   *)tmp___6);
      }
#line 281
      return (-1);
    }
  }
#line 284
  if ((int )self->r.code != 230) {
    {
#line 285
    tmp___7 = gettext("Error: ");
#line 285
    printout((unsigned char)1, (char const   *)tmp___7);
#line 286
    tmp___8 = gettext("Login-Sequence failed (%s)\n");
#line 286
    printout((unsigned char)1, (char const   *)tmp___8, self->r.message);
    }
#line 287
    return (-1);
  }
  {
#line 290
  tmp___9 = gettext("Logged in!\n");
#line 290
  printout((unsigned char)2, (char const   *)tmp___9);
#line 291
  self->loggedin = (unsigned char)1;
  }
#line 292
  if (user) {
    {
#line 292
    tmp___10 = cpy(user);
#line 292
    self->user = tmp___10;
    }
  } else {
#line 292
    self->user = (char *)((void *)0);
  }
#line 293
  if (pass) {
    {
#line 293
    tmp___11 = cpy(pass);
#line 293
    self->pass = tmp___11;
    }
  } else {
#line 293
    self->pass = (char *)((void *)0);
  }
#line 294
  return (0);
}
}
#line 339 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_syst(ftp_con *self ) 
{ 
  int res ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 342
  if ((unsigned int )self->OS != 6U) {
#line 342
    return (0);
  }
  {
#line 344
  printout((unsigned char)3, "==> SYST ... ");
#line 345
  ftp_issue_cmd(self, (char *)"SYST", (char *)0);
#line 346
  res = ftp_get_msg(self);
  }
#line 348
  if (res == -4) {
    {
#line 349
    self->OS = (enum stype )5;
#line 350
    tmp = gettext("failed.\n");
#line 350
    printout((unsigned char)3, (char const   *)tmp);
    }
#line 351
    return (0);
  } else
#line 352
  if (res < 0) {
#line 352
    return (res);
  }
#line 354
  self->OS = (enum stype )5;
#line 355
  if ((int )self->r.code == 215) {
    {
#line 356
    tmp___4 = strncasecmp((char const   *)self->r.message, "VMS", (size_t )3);
    }
#line 356
    if (tmp___4) {
      {
#line 358
      tmp___3 = strncasecmp((char const   *)self->r.message, "UNIX", (size_t )4);
      }
#line 358
      if (tmp___3) {
        {
#line 360
        tmp___2 = strncasecmp((char const   *)self->r.message, "WINDOWS_NT", (size_t )10);
        }
#line 360
        if (tmp___2) {
          {
#line 362
          tmp___1 = strncasecmp((char const   *)self->r.message, "MACOS", (size_t )5);
          }
#line 362
          if (tmp___1) {
            {
#line 364
            tmp___0 = strncasecmp((char const   *)self->r.message, "OS/400", (size_t )6);
            }
#line 364
            if (! tmp___0) {
#line 365
              self->OS = (enum stype )4;
            }
          } else {
#line 363
            self->OS = (enum stype )3;
          }
        } else {
#line 361
          self->OS = (enum stype )2;
        }
      } else {
#line 359
        self->OS = (enum stype )0;
      }
    } else {
#line 357
      self->OS = (enum stype )1;
    }
  }
  {
#line 367
  tmp___5 = gettext("done (%s).\n");
#line 367
  printout((unsigned char)3, (char const   *)tmp___5, self->r.message);
#line 368
  printout((unsigned char)4, "Operating System (enum): %d\n", (unsigned int )self->OS);
  }
#line 369
  return (0);
}
}
#line 373 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_abor(ftp_con *self ) 
{ 
  int res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 375
  printout((unsigned char)3, "==> ABOR ... ");
#line 376
  ftp_issue_cmd(self, (char *)"ABOR", (char *)0);
#line 377
  res = ftp_get_msg(self);
  }
#line 380
  if (res == -8) {
    {
#line 381
    tmp = gettext("failed.\n");
#line 381
    printout((unsigned char)3, (char const   *)tmp);
    }
#line 382
    return (-8);
  } else
#line 380
  if (res == -9) {
    {
#line 381
    tmp = gettext("failed.\n");
#line 381
    printout((unsigned char)3, (char const   *)tmp);
    }
#line 382
    return (-8);
  }
  {
#line 384
  tmp___0 = gettext("done.\n");
#line 384
  printout((unsigned char)3, (char const   *)tmp___0);
  }
#line 385
  if ((int )self->r.code == 426) {
    {
#line 386
    tmp___1 = gettext("Connection cancelled (%s)\n");
#line 386
    printout((unsigned char)2, (char const   *)tmp___1, self->r.message);
#line 387
    res = ftp_get_msg(self);
    }
  }
#line 389
  if (self->datasock) {
    {
#line 390
    socket_close(self->datasock);
#line 390
    self->datasock = (wput_socket *)0;
    }
  }
#line 392
  return (res);
}
}
#line 396 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
void ftp_do_quit(ftp_con *self ) 
{ 
  int tmp ;

  {
  {
#line 399
  printout((unsigned char)4, "Connection ended. (%x)\n", self->sock);
  }
#line 400
  if (self->sock) {
    {
#line 400
    tmp = socket_is_data_writeable((self->sock)->fd, 1);
    }
#line 400
    if (tmp) {
      {
#line 401
      ftp_issue_cmd(self, (char *)"QUIT", (char *)0);
#line 405
      ftp_get_msg(self);
      }
    }
  }
#line 407
  if (self->sock) {
    {
#line 407
    socket_close(self->sock);
    }
  }
#line 408
  if (self->datasock) {
    {
#line 408
    socket_close(self->datasock);
    }
  }
#line 409
  self->sock = (wput_socket *)((void *)0);
#line 410
  self->datasock = (wput_socket *)((void *)0);
#line 411
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_get_modification_time(ftp_con *self , char *filename , time_t *timestamp ) 
{ 
  int res ;
  struct fileinfo *finfo ;
  struct fileinfo *dl ;
  struct fileinfo *tmp ;
  struct tm ts ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 419
  finfo = (struct fileinfo *)((void *)0);
#line 420
  tmp = ftp_get_current_directory_list(self);
#line 420
  dl = tmp;
  }
#line 427
  if (! dl) {
    {
#line 428
    printout((unsigned char)3, "==> MDTM %s ... ", filename);
#line 429
    ftp_issue_cmd(self, (char *)"MDTM", filename);
#line 430
    res = ftp_get_msg(self);
    }
#line 431
    if (res == -8) {
#line 431
      return (res);
    } else
#line 431
    if (res == -9) {
#line 431
      return (res);
    }
#line 433
    if ((int )self->r.code == 213) {
      {
#line 436
      ts.tm_sec = atoi((char const   *)(self->r.message + 12));
#line 436
      *(self->r.message + 12) = (char)0;
#line 437
      ts.tm_min = atoi((char const   *)(self->r.message + 10));
#line 437
      *(self->r.message + 10) = (char)0;
#line 438
      ts.tm_hour = atoi((char const   *)(self->r.message + 8));
#line 438
      *(self->r.message + 8) = (char)0;
#line 439
      ts.tm_mday = atoi((char const   *)(self->r.message + 6));
#line 439
      *(self->r.message + 6) = (char)0;
#line 440
      ts.tm_mon = atoi((char const   *)(self->r.message + 4));
#line 440
      *(self->r.message + 4) = (char)0;
#line 441
      tmp___0 = atoi((char const   *)self->r.message);
#line 441
      ts.tm_year = tmp___0 - 1900;
#line 442
      ts.tm_wday = 0;
#line 443
      ts.tm_yday = 0;
#line 444
      ts.tm_isdst = -1;
#line 445
      (ts.tm_mon) --;
#line 447
      tmp___1 = gettext("done (modified on %d.%d.%d at %d:%d:%d)\n");
#line 447
      printout((unsigned char)3, (char const   *)tmp___1, ts.tm_mday, ts.tm_mon + 1,
               ts.tm_year + 1900, ts.tm_hour, ts.tm_min, ts.tm_sec);
#line 449
      *timestamp = mktime(& ts);
      }
#line 450
      return (0);
    }
    {
#line 452
    tmp___2 = gettext("failed.\n");
#line 452
    printout((unsigned char)3, (char const   *)tmp___2);
    }
#line 453
    if ((int )self->r.code == 551) {
#line 454
      return (-1);
    }
    {
#line 455
    res = ftp_get_list(self);
    }
#line 456
    if (res == -8) {
#line 456
      return (res);
    } else
#line 456
    if (res == -9) {
#line 456
      return (res);
    } else
#line 456
    if (res == -1) {
#line 456
      return (res);
    }
    {
#line 457
    dl = ftp_get_current_directory_list(self);
    }
  }
#line 459
  if (dl) {
    {
#line 459
    finfo = fileinfo_find_file(dl, filename);
    }
  }
#line 460
  if (! finfo) {
#line 460
    return (-1);
  }
#line 461
  *timestamp = finfo->tstamp;
#line 462
  return (0);
}
}
#line 468 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_get_filesize(ftp_con *self , char *filename , off_t *filesize ) 
{ 
  int res ;
  struct fileinfo *finfo ;
  struct fileinfo *dl ;
  struct fileinfo *tmp ;
  char *tmp___0 ;
  long long tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 470
  finfo = (struct fileinfo *)((void *)0);
#line 471
  tmp = ftp_get_current_directory_list(self);
#line 471
  dl = tmp;
  }
#line 473
  if (! dl) {
    {
#line 474
    printout((unsigned char)3, "==> SIZE %s ... ", filename);
#line 475
    ftp_issue_cmd(self, (char *)"SIZE", filename);
#line 476
    res = ftp_get_msg(self);
    }
#line 477
    if (res == -8) {
#line 477
      return (res);
    } else
#line 477
    if (res == -9) {
#line 477
      return (res);
    }
#line 480
    if ((int )self->r.code == 213) {
      {
#line 481
      tmp___0 = gettext("done (%s bytes)\n");
#line 481
      printout((unsigned char)3, (char const   *)tmp___0, self->r.message);
#line 482
      tmp___1 = strtoll((char const   */* __restrict  */)self->r.message, (char **/* __restrict  */)((void *)0),
                        10);
#line 482
      *filesize = (off_t )tmp___1;
      }
#line 483
      return (0);
    }
    {
#line 485
    tmp___2 = gettext("failed.\n");
#line 485
    printout((unsigned char)3, (char const   *)tmp___2);
    }
#line 486
    if ((int )self->r.code == 550) {
#line 487
      return (-1);
    }
    {
#line 490
    res = ftp_get_list(self);
    }
#line 491
    if (res == -8) {
#line 491
      return (res);
    } else
#line 491
    if (res == -9) {
#line 491
      return (res);
    } else
#line 491
    if (res == -1) {
#line 491
      return (res);
    }
    {
#line 492
    dl = ftp_get_current_directory_list(self);
    }
  }
#line 494
  if (dl) {
    {
#line 494
    finfo = fileinfo_find_file(dl, filename);
    }
  }
#line 495
  if (! finfo) {
#line 495
    return (-1);
  }
#line 496
  *filesize = finfo->size;
#line 497
  return (0);
}
}
#line 501 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_get_fileinfo(ftp_con *self , char *filename , struct fileinfo **info ) 
{ 
  int res ;
  struct fileinfo *finfo ;
  struct fileinfo *dl ;
  struct fileinfo *tmp ;

  {
  {
#line 503
  finfo = (struct fileinfo *)((void *)0);
#line 504
  tmp = ftp_get_current_directory_list(self);
#line 504
  dl = tmp;
  }
#line 506
  if (! dl) {
    {
#line 507
    res = ftp_get_list(self);
    }
#line 508
    if (res == -8) {
#line 508
      return (res);
    } else
#line 508
    if (res == -9) {
#line 508
      return (res);
    } else
#line 508
    if (res == -1) {
#line 508
      return (res);
    }
    {
#line 509
    dl = ftp_get_current_directory_list(self);
    }
  }
#line 511
  if (dl) {
    {
#line 511
    finfo = fileinfo_find_file(dl, filename);
    }
  }
#line 512
  if (! finfo) {
#line 512
    return (-1);
  }
#line 513
  *info = finfo;
#line 514
  return (0);
}
}
#line 521 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
static char *types[2]  = {      (char *)"A",      (char *)"I"};
#line 519 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_set_type(ftp_con *self , int type ) 
{ 
  int res ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 524
  if ((int )self->current_type == type) {
#line 524
    return (0);
  }
  {
#line 526
  printout((unsigned char)3, "==> TYPE %s ... ", types[type]);
#line 527
  ftp_issue_cmd(self, (char *)"TYPE", types[type]);
#line 528
  res = ftp_get_msg(self);
  }
#line 530
  if ((int )self->r.code == 200) {
    {
#line 531
    tmp = gettext("done.\n");
#line 531
    printout((unsigned char)3, (char const   *)tmp);
#line 532
    self->current_type = (char )type;
    }
#line 533
    return (0);
  }
  {
#line 535
  tmp___0 = gettext("failed.\n");
#line 535
  printout((unsigned char)3, (char const   *)tmp___0);
  }
#line 536
  return (res);
}
}
#line 539 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_cwd(ftp_con *self , char *directory ) 
{ 
  int res ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 542
  printout((unsigned char)3, "==> CWD %s", directory);
#line 543
  tmp = strncmp((char const   *)directory, "..", (size_t )3);
  }
#line 543
  if (tmp) {
    {
#line 546
    ftp_issue_cmd(self, (char *)"CWD", directory);
    }
  } else {
    {
#line 544
    ftp_issue_cmd(self, (char *)"CDUP", (char *)((void *)0));
    }
  }
  {
#line 547
  res = ftp_get_msg(self);
  }
#line 548
  if (res == -8) {
#line 549
    return (-8);
  } else
#line 548
  if (res == -9) {
#line 549
    return (-8);
  }
#line 552
  if ((int )self->r.code != 250) {
    {
#line 553
    tmp___0 = gettext(" failed (%s).\n");
#line 553
    printout((unsigned char)3, (char const   *)tmp___0, self->r.message);
    }
#line 554
    return (-1);
  } else
#line 552
  if ((int )self->r.code == 200) {
    {
#line 553
    tmp___0 = gettext(" failed (%s).\n");
#line 553
    printout((unsigned char)3, (char const   *)tmp___0, self->r.message);
    }
#line 554
    return (-1);
  }
  {
#line 556
  printout((unsigned char)3, "\n");
  }
#line 557
  return (0);
}
}
#line 559 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_mkd(ftp_con *self , char *directory ) 
{ 
  int res ;
  char *tmp ;

  {
  {
#line 562
  printout((unsigned char)3, "==> MKD %s", directory);
#line 563
  ftp_issue_cmd(self, (char *)"MKD", directory);
#line 564
  res = ftp_get_msg(self);
  }
#line 565
  if (res == -8) {
#line 566
    return (-8);
  } else
#line 565
  if (res == -9) {
#line 566
    return (-8);
  }
#line 569
  if ((int )self->r.code / 10 != 25) {
    {
#line 570
    tmp = gettext(" failed (%s).\n");
#line 570
    printout((unsigned char)3, (char const   *)tmp, self->r.message);
    }
#line 571
    return (-1);
  }
  {
#line 573
  printout((unsigned char)3, "\n");
  }
#line 574
  return (0);
}
}
#line 578 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_list(ftp_con *self ) 
{ 
  int res ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 581
  res = ftp_set_type(self, 0);
  }
#line 582
  if (res == -8) {
#line 583
    return (-8);
  } else
#line 582
  if (res == -9) {
#line 583
    return (-8);
  }
  {
#line 585
  printout((unsigned char)3, "==> LIST ... ");
#line 586
  ftp_issue_cmd(self, (char *)"LIST", (char *)((void *)0));
#line 587
  res = ftp_get_msg(self);
  }
#line 588
  if (res == -8) {
#line 589
    return (-8);
  } else
#line 588
  if (res == -9) {
#line 589
    return (-8);
  }
#line 594
  if ((int )*(self->r.reply + 0) != 49) {
    {
#line 595
    tmp = gettext("failed.\n");
#line 595
    printout((unsigned char)3, (char const   *)tmp);
    }
#line 596
    return (-1);
  }
  {
#line 598
  tmp___0 = gettext("done.\n");
#line 598
  printout((unsigned char)3, (char const   *)tmp___0);
#line 600
  tmp___3 = ftp_complete_data_connection(self);
  }
#line 600
  if (tmp___3 < 0) {
    {
#line 601
    tmp___1 = ftp_do_abor(self);
    }
#line 601
    if (tmp___1 == -8) {
#line 601
      return (-8);
    } else {
      {
#line 601
      tmp___2 = ftp_do_abor(self);
      }
#line 601
      if (tmp___2 == -9) {
#line 601
        return (-8);
      }
    }
#line 602
    return (-1);
  }
#line 604
  return (0);
}
}
#line 607 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_chmod(ftp_con *self , char *lfile , char *rfile ) 
{ 
  int res ;
  char *mode ;
  void *tmp ;
  struct stat statbuf ;
  char *tmp___0 ;
  char *value ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 609
  tmp = malloc((size_t )7);
#line 609
  mode = (char *)tmp;
  }
#line 611
  if (opt.chmod == 1U) {
    {
#line 617
    res = stat((char const   */* __restrict  */)lfile, (struct stat */* __restrict  */)(& statbuf));
    }
#line 619
    if (res != 0) {
      {
#line 620
      tmp___0 = gettext("Error accessing local file for getting mode");
#line 620
      perror((char const   *)tmp___0);
      }
#line 621
      return (-1);
    }
    {
#line 623
    snprintf((char */* __restrict  */)mode, (size_t )7, (char const   */* __restrict  */)"%lo",
             (unsigned long )statbuf.st_mode);
    }
  } else {
    {
#line 625
    snprintf((char */* __restrict  */)mode, (size_t )7, (char const   */* __restrict  */)"%lo",
             (unsigned long )opt.chmod);
    }
  }
  {
#line 628
  printout((unsigned char)3, "==> SITE CHMOD %s %s ... ", mode, rfile);
#line 629
  tmp___1 = strlen((char const   *)mode);
#line 629
  tmp___2 = strlen((char const   *)rfile);
#line 629
  tmp___3 = malloc(((tmp___1 + 1UL) + tmp___2) + 1UL);
#line 629
  value = (char *)tmp___3;
#line 633
  strcpy((char */* __restrict  */)value, (char const   */* __restrict  */)mode);
#line 634
  strcat((char */* __restrict  */)value, (char const   */* __restrict  */)" ");
#line 635
  strcat((char */* __restrict  */)value, (char const   */* __restrict  */)rfile);
#line 636
  free((void *)mode);
#line 637
  ftp_issue_cmd(self, (char *)"SITE CHMOD", value);
#line 638
  free((void *)value);
#line 639
  res = ftp_get_msg(self);
  }
#line 641
  if ((int )self->r.code != 200) {
    {
#line 642
    tmp___4 = gettext(" failed (%s).\n");
#line 642
    printout((unsigned char)3, (char const   *)tmp___4, self->r.message);
    }
#line 643
    return (-1);
  } else {
    {
#line 645
    tmp___5 = gettext(" done.\n");
#line 645
    printout((unsigned char)3, (char const   *)tmp___5);
    }
  }
  {
#line 647
  tmp___6 = gettext("\n");
#line 647
  printout((unsigned char)3, (char const   *)tmp___6);
  }
#line 648
  return (0);
}
}
#line 652 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
char *ls_next  ;
#line 656 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_get_list(ftp_con *self ) 
{ 
  int res ;
  int size ;
  char *list ;
  char rbuf[1024] ;
  struct fileinfo *listing ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 658
  size = 1;
#line 664
  res = ftp_do_syst(self);
  }
#line 665
  if (res < 0) {
#line 665
    return (res);
  }
  {
#line 667
  res = ftp_establish_data_connection(self);
  }
#line 668
  if (res < 0) {
    {
#line 669
    tmp = gettext("Error: ");
#line 669
    printout((unsigned char)1, (char const   *)tmp);
    }
#line 670
    if (res == -3) {
#line 670
      tmp___0 = (char const   *)self->r.message;
    } else
#line 670
    if (res == -4) {
#line 670
      tmp___0 = (char const   *)self->r.message;
    } else
#line 670
    if (res == -1) {
#line 670
      tmp___0 = (char const   *)self->r.message;
    } else {
#line 670
      tmp___0 = "";
    }
    {
#line 670
    tmp___1 = gettext("Cannot initiate data-connection (%s)\n");
#line 670
    printout((unsigned char)1, (char const   *)tmp___1, tmp___0);
    }
#line 672
    return (res);
  }
  {
#line 675
  res = ftp_do_list(self);
  }
#line 676
  if (res < 0) {
#line 676
    return (res);
  }
  {
#line 680
  tmp___2 = malloc((size_t )1);
#line 680
  list = (char *)tmp___2;
#line 681
  *(list + 0) = (char)0;
  }
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 684
    res = socket_read(self->datasock, (void *)(rbuf), (size_t )1023);
    }
#line 684
    if (! (res > 0)) {
#line 684
      goto while_break;
    }
    {
#line 685
    rbuf[res] = (char)0;
#line 686
    size += res;
#line 687
    tmp___3 = realloc((void *)list, (size_t )size);
#line 687
    list = (char *)tmp___3;
#line 688
    strcat((char */* __restrict  */)list, (char const   */* __restrict  */)(rbuf));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 692
  if (res == -9) {
    {
#line 693
    res = ftp_do_abor(self);
    }
#line 694
    if (res == -8) {
#line 694
      return (-8);
    } else
#line 694
    if (res == -9) {
#line 694
      return (-8);
    }
  }
#line 697
  if (self->datasock) {
    {
#line 698
    socket_close(self->datasock);
#line 699
    self->datasock = (wput_socket *)((void *)0);
    }
  }
  {
#line 704
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 705
    res = ftp_get_msg(self);
    }
#line 704
    if (! (res == -2)) {
#line 704
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 708
  if (res == -9) {
    {
#line 710
    res = ftp_do_abor(self);
    }
  }
#line 712
  if (res == -3) {
#line 712
    goto _L;
  } else
#line 712
  if (res == -4) {
    _L: /* CIL Label */ 
    {
#line 713
    free((void *)list);
#line 714
    tmp___4 = gettext("Error: ");
#line 714
    printout((unsigned char)1, (char const   *)tmp___4);
#line 715
    tmp___5 = gettext("listing directory failed (%s)\n");
#line 715
    printout((unsigned char)1, (char const   *)tmp___5, self->r.message);
    }
#line 716
    return (res);
  } else
#line 717
  if (res < 0) {
    {
#line 718
    free((void *)list);
    }
#line 719
    return (res);
  }
  {
#line 722
  printout((unsigned char)4, "Directory-Listing:\n%s\n-----\n", list);
#line 723
  ls_next = list;
#line 724
  listing = ftp_parse_ls((char const   *)list, (enum stype  const  )self->OS);
#line 725
  free((void *)list);
  }
#line 727
  if (self->current_directory) {
#line 727
    tmp___6 = (char const   *)self->current_directory;
  } else {
#line 727
    tmp___6 = "";
  }
  {
#line 727
  self->directorylist = directory_add_dir((char *)tmp___6, self->directorylist, listing);
  }
#line 728
  return (0);
}
}
#line 733 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_rest(ftp_con *self , off_t filesize ) 
{ 
  char tmpbuf[21] ;
  int res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 737
  printout((unsigned char)3, "==> REST %d ... ", filesize);
#line 738
  tmp = int64toa(filesize, tmpbuf, 10);
#line 738
  ftp_issue_cmd(self, (char *)"REST", tmp);
#line 739
  res = ftp_get_msg(self);
  }
#line 740
  if (res == -8) {
#line 741
    return (-8);
  } else
#line 740
  if (res == -9) {
#line 741
    return (-8);
  }
#line 743
  if ((int )self->r.code != 350) {
    {
#line 744
    tmp___0 = gettext("failed.\nServer seems not to support resuming. Restarting at 0\n");
#line 744
    printout((unsigned char)3, (char const   *)tmp___0);
    }
#line 745
    return (-1);
  }
  {
#line 747
  tmp___1 = gettext("done.\n");
#line 747
  printout((unsigned char)3, (char const   *)tmp___1);
  }
#line 748
  return (0);
}
}
#line 753 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_stor(ftp_con *self , char *filename ) 
{ 
  int res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 756
  printout((unsigned char)3, "==> STOR %s ... ", filename);
#line 757
  ftp_issue_cmd(self, (char *)"STOR", filename);
#line 758
  res = ftp_get_msg(self);
  }
#line 763
  if (res == -9) {
    {
#line 764
    tmp = gettext("[not done, but should be allright]\n");
#line 764
    printout((unsigned char)3, (char const   *)tmp);
    }
#line 765
    return (0);
  } else
#line 766
  if (res == -8) {
#line 767
    return (res);
  } else
#line 766
  if (res == -9) {
#line 767
    return (res);
  } else
#line 768
  if (res == -4) {
#line 769
    return (-1);
  }
#line 791
  if ((int )*(self->r.reply + 0) == 49) {
    {
#line 792
    tmp___0 = gettext("done.\n");
#line 792
    printout((unsigned char)3, (char const   *)tmp___0);
    }
#line 793
    return (0);
  }
#line 795
  if ((int )self->r.code == 451) {
    {
#line 796
    tmp___1 = gettext("failed (%s). (disabling resuming)\n");
#line 796
    printout((unsigned char)3, (char const   *)tmp___1, self->r.message);
    }
#line 797
    return (1);
  } else
#line 795
  if ((int )self->r.code == 553) {
    {
#line 796
    tmp___1 = gettext("failed (%s). (disabling resuming)\n");
#line 796
    printout((unsigned char)3, (char const   *)tmp___1, self->r.message);
    }
#line 797
    return (1);
  }
#line 799
  if ((int )self->r.code == 450) {
#line 799
    goto _L;
  } else
#line 799
  if ((int )self->r.code == 226) {
#line 799
    goto _L;
  } else
#line 799
  if ((int )self->r.code == 425) {
    _L: /* CIL Label */ 
    {
#line 800
    tmp___2 = gettext("failed.\n");
#line 800
    printout((unsigned char)3, (char const   *)tmp___2, self->r.message);
    }
#line 801
    if ((int )self->r.code == 425) {
      {
#line 802
      self->portmode = (unsigned char )(~ ((int )self->portmode));
#line 803
      tmp___3 = gettext("Trying to switch PORT/PASV mode\n");
#line 803
      printout((unsigned char)3, (char const   *)tmp___3);
      }
    }
#line 805
    return (-3);
  }
  {
#line 807
  tmp___4 = gettext("failed (%d %s). (skipping)\n");
#line 807
  printout((unsigned char)3, (char const   *)tmp___4, (int )self->r.code, self->r.message);
  }
#line 808
  return (-1);
}
}
#line 812 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_dele(ftp_con *self , char *filename ) 
{ 
  int res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 815
  printout((unsigned char)3, "==> DELE %s ... ", filename);
#line 816
  ftp_issue_cmd(self, (char *)"DELE", filename);
#line 817
  res = ftp_get_msg(self);
  }
#line 818
  if (res == -8) {
#line 819
    return (res);
  } else
#line 818
  if (res == -9) {
#line 819
    return (res);
  } else
#line 820
  if (res == -3) {
    {
#line 821
    tmp = gettext("failed (%s)\n");
#line 821
    printout((unsigned char)3, (char const   *)tmp, self->r.message);
    }
#line 822
    return (-3);
  } else
#line 823
  if (res == -4) {
#line 824
    return (-1);
  } else
#line 825
  if ((int )self->r.code == 250) {
    {
#line 826
    tmp___0 = gettext("done.\n");
#line 826
    printout((unsigned char)3, (char const   *)tmp___0);
    }
#line 827
    return (0);
  }
  {
#line 829
  tmp___1 = gettext("failed (%d %s). (skipping)\n");
#line 829
  printout((unsigned char)3, (char const   *)tmp___1, (int )self->r.code, self->r.message);
  }
#line 830
  return (-1);
}
}
#line 834 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_rmd(ftp_con *self , char *dirname ) 
{ 
  int res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 837
  printout((unsigned char)3, "==> RMD %s ... ", dirname);
#line 838
  ftp_issue_cmd(self, (char *)"RMD", dirname);
#line 839
  res = ftp_get_msg(self);
  }
#line 840
  if (res == -8) {
#line 841
    return (res);
  } else
#line 840
  if (res == -9) {
#line 841
    return (res);
  } else
#line 842
  if (res == -3) {
    {
#line 843
    tmp = gettext("failed (%s)\n");
#line 843
    printout((unsigned char)3, (char const   *)tmp, self->r.message);
    }
#line 844
    return (-3);
  } else
#line 845
  if (res == -4) {
    {
#line 846
    tmp___0 = gettext("failed (%s)\n");
#line 846
    printout((unsigned char)3, (char const   *)tmp___0, self->r.message);
    }
#line 847
    return (-1);
  } else
#line 848
  if ((int )self->r.code == 250) {
    {
#line 849
    tmp___1 = gettext("done.\n");
#line 849
    printout((unsigned char)3, (char const   *)tmp___1);
    }
#line 850
    return (0);
  }
  {
#line 852
  tmp___2 = gettext("failed (%d %s). (skipping)\n");
#line 852
  printout((unsigned char)3, (char const   *)tmp___2, (int )self->r.code, self->r.message);
  }
#line 853
  return (-1);
}
}
#line 862 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_establish_data_connection(ftp_con *self ) 
{ 
  int res ;

  {
  {
#line 879
  printout((unsigned char)4, "Portmode: %d\n", (int )self->portmode);
  }
#line 880
  if (! self->portmode) {
    {
#line 881
    res = ftp_do_passive(self);
    }
#line 882
    if (res == -1) {
      {
#line 886
      res = ftp_do_port(self);
      }
#line 887
      if (res < 0) {
#line 887
        return (res);
      }
#line 888
      self->portmode = (unsigned char)1;
    }
  } else {
    {
#line 892
    res = ftp_do_port(self);
    }
#line 893
    if (res == -1) {
      {
#line 894
      res = ftp_do_passive(self);
      }
#line 895
      if (res < 0) {
#line 895
        return (res);
      }
#line 896
      self->portmode = (unsigned char)0;
    }
  }
#line 899
  return (res);
}
}
#line 903 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_complete_data_connection(ftp_con *self ) 
{ 


  {
#line 904
  if (self->portmode) {
#line 905
    if ((self->ps)->type == 1U) {
#line 905
      if ((self->ps)->bind) {
        {
#line 906
        self->datasock = proxy_accept(self->servsock);
        }
      } else {
        {
#line 908
        self->datasock = socket_accept(self->servsock);
#line 909
        socket_close(self->servsock);
        }
      }
    } else {
      {
#line 908
      self->datasock = socket_accept(self->servsock);
#line 909
      socket_close(self->servsock);
      }
    }
#line 911
    self->servsock = (wput_socket *)((void *)0);
#line 913
    if (! self->datasock) {
#line 913
      return (-1);
    }
  }
#line 922
  return (0);
}
}
#line 927 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_passive(ftp_con *self ) 
{ 
  unsigned short sport ;
  unsigned int sip ;
  int res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 928
  sport = (unsigned short)0;
#line 929
  sip = 0U;
#line 932
  printout((unsigned char)3, "==> PASV ... ");
#line 933
  ftp_issue_cmd(self, (char *)"PASV", (char *)((void *)0));
#line 934
  res = ftp_get_msg(self);
  }
#line 935
  if (res == -8) {
#line 935
    return (-8);
  } else
#line 935
  if (res == -9) {
#line 935
    return (-8);
  }
#line 937
  if ((int )self->r.code != 227) {
    {
#line 938
    tmp = gettext("failed.\n");
#line 938
    printout((unsigned char)3, (char const   *)tmp);
    }
#line 939
    return (-1);
  }
  {
#line 941
  tmp___0 = gettext("done.\n");
#line 941
  printout((unsigned char)3, (char const   *)tmp___0);
#line 944
  parse_passive_string(self->r.message, & sip, & sport);
#line 945
  tmp___1 = printip((unsigned char *)(& sip));
#line 945
  printout((unsigned char)4, "Remote server data port: %s:%d\n", tmp___1, (int )sport);
  }
#line 947
  if ((self->ps)->type == 0U) {
    {
#line 948
    self->datasock = socket_connect((unsigned int const   )sip, (unsigned short const   )sport);
    }
  } else {
    {
#line 950
    self->datasock = proxy_connect(self->ps, sip, sport, (char const   *)((void *)0));
    }
  }
#line 952
  if (! self->datasock) {
    {
#line 953
    tmp___2 = gettext("connection failed.\n");
#line 953
    printout((unsigned char)3, (char const   *)tmp___2);
    }
#line 954
    return (-1);
  }
#line 957
  return (0);
}
}
#line 962 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
int ftp_do_port(ftp_con *self ) 
{ 
  unsigned short sport ;
  unsigned int sip ;
  int res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  wput_socket *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 963
  sport = (unsigned short)0;
#line 964
  sip = 0U;
#line 970
  if ((self->ps)->type == 1U) {
#line 970
    if ((self->ps)->bind) {
      {
#line 971
      tmp = gettext("Trying to listen on proxy server... ");
#line 971
      printout((unsigned char)3, (char const   *)tmp);
#line 972
      self->servsock = proxy_listen(self->ps, & sip, & sport);
      }
#line 973
      if (! self->servsock) {
        {
#line 974
        tmp___0 = gettext("failed. Falling back to listen locally\n");
#line 974
        printout((unsigned char)3, (char const   *)tmp___0);
#line 975
        tmp___1 = gettext("Warning: ");
#line 975
        printout((unsigned char)3, (char const   *)tmp___1);
#line 976
        tmp___2 = gettext("Unless FXP is enabled remotely, your control-connection should be from the same IP-address, as your PORT bind-request. So you should consider PASV-mode or reconnect without a proxy.\n");
#line 976
        printout((unsigned char)3, (char const   *)tmp___2);
#line 981
        (self->ps)->bind = 0U;
        }
      } else {
        {
#line 983
        tmp___3 = gettext("done.\n");
#line 983
        printout((unsigned char)3, (char const   *)tmp___3);
        }
      }
    } else {
#line 970
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 984
  if ((self->ps)->type == 2U) {
    {
#line 986
    tmp___4 = gettext("Warning: ");
#line 986
    printout((unsigned char)2, (char const   *)tmp___4);
#line 987
    tmp___5 = gettext("Using port-mode. Unable to use the http-proxy for this connection\n");
#line 987
    printout((unsigned char)2, (char const   *)tmp___5);
    }
  }
#line 990
  if (! self->servsock) {
    {
#line 991
    tmp___6 = socket_listen(self->bindaddr, & sport);
#line 991
    self->servsock = tmp___6;
    }
#line 991
    if (! tmp___6) {
#line 992
      return (-1);
    }
  }
  {
#line 994
  printout((unsigned char)3, "==> PORT ... ");
  }
#line 995
  if ((self->ps)->type == 1U) {
#line 995
    if (! (self->ps)->bind) {
#line 995
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 996
    printout((unsigned char)4, "determing local ip_addr\n");
#line 997
    res = get_local_ip((self->sock)->fd, (char *)(& sip));
    }
#line 999
    if (res == -1) {
      {
#line 999
      tmp___7 = gettext("Cannot determine local IP address");
#line 999
      Abort(tmp___7);
      }
    }
    {
#line 1000
    tmp___8 = printip((unsigned char *)(& sip));
#line 1000
    printout((unsigned char)4, "Local IP: %s\n", tmp___8);
    }
  }
  {
#line 1003
  tmp___9 = get_port_fmt((int )sip, (unsigned int )sport);
#line 1003
  ftp_issue_cmd(self, (char *)"PORT", tmp___9);
#line 1004
  res = ftp_get_msg(self);
  }
#line 1005
  if (res == -8) {
#line 1005
    return (res);
  } else
#line 1005
  if (res == -9) {
#line 1005
    return (res);
  }
#line 1007
  if ((int )self->r.code != 200) {
    {
#line 1008
    tmp___10 = gettext("failed.\n");
#line 1008
    printout((unsigned char)3, (char const   *)tmp___10);
    }
#line 1009
    return (-1);
  }
  {
#line 1011
  tmp___11 = gettext("done.\n");
#line 1011
  printout((unsigned char)3, (char const   *)tmp___11);
  }
#line 1012
  return (0);
}
}
#line 1025 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
static char *ls_line  ;
#line 1023 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
char *read_whole_line(FILE *fp ) 
{ 
  char *nl ;

  {
  {
#line 1027
  printout((unsigned char)4, "read_whole_line. ls_next: %x\n", ls_next);
#line 1029
  ls_line = ls_next;
#line 1030
  nl = strchr((char const   *)ls_line, '\n');
  }
#line 1032
  if ((unsigned long )nl == (unsigned long )((void *)0)) {
#line 1034
    return ((char *)((void *)0));
  } else {
#line 1038
    *nl = (char )'\000';
#line 1039
    ls_next = nl + 1;
#line 1040
    return (ls_line);
  }
}
}
#line 1047 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
char nextchr(void) 
{ 


  {
#line 1049
  return (*ls_next);
}
}
#line 1060 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
directory_list *directory_add_dir(char *current_directory , directory_list *A , struct fileinfo *K ) 
{ 
  void *tmp ;

  {
#line 1061
  if ((unsigned long )A == (unsigned long )((void *)0)) {
    {
#line 1062
    tmp = malloc(sizeof(directory_list ));
#line 1062
    A = (directory_list *)tmp;
#line 1063
    A->list = K;
#line 1064
    A->name = cpy(current_directory);
#line 1065
    A->next = (struct _directory_list *)((void *)0);
    }
  } else {
    {
#line 1067
    A->next = directory_add_dir(current_directory, A->next, K);
    }
  }
#line 1068
  return (A);
}
}
#line 1071 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
void ftp_fileinfo_free(ftp_con *self ) 
{ 
  directory_list *K ;
  directory_list *L ;
  struct fileinfo *M ;
  struct fileinfo *N ;

  {
#line 1072
  K = self->directorylist;
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! ((unsigned long )K != (unsigned long )((void *)0))) {
#line 1076
      goto while_break;
    }
    {
#line 1077
    L = K->next;
#line 1078
    free((void *)K->name);
#line 1079
    M = K->list;
    }
    {
#line 1080
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1080
      if (! ((unsigned long )M != (unsigned long )((void *)0))) {
#line 1080
        goto while_break___0;
      }
#line 1081
      N = M->next;
#line 1082
      if (M->name) {
        {
#line 1082
        free((void *)M->name);
        }
      }
      {
#line 1083
      free((void *)M);
#line 1084
      M = N;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1086
    free((void *)K);
#line 1087
    K = L;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1089
  return;
}
}
#line 1091 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
struct fileinfo *fileinfo_find_file(struct fileinfo *F , char *name ) 
{ 
  int tmp ;

  {
  {
#line 1092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1092
    if (! ((unsigned long )F != (unsigned long )((void *)0))) {
#line 1092
      goto while_break;
    }
    {
#line 1093
    tmp = strcmp((char const   *)F->name, (char const   *)name);
    }
#line 1093
    if (! tmp) {
#line 1093
      return (F);
    }
#line 1094
    F = F->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  return ((struct fileinfo *)((void *)0));
}
}
#line 1098 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
struct fileinfo *ftp_get_current_directory_list(ftp_con *self ) 
{ 
  directory_list *K ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 1099
  K = self->directorylist;
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    if (! ((unsigned long )K != (unsigned long )((void *)0))) {
#line 1100
      goto while_break;
    }
#line 1101
    if (self->current_directory) {
#line 1101
      tmp = (char const   *)self->current_directory;
    } else {
#line 1101
      tmp = "";
    }
    {
#line 1101
    tmp___0 = strcmp((char const   *)K->name, tmp);
    }
#line 1101
    if (! tmp___0) {
#line 1101
      return (K->list);
    }
#line 1102
    K = K->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1104
  return ((struct fileinfo *)((void *)0));
}
}
#line 1112 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftplib.c"
void parse_passive_string(char *msg , unsigned int *ip , unsigned short *port ) 
{ 
  char *start ;
  char *tmp ;
  char *curtok ;
  char temp[6] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1113
  tmp = strchr((char const   *)msg, '(');
#line 1113
  start = tmp + 1;
#line 1116
  i = 0;
#line 1117
  curtok = strtok((char */* __restrict  */)start, (char const   */* __restrict  */)",");
  }
  {
#line 1118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1119
    tmp___0 = i;
#line 1119
    i ++;
#line 1119
    tmp___1 = atoi((char const   *)curtok);
#line 1119
    temp[tmp___0] = (char )tmp___1;
#line 1118
    curtok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
#line 1118
    if (! curtok) {
#line 1118
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1123
  *ip = *((unsigned int *)(temp));
#line 1124
  *port = ntohs(*((unsigned short *)(temp + 4)));
  }
#line 1125
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 213
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strptime)(char const   * __restrict  __s ,
                                                                                 char const   * __restrict  __fmt ,
                                                                                 struct tm *__tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp-ls.c"
static int clean_line(char *line ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 88
  tmp = strlen((char const   *)line);
#line 88
  len = (int )tmp;
  }
#line 89
  if (! len) {
#line 89
    return (0);
  }
#line 90
  if ((int )*(line + (len - 1)) == 10) {
#line 91
    len --;
#line 91
    *(line + len) = (char )'\000';
  }
#line 92
  if ((int )*(line + (len - 1)) == 13) {
#line 93
    len --;
#line 93
    *(line + len) = (char )'\000';
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! *line) {
#line 94
      goto while_break;
    }
#line 94
    if ((int )*line == 9) {
#line 94
      *line = (char )' ';
    }
#line 94
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (len);
}
}
#line 110
static struct fileinfo *ftp_parse_unix_ls(char const   *file , int ignore_perms ) ;
#line 110 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp-ls.c"
static char const   *months[12]  = 
#line 110
  {      "Jan",      "Feb",      "Mar",      "Apr", 
        "May",      "Jun",      "Jul",      "Aug", 
        "Sep",      "Oct",      "Nov",      "Dec"};
#line 319
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 106 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp-ls.c"
static struct fileinfo *ftp_parse_unix_ls(char const   *file , int ignore_perms ) 
{ 
  FILE *fp ;
  int next ;
  int len ;
  int i ;
  int error ;
  int ignore ;
  int year ;
  int month ;
  int day ;
  int hour ;
  int min ;
  int sec ;
  struct tm timestruct ;
  struct tm *tnow ;
  time_t timenow ;
  char *line ;
  char *tok ;
  struct fileinfo *dir ;
  struct fileinfo *l ;
  struct fileinfo cur ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *t ;
  long mul ;
  int fnlen ;
  char *p ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  struct fileinfo *tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 123
  memset((void *)(& timenow), '\000', sizeof(timenow));
#line 124
  memset((void *)(& timestruct), '\000', sizeof(timestruct));
#line 125
  memset((void *)(& cur), '\000', sizeof(cur));
#line 127
  fp = stdin;
  }
#line 128
  if (! fp) {
    {
#line 130
    tmp = __errno_location();
#line 130
    tmp___0 = strerror(*tmp);
#line 130
    printout((unsigned char)4, "%s: %s\n", file, tmp___0);
    }
#line 131
    return ((struct fileinfo *)((void *)0));
  }
#line 133
  l = (struct fileinfo *)((void *)0);
#line 133
  dir = l;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 136
    line = read_whole_line(fp);
    }
#line 136
    if (! line) {
#line 136
      goto while_break;
    }
    {
#line 138
    len = clean_line(line);
#line 140
    tmp___1 = strncasecmp((char const   *)line, "total", (size_t )5);
    }
#line 140
    if (! tmp___1) {
#line 143
      goto while_continue;
    }
    {
#line 146
    tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
    }
#line 147
    if (! tok) {
#line 150
      goto while_continue;
    }
#line 153
    cur.name = (char *)((void *)0);
#line 154
    cur.linkto = (char *)((void *)0);
    {
#line 159
    if ((int )*tok == 45) {
#line 159
      goto case_45;
    }
#line 163
    if ((int )*tok == 100) {
#line 163
      goto case_100;
    }
#line 167
    if ((int )*tok == 108) {
#line 167
      goto case_108;
    }
#line 171
    goto switch_default;
    case_45: /* CIL Label */ 
    {
#line 160
    cur.type = (enum ftype )0;
#line 161
    printout((unsigned char)4, "PLAINFILE; ");
    }
#line 162
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 164
    cur.type = (enum ftype )1;
#line 165
    printout((unsigned char)4, "DIRECTORY; ");
    }
#line 166
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 168
    cur.type = (enum ftype )2;
#line 169
    printout((unsigned char)4, "SYMLINK; ");
    }
#line 170
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 172
    cur.type = (enum ftype )3;
#line 173
    printout((unsigned char)4, "UNKNOWN; ");
    }
#line 174
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 201
    ignore = 0;
#line 201
    error = ignore;
#line 203
    sec = 0;
#line 203
    min = sec;
#line 203
    hour = min;
#line 203
    year = hour;
#line 204
    day = 0;
#line 204
    month = day;
#line 205
    next = -1;
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 217
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
#line 217
      if (! tok) {
#line 217
        goto while_break___0;
      }
#line 219
      next --;
#line 220
      if (next < 0) {
#line 222
        i = 0;
        {
#line 222
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 222
          if (! (i < 12)) {
#line 222
            goto while_break___1;
          }
          {
#line 223
          tmp___2 = strcmp((char const   *)tok, months[i]);
          }
#line 223
          if (! tmp___2) {
#line 224
            goto while_break___1;
          }
#line 222
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 227
        if (i != 12) {
#line 229
          t = tok - 2;
#line 230
          mul = 1L;
#line 232
          cur.size = (off_t )0;
          {
#line 232
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 232
            if ((unsigned long )t > (unsigned long )line) {
#line 232
              if ((int )*t >= 48) {
#line 232
                if (! ((int )*t <= 57)) {
#line 232
                  goto while_break___2;
                }
              } else {
#line 232
                goto while_break___2;
              }
            } else {
#line 232
              goto while_break___2;
            }
#line 233
            cur.size += mul * (long )((int )*t - 48);
#line 232
            mul *= 10L;
#line 232
            t --;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 234
          if ((unsigned long )t == (unsigned long )line) {
#line 237
            error = 1;
#line 238
            goto while_break___0;
          }
          {
#line 240
          month = i;
#line 241
          next = 5;
#line 242
          printout((unsigned char)4, "month: %s; ", months[month]);
          }
        }
      } else
#line 245
      if (next == 4) {
#line 247
        if (*(tok + 1)) {
#line 248
          day = (10 * ((int )*tok - 48) + (int )*(tok + 1)) - 48;
        } else {
#line 250
          day = (int )*tok - 48;
        }
        {
#line 251
        printout((unsigned char)4, "day: %d; ", day);
        }
      } else
#line 253
      if (next == 3) {
#line 261
        year = 0;
#line 262
        sec = 0;
#line 262
        hour = sec;
#line 262
        min = hour;
#line 264
        if ((int )*tok >= 48) {
#line 264
          if ((int )*tok <= 57) {
            {
#line 267
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 267
              if ((int )*tok >= 48) {
#line 267
                if (! ((int )*tok <= 57)) {
#line 267
                  goto while_break___3;
                }
              } else {
#line 267
                goto while_break___3;
              }
#line 268
              year = ((int )*tok - 48) + 10 * year;
#line 267
              tok ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 269
            if ((int )*tok == 58) {
#line 272
              hour = year;
#line 273
              year = 0;
#line 274
              tok ++;
              {
#line 276
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 276
                if ((int )*tok >= 48) {
#line 276
                  if (! ((int )*tok <= 57)) {
#line 276
                    goto while_break___4;
                  }
                } else {
#line 276
                  goto while_break___4;
                }
#line 277
                min = ((int )*tok - 48) + 10 * min;
#line 276
                tok ++;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 278
              if ((int )*tok == 58) {
#line 281
                tok ++;
                {
#line 282
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 282
                  if ((int )*tok >= 48) {
#line 282
                    if (! ((int )*tok <= 57)) {
#line 282
                      goto while_break___5;
                    }
                  } else {
#line 282
                    goto while_break___5;
                  }
#line 283
                  sec = ((int )*tok - 48) + 10 * sec;
#line 282
                  tok ++;
                }
                while_break___5: /* CIL Label */ ;
                }
              }
            }
          }
        }
#line 287
        if (year) {
          {
#line 289
          printout((unsigned char)4, "year: %d (no tm); ", year);
          }
        } else {
          {
#line 293
          printout((unsigned char)4, "time: %02d:%02d:%02d (no yr); ", hour, min,
                   sec);
          }
        }
      } else
#line 296
      if (next == 2) {
        {
#line 303
        tmp___3 = strlen((char const   *)tok);
#line 303
        fnlen = (int )tmp___3;
        }
#line 304
        if ((long )fnlen < (long )len - (tok - line)) {
#line 308
          *(tok + fnlen) = (char )' ';
#line 311
          if ((unsigned int )cur.type == 2U) {
            {
#line 313
            p = strstr((char const   *)tok, " -> ");
            }
#line 314
            if (! p) {
#line 316
              error = 1;
#line 317
              goto while_break___0;
            }
            {
#line 319
            tmp___4 = (int )strdup(p + 4);
#line 319
            cur.linkto = (char *)tmp___4;
#line 320
            printout((unsigned char)4, "link to: %s\n", cur.linkto);
#line 322
            *p = (char )'\000';
            }
          }
        }
        {
#line 328
        tmp___5 = strcmp((char const   *)tok, ".");
        }
#line 328
        if (tmp___5) {
          {
#line 328
          tmp___6 = strcmp((char const   *)tok, "..");
          }
#line 328
          if (! tmp___6) {
            {
#line 330
            printout((unsigned char)4, "\nIgnoring `.\' and `..\'; ");
#line 331
            ignore = 1;
            }
#line 332
            goto while_break___0;
          }
        } else {
          {
#line 330
          printout((unsigned char)4, "\nIgnoring `.\' and `..\'; ");
#line 331
          ignore = 1;
          }
#line 332
          goto while_break___0;
        }
        {
#line 342
        tmp___7 = strlen((char const   *)tok);
#line 342
        fnlen = (int )tmp___7;
#line 343
        tmp___8 = malloc((size_t )(fnlen + 1));
#line 343
        cur.name = (char *)tmp___8;
#line 344
        memcpy((void */* __restrict  */)cur.name, (void const   */* __restrict  */)tok,
               (size_t )(fnlen + 1));
        }
#line 345
        if (fnlen) {
#line 347
          if ((unsigned int )cur.type == 1U) {
#line 347
            if ((int )*(cur.name + (fnlen - 1)) == 47) {
              {
#line 349
              *(cur.name + (fnlen - 1)) = (char )'\000';
#line 350
              printout((unsigned char)4, "trailing `/\' on dir.\n");
              }
            } else {
#line 347
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 352
          if ((unsigned int )cur.type == 2U) {
#line 352
            if ((int )*(cur.name + (fnlen - 1)) == 64) {
              {
#line 354
              *(cur.name + (fnlen - 1)) = (char )'\000';
#line 355
              printout((unsigned char)4, "trailing `@\' on link.\n");
              }
            } else {
#line 352
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 357
          if ((unsigned int )cur.type == 0U) {
#line 357
            if (cur.perms & 73) {
#line 357
              if ((int )*(cur.name + (fnlen - 1)) == 42) {
                {
#line 361
                *(cur.name + (fnlen - 1)) = (char )'\000';
#line 362
                printout((unsigned char)4, "trailing `*\' on exec.\n");
                }
              }
            }
          }
        } else {
#line 366
          error = 1;
        }
#line 367
        goto while_break___0;
      } else {
        {
#line 370
        abort();
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 373
    if (! cur.name) {
#line 374
      error = 1;
    } else
#line 373
    if ((unsigned int )cur.type == 2U) {
#line 373
      if (! cur.linkto) {
#line 374
        error = 1;
      }
    }
    {
#line 376
    printout((unsigned char)4, "\n");
    }
#line 378
    if (error) {
#line 378
      goto _L___1;
    } else
#line 378
    if (ignore) {
      _L___1: /* CIL Label */ 
      {
#line 380
      printout((unsigned char)4, "Skipping.\n");
      }
      {
#line 381
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 381
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 382
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 382
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 384
      goto while_continue;
    }
#line 387
    if (! dir) {
      {
#line 389
      tmp___9 = malloc(sizeof(struct fileinfo ));
#line 389
      dir = (struct fileinfo *)tmp___9;
#line 389
      l = dir;
#line 390
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 391
      tmp___10 = (struct fileinfo *)((void *)0);
#line 391
      l->next = tmp___10;
#line 391
      l->prev = tmp___10;
      }
    } else {
      {
#line 395
      cur.prev = l;
#line 396
      tmp___11 = malloc(sizeof(struct fileinfo ));
#line 396
      l->next = (struct fileinfo *)tmp___11;
#line 397
      l = l->next;
#line 398
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 399
      l->next = (struct fileinfo *)((void *)0);
      }
    }
    {
#line 402
    timenow = time((time_t *)((void *)0));
#line 403
    tnow = localtime((time_t const   *)(& timenow));
#line 405
    timestruct.tm_sec = sec;
#line 406
    timestruct.tm_min = min;
#line 407
    timestruct.tm_hour = hour;
#line 408
    timestruct.tm_mday = day;
#line 409
    timestruct.tm_mon = month;
    }
#line 410
    if (year == 0) {
#line 417
      if (month > tnow->tm_mon) {
#line 418
        timestruct.tm_year = tnow->tm_year - 1;
      } else {
#line 420
        timestruct.tm_year = tnow->tm_year;
      }
    } else {
#line 423
      timestruct.tm_year = year;
    }
#line 424
    if (timestruct.tm_year >= 1900) {
#line 425
      timestruct.tm_year -= 1900;
    }
    {
#line 426
    timestruct.tm_wday = 0;
#line 427
    timestruct.tm_yday = 0;
#line 428
    timestruct.tm_isdst = -1;
#line 429
    l->tstamp = mktime(& timestruct);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (dir);
}
}
#line 438 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp-ls.c"
static struct fileinfo *ftp_parse_winnt_ls(char const   *file ) 
{ 
  FILE *fp ;
  int len ;
  int year ;
  int month ;
  int day ;
  int hour ;
  int min ;
  struct tm timestruct ;
  char *line ;
  char *tok ;
  struct fileinfo *dir ;
  struct fileinfo *l ;
  struct fileinfo cur ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  struct fileinfo *tmp___5 ;
  void *tmp___6 ;

  {
#line 450
  fp = stdin;
#line 451
  if (! fp) {
    {
#line 453
    tmp = __errno_location();
#line 453
    tmp___0 = strerror(*tmp);
#line 453
    printout((unsigned char)4, "%s: %s\n", file, tmp___0);
    }
#line 454
    return ((struct fileinfo *)((void *)0));
  }
#line 456
  l = (struct fileinfo *)((void *)0);
#line 456
  dir = l;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 459
    line = read_whole_line(fp);
    }
#line 459
    if (! line) {
#line 459
      goto while_break;
    }
    {
#line 461
    len = clean_line(line);
    }
#line 469
    if (len < 40) {
#line 469
      goto while_continue;
    }
    {
#line 470
    tok = line + 39;
#line 471
    tmp___1 = (int )strdup(tok);
#line 471
    cur.name = (char *)tmp___1;
#line 472
    printout((unsigned char)4, "Name: \'%s\'\n", cur.name);
#line 476
    tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)"-");
#line 477
    tmp___2 = atoi((char const   *)tok);
#line 477
    month = tmp___2 - 1;
    }
#line 478
    if (month < 0) {
#line 478
      month = 0;
    }
    {
#line 479
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"-");
#line 480
    day = atoi((char const   *)tok);
#line 481
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 482
    year = atoi((char const   *)tok);
    }
#line 484
    if (year <= 70) {
#line 484
      year += 100;
    }
    {
#line 488
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
#line 489
    hour = atoi((char const   *)tok);
#line 490
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"M");
#line 491
    min = atoi((char const   *)tok);
#line 494
    tok += 2;
    }
#line 495
    if (hour == 12) {
#line 495
      hour = 0;
    }
#line 496
    if ((int )*tok == 80) {
#line 496
      hour += 12;
    }
    {
#line 498
    printout((unsigned char)4, "YYYY/MM/DD HH:MM - %d/%02d/%02d %02d:%02d\n", year + 1900,
             month, day, hour, min);
#line 502
    timestruct.tm_sec = 0;
#line 503
    timestruct.tm_min = min;
#line 504
    timestruct.tm_hour = hour;
#line 505
    timestruct.tm_mday = day;
#line 506
    timestruct.tm_mon = month;
#line 507
    timestruct.tm_year = year;
#line 508
    timestruct.tm_wday = 0;
#line 509
    timestruct.tm_yday = 0;
#line 510
    timestruct.tm_isdst = -1;
#line 511
    cur.tstamp = mktime(& timestruct);
#line 513
    printout((unsigned char)4, "Timestamp: %ld\n", cur.tstamp);
#line 519
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
    {
#line 520
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 520
      if (! ((int )*tok == 0)) {
#line 520
        goto while_break___0;
      }
      {
#line 520
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 521
    if ((int )*tok == 60) {
      {
#line 523
      cur.type = (enum ftype )1;
#line 524
      cur.size = (off_t )0;
#line 525
      cur.perms = 493;
#line 526
      printout((unsigned char)4, "Directory\n");
      }
    } else {
      {
#line 530
      cur.type = (enum ftype )0;
#line 531
      tmp___3 = atoi((char const   *)tok);
#line 531
      cur.size = (off_t )tmp___3;
#line 532
      cur.perms = 420;
#line 533
      printout((unsigned char)4, "File, size %ld bytes\n", cur.size);
      }
    }
#line 536
    cur.linkto = (char *)((void *)0);
#line 539
    if (! dir) {
      {
#line 541
      tmp___4 = malloc(sizeof(struct fileinfo ));
#line 541
      dir = (struct fileinfo *)tmp___4;
#line 541
      l = dir;
#line 542
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 543
      tmp___5 = (struct fileinfo *)((void *)0);
#line 543
      l->next = tmp___5;
#line 543
      l->prev = tmp___5;
      }
    } else {
      {
#line 547
      cur.prev = l;
#line 548
      tmp___6 = malloc(sizeof(struct fileinfo ));
#line 548
      l->next = (struct fileinfo *)tmp___6;
#line 549
      l = l->next;
#line 550
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 551
      l->next = (struct fileinfo *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  return (dir);
}
}
#line 577 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp-ls.c"
static struct fileinfo *ftp_parse_vms_ls(char const   *file ) 
{ 
  FILE *fp ;
  int dt ;
  int i ;
  int j ;
  int len ;
  int perms ;
  time_t timenow ;
  struct tm timestruct ;
  char date_str[32] ;
  char *line ;
  char *tok ;
  struct fileinfo *dir ;
  struct fileinfo *l ;
  struct fileinfo cur ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *p ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  void *tmp___14 ;
  struct fileinfo *tmp___15 ;
  void *tmp___16 ;

  {
#line 590
  fp = stdin;
#line 591
  if (! fp) {
    {
#line 593
    tmp = __errno_location();
#line 593
    tmp___0 = strerror(*tmp);
#line 593
    printout((unsigned char)4, "%s: %s\n", file, tmp___0);
    }
#line 594
    return ((struct fileinfo *)((void *)0));
  }
#line 596
  l = (struct fileinfo *)((void *)0);
#line 596
  dir = l;
#line 600
  j = 0;
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 603
    line = read_whole_line(fp);
    }
#line 604
    if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 606
      goto while_break;
    } else {
      {
#line 610
      i = clean_line(line);
      }
#line 611
      if (i <= 0) {
#line 614
        goto while_continue;
      } else
#line 618
      if (j == 0) {
#line 618
        if ((int )*(line + (i - 1)) == 93) {
#line 623
          j = 1;
        } else {
#line 618
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 625
        tmp___1 = strncmp((char const   *)line, "Total of ", (size_t )9);
        }
#line 625
        if (tmp___1) {
#line 636
          goto while_break;
        } else {
#line 631
          line = (char *)((void *)0);
#line 632
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 645
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 645
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 645
      goto while_break___0;
    }
    {
#line 655
    tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
    }
#line 656
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 656
      tok = line;
    }
    {
#line 657
    printout((unsigned char)4, "file name: \'%s\'\n", tok);
#line 665
    p = tok;
    }
    {
#line 665
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 665
      if (*p) {
#line 665
        if (! ((int )*p != 59)) {
#line 665
          goto while_break___1;
        }
      } else {
#line 665
        goto while_break___1;
      }
#line 665
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 666
    if ((int )*p == 59) {
#line 666
      *p = (char )'\000';
    }
    {
#line 677
    tmp___2 = strlen((char const   *)tok);
#line 677
    len = (int )tmp___2;
#line 678
    tmp___4 = strncasecmp((char const   *)(tok + (len - 4)), ".DIR", (size_t )4);
    }
#line 678
    if (tmp___4) {
      {
#line 685
      tmp___3 = strncasecmp((char const   *)(tok + (len - 6)), ".DIR;1", (size_t )6);
      }
#line 685
      if (tmp___3) {
        {
#line 694
        cur.type = (enum ftype )0;
#line 695
        cur.perms = 420;
#line 696
        printout((unsigned char)4, "File\n");
        }
      } else {
        {
#line 687
        len -= 6;
#line 687
        *(tok + len) = (char )'\000';
#line 688
        cur.type = (enum ftype )1;
#line 689
        cur.perms = 493;
#line 690
        printout((unsigned char)4, "Directory (v)\n");
        }
      }
    } else {
      {
#line 680
      len -= 4;
#line 680
      *(tok + len) = (char )'\000';
#line 681
      cur.type = (enum ftype )1;
#line 682
      cur.perms = 493;
#line 683
      printout((unsigned char)4, "Directory (nv)\n");
      }
    }
    {
#line 698
    tmp___5 = (int )strdup(tok);
#line 698
    cur.name = (char *)tmp___5;
#line 699
    printout((unsigned char)4, "Name: \'%s\'\n", cur.name);
#line 702
    date_str[0] = (char )'\000';
#line 705
    cur.linkto = (char *)((void *)0);
#line 711
    cur.size = (off_t )0;
#line 717
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 718
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
      {
#line 720
      printout((unsigned char)4, "Getting additional line.\n");
#line 722
      line = read_whole_line(fp);
      }
#line 723
      if (! line) {
        {
#line 725
        printout((unsigned char)4, "EOF.  Leaving listing parser.\n");
        }
#line 726
        goto while_break___0;
      }
#line 732
      if (i <= 0) {
        {
#line 735
        printout((unsigned char)4, "Blank line.  Leaving listing parser.\n");
        }
#line 737
        goto while_break___0;
      } else
#line 739
      if ((int )*(line + 0) != 32) {
        {
#line 741
        printout((unsigned char)4, "Non-blank in column 1.  Must be a new file name?\n");
        }
#line 742
        goto while_continue___0;
      } else {
        {
#line 746
        tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
        }
#line 747
        if ((unsigned long )tok == (unsigned long )((void *)0)) {
          {
#line 750
          printout((unsigned char)4, "Null token.  Leaving listing parser.\n");
          }
#line 752
          goto while_break___0;
        }
      }
    }
    {
#line 770
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 770
      if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 770
        goto while_break___2;
      }
      {
#line 772
      printout((unsigned char)4, "Token: >%s<: ", tok);
#line 774
      tmp___12 = strlen((char const   *)tok);
      }
#line 774
      if (tmp___12 < 12UL) {
        {
#line 774
        tmp___13 = strchr((char const   *)tok, '-');
        }
#line 774
        if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
          {
#line 777
          printout((unsigned char)4, "Date.\n");
#line 778
          strcpy((char */* __restrict  */)(date_str), (char const   */* __restrict  */)tok);
#line 779
          strcat((char */* __restrict  */)(date_str), (char const   */* __restrict  */)" ");
          }
        } else {
#line 774
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 781
        tmp___10 = strlen((char const   *)tok);
        }
#line 781
        if (tmp___10 < 12UL) {
          {
#line 781
          tmp___11 = strchr((char const   *)tok, ':');
          }
#line 781
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
            {
#line 784
            printout((unsigned char)4, "Time. ");
#line 785
            tmp___6 = strlen((char const   *)(date_str));
#line 785
            strncat((char */* __restrict  */)(date_str), (char const   */* __restrict  */)tok,
                    (sizeof(date_str) - tmp___6) - 1UL);
#line 788
            printout((unsigned char)4, "Date time: >%s<\n", date_str);
            }
          } else {
#line 781
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 790
          tmp___9 = strchr((char const   *)tok, '[');
          }
#line 790
          if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
            {
#line 793
            printout((unsigned char)4, "Owner.\n");
            }
          } else {
            {
#line 795
            tmp___8 = strchr((char const   *)tok, '(');
            }
#line 795
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 798
              perms = 0;
#line 799
              j = 0;
#line 800
              i = 0;
              {
#line 800
              while (1) {
                while_continue___3: /* CIL Label */ ;
                {
#line 800
                tmp___7 = strlen((char const   *)tok);
                }
#line 800
                if (! ((size_t )i < tmp___7)) {
#line 800
                  goto while_break___3;
                }
                {
#line 804
                if ((int )*(tok + i) == 40) {
#line 804
                  goto case_40;
                }
#line 806
                if ((int )*(tok + i) == 41) {
#line 806
                  goto case_41;
                }
#line 808
                if ((int )*(tok + i) == 44) {
#line 808
                  goto case_44;
                }
#line 819
                if ((int )*(tok + i) == 82) {
#line 819
                  goto case_82;
                }
#line 822
                if ((int )*(tok + i) == 87) {
#line 822
                  goto case_87;
                }
#line 825
                if ((int )*(tok + i) == 69) {
#line 825
                  goto case_69;
                }
#line 828
                if ((int )*(tok + i) == 68) {
#line 828
                  goto case_68;
                }
#line 802
                goto switch_break;
                case_40: /* CIL Label */ 
#line 805
                goto switch_break;
                case_41: /* CIL Label */ 
#line 807
                goto switch_break;
                case_44: /* CIL Label */ 
#line 809
                if (j == 0) {
#line 811
                  perms = 0;
#line 812
                  j = 1;
                } else {
#line 816
                  perms <<= 3;
                }
#line 818
                goto switch_break;
                case_82: /* CIL Label */ 
#line 820
                perms |= 4;
#line 821
                goto switch_break;
                case_87: /* CIL Label */ 
#line 823
                perms |= 2;
#line 824
                goto switch_break;
                case_69: /* CIL Label */ 
#line 826
                perms |= 1;
#line 827
                goto switch_break;
                case_68: /* CIL Label */ 
#line 829
                perms |= 2;
#line 830
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
#line 800
                i ++;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 833
              cur.perms = perms;
#line 834
              printout((unsigned char)4, "Prot.  perms = %0o.\n", cur.perms);
              }
            } else {
              {
#line 841
              printout((unsigned char)4, "Ignored (size?).\n");
              }
            }
          }
        }
      }
      {
#line 844
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 854
    timenow = time((time_t *)((void *)0));
#line 855
    localtime_r((time_t const   */* __restrict  */)(& timenow), (struct tm */* __restrict  */)(& timestruct));
#line 856
    strptime((char const   */* __restrict  */)(date_str), (char const   */* __restrict  */)"%d-%b-%Y %H:%M:%S",
             & timestruct);
#line 859
    timenow = mktime(& timestruct);
#line 861
    tok = getenv("WGET_TIMEZONE_DIFFERENTIAL");
    }
#line 861
    if ((unsigned long )tok != (unsigned long )((void *)0)) {
      {
#line 863
      dt = atoi((char const   *)tok);
#line 864
      printout((unsigned char)4, "Time differential = %d.\n", dt);
      }
    } else {
#line 868
      dt = 0;
    }
#line 871
    if (dt >= 0) {
#line 873
      timenow += (time_t )dt;
    } else {
#line 877
      timenow -= (time_t )(- dt);
    }
    {
#line 879
    cur.tstamp = timenow;
#line 880
    printout((unsigned char)4, "Timestamp: %ld\n", cur.tstamp);
    }
#line 883
    if (! dir) {
      {
#line 885
      tmp___14 = malloc(sizeof(struct fileinfo ));
#line 885
      dir = (struct fileinfo *)tmp___14;
#line 885
      l = dir;
#line 886
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 887
      tmp___15 = (struct fileinfo *)((void *)0);
#line 887
      l->next = tmp___15;
#line 887
      l->prev = tmp___15;
      }
    } else {
      {
#line 891
      cur.prev = l;
#line 892
      tmp___16 = malloc(sizeof(struct fileinfo ));
#line 892
      l->next = (struct fileinfo *)tmp___16;
#line 893
      l = l->next;
#line 894
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             sizeof(cur));
#line 895
      l->next = (struct fileinfo *)((void *)0);
      }
    }
    {
#line 900
    line = read_whole_line(fp);
    }
#line 901
    if ((unsigned long )line != (unsigned long )((void *)0)) {
      {
#line 903
      i = clean_line(line);
      }
#line 904
      if (i <= 0) {
#line 908
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 914
  return (dir);
}
}
#line 930 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/ftp-ls.c"
struct fileinfo *ftp_parse_ls(char const   *file , enum stype  const  system_type ) 
{ 
  struct fileinfo *tmp ;
  FILE *fp ;
  int c ;
  int *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  struct fileinfo *tmp___3 ;
  struct fileinfo *tmp___4 ;
  struct fileinfo *tmp___5 ;
  struct fileinfo *tmp___6 ;
  char *tmp___7 ;
  struct fileinfo *tmp___8 ;

  {
  {
#line 935
  if ((unsigned int const   )system_type == 0U) {
#line 935
    goto case_0;
  }
#line 937
  if ((unsigned int const   )system_type == 2U) {
#line 937
    goto case_2;
  }
#line 958
  if ((unsigned int const   )system_type == 1U) {
#line 958
    goto case_1;
  }
#line 960
  if ((unsigned int const   )system_type == 3U) {
#line 960
    goto case_3;
  }
#line 962
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 936
  tmp = ftp_parse_unix_ls(file, 0);
  }
#line 936
  return (tmp);
  case_2: /* CIL Label */ 
#line 943
  fp = stdin;
#line 944
  if (! fp) {
    {
#line 946
    tmp___0 = __errno_location();
#line 946
    tmp___1 = strerror(*tmp___0);
#line 946
    printout((unsigned char)4, "%s: %s\n", file, tmp___1);
    }
#line 947
    return ((struct fileinfo *)((void *)0));
  }
  {
#line 949
  tmp___2 = nextchr();
#line 949
  c = (int )tmp___2;
  }
#line 953
  if (c >= 48) {
#line 953
    if (c <= 57) {
      {
#line 954
      tmp___3 = ftp_parse_winnt_ls(file);
      }
#line 954
      return (tmp___3);
    } else {
      {
#line 956
      tmp___4 = ftp_parse_unix_ls(file, 1);
      }
#line 956
      return (tmp___4);
    }
  } else {
    {
#line 956
    tmp___4 = ftp_parse_unix_ls(file, 1);
    }
#line 956
    return (tmp___4);
  }
  case_1: /* CIL Label */ 
  {
#line 959
  tmp___5 = ftp_parse_vms_ls(file);
  }
#line 959
  return (tmp___5);
  case_3: /* CIL Label */ 
  {
#line 961
  tmp___6 = ftp_parse_unix_ls(file, 1);
  }
#line 961
  return (tmp___6);
  switch_default: /* CIL Label */ 
  {
#line 963
  tmp___7 = gettext("Unsupported listing type, trying Unix listing parser.\n");
#line 963
  printout((unsigned char)4, (char const   *)tmp___7);
#line 965
  tmp___8 = ftp_parse_unix_ls(file, 0);
  }
#line 965
  return (tmp___8);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/netrc.c"
static void maybe_add_to_list(acc_t **newentry , acc_t **list ) 
{ 
  acc_t *a ;
  acc_t *l ;
  void *tmp ;

  {
#line 56
  a = *newentry;
#line 57
  l = *list;
#line 60
  if (a) {
#line 60
    if (! a->acc) {
      {
#line 63
      free((void *)a->host);
#line 64
      free((void *)a->acc);
#line 65
      free((void *)a->passwd);
      }
    } else {
#line 60
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 69
    if (a) {
#line 72
      a->next = l;
#line 73
      l = a;
    }
    {
#line 77
    tmp = malloc(sizeof(acc_t ));
#line 77
    a = (acc_t *)tmp;
    }
  }
  {
#line 81
  memset((void *)a, 0, sizeof(*a));
#line 84
  *newentry = a;
#line 85
  *list = l;
  }
#line 86
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/netrc.c"
static void shift_left(char *string ) 
{ 
  char *p ;

  {
#line 97
  p = string;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *p) {
#line 97
      goto while_break;
    }
#line 98
    *p = *(p + 1);
#line 97
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/netrc.c"
acc_t *parse_netrc(char const   *path ) 
{ 
  FILE *fp ;
  char *line ;
  char *p ;
  char *tok ;
  char *premature_token ;
  acc_t *current ;
  acc_t *retval ;
  int ln ;
  int quote ;
  enum __anonenum_last_token_56 last_token ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  acc_t *saved_reference ;

  {
  {
#line 111
  last_token = (enum __anonenum_last_token_56 )0;
#line 116
  retval = (acc_t *)((void *)0);
#line 116
  current = retval;
#line 118
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 119
  if (! fp) {
    {
#line 121
    tmp = __errno_location();
#line 121
    tmp___0 = strerror(*tmp);
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot read %s (%s).\n",
            path, tmp___0);
    }
#line 123
    return (retval);
  }
#line 127
  ln = 0;
#line 128
  premature_token = (char *)((void *)0);
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    line = read_line(fp);
    }
#line 131
    if (! line) {
#line 131
      goto while_break;
    }
#line 133
    ln ++;
#line 136
    p = line;
#line 137
    quote = 0;
    {
#line 140
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 140
      if (*p) {
        {
#line 140
        tmp___1 = isspace((int )*p);
        }
#line 140
        if (! tmp___1) {
#line 140
          goto while_break___0;
        }
      } else {
#line 140
        goto while_break___0;
      }
#line 141
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    if ((unsigned int )last_token == 3U) {
#line 144
      if (! *p) {
#line 146
        last_token = (enum __anonenum_last_token_56 )0;
      }
    }
    {
#line 149
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 149
      if (*p) {
#line 149
        if (! ((unsigned int )last_token != 3U)) {
#line 149
          goto while_break___1;
        }
      } else {
#line 149
        goto while_break___1;
      }
      {
#line 152
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 152
        if (*p) {
          {
#line 152
          tmp___2 = isspace((int )*p);
          }
#line 152
          if (! tmp___2) {
#line 152
            goto while_break___2;
          }
        } else {
#line 152
          goto while_break___2;
        }
#line 153
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 157
      if ((int )*p == 35) {
#line 158
        goto while_break___1;
      } else
#line 157
      if (! *p) {
#line 158
        goto while_break___1;
      }
#line 162
      if ((int )*p == 34) {
        {
#line 163
        quote = 1;
#line 164
        shift_left(p);
        }
      }
#line 167
      tok = p;
      {
#line 170
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 170
        if (*p) {
#line 170
          if (quote) {
#line 170
            tmp___5 = (int )*p != 34;
          } else {
            {
#line 170
            tmp___3 = isspace((int )*p);
            }
#line 170
            if (tmp___3) {
#line 170
              tmp___4 = 0;
            } else {
#line 170
              tmp___4 = 1;
            }
#line 170
            tmp___5 = tmp___4;
          }
#line 170
          if (! tmp___5) {
#line 170
            goto while_break___3;
          }
        } else {
#line 170
          goto while_break___3;
        }
#line 171
        if ((int )*p == 92) {
          {
#line 172
          shift_left(p);
          }
        }
#line 173
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 178
      if (quote) {
        {
#line 179
        shift_left(p);
#line 180
        quote = 0;
        }
      }
#line 184
      if (*p) {
#line 185
        tmp___6 = p;
#line 185
        p ++;
#line 185
        *tmp___6 = (char )'\000';
      }
      {
#line 189
      if ((unsigned int )last_token == 2U) {
#line 189
        goto case_2;
      }
#line 196
      if ((unsigned int )last_token == 4U) {
#line 196
        goto case_4;
      }
#line 202
      if ((unsigned int )last_token == 5U) {
#line 202
        goto case_5;
      }
#line 210
      if ((unsigned int )last_token == 3U) {
#line 210
        goto case_3;
      }
#line 216
      if ((unsigned int )last_token == 1U) {
#line 216
        goto case_1;
      }
#line 222
      if ((unsigned int )last_token == 0U) {
#line 222
        goto case_0;
      }
#line 187
      goto switch_break;
      case_2: /* CIL Label */ 
#line 190
      if (current) {
        {
#line 191
        current->acc = strdup((char const   *)tok);
        }
      } else {
#line 193
        premature_token = (char *)"login";
      }
#line 194
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 198
      maybe_add_to_list(& current, & retval);
#line 199
      current->host = strdup((char const   *)tok);
      }
#line 200
      goto switch_break;
      case_5: /* CIL Label */ 
#line 203
      if (current) {
        {
#line 204
        current->passwd = strdup((char const   *)tok);
        }
      } else {
#line 206
        premature_token = (char *)"password";
      }
#line 207
      goto switch_break;
      case_3: /* CIL Label */ 
#line 211
      if (! current) {
#line 212
        premature_token = (char *)"macdef";
      }
#line 213
      goto switch_break;
      case_1: /* CIL Label */ 
#line 217
      if (! current) {
#line 218
        premature_token = (char *)"account";
      }
#line 219
      goto switch_break;
      case_0: /* CIL Label */ 
#line 223
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 226
      if (premature_token) {
        {
#line 228
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: warning: \"%s\" token appears before any machine name\n",
                path, ln, premature_token);
#line 231
        premature_token = (char *)((void *)0);
        }
      }
#line 234
      if ((unsigned int )last_token != 0U) {
#line 236
        last_token = (enum __anonenum_last_token_56 )0;
      } else {
        {
#line 240
        tmp___12 = strcmp((char const   *)tok, "account");
        }
#line 240
        if (tmp___12) {
          {
#line 242
          tmp___11 = strcmp((char const   *)tok, "default");
          }
#line 242
          if (tmp___11) {
            {
#line 246
            tmp___10 = strcmp((char const   *)tok, "login");
            }
#line 246
            if (tmp___10) {
              {
#line 249
              tmp___9 = strcmp((char const   *)tok, "macdef");
              }
#line 249
              if (tmp___9) {
                {
#line 252
                tmp___8 = strcmp((char const   *)tok, "machine");
                }
#line 252
                if (tmp___8) {
                  {
#line 255
                  tmp___7 = strcmp((char const   *)tok, "password");
                  }
#line 255
                  if (tmp___7) {
                    {
#line 259
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: unknown token \"%s\"\n",
                            path, ln, tok);
                    }
                  } else {
#line 256
                    last_token = (enum __anonenum_last_token_56 )5;
                  }
                } else {
#line 253
                  last_token = (enum __anonenum_last_token_56 )4;
                }
              } else {
#line 250
                last_token = (enum __anonenum_last_token_56 )3;
              }
            } else {
#line 247
              last_token = (enum __anonenum_last_token_56 )2;
            }
          } else {
            {
#line 244
            maybe_add_to_list(& current, & retval);
            }
          }
        } else {
#line 241
          last_token = (enum __anonenum_last_token_56 )1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 264
    free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  fclose(fp);
#line 270
  maybe_add_to_list(& current, & retval);
#line 271
  free((void *)current);
#line 274
  current = retval;
#line 275
  retval = (acc_t *)((void *)0);
  }
  {
#line 276
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 276
    if (! current) {
#line 276
      goto while_break___4;
    }
#line 281
    saved_reference = current->next;
#line 282
    current->next = retval;
#line 285
    retval = current;
#line 286
    current = saved_reference;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 289
  return (retval);
}
}
#line 294 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/netrc.c"
void free_netrc(acc_t *l ) 
{ 
  acc_t *t ;

  {
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! l) {
#line 299
      goto while_break;
    }
    {
#line 301
    t = l->next;
#line 302
    free((void *)l->acc);
#line 303
    free((void *)l->passwd);
#line 304
    free((void *)l->host);
#line 305
    free((void *)l);
#line 306
    l = t;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return;
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.h"
int get_term_width(void) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 81 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
struct wput_timer *wtimer_alloc(void) 
{ 
  void *tmp ;

  {
  {
#line 82
  tmp = malloc(sizeof(struct wput_timer ));
  }
#line 82
  return ((struct wput_timer *)tmp);
}
}
#line 85 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
void wtimer_sys_set(wput_sys_time *wst ) 
{ 


  {
  {
#line 87
  gettimeofday((struct timeval */* __restrict  */)wst, (__timezone_ptr_t )((void *)0));
  }
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
void wtimer_reset(struct wput_timer *wt ) 
{ 


  {
  {
#line 117
  wtimer_sys_set(& wt->start);
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
double wtimer_sys_diff(wput_sys_time *wst1 , wput_sys_time *wst2 ) 
{ 


  {
#line 122
  return ((double )(wst1->tv_sec - wst2->tv_sec) * (double )1000 + (double )(wst1->tv_usec - wst2->tv_usec) / (double )1000);
}
}
#line 143 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
double wtimer_elapsed(struct wput_timer *wt ) 
{ 
  wput_sys_time now ;
  double tmp ;

  {
  {
#line 146
  wtimer_sys_set(& now);
#line 147
  tmp = wtimer_sys_diff(& now, & wt->start);
  }
#line 147
  return (tmp);
}
}
#line 154 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
double wtimer_granularity(void) 
{ 


  {
#line 162
  return (0.1);
}
}
#line 181 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
static char output[15]  ;
#line 179 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
char *time_str(void) 
{ 
  time_t secs ;
  time_t tmp ;
  struct tm *ptm ;
  struct tm *tmp___0 ;

  {
  {
#line 182
  tmp = time((time_t *)((void *)0));
#line 182
  secs = tmp;
#line 183
  tmp___0 = localtime((time_t const   *)(& secs));
#line 183
  ptm = tmp___0;
#line 184
  sprintf((char */* __restrict  */)(output), (char const   */* __restrict  */)"%02d:%02d:%02d",
          ptm->tm_hour, ptm->tm_min, ptm->tm_sec);
  }
#line 185
  return (output);
}
}
#line 199 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
struct _bar bar  = 
#line 199
     {(unsigned short)1024, (unsigned short)50, (unsigned char)10, (unsigned short)0,
    (char *)0, (char *)0, 0UL, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                0, 0, 0, 0, 0, 0, 0}};
#line 219 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
unsigned short terminal_width  =    (unsigned short)80;
#line 221 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
int get_term_width(void) 
{ 
  int termwidth ;
  struct winsize win ;
  char *p ;
  int tmp ;

  {
  {
#line 222
  termwidth = 80;
#line 226
  tmp = ioctl(1, 21523UL, & win);
  }
#line 226
  if (tmp == -1) {
#line 226
    goto _L;
  } else
#line 226
  if (! win.ws_col) {
    _L: /* CIL Label */ 
    {
#line 227
    p = getenv("COLUMNS");
    }
#line 227
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 228
      termwidth = atoi((char const   *)p);
      }
    }
  } else {
#line 230
    termwidth = (int )win.ws_col;
  }
#line 232
  return (termwidth);
}
}
#line 248 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
static char buf___0[12]  = {      (char )' ',      (char )'-',      (char )'-',      (char )'.', 
        (char )'-',      (char )'-',      (char )'\000'};
#line 242 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
char *calculate_transfer_rate(double time_diff , off_t tbytes , unsigned char sp ) 
{ 
  char *units[2][4] ;
  double trate ;
  unsigned char unit ;
  char const   *tmp ;

  {
#line 243
  units[0][0] = (char *)"B/s";
#line 243
  units[0][1] = (char *)"K/s";
#line 243
  units[0][2] = (char *)"M/s";
#line 243
  units[0][3] = (char *)"G/s";
#line 243
  units[1][0] = (char *)" B/s ";
#line 243
  units[1][1] = (char *)" KiB/s";
#line 243
  units[1][2] = (char *)" MiB/s";
#line 243
  units[1][3] = (char *)" GiB/s";
#line 247
  trate = (double )tbytes / (time_diff / (double )1000);
#line 251
  if (tbytes == 0L) {
#line 251
    return (buf___0);
  } else
#line 251
  if (time_diff == (double )0) {
#line 251
    return (buf___0);
  }
#line 253
  if (trate < (double )1024) {
#line 254
    unit = (unsigned char)0;
#line 254
    trate = trate;
  } else
#line 255
  if (trate < (double )1048576) {
#line 256
    unit = (unsigned char)1;
#line 256
    trate /= (double )1024;
  } else
#line 257
  if (trate < (double )1073741824) {
#line 258
    unit = (unsigned char)2;
#line 258
    trate /= (double )1048576;
  } else {
#line 261
    unit = (unsigned char)3;
#line 261
    trate /= (double )1073741824;
  }
#line 263
  if (trate < (double )100) {
#line 264
    if (trate < (double )10) {
#line 264
      tmp = " ";
    } else {
#line 264
      tmp = "";
    }
    {
#line 264
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s%.2f%s",
            tmp, trate, units[sp][unit]);
    }
  } else
#line 265
  if (trate < (double )1000) {
    {
#line 266
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s",
            trate, units[sp][unit]);
    }
  } else {
    {
#line 268
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" %d%s",
            (int )trate, units[sp][unit]);
    }
  }
#line 269
  return (buf___0);
}
}
#line 272 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
char *get_transfer_rate(_fsession *fsession , unsigned char sp ) 
{ 
  off_t tbytes ;
  int time_diff ;
  int i ;
  char *tmp ;

  {
#line 274
  tbytes = (off_t )0;
#line 275
  time_diff = 24;
#line 278
  i = 0;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < 24)) {
#line 278
      goto while_break;
    }
#line 279
    if (bar.last_transfered[i] == -1) {
#line 279
      time_diff --;
    } else {
#line 280
      tbytes += (off_t )bar.last_transfered[i];
    }
#line 278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  tmp = calculate_transfer_rate((double )(time_diff * 1000), tbytes, sp);
  }
#line 283
  return (tmp);
}
}
#line 287
char *calculate_eta(_fsession *fsession , off_t transfered ) ;
#line 287 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
static char buf___1[11]  = {      (char)0};
#line 286 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
char *calculate_eta(_fsession *fsession , off_t transfered ) 
{ 
  int time_diff ;
  int remain ;
  off_t tbytes ;
  int i ;

  {
#line 288
  time_diff = 24;
#line 290
  tbytes = (off_t )0;
#line 293
  i = 0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i < 24)) {
#line 293
      goto while_break;
    }
#line 294
    if (bar.last_transfered[i] == -1) {
#line 295
      time_diff --;
    } else {
#line 297
      tbytes += (off_t )bar.last_transfered[i];
    }
#line 293
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  if (tbytes == 0L) {
#line 299
    return (buf___1);
  } else
#line 299
  if (time_diff == 0) {
#line 299
    return (buf___1);
  }
#line 303
  remain = (int )((((double )(fsession->local_fsize - transfered) * ((double )time_diff * (double )1000)) / (double )tbytes) / (double )1000);
#line 305
  if (remain < 60) {
    {
#line 306
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"ETA    %02ds",
            remain);
    }
  } else
#line 307
  if (remain < 3600) {
    {
#line 308
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"ETA %2d:%02dm",
            remain / 60, remain % 60);
    }
  } else
#line 309
  if (remain < 86400) {
    {
#line 310
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"ETA %2d:%02dh",
            remain / 3600, (remain % 3600) / 60);
    }
  } else {
    {
#line 312
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"ETA %2d:%02dd",
            remain / 86400, (remain % 86400) / 3600);
    }
  }
#line 315
  return (buf___1);
}
}
#line 318 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
void bar_create(_fsession *fsession ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int skipped_k ;
  int skipped_k_len ;
  int tmp___4 ;
  int start_paint ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 321
  if ((int )opt.verbose < 2) {
#line 321
    return;
  }
#line 324
  if (opt.barstyle) {
    {
#line 325
    tmp = get_term_width();
#line 325
    terminal_width = (unsigned short )tmp;
    }
#line 328
    if ((int )terminal_width < 45) {
#line 329
      opt.barstyle = (unsigned char)0;
    }
  }
#line 333
  i = 0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (i < 24)) {
#line 333
      goto while_break;
    }
#line 334
    bar.last_transfered[i] = -1;
#line 333
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  if (fsession->local_fname) {
    {
#line 337
    tmp___0 = legible(fsession->local_fsize);
#line 337
    tmp___1 = gettext("Length: %s");
#line 337
    printout((unsigned char)2, (char const   *)tmp___1, tmp___0);
    }
  }
#line 339
  bar.dots = (unsigned short)0;
#line 340
  if (fsession->target_fsize > 0L) {
    {
#line 341
    tmp___2 = legible(fsession->local_fsize - fsession->target_fsize);
#line 341
    tmp___3 = gettext(" [%s to go]\n");
#line 341
    printout((unsigned char)2, (char const   *)tmp___3, tmp___2);
    }
#line 342
    if (! opt.barstyle) {
      {
#line 343
      skipped_k = (int )(fsession->target_fsize / 1024L);
#line 344
      tmp___4 = numdigit((long )skipped_k);
#line 344
      skipped_k_len = tmp___4;
#line 345
      start_paint = (int )(fsession->target_fsize % (long )((int )bar.dots_per_line * (int )bar.bytes_per_dot));
      }
#line 346
      if (skipped_k_len < 5) {
#line 347
        skipped_k_len = 5;
      }
      {
#line 348
      tmp___5 = numdigit((long )skipped_k);
#line 348
      tmp___6 = gettext("%* [ skipped %dK ]\n%* %dK ");
#line 348
      printout((unsigned char)2, (char const   *)tmp___6, skipped_k_len + 2, skipped_k,
               skipped_k_len - tmp___5, skipped_k - start_paint / 1024);
      }
      {
#line 351
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 351
        if (! (start_paint > 0)) {
#line 351
          goto while_break___0;
        }
        {
#line 352
        _IO_putc(',', opt.output);
#line 353
        bar.dots = (unsigned short )((int )bar.dots + 1);
        }
#line 353
        if ((int )bar.dots % (int )bar.spacing == 0) {
          {
#line 354
          _IO_putc(' ', opt.output);
          }
        }
#line 351
        start_paint -= (int )bar.bytes_per_dot;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 358
    printout((unsigned char)2, "\n");
    }
#line 359
    if (! opt.barstyle) {
      {
#line 360
      printout((unsigned char)2, "    0K ");
      }
    }
  }
  {
#line 362
  fflush(opt.output);
  }
#line 363
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
static int updatecounter  =    1;
#line 370 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/progress.c"
void bar_update(_fsession *fsession , off_t transfered , int transfered_last , struct wput_timer *last ) 
{ 
  unsigned char percent ;
  unsigned int time_elapsed ;
  double tmp ;
  unsigned short bar_width ;
  short data[2] ;
  char *transf ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  unsigned int dots ;

  {
#line 371
  percent = (unsigned char )(((double )transfered / (double )fsession->local_fsize) * (double )100);
#line 374
  if ((int )opt.verbose < 2) {
#line 374
    return;
  }
  {
#line 376
  tmp = wtimer_elapsed(last);
#line 376
  time_elapsed = (unsigned int )tmp;
#line 379
  bar.transfered += (unsigned long )transfered_last;
  }
#line 380
  if (updatecounter >= 10) {
    {
#line 382
    while (1) {
      while_continue: /* CIL Label */ ;
#line 382
      if (! (updatecounter >= 10)) {
#line 382
        goto while_break;
      }
      {
#line 385
      memcpy((void */* __restrict  */)(bar.last_transfered), (void const   */* __restrict  */)(bar.last_transfered + 1),
             sizeof(int ) * 23UL);
#line 386
      bar.last_transfered[23] = (int )bar.transfered;
#line 387
      bar.transfered = 0UL;
#line 388
      updatecounter -= 10;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 391
    bar.last_rate = get_transfer_rate(fsession, (unsigned char )(! opt.barstyle));
#line 392
    bar.last_eta = calculate_eta(fsession, transfered);
    }
  }
#line 395
  if (time_elapsed > 100U) {
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 396
      if (! (time_elapsed > 100U)) {
#line 396
        goto while_break___0;
      }
#line 397
      updatecounter ++;
#line 398
      time_elapsed -= 100U;
#line 403
      last->start.tv_usec += 100000L;
#line 404
      if (last->start.tv_usec > 1000000L) {
#line 405
        last->start.tv_usec -= 1000000L;
#line 406
        (last->start.tv_sec) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    if (opt.barstyle) {
      {
#line 411
      bar_width = (unsigned short )((((((int )terminal_width - 4) - 2) - 14) - 9) - 15);
#line 412
      data[0] = (short )(((double )fsession->target_fsize / (double )fsession->local_fsize) * (double )bar_width);
#line 412
      data[1] = (short )(((double )(transfered - fsession->target_fsize) / (double )fsession->local_fsize) * (double )bar_width);
#line 416
      tmp___0 = legible(transfered);
#line 416
      transf = tmp___0;
      }
#line 421
      if ((int )percent < 100) {
        {
#line 422
        tmp___1 = strlen((char const   *)transf);
        }
#line 422
        if ((int )percent < 10) {
#line 422
          tmp___2 = " ";
        } else {
#line 422
          tmp___2 = "";
        }
        {
#line 422
        printout((unsigned char)2, "\r%s%d%% [%*+%*=>%* ] %s%* %s %s", tmp___2, (int )percent,
                 (int )data[0], (int )data[1], (((int )bar_width - (int )data[1]) - (int )data[0]) - 1,
                 transf, 17UL - tmp___1, bar.last_rate, bar.last_eta);
        }
      } else {
        {
#line 431
        tmp___3 = strlen((char const   *)transf);
#line 431
        printout((unsigned char)2, "\r%* \r100%%[%*+%*=] %s%* %s", (int )terminal_width,
                 (int )data[0], (int )data[1], transf, 17UL - tmp___3, bar.last_rate);
        }
      }
    } else {
#line 436
      dots = (unsigned int )(transfered_last / (int )bar.bytes_per_dot);
      {
#line 438
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 438
        if (! (dots > 0U)) {
#line 438
          goto while_break___1;
        }
        {
#line 439
        bar.dots = (unsigned short )((int )bar.dots + 1);
#line 440
        _IO_putc('.', opt.output);
        }
#line 441
        if ((int )bar.dots % (int )bar.spacing == 0) {
          {
#line 442
          _IO_putc(' ', opt.output);
          }
        }
#line 443
        if ((int )bar.dots == (int )bar.dots_per_line) {
          {
#line 444
          fprintf((FILE */* __restrict  */)opt.output, (char const   */* __restrict  */)"%3ld%% %s\n%5ldK ",
                  (long )percent, bar.last_rate, transfered / 1024L);
#line 448
          bar.dots = (unsigned short)0;
          }
        }
#line 438
        dots --;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 452
    fflush(opt.output);
    }
  }
#line 454
  return;
}
}
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.h"
wput_socket *socket_new(void) ;
#line 61
int socket_set_blocking(int sock , unsigned char block ) ;
#line 63
int socket_is_data_readable(int s , int timeout ) ;
#line 64
wput_socket *socket_timeout_connect(wput_socket *sock , struct sockaddr *remote_addr ,
                                    size_t size , int timeout ) ;
#line 65
wput_socket *proxy_init(proxy_settings *ps ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
char *base64(char *p , size_t len ) ;
#line 65 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
int default_timeout  =    300;
#line 67 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
wput_socket *socket_new(void) 
{ 
  wput_socket *sock ;
  void *tmp ;

  {
  {
#line 68
  tmp = malloc(sizeof(wput_socket ));
#line 68
  sock = (wput_socket *)tmp;
#line 69
  memset((void *)sock, 0, sizeof(wput_socket ));
  }
#line 70
  return (sock);
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
void socket_set_default_timeout(int timeout ) 
{ 


  {
#line 74
  default_timeout = timeout;
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
wput_socket *socket_connect(unsigned int const   ip , unsigned short const   port ) 
{ 
  struct sockaddr_in remote_addr ;
  wput_socket *sock ;
  wput_socket *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  wput_socket *tmp___2 ;

  {
  {
#line 79
  tmp = socket_new();
#line 79
  sock = tmp;
#line 81
  memset((void *)((char *)(& remote_addr)), 0, sizeof(remote_addr));
#line 82
  remote_addr.sin_family = (sa_family_t )2;
#line 83
  remote_addr.sin_addr.s_addr = (in_addr_t )ip;
#line 84
  remote_addr.sin_port = htons((unsigned short )port);
#line 90
  tmp___1 = socket(2, 1, 0);
#line 90
  sock->fd = tmp___1;
  }
#line 90
  if (tmp___1 < 0) {
    {
#line 94
    tmp___0 = gettext("client: can\'t open stream socket");
#line 94
    perror((char const   *)tmp___0);
    }
  }
  {
#line 96
  printout((unsigned char)4, "c_sock: %x\n", sock->fd);
#line 99
  tmp___2 = socket_timeout_connect(sock, (struct sockaddr *)(& remote_addr), sizeof(remote_addr),
                                   default_timeout);
  }
#line 99
  if (! tmp___2) {
    {
#line 100
    socket_close(sock);
    }
#line 101
    return ((wput_socket *)((void *)0));
  }
#line 103
  return (sock);
}
}
#line 106 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
wput_socket *socket_listen(unsigned int bindaddr , unsigned short *s_port ) 
{ 
  struct sockaddr_in serv_addr ;
  wput_socket *sock ;
  wput_socket *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  socklen_t addrlen ;
  int tmp___5 ;

  {
  {
#line 108
  tmp = socket_new();
#line 108
  sock = tmp;
#line 113
  tmp___1 = socket(2, 1, 0);
#line 113
  sock->fd = tmp___1;
  }
#line 113
  if (tmp___1 < 0) {
    {
#line 114
    tmp___0 = gettext("server: can\'t open new socket");
#line 114
    perror((char const   *)tmp___0);
    }
  }
  {
#line 118
  memset((void *)(& serv_addr), 0, sizeof(serv_addr));
#line 119
  serv_addr.sin_family = (sa_family_t )2;
#line 120
  serv_addr.sin_port = htons(*s_port);
#line 121
  serv_addr.sin_addr.s_addr = htonl(bindaddr);
#line 123
  tmp___4 = bind(sock->fd, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                 (socklen_t )sizeof(serv_addr));
  }
#line 123
  if (tmp___4 < 0) {
    {
#line 124
    tmp___2 = gettext("Error: ");
#line 124
    printout((unsigned char)1, (char const   *)tmp___2);
#line 125
    tmp___3 = gettext("server: can\'t bind local address\n");
#line 125
    printout((unsigned char)1, (char const   *)tmp___3);
#line 126
    exit(0);
    }
  }
#line 128
  if (! *s_port) {
    {
#line 133
    addrlen = (socklen_t )sizeof(struct sockaddr_in );
#line 134
    tmp___5 = getsockname(sock->fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& serv_addr)),
                          (socklen_t */* __restrict  */)(& addrlen));
    }
#line 134
    if (tmp___5 < 0) {
#line 136
      if (sock->fd != -1) {
        {
#line 137
        close(sock->fd);
#line 138
        sock->fd = -1;
        }
      }
      {
#line 140
      printout((unsigned char)4, "Failed to open server socket.\n");
      }
#line 141
      return ((wput_socket *)((void *)0));
    }
    {
#line 143
    *s_port = ntohs(serv_addr.sin_port);
    }
  }
  {
#line 148
  listen(sock->fd, 1);
#line 149
  printout((unsigned char)4, "Server socket ready to accept client connection.\n");
  }
#line 151
  return (sock);
}
}
#line 155 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
wput_socket *socket_accept(wput_socket *sock ) 
{ 
  socklen_t clilen ;
  struct sockaddr_in client_addr ;
  wput_socket *child ;
  wput_socket *tmp ;
  char *tmp___0 ;

  {
  {
#line 158
  tmp = socket_new();
#line 158
  child = tmp;
#line 160
  clilen = (socklen_t )sizeof(client_addr);
#line 161
  child->fd = accept(sock->fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& client_addr)),
                     (socklen_t */* __restrict  */)(& clilen));
  }
#line 162
  if (child->fd == -1) {
    {
#line 163
    tmp___0 = gettext("error accepting the incoming connection");
#line 163
    perror((char const   *)tmp___0);
#line 164
    exit(4);
    }
  }
  {
#line 166
  printout((unsigned char)4, "Server socket accepted new connection from requesting client.\n");
  }
#line 167
  return (child);
}
}
#line 192 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
void socket_close(wput_socket *sock ) 
{ 


  {
  {
#line 193
  printout((unsigned char)4, "Closing socket %x\n", sock);
#line 194
  shutdown(sock->fd, 2);
#line 203
  close(sock->fd);
#line 204
  free((void *)sock);
  }
#line 205
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
char *socket_read_line(wput_socket *sock ) 
{ 
  int length ;
  int bufsize ;
  char *buf___2 ;
  void *tmp ;
  int res ;
  void *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 214
  length = 0;
#line 215
  bufsize = 82;
#line 216
  tmp = malloc((size_t )(bufsize + 1));
#line 216
  buf___2 = (char *)tmp;
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 219
    res = socket_read(sock, (void *)(buf___2 + length), (size_t )1);
    }
#line 219
    if (! (res > 0)) {
#line 219
      goto while_break;
    }
#line 222
    if ((int )*(buf___2 + length) == 10) {
#line 224
      if ((int )*(buf___2 + (length - 1)) == 13) {
#line 225
        *(buf___2 + (length - 1)) = (char)0;
#line 226
        return (buf___2);
      }
    }
#line 229
    if (length == bufsize) {
      {
#line 230
      bufsize <<= 1;
#line 231
      tmp___0 = realloc((void *)buf___2, (size_t )(bufsize + 1));
#line 231
      buf___2 = (char *)tmp___0;
      }
    }
#line 233
    length ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  *(buf___2 + length) = (char)0;
#line 239
  if (res == -9) {
    {
#line 240
    tmp___1 = gettext("Receive-Warning: read() timed out. Read \'%s\' so far.\n");
#line 240
    printout((unsigned char)2, (char const   *)tmp___1, buf___2);
#line 241
    free((void *)buf___2);
    }
#line 242
    return ((char *)-9);
  }
  {
#line 245
  tmp___2 = __errno_location();
#line 245
  tmp___3 = __errno_location();
#line 245
  tmp___4 = strerror(*tmp___3);
#line 245
  tmp___5 = gettext("Receive-Error: read() failed. Read \'%s\' so far. (errno: %s (%d))\n");
#line 245
  printout((unsigned char)1, (char const   *)tmp___5, buf___2, tmp___4, *tmp___2);
#line 246
  free((void *)buf___2);
  }
#line 247
  return ((char *)((void *)0));
}
}
#line 251 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
int socket_read(wput_socket *sock , void *buf___2 , size_t len ) 
{ 
  int res ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 258
  tmp___1 = socket_is_data_readable(sock->fd, default_timeout);
  }
#line 258
  if (! tmp___1) {
    {
#line 264
    tmp = gettext("Error: ");
#line 264
    printout((unsigned char)2, (char const   *)tmp);
#line 265
    tmp___0 = gettext("recv() timed out. No data received\n");
#line 265
    printout((unsigned char)2, (char const   *)tmp___0);
    }
#line 266
    return (-9);
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 273
    tmp___2 = recv(sock->fd, buf___2, len, 0);
#line 273
    res = (int )tmp___2;
    }
#line 268
    if (res == -1) {
      {
#line 268
      tmp___3 = __errno_location();
      }
#line 268
      if (! (*tmp___3 == 4)) {
#line 268
        goto while_break;
      }
    } else {
#line 268
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  if (res == 0) {
#line 277
    return (-1);
  }
#line 278
  return (res);
}
}
#line 282 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
int socket_write(wput_socket *sock , void *buf___2 , size_t len ) 
{ 
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 283
  tmp___0 = socket_is_data_writeable(sock->fd, default_timeout);
  }
#line 283
  if (tmp___0) {
    {
#line 288
    tmp = send(sock->fd, (void const   *)buf___2, len, 0);
    }
#line 288
    return ((int )tmp);
  } else {
#line 290
    return (-1);
  }
}
}
#line 296 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
int get_ip_addr(char *hostname , unsigned int *ip ) 
{ 
  struct hostent *ht ;
  char *tmp ;

  {
  {
#line 306
  ht = gethostbyname((char const   *)hostname);
  }
#line 308
  if ((unsigned long )ht != (unsigned long )((struct hostent *)0)) {
    {
#line 309
    tmp = printip((unsigned char *)*(ht->h_addr_list + 0));
#line 309
    printout((unsigned char)4, "IP of `%s\' is `%s\'\n", hostname, tmp);
#line 310
    memcpy((void */* __restrict  */)ip, (void const   */* __restrict  */)*(ht->h_addr_list + 0),
           (size_t )4);
    }
#line 311
    return (0);
  }
#line 313
  return (-1);
}
}
#line 338 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
int get_local_ip(int sockfd , char *local_ip ) 
{ 
  struct sockaddr_in mysrv ;
  struct sockaddr *myaddr ;
  socklen_t addrlen ;
  int tmp ;

  {
  {
#line 341
  addrlen = (socklen_t )sizeof(mysrv);
#line 342
  myaddr = (struct sockaddr *)(& mysrv);
#line 343
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)myaddr, (socklen_t */* __restrict  */)(& addrlen));
  }
#line 343
  if (tmp < 0) {
#line 344
    return (-1);
  }
  {
#line 345
  memcpy((void */* __restrict  */)local_ip, (void const   */* __restrict  */)(& mysrv.sin_addr),
         (size_t )4);
  }
#line 346
  return (0);
}
}
#line 349 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
int socket_set_blocking(int sock , unsigned char block ) 
{ 
  int flags ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 354
  tmp = fcntl(sock, 3, 0);
#line 354
  flags = tmp;
  }
#line 355
  if (block) {
#line 356
    flags = (int )((unsigned int )flags & 4294965247U);
  } else {
#line 358
    flags |= 2048;
  }
  {
#line 359
  tmp___0 = fcntl(sock, 4, flags);
  }
#line 359
  if (tmp___0 < 0) {
#line 360
    return (-1);
  }
#line 361
  return (0);
}
}
#line 366 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
int socket_is_data_writeable(int s , int timeout ) 
{ 
  struct timeval t ;
  int res ;
  int errno_saved ;
  fd_set inSet ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 368
  res = 0;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& inSet.__fds_bits[0]): "memory");
#line 371
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  t.tv_sec = (__time_t )(timeout / 10);
#line 373
  t.tv_usec = (__suseconds_t )((timeout % 10) * 100);
#line 374
  inSet.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= 1L << s % (8 * (int )sizeof(__fd_mask ));
#line 375
  printout((unsigned char)4, "Checking whether %d is writable... ", s);
#line 376
  tmp = __errno_location();
#line 376
  *tmp = 0;
#line 377
  res = select(s + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& inSet),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& t));
#line 378
  tmp___0 = __errno_location();
#line 378
  errno_saved = *tmp___0;
#line 379
  tmp___1 = __errno_location();
#line 379
  tmp___2 = strerror(*tmp___1);
#line 379
  tmp___3 = __errno_location();
#line 379
  printout((unsigned char)4, "%d (%d:%s)\n", res, *tmp___3, tmp___2);
  }
#line 380
  if (errno_saved > 0) {
#line 380
    if (errno_saved != 115) {
#line 381
      return (0);
    }
  }
#line 382
  return (res);
}
}
#line 384 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
int socket_is_data_readable(int s , int timeout ) 
{ 
  struct timeval t ;
  fd_set inSet ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& inSet.__fds_bits[0]): "memory");
#line 387
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 388
  t.tv_sec = (__time_t )(timeout / 10);
#line 389
  t.tv_usec = (__suseconds_t )((timeout % 10) * 100);
#line 390
  inSet.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= 1L << s % (8 * (int )sizeof(__fd_mask ));
#line 391
  tmp = select(s + 1, (fd_set */* __restrict  */)(& inSet), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& t));
  }
#line 391
  return (tmp);
}
}
#line 395 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
wput_socket *socket_timeout_connect(wput_socket *sock , struct sockaddr *remote_addr ,
                                    size_t size , int timeout ) 
{ 
  int c ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  wput_socket *tmp___3 ;

  {
  {
#line 396
  c = 0;
#line 397
  printout((unsigned char)4, "initiating timeout connect (%d)\n", timeout);
#line 398
  socket_set_blocking(sock->fd, (unsigned char)0);
#line 399
  c = connect(sock->fd, (struct sockaddr  const  *)remote_addr, (socklen_t )size);
  }
#line 400
  if (c < 0) {
    {
#line 400
    tmp___1 = __errno_location();
    }
#line 400
    if (*tmp___1 > 0) {
      {
#line 400
      tmp___2 = __errno_location();
      }
#line 400
      if (*tmp___2 != 115) {
        {
#line 401
        tmp = __errno_location();
#line 401
        tmp___0 = strerror(*tmp);
#line 401
        printout((unsigned char)3, "[%s]", tmp___0);
        }
#line 402
        return ((wput_socket *)((void *)0));
      }
    }
  }
  {
#line 405
  socket_set_blocking(sock->fd, (unsigned char)1);
#line 406
  c = socket_is_data_writeable(sock->fd, timeout);
  }
#line 407
  if (c < 1) {
#line 407
    tmp___3 = (wput_socket *)((void *)0);
  } else {
#line 407
    tmp___3 = sock;
  }
#line 407
  return (tmp___3);
}
}
#line 419 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
wput_socket *proxy_init(proxy_settings *ps ) 
{ 
  char t[4] ;
  unsigned int tmp ;
  wput_socket *sock ;
  wput_socket *tmp___0 ;
  int res ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *p ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 421
  t[0] = (char)5;
#line 421
  t[1] = (char)1;
#line 421
  t[2] = (char)0;
#line 421
  tmp = 3U;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (tmp >= 4U) {
#line 421
      goto while_break;
    }
#line 421
    t[tmp] = (char)0;
#line 421
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 422
  tmp___0 = socket_connect((unsigned int const   )ps->ip, (unsigned short const   )ps->port);
#line 422
  sock = tmp___0;
  }
#line 424
  if (! sock) {
    {
#line 425
    tmp___1 = gettext("failed.\n");
#line 425
    printout((unsigned char)2, (char const   *)tmp___1);
#line 426
    tmp___2 = gettext("Error: ");
#line 426
    printout((unsigned char)1, (char const   *)tmp___2);
#line 427
    tmp___3 = gettext("Connection to proxy cannot be established.\n");
#line 427
    printout((unsigned char)1, (char const   *)tmp___3);
    }
#line 428
    return ((wput_socket *)((void *)0));
  }
  {
#line 430
  printout((unsigned char)4, "proxy-sock: %d\n", sock->fd);
  }
#line 432
  if (ps->user) {
#line 432
    if (ps->pass) {
#line 433
      t[1] = (char)2;
#line 434
      t[2] = (char)2;
#line 435
      t[3] = (char)0;
    }
  }
  {
#line 438
  tmp___4 = strlen((char const   *)(t));
#line 438
  send(sock->fd, (void const   *)(t), tmp___4 + 1UL, 0);
#line 439
  res = socket_read(sock, (void *)(t), (size_t )2);
  }
#line 440
  if (res < 0) {
    {
#line 441
    tmp___5 = __errno_location();
#line 441
    tmp___6 = strerror(*tmp___5);
#line 441
    tmp___7 = __errno_location();
#line 441
    tmp___8 = gettext("read() failed: %d (%d: %s)\n");
#line 441
    printout((unsigned char)3, (char const   *)tmp___8, res, *tmp___7, tmp___6);
    }
#line 442
    return ((wput_socket *)((void *)0));
  }
#line 445
  if ((int )t[0] != 5) {
    {
#line 446
    tmp___9 = gettext("failed.\n");
#line 446
    printout((unsigned char)2, (char const   *)tmp___9);
#line 447
    tmp___10 = gettext("Error: ");
#line 447
    printout((unsigned char)1, (char const   *)tmp___10);
#line 448
    tmp___11 = gettext("Proxy version mismatch (%d)\n");
#line 448
    printout((unsigned char)1, (char const   *)tmp___11, (int )t[0]);
    }
#line 449
    return ((wput_socket *)((void *)0));
  }
#line 451
  if ((int )t[1] == 2) {
#line 451
    if (ps->user) {
#line 451
      if (ps->pass) {
        {
#line 453
        tmp___12 = strlen((char const   *)ps->user);
#line 453
        tmp___13 = strlen((char const   *)ps->pass);
#line 453
        tmp___14 = malloc((tmp___12 + tmp___13) + 3UL);
#line 453
        p = (char *)tmp___14;
#line 454
        *(p + 0) = (char)5;
#line 455
        tmp___15 = strlen((char const   *)ps->user);
#line 455
        *(p + 1) = (char )tmp___15;
#line 456
        strcpy((char */* __restrict  */)(p + 2), (char const   */* __restrict  */)ps->user);
#line 457
        tmp___16 = strlen((char const   *)ps->pass);
#line 457
        *(p + (2 + (int )*(p + 1))) = (char )tmp___16;
#line 458
        strncpy((char */* __restrict  */)((p + 3) + (int )*(p + 1)), (char const   */* __restrict  */)ps->pass,
                (size_t )*(p + (2 + (int )*(p + 1))));
#line 459
        send(sock->fd, (void const   *)p, (size_t )((3 + (int )*(p + 1)) + (int )*(p + (2 + (int )*(p + 1)))),
             0);
#line 460
        socket_read(sock, (void *)p, (size_t )2);
        }
#line 461
        if ((int )*(p + 1) != 0) {
          {
#line 466
          tmp___17 = gettext("Proxy authentication failure\n");
#line 466
          Abort(tmp___17);
          }
        }
        {
#line 468
        free((void *)p);
        }
      } else {
#line 451
        goto _L___0;
      }
    } else {
#line 451
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 470
  if ((int )t[1] != 0) {
    {
#line 471
    tmp___18 = gettext("failed.\n");
#line 471
    printout((unsigned char)2, (char const   *)tmp___18);
#line 472
    tmp___19 = gettext("Error: ");
#line 472
    printout((unsigned char)1, (char const   *)tmp___19);
#line 473
    tmp___20 = gettext("Proxy method mismatch (%d)\n");
#line 473
    printout((unsigned char)1, (char const   *)tmp___20, (int )t[1]);
    }
#line 474
    return ((wput_socket *)((void *)0));
  }
#line 477
  return (sock);
}
}
#line 480 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
wput_socket *proxy_listen(proxy_settings *ps , unsigned int *ip , unsigned short *port ) 
{ 
  char t[10] ;
  wput_socket *sock ;
  wput_socket *tmp ;
  int res ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 482
  t[0] = (char)5;
#line 482
  t[1] = (char)2;
#line 482
  t[2] = (char)0;
#line 482
  t[3] = (char)1;
#line 482
  t[4] = (char)0;
#line 482
  t[5] = (char)0;
#line 482
  t[6] = (char)0;
#line 482
  t[7] = (char)0;
#line 482
  t[8] = (char)0;
#line 482
  t[9] = (char)0;
#line 483
  tmp = proxy_init(ps);
#line 483
  sock = tmp;
  }
#line 485
  if (! sock) {
#line 485
    return ((wput_socket *)((void *)0));
  }
  {
#line 486
  send(sock->fd, (void const   *)(t), (size_t )10, 0);
#line 487
  res = socket_read(sock, (void *)(t), (size_t )10);
  }
#line 488
  if (res < 0) {
#line 488
    return ((wput_socket *)((void *)0));
  }
#line 490
  if ((int )t[1] != 0) {
    {
#line 491
    tmp___0 = gettext("Error: ");
#line 491
    printout((unsigned char)1, (char const   *)tmp___0);
#line 492
    tmp___1 = gettext("Proxy discarded listen-request. Error-Code: %d\n");
#line 492
    printout((unsigned char)1, (char const   *)tmp___1, (int )t[1]);
#line 493
    tmp___2 = gettext("Disabling listen-tries for proxy\n");
#line 493
    printout((unsigned char)3, (char const   *)tmp___2);
#line 494
    ps->bind = 0U;
    }
#line 495
    return ((wput_socket *)((void *)0));
  }
  {
#line 497
  *ip = *((unsigned int *)(t + 4));
#line 498
  *port = *((unsigned short *)(t + 8));
#line 499
  tmp___3 = printip((unsigned char *)ip);
#line 499
  tmp___4 = gettext("Proxy is listening on %s:%d for incoming connections\n");
#line 499
  printout((unsigned char)3, (char const   *)tmp___4, tmp___3, (int )*port);
  }
#line 501
  return (sock);
}
}
#line 507 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
wput_socket *proxy_accept(wput_socket *server ) 
{ 
  char t[10] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 509
  socket_read(server, (void *)(t), (size_t )10);
  }
#line 510
  if ((int )t[1] != 0) {
    {
#line 511
    tmp = gettext("Error: ");
#line 511
    printout((unsigned char)1, (char const   *)tmp);
#line 512
    tmp___0 = gettext("Proxy encountered an error while accepting. Error-Code: %d\n");
#line 512
    printout((unsigned char)1, (char const   *)tmp___0, (int )t[1]);
    }
#line 513
    return ((wput_socket *)((void *)0));
  }
  {
#line 518
  tmp___1 = printip((unsigned char *)(t) + 4);
#line 518
  printout((unsigned char)4, "Proxy received an incoming connection on %s:%d.\n",
           tmp___1, (int )*((unsigned short *)(t + 8)));
  }
#line 519
  return (server);
}
}
#line 523 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
wput_socket *proxy_connect(proxy_settings *ps , unsigned int ip , unsigned short port ,
                           char const   *hostname ) 
{ 
  int res ;
  wput_socket *sock ;
  wput_socket *tmp ;
  char *t ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  uint16_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  uint16_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  wput_socket *sock___0 ;
  wput_socket *tmp___14 ;
  char *userencoded ;
  char *request ;
  int len ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  char *userunencoded ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  char *tmp___24 ;
  char str_port[6] ;
  size_t tmp___25 ;
  void *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;

  {
  {
#line 525
  printout((unsigned char)4, "Doing proxy connection\n");
  }
#line 526
  if (ps->type == 1U) {
    {
#line 527
    tmp = proxy_init(ps);
#line 527
    sock = tmp;
    }
#line 529
    if (! sock) {
#line 529
      return ((wput_socket *)((void *)0));
    }
    {
#line 530
    tmp___0 = printip((unsigned char *)(& ps->ip));
#line 530
    tmp___1 = gettext("Using SOCKS5-Proxy %s:%d... ");
#line 530
    printout((unsigned char)3, (char const   *)tmp___1, tmp___0, (int )ps->port);
    }
#line 533
    if (ip == 0U) {
      {
#line 534
      tmp___2 = strlen(hostname);
#line 534
      tmp___3 = malloc((6UL + tmp___2) + 1UL);
#line 534
      t = (char *)tmp___3;
#line 536
      printout((unsigned char)4, "hostname: %s\n", hostname);
#line 537
      memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)"\005\001\000\003",
             (size_t )4);
#line 538
      tmp___4 = strlen(hostname);
#line 538
      *(t + 4) = (char )tmp___4;
#line 539
      strcpy((char */* __restrict  */)(t + 5), (char const   */* __restrict  */)hostname);
#line 540
      tmp___5 = htons(port);
#line 540
      res = (int )tmp___5;
#line 541
      tmp___6 = strlen(hostname);
#line 541
      memcpy((void */* __restrict  */)((t + tmp___6) + 5), (void const   */* __restrict  */)((char *)(& res)),
             (size_t )2);
#line 542
      tmp___7 = strlen(hostname);
#line 542
      send(sock->fd, (void const   *)t, tmp___7 + 7UL, 0);
#line 543
      free((void *)t);
#line 544
      tmp___8 = malloc((size_t )10);
#line 544
      t = (char *)tmp___8;
      }
    } else {
      {
#line 546
      tmp___9 = malloc((size_t )10);
#line 546
      t = (char *)tmp___9;
#line 548
      memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)"\005\001\000\001",
             (size_t )4);
#line 550
      memcpy((void */* __restrict  */)(t + 4), (void const   */* __restrict  */)(& ip),
             (size_t )4);
#line 551
      tmp___10 = htons(port);
#line 551
      res = (int )tmp___10;
#line 552
      memcpy((void */* __restrict  */)(t + 8), (void const   */* __restrict  */)(& res),
             (size_t )2);
#line 553
      send(sock->fd, (void const   *)t, (size_t )10, 0);
      }
    }
    {
#line 555
    res = socket_read(sock, (void *)t, (size_t )10);
    }
#line 556
    if (res < 0) {
      {
#line 557
      free((void *)t);
      }
#line 558
      return ((wput_socket *)((void *)0));
    }
#line 561
    if ((int )*(t + 0) == 5) {
#line 561
      if ((int )*(t + 1) == 0) {
        {
#line 562
        tmp___11 = gettext("Proxy connection established.\n");
#line 562
        printout((unsigned char)3, (char const   *)tmp___11);
        }
      } else {
#line 561
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 564
      tmp___12 = gettext("Error: ");
#line 564
      printout((unsigned char)1, (char const   *)tmp___12);
#line 565
      tmp___13 = gettext("Connection through proxy failed. Error-code: %d\n");
#line 565
      printout((unsigned char)1, (char const   *)tmp___13, (int )*(t + 1));
#line 566
      free((void *)t);
      }
#line 567
      return ((wput_socket *)((void *)0));
    }
    {
#line 569
    free((void *)t);
    }
#line 570
    return (sock);
  } else {
    {
#line 576
    tmp___14 = socket_connect((unsigned int const   )ps->ip, (unsigned short const   )ps->port);
#line 576
    sock___0 = tmp___14;
#line 577
    userencoded = (char *)((void *)0);
    }
#line 579
    if (ps->user) {
#line 579
      if (ps->pass) {
        {
#line 580
        tmp___15 = strlen((char const   *)ps->user);
#line 580
        tmp___16 = strlen((char const   *)ps->pass);
#line 580
        len = (int )((tmp___15 + tmp___16) + 3UL);
#line 581
        tmp___17 = malloc((size_t )len);
#line 581
        userunencoded = (char *)tmp___17;
#line 582
        strcpy((char */* __restrict  */)userunencoded, (char const   */* __restrict  */)ps->user);
#line 583
        tmp___18 = strlen((char const   *)ps->user);
#line 583
        strcpy((char */* __restrict  */)((userunencoded + tmp___18) + 1), (char const   */* __restrict  */)ps->pass);
#line 584
        *(userunencoded + (len - 1)) = (char)0;
#line 585
        userencoded = base64(userunencoded, (size_t )(len - 1));
#line 586
        free((void *)userunencoded);
        }
      }
    }
#line 588
    if (hostname) {
      {
#line 588
      tmp___19 = strlen(hostname);
#line 588
      tmp___20 = tmp___19;
      }
    } else {
#line 588
      tmp___20 = (size_t )15;
    }
#line 588
    if (userencoded) {
      {
#line 588
      tmp___21 = strlen((char const   *)userencoded);
#line 588
      tmp___22 = tmp___21 + 29UL;
      }
    } else {
#line 588
      tmp___22 = (size_t )0;
    }
    {
#line 588
    tmp___23 = malloc(((((8UL + tmp___20) + tmp___22) + 10UL) + 5UL) + 5UL);
#line 588
    request = (char *)tmp___23;
#line 592
    strcpy((char */* __restrict  */)request, (char const   */* __restrict  */)"CONNECT ");
    }
#line 593
    if (ip == 0U) {
      {
#line 594
      strcat((char */* __restrict  */)request, (char const   */* __restrict  */)hostname);
      }
    } else {
      {
#line 596
      tmp___24 = printip((unsigned char *)(& ip));
#line 596
      strcat((char */* __restrict  */)request, (char const   */* __restrict  */)tmp___24);
      }
    }
    {
#line 597
    strcat((char */* __restrict  */)request, (char const   */* __restrict  */)":");
#line 600
    int64toa((off_t )port, str_port, 10);
#line 601
    strcat((char */* __restrict  */)request, (char const   */* __restrict  */)(str_port));
#line 603
    strcat((char */* __restrict  */)request, (char const   */* __restrict  */)" HTTP/1.0");
    }
#line 604
    if (userencoded) {
      {
#line 605
      strcat((char */* __restrict  */)request, (char const   */* __restrict  */)"\r\nProxy-Authorization: Basic ");
#line 606
      strcat((char */* __restrict  */)request, (char const   */* __restrict  */)userencoded);
#line 607
      free((void *)userencoded);
      }
    }
    {
#line 609
    strcat((char */* __restrict  */)request, (char const   */* __restrict  */)"\r\n\r\n");
#line 610
    printout((unsigned char)4, "proxy-connect: \'%s\' (IP %x)\n", request, ip);
#line 611
    tmp___25 = strlen((char const   *)request);
#line 611
    send(sock___0->fd, (void const   *)request, tmp___25, 0);
#line 612
    free((void *)request);
#line 615
    tmp___26 = malloc((size_t )512);
#line 615
    request = (char *)tmp___26;
#line 616
    *(request + 0) = (char)0;
#line 617
    res = socket_read(sock___0, (void *)request, (size_t )512);
    }
#line 618
    if (res < 0) {
#line 618
      goto _L___0;
    } else {
      {
#line 618
      tmp___29 = strncmp((char const   *)(request + 9), "200", (size_t )3);
      }
#line 618
      if (tmp___29) {
        _L___0: /* CIL Label */ 
        {
#line 619
        tmp___27 = gettext("Error: ");
#line 619
        printout((unsigned char)1, (char const   *)tmp___27);
#line 620
        tmp___28 = gettext("Connection could not be established.\nProxy states \'%s\'");
#line 620
        printout((unsigned char)1, (char const   *)tmp___28, request);
#line 621
        free((void *)request);
        }
#line 622
        return ((wput_socket *)((void *)0));
      }
    }
    {
#line 624
    free((void *)request);
    }
#line 625
    return (sock___0);
  }
}
}
#line 632 "/home/june/repo/benchmarks/collector2/temp/wput-0.6.2+git20130413/src/socketlib.c"
char *base64(char *p , size_t len ) 
{ 
  int i ;
  int len2 ;
  char *ret ;
  void *tmp ;
  int bytepointer ;
  uint16_t tmp___0 ;

  {
  {
#line 633
  i = 0;
#line 634
  len2 = (int )(3UL * ((len + 2UL) / 3UL));
#line 635
  tmp = malloc((size_t )((len2 * 4) / 3));
#line 635
  ret = (char *)tmp;
#line 636
  bytepointer = 0;
#line 637
  i = 0;
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! (i < (len2 * 4) / 3)) {
#line 637
      goto while_break;
    }
#line 638
    if ((size_t )(((i + 1) * 3) / 4) > len) {
#line 639
      *(ret + i) = (char )'=';
#line 640
      goto __Cont;
    }
    {
#line 642
    tmp___0 = htons((uint16_t )*((int *)(p + bytepointer / 8)));
#line 642
    *(ret + i) = (char )(((int )tmp___0 & (((1 << (10 - bytepointer % 8)) - 1) ^ ((1 << (16 - bytepointer % 8)) - 1))) >> (10 - bytepointer % 8));
#line 643
    bytepointer += 6;
    }
#line 644
    if ((int )*(ret + i) < 26) {
#line 645
      *(ret + i) = (char )((int )*(ret + i) + 65);
    } else
#line 646
    if ((int )*(ret + i) < 52) {
#line 647
      *(ret + i) = (char )((int )*(ret + i) + 71);
    } else
#line 648
    if ((int )*(ret + i) < 62) {
#line 649
      *(ret + i) = (char )((int )*(ret + i) + -4);
    } else
#line 650
    if ((int )*(ret + i) == 62) {
#line 651
      *(ret + i) = (char )'+';
    } else {
#line 653
      *(ret + i) = (char )'/';
    }
    __Cont: /* CIL Label */ 
#line 637
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  *(ret + i) = (char)0;
#line 656
  return (ret);
}
}
