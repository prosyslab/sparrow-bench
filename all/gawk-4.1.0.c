/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned long size_t;
#line 134 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 323 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef int wchar_t;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 194 "/usr/include/gmp-x86_64.h"
typedef unsigned long mp_limb_t;
#line 202 "/usr/include/gmp-x86_64.h"
struct __anonstruct___mpz_struct_55 {
   int _mp_alloc ;
   int _mp_size ;
   mp_limb_t *_mp_d ;
};
#line 202 "/usr/include/gmp-x86_64.h"
typedef struct __anonstruct___mpz_struct_55 __mpz_struct;
#line 216 "/usr/include/gmp-x86_64.h"
typedef __mpz_struct mpz_t[1];
#line 218 "/usr/include/gmp-x86_64.h"
typedef mp_limb_t *mp_ptr;
#line 219 "/usr/include/gmp-x86_64.h"
typedef mp_limb_t const   *mp_srcptr;
#line 227 "/usr/include/gmp-x86_64.h"
typedef long mp_size_t;
#line 228 "/usr/include/gmp-x86_64.h"
typedef long mp_exp_t;
#line 231 "/usr/include/gmp-x86_64.h"
struct __anonstruct___mpq_struct_56 {
   __mpz_struct _mp_num ;
   __mpz_struct _mp_den ;
};
#line 231 "/usr/include/gmp-x86_64.h"
typedef struct __anonstruct___mpq_struct_56 __mpq_struct;
#line 276 "/usr/include/gmp-x86_64.h"
typedef __mpz_struct const   *mpz_srcptr;
#line 277 "/usr/include/gmp-x86_64.h"
typedef __mpz_struct *mpz_ptr;
#line 280 "/usr/include/gmp-x86_64.h"
typedef __mpq_struct const   *mpq_srcptr;
#line 281 "/usr/include/gmp-x86_64.h"
typedef __mpq_struct *mpq_ptr;
#line 96 "/usr/include/mpfr.h"
typedef unsigned long mpfr_prec_t;
#line 106 "/usr/include/mpfr.h"
typedef int mpfr_sign_t;
#line 113 "/usr/include/mpfr.h"
struct __anonstruct___mpfr_struct_63 {
   mpfr_prec_t _mpfr_prec ;
   mpfr_sign_t _mpfr_sign ;
   mp_exp_t _mpfr_exp ;
   mp_limb_t *_mpfr_d ;
};
#line 113 "/usr/include/mpfr.h"
typedef struct __anonstruct___mpfr_struct_63 __mpfr_struct;
#line 139 "/usr/include/mpfr.h"
typedef __mpfr_struct mpfr_t[1];
#line 53 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 437 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex.h"
typedef int regoff_t;
#line 443 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex.h"
struct re_registers {
   unsigned int num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 34 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.h"
struct dfa;
#line 227 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct Regexp {
   struct re_pattern_buffer pat ;
   struct re_registers regs ;
   struct dfa *dfareg ;
   short dfa ;
   short has_anchor ;
   short non_empty ;
   short has_meta ;
   short maybe_long ;
};
#line 227 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef struct Regexp Regexp;
#line 280 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_string {
   char *str ;
   size_t len ;
};
#line 280 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_string awk_string_t;
#line 286 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef void *awk_array_t;
#line 289 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef void *awk_scalar_t;
#line 292 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef void *awk_value_cookie_t;
#line 301
enum __anonenum_awk_valtype_t_68 {
    AWK_UNDEFINED = 0,
    AWK_NUMBER = 1,
    AWK_STRING = 2,
    AWK_ARRAY = 3,
    AWK_SCALAR = 4,
    AWK_VALUE_COOKIE = 5
} ;
#line 301 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef enum __anonenum_awk_valtype_t_68 awk_valtype_t;
#line 314 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
union __anonunion_u_69 {
   awk_string_t s ;
   double d ;
   awk_array_t a ;
   awk_scalar_t scl ;
   awk_value_cookie_t vc ;
};
#line 314 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_value {
   awk_valtype_t val_type ;
   union __anonunion_u_69 u ;
};
#line 314 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_value awk_value_t;
#line 282 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
enum nodevals {
    Node_illegal = 0,
    Node_val = 1,
    Node_regex = 2,
    Node_dynregex = 3,
    Node_var = 4,
    Node_var_array = 5,
    Node_var_new = 6,
    Node_param_list = 7,
    Node_func = 8,
    Node_ext_func = 9,
    Node_old_ext_func = 10,
    Node_array_ref = 11,
    Node_array_tree = 12,
    Node_array_leaf = 13,
    Node_dump_array = 14,
    Node_arrayfor = 15,
    Node_frame = 16,
    Node_instruction = 17,
    Node_final = 18
} ;
#line 282 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef enum nodevals NODETYPE;
#line 312
struct exp_node;
#line 314 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct __anonstruct_hs_71 {
   union bucket_item *next ;
   char *str ;
   size_t len ;
   size_t code ;
   struct exp_node *name ;
   struct exp_node *val ;
};
#line 314 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct __anonstruct_hi_72 {
   union bucket_item *next ;
   long li[2] ;
   struct exp_node *val[2] ;
   size_t cnt ;
};
#line 314 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
union bucket_item {
   struct __anonstruct_hs_71 hs ;
   struct __anonstruct_hi_72 hi ;
};
#line 314 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef union bucket_item BUCKET;
#line 345
struct exp_instruction;
#line 348 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef struct exp_node **(*afunc_t)(struct exp_node * , struct exp_node * );
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
union __anonunion_l_75 {
   struct exp_node *lptr ;
   struct exp_instruction *li ;
   long ll ;
   afunc_t *lp ;
};
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
union __anonunion_r_76 {
   struct exp_node *rptr ;
   Regexp *preg ;
   struct exp_node **av ;
   BUCKET **bv ;
   void *aq ;
   void (*uptr)(void) ;
   struct exp_instruction *iptr ;
};
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
union __anonunion_x_77 {
   struct exp_node *extra ;
   void (*aptr)(void) ;
   long xl ;
   char **param_list ;
};
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct __anonstruct_nodep_74 {
   union __anonunion_l_75 l ;
   union __anonunion_r_76 r ;
   union __anonunion_x_77 x ;
   char *name ;
   size_t reserved ;
   struct exp_node *rn ;
   unsigned long cnt ;
   unsigned long reflags ;
};
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
union __anonunion_nm_79 {
   double fltnum ;
   mpfr_t mpnum ;
   mpz_t mpi ;
};
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct __anonstruct_val_78 {
   union __anonunion_nm_79 nm ;
   char *sp ;
   size_t slen ;
   long sref ;
   int idx ;
   wchar_t *wsp ;
   size_t wslen ;
};
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
union __anonunion_sub_73 {
   struct __anonstruct_nodep_74 nodep ;
   struct __anonstruct_val_78 val ;
};
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct exp_node {
   union __anonunion_sub_73 sub ;
   NODETYPE type ;
   unsigned int flags ;
};
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef struct exp_node NODE;
#line 551
enum opcodeval {
    Op_illegal = 0,
    Op_times = 1,
    Op_times_i = 2,
    Op_quotient = 3,
    Op_quotient_i = 4,
    Op_mod = 5,
    Op_mod_i = 6,
    Op_plus = 7,
    Op_plus_i = 8,
    Op_minus = 9,
    Op_minus_i = 10,
    Op_exp = 11,
    Op_exp_i = 12,
    Op_concat = 13,
    Op_line_range = 14,
    Op_cond_pair = 15,
    Op_subscript = 16,
    Op_sub_array = 17,
    Op_preincrement = 18,
    Op_predecrement = 19,
    Op_postincrement = 20,
    Op_postdecrement = 21,
    Op_unary_minus = 22,
    Op_field_spec = 23,
    Op_not = 24,
    Op_assign = 25,
    Op_store_var = 26,
    Op_store_sub = 27,
    Op_store_field = 28,
    Op_assign_times = 29,
    Op_assign_quotient = 30,
    Op_assign_mod = 31,
    Op_assign_plus = 32,
    Op_assign_minus = 33,
    Op_assign_exp = 34,
    Op_assign_concat = 35,
    Op_and = 36,
    Op_and_final = 37,
    Op_or = 38,
    Op_or_final = 39,
    Op_equal = 40,
    Op_notequal = 41,
    Op_less = 42,
    Op_greater = 43,
    Op_leq = 44,
    Op_geq = 45,
    Op_match = 46,
    Op_match_rec = 47,
    Op_nomatch = 48,
    Op_rule = 49,
    Op_K_case = 50,
    Op_K_default = 51,
    Op_K_break = 52,
    Op_K_continue = 53,
    Op_K_print = 54,
    Op_K_print_rec = 55,
    Op_K_printf = 56,
    Op_K_next = 57,
    Op_K_exit = 58,
    Op_K_return = 59,
    Op_K_delete = 60,
    Op_K_delete_loop = 61,
    Op_K_getline_redir = 62,
    Op_K_getline = 63,
    Op_K_nextfile = 64,
    Op_builtin = 65,
    Op_sub_builtin = 66,
    Op_ext_builtin = 67,
    Op_old_ext_builtin = 68,
    Op_in_array = 69,
    Op_func_call = 70,
    Op_indirect_func_call = 71,
    Op_push = 72,
    Op_push_arg = 73,
    Op_push_i = 74,
    Op_push_re = 75,
    Op_push_array = 76,
    Op_push_param = 77,
    Op_push_lhs = 78,
    Op_subscript_lhs = 79,
    Op_field_spec_lhs = 80,
    Op_no_op = 81,
    Op_pop = 82,
    Op_jmp = 83,
    Op_jmp_true = 84,
    Op_jmp_false = 85,
    Op_get_record = 86,
    Op_newfile = 87,
    Op_arrayfor_init = 88,
    Op_arrayfor_incr = 89,
    Op_arrayfor_final = 90,
    Op_var_update = 91,
    Op_var_assign = 92,
    Op_field_assign = 93,
    Op_subscript_assign = 94,
    Op_after_beginfile = 95,
    Op_after_endfile = 96,
    Op_func = 97,
    Op_exec_count = 98,
    Op_breakpoint = 99,
    Op_lint = 100,
    Op_atexit = 101,
    Op_stop = 102,
    Op_token = 103,
    Op_symbol = 104,
    Op_list = 105,
    Op_K_do = 106,
    Op_K_for = 107,
    Op_K_arrayfor = 108,
    Op_K_while = 109,
    Op_K_switch = 110,
    Op_K_if = 111,
    Op_K_else = 112,
    Op_K_function = 113,
    Op_cond_exp = 114,
    Op_final = 115
} ;
#line 551 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef enum opcodeval OPCODE;
#line 711
struct break_point;
#line 713 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
union __anonunion_d_80 {
   NODE *dn ;
   struct exp_instruction *di ;
   NODE *(*fptr)(int  ) ;
   awk_value_t *(*efptr)(int  , awk_value_t * ) ;
   long dl ;
   char *name ;
};
#line 713 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
union __anonunion_x_81 {
   long xl ;
   NODE *xn ;
   void (*aptr)(void) ;
   struct exp_instruction *xi ;
   struct break_point *bpt ;
};
#line 713 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct exp_instruction {
   struct exp_instruction *nexti ;
   union __anonunion_d_80 d ;
   union __anonunion_x_81 x ;
   short source_line ;
   OPCODE opcode ;
};
#line 713 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef struct exp_instruction INSTRUCTION;
#line 948
enum srctype {
    SRC_CMDLINE = 1,
    SRC_STDIN = 2,
    SRC_FILE = 3,
    SRC_INC = 4,
    SRC_EXTLIB = 5
} ;
#line 948 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct srcfile {
   struct srcfile *next ;
   struct srcfile *prev ;
   enum srctype stype ;
   char *src ;
   char *fullpath ;
   time_t mtime ;
   struct stat sbuf ;
   int srclines ;
   size_t bufsize ;
   char *buf ;
   int *line_offset ;
   int fd ;
   int maxlen ;
   void (*fini_func)() ;
   char *lexptr ;
   char *lexend ;
   char *lexeme ;
   char *lexptr_begin ;
   int lasttok ;
};
#line 948 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef struct srcfile SRCFILE;
#line 980 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct context {
   INSTRUCTION pools ;
   NODE symbols ;
   INSTRUCTION rule_list ;
   SRCFILE srcfiles ;
   int sourceline ;
   char *source ;
   void (*install_func)(NODE * ) ;
   struct context *prev ;
};
#line 980 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef struct context AWK_CONTEXT;
#line 998 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct block_item {
   size_t size ;
   struct block_item *freep ;
};
#line 998 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef struct block_item BLOCK;
#line 1325
enum __anonenum_sort_context_t_82 {
    SORTED_IN = 1,
    ASORT = 2,
    ASORTI = 3
} ;
#line 1325 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef enum __anonenum_sort_context_t_82 sort_context_t;
#line 364 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
enum __anonenum_SYMBOL_TYPE_86 {
    FUNCTION = 1,
    VARIABLE = 2
} ;
#line 364 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
typedef enum __anonenum_SYMBOL_TYPE_86 SYMBOL_TYPE;
#line 1326 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
enum __anonenum_assoc_kind_t_83 {
    AINDEX = 1,
    AVALUE = 2,
    AINUM = 4,
    AISTR = 8,
    AVNUM = 16,
    AVSTR = 32,
    AASC = 64,
    ADESC = 128,
    ADELETE = 256
} ;
#line 1326 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef enum __anonenum_assoc_kind_t_83 assoc_kind_t;
#line 180 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 319 "./regex.h"
enum __anonenum_reg_errcode_t_15 {
    REG_ENOSYS = -1,
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} ;
#line 319 "./regex.h"
typedef enum __anonenum_reg_errcode_t_15 reg_errcode_t;
#line 434 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 463 "./regex.h"
struct __anonstruct_regmatch_t_16 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "./regex.h"
typedef struct __anonstruct_regmatch_t_16 regmatch_t;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_19 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_18 {
   int __count ;
   union __anonunion___value_19 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_18 __mbstate_t;
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 352 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int wint_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 53 "/usr/include/wctype.h"
typedef unsigned long wctype_t;
#line 174 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef unsigned long bitset_word_t;
#line 181 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef bitset_word_t bitset_t[256UL / (sizeof(bitset_word_t ) * 8UL)];
#line 182 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef bitset_word_t *re_bitset_ptr_t;
#line 183 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef bitset_word_t const   *re_const_bitset_ptr_t;
#line 206
enum __anonenum_re_context_type_32 {
    INSIDE_WORD = 5,
    WORD_FIRST = 6,
    WORD_LAST = 9,
    INSIDE_NOTWORD = 10,
    LINE_FIRST = 16,
    LINE_LAST = 32,
    BUF_FIRST = 64,
    BUF_LAST = 128,
    WORD_DELIM = 256,
    NOT_WORD_DELIM = 512
} ;
#line 206 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef enum __anonenum_re_context_type_32 re_context_type;
#line 220 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct __anonstruct_re_node_set_33 {
   int alloc ;
   int nelem ;
   int *elems ;
};
#line 220 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct __anonstruct_re_node_set_33 re_node_set;
#line 227
enum __anonenum_re_token_type_t_34 {
    NON_TYPE = 0,
    CHARACTER = 1,
    END_OF_RE = 2,
    SIMPLE_BRACKET = 3,
    OP_BACK_REF = 4,
    OP_PERIOD = 5,
    COMPLEX_BRACKET = 6,
    OP_UTF8_PERIOD = 7,
    OP_OPEN_SUBEXP = 8,
    OP_CLOSE_SUBEXP = 9,
    OP_ALT = 10,
    OP_DUP_ASTERISK = 11,
    ANCHOR = 12,
    CONCAT = 16,
    SUBEXP = 17,
    OP_DUP_PLUS = 18,
    OP_DUP_QUESTION = 19,
    OP_OPEN_BRACKET = 20,
    OP_CLOSE_BRACKET = 21,
    OP_CHARSET_RANGE = 22,
    OP_OPEN_DUP_NUM = 23,
    OP_CLOSE_DUP_NUM = 24,
    OP_NON_MATCH_LIST = 25,
    OP_OPEN_COLL_ELEM = 26,
    OP_CLOSE_COLL_ELEM = 27,
    OP_OPEN_EQUIV_CLASS = 28,
    OP_CLOSE_EQUIV_CLASS = 29,
    OP_OPEN_CHAR_CLASS = 30,
    OP_CLOSE_CHAR_CLASS = 31,
    OP_WORD = 32,
    OP_NOTWORD = 33,
    OP_SPACE = 34,
    OP_NOTSPACE = 35,
    BACK_SLASH = 36
} ;
#line 227 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef enum __anonenum_re_token_type_t_34 re_token_type_t;
#line 279 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct __anonstruct_re_charset_t_35 {
   wchar_t *mbchars ;
   wchar_t *range_starts ;
   wchar_t *range_ends ;
   wctype_t *char_classes ;
   unsigned int non_match : 1 ;
   int nmbchars ;
   int ncoll_syms ;
   int nequiv_classes ;
   int nranges ;
   int nchar_classes ;
};
#line 279 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct __anonstruct_re_charset_t_35 re_charset_t;
#line 326 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
union __anonunion_opr_37 {
   unsigned char c ;
   re_bitset_ptr_t sbcset ;
   re_charset_t *mbcset ;
   int idx ;
   re_context_type ctx_type ;
};
#line 326 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct __anonstruct_re_token_t_36 {
   union __anonunion_opr_37 opr ;
   re_token_type_t type : 8 ;
   unsigned int constraint : 10 ;
   unsigned int duplicated : 1 ;
   unsigned int opt_subexp : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int mb_partial : 1 ;
   unsigned int word_char : 1 ;
};
#line 326 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct __anonstruct_re_token_t_36 re_token_t;
#line 357 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct re_string_t {
   unsigned char const   *raw_mbs ;
   unsigned char *mbs ;
   wint_t *wcs ;
   int *offsets ;
   mbstate_t cur_state ;
   int raw_mbs_idx ;
   int valid_len ;
   int valid_raw_len ;
   int bufs_len ;
   int cur_idx ;
   int raw_len ;
   int len ;
   int raw_stop ;
   int stop ;
   unsigned int tip_context ;
   unsigned char *trans ;
   re_const_bitset_ptr_t word_char ;
   unsigned char icase ;
   unsigned char is_utf8 ;
   unsigned char map_notascii ;
   unsigned char mbs_allocated ;
   unsigned char offsets_needed ;
   unsigned char newline_anchor ;
   unsigned char word_ops_used ;
   int mb_cur_max ;
};
#line 412 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct re_string_t re_string_t;
#line 415
struct re_dfa_t;
#line 416 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct re_dfa_t re_dfa_t;
#line 476 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct bin_tree_t {
   struct bin_tree_t *parent ;
   struct bin_tree_t *left ;
   struct bin_tree_t *right ;
   struct bin_tree_t *first ;
   struct bin_tree_t *next ;
   re_token_t token ;
   int node_idx ;
};
#line 490 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct bin_tree_t bin_tree_t;
#line 495 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct bin_tree_storage_t {
   struct bin_tree_storage_t *next ;
   bin_tree_t data[(1024UL - sizeof(void *)) / sizeof(bin_tree_t )] ;
};
#line 500 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct bin_tree_storage_t bin_tree_storage_t;
#line 530 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct re_dfastate_t {
   unsigned int hash ;
   re_node_set nodes ;
   re_node_set non_eps_nodes ;
   re_node_set inveclosure ;
   re_node_set *entrance_nodes ;
   struct re_dfastate_t **trtable ;
   struct re_dfastate_t **word_trtable ;
   unsigned int context : 4 ;
   unsigned int halt : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int has_backref : 1 ;
   unsigned int has_constraint : 1 ;
};
#line 548 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct re_dfastate_t re_dfastate_t;
#line 550 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct re_state_table_entry {
   int num ;
   int alloc ;
   re_dfastate_t **array ;
};
#line 559 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct __anonstruct_state_array_t_38 {
   int next_idx ;
   int alloc ;
   re_dfastate_t **array ;
};
#line 559 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct __anonstruct_state_array_t_38 state_array_t;
#line 568 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct __anonstruct_re_sub_match_last_t_39 {
   int node ;
   int str_idx ;
   state_array_t path ;
};
#line 568 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct __anonstruct_re_sub_match_last_t_39 re_sub_match_last_t;
#line 579 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct __anonstruct_re_sub_match_top_t_40 {
   int str_idx ;
   int node ;
   state_array_t *path ;
   int alasts ;
   int nlasts ;
   re_sub_match_last_t **lasts ;
};
#line 579 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct __anonstruct_re_sub_match_top_t_40 re_sub_match_top_t;
#line 589 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct re_backref_cache_entry {
   int node ;
   int str_idx ;
   int subexp_from ;
   int subexp_to ;
   char more ;
   char unused ;
   unsigned short eps_reachable_subexps_map ;
};
#line 600 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct __anonstruct_re_match_context_t_41 {
   re_string_t input ;
   re_dfa_t const   *dfa ;
   int eflags ;
   int match_last ;
   int last_node ;
   re_dfastate_t **state_log ;
   int state_log_top ;
   int nbkref_ents ;
   int abkref_ents ;
   struct re_backref_cache_entry *bkref_ents ;
   int max_mb_elem_len ;
   int nsub_tops ;
   int asub_tops ;
   re_sub_match_top_t **sub_tops ;
};
#line 600 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct __anonstruct_re_match_context_t_41 re_match_context_t;
#line 627 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct __anonstruct_re_sift_context_t_42 {
   re_dfastate_t **sifted_states ;
   re_dfastate_t **limited_states ;
   int last_node ;
   int last_str_idx ;
   re_node_set limits ;
};
#line 627 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct __anonstruct_re_sift_context_t_42 re_sift_context_t;
#line 636 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct re_fail_stack_ent_t {
   int idx ;
   int node ;
   regmatch_t *regs ;
   re_node_set eps_via_nodes ;
};
#line 644 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct re_fail_stack_t {
   int num ;
   int alloc ;
   struct re_fail_stack_ent_t *stack ;
};
#line 651 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct re_dfa_t {
   re_token_t *nodes ;
   size_t nodes_alloc ;
   size_t nodes_len ;
   int *nexts ;
   int *org_indices ;
   re_node_set *edests ;
   re_node_set *eclosures ;
   re_node_set *inveclosures ;
   struct re_state_table_entry *state_table ;
   re_dfastate_t *init_state ;
   re_dfastate_t *init_state_word ;
   re_dfastate_t *init_state_nl ;
   re_dfastate_t *init_state_begbuf ;
   bin_tree_t *str_tree ;
   bin_tree_storage_t *str_tree_storage ;
   re_bitset_ptr_t sb_char ;
   int str_tree_storage_idx ;
   unsigned int state_hash_mask ;
   int init_node ;
   int nbackref ;
   bitset_word_t used_bkref_map ;
   bitset_word_t completed_bkref_map ;
   unsigned int has_plural_match : 1 ;
   unsigned int has_mb_node : 1 ;
   unsigned int is_utf8 : 1 ;
   unsigned int map_notascii : 1 ;
   unsigned int word_ops_used : 1 ;
   int mb_cur_max ;
   bitset_t word_char ;
   reg_syntax_t syntax ;
   int *subexp_map ;
};
#line 707
enum __anonenum_bracket_elem_type_43 {
    SB_CHAR = 0,
    MB_CHAR = 1,
    EQUIV_CLASS = 2,
    COLL_SYM = 3,
    CHAR_CLASS = 4
} ;
#line 707 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef enum __anonenum_bracket_elem_type_43 bracket_elem_type;
#line 716 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
union __anonunion_opr_45 {
   unsigned char ch ;
   unsigned char *name ;
   wchar_t wch ;
};
#line 716 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
struct __anonstruct_bracket_elem_t_44 {
   bracket_elem_type type ;
   union __anonunion_opr_45 opr ;
};
#line 716 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
typedef struct __anonstruct_bracket_elem_t_44 bracket_elem_t;
#line 3351 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
struct dests_alloc {
   re_node_set dests_node[256] ;
   bitset_t dests_ch[256] ;
};
#line 992 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct flagtab {
   int val ;
   char const   *name ;
};
#line 514 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
struct reclass {
   char const   *name ;
   size_t len ;
   _Bool warned ;
};
#line 32 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.h"
typedef unsigned int gawk_uint32_t;
#line 33 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.h"
typedef int gawk_int32_t;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 72 "/usr/include/mpfr.h"
enum __anonenum_mpfr_rnd_t_62 {
    GMP_RNDN = 0,
    GMP_RNDZ = 1,
    GMP_RNDU = 2,
    GMP_RNDD = 3,
    GMP_RND_MAX = 4,
    GMP_RNDNA = -1
} ;
#line 72 "/usr/include/mpfr.h"
typedef enum __anonenum_mpfr_rnd_t_62 mpfr_rnd_t;
#line 54 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 80 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 32 "/usr/include/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_8 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_8 __sigset_t;
#line 35 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 49 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 257 "/usr/include/gmp-x86_64.h"
enum __anonenum_gmp_randalg_t_58 {
    GMP_RAND_ALG_DEFAULT = 0,
    GMP_RAND_ALG_LC = 0
} ;
#line 257 "/usr/include/gmp-x86_64.h"
typedef enum __anonenum_gmp_randalg_t_58 gmp_randalg_t;
#line 264 "/usr/include/gmp-x86_64.h"
union __anonunion__mp_algdata_60 {
   void *_mp_lc ;
};
#line 264 "/usr/include/gmp-x86_64.h"
struct __anonstruct___gmp_randstate_struct_59 {
   mpz_t _mp_seed ;
   gmp_randalg_t _mp_alg ;
   union __anonunion__mp_algdata_60 _mp_algdata ;
};
#line 264 "/usr/include/gmp-x86_64.h"
typedef struct __anonstruct___gmp_randstate_struct_59 __gmp_randstate_struct;
#line 272 "/usr/include/gmp-x86_64.h"
typedef __gmp_randstate_struct gmp_randstate_t[1];
#line 140 "/usr/include/mpfr.h"
typedef __mpfr_struct *mpfr_ptr;
#line 141 "/usr/include/mpfr.h"
typedef __mpfr_struct const   *mpfr_srcptr;
#line 1149 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
union stack_item {
   NODE *rptr ;
   NODE **lptr ;
};
#line 1149 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef union stack_item STACK_ITEM;
#line 31 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
typedef mp_exp_t mpfr_exp_t;
#line 494 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
struct ieee_fmt {
   char const   *name ;
   mpfr_prec_t precision ;
   mpfr_exp_t emax ;
   mpfr_exp_t emin ;
};
#line 40 "/usr/include/bits/types.h"
typedef unsigned short __uint16_t;
#line 42 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 45 "/usr/include/bits/types.h"
typedef unsigned long __uint64_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 50 "/usr/include/bits/sigstack.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 50 "/usr/include/bits/sigstack.h"
typedef struct sigaltstack stack_t;
#line 33 "/usr/include/sys/ucontext.h"
typedef long greg_t;
#line 39 "/usr/include/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 94 "/usr/include/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
#line 101 "/usr/include/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 106 "/usr/include/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t padding[24] ;
};
#line 123 "/usr/include/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 126 "/usr/include/sys/ucontext.h"
struct __anonstruct_mcontext_t_31 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long __reserved1[8] ;
};
#line 126 "/usr/include/sys/ucontext.h"
typedef struct __anonstruct_mcontext_t_31 mcontext_t;
#line 135 "/usr/include/sys/ucontext.h"
struct ucontext {
   unsigned long uc_flags ;
   struct ucontext *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   __sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
};
#line 135 "/usr/include/sys/ucontext.h"
typedef struct ucontext ucontext_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 84 "/usr/include/sigsegv.h"
typedef ucontext_t *stackoverflow_context_t;
#line 1480 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
enum __anonenum_field_sep_type_84 {
    Using_FS = 0,
    Using_FIELDWIDTHS = 1,
    Using_FPAT = 2
} ;
#line 1480 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef enum __anonenum_field_sep_type_84 field_sep_type;
#line 104 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 123 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
enum assign_type {
    PRE_ASSIGN = 1,
    PRE_ASSIGN_FS = 2
} ;
#line 123 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
struct pre_assign {
   enum assign_type type ;
   char *val ;
};
#line 951 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
struct varinit {
   NODE **spec ;
   char const   *name ;
   char const   *strval ;
   double numval ;
   void (*update)(void) ;
   void (*assign)(void) ;
   _Bool do_assign ;
   int flags ;
};
#line 150 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 62 "/usr/include/signal.h"
typedef __pid_t pid_t;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_43 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_44 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_43 __wait_terminated ;
   struct __anonstruct___wait_stopped_44 __wait_stopped ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_49 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_49 fd_set;
#line 275 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 116 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
enum awk_bool {
    awk_false = 0,
    awk_true = 1
} ;
#line 116 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef enum awk_bool awk_bool_t;
#line 122 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_input {
   char const   *name ;
   int fd ;
   void *opaque ;
   int (*get_record)(char **out , struct awk_input *iobuf , int *errcode , char **rt_start ,
                     size_t *rt_len ) ;
   ssize_t (*read_func)() ;
   void (*close_func)(struct awk_input *iobuf ) ;
   struct stat sbuf ;
};
#line 122 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_input awk_input_buf_t;
#line 172 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_input_parser {
   char const   *name ;
   awk_bool_t (*can_take_file)(awk_input_buf_t const   *iobuf ) ;
   awk_bool_t (*take_control_of)(awk_input_buf_t *iobuf ) ;
   struct awk_input_parser *next ;
};
#line 172 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_input_parser awk_input_parser_t;
#line 199 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_output_buf {
   char const   *name ;
   char const   *mode ;
   FILE *fp ;
   awk_bool_t redirected ;
   void *opaque ;
   size_t (*gawk_fwrite)(void const   *buf , size_t size , size_t count , FILE *fp ,
                         void *opaque ) ;
   int (*gawk_fflush)(FILE *fp , void *opaque ) ;
   int (*gawk_ferror)(FILE *fp , void *opaque ) ;
   int (*gawk_fclose)(FILE *fp , void *opaque ) ;
};
#line 199 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_output_buf awk_output_buf_t;
#line 218 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_output_wrapper {
   char const   *name ;
   awk_bool_t (*can_take_file)(awk_output_buf_t const   *outbuf ) ;
   awk_bool_t (*take_control_of)(awk_output_buf_t *outbuf ) ;
   struct awk_output_wrapper *next ;
};
#line 218 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_output_wrapper awk_output_wrapper_t;
#line 241 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_two_way_processor {
   char const   *name ;
   awk_bool_t (*can_take_two_way)(char const   *name ) ;
   awk_bool_t (*take_control_of)(char const   *name , awk_input_buf_t *inbuf , awk_output_buf_t *outbuf ) ;
   struct awk_two_way_processor *next ;
};
#line 241 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_two_way_processor awk_two_way_processor_t;
#line 700 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
enum redirval {
    redirect_none = 0,
    redirect_output = 1,
    redirect_append = 2,
    redirect_pipe = 3,
    redirect_pipein = 4,
    redirect_input = 5,
    redirect_twoway = 6
} ;
#line 885 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct iobuf {
   awk_input_buf_t public ;
   char *buf ;
   char *off ;
   char *dataend ;
   char *end ;
   size_t readsize ;
   size_t size ;
   ssize_t count ;
   size_t scanoff ;
   _Bool valid ;
   int errcode ;
   int flag ;
};
#line 885 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef struct iobuf IOBUF;
#line 910 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct redirect {
   unsigned int flag ;
   char *value ;
   FILE *ifp ;
   IOBUF *iop ;
   int pid ;
   int status ;
   struct redirect *prev ;
   struct redirect *next ;
   char const   *mode ;
   awk_output_buf_t output ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 187 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   unsigned long __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(unsigned long )] ;
};
#line 400 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 543 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 155 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
enum __anonenum_two_way_close_type_94 {
    CLOSE_ALL = 0,
    CLOSE_TO = 1,
    CLOSE_FROM = 2
} ;
#line 155 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
typedef enum __anonenum_two_way_close_type_94 two_way_close_type;
#line 171
enum recvalues {
    REC_OK = 0,
    NOTERM = 1,
    TERMATEND = 2,
    TERMNEAREND = 3
} ;
#line 171 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
typedef enum recvalues RECVALUE;
#line 186
enum scanstate {
    NOSTATE = 0,
    INLEADER = 1,
    INDATA = 2,
    INTERM = 3
} ;
#line 186 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
typedef enum scanstate SCANSTATE;
#line 198 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
struct recmatch {
   char *start ;
   size_t len ;
   char *rt_start ;
   size_t rt_len ;
};
#line 2411 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
struct __anonstruct_path_info_95 {
   char const   *envname ;
   char **dfltp ;
   char try_cwd ;
   char **awkpath ;
   int max_pathlen ;
};
#line 2411 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
typedef struct __anonstruct_path_info_95 path_info;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 32 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt_int.h"
enum __anonenum___ordering_3 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 32 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt_int.h"
struct _getopt_data {
   int optind ;
   int opterr ;
   int optopt ;
   char *optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __anonenum___ordering_3 __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 538 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
struct option_list {
   struct option  const  *p ;
   struct option_list *next ;
   int needs_free ;
};
#line 47 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkmisc.c"
typedef void *pointer;
#line 338 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
enum __anonenum_flags_70 {
    AWK_ELEMENT_DEFAULT = 0,
    AWK_ELEMENT_DELETE = 1
} ;
#line 338 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_element {
   struct awk_element *next ;
   enum __anonenum_flags_70 flags ;
   awk_value_t index ;
   awk_value_t value ;
};
#line 338 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_element awk_element_t;
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_flat_array {
   void *opaque1 ;
   void *opaque2 ;
   size_t count ;
   awk_element_t elements[1] ;
};
#line 354 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_flat_array awk_flat_array_t;
#line 376 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct awk_ext_func {
   char const   *name ;
   awk_value_t *(*function)(int num_actual_args , awk_value_t *result ) ;
   size_t num_expected_args ;
};
#line 376 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct awk_ext_func awk_ext_func_t;
#line 382 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef void *awk_ext_id_t;
#line 388 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
struct gawk_api {
   int major_version ;
   int minor_version ;
   int do_flags[6] ;
   awk_bool_t (*api_add_ext_func)(awk_ext_id_t id , char const   *namespace , awk_ext_func_t const   *func ) ;
   void (*api_register_input_parser)(awk_ext_id_t id , awk_input_parser_t *input_parser ) ;
   void (*api_register_output_wrapper)(awk_ext_id_t id , awk_output_wrapper_t *output_wrapper ) ;
   void (*api_register_two_way_processor)(awk_ext_id_t id , awk_two_way_processor_t *two_way_processor ) ;
   void (*api_awk_atexit)(awk_ext_id_t id , void (*funcp)(void *data , int exit_status ) ,
                          void *arg0 ) ;
   void (*api_register_ext_version)(awk_ext_id_t id , char const   *version ) ;
   void (*api_fatal)(awk_ext_id_t id , char const   *format  , ...) ;
   void (*api_warning)(awk_ext_id_t id , char const   *format  , ...) ;
   void (*api_lintwarn)(awk_ext_id_t id , char const   *format  , ...) ;
   void (*api_update_ERRNO_int)(awk_ext_id_t id , int errno_val ) ;
   void (*api_update_ERRNO_string)(awk_ext_id_t id , char const   *string ) ;
   void (*api_unset_ERRNO)(awk_ext_id_t id ) ;
   awk_bool_t (*api_get_argument)(awk_ext_id_t id , size_t count , awk_valtype_t wanted ,
                                  awk_value_t *result ) ;
   awk_bool_t (*api_set_argument)(awk_ext_id_t id , size_t count , awk_array_t array ) ;
   awk_bool_t (*api_sym_lookup)(awk_ext_id_t id , char const   *name , awk_valtype_t wanted ,
                                awk_value_t *result ) ;
   awk_bool_t (*api_sym_update)(awk_ext_id_t id , char const   *name , awk_value_t *value ) ;
   awk_bool_t (*api_sym_lookup_scalar)(awk_ext_id_t id , awk_scalar_t cookie , awk_valtype_t wanted ,
                                       awk_value_t *result ) ;
   awk_bool_t (*api_sym_update_scalar)(awk_ext_id_t id , awk_scalar_t cookie , awk_value_t *value ) ;
   awk_bool_t (*api_create_value)(awk_ext_id_t id , awk_value_t *value , awk_value_cookie_t *result ) ;
   awk_bool_t (*api_release_value)(awk_ext_id_t id , awk_value_cookie_t vc ) ;
   awk_bool_t (*api_get_element_count)(awk_ext_id_t id , awk_array_t a_cookie , size_t *count ) ;
   awk_bool_t (*api_get_array_element)(awk_ext_id_t id , awk_array_t a_cookie , awk_value_t const   * const  index ,
                                       awk_valtype_t wanted , awk_value_t *result ) ;
   awk_bool_t (*api_set_array_element)(awk_ext_id_t id , awk_array_t a_cookie , awk_value_t const   * const  index ,
                                       awk_value_t const   * const  value ) ;
   awk_bool_t (*api_del_array_element)(awk_ext_id_t id , awk_array_t a_cookie , awk_value_t const   * const  index ) ;
   awk_array_t (*api_create_array)(awk_ext_id_t id ) ;
   awk_bool_t (*api_clear_array)(awk_ext_id_t id , awk_array_t a_cookie ) ;
   awk_bool_t (*api_flatten_array)(awk_ext_id_t id , awk_array_t a_cookie , awk_flat_array_t **data ) ;
   awk_bool_t (*api_release_flattened_array)(awk_ext_id_t id , awk_array_t a_cookie ,
                                             awk_flat_array_t *data ) ;
};
#line 388 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.h"
typedef struct gawk_api gawk_api_t;
#line 328 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
struct ext_exit_handler {
   struct ext_exit_handler *next ;
   void (*funcp)(void *data , int exit_status ) ;
   void *arg0 ;
};
#line 1035 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
struct version_info {
   char const   *version ;
   struct version_info *next ;
};
#line 136 "/usr/include/stdint.h"
typedef unsigned long uintmax_t;
#line 907 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef void (*Func_ptr)(void);
#line 1010 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef int (*Func_pre_exec)(INSTRUCTION ** );
#line 261 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
struct optypetab {
   char *desc ;
   char *operator ;
};
#line 1632 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
struct exec_state {
   struct exec_state *next ;
   INSTRUCTION *cptr ;
   int rule ;
   long stack_size ;
   char const   *source ;
};
#line 1632 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
typedef struct exec_state EXEC_STATE;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef long ptrdiff_t;
#line 26 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.h"
struct dfamust {
   int exact ;
   char *must ;
   struct dfamust *next ;
};
#line 128 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef int charclass[(((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))];
#line 206 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef ptrdiff_t token;
#line 302 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct __anonstruct_position_34 {
   size_t index ;
   unsigned int constraint ;
};
#line 302 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef struct __anonstruct_position_34 position;
#line 309 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct __anonstruct_position_set_35 {
   position *elems ;
   size_t nelem ;
   size_t alloc ;
};
#line 309 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef struct __anonstruct_position_set_35 position_set;
#line 317 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct __anonstruct_leaf_set_36 {
   size_t *elems ;
   size_t nelem ;
};
#line 317 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef struct __anonstruct_leaf_set_36 leaf_set;
#line 326 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct __anonstruct_dfa_state_37 {
   size_t hash ;
   position_set elems ;
   unsigned char context ;
   char backref ;
   unsigned short constraint ;
   token first_end ;
   position_set mbps ;
};
#line 326 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef struct __anonstruct_dfa_state_37 dfa_state;
#line 342 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef ptrdiff_t state_num;
#line 346 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct mb_char_classes {
   ptrdiff_t cset ;
   int invert ;
   wchar_t *chars ;
   size_t nchars ;
   wctype_t *ch_classes ;
   size_t nch_classes ;
   wchar_t *range_sts ;
   wchar_t *range_ends ;
   size_t nranges ;
   char **equivs ;
   size_t nequivs ;
   char **coll_elems ;
   size_t ncoll_elems ;
};
#line 364 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct dfa {
   charclass *charclasses ;
   size_t cindex ;
   size_t calloc ;
   token *tokens ;
   size_t tindex ;
   size_t talloc ;
   size_t depth ;
   size_t nleaves ;
   size_t nregexps ;
   unsigned int mb_cur_max ;
   token utf8_anychar_classes[5] ;
   size_t nmultibyte_prop ;
   int *multibyte_prop ;
   struct mb_char_classes *mbcsets ;
   size_t nmbcsets ;
   size_t mbcsets_alloc ;
   dfa_state *states ;
   state_num sindex ;
   state_num salloc ;
   position_set *follows ;
   int searchflag ;
   state_num tralloc ;
   int trcount ;
   state_num **trans ;
   state_num **realtrans ;
   state_num **fails ;
   int *success ;
   state_num *newlines ;
   struct dfamust *musts ;
};
#line 913 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef int predicate(int  );
#line 918 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct dfa_ctype {
   char const   *name ;
   predicate *func ;
   _Bool single_byte_only ;
};
#line 2924
enum __anonenum_status_transit_state_38 {
    TRANSIT_STATE_IN_PROGRESS = 0,
    TRANSIT_STATE_DONE = 1,
    TRANSIT_STATE_END_BUFFER = 2
} ;
#line 2924 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef enum __anonenum_status_transit_state_38 status_transit_state;
#line 3888 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct __anonstruct_must_39 {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
};
#line 3888 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
typedef struct __anonstruct_must_39 must;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 51 "/usr/include/readline/rltypedefs.h"
typedef char **rl_completion_func_t(char const   * , int  , int  );
#line 41 "/usr/include/readline/history.h"
typedef void *histdata_t;
#line 47 "/usr/include/readline/history.h"
struct _hist_entry {
   char *line ;
   char *timestamp ;
   histdata_t data ;
};
#line 47 "/usr/include/readline/history.h"
typedef struct _hist_entry HIST_ENTRY;
#line 50 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
enum argtype {
    D_illegal = 0,
    D_backtrace = 1,
    D_break = 2,
    D_clear = 3,
    D_commands = 4,
    D_condition = 5,
    D_continue = 6,
    D_delete = 7,
    D_disable = 8,
    D_display = 9,
    D_down = 10,
    D_dump = 11,
    D_enable = 12,
    D_end = 13,
    D_eval = 14,
    D_finish = 15,
    D_frame = 16,
    D_help = 17,
    D_ignore = 18,
    D_info = 19,
    D_list = 20,
    D_next = 21,
    D_nexti = 22,
    D_option = 23,
    D_print = 24,
    D_printf = 25,
    D_quit = 26,
    D_return = 27,
    D_run = 28,
    D_save = 29,
    D_set = 30,
    D_silent = 31,
    D_source = 32,
    D_step = 33,
    D_stepi = 34,
    D_tbreak = 35,
    D_trace = 36,
    D_undisplay = 37,
    D_until = 38,
    D_unwatch = 39,
    D_up = 40,
    D_watch = 41,
    D_argument = 42,
    D_int = 43,
    D_string = 44,
    D_variable = 45,
    D_node = 46,
    D_field = 47,
    D_array = 48,
    D_subscript = 49,
    D_func = 50,
    D_range = 51
} ;
#line 128 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
union __anonunion_value_86 {
   long lval ;
   char *sval ;
   NODE *nodeval ;
};
#line 128 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
struct cmd_argument {
   struct cmd_argument *next ;
   enum argtype type ;
   union __anonunion_value_86 value ;
   int a_count ;
};
#line 128 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
typedef struct cmd_argument CMDARG;
#line 145 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
typedef int (*Func_cmd)(CMDARG * , int  );
#line 66 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
struct condition {
   INSTRUCTION *code ;
   AWK_CONTEXT *ctxt ;
   char *expr ;
};
#line 72 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
struct commands_item {
   struct commands_item *next ;
   struct commands_item *prev ;
   int cmd ;
   char *cmd_string ;
   CMDARG *arg ;
};
#line 81 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
struct break_point {
   struct break_point *next ;
   struct break_point *prev ;
   int number ;
   long ignore_count ;
   long hit_count ;
   char *src ;
   INSTRUCTION *bpi ;
   struct commands_item commands ;
   _Bool silent ;
   struct condition cndn ;
   short flags ;
};
#line 81 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
typedef struct break_point BREAKPOINT;
#line 116 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
union __anonunion_value_87 {
   NODE *n ;
   long l ;
};
#line 116 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
struct list_item {
   struct list_item *next ;
   struct list_item *prev ;
   int number ;
   NODE *symbol ;
   NODE **subs ;
   int num_subs ;
   char *sname ;
   long fcall_count ;
   struct commands_item commands ;
   int silent ;
   struct condition cndn ;
   union __anonunion_value_87 value[2] ;
   int flags ;
};
#line 161 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
struct __anonstruct_stop_88 {
   long fcall_count ;
   int sourceline ;
   char *source ;
   INSTRUCTION *pc ;
   int repeat_count ;
   _Bool print_frame ;
   _Bool print_ret ;
   int break_point ;
   int watch_point ;
   int (*check_func)(INSTRUCTION ** ) ;
   enum argtype command ;
};
#line 208 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
struct dbg_option {
   char const   *name ;
   int *num_val ;
   char **str_val ;
   void (*assign)(char const   * ) ;
   char const   *help_txt ;
};
#line 313 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
struct pf_data {
   int (*print_func)(FILE * , char const   *  , ...) ;
   _Bool defn ;
   FILE *fp ;
};
#line 321 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
struct command_source {
   int fd ;
   int is_tty ;
   char *(*read_func)(char const   * ) ;
   int (*close_func)(int  ) ;
   int eof_status ;
   int cmd ;
   char *str ;
   struct command_source *next ;
};
#line 50 "/usr/include/readline/rltypedefs.h"
typedef char *rl_compentry_func_t(char const   * , int  );
#line 111 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
enum nametypeval {
    A_ARGS = 1,
    A_BREAK = 2,
    A_DEL = 3,
    A_DISPLAY = 4,
    A_FRAME = 5,
    A_FUNCTIONS = 6,
    A_LOCALS = 7,
    A_ONCE = 8,
    A_SOURCE = 9,
    A_SOURCES = 10,
    A_TRACE_ON = 11,
    A_TRACE_OFF = 12,
    A_VARIABLES = 13,
    A_WATCH = 14
} ;
#line 147 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
struct cmdtoken {
   char const   *name ;
   char *abbrvn ;
   enum argtype type ;
   int class ;
   int (*cf_ptr)(CMDARG * , int  ) ;
   char const   *help_txt ;
};
#line 70 "command.y"
struct argtoken {
   char const   *name ;
   enum argtype cmd ;
   enum nametypeval value ;
};
#line 309 "command.c"
typedef unsigned char yytype_uint8;
#line 330 "command.c"
typedef short yytype_int16;
#line 471 "command.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   CMDARG *yyvs_alloc ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 135 "/usr/include/stdint.h"
typedef long intmax_t;
#line 696 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
struct __anonstruct_cpbufs_88 {
   char *buf ;
   size_t bufsize ;
   char stackbuf[30] ;
};
#line 717
enum __anonenum_fmt_type_89 {
    MP_INT_WITH_PREC = 1,
    MP_INT_WITHOUT_PREC = 2,
    MP_FLOAT = 3
} ;
#line 2051 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
union __anonunion_90 {
   int __in ;
   int __i ;
};
#line 3298 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
struct category_table {
   int val ;
   char const   *name ;
};
#line 543 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
enum lintvals {
    LINT_illegal = 0,
    LINT_assign_in_cond = 1,
    LINT_no_effect = 2
} ;
#line 543 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
typedef enum lintvals LINTTYPE;
#line 84 "awkgram.y"
enum defref {
    FUNC_DEFINE = 0,
    FUNC_USE = 1,
    FUNC_EXT = 2
} ;
#line 542 "awkgram.c"
union yyalloc___0 {
   yytype_int16 yyss_alloc ;
   INSTRUCTION *yyvs_alloc ;
};
#line 1804 "awkgram.y"
struct token {
   char const   *operator ;
   OPCODE value ;
   int class ;
   unsigned int flags ;
   NODE *(*ptr)(int  ) ;
   NODE *(*ptr2)(int  ) ;
};
#line 4291 "awkgram.y"
struct fdesc {
   char *name ;
   short used ;
   short defined ;
   short extension ;
   struct fdesc *next ;
};
#line 4423 "awkgram.y"
struct deferred_variable {
   NODE *(*load_func)(void) ;
   struct deferred_variable *next ;
   char name[1] ;
};
#line 4901
enum defline {
    FIRST_LINE = 0,
    LAST_LINE = 1
} ;
#line 1246 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
struct qsort_funcs {
   char const   *name ;
   int (*comp_func)(void const   * , void const   * ) ;
   assoc_kind_t kind ;
};
#line 3 "/home/wslee/gnu_benchmarks/gawk-4.1.0/version.c"
char const   *version_string  =    "GNU Awk 4.1.0";
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 756
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 692 "/usr/include/gmp-x86_64.h"
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 856
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 861
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 866
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 892
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 897
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 996
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) ;
#line 1017
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 1022
__inline extern unsigned long __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1065
extern void __gmpz_set(mpz_ptr  , mpz_srcptr  ) ;
#line 1075
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1092
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1126
extern void __gmpz_tdiv_q(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 1170
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1231
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) ;
#line 1240
extern void __gmpq_set(mpq_ptr  , mpq_srcptr  ) ;
#line 1480
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1485
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1489
extern mp_limb_t __gmpn_add_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1499
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 1558
__inline extern mp_limb_t __gmpn_neg_n(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) ;
#line 1562
extern int __gmpn_perfect_square_p(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1565
extern unsigned long __gmpn_popcount(mp_srcptr  , mp_size_t  )  __attribute__((__pure__)) ;
#line 1597
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) ;
#line 1602
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) ;
#line 1606
extern mp_limb_t __gmpn_sub_n(mp_ptr  , mp_srcptr  , mp_srcptr  , mp_size_t  ) ;
#line 1632 "/usr/include/gmp-x86_64.h"
__inline extern void __gmpz_abs(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1635
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1636
    __gmpz_set(__gmp_w, __gmp_u);
    }
  }
#line 1637
  if (__gmp_w->_mp_size >= 0) {
#line 1637
    __gmp_w->_mp_size = __gmp_w->_mp_size;
  } else {
#line 1637
    __gmp_w->_mp_size = - __gmp_w->_mp_size;
  }
#line 1638
  return;
}
}
#line 1656
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1656 "/usr/include/gmp-x86_64.h"
__inline extern int __gmpz_fits_uint_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp___1 ;

  {
#line 1661
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1661
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1661
  if (__gmp_n == 0L) {
#line 1661
    tmp___1 = 1;
  } else
#line 1661
  if (__gmp_n == 1L) {
#line 1661
    if (*(__gmp_p + 0) <= 4294967295UL) {
#line 1661
      tmp___1 = 1;
    } else {
#line 1661
      tmp___1 = 0;
    }
  } else {
#line 1661
    tmp___1 = 0;
  }
#line 1661
  return (tmp___1);
}
}
#line 1667
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1667 "/usr/include/gmp-x86_64.h"
__inline extern int __gmpz_fits_ulong_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp___1 ;

  {
#line 1672
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1672
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1672
  if (__gmp_n == 0L) {
#line 1672
    tmp___1 = 1;
  } else
#line 1672
  if (__gmp_n == 1L) {
#line 1672
    if (*(__gmp_p + 0) <= 0xffffffffffffffffUL) {
#line 1672
      tmp___1 = 1;
    } else {
#line 1672
      tmp___1 = 0;
    }
  } else {
#line 1672
    tmp___1 = 0;
  }
#line 1672
  return (tmp___1);
}
}
#line 1678
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1678 "/usr/include/gmp-x86_64.h"
__inline extern int __gmpz_fits_ushort_p(mpz_srcptr __gmp_z ) 
{ 
  mp_size_t __gmp_n ;
  mp_ptr __gmp_p ;
  int tmp___1 ;

  {
#line 1683
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1683
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1683
  if (__gmp_n == 0L) {
#line 1683
    tmp___1 = 1;
  } else
#line 1683
  if (__gmp_n == 1L) {
#line 1683
    if (*(__gmp_p + 0) <= 65535UL) {
#line 1683
      tmp___1 = 1;
    } else {
#line 1683
      tmp___1 = 0;
    }
  } else {
#line 1683
    tmp___1 = 0;
  }
#line 1683
  return (tmp___1);
}
}
#line 1689
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1689 "/usr/include/gmp-x86_64.h"
__inline extern unsigned long __gmpz_get_ui(mpz_srcptr __gmp_z ) 
{ 
  mp_ptr __gmp_p ;
  mp_size_t __gmp_n ;
  mp_limb_t __gmp_l ;
  mp_limb_t tmp___1 ;

  {
#line 1694
  __gmp_p = (mp_ptr )__gmp_z->_mp_d;
#line 1695
  __gmp_n = (mp_size_t )__gmp_z->_mp_size;
#line 1696
  __gmp_l = *(__gmp_p + 0);
#line 1703
  if (__gmp_n != 0L) {
#line 1703
    tmp___1 = __gmp_l;
  } else {
#line 1703
    tmp___1 = (mp_limb_t )0;
  }
#line 1703
  return (tmp___1);
}
}
#line 1717
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n )  __attribute__((__pure__)) ;
#line 1717 "/usr/include/gmp-x86_64.h"
__inline extern mp_limb_t __gmpz_getlimbn(mpz_srcptr __gmp_z , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_result ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 1722
  __gmp_result = (mp_limb_t )0;
#line 1723
  if (__gmp_n >= 0L) {
#line 1723
    if (__gmp_z->_mp_size >= 0) {
#line 1723
      tmp___1 = __gmp_z->_mp_size;
    } else {
#line 1723
      tmp___1 = - __gmp_z->_mp_size;
    }
#line 1723
    if (__gmp_n < (mp_size_t )tmp___1) {
#line 1723
      tmp___2 = 1;
    } else {
#line 1723
      tmp___2 = 0;
    }
  } else {
#line 1723
    tmp___2 = 0;
  }
  {
#line 1723
  tmp___3 = __builtin_expect((long )(tmp___2 != 0), 1L);
  }
#line 1723
  if (tmp___3) {
#line 1724
    __gmp_result = *(__gmp_z->_mp_d + __gmp_n);
  }
#line 1725
  return (__gmp_result);
}
}
#line 1730 "/usr/include/gmp-x86_64.h"
__inline extern void __gmpz_neg(mpz_ptr __gmp_w , mpz_srcptr __gmp_u ) 
{ 


  {
#line 1733
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1734
    __gmpz_set(__gmp_w, __gmp_u);
    }
  }
#line 1735
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
#line 1736
  return;
}
}
#line 1741
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a )  __attribute__((__pure__)) ;
#line 1741 "/usr/include/gmp-x86_64.h"
__inline extern int __gmpz_perfect_square_p(mpz_srcptr __gmp_a ) 
{ 
  mp_size_t __gmp_asize ;
  int __gmp_result ;
  long tmp___1 ;

  {
  {
#line 1749
  __gmp_asize = (mp_size_t )__gmp_a->_mp_size;
#line 1750
  __gmp_result = __gmp_asize >= 0L;
#line 1751
  tmp___1 = __builtin_expect((long )((__gmp_asize > 0L) != 0), 1L);
  }
#line 1751
  if (tmp___1) {
    {
#line 1752
    __gmp_result = __gmpn_perfect_square_p((mp_srcptr )__gmp_a->_mp_d, __gmp_asize);
    }
  }
#line 1753
  return (__gmp_result);
}
}
#line 1759
__inline extern unsigned long __gmpz_popcount(mpz_srcptr __gmp_u )  __attribute__((__pure__)) ;
#line 1759 "/usr/include/gmp-x86_64.h"
__inline extern unsigned long __gmpz_popcount(mpz_srcptr __gmp_u ) 
{ 
  mp_size_t __gmp_usize ;
  unsigned long __gmp_result ;
  long tmp___1 ;

  {
#line 1767
  __gmp_usize = (mp_size_t )__gmp_u->_mp_size;
#line 1768
  if (__gmp_usize < 0L) {
#line 1768
    __gmp_result = ~ 0UL;
  } else {
#line 1768
    __gmp_result = 0UL;
  }
  {
#line 1769
  tmp___1 = __builtin_expect((long )((__gmp_usize > 0L) != 0), 1L);
  }
#line 1769
  if (tmp___1) {
    {
#line 1770
    __gmp_result = __gmpn_popcount((mp_srcptr )__gmp_u->_mp_d, __gmp_usize);
    }
  }
#line 1771
  return (__gmp_result);
}
}
#line 1777 "/usr/include/gmp-x86_64.h"
__inline extern void __gmpz_set_q(mpz_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
  {
#line 1782
  __gmpz_tdiv_q(__gmp_w, & __gmp_u->_mp_num, & __gmp_u->_mp_den);
  }
#line 1783
  return;
}
}
#line 1788
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z )  __attribute__((__pure__)) ;
#line 1788 "/usr/include/gmp-x86_64.h"
__inline extern size_t __gmpz_size(mpz_srcptr __gmp_z ) 
{ 
  int tmp___1 ;

  {
#line 1793
  if (__gmp_z->_mp_size >= 0) {
#line 1793
    tmp___1 = __gmp_z->_mp_size;
  } else {
#line 1793
    tmp___1 = - __gmp_z->_mp_size;
  }
#line 1793
  return ((size_t )tmp___1);
}
}
#line 1801 "/usr/include/gmp-x86_64.h"
__inline extern void __gmpq_abs(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1804
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1805
    __gmpq_set(__gmp_w, __gmp_u);
    }
  }
#line 1806
  if (__gmp_w->_mp_num._mp_size >= 0) {
#line 1806
    __gmp_w->_mp_num._mp_size = __gmp_w->_mp_num._mp_size;
  } else {
#line 1806
    __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
  }
#line 1807
  return;
}
}
#line 1811 "/usr/include/gmp-x86_64.h"
__inline extern void __gmpq_neg(mpq_ptr __gmp_w , mpq_srcptr __gmp_u ) 
{ 


  {
#line 1814
  if ((unsigned long )__gmp_w != (unsigned long )__gmp_u) {
    {
#line 1815
    __gmpq_set(__gmp_w, __gmp_u);
    }
  }
#line 1816
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
#line 1817
  return;
}
}
#line 2054 "/usr/include/gmp-x86_64.h"
__inline extern mp_limb_t __gmpn_add(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp___1 ;
  mp_limb_t tmp___2 ;
  mp_limb_t tmp___3 ;
  mp_size_t __gmp_j ;

  {
  {
#line 2060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2060
    __gmp_i = __gmp_ysize;
#line 2060
    if (__gmp_i != 0L) {
      {
#line 2060
      tmp___3 = __gmpn_add_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
#line 2060
      if (tmp___3) {
        {
#line 2060
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2060
          if (__gmp_i >= __gmp_xsize) {
#line 2060
            __gmp_c = (mp_limb_t )1;
#line 2060
            goto __gmp_done;
          }
#line 2060
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2060
          tmp___1 = __gmp_i;
#line 2060
          __gmp_i ++;
#line 2060
          tmp___2 = (__gmp_x + 1UL) & 0xffffffffffffffffUL;
#line 2060
          *(__gmp_wp + tmp___1) = tmp___2;
#line 2060
          if (! (tmp___2 == 0UL)) {
#line 2060
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 2060
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
#line 2060
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2060
        __gmp_j = __gmp_i;
        {
#line 2060
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2060
          if (! (__gmp_j < __gmp_xsize)) {
#line 2060
            goto while_break___2;
          }
#line 2060
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2060
          __gmp_j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2060
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2060
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2060
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2061
  return (__gmp_c);
}
}
#line 2067 "/usr/include/gmp-x86_64.h"
__inline extern mp_limb_t __gmpn_add_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
#line 2073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2073
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2073
    __gmp_r = __gmp_x + __gmp_n;
#line 2073
    *(__gmp_dst + 0) = __gmp_r;
#line 2073
    if (__gmp_r < __gmp_n) {
#line 2073
      __gmp_c = (mp_limb_t )1;
#line 2073
      __gmp_i = (mp_size_t )1;
      {
#line 2073
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2073
        if (! (__gmp_i < __gmp_size)) {
#line 2073
          goto while_break___0;
        }
#line 2073
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2073
        __gmp_r = __gmp_x + 1UL;
#line 2073
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2073
        __gmp_i ++;
#line 2073
        if (! (__gmp_r < 1UL)) {
#line 2073
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
#line 2073
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2073
              __gmp_j = __gmp_i;
              {
#line 2073
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 2073
                if (! (__gmp_j < __gmp_size)) {
#line 2073
                  goto while_break___2;
                }
#line 2073
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2073
                __gmp_j ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2073
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 2073
          __gmp_c = (mp_limb_t )0;
#line 2073
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2073
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
#line 2073
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2073
          __gmp_j___0 = (mp_size_t )1;
          {
#line 2073
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2073
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2073
              goto while_break___4;
            }
#line 2073
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2073
            __gmp_j___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2073
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2073
      __gmp_c = (mp_limb_t )0;
    }
#line 2073
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2074
  return (__gmp_c);
}
}
#line 2080
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size )  __attribute__((__pure__)) ;
#line 2080 "/usr/include/gmp-x86_64.h"
__inline extern int __gmpn_cmp(mp_srcptr __gmp_xp , mp_srcptr __gmp_yp , mp_size_t __gmp_size ) 
{ 
  int __gmp_result ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_y ;

  {
  {
#line 2086
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2086
    __gmp_result = 0;
#line 2086
    __gmp_i = __gmp_size;
    {
#line 2086
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2086
      __gmp_i --;
#line 2086
      if (! (__gmp_i >= 0L)) {
#line 2086
        goto while_break___0;
      }
#line 2086
      __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2086
      __gmp_y = (mp_limb_t )*(__gmp_yp + __gmp_i);
#line 2086
      if (__gmp_x != __gmp_y) {
#line 2086
        if (__gmp_x > __gmp_y) {
#line 2086
          __gmp_result = 1;
        } else {
#line 2086
          __gmp_result = -1;
        }
#line 2086
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2086
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2087
  return (__gmp_result);
}
}
#line 2093 "/usr/include/gmp-x86_64.h"
__inline extern mp_limb_t __gmpn_sub(mp_ptr __gmp_wp , mp_srcptr __gmp_xp , mp_size_t __gmp_xsize ,
                                     mp_srcptr __gmp_yp , mp_size_t __gmp_ysize ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_size_t tmp___1 ;
  mp_limb_t tmp___2 ;
  mp_size_t __gmp_j ;

  {
  {
#line 2099
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2099
    __gmp_i = __gmp_ysize;
#line 2099
    if (__gmp_i != 0L) {
      {
#line 2099
      tmp___2 = __gmpn_sub_n(__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i);
      }
#line 2099
      if (tmp___2) {
        {
#line 2099
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2099
          if (__gmp_i >= __gmp_xsize) {
#line 2099
            __gmp_c = (mp_limb_t )1;
#line 2099
            goto __gmp_done;
          }
#line 2099
          __gmp_x = (mp_limb_t )*(__gmp_xp + __gmp_i);
#line 2099
          tmp___1 = __gmp_i;
#line 2099
          __gmp_i ++;
#line 2099
          *(__gmp_wp + tmp___1) = (__gmp_x - 1UL) & 0xffffffffffffffffUL;
#line 2099
          if (! (__gmp_x == 0UL)) {
#line 2099
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 2099
    if ((unsigned long )__gmp_wp != (unsigned long )__gmp_xp) {
      {
#line 2099
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2099
        __gmp_j = __gmp_i;
        {
#line 2099
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2099
          if (! (__gmp_j < __gmp_xsize)) {
#line 2099
            goto while_break___2;
          }
#line 2099
          *(__gmp_wp + __gmp_j) = (mp_limb_t )*(__gmp_xp + __gmp_j);
#line 2099
          __gmp_j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2099
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2099
    __gmp_c = (mp_limb_t )0;
    __gmp_done: ;
#line 2099
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2100
  return (__gmp_c);
}
}
#line 2106 "/usr/include/gmp-x86_64.h"
__inline extern mp_limb_t __gmpn_sub_1(mp_ptr __gmp_dst , mp_srcptr __gmp_src , mp_size_t __gmp_size ,
                                       mp_limb_t __gmp_n ) 
{ 
  mp_limb_t __gmp_c ;
  mp_size_t __gmp_i ;
  mp_limb_t __gmp_x ;
  mp_limb_t __gmp_r ;
  mp_size_t __gmp_j ;
  mp_size_t __gmp_j___0 ;

  {
  {
#line 2112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2112
    __gmp_x = (mp_limb_t )*(__gmp_src + 0);
#line 2112
    __gmp_r = __gmp_x - __gmp_n;
#line 2112
    *(__gmp_dst + 0) = __gmp_r;
#line 2112
    if (__gmp_x < __gmp_n) {
#line 2112
      __gmp_c = (mp_limb_t )1;
#line 2112
      __gmp_i = (mp_size_t )1;
      {
#line 2112
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2112
        if (! (__gmp_i < __gmp_size)) {
#line 2112
          goto while_break___0;
        }
#line 2112
        __gmp_x = (mp_limb_t )*(__gmp_src + __gmp_i);
#line 2112
        __gmp_r = __gmp_x - 1UL;
#line 2112
        *(__gmp_dst + __gmp_i) = __gmp_r;
#line 2112
        __gmp_i ++;
#line 2112
        if (! (__gmp_x < 1UL)) {
#line 2112
          if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
            {
#line 2112
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2112
              __gmp_j = __gmp_i;
              {
#line 2112
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 2112
                if (! (__gmp_j < __gmp_size)) {
#line 2112
                  goto while_break___2;
                }
#line 2112
                *(__gmp_dst + __gmp_j) = (mp_limb_t )*(__gmp_src + __gmp_j);
#line 2112
                __gmp_j ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2112
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 2112
          __gmp_c = (mp_limb_t )0;
#line 2112
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2112
      if ((unsigned long )__gmp_src != (unsigned long )__gmp_dst) {
        {
#line 2112
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2112
          __gmp_j___0 = (mp_size_t )1;
          {
#line 2112
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2112
            if (! (__gmp_j___0 < __gmp_size)) {
#line 2112
              goto while_break___4;
            }
#line 2112
            *(__gmp_dst + __gmp_j___0) = (mp_limb_t )*(__gmp_src + __gmp_j___0);
#line 2112
            __gmp_j___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2112
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2112
      __gmp_c = (mp_limb_t )0;
    }
#line 2112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2113
  return (__gmp_c);
}
}
#line 2119 "/usr/include/gmp-x86_64.h"
__inline extern mp_limb_t __gmpn_neg_n(mp_ptr __gmp_rp , mp_srcptr __gmp_up , mp_size_t __gmp_n ) 
{ 
  mp_limb_t __gmp_ul ;
  mp_limb_t __gmp_cy ;
  mp_srcptr tmp___1 ;
  mp_ptr tmp___2 ;

  {
#line 2125
  __gmp_cy = (mp_limb_t )0;
  {
#line 2126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2127
    tmp___1 = __gmp_up;
#line 2127
    __gmp_up ++;
#line 2127
    __gmp_ul = (mp_limb_t )*tmp___1;
#line 2128
    tmp___2 = __gmp_rp;
#line 2128
    __gmp_rp ++;
#line 2128
    *tmp___2 = - __gmp_ul - __gmp_cy;
#line 2129
    __gmp_cy |= (unsigned long )(__gmp_ul != 0UL);
#line 2126
    __gmp_n --;
#line 2126
    if (! (__gmp_n != 0L)) {
#line 2126
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2131
  return (__gmp_cy);
}
}
#line 1044 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *PROCINFO_node ;
#line 1047
NODE *Nnull_string ;
#line 1050
int sourceline ;
#line 1051
char *source ;
#line 1063
BLOCK nextfree[3] ;
#line 1066
int do_flags ;
#line 1068
SRCFILE *srcfiles ;
#line 1185
void r_unref(NODE *tmp___1 ) ;
#line 1286 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static void unref(NODE *r ) 
{ 


  {
#line 1289
  if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 1289
    (r->sub.val.sref) --;
#line 1289
    if (r->sub.val.sref <= 0L) {
      {
#line 1290
      r_unref(r);
      }
    }
  }
#line 1291
  return;
}
}
#line 1339
void null_array(NODE *symbol ) ;
#line 1341
char const   *make_aname(NODE const   *symbol ) ;
#line 1351
NODE **assoc_list(NODE *symbol , char const   *sort_str , sort_context_t sort_ctxt ) ;
#line 1373
void valinfo(NODE *n , int (*print_func)(FILE * , char const   *  , ...) , FILE *fp___0 ) ;
#line 1534
char *estrdup(char const   *str , size_t len ) ;
#line 1535
void update_global_values(void) ;
#line 1575
void set_loc(char const   *file , int line ) ;
#line 1576
 __attribute__((__noreturn__)) void ( /* format attribute */  r_fatal)(char const   *mesg 
                                                                       , ...) ;
#line 1595
NODE *r_dupnode(NODE *n ) ;
#line 1596
NODE *make_str_node(char const   *s___0 , size_t len , int flags___0 ) ;
#line 1597
void *more_blocks(int id ) ;
#line 1619
void refree(Regexp *rp ) ;
#line 1629
void load_symbols(void) ;
#line 1630
void init_symbol_table(void) ;
#line 1631 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *symbol_table  ;
#line 1632 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *func_table  ;
#line 1633
NODE *install_symbol(char *name , NODETYPE type ) ;
#line 1634
NODE *remove_symbol(NODE *r ) ;
#line 1635
void destroy_symbol(NODE *r ) ;
#line 1636
void release_symbols(NODE *symlist , int keep_globals ) ;
#line 1637
void append_symbol(NODE *r ) ;
#line 1638
NODE *lookup(char const   *name ) ;
#line 1639
NODE *make_params(char **pnames , int pcount ) ;
#line 1640
void install_params(NODE *func___1 ) ;
#line 1641
void remove_params(NODE *func___1 ) ;
#line 1642
void release_all_vars(void) ;
#line 1643
int foreach_func(NODE **table , int (*pfunc)(INSTRUCTION * , void * ) , void *data ) ;
#line 1644
INSTRUCTION *bcalloc(OPCODE op , int size , int srcline___0 ) ;
#line 1645
void bcfree(INSTRUCTION *cp ) ;
#line 1646
AWK_CONTEXT *new_context(void) ;
#line 1647
void push_context(AWK_CONTEXT *ctxt ) ;
#line 1648
void pop_context(void) ;
#line 1649
int in_main_context(void) ;
#line 1650
void free_context(AWK_CONTEXT *ctxt , _Bool keep_globals ) ;
#line 1651
NODE **variable_list(void) ;
#line 1652
NODE **function_list(_Bool sort ) ;
#line 1653
void print_vars(NODE **table , int (*print_func)(FILE * , char const   *  , ...) ,
                FILE *fp___0 ) ;
#line 1766 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static NODE *in_array(NODE *a , NODE *s___0 ) 
{ 
  NODE **ret ;
  NODE *tmp___1 ;

  {
  {
#line 1771
  ret = (*(*(a->sub.nodep.l.lp + 4)))(a, s___0);
  }
#line 1773
  if (ret) {
#line 1773
    tmp___1 = *ret;
  } else {
#line 1773
    tmp___1 = (NODE *)((void *)0);
  }
#line 1773
  return (tmp___1);
}
}
#line 1781 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static NODE *dupnode(NODE *n ) 
{ 
  NODE *tmp___1 ;

  {
#line 1784
  if ((n->flags & 1U) != 0U) {
#line 1785
    (n->sub.val.sref) ++;
#line 1786
    return (n);
  }
  {
#line 1788
  tmp___1 = r_dupnode(n);
  }
#line 1788
  return (tmp___1);
}
}
#line 29 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
INSTRUCTION *rule_list ;
#line 33 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static int func_count  ;
#line 34 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static int var_count  ;
#line 36 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static NODE *symbol_list  ;
#line 37 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static void (*install_func)(NODE * )  =    (void (*)(NODE * ))((void *)0);
#line 38
static NODE *make_symbol(char *name , NODETYPE type ) ;
#line 39
static NODE *install(char *name , NODE *parm , NODETYPE type ) ;
#line 40
static void free_bcpool(INSTRUCTION *pl ) ;
#line 42 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static AWK_CONTEXT *curr_ctxt  =    (AWK_CONTEXT *)((void *)0);
#line 43 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static int ctxt_level  ;
#line 45 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static NODE *global_table  ;
#line 45 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static NODE *param_table  ;
#line 49 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static _Bool installing_specials  =    (_Bool)0;
#line 53 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void init_symbol_table(void) 
{ 
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 56
  global_table = (NODE *)nextfree[1].freep;
#line 56
  if (global_table) {
#line 56
    nextfree[1].freep = ((BLOCK *)global_table)->freep;
  } else {
    {
#line 56
    tmp___1 = more_blocks(1);
#line 56
    global_table = (NODE *)tmp___1;
    }
  }
  {
#line 57
  memset((void *)global_table, '\000', sizeof(NODE ));
#line 58
  null_array(global_table);
#line 60
  param_table = (NODE *)nextfree[1].freep;
  }
#line 60
  if (param_table) {
#line 60
    nextfree[1].freep = ((BLOCK *)param_table)->freep;
  } else {
    {
#line 60
    tmp___2 = more_blocks(1);
#line 60
    param_table = (NODE *)tmp___2;
    }
  }
  {
#line 61
  memset((void *)param_table, '\000', sizeof(NODE ));
#line 62
  null_array(param_table);
#line 64
  installing_specials = (_Bool)1;
#line 65
  tmp___3 = estrdup("FUNCTAB", (size_t )7);
#line 65
  func_table = install_symbol(tmp___3, (NODETYPE )5);
#line 67
  tmp___4 = estrdup("SYMTAB", (size_t )6);
#line 67
  symbol_table = install_symbol(tmp___4, (NODETYPE )5);
#line 68
  installing_specials = (_Bool)0;
  }
#line 69
  return;
}
}
#line 77 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
NODE *install_symbol(char *name , NODETYPE type ) 
{ 
  NODE *tmp___1 ;

  {
  {
#line 80
  tmp___1 = install(name, (NODE *)((void *)0), type);
  }
#line 80
  return (tmp___1);
}
}
#line 89 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
NODE *lookup(char const   *name ) 
{ 
  NODE *n ;
  NODE *tmp___1 ;
  NODE *tables[5] ;
  int i___0 ;
  size_t tmp___2 ;
  void *__cil_tmp7 ;

  {
  {
#line 98
  tables[0] = param_table;
#line 99
  tables[1] = global_table;
#line 100
  tables[2] = func_table;
#line 101
  tables[3] = symbol_table;
#line 102
  tables[4] = (NODE *)((void *)0);
#line 104
  tmp___2 = strlen(name);
#line 104
  tmp___1 = make_str_node(name, tmp___2, 0);
#line 106
  n = (NODE *)((void *)0);
#line 107
  i___0 = 0;
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! ((unsigned long )tables[i___0] != (unsigned long )((void *)0))) {
#line 107
      goto while_break;
    }
#line 108
    if ((tables[i___0])->sub.nodep.reflags == 0UL) {
#line 109
      goto __Cont;
    }
#line 111
    if (do_flags & 16) {
#line 111
      goto _L;
    } else
#line 111
    if (do_flags & 8) {
      _L: /* CIL Label */ 
#line 111
      if ((unsigned long )tables[i___0] == (unsigned long )global_table) {
#line 112
        goto __Cont;
      }
    }
    {
#line 114
    n = in_array(tables[i___0], tmp___1);
    }
#line 115
    if ((unsigned long )n != (unsigned long )((void *)0)) {
      {
#line 116
      unref(tmp___1);
      }
#line 117
      return (n);
    }
    __Cont: /* CIL Label */ 
#line 107
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  unref(tmp___1);
  }
#line 122
  return (n);
}
}
#line 127 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
NODE *make_params(char **pnames , int pcount ) 
{ 
  NODE *p ;
  NODE *parms ;
  int i___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 133
  if (pcount <= 0) {
#line 134
    return ((NODE *)((void *)0));
  } else
#line 133
  if ((unsigned long )pnames == (unsigned long )((void *)0)) {
#line 134
    return ((NODE *)((void *)0));
  }
  {
#line 136
  tmp___1 = malloc((unsigned long )pcount * sizeof(NODE ));
#line 136
  parms = (NODE *)tmp___1;
  }
#line 136
  if (parms) {
#line 136
    tmp___5 = 1;
  } else {
    {
#line 136
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c", 136);
#line 136
    tmp___2 = __errno_location();
#line 136
    tmp___3 = strerror(*tmp___2);
#line 136
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 136
    r_fatal((char const   *)tmp___4, "make_params", "parms", (long )((unsigned long )pcount * sizeof(NODE )),
            tmp___3);
#line 136
    tmp___5 = 0;
    }
  }
  {
#line 137
  memset((void *)parms, '\000', (unsigned long )pcount * sizeof(NODE ));
#line 139
  i___0 = 0;
#line 139
  p = parms;
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i___0 < pcount)) {
#line 139
      goto while_break;
    }
#line 140
    p->type = (NODETYPE )7;
#line 141
    p->sub.nodep.name = *(pnames + i___0);
#line 142
    p->sub.nodep.l.ll = (long )i___0;
#line 139
    i___0 ++;
#line 139
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (parms);
}
}
#line 150 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void install_params(NODE *func___1 ) 
{ 
  int i___0 ;
  int pcount ;
  NODE *parms ;

  {
#line 156
  if ((unsigned long )func___1 == (unsigned long )((void *)0)) {
#line 157
    return;
  }
#line 159
  pcount = (int )func___1->sub.nodep.l.ll;
#line 159
  if (pcount <= 0) {
#line 162
    return;
  } else {
#line 159
    parms = func___1->sub.nodep.rn;
#line 159
    if ((unsigned long )parms == (unsigned long )((void *)0)) {
#line 162
      return;
    }
  }
#line 163
  i___0 = 0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i___0 < pcount)) {
#line 163
      goto while_break;
    }
    {
#line 164
    install((parms + i___0)->sub.nodep.name, parms + i___0, (NODETYPE )7);
#line 163
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return;
}
}
#line 172 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void remove_params(NODE *func___1 ) 
{ 
  NODE *parms ;
  NODE *p ;
  int i___0 ;
  int pcount ;
  NODE *tmp___1 ;
  NODE *tmp2 ;
  size_t tmp___2 ;
  struct exp_node **tmp___3 ;

  {
#line 178
  if ((unsigned long )func___1 == (unsigned long )((void *)0)) {
#line 179
    return;
  }
#line 181
  pcount = (int )func___1->sub.nodep.l.ll;
#line 181
  if (pcount <= 0) {
#line 184
    return;
  } else {
#line 181
    parms = func___1->sub.nodep.rn;
#line 181
    if ((unsigned long )parms == (unsigned long )((void *)0)) {
#line 184
      return;
    }
  }
#line 186
  i___0 = pcount - 1;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i___0 >= 0)) {
#line 186
      goto while_break;
    }
    {
#line 190
    p = parms + i___0;
#line 192
    tmp___2 = strlen((char const   *)p->sub.nodep.name);
#line 192
    tmp___1 = make_str_node((char const   *)p->sub.nodep.name, tmp___2, 0);
#line 193
    tmp2 = in_array(param_table, tmp___1);
    }
#line 194
    if ((unsigned long )tmp2 != (unsigned long )((void *)0)) {
#line 194
      if ((unsigned long )tmp2->sub.nodep.r.rptr != (unsigned long )((void *)0)) {
#line 195
        tmp2->sub.nodep.r.rptr = (tmp2->sub.nodep.r.rptr)->sub.nodep.r.rptr;
      } else {
        {
#line 197
        tmp___3 = (*(*(param_table->sub.nodep.l.lp + 6)))(param_table, tmp___1);
        }
      }
    } else {
      {
#line 197
      tmp___3 = (*(*(param_table->sub.nodep.l.lp + 6)))(param_table, tmp___1);
      }
    }
    {
#line 199
    unref(tmp___1);
#line 186
    i___0 --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  (*(*(param_table->sub.nodep.l.lp + 5)))(param_table, (struct exp_node *)((void *)0));
  }
#line 203
  return;
}
}
#line 208 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
NODE *remove_symbol(NODE *r ) 
{ 
  NODE *n ;
  NODE *tmp___1 ;
  struct exp_node **tmp___2 ;

  {
  {
#line 211
  tmp___1 = in_array(symbol_table, r);
#line 211
  n = tmp___1;
  }
#line 213
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 214
    return (n);
  }
  {
#line 216
  n = dupnode(n);
#line 218
  tmp___2 = (*(*(symbol_table->sub.nodep.l.lp + 6)))(symbol_table, r);
  }
#line 220
  return (n);
}
}
#line 228 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void destroy_symbol(NODE *r ) 
{ 
  NODE *n ;
  int i___0 ;
  int pcount ;

  {
  {
#line 231
  r = remove_symbol(r);
  }
#line 232
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 233
    return;
  }
  {
#line 236
  if ((unsigned int )r->type == 8U) {
#line 236
    goto case_8;
  }
#line 251
  if ((unsigned int )r->type == 9U) {
#line 251
    goto case_9;
  }
#line 255
  if ((unsigned int )r->type == 5U) {
#line 255
    goto case_5;
  }
#line 259
  if ((unsigned int )r->type == 4U) {
#line 259
    goto case_4;
  }
#line 263
  goto switch_default;
  case_8: /* CIL Label */ 
#line 237
  if (r->sub.nodep.l.ll > 0L) {
#line 240
    pcount = (int )r->sub.nodep.l.ll;
#line 243
    i___0 = 0;
    {
#line 243
    while (1) {
      while_continue: /* CIL Label */ ;
#line 243
      if (! (i___0 < pcount)) {
#line 243
        goto while_break;
      }
      {
#line 244
      n = r->sub.nodep.rn + i___0;
#line 245
      free((void *)n->sub.nodep.name);
#line 243
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 247
    free((void *)r->sub.nodep.rn);
    }
  }
#line 249
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 252
  bcfree(r->sub.nodep.r.iptr);
  }
#line 253
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 256
  (*(*(r->sub.nodep.l.lp + 5)))(r, (struct exp_node *)((void *)0));
  }
#line 257
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 260
  unref(r->sub.nodep.l.lptr);
  }
#line 261
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 265
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 268
  free((void *)r->sub.nodep.name);
#line 269
  ((BLOCK *)r)->freep = nextfree[1].freep;
#line 269
  nextfree[1].freep = (BLOCK *)r;
  }
#line 270
  return;
}
}
#line 275 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static NODE *make_symbol(char *name , NODETYPE type ) 
{ 
  NODE *r ;
  void *tmp___1 ;

  {
#line 280
  r = (NODE *)nextfree[1].freep;
#line 280
  if (r) {
#line 280
    nextfree[1].freep = ((BLOCK *)r)->freep;
  } else {
    {
#line 280
    tmp___1 = more_blocks(1);
#line 280
    r = (NODE *)tmp___1;
    }
  }
  {
#line 281
  memset((void *)r, '\000', sizeof(NODE ));
  }
#line 282
  if ((unsigned int )type == 5U) {
    {
#line 283
    null_array(r);
    }
  } else
#line 284
  if ((unsigned int )type == 4U) {
    {
#line 285
    r->sub.nodep.l.lptr = dupnode(Nnull_string);
    }
  }
#line 286
  r->sub.nodep.name = name;
#line 287
  r->type = type;
#line 289
  return (r);
}
}
#line 294 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static NODE *install(char *name , NODE *parm , NODETYPE type ) 
{ 
  NODE *r ;
  NODE **aptr ;
  NODE *table ;
  NODE *n_name ;
  NODE *prev ;
  size_t tmp___1 ;

  {
  {
#line 303
  tmp___1 = strlen((char const   *)name);
#line 303
  n_name = make_str_node((char const   *)name, tmp___1, 0);
#line 304
  table = symbol_table;
  }
#line 306
  if ((unsigned int )type == 7U) {
#line 307
    table = param_table;
  } else
#line 308
  if ((unsigned int )type == 8U) {
#line 309
    table = func_table;
  } else
#line 308
  if ((unsigned int )type == 9U) {
#line 309
    table = func_table;
  } else
#line 310
  if (installing_specials) {
#line 311
    table = global_table;
  }
#line 314
  if ((unsigned long )parm != (unsigned long )((void *)0)) {
#line 315
    r = parm;
  } else {
    {
#line 318
    r = make_symbol(name, type);
    }
#line 319
    if ((unsigned int )type == 8U) {
#line 320
      func_count ++;
    }
#line 321
    if ((unsigned int )type != 9U) {
#line 321
      if ((unsigned long )table != (unsigned long )global_table) {
#line 322
        var_count ++;
      }
    }
  }
#line 325
  if ((unsigned int )type == 7U) {
    {
#line 326
    prev = in_array(table, n_name);
    }
#line 327
    if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 328
      goto simple;
    }
#line 329
    r->sub.nodep.r.rptr = prev->sub.nodep.r.rptr;
#line 330
    prev->sub.nodep.r.rptr = r;
  } else {
    simple: 
    {
#line 334
    aptr = (*(*(table->sub.nodep.l.lp + 3)))(table, n_name);
#line 335
    unref(*aptr);
#line 336
    *aptr = r;
    }
  }
  {
#line 338
  unref(n_name);
  }
#line 340
  if (install_func) {
    {
#line 341
    (*install_func)(r);
    }
  }
#line 343
  return (r);
}
}
#line 349 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static int comp_symbol(void const   *v1 , void const   *v2 ) 
{ 
  NODE const   * const  *npp1 ;
  NODE const   * const  *npp2 ;
  NODE const   *n1 ;
  NODE const   *n2 ;
  int tmp___1 ;

  {
  {
#line 355
  npp1 = (NODE const   * const  *)v1;
#line 356
  npp2 = (NODE const   * const  *)v2;
#line 357
  n1 = (NODE const   *)*npp1;
#line 358
  n2 = (NODE const   *)*npp2;
#line 360
  tmp___1 = strcmp((char const   *)n1->sub.nodep.name, (char const   *)n2->sub.nodep.name);
  }
#line 360
  return (tmp___1);
}
}
#line 368 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static NODE **get_symbols(SYMBOL_TYPE what , _Bool sort ) 
{ 
  int i___0 ;
  NODE **table ;
  NODE **list ;
  NODE *r ;
  long count ;
  long max ;
  NODE *the_table ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 375
  count = 0L;
#line 386
  if ((unsigned int )what == 1U) {
    {
#line 387
    the_table = func_table;
#line 388
    max = (long )(the_table->sub.nodep.reflags * 2UL);
#line 390
    list = assoc_list(the_table, "@unsorted", (sort_context_t )3);
#line 391
    tmp___1 = malloc((unsigned long )(func_count + 1) * sizeof(NODE *));
#line 391
    table = (NODE **)tmp___1;
    }
#line 391
    if (table) {
#line 391
      tmp___5 = 1;
    } else {
      {
#line 391
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c", 391);
#line 391
      tmp___2 = __errno_location();
#line 391
      tmp___3 = strerror(*tmp___2);
#line 391
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 391
      r_fatal((char const   *)tmp___4, "get_symbols", "table", (long )((unsigned long )(func_count + 1) * sizeof(NODE *)),
              tmp___3);
#line 391
      tmp___5 = 0;
      }
    }
#line 393
    count = 0L;
#line 393
    i___0 = (int )count;
    {
#line 393
    while (1) {
      while_continue: /* CIL Label */ ;
#line 393
      if (! ((long )i___0 < max)) {
#line 393
        goto while_break;
      }
#line 394
      r = *(list + (i___0 + 1));
#line 395
      if ((unsigned int )r->type == 9U) {
#line 396
        goto __Cont;
      }
#line 398
      tmp___6 = count;
#line 398
      count ++;
#line 398
      *(table + tmp___6) = r;
      __Cont: /* CIL Label */ 
#line 393
      i___0 += 2;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 401
    update_global_values();
#line 403
    the_table = symbol_table;
#line 404
    max = (long )(the_table->sub.nodep.reflags * 2UL);
#line 406
    list = assoc_list(the_table, "@unsorted", (sort_context_t )3);
#line 407
    tmp___7 = malloc((unsigned long )(var_count + 1) * sizeof(NODE *));
#line 407
    table = (NODE **)tmp___7;
    }
#line 407
    if (table) {
#line 407
      tmp___11 = 1;
    } else {
      {
#line 407
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c", 407);
#line 407
      tmp___8 = __errno_location();
#line 407
      tmp___9 = strerror(*tmp___8);
#line 407
      tmp___10 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 407
      r_fatal((char const   *)tmp___10, "get_symbols", "table", (long )((unsigned long )(var_count + 1) * sizeof(NODE *)),
              tmp___9);
#line 407
      tmp___11 = 0;
      }
    }
#line 409
    count = 0L;
#line 409
    i___0 = (int )count;
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 409
      if (! ((long )i___0 < max)) {
#line 409
        goto while_break___0;
      }
#line 410
      r = *(list + (i___0 + 1));
#line 411
      if ((unsigned int )r->type == 1U) {
#line 412
        goto __Cont___0;
      }
#line 413
      tmp___12 = count;
#line 413
      count ++;
#line 413
      *(table + tmp___12) = r;
      __Cont___0: /* CIL Label */ 
#line 409
      i___0 += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 417
  free((void *)list);
  }
#line 419
  if (sort) {
#line 419
    if (count > 1L) {
      {
#line 420
      qsort((void *)table, (size_t )count, sizeof(NODE *), & comp_symbol);
      }
    }
  }
#line 421
  *(table + count) = (NODE *)((void *)0);
#line 422
  return (table);
}
}
#line 428 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
NODE **variable_list(void) 
{ 
  NODE **tmp___1 ;

  {
  {
#line 431
  tmp___1 = get_symbols((SYMBOL_TYPE )2, (_Bool)1);
  }
#line 431
  return (tmp___1);
}
}
#line 436 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
NODE **function_list(_Bool sort ) 
{ 
  NODE **tmp___1 ;

  {
  {
#line 439
  tmp___1 = get_symbols((SYMBOL_TYPE )1, sort);
  }
#line 439
  return (tmp___1);
}
}
#line 444 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void print_vars(NODE **table , int (*print_func)(FILE * , char const   *  , ...) ,
                FILE *fp___0 ) 
{ 
  int i___0 ;
  NODE *r ;
  struct exp_node **tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 452
  i___0 = 0;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    r = *(table + i___0);
#line 452
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 452
      goto while_break;
    }
#line 453
    if ((unsigned int )r->type == 8U) {
#line 454
      goto __Cont;
    } else
#line 453
    if ((unsigned int )r->type == 9U) {
#line 454
      goto __Cont;
    }
    {
#line 455
    (*print_func)(fp___0, "%s: ", r->sub.nodep.name);
    }
#line 456
    if ((unsigned int )r->type == 5U) {
      {
#line 457
      tmp___1 = (*(*(r->sub.nodep.l.lp + 2)))(r, (struct exp_node *)((void *)0));
#line 457
      (*print_func)(fp___0, "array, %ld elements\n", (*tmp___1)->sub.nodep.reflags);
      }
    } else
#line 458
    if ((unsigned int )r->type == 6U) {
      {
#line 459
      (*print_func)(fp___0, "untyped variable\n");
      }
    } else
#line 460
    if ((unsigned int )r->type == 4U) {
      {
#line 461
      valinfo(r->sub.nodep.l.lptr, print_func, fp___0);
      }
    }
    __Cont: /* CIL Label */ 
#line 452
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return;
}
}
#line 468 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
int foreach_func(NODE **table , int (*pfunc)(INSTRUCTION * , void * ) , void *data ) 
{ 
  int i___0 ;
  NODE *r ;
  int ret ;

  {
#line 473
  ret = 0;
#line 477
  i___0 = 0;
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    r = *(table + i___0);
#line 477
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 477
      goto while_break;
    }
    {
#line 478
    ret = (*pfunc)(r->sub.nodep.r.iptr, data);
    }
#line 478
    if (ret != 0) {
#line 479
      goto while_break;
    }
#line 477
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  return (ret);
}
}
#line 486 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void release_all_vars(void) 
{ 


  {
  {
#line 489
  (*(*(symbol_table->sub.nodep.l.lp + 5)))(symbol_table, (struct exp_node *)((void *)0));
#line 490
  (*(*(func_table->sub.nodep.l.lp + 5)))(func_table, (struct exp_node *)((void *)0));
#line 491
  (*(*(global_table->sub.nodep.l.lp + 5)))(global_table, (struct exp_node *)((void *)0));
  }
#line 492
  return;
}
}
#line 499 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void append_symbol(NODE *r ) 
{ 
  NODE *p ;
  void *tmp___1 ;

  {
#line 504
  p = (NODE *)nextfree[1].freep;
#line 504
  if (p) {
#line 504
    nextfree[1].freep = ((BLOCK *)p)->freep;
  } else {
    {
#line 504
    tmp___1 = more_blocks(1);
#line 504
    p = (NODE *)tmp___1;
    }
  }
#line 505
  p->sub.nodep.l.lptr = r;
#line 506
  p->sub.nodep.r.rptr = symbol_list->sub.nodep.r.rptr;
#line 507
  symbol_list->sub.nodep.r.rptr = p;
#line 508
  return;
}
}
#line 512 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void release_symbols(NODE *symlist , int keep_globals ) 
{ 
  NODE *p ;
  NODE *next ;

  {
#line 517
  p = symlist->sub.nodep.r.rptr;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 517
      goto while_break;
    }
#line 518
    if (! keep_globals) {
      {
#line 522
      destroy_symbol(p->sub.nodep.l.lptr);
      }
    }
#line 524
    next = p->sub.nodep.r.rptr;
#line 525
    ((BLOCK *)p)->freep = nextfree[1].freep;
#line 525
    nextfree[1].freep = (BLOCK *)p;
#line 517
    p = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  symlist->sub.nodep.r.rptr = (struct exp_node *)((void *)0);
#line 528
  return;
}
}
#line 532 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void load_symbols(void) 
{ 
  NODE *r ;
  NODE *tmp___1 ;
  NODE *sym_array ;
  NODE **aptr ;
  long i___0 ;
  long j ;
  long max ;
  NODE *user ;
  NODE *extension ;
  NODE *untyped ;
  NODE *scalar ;
  NODE *array ;
  NODE **list ;
  NODE *tables[4] ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 544
  if ((unsigned long )PROCINFO_node == (unsigned long )((void *)0)) {
#line 545
    return;
  }
  {
#line 547
  tables[0] = func_table;
#line 548
  tables[1] = symbol_table;
#line 549
  tables[2] = global_table;
#line 550
  tables[3] = (NODE *)((void *)0);
#line 552
  tmp___1 = make_str_node("identifiers", (size_t )11, 0);
#line 553
  aptr = (*(*(PROCINFO_node->sub.nodep.l.lp + 3)))(PROCINFO_node, tmp___1);
#line 555
  sym_array = (NODE *)nextfree[1].freep;
  }
#line 555
  if (sym_array) {
#line 555
    nextfree[1].freep = ((BLOCK *)sym_array)->freep;
  } else {
    {
#line 555
    tmp___2 = more_blocks(1);
#line 555
    sym_array = (NODE *)tmp___2;
    }
  }
  {
#line 556
  memset((void *)sym_array, '\000', sizeof(NODE ));
#line 557
  null_array(sym_array);
#line 559
  unref(*aptr);
#line 560
  *aptr = sym_array;
#line 562
  sym_array->sub.nodep.x.extra = PROCINFO_node;
#line 563
  sym_array->sub.nodep.name = estrdup("identifiers", (size_t )11);
#line 564
  make_aname((NODE const   *)sym_array);
#line 566
  user = make_str_node("user", (size_t )4, 0);
#line 567
  extension = make_str_node("extension", (size_t )9, 0);
#line 568
  scalar = make_str_node("scalar", (size_t )6, 0);
#line 569
  untyped = make_str_node("untyped", (size_t )7, 0);
#line 570
  array = make_str_node("array", (size_t )5, 0);
#line 572
  i___0 = 0L;
  }
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    if (! ((unsigned long )tables[i___0] != (unsigned long )((void *)0))) {
#line 572
      goto while_break;
    }
    {
#line 573
    list = assoc_list(tables[i___0], "@unsorted", (sort_context_t )3);
#line 574
    max = (long )((tables[i___0])->sub.nodep.reflags * 2UL);
    }
#line 575
    if (max == 0L) {
#line 576
      goto __Cont;
    }
#line 577
    j = 0L;
    {
#line 577
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 577
      if (! (j < max)) {
#line 577
        goto while_break___0;
      }
#line 578
      r = *(list + (j + 1L));
#line 579
      if ((unsigned int )r->type == 9U) {
#line 579
        goto _L;
      } else
#line 579
      if ((unsigned int )r->type == 8U) {
#line 579
        goto _L;
      } else
#line 579
      if ((unsigned int )r->type == 4U) {
#line 579
        goto _L;
      } else
#line 579
      if ((unsigned int )r->type == 5U) {
#line 579
        goto _L;
      } else
#line 579
      if ((unsigned int )r->type == 6U) {
        _L: /* CIL Label */ 
        {
#line 584
        tmp___3 = strlen((char const   *)r->sub.nodep.name);
#line 584
        tmp___1 = make_str_node((char const   *)r->sub.nodep.name, tmp___3, 0);
#line 585
        aptr = (*(*(sym_array->sub.nodep.l.lp + 3)))(sym_array, tmp___1);
#line 586
        unref(tmp___1);
#line 587
        unref(*aptr);
        }
        {
#line 589
        if ((unsigned int )r->type == 9U) {
#line 589
          goto case_9;
        }
#line 592
        if ((unsigned int )r->type == 8U) {
#line 592
          goto case_8;
        }
#line 595
        if ((unsigned int )r->type == 4U) {
#line 595
          goto case_4;
        }
#line 598
        if ((unsigned int )r->type == 5U) {
#line 598
          goto case_5;
        }
#line 601
        if ((unsigned int )r->type == 6U) {
#line 601
          goto case_6;
        }
#line 604
        goto switch_default;
        case_9: /* CIL Label */ 
        {
#line 590
        *aptr = dupnode(extension);
        }
#line 591
        goto switch_break;
        case_8: /* CIL Label */ 
        {
#line 593
        *aptr = dupnode(user);
        }
#line 594
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 596
        *aptr = dupnode(scalar);
        }
#line 597
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 599
        *aptr = dupnode(array);
        }
#line 600
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 602
        *aptr = dupnode(untyped);
        }
#line 603
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 605
        r_fatal("internal error line %d, file: %s", 605, "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c");
        }
#line 606
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 577
      j += 2L;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 610
    free((void *)list);
    }
    __Cont: /* CIL Label */ 
#line 572
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  unref(user);
#line 614
  unref(extension);
#line 615
  unref(scalar);
#line 616
  unref(untyped);
#line 617
  unref(array);
  }
#line 618
  return;
}
}
#line 622 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static INSTRUCTION *pool_list  ;
#line 629 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void bcfree(INSTRUCTION *cp ) 
{ 


  {
#line 632
  cp->opcode = (OPCODE )0;
#line 633
  cp->nexti = pool_list->x.xi;
#line 634
  pool_list->x.xi = cp;
#line 635
  return;
}
}
#line 639 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
INSTRUCTION *bcalloc(OPCODE op , int size , int srcline___0 ) 
{ 
  INSTRUCTION *cp ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  INSTRUCTION *tmp___6 ;
  INSTRUCTION *pool ;
  INSTRUCTION *last ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 644
  if (size > 1) {
    {
#line 646
    tmp___1 = malloc((unsigned long )(size + 1) * sizeof(INSTRUCTION ));
#line 646
    cp = (INSTRUCTION *)tmp___1;
    }
#line 646
    if (cp) {
#line 646
      tmp___5 = 1;
    } else {
      {
#line 646
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c", 646);
#line 646
      tmp___2 = __errno_location();
#line 646
      tmp___3 = strerror(*tmp___2);
#line 646
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 646
      r_fatal((char const   *)tmp___4, "bcalloc", "cp", (long )((unsigned long )(size + 1) * sizeof(INSTRUCTION )),
              tmp___3);
#line 646
      tmp___5 = 0;
      }
    }
#line 647
    cp->d.dl = (long )size;
#line 648
    cp->nexti = pool_list->nexti;
#line 649
    tmp___6 = cp;
#line 649
    cp ++;
#line 649
    pool_list->nexti = tmp___6;
  } else {
#line 653
    pool = pool_list->x.xi;
#line 654
    if ((unsigned long )pool == (unsigned long )((void *)0)) {
      {
#line 656
      tmp___7 = malloc(128UL * sizeof(INSTRUCTION ));
#line 656
      cp = (INSTRUCTION *)tmp___7;
      }
#line 656
      if (cp) {
#line 656
        tmp___11 = 1;
      } else {
        {
#line 656
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c", 656);
#line 656
        tmp___8 = __errno_location();
#line 656
        tmp___9 = strerror(*tmp___8);
#line 656
        tmp___10 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 656
        r_fatal((char const   *)tmp___10, "bcalloc", "cp", (long )(128UL * sizeof(INSTRUCTION )),
                tmp___9);
#line 656
        tmp___11 = 0;
        }
      }
#line 658
      cp->d.dl = 127L;
#line 659
      cp->nexti = pool_list->nexti;
#line 660
      pool_list->nexti = cp;
#line 661
      cp ++;
#line 661
      pool = cp;
#line 662
      last = pool + 126;
      {
#line 663
      while (1) {
        while_continue: /* CIL Label */ ;
#line 663
        if (! ((unsigned long )cp <= (unsigned long )last)) {
#line 663
          goto while_break;
        }
#line 664
        cp->opcode = (OPCODE )0;
#line 665
        cp->nexti = cp + 1;
#line 663
        cp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 667
      cp --;
#line 668
      cp->nexti = (struct exp_instruction *)((void *)0);
    }
#line 670
    cp = pool;
#line 671
    pool_list->x.xi = cp->nexti;
  }
  {
#line 674
  memset((void *)cp, 0, (unsigned long )size * sizeof(INSTRUCTION ));
#line 675
  cp->opcode = op;
#line 676
  cp->source_line = (short )srcline___0;
  }
#line 677
  return (cp);
}
}
#line 682 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
AWK_CONTEXT *new_context(void) 
{ 
  AWK_CONTEXT *ctxt ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  struct srcfile *tmp___6 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 687
  tmp___1 = malloc(sizeof(AWK_CONTEXT ));
#line 687
  ctxt = (AWK_CONTEXT *)tmp___1;
  }
#line 687
  if (ctxt) {
#line 687
    tmp___5 = 1;
  } else {
    {
#line 687
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c", 687);
#line 687
    tmp___2 = __errno_location();
#line 687
    tmp___3 = strerror(*tmp___2);
#line 687
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 687
    r_fatal((char const   *)tmp___4, "new_context", "ctxt", (long )sizeof(AWK_CONTEXT ),
            tmp___3);
#line 687
    tmp___5 = 0;
    }
  }
  {
#line 688
  memset((void *)ctxt, 0, sizeof(AWK_CONTEXT ));
#line 689
  tmp___6 = & ctxt->srcfiles;
#line 689
  ctxt->srcfiles.prev = tmp___6;
#line 689
  ctxt->srcfiles.next = tmp___6;
#line 690
  ctxt->rule_list.opcode = (OPCODE )105;
#line 691
  ctxt->rule_list.d.di = & ctxt->rule_list;
  }
#line 692
  return (ctxt);
}
}
#line 697 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static void set_context(AWK_CONTEXT *ctxt ) 
{ 


  {
#line 700
  pool_list = & ctxt->pools;
#line 701
  symbol_list = & ctxt->symbols;
#line 702
  srcfiles = & ctxt->srcfiles;
#line 703
  rule_list = & ctxt->rule_list;
#line 704
  install_func = ctxt->install_func;
#line 705
  curr_ctxt = ctxt;
#line 706
  return;
}
}
#line 716 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void push_context(AWK_CONTEXT *ctxt ) 
{ 


  {
#line 719
  ctxt->prev = curr_ctxt;
#line 721
  if ((unsigned long )curr_ctxt != (unsigned long )((void *)0)) {
#line 722
    curr_ctxt->sourceline = sourceline;
#line 723
    curr_ctxt->source = source;
  }
  {
#line 725
  sourceline = 0;
#line 726
  source = (char *)((void *)0);
#line 727
  set_context(ctxt);
#line 728
  ctxt_level ++;
  }
#line 729
  return;
}
}
#line 733 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void pop_context(void) 
{ 
  AWK_CONTEXT *ctxt ;
  char *tmp___1 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 739
  if ((unsigned long )curr_ctxt->prev == (unsigned long )((void *)0)) {
    {
#line 740
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c", 740);
#line 740
    tmp___1 = gettext("can not pop main context");
#line 740
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 741
  ctxt = curr_ctxt->prev;
#line 743
  sourceline = ctxt->sourceline;
#line 744
  source = ctxt->source;
#line 745
  set_context(ctxt);
#line 746
  ctxt_level --;
  }
#line 747
  return;
}
}
#line 751 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
int in_main_context(void) 
{ 


  {
#line 755
  return (ctxt_level == 1);
}
}
#line 760 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
void free_context(AWK_CONTEXT *ctxt , _Bool keep_globals ) 
{ 
  SRCFILE *s___0 ;
  SRCFILE *sn ;

  {
#line 765
  if ((unsigned long )ctxt == (unsigned long )((void *)0)) {
#line 766
    return;
  }
  {
#line 772
  free_bcpool(& ctxt->pools);
#line 776
  release_symbols(& ctxt->symbols, (int )keep_globals);
#line 780
  s___0 = & ctxt->srcfiles;
  }
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 780
    if (! ((unsigned long )s___0 != (unsigned long )(& ctxt->srcfiles))) {
#line 780
      goto while_break;
    }
#line 781
    sn = s___0->next;
#line 782
    if ((unsigned int )s___0->stype != 1U) {
#line 782
      if ((unsigned int )s___0->stype != 2U) {
        {
#line 783
        free((void *)s___0->fullpath);
        }
      }
    }
    {
#line 784
    free((void *)s___0->src);
#line 785
    free((void *)s___0);
#line 780
    s___0 = sn;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 788
  free((void *)ctxt);
  }
#line 789
  return;
}
}
#line 793 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static void free_bc_internal(INSTRUCTION *cp ) 
{ 
  NODE *m ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 799
  if ((unsigned int )cp->opcode == 70U) {
#line 799
    goto case_70;
  }
#line 806
  if ((unsigned int )cp->opcode == 48U) {
#line 806
    goto case_48;
  }
#line 806
  if ((unsigned int )cp->opcode == 46U) {
#line 806
    goto case_48;
  }
#line 806
  if ((unsigned int )cp->opcode == 47U) {
#line 806
    goto case_48;
  }
#line 806
  if ((unsigned int )cp->opcode == 75U) {
#line 806
    goto case_48;
  }
#line 816
  if ((unsigned int )cp->opcode == 103U) {
#line 816
    goto case_103;
  }
#line 821
  if ((unsigned int )cp->opcode == 74U) {
#line 821
    goto case_74;
  }
#line 825
  if ((unsigned int )cp->opcode == 26U) {
#line 825
    goto case_26;
  }
#line 830
  if ((unsigned int )cp->opcode == 0U) {
#line 830
    goto case_0;
  }
#line 832
  goto switch_default;
  case_70: /* CIL Label */ 
#line 800
  if ((unsigned long )cp->d.name != (unsigned long )((void *)0)) {
    {
#line 801
    free((void *)cp->d.name);
    }
  }
#line 802
  goto switch_break;
  case_48: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_75: /* CIL Label */ 
#line 807
  m = cp->d.dn;
#line 808
  if ((unsigned long )m->sub.nodep.r.preg != (unsigned long )((void *)0)) {
    {
#line 809
    refree(m->sub.nodep.r.preg);
    }
  }
#line 810
  if ((unsigned long )m->sub.nodep.x.extra != (unsigned long )((void *)0)) {
    {
#line 811
    unref(m->sub.nodep.x.extra);
    }
  }
#line 812
  if ((unsigned long )m->sub.nodep.l.lptr != (unsigned long )((void *)0)) {
    {
#line 813
    unref(m->sub.nodep.l.lptr);
    }
  }
#line 814
  ((BLOCK *)m)->freep = nextfree[1].freep;
#line 814
  nextfree[1].freep = (BLOCK *)m;
#line 815
  goto switch_break;
  case_103: /* CIL Label */ 
#line 818
  if ((unsigned long )cp->d.name != (unsigned long )((void *)0)) {
    {
#line 819
    free((void *)cp->d.name);
    }
  }
#line 820
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 822
  m = cp->d.dn;
#line 823
  unref(m);
  }
#line 824
  goto switch_break;
  case_26: /* CIL Label */ 
#line 826
  m = cp->x.xn;
#line 827
  if ((unsigned long )m != (unsigned long )((void *)0)) {
    {
#line 828
    unref(m);
    }
  }
#line 829
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 831
  r_fatal("internal error line %d, file: %s", 831, "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c");
  }
  switch_default: /* CIL Label */ 
#line 833
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 835
  return;
}
}
#line 839 "/home/wslee/gnu_benchmarks/gawk-4.1.0/symbol.c"
static void free_bcpool(INSTRUCTION *pl ) 
{ 
  INSTRUCTION *pool ;
  INSTRUCTION *tmp___1 ;
  INSTRUCTION *cp ;
  INSTRUCTION *last ;
  long psiz ;

  {
#line 844
  pool = pl->nexti;
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if (! ((unsigned long )pool != (unsigned long )((void *)0))) {
#line 844
      goto while_break;
    }
#line 847
    psiz = pool->d.dl;
#line 848
    if (psiz == 127L) {
#line 849
      last = pool + psiz;
    } else {
#line 851
      last = pool + 1;
    }
#line 852
    cp = pool + 1;
    {
#line 852
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 852
      if (! ((unsigned long )cp <= (unsigned long )last)) {
#line 852
        goto while_break___0;
      }
#line 853
      if ((unsigned int )cp->opcode != 0U) {
        {
#line 854
        free_bc_internal(cp);
        }
      }
#line 852
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 856
    tmp___1 = pool->nexti;
#line 857
    free((void *)pool);
#line 844
    pool = tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 859
  memset((void *)pl, 0, sizeof(INSTRUCTION ));
  }
#line 860
  return;
}
}
#line 333 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 1037 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
char *CONVFMT ;
#line 1038
int CONVFMTidx ;
#line 1054
NODE *(*str2number)(NODE * ) ;
#line 1055
NODE *(*format_val)(char const   * , int  , NODE * ) ;
#line 1059
afunc_t str_array_func[11] ;
#line 1271 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static NODE *force_string(NODE *s___0 ) 
{ 
  NODE *tmp___1 ;

  {
#line 1274
  if ((s___0->flags & 4U) != 0U) {
#line 1274
    if (s___0->sub.val.idx == -1) {
#line 1277
      return (s___0);
    } else
#line 1274
    if (s___0->sub.val.idx == CONVFMTidx) {
#line 1277
      return (s___0);
    }
  }
  {
#line 1278
  tmp___1 = (*format_val)((char const   *)CONVFMT, CONVFMTidx, s___0);
  }
#line 1278
  return (tmp___1);
}
}
#line 1293 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static NODE *force_number(NODE *n ) 
{ 
  NODE *tmp___1 ;
  NODE *tmp___2 ;

  {
#line 1296
  if (n->flags & 8U) {
#line 1296
    tmp___2 = n;
  } else {
    {
#line 1296
    tmp___1 = (*str2number)(n);
#line 1296
    tmp___2 = tmp___1;
    }
  }
#line 1296
  return (tmp___2);
}
}
#line 1338
NODE *make_array(void) ;
#line 1342
char const   *array_vname(NODE const   *symbol ) ;
#line 1345
NODE **null_length(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) ;
#line 1349
NODE *assoc_copy(NODE *symbol , NODE *newsymb ) ;
#line 1352
void assoc_info(NODE *subs , NODE *val , NODE *ndump___0 , char const   *aname___0 ) ;
#line 1359
unsigned long (*hash)(char const   *s , size_t len , unsigned long hsize , size_t *code ) ;
#line 1441
char const   *flags2str(int flagval ) ;
#line 1536
long getenv_long(char const   *name ) ;
#line 44 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static size_t STR_CHAIN_MAX  =    (size_t )2;
#line 46
FILE *output_fp ;
#line 47
void indent(int indent_level___0 ) ;
#line 49
static NODE **str_array_init(NODE *symbol  __attribute__((__unused__)) , NODE *subs  __attribute__((__unused__)) ) ;
#line 50
static NODE **str_lookup(NODE *symbol , NODE *subs ) ;
#line 51
static NODE **str_exists(NODE *symbol , NODE *subs ) ;
#line 52
static NODE **str_clear(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) ;
#line 53
static NODE **str_remove(NODE *symbol , NODE *subs ) ;
#line 54
static NODE **str_list(NODE *symbol , NODE *t ) ;
#line 55
static NODE **str_copy(NODE *symbol , NODE *newsymb ) ;
#line 56
static NODE **str_dump(NODE *symbol , NODE *ndump___0 ) ;
#line 58 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
afunc_t str_array_func[11]  = 
#line 58
  {      & str_array_init,      (struct exp_node **(*)(struct exp_node * , struct exp_node * ))0,      & null_length,      & str_lookup, 
        & str_exists,      & str_clear,      & str_remove,      & str_list, 
        & str_copy,      & str_dump,      (struct exp_node **(*)(struct exp_node * , struct exp_node * ))0};
#line 72
__inline static NODE **str_find(NODE *symbol , NODE *s1 , size_t code1 , unsigned long hash1 ) ;
#line 73
static void grow_table(NODE *symbol ) ;
#line 75
static unsigned long gst_hash_string(char const   *str , size_t len , unsigned long hsize ,
                                     size_t *code ) ;
#line 76
static unsigned long scramble(unsigned long x ) ;
#line 77
static unsigned long awk_hash(char const   *s___0 , size_t len , unsigned long hsize ,
                              size_t *code ) ;
#line 79 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
unsigned long (*hash)(char const   *s , size_t len , unsigned long hsize , size_t *code )  =    & awk_hash;
#line 84 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static NODE **str_array_init(NODE *symbol  __attribute__((__unused__)) , NODE *subs  __attribute__((__unused__)) ) 
{ 
  long newval ;
  char const   *val ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 87
  if ((unsigned long )symbol == (unsigned long )((void *)0)) {
    {
#line 92
    newval = getenv_long("STR_CHAIN_MAX");
    }
#line 92
    if (newval > 0L) {
#line 93
      STR_CHAIN_MAX = (size_t )newval;
    }
    {
#line 94
    tmp___1 = getenv("AWK_HASH");
#line 94
    val = (char const   *)tmp___1;
    }
#line 94
    if ((unsigned long )val != (unsigned long )((void *)0)) {
      {
#line 94
      tmp___2 = strcmp(val, "gst");
      }
#line 94
      if (tmp___2 == 0) {
#line 95
        hash = & gst_hash_string;
      }
    }
  } else {
    {
#line 97
    null_array(symbol);
    }
  }
#line 99
  return ((NODE **)(! ((void *)0)));
}
}
#line 112 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static NODE **str_lookup(NODE *symbol , NODE *subs ) 
{ 
  unsigned long hash1 ;
  NODE **lhs ;
  BUCKET *b___0 ;
  size_t code1 ;
  NODE *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 120
  subs = force_string(subs);
  }
#line 122
  if ((unsigned long )symbol->sub.nodep.r.bv == (unsigned long )((void *)0)) {
    {
#line 123
    grow_table(symbol);
    }
  }
  {
#line 124
  hash1 = (*hash)((char const   *)subs->sub.val.sp, subs->sub.val.slen, symbol->sub.nodep.cnt,
                  & code1);
#line 126
  lhs = str_find(symbol, subs, code1, hash1);
  }
#line 126
  if ((unsigned long )lhs != (unsigned long )((void *)0)) {
#line 127
    return (lhs);
  }
#line 132
  (symbol->sub.nodep.reflags) ++;
#line 133
  if ((symbol->flags & 16384U) == 0U) {
#line 133
    if (symbol->sub.nodep.reflags / symbol->sub.nodep.cnt > STR_CHAIN_MAX) {
      {
#line 135
      grow_table(symbol);
#line 137
      hash1 = code1 % symbol->sub.nodep.cnt;
      }
    }
  }
#line 140
  if (subs->sub.val.idx != -1) {
    {
#line 150
    tmp___1 = make_str_node((char const   *)subs->sub.val.sp, subs->sub.val.slen,
                            0);
    }
#line 160
    if ((subs->flags & 6152U) == 8U) {
#line 161
      tmp___1->sub.val.nm.fltnum = subs->sub.val.nm.fltnum;
#line 162
      tmp___1->flags |= 8U;
    }
#line 164
    subs = tmp___1;
  } else {
    {
#line 168
    subs = dupnode(subs);
    }
  }
#line 171
  b___0 = (BUCKET *)nextfree[2].freep;
#line 171
  if (b___0) {
#line 171
    nextfree[2].freep = ((BLOCK *)b___0)->freep;
  } else {
    {
#line 171
    tmp___2 = more_blocks(2);
#line 171
    b___0 = (BUCKET *)tmp___2;
    }
  }
  {
#line 172
  b___0->hs.next = *(symbol->sub.nodep.r.bv + hash1);
#line 173
  *(symbol->sub.nodep.r.bv + hash1) = b___0;
#line 174
  b___0->hs.name = subs;
#line 175
  b___0->hs.str = subs->sub.val.sp;
#line 176
  b___0->hs.len = subs->sub.val.slen;
#line 177
  b___0->hs.val = dupnode(Nnull_string);
#line 178
  b___0->hs.code = code1;
  }
#line 179
  return (& b___0->hs.val);
}
}
#line 186 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static NODE **str_exists(NODE *symbol , NODE *subs ) 
{ 
  unsigned long hash1 ;
  size_t code1 ;
  NODE **tmp___1 ;

  {
#line 192
  if (symbol->sub.nodep.reflags == 0UL) {
#line 193
    return ((NODE **)((void *)0));
  }
  {
#line 195
  subs = force_string(subs);
#line 196
  hash1 = (*hash)((char const   *)subs->sub.val.sp, subs->sub.val.slen, symbol->sub.nodep.cnt,
                  & code1);
#line 197
  tmp___1 = str_find(symbol, subs, code1, hash1);
  }
#line 197
  return (tmp___1);
}
}
#line 202 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static NODE **str_clear(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) 
{ 
  unsigned long i___0 ;
  BUCKET *b___0 ;
  BUCKET *next ;
  NODE *r ;

  {
#line 209
  i___0 = 0UL;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i___0 < symbol->sub.nodep.cnt)) {
#line 209
      goto while_break;
    }
#line 210
    b___0 = *(symbol->sub.nodep.r.bv + i___0);
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 210
      if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 210
        goto while_break___0;
      }
#line 211
      next = b___0->hs.next;
#line 212
      r = b___0->hs.val;
#line 213
      if ((unsigned int )r->type == 5U) {
        {
#line 214
        (*(*(r->sub.nodep.l.lp + 5)))(r, (struct exp_node *)((void *)0));
#line 215
        free((void *)r->sub.nodep.name);
#line 216
        ((BLOCK *)r)->freep = nextfree[1].freep;
#line 216
        nextfree[1].freep = (BLOCK *)r;
        }
      } else {
        {
#line 218
        unref(r);
        }
      }
      {
#line 219
      unref(b___0->hs.name);
#line 220
      ((BLOCK *)b___0)->freep = nextfree[2].freep;
#line 220
      nextfree[2].freep = (BLOCK *)b___0;
#line 210
      b___0 = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 222
    *(symbol->sub.nodep.r.bv + i___0) = (BUCKET *)((void *)0);
#line 209
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if ((unsigned long )symbol->sub.nodep.r.bv != (unsigned long )((void *)0)) {
    {
#line 226
    free((void *)symbol->sub.nodep.r.bv);
    }
  }
  {
#line 227
  (*(*(symbol->sub.nodep.l.lp + 0)))(symbol, (struct exp_node *)((void *)0));
  }
#line 228
  return ((NODE **)((void *)0));
}
}
#line 234 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static NODE **str_remove(NODE *symbol , NODE *subs ) 
{ 
  unsigned long hash1 ;
  BUCKET *b___0 ;
  BUCKET *prev ;
  NODE *s2 ;
  size_t s1_len ;
  int tmp___1 ;

  {
#line 242
  if (symbol->sub.nodep.reflags == 0UL) {
#line 243
    return ((NODE **)((void *)0));
  }
  {
#line 245
  s2 = force_string(subs);
#line 246
  hash1 = (*hash)((char const   *)s2->sub.val.sp, s2->sub.val.slen, symbol->sub.nodep.cnt,
                  (size_t *)((void *)0));
#line 248
  b___0 = *(symbol->sub.nodep.r.bv + hash1);
#line 248
  prev = (BUCKET *)((void *)0);
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 248
      goto while_break;
    }
#line 252
    s1_len = b___0->hs.len;
#line 254
    if (s1_len != s2->sub.val.slen) {
#line 255
      goto __Cont;
    }
#line 256
    if (s1_len == 0UL) {
#line 256
      goto _L;
    } else {
      {
#line 256
      tmp___1 = memcmp((void const   *)b___0->hs.str, (void const   *)s2->sub.val.sp,
                       s1_len);
      }
#line 256
      if (tmp___1 == 0) {
        _L: /* CIL Label */ 
        {
#line 260
        unref(b___0->hs.name);
        }
#line 261
        if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 262
          prev->hs.next = b___0->hs.next;
        } else {
#line 264
          *(symbol->sub.nodep.r.bv + hash1) = b___0->hs.next;
        }
#line 267
        ((BLOCK *)b___0)->freep = nextfree[2].freep;
#line 267
        nextfree[2].freep = (BLOCK *)b___0;
#line 270
        (symbol->sub.nodep.reflags) --;
#line 270
        if (symbol->sub.nodep.reflags == 0UL) {
#line 271
          if ((unsigned long )symbol->sub.nodep.r.bv != (unsigned long )((void *)0)) {
            {
#line 272
            free((void *)symbol->sub.nodep.r.bv);
            }
          }
          {
#line 273
          (*(*(symbol->sub.nodep.l.lp + 0)))(symbol, (struct exp_node *)((void *)0));
          }
        }
#line 276
        return ((NODE **)(! ((void *)0)));
      }
    }
    __Cont: /* CIL Label */ 
#line 248
    prev = b___0;
#line 248
    b___0 = b___0->hs.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return ((NODE **)((void *)0));
}
}
#line 286 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static NODE **str_copy(NODE *symbol , NODE *newsymb ) 
{ 
  BUCKET **old ;
  BUCKET **new ;
  BUCKET **pnew ;
  BUCKET *chain ;
  BUCKET *newchain ;
  unsigned long cursize ;
  unsigned long i___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  NODE *oldval ;
  NODE *newsubs ;
  void *tmp___6 ;
  struct exp_node *tmp___7 ;
  NODE *r ;
  size_t tmp___8 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 296
  cursize = symbol->sub.nodep.cnt;
#line 299
  tmp___1 = malloc(cursize * sizeof(BUCKET *));
#line 299
  new = (BUCKET **)tmp___1;
  }
#line 299
  if (new) {
#line 299
    tmp___5 = 1;
  } else {
    {
#line 299
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c", 299);
#line 299
    tmp___2 = __errno_location();
#line 299
    tmp___3 = strerror(*tmp___2);
#line 299
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 299
    r_fatal((char const   *)tmp___4, "str_copy", "new", (long )(cursize * sizeof(BUCKET *)),
            tmp___3);
#line 299
    tmp___5 = 0;
    }
  }
  {
#line 300
  memset((void *)new, '\000', cursize * sizeof(BUCKET *));
#line 302
  old = symbol->sub.nodep.r.bv;
#line 304
  i___0 = 0UL;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i___0 < cursize)) {
#line 304
      goto while_break;
    }
#line 305
    chain = *(old + i___0);
#line 305
    pnew = new + i___0;
    {
#line 305
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 305
      if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
#line 305
        goto while_break___0;
      }
#line 310
      newchain = (BUCKET *)nextfree[2].freep;
#line 310
      if (newchain) {
#line 310
        nextfree[2].freep = ((BLOCK *)newchain)->freep;
      } else {
        {
#line 310
        tmp___6 = more_blocks(2);
#line 310
        newchain = (BUCKET *)tmp___6;
        }
      }
      {
#line 317
      tmp___7 = dupnode(chain->hs.name);
#line 317
      newchain->hs.name = tmp___7;
#line 317
      newsubs = tmp___7;
#line 318
      newchain->hs.str = newsubs->sub.val.sp;
#line 319
      newchain->hs.len = newsubs->sub.val.slen;
#line 321
      oldval = chain->hs.val;
      }
#line 322
      if ((unsigned int )oldval->type == 1U) {
        {
#line 323
        newchain->hs.val = dupnode(oldval);
        }
      } else {
        {
#line 327
        r = make_array();
#line 328
        tmp___8 = strlen((char const   *)oldval->sub.nodep.name);
#line 328
        r->sub.nodep.name = estrdup((char const   *)oldval->sub.nodep.name, tmp___8);
#line 329
        r->sub.nodep.x.extra = newsymb;
#line 330
        newchain->hs.val = assoc_copy(oldval, r);
        }
      }
#line 332
      newchain->hs.code = chain->hs.code;
#line 334
      *pnew = newchain;
#line 335
      newchain->hs.next = (union bucket_item *)((void *)0);
#line 336
      pnew = & newchain->hs.next;
#line 305
      chain = chain->hs.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 304
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  newsymb->sub.nodep.reflags = symbol->sub.nodep.reflags;
#line 341
  newsymb->sub.nodep.r.bv = new;
#line 342
  newsymb->sub.nodep.cnt = cursize;
#line 343
  newsymb->flags = symbol->flags;
#line 344
  return ((NODE **)((void *)0));
}
}
#line 350 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static NODE **str_list(NODE *symbol , NODE *t ) 
{ 
  NODE **list ;
  NODE *subs ;
  NODE *val ;
  BUCKET *b___0 ;
  unsigned long num_elems ;
  unsigned long list_size___0 ;
  unsigned long i___0 ;
  unsigned long k ;
  int elem_size ;
  assoc_kind_t assoc_kind ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 356
  k = 0UL;
#line 357
  elem_size = 1;
#line 360
  if (symbol->sub.nodep.reflags == 0UL) {
#line 361
    return ((NODE **)((void *)0));
  }
#line 363
  assoc_kind = (assoc_kind_t )t->flags;
#line 364
  if (((unsigned int )assoc_kind & 3U) == 3U) {
#line 365
    elem_size = 2;
  }
#line 368
  num_elems = symbol->sub.nodep.reflags;
#line 369
  if (((unsigned int )assoc_kind & 259U) == 257U) {
#line 370
    num_elems = 1UL;
  }
  {
#line 371
  list_size___0 = (unsigned long )elem_size * num_elems;
#line 373
  tmp___1 = malloc(list_size___0 * sizeof(NODE *));
#line 373
  list = (NODE **)tmp___1;
  }
#line 373
  if (list) {
#line 373
    tmp___5 = 1;
  } else {
    {
#line 373
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c", 373);
#line 373
    tmp___2 = __errno_location();
#line 373
    tmp___3 = strerror(*tmp___2);
#line 373
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 373
    r_fatal((char const   *)tmp___4, "str_list", "list", (long )(list_size___0 * sizeof(NODE *)),
            tmp___3);
#line 373
    tmp___5 = 0;
    }
  }
#line 377
  i___0 = 0UL;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i___0 < symbol->sub.nodep.cnt)) {
#line 377
      goto while_break;
    }
#line 378
    b___0 = *(symbol->sub.nodep.r.bv + i___0);
    {
#line 378
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 378
      if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 378
        goto while_break___0;
      }
#line 380
      subs = b___0->hs.name;
#line 381
      if (((unsigned int )assoc_kind & 4U) != 0U) {
        {
#line 382
        force_number(subs);
        }
      }
      {
#line 383
      tmp___6 = k;
#line 383
      k ++;
#line 383
      *(list + tmp___6) = dupnode(subs);
      }
#line 386
      if (((unsigned int )assoc_kind & 2U) != 0U) {
#line 387
        val = b___0->hs.val;
#line 388
        if ((unsigned int )val->type == 1U) {
#line 389
          if (((unsigned int )assoc_kind & 16U) != 0U) {
            {
#line 390
            force_number(val);
            }
          } else
#line 391
          if (((unsigned int )assoc_kind & 32U) != 0U) {
            {
#line 392
            val = force_string(val);
            }
          }
        }
#line 394
        tmp___7 = k;
#line 394
        k ++;
#line 394
        *(list + tmp___7) = val;
      }
#line 396
      if (k >= list_size___0) {
#line 397
        return (list);
      }
#line 378
      b___0 = b___0->hs.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 377
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return (list);
}
}
#line 406 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
double str_kilobytes(NODE *symbol ) 
{ 
  unsigned long bucket_cnt ;
  double kb ;

  {
#line 412
  bucket_cnt = symbol->sub.nodep.reflags;
#line 415
  kb = ((double )bucket_cnt * (double )sizeof(BUCKET ) + (double )symbol->sub.nodep.cnt * (double )sizeof(BUCKET *)) / 1024.0;
#line 417
  return (kb);
}
}
#line 431 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static size_t hash_dist[32]  ;
#line 423 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static NODE **str_dump(NODE *symbol , NODE *ndump___0 ) 
{ 
  int indent_level___0 ;
  unsigned long i___0 ;
  unsigned long bucket_cnt ;
  BUCKET *b___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  double tmp___4 ;
  char const   *aname___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 433
  indent_level___0 = (int )ndump___0->sub.nodep.x.xl;
#line 435
  if ((symbol->flags & 65536U) == 0U) {
    {
#line 436
    tmp___1 = array_vname((NODE const   *)symbol);
    }
#line 436
    if ((unsigned long )symbol->sub.nodep.x.extra == (unsigned long )((void *)0)) {
#line 436
      tmp___2 = "array";
    } else {
#line 436
      tmp___2 = "sub-array";
    }
    {
#line 436
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"%s `%s\'\n",
            tmp___2, tmp___1);
    }
  }
  {
#line 439
  indent_level___0 ++;
#line 440
  indent(indent_level___0);
#line 441
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"array_func: str_array_func\n");
  }
#line 442
  if (symbol->flags != 0U) {
    {
#line 443
    indent(indent_level___0);
#line 444
    tmp___3 = flags2str((int )symbol->flags);
#line 444
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"flags: %s\n",
            tmp___3);
    }
  }
  {
#line 446
  indent(indent_level___0);
#line 447
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"STR_CHAIN_MAX: %lu\n",
          STR_CHAIN_MAX);
#line 448
  indent(indent_level___0);
#line 449
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"array_size: %lu\n",
          symbol->sub.nodep.cnt);
#line 450
  indent(indent_level___0);
#line 451
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"table_size: %lu\n",
          symbol->sub.nodep.reflags);
#line 452
  indent(indent_level___0);
#line 453
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"Avg # of items per chain: %.2g\n",
          (double )symbol->sub.nodep.reflags / (double )symbol->sub.nodep.cnt);
#line 456
  indent(indent_level___0);
#line 457
  tmp___4 = str_kilobytes(symbol);
#line 457
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"memory: %.2g kB\n",
          tmp___4);
#line 461
  memset((void *)(hash_dist), '\000', 32UL * sizeof(size_t ));
#line 462
  i___0 = 0UL;
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (i___0 < symbol->sub.nodep.cnt)) {
#line 462
      goto while_break;
    }
#line 463
    bucket_cnt = 0UL;
#line 464
    b___0 = *(symbol->sub.nodep.r.bv + i___0);
    {
#line 464
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 464
      if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 464
        goto while_break___0;
      }
#line 465
      bucket_cnt ++;
#line 464
      b___0 = b___0->hs.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 466
    if (bucket_cnt >= 31UL) {
#line 467
      bucket_cnt = 31UL;
    }
#line 468
    (hash_dist[bucket_cnt]) ++;
#line 462
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 471
  indent(indent_level___0);
#line 472
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"Hash distribution:\n");
#line 473
  indent_level___0 ++;
#line 474
  i___0 = 0UL;
  }
  {
#line 474
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 474
    if (! (i___0 <= 31UL)) {
#line 474
      goto while_break___1;
    }
#line 475
    if (hash_dist[i___0] > 0UL) {
      {
#line 476
      indent(indent_level___0);
      }
#line 477
      if (i___0 == 31UL) {
        {
#line 478
        fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"[>=%lu]:%lu\n",
                31UL, hash_dist[i___0]);
        }
      } else {
        {
#line 481
        fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"[%lu]:%lu\n",
                i___0, hash_dist[i___0]);
        }
      }
    }
#line 474
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 485
  indent_level___0 --;
#line 489
  if (ndump___0->sub.nodep.l.ll >= 0L) {
    {
#line 492
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"\n");
#line 493
    aname___0 = make_aname((NODE const   *)symbol);
#line 494
    i___0 = 0UL;
    }
    {
#line 494
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 494
      if (! (i___0 < symbol->sub.nodep.cnt)) {
#line 494
        goto while_break___2;
      }
#line 495
      b___0 = *(symbol->sub.nodep.r.bv + i___0);
      {
#line 495
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 495
        if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 495
          goto while_break___3;
        }
        {
#line 496
        assoc_info(b___0->hs.name, b___0->hs.val, ndump___0, aname___0);
#line 495
        b___0 = b___0->hs.next;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 494
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 500
  return ((NODE **)((void *)0));
}
}
#line 508 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static unsigned long awk_hash(char const   *s___0 , size_t len , unsigned long hsize ,
                              size_t *code ) 
{ 
  unsigned long h ;
  unsigned long htmp ;
  size_t loop ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
#line 511
  h = 0UL;
#line 540
  h = 0UL;
#line 543
  if (len > 0UL) {
#line 544
    loop = ((len + 8UL) - 1UL) >> 3;
    {
#line 547
    if ((len & 7UL) == 0UL) {
#line 547
      goto case_0;
    }
#line 550
    if ((len & 7UL) == 7UL) {
#line 550
      goto case_7;
    }
#line 551
    if ((len & 7UL) == 6UL) {
#line 551
      goto case_6;
    }
#line 552
    if ((len & 7UL) == 5UL) {
#line 552
      goto case_5;
    }
#line 553
    if ((len & 7UL) == 4UL) {
#line 553
      goto case_4;
    }
#line 554
    if ((len & 7UL) == 3UL) {
#line 554
      goto case_3;
    }
#line 555
    if ((len & 7UL) == 2UL) {
#line 555
      goto case_2;
    }
#line 556
    if ((len & 7UL) == 1UL) {
#line 556
      goto case_1;
    }
#line 546
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 548
    while (1) {
      while_continue: /* CIL Label */ ;
#line 549
      htmp = h << 6;
#line 549
      tmp___1 = s___0;
#line 549
      s___0 ++;
#line 549
      h = (((unsigned long )*tmp___1 + htmp) + (htmp << 10)) - h;
#line 549
      htmp &= 4294967295UL;
#line 549
      h &= 4294967295UL;
      case_7: /* CIL Label */ 
#line 550
      htmp = h << 6;
#line 550
      tmp___2 = s___0;
#line 550
      s___0 ++;
#line 550
      h = (((unsigned long )*tmp___2 + htmp) + (htmp << 10)) - h;
#line 550
      htmp &= 4294967295UL;
#line 550
      h &= 4294967295UL;
      case_6: /* CIL Label */ 
#line 551
      htmp = h << 6;
#line 551
      tmp___3 = s___0;
#line 551
      s___0 ++;
#line 551
      h = (((unsigned long )*tmp___3 + htmp) + (htmp << 10)) - h;
#line 551
      htmp &= 4294967295UL;
#line 551
      h &= 4294967295UL;
      case_5: /* CIL Label */ 
#line 552
      htmp = h << 6;
#line 552
      tmp___4 = s___0;
#line 552
      s___0 ++;
#line 552
      h = (((unsigned long )*tmp___4 + htmp) + (htmp << 10)) - h;
#line 552
      htmp &= 4294967295UL;
#line 552
      h &= 4294967295UL;
      case_4: /* CIL Label */ 
#line 553
      htmp = h << 6;
#line 553
      tmp___5 = s___0;
#line 553
      s___0 ++;
#line 553
      h = (((unsigned long )*tmp___5 + htmp) + (htmp << 10)) - h;
#line 553
      htmp &= 4294967295UL;
#line 553
      h &= 4294967295UL;
      case_3: /* CIL Label */ 
#line 554
      htmp = h << 6;
#line 554
      tmp___6 = s___0;
#line 554
      s___0 ++;
#line 554
      h = (((unsigned long )*tmp___6 + htmp) + (htmp << 10)) - h;
#line 554
      htmp &= 4294967295UL;
#line 554
      h &= 4294967295UL;
      case_2: /* CIL Label */ 
#line 555
      htmp = h << 6;
#line 555
      tmp___7 = s___0;
#line 555
      s___0 ++;
#line 555
      h = (((unsigned long )*tmp___7 + htmp) + (htmp << 10)) - h;
#line 555
      htmp &= 4294967295UL;
#line 555
      h &= 4294967295UL;
      case_1: /* CIL Label */ 
#line 556
      htmp = h << 6;
#line 556
      tmp___8 = s___0;
#line 556
      s___0 ++;
#line 556
      h = (((unsigned long )*tmp___8 + htmp) + (htmp << 10)) - h;
#line 556
      htmp &= 4294967295UL;
#line 556
      h &= 4294967295UL;
#line 548
      loop --;
#line 548
      if (! loop) {
#line 548
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 561
  if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 562
    *code = h;
  }
#line 564
  if (h >= hsize) {
#line 565
    h %= hsize;
  }
#line 566
  return (h);
}
}
#line 572 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
__inline static NODE **str_find(NODE *symbol , NODE *s1 , size_t code1 , unsigned long hash1 ) 
{ 
  BUCKET *b___0 ;
  size_t s2_len ;
  int tmp___1 ;

  {
#line 578
  b___0 = *(symbol->sub.nodep.r.bv + hash1);
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 578
      goto while_break;
    }
#line 583
    s2_len = b___0->hs.len;
#line 585
    if (code1 == b___0->hs.code) {
#line 585
      if (s1->sub.val.slen == s2_len) {
#line 585
        if (s2_len == 0UL) {
#line 590
          return (& b___0->hs.val);
        } else {
          {
#line 585
          tmp___1 = memcmp((void const   *)s1->sub.val.sp, (void const   *)b___0->hs.str,
                           s2_len);
          }
#line 585
          if (tmp___1 == 0) {
#line 590
            return (& b___0->hs.val);
          }
        }
      }
    }
#line 578
    b___0 = b___0->hs.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  return ((NODE **)((void *)0));
}
}
#line 617 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static unsigned long const   sizes[21]  = 
#line 617
  {      (unsigned long const   )13,      (unsigned long const   )127,      (unsigned long const   )1021,      (unsigned long const   )8191, 
        (unsigned long const   )16381,      (unsigned long const   )32749,      (unsigned long const   )65497,      (unsigned long const   )131101, 
        (unsigned long const   )262147,      (unsigned long const   )524309,      (unsigned long const   )1048583,      (unsigned long const   )2097169, 
        (unsigned long const   )4194319,      (unsigned long const   )8388617,      (unsigned long const   )16777259,      (unsigned long const   )33554467, 
        (unsigned long const   )67108879,      (unsigned long const   )134217757,      (unsigned long const   )268435459,      (unsigned long const   )536870923, 
        (unsigned long const   )1073741827};
#line 598 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static void grow_table(NODE *symbol ) 
{ 
  BUCKET **old ;
  BUCKET **new ;
  BUCKET *chain ;
  BUCKET *next ;
  int i___0 ;
  int j ;
  unsigned long oldsize ;
  unsigned long newsize ;
  unsigned long k ;
  unsigned long hash1 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 626
  oldsize = symbol->sub.nodep.cnt;
#line 626
  newsize = oldsize;
#line 628
  i___0 = 0;
#line 628
  j = (int )(sizeof(sizes) / sizeof(sizes[0]));
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
#line 628
    if (! (i___0 < j)) {
#line 628
      goto while_break;
    }
#line 629
    if (oldsize < (unsigned long )sizes[i___0]) {
#line 630
      newsize = (unsigned long )sizes[i___0];
#line 631
      goto while_break;
    }
#line 628
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  if (newsize == oldsize) {
#line 635
    symbol->flags |= 16384U;
#line 636
    return;
  }
  {
#line 640
  tmp___1 = malloc(newsize * sizeof(BUCKET *));
#line 640
  new = (BUCKET **)tmp___1;
  }
#line 640
  if (new) {
#line 640
    tmp___5 = 1;
  } else {
    {
#line 640
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c", 640);
#line 640
    tmp___2 = __errno_location();
#line 640
    tmp___3 = strerror(*tmp___2);
#line 640
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 640
    r_fatal((char const   *)tmp___4, "grow_table", "new", (long )(newsize * sizeof(BUCKET *)),
            tmp___3);
#line 640
    tmp___5 = 0;
    }
  }
  {
#line 641
  memset((void *)new, '\000', newsize * sizeof(BUCKET *));
#line 643
  old = symbol->sub.nodep.r.bv;
#line 644
  symbol->sub.nodep.r.bv = new;
#line 645
  symbol->sub.nodep.cnt = newsize;
  }
#line 648
  if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 649
    symbol->sub.nodep.reflags = 0UL;
#line 650
    return;
  }
#line 660
  k = 0UL;
  {
#line 660
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 660
    if (! (k < oldsize)) {
#line 660
      goto while_break___0;
    }
#line 661
    chain = *(old + k);
    {
#line 661
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 661
      if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
#line 661
        goto while_break___1;
      }
#line 662
      next = chain->hs.next;
#line 663
      hash1 = chain->hs.code % newsize;
#line 666
      chain->hs.next = *(new + hash1);
#line 667
      *(new + hash1) = chain;
#line 661
      chain = next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 660
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 670
  free((void *)old);
  }
#line 671
  return;
}
}
#line 698 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static unsigned long gst_hash_string(char const   *str , size_t len , unsigned long hsize ,
                                     size_t *code ) 
{ 
  unsigned long hashVal ;
  unsigned long ret ;
  char const   *tmp___1 ;
  size_t tmp___2 ;

  {
#line 701
  hashVal = 1497032417UL;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    tmp___2 = len;
#line 704
    len --;
#line 704
    if (! tmp___2) {
#line 704
      goto while_break;
    }
#line 705
    tmp___1 = str;
#line 705
    str ++;
#line 705
    hashVal += (unsigned long )*tmp___1;
#line 706
    hashVal += hashVal << 10;
#line 707
    hashVal ^= hashVal >> 6;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 710
  ret = scramble(hashVal);
  }
#line 712
  if ((unsigned long )code != (unsigned long )((void *)0)) {
#line 713
    *code = ret;
  }
#line 715
  if (ret >= hsize) {
#line 716
    ret %= hsize;
  }
#line 718
  return (ret);
}
}
#line 721 "/home/wslee/gnu_benchmarks/gawk-4.1.0/str_array.c"
static unsigned long scramble(unsigned long x ) 
{ 
  int y ;

  {
#line 724
  if (sizeof(long ) == 4UL) {
#line 725
    y = (int )(~ x);
#line 727
    x += (unsigned long )((y << 10) | (y >> 22));
#line 728
    x += (x << 6) | (x >> 26);
#line 729
    x -= (x << 16) | (x >> 16);
  } else {
#line 731
    x ^= ~ x >> 31;
#line 732
    x += (x << 21) | (x >> 11);
#line 733
    x += (x << 5) | (x >> 27);
#line 734
    x += (x << 27) | (x >> 5);
#line 735
    x += x << 31;
  }
#line 738
  return (x);
}
}
#line 192 "./regex.h"
reg_syntax_t re_syntax_options  ;
#line 474
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) ;
#line 484
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
#line 491
int re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 499
int re_search(struct re_pattern_buffer *bufp , char const   *string , int length ,
              int start , int range , struct re_registers *regs ) ;
#line 506
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
                char const   *string2 , int length2 , int start , int range , struct re_registers *regs ,
                int stop___0 ) ;
#line 514
int re_match(struct re_pattern_buffer *bufp , char const   *string , int length ,
             int start , struct re_registers *regs ) ;
#line 519
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
               char const   *string2 , int length2 , int start , struct re_registers *regs ,
               int stop___0 ) ;
#line 537
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) ;
#line 573
int regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) ;
#line 577
int regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
            size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) ;
#line 582
size_t regerror(int errcode , regex_t const   * __restrict  preg , char * __restrict  errbuf ,
                size_t errbuf_size ) ;
#line 585
void regfree(regex_t *preg ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 116
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 513
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 48
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 584 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 351 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wint_t btowc(int __c ) ;
#line 359
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 368
extern  __attribute__((__nothrow__)) size_t wcrtomb(char * __restrict  __s , wchar_t __wc ,
                                                    mbstate_t * __restrict  __ps ) ;
#line 112 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswalnum(wint_t __wc ) ;
#line 134
extern  __attribute__((__nothrow__)) int iswlower(wint_t __wc ) ;
#line 172
extern  __attribute__((__nothrow__)) wctype_t wctype(char const   *__property ) ;
#line 176
extern  __attribute__((__nothrow__)) int iswctype(wint_t __wc , wctype_t __desc ) ;
#line 195
extern  __attribute__((__nothrow__)) wint_t towlower(wint_t __wc ) ;
#line 198
extern  __attribute__((__nothrow__)) wint_t towupper(wint_t __wc ) ;
#line 73 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
static int is_blank(int c ) 
{ 
  int tmp___1 ;

  {
#line 76
  if (c == 32) {
#line 76
    tmp___1 = 1;
  } else
#line 76
  if (c == 9) {
#line 76
    tmp___1 = 1;
  } else {
#line 76
    tmp___1 = 0;
  }
#line 76
  return (tmp___1);
}
}
#line 169
char const   __re_error_msgid[369] ;
#line 170
size_t const   __re_error_msgid_idx[17] ;
#line 427
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr___0 , int new_buf_len ) ;
#line 431
static void build_wcs_buffer(re_string_t *pstr___0 ) ;
#line 432
static reg_errcode_t build_wcs_upper_buffer(re_string_t *pstr___0 ) ;
#line 435
static void build_upper_buffer(re_string_t *pstr___0 ) ;
#line 436
static void re_string_translate_buffer(re_string_t *pstr___0 ) ;
#line 437
static unsigned int re_string_context_at(re_string_t const   *input , int idx___3 ,
                                         int eflags )  __attribute__((__pure__)) ;
#line 729 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
__inline static void bitset_not(bitset_word_t *set ) 
{ 
  int bitset_i ;

  {
#line 733
  bitset_i = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! ((unsigned long )bitset_i < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 733
      goto while_break;
    }
#line 734
    *(set + bitset_i) = ~ *(set + bitset_i);
#line 733
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  return;
}
}
#line 737 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
__inline static void bitset_merge(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 
  int bitset_i ;

  {
#line 741
  bitset_i = 0;
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    if (! ((unsigned long )bitset_i < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 741
      goto while_break;
    }
#line 742
    *(dest + bitset_i) |= *(src + bitset_i);
#line 741
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  return;
}
}
#line 745 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
__inline static void bitset_mask(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 
  int bitset_i ;

  {
#line 749
  bitset_i = 0;
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (! ((unsigned long )bitset_i < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 749
      goto while_break;
    }
#line 750
    *(dest + bitset_i) &= *(src + bitset_i);
#line 749
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  return;
}
}
#line 755 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
__inline static int __attribute__((__pure__))  re_string_char_size_at(re_string_t const   *pstr___0 ,
                                                                      int idx___3 ) 
{ 
  int byte_idx ;

  {
#line 760
  if (pstr___0->mb_cur_max == 1) {
#line 761
    return ((int __attribute__((__pure__))  )1);
  }
#line 762
  byte_idx = 1;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
#line 762
    if (! (idx___3 + byte_idx < (int )pstr___0->valid_len)) {
#line 762
      goto while_break;
    }
#line 763
    if (*(pstr___0->wcs + (idx___3 + byte_idx)) != 4294967295U) {
#line 764
      goto while_break;
    }
#line 762
    byte_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 765
  return ((int __attribute__((__pure__))  )byte_idx);
}
}
#line 768 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
__inline static wint_t __attribute__((__pure__))  re_string_wchar_at(re_string_t const   *pstr___0 ,
                                                                     int idx___3 ) 
{ 


  {
#line 772
  if (pstr___0->mb_cur_max == 1) {
#line 773
    return ((wint_t __attribute__((__pure__))  )((wint_t )*(pstr___0->mbs + idx___3)));
  }
#line 774
  return ((wint_t __attribute__((__pure__))  )*(pstr___0->wcs + idx___3));
}
}
#line 778 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.h"
static int __attribute__((__pure__))  re_string_elem_size_at(re_string_t const   *pstr___0 ,
                                                             int idx___3 ) 
{ 


  {
#line 801
  return ((int __attribute__((__pure__))  )1);
}
}
#line 20 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static void re_string_construct_common(char const   *str , int len , re_string_t *pstr___0 ,
                                       unsigned char *trans , int icase , re_dfa_t const   *dfa___0 ) ;
#line 24
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa___0 , re_node_set const   *nodes ,
                                         unsigned int hash___0 ) ;
#line 27
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa___0 , re_node_set const   *nodes ,
                                         unsigned int context , unsigned int hash___0 ) ;
#line 34 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static int MAX(size_t a , size_t b___0 ) 
{ 
  size_t tmp___1 ;

  {
#line 37
  if (a > b___0) {
#line 37
    tmp___1 = a;
  } else {
#line 37
    tmp___1 = b___0;
  }
#line 37
  return ((int )tmp___1);
}
}
#line 46 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_string_allocate(re_string_t *pstr___0 , char const   *str ,
                                        int len , int init_len , unsigned char *trans ,
                                        int icase , re_dfa_t const   *dfa___0 ) 
{ 
  reg_errcode_t ret ;
  int init_buf_len ;
  long tmp___1 ;

  {
#line 55
  if (init_len < (int )dfa___0->mb_cur_max) {
#line 56
    init_len = (int )dfa___0->mb_cur_max;
  }
#line 57
  if (len + 1 < init_len) {
#line 57
    init_buf_len = len + 1;
  } else {
#line 57
    init_buf_len = init_len;
  }
  {
#line 58
  re_string_construct_common(str, len, pstr___0, trans, icase, dfa___0);
#line 60
  ret = re_string_realloc_buffers(pstr___0, init_buf_len);
#line 61
  tmp___1 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 61
  if (tmp___1) {
#line 62
    return (ret);
  }
#line 64
  pstr___0->word_char = (re_const_bitset_ptr_t )(dfa___0->word_char);
#line 65
  pstr___0->word_ops_used = (unsigned char )dfa___0->word_ops_used;
#line 66
  if (pstr___0->mbs_allocated) {
#line 66
    pstr___0->mbs = pstr___0->mbs;
  } else {
#line 66
    pstr___0->mbs = (unsigned char *)str;
  }
#line 67
  if (pstr___0->mbs_allocated) {
#line 67
    pstr___0->valid_len = 0;
  } else
#line 67
  if (dfa___0->mb_cur_max > 1) {
#line 67
    pstr___0->valid_len = 0;
  } else {
#line 67
    pstr___0->valid_len = len;
  }
#line 68
  pstr___0->valid_raw_len = pstr___0->valid_len;
#line 69
  return ((reg_errcode_t )0);
}
}
#line 74 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_string_construct(re_string_t *pstr___0 , char const   *str ,
                                         int len , unsigned char *trans , int icase ,
                                         re_dfa_t const   *dfa___0 ) 
{ 
  reg_errcode_t ret ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 80
  memset((void *)pstr___0, '\000', sizeof(re_string_t ));
#line 81
  re_string_construct_common(str, len, pstr___0, trans, icase, dfa___0);
  }
#line 83
  if (len > 0) {
    {
#line 85
    ret = re_string_realloc_buffers(pstr___0, len + 1);
#line 86
    tmp___1 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 86
    if (tmp___1) {
#line 87
      return (ret);
    }
  }
#line 89
  if (pstr___0->mbs_allocated) {
#line 89
    pstr___0->mbs = pstr___0->mbs;
  } else {
#line 89
    pstr___0->mbs = (unsigned char *)str;
  }
#line 91
  if (icase) {
#line 94
    if (dfa___0->mb_cur_max > 1) {
      {
#line 96
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 98
        ret = build_wcs_upper_buffer(pstr___0);
#line 99
        tmp___2 = __builtin_expect((long )((int )ret != 0), 0L);
        }
#line 99
        if (tmp___2) {
#line 100
          return (ret);
        }
#line 101
        if (pstr___0->valid_raw_len >= len) {
#line 102
          goto while_break;
        }
#line 103
        if (pstr___0->bufs_len > pstr___0->valid_len + (int )dfa___0->mb_cur_max) {
#line 104
          goto while_break;
        }
        {
#line 105
        ret = re_string_realloc_buffers(pstr___0, pstr___0->bufs_len * 2);
#line 106
        tmp___3 = __builtin_expect((long )((int )ret != 0), 0L);
        }
#line 106
        if (tmp___3) {
#line 107
          return (ret);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 112
      build_upper_buffer(pstr___0);
      }
    }
  } else
#line 117
  if (dfa___0->mb_cur_max > 1) {
    {
#line 118
    build_wcs_buffer(pstr___0);
    }
  } else
#line 122
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
    {
#line 123
    re_string_translate_buffer(pstr___0);
    }
  } else {
#line 126
    pstr___0->valid_len = pstr___0->bufs_len;
#line 127
    pstr___0->valid_raw_len = pstr___0->bufs_len;
  }
#line 132
  return ((reg_errcode_t )0);
}
}
#line 137 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr___0 , int new_buf_len ) 
{ 
  wint_t *new_wcs ;
  size_t max_object_size ;
  int tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  int *new_offsets ;
  void *tmp___5 ;
  long tmp___6 ;
  unsigned char *new_mbs ;
  void *tmp___7 ;
  long tmp___8 ;

  {
#line 142
  if (pstr___0->mb_cur_max > 1) {
    {
#line 147
    tmp___1 = MAX(sizeof(wint_t ), sizeof(int ));
#line 147
    max_object_size = (size_t )tmp___1;
#line 148
    tmp___2 = __builtin_expect((long )(0xffffffffffffffffUL / max_object_size < (unsigned long )new_buf_len),
                               0L);
    }
#line 148
    if (tmp___2) {
#line 149
      return ((reg_errcode_t )12);
    }
    {
#line 151
    tmp___3 = realloc((void *)pstr___0->wcs, (unsigned long )new_buf_len * sizeof(wint_t ));
#line 151
    new_wcs = (wint_t *)tmp___3;
#line 152
    tmp___4 = __builtin_expect((long )((unsigned long )new_wcs == (unsigned long )((void *)0)),
                               0L);
    }
#line 152
    if (tmp___4) {
#line 153
      return ((reg_errcode_t )12);
    }
#line 154
    pstr___0->wcs = new_wcs;
#line 155
    if ((unsigned long )pstr___0->offsets != (unsigned long )((void *)0)) {
      {
#line 157
      tmp___5 = realloc((void *)pstr___0->offsets, (unsigned long )new_buf_len * sizeof(int ));
#line 157
      new_offsets = (int *)tmp___5;
#line 158
      tmp___6 = __builtin_expect((long )((unsigned long )new_offsets == (unsigned long )((void *)0)),
                                 0L);
      }
#line 158
      if (tmp___6) {
#line 159
        return ((reg_errcode_t )12);
      }
#line 160
      pstr___0->offsets = new_offsets;
    }
  }
#line 164
  if (pstr___0->mbs_allocated) {
    {
#line 166
    tmp___7 = realloc((void *)pstr___0->mbs, (unsigned long )new_buf_len * sizeof(unsigned char ));
#line 166
    new_mbs = (unsigned char *)tmp___7;
#line 168
    tmp___8 = __builtin_expect((long )((unsigned long )new_mbs == (unsigned long )((void *)0)),
                               0L);
    }
#line 168
    if (tmp___8) {
#line 169
      return ((reg_errcode_t )12);
    }
#line 170
    pstr___0->mbs = new_mbs;
  }
#line 172
  pstr___0->bufs_len = new_buf_len;
#line 173
  return ((reg_errcode_t )0);
}
}
#line 177 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static void re_string_construct_common(char const   *str , int len , re_string_t *pstr___0 ,
                                       unsigned char *trans , int icase , re_dfa_t const   *dfa___0 ) 
{ 
  int tmp___1 ;

  {
#line 183
  pstr___0->raw_mbs = (unsigned char const   *)str;
#line 184
  pstr___0->len = len;
#line 185
  pstr___0->raw_len = len;
#line 186
  pstr___0->trans = trans;
#line 187
  if (icase) {
#line 187
    pstr___0->icase = (unsigned char)1;
  } else {
#line 187
    pstr___0->icase = (unsigned char)0;
  }
#line 188
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
#line 188
    tmp___1 = 1;
  } else
#line 188
  if (icase) {
#line 188
    tmp___1 = 1;
  } else {
#line 188
    tmp___1 = 0;
  }
#line 188
  pstr___0->mbs_allocated = (unsigned char )tmp___1;
#line 189
  pstr___0->mb_cur_max = (int )dfa___0->mb_cur_max;
#line 190
  pstr___0->is_utf8 = (unsigned char )dfa___0->is_utf8;
#line 191
  pstr___0->map_notascii = (unsigned char )dfa___0->map_notascii;
#line 192
  pstr___0->stop = pstr___0->len;
#line 193
  pstr___0->raw_stop = pstr___0->stop;
#line 194
  return;
}
}
#line 209 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static void build_wcs_buffer(re_string_t *pstr___0 ) 
{ 
  unsigned char buf___7[64] ;
  mbstate_t prev_st ;
  int byte_idx ;
  int end_idx ;
  int remain_len ;
  size_t mbclen ;
  wchar_t wc ;
  char const   *p ;
  int i___0 ;
  int ch ;
  unsigned char tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
#line 225
  if (pstr___0->bufs_len > pstr___0->len) {
#line 225
    end_idx = pstr___0->len;
  } else {
#line 225
    end_idx = pstr___0->bufs_len;
  }
#line 226
  byte_idx = pstr___0->valid_len;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (byte_idx < end_idx)) {
#line 226
      goto while_break;
    }
    {
#line 231
    remain_len = end_idx - byte_idx;
#line 232
    prev_st = pstr___0->cur_state;
#line 234
    tmp___2 = __builtin_expect((long )((unsigned long )pstr___0->trans != (unsigned long )((void *)0)),
                               0L);
    }
#line 234
    if (tmp___2) {
#line 238
      i___0 = 0;
      {
#line 238
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 238
        if (i___0 < pstr___0->mb_cur_max) {
#line 238
          if (! (i___0 < remain_len)) {
#line 238
            goto while_break___0;
          }
        } else {
#line 238
          goto while_break___0;
        }
#line 240
        ch = (int )*(pstr___0->raw_mbs + ((pstr___0->raw_mbs_idx + byte_idx) + i___0));
#line 241
        tmp___1 = *(pstr___0->trans + ch);
#line 241
        *(pstr___0->mbs + (byte_idx + i___0)) = tmp___1;
#line 241
        buf___7[i___0] = tmp___1;
#line 238
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 243
      p = (char const   *)(buf___7);
    } else {
#line 246
      p = ((char const   *)pstr___0->raw_mbs + pstr___0->raw_mbs_idx) + byte_idx;
    }
    {
#line 247
    mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)p,
                     (size_t )remain_len, & pstr___0->cur_state);
    }
#line 248
    if (mbclen == 0xffffffffffffffffUL) {
#line 248
      tmp___5 = 1;
    } else
#line 248
    if (mbclen == 0UL) {
#line 248
      tmp___5 = 1;
    } else
#line 248
    if (mbclen == 0xfffffffffffffffeUL) {
#line 248
      if (pstr___0->bufs_len >= pstr___0->len) {
#line 248
        tmp___5 = 1;
      } else {
#line 248
        tmp___5 = 0;
      }
    } else {
#line 248
      tmp___5 = 0;
    }
    {
#line 248
    tmp___6 = __builtin_expect((long )tmp___5, 0L);
    }
#line 248
    if (tmp___6) {
      {
#line 252
      mbclen = (size_t )1;
#line 253
      wc = (wchar_t )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + byte_idx));
#line 254
      tmp___3 = __builtin_expect((long )((unsigned long )pstr___0->trans != (unsigned long )((void *)0)),
                                 0L);
      }
#line 254
      if (tmp___3) {
#line 255
        wc = (wchar_t )*(pstr___0->trans + wc);
      }
#line 256
      pstr___0->cur_state = prev_st;
    } else {
      {
#line 258
      tmp___4 = __builtin_expect((long )(mbclen == 0xfffffffffffffffeUL), 0L);
      }
#line 258
      if (tmp___4) {
#line 261
        pstr___0->cur_state = prev_st;
#line 262
        goto while_break;
      }
    }
#line 266
    tmp___7 = byte_idx;
#line 266
    byte_idx ++;
#line 266
    *(pstr___0->wcs + tmp___7) = (wint_t )wc;
#line 268
    remain_len = (int )(((size_t )byte_idx + mbclen) - 1UL);
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      if (! (byte_idx < remain_len)) {
#line 268
        goto while_break___1;
      }
#line 269
      tmp___8 = byte_idx;
#line 269
      byte_idx ++;
#line 269
      *(pstr___0->wcs + tmp___8) = 4294967295U;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  pstr___0->valid_len = byte_idx;
#line 272
  pstr___0->valid_raw_len = byte_idx;
#line 273
  return;
}
}
#line 278 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t build_wcs_upper_buffer(re_string_t *pstr___0 ) 
{ 
  mbstate_t prev_st ;
  int src_idx ;
  int byte_idx ;
  int end_idx ;
  int remain_len ;
  size_t mbclen ;
  char buf___7[64] ;
  wchar_t wc ;
  int tmp___1 ;
  int tmp___2 ;
  wchar_t wcu ;
  size_t mbcdlen ;
  wint_t tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int ch ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  wchar_t wc___0 ;
  char const   *p ;
  int i___0 ;
  int ch___0 ;
  long tmp___11 ;
  wchar_t wcu___0 ;
  size_t mbcdlen___0 ;
  wint_t tmp___12 ;
  size_t i___1 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  size_t i___2 ;
  long tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int ch___1 ;
  long tmp___20 ;
  long tmp___21 ;
  int tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;

  {
#line 292
  byte_idx = pstr___0->valid_len;
#line 293
  if (pstr___0->bufs_len > pstr___0->len) {
#line 293
    end_idx = pstr___0->len;
  } else {
#line 293
    end_idx = pstr___0->bufs_len;
  }
#line 297
  if (! pstr___0->map_notascii) {
#line 297
    if ((unsigned long )pstr___0->trans == (unsigned long )((void *)0)) {
#line 297
      if (! pstr___0->offsets_needed) {
        {
#line 299
        while (1) {
          while_continue: /* CIL Label */ ;
#line 299
          if (! (byte_idx < end_idx)) {
#line 299
            goto while_break;
          }
#line 303
          if (((int const   )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + byte_idx)) & -128) == 0) {
            {
#line 303
            tmp___2 = mbsinit((mbstate_t const   *)(& pstr___0->cur_state));
            }
#line 303
            if (tmp___2) {
              {
#line 307
              tmp___1 = toupper((int )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + byte_idx)));
#line 307
              *(pstr___0->mbs + byte_idx) = (unsigned char )tmp___1;
#line 311
              *(pstr___0->wcs + byte_idx) = (wint_t )((wchar_t )*(pstr___0->mbs + byte_idx));
#line 312
              byte_idx ++;
              }
#line 313
              goto while_continue;
            }
          }
          {
#line 316
          remain_len = end_idx - byte_idx;
#line 317
          prev_st = pstr___0->cur_state;
#line 318
          mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)(((char const   *)pstr___0->raw_mbs + pstr___0->raw_mbs_idx) + byte_idx),
                           (size_t )remain_len, & pstr___0->cur_state);
#line 321
          tmp___10 = __builtin_expect((long )(mbclen + 2UL > 2UL), 1L);
          }
#line 321
          if (tmp___10) {
            {
#line 323
            wcu = wc;
#line 324
            tmp___5 = iswlower((wint_t )wc);
            }
#line 324
            if (tmp___5) {
              {
#line 328
              tmp___3 = towupper((wint_t )wc);
#line 328
              wcu = (wchar_t )tmp___3;
#line 329
              mbcdlen = wcrtomb((char */* __restrict  */)(buf___7), wcu, (mbstate_t */* __restrict  */)(& prev_st));
#line 330
              tmp___4 = __builtin_expect((long )(mbclen == mbcdlen), 1L);
              }
#line 330
              if (tmp___4) {
                {
#line 331
                memcpy((void */* __restrict  */)(pstr___0->mbs + byte_idx), (void const   */* __restrict  */)(buf___7),
                       mbclen);
                }
              } else {
#line 334
                src_idx = byte_idx;
#line 335
                goto offsets_needed;
              }
            } else {
              {
#line 339
              memcpy((void */* __restrict  */)(pstr___0->mbs + byte_idx), (void const   */* __restrict  */)((pstr___0->raw_mbs + pstr___0->raw_mbs_idx) + byte_idx),
                     mbclen);
              }
            }
#line 341
            tmp___6 = byte_idx;
#line 341
            byte_idx ++;
#line 341
            *(pstr___0->wcs + tmp___6) = (wint_t )wcu;
#line 343
            remain_len = (int )(((size_t )byte_idx + mbclen) - 1UL);
            {
#line 343
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 343
              if (! (byte_idx < remain_len)) {
#line 343
                goto while_break___0;
              }
#line 344
              tmp___7 = byte_idx;
#line 344
              byte_idx ++;
#line 344
              *(pstr___0->wcs + tmp___7) = 4294967295U;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else
#line 346
          if (mbclen == 0xffffffffffffffffUL) {
#line 346
            goto _L;
          } else
#line 346
          if (mbclen == 0UL) {
#line 346
            goto _L;
          } else
#line 346
          if (mbclen == 0xfffffffffffffffeUL) {
#line 346
            if (pstr___0->bufs_len >= pstr___0->len) {
              _L: /* CIL Label */ 
              {
#line 351
              ch = (int )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + byte_idx));
#line 352
              *(pstr___0->mbs + byte_idx) = (unsigned char )ch;
#line 354
              tmp___8 = byte_idx;
#line 354
              byte_idx ++;
#line 354
              *(pstr___0->wcs + tmp___8) = (wint_t )ch;
#line 355
              tmp___9 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL),
                                         0L);
              }
#line 355
              if (tmp___9) {
#line 356
                pstr___0->cur_state = prev_st;
              }
            } else {
#line 361
              pstr___0->cur_state = prev_st;
#line 362
              goto while_break;
            }
          } else {
#line 361
            pstr___0->cur_state = prev_st;
#line 362
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 365
        pstr___0->valid_len = byte_idx;
#line 366
        pstr___0->valid_raw_len = byte_idx;
#line 367
        return ((reg_errcode_t )0);
      } else {
#line 297
        goto _L___2;
      }
    } else {
#line 297
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 370
    src_idx = pstr___0->valid_raw_len;
    {
#line 370
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 370
      if (! (byte_idx < end_idx)) {
#line 370
        goto while_break___1;
      }
      offsets_needed: 
      {
#line 375
      remain_len = end_idx - byte_idx;
#line 376
      prev_st = pstr___0->cur_state;
#line 377
      tmp___11 = __builtin_expect((long )((unsigned long )pstr___0->trans != (unsigned long )((void *)0)),
                                  0L);
      }
#line 377
      if (tmp___11) {
#line 381
        i___0 = 0;
        {
#line 381
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 381
          if (i___0 < pstr___0->mb_cur_max) {
#line 381
            if (! (i___0 < remain_len)) {
#line 381
              goto while_break___2;
            }
          } else {
#line 381
            goto while_break___2;
          }
#line 383
          ch___0 = (int )*(pstr___0->raw_mbs + ((pstr___0->raw_mbs_idx + src_idx) + i___0));
#line 384
          buf___7[i___0] = (char )*(pstr___0->trans + ch___0);
#line 381
          i___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 386
        p = (char const   *)(buf___7);
      } else {
#line 389
        p = ((char const   *)pstr___0->raw_mbs + pstr___0->raw_mbs_idx) + src_idx;
      }
      {
#line 390
      mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc___0), (char const   */* __restrict  */)p,
                       (size_t )remain_len, & pstr___0->cur_state);
#line 391
      tmp___24 = __builtin_expect((long )(mbclen + 2UL > 2UL), 1L);
      }
#line 391
      if (tmp___24) {
        {
#line 393
        wcu___0 = wc___0;
#line 394
        tmp___16 = iswlower((wint_t )wc___0);
        }
#line 394
        if (tmp___16) {
          {
#line 398
          tmp___12 = towupper((wint_t )wc___0);
#line 398
          wcu___0 = (wchar_t )tmp___12;
#line 399
          mbcdlen___0 = wcrtomb((char */* __restrict  */)(buf___7), wcu___0, (mbstate_t */* __restrict  */)(& prev_st));
#line 400
          tmp___15 = __builtin_expect((long )(mbclen == mbcdlen___0), 1L);
          }
#line 400
          if (tmp___15) {
            {
#line 401
            memcpy((void */* __restrict  */)(pstr___0->mbs + byte_idx), (void const   */* __restrict  */)(buf___7),
                   mbclen);
            }
          } else
#line 402
          if (mbcdlen___0 != 0xffffffffffffffffUL) {
#line 406
            if ((size_t )byte_idx + mbcdlen___0 > (size_t )pstr___0->bufs_len) {
#line 408
              pstr___0->cur_state = prev_st;
#line 409
              goto while_break___1;
            }
#line 412
            if ((unsigned long )pstr___0->offsets == (unsigned long )((void *)0)) {
              {
#line 414
              tmp___13 = malloc((unsigned long )pstr___0->bufs_len * sizeof(int ));
#line 414
              pstr___0->offsets = (int *)tmp___13;
              }
#line 416
              if ((unsigned long )pstr___0->offsets == (unsigned long )((void *)0)) {
#line 417
                return ((reg_errcode_t )12);
              }
            }
#line 419
            if (! pstr___0->offsets_needed) {
#line 421
              i___1 = (size_t )0;
              {
#line 421
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 421
                if (! (i___1 < (size_t )byte_idx)) {
#line 421
                  goto while_break___3;
                }
#line 422
                *(pstr___0->offsets + i___1) = (int )i___1;
#line 421
                i___1 ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 423
              pstr___0->offsets_needed = (unsigned char)1;
            }
            {
#line 426
            memcpy((void */* __restrict  */)(pstr___0->mbs + byte_idx), (void const   */* __restrict  */)(buf___7),
                   mbcdlen___0);
#line 427
            *(pstr___0->wcs + byte_idx) = (wint_t )wcu___0;
#line 428
            *(pstr___0->offsets + byte_idx) = src_idx;
#line 429
            i___1 = (size_t )1;
            }
            {
#line 429
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 429
              if (! (i___1 < mbcdlen___0)) {
#line 429
                goto while_break___4;
              }
#line 431
              if (i___1 < mbclen) {
#line 431
                tmp___14 = i___1;
              } else {
#line 431
                tmp___14 = mbclen - 1UL;
              }
#line 431
              *(pstr___0->offsets + ((size_t )byte_idx + i___1)) = (int )((size_t )src_idx + tmp___14);
#line 433
              *(pstr___0->wcs + ((size_t )byte_idx + i___1)) = 4294967295U;
#line 429
              i___1 ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 435
            pstr___0->len = (int )((size_t )pstr___0->len + (mbcdlen___0 - mbclen));
#line 436
            if (pstr___0->raw_stop > src_idx) {
#line 437
              pstr___0->stop = (int )((size_t )pstr___0->stop + (mbcdlen___0 - mbclen));
            }
#line 438
            if (pstr___0->bufs_len > pstr___0->len) {
#line 438
              end_idx = pstr___0->len;
            } else {
#line 438
              end_idx = pstr___0->bufs_len;
            }
#line 440
            byte_idx = (int )((size_t )byte_idx + mbcdlen___0);
#line 441
            src_idx = (int )((size_t )src_idx + mbclen);
#line 442
            goto __Cont;
          } else {
            {
#line 445
            memcpy((void */* __restrict  */)(pstr___0->mbs + byte_idx), (void const   */* __restrict  */)p,
                   mbclen);
            }
          }
        } else {
          {
#line 448
          memcpy((void */* __restrict  */)(pstr___0->mbs + byte_idx), (void const   */* __restrict  */)p,
                 mbclen);
          }
        }
        {
#line 450
        tmp___17 = __builtin_expect((long )((int )pstr___0->offsets_needed != 0),
                                    0L);
        }
#line 450
        if (tmp___17) {
#line 453
          i___2 = (size_t )0;
          {
#line 453
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 453
            if (! (i___2 < mbclen)) {
#line 453
              goto while_break___5;
            }
#line 454
            *(pstr___0->offsets + ((size_t )byte_idx + i___2)) = (int )((size_t )src_idx + i___2);
#line 453
            i___2 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 456
        src_idx = (int )((size_t )src_idx + mbclen);
#line 458
        tmp___18 = byte_idx;
#line 458
        byte_idx ++;
#line 458
        *(pstr___0->wcs + tmp___18) = (wint_t )wcu___0;
#line 460
        remain_len = (int )(((size_t )byte_idx + mbclen) - 1UL);
        {
#line 460
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 460
          if (! (byte_idx < remain_len)) {
#line 460
            goto while_break___6;
          }
#line 461
          tmp___19 = byte_idx;
#line 461
          byte_idx ++;
#line 461
          *(pstr___0->wcs + tmp___19) = 4294967295U;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 463
      if (mbclen == 0xffffffffffffffffUL) {
#line 463
        goto _L___0;
      } else
#line 463
      if (mbclen == 0UL) {
#line 463
        goto _L___0;
      } else
#line 463
      if (mbclen == 0xfffffffffffffffeUL) {
#line 463
        if (pstr___0->bufs_len >= pstr___0->len) {
          _L___0: /* CIL Label */ 
          {
#line 467
          ch___1 = (int )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + src_idx));
#line 469
          tmp___20 = __builtin_expect((long )((unsigned long )pstr___0->trans != (unsigned long )((void *)0)),
                                      0L);
          }
#line 469
          if (tmp___20) {
#line 470
            ch___1 = (int )*(pstr___0->trans + ch___1);
          }
          {
#line 471
          *(pstr___0->mbs + byte_idx) = (unsigned char )ch___1;
#line 473
          tmp___21 = __builtin_expect((long )((int )pstr___0->offsets_needed != 0),
                                      0L);
          }
#line 473
          if (tmp___21) {
#line 474
            *(pstr___0->offsets + byte_idx) = src_idx;
          }
          {
#line 475
          src_idx ++;
#line 478
          tmp___22 = byte_idx;
#line 478
          byte_idx ++;
#line 478
          *(pstr___0->wcs + tmp___22) = (wint_t )ch___1;
#line 479
          tmp___23 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL), 0L);
          }
#line 479
          if (tmp___23) {
#line 480
            pstr___0->cur_state = prev_st;
          }
        } else {
#line 485
          pstr___0->cur_state = prev_st;
#line 486
          goto while_break___1;
        }
      } else {
#line 485
        pstr___0->cur_state = prev_st;
#line 486
        goto while_break___1;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 489
  pstr___0->valid_len = byte_idx;
#line 490
  pstr___0->valid_raw_len = src_idx;
#line 491
  return ((reg_errcode_t )0);
}
}
#line 497 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static int re_string_skip_chars(re_string_t *pstr___0 , int new_raw_idx , wint_t *last_wc ) 
{ 
  mbstate_t prev_st ;
  int rawbuf_idx ;
  size_t mbclen ;
  wint_t wc ;
  wchar_t wc2 ;
  int remain_len ;
  long tmp___1 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 504
  wc = 4294967295U;
#line 507
  rawbuf_idx = pstr___0->raw_mbs_idx + pstr___0->valid_raw_len;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! (rawbuf_idx < new_raw_idx)) {
#line 507
      goto while_break;
    }
    {
#line 511
    remain_len = pstr___0->raw_len - rawbuf_idx;
#line 512
    prev_st = pstr___0->cur_state;
#line 513
    mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc2), (char const   */* __restrict  */)((char const   *)pstr___0->raw_mbs + rawbuf_idx),
                     (size_t )remain_len, & pstr___0->cur_state);
#line 515
    tmp___1 = __builtin_expect((long )((ssize_t )mbclen <= 0L), 0L);
    }
#line 515
    if (tmp___1) {
#line 518
      if (mbclen == 0UL) {
#line 519
        wc = (wint_t )0;
      } else
#line 518
      if (remain_len == 0) {
#line 519
        wc = (wint_t )0;
      } else {
#line 521
        wc = (wint_t )*((unsigned char *)(pstr___0->raw_mbs + rawbuf_idx));
      }
#line 522
      mbclen = (size_t )1;
#line 523
      pstr___0->cur_state = prev_st;
    } else {
#line 526
      wc = (wint_t )wc2;
    }
#line 528
    rawbuf_idx = (int )((size_t )rawbuf_idx + mbclen);
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  *last_wc = wc;
#line 531
  return (rawbuf_idx);
}
}
#line 538 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static void build_upper_buffer(re_string_t *pstr___0 ) 
{ 
  int char_idx ;
  int end_idx ;
  int ch ;
  long tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 543
  if (pstr___0->bufs_len > pstr___0->len) {
#line 543
    end_idx = pstr___0->len;
  } else {
#line 543
    end_idx = pstr___0->bufs_len;
  }
#line 545
  char_idx = pstr___0->valid_len;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! (char_idx < end_idx)) {
#line 545
      goto while_break;
    }
    {
#line 547
    ch = (int )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + char_idx));
#line 548
    tmp___1 = __builtin_expect((long )((unsigned long )pstr___0->trans != (unsigned long )((void *)0)),
                               0L);
    }
#line 548
    if (tmp___1) {
#line 549
      ch = (int )*(pstr___0->trans + ch);
    }
    {
#line 550
    tmp___3 = __ctype_b_loc();
    }
#line 550
    if ((int const   )*(*tmp___3 + ch) & 512) {
      {
#line 551
      tmp___2 = toupper(ch);
#line 551
      *(pstr___0->mbs + char_idx) = (unsigned char )tmp___2;
      }
    } else {
#line 553
      *(pstr___0->mbs + char_idx) = (unsigned char )ch;
    }
#line 545
    char_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  pstr___0->valid_len = char_idx;
#line 556
  pstr___0->valid_raw_len = char_idx;
#line 557
  return;
}
}
#line 561 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static void re_string_translate_buffer(re_string_t *pstr___0 ) 
{ 
  int buf_idx ;
  int end_idx ;
  int ch ;

  {
#line 566
  if (pstr___0->bufs_len > pstr___0->len) {
#line 566
    end_idx = pstr___0->len;
  } else {
#line 566
    end_idx = pstr___0->bufs_len;
  }
#line 568
  buf_idx = pstr___0->valid_len;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 568
    if (! (buf_idx < end_idx)) {
#line 568
      goto while_break;
    }
#line 570
    ch = (int )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + buf_idx));
#line 571
    *(pstr___0->mbs + buf_idx) = *(pstr___0->trans + ch);
#line 568
    buf_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  pstr___0->valid_len = buf_idx;
#line 575
  pstr___0->valid_raw_len = buf_idx;
#line 576
  return;
}
}
#line 582 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_string_reconstruct(re_string_t *pstr___0 , int idx___3 , int eflags ) 
{ 
  int offset ;
  long tmp___1 ;
  int low ;
  int high ;
  int mid ;
  long tmp___2 ;
  long tmp___3 ;
  int prev_valid_len ;
  long tmp___4 ;
  int wcs_idx ;
  wint_t wc ;
  unsigned char const   *raw ;
  unsigned char const   *p ;
  unsigned char const   *end ;
  mbstate_t cur_state ;
  wchar_t wc2 ;
  int mlen ;
  unsigned char buf___7[6] ;
  size_t mbclen ;
  unsigned char const   *pp ;
  int i___0 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int c ;
  int tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;

  {
  {
#line 586
  offset = idx___3 - pstr___0->raw_mbs_idx;
#line 587
  tmp___1 = __builtin_expect((long )(offset < 0), 0L);
  }
#line 587
  if (tmp___1) {
#line 591
    if (pstr___0->mb_cur_max > 1) {
      {
#line 592
      memset((void *)(& pstr___0->cur_state), '\000', sizeof(mbstate_t ));
      }
    }
#line 594
    pstr___0->len = pstr___0->raw_len;
#line 595
    pstr___0->stop = pstr___0->raw_stop;
#line 596
    pstr___0->valid_len = 0;
#line 597
    pstr___0->raw_mbs_idx = 0;
#line 598
    pstr___0->valid_raw_len = 0;
#line 599
    pstr___0->offsets_needed = (unsigned char)0;
#line 600
    if (eflags & 1) {
#line 600
      pstr___0->tip_context = (unsigned int )((1 << 1) << 1);
    } else {
#line 600
      pstr___0->tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
    }
#line 602
    if (! pstr___0->mbs_allocated) {
#line 603
      pstr___0->mbs = (unsigned char *)pstr___0->raw_mbs;
    }
#line 604
    offset = idx___3;
  }
  {
#line 607
  tmp___15 = __builtin_expect((long )(offset != 0), 1L);
  }
#line 607
  if (tmp___15) {
    {
#line 610
    tmp___13 = __builtin_expect((long )(offset < pstr___0->valid_raw_len), 1L);
    }
#line 610
    if (tmp___13) {
      {
#line 614
      tmp___3 = __builtin_expect((long )pstr___0->offsets_needed, 0L);
      }
#line 614
      if (tmp___3) {
#line 616
        low = 0;
#line 616
        high = pstr___0->valid_len;
        {
#line 617
        while (1) {
          while_continue: /* CIL Label */ ;
#line 619
          mid = (high + low) / 2;
#line 620
          if (*(pstr___0->offsets + mid) > offset) {
#line 621
            high = mid;
          } else
#line 622
          if (*(pstr___0->offsets + mid) < offset) {
#line 623
            low = mid + 1;
          } else {
#line 625
            goto while_break;
          }
#line 617
          if (! (low < high)) {
#line 617
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 628
        if (*(pstr___0->offsets + mid) < offset) {
#line 629
          mid ++;
        }
        {
#line 630
        pstr___0->tip_context = re_string_context_at((re_string_t const   *)pstr___0,
                                                     mid - 1, eflags);
        }
#line 636
        if (pstr___0->valid_len > offset) {
#line 636
          if (mid == offset) {
#line 636
            if (*(pstr___0->offsets + mid) == offset) {
              {
#line 639
              memmove((void *)pstr___0->wcs, (void const   *)(pstr___0->wcs + offset),
                      (unsigned long )(pstr___0->valid_len - offset) * sizeof(wint_t ));
#line 641
              memmove((void *)pstr___0->mbs, (void const   *)(pstr___0->mbs + offset),
                      (size_t )(pstr___0->valid_len - offset));
#line 642
              pstr___0->valid_len -= offset;
#line 643
              pstr___0->valid_raw_len -= offset;
#line 644
              low = 0;
              }
              {
#line 644
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 644
                if (! (low < pstr___0->valid_len)) {
#line 644
                  goto while_break___0;
                }
#line 645
                *(pstr___0->offsets + low) = *(pstr___0->offsets + (low + offset)) - offset;
#line 644
                low ++;
              }
              while_break___0: /* CIL Label */ ;
              }
            } else {
#line 636
              goto _L___0;
            }
          } else {
#line 636
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 651
          pstr___0->len = (pstr___0->raw_len - idx___3) + offset;
#line 652
          pstr___0->stop = (pstr___0->raw_stop - idx___3) + offset;
#line 653
          pstr___0->offsets_needed = (unsigned char)0;
          {
#line 654
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 654
            if (mid > 0) {
#line 654
              if (! (*(pstr___0->offsets + (mid - 1)) == offset)) {
#line 654
                goto while_break___1;
              }
            } else {
#line 654
              goto while_break___1;
            }
#line 655
            mid --;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 656
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 656
            if (! (mid < pstr___0->valid_len)) {
#line 656
              goto while_break___2;
            }
#line 657
            if (*(pstr___0->wcs + mid) != 4294967295U) {
#line 658
              goto while_break___2;
            } else {
#line 660
              mid ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 661
          if (mid == pstr___0->valid_len) {
#line 662
            pstr___0->valid_len = 0;
          } else {
#line 665
            pstr___0->valid_len = *(pstr___0->offsets + mid) - offset;
#line 666
            if (pstr___0->valid_len) {
#line 668
              low = 0;
              {
#line 668
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 668
                if (! (low < pstr___0->valid_len)) {
#line 668
                  goto while_break___3;
                }
#line 669
                *(pstr___0->wcs + low) = 4294967295U;
#line 668
                low ++;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 670
              memset((void *)pstr___0->mbs, 255, (size_t )pstr___0->valid_len);
              }
            }
          }
#line 673
          pstr___0->valid_raw_len = pstr___0->valid_len;
        }
      } else {
        {
#line 679
        pstr___0->tip_context = re_string_context_at((re_string_t const   *)pstr___0,
                                                     offset - 1, eflags);
        }
#line 682
        if (pstr___0->mb_cur_max > 1) {
          {
#line 683
          memmove((void *)pstr___0->wcs, (void const   *)(pstr___0->wcs + offset),
                  (unsigned long )(pstr___0->valid_len - offset) * sizeof(wint_t ));
          }
        }
        {
#line 686
        tmp___2 = __builtin_expect((long )pstr___0->mbs_allocated, 0L);
        }
#line 686
        if (tmp___2) {
          {
#line 687
          memmove((void *)pstr___0->mbs, (void const   *)(pstr___0->mbs + offset),
                  (size_t )(pstr___0->valid_len - offset));
          }
        }
#line 689
        pstr___0->valid_len -= offset;
#line 690
        pstr___0->valid_raw_len -= offset;
      }
    } else {
      {
#line 700
      prev_valid_len = pstr___0->valid_len;
#line 702
      tmp___4 = __builtin_expect((long )pstr___0->offsets_needed, 0L);
      }
#line 702
      if (tmp___4) {
#line 704
        pstr___0->len = (pstr___0->raw_len - idx___3) + offset;
#line 705
        pstr___0->stop = (pstr___0->raw_stop - idx___3) + offset;
#line 706
        pstr___0->offsets_needed = (unsigned char)0;
      }
#line 709
      pstr___0->valid_len = 0;
#line 711
      if (pstr___0->mb_cur_max > 1) {
#line 714
        wc = 4294967295U;
#line 716
        if (pstr___0->is_utf8) {
#line 722
          raw = pstr___0->raw_mbs + pstr___0->raw_mbs_idx;
#line 723
          end = raw + (offset - pstr___0->mb_cur_max);
#line 724
          if ((unsigned long )end < (unsigned long )pstr___0->raw_mbs) {
#line 725
            end = pstr___0->raw_mbs;
          }
#line 726
          p = (raw + offset) - 1;
          {
#line 738
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 738
            if (! ((unsigned long )p >= (unsigned long )end)) {
#line 738
              goto while_break___4;
            }
#line 739
            if (((int const   )*p & 192) != 128) {
              {
#line 743
              mlen = (int )((raw + pstr___0->len) - p);
#line 747
              pp = p;
#line 748
              tmp___6 = __builtin_expect((long )((unsigned long )pstr___0->trans != (unsigned long )((void *)0)),
                                         0L);
              }
#line 748
              if (tmp___6) {
#line 750
                if (mlen < 6) {
#line 750
                  tmp___5 = mlen;
                } else {
#line 750
                  tmp___5 = 6;
                }
#line 750
                i___0 = tmp___5;
                {
#line 751
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 751
                  i___0 --;
#line 751
                  if (! (i___0 >= 0)) {
#line 751
                    goto while_break___5;
                  }
#line 752
                  buf___7[i___0] = *(pstr___0->trans + *(p + i___0));
                }
                while_break___5: /* CIL Label */ ;
                }
#line 753
                pp = (unsigned char const   *)(buf___7);
              }
              {
#line 757
              memset((void *)(& cur_state), 0, sizeof(cur_state));
#line 758
              mbclen = mbrtowc((wchar_t */* __restrict  */)(& wc2), (char const   */* __restrict  */)((char const   *)pp),
                               (size_t )mlen, & cur_state);
              }
#line 760
              if ((size_t )((raw + offset) - p) <= mbclen) {
#line 760
                if (mbclen < 0xfffffffffffffffeUL) {
                  {
#line 763
                  memset((void *)(& pstr___0->cur_state), '\000', sizeof(mbstate_t ));
#line 765
                  pstr___0->valid_len = (int )(mbclen - (size_t )((raw + offset) - p));
#line 766
                  wc = (wint_t )wc2;
                  }
                }
              }
#line 768
              goto while_break___4;
            }
#line 738
            p --;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 772
        if (wc == 4294967295U) {
          {
#line 773
          tmp___7 = re_string_skip_chars(pstr___0, idx___3, & wc);
#line 773
          pstr___0->valid_len = tmp___7 - idx___3;
          }
        }
#line 774
        if (wc == 4294967295U) {
          {
#line 775
          pstr___0->tip_context = re_string_context_at((re_string_t const   *)pstr___0,
                                                       prev_valid_len - 1, eflags);
          }
        } else {
          {
#line 778
          tmp___9 = __builtin_expect((long )((int )pstr___0->word_ops_used != 0),
                                     0L);
          }
#line 778
          if (tmp___9) {
            {
#line 778
            tmp___10 = iswalnum(wc);
            }
#line 778
            if (tmp___10) {
#line 778
              pstr___0->tip_context = 1U;
            } else
#line 778
            if (wc == 95U) {
#line 778
              pstr___0->tip_context = 1U;
            } else {
#line 778
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 778
            if (wc == 10U) {
#line 778
              if (pstr___0->newline_anchor) {
#line 778
                tmp___8 = 1 << 1;
              } else {
#line 778
                tmp___8 = 0;
              }
            } else {
#line 778
              tmp___8 = 0;
            }
#line 778
            pstr___0->tip_context = (unsigned int )tmp___8;
          }
        }
        {
#line 784
        tmp___11 = __builtin_expect((long )pstr___0->valid_len, 0L);
        }
#line 784
        if (tmp___11) {
#line 786
          wcs_idx = 0;
          {
#line 786
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 786
            if (! (wcs_idx < pstr___0->valid_len)) {
#line 786
              goto while_break___6;
            }
#line 787
            *(pstr___0->wcs + wcs_idx) = 4294967295U;
#line 786
            wcs_idx ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 788
          if (pstr___0->mbs_allocated) {
            {
#line 789
            memset((void *)pstr___0->mbs, 255, (size_t )pstr___0->valid_len);
            }
          }
        }
#line 791
        pstr___0->valid_raw_len = pstr___0->valid_len;
      } else {
#line 796
        c = (int )*(pstr___0->raw_mbs + ((pstr___0->raw_mbs_idx + offset) - 1));
#line 797
        pstr___0->valid_raw_len = 0;
#line 798
        if (pstr___0->trans) {
#line 799
          c = (int )*(pstr___0->trans + c);
        }
#line 800
        if (*(pstr___0->word_char + (unsigned long )c / (sizeof(bitset_word_t ) * 8UL)) & (unsigned long const   )(1UL << (unsigned long )c % (sizeof(bitset_word_t ) * 8UL))) {
#line 800
          pstr___0->tip_context = 1U;
        } else {
#line 800
          if (c == 10) {
#line 800
            if (pstr___0->newline_anchor) {
#line 800
              tmp___12 = 1 << 1;
            } else {
#line 800
              tmp___12 = 0;
            }
          } else {
#line 800
            tmp___12 = 0;
          }
#line 800
          pstr___0->tip_context = (unsigned int )tmp___12;
        }
      }
    }
    {
#line 806
    tmp___14 = __builtin_expect((long )pstr___0->mbs_allocated, 0L);
    }
#line 806
    if (! tmp___14) {
#line 807
      pstr___0->mbs += offset;
    }
  }
#line 809
  pstr___0->raw_mbs_idx = idx___3;
#line 810
  pstr___0->len -= offset;
#line 811
  pstr___0->stop -= offset;
#line 815
  if (pstr___0->mb_cur_max > 1) {
#line 817
    if (pstr___0->icase) {
      {
#line 819
      tmp___16 = build_wcs_upper_buffer(pstr___0);
#line 819
      ret = tmp___16;
#line 820
      tmp___17 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 820
      if (tmp___17) {
#line 821
        return (ret);
      }
    } else {
      {
#line 824
      build_wcs_buffer(pstr___0);
      }
    }
  } else {
    {
#line 828
    tmp___18 = __builtin_expect((long )pstr___0->mbs_allocated, 0L);
    }
#line 828
    if (tmp___18) {
#line 830
      if (pstr___0->icase) {
        {
#line 831
        build_upper_buffer(pstr___0);
        }
      } else
#line 832
      if ((unsigned long )pstr___0->trans != (unsigned long )((void *)0)) {
        {
#line 833
        re_string_translate_buffer(pstr___0);
        }
      }
    } else {
#line 836
      pstr___0->valid_len = pstr___0->len;
    }
  }
#line 838
  pstr___0->cur_idx = 0;
#line 839
  return ((reg_errcode_t )0);
}
}
#line 842 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static unsigned char __attribute__((__pure__))  re_string_peek_byte_case(re_string_t const   *pstr___0 ,
                                                                         int idx___3 ) 
{ 
  int ch ;
  int off ;
  long tmp___1 ;

  {
  {
#line 849
  tmp___1 = __builtin_expect((long )(! pstr___0->mbs_allocated), 1L);
  }
#line 849
  if (tmp___1) {
#line 850
    return ((unsigned char __attribute__((__pure__))  )*(pstr___0->mbs + (pstr___0->cur_idx + (int const   )idx___3)));
  }
#line 853
  if (pstr___0->mb_cur_max > 1) {
#line 853
    if (*(pstr___0->wcs + (pstr___0->cur_idx + (int const   )idx___3)) != 4294967295U) {
#line 853
      if (! (pstr___0->valid_len == (pstr___0->cur_idx + (int const   )idx___3) + 1)) {
#line 853
        if (! (*(pstr___0->wcs + ((pstr___0->cur_idx + (int const   )idx___3) + 1)) != 4294967295U)) {
#line 855
          return ((unsigned char __attribute__((__pure__))  )*(pstr___0->mbs + (pstr___0->cur_idx + (int const   )idx___3)));
        }
      }
    } else {
#line 855
      return ((unsigned char __attribute__((__pure__))  )*(pstr___0->mbs + (pstr___0->cur_idx + (int const   )idx___3)));
    }
  }
#line 858
  off = (int )(pstr___0->cur_idx + (int const   )idx___3);
#line 860
  if (pstr___0->offsets_needed) {
#line 861
    off = *(pstr___0->offsets + off);
  }
#line 864
  ch = (int )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + (int const   )off));
#line 871
  if (pstr___0->offsets_needed) {
#line 871
    if (! ((ch & -128) == 0)) {
#line 872
      return ((unsigned char __attribute__((__pure__))  )*(pstr___0->mbs + (pstr___0->cur_idx + (int const   )idx___3)));
    }
  }
#line 875
  return ((unsigned char __attribute__((__pure__))  )ch);
}
}
#line 878 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static unsigned char re_string_fetch_byte_case(re_string_t *pstr___0 ) 
{ 
  int tmp___1 ;
  long tmp___2 ;
  int off ;
  int ch ;
  int tmp___3 ;
  int tmp___4 ;
  int __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;

  {
  {
#line 882
  tmp___2 = __builtin_expect((long )(! pstr___0->mbs_allocated), 1L);
  }
#line 882
  if (tmp___2) {
#line 883
    tmp___1 = pstr___0->cur_idx;
#line 883
    (pstr___0->cur_idx) ++;
#line 883
    return (*(pstr___0->mbs + tmp___1));
  }
#line 886
  if (pstr___0->offsets_needed) {
#line 897
    if (! (pstr___0->cur_idx == pstr___0->valid_len)) {
#line 897
      if (! (*(pstr___0->wcs + pstr___0->cur_idx) != 4294967295U)) {
#line 898
        tmp___3 = pstr___0->cur_idx;
#line 898
        (pstr___0->cur_idx) ++;
#line 898
        return (*(pstr___0->mbs + tmp___3));
      }
    }
#line 900
    off = *(pstr___0->offsets + pstr___0->cur_idx);
#line 901
    ch = (int )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + off));
#line 903
    if (! ((ch & -128) == 0)) {
#line 904
      tmp___4 = pstr___0->cur_idx;
#line 904
      (pstr___0->cur_idx) ++;
#line 904
      return (*(pstr___0->mbs + tmp___4));
    }
    {
#line 906
    tmp___5 = re_string_char_size_at((re_string_t const   *)pstr___0, pstr___0->cur_idx);
#line 906
    pstr___0->cur_idx += (int )tmp___5;
    }
#line 908
    return ((unsigned char )ch);
  }
#line 912
  tmp___6 = pstr___0->cur_idx;
#line 912
  (pstr___0->cur_idx) ++;
#line 912
  return ((unsigned char )*(pstr___0->raw_mbs + (pstr___0->raw_mbs_idx + tmp___6)));
}
}
#line 915 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static void re_string_destruct(re_string_t *pstr___0 ) 
{ 


  {
  {
#line 920
  free((void *)pstr___0->wcs);
#line 921
  free((void *)pstr___0->offsets);
  }
#line 923
  if (pstr___0->mbs_allocated) {
    {
#line 924
    free((void *)pstr___0->mbs);
    }
  }
#line 925
  return;
}
}
#line 929
static unsigned int re_string_context_at(re_string_t const   *input , int idx___3 ,
                                         int eflags )  __attribute__((__pure__)) ;
#line 929 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static unsigned int re_string_context_at(re_string_t const   *input , int idx___3 ,
                                         int eflags ) 
{ 
  int c ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  wint_t wc ;
  int wc_idx ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 934
  tmp___1 = __builtin_expect((long )(idx___3 < 0), 0L);
  }
#line 934
  if (tmp___1) {
#line 937
    return ((unsigned int )input->tip_context);
  }
  {
#line 938
  tmp___3 = __builtin_expect((long )(idx___3 == (int )input->len), 0L);
  }
#line 938
  if (tmp___3) {
#line 939
    if (eflags & (1 << 1)) {
#line 939
      tmp___2 = ((1 << 1) << 1) << 1;
    } else {
#line 939
      tmp___2 = (1 << 1) | (((1 << 1) << 1) << 1);
    }
#line 939
    return ((unsigned int )tmp___2);
  }
#line 942
  if (input->mb_cur_max > 1) {
#line 945
    wc_idx = idx___3;
    {
#line 946
    while (1) {
      while_continue: /* CIL Label */ ;
#line 946
      if (! (*(input->wcs + wc_idx) == 4294967295U)) {
#line 946
        goto while_break;
      }
#line 952
      wc_idx --;
#line 953
      if (wc_idx < 0) {
#line 954
        return ((unsigned int )input->tip_context);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 956
    wc = *(input->wcs + wc_idx);
#line 957
    tmp___4 = __builtin_expect((long )((int const   )input->word_ops_used != 0), 0L);
    }
#line 957
    if (tmp___4) {
      {
#line 957
      tmp___5 = iswalnum(wc);
      }
#line 957
      if (tmp___5) {
#line 958
        return (1U);
      } else
#line 957
      if (wc == 95U) {
#line 958
        return (1U);
      }
    }
#line 959
    if (wc == 10U) {
#line 959
      if (input->newline_anchor) {
#line 959
        tmp___6 = 1 << 1;
      } else {
#line 959
        tmp___6 = 0;
      }
    } else {
#line 959
      tmp___6 = 0;
    }
#line 959
    return ((unsigned int )tmp___6);
  } else {
#line 965
    c = (int )*(input->mbs + idx___3);
#line 966
    if (*(input->word_char + (unsigned long )c / (sizeof(bitset_word_t ) * 8UL)) & (unsigned long const   )(1UL << (unsigned long )c % (sizeof(bitset_word_t ) * 8UL))) {
#line 967
      return (1U);
    }
#line 968
    if (c == 10) {
#line 968
      if (input->newline_anchor) {
#line 968
        tmp___7 = 1 << 1;
      } else {
#line 968
        tmp___7 = 0;
      }
    } else {
#line 968
      tmp___7 = 0;
    }
#line 968
    return ((unsigned int )tmp___7);
  }
}
}
#line 974 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_node_set_alloc(re_node_set *set , int size ) 
{ 
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 983
  if (size == 0) {
    {
#line 985
    memset((void *)set, 0, sizeof(*set));
    }
#line 986
    return ((reg_errcode_t )0);
  }
  {
#line 988
  set->alloc = size;
#line 989
  set->nelem = 0;
#line 990
  tmp___1 = malloc((unsigned long )size * sizeof(int ));
#line 990
  set->elems = (int *)tmp___1;
#line 991
  tmp___2 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 991
  if (tmp___2) {
#line 992
    return ((reg_errcode_t )12);
  }
#line 993
  return ((reg_errcode_t )0);
}
}
#line 996 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_node_set_init_1(re_node_set *set , int elem ) 
{ 
  void *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 1000
  set->alloc = 1;
#line 1001
  set->nelem = 1;
#line 1002
  tmp___1 = malloc(sizeof(int ));
#line 1002
  set->elems = (int *)tmp___1;
#line 1003
  tmp___3 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 1003
  if (tmp___3) {
#line 1005
    tmp___2 = 0;
#line 1005
    set->nelem = tmp___2;
#line 1005
    set->alloc = tmp___2;
#line 1006
    return ((reg_errcode_t )12);
  }
#line 1008
  *(set->elems + 0) = elem;
#line 1009
  return ((reg_errcode_t )0);
}
}
#line 1012 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_node_set_init_2(re_node_set *set , int elem1 , int elem2 ) 
{ 
  void *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1016
  set->alloc = 2;
#line 1017
  tmp___1 = malloc(2UL * sizeof(int ));
#line 1017
  set->elems = (int *)tmp___1;
#line 1018
  tmp___2 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 1018
  if (tmp___2) {
#line 1019
    return ((reg_errcode_t )12);
  }
#line 1020
  if (elem1 == elem2) {
#line 1022
    set->nelem = 1;
#line 1023
    *(set->elems + 0) = elem1;
  } else {
#line 1027
    set->nelem = 2;
#line 1028
    if (elem1 < elem2) {
#line 1030
      *(set->elems + 0) = elem1;
#line 1031
      *(set->elems + 1) = elem2;
    } else {
#line 1035
      *(set->elems + 0) = elem2;
#line 1036
      *(set->elems + 1) = elem1;
    }
  }
#line 1039
  return ((reg_errcode_t )0);
}
}
#line 1042 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_node_set_init_copy(re_node_set *dest , re_node_set const   *src ) 
{ 
  void *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 1046
  dest->nelem = (int )src->nelem;
#line 1047
  if (src->nelem > 0) {
    {
#line 1049
    dest->alloc = dest->nelem;
#line 1050
    tmp___1 = malloc((unsigned long )dest->alloc * sizeof(int ));
#line 1050
    dest->elems = (int *)tmp___1;
#line 1051
    tmp___3 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1051
    if (tmp___3) {
#line 1053
      tmp___2 = 0;
#line 1053
      dest->nelem = tmp___2;
#line 1053
      dest->alloc = tmp___2;
#line 1054
      return ((reg_errcode_t )12);
    }
    {
#line 1056
    memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)src->elems,
           (unsigned long )src->nelem * sizeof(int ));
    }
  } else {
    {
#line 1059
    memset((void *)dest, '\000', sizeof(re_node_set ));
    }
  }
#line 1060
  return ((reg_errcode_t )0);
}
}
#line 1067 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_node_set_add_intersect(re_node_set *dest , re_node_set const   *src1 ,
                                               re_node_set const   *src2 ) 
{ 
  int i1 ;
  int i2 ;
  int is ;
  int id ;
  int delta ;
  int sbase ;
  int new_alloc ;
  int *new_elems ;
  void *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1073
  if (src1->nelem == 0) {
#line 1074
    return ((reg_errcode_t )0);
  } else
#line 1073
  if (src2->nelem == 0) {
#line 1074
    return ((reg_errcode_t )0);
  }
#line 1078
  if ((src1->nelem + src2->nelem) + (int const   )dest->nelem > (int const   )dest->alloc) {
    {
#line 1080
    new_alloc = (int )((src1->nelem + src2->nelem) + (int const   )dest->alloc);
#line 1081
    tmp___1 = realloc((void *)dest->elems, (unsigned long )new_alloc * sizeof(int ));
#line 1081
    new_elems = (int *)tmp___1;
#line 1082
    tmp___2 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1082
    if (tmp___2) {
#line 1083
      return ((reg_errcode_t )12);
    }
#line 1084
    dest->elems = new_elems;
#line 1085
    dest->alloc = new_alloc;
  }
#line 1090
  sbase = (dest->nelem + (int )src1->nelem) + (int )src2->nelem;
#line 1091
  i1 = (int )(src1->nelem - 1);
#line 1092
  i2 = (int )(src2->nelem - 1);
#line 1093
  id = dest->nelem - 1;
  {
#line 1094
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1096
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
      {
#line 1099
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1099
        if (id >= 0) {
#line 1099
          if (! (*(dest->elems + id) > *(src1->elems + i1))) {
#line 1099
            goto while_break___0;
          }
        } else {
#line 1099
          goto while_break___0;
        }
#line 1100
        id --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1102
      if (id < 0) {
#line 1103
        sbase --;
#line 1103
        *(dest->elems + sbase) = *(src1->elems + i1);
      } else
#line 1102
      if (*(dest->elems + id) != *(src1->elems + i1)) {
#line 1103
        sbase --;
#line 1103
        *(dest->elems + sbase) = *(src1->elems + i1);
      }
#line 1105
      i1 --;
#line 1105
      if (i1 < 0) {
#line 1106
        goto while_break;
      } else {
#line 1105
        i2 --;
#line 1105
        if (i2 < 0) {
#line 1106
          goto while_break;
        }
      }
    } else
#line 1110
    if (*(src1->elems + i1) < *(src2->elems + i2)) {
#line 1112
      i2 --;
#line 1112
      if (i2 < 0) {
#line 1113
        goto while_break;
      }
    } else {
#line 1117
      i1 --;
#line 1117
      if (i1 < 0) {
#line 1118
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1122
  id = dest->nelem - 1;
#line 1123
  is = ((dest->nelem + (int )src1->nelem) + (int )src2->nelem) - 1;
#line 1124
  delta = (is - sbase) + 1;
#line 1129
  dest->nelem += delta;
#line 1130
  if (delta > 0) {
#line 1130
    if (id >= 0) {
      {
#line 1131
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1133
        if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1136
          tmp___3 = delta;
#line 1136
          delta --;
#line 1136
          tmp___4 = is;
#line 1136
          is --;
#line 1136
          *(dest->elems + (id + tmp___3)) = *(dest->elems + tmp___4);
#line 1137
          if (delta == 0) {
#line 1138
            goto while_break___1;
          }
        } else {
#line 1143
          *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1144
          id --;
#line 1144
          if (id < 0) {
#line 1145
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  {
#line 1150
  memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)(dest->elems + sbase),
         (unsigned long )delta * sizeof(int ));
  }
#line 1152
  return ((reg_errcode_t )0);
}
}
#line 1158 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_node_set_init_union(re_node_set *dest , re_node_set const   *src1 ,
                                            re_node_set const   *src2 ) 
{ 
  int i1 ;
  int i2 ;
  int id ;
  void *tmp___1 ;
  long tmp___2 ;
  reg_errcode_t tmp___3 ;
  reg_errcode_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1164
  if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1164
    if (src1->nelem > 0) {
#line 1164
      if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1164
        if (src2->nelem > 0) {
          {
#line 1166
          dest->alloc = (int )(src1->nelem + src2->nelem);
#line 1167
          tmp___1 = malloc((unsigned long )dest->alloc * sizeof(int ));
#line 1167
          dest->elems = (int *)tmp___1;
#line 1168
          tmp___2 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                                     0L);
          }
#line 1168
          if (tmp___2) {
#line 1169
            return ((reg_errcode_t )12);
          }
        } else {
#line 1164
          goto _L___2;
        }
      } else {
#line 1164
        goto _L___2;
      }
    } else {
#line 1164
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 1173
    if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1173
      if (src1->nelem > 0) {
        {
#line 1174
        tmp___3 = re_node_set_init_copy(dest, src1);
        }
#line 1174
        return (tmp___3);
      } else {
#line 1173
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1175
    if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1175
      if (src2->nelem > 0) {
        {
#line 1176
        tmp___4 = re_node_set_init_copy(dest, src2);
        }
#line 1176
        return (tmp___4);
      } else {
        {
#line 1178
        memset((void *)dest, '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
#line 1178
      memset((void *)dest, '\000', sizeof(re_node_set ));
      }
    }
#line 1179
    return ((reg_errcode_t )0);
  }
#line 1181
  id = 0;
#line 1181
  i2 = id;
#line 1181
  i1 = i2;
  {
#line 1181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1181
    if (i1 < (int )src1->nelem) {
#line 1181
      if (! (i2 < (int )src2->nelem)) {
#line 1181
        goto while_break;
      }
    } else {
#line 1181
      goto while_break;
    }
#line 1183
    if (*(src1->elems + i1) > *(src2->elems + i2)) {
#line 1185
      tmp___5 = id;
#line 1185
      id ++;
#line 1185
      tmp___6 = i2;
#line 1185
      i2 ++;
#line 1185
      *(dest->elems + tmp___5) = *(src2->elems + tmp___6);
#line 1186
      goto __Cont;
    }
#line 1188
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
#line 1189
      i2 ++;
    }
#line 1190
    tmp___7 = id;
#line 1190
    id ++;
#line 1190
    tmp___8 = i1;
#line 1190
    i1 ++;
#line 1190
    *(dest->elems + tmp___7) = *(src1->elems + tmp___8);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1192
  if (i1 < (int )src1->nelem) {
    {
#line 1194
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src1->elems + i1),
           (unsigned long )(src1->nelem - (int const   )i1) * sizeof(int ));
#line 1196
    id += (int )(src1->nelem - (int const   )i1);
    }
  } else
#line 1198
  if (i2 < (int )src2->nelem) {
    {
#line 1200
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src2->elems + i2),
           (unsigned long )(src2->nelem - (int const   )i2) * sizeof(int ));
#line 1202
    id += (int )(src2->nelem - (int const   )i2);
    }
  }
#line 1204
  dest->nelem = id;
#line 1205
  return ((reg_errcode_t )0);
}
}
#line 1211 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t re_node_set_merge(re_node_set *dest , re_node_set const   *src ) 
{ 
  int is ;
  int id ;
  int sbase ;
  int delta ;
  int new_alloc ;
  int *new_buffer ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1216
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 1217
    return ((reg_errcode_t )0);
  } else
#line 1216
  if (src->nelem == 0) {
#line 1217
    return ((reg_errcode_t )0);
  }
#line 1218
  if (dest->alloc < 2 * (int )src->nelem + dest->nelem) {
    {
#line 1220
    new_alloc = 2 * (int )(src->nelem + (int const   )dest->alloc);
#line 1221
    tmp___1 = realloc((void *)dest->elems, (unsigned long )new_alloc * sizeof(int ));
#line 1221
    new_buffer = (int *)tmp___1;
#line 1222
    tmp___2 = __builtin_expect((long )((unsigned long )new_buffer == (unsigned long )((void *)0)),
                               0L);
    }
#line 1222
    if (tmp___2) {
#line 1223
      return ((reg_errcode_t )12);
    }
#line 1224
    dest->elems = new_buffer;
#line 1225
    dest->alloc = new_alloc;
  }
  {
#line 1228
  tmp___3 = __builtin_expect((long )(dest->nelem == 0), 0L);
  }
#line 1228
  if (tmp___3) {
    {
#line 1230
    dest->nelem = (int )src->nelem;
#line 1231
    memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)src->elems,
           (unsigned long )src->nelem * sizeof(int ));
    }
#line 1232
    return ((reg_errcode_t )0);
  }
#line 1237
  sbase = dest->nelem + 2 * (int )src->nelem;
#line 1237
  is = (int )(src->nelem - 1);
#line 1237
  id = dest->nelem - 1;
  {
#line 1237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1237
    if (is >= 0) {
#line 1237
      if (! (id >= 0)) {
#line 1237
        goto while_break;
      }
    } else {
#line 1237
      goto while_break;
    }
#line 1240
    if (*(dest->elems + id) == *(src->elems + is)) {
#line 1241
      is --;
#line 1241
      id --;
    } else
#line 1242
    if (*(dest->elems + id) < *(src->elems + is)) {
#line 1243
      sbase --;
#line 1243
      tmp___4 = is;
#line 1243
      is --;
#line 1243
      *(dest->elems + sbase) = *(src->elems + tmp___4);
    } else {
#line 1245
      id --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1248
  if (is >= 0) {
    {
#line 1251
    sbase -= is + 1;
#line 1252
    memcpy((void */* __restrict  */)(dest->elems + sbase), (void const   */* __restrict  */)src->elems,
           (unsigned long )(is + 1) * sizeof(int ));
    }
  }
#line 1255
  id = dest->nelem - 1;
#line 1256
  is = (dest->nelem + 2 * (int )src->nelem) - 1;
#line 1257
  delta = (is - sbase) + 1;
#line 1258
  if (delta == 0) {
#line 1259
    return ((reg_errcode_t )0);
  }
#line 1263
  dest->nelem += delta;
  {
#line 1264
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1266
    if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1269
      tmp___5 = delta;
#line 1269
      delta --;
#line 1269
      tmp___6 = is;
#line 1269
      is --;
#line 1269
      *(dest->elems + (id + tmp___5)) = *(dest->elems + tmp___6);
#line 1270
      if (delta == 0) {
#line 1271
        goto while_break___0;
      }
    } else {
#line 1276
      *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1277
      id --;
#line 1277
      if (id < 0) {
        {
#line 1280
        memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)(dest->elems + sbase),
               (unsigned long )delta * sizeof(int ));
        }
#line 1282
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1287
  return ((reg_errcode_t )0);
}
}
#line 1294 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static int re_node_set_insert(re_node_set *set , int elem ) 
{ 
  int idx___3 ;
  reg_errcode_t tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int *new_elems ;
  void *tmp___4 ;
  long tmp___5 ;

  {
#line 1300
  if (set->alloc == 0) {
    {
#line 1302
    tmp___1 = re_node_set_init_1(set, elem);
#line 1302
    tmp___2 = __builtin_expect((long )((int )tmp___1 == 0), 1L);
    }
#line 1302
    if (tmp___2) {
#line 1303
      return (1);
    } else {
#line 1305
      return (-1);
    }
  }
  {
#line 1308
  tmp___3 = __builtin_expect((long )set->nelem, 0L);
  }
#line 1308
  if (tmp___3 == 0L) {
#line 1311
    *(set->elems + 0) = elem;
#line 1312
    (set->nelem) ++;
#line 1313
    return (1);
  }
#line 1317
  if (set->alloc == set->nelem) {
    {
#line 1320
    set->alloc *= 2;
#line 1321
    tmp___4 = realloc((void *)set->elems, (unsigned long )set->alloc * sizeof(int ));
#line 1321
    new_elems = (int *)tmp___4;
#line 1322
    tmp___5 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1322
    if (tmp___5) {
#line 1323
      return (-1);
    }
#line 1324
    set->elems = new_elems;
  }
#line 1329
  if (elem < *(set->elems + 0)) {
#line 1331
    idx___3 = 0;
#line 1332
    idx___3 = set->nelem;
    {
#line 1332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1332
      if (! (idx___3 > 0)) {
#line 1332
        goto while_break;
      }
#line 1333
      *(set->elems + idx___3) = *(set->elems + (idx___3 - 1));
#line 1332
      idx___3 --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1337
    idx___3 = set->nelem;
    {
#line 1337
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1337
      if (! (*(set->elems + (idx___3 - 1)) > elem)) {
#line 1337
        goto while_break___0;
      }
#line 1338
      *(set->elems + idx___3) = *(set->elems + (idx___3 - 1));
#line 1337
      idx___3 --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1342
  *(set->elems + idx___3) = elem;
#line 1343
  (set->nelem) ++;
#line 1344
  return (1);
}
}
#line 1351 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static int re_node_set_insert_last(re_node_set *set , int elem ) 
{ 
  int *new_elems ;
  void *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 1356
  if (set->alloc == set->nelem) {
    {
#line 1359
    set->alloc = (set->alloc + 1) * 2;
#line 1360
    tmp___1 = realloc((void *)set->elems, (unsigned long )set->alloc * sizeof(int ));
#line 1360
    new_elems = (int *)tmp___1;
#line 1361
    tmp___2 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1361
    if (tmp___2) {
#line 1362
      return (-1);
    }
#line 1363
    set->elems = new_elems;
  }
#line 1367
  tmp___3 = set->nelem;
#line 1367
  (set->nelem) ++;
#line 1367
  *(set->elems + tmp___3) = elem;
#line 1368
  return (1);
}
}
#line 1374 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static int __attribute__((__pure__))  re_node_set_compare(re_node_set const   *set1 ,
                                                          re_node_set const   *set2 ) 
{ 
  int i___0 ;

  {
#line 1379
  if ((unsigned long )set1 == (unsigned long )((void *)0)) {
#line 1380
    return ((int __attribute__((__pure__))  )0);
  } else
#line 1379
  if ((unsigned long )set2 == (unsigned long )((void *)0)) {
#line 1380
    return ((int __attribute__((__pure__))  )0);
  } else
#line 1379
  if (set1->nelem != set2->nelem) {
#line 1380
    return ((int __attribute__((__pure__))  )0);
  }
#line 1381
  i___0 = (int )set1->nelem;
  {
#line 1381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1381
    i___0 --;
#line 1381
    if (! (i___0 >= 0)) {
#line 1381
      goto while_break;
    }
#line 1382
    if (*(set1->elems + i___0) != *(set2->elems + i___0)) {
#line 1383
      return ((int __attribute__((__pure__))  )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1384
  return ((int __attribute__((__pure__))  )1);
}
}
#line 1389 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static int __attribute__((__pure__))  re_node_set_contains(re_node_set const   *set ,
                                                           int elem ) 
{ 
  unsigned int idx___3 ;
  unsigned int right ;
  unsigned int mid ;
  unsigned int tmp___1 ;

  {
#line 1394
  if (set->nelem <= 0) {
#line 1395
    return ((int __attribute__((__pure__))  )0);
  }
#line 1398
  idx___3 = 0U;
#line 1399
  right = (unsigned int )(set->nelem - 1);
  {
#line 1400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1400
    if (! (idx___3 < right)) {
#line 1400
      goto while_break;
    }
#line 1402
    mid = (idx___3 + right) / 2U;
#line 1403
    if (*(set->elems + mid) < elem) {
#line 1404
      idx___3 = mid + 1U;
    } else {
#line 1406
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1408
  if (*(set->elems + idx___3) == elem) {
#line 1408
    tmp___1 = idx___3 + 1U;
  } else {
#line 1408
    tmp___1 = 0U;
  }
#line 1408
  return ((int __attribute__((__pure__))  )tmp___1);
}
}
#line 1411 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static void re_node_set_remove_at(re_node_set *set , int idx___3 ) 
{ 


  {
#line 1415
  if (idx___3 < 0) {
#line 1416
    return;
  } else
#line 1415
  if (idx___3 >= set->nelem) {
#line 1416
    return;
  }
#line 1417
  (set->nelem) --;
  {
#line 1418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1418
    if (! (idx___3 < set->nelem)) {
#line 1418
      goto while_break;
    }
#line 1419
    *(set->elems + idx___3) = *(set->elems + (idx___3 + 1));
#line 1418
    idx___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1420
  return;
}
}
#line 1426 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static int re_dfa_add_node(re_dfa_t *dfa___0 , re_token_t token ) 
{ 
  size_t new_nodes_alloc ;
  int *new_nexts ;
  int *new_indices ;
  re_node_set *new_edests ;
  re_node_set *new_eclosures ;
  re_token_t *new_nodes ;
  size_t max_object_size ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;

  {
  {
#line 1430
  tmp___12 = __builtin_expect((long )(dfa___0->nodes_len >= dfa___0->nodes_alloc),
                              0L);
  }
#line 1430
  if (tmp___12) {
    {
#line 1432
    new_nodes_alloc = dfa___0->nodes_alloc * 2UL;
#line 1438
    tmp___1 = MAX(sizeof(re_node_set ), sizeof(int ));
#line 1438
    tmp___2 = MAX(sizeof(re_token_t ), (size_t )tmp___1);
#line 1438
    max_object_size = (size_t )tmp___2;
#line 1441
    tmp___3 = __builtin_expect((long )(0xffffffffffffffffUL / max_object_size < new_nodes_alloc),
                               0L);
    }
#line 1441
    if (tmp___3) {
#line 1442
      return (-1);
    }
    {
#line 1444
    tmp___4 = realloc((void *)dfa___0->nodes, new_nodes_alloc * sizeof(re_token_t ));
#line 1444
    new_nodes = (re_token_t *)tmp___4;
#line 1445
    tmp___5 = __builtin_expect((long )((unsigned long )new_nodes == (unsigned long )((void *)0)),
                               0L);
    }
#line 1445
    if (tmp___5) {
#line 1446
      return (-1);
    }
    {
#line 1447
    dfa___0->nodes = new_nodes;
#line 1448
    tmp___6 = realloc((void *)dfa___0->nexts, new_nodes_alloc * sizeof(int ));
#line 1448
    new_nexts = (int *)tmp___6;
#line 1449
    tmp___7 = realloc((void *)dfa___0->org_indices, new_nodes_alloc * sizeof(int ));
#line 1449
    new_indices = (int *)tmp___7;
#line 1450
    tmp___8 = realloc((void *)dfa___0->edests, new_nodes_alloc * sizeof(re_node_set ));
#line 1450
    new_edests = (re_node_set *)tmp___8;
#line 1451
    tmp___9 = realloc((void *)dfa___0->eclosures, new_nodes_alloc * sizeof(re_node_set ));
#line 1451
    new_eclosures = (re_node_set *)tmp___9;
    }
#line 1452
    if ((unsigned long )new_nexts == (unsigned long )((void *)0)) {
#line 1452
      tmp___10 = 1;
    } else
#line 1452
    if ((unsigned long )new_indices == (unsigned long )((void *)0)) {
#line 1452
      tmp___10 = 1;
    } else
#line 1452
    if ((unsigned long )new_edests == (unsigned long )((void *)0)) {
#line 1452
      tmp___10 = 1;
    } else
#line 1452
    if ((unsigned long )new_eclosures == (unsigned long )((void *)0)) {
#line 1452
      tmp___10 = 1;
    } else {
#line 1452
      tmp___10 = 0;
    }
    {
#line 1452
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 1452
    if (tmp___11) {
#line 1454
      return (-1);
    }
#line 1455
    dfa___0->nexts = new_nexts;
#line 1456
    dfa___0->org_indices = new_indices;
#line 1457
    dfa___0->edests = new_edests;
#line 1458
    dfa___0->eclosures = new_eclosures;
#line 1459
    dfa___0->nodes_alloc = new_nodes_alloc;
  }
#line 1461
  *(dfa___0->nodes + dfa___0->nodes_len) = token;
#line 1462
  (dfa___0->nodes + dfa___0->nodes_len)->constraint = 0U;
#line 1464
  if ((unsigned int )token.type == 5U) {
#line 1464
    if (dfa___0->mb_cur_max > 1) {
#line 1464
      tmp___13 = 1;
    } else {
#line 1464
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1464
  if ((unsigned int )token.type == 6U) {
#line 1464
    tmp___13 = 1;
  } else {
#line 1464
    tmp___13 = 0;
  }
  {
#line 1464
  (dfa___0->nodes + dfa___0->nodes_len)->accept_mb = (unsigned int )tmp___13;
#line 1467
  *(dfa___0->nexts + dfa___0->nodes_len) = -1;
#line 1468
  memset((void *)(dfa___0->edests + dfa___0->nodes_len), '\000', sizeof(re_node_set ));
#line 1469
  memset((void *)(dfa___0->eclosures + dfa___0->nodes_len), '\000', sizeof(re_node_set ));
#line 1470
  tmp___14 = dfa___0->nodes_len;
#line 1470
  (dfa___0->nodes_len) ++;
  }
#line 1470
  return ((int )tmp___14);
}
}
#line 1473 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
__inline static unsigned int calc_state_hash(re_node_set const   *nodes , unsigned int context ) 
{ 
  unsigned int hash___0 ;
  int i___0 ;

  {
#line 1477
  hash___0 = (unsigned int )nodes->nelem + context;
#line 1479
  i___0 = 0;
  {
#line 1479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1479
    if (! (i___0 < (int )nodes->nelem)) {
#line 1479
      goto while_break;
    }
#line 1480
    hash___0 += (unsigned int )*(nodes->elems + i___0);
#line 1479
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1481
  return (hash___0);
}
}
#line 1493 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static re_dfastate_t *re_acquire_state(reg_errcode_t *err___0 , re_dfa_t const   *dfa___0 ,
                                       re_node_set const   *nodes ) 
{ 
  unsigned int hash___0 ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  int i___0 ;
  long tmp___1 ;
  re_dfastate_t *state___2 ;
  int __attribute__((__pure__))  tmp___2 ;
  long tmp___3 ;

  {
  {
#line 1502
  tmp___1 = __builtin_expect((long )(nodes->nelem == 0), 0L);
  }
#line 1502
  if (tmp___1) {
#line 1504
    *err___0 = (reg_errcode_t )0;
#line 1505
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1507
  hash___0 = calc_state_hash(nodes, 0U);
#line 1508
  spot = (struct re_state_table_entry *)(dfa___0->state_table + (hash___0 & (unsigned int )dfa___0->state_hash_mask));
#line 1510
  i___0 = 0;
  }
  {
#line 1510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1510
    if (! (i___0 < spot->num)) {
#line 1510
      goto while_break;
    }
#line 1512
    state___2 = *(spot->array + i___0);
#line 1513
    if (hash___0 != state___2->hash) {
#line 1514
      goto __Cont;
    }
    {
#line 1515
    tmp___2 = re_node_set_compare((re_node_set const   *)(& state___2->nodes), nodes);
    }
#line 1515
    if (tmp___2) {
#line 1516
      return (state___2);
    }
    __Cont: /* CIL Label */ 
#line 1510
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1520
  new_state = create_ci_newstate(dfa___0, nodes, hash___0);
#line 1521
  tmp___3 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1521
  if (tmp___3) {
#line 1522
    *err___0 = (reg_errcode_t )12;
  }
#line 1524
  return (new_state);
}
}
#line 1537 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static re_dfastate_t *re_acquire_state_context(reg_errcode_t *err___0 , re_dfa_t const   *dfa___0 ,
                                               re_node_set const   *nodes , unsigned int context ) 
{ 
  unsigned int hash___0 ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  int i___0 ;
  re_dfastate_t *state___2 ;
  int __attribute__((__pure__))  tmp___1 ;
  long tmp___2 ;

  {
#line 1546
  if (nodes->nelem == 0) {
#line 1548
    *err___0 = (reg_errcode_t )0;
#line 1549
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1551
  hash___0 = calc_state_hash(nodes, context);
#line 1552
  spot = (struct re_state_table_entry *)(dfa___0->state_table + (hash___0 & (unsigned int )dfa___0->state_hash_mask));
#line 1554
  i___0 = 0;
  }
  {
#line 1554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1554
    if (! (i___0 < spot->num)) {
#line 1554
      goto while_break;
    }
#line 1556
    state___2 = *(spot->array + i___0);
#line 1557
    if (state___2->hash == hash___0) {
#line 1557
      if (state___2->context == context) {
        {
#line 1557
        tmp___1 = re_node_set_compare((re_node_set const   *)state___2->entrance_nodes,
                                      nodes);
        }
#line 1557
        if (tmp___1) {
#line 1560
          return (state___2);
        }
      }
    }
#line 1554
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1563
  new_state = create_cd_newstate(dfa___0, nodes, context, hash___0);
#line 1564
  tmp___2 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1564
  if (tmp___2) {
#line 1565
    *err___0 = (reg_errcode_t )12;
  }
#line 1567
  return (new_state);
}
}
#line 1574 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static reg_errcode_t register_state(re_dfa_t const   *dfa___0 , re_dfastate_t *newstate ,
                                    unsigned int hash___0 ) 
{ 
  struct re_state_table_entry *spot ;
  reg_errcode_t err___0 ;
  int i___0 ;
  long tmp___1 ;
  int elem ;
  int tmp___2 ;
  int new_alloc ;
  re_dfastate_t **new_array ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1583
  newstate->hash = hash___0;
#line 1584
  err___0 = re_node_set_alloc(& newstate->non_eps_nodes, newstate->nodes.nelem);
#line 1585
  tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1585
  if (tmp___1) {
#line 1586
    return ((reg_errcode_t )12);
  }
#line 1587
  i___0 = 0;
  {
#line 1587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1587
    if (! (i___0 < newstate->nodes.nelem)) {
#line 1587
      goto while_break;
    }
#line 1589
    elem = *(newstate->nodes.elems + i___0);
#line 1590
    if (! ((unsigned int )(dfa___0->nodes + elem)->type & 8U)) {
      {
#line 1591
      tmp___2 = re_node_set_insert_last(& newstate->non_eps_nodes, elem);
      }
#line 1591
      if (tmp___2 < 0) {
#line 1592
        return ((reg_errcode_t )12);
      }
    }
#line 1587
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1595
  spot = (struct re_state_table_entry *)(dfa___0->state_table + (hash___0 & (unsigned int )dfa___0->state_hash_mask));
#line 1596
  tmp___5 = __builtin_expect((long )(spot->alloc <= spot->num), 0L);
  }
#line 1596
  if (tmp___5) {
    {
#line 1598
    new_alloc = 2 * spot->num + 2;
#line 1599
    tmp___3 = realloc((void *)spot->array, (unsigned long )new_alloc * sizeof(re_dfastate_t *));
#line 1599
    new_array = (re_dfastate_t **)tmp___3;
#line 1601
    tmp___4 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 1601
    if (tmp___4) {
#line 1602
      return ((reg_errcode_t )12);
    }
#line 1603
    spot->array = new_array;
#line 1604
    spot->alloc = new_alloc;
  }
#line 1606
  tmp___6 = spot->num;
#line 1606
  (spot->num) ++;
#line 1606
  *(spot->array + tmp___6) = newstate;
#line 1607
  return ((reg_errcode_t )0);
}
}
#line 1610 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static void free_state(re_dfastate_t *state___2 ) 
{ 


  {
  {
#line 1613
  free((void *)state___2->non_eps_nodes.elems);
#line 1614
  free((void *)state___2->inveclosure.elems);
  }
#line 1615
  if ((unsigned long )state___2->entrance_nodes != (unsigned long )(& state___2->nodes)) {
    {
#line 1617
    free((void *)(state___2->entrance_nodes)->elems);
#line 1618
    free((void *)state___2->entrance_nodes);
    }
  }
  {
#line 1620
  free((void *)state___2->nodes.elems);
#line 1621
  free((void *)state___2->word_trtable);
#line 1622
  free((void *)state___2->trtable);
#line 1623
  free((void *)state___2);
  }
#line 1624
  return;
}
}
#line 1629 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa___0 , re_node_set const   *nodes ,
                                         unsigned int hash___0 ) 
{ 
  int i___0 ;
  reg_errcode_t err___0 ;
  re_dfastate_t *newstate ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  re_token_t *node ;
  re_token_type_t type ;
  long tmp___4 ;

  {
  {
#line 1638
  tmp___1 = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1638
  newstate = (re_dfastate_t *)tmp___1;
#line 1639
  tmp___2 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
#line 1639
  if (tmp___2) {
#line 1640
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1641
  err___0 = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1642
  tmp___3 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1642
  if (tmp___3) {
    {
#line 1644
    free((void *)newstate);
    }
#line 1645
    return ((re_dfastate_t *)((void *)0));
  }
#line 1648
  newstate->entrance_nodes = & newstate->nodes;
#line 1649
  i___0 = 0;
  {
#line 1649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1649
    if (! (i___0 < (int )nodes->nelem)) {
#line 1649
      goto while_break;
    }
#line 1651
    node = (re_token_t *)(dfa___0->nodes + *(nodes->elems + i___0));
#line 1652
    type = node->type;
#line 1653
    if ((unsigned int )type == 1U) {
#line 1653
      if (! node->constraint) {
#line 1654
        goto __Cont;
      }
    }
#line 1656
    newstate->accept_mb |= node->accept_mb;
#line 1660
    if ((unsigned int )type == 2U) {
#line 1661
      newstate->halt = 1U;
    } else
#line 1662
    if ((unsigned int )type == 4U) {
#line 1663
      newstate->has_backref = 1U;
    } else
#line 1664
    if ((unsigned int )type == 12U) {
#line 1665
      newstate->has_constraint = 1U;
    } else
#line 1664
    if (node->constraint) {
#line 1665
      newstate->has_constraint = 1U;
    }
    __Cont: /* CIL Label */ 
#line 1649
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1667
  err___0 = register_state(dfa___0, newstate, hash___0);
#line 1668
  tmp___4 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1668
  if (tmp___4) {
    {
#line 1670
    free_state(newstate);
#line 1671
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1673
  return (newstate);
}
}
#line 1679 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regex_internal.c"
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa___0 , re_node_set const   *nodes ,
                                         unsigned int context , unsigned int hash___0 ) 
{ 
  int i___0 ;
  int nctx_nodes ;
  reg_errcode_t err___0 ;
  re_dfastate_t *newstate ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  void *tmp___4 ;
  long tmp___5 ;
  reg_errcode_t tmp___6 ;
  long tmp___7 ;

  {
  {
#line 1684
  nctx_nodes = 0;
#line 1688
  tmp___1 = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1688
  newstate = (re_dfastate_t *)tmp___1;
#line 1689
  tmp___2 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
#line 1689
  if (tmp___2) {
#line 1690
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1691
  err___0 = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1692
  tmp___3 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1692
  if (tmp___3) {
    {
#line 1694
    free((void *)newstate);
    }
#line 1695
    return ((re_dfastate_t *)((void *)0));
  }
#line 1698
  newstate->context = context;
#line 1699
  newstate->entrance_nodes = & newstate->nodes;
#line 1701
  i___0 = 0;
  {
#line 1701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1701
    if (! (i___0 < (int )nodes->nelem)) {
#line 1701
      goto while_break;
    }
#line 1703
    node = (re_token_t *)(dfa___0->nodes + *(nodes->elems + i___0));
#line 1704
    type = node->type;
#line 1705
    constraint = node->constraint;
#line 1707
    if ((unsigned int )type == 1U) {
#line 1707
      if (! constraint) {
#line 1708
        goto __Cont;
      }
    }
#line 1710
    newstate->accept_mb |= node->accept_mb;
#line 1714
    if ((unsigned int )type == 2U) {
#line 1715
      newstate->halt = 1U;
    } else
#line 1716
    if ((unsigned int )type == 4U) {
#line 1717
      newstate->has_backref = 1U;
    }
#line 1719
    if (constraint) {
#line 1721
      if ((unsigned long )newstate->entrance_nodes == (unsigned long )(& newstate->nodes)) {
        {
#line 1723
        tmp___4 = malloc(sizeof(re_node_set ));
#line 1723
        newstate->entrance_nodes = (re_node_set *)tmp___4;
#line 1724
        tmp___5 = __builtin_expect((long )((unsigned long )newstate->entrance_nodes == (unsigned long )((void *)0)),
                                   0L);
        }
#line 1724
        if (tmp___5) {
          {
#line 1726
          free_state(newstate);
          }
#line 1727
          return ((re_dfastate_t *)((void *)0));
        }
        {
#line 1729
        tmp___6 = re_node_set_init_copy(newstate->entrance_nodes, nodes);
        }
#line 1729
        if ((int )tmp___6 != 0) {
#line 1731
          return ((re_dfastate_t *)((void *)0));
        }
#line 1732
        nctx_nodes = 0;
#line 1733
        newstate->has_constraint = 1U;
      }
#line 1736
      if (constraint & 1U) {
#line 1736
        if (! (context & 1U)) {
          {
#line 1738
          re_node_set_remove_at(& newstate->nodes, i___0 - nctx_nodes);
#line 1739
          nctx_nodes ++;
          }
        } else {
#line 1736
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1736
      if (constraint & 2U) {
#line 1736
        if (context & 1U) {
          {
#line 1738
          re_node_set_remove_at(& newstate->nodes, i___0 - nctx_nodes);
#line 1739
          nctx_nodes ++;
          }
        } else {
#line 1736
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1736
      if (constraint & 16U) {
#line 1736
        if (! (context & (unsigned int )(1 << 1))) {
          {
#line 1738
          re_node_set_remove_at(& newstate->nodes, i___0 - nctx_nodes);
#line 1739
          nctx_nodes ++;
          }
        } else {
#line 1736
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1736
      if (constraint & 64U) {
#line 1736
        if (! (context & (unsigned int )((1 << 1) << 1))) {
          {
#line 1738
          re_node_set_remove_at(& newstate->nodes, i___0 - nctx_nodes);
#line 1739
          nctx_nodes ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1701
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1743
  err___0 = register_state(dfa___0, newstate, hash___0);
#line 1744
  tmp___7 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1744
  if (tmp___7) {
    {
#line 1746
    free_state(newstate);
#line 1747
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1749
  return (newstate);
}
}
#line 20 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) ;
#line 22
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) ;
#line 25
static reg_errcode_t init_dfa(re_dfa_t *dfa___0 , size_t pat_len ) ;
#line 27
static void free_charset(re_charset_t *cset ) ;
#line 29
static void free_workarea_compile(regex_t *preg ) ;
#line 30
static reg_errcode_t create_initial_state(re_dfa_t *dfa___0 ) ;
#line 32
static void optimize_utf8(re_dfa_t *dfa___0 ) ;
#line 34
static reg_errcode_t analyze(regex_t *preg ) ;
#line 35
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) ;
#line 38
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) ;
#line 41
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) ;
#line 42
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) ;
#line 43
static bin_tree_t *lower_subexp(reg_errcode_t *err___0 , regex_t *preg , bin_tree_t *node ) ;
#line 45
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) ;
#line 46
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) ;
#line 47
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) ;
#line 48
static int duplicate_node(re_dfa_t *dfa___0 , int org_idx , unsigned int constraint ) ;
#line 49
static int search_duplicated_node(re_dfa_t const   *dfa___0 , int org_node , unsigned int constraint ) ;
#line 51
static reg_errcode_t calc_eclosure(re_dfa_t *dfa___0 ) ;
#line 52
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa___0 ,
                                        int node , int root ) ;
#line 54
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa___0 ) ;
#line 55
static int fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) ;
#line 57
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) ;
#line 59
static bin_tree_t *parse(re_string_t *regexp___0 , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err___0 ) ;
#line 61
static bin_tree_t *parse_reg_exp(re_string_t *regexp___0 , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err___0 ) ;
#line 64
static bin_tree_t *parse_branch(re_string_t *regexp___0 , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , int nest , reg_errcode_t *err___0 ) ;
#line 67
static bin_tree_t *parse_expression(re_string_t *regexp___0 , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , int nest , reg_errcode_t *err___0 ) ;
#line 70
static bin_tree_t *parse_sub_exp(re_string_t *regexp___0 , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err___0 ) ;
#line 73
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp___0 , re_dfa_t *dfa___0 ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err___0 ) ;
#line 76
static bin_tree_t *parse_bracket_exp(re_string_t *regexp___0 , re_dfa_t *dfa___0 ,
                                     re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err___0 ) ;
#line 79
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp___0 ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa___0 ,
                                           reg_syntax_t syntax , int accept_hyphen ) ;
#line 85
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp___0 ,
                                          re_token_t *token ) ;
#line 89
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                       int *equiv_class_alloc , unsigned char const   *name ) ;
#line 93
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , int *char_class_alloc ,
                                     char const   *class_name , reg_syntax_t syntax ) ;
#line 107
static bin_tree_t *build_charclass_op(re_dfa_t *dfa___0 , unsigned char *trans , char const   *class_name ,
                                      char const   *extra , int non_match , reg_errcode_t *err___0 ) ;
#line 112
static bin_tree_t *create_tree(re_dfa_t *dfa___0 , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) ;
#line 115
static bin_tree_t *create_token_tree(re_dfa_t *dfa___0 , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) ;
#line 118
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa___0 ) ;
#line 119
static void free_token(re_token_t *node ) ;
#line 120
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) ;
#line 121
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) ;
#line 128 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
char const   __re_error_msgid[369]  = 
#line 128
  {      (char const   )'S',      (char const   )'u',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'\000',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'h',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'[',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'[',      (char const   )'^', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'(', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )'{',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'\\', 
        (char const   )'{',      (char const   )'\\',      (char const   )'}',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'M',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'h', 
        (char const   )'a',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )'\000',      (char const   )'I', 
        (char const   )'n',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'P',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'R',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )'o',      (char const   )' ',      (char const   )'b', 
        (char const   )'i',      (char const   )'g',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )')',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\\',      (char const   )')', 
        (char const   )'\000'};
#line 182 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
size_t const   __re_error_msgid_idx[17]  = 
#line 182
  {      (size_t const   )0,      (size_t const   )sizeof("Success"),      (size_t const   )(sizeof("Success") + sizeof("No match")),      (size_t const   )((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")), 
        (size_t const   )(((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")),      (size_t const   )((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")),      (size_t const   )(((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")),      (size_t const   )((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")), 
        (size_t const   )(((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")),      (size_t const   )((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")),      (size_t const   )(((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")),      (size_t const   )((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")), 
        (size_t const   )(((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")),      (size_t const   )((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")),      (size_t const   )(((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")),      (size_t const   )((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")), 
        (size_t const   )(((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")) + sizeof("Regular expression too big"))};
#line 233 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;
  char *tmp___1 ;

  {
  {
#line 244
  bufp->no_sub = (unsigned int )(! (! (re_syntax_options & (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))));
#line 247
  bufp->newline_anchor = 1U;
#line 249
  ret = re_compile_internal(bufp, pattern, length, re_syntax_options);
  }
#line 251
  if (! ret) {
#line 252
    return ((char const   *)((void *)0));
  }
  {
#line 253
  tmp___1 = gettext(__re_error_msgid + __re_error_msgid_idx[(int )ret]);
  }
#line 253
  return ((char const   *)tmp___1);
}
}
#line 274 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
#line 278
  ret = re_syntax_options;
#line 280
  re_syntax_options = syntax;
#line 281
  return (ret);
}
}
#line 287 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
int re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  re_dfa_t *dfa___0 ;
  char *fastmap ;

  {
  {
#line 291
  dfa___0 = (re_dfa_t *)bufp->buffer;
#line 292
  fastmap = bufp->fastmap;
#line 294
  memset((void *)fastmap, '\000', sizeof(char ) * 256UL);
#line 295
  re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa___0->init_state, fastmap);
  }
#line 296
  if ((unsigned long )dfa___0->init_state != (unsigned long )dfa___0->init_state_word) {
    {
#line 297
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa___0->init_state_word,
                            fastmap);
    }
  }
#line 298
  if ((unsigned long )dfa___0->init_state != (unsigned long )dfa___0->init_state_nl) {
    {
#line 299
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa___0->init_state_nl,
                            fastmap);
    }
  }
#line 300
  if ((unsigned long )dfa___0->init_state != (unsigned long )dfa___0->init_state_begbuf) {
    {
#line 301
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa___0->init_state_begbuf,
                            fastmap);
    }
  }
#line 302
  bufp->fastmap_accurate = 1U;
#line 303
  return (0);
}
}
#line 309 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
__inline static void ( __attribute__((__always_inline__)) re_set_fastmap)(char *fastmap ,
                                                                          int icase ,
                                                                          int ch ) 
{ 
  int tmp___1 ;

  {
#line 313
  *(fastmap + ch) = (char)1;
#line 314
  if (icase) {
    {
#line 315
    tmp___1 = tolower(ch);
#line 315
    *(fastmap + tmp___1) = (char)1;
    }
  }
#line 316
  return;
}
}
#line 321 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) 
{ 
  re_dfa_t volatile   *dfa___0 ;
  int node_cnt ;
  int icase ;
  int tmp___1 ;
  int node ;
  re_token_type_t type ;
  unsigned char *buf___7 ;
  void *tmp___2 ;
  unsigned char *p ;
  wchar_t wc ;
  mbstate_t state___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  size_t tmp___5 ;
  wint_t tmp___6 ;
  size_t tmp___7 ;
  int i___0 ;
  int ch ;
  int j ;
  bitset_word_t w___0 ;
  re_charset_t *cset ;
  int i___1 ;
  unsigned char c ;
  mbstate_t mbs___0 ;
  size_t tmp___8 ;
  char buf___8[256] ;
  mbstate_t state___3 ;
  size_t tmp___9 ;
  wint_t tmp___10 ;
  size_t tmp___11 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;

  {
#line 325
  dfa___0 = (re_dfa_t volatile   *)((re_dfa_t *)bufp->buffer);
#line 327
  if (dfa___0->mb_cur_max == (int volatile   )1) {
#line 327
    if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 327
      tmp___1 = 1;
    } else {
#line 327
      tmp___1 = 0;
    }
  } else {
#line 327
    tmp___1 = 0;
  }
#line 327
  icase = tmp___1;
#line 328
  node_cnt = 0;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (node_cnt < (int )init_state->nodes.nelem)) {
#line 328
      goto while_break;
    }
#line 330
    node = *(init_state->nodes.elems + node_cnt);
#line 331
    type = (dfa___0->nodes + node)->type;
#line 333
    if ((unsigned int )type == 1U) {
      {
#line 335
      re_set_fastmap(fastmap, icase, (int )(dfa___0->nodes + node)->opr.c);
      }
#line 337
      if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 337
        if (dfa___0->mb_cur_max > (int volatile   )1) {
          {
#line 339
          tmp___2 = malloc((unsigned long )dfa___0->mb_cur_max * sizeof(unsigned char ));
#line 339
          buf___7 = (unsigned char *)tmp___2;
#line 343
          p = buf___7;
#line 344
          tmp___3 = p;
#line 344
          p ++;
#line 344
          *tmp___3 = (dfa___0->nodes + node)->opr.c;
          }
          {
#line 345
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 345
            node ++;
#line 345
            if ((size_t volatile   )node < dfa___0->nodes_len) {
#line 345
              if ((unsigned int )(dfa___0->nodes + node)->type == 1U) {
#line 345
                if (! (dfa___0->nodes + node)->mb_partial) {
#line 345
                  goto while_break___0;
                }
              } else {
#line 345
                goto while_break___0;
              }
            } else {
#line 345
              goto while_break___0;
            }
#line 348
            tmp___4 = p;
#line 348
            p ++;
#line 348
            *tmp___4 = (dfa___0->nodes + node)->opr.c;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 349
          memset((void *)(& state___2), '\000', sizeof(state___2));
#line 350
          tmp___5 = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)((char const   *)buf___7),
                            (size_t )(p - buf___7), & state___2);
          }
#line 350
          if (tmp___5 == (size_t )(p - buf___7)) {
            {
#line 350
            tmp___6 = towlower((wint_t )wc);
#line 350
            tmp___7 = wcrtomb((char */* __restrict  */)((char *)buf___7), (wchar_t )tmp___6,
                              (mbstate_t */* __restrict  */)(& state___2));
            }
#line 350
            if (tmp___7 != 0xffffffffffffffffUL) {
              {
#line 354
              re_set_fastmap(fastmap, 0, (int )*(buf___7 + 0));
              }
            }
          }
          {
#line 355
          free((void *)buf___7);
          }
        }
      }
    } else
#line 359
    if ((unsigned int )type == 3U) {
#line 362
      i___0 = 0;
#line 362
      ch = 0;
      {
#line 362
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 362
        if (! ((unsigned long )i___0 < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 362
          goto while_break___1;
        }
#line 365
        w___0 = *((dfa___0->nodes + node)->opr.sbcset + i___0);
#line 366
        j = 0;
        {
#line 366
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 366
          if (! ((unsigned long )j < sizeof(bitset_word_t ) * 8UL)) {
#line 366
            goto while_break___2;
          }
#line 367
          if (w___0 & (1UL << j)) {
            {
#line 368
            re_set_fastmap(fastmap, icase, ch);
            }
          }
#line 366
          j ++;
#line 366
          ch ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 362
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 372
    if ((unsigned int )type == 6U) {
#line 374
      cset = (dfa___0->nodes + node)->opr.mbcset;
#line 399
      if (dfa___0->mb_cur_max > (int volatile   )1) {
#line 399
        if (cset->nchar_classes) {
#line 399
          goto _L___0;
        } else
#line 399
        if (cset->non_match) {
#line 399
          goto _L___0;
        } else
#line 399
        if (cset->nranges) {
          _L___0: /* CIL Label */ 
#line 406
          c = (unsigned char)0;
          {
#line 407
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 410
            memset((void *)(& mbs___0), 0, sizeof(mbs___0));
#line 411
            tmp___8 = mbrtowc((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)((char *)(& c)),
                              (size_t )1, & mbs___0);
            }
#line 411
            if (tmp___8 == 0xfffffffffffffffeUL) {
              {
#line 412
              re_set_fastmap(fastmap, 0, (int )c);
              }
            }
#line 407
            c = (unsigned char )((int )c + 1);
#line 407
            if (! ((int )c != 0)) {
#line 407
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
#line 399
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 420
        i___1 = 0;
        {
#line 420
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 420
          if (! (i___1 < cset->nmbchars)) {
#line 420
            goto while_break___4;
          }
          {
#line 424
          memset((void *)(& state___3), '\000', sizeof(state___3));
#line 425
          tmp___9 = wcrtomb((char */* __restrict  */)(buf___8), *(cset->mbchars + i___1),
                            (mbstate_t */* __restrict  */)(& state___3));
          }
#line 425
          if (tmp___9 != 0xffffffffffffffffUL) {
            {
#line 426
            re_set_fastmap(fastmap, icase, (int )*((unsigned char *)(buf___8)));
            }
          }
#line 427
          if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 427
            if (dfa___0->mb_cur_max > (int volatile   )1) {
              {
#line 429
              tmp___10 = towlower((wint_t )*(cset->mbchars + i___1));
#line 429
              tmp___11 = wcrtomb((char */* __restrict  */)(buf___8), (wchar_t )tmp___10,
                                 (mbstate_t */* __restrict  */)(& state___3));
              }
#line 429
              if (tmp___11 != 0xffffffffffffffffUL) {
                {
#line 431
                re_set_fastmap(fastmap, 0, (int )*((unsigned char *)(buf___8)));
                }
              }
            }
          }
#line 420
          i___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    } else
#line 437
    if ((unsigned int )type == 5U) {
#line 437
      goto _L___1;
    } else
#line 437
    if ((unsigned int )type == 7U) {
#line 437
      goto _L___1;
    } else
#line 437
    if ((unsigned int )type == 2U) {
      _L___1: /* CIL Label */ 
      {
#line 443
      memset((void *)fastmap, '\001', sizeof(char ) * 256UL);
      }
#line 444
      if ((unsigned int )type == 2U) {
#line 445
        bufp->can_be_null = 1U;
      }
#line 446
      return;
    }
#line 328
    node_cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  return;
}
}
#line 487 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
int regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  long tmp___6 ;

  {
#line 494
  if (cflags & 1) {
#line 494
    tmp___1 = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 494
    tmp___1 = (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
  {
#line 494
  syntax = tmp___1;
#line 497
  preg->buffer = (unsigned char *)((void *)0);
#line 498
  preg->allocated = 0UL;
#line 499
  preg->used = 0UL;
#line 502
  tmp___2 = malloc(256UL * sizeof(char ));
#line 502
  preg->fastmap = (char *)tmp___2;
#line 503
  tmp___3 = __builtin_expect((long )((unsigned long )preg->fastmap == (unsigned long )((void *)0)),
                             0L);
  }
#line 503
  if (tmp___3) {
#line 504
    return (12);
  }
#line 506
  if (cflags & (1 << 1)) {
#line 506
    tmp___4 = (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  } else {
#line 506
    tmp___4 = 0UL;
  }
#line 506
  syntax |= tmp___4;
#line 509
  if (cflags & ((1 << 1) << 1)) {
#line 511
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
#line 512
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 514
    preg->newline_anchor = 1U;
  } else {
#line 517
    preg->newline_anchor = 0U;
  }
  {
#line 518
  preg->no_sub = (unsigned int )(! (! (cflags & (((1 << 1) << 1) << 1))));
#line 519
  preg->translate = (unsigned char *)((void *)0);
#line 521
  tmp___5 = strlen((char const   *)pattern);
#line 521
  ret = re_compile_internal((regex_t *)preg, (char const   *)pattern, tmp___5, syntax);
  }
#line 525
  if ((int )ret == 16) {
#line 526
    ret = (reg_errcode_t )8;
  }
  {
#line 529
  tmp___6 = __builtin_expect((long )((int )ret == 0), 1L);
  }
#line 529
  if (tmp___6) {
    {
#line 532
    re_compile_fastmap((struct re_pattern_buffer *)preg);
    }
  } else {
    {
#line 536
    free((void *)preg->fastmap);
#line 537
    preg->fastmap = (char *)((void *)0);
    }
  }
#line 540
  return ((int )ret);
}
}
#line 549 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
size_t regerror(int errcode , regex_t const   * __restrict  preg , char * __restrict  errbuf ,
                size_t errbuf_size ) 
{ 
  char const   *msg___0 ;
  size_t msg_size ;
  int tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 559
  if (errcode < 0) {
#line 559
    tmp___1 = 1;
  } else
#line 559
  if (errcode >= (int )(sizeof(__re_error_msgid_idx) / sizeof(__re_error_msgid_idx[0]))) {
#line 559
    tmp___1 = 1;
  } else {
#line 559
    tmp___1 = 0;
  }
  {
#line 559
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 559
  if (tmp___2) {
    {
#line 566
    abort();
    }
  }
  {
#line 568
  tmp___3 = gettext(__re_error_msgid + __re_error_msgid_idx[errcode]);
#line 568
  msg___0 = (char const   *)tmp___3;
#line 570
  tmp___4 = strlen(msg___0);
#line 570
  msg_size = tmp___4 + 1UL;
#line 572
  tmp___6 = __builtin_expect((long )(errbuf_size != 0UL), 1L);
  }
#line 572
  if (tmp___6) {
    {
#line 574
    tmp___5 = __builtin_expect((long )(msg_size > errbuf_size), 0L);
    }
#line 574
    if (tmp___5) {
      {
#line 579
      memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg___0,
             errbuf_size - 1UL);
#line 580
      *(errbuf + (errbuf_size - 1UL)) = (char)0;
      }
    } else {
      {
#line 584
      memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg___0,
             msg_size);
      }
    }
  }
#line 587
  return (msg_size);
}
}
#line 600 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bitset_word_t utf8_sb_map[256UL / (sizeof(bitset_word_t ) * 8UL)]  = {      0xffffffffffffffffUL,      0xffffffffffffffffUL};
#line 610 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static void free_dfa_content(re_dfa_t *dfa___0 ) 
{ 
  int i___0 ;
  int j ;
  struct re_state_table_entry *entry ;
  re_dfastate_t *state___2 ;

  {
#line 615
  if (dfa___0->nodes) {
#line 616
    i___0 = 0;
    {
#line 616
    while (1) {
      while_continue: /* CIL Label */ ;
#line 616
      if (! ((size_t )i___0 < dfa___0->nodes_len)) {
#line 616
        goto while_break;
      }
      {
#line 617
      free_token(dfa___0->nodes + i___0);
#line 616
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 618
  free((void *)dfa___0->nexts);
#line 619
  i___0 = 0;
  }
  {
#line 619
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 619
    if (! ((size_t )i___0 < dfa___0->nodes_len)) {
#line 619
      goto while_break___0;
    }
#line 621
    if ((unsigned long )dfa___0->eclosures != (unsigned long )((void *)0)) {
      {
#line 622
      free((void *)(dfa___0->eclosures + i___0)->elems);
      }
    }
#line 623
    if ((unsigned long )dfa___0->inveclosures != (unsigned long )((void *)0)) {
      {
#line 624
      free((void *)(dfa___0->inveclosures + i___0)->elems);
      }
    }
#line 625
    if ((unsigned long )dfa___0->edests != (unsigned long )((void *)0)) {
      {
#line 626
      free((void *)(dfa___0->edests + i___0)->elems);
      }
    }
#line 619
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 628
  free((void *)dfa___0->edests);
#line 629
  free((void *)dfa___0->eclosures);
#line 630
  free((void *)dfa___0->inveclosures);
#line 631
  free((void *)dfa___0->nodes);
  }
#line 633
  if (dfa___0->state_table) {
#line 634
    i___0 = 0;
    {
#line 634
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 634
      if (! ((unsigned int )i___0 <= dfa___0->state_hash_mask)) {
#line 634
        goto while_break___1;
      }
#line 636
      entry = dfa___0->state_table + i___0;
#line 637
      j = 0;
      {
#line 637
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 637
        if (! (j < entry->num)) {
#line 637
          goto while_break___2;
        }
        {
#line 639
        state___2 = *(entry->array + j);
#line 640
        free_state(state___2);
#line 637
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 642
      free((void *)entry->array);
#line 634
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 644
  free((void *)dfa___0->state_table);
  }
#line 646
  if ((unsigned long )dfa___0->sb_char != (unsigned long )(utf8_sb_map)) {
    {
#line 647
    free((void *)dfa___0->sb_char);
    }
  }
  {
#line 649
  free((void *)dfa___0->subexp_map);
#line 654
  free((void *)dfa___0);
  }
#line 655
  return;
}
}
#line 660 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
void regfree(regex_t *preg ) 
{ 
  re_dfa_t *dfa___0 ;
  long tmp___1 ;

  {
  {
#line 664
  dfa___0 = (re_dfa_t *)preg->buffer;
#line 665
  tmp___1 = __builtin_expect((long )((unsigned long )dfa___0 != (unsigned long )((void *)0)),
                             1L);
  }
#line 665
  if (tmp___1) {
    {
#line 666
    free_dfa_content(dfa___0);
    }
  }
  {
#line 667
  preg->buffer = (unsigned char *)((void *)0);
#line 668
  preg->allocated = 0UL;
#line 670
  free((void *)preg->fastmap);
#line 671
  preg->fastmap = (char *)((void *)0);
#line 673
  free((void *)preg->translate);
#line 674
  preg->translate = (unsigned char *)((void *)0);
  }
#line 675
  return;
}
}
#line 753 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) 
{ 
  reg_errcode_t err___0 ;
  re_dfa_t *dfa___0 ;
  re_string_t regexp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 757
  err___0 = (reg_errcode_t )0;
#line 762
  preg->fastmap_accurate = 0U;
#line 763
  preg->syntax = syntax;
#line 764
  tmp___1 = 0U;
#line 764
  preg->not_eol = tmp___1;
#line 764
  preg->not_bol = tmp___1;
#line 765
  preg->used = 0UL;
#line 766
  preg->re_nsub = (size_t )0;
#line 767
  preg->can_be_null = 0U;
#line 768
  preg->regs_allocated = 0U;
#line 771
  dfa___0 = (re_dfa_t *)preg->buffer;
#line 772
  tmp___3 = __builtin_expect((long )(preg->allocated < sizeof(re_dfa_t )), 0L);
  }
#line 772
  if (tmp___3) {
    {
#line 778
    tmp___2 = realloc((void *)preg->buffer, sizeof(re_dfa_t ));
#line 778
    dfa___0 = (re_dfa_t *)tmp___2;
    }
#line 779
    if ((unsigned long )dfa___0 == (unsigned long )((void *)0)) {
#line 780
      return ((reg_errcode_t )12);
    }
#line 781
    preg->allocated = sizeof(re_dfa_t );
#line 782
    preg->buffer = (unsigned char *)dfa___0;
  }
  {
#line 784
  preg->used = sizeof(re_dfa_t );
#line 786
  err___0 = init_dfa(dfa___0, length);
#line 787
  tmp___4 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 787
  if (tmp___4) {
    {
#line 789
    free_dfa_content(dfa___0);
#line 790
    preg->buffer = (unsigned char *)((void *)0);
#line 791
    preg->allocated = 0UL;
    }
#line 792
    return (err___0);
  }
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 802
  err___0 = re_string_construct(& regexp___0, pattern, (int )length, preg->translate,
                                (int )(syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
                                (re_dfa_t const   *)dfa___0);
#line 804
  tmp___5 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 804
  if (tmp___5) {
    re_compile_internal_free_return: 
    {
#line 807
    free_workarea_compile(preg);
#line 808
    re_string_destruct(& regexp___0);
#line 809
    free_dfa_content(dfa___0);
#line 810
    preg->buffer = (unsigned char *)((void *)0);
#line 811
    preg->allocated = 0UL;
    }
#line 812
    return (err___0);
  }
  {
#line 816
  preg->re_nsub = (size_t )0;
#line 817
  dfa___0->str_tree = parse(& regexp___0, preg, syntax, & err___0);
#line 818
  tmp___6 = __builtin_expect((long )((unsigned long )dfa___0->str_tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 818
  if (tmp___6) {
#line 819
    goto re_compile_internal_free_return;
  }
  {
#line 822
  err___0 = analyze(preg);
#line 823
  tmp___7 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 823
  if (tmp___7) {
#line 824
    goto re_compile_internal_free_return;
  }
#line 828
  if (dfa___0->is_utf8) {
#line 828
    if (! (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 828
      if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
        {
#line 829
        optimize_utf8(dfa___0);
        }
      }
    }
  }
  {
#line 833
  err___0 = create_initial_state(dfa___0);
#line 836
  free_workarea_compile(preg);
#line 837
  re_string_destruct(& regexp___0);
#line 839
  tmp___8 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 839
  if (tmp___8) {
    {
#line 841
    free_dfa_content(dfa___0);
#line 842
    preg->buffer = (unsigned char *)((void *)0);
#line 843
    preg->allocated = 0UL;
    }
  }
#line 846
  return (err___0);
}
}
#line 852 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t init_dfa(re_dfa_t *dfa___0 , size_t pat_len ) 
{ 
  unsigned int table_size ;
  char *codeset_name ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int i___0 ;
  int j ;
  int ch ;
  void *tmp___7 ;
  long tmp___8 ;
  wint_t wch ;
  wint_t tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;

  {
  {
#line 864
  memset((void *)dfa___0, '\000', sizeof(re_dfa_t ));
#line 867
  dfa___0->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
  }
#line 870
  if (pat_len == 0xffffffffffffffffUL) {
#line 871
    return ((reg_errcode_t )12);
  }
  {
#line 873
  dfa___0->nodes_alloc = pat_len + 1UL;
#line 874
  tmp___1 = malloc(dfa___0->nodes_alloc * sizeof(re_token_t ));
#line 874
  dfa___0->nodes = (re_token_t *)tmp___1;
#line 877
  table_size = 1U;
  }
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    if ((size_t )table_size > pat_len) {
#line 879
      goto while_break;
    }
#line 877
    table_size <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 881
  tmp___2 = calloc(sizeof(struct re_state_table_entry ), (size_t )table_size);
#line 881
  dfa___0->state_table = (struct re_state_table_entry *)tmp___2;
#line 882
  dfa___0->state_hash_mask = table_size - 1U;
#line 887
  tmp___3 = __ctype_get_mb_cur_max();
#line 887
  dfa___0->mb_cur_max = (int )tmp___3;
#line 897
  codeset_name = nl_langinfo(14);
  }
#line 916
  if ((int )*(codeset_name + 0) == 85) {
#line 916
    goto _L___1;
  } else
#line 916
  if ((int )*(codeset_name + 0) == 117) {
    _L___1: /* CIL Label */ 
#line 916
    if ((int )*(codeset_name + 1) == 84) {
#line 916
      goto _L___0;
    } else
#line 916
    if ((int )*(codeset_name + 1) == 116) {
      _L___0: /* CIL Label */ 
#line 916
      if ((int )*(codeset_name + 2) == 70) {
#line 916
        goto _L;
      } else
#line 916
      if ((int )*(codeset_name + 2) == 102) {
        _L: /* CIL Label */ 
#line 916
        if ((int )*(codeset_name + 3) == 45) {
#line 916
          if ((int )*(codeset_name + 4) == 56) {
#line 916
            if ((int )*(codeset_name + 5) == 0) {
#line 916
              tmp___4 = 1;
            } else {
#line 916
              tmp___4 = 0;
            }
          } else {
#line 916
            tmp___4 = 0;
          }
#line 916
          tmp___6 = tmp___4;
        } else {
#line 916
          if ((int )*(codeset_name + 3) == 56) {
#line 916
            if ((int )*(codeset_name + 4) == 0) {
#line 916
              tmp___5 = 1;
            } else {
#line 916
              tmp___5 = 0;
            }
          } else {
#line 916
            tmp___5 = 0;
          }
#line 916
          tmp___6 = tmp___5;
        }
#line 916
        if (tmp___6) {
#line 922
          dfa___0->is_utf8 = 1U;
        }
      }
    }
  }
#line 931
  dfa___0->map_notascii = 0U;
#line 935
  if (dfa___0->mb_cur_max > 1) {
#line 937
    if (dfa___0->is_utf8) {
#line 951
      dfa___0->sb_char = (re_bitset_ptr_t )(utf8_sb_map);
    } else {
      {
#line 957
      tmp___7 = calloc(sizeof(bitset_t ), (size_t )1);
#line 957
      dfa___0->sb_char = (re_bitset_ptr_t )tmp___7;
#line 958
      tmp___8 = __builtin_expect((long )((unsigned long )dfa___0->sb_char == (unsigned long )((void *)0)),
                                 0L);
      }
#line 958
      if (tmp___8) {
#line 959
        return ((reg_errcode_t )12);
      }
#line 962
      i___0 = 0;
#line 962
      ch = 0;
      {
#line 962
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 962
        if (! ((unsigned long )i___0 < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 962
          goto while_break___0;
        }
#line 963
        j = 0;
        {
#line 963
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 963
          if (! ((unsigned long )j < sizeof(bitset_word_t ) * 8UL)) {
#line 963
            goto while_break___1;
          }
          {
#line 965
          tmp___9 = btowc(ch);
#line 965
          wch = tmp___9;
          }
#line 966
          if (wch != 4294967295U) {
#line 967
            *(dfa___0->sb_char + i___0) |= 1UL << j;
          }
#line 969
          if ((ch & -128) == 0) {
#line 969
            if (wch != (wint_t )ch) {
#line 970
              dfa___0->map_notascii = 1U;
            }
          }
#line 963
          j ++;
#line 963
          ch ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 962
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 977
  if ((unsigned long )dfa___0->nodes == (unsigned long )((void *)0)) {
#line 977
    tmp___10 = 1;
  } else
#line 977
  if ((unsigned long )dfa___0->state_table == (unsigned long )((void *)0)) {
#line 977
    tmp___10 = 1;
  } else {
#line 977
    tmp___10 = 0;
  }
  {
#line 977
  tmp___11 = __builtin_expect((long )tmp___10, 0L);
  }
#line 977
  if (tmp___11) {
#line 978
    return ((reg_errcode_t )12);
  }
#line 979
  return ((reg_errcode_t )0);
}
}
#line 986 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static void init_word_char(re_dfa_t *dfa___0 ) 
{ 
  int i___0 ;
  int j ;
  int ch ;
  unsigned short const   **tmp___1 ;

  {
#line 991
  dfa___0->word_ops_used = 1U;
#line 1025
  i___0 = 0;
#line 1025
  ch = 0;
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (! ((unsigned long )i___0 < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 1025
      goto while_break;
    }
#line 1026
    j = 0;
    {
#line 1026
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1026
      if (! ((unsigned long )j < sizeof(bitset_word_t ) * 8UL)) {
#line 1026
        goto while_break___0;
      }
      {
#line 1027
      tmp___1 = __ctype_b_loc();
      }
#line 1027
      if ((int const   )*(*tmp___1 + ch) & 8) {
#line 1028
        dfa___0->word_char[i___0] |= 1UL << j;
      } else
#line 1027
      if (ch == 95) {
#line 1028
        dfa___0->word_char[i___0] |= 1UL << j;
      }
#line 1026
      j ++;
#line 1026
      ch ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1025
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1029
  return;
}
}
#line 1033 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static void free_workarea_compile(regex_t *preg ) 
{ 
  re_dfa_t *dfa___0 ;
  bin_tree_storage_t *storage ;
  bin_tree_storage_t *next ;

  {
#line 1036
  dfa___0 = (re_dfa_t *)preg->buffer;
#line 1038
  storage = dfa___0->str_tree_storage;
  {
#line 1038
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1038
    if (! storage) {
#line 1038
      goto while_break;
    }
    {
#line 1040
    next = storage->next;
#line 1041
    free((void *)storage);
#line 1038
    storage = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1043
  dfa___0->str_tree_storage = (bin_tree_storage_t *)((void *)0);
#line 1044
  dfa___0->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
#line 1045
  dfa___0->str_tree = (bin_tree_t *)((void *)0);
#line 1046
  free((void *)dfa___0->org_indices);
#line 1047
  dfa___0->org_indices = (int *)((void *)0);
  }
#line 1048
  return;
}
}
#line 1052 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t create_initial_state(re_dfa_t *dfa___0 ) 
{ 
  int first___3 ;
  int i___0 ;
  reg_errcode_t err___0 ;
  re_node_set init_nodes ;
  long tmp___1 ;
  int node_idx ;
  re_token_type_t type ;
  int clexp_idx ;
  re_token_t *clexp_node ;
  int dest_idx ;
  reg_errcode_t err___1 ;
  reg_errcode_t tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  re_dfastate_t *tmp___7 ;
  re_dfastate_t *tmp___8 ;
  void *__cil_tmp20 ;

  {
  {
#line 1061
  first___3 = ((dfa___0->str_tree)->first)->node_idx;
#line 1062
  dfa___0->init_node = first___3;
#line 1063
  err___0 = re_node_set_init_copy(& init_nodes, (re_node_set const   *)(dfa___0->eclosures + first___3));
#line 1064
  tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1064
  if (tmp___1) {
#line 1065
    return (err___0);
  }
#line 1071
  if (dfa___0->nbackref > 0) {
#line 1072
    i___0 = 0;
    {
#line 1072
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1072
      if (! (i___0 < init_nodes.nelem)) {
#line 1072
        goto while_break;
      }
#line 1074
      node_idx = *(init_nodes.elems + i___0);
#line 1075
      type = (dfa___0->nodes + node_idx)->type;
#line 1078
      if ((unsigned int )type != 4U) {
#line 1079
        goto __Cont;
      }
#line 1080
      clexp_idx = 0;
      {
#line 1080
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1080
        if (! (clexp_idx < init_nodes.nelem)) {
#line 1080
          goto while_break___0;
        }
#line 1083
        clexp_node = dfa___0->nodes + *(init_nodes.elems + clexp_idx);
#line 1084
        if ((unsigned int )clexp_node->type == 9U) {
#line 1084
          if (clexp_node->opr.idx == (dfa___0->nodes + node_idx)->opr.idx) {
#line 1086
            goto while_break___0;
          }
        }
#line 1080
        clexp_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1088
      if (clexp_idx == init_nodes.nelem) {
#line 1089
        goto __Cont;
      }
#line 1091
      if ((unsigned int )type == 4U) {
        {
#line 1093
        dest_idx = *((dfa___0->edests + node_idx)->elems + 0);
#line 1094
        tmp___3 = re_node_set_contains((re_node_set const   *)(& init_nodes), dest_idx);
        }
#line 1094
        if (! tmp___3) {
          {
#line 1096
          tmp___2 = re_node_set_merge(& init_nodes, (re_node_set const   *)(dfa___0->eclosures + dest_idx));
#line 1096
          err___1 = tmp___2;
          }
#line 1099
          if ((int )err___1 != 0) {
#line 1100
            return (err___1);
          }
#line 1101
          i___0 = 0;
        }
      }
      __Cont: /* CIL Label */ 
#line 1072
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1107
  dfa___0->init_state = re_acquire_state_context(& err___0, (re_dfa_t const   *)dfa___0,
                                                 (re_node_set const   *)(& init_nodes),
                                                 0U);
#line 1109
  tmp___4 = __builtin_expect((long )((unsigned long )dfa___0->init_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1109
  if (tmp___4) {
#line 1110
    return (err___0);
  }
#line 1111
  if ((dfa___0->init_state)->has_constraint) {
    {
#line 1113
    dfa___0->init_state_word = re_acquire_state_context(& err___0, (re_dfa_t const   *)dfa___0,
                                                        (re_node_set const   *)(& init_nodes),
                                                        1U);
#line 1115
    dfa___0->init_state_nl = re_acquire_state_context(& err___0, (re_dfa_t const   *)dfa___0,
                                                      (re_node_set const   *)(& init_nodes),
                                                      (unsigned int )(1 << 1));
#line 1117
    dfa___0->init_state_begbuf = re_acquire_state_context(& err___0, (re_dfa_t const   *)dfa___0,
                                                          (re_node_set const   *)(& init_nodes),
                                                          (unsigned int )((1 << 1) | ((1 << 1) << 1)));
    }
#line 1121
    if ((unsigned long )dfa___0->init_state_word == (unsigned long )((void *)0)) {
#line 1121
      tmp___5 = 1;
    } else
#line 1121
    if ((unsigned long )dfa___0->init_state_nl == (unsigned long )((void *)0)) {
#line 1121
      tmp___5 = 1;
    } else
#line 1121
    if ((unsigned long )dfa___0->init_state_begbuf == (unsigned long )((void *)0)) {
#line 1121
      tmp___5 = 1;
    } else {
#line 1121
      tmp___5 = 0;
    }
    {
#line 1121
    tmp___6 = __builtin_expect((long )tmp___5, 0L);
    }
#line 1121
    if (tmp___6) {
#line 1123
      return (err___0);
    }
  } else {
#line 1126
    tmp___8 = dfa___0->init_state;
#line 1126
    dfa___0->init_state_begbuf = tmp___8;
#line 1126
    tmp___7 = tmp___8;
#line 1126
    dfa___0->init_state_nl = tmp___7;
#line 1126
    dfa___0->init_state_word = tmp___7;
  }
  {
#line 1129
  free((void *)init_nodes.elems);
  }
#line 1130
  return ((reg_errcode_t )0);
}
}
#line 1138 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static void optimize_utf8(re_dfa_t *dfa___0 ) 
{ 
  int node ;
  int i___0 ;
  int mb_chars ;
  int has_period ;
  int tmp___1 ;

  {
#line 1141
  mb_chars = 0;
#line 1141
  has_period = 0;
#line 1143
  node = 0;
  {
#line 1143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1143
    if (! ((size_t )node < dfa___0->nodes_len)) {
#line 1143
      goto while_break;
    }
    {
#line 1146
    if ((unsigned int )(dfa___0->nodes + node)->type == 1U) {
#line 1146
      goto case_1;
    }
#line 1150
    if ((unsigned int )(dfa___0->nodes + node)->type == 12U) {
#line 1150
      goto case_12;
    }
#line 1165
    if ((unsigned int )(dfa___0->nodes + node)->type == 5U) {
#line 1165
      goto case_5;
    }
#line 1173
    if ((unsigned int )(dfa___0->nodes + node)->type == 9U) {
#line 1173
      goto case_9;
    }
#line 1173
    if ((unsigned int )(dfa___0->nodes + node)->type == 8U) {
#line 1173
      goto case_9;
    }
#line 1173
    if ((unsigned int )(dfa___0->nodes + node)->type == 11U) {
#line 1173
      goto case_9;
    }
#line 1173
    if ((unsigned int )(dfa___0->nodes + node)->type == 2U) {
#line 1173
      goto case_9;
    }
#line 1173
    if ((unsigned int )(dfa___0->nodes + node)->type == 10U) {
#line 1173
      goto case_9;
    }
#line 1173
    if ((unsigned int )(dfa___0->nodes + node)->type == 4U) {
#line 1173
      goto case_9;
    }
#line 1175
    if ((unsigned int )(dfa___0->nodes + node)->type == 6U) {
#line 1175
      goto case_6;
    }
#line 1177
    if ((unsigned int )(dfa___0->nodes + node)->type == 3U) {
#line 1177
      goto case_3;
    }
#line 1184
    goto switch_default___0;
    case_1: /* CIL Label */ 
#line 1147
    if ((int )(dfa___0->nodes + node)->opr.c >= 128) {
#line 1148
      mb_chars = 1;
    }
#line 1149
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 1156
    if ((unsigned int )(dfa___0->nodes + node)->opr.ctx_type == 128U) {
#line 1156
      goto case_128;
    }
#line 1156
    if ((unsigned int )(dfa___0->nodes + node)->opr.ctx_type == 64U) {
#line 1156
      goto case_128;
    }
#line 1156
    if ((unsigned int )(dfa___0->nodes + node)->opr.ctx_type == 32U) {
#line 1156
      goto case_128;
    }
#line 1156
    if ((unsigned int )(dfa___0->nodes + node)->opr.ctx_type == 16U) {
#line 1156
      goto case_128;
    }
#line 1158
    goto switch_default;
    case_128: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_16: /* CIL Label */ 
#line 1157
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1162
    return;
    switch_break___0: /* CIL Label */ ;
    }
#line 1164
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1166
    has_period = 1;
#line 1167
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1174
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1176
    return;
    case_3: /* CIL Label */ 
#line 1180
    i___0 = (int )(128UL / (sizeof(bitset_word_t ) * 8UL));
    {
#line 1180
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1180
      if (! ((unsigned long )i___0 < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 1180
        goto while_break___0;
      }
#line 1181
      if (*((dfa___0->nodes + node)->opr.sbcset + i___0)) {
#line 1182
        return;
      }
#line 1180
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1183
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 1185
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 1143
    node ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1188
  if (mb_chars) {
#line 1188
    goto _L___0;
  } else
#line 1188
  if (has_period) {
    _L___0: /* CIL Label */ 
#line 1189
    node = 0;
    {
#line 1189
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1189
      if (! ((size_t )node < dfa___0->nodes_len)) {
#line 1189
        goto while_break___1;
      }
#line 1191
      if ((unsigned int )(dfa___0->nodes + node)->type == 1U) {
#line 1191
        if ((int )(dfa___0->nodes + node)->opr.c >= 128) {
#line 1193
          (dfa___0->nodes + node)->mb_partial = 0U;
        } else {
#line 1191
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1194
      if ((unsigned int )(dfa___0->nodes + node)->type == 5U) {
#line 1195
        (dfa___0->nodes + node)->type = (re_token_type_t )7;
      }
#line 1189
      node ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1199
  dfa___0->mb_cur_max = 1;
#line 1200
  dfa___0->is_utf8 = 0U;
#line 1201
  if (dfa___0->nbackref > 0) {
#line 1201
    tmp___1 = 1;
  } else
#line 1201
  if (has_period) {
#line 1201
    tmp___1 = 1;
  } else {
#line 1201
    tmp___1 = 0;
  }
#line 1201
  dfa___0->has_mb_node = (unsigned int )tmp___1;
#line 1202
  return;
}
}
#line 1208 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t analyze(regex_t *preg ) 
{ 
  re_dfa_t *dfa___0 ;
  reg_errcode_t ret ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;
  int i___0 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  void *tmp___12 ;
  long tmp___13 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;

  {
  {
#line 1211
  dfa___0 = (re_dfa_t *)preg->buffer;
#line 1215
  tmp___1 = malloc(dfa___0->nodes_alloc * sizeof(int ));
#line 1215
  dfa___0->nexts = (int *)tmp___1;
#line 1216
  tmp___2 = malloc(dfa___0->nodes_alloc * sizeof(int ));
#line 1216
  dfa___0->org_indices = (int *)tmp___2;
#line 1217
  tmp___3 = malloc(dfa___0->nodes_alloc * sizeof(re_node_set ));
#line 1217
  dfa___0->edests = (re_node_set *)tmp___3;
#line 1218
  tmp___4 = malloc(dfa___0->nodes_alloc * sizeof(re_node_set ));
#line 1218
  dfa___0->eclosures = (re_node_set *)tmp___4;
  }
#line 1219
  if ((unsigned long )dfa___0->nexts == (unsigned long )((void *)0)) {
#line 1219
    tmp___5 = 1;
  } else
#line 1219
  if ((unsigned long )dfa___0->org_indices == (unsigned long )((void *)0)) {
#line 1219
    tmp___5 = 1;
  } else
#line 1219
  if ((unsigned long )dfa___0->edests == (unsigned long )((void *)0)) {
#line 1219
    tmp___5 = 1;
  } else
#line 1219
  if ((unsigned long )dfa___0->eclosures == (unsigned long )((void *)0)) {
#line 1219
    tmp___5 = 1;
  } else {
#line 1219
    tmp___5 = 0;
  }
  {
#line 1219
  tmp___6 = __builtin_expect((long )tmp___5, 0L);
  }
#line 1219
  if (tmp___6) {
#line 1221
    return ((reg_errcode_t )12);
  }
  {
#line 1223
  tmp___7 = malloc(preg->re_nsub * sizeof(int ));
#line 1223
  dfa___0->subexp_map = (int *)tmp___7;
  }
#line 1224
  if ((unsigned long )dfa___0->subexp_map != (unsigned long )((void *)0)) {
#line 1227
    i___0 = 0;
    {
#line 1227
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1227
      if (! ((size_t )i___0 < preg->re_nsub)) {
#line 1227
        goto while_break;
      }
#line 1228
      *(dfa___0->subexp_map + i___0) = i___0;
#line 1227
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1229
    preorder(dfa___0->str_tree, & optimize_subexps, (void *)dfa___0);
#line 1230
    i___0 = 0;
    }
    {
#line 1230
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1230
      if (! ((size_t )i___0 < preg->re_nsub)) {
#line 1230
        goto while_break___0;
      }
#line 1231
      if (*(dfa___0->subexp_map + i___0) != i___0) {
#line 1232
        goto while_break___0;
      }
#line 1230
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1233
    if ((size_t )i___0 == preg->re_nsub) {
      {
#line 1235
      free((void *)dfa___0->subexp_map);
#line 1236
      dfa___0->subexp_map = (int *)((void *)0);
      }
    }
  }
  {
#line 1240
  ret = postorder(dfa___0->str_tree, & lower_subexps, (void *)preg);
#line 1241
  tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1241
  if (tmp___8) {
#line 1242
    return (ret);
  }
  {
#line 1243
  ret = postorder(dfa___0->str_tree, & calc_first, (void *)dfa___0);
#line 1244
  tmp___9 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1244
  if (tmp___9) {
#line 1245
    return (ret);
  }
  {
#line 1246
  preorder(dfa___0->str_tree, & calc_next, (void *)dfa___0);
#line 1247
  ret = preorder(dfa___0->str_tree, & link_nfa_nodes, (void *)dfa___0);
#line 1248
  tmp___10 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1248
  if (tmp___10) {
#line 1249
    return (ret);
  }
  {
#line 1250
  ret = calc_eclosure(dfa___0);
#line 1251
  tmp___11 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1251
  if (tmp___11) {
#line 1252
    return (ret);
  }
#line 1256
  if (! preg->no_sub) {
#line 1256
    if (preg->re_nsub > 0UL) {
#line 1256
      if (dfa___0->has_plural_match) {
#line 1256
        goto _L;
      } else {
#line 1256
        goto _L___1;
      }
    } else {
#line 1256
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1256
  if (dfa___0->nbackref) {
    _L: /* CIL Label */ 
    {
#line 1259
    tmp___12 = malloc(dfa___0->nodes_len * sizeof(re_node_set ));
#line 1259
    dfa___0->inveclosures = (re_node_set *)tmp___12;
#line 1260
    tmp___13 = __builtin_expect((long )((unsigned long )dfa___0->inveclosures == (unsigned long )((void *)0)),
                                0L);
    }
#line 1260
    if (tmp___13) {
#line 1261
      return ((reg_errcode_t )12);
    }
    {
#line 1262
    ret = calc_inveclosure(dfa___0);
    }
  }
#line 1265
  return (ret);
}
}
#line 1271 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) 
{ 
  bin_tree_t *node ;
  bin_tree_t *prev ;
  reg_errcode_t err___0 ;
  reg_errcode_t tmp___1 ;
  long tmp___2 ;

  {
#line 1277
  node = root;
  {
#line 1277
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1281
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1281
      if (! node->left) {
#line 1281
        if (! node->right) {
#line 1281
          goto while_break___0;
        }
      }
#line 1282
      if (node->left) {
#line 1283
        node = node->left;
      } else {
#line 1285
        node = node->right;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1287
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1289
      tmp___1 = (*fn)(extra, node);
#line 1289
      err___0 = tmp___1;
#line 1290
      tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1290
      if (tmp___2) {
#line 1291
        return (err___0);
      }
#line 1292
      if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
#line 1293
        return ((reg_errcode_t )0);
      }
#line 1294
      prev = node;
#line 1295
      node = node->parent;
#line 1287
      if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1287
        if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1287
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1299
    node = node->right;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1303 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) 
{ 
  bin_tree_t *node ;
  reg_errcode_t err___0 ;
  reg_errcode_t tmp___1 ;
  long tmp___2 ;
  bin_tree_t *prev ;

  {
#line 1309
  node = root;
  {
#line 1309
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1311
    tmp___1 = (*fn)(extra, node);
#line 1311
    err___0 = tmp___1;
#line 1312
    tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 1312
    if (tmp___2) {
#line 1313
      return (err___0);
    }
#line 1316
    if (node->left) {
#line 1317
      node = node->left;
    } else {
#line 1320
      prev = (bin_tree_t *)((void *)0);
      {
#line 1321
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1321
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1321
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1321
            goto while_break___0;
          }
        }
#line 1323
        prev = node;
#line 1324
        node = node->parent;
#line 1325
        if (! node) {
#line 1326
          return ((reg_errcode_t )0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1328
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1336 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa___0 ;
  int idx___3 ;
  int other_idx ;

  {
#line 1339
  dfa___0 = (re_dfa_t *)extra;
#line 1341
  if ((unsigned int )node->token.type == 4U) {
#line 1341
    if (dfa___0->subexp_map) {
#line 1343
      idx___3 = node->token.opr.idx;
#line 1344
      node->token.opr.idx = *(dfa___0->subexp_map + idx___3);
#line 1345
      dfa___0->used_bkref_map |= (unsigned long )(1 << node->token.opr.idx);
    } else {
#line 1341
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1348
  if ((unsigned int )node->token.type == 17U) {
#line 1348
    if (node->left) {
#line 1348
      if ((unsigned int )(node->left)->token.type == 17U) {
#line 1351
        other_idx = (node->left)->token.opr.idx;
#line 1353
        node->left = (node->left)->left;
#line 1354
        if (node->left) {
#line 1355
          (node->left)->parent = node;
        }
#line 1357
        *(dfa___0->subexp_map + other_idx) = *(dfa___0->subexp_map + node->token.opr.idx);
#line 1358
        if ((unsigned long )other_idx < sizeof(bitset_word_t ) * 8UL) {
#line 1359
          dfa___0->used_bkref_map &= ~ (1UL << other_idx);
        }
      }
    }
  }
#line 1362
  return ((reg_errcode_t )0);
}
}
#line 1367 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) 
{ 
  regex_t *preg ;
  reg_errcode_t err___0 ;

  {
#line 1370
  preg = (regex_t *)extra;
#line 1371
  err___0 = (reg_errcode_t )0;
#line 1373
  if (node->left) {
#line 1373
    if ((unsigned int )(node->left)->token.type == 17U) {
      {
#line 1375
      node->left = lower_subexp(& err___0, preg, node->left);
      }
#line 1376
      if (node->left) {
#line 1377
        (node->left)->parent = node;
      }
    }
  }
#line 1379
  if (node->right) {
#line 1379
    if ((unsigned int )(node->right)->token.type == 17U) {
      {
#line 1381
      node->right = lower_subexp(& err___0, preg, node->right);
      }
#line 1382
      if (node->right) {
#line 1383
        (node->right)->parent = node;
      }
    }
  }
#line 1386
  return (err___0);
}
}
#line 1389 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *lower_subexp(reg_errcode_t *err___0 , regex_t *preg , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa___0 ;
  bin_tree_t *body ;
  bin_tree_t *op ;
  bin_tree_t *cls ;
  bin_tree_t *tree1 ;
  bin_tree_t *tree ;
  bin_tree_t *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 1392
  dfa___0 = (re_dfa_t *)preg->buffer;
#line 1393
  body = node->left;
#line 1396
  if (preg->no_sub) {
#line 1396
    if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1396
      if ((unsigned long )node->token.opr.idx >= sizeof(bitset_word_t ) * 8UL) {
#line 1405
        return (node->left);
      } else
#line 1396
      if (! (dfa___0->used_bkref_map & (1UL << node->token.opr.idx))) {
#line 1405
        return (node->left);
      }
    }
  }
  {
#line 1409
  op = create_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                   (re_token_type_t )8);
#line 1410
  cls = create_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                    (re_token_type_t )9);
  }
#line 1411
  if (body) {
    {
#line 1411
    tmp___1 = create_tree(dfa___0, body, cls, (re_token_type_t )16);
#line 1411
    tree1 = tmp___1;
    }
  } else {
#line 1411
    tree1 = cls;
  }
  {
#line 1412
  tree = create_tree(dfa___0, op, tree1, (re_token_type_t )16);
  }
#line 1413
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1413
    tmp___2 = 1;
  } else
#line 1413
  if ((unsigned long )tree1 == (unsigned long )((void *)0)) {
#line 1413
    tmp___2 = 1;
  } else
#line 1413
  if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 1413
    tmp___2 = 1;
  } else
#line 1413
  if ((unsigned long )cls == (unsigned long )((void *)0)) {
#line 1413
    tmp___2 = 1;
  } else {
#line 1413
    tmp___2 = 0;
  }
  {
#line 1413
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
#line 1413
  if (tmp___3) {
#line 1415
    *err___0 = (reg_errcode_t )12;
#line 1416
    return ((bin_tree_t *)((void *)0));
  }
#line 1419
  tmp___4 = node->token.opr.idx;
#line 1419
  cls->token.opr.idx = tmp___4;
#line 1419
  op->token.opr.idx = tmp___4;
#line 1420
  tmp___5 = node->token.opt_subexp;
#line 1420
  cls->token.opt_subexp = tmp___5;
#line 1420
  op->token.opt_subexp = tmp___5;
#line 1421
  return (tree);
}
}
#line 1426 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa___0 ;
  long tmp___1 ;

  {
#line 1429
  dfa___0 = (re_dfa_t *)extra;
#line 1430
  if ((unsigned int )node->token.type == 16U) {
#line 1432
    node->first = (node->left)->first;
#line 1433
    node->node_idx = (node->left)->node_idx;
  } else {
    {
#line 1437
    node->first = node;
#line 1438
    node->node_idx = re_dfa_add_node(dfa___0, node->token);
#line 1439
    tmp___1 = __builtin_expect((long )(node->node_idx == -1), 0L);
    }
#line 1439
    if (tmp___1) {
#line 1440
      return ((reg_errcode_t )12);
    }
#line 1441
    if ((unsigned int )node->token.type == 12U) {
#line 1442
      (dfa___0->nodes + node->node_idx)->constraint = (unsigned int )node->token.opr.ctx_type;
    }
  }
#line 1444
  return ((reg_errcode_t )0);
}
}
#line 1448 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) 
{ 


  {
  {
#line 1453
  if ((unsigned int )node->token.type == 11U) {
#line 1453
    goto case_11;
  }
#line 1456
  if ((unsigned int )node->token.type == 16U) {
#line 1456
    goto case_16;
  }
#line 1460
  goto switch_default;
  case_11: /* CIL Label */ 
#line 1454
  (node->left)->next = node;
#line 1455
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1457
  (node->left)->next = (node->right)->first;
#line 1458
  (node->right)->next = node->next;
#line 1459
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1461
  if (node->left) {
#line 1462
    (node->left)->next = node->next;
  }
#line 1463
  if (node->right) {
#line 1464
    (node->right)->next = node->next;
  }
#line 1465
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1467
  return ((reg_errcode_t )0);
}
}
#line 1471 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa___0 ;
  int idx___3 ;
  reg_errcode_t err___0 ;
  int left ;
  int right ;

  {
#line 1474
  dfa___0 = (re_dfa_t *)extra;
#line 1475
  idx___3 = node->node_idx;
#line 1476
  err___0 = (reg_errcode_t )0;
  {
#line 1480
  if ((unsigned int )node->token.type == 16U) {
#line 1480
    goto case_16;
  }
#line 1483
  if ((unsigned int )node->token.type == 2U) {
#line 1483
    goto case_2;
  }
#line 1488
  if ((unsigned int )node->token.type == 10U) {
#line 1488
    goto case_10;
  }
#line 1488
  if ((unsigned int )node->token.type == 11U) {
#line 1488
    goto case_10;
  }
#line 1508
  if ((unsigned int )node->token.type == 9U) {
#line 1508
    goto case_9;
  }
#line 1508
  if ((unsigned int )node->token.type == 8U) {
#line 1508
    goto case_9;
  }
#line 1508
  if ((unsigned int )node->token.type == 12U) {
#line 1508
    goto case_9;
  }
#line 1512
  if ((unsigned int )node->token.type == 4U) {
#line 1512
    goto case_4;
  }
#line 1518
  goto switch_default;
  case_16: /* CIL Label */ 
#line 1481
  goto switch_break;
  case_2: /* CIL Label */ ;
#line 1485
  goto switch_break;
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 1491
  dfa___0->has_plural_match = 1U;
#line 1492
  if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1493
    left = ((node->left)->first)->node_idx;
  } else {
#line 1495
    left = (node->next)->node_idx;
  }
#line 1496
  if ((unsigned long )node->right != (unsigned long )((void *)0)) {
#line 1497
    right = ((node->right)->first)->node_idx;
  } else {
#line 1499
    right = (node->next)->node_idx;
  }
  {
#line 1502
  err___0 = re_node_set_init_2(dfa___0->edests + idx___3, left, right);
  }
#line 1504
  goto switch_break;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_12: /* CIL Label */ 
  {
#line 1509
  err___0 = re_node_set_init_1(dfa___0->edests + idx___3, (node->next)->node_idx);
  }
#line 1510
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1513
  *(dfa___0->nexts + idx___3) = (node->next)->node_idx;
#line 1514
  if ((unsigned int )node->token.type == 4U) {
    {
#line 1515
    err___0 = re_node_set_init_1(dfa___0->edests + idx___3, *(dfa___0->nexts + idx___3));
    }
  }
#line 1516
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1520
  *(dfa___0->nexts + idx___3) = (node->next)->node_idx;
#line 1521
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1524
  return (err___0);
}
}
#line 1531 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t duplicate_node_closure(re_dfa_t *dfa___0 , int top_org_node ,
                                            int top_clone_node , int root_node , unsigned int init_constraint ) 
{ 
  int org_node ;
  int clone_node ;
  int ret ;
  unsigned int constraint ;
  int org_dest ;
  int clone_dest ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  reg_errcode_t err___0 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;

  {
#line 1537
  constraint = init_constraint;
#line 1538
  org_node = top_org_node;
#line 1538
  clone_node = top_clone_node;
  {
#line 1538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1541
    if ((unsigned int )(dfa___0->nodes + org_node)->type == 4U) {
      {
#line 1547
      org_dest = *(dfa___0->nexts + org_node);
#line 1548
      (dfa___0->edests + clone_node)->nelem = 0;
#line 1549
      clone_dest = duplicate_node(dfa___0, org_dest, constraint);
#line 1550
      tmp___1 = __builtin_expect((long )(clone_dest == -1), 0L);
      }
#line 1550
      if (tmp___1) {
#line 1551
        return ((reg_errcode_t )12);
      }
      {
#line 1552
      *(dfa___0->nexts + clone_node) = *(dfa___0->nexts + org_node);
#line 1553
      ret = re_node_set_insert(dfa___0->edests + clone_node, clone_dest);
#line 1554
      tmp___2 = __builtin_expect((long )(ret < 0), 0L);
      }
#line 1554
      if (tmp___2) {
#line 1555
        return ((reg_errcode_t )12);
      }
    } else
#line 1557
    if ((dfa___0->edests + org_node)->nelem == 0) {
#line 1562
      *(dfa___0->nexts + clone_node) = *(dfa___0->nexts + org_node);
#line 1563
      goto while_break;
    } else
#line 1565
    if ((dfa___0->edests + org_node)->nelem == 1) {
#line 1569
      org_dest = *((dfa___0->edests + org_node)->elems + 0);
#line 1570
      (dfa___0->edests + clone_node)->nelem = 0;
#line 1573
      if (org_node == root_node) {
#line 1573
        if (clone_node != org_node) {
          {
#line 1575
          ret = re_node_set_insert(dfa___0->edests + clone_node, org_dest);
#line 1576
          tmp___3 = __builtin_expect((long )(ret < 0), 0L);
          }
#line 1576
          if (tmp___3) {
#line 1577
            return ((reg_errcode_t )12);
          }
#line 1578
          goto while_break;
        }
      }
      {
#line 1581
      constraint |= (dfa___0->nodes + org_node)->constraint;
#line 1582
      clone_dest = duplicate_node(dfa___0, org_dest, constraint);
#line 1583
      tmp___4 = __builtin_expect((long )(clone_dest == -1), 0L);
      }
#line 1583
      if (tmp___4) {
#line 1584
        return ((reg_errcode_t )12);
      }
      {
#line 1585
      ret = re_node_set_insert(dfa___0->edests + clone_node, clone_dest);
#line 1586
      tmp___5 = __builtin_expect((long )(ret < 0), 0L);
      }
#line 1586
      if (tmp___5) {
#line 1587
        return ((reg_errcode_t )12);
      }
    } else {
      {
#line 1593
      org_dest = *((dfa___0->edests + org_node)->elems + 0);
#line 1594
      (dfa___0->edests + clone_node)->nelem = 0;
#line 1596
      clone_dest = search_duplicated_node((re_dfa_t const   *)dfa___0, org_dest, constraint);
      }
#line 1597
      if (clone_dest == -1) {
        {
#line 1601
        clone_dest = duplicate_node(dfa___0, org_dest, constraint);
#line 1602
        tmp___6 = __builtin_expect((long )(clone_dest == -1), 0L);
        }
#line 1602
        if (tmp___6) {
#line 1603
          return ((reg_errcode_t )12);
        }
        {
#line 1604
        ret = re_node_set_insert(dfa___0->edests + clone_node, clone_dest);
#line 1605
        tmp___7 = __builtin_expect((long )(ret < 0), 0L);
        }
#line 1605
        if (tmp___7) {
#line 1606
          return ((reg_errcode_t )12);
        }
        {
#line 1607
        err___0 = duplicate_node_closure(dfa___0, org_dest, clone_dest, root_node,
                                         constraint);
#line 1609
        tmp___8 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 1609
        if (tmp___8) {
#line 1610
          return (err___0);
        }
      } else {
        {
#line 1616
        ret = re_node_set_insert(dfa___0->edests + clone_node, clone_dest);
#line 1617
        tmp___9 = __builtin_expect((long )(ret < 0), 0L);
        }
#line 1617
        if (tmp___9) {
#line 1618
          return ((reg_errcode_t )12);
        }
      }
      {
#line 1621
      org_dest = *((dfa___0->edests + org_node)->elems + 1);
#line 1622
      clone_dest = duplicate_node(dfa___0, org_dest, constraint);
#line 1623
      tmp___10 = __builtin_expect((long )(clone_dest == -1), 0L);
      }
#line 1623
      if (tmp___10) {
#line 1624
        return ((reg_errcode_t )12);
      }
      {
#line 1625
      ret = re_node_set_insert(dfa___0->edests + clone_node, clone_dest);
#line 1626
      tmp___11 = __builtin_expect((long )(ret < 0), 0L);
      }
#line 1626
      if (tmp___11) {
#line 1627
        return ((reg_errcode_t )12);
      }
    }
#line 1629
    org_node = org_dest;
#line 1630
    clone_node = clone_dest;
  }
  while_break: /* CIL Label */ ;
  }
#line 1632
  return ((reg_errcode_t )0);
}
}
#line 1638 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static int search_duplicated_node(re_dfa_t const   *dfa___0 , int org_node , unsigned int constraint ) 
{ 
  int idx___3 ;

  {
#line 1643
  idx___3 = (int )(dfa___0->nodes_len - 1UL);
  {
#line 1643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1643
    if ((dfa___0->nodes + idx___3)->duplicated) {
#line 1643
      if (! (idx___3 > 0)) {
#line 1643
        goto while_break;
      }
    } else {
#line 1643
      goto while_break;
    }
#line 1645
    if (org_node == *(dfa___0->org_indices + idx___3)) {
#line 1645
      if (constraint == (dfa___0->nodes + idx___3)->constraint) {
#line 1647
        return (idx___3);
      }
    }
#line 1643
    idx___3 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1649
  return (-1);
}
}
#line 1656 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static int duplicate_node(re_dfa_t *dfa___0 , int org_idx , unsigned int constraint ) 
{ 
  int dup_idx ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1659
  tmp___1 = re_dfa_add_node(dfa___0, *(dfa___0->nodes + org_idx));
#line 1659
  dup_idx = tmp___1;
#line 1660
  tmp___2 = __builtin_expect((long )(dup_idx != -1), 1L);
  }
#line 1660
  if (tmp___2) {
#line 1662
    (dfa___0->nodes + dup_idx)->constraint = constraint;
#line 1663
    (dfa___0->nodes + dup_idx)->constraint |= (dfa___0->nodes + org_idx)->constraint;
#line 1664
    (dfa___0->nodes + dup_idx)->duplicated = 1U;
#line 1667
    *(dfa___0->org_indices + dup_idx) = org_idx;
  }
#line 1669
  return (dup_idx);
}
}
#line 1672 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa___0 ) 
{ 
  int src ;
  int idx___3 ;
  int ret ;
  int *elems ;
  long tmp___1 ;

  {
#line 1676
  idx___3 = 0;
  {
#line 1676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1676
    if (! ((size_t )idx___3 < dfa___0->nodes_len)) {
#line 1676
      goto while_break;
    }
    {
#line 1677
    memset((void *)(dfa___0->inveclosures + idx___3), '\000', sizeof(re_node_set ));
#line 1676
    idx___3 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1679
  src = 0;
  {
#line 1679
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1679
    if (! ((size_t )src < dfa___0->nodes_len)) {
#line 1679
      goto while_break___0;
    }
#line 1681
    elems = (dfa___0->eclosures + src)->elems;
#line 1682
    idx___3 = 0;
    {
#line 1682
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1682
      if (! (idx___3 < (dfa___0->eclosures + src)->nelem)) {
#line 1682
        goto while_break___1;
      }
      {
#line 1684
      ret = re_node_set_insert_last(dfa___0->inveclosures + *(elems + idx___3), src);
#line 1685
      tmp___1 = __builtin_expect((long )(ret == -1), 0L);
      }
#line 1685
      if (tmp___1) {
#line 1686
        return ((reg_errcode_t )12);
      }
#line 1682
      idx___3 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1679
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1690
  return ((reg_errcode_t )0);
}
}
#line 1695 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t calc_eclosure(re_dfa_t *dfa___0 ) 
{ 
  int node_idx ;
  int incomplete ;
  reg_errcode_t err___0 ;
  re_node_set eclosure_elem ;
  long tmp___1 ;
  void *__cil_tmp7 ;

  {
#line 1702
  incomplete = 0;
#line 1704
  node_idx = 0;
  {
#line 1704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1708
    if ((size_t )node_idx == dfa___0->nodes_len) {
#line 1710
      if (! incomplete) {
#line 1711
        goto while_break;
      }
#line 1712
      incomplete = 0;
#line 1713
      node_idx = 0;
    }
#line 1721
    if ((dfa___0->eclosures + node_idx)->nelem != 0) {
#line 1722
      goto __Cont;
    }
    {
#line 1724
    err___0 = calc_eclosure_iter(& eclosure_elem, dfa___0, node_idx, 1);
#line 1725
    tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 1725
    if (tmp___1) {
#line 1726
      return (err___0);
    }
#line 1728
    if ((dfa___0->eclosures + node_idx)->nelem == 0) {
      {
#line 1730
      incomplete = 1;
#line 1731
      free((void *)eclosure_elem.elems);
      }
    }
    __Cont: /* CIL Label */ 
#line 1704
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1734
  return ((reg_errcode_t )0);
}
}
#line 1739 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa___0 ,
                                        int node , int root ) 
{ 
  reg_errcode_t err___0 ;
  int i___0 ;
  re_node_set eclosure ;
  int ret ;
  int incomplete ;
  long tmp___1 ;
  long tmp___2 ;
  re_node_set eclosure_elem ;
  int edest ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;

  {
  {
#line 1746
  incomplete = 0;
#line 1747
  err___0 = re_node_set_alloc(& eclosure, (dfa___0->edests + node)->nelem + 1);
#line 1748
  tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1748
  if (tmp___1) {
#line 1749
    return (err___0);
  }
#line 1753
  (dfa___0->eclosures + node)->nelem = -1;
#line 1757
  if ((dfa___0->nodes + node)->constraint) {
#line 1757
    if ((dfa___0->edests + node)->nelem) {
#line 1757
      if (! (dfa___0->nodes + *((dfa___0->edests + node)->elems + 0))->duplicated) {
        {
#line 1761
        err___0 = duplicate_node_closure(dfa___0, node, node, node, (dfa___0->nodes + node)->constraint);
#line 1763
        tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 1763
        if (tmp___2) {
#line 1764
          return (err___0);
        }
      }
    }
  }
#line 1768
  if ((unsigned int )(dfa___0->nodes + node)->type & 8U) {
#line 1769
    i___0 = 0;
    {
#line 1769
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1769
      if (! (i___0 < (dfa___0->edests + node)->nelem)) {
#line 1769
        goto while_break;
      }
#line 1772
      edest = *((dfa___0->edests + node)->elems + i___0);
#line 1775
      if ((dfa___0->eclosures + edest)->nelem == -1) {
#line 1777
        incomplete = 1;
#line 1778
        goto __Cont;
      }
#line 1782
      if ((dfa___0->eclosures + edest)->nelem == 0) {
        {
#line 1784
        err___0 = calc_eclosure_iter(& eclosure_elem, dfa___0, edest, 0);
#line 1785
        tmp___3 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 1785
        if (tmp___3) {
#line 1786
          return (err___0);
        }
      } else {
#line 1789
        eclosure_elem = *(dfa___0->eclosures + edest);
      }
      {
#line 1791
      err___0 = re_node_set_merge(& eclosure, (re_node_set const   *)(& eclosure_elem));
#line 1792
      tmp___4 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1792
      if (tmp___4) {
#line 1793
        return (err___0);
      }
#line 1796
      if ((dfa___0->eclosures + edest)->nelem == 0) {
        {
#line 1798
        incomplete = 1;
#line 1799
        free((void *)eclosure_elem.elems);
        }
      }
      __Cont: /* CIL Label */ 
#line 1769
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1804
  ret = re_node_set_insert(& eclosure, node);
#line 1805
  tmp___5 = __builtin_expect((long )(ret < 0), 0L);
  }
#line 1805
  if (tmp___5) {
#line 1806
    return ((reg_errcode_t )12);
  }
#line 1807
  if (incomplete) {
#line 1807
    if (! root) {
#line 1808
      (dfa___0->eclosures + node)->nelem = 0;
    } else {
#line 1810
      *(dfa___0->eclosures + node) = eclosure;
    }
  } else {
#line 1810
    *(dfa___0->eclosures + node) = eclosure;
  }
#line 1811
  *new_set = eclosure;
#line 1812
  return ((reg_errcode_t )0);
}
}
#line 1820 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static void fetch_token(re_token_t *result , re_string_t *input , reg_syntax_t syntax ) 
{ 
  int tmp___1 ;

  {
  {
#line 1824
  tmp___1 = peek_token(result, input, syntax);
#line 1824
  input->cur_idx += tmp___1;
  }
#line 1825
  return;
}
}
#line 1830 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char __attribute__((__pure__))  tmp___1 ;
  wint_t wc ;
  wint_t __attribute__((__pure__))  tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  wint_t wc___0 ;
  wint_t __attribute__((__pure__))  tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  char prev ;
  re_token_t next ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;

  {
#line 1836
  if (input->stop <= input->cur_idx) {
#line 1838
    token->type = (re_token_type_t )2;
#line 1839
    return (0);
  }
#line 1842
  c = *(input->mbs + input->cur_idx);
#line 1843
  token->opr.c = c;
#line 1845
  token->word_char = 0U;
#line 1847
  token->mb_partial = 0U;
#line 1848
  if (input->mb_cur_max > 1) {
#line 1848
    if (! (input->cur_idx == input->valid_len)) {
#line 1848
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 1851
        token->type = (re_token_type_t )1;
#line 1852
        token->mb_partial = 1U;
#line 1853
        return (1);
      }
    }
  }
#line 1856
  if ((int )c == 92) {
#line 1859
    if (input->cur_idx + 1 >= input->len) {
#line 1861
      token->type = (re_token_type_t )36;
#line 1862
      return (1);
    }
    {
#line 1865
    tmp___1 = re_string_peek_byte_case((re_string_t const   *)input, 1);
#line 1865
    c2 = (unsigned char )tmp___1;
#line 1866
    token->opr.c = c2;
#line 1867
    token->type = (re_token_type_t )1;
    }
#line 1869
    if (input->mb_cur_max > 1) {
      {
#line 1871
      tmp___2 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx + 1);
#line 1871
      wc = (wint_t )tmp___2;
#line 1873
      tmp___3 = iswalnum(wc);
      }
#line 1873
      if (tmp___3) {
#line 1873
        tmp___4 = 1;
      } else
#line 1873
      if (wc == 95U) {
#line 1873
        tmp___4 = 1;
      } else {
#line 1873
        tmp___4 = 0;
      }
#line 1873
      token->word_char = (unsigned int )(tmp___4 != 0);
    } else {
      {
#line 1877
      tmp___5 = __ctype_b_loc();
      }
#line 1877
      if ((int const   )*(*tmp___5 + (int )c2) & 8) {
#line 1877
        tmp___6 = 1;
      } else
#line 1877
      if ((int )c2 == 95) {
#line 1877
        tmp___6 = 1;
      } else {
#line 1877
        tmp___6 = 0;
      }
#line 1877
      token->word_char = (unsigned int )(tmp___6 != 0);
    }
    {
#line 1881
    if ((int )c2 == 124) {
#line 1881
      goto case_124;
    }
#line 1886
    if ((int )c2 == 57) {
#line 1886
      goto case_57;
    }
#line 1886
    if ((int )c2 == 56) {
#line 1886
      goto case_57;
    }
#line 1886
    if ((int )c2 == 55) {
#line 1886
      goto case_57;
    }
#line 1886
    if ((int )c2 == 54) {
#line 1886
      goto case_57;
    }
#line 1886
    if ((int )c2 == 53) {
#line 1886
      goto case_57;
    }
#line 1886
    if ((int )c2 == 52) {
#line 1886
      goto case_57;
    }
#line 1886
    if ((int )c2 == 51) {
#line 1886
      goto case_57;
    }
#line 1886
    if ((int )c2 == 50) {
#line 1886
      goto case_57;
    }
#line 1886
    if ((int )c2 == 49) {
#line 1886
      goto case_57;
    }
#line 1893
    if ((int )c2 == 60) {
#line 1893
      goto case_60;
    }
#line 1900
    if ((int )c2 == 62) {
#line 1900
      goto case_62;
    }
#line 1907
    if ((int )c2 == 98) {
#line 1907
      goto case_98;
    }
#line 1914
    if ((int )c2 == 66) {
#line 1914
      goto case_66;
    }
#line 1921
    if ((int )c2 == 119) {
#line 1921
      goto case_119;
    }
#line 1925
    if ((int )c2 == 87) {
#line 1925
      goto case_87;
    }
#line 1929
    if ((int )c2 == 115) {
#line 1929
      goto case_115;
    }
#line 1933
    if ((int )c2 == 83) {
#line 1933
      goto case_83;
    }
#line 1937
    if ((int )c2 == 96) {
#line 1937
      goto case_96;
    }
#line 1944
    if ((int )c2 == 39) {
#line 1944
      goto case_39;
    }
#line 1951
    if ((int )c2 == 40) {
#line 1951
      goto case_40;
    }
#line 1955
    if ((int )c2 == 41) {
#line 1955
      goto case_41;
    }
#line 1959
    if ((int )c2 == 43) {
#line 1959
      goto case_43;
    }
#line 1963
    if ((int )c2 == 63) {
#line 1963
      goto case_63;
    }
#line 1967
    if ((int )c2 == 123) {
#line 1967
      goto case_123;
    }
#line 1971
    if ((int )c2 == 125) {
#line 1971
      goto case_125;
    }
#line 1975
    goto switch_default;
    case_124: /* CIL Label */ 
#line 1882
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1882
      if (! (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1883
        token->type = (re_token_type_t )10;
      }
    }
#line 1884
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1887
    if (! (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1889
      token->type = (re_token_type_t )4;
#line 1890
      token->opr.idx = (int )c2 - 49;
    }
#line 1892
    goto switch_break;
    case_60: /* CIL Label */ 
#line 1894
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1896
      token->type = (re_token_type_t )12;
#line 1897
      token->opr.ctx_type = (re_context_type )6;
    }
#line 1899
    goto switch_break;
    case_62: /* CIL Label */ 
#line 1901
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1903
      token->type = (re_token_type_t )12;
#line 1904
      token->opr.ctx_type = (re_context_type )9;
    }
#line 1906
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1908
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1910
      token->type = (re_token_type_t )12;
#line 1911
      token->opr.ctx_type = (re_context_type )256;
    }
#line 1913
    goto switch_break;
    case_66: /* CIL Label */ 
#line 1915
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1917
      token->type = (re_token_type_t )12;
#line 1918
      token->opr.ctx_type = (re_context_type )512;
    }
#line 1920
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1922
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1923
      token->type = (re_token_type_t )32;
    }
#line 1924
    goto switch_break;
    case_87: /* CIL Label */ 
#line 1926
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1927
      token->type = (re_token_type_t )33;
    }
#line 1928
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1930
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1931
      token->type = (re_token_type_t )34;
    }
#line 1932
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1934
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1935
      token->type = (re_token_type_t )35;
    }
#line 1936
    goto switch_break;
    case_96: /* CIL Label */ 
#line 1938
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1940
      token->type = (re_token_type_t )12;
#line 1941
      token->opr.ctx_type = (re_context_type )64;
    }
#line 1943
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1945
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1947
      token->type = (re_token_type_t )12;
#line 1948
      token->opr.ctx_type = (re_context_type )128;
    }
#line 1950
    goto switch_break;
    case_40: /* CIL Label */ 
#line 1952
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1953
      token->type = (re_token_type_t )8;
    }
#line 1954
    goto switch_break;
    case_41: /* CIL Label */ 
#line 1956
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1957
      token->type = (re_token_type_t )9;
    }
#line 1958
    goto switch_break;
    case_43: /* CIL Label */ 
#line 1960
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1960
      if (syntax & (1UL << 1)) {
#line 1961
        token->type = (re_token_type_t )18;
      }
    }
#line 1962
    goto switch_break;
    case_63: /* CIL Label */ 
#line 1964
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1964
      if (syntax & (1UL << 1)) {
#line 1965
        token->type = (re_token_type_t )19;
      }
    }
#line 1966
    goto switch_break;
    case_123: /* CIL Label */ 
#line 1968
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1968
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1969
        token->type = (re_token_type_t )23;
      }
    }
#line 1970
    goto switch_break;
    case_125: /* CIL Label */ 
#line 1972
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1972
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1973
        token->type = (re_token_type_t )24;
      }
    }
#line 1974
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1976
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1978
    return (2);
  }
#line 1981
  token->type = (re_token_type_t )1;
#line 1983
  if (input->mb_cur_max > 1) {
    {
#line 1985
    tmp___7 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx);
#line 1985
    wc___0 = (wint_t )tmp___7;
#line 1986
    tmp___8 = iswalnum(wc___0);
    }
#line 1986
    if (tmp___8) {
#line 1986
      tmp___9 = 1;
    } else
#line 1986
    if (wc___0 == 95U) {
#line 1986
      tmp___9 = 1;
    } else {
#line 1986
      tmp___9 = 0;
    }
#line 1986
    token->word_char = (unsigned int )(tmp___9 != 0);
  } else {
    {
#line 1990
    tmp___10 = __ctype_b_loc();
    }
#line 1990
    if ((int const   )*(*tmp___10 + (int )token->opr.c) & 8) {
#line 1990
      tmp___11 = 1;
    } else
#line 1990
    if ((int )token->opr.c == 95) {
#line 1990
      tmp___11 = 1;
    } else {
#line 1990
      tmp___11 = 0;
    }
#line 1990
    token->word_char = (unsigned int )tmp___11;
  }
  {
#line 1994
  if ((int )c == 10) {
#line 1994
    goto case_10;
  }
#line 1998
  if ((int )c == 124) {
#line 1998
    goto case_124___0;
  }
#line 2002
  if ((int )c == 42) {
#line 2002
    goto case_42;
  }
#line 2005
  if ((int )c == 43) {
#line 2005
    goto case_43___0;
  }
#line 2009
  if ((int )c == 63) {
#line 2009
    goto case_63___0;
  }
#line 2013
  if ((int )c == 123) {
#line 2013
    goto case_123___0;
  }
#line 2017
  if ((int )c == 125) {
#line 2017
    goto case_125___0;
  }
#line 2021
  if ((int )c == 40) {
#line 2021
    goto case_40___0;
  }
#line 2025
  if ((int )c == 41) {
#line 2025
    goto case_41___0;
  }
#line 2029
  if ((int )c == 91) {
#line 2029
    goto case_91;
  }
#line 2032
  if ((int )c == 46) {
#line 2032
    goto case_46;
  }
#line 2035
  if ((int )c == 94) {
#line 2035
    goto case_94;
  }
#line 2046
  if ((int )c == 36) {
#line 2046
    goto case_36;
  }
#line 2060
  goto switch_default___0;
  case_10: /* CIL Label */ 
#line 1995
  if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1996
    token->type = (re_token_type_t )10;
  }
#line 1997
  goto switch_break___0;
  case_124___0: /* CIL Label */ 
#line 1999
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1999
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2000
      token->type = (re_token_type_t )10;
    }
  }
#line 2001
  goto switch_break___0;
  case_42: /* CIL Label */ 
#line 2003
  token->type = (re_token_type_t )11;
#line 2004
  goto switch_break___0;
  case_43___0: /* CIL Label */ 
#line 2006
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2006
    if (! (syntax & (1UL << 1))) {
#line 2007
      token->type = (re_token_type_t )18;
    }
  }
#line 2008
  goto switch_break___0;
  case_63___0: /* CIL Label */ 
#line 2010
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2010
    if (! (syntax & (1UL << 1))) {
#line 2011
      token->type = (re_token_type_t )19;
    }
  }
#line 2012
  goto switch_break___0;
  case_123___0: /* CIL Label */ 
#line 2014
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2014
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2015
      token->type = (re_token_type_t )23;
    }
  }
#line 2016
  goto switch_break___0;
  case_125___0: /* CIL Label */ 
#line 2018
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2018
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2019
      token->type = (re_token_type_t )24;
    }
  }
#line 2020
  goto switch_break___0;
  case_40___0: /* CIL Label */ 
#line 2022
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2023
    token->type = (re_token_type_t )8;
  }
#line 2024
  goto switch_break___0;
  case_41___0: /* CIL Label */ 
#line 2026
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2027
    token->type = (re_token_type_t )9;
  }
#line 2028
  goto switch_break___0;
  case_91: /* CIL Label */ 
#line 2030
  token->type = (re_token_type_t )20;
#line 2031
  goto switch_break___0;
  case_46: /* CIL Label */ 
#line 2033
  token->type = (re_token_type_t )5;
#line 2034
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 2036
  if (! (syntax & ((((1UL << 1) << 1) << 1) | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 2036
    if (input->cur_idx != 0) {
#line 2039
      prev = (char )*(input->mbs + (input->cur_idx + -1));
#line 2040
      if (! (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2041
        goto switch_break___0;
      } else
#line 2040
      if ((int )prev != 10) {
#line 2041
        goto switch_break___0;
      }
    }
  }
#line 2043
  token->type = (re_token_type_t )12;
#line 2044
  token->opr.ctx_type = (re_context_type )16;
#line 2045
  goto switch_break___0;
  case_36: /* CIL Label */ 
#line 2047
  if (! (syntax & (((1UL << 1) << 1) << 1))) {
#line 2047
    if (input->cur_idx + 1 != input->len) {
      {
#line 2051
      (input->cur_idx) ++;
#line 2052
      peek_token(& next, input, syntax);
#line 2053
      (input->cur_idx) --;
      }
#line 2054
      if ((unsigned int )next.type != 10U) {
#line 2054
        if ((unsigned int )next.type != 9U) {
#line 2055
          goto switch_break___0;
        }
      }
    }
  }
#line 2057
  token->type = (re_token_type_t )12;
#line 2058
  token->opr.ctx_type = (re_context_type )32;
#line 2059
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2061
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2063
  return (1);
}
}
#line 2069 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static int peek_token_bracket(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char c2___0 ;
  int token_len ;

  {
#line 2074
  if (input->stop <= input->cur_idx) {
#line 2076
    token->type = (re_token_type_t )2;
#line 2077
    return (0);
  }
#line 2079
  c = *(input->mbs + input->cur_idx);
#line 2080
  token->opr.c = c;
#line 2083
  if (input->mb_cur_max > 1) {
#line 2083
    if (! (input->cur_idx == input->valid_len)) {
#line 2083
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 2086
        token->type = (re_token_type_t )1;
#line 2087
        return (1);
      }
    }
  }
#line 2091
  if ((int )c == 92) {
#line 2091
    if (syntax & 1UL) {
#line 2091
      if (input->cur_idx + 1 < input->len) {
#line 2096
        (input->cur_idx) ++;
#line 2097
        c2 = *(input->mbs + input->cur_idx);
#line 2098
        token->opr.c = c2;
#line 2099
        token->type = (re_token_type_t )1;
#line 2100
        return (1);
      }
    }
  }
#line 2102
  if ((int )c == 91) {
#line 2106
    if (input->cur_idx + 1 < input->len) {
#line 2107
      c2___0 = *(input->mbs + (input->cur_idx + 1));
    } else {
#line 2109
      c2___0 = (unsigned char)0;
    }
#line 2110
    token->opr.c = c2___0;
#line 2111
    token_len = 2;
    {
#line 2114
    if ((int )c2___0 == 46) {
#line 2114
      goto case_46;
    }
#line 2117
    if ((int )c2___0 == 61) {
#line 2117
      goto case_61;
    }
#line 2120
    if ((int )c2___0 == 58) {
#line 2120
      goto case_58;
    }
#line 2127
    goto switch_default;
    case_46: /* CIL Label */ 
#line 2115
    token->type = (re_token_type_t )26;
#line 2116
    goto switch_break;
    case_61: /* CIL Label */ 
#line 2118
    token->type = (re_token_type_t )28;
#line 2119
    goto switch_break;
    case_58: /* CIL Label */ 
#line 2121
    if (syntax & ((1UL << 1) << 1)) {
#line 2123
      token->type = (re_token_type_t )30;
#line 2124
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 2128
    token->type = (re_token_type_t )1;
#line 2129
    token->opr.c = c;
#line 2130
    token_len = 1;
#line 2131
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2133
    return (token_len);
  }
  {
#line 2137
  if ((int )c == 45) {
#line 2137
    goto case_45;
  }
#line 2140
  if ((int )c == 93) {
#line 2140
    goto case_93;
  }
#line 2143
  if ((int )c == 94) {
#line 2143
    goto case_94;
  }
#line 2146
  goto switch_default___0;
  case_45: /* CIL Label */ 
#line 2138
  token->type = (re_token_type_t )22;
#line 2139
  goto switch_break___0;
  case_93: /* CIL Label */ 
#line 2141
  token->type = (re_token_type_t )21;
#line 2142
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 2144
  token->type = (re_token_type_t )25;
#line 2145
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2147
  token->type = (re_token_type_t )1;
  switch_break___0: /* CIL Label */ ;
  }
#line 2149
  return (1);
}
}
#line 2166 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *parse(re_string_t *regexp___0 , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err___0 ) 
{ 
  re_dfa_t *dfa___0 ;
  bin_tree_t *tree ;
  bin_tree_t *eor ;
  bin_tree_t *root ;
  re_token_t current_token ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 2170
  dfa___0 = (re_dfa_t *)preg->buffer;
#line 2173
  dfa___0->syntax = syntax;
#line 2174
  fetch_token(& current_token, regexp___0, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2175
  tree = parse_reg_exp(regexp___0, preg, & current_token, syntax, 0, err___0);
  }
#line 2176
  if ((int )*err___0 != 0) {
#line 2176
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2176
      tmp___1 = 1;
    } else {
#line 2176
      tmp___1 = 0;
    }
  } else {
#line 2176
    tmp___1 = 0;
  }
  {
#line 2176
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 2176
  if (tmp___2) {
#line 2177
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2178
  eor = create_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                    (re_token_type_t )2);
  }
#line 2179
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
    {
#line 2180
    root = create_tree(dfa___0, tree, eor, (re_token_type_t )16);
    }
  } else {
#line 2182
    root = eor;
  }
#line 2183
  if ((unsigned long )eor == (unsigned long )((void *)0)) {
#line 2183
    tmp___3 = 1;
  } else
#line 2183
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 2183
    tmp___3 = 1;
  } else {
#line 2183
    tmp___3 = 0;
  }
  {
#line 2183
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 2183
  if (tmp___4) {
#line 2185
    *err___0 = (reg_errcode_t )12;
#line 2186
    return ((bin_tree_t *)((void *)0));
  }
#line 2188
  return (root);
}
}
#line 2200 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *parse_reg_exp(re_string_t *regexp___0 , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err___0 ) 
{ 
  re_dfa_t *dfa___0 ;
  bin_tree_t *tree ;
  bin_tree_t *branch___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  {
#line 2204
  dfa___0 = (re_dfa_t *)preg->buffer;
#line 2205
  branch___0 = (bin_tree_t *)((void *)0);
#line 2206
  tree = parse_branch(regexp___0, preg, token, syntax, nest, err___0);
  }
#line 2207
  if ((int )*err___0 != 0) {
#line 2207
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2207
      tmp___1 = 1;
    } else {
#line 2207
      tmp___1 = 0;
    }
  } else {
#line 2207
    tmp___1 = 0;
  }
  {
#line 2207
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 2207
  if (tmp___2) {
#line 2208
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2210
    if (! ((unsigned int )token->type == 10U)) {
#line 2210
      goto while_break;
    }
    {
#line 2212
    fetch_token(token, regexp___0, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    }
#line 2213
    if ((unsigned int )token->type != 10U) {
#line 2213
      if ((unsigned int )token->type != 2U) {
#line 2213
        if (nest == 0) {
#line 2213
          goto _L;
        } else
#line 2213
        if ((unsigned int )token->type != 9U) {
          _L: /* CIL Label */ 
          {
#line 2216
          branch___0 = parse_branch(regexp___0, preg, token, syntax, nest, err___0);
          }
#line 2217
          if ((int )*err___0 != 0) {
#line 2217
            if ((unsigned long )branch___0 == (unsigned long )((void *)0)) {
#line 2217
              tmp___3 = 1;
            } else {
#line 2217
              tmp___3 = 0;
            }
          } else {
#line 2217
            tmp___3 = 0;
          }
          {
#line 2217
          tmp___4 = __builtin_expect((long )tmp___3, 0L);
          }
#line 2217
          if (tmp___4) {
#line 2218
            return ((bin_tree_t *)((void *)0));
          }
        } else {
#line 2221
          branch___0 = (bin_tree_t *)((void *)0);
        }
      } else {
#line 2221
        branch___0 = (bin_tree_t *)((void *)0);
      }
    } else {
#line 2221
      branch___0 = (bin_tree_t *)((void *)0);
    }
    {
#line 2222
    tree = create_tree(dfa___0, tree, branch___0, (re_token_type_t )10);
#line 2223
    tmp___5 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                               0L);
    }
#line 2223
    if (tmp___5) {
#line 2225
      *err___0 = (reg_errcode_t )12;
#line 2226
      return ((bin_tree_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2229
  return (tree);
}
}
#line 2241 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *parse_branch(re_string_t *regexp___0 , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , int nest , reg_errcode_t *err___0 ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *exp___0 ;
  re_dfa_t *dfa___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  bin_tree_t *newtree ;
  bin_tree_t *tmp___5 ;

  {
  {
#line 2246
  dfa___0 = (re_dfa_t *)preg->buffer;
#line 2247
  tree = parse_expression(regexp___0, preg, token, syntax, nest, err___0);
  }
#line 2248
  if ((int )*err___0 != 0) {
#line 2248
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2248
      tmp___1 = 1;
    } else {
#line 2248
      tmp___1 = 0;
    }
  } else {
#line 2248
    tmp___1 = 0;
  }
  {
#line 2248
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 2248
  if (tmp___2) {
#line 2249
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2251
    if ((unsigned int )token->type != 10U) {
#line 2251
      if ((unsigned int )token->type != 2U) {
#line 2251
        if (! (nest == 0)) {
#line 2251
          if (! ((unsigned int )token->type != 9U)) {
#line 2251
            goto while_break;
          }
        }
      } else {
#line 2251
        goto while_break;
      }
    } else {
#line 2251
      goto while_break;
    }
    {
#line 2254
    exp___0 = parse_expression(regexp___0, preg, token, syntax, nest, err___0);
    }
#line 2255
    if ((int )*err___0 != 0) {
#line 2255
      if ((unsigned long )exp___0 == (unsigned long )((void *)0)) {
#line 2255
        tmp___3 = 1;
      } else {
#line 2255
        tmp___3 = 0;
      }
    } else {
#line 2255
      tmp___3 = 0;
    }
    {
#line 2255
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 2255
    if (tmp___4) {
#line 2257
      if ((unsigned long )tree != (unsigned long )((void *)0)) {
        {
#line 2258
        postorder(tree, & free_tree, (void *)0);
        }
      }
#line 2259
      return ((bin_tree_t *)((void *)0));
    }
#line 2261
    if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 2261
      if ((unsigned long )exp___0 != (unsigned long )((void *)0)) {
        {
#line 2263
        tmp___5 = create_tree(dfa___0, tree, exp___0, (re_token_type_t )16);
#line 2263
        newtree = tmp___5;
        }
#line 2264
        if ((unsigned long )newtree == (unsigned long )((void *)0)) {
          {
#line 2266
          postorder(exp___0, & free_tree, (void *)0);
#line 2267
          postorder(tree, & free_tree, (void *)0);
#line 2268
          *err___0 = (reg_errcode_t )12;
          }
#line 2269
          return ((bin_tree_t *)((void *)0));
        }
#line 2271
        tree = newtree;
      } else {
#line 2261
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2273
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2274
      tree = exp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2277
  return (tree);
}
}
#line 2286 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *parse_expression(re_string_t *regexp___0 , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , int nest , reg_errcode_t *err___0 ) 
{ 
  re_dfa_t *dfa___0 ;
  bin_tree_t *tree ;
  long tmp___1 ;
  bin_tree_t *mbc_remain ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  bin_tree_t *tmp___10 ;
  long tmp___11 ;
  bin_tree_t *tree_first ;
  bin_tree_t *tree_last ;
  int tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;
  int tmp___20 ;
  long tmp___21 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 2290
  dfa___0 = (re_dfa_t *)preg->buffer;
  {
#line 2294
  if ((unsigned int )token->type == 1U) {
#line 2294
    goto case_1;
  }
#line 2320
  if ((unsigned int )token->type == 8U) {
#line 2320
    goto case_8;
  }
#line 2325
  if ((unsigned int )token->type == 20U) {
#line 2325
    goto case_20;
  }
#line 2330
  if ((unsigned int )token->type == 4U) {
#line 2330
    goto case_4;
  }
#line 2346
  if ((unsigned int )token->type == 23U) {
#line 2346
    goto case_23;
  }
#line 2355
  if ((unsigned int )token->type == 19U) {
#line 2355
    goto case_19;
  }
#line 2355
  if ((unsigned int )token->type == 18U) {
#line 2355
    goto case_19;
  }
#line 2355
  if ((unsigned int )token->type == 11U) {
#line 2355
    goto case_19;
  }
#line 2367
  if ((unsigned int )token->type == 9U) {
#line 2367
    goto case_9;
  }
#line 2375
  if ((unsigned int )token->type == 24U) {
#line 2375
    goto case_24;
  }
#line 2389
  if ((unsigned int )token->type == 12U) {
#line 2389
    goto case_12;
  }
#line 2433
  if ((unsigned int )token->type == 5U) {
#line 2433
    goto case_5;
  }
#line 2444
  if ((unsigned int )token->type == 33U) {
#line 2444
    goto case_33;
  }
#line 2444
  if ((unsigned int )token->type == 32U) {
#line 2444
    goto case_33;
  }
#line 2453
  if ((unsigned int )token->type == 35U) {
#line 2453
    goto case_35;
  }
#line 2453
  if ((unsigned int )token->type == 34U) {
#line 2453
    goto case_35;
  }
#line 2462
  if ((unsigned int )token->type == 2U) {
#line 2462
    goto case_2;
  }
#line 2462
  if ((unsigned int )token->type == 10U) {
#line 2462
    goto case_2;
  }
#line 2464
  if ((unsigned int )token->type == 36U) {
#line 2464
    goto case_36;
  }
#line 2467
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2295
  tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2296
  tmp___1 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2296
  if (tmp___1) {
#line 2298
    *err___0 = (reg_errcode_t )12;
#line 2299
    return ((bin_tree_t *)((void *)0));
  }
#line 2302
  if (dfa___0->mb_cur_max > 1) {
    {
#line 2304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2304
      if (! (regexp___0->stop <= regexp___0->cur_idx)) {
#line 2304
        if (regexp___0->cur_idx == regexp___0->valid_len) {
#line 2304
          goto while_break;
        } else
#line 2304
        if (*(regexp___0->wcs + regexp___0->cur_idx) != 4294967295U) {
#line 2304
          goto while_break;
        }
      } else {
#line 2304
        goto while_break;
      }
      {
#line 2308
      fetch_token(token, regexp___0, syntax);
#line 2309
      mbc_remain = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2310
      tree = create_tree(dfa___0, tree, mbc_remain, (re_token_type_t )16);
      }
#line 2311
      if ((unsigned long )mbc_remain == (unsigned long )((void *)0)) {
#line 2311
        tmp___2 = 1;
      } else
#line 2311
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2311
        tmp___2 = 1;
      } else {
#line 2311
        tmp___2 = 0;
      }
      {
#line 2311
      tmp___3 = __builtin_expect((long )tmp___2, 0L);
      }
#line 2311
      if (tmp___3) {
#line 2313
        *err___0 = (reg_errcode_t )12;
#line 2314
        return ((bin_tree_t *)((void *)0));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2319
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 2321
  tree = parse_sub_exp(regexp___0, preg, token, syntax, nest + 1, err___0);
  }
#line 2322
  if ((int )*err___0 != 0) {
#line 2322
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2322
      tmp___4 = 1;
    } else {
#line 2322
      tmp___4 = 0;
    }
  } else {
#line 2322
    tmp___4 = 0;
  }
  {
#line 2322
  tmp___5 = __builtin_expect((long )tmp___4, 0L);
  }
#line 2322
  if (tmp___5) {
#line 2323
    return ((bin_tree_t *)((void *)0));
  }
#line 2324
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 2326
  tree = parse_bracket_exp(regexp___0, dfa___0, token, syntax, err___0);
  }
#line 2327
  if ((int )*err___0 != 0) {
#line 2327
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2327
      tmp___6 = 1;
    } else {
#line 2327
      tmp___6 = 0;
    }
  } else {
#line 2327
    tmp___6 = 0;
  }
  {
#line 2327
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
#line 2327
  if (tmp___7) {
#line 2328
    return ((bin_tree_t *)((void *)0));
  }
#line 2329
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2331
  tmp___8 = __builtin_expect((long )(dfa___0->completed_bkref_map & (unsigned long )(1 << token->opr.idx)),
                             1L);
  }
#line 2331
  if (! tmp___8) {
#line 2333
    *err___0 = (reg_errcode_t )6;
#line 2334
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2336
  dfa___0->used_bkref_map |= (unsigned long )(1 << token->opr.idx);
#line 2337
  tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2338
  tmp___9 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2338
  if (tmp___9) {
#line 2340
    *err___0 = (reg_errcode_t )12;
#line 2341
    return ((bin_tree_t *)((void *)0));
  }
#line 2343
  (dfa___0->nbackref) ++;
#line 2344
  dfa___0->has_mb_node = 1U;
#line 2345
  goto switch_break;
  case_23: /* CIL Label */ 
#line 2347
  if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2349
    *err___0 = (reg_errcode_t )13;
#line 2350
    return ((bin_tree_t *)((void *)0));
  }
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 2356
  if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
#line 2358
    *err___0 = (reg_errcode_t )13;
#line 2359
    return ((bin_tree_t *)((void *)0));
  } else
#line 2361
  if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
    {
#line 2363
    fetch_token(token, regexp___0, syntax);
#line 2364
    tmp___10 = parse_expression(regexp___0, preg, token, syntax, nest, err___0);
    }
#line 2364
    return (tmp___10);
  }
  case_9: /* CIL Label */ 
#line 2368
  if ((unsigned int )token->type == 9U) {
#line 2368
    if (! (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2371
      *err___0 = (reg_errcode_t )16;
#line 2372
      return ((bin_tree_t *)((void *)0));
    }
  }
  case_24: /* CIL Label */ 
  {
#line 2379
  token->type = (re_token_type_t )1;
#line 2382
  tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2383
  tmp___11 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
#line 2383
  if (tmp___11) {
#line 2385
    *err___0 = (reg_errcode_t )12;
#line 2386
    return ((bin_tree_t *)((void *)0));
  }
#line 2388
  goto switch_break;
  case_12: /* CIL Label */ 
#line 2390
  if ((unsigned int )token->opr.ctx_type & 783U) {
#line 2390
    if (dfa___0->word_ops_used == 0U) {
      {
#line 2393
      init_word_char(dfa___0);
      }
    }
  }
#line 2394
  if ((unsigned int )token->opr.ctx_type == 256U) {
#line 2394
    goto _L;
  } else
#line 2394
  if ((unsigned int )token->opr.ctx_type == 512U) {
    _L: /* CIL Label */ 
#line 2398
    if ((unsigned int )token->opr.ctx_type == 256U) {
      {
#line 2400
      token->opr.ctx_type = (re_context_type )6;
#line 2401
      tree_first = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2402
      token->opr.ctx_type = (re_context_type )9;
      }
    } else {
      {
#line 2406
      token->opr.ctx_type = (re_context_type )5;
#line 2407
      tree_first = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2408
      token->opr.ctx_type = (re_context_type )10;
      }
    }
    {
#line 2410
    tree_last = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)token);
#line 2411
    tree = create_tree(dfa___0, tree_first, tree_last, (re_token_type_t )10);
    }
#line 2412
    if ((unsigned long )tree_first == (unsigned long )((void *)0)) {
#line 2412
      tmp___12 = 1;
    } else
#line 2412
    if ((unsigned long )tree_last == (unsigned long )((void *)0)) {
#line 2412
      tmp___12 = 1;
    } else
#line 2412
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2412
      tmp___12 = 1;
    } else {
#line 2412
      tmp___12 = 0;
    }
    {
#line 2412
    tmp___13 = __builtin_expect((long )tmp___12, 0L);
    }
#line 2412
    if (tmp___13) {
#line 2414
      *err___0 = (reg_errcode_t )12;
#line 2415
      return ((bin_tree_t *)((void *)0));
    }
  } else {
    {
#line 2420
    tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                             (re_token_t const   *)token);
#line 2421
    tmp___14 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 2421
    if (tmp___14) {
#line 2423
      *err___0 = (reg_errcode_t )12;
#line 2424
      return ((bin_tree_t *)((void *)0));
    }
  }
  {
#line 2431
  fetch_token(token, regexp___0, syntax);
  }
#line 2432
  return (tree);
  case_5: /* CIL Label */ 
  {
#line 2434
  tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2435
  tmp___15 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
#line 2435
  if (tmp___15) {
#line 2437
    *err___0 = (reg_errcode_t )12;
#line 2438
    return ((bin_tree_t *)((void *)0));
  }
#line 2440
  if (dfa___0->mb_cur_max > 1) {
#line 2441
    dfa___0->has_mb_node = 1U;
  }
#line 2442
  goto switch_break;
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 2445
  tree = build_charclass_op(dfa___0, regexp___0->trans, "alnum", "_", (unsigned int )token->type == 33U,
                            err___0);
  }
#line 2449
  if ((int )*err___0 != 0) {
#line 2449
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2449
      tmp___16 = 1;
    } else {
#line 2449
      tmp___16 = 0;
    }
  } else {
#line 2449
    tmp___16 = 0;
  }
  {
#line 2449
  tmp___17 = __builtin_expect((long )tmp___16, 0L);
  }
#line 2449
  if (tmp___17) {
#line 2450
    return ((bin_tree_t *)((void *)0));
  }
#line 2451
  goto switch_break;
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  {
#line 2454
  tree = build_charclass_op(dfa___0, regexp___0->trans, "space", "", (unsigned int )token->type == 35U,
                            err___0);
  }
#line 2458
  if ((int )*err___0 != 0) {
#line 2458
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2458
      tmp___18 = 1;
    } else {
#line 2458
      tmp___18 = 0;
    }
  } else {
#line 2458
    tmp___18 = 0;
  }
  {
#line 2458
  tmp___19 = __builtin_expect((long )tmp___18, 0L);
  }
#line 2458
  if (tmp___19) {
#line 2459
    return ((bin_tree_t *)((void *)0));
  }
#line 2460
  goto switch_break;
  case_2: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 2463
  return ((bin_tree_t *)((void *)0));
  case_36: /* CIL Label */ 
#line 2465
  *err___0 = (reg_errcode_t )5;
#line 2466
  return ((bin_tree_t *)((void *)0));
  switch_default: /* CIL Label */ 
#line 2472
  return ((bin_tree_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 2474
  fetch_token(token, regexp___0, syntax);
  }
  {
#line 2476
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2476
    if (! ((unsigned int )token->type == 11U)) {
#line 2476
      if (! ((unsigned int )token->type == 18U)) {
#line 2476
        if (! ((unsigned int )token->type == 19U)) {
#line 2476
          if (! ((unsigned int )token->type == 23U)) {
#line 2476
            goto while_break___0;
          }
        }
      }
    }
    {
#line 2479
    tree = parse_dup_op(tree, regexp___0, dfa___0, token, syntax, err___0);
    }
#line 2480
    if ((int )*err___0 != 0) {
#line 2480
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2480
        tmp___20 = 1;
      } else {
#line 2480
        tmp___20 = 0;
      }
    } else {
#line 2480
      tmp___20 = 0;
    }
    {
#line 2480
    tmp___21 = __builtin_expect((long )tmp___20, 0L);
    }
#line 2480
    if (tmp___21) {
#line 2481
      return ((bin_tree_t *)((void *)0));
    }
#line 2483
    if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2483
      if ((unsigned int )token->type == 11U) {
#line 2487
        *err___0 = (reg_errcode_t )13;
#line 2488
        return ((bin_tree_t *)((void *)0));
      } else
#line 2483
      if ((unsigned int )token->type == 23U) {
#line 2487
        *err___0 = (reg_errcode_t )13;
#line 2488
        return ((bin_tree_t *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2492
  return (tree);
}
}
#line 2502 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *parse_sub_exp(re_string_t *regexp___0 , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , int nest , reg_errcode_t *err___0 ) 
{ 
  re_dfa_t *dfa___0 ;
  bin_tree_t *tree ;
  size_t cur_nsub ;
  size_t tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  {
#line 2506
  dfa___0 = (re_dfa_t *)preg->buffer;
#line 2509
  tmp___1 = preg->re_nsub;
#line 2509
  (preg->re_nsub) ++;
#line 2509
  cur_nsub = tmp___1;
#line 2511
  fetch_token(token, regexp___0, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 2514
  if ((unsigned int )token->type == 9U) {
#line 2515
    tree = (bin_tree_t *)((void *)0);
  } else {
    {
#line 2518
    tree = parse_reg_exp(regexp___0, preg, token, syntax, nest, err___0);
    }
#line 2519
    if ((int )*err___0 == 0) {
#line 2519
      if ((unsigned int )token->type != 9U) {
#line 2519
        tmp___2 = 1;
      } else {
#line 2519
        tmp___2 = 0;
      }
    } else {
#line 2519
      tmp___2 = 0;
    }
    {
#line 2519
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
    }
#line 2519
    if (tmp___3) {
#line 2521
      if ((unsigned long )tree != (unsigned long )((void *)0)) {
        {
#line 2522
        postorder(tree, & free_tree, (void *)0);
        }
      }
#line 2523
      *err___0 = (reg_errcode_t )8;
    }
    {
#line 2525
    tmp___4 = __builtin_expect((long )((int )*err___0 != 0), 0L);
    }
#line 2525
    if (tmp___4) {
#line 2526
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2529
  if (cur_nsub <= 8UL) {
#line 2530
    dfa___0->completed_bkref_map |= (unsigned long )(1 << cur_nsub);
  }
  {
#line 2532
  tree = create_tree(dfa___0, tree, (bin_tree_t *)((void *)0), (re_token_type_t )17);
#line 2533
  tmp___5 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2533
  if (tmp___5) {
#line 2535
    *err___0 = (reg_errcode_t )12;
#line 2536
    return ((bin_tree_t *)((void *)0));
  }
#line 2538
  tree->token.opr.idx = (int )cur_nsub;
#line 2539
  return (tree);
}
}
#line 2544 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp___0 , re_dfa_t *dfa___0 ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err___0 ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *old_tree ;
  int i___0 ;
  int start ;
  int end ;
  int start_idx ;
  re_token_t start_token ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  int tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;

  {
#line 2548
  tree = (bin_tree_t *)((void *)0);
#line 2548
  old_tree = (bin_tree_t *)((void *)0);
#line 2549
  start_idx = regexp___0->cur_idx;
#line 2551
  start_token = *token;
#line 2558
  if ((unsigned int )token->type == 23U) {
    {
#line 2560
    end = 0;
#line 2561
    start = fetch_number(regexp___0, token, syntax);
    }
#line 2562
    if (start == -1) {
#line 2564
      if ((unsigned int )token->type == 1U) {
#line 2564
        if ((int )token->opr.c == 44) {
#line 2565
          start = 0;
        } else {
#line 2568
          *err___0 = (reg_errcode_t )10;
#line 2569
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 2568
        *err___0 = (reg_errcode_t )10;
#line 2569
        return ((bin_tree_t *)((void *)0));
      }
    }
    {
#line 2572
    tmp___3 = __builtin_expect((long )(start != -2), 1L);
    }
#line 2572
    if (tmp___3) {
#line 2575
      if ((unsigned int )token->type == 24U) {
#line 2575
        end = start;
      } else {
#line 2575
        if ((unsigned int )token->type == 1U) {
#line 2575
          if ((int )token->opr.c == 44) {
            {
#line 2575
            tmp___1 = fetch_number(regexp___0, token, syntax);
#line 2575
            tmp___2 = tmp___1;
            }
          } else {
#line 2575
            tmp___2 = -2;
          }
        } else {
#line 2575
          tmp___2 = -2;
        }
#line 2575
        end = tmp___2;
      }
    }
#line 2579
    if (start == -2) {
#line 2579
      tmp___5 = 1;
    } else
#line 2579
    if (end == -2) {
#line 2579
      tmp___5 = 1;
    } else {
#line 2579
      tmp___5 = 0;
    }
    {
#line 2579
    tmp___6 = __builtin_expect((long )tmp___5, 0L);
    }
#line 2579
    if (tmp___6) {
      {
#line 2582
      tmp___4 = __builtin_expect((long )(! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
                                 0L);
      }
#line 2582
      if (tmp___4) {
#line 2584
        if ((unsigned int )token->type == 2U) {
#line 2585
          *err___0 = (reg_errcode_t )9;
        } else {
#line 2587
          *err___0 = (reg_errcode_t )10;
        }
#line 2589
        return ((bin_tree_t *)((void *)0));
      }
#line 2593
      regexp___0->cur_idx = start_idx;
#line 2594
      *token = start_token;
#line 2595
      token->type = (re_token_type_t )1;
#line 2598
      return (elem);
    }
#line 2601
    if (end != -1) {
#line 2601
      if (start > end) {
#line 2601
        tmp___7 = 1;
      } else {
#line 2601
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2601
    if ((unsigned int )token->type != 24U) {
#line 2601
      tmp___7 = 1;
    } else {
#line 2601
      tmp___7 = 0;
    }
    {
#line 2601
    tmp___8 = __builtin_expect((long )tmp___7, 0L);
    }
#line 2601
    if (tmp___8) {
#line 2604
      *err___0 = (reg_errcode_t )10;
#line 2605
      return ((bin_tree_t *)((void *)0));
    }
  } else {
#line 2610
    if ((unsigned int )token->type == 18U) {
#line 2610
      start = 1;
    } else {
#line 2610
      start = 0;
    }
#line 2611
    if ((unsigned int )token->type == 19U) {
#line 2611
      end = 1;
    } else {
#line 2611
      end = -1;
    }
  }
  {
#line 2614
  fetch_token(token, regexp___0, syntax);
#line 2616
  tmp___9 = __builtin_expect((long )((unsigned long )elem == (unsigned long )((void *)0)),
                             0L);
  }
#line 2616
  if (tmp___9) {
#line 2617
    return ((bin_tree_t *)((void *)0));
  }
#line 2618
  if (start == 0) {
#line 2618
    if (end == 0) {
#line 2618
      tmp___10 = 1;
    } else {
#line 2618
      tmp___10 = 0;
    }
  } else {
#line 2618
    tmp___10 = 0;
  }
  {
#line 2618
  tmp___11 = __builtin_expect((long )tmp___10, 0L);
  }
#line 2618
  if (tmp___11) {
    {
#line 2620
    postorder(elem, & free_tree, (void *)0);
    }
#line 2621
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2625
  tmp___14 = __builtin_expect((long )(start > 0), 0L);
  }
#line 2625
  if (tmp___14) {
#line 2627
    tree = elem;
#line 2628
    i___0 = 2;
    {
#line 2628
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2628
      if (! (i___0 <= start)) {
#line 2628
        goto while_break;
      }
      {
#line 2630
      elem = duplicate_tree((bin_tree_t const   *)elem, dfa___0);
#line 2631
      tree = create_tree(dfa___0, tree, elem, (re_token_type_t )16);
      }
#line 2632
      if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2632
        tmp___12 = 1;
      } else
#line 2632
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2632
        tmp___12 = 1;
      } else {
#line 2632
        tmp___12 = 0;
      }
      {
#line 2632
      tmp___13 = __builtin_expect((long )tmp___12, 0L);
      }
#line 2632
      if (tmp___13) {
#line 2633
        goto parse_dup_op_espace;
      }
#line 2628
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2636
    if (start == end) {
#line 2637
      return (tree);
    }
    {
#line 2640
    elem = duplicate_tree((bin_tree_t const   *)elem, dfa___0);
#line 2641
    old_tree = tree;
    }
  } else {
#line 2644
    old_tree = (bin_tree_t *)((void *)0);
  }
#line 2646
  if ((unsigned int )elem->token.type == 17U) {
    {
#line 2647
    postorder(elem, & mark_opt_subexp, (void *)((long )elem->token.opr.idx));
    }
  }
#line 2649
  if (end == -1) {
#line 2649
    tmp___15 = 11;
  } else {
#line 2649
    tmp___15 = 10;
  }
  {
#line 2649
  tree = create_tree(dfa___0, elem, (bin_tree_t *)((void *)0), (re_token_type_t )tmp___15);
#line 2650
  tmp___16 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
#line 2650
  if (tmp___16) {
#line 2651
    goto parse_dup_op_espace;
  }
#line 2656
  i___0 = start + 2;
  {
#line 2656
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2656
    if (! (i___0 <= end)) {
#line 2656
      goto while_break___0;
    }
    {
#line 2658
    elem = duplicate_tree((bin_tree_t const   *)elem, dfa___0);
#line 2659
    tree = create_tree(dfa___0, tree, elem, (re_token_type_t )16);
    }
#line 2660
    if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2660
      tmp___17 = 1;
    } else
#line 2660
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2660
      tmp___17 = 1;
    } else {
#line 2660
      tmp___17 = 0;
    }
    {
#line 2660
    tmp___18 = __builtin_expect((long )tmp___17, 0L);
    }
#line 2660
    if (tmp___18) {
#line 2661
      goto parse_dup_op_espace;
    }
    {
#line 2663
    tree = create_tree(dfa___0, tree, (bin_tree_t *)((void *)0), (re_token_type_t )10);
#line 2664
    tmp___19 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 2664
    if (tmp___19) {
#line 2665
      goto parse_dup_op_espace;
    }
#line 2656
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2668
  if (old_tree) {
    {
#line 2669
    tree = create_tree(dfa___0, old_tree, tree, (re_token_type_t )16);
    }
  }
#line 2671
  return (tree);
  parse_dup_op_espace: 
#line 2674
  *err___0 = (reg_errcode_t )12;
#line 2675
  return ((bin_tree_t *)((void *)0));
}
}
#line 2690 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t build_range_exp(reg_syntax_t syntax , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , int *range_alloc , bracket_elem_t *start_elem ,
                                     bracket_elem_t *end_elem ) 
{ 
  unsigned int start_ch ;
  unsigned int end_ch ;
  int tmp___1 ;
  long tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  wchar_t wc ;
  wint_t start_wc ;
  wint_t end_wc ;
  int tmp___7 ;
  int tmp___8 ;
  wchar_t *new_array_start ;
  wchar_t *new_array_end ;
  int new_nranges ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;

  {
#line 2703
  if ((unsigned int )start_elem->type == 2U) {
#line 2703
    tmp___1 = 1;
  } else
#line 2703
  if ((unsigned int )start_elem->type == 4U) {
#line 2703
    tmp___1 = 1;
  } else
#line 2703
  if ((unsigned int )end_elem->type == 2U) {
#line 2703
    tmp___1 = 1;
  } else
#line 2703
  if ((unsigned int )end_elem->type == 4U) {
#line 2703
    tmp___1 = 1;
  } else {
#line 2703
    tmp___1 = 0;
  }
  {
#line 2703
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 2703
  if (tmp___2) {
#line 2706
    return ((reg_errcode_t )11);
  }
#line 2710
  if ((unsigned int )start_elem->type == 3U) {
    {
#line 2710
    tmp___3 = strlen((char const   *)((char *)start_elem->opr.name));
    }
#line 2710
    if (tmp___3 > 1UL) {
#line 2710
      tmp___5 = 1;
    } else {
#line 2710
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2710
  if ((unsigned int )end_elem->type == 3U) {
    {
#line 2710
    tmp___4 = strlen((char const   *)((char *)end_elem->opr.name));
    }
#line 2710
    if (tmp___4 > 1UL) {
#line 2710
      tmp___5 = 1;
    } else {
#line 2710
      tmp___5 = 0;
    }
  } else {
#line 2710
    tmp___5 = 0;
  }
  {
#line 2710
  tmp___6 = __builtin_expect((long )tmp___5, 0L);
  }
#line 2710
  if (tmp___6) {
#line 2714
    return ((reg_errcode_t )3);
  }
#line 2722
  if ((unsigned int )start_elem->type == 0U) {
#line 2722
    start_ch = (unsigned int )start_elem->opr.ch;
  } else {
#line 2722
    if ((unsigned int )start_elem->type == 3U) {
#line 2722
      tmp___7 = (int )*(start_elem->opr.name + 0);
    } else {
#line 2722
      tmp___7 = 0;
    }
#line 2722
    start_ch = (unsigned int )tmp___7;
  }
#line 2725
  if ((unsigned int )end_elem->type == 0U) {
#line 2725
    end_ch = (unsigned int )end_elem->opr.ch;
  } else {
#line 2725
    if ((unsigned int )end_elem->type == 3U) {
#line 2725
      tmp___8 = (int )*(end_elem->opr.name + 0);
    } else {
#line 2725
      tmp___8 = 0;
    }
#line 2725
    end_ch = (unsigned int )tmp___8;
  }
#line 2734
  if ((unsigned int )start_elem->type == 0U) {
#line 2734
    start_wc = start_ch;
  } else
#line 2734
  if ((unsigned int )start_elem->type == 3U) {
#line 2734
    start_wc = start_ch;
  } else {
#line 2734
    start_wc = (wint_t )start_elem->opr.wch;
  }
#line 2736
  if ((unsigned int )end_elem->type == 0U) {
#line 2736
    end_wc = end_ch;
  } else
#line 2736
  if ((unsigned int )end_elem->type == 3U) {
#line 2736
    end_wc = end_ch;
  } else {
#line 2736
    end_wc = (wint_t )end_elem->opr.wch;
  }
#line 2744
  if (start_wc == 4294967295U) {
#line 2745
    return ((reg_errcode_t )3);
  } else
#line 2744
  if (end_wc == 4294967295U) {
#line 2745
    return ((reg_errcode_t )3);
  } else
#line 2746
  if (syntax & ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2746
    if (start_wc > end_wc) {
#line 2747
      return ((reg_errcode_t )11);
    }
  }
#line 2754
  if (mbcset) {
    {
#line 2757
    tmp___13 = __builtin_expect((long )(*range_alloc == mbcset->nranges), 0L);
    }
#line 2757
    if (tmp___13) {
      {
#line 2764
      new_nranges = 2 * mbcset->nranges + 1;
#line 2767
      tmp___9 = realloc((void *)mbcset->range_starts, (unsigned long )new_nranges * sizeof(wchar_t ));
#line 2767
      new_array_start = (wchar_t *)tmp___9;
#line 2769
      tmp___10 = realloc((void *)mbcset->range_ends, (unsigned long )new_nranges * sizeof(wchar_t ));
#line 2769
      new_array_end = (wchar_t *)tmp___10;
      }
#line 2772
      if ((unsigned long )new_array_start == (unsigned long )((void *)0)) {
#line 2772
        tmp___11 = 1;
      } else
#line 2772
      if ((unsigned long )new_array_end == (unsigned long )((void *)0)) {
#line 2772
        tmp___11 = 1;
      } else {
#line 2772
        tmp___11 = 0;
      }
      {
#line 2772
      tmp___12 = __builtin_expect((long )tmp___11, 0L);
      }
#line 2772
      if (tmp___12) {
#line 2773
        return ((reg_errcode_t )12);
      }
#line 2775
      mbcset->range_starts = new_array_start;
#line 2776
      mbcset->range_ends = new_array_end;
#line 2777
      *range_alloc = new_nranges;
    }
#line 2780
    *(mbcset->range_starts + mbcset->nranges) = (wchar_t )start_wc;
#line 2781
    tmp___14 = mbcset->nranges;
#line 2781
    (mbcset->nranges) ++;
#line 2781
    *(mbcset->range_ends + tmp___14) = (wchar_t )end_wc;
  }
#line 2785
  wc = 0;
  {
#line 2785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2785
    if (! (wc < 256)) {
#line 2785
      goto while_break;
    }
#line 2787
    if (start_wc <= (wint_t )wc) {
#line 2787
      if ((wint_t )wc <= end_wc) {
#line 2788
        *(sbcset + (unsigned long )wc / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )wc % (sizeof(bitset_word_t ) * 8UL);
      }
    }
#line 2785
    wc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2808
  return ((reg_errcode_t )0);
}
}
#line 2819 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t build_collating_symbol(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                            int *coll_sym_alloc , unsigned char const   *name ) 
{ 
  size_t name_len ;
  size_t tmp___1 ;
  long tmp___2 ;

  {
  {
#line 2828
  tmp___1 = strlen((char const   *)name);
#line 2828
  name_len = tmp___1;
#line 2829
  tmp___2 = __builtin_expect((long )(name_len != 1UL), 0L);
  }
#line 2829
  if (tmp___2) {
#line 2830
    return ((reg_errcode_t )3);
  } else {
#line 2833
    *(sbcset + (unsigned long )*(name + 0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(name + 0) % (sizeof(bitset_word_t ) * 8UL);
#line 2834
    return ((reg_errcode_t )0);
  }
}
}
#line 2842 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *parse_bracket_exp(re_string_t *regexp___0 , re_dfa_t *dfa___0 ,
                                     re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err___0 ) 
{ 
  re_token_t br_token ;
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  int coll_sym_alloc ;
  int range_alloc ;
  int mbchar_alloc ;
  int equiv_class_alloc ;
  int char_class_alloc ;
  int non_match ;
  bin_tree_t *work_tree ;
  int token_len ;
  int first_round ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  bracket_elem_t start_elem ;
  bracket_elem_t end_elem ;
  unsigned char start_name_buf[32] ;
  unsigned char end_name_buf[32] ;
  reg_errcode_t ret ;
  int token_len2 ;
  int is_range_exp ;
  re_token_t token2 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  re_charset_t *tmp___11 ;
  long tmp___12 ;
  wchar_t *new_mbchars ;
  void *tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  bin_tree_t *mbc_tree ;
  int sbc_idx ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;

  {
  {
#line 3114
  coll_sym_alloc = 0;
#line 3114
  range_alloc = 0;
#line 3114
  mbchar_alloc = 0;
#line 3115
  equiv_class_alloc = 0;
#line 3115
  char_class_alloc = 0;
#line 3117
  non_match = 0;
#line 3120
  first_round = 1;
#line 3138
  tmp___1 = calloc(sizeof(bitset_t ), (size_t )1);
#line 3138
  sbcset = (re_bitset_ptr_t )tmp___1;
#line 3140
  tmp___2 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3140
  mbcset = (re_charset_t *)tmp___2;
  }
#line 3143
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3143
    tmp___3 = 1;
  } else
#line 3143
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3143
    tmp___3 = 1;
  } else {
#line 3143
    tmp___3 = 0;
  }
  {
#line 3143
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 3143
  if (tmp___4) {
    {
#line 3148
    free((void *)sbcset);
#line 3150
    free((void *)mbcset);
#line 3152
    *err___0 = (reg_errcode_t )12;
    }
#line 3153
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3156
  token_len = peek_token_bracket(token, regexp___0, syntax);
#line 3157
  tmp___5 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
  }
#line 3157
  if (tmp___5) {
#line 3159
    *err___0 = (reg_errcode_t )2;
#line 3160
    goto parse_bracket_exp_free_return;
  }
#line 3162
  if ((unsigned int )token->type == 25U) {
#line 3165
    mbcset->non_match = 1U;
#line 3167
    non_match = 1;
#line 3168
    if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3169
      *(sbcset + 10UL / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << 10UL % (sizeof(bitset_word_t ) * 8UL);
    }
    {
#line 3170
    regexp___0->cur_idx += token_len;
#line 3171
    token_len = peek_token_bracket(token, regexp___0, syntax);
#line 3172
    tmp___6 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3172
    if (tmp___6) {
#line 3174
      *err___0 = (reg_errcode_t )2;
#line 3175
      goto parse_bracket_exp_free_return;
    }
  }
#line 3180
  if ((unsigned int )token->type == 21U) {
#line 3181
    token->type = (re_token_type_t )1;
  }
  {
#line 3183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3189
    token_len2 = 0;
#line 3189
    is_range_exp = 0;
#line 3192
    start_elem.opr.name = start_name_buf;
#line 3193
    ret = parse_bracket_element(& start_elem, regexp___0, token, token_len, dfa___0,
                                syntax, first_round);
#line 3195
    tmp___7 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 3195
    if (tmp___7) {
#line 3197
      *err___0 = ret;
#line 3198
      goto parse_bracket_exp_free_return;
    }
    {
#line 3200
    first_round = 0;
#line 3203
    token_len = peek_token_bracket(token, regexp___0, syntax);
    }
#line 3206
    if ((unsigned int )start_elem.type != 4U) {
#line 3206
      if ((unsigned int )start_elem.type != 2U) {
        {
#line 3208
        tmp___8 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
        }
#line 3208
        if (tmp___8) {
#line 3210
          *err___0 = (reg_errcode_t )7;
#line 3211
          goto parse_bracket_exp_free_return;
        }
#line 3213
        if ((unsigned int )token->type == 22U) {
          {
#line 3215
          regexp___0->cur_idx += token_len;
#line 3216
          token_len2 = peek_token_bracket(& token2, regexp___0, syntax);
#line 3217
          tmp___9 = __builtin_expect((long )((unsigned int )token2.type == 2U), 0L);
          }
#line 3217
          if (tmp___9) {
#line 3219
            *err___0 = (reg_errcode_t )7;
#line 3220
            goto parse_bracket_exp_free_return;
          }
#line 3222
          if ((unsigned int )token2.type == 21U) {
#line 3225
            regexp___0->cur_idx += - token_len;
#line 3226
            token->type = (re_token_type_t )1;
          } else {
#line 3229
            is_range_exp = 1;
          }
        }
      }
    }
#line 3233
    if (is_range_exp == 1) {
      {
#line 3235
      end_elem.opr.name = end_name_buf;
#line 3236
      ret = parse_bracket_element(& end_elem, regexp___0, & token2, token_len2, dfa___0,
                                  syntax, 1);
#line 3238
      tmp___10 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 3238
      if (tmp___10) {
#line 3240
        *err___0 = ret;
#line 3241
        goto parse_bracket_exp_free_return;
      }
      {
#line 3244
      token_len = peek_token_bracket(token, regexp___0, syntax);
      }
#line 3251
      if (dfa___0->mb_cur_max > 1) {
#line 3251
        tmp___11 = mbcset;
      } else {
#line 3251
        tmp___11 = (re_charset_t *)((void *)0);
      }
      {
#line 3251
      *err___0 = build_range_exp(syntax, (bitset_word_t *)sbcset, tmp___11, & range_alloc,
                                 & start_elem, & end_elem);
#line 3258
      tmp___12 = __builtin_expect((long )((int )*err___0 != 0), 0L);
      }
#line 3258
      if (tmp___12) {
#line 3259
        goto parse_bracket_exp_free_return;
      }
    } else {
      {
#line 3265
      if ((unsigned int )start_elem.type == 0U) {
#line 3265
        goto case_0;
      }
#line 3269
      if ((unsigned int )start_elem.type == 1U) {
#line 3269
        goto case_1;
      }
#line 3287
      if ((unsigned int )start_elem.type == 2U) {
#line 3287
        goto case_2;
      }
#line 3296
      if ((unsigned int )start_elem.type == 3U) {
#line 3296
        goto case_3;
      }
#line 3305
      if ((unsigned int )start_elem.type == 4U) {
#line 3305
        goto case_4;
      }
#line 3314
      goto switch_default;
      case_0: /* CIL Label */ 
#line 3266
      *(sbcset + (unsigned long )start_elem.opr.ch / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )start_elem.opr.ch % (sizeof(bitset_word_t ) * 8UL);
#line 3267
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 3271
      tmp___15 = __builtin_expect((long )(mbchar_alloc == mbcset->nmbchars), 0L);
      }
#line 3271
      if (tmp___15) {
        {
#line 3276
        mbchar_alloc = 2 * mbcset->nmbchars + 1;
#line 3278
        tmp___13 = realloc((void *)mbcset->mbchars, (unsigned long )mbchar_alloc * sizeof(wchar_t ));
#line 3278
        new_mbchars = (wchar_t *)tmp___13;
#line 3280
        tmp___14 = __builtin_expect((long )((unsigned long )new_mbchars == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3280
        if (tmp___14) {
#line 3281
          goto parse_bracket_exp_espace;
        }
#line 3282
        mbcset->mbchars = new_mbchars;
      }
#line 3284
      tmp___16 = mbcset->nmbchars;
#line 3284
      (mbcset->nmbchars) ++;
#line 3284
      *(mbcset->mbchars + tmp___16) = start_elem.opr.wch;
#line 3285
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 3288
      *err___0 = build_equiv_class((bitset_word_t *)sbcset, mbcset, & equiv_class_alloc,
                                   (unsigned char const   *)start_elem.opr.name);
#line 3293
      tmp___17 = __builtin_expect((long )((int )*err___0 != 0), 0L);
      }
#line 3293
      if (tmp___17) {
#line 3294
        goto parse_bracket_exp_free_return;
      }
#line 3295
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 3297
      *err___0 = build_collating_symbol((bitset_word_t *)sbcset, mbcset, & coll_sym_alloc,
                                        (unsigned char const   *)start_elem.opr.name);
#line 3302
      tmp___18 = __builtin_expect((long )((int )*err___0 != 0), 0L);
      }
#line 3302
      if (tmp___18) {
#line 3303
        goto parse_bracket_exp_free_return;
      }
#line 3304
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 3306
      *err___0 = build_charclass(regexp___0->trans, (bitset_word_t *)sbcset, mbcset,
                                 & char_class_alloc, (char const   *)start_elem.opr.name,
                                 syntax);
#line 3311
      tmp___19 = __builtin_expect((long )((int )*err___0 != 0), 0L);
      }
#line 3311
      if (tmp___19) {
#line 3312
        goto parse_bracket_exp_free_return;
      }
#line 3313
      goto switch_break;
      switch_default: /* CIL Label */ ;
#line 3316
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 3319
    tmp___20 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3319
    if (tmp___20) {
#line 3321
      *err___0 = (reg_errcode_t )7;
#line 3322
      goto parse_bracket_exp_free_return;
    }
#line 3324
    if ((unsigned int )token->type == 21U) {
#line 3325
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3328
  regexp___0->cur_idx += token_len;
#line 3331
  if (non_match) {
    {
#line 3332
    bitset_not((bitset_word_t *)sbcset);
    }
  }
#line 3336
  if (dfa___0->mb_cur_max > 1) {
    {
#line 3337
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t */* const  */)dfa___0->sb_char);
    }
  }
#line 3339
  if (mbcset->nmbchars) {
#line 3339
    goto _L___1;
  } else
#line 3339
  if (mbcset->ncoll_syms) {
#line 3339
    goto _L___1;
  } else
#line 3339
  if (mbcset->nequiv_classes) {
#line 3339
    goto _L___1;
  } else
#line 3339
  if (mbcset->nranges) {
#line 3339
    goto _L___1;
  } else
#line 3339
  if (dfa___0->mb_cur_max > 1) {
#line 3339
    if (mbcset->nchar_classes) {
#line 3339
      goto _L___1;
    } else
#line 3339
    if (mbcset->non_match) {
      _L___1: /* CIL Label */ 
      {
#line 3346
      dfa___0->has_mb_node = 1U;
#line 3347
      br_token.type = (re_token_type_t )6;
#line 3348
      br_token.opr.mbcset = mbcset;
#line 3349
      mbc_tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                   (re_token_t const   *)(& br_token));
#line 3350
      tmp___21 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                                  0L);
      }
#line 3350
      if (tmp___21) {
#line 3351
        goto parse_bracket_exp_espace;
      }
#line 3352
      sbc_idx = 0;
      {
#line 3352
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3352
        if (! ((unsigned long )sbc_idx < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 3352
          goto while_break___0;
        }
#line 3353
        if (*(sbcset + sbc_idx)) {
#line 3354
          goto while_break___0;
        }
#line 3352
        sbc_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3357
      if ((unsigned long )sbc_idx < 256UL / (sizeof(bitset_word_t ) * 8UL)) {
        {
#line 3360
        br_token.type = (re_token_type_t )3;
#line 3361
        br_token.opr.sbcset = sbcset;
#line 3362
        work_tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                      (re_token_t const   *)(& br_token));
#line 3363
        tmp___22 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3363
        if (tmp___22) {
#line 3364
          goto parse_bracket_exp_espace;
        }
        {
#line 3367
        work_tree = create_tree(dfa___0, work_tree, mbc_tree, (re_token_type_t )10);
#line 3368
        tmp___23 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3368
        if (tmp___23) {
#line 3369
          goto parse_bracket_exp_espace;
        }
      } else {
        {
#line 3373
        free((void *)sbcset);
#line 3374
        work_tree = mbc_tree;
        }
      }
    } else {
#line 3339
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 3381
    free_charset(mbcset);
#line 3384
    br_token.type = (re_token_type_t )3;
#line 3385
    br_token.opr.sbcset = sbcset;
#line 3386
    work_tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)(& br_token));
#line 3387
    tmp___24 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 3387
    if (tmp___24) {
#line 3388
      goto parse_bracket_exp_espace;
    }
  }
#line 3390
  return (work_tree);
  parse_bracket_exp_espace: 
#line 3393
  *err___0 = (reg_errcode_t )12;
  parse_bracket_exp_free_return: 
  {
#line 3395
  free((void *)sbcset);
#line 3397
  free_charset(mbcset);
  }
#line 3399
  return ((bin_tree_t *)((void *)0));
}
}
#line 3404 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp___0 ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa___0 ,
                                           reg_syntax_t syntax , int accept_hyphen ) 
{ 
  int cur_char_size ;
  int __attribute__((__pure__))  tmp___1 ;
  wint_t __attribute__((__pure__))  tmp___2 ;
  reg_errcode_t tmp___3 ;
  re_token_t token2 ;
  long tmp___4 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 3411
  tmp___1 = re_string_char_size_at((re_string_t const   *)regexp___0, regexp___0->cur_idx);
#line 3411
  cur_char_size = (int )tmp___1;
  }
#line 3412
  if (cur_char_size > 1) {
    {
#line 3414
    elem->type = (bracket_elem_type )1;
#line 3415
    tmp___2 = re_string_wchar_at((re_string_t const   *)regexp___0, regexp___0->cur_idx);
#line 3415
    elem->opr.wch = (wchar_t )tmp___2;
#line 3416
    regexp___0->cur_idx += cur_char_size;
    }
#line 3417
    return ((reg_errcode_t )0);
  }
#line 3420
  regexp___0->cur_idx += token_len;
#line 3421
  if ((unsigned int )token->type == 26U) {
    {
#line 3423
    tmp___3 = parse_bracket_symbol(elem, regexp___0, token);
    }
#line 3423
    return (tmp___3);
  } else
#line 3421
  if ((unsigned int )token->type == 30U) {
    {
#line 3423
    tmp___3 = parse_bracket_symbol(elem, regexp___0, token);
    }
#line 3423
    return (tmp___3);
  } else
#line 3421
  if ((unsigned int )token->type == 28U) {
    {
#line 3423
    tmp___3 = parse_bracket_symbol(elem, regexp___0, token);
    }
#line 3423
    return (tmp___3);
  }
  {
#line 3424
  tmp___4 = __builtin_expect((long )((unsigned int )token->type == 22U), 0L);
  }
#line 3424
  if (tmp___4) {
#line 3424
    if (! accept_hyphen) {
      {
#line 3429
      peek_token_bracket(& token2, regexp___0, syntax);
      }
#line 3430
      if ((unsigned int )token2.type != 21U) {
#line 3433
        return ((reg_errcode_t )11);
      }
    }
  }
#line 3435
  elem->type = (bracket_elem_type )0;
#line 3436
  elem->opr.ch = token->opr.c;
#line 3437
  return ((reg_errcode_t )0);
}
}
#line 3444 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp___0 ,
                                          re_token_t *token ) 
{ 
  unsigned char ch ;
  unsigned char delim ;
  int i___0 ;
  int tmp___1 ;

  {
#line 3448
  delim = token->opr.c;
#line 3449
  i___0 = 0;
#line 3450
  if (regexp___0->stop <= regexp___0->cur_idx) {
#line 3451
    return ((reg_errcode_t )7);
  }
  {
#line 3452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3454
    if (i___0 >= 32) {
#line 3455
      return ((reg_errcode_t )7);
    }
#line 3456
    if ((unsigned int )token->type == 30U) {
      {
#line 3457
      ch = re_string_fetch_byte_case(regexp___0);
      }
    } else {
#line 3459
      tmp___1 = regexp___0->cur_idx;
#line 3459
      (regexp___0->cur_idx) ++;
#line 3459
      ch = *(regexp___0->mbs + tmp___1);
    }
#line 3460
    if (regexp___0->stop <= regexp___0->cur_idx) {
#line 3461
      return ((reg_errcode_t )7);
    }
#line 3462
    if ((int )ch == (int )delim) {
#line 3462
      if ((int )*(regexp___0->mbs + regexp___0->cur_idx) == 93) {
#line 3463
        goto while_break;
      }
    }
#line 3464
    *(elem->opr.name + i___0) = ch;
#line 3452
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3466
  (regexp___0->cur_idx) ++;
#line 3467
  *(elem->opr.name + i___0) = (unsigned char )'\000';
  {
#line 3470
  if ((unsigned int )token->type == 26U) {
#line 3470
    goto case_26;
  }
#line 3473
  if ((unsigned int )token->type == 28U) {
#line 3473
    goto case_28;
  }
#line 3476
  if ((unsigned int )token->type == 30U) {
#line 3476
    goto case_30;
  }
#line 3479
  goto switch_default;
  case_26: /* CIL Label */ 
#line 3471
  elem->type = (bracket_elem_type )3;
#line 3472
  goto switch_break;
  case_28: /* CIL Label */ 
#line 3474
  elem->type = (bracket_elem_type )2;
#line 3475
  goto switch_break;
  case_30: /* CIL Label */ 
#line 3477
  elem->type = (bracket_elem_type )4;
#line 3478
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3480
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3482
  return ((reg_errcode_t )0);
}
}
#line 3491 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                       int *equiv_class_alloc , unsigned char const   *name ) 
{ 
  size_t tmp___1 ;
  long tmp___2 ;

  {
  {
#line 3574
  tmp___1 = strlen((char const   *)name);
#line 3574
  tmp___2 = __builtin_expect((long )(tmp___1 != 1UL), 0L);
  }
#line 3574
  if (tmp___2) {
#line 3575
    return ((reg_errcode_t )3);
  }
#line 3576
  *(sbcset + (unsigned long )*name / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*name % (sizeof(bitset_word_t ) * 8UL);
#line 3578
  return ((reg_errcode_t )0);
}
}
#line 3587 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , int *char_class_alloc ,
                                     char const   *class_name , reg_syntax_t syntax ) 
{ 
  int i___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int new_char_class_alloc ;
  wctype_t *new_char_classes ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  long tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  long tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  long tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  long tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  long tmp___21 ;
  unsigned short const   **tmp___22 ;
  unsigned short const   **tmp___23 ;
  long tmp___24 ;
  unsigned short const   **tmp___25 ;
  unsigned short const   **tmp___26 ;
  long tmp___27 ;
  unsigned short const   **tmp___28 ;
  unsigned short const   **tmp___29 ;
  long tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  long tmp___33 ;
  unsigned short const   **tmp___34 ;
  unsigned short const   **tmp___35 ;
  long tmp___36 ;
  unsigned short const   **tmp___37 ;
  unsigned short const   **tmp___38 ;
  long tmp___39 ;
  unsigned short const   **tmp___40 ;
  unsigned short const   **tmp___41 ;
  long tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;

  {
#line 3601
  if (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    {
#line 3601
    tmp___1 = strcmp(class_name, "upper");
    }
#line 3601
    if (tmp___1 == 0) {
#line 3603
      class_name = "alpha";
    } else {
      {
#line 3601
      tmp___2 = strcmp(class_name, "lower");
      }
#line 3601
      if (tmp___2 == 0) {
#line 3603
        class_name = "alpha";
      }
    }
  }
  {
#line 3607
  tmp___5 = __builtin_expect((long )(*char_class_alloc == mbcset->nchar_classes),
                             0L);
  }
#line 3607
  if (tmp___5) {
    {
#line 3611
    new_char_class_alloc = 2 * mbcset->nchar_classes + 1;
#line 3613
    tmp___3 = realloc((void *)mbcset->char_classes, (unsigned long )new_char_class_alloc * sizeof(wctype_t ));
#line 3613
    new_char_classes = (wctype_t *)tmp___3;
#line 3615
    tmp___4 = __builtin_expect((long )((unsigned long )new_char_classes == (unsigned long )((void *)0)),
                               0L);
    }
#line 3615
    if (tmp___4) {
#line 3616
      return ((reg_errcode_t )12);
    }
#line 3617
    mbcset->char_classes = new_char_classes;
#line 3618
    *char_class_alloc = new_char_class_alloc;
  }
  {
#line 3620
  tmp___6 = mbcset->nchar_classes;
#line 3620
  (mbcset->nchar_classes) ++;
#line 3620
  *(mbcset->char_classes + tmp___6) = wctype(class_name);
#line 3639
  tmp___54 = strcmp(class_name, "alnum");
  }
#line 3639
  if (tmp___54 == 0) {
    {
#line 3640
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3640
      tmp___9 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                 0L);
      }
#line 3640
      if (tmp___9) {
#line 3640
        i___0 = 0;
        {
#line 3640
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3640
          if (! (i___0 < 256)) {
#line 3640
            goto while_break___0;
          }
          {
#line 3640
          tmp___7 = __ctype_b_loc();
          }
#line 3640
          if ((int const   )*(*tmp___7 + i___0) & 8) {
#line 3640
            *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
          }
#line 3640
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 3640
        i___0 = 0;
        {
#line 3640
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3640
          if (! (i___0 < 256)) {
#line 3640
            goto while_break___1;
          }
          {
#line 3640
          tmp___8 = __ctype_b_loc();
          }
#line 3640
          if ((int const   )*(*tmp___8 + i___0) & 8) {
#line 3640
            *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
          }
#line 3640
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 3640
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 3641
    tmp___53 = strcmp(class_name, "cntrl");
    }
#line 3641
    if (tmp___53 == 0) {
      {
#line 3642
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 3642
        tmp___12 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                    0L);
        }
#line 3642
        if (tmp___12) {
#line 3642
          i___0 = 0;
          {
#line 3642
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3642
            if (! (i___0 < 256)) {
#line 3642
              goto while_break___3;
            }
            {
#line 3642
            tmp___10 = __ctype_b_loc();
            }
#line 3642
            if ((int const   )*(*tmp___10 + i___0) & 2) {
#line 3642
              *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
            }
#line 3642
            i___0 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
#line 3642
          i___0 = 0;
          {
#line 3642
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3642
            if (! (i___0 < 256)) {
#line 3642
              goto while_break___4;
            }
            {
#line 3642
            tmp___11 = __ctype_b_loc();
            }
#line 3642
            if ((int const   )*(*tmp___11 + i___0) & 2) {
#line 3642
              *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
            }
#line 3642
            i___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 3642
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 3643
      tmp___52 = strcmp(class_name, "lower");
      }
#line 3643
      if (tmp___52 == 0) {
        {
#line 3644
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 3644
          tmp___15 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                      0L);
          }
#line 3644
          if (tmp___15) {
#line 3644
            i___0 = 0;
            {
#line 3644
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 3644
              if (! (i___0 < 256)) {
#line 3644
                goto while_break___6;
              }
              {
#line 3644
              tmp___13 = __ctype_b_loc();
              }
#line 3644
              if ((int const   )*(*tmp___13 + i___0) & 512) {
#line 3644
                *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
              }
#line 3644
              i___0 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
          } else {
#line 3644
            i___0 = 0;
            {
#line 3644
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 3644
              if (! (i___0 < 256)) {
#line 3644
                goto while_break___7;
              }
              {
#line 3644
              tmp___14 = __ctype_b_loc();
              }
#line 3644
              if ((int const   )*(*tmp___14 + i___0) & 512) {
#line 3644
                *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
              }
#line 3644
              i___0 ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 3644
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 3645
        tmp___51 = strcmp(class_name, "space");
        }
#line 3645
        if (tmp___51 == 0) {
          {
#line 3646
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 3646
            tmp___18 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                        0L);
            }
#line 3646
            if (tmp___18) {
#line 3646
              i___0 = 0;
              {
#line 3646
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 3646
                if (! (i___0 < 256)) {
#line 3646
                  goto while_break___9;
                }
                {
#line 3646
                tmp___16 = __ctype_b_loc();
                }
#line 3646
                if ((int const   )*(*tmp___16 + i___0) & 8192) {
#line 3646
                  *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
                }
#line 3646
                i___0 ++;
              }
              while_break___9: /* CIL Label */ ;
              }
            } else {
#line 3646
              i___0 = 0;
              {
#line 3646
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 3646
                if (! (i___0 < 256)) {
#line 3646
                  goto while_break___10;
                }
                {
#line 3646
                tmp___17 = __ctype_b_loc();
                }
#line 3646
                if ((int const   )*(*tmp___17 + i___0) & 8192) {
#line 3646
                  *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
                }
#line 3646
                i___0 ++;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
#line 3646
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        } else {
          {
#line 3647
          tmp___50 = strcmp(class_name, "alpha");
          }
#line 3647
          if (tmp___50 == 0) {
            {
#line 3648
            while (1) {
              while_continue___11: /* CIL Label */ ;
              {
#line 3648
              tmp___21 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                          0L);
              }
#line 3648
              if (tmp___21) {
#line 3648
                i___0 = 0;
                {
#line 3648
                while (1) {
                  while_continue___12: /* CIL Label */ ;
#line 3648
                  if (! (i___0 < 256)) {
#line 3648
                    goto while_break___12;
                  }
                  {
#line 3648
                  tmp___19 = __ctype_b_loc();
                  }
#line 3648
                  if ((int const   )*(*tmp___19 + i___0) & 1024) {
#line 3648
                    *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
                  }
#line 3648
                  i___0 ++;
                }
                while_break___12: /* CIL Label */ ;
                }
              } else {
#line 3648
                i___0 = 0;
                {
#line 3648
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 3648
                  if (! (i___0 < 256)) {
#line 3648
                    goto while_break___13;
                  }
                  {
#line 3648
                  tmp___20 = __ctype_b_loc();
                  }
#line 3648
                  if ((int const   )*(*tmp___20 + i___0) & 1024) {
#line 3648
                    *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
                  }
#line 3648
                  i___0 ++;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
#line 3648
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          } else {
            {
#line 3649
            tmp___49 = strcmp(class_name, "digit");
            }
#line 3649
            if (tmp___49 == 0) {
              {
#line 3650
              while (1) {
                while_continue___14: /* CIL Label */ ;
                {
#line 3650
                tmp___24 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                            0L);
                }
#line 3650
                if (tmp___24) {
#line 3650
                  i___0 = 0;
                  {
#line 3650
                  while (1) {
                    while_continue___15: /* CIL Label */ ;
#line 3650
                    if (! (i___0 < 256)) {
#line 3650
                      goto while_break___15;
                    }
                    {
#line 3650
                    tmp___22 = __ctype_b_loc();
                    }
#line 3650
                    if ((int const   )*(*tmp___22 + i___0) & 2048) {
#line 3650
                      *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
                    }
#line 3650
                    i___0 ++;
                  }
                  while_break___15: /* CIL Label */ ;
                  }
                } else {
#line 3650
                  i___0 = 0;
                  {
#line 3650
                  while (1) {
                    while_continue___16: /* CIL Label */ ;
#line 3650
                    if (! (i___0 < 256)) {
#line 3650
                      goto while_break___16;
                    }
                    {
#line 3650
                    tmp___23 = __ctype_b_loc();
                    }
#line 3650
                    if ((int const   )*(*tmp___23 + i___0) & 2048) {
#line 3650
                      *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
                    }
#line 3650
                    i___0 ++;
                  }
                  while_break___16: /* CIL Label */ ;
                  }
                }
#line 3650
                goto while_break___14;
              }
              while_break___14: /* CIL Label */ ;
              }
            } else {
              {
#line 3651
              tmp___48 = strcmp(class_name, "print");
              }
#line 3651
              if (tmp___48 == 0) {
                {
#line 3652
                while (1) {
                  while_continue___17: /* CIL Label */ ;
                  {
#line 3652
                  tmp___27 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                              0L);
                  }
#line 3652
                  if (tmp___27) {
#line 3652
                    i___0 = 0;
                    {
#line 3652
                    while (1) {
                      while_continue___18: /* CIL Label */ ;
#line 3652
                      if (! (i___0 < 256)) {
#line 3652
                        goto while_break___18;
                      }
                      {
#line 3652
                      tmp___25 = __ctype_b_loc();
                      }
#line 3652
                      if ((int const   )*(*tmp___25 + i___0) & 16384) {
#line 3652
                        *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
                      }
#line 3652
                      i___0 ++;
                    }
                    while_break___18: /* CIL Label */ ;
                    }
                  } else {
#line 3652
                    i___0 = 0;
                    {
#line 3652
                    while (1) {
                      while_continue___19: /* CIL Label */ ;
#line 3652
                      if (! (i___0 < 256)) {
#line 3652
                        goto while_break___19;
                      }
                      {
#line 3652
                      tmp___26 = __ctype_b_loc();
                      }
#line 3652
                      if ((int const   )*(*tmp___26 + i___0) & 16384) {
#line 3652
                        *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
                      }
#line 3652
                      i___0 ++;
                    }
                    while_break___19: /* CIL Label */ ;
                    }
                  }
#line 3652
                  goto while_break___17;
                }
                while_break___17: /* CIL Label */ ;
                }
              } else {
                {
#line 3653
                tmp___47 = strcmp(class_name, "upper");
                }
#line 3653
                if (tmp___47 == 0) {
                  {
#line 3654
                  while (1) {
                    while_continue___20: /* CIL Label */ ;
                    {
#line 3654
                    tmp___30 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                0L);
                    }
#line 3654
                    if (tmp___30) {
#line 3654
                      i___0 = 0;
                      {
#line 3654
                      while (1) {
                        while_continue___21: /* CIL Label */ ;
#line 3654
                        if (! (i___0 < 256)) {
#line 3654
                          goto while_break___21;
                        }
                        {
#line 3654
                        tmp___28 = __ctype_b_loc();
                        }
#line 3654
                        if ((int const   )*(*tmp___28 + i___0) & 256) {
#line 3654
                          *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
                        }
#line 3654
                        i___0 ++;
                      }
                      while_break___21: /* CIL Label */ ;
                      }
                    } else {
#line 3654
                      i___0 = 0;
                      {
#line 3654
                      while (1) {
                        while_continue___22: /* CIL Label */ ;
#line 3654
                        if (! (i___0 < 256)) {
#line 3654
                          goto while_break___22;
                        }
                        {
#line 3654
                        tmp___29 = __ctype_b_loc();
                        }
#line 3654
                        if ((int const   )*(*tmp___29 + i___0) & 256) {
#line 3654
                          *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
                        }
#line 3654
                        i___0 ++;
                      }
                      while_break___22: /* CIL Label */ ;
                      }
                    }
#line 3654
                    goto while_break___20;
                  }
                  while_break___20: /* CIL Label */ ;
                  }
                } else {
                  {
#line 3655
                  tmp___46 = strcmp(class_name, "blank");
                  }
#line 3655
                  if (tmp___46 == 0) {
                    {
#line 3660
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
                      {
#line 3660
                      tmp___33 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                  0L);
                      }
#line 3660
                      if (tmp___33) {
#line 3660
                        i___0 = 0;
                        {
#line 3660
                        while (1) {
                          while_continue___24: /* CIL Label */ ;
#line 3660
                          if (! (i___0 < 256)) {
#line 3660
                            goto while_break___24;
                          }
                          {
#line 3660
                          tmp___31 = is_blank(i___0);
                          }
#line 3660
                          if (tmp___31) {
#line 3660
                            *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
                          }
#line 3660
                          i___0 ++;
                        }
                        while_break___24: /* CIL Label */ ;
                        }
                      } else {
#line 3660
                        i___0 = 0;
                        {
#line 3660
                        while (1) {
                          while_continue___25: /* CIL Label */ ;
#line 3660
                          if (! (i___0 < 256)) {
#line 3660
                            goto while_break___25;
                          }
                          {
#line 3660
                          tmp___32 = is_blank(i___0);
                          }
#line 3660
                          if (tmp___32) {
#line 3660
                            *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
                          }
#line 3660
                          i___0 ++;
                        }
                        while_break___25: /* CIL Label */ ;
                        }
                      }
#line 3660
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                  } else {
                    {
#line 3662
                    tmp___45 = strcmp(class_name, "graph");
                    }
#line 3662
                    if (tmp___45 == 0) {
                      {
#line 3663
                      while (1) {
                        while_continue___26: /* CIL Label */ ;
                        {
#line 3663
                        tmp___36 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                    0L);
                        }
#line 3663
                        if (tmp___36) {
#line 3663
                          i___0 = 0;
                          {
#line 3663
                          while (1) {
                            while_continue___27: /* CIL Label */ ;
#line 3663
                            if (! (i___0 < 256)) {
#line 3663
                              goto while_break___27;
                            }
                            {
#line 3663
                            tmp___34 = __ctype_b_loc();
                            }
#line 3663
                            if ((int const   )*(*tmp___34 + i___0) & 32768) {
#line 3663
                              *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
                            }
#line 3663
                            i___0 ++;
                          }
                          while_break___27: /* CIL Label */ ;
                          }
                        } else {
#line 3663
                          i___0 = 0;
                          {
#line 3663
                          while (1) {
                            while_continue___28: /* CIL Label */ ;
#line 3663
                            if (! (i___0 < 256)) {
#line 3663
                              goto while_break___28;
                            }
                            {
#line 3663
                            tmp___35 = __ctype_b_loc();
                            }
#line 3663
                            if ((int const   )*(*tmp___35 + i___0) & 32768) {
#line 3663
                              *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
                            }
#line 3663
                            i___0 ++;
                          }
                          while_break___28: /* CIL Label */ ;
                          }
                        }
#line 3663
                        goto while_break___26;
                      }
                      while_break___26: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 3664
                      tmp___44 = strcmp(class_name, "punct");
                      }
#line 3664
                      if (tmp___44 == 0) {
                        {
#line 3665
                        while (1) {
                          while_continue___29: /* CIL Label */ ;
                          {
#line 3665
                          tmp___39 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                      0L);
                          }
#line 3665
                          if (tmp___39) {
#line 3665
                            i___0 = 0;
                            {
#line 3665
                            while (1) {
                              while_continue___30: /* CIL Label */ ;
#line 3665
                              if (! (i___0 < 256)) {
#line 3665
                                goto while_break___30;
                              }
                              {
#line 3665
                              tmp___37 = __ctype_b_loc();
                              }
#line 3665
                              if ((int const   )*(*tmp___37 + i___0) & 4) {
#line 3665
                                *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
                              }
#line 3665
                              i___0 ++;
                            }
                            while_break___30: /* CIL Label */ ;
                            }
                          } else {
#line 3665
                            i___0 = 0;
                            {
#line 3665
                            while (1) {
                              while_continue___31: /* CIL Label */ ;
#line 3665
                              if (! (i___0 < 256)) {
#line 3665
                                goto while_break___31;
                              }
                              {
#line 3665
                              tmp___38 = __ctype_b_loc();
                              }
#line 3665
                              if ((int const   )*(*tmp___38 + i___0) & 4) {
#line 3665
                                *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
                              }
#line 3665
                              i___0 ++;
                            }
                            while_break___31: /* CIL Label */ ;
                            }
                          }
#line 3665
                          goto while_break___29;
                        }
                        while_break___29: /* CIL Label */ ;
                        }
                      } else {
                        {
#line 3666
                        tmp___43 = strcmp(class_name, "xdigit");
                        }
#line 3666
                        if (tmp___43 == 0) {
                          {
#line 3667
                          while (1) {
                            while_continue___32: /* CIL Label */ ;
                            {
#line 3667
                            tmp___42 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                        0L);
                            }
#line 3667
                            if (tmp___42) {
#line 3667
                              i___0 = 0;
                              {
#line 3667
                              while (1) {
                                while_continue___33: /* CIL Label */ ;
#line 3667
                                if (! (i___0 < 256)) {
#line 3667
                                  goto while_break___33;
                                }
                                {
#line 3667
                                tmp___40 = __ctype_b_loc();
                                }
#line 3667
                                if ((int const   )*(*tmp___40 + i___0) & 4096) {
#line 3667
                                  *(sbcset + (unsigned long )*(trans + i___0) / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*(trans + i___0) % (sizeof(bitset_word_t ) * 8UL);
                                }
#line 3667
                                i___0 ++;
                              }
                              while_break___33: /* CIL Label */ ;
                              }
                            } else {
#line 3667
                              i___0 = 0;
                              {
#line 3667
                              while (1) {
                                while_continue___34: /* CIL Label */ ;
#line 3667
                                if (! (i___0 < 256)) {
#line 3667
                                  goto while_break___34;
                                }
                                {
#line 3667
                                tmp___41 = __ctype_b_loc();
                                }
#line 3667
                                if ((int const   )*(*tmp___41 + i___0) & 4096) {
#line 3667
                                  *(sbcset + (unsigned long )i___0 / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )i___0 % (sizeof(bitset_word_t ) * 8UL);
                                }
#line 3667
                                i___0 ++;
                              }
                              while_break___34: /* CIL Label */ ;
                              }
                            }
#line 3667
                            goto while_break___32;
                          }
                          while_break___32: /* CIL Label */ ;
                          }
                        } else {
#line 3669
                          return ((reg_errcode_t )4);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3671
  return ((reg_errcode_t )0);
}
}
#line 3674 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *build_charclass_op(re_dfa_t *dfa___0 , unsigned char *trans , char const   *class_name ,
                                      char const   *extra , int non_match , reg_errcode_t *err___0 ) 
{ 
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  int alloc ;
  reg_errcode_t ret ;
  re_token_t br_token ;
  bin_tree_t *tree ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  bin_tree_t *mbc_tree ;
  long tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
  {
#line 3683
  alloc = 0;
#line 3689
  tmp___1 = calloc(sizeof(bitset_t ), (size_t )1);
#line 3689
  sbcset = (re_bitset_ptr_t )tmp___1;
#line 3691
  tmp___2 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3691
  mbcset = (re_charset_t *)tmp___2;
  }
#line 3695
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3695
    tmp___3 = 1;
  } else
#line 3695
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3695
    tmp___3 = 1;
  } else {
#line 3695
    tmp___3 = 0;
  }
  {
#line 3695
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 3695
  if (tmp___4) {
#line 3700
    *err___0 = (reg_errcode_t )12;
#line 3701
    return ((bin_tree_t *)((void *)0));
  }
#line 3704
  if (non_match) {
#line 3707
    mbcset->non_match = 1U;
  }
  {
#line 3712
  ret = build_charclass(trans, (bitset_word_t *)sbcset, mbcset, & alloc, class_name,
                        (reg_syntax_t )0);
#line 3718
  tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 3718
  if (tmp___5) {
    {
#line 3720
    free((void *)sbcset);
#line 3722
    free_charset(mbcset);
#line 3724
    *err___0 = ret;
    }
#line 3725
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3728
    if (! *extra) {
#line 3728
      goto while_break;
    }
#line 3729
    *(sbcset + (unsigned long )*extra / (sizeof(bitset_word_t ) * 8UL)) |= 1UL << (unsigned long )*extra % (sizeof(bitset_word_t ) * 8UL);
#line 3728
    extra ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3732
  if (non_match) {
    {
#line 3733
    bitset_not((bitset_word_t *)sbcset);
    }
  }
#line 3737
  if (dfa___0->mb_cur_max > 1) {
    {
#line 3738
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t */* const  */)dfa___0->sb_char);
    }
  }
  {
#line 3742
  br_token.type = (re_token_type_t )3;
#line 3743
  br_token.opr.sbcset = sbcset;
#line 3744
  tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)(& br_token));
#line 3745
  tmp___6 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 3745
  if (tmp___6) {
#line 3746
    goto build_word_op_espace;
  }
#line 3749
  if (dfa___0->mb_cur_max > 1) {
    {
#line 3753
    br_token.type = (re_token_type_t )6;
#line 3754
    br_token.opr.mbcset = mbcset;
#line 3755
    dfa___0->has_mb_node = 1U;
#line 3756
    mbc_tree = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                 (re_token_t const   *)(& br_token));
#line 3757
    tmp___7 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                               0L);
    }
#line 3757
    if (tmp___7) {
#line 3758
      goto build_word_op_espace;
    }
    {
#line 3760
    tree = create_tree(dfa___0, tree, mbc_tree, (re_token_type_t )10);
#line 3761
    tmp___8 = __builtin_expect((long )((unsigned long )mbc_tree != (unsigned long )((void *)0)),
                               1L);
    }
#line 3761
    if (tmp___8) {
#line 3762
      return (tree);
    }
  } else {
    {
#line 3766
    free_charset(mbcset);
    }
#line 3767
    return (tree);
  }
  build_word_op_espace: 
  {
#line 3774
  free((void *)sbcset);
#line 3776
  free_charset(mbcset);
#line 3778
  *err___0 = (reg_errcode_t )12;
  }
#line 3779
  return ((bin_tree_t *)((void *)0));
}
}
#line 3787 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static int fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) 
{ 
  int num ;
  unsigned char c ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 3790
  num = -1;
  {
#line 3792
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3794
    fetch_token(token, input, syntax);
#line 3795
    c = token->opr.c;
#line 3796
    tmp___1 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3796
    if (tmp___1) {
#line 3797
      return (-2);
    }
#line 3798
    if ((unsigned int )token->type == 24U) {
#line 3799
      goto while_break;
    } else
#line 3798
    if ((int )c == 44) {
#line 3799
      goto while_break;
    }
#line 3800
    if ((unsigned int )token->type != 1U) {
#line 3800
      num = -2;
    } else
#line 3800
    if ((int )c < 48) {
#line 3800
      num = -2;
    } else
#line 3800
    if (57 < (int )c) {
#line 3800
      num = -2;
    } else
#line 3800
    if (num == -2) {
#line 3800
      num = -2;
    } else {
#line 3800
      if (num == -1) {
#line 3800
        tmp___2 = (int )c - 48;
      } else {
#line 3800
        tmp___2 = (num * 10 + (int )c) - 48;
      }
#line 3800
      num = tmp___2;
    }
#line 3802
    if (num > 32767) {
#line 3802
      num = -2;
    } else {
#line 3802
      num = num;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3804
  return (num);
}
}
#line 3808 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static void free_charset(re_charset_t *cset ) 
{ 


  {
  {
#line 3811
  free((void *)cset->mbchars);
#line 3818
  free((void *)cset->char_classes);
#line 3819
  free((void *)cset);
  }
#line 3820
  return;
}
}
#line 3827 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *create_tree(re_dfa_t *dfa___0 , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) 
{ 
  re_token_t t ;
  bin_tree_t *tmp___1 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 3832
  t.type = type;
#line 3833
  tmp___1 = create_token_tree(dfa___0, left, right, (re_token_t const   *)(& t));
  }
#line 3833
  return (tmp___1);
}
}
#line 3836 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *create_token_tree(re_dfa_t *dfa___0 , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) 
{ 
  bin_tree_t *tree ;
  bin_tree_storage_t *storage ;
  void *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp10 ;

  {
  {
#line 3841
  tmp___2 = __builtin_expect((long )((unsigned long )dfa___0->str_tree_storage_idx == (1024UL - sizeof(void *)) / sizeof(bin_tree_t )),
                             0L);
  }
#line 3841
  if (tmp___2) {
    {
#line 3843
    tmp___1 = malloc(sizeof(bin_tree_storage_t ));
#line 3843
    storage = (bin_tree_storage_t *)tmp___1;
    }
#line 3845
    if ((unsigned long )storage == (unsigned long )((void *)0)) {
#line 3846
      return ((bin_tree_t *)((void *)0));
    }
#line 3847
    storage->next = dfa___0->str_tree_storage;
#line 3848
    dfa___0->str_tree_storage = storage;
#line 3849
    dfa___0->str_tree_storage_idx = 0;
  }
#line 3851
  tmp___3 = dfa___0->str_tree_storage_idx;
#line 3851
  (dfa___0->str_tree_storage_idx) ++;
#line 3851
  tree = & (dfa___0->str_tree_storage)->data[tmp___3];
#line 3853
  tree->parent = (struct bin_tree_t *)((void *)0);
#line 3854
  tree->left = left;
#line 3855
  tree->right = right;
#line 3856
  tree->token = (re_token_t )*token;
#line 3857
  tree->token.duplicated = 0U;
#line 3858
  tree->token.opt_subexp = 0U;
#line 3859
  tree->first = (struct bin_tree_t *)((void *)0);
#line 3860
  tree->next = (struct bin_tree_t *)((void *)0);
#line 3861
  tree->node_idx = -1;
#line 3863
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 3864
    left->parent = tree;
  }
#line 3865
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 3866
    right->parent = tree;
  }
#line 3867
  return (tree);
}
}
#line 3873 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) 
{ 
  int idx___3 ;

  {
#line 3876
  idx___3 = (int )((long )extra);
#line 3877
  if ((unsigned int )node->token.type == 17U) {
#line 3877
    if (node->token.opr.idx == idx___3) {
#line 3878
      node->token.opt_subexp = 1U;
    }
  }
#line 3880
  return ((reg_errcode_t )0);
}
}
#line 3885 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static void free_token(re_token_t *node ) 
{ 


  {
#line 3889
  if ((unsigned int )node->type == 6U) {
#line 3889
    if (node->duplicated == 0U) {
      {
#line 3890
      free_charset(node->opr.mbcset);
      }
    } else {
#line 3889
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3893
  if ((unsigned int )node->type == 3U) {
#line 3893
    if (node->duplicated == 0U) {
      {
#line 3894
      free((void *)node->opr.sbcset);
      }
    }
  }
#line 3895
  return;
}
}
#line 3900 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) 
{ 


  {
  {
#line 3903
  free_token(& node->token);
  }
#line 3904
  return ((reg_errcode_t )0);
}
}
#line 3913 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regcomp.c"
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa___0 ) 
{ 
  bin_tree_t const   *node ;
  bin_tree_t *dup_root ;
  bin_tree_t **p_new ;
  bin_tree_t *dup_node ;
  bin_tree_t const   *prev ;

  {
#line 3918
  p_new = & dup_root;
#line 3918
  dup_node = (bin_tree_t *)root->parent;
#line 3920
  node = root;
  {
#line 3920
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3923
    *p_new = create_token_tree(dfa___0, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               & node->token);
    }
#line 3924
    if ((unsigned long )*p_new == (unsigned long )((void *)0)) {
#line 3925
      return ((bin_tree_t *)((void *)0));
    }
#line 3926
    (*p_new)->parent = dup_node;
#line 3927
    (*p_new)->token.duplicated = 1U;
#line 3928
    dup_node = *p_new;
#line 3931
    if (node->left) {
#line 3933
      node = (bin_tree_t const   *)node->left;
#line 3934
      p_new = & dup_node->left;
    } else {
#line 3938
      prev = (bin_tree_t const   *)((void *)0);
      {
#line 3939
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3939
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 3939
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 3939
            goto while_break___0;
          }
        }
#line 3941
        prev = node;
#line 3942
        node = (bin_tree_t const   *)node->parent;
#line 3943
        dup_node = dup_node->parent;
#line 3944
        if (! node) {
#line 3945
          return (dup_root);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3947
      node = (bin_tree_t const   *)node->right;
#line 3948
      p_new = & dup_node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 20 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , int n ) ;
#line 22
static void match_ctx_clean(re_match_context_t *mctx ) ;
#line 23
static void match_ctx_free(re_match_context_t *mctx ) ;
#line 24
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , int node , int str_idx ,
                                         int from , int to ) ;
#line 27
static int search_cur_bkref_entry(re_match_context_t const   *mctx , int str_idx ) ;
#line 29
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , int node , int str_idx ) ;
#line 31
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , int node ,
                                                  int str_idx ) ;
#line 34
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          int last_node , int last_str_idx ) ;
#line 38
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        int length , int start , int range , int stop___0 ,
                                        size_t nmatch , regmatch_t *pmatch , int eflags ) ;
#line 43
static int re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int length1 , char const   *string2 , int length2 , int start ,
                            int range , struct re_registers *regs , int stop___0 ,
                            int ret_len ) ;
#line 48
static int re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                          int length , int start , int range , int stop___0 , struct re_registers *regs ,
                          int ret_len ) ;
#line 52
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 int nregs , int regs_allocated ) ;
#line 54
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) ;
#line 56
static int check_matching(re_match_context_t *mctx , int fl_longest_match , int *p_match_first ) ;
#line 58
static int check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state___2 ,
                                    int idx___3 ) ;
#line 61
static void update_regs(re_dfa_t const   *dfa___0 , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        int cur_node , int cur_idx , int nmatch ) ;
#line 64
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , int str_idx , int dest_node ,
                                     int nregs , regmatch_t *regs , re_node_set *eps_via_nodes ) ;
#line 69
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , int fl_backtrack ) ;
#line 73
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) ;
#line 77
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               int node_idx , int str_idx , int max_str_idx ) ;
#line 82
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) ;
#line 85
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         int str_idx , re_node_set *cur_dest ) ;
#line 89
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             int str_idx , re_node_set *dest_nodes ) ;
#line 94
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa___0 , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) ;
#line 98
static int check_dst_limits(re_match_context_t const   *mctx , re_node_set *limits ,
                            int dst_node , int dst_idx , int src_node , int src_idx ) ;
#line 102
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       int subexp_idx , int from_node , int bkref_idx ) ;
#line 106
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , int limit ,
                                     int subexp_idx , int from_node , int str_idx ,
                                     int bkref_idx ) ;
#line 110
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa___0 , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         int str_idx ) ;
#line 116
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       int str_idx , re_node_set const   *candidates ) ;
#line 120
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa___0 , re_dfastate_t **dst ,
                                       re_dfastate_t **src , int num ) ;
#line 124
static re_dfastate_t *find_recover_state(reg_errcode_t *err___0 , re_match_context_t *mctx ) ;
#line 126
static re_dfastate_t *transit_state(reg_errcode_t *err___0 , re_match_context_t *mctx ,
                                    re_dfastate_t *state___2 ) ;
#line 129
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err___0 , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) ;
#line 133
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               int str_idx ) ;
#line 143
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) ;
#line 147
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) ;
#line 150
static reg_errcode_t get_subexp(re_match_context_t *mctx , int bkref_node , int bkref_str_idx ) ;
#line 153
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , int bkref_node ,
                                    int bkref_str ) ;
#line 158
static int find_subexp_node(re_dfa_t const   *dfa___0 , re_node_set const   *nodes ,
                            int subexp_idx , int type ) ;
#line 160
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   int top_node , int top_str , int last_node , int last_str ,
                                   int type ) ;
#line 164
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , int str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) ;
#line 169
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa___0 , re_node_set *cur_nodes ,
                                              int ex_subexp , int type ) ;
#line 173
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa___0 , re_node_set *dst_nodes ,
                                                  int target , int ex_subexp , int type ) ;
#line 177
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        int cur_str , int subexp_num , int type ) ;
#line 181
static int build_trtable(re_dfa_t const   *dfa___0 , re_dfastate_t *state___2 ) ;
#line 184
static int check_node_accept_bytes(re_dfa_t const   *dfa___0 , int node_idx , re_string_t const   *input ,
                                   int str_idx ) ;
#line 193
static int group_nodes_into_DFAstates(re_dfa_t const   *dfa___0 , re_dfastate_t const   *state___2 ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) ;
#line 197
static int check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                             int idx___3 ) ;
#line 200
static reg_errcode_t extend_buffers(re_match_context_t *mctx , int min_len ) ;
#line 205 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int MIN(size_t a , size_t b___0 ) 
{ 
  size_t tmp___1 ;

  {
#line 208
  if (a < b___0) {
#line 208
    tmp___1 = a;
  } else {
#line 208
    tmp___1 = b___0;
  }
#line 208
  return ((int )tmp___1);
}
}
#line 228 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
int regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
            size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) 
{ 
  reg_errcode_t err___0 ;
  int start ;
  int length ;
  size_t tmp___1 ;

  {
#line 239
  if (eflags & ~ ((1 | (1 << 1)) | (1 << 2))) {
#line 240
    return (2);
  }
#line 242
  if (eflags & (1 << 2)) {
#line 244
    start = (pmatch + 0)->rm_so;
#line 245
    length = (pmatch + 0)->rm_eo;
  } else {
    {
#line 249
    start = 0;
#line 250
    tmp___1 = strlen((char const   *)string);
#line 250
    length = (int )tmp___1;
    }
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  if (preg->no_sub) {
    {
#line 255
    err___0 = re_search_internal((regex_t const   *)preg, (char const   *)string,
                                 length, start, length - start, length, (size_t )0,
                                 (regmatch_t *)((void *)0), eflags);
    }
  } else {
    {
#line 258
    err___0 = re_search_internal((regex_t const   *)preg, (char const   *)string,
                                 length, start, length - start, length, nmatch, (regmatch_t *)pmatch,
                                 eflags);
    }
  }
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 261
  return ((int )err___0 != 0);
}
}
#line 313 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
int re_match(struct re_pattern_buffer *bufp , char const   *string , int length ,
             int start , struct re_registers *regs ) 
{ 
  int tmp___1 ;

  {
  {
#line 320
  tmp___1 = re_search_stub(bufp, string, length, start, 0, length, regs, 1);
  }
#line 320
  return (tmp___1);
}
}
#line 326 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
int re_search(struct re_pattern_buffer *bufp , char const   *string , int length ,
              int start , int range , struct re_registers *regs ) 
{ 
  int tmp___1 ;

  {
  {
#line 333
  tmp___1 = re_search_stub(bufp, string, length, start, range, length, regs, 0);
  }
#line 333
  return (tmp___1);
}
}
#line 339 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
               char const   *string2 , int length2 , int start , struct re_registers *regs ,
               int stop___0 ) 
{ 
  int tmp___1 ;

  {
  {
#line 346
  tmp___1 = re_search_2_stub(bufp, string1, length1, string2, length2, start, 0, regs,
                             stop___0, 1);
  }
#line 346
  return (tmp___1);
}
}
#line 353 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int length1 ,
                char const   *string2 , int length2 , int start , int range , struct re_registers *regs ,
                int stop___0 ) 
{ 
  int tmp___1 ;

  {
  {
#line 360
  tmp___1 = re_search_2_stub(bufp, string1, length1, string2, length2, start, range,
                             regs, stop___0, 0);
  }
#line 360
  return (tmp___1);
}
}
#line 367 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int length1 , char const   *string2 , int length2 , int start ,
                            int range , struct re_registers *regs , int stop___0 ,
                            int ret_len ) 
{ 
  char const   *str ;
  int rval ;
  int len ;
  char *s___0 ;
  int tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;

  {
#line 377
  len = length1 + length2;
#line 378
  s___0 = (char *)((void *)0);
#line 380
  if (length1 < 0) {
#line 380
    tmp___1 = 1;
  } else
#line 380
  if (length2 < 0) {
#line 380
    tmp___1 = 1;
  } else
#line 380
  if (stop___0 < 0) {
#line 380
    tmp___1 = 1;
  } else
#line 380
  if (len < length1) {
#line 380
    tmp___1 = 1;
  } else {
#line 380
    tmp___1 = 0;
  }
  {
#line 380
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 380
  if (tmp___2) {
#line 381
    return (-2);
  }
#line 384
  if (length2 > 0) {
#line 385
    if (length1 > 0) {
      {
#line 387
      tmp___3 = malloc((unsigned long )len * sizeof(char ));
#line 387
      s___0 = (char *)tmp___3;
#line 389
      tmp___4 = __builtin_expect((long )((unsigned long )s___0 == (unsigned long )((void *)0)),
                                 0L);
      }
#line 389
      if (tmp___4) {
#line 390
        return (-2);
      }
      {
#line 394
      memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)string1,
             (size_t )length1);
#line 395
      memcpy((void */* __restrict  */)(s___0 + length1), (void const   */* __restrict  */)string2,
             (size_t )length2);
#line 397
      str = (char const   *)s___0;
      }
    } else {
#line 400
      str = string2;
    }
  } else {
#line 402
    str = string1;
  }
  {
#line 404
  rval = re_search_stub(bufp, str, len, start, range, stop___0, regs, ret_len);
#line 405
  free((void *)s___0);
  }
#line 406
  return (rval);
}
}
#line 414 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                          int length , int start , int range , int stop___0 , struct re_registers *regs ,
                          int ret_len ) 
{ 
  reg_errcode_t result ;
  regmatch_t *pmatch ;
  int nregs ;
  int rval ;
  int eflags ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;

  {
#line 424
  eflags = 0;
#line 427
  if (start < 0) {
#line 427
    tmp___1 = 1;
  } else
#line 427
  if (start > length) {
#line 427
    tmp___1 = 1;
  } else {
#line 427
    tmp___1 = 0;
  }
  {
#line 427
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 427
  if (tmp___2) {
#line 428
    return (-1);
  }
  {
#line 429
  tmp___4 = __builtin_expect((long )(start + range > length), 0L);
  }
#line 429
  if (tmp___4) {
#line 430
    range = length - start;
  } else {
    {
#line 431
    tmp___3 = __builtin_expect((long )(start + range < 0), 0L);
    }
#line 431
    if (tmp___3) {
#line 432
      range = - start;
    }
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  if (bufp->not_bol) {
#line 436
    tmp___5 = 1;
  } else {
#line 436
    tmp___5 = 0;
  }
#line 436
  eflags |= tmp___5;
#line 437
  if (bufp->not_eol) {
#line 437
    tmp___6 = 1 << 1;
  } else {
#line 437
    tmp___6 = 0;
  }
#line 437
  eflags |= tmp___6;
#line 440
  if (range > 0) {
#line 440
    if ((unsigned long )bufp->fastmap != (unsigned long )((void *)0)) {
#line 440
      if (! bufp->fastmap_accurate) {
        {
#line 441
        re_compile_fastmap(bufp);
        }
      }
    }
  }
  {
#line 443
  tmp___7 = __builtin_expect((long )bufp->no_sub, 0L);
  }
#line 443
  if (tmp___7) {
#line 444
    regs = (struct re_registers *)((void *)0);
  }
#line 447
  if ((unsigned long )regs == (unsigned long )((void *)0)) {
#line 448
    nregs = 1;
  } else {
#line 449
    if (bufp->regs_allocated == 2U) {
#line 449
      if ((size_t )regs->num_regs < bufp->re_nsub + 1UL) {
#line 449
        tmp___9 = 1;
      } else {
#line 449
        tmp___9 = 0;
      }
    } else {
#line 449
      tmp___9 = 0;
    }
    {
#line 449
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 449
    if (tmp___10) {
      {
#line 452
      nregs = (int )regs->num_regs;
#line 453
      tmp___8 = __builtin_expect((long )(nregs < 1), 0L);
      }
#line 453
      if (tmp___8) {
#line 456
        regs = (struct re_registers *)((void *)0);
#line 457
        nregs = 1;
      }
    } else {
#line 461
      nregs = (int )(bufp->re_nsub + 1UL);
    }
  }
  {
#line 462
  tmp___11 = malloc((unsigned long )nregs * sizeof(regmatch_t ));
#line 462
  pmatch = (regmatch_t *)tmp___11;
#line 463
  tmp___12 = __builtin_expect((long )((unsigned long )pmatch == (unsigned long )((void *)0)),
                              0L);
  }
#line 463
  if (tmp___12) {
#line 465
    rval = -2;
#line 466
    goto out;
  }
  {
#line 469
  result = re_search_internal((regex_t const   *)bufp, string, length, start, range,
                              stop___0, (size_t )nregs, pmatch, eflags);
#line 472
  rval = 0;
  }
#line 475
  if ((int )result != 0) {
#line 476
    rval = -1;
  } else
#line 477
  if ((unsigned long )regs != (unsigned long )((void *)0)) {
    {
#line 480
    bufp->regs_allocated = re_copy_regs(regs, pmatch, nregs, (int )bufp->regs_allocated);
#line 482
    tmp___13 = __builtin_expect((long )(bufp->regs_allocated == 0U), 0L);
    }
#line 482
    if (tmp___13) {
#line 483
      rval = -2;
    }
  }
  {
#line 486
  tmp___14 = __builtin_expect((long )(rval == 0), 1L);
  }
#line 486
  if (tmp___14) {
#line 488
    if (ret_len) {
#line 491
      rval = (pmatch + 0)->rm_eo - start;
    } else {
#line 494
      rval = (pmatch + 0)->rm_so;
    }
  }
  {
#line 496
  free((void *)pmatch);
  }
  out: 
  {
#line 498
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 498
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 499
  return (rval);
}
}
#line 502 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 int nregs , int regs_allocated ) 
{ 
  int rval ;
  int i___0 ;
  int need_regs ;
  void *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  regoff_t *new_start ;
  void *tmp___5 ;
  regoff_t *new_end ;
  long tmp___6 ;
  void *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  regoff_t tmp___10 ;

  {
#line 508
  rval = 1;
#line 510
  need_regs = nregs + 1;
#line 515
  if (regs_allocated == 0) {
    {
#line 517
    tmp___1 = malloc((unsigned long )need_regs * sizeof(regoff_t ));
#line 517
    regs->start = (regoff_t *)tmp___1;
#line 518
    tmp___2 = __builtin_expect((long )((unsigned long )regs->start == (unsigned long )((void *)0)),
                               0L);
    }
#line 518
    if (tmp___2) {
#line 519
      return (0U);
    }
    {
#line 520
    tmp___3 = malloc((unsigned long )need_regs * sizeof(regoff_t ));
#line 520
    regs->end = (regoff_t *)tmp___3;
#line 521
    tmp___4 = __builtin_expect((long )((unsigned long )regs->end == (unsigned long )((void *)0)),
                               0L);
    }
#line 521
    if (tmp___4) {
      {
#line 523
      free((void *)regs->start);
      }
#line 524
      return (0U);
    }
#line 526
    regs->num_regs = (unsigned int )need_regs;
  } else
#line 528
  if (regs_allocated == 1) {
    {
#line 532
    tmp___9 = __builtin_expect((long )((unsigned int )need_regs > regs->num_regs),
                               0L);
    }
#line 532
    if (tmp___9) {
      {
#line 534
      tmp___5 = realloc((void *)regs->start, (unsigned long )need_regs * sizeof(regoff_t ));
#line 534
      new_start = (regoff_t *)tmp___5;
#line 536
      tmp___6 = __builtin_expect((long )((unsigned long )new_start == (unsigned long )((void *)0)),
                                 0L);
      }
#line 536
      if (tmp___6) {
#line 537
        return (0U);
      }
      {
#line 538
      tmp___7 = realloc((void *)regs->end, (unsigned long )need_regs * sizeof(regoff_t ));
#line 538
      new_end = (regoff_t *)tmp___7;
#line 539
      tmp___8 = __builtin_expect((long )((unsigned long )new_end == (unsigned long )((void *)0)),
                                 0L);
      }
#line 539
      if (tmp___8) {
        {
#line 541
        free((void *)new_start);
        }
#line 542
        return (0U);
      }
#line 544
      regs->start = new_start;
#line 545
      regs->end = new_end;
#line 546
      regs->num_regs = (unsigned int )need_regs;
    }
  } else {
#line 554
    rval = 2;
  }
#line 558
  i___0 = 0;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (i___0 < nregs)) {
#line 558
      goto while_break;
    }
#line 560
    *(regs->start + i___0) = (pmatch + i___0)->rm_so;
#line 561
    *(regs->end + i___0) = (pmatch + i___0)->rm_eo;
#line 558
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 563
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 563
    if (! ((unsigned int )i___0 < regs->num_regs)) {
#line 563
      goto while_break___0;
    }
#line 564
    tmp___10 = -1;
#line 564
    *(regs->end + i___0) = tmp___10;
#line 564
    *(regs->start + i___0) = tmp___10;
#line 563
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 566
  return ((unsigned int )rval);
}
}
#line 582 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) 
{ 
  regoff_t *tmp___1 ;

  {
#line 589
  if (num_regs) {
#line 591
    bufp->regs_allocated = 1U;
#line 592
    regs->num_regs = num_regs;
#line 593
    regs->start = starts;
#line 594
    regs->end = ends;
  } else {
#line 598
    bufp->regs_allocated = 0U;
#line 599
    regs->num_regs = 0U;
#line 600
    tmp___1 = (regoff_t *)0;
#line 600
    regs->end = tmp___1;
#line 600
    regs->start = tmp___1;
  }
#line 602
  return;
}
}
#line 633 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        int length , int start , int range , int stop___0 ,
                                        size_t nmatch , regmatch_t *pmatch , int eflags ) 
{ 
  reg_errcode_t err___0 ;
  re_dfa_t const   *dfa___0 ;
  int left_lim ;
  int right_lim ;
  int incr ;
  int fl_longest_match ;
  int match_first ;
  int match_kind ;
  int match_last ;
  int extra_nmatch ;
  int sb ;
  int ch ;
  re_match_context_t mctx ;
  char *fastmap ;
  char *tmp___1 ;
  unsigned char *t ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  int tmp___17 ;
  unsigned int offset ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  int *tmp___21 ;
  re_dfastate_t *pstate ;
  long tmp___22 ;
  long tmp___23 ;
  int reg_idx ;
  regoff_t tmp___24 ;
  int tmp___25 ;
  long tmp___26 ;
  long tmp___27 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;

  {
#line 644
  dfa___0 = (re_dfa_t const   *)preg->buffer;
#line 646
  match_last = -1;
#line 654
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
#line 654
    if (preg->fastmap_accurate) {
#line 654
      if (range) {
#line 654
        if (! preg->can_be_null) {
#line 654
          tmp___1 = preg->fastmap;
        } else {
#line 654
          tmp___1 = (char */* const  */)((void *)0);
        }
      } else {
#line 654
        tmp___1 = (char */* const  */)((void *)0);
      }
    } else {
#line 654
      tmp___1 = (char */* const  */)((void *)0);
    }
  } else {
#line 654
    tmp___1 = (char */* const  */)((void *)0);
  }
  {
#line 654
  fastmap = (char *)tmp___1;
#line 656
  t = (unsigned char *)preg->translate;
#line 659
  memset((void *)(& mctx), '\000', sizeof(re_match_context_t ));
#line 660
  mctx.dfa = dfa___0;
  }
#line 663
  if (nmatch > (size_t )preg->re_nsub) {
#line 663
    extra_nmatch = (int )(nmatch - (size_t )(preg->re_nsub + 1UL));
  } else {
#line 663
    extra_nmatch = 0;
  }
#line 664
  nmatch -= (size_t )extra_nmatch;
#line 667
  if (preg->used == 0UL) {
#line 667
    tmp___2 = 1;
  } else
#line 667
  if ((unsigned long )dfa___0->init_state == (unsigned long )((void *)0)) {
#line 667
    tmp___2 = 1;
  } else
#line 667
  if ((unsigned long )dfa___0->init_state_word == (unsigned long )((void *)0)) {
#line 667
    tmp___2 = 1;
  } else
#line 667
  if ((unsigned long )dfa___0->init_state_nl == (unsigned long )((void *)0)) {
#line 667
    tmp___2 = 1;
  } else
#line 667
  if ((unsigned long )dfa___0->init_state_begbuf == (unsigned long )((void *)0)) {
#line 667
    tmp___2 = 1;
  } else {
#line 667
    tmp___2 = 0;
  }
  {
#line 667
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
#line 667
  if (tmp___3) {
#line 670
    return ((reg_errcode_t )1);
  }
#line 680
  if ((dfa___0->init_state)->nodes.nelem == 0) {
#line 680
    if ((dfa___0->init_state_word)->nodes.nelem == 0) {
#line 680
      if ((dfa___0->init_state_nl)->nodes.nelem == 0) {
#line 680
        goto _L;
      } else
#line 680
      if (! preg->newline_anchor) {
        _L: /* CIL Label */ 
#line 685
        if (start != 0) {
#line 685
          if (start + range != 0) {
#line 686
            return ((reg_errcode_t )1);
          }
        }
#line 687
        range = 0;
#line 687
        start = range;
      }
    }
  }
#line 691
  if (nmatch != 0UL) {
#line 691
    tmp___4 = 1;
  } else
#line 691
  if (dfa___0->nbackref) {
#line 691
    tmp___4 = 1;
  } else {
#line 691
    tmp___4 = 0;
  }
  {
#line 691
  fl_longest_match = tmp___4;
#line 693
  err___0 = re_string_allocate(& mctx.input, string, length, (int )(dfa___0->nodes_len + 1UL),
                               (unsigned char *)preg->translate, (int )(preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
                               dfa___0);
#line 695
  tmp___5 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 695
  if (tmp___5) {
#line 696
    goto free_return;
  }
  {
#line 697
  mctx.input.stop = stop___0;
#line 698
  mctx.input.raw_stop = stop___0;
#line 699
  mctx.input.newline_anchor = (unsigned char )preg->newline_anchor;
#line 701
  err___0 = match_ctx_init(& mctx, eflags, (int )(dfa___0->nbackref * 2));
#line 702
  tmp___6 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 702
  if (tmp___6) {
#line 703
    goto free_return;
  }
#line 709
  if (nmatch > 1UL) {
#line 709
    goto _L___0;
  } else
#line 709
  if (dfa___0->has_mb_node) {
    _L___0: /* CIL Label */ 
    {
#line 712
    tmp___7 = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) <= (unsigned long )mctx.input.bufs_len),
                               0L);
    }
#line 712
    if (tmp___7) {
#line 714
      err___0 = (reg_errcode_t )12;
#line 715
      goto free_return;
    }
    {
#line 718
    tmp___8 = malloc((unsigned long )(mctx.input.bufs_len + 1) * sizeof(re_dfastate_t *));
#line 718
    mctx.state_log = (re_dfastate_t **)tmp___8;
#line 719
    tmp___9 = __builtin_expect((long )((unsigned long )mctx.state_log == (unsigned long )((void *)0)),
                               0L);
    }
#line 719
    if (tmp___9) {
#line 721
      err___0 = (reg_errcode_t )12;
#line 722
      goto free_return;
    }
  } else {
#line 726
    mctx.state_log = (re_dfastate_t **)((void *)0);
  }
#line 728
  match_first = start;
#line 729
  if (eflags & 1) {
#line 729
    mctx.input.tip_context = (unsigned int )((1 << 1) << 1);
  } else {
#line 729
    mctx.input.tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
  }
#line 733
  if (range < 0) {
#line 733
    incr = -1;
  } else {
#line 733
    incr = 1;
  }
#line 734
  if (range < 0) {
#line 734
    left_lim = start + range;
  } else {
#line 734
    left_lim = start;
  }
#line 735
  if (range < 0) {
#line 735
    right_lim = start;
  } else {
#line 735
    right_lim = start + range;
  }
#line 736
  sb = dfa___0->mb_cur_max == 1;
#line 737
  if (fastmap) {
#line 737
    if (sb) {
#line 737
      tmp___10 = 4;
    } else
#line 737
    if (preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 737
      tmp___10 = 0;
    } else
#line 737
    if (t) {
#line 737
      tmp___10 = 0;
    } else {
#line 737
      tmp___10 = 4;
    }
#line 737
    if (range >= 0) {
#line 737
      tmp___11 = 2;
    } else {
#line 737
      tmp___11 = 0;
    }
#line 737
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 737
      tmp___12 = 1;
    } else {
#line 737
      tmp___12 = 0;
    }
#line 737
    match_kind = (tmp___10 | tmp___11) | tmp___12;
  } else {
#line 737
    match_kind = 8;
  }
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    err___0 = (reg_errcode_t )1;
#line 747
    if (match_first < left_lim) {
#line 748
      goto free_return;
    } else
#line 747
    if (right_lim < match_first) {
#line 748
      goto free_return;
    }
    {
#line 757
    if (match_kind == 8) {
#line 757
      goto case_8;
    }
#line 761
    if (match_kind == 7) {
#line 761
      goto case_7;
    }
#line 768
    if (match_kind == 6) {
#line 768
      goto case_6;
    }
#line 785
    if (match_kind == 5) {
#line 785
      goto case_5;
    }
#line 785
    if (match_kind == 4) {
#line 785
      goto case_5;
    }
#line 799
    goto switch_default;
    case_8: /* CIL Label */ 
#line 759
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 763
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 763
      tmp___13 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
#line 763
      if (tmp___13) {
#line 763
        if (! (! *(fastmap + *(t + (unsigned char )*(string + match_first))))) {
#line 763
          goto while_break___0;
        }
      } else {
#line 763
        goto while_break___0;
      }
#line 765
      match_first ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 766
    goto forward_match_found_start_or_reached_end;
    case_6: /* CIL Label */ 
    {
#line 770
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 770
      tmp___14 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
#line 770
      if (tmp___14) {
#line 770
        if (! (! *(fastmap + (unsigned char )*(string + match_first)))) {
#line 770
          goto while_break___1;
        }
      } else {
#line 770
        goto while_break___1;
      }
#line 772
      match_first ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    forward_match_found_start_or_reached_end: 
    {
#line 775
    tmp___16 = __builtin_expect((long )(match_first == right_lim), 0L);
    }
#line 775
    if (tmp___16) {
#line 777
      if (match_first >= length) {
#line 777
        ch = 0;
      } else {
#line 777
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 779
      if (t) {
#line 779
        tmp___15 = (int )*(t + ch);
      } else {
#line 779
        tmp___15 = ch;
      }
#line 779
      if (! *(fastmap + tmp___15)) {
#line 780
        goto free_return;
      }
    }
#line 782
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 787
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 787
      if (! (match_first >= left_lim)) {
#line 787
        goto while_break___2;
      }
#line 789
      if (match_first >= length) {
#line 789
        ch = 0;
      } else {
#line 789
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 791
      if (t) {
#line 791
        tmp___17 = (int )*(t + ch);
      } else {
#line 791
        tmp___17 = ch;
      }
#line 791
      if (*(fastmap + tmp___17)) {
#line 792
        goto while_break___2;
      }
#line 793
      match_first --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 795
    if (match_first < left_lim) {
#line 796
      goto free_return;
    }
#line 797
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 803
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 807
      offset = (unsigned int )(match_first - mctx.input.raw_mbs_idx);
#line 808
      tmp___19 = __builtin_expect((long )(offset >= (unsigned int )mctx.input.valid_raw_len),
                                  0L);
      }
#line 808
      if (tmp___19) {
        {
#line 810
        err___0 = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 812
        tmp___18 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 812
        if (tmp___18) {
#line 813
          goto free_return;
        }
#line 815
        offset = (unsigned int )(match_first - mctx.input.raw_mbs_idx);
      }
#line 819
      if (match_first >= length) {
#line 819
        ch = 0;
      } else {
#line 819
        ch = (int )*(mctx.input.mbs + offset);
      }
#line 821
      if (*(fastmap + ch)) {
#line 822
        goto while_break___3;
      }
#line 823
      match_first += incr;
#line 824
      if (match_first < left_lim) {
#line 826
        err___0 = (reg_errcode_t )1;
#line 827
        goto free_return;
      } else
#line 824
      if (match_first > right_lim) {
#line 826
        err___0 = (reg_errcode_t )1;
#line 827
        goto free_return;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 830
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 835
    err___0 = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 836
    tmp___20 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 836
    if (tmp___20) {
#line 837
      goto free_return;
    }
#line 842
    if (! sb) {
#line 842
      if (! (0 == mctx.input.valid_len)) {
#line 842
        if (! (*(mctx.input.wcs + 0) != 4294967295U)) {
#line 843
          goto __Cont;
        }
      }
    }
#line 848
    mctx.max_mb_elem_len = 0;
#line 848
    mctx.nbkref_ents = mctx.max_mb_elem_len;
#line 848
    mctx.state_log_top = mctx.nbkref_ents;
#line 849
    if (range >= 0) {
#line 849
      tmp___21 = & match_first;
    } else {
#line 849
      tmp___21 = (int *)((void *)0);
    }
    {
#line 849
    match_last = check_matching(& mctx, fl_longest_match, tmp___21);
    }
#line 851
    if (match_last != -1) {
      {
#line 853
      tmp___23 = __builtin_expect((long )(match_last == -2), 0L);
      }
#line 853
      if (tmp___23) {
#line 855
        err___0 = (reg_errcode_t )12;
#line 856
        goto free_return;
      } else {
#line 860
        mctx.match_last = match_last;
#line 861
        if (! preg->no_sub) {
#line 861
          if (nmatch > 1UL) {
            {
#line 863
            pstate = *(mctx.state_log + match_last);
#line 864
            mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                      (re_dfastate_t const   *)pstate,
                                                      match_last);
            }
          } else {
#line 861
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 861
        if (dfa___0->nbackref) {
          {
#line 863
          pstate = *(mctx.state_log + match_last);
#line 864
          mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                    (re_dfastate_t const   *)pstate,
                                                    match_last);
          }
        }
#line 867
        if (! preg->no_sub) {
#line 867
          if (nmatch > 1UL) {
#line 867
            if (dfa___0->has_plural_match) {
#line 867
              goto _L___2;
            } else {
#line 867
              goto _L___4;
            }
          } else {
#line 867
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 867
        if (dfa___0->nbackref) {
          _L___2: /* CIL Label */ 
          {
#line 870
          err___0 = prune_impossible_nodes(& mctx);
          }
#line 871
          if ((int )err___0 == 0) {
#line 872
            goto while_break;
          }
          {
#line 873
          tmp___22 = __builtin_expect((long )((int )err___0 != 1), 0L);
          }
#line 873
          if (tmp___22) {
#line 874
            goto free_return;
          }
#line 875
          match_last = -1;
        } else {
#line 878
          goto while_break;
        }
      }
    }
    {
#line 882
    match_ctx_clean(& mctx);
    }
    __Cont: /* CIL Label */ 
#line 744
    match_first += incr;
  }
  while_break: /* CIL Label */ ;
  }
#line 891
  if (nmatch > 0UL) {
#line 896
    reg_idx = 1;
    {
#line 896
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 896
      if (! ((size_t )reg_idx < nmatch)) {
#line 896
        goto while_break___4;
      }
#line 897
      tmp___24 = -1;
#line 897
      (pmatch + reg_idx)->rm_eo = tmp___24;
#line 897
      (pmatch + reg_idx)->rm_so = tmp___24;
#line 896
      reg_idx ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 900
    (pmatch + 0)->rm_so = 0;
#line 901
    (pmatch + 0)->rm_eo = mctx.match_last;
#line 903
    if (! preg->no_sub) {
#line 903
      if (nmatch > 1UL) {
#line 905
        if (dfa___0->has_plural_match) {
#line 905
          if (dfa___0->nbackref > 0) {
#line 905
            tmp___25 = 1;
          } else {
#line 905
            tmp___25 = 0;
          }
        } else {
#line 905
          tmp___25 = 0;
        }
        {
#line 905
        err___0 = set_regs(preg, (re_match_context_t const   *)(& mctx), nmatch, pmatch,
                           tmp___25);
#line 907
        tmp___26 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 907
        if (tmp___26) {
#line 908
          goto free_return;
        }
      }
    }
#line 914
    reg_idx = 0;
    {
#line 914
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 914
      if (! ((size_t )reg_idx < nmatch)) {
#line 914
        goto while_break___5;
      }
#line 915
      if ((pmatch + reg_idx)->rm_so != -1) {
        {
#line 918
        tmp___27 = __builtin_expect((long )((int )mctx.input.offsets_needed != 0),
                                    0L);
        }
#line 918
        if (tmp___27) {
#line 920
          if ((pmatch + reg_idx)->rm_so == mctx.input.valid_len) {
#line 920
            (pmatch + reg_idx)->rm_so = mctx.input.valid_raw_len;
          } else {
#line 920
            (pmatch + reg_idx)->rm_so = *(mctx.input.offsets + (pmatch + reg_idx)->rm_so);
          }
#line 924
          if ((pmatch + reg_idx)->rm_eo == mctx.input.valid_len) {
#line 924
            (pmatch + reg_idx)->rm_eo = mctx.input.valid_raw_len;
          } else {
#line 924
            (pmatch + reg_idx)->rm_eo = *(mctx.input.offsets + (pmatch + reg_idx)->rm_eo);
          }
        }
#line 932
        (pmatch + reg_idx)->rm_so += match_first;
#line 933
        (pmatch + reg_idx)->rm_eo += match_first;
      }
#line 914
      reg_idx ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 935
    reg_idx = 0;
    {
#line 935
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 935
      if (! (reg_idx < extra_nmatch)) {
#line 935
        goto while_break___6;
      }
#line 937
      (pmatch + (nmatch + (size_t )reg_idx))->rm_so = -1;
#line 938
      (pmatch + (nmatch + (size_t )reg_idx))->rm_eo = -1;
#line 935
      reg_idx ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 941
    if (dfa___0->subexp_map) {
#line 942
      reg_idx = 0;
      {
#line 942
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 942
        if (! ((size_t )(reg_idx + 1) < nmatch)) {
#line 942
          goto while_break___7;
        }
#line 943
        if (*(dfa___0->subexp_map + reg_idx) != reg_idx) {
#line 945
          (pmatch + (reg_idx + 1))->rm_so = (pmatch + (*(dfa___0->subexp_map + reg_idx) + 1))->rm_so;
#line 947
          (pmatch + (reg_idx + 1))->rm_eo = (pmatch + (*(dfa___0->subexp_map + reg_idx) + 1))->rm_eo;
        }
#line 942
        reg_idx ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  free_return: 
  {
#line 953
  free((void *)mctx.state_log);
  }
#line 954
  if (dfa___0->nbackref) {
    {
#line 955
    match_ctx_free(& mctx);
    }
  }
  {
#line 956
  re_string_destruct(& mctx.input);
  }
#line 957
  return (err___0);
}
}
#line 960 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) 
{ 
  re_dfa_t const   *dfa___0 ;
  int halt_node ;
  int match_last ;
  reg_errcode_t ret ;
  re_dfastate_t **sifted_states ;
  re_dfastate_t **lim_states ;
  re_sift_context_t sctx ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;

  {
  {
#line 965
  dfa___0 = mctx->dfa;
#line 969
  lim_states = (re_dfastate_t **)((void *)0);
#line 974
  match_last = mctx->match_last;
#line 975
  halt_node = mctx->last_node;
#line 978
  tmp___1 = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) <= (unsigned long )match_last),
                             0L);
  }
#line 978
  if (tmp___1) {
#line 979
    return ((reg_errcode_t )12);
  }
  {
#line 981
  tmp___2 = malloc((unsigned long )(match_last + 1) * sizeof(re_dfastate_t *));
#line 981
  sifted_states = (re_dfastate_t **)tmp___2;
#line 982
  tmp___3 = __builtin_expect((long )((unsigned long )sifted_states == (unsigned long )((void *)0)),
                             0L);
  }
#line 982
  if (tmp___3) {
#line 984
    ret = (reg_errcode_t )12;
#line 985
    goto free_return;
  }
#line 987
  if (dfa___0->nbackref) {
    {
#line 989
    tmp___4 = malloc((unsigned long )(match_last + 1) * sizeof(re_dfastate_t *));
#line 989
    lim_states = (re_dfastate_t **)tmp___4;
#line 990
    tmp___5 = __builtin_expect((long )((unsigned long )lim_states == (unsigned long )((void *)0)),
                               0L);
    }
#line 990
    if (tmp___5) {
#line 992
      ret = (reg_errcode_t )12;
#line 993
      goto free_return;
    }
    {
#line 995
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 997
      memset((void *)lim_states, '\000', sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1));
#line 999
      sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1001
      ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 1002
      free((void *)sctx.limits.elems);
#line 1003
      tmp___6 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 1003
      if (tmp___6) {
#line 1004
        goto free_return;
      }
#line 1005
      if ((unsigned long )*(sifted_states + 0) != (unsigned long )((void *)0)) {
#line 1006
        goto while_break;
      } else
#line 1005
      if ((unsigned long )*(lim_states + 0) != (unsigned long )((void *)0)) {
#line 1006
        goto while_break;
      }
      {
#line 1007
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1009
        match_last --;
#line 1010
        if (match_last < 0) {
#line 1012
          ret = (reg_errcode_t )1;
#line 1013
          goto free_return;
        }
#line 1007
        if (! ((unsigned long )*(mctx->state_log + match_last) == (unsigned long )((void *)0))) {
#line 1007
          if (! (! (*(mctx->state_log + match_last))->halt)) {
#line 1007
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1017
      halt_node = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)*(mctx->state_log + match_last),
                                           match_last);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1021
    ret = merge_state_array(dfa___0, sifted_states, lim_states, match_last + 1);
#line 1023
    free((void *)lim_states);
#line 1024
    lim_states = (re_dfastate_t **)((void *)0);
#line 1025
    tmp___7 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 1025
    if (tmp___7) {
#line 1026
      goto free_return;
    }
  } else {
    {
#line 1030
    sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1031
    ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 1032
    free((void *)sctx.limits.elems);
#line 1033
    tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 1033
    if (tmp___8) {
#line 1034
      goto free_return;
    }
#line 1035
    if ((unsigned long )*(sifted_states + 0) == (unsigned long )((void *)0)) {
#line 1037
      ret = (reg_errcode_t )1;
#line 1038
      goto free_return;
    }
  }
  {
#line 1041
  free((void *)mctx->state_log);
#line 1042
  mctx->state_log = sifted_states;
#line 1043
  sifted_states = (re_dfastate_t **)((void *)0);
#line 1044
  mctx->last_node = halt_node;
#line 1045
  mctx->match_last = match_last;
#line 1046
  ret = (reg_errcode_t )0;
  }
  free_return: 
  {
#line 1048
  free((void *)sifted_states);
#line 1049
  free((void *)lim_states);
  }
#line 1050
  return (ret);
}
}
#line 1057 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
__inline static re_dfastate_t *( __attribute__((__always_inline__)) acquire_init_state_context)(reg_errcode_t *err___0 ,
                                                                                                re_match_context_t const   *mctx ,
                                                                                                int idx___3 ) 
{ 
  re_dfa_t const   *dfa___0 ;
  unsigned int context ;
  re_dfastate_t *tmp___1 ;

  {
#line 1062
  dfa___0 = (re_dfa_t const   *)mctx->dfa;
#line 1063
  if ((dfa___0->init_state)->has_constraint) {
    {
#line 1066
    context = re_string_context_at(& mctx->input, idx___3 - 1, (int )mctx->eflags);
    }
#line 1067
    if (context & 1U) {
#line 1068
      return ((re_dfastate_t *)dfa___0->init_state_word);
    } else
#line 1069
    if (context == 0U) {
#line 1070
      return ((re_dfastate_t *)dfa___0->init_state);
    } else
#line 1071
    if (context & (unsigned int )((1 << 1) << 1)) {
#line 1071
      if (context & (unsigned int )(1 << 1)) {
#line 1072
        return ((re_dfastate_t *)dfa___0->init_state_begbuf);
      } else {
#line 1071
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1073
    if (context & (unsigned int )(1 << 1)) {
#line 1074
      return ((re_dfastate_t *)dfa___0->init_state_nl);
    } else
#line 1075
    if (context & (unsigned int )((1 << 1) << 1)) {
      {
#line 1078
      tmp___1 = re_acquire_state_context(err___0, dfa___0, (re_node_set const   *)(dfa___0->init_state)->entrance_nodes,
                                         context);
      }
#line 1078
      return (tmp___1);
    } else {
#line 1084
      return ((re_dfastate_t *)dfa___0->init_state);
    }
  } else {
#line 1087
    return ((re_dfastate_t *)dfa___0->init_state);
  }
}
}
#line 1099 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int check_matching(re_match_context_t *mctx , int fl_longest_match , int *p_match_first ) 
{ 
  re_dfa_t const   *dfa___0 ;
  reg_errcode_t err___0 ;
  int match ;
  int match_last ;
  int cur_str_idx ;
  re_dfastate_t *cur_state ;
  int at_init_state ;
  int next_start_idx ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  re_dfastate_t *old_state ;
  int next_char_idx ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;

  {
  {
#line 1104
  dfa___0 = mctx->dfa;
#line 1106
  match = 0;
#line 1107
  match_last = -1;
#line 1108
  cur_str_idx = mctx->input.cur_idx;
#line 1110
  at_init_state = (unsigned long )p_match_first != (unsigned long )((void *)0);
#line 1111
  next_start_idx = cur_str_idx;
#line 1113
  err___0 = (reg_errcode_t )0;
#line 1114
  cur_state = acquire_init_state_context(& err___0, (re_match_context_t const   *)mctx,
                                         cur_str_idx);
#line 1116
  tmp___1 = __builtin_expect((long )((unsigned long )cur_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1116
  if (tmp___1) {
#line 1119
    return (-2);
  }
#line 1122
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
#line 1124
    *(mctx->state_log + cur_str_idx) = cur_state;
#line 1128
    tmp___4 = __builtin_expect((long )dfa___0->nbackref, 0L);
    }
#line 1128
    if (tmp___4) {
      {
#line 1130
      at_init_state = 0;
#line 1131
      err___0 = check_subexp_matching_top(mctx, & cur_state->nodes, 0);
#line 1132
      tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1132
      if (tmp___2) {
#line 1133
        return ((int )err___0);
      }
#line 1135
      if (cur_state->has_backref) {
        {
#line 1137
        err___0 = transit_state_bkref(mctx, (re_node_set const   *)(& cur_state->nodes));
#line 1138
        tmp___3 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 1138
        if (tmp___3) {
#line 1139
          return ((int )err___0);
        }
      }
    }
  }
  {
#line 1145
  tmp___6 = __builtin_expect((long )cur_state->halt, 0L);
  }
#line 1145
  if (tmp___6) {
#line 1147
    if (! cur_state->has_constraint) {
#line 1147
      goto _L;
    } else {
      {
#line 1147
      tmp___5 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                         cur_str_idx);
      }
#line 1147
      if (tmp___5) {
        _L: /* CIL Label */ 
#line 1150
        if (! fl_longest_match) {
#line 1151
          return (cur_str_idx);
        } else {
#line 1154
          match_last = cur_str_idx;
#line 1155
          match = 1;
        }
      }
    }
  }
  {
#line 1160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1160
    if (! (! (mctx->input.stop <= mctx->input.cur_idx))) {
#line 1160
      goto while_break;
    }
    {
#line 1162
    old_state = cur_state;
#line 1163
    next_char_idx = mctx->input.cur_idx + 1;
#line 1165
    tmp___8 = __builtin_expect((long )(next_char_idx >= mctx->input.bufs_len), 0L);
    }
#line 1165
    if (tmp___8) {
#line 1165
      if (mctx->input.bufs_len < mctx->input.len) {
#line 1165
        goto _L___0;
      } else {
#line 1165
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 1165
      tmp___9 = __builtin_expect((long )(next_char_idx >= mctx->input.valid_len),
                                 0L);
      }
#line 1165
      if (tmp___9) {
#line 1165
        if (mctx->input.valid_len < mctx->input.len) {
          _L___0: /* CIL Label */ 
          {
#line 1170
          err___0 = extend_buffers(mctx, next_char_idx + 1);
#line 1171
          tmp___7 = __builtin_expect((long )((int )err___0 != 0), 0L);
          }
#line 1171
          if (tmp___7) {
#line 1174
            return (-2);
          }
        }
      }
    }
    {
#line 1178
    cur_state = transit_state(& err___0, mctx, cur_state);
    }
#line 1179
    if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
      {
#line 1180
      cur_state = merge_state_with_log(& err___0, mctx, cur_state);
      }
    }
#line 1182
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
      {
#line 1187
      tmp___10 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1187
      if (tmp___10) {
#line 1188
        return (-2);
      }
#line 1190
      if ((unsigned long )mctx->state_log == (unsigned long )((void *)0)) {
#line 1193
        goto while_break;
      } else
#line 1190
      if (match) {
#line 1190
        if (! fl_longest_match) {
#line 1193
          goto while_break;
        } else {
#line 1190
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        {
#line 1190
        cur_state = find_recover_state(& err___0, mctx);
        }
#line 1190
        if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 1193
          goto while_break;
        }
      }
    }
    {
#line 1196
    tmp___11 = __builtin_expect((long )at_init_state, 0L);
    }
#line 1196
    if (tmp___11) {
#line 1198
      if ((unsigned long )old_state == (unsigned long )cur_state) {
#line 1199
        next_start_idx = next_char_idx;
      } else {
#line 1201
        at_init_state = 0;
      }
    }
#line 1204
    if (cur_state->halt) {
#line 1208
      if (! cur_state->has_constraint) {
#line 1208
        goto _L___3;
      } else {
        {
#line 1208
        tmp___12 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                            mctx->input.cur_idx);
        }
#line 1208
        if (tmp___12) {
          _L___3: /* CIL Label */ 
#line 1213
          match_last = mctx->input.cur_idx;
#line 1214
          match = 1;
#line 1217
          p_match_first = (int *)((void *)0);
#line 1218
          if (! fl_longest_match) {
#line 1219
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1224
  if (p_match_first) {
#line 1225
    *p_match_first += next_start_idx;
  }
#line 1227
  return (match_last);
}
}
#line 1232 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int check_halt_node_context(re_dfa_t const   *dfa___0 , int node , unsigned int context ) 
{ 
  re_token_type_t type ;
  unsigned int constraint ;

  {
#line 1236
  type = (dfa___0->nodes + node)->type;
#line 1237
  constraint = (dfa___0->nodes + node)->constraint;
#line 1238
  if ((unsigned int )type != 2U) {
#line 1239
    return (0);
  }
#line 1240
  if (! constraint) {
#line 1241
    return (1);
  }
#line 1242
  if (constraint & 4U) {
#line 1242
    if (! (context & 1U)) {
#line 1243
      return (0);
    } else {
#line 1242
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1242
  if (constraint & 8U) {
#line 1242
    if (context & 1U) {
#line 1243
      return (0);
    } else {
#line 1242
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1242
  if (constraint & 32U) {
#line 1242
    if (! (context & (unsigned int )(1 << 1))) {
#line 1243
      return (0);
    } else {
#line 1242
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1242
  if (constraint & 128U) {
#line 1242
    if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 1243
      return (0);
    }
  }
#line 1244
  return (1);
}
}
#line 1251 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state___2 ,
                                    int idx___3 ) 
{ 
  int i___0 ;
  unsigned int context ;
  int tmp___1 ;

  {
  {
#line 1261
  context = re_string_context_at(& mctx->input, idx___3, (int )mctx->eflags);
#line 1262
  i___0 = 0;
  }
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1262
    if (! (i___0 < (int )state___2->nodes.nelem)) {
#line 1262
      goto while_break;
    }
    {
#line 1263
    tmp___1 = check_halt_node_context((re_dfa_t const   *)mctx->dfa, *(state___2->nodes.elems + i___0),
                                      context);
    }
#line 1263
    if (tmp___1) {
#line 1264
      return (*(state___2->nodes.elems + i___0));
    }
#line 1262
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1265
  return (0);
}
}
#line 1273 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int proceed_next_node(re_match_context_t const   *mctx , int nregs , regmatch_t *regs ,
                             int *pidx , int node , re_node_set *eps_via_nodes , struct re_fail_stack_t *fs ) 
{ 
  re_dfa_t const   *dfa___0 ;
  int i___0 ;
  int err___0 ;
  re_node_set *cur_nodes ;
  re_node_set *edests ;
  int dest_node ;
  long tmp___1 ;
  int candidate ;
  int __attribute__((__pure__))  tmp___2 ;
  reg_errcode_t tmp___3 ;
  int __attribute__((__pure__))  tmp___4 ;
  int naccepted ;
  re_token_type_t type ;
  int subexp_idx ;
  char *buf___7 ;
  int tmp___5 ;
  int dest_node___0 ;
  long tmp___6 ;
  int __attribute__((__pure__))  tmp___7 ;
  int dest_node___1 ;
  int __attribute__((__pure__))  tmp___8 ;
  int tmp___9 ;

  {
#line 1279
  dfa___0 = (re_dfa_t const   *)mctx->dfa;
#line 1281
  if ((unsigned int )(dfa___0->nodes + node)->type & 8U) {
    {
#line 1283
    cur_nodes = & (*(mctx->state_log + *pidx))->nodes;
#line 1284
    edests = dfa___0->edests + node;
#line 1286
    err___0 = re_node_set_insert(eps_via_nodes, node);
#line 1287
    tmp___1 = __builtin_expect((long )(err___0 < 0), 0L);
    }
#line 1287
    if (tmp___1) {
#line 1288
      return (-2);
    }
#line 1290
    dest_node = -1;
#line 1290
    i___0 = 0;
    {
#line 1290
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1290
      if (! (i___0 < edests->nelem)) {
#line 1290
        goto while_break;
      }
      {
#line 1292
      candidate = *(edests->elems + i___0);
#line 1293
      tmp___2 = re_node_set_contains((re_node_set const   *)cur_nodes, candidate);
      }
#line 1293
      if (! tmp___2) {
#line 1294
        goto __Cont;
      }
#line 1295
      if (dest_node == -1) {
#line 1296
        dest_node = candidate;
      } else {
        {
#line 1302
        tmp___4 = re_node_set_contains((re_node_set const   *)eps_via_nodes, dest_node);
        }
#line 1302
        if (tmp___4) {
#line 1303
          return (candidate);
        } else
#line 1306
        if ((unsigned long )fs != (unsigned long )((void *)0)) {
          {
#line 1306
          tmp___3 = push_fail_stack(fs, *pidx, candidate, nregs, regs, eps_via_nodes);
          }
#line 1306
          if (tmp___3) {
#line 1309
            return (-2);
          }
        }
#line 1312
        goto while_break;
      }
      __Cont: /* CIL Label */ 
#line 1290
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1315
    return (dest_node);
  } else {
#line 1319
    naccepted = 0;
#line 1320
    type = (dfa___0->nodes + node)->type;
#line 1323
    if ((dfa___0->nodes + node)->accept_mb) {
      {
#line 1324
      naccepted = check_node_accept_bytes(dfa___0, node, & mctx->input, *pidx);
      }
    } else
#line 1327
    if ((unsigned int )type == 4U) {
#line 1329
      subexp_idx = (dfa___0->nodes + node)->opr.idx + 1;
#line 1330
      naccepted = (regs + subexp_idx)->rm_eo - (regs + subexp_idx)->rm_so;
#line 1331
      if ((unsigned long )fs != (unsigned long )((void *)0)) {
#line 1333
        if ((regs + subexp_idx)->rm_so == -1) {
#line 1334
          return (-1);
        } else
#line 1333
        if ((regs + subexp_idx)->rm_eo == -1) {
#line 1334
          return (-1);
        } else
#line 1335
        if (naccepted) {
          {
#line 1337
          buf___7 = (char *)mctx->input.mbs;
#line 1338
          tmp___5 = memcmp((void const   *)(buf___7 + (regs + subexp_idx)->rm_so),
                           (void const   *)(buf___7 + *pidx), (size_t )naccepted);
          }
#line 1338
          if (tmp___5 != 0) {
#line 1340
            return (-1);
          }
        }
      }
#line 1344
      if (naccepted == 0) {
        {
#line 1347
        err___0 = re_node_set_insert(eps_via_nodes, node);
#line 1348
        tmp___6 = __builtin_expect((long )(err___0 < 0), 0L);
        }
#line 1348
        if (tmp___6) {
#line 1349
          return (-2);
        }
        {
#line 1350
        dest_node___0 = *((dfa___0->edests + node)->elems + 0);
#line 1351
        tmp___7 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                       dest_node___0);
        }
#line 1351
        if (tmp___7) {
#line 1353
          return (dest_node___0);
        }
      }
    }
#line 1357
    if (naccepted != 0) {
#line 1357
      goto _L;
    } else {
      {
#line 1357
      tmp___9 = check_node_accept(mctx, (re_token_t const   *)(dfa___0->nodes + node),
                                  *pidx);
      }
#line 1357
      if (tmp___9) {
        _L: /* CIL Label */ 
#line 1360
        dest_node___1 = *(dfa___0->nexts + node);
#line 1361
        if (naccepted == 0) {
#line 1361
          (*pidx) ++;
        } else {
#line 1361
          *pidx += naccepted;
        }
#line 1362
        if (fs) {
#line 1362
          if (*pidx > (int )mctx->match_last) {
#line 1365
            return (-1);
          } else
#line 1362
          if ((unsigned long )*(mctx->state_log + *pidx) == (unsigned long )((void *)0)) {
#line 1365
            return (-1);
          } else {
            {
#line 1362
            tmp___8 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                           dest_node___1);
            }
#line 1362
            if (! tmp___8) {
#line 1365
              return (-1);
            }
          }
        }
#line 1366
        eps_via_nodes->nelem = 0;
#line 1367
        return (dest_node___1);
      }
    }
  }
#line 1370
  return (-1);
}
}
#line 1373 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , int str_idx , int dest_node ,
                                     int nregs , regmatch_t *regs , re_node_set *eps_via_nodes ) 
{ 
  reg_errcode_t err___0 ;
  int num ;
  int tmp___1 ;
  struct re_fail_stack_ent_t *new_array ;
  void *tmp___2 ;
  void *tmp___3 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;

  {
#line 1379
  tmp___1 = fs->num;
#line 1379
  (fs->num) ++;
#line 1379
  num = tmp___1;
#line 1380
  if (fs->num == fs->alloc) {
    {
#line 1383
    tmp___2 = realloc((void *)fs->stack, (sizeof(struct re_fail_stack_ent_t ) * (unsigned long )fs->alloc) * 2UL);
#line 1383
    new_array = (struct re_fail_stack_ent_t *)tmp___2;
    }
#line 1385
    if ((unsigned long )new_array == (unsigned long )((void *)0)) {
#line 1386
      return ((reg_errcode_t )12);
    }
#line 1387
    fs->alloc *= 2;
#line 1388
    fs->stack = new_array;
  }
  {
#line 1390
  (fs->stack + num)->idx = str_idx;
#line 1391
  (fs->stack + num)->node = dest_node;
#line 1392
  tmp___3 = malloc((unsigned long )nregs * sizeof(regmatch_t ));
#line 1392
  (fs->stack + num)->regs = (regmatch_t *)tmp___3;
  }
#line 1393
  if ((unsigned long )(fs->stack + num)->regs == (unsigned long )((void *)0)) {
#line 1394
    return ((reg_errcode_t )12);
  }
  {
#line 1395
  memcpy((void */* __restrict  */)(fs->stack + num)->regs, (void const   */* __restrict  */)regs,
         sizeof(regmatch_t ) * (unsigned long )nregs);
#line 1396
  err___0 = re_node_set_init_copy(& (fs->stack + num)->eps_via_nodes, (re_node_set const   *)eps_via_nodes);
  }
#line 1397
  return (err___0);
}
}
#line 1400 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int pop_fail_stack(struct re_fail_stack_t *fs , int *pidx , int nregs , regmatch_t *regs ,
                          re_node_set *eps_via_nodes ) 
{ 
  int num ;

  {
  {
#line 1405
  (fs->num) --;
#line 1405
  num = fs->num;
#line 1407
  *pidx = (fs->stack + num)->idx;
#line 1408
  memcpy((void */* __restrict  */)regs, (void const   */* __restrict  */)(fs->stack + num)->regs,
         sizeof(regmatch_t ) * (unsigned long )nregs);
#line 1409
  free((void *)eps_via_nodes->elems);
#line 1410
  free((void *)(fs->stack + num)->regs);
#line 1411
  *eps_via_nodes = (fs->stack + num)->eps_via_nodes;
  }
#line 1412
  return ((fs->stack + num)->node);
}
}
#line 1420 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , int fl_backtrack ) 
{ 
  re_dfa_t const   *dfa___0 ;
  int idx___3 ;
  int cur_node ;
  re_node_set eps_via_nodes ;
  struct re_fail_stack_t *fs ;
  struct re_fail_stack_t fs_body ;
  regmatch_t *prev_idx_match ;
  int prev_idx_match_malloced ;
  void *tmp___1 ;
  void *tmp___2 ;
  int reg_idx ;
  reg_errcode_t tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  reg_errcode_t tmp___6 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  int __cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;

  {
#line 1425
  dfa___0 = (re_dfa_t const   *)preg->buffer;
#line 1429
  fs_body.num = 0;
#line 1429
  fs_body.alloc = 2;
#line 1429
  fs_body.stack = (struct re_fail_stack_ent_t *)((void *)0);
#line 1431
  prev_idx_match_malloced = 0;
#line 1437
  if (fl_backtrack) {
    {
#line 1439
    fs = & fs_body;
#line 1440
    tmp___1 = malloc((unsigned long )fs->alloc * sizeof(struct re_fail_stack_ent_t ));
#line 1440
    fs->stack = (struct re_fail_stack_ent_t *)tmp___1;
    }
#line 1441
    if ((unsigned long )fs->stack == (unsigned long )((void *)0)) {
#line 1442
      return ((reg_errcode_t )12);
    }
  } else {
#line 1445
    fs = (struct re_fail_stack_t *)((void *)0);
  }
  {
#line 1447
  cur_node = (int )dfa___0->init_node;
#line 1448
  memset((void *)(& eps_via_nodes), '\000', sizeof(re_node_set ));
#line 1456
  tmp___2 = malloc(nmatch * sizeof(regmatch_t ));
#line 1456
  prev_idx_match = (regmatch_t *)tmp___2;
  }
#line 1457
  if ((unsigned long )prev_idx_match == (unsigned long )((void *)0)) {
    {
#line 1459
    free_fail_stack_return(fs);
    }
#line 1460
    return ((reg_errcode_t )12);
  }
  {
#line 1462
  prev_idx_match_malloced = 1;
#line 1464
  memcpy((void */* __restrict  */)prev_idx_match, (void const   */* __restrict  */)pmatch,
         sizeof(regmatch_t ) * nmatch);
#line 1466
  idx___3 = (pmatch + 0)->rm_so;
  }
  {
#line 1466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1466
    if (! (idx___3 <= (pmatch + 0)->rm_eo)) {
#line 1466
      goto while_break;
    }
    {
#line 1468
    update_regs(dfa___0, pmatch, prev_idx_match, cur_node, idx___3, (int )nmatch);
    }
#line 1470
    if (idx___3 == (pmatch + 0)->rm_eo) {
#line 1470
      if (cur_node == (int )mctx->last_node) {
#line 1473
        if (fs) {
#line 1475
          reg_idx = 0;
          {
#line 1475
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1475
            if (! ((size_t )reg_idx < nmatch)) {
#line 1475
              goto while_break___0;
            }
#line 1476
            if ((pmatch + reg_idx)->rm_so > -1) {
#line 1476
              if ((pmatch + reg_idx)->rm_eo == -1) {
#line 1477
                goto while_break___0;
              }
            }
#line 1475
            reg_idx ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1478
          if ((size_t )reg_idx == nmatch) {
            {
#line 1480
            free((void *)eps_via_nodes.elems);
            }
#line 1481
            if (prev_idx_match_malloced) {
              {
#line 1482
              free((void *)prev_idx_match);
              }
            }
            {
#line 1483
            tmp___3 = free_fail_stack_return(fs);
            }
#line 1483
            return (tmp___3);
          }
          {
#line 1485
          cur_node = pop_fail_stack(fs, & idx___3, (int )nmatch, pmatch, & eps_via_nodes);
          }
        } else {
          {
#line 1490
          free((void *)eps_via_nodes.elems);
          }
#line 1491
          if (prev_idx_match_malloced) {
            {
#line 1492
            free((void *)prev_idx_match);
            }
          }
#line 1493
          return ((reg_errcode_t )0);
        }
      }
    }
    {
#line 1498
    cur_node = proceed_next_node(mctx, (int )nmatch, pmatch, & idx___3, cur_node,
                                 & eps_via_nodes, fs);
#line 1501
    tmp___5 = __builtin_expect((long )(cur_node < 0), 0L);
    }
#line 1501
    if (tmp___5) {
      {
#line 1503
      tmp___4 = __builtin_expect((long )(cur_node == -2), 0L);
      }
#line 1503
      if (tmp___4) {
        {
#line 1505
        free((void *)eps_via_nodes.elems);
        }
#line 1506
        if (prev_idx_match_malloced) {
          {
#line 1507
          free((void *)prev_idx_match);
          }
        }
        {
#line 1508
        free_fail_stack_return(fs);
        }
#line 1509
        return ((reg_errcode_t )12);
      }
#line 1511
      if (fs) {
        {
#line 1512
        cur_node = pop_fail_stack(fs, & idx___3, (int )nmatch, pmatch, & eps_via_nodes);
        }
      } else {
        {
#line 1516
        free((void *)eps_via_nodes.elems);
        }
#line 1517
        if (prev_idx_match_malloced) {
          {
#line 1518
          free((void *)prev_idx_match);
          }
        }
#line 1519
        return ((reg_errcode_t )1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1523
  free((void *)eps_via_nodes.elems);
  }
#line 1524
  if (prev_idx_match_malloced) {
    {
#line 1525
    free((void *)prev_idx_match);
    }
  }
  {
#line 1526
  tmp___6 = free_fail_stack_return(fs);
  }
#line 1526
  return (tmp___6);
}
}
#line 1529 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) 
{ 
  int fs_idx ;

  {
#line 1533
  if (fs) {
#line 1536
    fs_idx = 0;
    {
#line 1536
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1536
      if (! (fs_idx < fs->num)) {
#line 1536
        goto while_break;
      }
      {
#line 1538
      free((void *)(fs->stack + fs_idx)->eps_via_nodes.elems);
#line 1539
      free((void *)(fs->stack + fs_idx)->regs);
#line 1536
      fs_idx ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1541
    free((void *)fs->stack);
    }
  }
#line 1543
  return ((reg_errcode_t )0);
}
}
#line 1546 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static void update_regs(re_dfa_t const   *dfa___0 , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        int cur_node , int cur_idx , int nmatch ) 
{ 
  int type ;
  int reg_num ;
  int reg_num___0 ;

  {
#line 1551
  type = (int )(dfa___0->nodes + cur_node)->type;
#line 1552
  if (type == 8) {
#line 1554
    reg_num = (dfa___0->nodes + cur_node)->opr.idx + 1;
#line 1557
    if (reg_num < nmatch) {
#line 1559
      (pmatch + reg_num)->rm_so = cur_idx;
#line 1560
      (pmatch + reg_num)->rm_eo = -1;
    }
  } else
#line 1563
  if (type == 9) {
#line 1565
    reg_num___0 = (dfa___0->nodes + cur_node)->opr.idx + 1;
#line 1566
    if (reg_num___0 < nmatch) {
#line 1569
      if ((pmatch + reg_num___0)->rm_so < cur_idx) {
        {
#line 1571
        (pmatch + reg_num___0)->rm_eo = cur_idx;
#line 1574
        memcpy((void */* __restrict  */)prev_idx_match, (void const   */* __restrict  */)pmatch,
               sizeof(regmatch_t ) * (unsigned long )nmatch);
        }
      } else
#line 1578
      if ((dfa___0->nodes + cur_node)->opt_subexp) {
#line 1578
        if ((prev_idx_match + reg_num___0)->rm_so != -1) {
          {
#line 1585
          memcpy((void */* __restrict  */)pmatch, (void const   */* __restrict  */)prev_idx_match,
                 sizeof(regmatch_t ) * (unsigned long )nmatch);
          }
        } else {
#line 1589
          (pmatch + reg_num___0)->rm_eo = cur_idx;
        }
      } else {
#line 1589
        (pmatch + reg_num___0)->rm_eo = cur_idx;
      }
    }
  }
#line 1593
  return;
}
}
#line 1618 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) 
{ 
  reg_errcode_t err___0 ;
  int null_cnt ;
  int str_idx ;
  re_node_set cur_dest ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  void *__cil_tmp11 ;

  {
  {
#line 1623
  null_cnt = 0;
#line 1624
  str_idx = sctx->last_str_idx;
#line 1633
  err___0 = re_node_set_init_1(& cur_dest, sctx->last_node);
#line 1634
  tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1634
  if (tmp___1) {
#line 1635
    return (err___0);
  }
  {
#line 1636
  err___0 = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1637
  tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1637
  if (tmp___2) {
#line 1638
    goto free_return;
  }
  {
#line 1641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1641
    if (! (str_idx > 0)) {
#line 1641
      goto while_break;
    }
#line 1644
    if ((unsigned long )*(sctx->sifted_states + str_idx) == (unsigned long )((void *)0)) {
#line 1644
      null_cnt ++;
    } else {
#line 1644
      null_cnt = 0;
    }
#line 1645
    if (null_cnt > (int )mctx->max_mb_elem_len) {
      {
#line 1647
      memset((void *)sctx->sifted_states, '\000', sizeof(re_dfastate_t *) * (unsigned long )str_idx);
#line 1649
      free((void *)cur_dest.elems);
      }
#line 1650
      return ((reg_errcode_t )0);
    }
#line 1652
    cur_dest.nelem = 0;
#line 1653
    str_idx --;
#line 1655
    if (*(mctx->state_log + str_idx)) {
      {
#line 1657
      err___0 = build_sifted_states(mctx, sctx, str_idx, & cur_dest);
#line 1658
      tmp___3 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1658
      if (tmp___3) {
#line 1659
        goto free_return;
      }
    }
    {
#line 1666
    err___0 = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1667
    tmp___4 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 1667
    if (tmp___4) {
#line 1668
      goto free_return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1670
  err___0 = (reg_errcode_t )0;
  free_return: 
  {
#line 1672
  free((void *)cur_dest.elems);
  }
#line 1673
  return (err___0);
}
}
#line 1676 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         int str_idx , re_node_set *cur_dest ) 
{ 
  re_dfa_t const   *dfa___0 ;
  re_node_set const   *cur_src ;
  int i___0 ;
  int prev_node ;
  int naccepted ;
  int ret ;
  int tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int to_idx ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 1681
  dfa___0 = (re_dfa_t const   *)mctx->dfa;
#line 1682
  cur_src = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->non_eps_nodes);
#line 1692
  i___0 = 0;
  {
#line 1692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1692
    if (! (i___0 < (int )cur_src->nelem)) {
#line 1692
      goto while_break;
    }
#line 1694
    prev_node = *(cur_src->elems + i___0);
#line 1695
    naccepted = 0;
#line 1704
    if ((dfa___0->nodes + prev_node)->accept_mb) {
      {
#line 1705
      naccepted = sift_states_iter_mb(mctx, sctx, prev_node, str_idx, sctx->last_str_idx);
      }
    }
#line 1711
    if (! naccepted) {
      {
#line 1711
      tmp___1 = check_node_accept(mctx, (re_token_t const   *)(dfa___0->nodes + prev_node),
                                  str_idx);
      }
#line 1711
      if (tmp___1) {
#line 1711
        if ((unsigned long )*(sctx->sifted_states + (str_idx + 1)) != (unsigned long )((void *)0)) {
          {
#line 1711
          tmp___2 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + 1)))->nodes),
                                         *(dfa___0->nexts + prev_node));
          }
#line 1711
          if (tmp___2) {
#line 1715
            naccepted = 1;
          }
        }
      }
    }
#line 1717
    if (naccepted == 0) {
#line 1718
      goto __Cont;
    }
#line 1720
    if (sctx->limits.nelem) {
      {
#line 1722
      to_idx = str_idx + naccepted;
#line 1723
      tmp___3 = check_dst_limits(mctx, & sctx->limits, *(dfa___0->nexts + prev_node),
                                 to_idx, prev_node, str_idx);
      }
#line 1723
      if (tmp___3) {
#line 1726
        goto __Cont;
      }
    }
    {
#line 1728
    ret = re_node_set_insert(cur_dest, prev_node);
#line 1729
    tmp___4 = __builtin_expect((long )(ret == -1), 0L);
    }
#line 1729
    if (tmp___4) {
#line 1730
      return ((reg_errcode_t )12);
    }
    __Cont: /* CIL Label */ 
#line 1692
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1733
  return ((reg_errcode_t )0);
}
}
#line 1738 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t clean_state_log_if_needed(re_match_context_t *mctx , int next_state_log_idx ) 
{ 
  int top ;
  reg_errcode_t err___0 ;
  long tmp___1 ;

  {
#line 1742
  top = mctx->state_log_top;
#line 1744
  if (next_state_log_idx >= mctx->input.bufs_len) {
#line 1744
    if (mctx->input.bufs_len < mctx->input.len) {
#line 1744
      goto _L;
    } else {
#line 1744
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1744
  if (next_state_log_idx >= mctx->input.valid_len) {
#line 1744
    if (mctx->input.valid_len < mctx->input.len) {
      _L: /* CIL Label */ 
      {
#line 1750
      err___0 = extend_buffers(mctx, next_state_log_idx + 1);
#line 1751
      tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1751
      if (tmp___1) {
#line 1752
        return (err___0);
      }
    }
  }
#line 1755
  if (top < next_state_log_idx) {
    {
#line 1757
    memset((void *)((mctx->state_log + top) + 1), '\000', sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top));
#line 1759
    mctx->state_log_top = next_state_log_idx;
    }
  }
#line 1761
  return ((reg_errcode_t )0);
}
}
#line 1764 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa___0 , re_dfastate_t **dst ,
                                       re_dfastate_t **src , int num ) 
{ 
  int st_idx ;
  reg_errcode_t err___0 ;
  re_node_set merged_set ;
  long tmp___1 ;
  long tmp___2 ;
  void *__cil_tmp10 ;

  {
#line 1771
  st_idx = 0;
  {
#line 1771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1771
    if (! (st_idx < num)) {
#line 1771
      goto while_break;
    }
#line 1773
    if ((unsigned long )*(dst + st_idx) == (unsigned long )((void *)0)) {
#line 1774
      *(dst + st_idx) = *(src + st_idx);
    } else
#line 1775
    if ((unsigned long )*(src + st_idx) != (unsigned long )((void *)0)) {
      {
#line 1778
      err___0 = re_node_set_init_union(& merged_set, (re_node_set const   *)(& (*(dst + st_idx))->nodes),
                                       (re_node_set const   *)(& (*(src + st_idx))->nodes));
#line 1780
      tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1780
      if (tmp___1) {
#line 1781
        return (err___0);
      }
      {
#line 1782
      *(dst + st_idx) = re_acquire_state(& err___0, dfa___0, (re_node_set const   *)(& merged_set));
#line 1783
      free((void *)merged_set.elems);
#line 1784
      tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1784
      if (tmp___2) {
#line 1785
        return (err___0);
      }
    }
#line 1771
    st_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1788
  return ((reg_errcode_t )0);
}
}
#line 1791 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             int str_idx , re_node_set *dest_nodes ) 
{ 
  re_dfa_t const   *dfa___0 ;
  reg_errcode_t err___0 ;
  re_node_set const   *candidates ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 1797
  dfa___0 = (re_dfa_t const   *)mctx->dfa;
#line 1798
  err___0 = (reg_errcode_t )0;
#line 1800
  if ((unsigned long )*(mctx->state_log + str_idx) == (unsigned long )((void *)0)) {
#line 1800
    candidates = (re_node_set const   *)((void *)0);
  } else {
#line 1800
    candidates = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->nodes);
  }
#line 1803
  if (dest_nodes->nelem == 0) {
#line 1804
    *(sctx->sifted_states + str_idx) = (re_dfastate_t *)((void *)0);
  } else {
#line 1807
    if (candidates) {
      {
#line 1811
      err___0 = add_epsilon_src_nodes(dfa___0, dest_nodes, candidates);
#line 1812
      tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1812
      if (tmp___1) {
#line 1813
        return (err___0);
      }
#line 1816
      if (sctx->limits.nelem) {
        {
#line 1818
        err___0 = check_subexp_limits(dfa___0, dest_nodes, candidates, & sctx->limits,
                                      (struct re_backref_cache_entry *)mctx->bkref_ents,
                                      str_idx);
#line 1820
        tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 1820
        if (tmp___2) {
#line 1821
          return (err___0);
        }
      }
    }
    {
#line 1825
    *(sctx->sifted_states + str_idx) = re_acquire_state(& err___0, dfa___0, (re_node_set const   *)dest_nodes);
#line 1826
    tmp___3 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 1826
    if (tmp___3) {
#line 1827
      return (err___0);
    }
  }
#line 1830
  if (candidates) {
#line 1830
    if ((*(mctx->state_log + str_idx))->has_backref) {
      {
#line 1832
      err___0 = sift_states_bkref(mctx, sctx, str_idx, candidates);
#line 1833
      tmp___4 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1833
      if (tmp___4) {
#line 1834
        return (err___0);
      }
    }
  }
#line 1836
  return ((reg_errcode_t )0);
}
}
#line 1839 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa___0 , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  reg_errcode_t err___0 ;
  int i___0 ;
  re_dfastate_t *state___2 ;
  re_dfastate_t *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  reg_errcode_t tmp___5 ;

  {
  {
#line 1844
  err___0 = (reg_errcode_t )0;
#line 1847
  tmp___1 = re_acquire_state(& err___0, dfa___0, (re_node_set const   *)dest_nodes);
#line 1847
  state___2 = tmp___1;
#line 1848
  tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 1848
  if (tmp___2) {
#line 1849
    return (err___0);
  }
#line 1851
  if (! state___2->inveclosure.alloc) {
    {
#line 1853
    err___0 = re_node_set_alloc(& state___2->inveclosure, dest_nodes->nelem);
#line 1854
    tmp___3 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 1854
    if (tmp___3) {
#line 1855
      return ((reg_errcode_t )12);
    }
#line 1856
    i___0 = 0;
    {
#line 1856
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1856
      if (! (i___0 < dest_nodes->nelem)) {
#line 1856
        goto while_break;
      }
      {
#line 1858
      err___0 = re_node_set_merge(& state___2->inveclosure, (re_node_set const   *)(dfa___0->inveclosures + *(dest_nodes->elems + i___0)));
#line 1860
      tmp___4 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 1860
      if (tmp___4) {
#line 1861
        return ((reg_errcode_t )12);
      }
#line 1856
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1864
  tmp___5 = re_node_set_add_intersect(dest_nodes, candidates, (re_node_set const   *)(& state___2->inveclosure));
  }
#line 1864
  return (tmp___5);
}
}
#line 1868 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t sub_epsilon_src_nodes(re_dfa_t const   *dfa___0 , int node ,
                                           re_node_set *dest_nodes , re_node_set const   *candidates ) 
{ 
  int ecl_idx ;
  reg_errcode_t err___0 ;
  re_node_set *inv_eclosure ;
  re_node_set except_nodes ;
  int cur_node ;
  int edst1 ;
  int edst2 ;
  int tmp___1 ;
  long tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  int __attribute__((__pure__))  tmp___4 ;
  int __attribute__((__pure__))  tmp___5 ;
  int __attribute__((__pure__))  tmp___6 ;
  int cur_node___0 ;
  int idx___3 ;
  int __attribute__((__pure__))  tmp___7 ;
  int __attribute__((__pure__))  tmp___8 ;
  void *__cil_tmp22 ;

  {
  {
#line 1875
  inv_eclosure = (re_node_set *)(dfa___0->inveclosures + node);
#line 1877
  memset((void *)(& except_nodes), '\000', sizeof(re_node_set ));
#line 1878
  ecl_idx = 0;
  }
  {
#line 1878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1878
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1878
      goto while_break;
    }
#line 1880
    cur_node = *(inv_eclosure->elems + ecl_idx);
#line 1881
    if (cur_node == node) {
#line 1882
      goto __Cont;
    }
#line 1883
    if ((unsigned int )(dfa___0->nodes + cur_node)->type & 8U) {
#line 1885
      edst1 = *((dfa___0->edests + cur_node)->elems + 0);
#line 1886
      if ((dfa___0->edests + cur_node)->nelem > 1) {
#line 1886
        tmp___1 = *((dfa___0->edests + cur_node)->elems + 1);
      } else {
#line 1886
        tmp___1 = -1;
      }
      {
#line 1886
      edst2 = tmp___1;
#line 1888
      tmp___3 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst1);
      }
#line 1888
      if (tmp___3) {
        _L___0: /* CIL Label */ 
#line 1888
        if (edst2 > 0) {
          {
#line 1888
          tmp___5 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst2);
          }
#line 1888
          if (! tmp___5) {
            {
#line 1888
            tmp___6 = re_node_set_contains((re_node_set const   *)dest_nodes, edst2);
            }
#line 1888
            if (tmp___6) {
              _L: /* CIL Label */ 
              {
#line 1894
              err___0 = re_node_set_add_intersect(& except_nodes, candidates, (re_node_set const   *)(dfa___0->inveclosures + cur_node));
#line 1896
              tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
              }
#line 1896
              if (tmp___2) {
                {
#line 1898
                free((void *)except_nodes.elems);
                }
#line 1899
                return (err___0);
              }
            }
          }
        }
      } else {
        {
#line 1888
        tmp___4 = re_node_set_contains((re_node_set const   *)dest_nodes, edst1);
        }
#line 1888
        if (tmp___4) {
#line 1888
          goto _L;
        } else {
#line 1888
          goto _L___0;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1878
    ecl_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1904
  ecl_idx = 0;
  {
#line 1904
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1904
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1904
      goto while_break___0;
    }
    {
#line 1906
    cur_node___0 = *(inv_eclosure->elems + ecl_idx);
#line 1907
    tmp___8 = re_node_set_contains((re_node_set const   *)(& except_nodes), cur_node___0);
    }
#line 1907
    if (! tmp___8) {
      {
#line 1909
      tmp___7 = re_node_set_contains((re_node_set const   *)dest_nodes, cur_node___0);
#line 1909
      idx___3 = (int )(tmp___7 - (int __attribute__((__pure__))  )1);
#line 1910
      re_node_set_remove_at(dest_nodes, idx___3);
      }
    }
#line 1904
    ecl_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1913
  free((void *)except_nodes.elems);
  }
#line 1914
  return ((reg_errcode_t )0);
}
}
#line 1917 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int check_dst_limits(re_match_context_t const   *mctx , re_node_set *limits ,
                            int dst_node , int dst_idx , int src_node , int src_idx ) 
{ 
  re_dfa_t const   *dfa___0 ;
  int lim_idx ;
  int src_pos ;
  int dst_pos ;
  int dst_bkref_idx ;
  int tmp___1 ;
  int src_bkref_idx ;
  int tmp___2 ;
  int subexp_idx ;
  struct re_backref_cache_entry *ent ;

  {
  {
#line 1922
  dfa___0 = (re_dfa_t const   *)mctx->dfa;
#line 1925
  tmp___1 = search_cur_bkref_entry(mctx, dst_idx);
#line 1925
  dst_bkref_idx = tmp___1;
#line 1926
  tmp___2 = search_cur_bkref_entry(mctx, src_idx);
#line 1926
  src_bkref_idx = tmp___2;
#line 1927
  lim_idx = 0;
  }
  {
#line 1927
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1927
    if (! (lim_idx < limits->nelem)) {
#line 1927
      goto while_break;
    }
    {
#line 1931
    ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + *(limits->elems + lim_idx));
#line 1932
    subexp_idx = (dfa___0->nodes + ent->node)->opr.idx;
#line 1934
    dst_pos = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        dst_node, dst_idx, dst_bkref_idx);
#line 1937
    src_pos = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        src_node, src_idx, src_bkref_idx);
    }
#line 1945
    if (! (src_pos == dst_pos)) {
#line 1948
      return (1);
    }
#line 1927
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1950
  return (0);
}
}
#line 1953 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       int subexp_idx , int from_node , int bkref_idx ) 
{ 
  re_dfa_t const   *dfa___0 ;
  re_node_set const   *eclosures ;
  int node_idx ;
  int node ;
  struct re_backref_cache_entry *ent ;
  int dst ;
  int cpos ;
  struct re_backref_cache_entry *tmp___1 ;
  int tmp___2 ;

  {
#line 1958
  dfa___0 = (re_dfa_t const   *)mctx->dfa;
#line 1959
  eclosures = (re_node_set const   *)(dfa___0->eclosures + from_node);
#line 1964
  node_idx = 0;
  {
#line 1964
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1964
    if (! (node_idx < (int )eclosures->nelem)) {
#line 1964
      goto while_break;
    }
#line 1966
    node = *(eclosures->elems + node_idx);
    {
#line 1969
    if ((unsigned int )(dfa___0->nodes + node)->type == 4U) {
#line 1969
      goto case_4;
    }
#line 2016
    if ((unsigned int )(dfa___0->nodes + node)->type == 8U) {
#line 2016
      goto case_8;
    }
#line 2021
    if ((unsigned int )(dfa___0->nodes + node)->type == 9U) {
#line 2021
      goto case_9;
    }
#line 2026
    goto switch_default;
    case_4: /* CIL Label */ 
#line 1970
    if (bkref_idx != -1) {
#line 1972
      ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + bkref_idx);
      {
#line 1973
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1977
        if (ent->node != node) {
#line 1978
          goto __Cont;
        }
#line 1980
        if ((unsigned long )subexp_idx < sizeof(bitset_word_t ) * 8UL) {
#line 1980
          if (! ((unsigned long )ent->eps_reachable_subexps_map & (1UL << subexp_idx))) {
#line 1983
            goto __Cont;
          }
        }
#line 1991
        dst = *((dfa___0->edests + node)->elems + 0);
#line 1992
        if (dst == from_node) {
#line 1994
          if (boundaries & 1) {
#line 1995
            return (-1);
          } else {
#line 1997
            return (0);
          }
        }
        {
#line 2000
        cpos = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, dst, bkref_idx);
        }
#line 2003
        if (cpos == -1) {
#line 2004
          return (-1);
        }
#line 2005
        if (cpos == 0) {
#line 2005
          if (boundaries & 2) {
#line 2006
            return (0);
          }
        }
#line 2008
        if ((unsigned long )subexp_idx < sizeof(bitset_word_t ) * 8UL) {
#line 2009
          ent->eps_reachable_subexps_map = (unsigned short )((unsigned long )ent->eps_reachable_subexps_map & ~ (1UL << subexp_idx));
        }
        __Cont: /* CIL Label */ 
#line 1973
        tmp___1 = ent;
#line 1973
        ent ++;
#line 1973
        if (! tmp___1->more) {
#line 1973
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2014
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2017
    if (boundaries & 1) {
#line 2017
      if (subexp_idx == (dfa___0->nodes + node)->opr.idx) {
#line 2018
        return (-1);
      }
    }
#line 2019
    goto switch_break;
    case_9: /* CIL Label */ 
#line 2022
    if (boundaries & 2) {
#line 2022
      if (subexp_idx == (dfa___0->nodes + node)->opr.idx) {
#line 2023
        return (0);
      }
    }
#line 2024
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2027
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1964
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2031
  if (boundaries & 2) {
#line 2031
    tmp___2 = 1;
  } else {
#line 2031
    tmp___2 = 0;
  }
#line 2031
  return (tmp___2);
}
}
#line 2034 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , int limit ,
                                     int subexp_idx , int from_node , int str_idx ,
                                     int bkref_idx ) 
{ 
  struct re_backref_cache_entry *lim ;
  int boundaries ;
  int tmp___1 ;

  {
#line 2040
  lim = (struct re_backref_cache_entry *)(mctx->bkref_ents + limit);
#line 2044
  if (str_idx < lim->subexp_from) {
#line 2045
    return (-1);
  }
#line 2047
  if (lim->subexp_to < str_idx) {
#line 2048
    return (1);
  }
#line 2051
  boundaries = str_idx == lim->subexp_from;
#line 2052
  boundaries |= (str_idx == lim->subexp_to) << 1;
#line 2053
  if (boundaries == 0) {
#line 2054
    return (0);
  }
  {
#line 2057
  tmp___1 = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, from_node, bkref_idx);
  }
#line 2057
  return (tmp___1);
}
}
#line 2064 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa___0 , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         int str_idx ) 
{ 
  reg_errcode_t err___0 ;
  int node_idx ;
  int lim_idx ;
  int subexp_idx ;
  struct re_backref_cache_entry *ent ;
  int ops_node ;
  int cls_node ;
  int node ;
  re_token_type_t type ;
  long tmp___1 ;
  int node___0 ;
  long tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  int __attribute__((__pure__))  tmp___4 ;
  int node___1 ;
  re_token_type_t type___0 ;
  long tmp___5 ;

  {
#line 2073
  lim_idx = 0;
  {
#line 2073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2073
    if (! (lim_idx < limits->nelem)) {
#line 2073
      goto while_break;
    }
#line 2077
    ent = bkref_ents + *(limits->elems + lim_idx);
#line 2079
    if (str_idx <= ent->subexp_from) {
#line 2080
      goto __Cont;
    } else
#line 2079
    if (ent->str_idx < str_idx) {
#line 2080
      goto __Cont;
    }
#line 2082
    subexp_idx = (dfa___0->nodes + ent->node)->opr.idx;
#line 2083
    if (ent->subexp_to == str_idx) {
#line 2085
      ops_node = -1;
#line 2086
      cls_node = -1;
#line 2087
      node_idx = 0;
      {
#line 2087
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2087
        if (! (node_idx < dest_nodes->nelem)) {
#line 2087
          goto while_break___0;
        }
#line 2089
        node = *(dest_nodes->elems + node_idx);
#line 2090
        type = (dfa___0->nodes + node)->type;
#line 2091
        if ((unsigned int )type == 8U) {
#line 2091
          if (subexp_idx == (dfa___0->nodes + node)->opr.idx) {
#line 2093
            ops_node = node;
          } else {
#line 2091
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2094
        if ((unsigned int )type == 9U) {
#line 2094
          if (subexp_idx == (dfa___0->nodes + node)->opr.idx) {
#line 2096
            cls_node = node;
          }
        }
#line 2087
        node_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2101
      if (ops_node >= 0) {
        {
#line 2103
        err___0 = sub_epsilon_src_nodes(dfa___0, ops_node, dest_nodes, candidates);
#line 2105
        tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 2105
        if (tmp___1) {
#line 2106
          return (err___0);
        }
      }
#line 2110
      if (cls_node >= 0) {
#line 2111
        node_idx = 0;
        {
#line 2111
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2111
          if (! (node_idx < dest_nodes->nelem)) {
#line 2111
            goto while_break___1;
          }
          {
#line 2113
          node___0 = *(dest_nodes->elems + node_idx);
#line 2114
          tmp___3 = re_node_set_contains((re_node_set const   *)(dfa___0->inveclosures + node___0),
                                         cls_node);
          }
#line 2114
          if (! tmp___3) {
            {
#line 2114
            tmp___4 = re_node_set_contains((re_node_set const   *)(dfa___0->eclosures + node___0),
                                           cls_node);
            }
#line 2114
            if (! tmp___4) {
              {
#line 2121
              err___0 = sub_epsilon_src_nodes(dfa___0, node___0, dest_nodes, candidates);
#line 2123
              tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
              }
#line 2123
              if (tmp___2) {
#line 2124
                return (err___0);
              }
#line 2125
              node_idx --;
            }
          }
#line 2111
          node_idx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 2131
      node_idx = 0;
      {
#line 2131
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2131
        if (! (node_idx < dest_nodes->nelem)) {
#line 2131
          goto while_break___2;
        }
#line 2133
        node___1 = *(dest_nodes->elems + node_idx);
#line 2134
        type___0 = (dfa___0->nodes + node___1)->type;
#line 2135
        if ((unsigned int )type___0 == 9U) {
#line 2135
          goto _L___0;
        } else
#line 2135
        if ((unsigned int )type___0 == 8U) {
          _L___0: /* CIL Label */ 
#line 2137
          if (subexp_idx != (dfa___0->nodes + node___1)->opr.idx) {
#line 2138
            goto __Cont___0;
          }
          {
#line 2141
          err___0 = sub_epsilon_src_nodes(dfa___0, node___1, dest_nodes, candidates);
#line 2143
          tmp___5 = __builtin_expect((long )((int )err___0 != 0), 0L);
          }
#line 2143
          if (tmp___5) {
#line 2144
            return (err___0);
          }
        }
        __Cont___0: /* CIL Label */ 
#line 2131
        node_idx ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2073
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2149
  return ((reg_errcode_t )0);
}
}
#line 2152 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       int str_idx , re_node_set const   *candidates ) 
{ 
  re_dfa_t const   *dfa___0 ;
  reg_errcode_t err___0 ;
  int node_idx ;
  int node ;
  re_sift_context_t local_sctx ;
  int first_idx ;
  int tmp___1 ;
  int enabled_idx ;
  re_token_type_t type ;
  struct re_backref_cache_entry *entry ;
  int subexp_len ;
  int to_idx ;
  int dst_node ;
  int ret ;
  re_dfastate_t *cur_state ;
  int __attribute__((__pure__))  tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int __attribute__((__pure__))  tmp___8 ;
  struct re_backref_cache_entry *tmp___9 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;

  {
  {
#line 2157
  dfa___0 = (re_dfa_t const   *)mctx->dfa;
#line 2161
  tmp___1 = search_cur_bkref_entry(mctx, str_idx);
#line 2161
  first_idx = tmp___1;
  }
#line 2163
  if (first_idx == -1) {
#line 2164
    return ((reg_errcode_t )0);
  }
#line 2166
  local_sctx.sifted_states = (re_dfastate_t **)((void *)0);
#line 2168
  node_idx = 0;
  {
#line 2168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2168
    if (! (node_idx < (int )candidates->nelem)) {
#line 2168
      goto while_break;
    }
#line 2173
    node = *(candidates->elems + node_idx);
#line 2174
    type = (dfa___0->nodes + node)->type;
#line 2176
    if (node == sctx->last_node) {
#line 2176
      if (str_idx == sctx->last_str_idx) {
#line 2177
        goto __Cont;
      }
    }
#line 2178
    if ((unsigned int )type != 4U) {
#line 2179
      goto __Cont;
    }
#line 2181
    entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + first_idx);
#line 2182
    enabled_idx = first_idx;
    {
#line 2183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2191
      if (entry->node != node) {
#line 2192
        goto __Cont___0;
      }
#line 2193
      subexp_len = entry->subexp_to - entry->subexp_from;
#line 2194
      to_idx = str_idx + subexp_len;
#line 2195
      if (subexp_len) {
#line 2195
        dst_node = *(dfa___0->nexts + node);
      } else {
#line 2195
        dst_node = *((dfa___0->edests + node)->elems + 0);
      }
#line 2198
      if (to_idx > sctx->last_str_idx) {
#line 2203
        goto __Cont___0;
      } else
#line 2198
      if ((unsigned long )*(sctx->sifted_states + to_idx) == (unsigned long )((void *)0)) {
#line 2203
        goto __Cont___0;
      } else
#line 2198
      if ((unsigned long )*(sctx->sifted_states + to_idx) != (unsigned long )((void *)0)) {
        {
#line 2198
        tmp___2 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + to_idx))->nodes),
                                       dst_node);
        }
#line 2198
        if (tmp___2) {
          {
#line 2198
          tmp___3 = check_dst_limits(mctx, & sctx->limits, node, str_idx, dst_node,
                                     to_idx);
          }
#line 2198
          if (tmp___3) {
#line 2203
            goto __Cont___0;
          }
        } else {
#line 2203
          goto __Cont___0;
        }
      } else {
#line 2203
        goto __Cont___0;
      }
#line 2205
      if ((unsigned long )local_sctx.sifted_states == (unsigned long )((void *)0)) {
        {
#line 2207
        local_sctx = *sctx;
#line 2208
        err___0 = re_node_set_init_copy(& local_sctx.limits, (re_node_set const   *)(& sctx->limits));
#line 2209
        tmp___4 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 2209
        if (tmp___4) {
#line 2210
          goto free_return;
        }
      }
      {
#line 2212
      local_sctx.last_node = node;
#line 2213
      local_sctx.last_str_idx = str_idx;
#line 2214
      ret = re_node_set_insert(& local_sctx.limits, enabled_idx);
#line 2215
      tmp___5 = __builtin_expect((long )(ret < 0), 0L);
      }
#line 2215
      if (tmp___5) {
#line 2217
        err___0 = (reg_errcode_t )12;
#line 2218
        goto free_return;
      }
      {
#line 2220
      cur_state = *(local_sctx.sifted_states + str_idx);
#line 2221
      err___0 = sift_states_backward(mctx, & local_sctx);
#line 2222
      tmp___6 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 2222
      if (tmp___6) {
#line 2223
        goto free_return;
      }
#line 2224
      if ((unsigned long )sctx->limited_states != (unsigned long )((void *)0)) {
        {
#line 2226
        err___0 = merge_state_array(dfa___0, sctx->limited_states, local_sctx.sifted_states,
                                    str_idx + 1);
#line 2229
        tmp___7 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 2229
        if (tmp___7) {
#line 2230
          goto free_return;
        }
      }
      {
#line 2232
      *(local_sctx.sifted_states + str_idx) = cur_state;
#line 2233
      tmp___8 = re_node_set_contains((re_node_set const   *)(& local_sctx.limits),
                                     enabled_idx);
#line 2233
      re_node_set_remove_at(& local_sctx.limits, (int )(tmp___8 - (int __attribute__((__pure__))  )1));
#line 2236
      entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + enabled_idx);
      }
      __Cont___0: /* CIL Label */ 
#line 2183
      enabled_idx ++;
#line 2183
      tmp___9 = entry;
#line 2183
      entry ++;
#line 2183
      if (! tmp___9->more) {
#line 2183
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2168
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2240
  err___0 = (reg_errcode_t )0;
  free_return: 
#line 2242
  if ((unsigned long )local_sctx.sifted_states != (unsigned long )((void *)0)) {
    {
#line 2244
    free((void *)local_sctx.limits.elems);
    }
  }
#line 2247
  return (err___0);
}
}
#line 2252 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               int node_idx , int str_idx , int max_str_idx ) 
{ 
  re_dfa_t const   *dfa___0 ;
  int naccepted ;
  int __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 2257
  dfa___0 = (re_dfa_t const   *)mctx->dfa;
#line 2260
  naccepted = check_node_accept_bytes(dfa___0, node_idx, & mctx->input, str_idx);
  }
#line 2261
  if (naccepted > 0) {
#line 2261
    if (str_idx + naccepted <= max_str_idx) {
#line 2261
      if ((unsigned long )*(sctx->sifted_states + (str_idx + naccepted)) != (unsigned long )((void *)0)) {
        {
#line 2261
        tmp___1 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + naccepted)))->nodes),
                                       *(dfa___0->nexts + node_idx));
        }
#line 2261
        if (! tmp___1) {
#line 2267
          naccepted = 0;
        }
      } else {
#line 2267
        naccepted = 0;
      }
    }
  }
#line 2270
  return (naccepted);
}
}
#line 2282 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static re_dfastate_t *transit_state(reg_errcode_t *err___0 , re_match_context_t *mctx ,
                                    re_dfastate_t *state___2 ) 
{ 
  re_dfastate_t **trtable ;
  unsigned char ch ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned int context ;
  long tmp___5 ;
  int tmp___6 ;

  {
  {
#line 2292
  tmp___2 = __builtin_expect((long )state___2->accept_mb, 0L);
  }
#line 2292
  if (tmp___2) {
    {
#line 2294
    *err___0 = transit_state_mb(mctx, state___2);
#line 2295
    tmp___1 = __builtin_expect((long )((int )*err___0 != 0), 0L);
    }
#line 2295
    if (tmp___1) {
#line 2296
      return ((re_dfastate_t *)((void *)0));
    }
  }
#line 2308
  tmp___3 = mctx->input.cur_idx;
#line 2308
  (mctx->input.cur_idx) ++;
#line 2308
  ch = *(mctx->input.mbs + tmp___3);
  {
#line 2309
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2311
    trtable = state___2->trtable;
#line 2312
    tmp___4 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
#line 2312
    if (tmp___4) {
#line 2313
      return (*(trtable + ch));
    }
    {
#line 2315
    trtable = state___2->word_trtable;
#line 2316
    tmp___5 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
#line 2316
    if (tmp___5) {
      {
#line 2319
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1,
                                     mctx->eflags);
      }
#line 2323
      if (context & 1U) {
#line 2324
        return (*(trtable + ((int )ch + 256)));
      } else {
#line 2326
        return (*(trtable + ch));
      }
    }
    {
#line 2329
    tmp___6 = build_trtable(mctx->dfa, state___2);
    }
#line 2329
    if (! tmp___6) {
#line 2331
      *err___0 = (reg_errcode_t )12;
#line 2332
      return ((re_dfastate_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2340 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err___0 , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) 
{ 
  re_dfa_t const   *dfa___0 ;
  int cur_idx ;
  re_dfastate_t *pstate ;
  unsigned int context ;
  re_node_set next_nodes ;
  re_node_set *log_nodes ;
  re_node_set *table_nodes ;
  long tmp___1 ;
  re_dfastate_t *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  void *__cil_tmp16 ;

  {
#line 2345
  dfa___0 = mctx->dfa;
#line 2346
  cur_idx = mctx->input.cur_idx;
#line 2348
  if (cur_idx > mctx->state_log_top) {
#line 2350
    *(mctx->state_log + cur_idx) = next_state;
#line 2351
    mctx->state_log_top = cur_idx;
  } else
#line 2353
  if ((unsigned long )*(mctx->state_log + cur_idx) == (unsigned long )((re_dfastate_t *)0)) {
#line 2355
    *(mctx->state_log + cur_idx) = next_state;
  } else {
#line 2361
    table_nodes = (re_node_set *)((void *)0);
#line 2366
    pstate = *(mctx->state_log + cur_idx);
#line 2367
    log_nodes = pstate->entrance_nodes;
#line 2368
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
#line 2370
      table_nodes = next_state->entrance_nodes;
#line 2371
      *err___0 = re_node_set_init_union(& next_nodes, (re_node_set const   *)table_nodes,
                                        (re_node_set const   *)log_nodes);
#line 2373
      tmp___1 = __builtin_expect((long )((int )*err___0 != 0), 0L);
      }
#line 2373
      if (tmp___1) {
#line 2374
        return ((re_dfastate_t *)((void *)0));
      }
    } else {
#line 2377
      next_nodes = *log_nodes;
    }
    {
#line 2381
    context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1,
                                   mctx->eflags);
#line 2384
    tmp___2 = re_acquire_state_context(err___0, dfa___0, (re_node_set const   *)(& next_nodes),
                                       context);
#line 2384
    *(mctx->state_log + cur_idx) = tmp___2;
#line 2384
    next_state = tmp___2;
    }
#line 2389
    if ((unsigned long )table_nodes != (unsigned long )((void *)0)) {
      {
#line 2390
      free((void *)next_nodes.elems);
      }
    }
  }
  {
#line 2393
  tmp___5 = __builtin_expect((long )dfa___0->nbackref, 0L);
  }
#line 2393
  if (tmp___5) {
#line 2393
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
#line 2398
      *err___0 = check_subexp_matching_top(mctx, & next_state->nodes, cur_idx);
#line 2400
      tmp___3 = __builtin_expect((long )((int )*err___0 != 0), 0L);
      }
#line 2400
      if (tmp___3) {
#line 2401
        return ((re_dfastate_t *)((void *)0));
      }
#line 2404
      if (next_state->has_backref) {
        {
#line 2406
        *err___0 = transit_state_bkref(mctx, (re_node_set const   *)(& next_state->nodes));
#line 2407
        tmp___4 = __builtin_expect((long )((int )*err___0 != 0), 0L);
        }
#line 2407
        if (tmp___4) {
#line 2408
          return ((re_dfastate_t *)((void *)0));
        }
#line 2409
        next_state = *(mctx->state_log + cur_idx);
      }
    }
  }
#line 2413
  return (next_state);
}
}
#line 2419 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static re_dfastate_t *find_recover_state(reg_errcode_t *err___0 , re_match_context_t *mctx ) 
{ 
  re_dfastate_t *cur_state ;
  int max ;
  int cur_str_idx ;

  {
  {
#line 2424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2426
    max = mctx->state_log_top;
#line 2427
    cur_str_idx = mctx->input.cur_idx;
    {
#line 2429
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2431
      cur_str_idx ++;
#line 2431
      if (cur_str_idx > max) {
#line 2432
        return ((re_dfastate_t *)((void *)0));
      }
#line 2433
      (mctx->input.cur_idx) ++;
#line 2429
      if (! ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0))) {
#line 2429
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2437
    cur_state = merge_state_with_log(err___0, mctx, (re_dfastate_t *)((void *)0));
    }
#line 2424
    if ((int )*err___0 == 0) {
#line 2424
      if (! ((unsigned long )cur_state == (unsigned long )((void *)0))) {
#line 2424
        goto while_break;
      }
    } else {
#line 2424
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2440
  return (cur_state);
}
}
#line 2450 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               int str_idx ) 
{ 
  re_dfa_t const   *dfa___0 ;
  int node_idx ;
  reg_errcode_t err___0 ;
  int node ;
  long tmp___1 ;

  {
#line 2455
  dfa___0 = mctx->dfa;
#line 2464
  node_idx = 0;
  {
#line 2464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2464
    if (! (node_idx < cur_nodes->nelem)) {
#line 2464
      goto while_break;
    }
#line 2466
    node = *(cur_nodes->elems + node_idx);
#line 2467
    if ((unsigned int )(dfa___0->nodes + node)->type == 8U) {
#line 2467
      if ((unsigned long )(dfa___0->nodes + node)->opr.idx < sizeof(bitset_word_t ) * 8UL) {
#line 2467
        if (dfa___0->used_bkref_map & (unsigned long const   )(1UL << (dfa___0->nodes + node)->opr.idx)) {
          {
#line 2472
          err___0 = match_ctx_add_subtop(mctx, node, str_idx);
#line 2473
          tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
          }
#line 2473
          if (tmp___1) {
#line 2474
            return (err___0);
          }
        }
      }
    }
#line 2464
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2477
  return ((reg_errcode_t )0);
}
}
#line 2523 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) 
{ 
  re_dfa_t const   *dfa___0 ;
  reg_errcode_t err___0 ;
  int i___0 ;
  re_node_set dest_nodes ;
  re_node_set *new_nodes ;
  int cur_node_idx ;
  int naccepted ;
  int dest_idx ;
  unsigned int context ;
  re_dfastate_t *dest_state ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  void *__cil_tmp17 ;

  {
#line 2527
  dfa___0 = mctx->dfa;
#line 2531
  i___0 = 0;
  {
#line 2531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2531
    if (! (i___0 < pstate->nodes.nelem)) {
#line 2531
      goto while_break;
    }
#line 2534
    cur_node_idx = *(pstate->nodes.elems + i___0);
#line 2539
    if (! (dfa___0->nodes + cur_node_idx)->accept_mb) {
#line 2540
      goto __Cont;
    }
#line 2542
    if ((dfa___0->nodes + cur_node_idx)->constraint) {
      {
#line 2544
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx,
                                     mctx->eflags);
      }
#line 2547
      if ((dfa___0->nodes + cur_node_idx)->constraint & 4U) {
#line 2547
        if (! (context & 1U)) {
#line 2549
          goto __Cont;
        } else {
#line 2547
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2547
      if ((dfa___0->nodes + cur_node_idx)->constraint & 8U) {
#line 2547
        if (context & 1U) {
#line 2549
          goto __Cont;
        } else {
#line 2547
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2547
      if ((dfa___0->nodes + cur_node_idx)->constraint & 32U) {
#line 2547
        if (! (context & (unsigned int )(1 << 1))) {
#line 2549
          goto __Cont;
        } else {
#line 2547
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2547
      if ((dfa___0->nodes + cur_node_idx)->constraint & 128U) {
#line 2547
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2549
          goto __Cont;
        }
      }
    }
    {
#line 2553
    naccepted = check_node_accept_bytes(dfa___0, cur_node_idx, (re_string_t const   *)(& mctx->input),
                                        mctx->input.cur_idx);
    }
#line 2555
    if (naccepted == 0) {
#line 2556
      goto __Cont;
    }
#line 2559
    dest_idx = mctx->input.cur_idx + naccepted;
#line 2560
    if (mctx->max_mb_elem_len < naccepted) {
#line 2560
      mctx->max_mb_elem_len = naccepted;
    } else {
#line 2560
      mctx->max_mb_elem_len = mctx->max_mb_elem_len;
    }
    {
#line 2562
    err___0 = clean_state_log_if_needed(mctx, dest_idx);
#line 2563
    tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 2563
    if (tmp___1) {
#line 2564
      return (err___0);
    }
#line 2568
    new_nodes = (re_node_set *)(dfa___0->eclosures + *(dfa___0->nexts + cur_node_idx));
#line 2570
    dest_state = *(mctx->state_log + dest_idx);
#line 2571
    if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
#line 2572
      dest_nodes = *new_nodes;
    } else {
      {
#line 2575
      err___0 = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                       (re_node_set const   *)new_nodes);
#line 2577
      tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 2577
      if (tmp___2) {
#line 2578
        return (err___0);
      }
    }
    {
#line 2580
    context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_idx - 1,
                                   mctx->eflags);
#line 2582
    *(mctx->state_log + dest_idx) = re_acquire_state_context(& err___0, dfa___0, (re_node_set const   *)(& dest_nodes),
                                                             context);
    }
#line 2584
    if ((unsigned long )dest_state != (unsigned long )((void *)0)) {
      {
#line 2585
      free((void *)dest_nodes.elems);
      }
    }
#line 2586
    if ((unsigned long )*(mctx->state_log + dest_idx) == (unsigned long )((void *)0)) {
#line 2586
      if ((int )err___0 != 0) {
#line 2586
        tmp___3 = 1;
      } else {
#line 2586
        tmp___3 = 0;
      }
    } else {
#line 2586
      tmp___3 = 0;
    }
    {
#line 2586
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 2586
    if (tmp___4) {
#line 2587
      return (err___0);
    }
    __Cont: /* CIL Label */ 
#line 2531
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2589
  return ((reg_errcode_t )0);
}
}
#line 2593 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) 
{ 
  re_dfa_t const   *dfa___0 ;
  reg_errcode_t err___0 ;
  int i___0 ;
  int cur_str_idx ;
  int dest_str_idx ;
  int prev_nelem ;
  int bkc_idx ;
  int node_idx ;
  unsigned int context ;
  re_token_t const   *node ;
  re_node_set *new_dest_nodes ;
  long tmp___1 ;
  int subexp_len ;
  re_dfastate_t *dest_state ;
  struct re_backref_cache_entry *bkref_ent ;
  int tmp___2 ;
  long tmp___3 ;
  re_node_set dest_nodes ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp26 ;

  {
#line 2597
  dfa___0 = mctx->dfa;
#line 2600
  cur_str_idx = mctx->input.cur_idx;
#line 2602
  i___0 = 0;
  {
#line 2602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2602
    if (! (i___0 < (int )nodes->nelem)) {
#line 2602
      goto while_break;
    }
#line 2605
    node_idx = *(nodes->elems + i___0);
#line 2607
    node = (re_token_t const   *)(dfa___0->nodes + node_idx);
#line 2611
    if ((unsigned int const   )node->type != 4U) {
#line 2612
      goto __Cont;
    }
#line 2614
    if (node->constraint) {
      {
#line 2616
      context = re_string_context_at((re_string_t const   *)(& mctx->input), cur_str_idx,
                                     mctx->eflags);
      }
#line 2618
      if (node->constraint & 4U) {
#line 2618
        if (! (context & 1U)) {
#line 2619
          goto __Cont;
        } else {
#line 2618
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2618
      if (node->constraint & 8U) {
#line 2618
        if (context & 1U) {
#line 2619
          goto __Cont;
        } else {
#line 2618
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2618
      if (node->constraint & 32U) {
#line 2618
        if (! (context & (unsigned int )(1 << 1))) {
#line 2619
          goto __Cont;
        } else {
#line 2618
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2618
      if (node->constraint & 128U) {
#line 2618
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2619
          goto __Cont;
        }
      }
    }
    {
#line 2624
    bkc_idx = mctx->nbkref_ents;
#line 2625
    err___0 = get_subexp(mctx, node_idx, cur_str_idx);
#line 2626
    tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 2626
    if (tmp___1) {
#line 2627
      goto free_return;
    }
    {
#line 2634
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2634
      if (! (bkc_idx < mctx->nbkref_ents)) {
#line 2634
        goto while_break___0;
      }
#line 2639
      bkref_ent = mctx->bkref_ents + bkc_idx;
#line 2640
      if (bkref_ent->node != node_idx) {
#line 2641
        goto __Cont___0;
      } else
#line 2640
      if (bkref_ent->str_idx != cur_str_idx) {
#line 2641
        goto __Cont___0;
      }
#line 2642
      subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
#line 2643
      if (subexp_len == 0) {
#line 2643
        new_dest_nodes = (re_node_set *)(dfa___0->eclosures + *((dfa___0->edests + node_idx)->elems + 0));
      } else {
#line 2643
        new_dest_nodes = (re_node_set *)(dfa___0->eclosures + *(dfa___0->nexts + node_idx));
      }
      {
#line 2646
      dest_str_idx = (cur_str_idx + bkref_ent->subexp_to) - bkref_ent->subexp_from;
#line 2648
      context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_str_idx - 1,
                                     mctx->eflags);
#line 2650
      dest_state = *(mctx->state_log + dest_str_idx);
      }
#line 2651
      if ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0)) {
#line 2651
        prev_nelem = 0;
      } else {
#line 2651
        prev_nelem = (*(mctx->state_log + cur_str_idx))->nodes.nelem;
      }
#line 2654
      if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
        {
#line 2656
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err___0, dfa___0,
                                                                     (re_node_set const   *)new_dest_nodes,
                                                                     context);
        }
#line 2659
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2659
          if ((int )err___0 != 0) {
#line 2659
            tmp___2 = 1;
          } else {
#line 2659
            tmp___2 = 0;
          }
        } else {
#line 2659
          tmp___2 = 0;
        }
        {
#line 2659
        tmp___3 = __builtin_expect((long )tmp___2, 0L);
        }
#line 2659
        if (tmp___3) {
#line 2661
          goto free_return;
        }
      } else {
        {
#line 2666
        err___0 = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                         (re_node_set const   *)new_dest_nodes);
#line 2669
        tmp___4 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 2669
        if (tmp___4) {
          {
#line 2671
          free((void *)dest_nodes.elems);
          }
#line 2672
          goto free_return;
        }
        {
#line 2674
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err___0, dfa___0,
                                                                     (re_node_set const   *)(& dest_nodes),
                                                                     context);
#line 2676
        free((void *)dest_nodes.elems);
        }
#line 2677
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2677
          if ((int )err___0 != 0) {
#line 2677
            tmp___5 = 1;
          } else {
#line 2677
            tmp___5 = 0;
          }
        } else {
#line 2677
          tmp___5 = 0;
        }
        {
#line 2677
        tmp___6 = __builtin_expect((long )tmp___5, 0L);
        }
#line 2677
        if (tmp___6) {
#line 2679
          goto free_return;
        }
      }
#line 2683
      if (subexp_len == 0) {
#line 2683
        if ((*(mctx->state_log + cur_str_idx))->nodes.nelem > prev_nelem) {
          {
#line 2686
          err___0 = check_subexp_matching_top(mctx, new_dest_nodes, cur_str_idx);
#line 2688
          tmp___7 = __builtin_expect((long )((int )err___0 != 0), 0L);
          }
#line 2688
          if (tmp___7) {
#line 2689
            goto free_return;
          }
          {
#line 2690
          err___0 = transit_state_bkref(mctx, (re_node_set const   *)new_dest_nodes);
#line 2691
          tmp___8 = __builtin_expect((long )((int )err___0 != 0), 0L);
          }
#line 2691
          if (tmp___8) {
#line 2692
            goto free_return;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 2634
      bkc_idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2602
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2696
  err___0 = (reg_errcode_t )0;
  free_return: 
#line 2698
  return (err___0);
}
}
#line 2707 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t get_subexp(re_match_context_t *mctx , int bkref_node , int bkref_str_idx ) 
{ 
  re_dfa_t const   *dfa___0 ;
  int subexp_num ;
  int sub_top_idx ;
  char const   *buf___7 ;
  int cache_idx ;
  int tmp___1 ;
  struct re_backref_cache_entry  const  *entry ;
  struct re_backref_cache_entry  const  *tmp___2 ;
  reg_errcode_t err___0 ;
  re_sub_match_top_t *sub_top ;
  re_sub_match_last_t *sub_last ;
  int sub_last_idx ;
  int sl_str ;
  int bkref_str_off ;
  int sl_str_diff ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int cls_node ;
  int sl_str_off ;
  re_node_set const   *nodes ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
  {
#line 2711
  dfa___0 = mctx->dfa;
#line 2713
  buf___7 = (char const   *)mctx->input.mbs;
#line 2715
  tmp___1 = search_cur_bkref_entry((re_match_context_t const   *)mctx, bkref_str_idx);
#line 2715
  cache_idx = tmp___1;
  }
#line 2716
  if (cache_idx != -1) {
#line 2718
    entry = (struct re_backref_cache_entry  const  *)(mctx->bkref_ents + cache_idx);
    {
#line 2720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2721
      if (entry->node == (int const   )bkref_node) {
#line 2722
        return ((reg_errcode_t )0);
      }
#line 2720
      tmp___2 = entry;
#line 2720
      entry ++;
#line 2720
      if (! tmp___2->more) {
#line 2720
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2726
  subexp_num = (dfa___0->nodes + bkref_node)->opr.idx;
#line 2729
  sub_top_idx = 0;
  {
#line 2729
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2729
    if (! (sub_top_idx < mctx->nsub_tops)) {
#line 2729
      goto while_break___0;
    }
#line 2732
    sub_top = *(mctx->sub_tops + sub_top_idx);
#line 2736
    if ((dfa___0->nodes + sub_top->node)->opr.idx != subexp_num) {
#line 2737
      goto __Cont;
    }
#line 2739
    sl_str = sub_top->str_idx;
#line 2740
    bkref_str_off = bkref_str_idx;
#line 2743
    sub_last_idx = 0;
    {
#line 2743
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2743
      if (! (sub_last_idx < sub_top->nlasts)) {
#line 2743
        goto while_break___1;
      }
#line 2746
      sub_last = *(sub_top->lasts + sub_last_idx);
#line 2747
      sl_str_diff = sub_last->str_idx - sl_str;
#line 2750
      if (sl_str_diff > 0) {
        {
#line 2752
        tmp___4 = __builtin_expect((long )(bkref_str_off + sl_str_diff > mctx->input.valid_len),
                                   0L);
        }
#line 2752
        if (tmp___4) {
#line 2755
          if (bkref_str_off + sl_str_diff > mctx->input.len) {
#line 2756
            goto while_break___1;
          }
          {
#line 2758
          err___0 = clean_state_log_if_needed(mctx, bkref_str_off + sl_str_diff);
#line 2761
          tmp___3 = __builtin_expect((long )((int )err___0 != 0), 0L);
          }
#line 2761
          if (tmp___3) {
#line 2762
            return (err___0);
          }
#line 2763
          buf___7 = (char const   *)mctx->input.mbs;
        }
        {
#line 2765
        tmp___5 = memcmp((void const   *)(buf___7 + bkref_str_off), (void const   *)(buf___7 + sl_str),
                         (size_t )sl_str_diff);
        }
#line 2765
        if (tmp___5 != 0) {
#line 2767
          goto while_break___1;
        }
      }
      {
#line 2769
      bkref_str_off += sl_str_diff;
#line 2770
      sl_str += sl_str_diff;
#line 2771
      err___0 = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                               bkref_node, bkref_str_idx);
#line 2776
      buf___7 = (char const   *)mctx->input.mbs;
      }
#line 2778
      if ((int )err___0 == 1) {
#line 2779
        goto __Cont___0;
      }
      {
#line 2780
      tmp___6 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 2780
      if (tmp___6) {
#line 2781
        return (err___0);
      }
      __Cont___0: /* CIL Label */ 
#line 2743
      sub_last_idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2784
    if (sub_last_idx < sub_top->nlasts) {
#line 2785
      goto __Cont;
    }
#line 2786
    if (sub_last_idx > 0) {
#line 2787
      sl_str ++;
    }
    {
#line 2789
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2789
      if (! (sl_str <= bkref_str_idx)) {
#line 2789
        goto while_break___2;
      }
#line 2793
      sl_str_off = sl_str - sub_top->str_idx;
#line 2796
      if (sl_str_off > 0) {
        {
#line 2798
        tmp___8 = __builtin_expect((long )(bkref_str_off >= mctx->input.valid_len),
                                   0L);
        }
#line 2798
        if (tmp___8) {
#line 2801
          if (bkref_str_off >= mctx->input.len) {
#line 2802
            goto while_break___2;
          }
          {
#line 2804
          err___0 = extend_buffers(mctx, bkref_str_off + 1);
#line 2805
          tmp___7 = __builtin_expect((long )((int )err___0 != 0), 0L);
          }
#line 2805
          if (tmp___7) {
#line 2806
            return (err___0);
          }
#line 2808
          buf___7 = (char const   *)mctx->input.mbs;
        }
#line 2810
        tmp___9 = bkref_str_off;
#line 2810
        bkref_str_off ++;
#line 2810
        if ((int const   )*(buf___7 + tmp___9) != (int const   )*(buf___7 + (sl_str - 1))) {
#line 2811
          goto while_break___2;
        }
      }
#line 2814
      if ((unsigned long )*(mctx->state_log + sl_str) == (unsigned long )((void *)0)) {
#line 2815
        goto __Cont___1;
      }
      {
#line 2817
      nodes = (re_node_set const   *)(& (*(mctx->state_log + sl_str))->nodes);
#line 2818
      cls_node = find_subexp_node(dfa___0, nodes, subexp_num, 9);
      }
#line 2820
      if (cls_node == -1) {
#line 2821
        goto __Cont___1;
      }
#line 2822
      if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
        {
#line 2824
        tmp___10 = calloc(sizeof(state_array_t ), (size_t )((sl_str - sub_top->str_idx) + 1));
#line 2824
        sub_top->path = (state_array_t *)tmp___10;
        }
#line 2826
        if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
#line 2827
          return ((reg_errcode_t )12);
        }
      }
      {
#line 2831
      err___0 = check_arrival(mctx, sub_top->path, sub_top->node, sub_top->str_idx,
                              cls_node, sl_str, 9);
      }
#line 2834
      if ((int )err___0 == 1) {
#line 2835
        goto __Cont___1;
      }
      {
#line 2836
      tmp___11 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 2836
      if (tmp___11) {
#line 2837
        return (err___0);
      }
      {
#line 2838
      sub_last = match_ctx_add_sublast(sub_top, cls_node, sl_str);
#line 2839
      tmp___12 = __builtin_expect((long )((unsigned long )sub_last == (unsigned long )((void *)0)),
                                  0L);
      }
#line 2839
      if (tmp___12) {
#line 2840
        return ((reg_errcode_t )12);
      }
      {
#line 2841
      err___0 = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                               bkref_node, bkref_str_idx);
      }
#line 2843
      if ((int )err___0 == 1) {

      }
      __Cont___1: /* CIL Label */ 
#line 2789
      sl_str ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2729
    sub_top_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2847
  return ((reg_errcode_t )0);
}
}
#line 2856 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , int bkref_node ,
                                    int bkref_str ) 
{ 
  reg_errcode_t err___0 ;
  int to_idx ;
  long tmp___1 ;
  reg_errcode_t tmp___2 ;

  {
  {
#line 2864
  err___0 = check_arrival(mctx, & sub_last->path, sub_last->node, sub_last->str_idx,
                          bkref_node, bkref_str, 8);
  }
#line 2867
  if ((int )err___0 != 0) {
#line 2868
    return (err___0);
  }
  {
#line 2869
  err___0 = match_ctx_add_entry(mctx, bkref_node, bkref_str, (int )sub_top->str_idx,
                                sub_last->str_idx);
#line 2871
  tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 2871
  if (tmp___1) {
#line 2872
    return (err___0);
  }
  {
#line 2873
  to_idx = (bkref_str + sub_last->str_idx) - (int )sub_top->str_idx;
#line 2874
  tmp___2 = clean_state_log_if_needed(mctx, to_idx);
  }
#line 2874
  return (tmp___2);
}
}
#line 2885 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int find_subexp_node(re_dfa_t const   *dfa___0 , re_node_set const   *nodes ,
                            int subexp_idx , int type ) 
{ 
  int cls_idx ;
  int cls_node ;
  re_token_t const   *node ;

  {
#line 2891
  cls_idx = 0;
  {
#line 2891
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2891
    if (! (cls_idx < (int )nodes->nelem)) {
#line 2891
      goto while_break;
    }
#line 2893
    cls_node = *(nodes->elems + cls_idx);
#line 2894
    node = (re_token_t const   *)(dfa___0->nodes + cls_node);
#line 2895
    if ((unsigned int const   )node->type == (unsigned int const   )type) {
#line 2895
      if (node->opr.idx == (int const   )subexp_idx) {
#line 2897
        return (cls_node);
      }
    }
#line 2891
    cls_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2899
  return (-1);
}
}
#line 2907 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   int top_node , int top_str , int last_node , int last_str ,
                                   int type ) 
{ 
  re_dfa_t const   *dfa___0 ;
  reg_errcode_t err___0 ;
  int subexp_num ;
  int backup_cur_idx ;
  int str_idx ;
  int null_cnt ;
  re_dfastate_t *cur_state ;
  re_node_set *cur_nodes ;
  re_node_set next_nodes ;
  re_dfastate_t **backup_state_log ;
  unsigned int context ;
  re_dfastate_t **new_array ;
  int old_alloc ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int __attribute__((__pure__))  tmp___16 ;
  void *__cil_tmp37 ;

  {
  {
#line 2912
  dfa___0 = mctx->dfa;
#line 2913
  err___0 = (reg_errcode_t )0;
#line 2915
  cur_state = (re_dfastate_t *)((void *)0);
#line 2920
  subexp_num = (dfa___0->nodes + top_node)->opr.idx;
#line 2922
  tmp___3 = __builtin_expect((long )(path->alloc < (last_str + mctx->max_mb_elem_len) + 1),
                             0L);
  }
#line 2922
  if (tmp___3) {
    {
#line 2925
    old_alloc = path->alloc;
#line 2926
    path->alloc += (last_str + mctx->max_mb_elem_len) + 1;
#line 2927
    tmp___1 = realloc((void *)path->array, (unsigned long )path->alloc * sizeof(re_dfastate_t *));
#line 2927
    new_array = (re_dfastate_t **)tmp___1;
#line 2928
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 2928
    if (tmp___2) {
#line 2930
      path->alloc = old_alloc;
#line 2931
      return ((reg_errcode_t )12);
    }
    {
#line 2933
    path->array = new_array;
#line 2934
    memset((void *)(new_array + old_alloc), '\000', sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc));
    }
  }
#line 2938
  if (path->next_idx) {
#line 2938
    str_idx = path->next_idx;
  } else {
#line 2938
    str_idx = top_str;
  }
  {
#line 2941
  backup_state_log = mctx->state_log;
#line 2942
  backup_cur_idx = mctx->input.cur_idx;
#line 2943
  mctx->state_log = path->array;
#line 2944
  mctx->input.cur_idx = str_idx;
#line 2947
  context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1,
                                 mctx->eflags);
  }
#line 2948
  if (str_idx == top_str) {
    {
#line 2950
    err___0 = re_node_set_init_1(& next_nodes, top_node);
#line 2951
    tmp___4 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 2951
    if (tmp___4) {
#line 2952
      return (err___0);
    }
    {
#line 2953
    err___0 = check_arrival_expand_ecl(dfa___0, & next_nodes, subexp_num, type);
#line 2954
    tmp___5 = __builtin_expect((long )((int )err___0 != 0), 0L);
    }
#line 2954
    if (tmp___5) {
      {
#line 2956
      free((void *)next_nodes.elems);
      }
#line 2957
      return (err___0);
    }
  } else {
#line 2962
    cur_state = *(mctx->state_log + str_idx);
#line 2963
    if (cur_state) {
#line 2963
      if (cur_state->has_backref) {
        {
#line 2965
        err___0 = re_node_set_init_copy(& next_nodes, (re_node_set const   *)(& cur_state->nodes));
#line 2966
        tmp___6 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 2966
        if (tmp___6) {
#line 2967
          return (err___0);
        }
      } else {
        {
#line 2970
        memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
#line 2970
      memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
      }
    }
  }
#line 2972
  if (str_idx == top_str) {
#line 2972
    goto _L;
  } else
#line 2972
  if (cur_state) {
#line 2972
    if (cur_state->has_backref) {
      _L: /* CIL Label */ 
#line 2974
      if (next_nodes.nelem) {
        {
#line 2976
        err___0 = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 2978
        tmp___7 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 2978
        if (tmp___7) {
          {
#line 2980
          free((void *)next_nodes.elems);
          }
#line 2981
          return (err___0);
        }
      }
      {
#line 2984
      cur_state = re_acquire_state_context(& err___0, dfa___0, (re_node_set const   *)(& next_nodes),
                                           context);
      }
#line 2985
      if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 2985
        if ((int )err___0 != 0) {
#line 2985
          tmp___8 = 1;
        } else {
#line 2985
          tmp___8 = 0;
        }
      } else {
#line 2985
        tmp___8 = 0;
      }
      {
#line 2985
      tmp___9 = __builtin_expect((long )tmp___8, 0L);
      }
#line 2985
      if (tmp___9) {
        {
#line 2987
        free((void *)next_nodes.elems);
        }
#line 2988
        return (err___0);
      }
#line 2990
      *(mctx->state_log + str_idx) = cur_state;
    }
  }
#line 2993
  null_cnt = 0;
  {
#line 2993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2993
    if (str_idx < last_str) {
#line 2993
      if (! (null_cnt <= mctx->max_mb_elem_len)) {
#line 2993
        goto while_break;
      }
    } else {
#line 2993
      goto while_break;
    }
#line 2995
    next_nodes.nelem = 0;
#line 2996
    if (*(mctx->state_log + (str_idx + 1))) {
      {
#line 2998
      err___0 = re_node_set_merge(& next_nodes, (re_node_set const   *)(& (*(mctx->state_log + (str_idx + 1)))->nodes));
#line 3000
      tmp___10 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 3000
      if (tmp___10) {
        {
#line 3002
        free((void *)next_nodes.elems);
        }
#line 3003
        return (err___0);
      }
    }
#line 3006
    if (cur_state) {
      {
#line 3008
      err___0 = check_arrival_add_next_nodes(mctx, str_idx, & cur_state->non_eps_nodes,
                                             & next_nodes);
#line 3011
      tmp___11 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 3011
      if (tmp___11) {
        {
#line 3013
        free((void *)next_nodes.elems);
        }
#line 3014
        return (err___0);
      }
    }
#line 3017
    str_idx ++;
#line 3018
    if (next_nodes.nelem) {
      {
#line 3020
      err___0 = check_arrival_expand_ecl(dfa___0, & next_nodes, subexp_num, type);
#line 3021
      tmp___12 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 3021
      if (tmp___12) {
        {
#line 3023
        free((void *)next_nodes.elems);
        }
#line 3024
        return (err___0);
      }
      {
#line 3026
      err___0 = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 3028
      tmp___13 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 3028
      if (tmp___13) {
        {
#line 3030
        free((void *)next_nodes.elems);
        }
#line 3031
        return (err___0);
      }
    }
    {
#line 3034
    context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1,
                                   mctx->eflags);
#line 3035
    cur_state = re_acquire_state_context(& err___0, dfa___0, (re_node_set const   *)(& next_nodes),
                                         context);
    }
#line 3036
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 3036
      if ((int )err___0 != 0) {
#line 3036
        tmp___14 = 1;
      } else {
#line 3036
        tmp___14 = 0;
      }
    } else {
#line 3036
      tmp___14 = 0;
    }
    {
#line 3036
    tmp___15 = __builtin_expect((long )tmp___14, 0L);
    }
#line 3036
    if (tmp___15) {
      {
#line 3038
      free((void *)next_nodes.elems);
      }
#line 3039
      return (err___0);
    }
#line 3041
    *(mctx->state_log + str_idx) = cur_state;
#line 3042
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 3042
      null_cnt ++;
    } else {
#line 3042
      null_cnt = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3044
  free((void *)next_nodes.elems);
  }
#line 3045
  if ((unsigned long )*(mctx->state_log + last_str) == (unsigned long )((void *)0)) {
#line 3045
    cur_nodes = (re_node_set *)((void *)0);
  } else {
#line 3045
    cur_nodes = & (*(mctx->state_log + last_str))->nodes;
  }
#line 3047
  path->next_idx = str_idx;
#line 3050
  mctx->state_log = backup_state_log;
#line 3051
  mctx->input.cur_idx = backup_cur_idx;
#line 3054
  if ((unsigned long )cur_nodes != (unsigned long )((void *)0)) {
    {
#line 3054
    tmp___16 = re_node_set_contains((re_node_set const   *)cur_nodes, last_node);
    }
#line 3054
    if (tmp___16) {
#line 3055
      return ((reg_errcode_t )0);
    }
  }
#line 3057
  return ((reg_errcode_t )1);
}
}
#line 3068 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , int str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) 
{ 
  re_dfa_t const   *dfa___0 ;
  int result ;
  int cur_idx ;
  reg_errcode_t err___0 ;
  re_node_set union_set ;
  int naccepted ;
  int cur_node ;
  re_dfastate_t *dest_state ;
  int next_node ;
  int next_idx ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp21 ;

  {
  {
#line 3073
  dfa___0 = mctx->dfa;
#line 3077
  err___0 = (reg_errcode_t )0;
#line 3080
  memset((void *)(& union_set), '\000', sizeof(re_node_set ));
#line 3081
  cur_idx = 0;
  }
  {
#line 3081
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3081
    if (! (cur_idx < cur_nodes->nelem)) {
#line 3081
      goto while_break;
    }
#line 3083
    naccepted = 0;
#line 3084
    cur_node = *(cur_nodes->elems + cur_idx);
#line 3091
    if ((dfa___0->nodes + cur_node)->accept_mb) {
      {
#line 3093
      naccepted = check_node_accept_bytes(dfa___0, cur_node, (re_string_t const   *)(& mctx->input),
                                          str_idx);
      }
#line 3095
      if (naccepted > 1) {
#line 3098
        next_node = *(dfa___0->nexts + cur_node);
#line 3099
        next_idx = str_idx + naccepted;
#line 3100
        dest_state = *(mctx->state_log + next_idx);
#line 3101
        union_set.nelem = 0;
#line 3102
        if (dest_state) {
          {
#line 3104
          err___0 = re_node_set_merge(& union_set, (re_node_set const   *)(& dest_state->nodes));
#line 3105
          tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
          }
#line 3105
          if (tmp___1) {
            {
#line 3107
            free((void *)union_set.elems);
            }
#line 3108
            return (err___0);
          }
        }
        {
#line 3111
        result = re_node_set_insert(& union_set, next_node);
#line 3112
        tmp___2 = __builtin_expect((long )(result < 0), 0L);
        }
#line 3112
        if (tmp___2) {
          {
#line 3114
          free((void *)union_set.elems);
          }
#line 3115
          return ((reg_errcode_t )12);
        }
        {
#line 3117
        *(mctx->state_log + next_idx) = re_acquire_state(& err___0, dfa___0, (re_node_set const   *)(& union_set));
        }
#line 3119
        if ((unsigned long )*(mctx->state_log + next_idx) == (unsigned long )((void *)0)) {
#line 3119
          if ((int )err___0 != 0) {
#line 3119
            tmp___3 = 1;
          } else {
#line 3119
            tmp___3 = 0;
          }
        } else {
#line 3119
          tmp___3 = 0;
        }
        {
#line 3119
        tmp___4 = __builtin_expect((long )tmp___3, 0L);
        }
#line 3119
        if (tmp___4) {
          {
#line 3122
          free((void *)union_set.elems);
          }
#line 3123
          return (err___0);
        }
      }
    }
#line 3128
    if (naccepted) {
#line 3128
      goto _L;
    } else {
      {
#line 3128
      tmp___6 = check_node_accept((re_match_context_t const   *)mctx, (re_token_t const   *)(dfa___0->nodes + cur_node),
                                  str_idx);
      }
#line 3128
      if (tmp___6) {
        _L: /* CIL Label */ 
        {
#line 3131
        result = re_node_set_insert(next_nodes, *(dfa___0->nexts + cur_node));
#line 3132
        tmp___5 = __builtin_expect((long )(result < 0), 0L);
        }
#line 3132
        if (tmp___5) {
          {
#line 3134
          free((void *)union_set.elems);
          }
#line 3135
          return ((reg_errcode_t )12);
        }
      }
    }
#line 3081
    cur_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3139
  free((void *)union_set.elems);
  }
#line 3140
  return ((reg_errcode_t )0);
}
}
#line 3149 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa___0 , re_node_set *cur_nodes ,
                                              int ex_subexp , int type ) 
{ 
  reg_errcode_t err___0 ;
  int idx___3 ;
  int outside_node ;
  re_node_set new_nodes ;
  long tmp___1 ;
  int cur_node ;
  re_node_set const   *eclosure ;
  long tmp___2 ;
  long tmp___3 ;
  void *__cil_tmp14 ;

  {
  {
#line 3160
  err___0 = re_node_set_alloc(& new_nodes, cur_nodes->nelem);
#line 3161
  tmp___1 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 3161
  if (tmp___1) {
#line 3162
    return (err___0);
  }
#line 3166
  idx___3 = 0;
  {
#line 3166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3166
    if (! (idx___3 < cur_nodes->nelem)) {
#line 3166
      goto while_break;
    }
    {
#line 3168
    cur_node = *(cur_nodes->elems + idx___3);
#line 3169
    eclosure = (re_node_set const   *)(dfa___0->eclosures + cur_node);
#line 3170
    outside_node = find_subexp_node(dfa___0, eclosure, ex_subexp, type);
    }
#line 3171
    if (outside_node == -1) {
      {
#line 3174
      err___0 = re_node_set_merge(& new_nodes, eclosure);
#line 3175
      tmp___2 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 3175
      if (tmp___2) {
        {
#line 3177
        free((void *)new_nodes.elems);
        }
#line 3178
        return (err___0);
      }
    } else {
      {
#line 3184
      err___0 = check_arrival_expand_ecl_sub(dfa___0, & new_nodes, cur_node, ex_subexp,
                                             type);
#line 3186
      tmp___3 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 3186
      if (tmp___3) {
        {
#line 3188
        free((void *)new_nodes.elems);
        }
#line 3189
        return (err___0);
      }
    }
#line 3166
    idx___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3193
  free((void *)cur_nodes->elems);
#line 3194
  *cur_nodes = new_nodes;
  }
#line 3195
  return ((reg_errcode_t )0);
}
}
#line 3202 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa___0 , re_node_set *dst_nodes ,
                                                  int target , int ex_subexp , int type ) 
{ 
  int cur_node ;
  int err___0 ;
  long tmp___1 ;
  long tmp___2 ;
  reg_errcode_t tmp___3 ;
  long tmp___4 ;
  int __attribute__((__pure__))  tmp___5 ;

  {
#line 3208
  cur_node = target;
  {
#line 3208
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3208
    tmp___5 = re_node_set_contains((re_node_set const   *)dst_nodes, cur_node);
    }
#line 3208
    if (tmp___5) {
#line 3208
      goto while_break;
    }
#line 3212
    if ((unsigned int )(dfa___0->nodes + cur_node)->type == (unsigned int )type) {
#line 3212
      if ((dfa___0->nodes + cur_node)->opr.idx == ex_subexp) {
#line 3215
        if (type == 9) {
          {
#line 3217
          err___0 = re_node_set_insert(dst_nodes, cur_node);
#line 3218
          tmp___1 = __builtin_expect((long )(err___0 == -1), 0L);
          }
#line 3218
          if (tmp___1) {
#line 3219
            return ((reg_errcode_t )12);
          }
        }
#line 3221
        goto while_break;
      }
    }
    {
#line 3223
    err___0 = re_node_set_insert(dst_nodes, cur_node);
#line 3224
    tmp___2 = __builtin_expect((long )(err___0 == -1), 0L);
    }
#line 3224
    if (tmp___2) {
#line 3225
      return ((reg_errcode_t )12);
    }
#line 3226
    if ((dfa___0->edests + cur_node)->nelem == 0) {
#line 3227
      goto while_break;
    }
#line 3228
    if ((dfa___0->edests + cur_node)->nelem == 2) {
      {
#line 3230
      tmp___3 = check_arrival_expand_ecl_sub(dfa___0, dst_nodes, *((dfa___0->edests + cur_node)->elems + 1),
                                             ex_subexp, type);
#line 3230
      err___0 = (int )tmp___3;
#line 3233
      tmp___4 = __builtin_expect((long )(err___0 != 0), 0L);
      }
#line 3233
      if (tmp___4) {
#line 3234
        return ((reg_errcode_t )err___0);
      }
    }
#line 3236
    cur_node = *((dfa___0->edests + cur_node)->elems + 0);
  }
  while_break: /* CIL Label */ ;
  }
#line 3238
  return ((reg_errcode_t )0);
}
}
#line 3246 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        int cur_str , int subexp_num , int type ) 
{ 
  re_dfa_t const   *dfa___0 ;
  reg_errcode_t err___0 ;
  int cache_idx_start ;
  int tmp___1 ;
  struct re_backref_cache_entry *ent ;
  int to_idx ;
  int next_node ;
  int __attribute__((__pure__))  tmp___2 ;
  re_node_set new_dests ;
  reg_errcode_t err2 ;
  reg_errcode_t err3 ;
  int __attribute__((__pure__))  tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  re_node_set union_set ;
  int ret ;
  int __attribute__((__pure__))  tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  struct re_backref_cache_entry *tmp___13 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;

  {
  {
#line 3251
  dfa___0 = mctx->dfa;
#line 3253
  tmp___1 = search_cur_bkref_entry((re_match_context_t const   *)mctx, cur_str);
#line 3253
  cache_idx_start = tmp___1;
  }
#line 3256
  if (cache_idx_start == -1) {
#line 3257
    return ((reg_errcode_t )0);
  }
  restart: 
#line 3260
  ent = mctx->bkref_ents + cache_idx_start;
  {
#line 3261
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3266
    tmp___2 = re_node_set_contains((re_node_set const   *)cur_nodes, ent->node);
    }
#line 3266
    if (! tmp___2) {
#line 3267
      goto __Cont;
    }
#line 3269
    to_idx = (cur_str + ent->subexp_to) - ent->subexp_from;
#line 3272
    if (to_idx == cur_str) {
      {
#line 3278
      next_node = *((dfa___0->edests + ent->node)->elems + 0);
#line 3279
      tmp___3 = re_node_set_contains((re_node_set const   *)cur_nodes, next_node);
      }
#line 3279
      if (tmp___3) {
#line 3280
        goto __Cont;
      }
      {
#line 3281
      err___0 = re_node_set_init_1(& new_dests, next_node);
#line 3282
      err2 = check_arrival_expand_ecl(dfa___0, & new_dests, subexp_num, type);
#line 3283
      err3 = re_node_set_merge(cur_nodes, (re_node_set const   *)(& new_dests));
#line 3284
      free((void *)new_dests.elems);
      }
#line 3285
      if ((int )err___0 != 0) {
#line 3285
        tmp___5 = 1;
      } else
#line 3285
      if ((int )err2 != 0) {
#line 3285
        tmp___5 = 1;
      } else
#line 3285
      if ((int )err3 != 0) {
#line 3285
        tmp___5 = 1;
      } else {
#line 3285
        tmp___5 = 0;
      }
      {
#line 3285
      tmp___6 = __builtin_expect((long )tmp___5, 0L);
      }
#line 3285
      if (tmp___6) {
#line 3288
        if ((int )err___0 != 0) {
#line 3288
          err___0 = err___0;
        } else {
#line 3288
          if ((int )err2 != 0) {
#line 3288
            tmp___4 = (int )err2;
          } else {
#line 3288
            tmp___4 = (int )err3;
          }
#line 3288
          err___0 = (reg_errcode_t )tmp___4;
        }
#line 3290
        return (err___0);
      }
#line 3293
      goto restart;
    } else {
#line 3298
      next_node = *(dfa___0->nexts + ent->node);
#line 3299
      if (*(mctx->state_log + to_idx)) {
        {
#line 3302
        tmp___7 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes),
                                       next_node);
        }
#line 3302
        if (tmp___7) {
#line 3304
          goto __Cont;
        }
        {
#line 3305
        err___0 = re_node_set_init_copy(& union_set, (re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes));
#line 3307
        ret = re_node_set_insert(& union_set, next_node);
        }
#line 3308
        if ((int )err___0 != 0) {
#line 3308
          tmp___8 = 1;
        } else
#line 3308
        if (ret < 0) {
#line 3308
          tmp___8 = 1;
        } else {
#line 3308
          tmp___8 = 0;
        }
        {
#line 3308
        tmp___9 = __builtin_expect((long )tmp___8, 0L);
        }
#line 3308
        if (tmp___9) {
          {
#line 3310
          free((void *)union_set.elems);
          }
#line 3311
          if ((int )err___0 != 0) {
#line 3311
            err___0 = err___0;
          } else {
#line 3311
            err___0 = (reg_errcode_t )12;
          }
#line 3312
          return (err___0);
        }
      } else {
        {
#line 3317
        err___0 = re_node_set_init_1(& union_set, next_node);
#line 3318
        tmp___10 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 3318
        if (tmp___10) {
#line 3319
          return (err___0);
        }
      }
      {
#line 3321
      *(mctx->state_log + to_idx) = re_acquire_state(& err___0, dfa___0, (re_node_set const   *)(& union_set));
#line 3322
      free((void *)union_set.elems);
      }
#line 3323
      if ((unsigned long )*(mctx->state_log + to_idx) == (unsigned long )((void *)0)) {
#line 3323
        if ((int )err___0 != 0) {
#line 3323
          tmp___11 = 1;
        } else {
#line 3323
          tmp___11 = 0;
        }
      } else {
#line 3323
        tmp___11 = 0;
      }
      {
#line 3323
      tmp___12 = __builtin_expect((long )tmp___11, 0L);
      }
#line 3323
      if (tmp___12) {
#line 3325
        return (err___0);
      }
    }
    __Cont: /* CIL Label */ 
#line 3261
    tmp___13 = ent;
#line 3261
    ent ++;
#line 3261
    if (! tmp___13->more) {
#line 3261
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3329
  return ((reg_errcode_t )0);
}
}
#line 3335 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int build_trtable(re_dfa_t const   *dfa___0 , re_dfastate_t *state___2 ) 
{ 
  reg_errcode_t err___0 ;
  int i___0 ;
  int j ;
  int ch ;
  int need_word_trtable ;
  bitset_word_t elem ;
  bitset_word_t mask ;
  _Bool dests_node_malloced ;
  _Bool dest_states_malloced ;
  int ndests ;
  re_dfastate_t **trtable ;
  re_dfastate_t **dest_states ;
  re_dfastate_t **dest_states_word ;
  re_dfastate_t **dest_states_nl ;
  re_node_set follows ;
  re_node_set *dests_node ;
  bitset_t *dests_ch ;
  bitset_t acceptable ;
  struct dests_alloc *dests_alloc ;
  void *tmp___1 ;
  long tmp___2 ;
  struct re_dfastate_t **tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  int next_node ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  struct re_dfastate_t **tmp___18 ;
  void *tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  struct re_dfastate_t **tmp___22 ;
  void *tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;

  {
  {
#line 3340
  need_word_trtable = 0;
#line 3342
  dests_node_malloced = (_Bool)0;
#line 3343
  dest_states_malloced = (_Bool)0;
#line 3346
  dest_states = (re_dfastate_t **)((void *)0);
#line 3367
  tmp___1 = malloc(sizeof(struct dests_alloc ));
#line 3367
  dests_alloc = (struct dests_alloc *)tmp___1;
#line 3368
  tmp___2 = __builtin_expect((long )((unsigned long )dests_alloc == (unsigned long )((void *)0)),
                             0L);
  }
#line 3368
  if (tmp___2) {
#line 3369
    return (0);
  }
  {
#line 3370
  dests_node_malloced = (_Bool)1;
#line 3372
  dests_node = dests_alloc->dests_node;
#line 3373
  dests_ch = dests_alloc->dests_ch;
#line 3376
  tmp___3 = (struct re_dfastate_t **)((void *)0);
#line 3376
  state___2->trtable = tmp___3;
#line 3376
  state___2->word_trtable = tmp___3;
#line 3380
  ndests = group_nodes_into_DFAstates(dfa___0, (re_dfastate_t const   *)state___2,
                                      dests_node, dests_ch);
#line 3381
  tmp___6 = __builtin_expect((long )(ndests <= 0), 0L);
  }
#line 3381
  if (tmp___6) {
#line 3383
    if (dests_node_malloced) {
      {
#line 3384
      free((void *)dests_alloc);
      }
    }
#line 3386
    if (ndests == 0) {
      {
#line 3388
      tmp___4 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3388
      state___2->trtable = (re_dfastate_t **)tmp___4;
#line 3390
      tmp___5 = __builtin_expect((long )((unsigned long )state___2->trtable == (unsigned long )((void *)0)),
                                 0L);
      }
#line 3390
      if (tmp___5) {
#line 3391
        return (0);
      }
#line 3392
      return (1);
    }
#line 3394
    return (0);
  }
  {
#line 3397
  err___0 = re_node_set_alloc(& follows, ndests + 1);
#line 3398
  tmp___7 = __builtin_expect((long )((int )err___0 != 0), 0L);
  }
#line 3398
  if (tmp___7) {
#line 3399
    goto out_free;
  }
  {
#line 3402
  tmp___8 = __builtin_expect((long )((0xffffffffffffffffUL - (sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL) / (3UL * sizeof(re_dfastate_t *)) < (unsigned long )ndests),
                             0L);
  }
#line 3402
  if (tmp___8) {
#line 3406
    goto out_free;
  }
  {
#line 3416
  tmp___9 = malloc((unsigned long )(ndests * 3) * sizeof(re_dfastate_t *));
#line 3416
  dest_states = (re_dfastate_t **)tmp___9;
#line 3418
  tmp___10 = __builtin_expect((long )((unsigned long )dest_states == (unsigned long )((void *)0)),
                              0L);
  }
#line 3418
  if (tmp___10) {
    out_free: 
#line 3421
    if (dest_states_malloced) {
      {
#line 3422
      free((void *)dest_states);
      }
    }
    {
#line 3423
    free((void *)follows.elems);
#line 3424
    i___0 = 0;
    }
    {
#line 3424
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3424
      if (! (i___0 < ndests)) {
#line 3424
        goto while_break;
      }
      {
#line 3425
      free((void *)(dests_node + i___0)->elems);
#line 3424
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3426
    if (dests_node_malloced) {
      {
#line 3427
      free((void *)dests_alloc);
      }
    }
#line 3428
    return (0);
  }
  {
#line 3430
  dest_states_malloced = (_Bool)1;
#line 3432
  dest_states_word = dest_states + ndests;
#line 3433
  dest_states_nl = dest_states_word + ndests;
#line 3434
  memset((void *)(acceptable), '\000', sizeof(bitset_t ));
#line 3437
  i___0 = 0;
  }
  {
#line 3437
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3437
    if (! (i___0 < ndests)) {
#line 3437
      goto while_break___0;
    }
#line 3440
    follows.nelem = 0;
#line 3442
    j = 0;
    {
#line 3442
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3442
      if (! (j < (dests_node + i___0)->nelem)) {
#line 3442
        goto while_break___1;
      }
#line 3444
      next_node = *(dfa___0->nexts + *((dests_node + i___0)->elems + j));
#line 3445
      if (next_node != -1) {
        {
#line 3447
        err___0 = re_node_set_merge(& follows, (re_node_set const   *)(dfa___0->eclosures + next_node));
#line 3448
        tmp___11 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 3448
        if (tmp___11) {
#line 3449
          goto out_free;
        }
      }
#line 3442
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3452
    *(dest_states + i___0) = re_acquire_state_context(& err___0, dfa___0, (re_node_set const   *)(& follows),
                                                      0U);
    }
#line 3453
    if ((unsigned long )*(dest_states + i___0) == (unsigned long )((void *)0)) {
#line 3453
      if ((int )err___0 != 0) {
#line 3453
        tmp___12 = 1;
      } else {
#line 3453
        tmp___12 = 0;
      }
    } else {
#line 3453
      tmp___12 = 0;
    }
    {
#line 3453
    tmp___13 = __builtin_expect((long )tmp___12, 0L);
    }
#line 3453
    if (tmp___13) {
#line 3454
      goto out_free;
    }
#line 3457
    if ((*(dest_states + i___0))->has_constraint) {
      {
#line 3459
      *(dest_states_word + i___0) = re_acquire_state_context(& err___0, dfa___0, (re_node_set const   *)(& follows),
                                                             1U);
      }
#line 3461
      if ((unsigned long )*(dest_states_word + i___0) == (unsigned long )((void *)0)) {
#line 3461
        if ((int )err___0 != 0) {
#line 3461
          tmp___14 = 1;
        } else {
#line 3461
          tmp___14 = 0;
        }
      } else {
#line 3461
        tmp___14 = 0;
      }
      {
#line 3461
      tmp___15 = __builtin_expect((long )tmp___14, 0L);
      }
#line 3461
      if (tmp___15) {
#line 3462
        goto out_free;
      }
#line 3464
      if ((unsigned long )*(dest_states + i___0) != (unsigned long )*(dest_states_word + i___0)) {
#line 3464
        if (dfa___0->mb_cur_max > 1) {
#line 3465
          need_word_trtable = 1;
        }
      }
      {
#line 3467
      *(dest_states_nl + i___0) = re_acquire_state_context(& err___0, dfa___0, (re_node_set const   *)(& follows),
                                                           (unsigned int )(1 << 1));
      }
#line 3469
      if ((unsigned long )*(dest_states_nl + i___0) == (unsigned long )((void *)0)) {
#line 3469
        if ((int )err___0 != 0) {
#line 3469
          tmp___16 = 1;
        } else {
#line 3469
          tmp___16 = 0;
        }
      } else {
#line 3469
        tmp___16 = 0;
      }
      {
#line 3469
      tmp___17 = __builtin_expect((long )tmp___16, 0L);
      }
#line 3469
      if (tmp___17) {
#line 3470
        goto out_free;
      }
    } else {
#line 3474
      *(dest_states_word + i___0) = *(dest_states + i___0);
#line 3475
      *(dest_states_nl + i___0) = *(dest_states + i___0);
    }
    {
#line 3477
    bitset_merge((bitset_word_t *)(acceptable), (bitset_word_t */* const  */)(*(dests_ch + i___0)));
#line 3437
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3480
  tmp___26 = __builtin_expect((long )need_word_trtable, 0L);
  }
#line 3480
  if (tmp___26) {
    {
#line 3517
    tmp___23 = calloc(sizeof(re_dfastate_t *), (size_t )512);
#line 3517
    tmp___22 = (re_dfastate_t **)tmp___23;
#line 3517
    state___2->word_trtable = tmp___22;
#line 3517
    trtable = tmp___22;
#line 3519
    tmp___24 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
#line 3519
    if (tmp___24) {
#line 3520
      goto out_free;
    }
#line 3523
    i___0 = 0;
    {
#line 3523
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3523
      if (! ((unsigned long )i___0 < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 3523
        goto while_break___2;
      }
#line 3524
      ch = (int )((unsigned long )i___0 * (sizeof(bitset_word_t ) * 8UL));
#line 3524
      elem = acceptable[i___0];
#line 3524
      mask = (bitset_word_t )1;
      {
#line 3524
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3524
        if (! elem) {
#line 3524
          goto while_break___3;
        }
        {
#line 3527
        tmp___25 = __builtin_expect((long )(elem & 1UL), 0L);
        }
#line 3527
        if (tmp___25) {
#line 3531
          j = 0;
          {
#line 3531
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3531
            if (! (((*(dests_ch + j))[i___0] & mask) == 0UL)) {
#line 3531
              goto while_break___4;
            }
#line 3531
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 3535
          *(trtable + ch) = *(dest_states + j);
#line 3536
          *(trtable + (ch + 256)) = *(dest_states_word + j);
        }
#line 3524
        mask <<= 1;
#line 3524
        elem >>= 1;
#line 3524
        ch ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3523
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 3486
    tmp___19 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3486
    tmp___18 = (re_dfastate_t **)tmp___19;
#line 3486
    state___2->trtable = tmp___18;
#line 3486
    trtable = tmp___18;
#line 3488
    tmp___20 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
#line 3488
    if (tmp___20) {
#line 3489
      goto out_free;
    }
#line 3492
    i___0 = 0;
    {
#line 3492
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3492
      if (! ((unsigned long )i___0 < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 3492
        goto while_break___5;
      }
#line 3493
      ch = (int )((unsigned long )i___0 * (sizeof(bitset_word_t ) * 8UL));
#line 3493
      elem = acceptable[i___0];
#line 3493
      mask = (bitset_word_t )1;
      {
#line 3493
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3493
        if (! elem) {
#line 3493
          goto while_break___6;
        }
        {
#line 3496
        tmp___21 = __builtin_expect((long )(elem & 1UL), 0L);
        }
#line 3496
        if (tmp___21) {
#line 3500
          j = 0;
          {
#line 3500
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 3500
            if (! (((*(dests_ch + j))[i___0] & mask) == 0UL)) {
#line 3500
              goto while_break___7;
            }
#line 3500
            j ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 3504
          if (dfa___0->word_char[i___0] & mask) {
#line 3505
            *(trtable + ch) = *(dest_states_word + j);
          } else {
#line 3507
            *(trtable + ch) = *(dest_states + j);
          }
        }
#line 3493
        mask <<= 1;
#line 3493
        elem >>= 1;
#line 3493
        ch ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 3492
      i___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 3541
  if (acceptable[10UL / (sizeof(bitset_word_t ) * 8UL)] & (1UL << 10UL % (sizeof(bitset_word_t ) * 8UL))) {
#line 3544
    j = 0;
    {
#line 3544
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 3544
      if (! (j < ndests)) {
#line 3544
        goto while_break___8;
      }
#line 3545
      if ((*(dests_ch + j))[10UL / (sizeof(bitset_word_t ) * 8UL)] & (1UL << 10UL % (sizeof(bitset_word_t ) * 8UL))) {
#line 3548
        *(trtable + '\n') = *(dest_states_nl + j);
#line 3549
        if (need_word_trtable) {
#line 3550
          *(trtable + 266) = *(dest_states_nl + j);
        }
#line 3553
        goto while_break___8;
      }
#line 3544
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 3557
  if (dest_states_malloced) {
    {
#line 3558
    free((void *)dest_states);
    }
  }
  {
#line 3560
  free((void *)follows.elems);
#line 3561
  i___0 = 0;
  }
  {
#line 3561
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 3561
    if (! (i___0 < ndests)) {
#line 3561
      goto while_break___9;
    }
    {
#line 3562
    free((void *)(dests_node + i___0)->elems);
#line 3561
    i___0 ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 3564
  if (dests_node_malloced) {
    {
#line 3565
    free((void *)dests_alloc);
    }
  }
#line 3567
  return (1);
}
}
#line 3575 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int group_nodes_into_DFAstates(re_dfa_t const   *dfa___0 , re_dfastate_t const   *state___2 ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) 
{ 
  reg_errcode_t err___0 ;
  int result ;
  int i___0 ;
  int j ;
  int k ;
  int ndests ;
  bitset_t accepts ;
  re_node_set const   *cur_nodes ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  _Bool accepts_newline ;
  bitset_word_t any_set ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  bitset_word_t any_set___0 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  bitset_t intersec ;
  bitset_t remains ;
  bitset_word_t has_intersec ;
  bitset_word_t not_subset ;
  bitset_word_t not_consumed ;
  bitset_word_t tmp___5 ;
  bitset_word_t tmp___6 ;
  bitset_word_t tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
  {
#line 3585
  cur_nodes = & state___2->nodes;
#line 3586
  memset((void *)(accepts), '\000', sizeof(bitset_t ));
#line 3587
  ndests = 0;
#line 3590
  i___0 = 0;
  }
  {
#line 3590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3590
    if (! (i___0 < (int )cur_nodes->nelem)) {
#line 3590
      goto while_break;
    }
#line 3592
    node = dfa___0->nodes + *(cur_nodes->elems + i___0);
#line 3593
    type = node->type;
#line 3594
    constraint = node->constraint;
#line 3597
    if ((unsigned int )type == 1U) {
#line 3598
      accepts[(unsigned long )node->opr.c / (sizeof(bitset_word_t ) * 8UL)] |= 1UL << (unsigned long )node->opr.c % (sizeof(bitset_word_t ) * 8UL);
    } else
#line 3599
    if ((unsigned int )type == 3U) {
      {
#line 3601
      bitset_merge((bitset_word_t *)(accepts), (bitset_word_t */* const  */)node->opr.sbcset);
      }
    } else
#line 3603
    if ((unsigned int )type == 5U) {
#line 3606
      if (dfa___0->mb_cur_max > 1) {
        {
#line 3607
        bitset_merge((bitset_word_t *)(accepts), (bitset_word_t */* const  */)dfa___0->sb_char);
        }
      } else {
        {
#line 3610
        memset((void *)(accepts), '\377', sizeof(bitset_t ));
        }
      }
#line 3611
      if (! (dfa___0->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3612
        accepts[10UL / (sizeof(bitset_word_t ) * 8UL)] &= ~ (1UL << 10UL % (sizeof(bitset_word_t ) * 8UL));
      }
#line 3613
      if (dfa___0->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3614
        accepts[0UL / (sizeof(bitset_word_t ) * 8UL)] &= ~ (1UL << 0UL % (sizeof(bitset_word_t ) * 8UL));
      }
    } else
#line 3617
    if ((unsigned int )type == 7U) {
      {
#line 3619
      memset((void *)(accepts), '\377', sizeof(bitset_t ) / 2UL);
      }
#line 3620
      if (! (dfa___0->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3621
        accepts[10UL / (sizeof(bitset_word_t ) * 8UL)] &= ~ (1UL << 10UL % (sizeof(bitset_word_t ) * 8UL));
      }
#line 3622
      if (dfa___0->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3623
        accepts[0UL / (sizeof(bitset_word_t ) * 8UL)] &= ~ (1UL << 0UL % (sizeof(bitset_word_t ) * 8UL));
      }
    } else {
#line 3627
      goto __Cont;
    }
#line 3631
    if (constraint) {
#line 3633
      if (constraint & 32U) {
        {
#line 3635
        accepts_newline = (_Bool )(accepts[10UL / (sizeof(bitset_word_t ) * 8UL)] & (1UL << 10UL % (sizeof(bitset_word_t ) * 8UL)));
#line 3636
        memset((void *)(accepts), '\000', sizeof(bitset_t ));
        }
#line 3637
        if (accepts_newline) {
#line 3638
          accepts[10UL / (sizeof(bitset_word_t ) * 8UL)] |= 1UL << 10UL % (sizeof(bitset_word_t ) * 8UL);
        } else {
#line 3640
          goto __Cont;
        }
      }
#line 3642
      if (constraint & 128U) {
        {
#line 3644
        memset((void *)(accepts), '\000', sizeof(bitset_t ));
        }
#line 3645
        goto __Cont;
      }
#line 3648
      if (constraint & 4U) {
#line 3650
        any_set = (bitset_word_t )0;
#line 3651
        if ((unsigned int )type == 1U) {
#line 3651
          if (! node->word_char) {
            {
#line 3653
            memset((void *)(accepts), '\000', sizeof(bitset_t ));
            }
#line 3654
            goto __Cont;
          }
        }
#line 3657
        if (dfa___0->mb_cur_max > 1) {
#line 3658
          j = 0;
          {
#line 3658
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3658
            if (! ((unsigned long )j < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 3658
              goto while_break___0;
            }
#line 3659
            tmp___1 = accepts[j] & (dfa___0->word_char[j] | ~ *(dfa___0->sb_char + j));
#line 3659
            accepts[j] = tmp___1;
#line 3659
            any_set |= tmp___1;
#line 3658
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 3662
          j = 0;
          {
#line 3662
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3662
            if (! ((unsigned long )j < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 3662
              goto while_break___1;
            }
#line 3663
            tmp___2 = accepts[j] & dfa___0->word_char[j];
#line 3663
            accepts[j] = tmp___2;
#line 3663
            any_set |= tmp___2;
#line 3662
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 3664
        if (! any_set) {
#line 3665
          goto __Cont;
        }
      }
#line 3667
      if (constraint & 8U) {
#line 3669
        any_set___0 = (bitset_word_t )0;
#line 3670
        if ((unsigned int )type == 1U) {
#line 3670
          if (node->word_char) {
            {
#line 3672
            memset((void *)(accepts), '\000', sizeof(bitset_t ));
            }
#line 3673
            goto __Cont;
          }
        }
#line 3676
        if (dfa___0->mb_cur_max > 1) {
#line 3677
          j = 0;
          {
#line 3677
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3677
            if (! ((unsigned long )j < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 3677
              goto while_break___2;
            }
#line 3678
            tmp___3 = accepts[j] & ~ (dfa___0->word_char[j] & *(dfa___0->sb_char + j));
#line 3678
            accepts[j] = tmp___3;
#line 3678
            any_set___0 |= tmp___3;
#line 3677
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 3681
          j = 0;
          {
#line 3681
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3681
            if (! ((unsigned long )j < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 3681
              goto while_break___3;
            }
#line 3682
            tmp___4 = accepts[j] & ~ dfa___0->word_char[j];
#line 3682
            accepts[j] = tmp___4;
#line 3682
            any_set___0 |= tmp___4;
#line 3681
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 3683
        if (! any_set___0) {
#line 3684
          goto __Cont;
        }
      }
    }
#line 3690
    j = 0;
    {
#line 3690
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3690
      if (! (j < ndests)) {
#line 3690
        goto while_break___4;
      }
#line 3698
      if ((unsigned int )type == 1U) {
#line 3698
        if (! ((*(dests_ch + j))[(unsigned long )node->opr.c / (sizeof(bitset_word_t ) * 8UL)] & (1UL << (unsigned long )node->opr.c % (sizeof(bitset_word_t ) * 8UL)))) {
#line 3699
          goto __Cont___0;
        }
      }
#line 3702
      has_intersec = (bitset_word_t )0;
#line 3703
      k = 0;
      {
#line 3703
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3703
        if (! ((unsigned long )k < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 3703
          goto while_break___5;
        }
#line 3704
        tmp___5 = accepts[k] & (*(dests_ch + j))[k];
#line 3704
        intersec[k] = tmp___5;
#line 3704
        has_intersec |= tmp___5;
#line 3703
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3706
      if (! has_intersec) {
#line 3707
        goto __Cont___0;
      }
#line 3710
      not_consumed = (bitset_word_t )0;
#line 3710
      not_subset = not_consumed;
#line 3711
      k = 0;
      {
#line 3711
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3711
        if (! ((unsigned long )k < 256UL / (sizeof(bitset_word_t ) * 8UL))) {
#line 3711
          goto while_break___6;
        }
#line 3713
        tmp___6 = ~ accepts[k] & (*(dests_ch + j))[k];
#line 3713
        remains[k] = tmp___6;
#line 3713
        not_subset |= tmp___6;
#line 3714
        tmp___7 = accepts[k] & ~ (*(dests_ch + j))[k];
#line 3714
        accepts[k] = tmp___7;
#line 3714
        not_consumed |= tmp___7;
#line 3711
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 3719
      if (not_subset) {
        {
#line 3721
        memcpy((void */* __restrict  */)(*(dests_ch + ndests)), (void const   */* __restrict  */)(remains),
               sizeof(bitset_t ));
#line 3722
        memcpy((void */* __restrict  */)(*(dests_ch + j)), (void const   */* __restrict  */)(intersec),
               sizeof(bitset_t ));
#line 3723
        err___0 = re_node_set_init_copy(dests_node + ndests, (re_node_set const   *)(dests_node + j));
#line 3724
        tmp___8 = __builtin_expect((long )((int )err___0 != 0), 0L);
        }
#line 3724
        if (tmp___8) {
#line 3725
          goto error_return;
        }
#line 3726
        ndests ++;
      }
      {
#line 3730
      result = re_node_set_insert(dests_node + j, *(cur_nodes->elems + i___0));
#line 3731
      tmp___9 = __builtin_expect((long )(result < 0), 0L);
      }
#line 3731
      if (tmp___9) {
#line 3732
        goto error_return;
      }
#line 3735
      if (! not_consumed) {
#line 3736
        goto while_break___4;
      }
      __Cont___0: /* CIL Label */ 
#line 3690
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3739
    if (j == ndests) {
      {
#line 3741
      memcpy((void */* __restrict  */)(*(dests_ch + ndests)), (void const   */* __restrict  */)(accepts),
             sizeof(bitset_t ));
#line 3742
      err___0 = re_node_set_init_1(dests_node + ndests, *(cur_nodes->elems + i___0));
#line 3743
      tmp___10 = __builtin_expect((long )((int )err___0 != 0), 0L);
      }
#line 3743
      if (tmp___10) {
#line 3744
        goto error_return;
      }
      {
#line 3745
      ndests ++;
#line 3746
      memset((void *)(accepts), '\000', sizeof(bitset_t ));
      }
    }
    __Cont: /* CIL Label */ 
#line 3590
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3749
  return (ndests);
  error_return: 
#line 3751
  j = 0;
  {
#line 3751
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 3751
    if (! (j < ndests)) {
#line 3751
      goto while_break___7;
    }
    {
#line 3752
    free((void *)(dests_node + j)->elems);
#line 3751
    j ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 3753
  return (-1);
}
}
#line 3765 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int check_node_accept_bytes(re_dfa_t const   *dfa___0 , int node_idx , re_string_t const   *input ,
                                   int str_idx ) 
{ 
  re_token_t const   *node ;
  int char_len ;
  int elem_len ;
  int i___0 ;
  wint_t wc ;
  unsigned char c ;
  unsigned char d ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int __attribute__((__pure__))  tmp___4 ;
  int __attribute__((__pure__))  tmp___5 ;
  re_charset_t const   *cset ;
  int match_len ;
  wchar_t wc___0 ;
  wint_t __attribute__((__pure__))  tmp___6 ;
  wint_t __attribute__((__pure__))  tmp___7 ;
  wctype_t wt ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 3770
  node = (re_token_t const   *)(dfa___0->nodes + node_idx);
#line 3775
  tmp___3 = __builtin_expect((long )((unsigned int const   )node->type == 7U), 0L);
  }
#line 3775
  if (tmp___3) {
    {
#line 3777
    c = *(input->mbs + str_idx);
#line 3778
    tmp___1 = __builtin_expect((long )((int )c < 194), 1L);
    }
#line 3778
    if (tmp___1) {
#line 3779
      return (0);
    }
#line 3781
    if (str_idx + 2 > (int )input->len) {
#line 3782
      return (0);
    }
#line 3784
    d = *(input->mbs + (str_idx + 1));
#line 3785
    if ((int )c < 224) {
#line 3786
      if ((int )d < 128) {
#line 3786
        tmp___2 = 0;
      } else
#line 3786
      if ((int )d > 191) {
#line 3786
        tmp___2 = 0;
      } else {
#line 3786
        tmp___2 = 2;
      }
#line 3786
      return (tmp___2);
    } else
#line 3787
    if ((int )c < 240) {
#line 3789
      char_len = 3;
#line 3790
      if ((int )c == 224) {
#line 3790
        if ((int )d < 160) {
#line 3791
          return (0);
        }
      }
    } else
#line 3793
    if ((int )c < 248) {
#line 3795
      char_len = 4;
#line 3796
      if ((int )c == 240) {
#line 3796
        if ((int )d < 144) {
#line 3797
          return (0);
        }
      }
    } else
#line 3799
    if ((int )c < 252) {
#line 3801
      char_len = 5;
#line 3802
      if ((int )c == 248) {
#line 3802
        if ((int )d < 136) {
#line 3803
          return (0);
        }
      }
    } else
#line 3805
    if ((int )c < 254) {
#line 3807
      char_len = 6;
#line 3808
      if ((int )c == 252) {
#line 3808
        if ((int )d < 132) {
#line 3809
          return (0);
        }
      }
    } else {
#line 3812
      return (0);
    }
#line 3814
    if (str_idx + char_len > (int )input->len) {
#line 3815
      return (0);
    }
#line 3817
    i___0 = 1;
    {
#line 3817
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3817
      if (! (i___0 < char_len)) {
#line 3817
        goto while_break;
      }
#line 3819
      d = *(input->mbs + (str_idx + i___0));
#line 3820
      if ((int )d < 128) {
#line 3821
        return (0);
      } else
#line 3820
      if ((int )d > 191) {
#line 3821
        return (0);
      }
#line 3817
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 3823
    return (char_len);
  }
  {
#line 3826
  tmp___4 = re_string_char_size_at(input, str_idx);
#line 3826
  char_len = (int )tmp___4;
  }
#line 3827
  if ((unsigned int const   )node->type == 5U) {
#line 3829
    if (char_len <= 1) {
#line 3830
      return (0);
    }
#line 3834
    if (! (dfa___0->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3834
      if ((int )*(input->mbs + str_idx) == 10) {
#line 3838
        return (0);
      } else {
#line 3834
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3834
    if (dfa___0->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3834
      if ((int )*(input->mbs + str_idx) == 0) {
#line 3838
        return (0);
      }
    }
#line 3839
    return (char_len);
  }
  {
#line 3842
  tmp___5 = re_string_elem_size_at(input, str_idx);
#line 3842
  elem_len = (int )tmp___5;
#line 3843
  wc = btowc((int )*(input->mbs + str_idx));
  }
#line 3844
  if (elem_len <= 1) {
#line 3844
    if (char_len <= 1) {
#line 3844
      goto _L___0;
    } else {
#line 3844
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3844
  if (char_len == 0) {
    _L___0: /* CIL Label */ 
#line 3844
    if (wc != 4294967295U) {
#line 3844
      if (wc < 256U) {
#line 3845
        return (0);
      }
    }
  }
#line 3847
  if ((unsigned int const   )node->type == 6U) {
#line 3849
    cset = (re_charset_t const   *)node->opr.mbcset;
#line 3856
    match_len = 0;
#line 3857
    if (cset->nranges) {
      {
#line 3857
      tmp___6 = re_string_wchar_at(input, str_idx);
#line 3857
      tmp___7 = tmp___6;
      }
    } else
#line 3857
    if (cset->nchar_classes) {
      {
#line 3857
      tmp___6 = re_string_wchar_at(input, str_idx);
#line 3857
      tmp___7 = tmp___6;
      }
    } else
#line 3857
    if (cset->nmbchars) {
      {
#line 3857
      tmp___6 = re_string_wchar_at(input, str_idx);
#line 3857
      tmp___7 = tmp___6;
      }
    } else {
#line 3857
      tmp___7 = (wint_t __attribute__((__pure__))  )0;
    }
#line 3857
    wc___0 = (wchar_t )tmp___7;
#line 3861
    i___0 = 0;
    {
#line 3861
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3861
      if (! (i___0 < (int )cset->nmbchars)) {
#line 3861
        goto while_break___0;
      }
#line 3862
      if (wc___0 == *(cset->mbchars + i___0)) {
#line 3864
        match_len = char_len;
#line 3865
        goto check_node_accept_bytes_match;
      }
#line 3861
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3868
    i___0 = 0;
    {
#line 3868
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3868
      if (! (i___0 < (int )cset->nchar_classes)) {
#line 3868
        goto while_break___1;
      }
      {
#line 3870
      wt = *(cset->char_classes + i___0);
#line 3871
      tmp___8 = iswctype((wint_t )wc___0, wt);
      }
#line 3871
      if (tmp___8) {
#line 3873
        match_len = char_len;
#line 3874
        goto check_node_accept_bytes_match;
      }
#line 3868
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3974
    i___0 = 0;
    {
#line 3974
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3974
      if (! (i___0 < (int )cset->nranges)) {
#line 3974
        goto while_break___2;
      }
#line 3976
      if (*(cset->range_starts + i___0) <= wc___0) {
#line 3976
        if (wc___0 <= *(cset->range_ends + i___0)) {
#line 3979
          match_len = char_len;
#line 3980
          goto check_node_accept_bytes_match;
        }
      }
#line 3974
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    check_node_accept_bytes_match: 
#line 3985
    if (! cset->non_match) {
#line 3986
      return (match_len);
    } else
#line 3989
    if (match_len > 0) {
#line 3990
      return (0);
    } else {
#line 3992
      if (elem_len > char_len) {
#line 3992
        tmp___9 = elem_len;
      } else {
#line 3992
        tmp___9 = char_len;
      }
#line 3992
      return (tmp___9);
    }
  }
#line 3995
  return (0);
}
}
#line 4062 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                             int idx___3 ) 
{ 
  unsigned char ch ;
  unsigned int context ;
  unsigned int tmp___1 ;

  {
#line 4068
  ch = *(mctx->input.mbs + idx___3);
  {
#line 4071
  if ((unsigned int const   )node->type == 1U) {
#line 4071
    goto case_1;
  }
#line 4076
  if ((unsigned int const   )node->type == 3U) {
#line 4076
    goto case_3;
  }
#line 4082
  if ((unsigned int const   )node->type == 7U) {
#line 4082
    goto case_7;
  }
#line 4087
  if ((unsigned int const   )node->type == 5U) {
#line 4087
    goto case_5;
  }
#line 4093
  goto switch_default;
  case_1: /* CIL Label */ 
#line 4072
  if ((int const   )node->opr.c != (int const   )ch) {
#line 4073
    return (0);
  }
#line 4074
  goto switch_break;
  case_3: /* CIL Label */ 
#line 4077
  if (! (*(node->opr.sbcset + (unsigned long )ch / (sizeof(bitset_word_t ) * 8UL)) & (1UL << (unsigned long )ch % (sizeof(bitset_word_t ) * 8UL)))) {
#line 4078
    return (0);
  }
#line 4079
  goto switch_break;
  case_7: /* CIL Label */ 
#line 4083
  if ((int )ch >= 128) {
#line 4084
    return (0);
  }
  case_5: /* CIL Label */ 
#line 4088
  if ((int )ch == 10) {
#line 4088
    if (! ((mctx->dfa)->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 4090
      return (0);
    } else {
#line 4088
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4088
  if ((int )ch == 0) {
#line 4088
    if ((mctx->dfa)->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4090
      return (0);
    }
  }
#line 4091
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4094
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 4097
  if (node->constraint) {
    {
#line 4101
    tmp___1 = re_string_context_at(& mctx->input, idx___3, (int )mctx->eflags);
#line 4101
    context = tmp___1;
    }
#line 4103
    if (node->constraint & 4U) {
#line 4103
      if (! (context & 1U)) {
#line 4104
        return (0);
      } else {
#line 4103
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 4103
    if (node->constraint & 8U) {
#line 4103
      if (context & 1U) {
#line 4104
        return (0);
      } else {
#line 4103
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 4103
    if (node->constraint & 32U) {
#line 4103
      if (! (context & (unsigned int )(1 << 1))) {
#line 4104
        return (0);
      } else {
#line 4103
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 4103
    if (node->constraint & 128U) {
#line 4103
      if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 4104
        return (0);
      }
    }
  }
#line 4107
  return (1);
}
}
#line 4112 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t extend_buffers(re_match_context_t *mctx , int min_len ) 
{ 
  reg_errcode_t ret ;
  re_string_t *pstr___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  re_dfastate_t **new_array ;
  void *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  {
#line 4117
  pstr___0 = & mctx->input;
#line 4120
  tmp___1 = __builtin_expect((long )(1073741823UL / sizeof(re_dfastate_t *) <= (unsigned long )pstr___0->bufs_len),
                             0L);
  }
#line 4120
  if (tmp___1) {
#line 4121
    return ((reg_errcode_t )12);
  }
  {
#line 4124
  tmp___2 = MIN((size_t )pstr___0->len, (size_t )(pstr___0->bufs_len * 2));
#line 4124
  tmp___3 = MAX((size_t )min_len, (size_t )tmp___2);
#line 4124
  ret = re_string_realloc_buffers(pstr___0, tmp___3);
#line 4127
  tmp___4 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 4127
  if (tmp___4) {
#line 4128
    return (ret);
  }
#line 4130
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
#line 4136
    tmp___5 = realloc((void *)mctx->state_log, (unsigned long )(pstr___0->bufs_len + 1) * sizeof(re_dfastate_t *));
#line 4136
    new_array = (re_dfastate_t **)tmp___5;
#line 4138
    tmp___6 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4138
    if (tmp___6) {
#line 4139
      return ((reg_errcode_t )12);
    }
#line 4140
    mctx->state_log = new_array;
  }
#line 4144
  if (pstr___0->icase) {
#line 4147
    if (pstr___0->mb_cur_max > 1) {
      {
#line 4149
      ret = build_wcs_upper_buffer(pstr___0);
#line 4150
      tmp___7 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 4150
      if (tmp___7) {
#line 4151
        return (ret);
      }
    } else {
      {
#line 4155
      build_upper_buffer(pstr___0);
      }
    }
  } else
#line 4160
  if (pstr___0->mb_cur_max > 1) {
    {
#line 4161
    build_wcs_buffer(pstr___0);
    }
  } else
#line 4165
  if ((unsigned long )pstr___0->trans != (unsigned long )((void *)0)) {
    {
#line 4166
    re_string_translate_buffer(pstr___0);
    }
  }
#line 4169
  return ((reg_errcode_t )0);
}
}
#line 4177 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , int n ) 
{ 
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 4181
  mctx->eflags = eflags;
#line 4182
  mctx->match_last = -1;
#line 4183
  if (n > 0) {
    {
#line 4185
    tmp___1 = malloc((unsigned long )n * sizeof(struct re_backref_cache_entry ));
#line 4185
    mctx->bkref_ents = (struct re_backref_cache_entry *)tmp___1;
#line 4186
    tmp___2 = malloc((unsigned long )n * sizeof(re_sub_match_top_t *));
#line 4186
    mctx->sub_tops = (re_sub_match_top_t **)tmp___2;
    }
#line 4187
    if ((unsigned long )mctx->bkref_ents == (unsigned long )((void *)0)) {
#line 4187
      tmp___3 = 1;
    } else
#line 4187
    if ((unsigned long )mctx->sub_tops == (unsigned long )((void *)0)) {
#line 4187
      tmp___3 = 1;
    } else {
#line 4187
      tmp___3 = 0;
    }
    {
#line 4187
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 4187
    if (tmp___4) {
#line 4188
      return ((reg_errcode_t )12);
    }
  }
#line 4195
  mctx->abkref_ents = n;
#line 4196
  mctx->max_mb_elem_len = 1;
#line 4197
  mctx->asub_tops = n;
#line 4198
  return ((reg_errcode_t )0);
}
}
#line 4205 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static void match_ctx_clean(re_match_context_t *mctx ) 
{ 
  int st_idx ;
  int sl_idx ;
  re_sub_match_top_t *top ;
  re_sub_match_last_t *last ;

  {
#line 4210
  st_idx = 0;
  {
#line 4210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4210
    if (! (st_idx < mctx->nsub_tops)) {
#line 4210
      goto while_break;
    }
#line 4213
    top = *(mctx->sub_tops + st_idx);
#line 4214
    sl_idx = 0;
    {
#line 4214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4214
      if (! (sl_idx < top->nlasts)) {
#line 4214
        goto while_break___0;
      }
      {
#line 4216
      last = *(top->lasts + sl_idx);
#line 4217
      free((void *)last->path.array);
#line 4218
      free((void *)last);
#line 4214
      sl_idx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4220
    free((void *)top->lasts);
    }
#line 4221
    if (top->path) {
      {
#line 4223
      free((void *)(top->path)->array);
#line 4224
      free((void *)top->path);
      }
    }
    {
#line 4226
    free((void *)top);
#line 4210
    st_idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4229
  mctx->nsub_tops = 0;
#line 4230
  mctx->nbkref_ents = 0;
#line 4231
  return;
}
}
#line 4235 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static void match_ctx_free(re_match_context_t *mctx ) 
{ 


  {
  {
#line 4240
  match_ctx_clean(mctx);
#line 4241
  free((void *)mctx->sub_tops);
#line 4242
  free((void *)mctx->bkref_ents);
  }
#line 4243
  return;
}
}
#line 4250 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , int node , int str_idx ,
                                         int from , int to ) 
{ 
  struct re_backref_cache_entry *new_entry ;
  void *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 4255
  if (mctx->nbkref_ents >= mctx->abkref_ents) {
    {
#line 4258
    tmp___1 = realloc((void *)mctx->bkref_ents, (unsigned long )(mctx->abkref_ents * 2) * sizeof(struct re_backref_cache_entry ));
#line 4258
    new_entry = (struct re_backref_cache_entry *)tmp___1;
#line 4260
    tmp___2 = __builtin_expect((long )((unsigned long )new_entry == (unsigned long )((void *)0)),
                               0L);
    }
#line 4260
    if (tmp___2) {
      {
#line 4262
      free((void *)mctx->bkref_ents);
      }
#line 4263
      return ((reg_errcode_t )12);
    }
    {
#line 4265
    mctx->bkref_ents = new_entry;
#line 4266
    memset((void *)(mctx->bkref_ents + mctx->nbkref_ents), '\000', sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents);
#line 4268
    mctx->abkref_ents *= 2;
    }
  }
#line 4270
  if (mctx->nbkref_ents > 0) {
#line 4270
    if ((mctx->bkref_ents + (mctx->nbkref_ents - 1))->str_idx == str_idx) {
#line 4272
      (mctx->bkref_ents + (mctx->nbkref_ents - 1))->more = (char)1;
    }
  }
#line 4274
  (mctx->bkref_ents + mctx->nbkref_ents)->node = node;
#line 4275
  (mctx->bkref_ents + mctx->nbkref_ents)->str_idx = str_idx;
#line 4276
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_from = from;
#line 4277
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_to = to;
#line 4287
  if (from == to) {
#line 4287
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short )(~ 0);
  } else {
#line 4287
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short)0;
  }
#line 4290
  tmp___3 = mctx->nbkref_ents;
#line 4290
  (mctx->nbkref_ents) ++;
#line 4290
  (mctx->bkref_ents + tmp___3)->more = (char)0;
#line 4291
  if (mctx->max_mb_elem_len < to - from) {
#line 4292
    mctx->max_mb_elem_len = to - from;
  }
#line 4293
  return ((reg_errcode_t )0);
}
}
#line 4299 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static int search_cur_bkref_entry(re_match_context_t const   *mctx , int str_idx ) 
{ 
  int left ;
  int right ;
  int mid ;
  int last ;

  {
#line 4304
  right = (int )mctx->nbkref_ents;
#line 4304
  last = right;
#line 4305
  left = 0;
  {
#line 4305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4305
    if (! (left < right)) {
#line 4305
      goto while_break;
    }
#line 4307
    mid = (left + right) / 2;
#line 4308
    if ((mctx->bkref_ents + mid)->str_idx < str_idx) {
#line 4309
      left = mid + 1;
    } else {
#line 4311
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4313
  if (left < last) {
#line 4313
    if ((mctx->bkref_ents + left)->str_idx == str_idx) {
#line 4314
      return (left);
    } else {
#line 4316
      return (-1);
    }
  } else {
#line 4316
    return (-1);
  }
}
}
#line 4322 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , int node , int str_idx ) 
{ 
  int new_asub_tops ;
  re_sub_match_top_t **new_array ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  {
#line 4330
  tmp___3 = __builtin_expect((long )(mctx->nsub_tops == mctx->asub_tops), 0L);
  }
#line 4330
  if (tmp___3) {
    {
#line 4332
    new_asub_tops = mctx->asub_tops * 2;
#line 4333
    tmp___1 = realloc((void *)mctx->sub_tops, (unsigned long )new_asub_tops * sizeof(re_sub_match_top_t *));
#line 4333
    new_array = (re_sub_match_top_t **)tmp___1;
#line 4336
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4336
    if (tmp___2) {
#line 4337
      return ((reg_errcode_t )12);
    }
#line 4338
    mctx->sub_tops = new_array;
#line 4339
    mctx->asub_tops = new_asub_tops;
  }
  {
#line 4341
  tmp___4 = calloc((size_t )1, sizeof(re_sub_match_top_t ));
#line 4341
  *(mctx->sub_tops + mctx->nsub_tops) = (re_sub_match_top_t *)tmp___4;
#line 4342
  tmp___5 = __builtin_expect((long )((unsigned long )*(mctx->sub_tops + mctx->nsub_tops) == (unsigned long )((void *)0)),
                             0L);
  }
#line 4342
  if (tmp___5) {
#line 4343
    return ((reg_errcode_t )12);
  }
#line 4344
  (*(mctx->sub_tops + mctx->nsub_tops))->node = node;
#line 4345
  tmp___6 = mctx->nsub_tops;
#line 4345
  (mctx->nsub_tops) ++;
#line 4345
  (*(mctx->sub_tops + tmp___6))->str_idx = str_idx;
#line 4346
  return ((reg_errcode_t )0);
}
}
#line 4352 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , int node ,
                                                  int str_idx ) 
{ 
  re_sub_match_last_t *new_entry ;
  int new_alasts ;
  re_sub_match_last_t **new_array ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;

  {
  {
#line 4357
  tmp___3 = __builtin_expect((long )(subtop->nlasts == subtop->alasts), 0L);
  }
#line 4357
  if (tmp___3) {
    {
#line 4359
    new_alasts = 2 * subtop->alasts + 1;
#line 4360
    tmp___1 = realloc((void *)subtop->lasts, (unsigned long )new_alasts * sizeof(re_sub_match_last_t *));
#line 4360
    new_array = (re_sub_match_last_t **)tmp___1;
#line 4363
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4363
    if (tmp___2) {
#line 4364
      return ((re_sub_match_last_t *)((void *)0));
    }
#line 4365
    subtop->lasts = new_array;
#line 4366
    subtop->alasts = new_alasts;
  }
  {
#line 4368
  tmp___4 = calloc((size_t )1, sizeof(re_sub_match_last_t ));
#line 4368
  new_entry = (re_sub_match_last_t *)tmp___4;
#line 4369
  tmp___5 = __builtin_expect((long )((unsigned long )new_entry != (unsigned long )((void *)0)),
                             1L);
  }
#line 4369
  if (tmp___5) {
#line 4371
    *(subtop->lasts + subtop->nlasts) = new_entry;
#line 4372
    new_entry->node = node;
#line 4373
    new_entry->str_idx = str_idx;
#line 4374
    (subtop->nlasts) ++;
  }
#line 4376
  return (new_entry);
}
}
#line 4379 "/home/wslee/gnu_benchmarks/gawk-4.1.0/regexec.c"
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          int last_node , int last_str_idx ) 
{ 


  {
  {
#line 4384
  sctx->sifted_states = sifted_sts;
#line 4385
  sctx->limited_states = limited_sts;
#line 4386
  sctx->last_node = last_node;
#line 4387
  sctx->last_str_idx = last_str_idx;
#line 4388
  memset((void *)(& sctx->limits), '\000', sizeof(re_node_set ));
  }
#line 4389
  return;
}
}
#line 94 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 374 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t mbrlen(char const   * __restrict  __s ,
                                                   size_t __n , mbstate_t * __restrict  __ps ) ;
#line 41 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.h"
struct dfa *dfaalloc(void) ;
#line 49
void dfasyntax(reg_syntax_t bits , int fold , unsigned char eol ) ;
#line 54
void dfacomp(char const   *s___0 , size_t len , struct dfa *d , int searchflag ) ;
#line 68
char *dfaexec(struct dfa *d , char const   *begin , char *end , int allow_nl , size_t *count ,
              int *backref ) ;
#line 72
void dfafree(struct dfa *d ) ;
#line 96
void dfawarn(char const   *dfa_warning ) ;
#line 101
 __attribute__((__noreturn__)) void dfaerror(char const   *s___0 ) ;
#line 1030 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int IGNORECASE ;
#line 1113
int gawk_mb_cur_max ;
#line 1145
char casetable[256] ;
#line 1424
int cmp_nodes(NODE *t1 , NODE *t2 ) ;
#line 1442
char const   *genflags2str(int flagval , struct flagtab  const  *tab ) ;
#line 1573
void ( /* format attribute */  error)(char const   *mesg  , ...) ;
#line 1574
void ( /* format attribute */  warning)(char const   *mesg  , ...) ;
#line 1598
int parse_escape(char const   **string_ptr ) ;
#line 1617
Regexp *make_regexp(char const   *s___0 , size_t len , _Bool ignorecase , _Bool dfa___0 ,
                    _Bool canfatal ) ;
#line 1618
int research(Regexp *rp , char *str , int start , size_t len , int flags___0 ) ;
#line 1621
Regexp *re_update(NODE *t ) ;
#line 1623
void resetup(void) ;
#line 1624
int avoid_dfa(NODE *re , char *str , size_t len ) ;
#line 1625
int reisstring(char const   *text , size_t len , Regexp *re , char const   *buf___7 ) ;
#line 28 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static reg_syntax_t syn  ;
#line 29
static void check_bracket_exp(char *s___0 , size_t length ) ;
#line 30
char const   *regexflags2str(int flags___0 ) ;
#line 37 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static char metas[15]  = 
#line 37
  {      (char )'.',      (char )'*',      (char )'+',      (char )'(', 
        (char )')',      (char )'{',      (char )'}',      (char )'[', 
        (char )']',      (char )'|',      (char )'?',      (char )'^', 
        (char )'$',      (char )'\\',      (char )'\000'};
#line 41 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static char *buf  =    (char *)((void *)0);
#line 42 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static size_t buflen  ;
#line 46 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static _Bool first  =    (_Bool)1;
#line 47 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static _Bool no_dfa  =    (_Bool)0;
#line 34 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
Regexp *make_regexp(char const   *s___0 , size_t len , _Bool ignorecase , _Bool dfa___0 ,
                    _Bool canfatal ) 
{ 
  Regexp *rp ;
  char const   *rerr ;
  char const   *src ;
  char const   *end ;
  char *dest ;
  int c ;
  int c2 ;
  _Bool has_anchor ;
  reg_syntax_t dfa_syn ;
  int i___0 ;
  size_t is_multibyte ;
  mbstate_t mbs___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  void *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  void *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;

  {
#line 40
  src = s___0;
#line 43
  end = s___0 + len;
#line 48
  has_anchor = (_Bool)0;
#line 56
  is_multibyte = (size_t )0;
#line 60
  if (gawk_mb_cur_max > 1) {
    {
#line 61
    memset((void *)(& mbs___0), 0, sizeof(mbstate_t ));
    }
  }
#line 64
  if (first) {
    {
#line 65
    first = (_Bool)0;
#line 67
    tmp___1 = getenv("GAWK_NO_DFA");
#line 67
    no_dfa = (_Bool )((unsigned long )tmp___1 != (unsigned long )((void *)0));
    }
  }
  {
#line 71
  check_bracket_exp((char *)s___0, len);
  }
#line 80
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 81
    tmp___2 = malloc(len + 2UL);
#line 81
    buf = (char *)tmp___2;
    }
#line 81
    if (buf) {
#line 81
      tmp___6 = 1;
    } else {
      {
#line 81
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c", 81);
#line 81
      tmp___3 = __errno_location();
#line 81
      tmp___4 = strerror(*tmp___3);
#line 81
      tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 81
      r_fatal((char const   *)tmp___5, "make_regexp", "buf", (long )(len + 2UL), tmp___4);
#line 81
      tmp___6 = 0;
      }
    }
#line 82
    buflen = len;
  } else
#line 83
  if (len > buflen) {
    {
#line 84
    tmp___7 = realloc((void *)buf, len + 2UL);
#line 84
    buf = (char *)tmp___7;
    }
#line 84
    if (buf) {
#line 84
      tmp___11 = 1;
    } else {
      {
#line 84
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c", 84);
#line 84
      tmp___8 = __errno_location();
#line 84
      tmp___9 = strerror(*tmp___8);
#line 84
      tmp___10 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 84
      r_fatal((char const   *)tmp___10, "make_regexp", "buf", (long )(len + 2UL),
              tmp___9);
#line 84
      tmp___11 = 0;
      }
    }
#line 85
    buflen = len;
  }
#line 87
  dest = buf;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! ((unsigned long )src < (unsigned long )end)) {
#line 89
      goto while_break;
    }
#line 91
    if (gawk_mb_cur_max > 1) {
#line 91
      if (! is_multibyte) {
        {
#line 94
        is_multibyte = mbrlen((char const   */* __restrict  */)src, (size_t )(end - src),
                              (mbstate_t */* __restrict  */)(& mbs___0));
        }
#line 95
        if (is_multibyte == 1UL) {
#line 100
          is_multibyte = (size_t )0;
        } else
#line 95
        if (is_multibyte == 0xffffffffffffffffUL) {
#line 100
          is_multibyte = (size_t )0;
        } else
#line 95
        if (is_multibyte == 0xfffffffffffffffeUL) {
#line 100
          is_multibyte = (size_t )0;
        } else
#line 95
        if (is_multibyte == 0UL) {
#line 100
          is_multibyte = (size_t )0;
        }
      }
    }
#line 107
    if (gawk_mb_cur_max == 1) {
#line 107
      goto _L___1;
    } else
#line 107
    if (! is_multibyte) {
      _L___1: /* CIL Label */ 
#line 107
      if ((int const   )*src == 92) {
#line 109
        src ++;
#line 109
        c = (int )*src;
        {
#line 126
        if (c == 55) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 54) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 53) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 52) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 51) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 50) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 49) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 48) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 120) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 118) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 116) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 114) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 110) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 102) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 98) {
#line 126
          goto case_55;
        }
#line 126
        if (c == 97) {
#line 126
          goto case_55;
        }
#line 143
        if (c == 57) {
#line 143
          goto case_57;
        }
#line 143
        if (c == 56) {
#line 143
          goto case_57;
        }
#line 147
        if (c == 121) {
#line 147
          goto case_121;
        }
#line 156
        goto switch_default;
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
        case_120: /* CIL Label */ 
        case_118: /* CIL Label */ 
        case_116: /* CIL Label */ 
        case_114: /* CIL Label */ 
        case_110: /* CIL Label */ 
        case_102: /* CIL Label */ 
        case_98: /* CIL Label */ 
        case_97: /* CIL Label */ 
        {
#line 127
        c2 = parse_escape(& src);
        }
#line 128
        if (c2 < 0) {
          {
#line 129
          r_fatal("internal error line %d, file: %s", 129, "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c");
          }
        }
#line 135
        if (do_flags & 8) {
#line 135
          if (! (do_flags & 16)) {
            {
#line 135
            tmp___13 = __ctype_b_loc();
            }
#line 135
            if ((int const   )*(*tmp___13 + c) & 2048) {
#line 135
              goto _L;
            } else
#line 135
            if (c == 120) {
              _L: /* CIL Label */ 
              {
#line 135
              tmp___14 = strchr("()|*+?.^$\\[]", c2);
              }
#line 135
              if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
#line 139
                tmp___12 = dest;
#line 139
                dest ++;
#line 139
                *tmp___12 = (char )'\\';
              }
            }
          }
        }
#line 140
        tmp___15 = dest;
#line 140
        dest ++;
#line 140
        *tmp___15 = (char )c2;
#line 141
        goto switch_break;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
#line 144
        tmp___16 = dest;
#line 144
        dest ++;
#line 144
        *tmp___16 = (char )c;
#line 145
        src ++;
#line 146
        goto switch_break;
        case_121: /* CIL Label */ 
#line 149
        if (! (do_flags & 8)) {
#line 150
          tmp___17 = dest;
#line 150
          dest ++;
#line 150
          *tmp___17 = (char )'\\';
#line 151
          tmp___18 = dest;
#line 151
          dest ++;
#line 151
          *tmp___18 = (char )'b';
#line 152
          src ++;
#line 153
          goto switch_break;
        }
        switch_default: /* CIL Label */ 
#line 157
        tmp___19 = dest;
#line 157
        dest ++;
#line 157
        *tmp___19 = (char )'\\';
#line 158
        tmp___20 = dest;
#line 158
        dest ++;
#line 158
        *tmp___20 = (char )c;
#line 159
        src ++;
#line 160
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 107
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 163
      c = (int )*src;
#line 164
      if (c == 94) {
#line 165
        has_anchor = (_Bool)1;
      } else
#line 164
      if (c == 36) {
#line 165
        has_anchor = (_Bool)1;
      }
#line 167
      tmp___21 = dest;
#line 167
      dest ++;
#line 167
      tmp___22 = src;
#line 167
      src ++;
#line 167
      *tmp___21 = (char )*tmp___22;
    }
#line 169
    if (gawk_mb_cur_max > 1) {
#line 169
      if (is_multibyte) {
#line 170
        is_multibyte --;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  *dest = (char )'\000';
#line 174
  len = (size_t )(dest - buf);
#line 176
  tmp___23 = malloc(sizeof(*rp));
#line 176
  rp = (Regexp *)tmp___23;
  }
#line 176
  if (rp) {
#line 176
    tmp___27 = 1;
  } else {
    {
#line 176
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c", 176);
#line 176
    tmp___24 = __errno_location();
#line 176
    tmp___25 = strerror(*tmp___24);
#line 176
    tmp___26 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 176
    r_fatal((char const   *)tmp___26, "make_regexp", "rp", (long )sizeof(*rp), tmp___25);
#line 176
    tmp___27 = 0;
    }
  }
  {
#line 177
  memset((void *)((char *)rp), 0, sizeof(*rp));
#line 178
  rp->dfareg = (struct dfa *)((void *)0);
#line 179
  rp->pat.allocated = 0UL;
#line 180
  tmp___29 = malloc((size_t )256);
#line 180
  tmp___28 = (char *)tmp___29;
#line 180
  rp->pat.fastmap = tmp___28;
  }
#line 180
  if (tmp___28) {
#line 180
    tmp___33 = 1;
  } else {
    {
#line 180
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c", 180);
#line 180
    tmp___30 = __errno_location();
#line 180
    tmp___31 = strerror(*tmp___30);
#line 180
    tmp___32 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 180
    r_fatal((char const   *)tmp___32, "make_regexp", "rp->pat.fastmap", 256L, tmp___31);
#line 180
    tmp___33 = 0;
    }
  }
#line 197
  ignorecase = (_Bool )(! (! ignorecase));
#line 198
  if (ignorecase) {
#line 199
    if (gawk_mb_cur_max > 1) {
#line 200
      syn |= (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 201
      rp->pat.translate = (unsigned char *)((void *)0);
    } else {
#line 203
      syn &= ~ ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
#line 204
      rp->pat.translate = (unsigned char *)(casetable);
    }
  } else {
#line 207
    rp->pat.translate = (unsigned char *)((void *)0);
#line 208
    syn &= ~ ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
#line 211
  dfa_syn = syn;
#line 212
  if (ignorecase) {
#line 213
    dfa_syn |= (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  }
  {
#line 214
  dfasyntax(dfa_syn, (int )ignorecase, (unsigned char )'\n');
#line 215
  re_set_syntax(syn);
#line 217
  rerr = re_compile_pattern((char const   *)buf, len, & rp->pat);
  }
#line 217
  if ((unsigned long )rerr != (unsigned long )((void *)0)) {
    {
#line 218
    refree(rp);
    }
#line 219
    if (! canfatal) {
      {
#line 221
      error("%s: /%s/", rerr, buf);
      }
#line 222
      return ((Regexp *)((void *)0));
    }
    {
#line 224
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c", 224);
#line 224
    r_fatal("%s: /%s/", rerr, buf);
    }
  }
#line 228
  rp->pat.newline_anchor = 0U;
#line 229
  if (dfa___0) {
#line 229
    if (! no_dfa) {
      {
#line 230
      rp->dfa = (short)1;
#line 231
      rp->dfareg = dfaalloc();
#line 232
      dfacomp((char const   *)buf, len, rp->dfareg, 1);
      }
    } else {
#line 234
      rp->dfa = (short)0;
    }
  } else {
#line 234
    rp->dfa = (short)0;
  }
#line 235
  rp->has_anchor = (short )has_anchor;
#line 238
  i___0 = 0;
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 238
    if (! ((size_t )i___0 < len)) {
#line 238
      goto while_break___0;
    }
    {
#line 239
    tmp___34 = strchr((char const   *)(metas), (int )*(buf + i___0));
    }
#line 239
    if ((unsigned long )tmp___34 != (unsigned long )((void *)0)) {
#line 240
      rp->has_meta = (short)1;
#line 241
      goto while_break___0;
    }
#line 238
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 245
  i___0 = (int )(len - 1UL);
  {
#line 245
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 245
    if (! (i___0 >= 0)) {
#line 245
      goto while_break___1;
    }
    {
#line 246
    tmp___35 = strchr("*+|?", (int )*(buf + i___0));
    }
#line 246
    if ((unsigned long )tmp___35 != (unsigned long )((void *)0)) {
#line 247
      rp->maybe_long = (short)1;
#line 248
      goto while_break___1;
    }
#line 245
    i___0 --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 252
  return (rp);
}
}
#line 257 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
int research(Regexp *rp , char *str , int start , size_t len , int flags___0 ) 
{ 
  char const   *ret ;
  int try_backref ;
  int need_start ;
  int no_bol ;
  int res ;
  char save ;
  size_t count ;
  char *tmp___1 ;
  struct re_registers *tmp___2 ;

  {
#line 261
  ret = (char const   *)str;
#line 267
  need_start = (flags___0 & 1) != 0;
#line 268
  no_bol = (flags___0 & 2) != 0;
#line 270
  if (no_bol) {
#line 271
    rp->pat.not_bol = 1U;
  }
#line 284
  if (rp->dfa) {
#line 284
    if (! no_bol) {
#line 284
      if (! need_start) {
        {
#line 286
        count = (size_t )0;
#line 291
        save = *(str + ((size_t )start + len));
#line 292
        tmp___1 = dfaexec(rp->dfareg, (char const   *)(str + start), (str + start) + len,
                          1, & count, & try_backref);
#line 292
        ret = (char const   *)tmp___1;
#line 294
        *(str + ((size_t )start + len)) = save;
        }
      }
    }
  }
#line 297
  if (ret) {
#line 298
    if (need_start) {
#line 298
      goto _L;
    } else
#line 298
    if ((int )rp->dfa == 0) {
#line 298
      goto _L;
    } else
#line 298
    if (try_backref) {
      _L: /* CIL Label */ 
#line 303
      if (need_start) {
#line 303
        tmp___2 = & rp->regs;
      } else {
#line 303
        tmp___2 = (struct re_registers *)((void *)0);
      }
      {
#line 303
      res = re_search(& rp->pat, (char const   *)str, (int )((size_t )start + len),
                      start, (int )len, tmp___2);
      }
    } else {
#line 306
      res = 1;
    }
  } else {
#line 308
    res = -1;
  }
#line 310
  rp->pat.not_bol = 0U;
#line 311
  return (res);
}
}
#line 316 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
void refree(Regexp *rp ) 
{ 


  {
#line 319
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 320
    return;
  }
  {
#line 321
  rp->pat.translate = (unsigned char *)((void *)0);
#line 322
  regfree(& rp->pat);
  }
#line 323
  if (rp->regs.start) {
    {
#line 324
    free((void *)rp->regs.start);
    }
  }
#line 325
  if (rp->regs.end) {
    {
#line 326
    free((void *)rp->regs.end);
    }
  }
#line 327
  if (rp->dfa) {
    {
#line 328
    dfafree(rp->dfareg);
#line 329
    free((void *)rp->dfareg);
    }
  }
  {
#line 331
  free((void *)rp);
  }
#line 332
  return;
}
}
#line 336
 __attribute__((__noreturn__)) void dfaerror(char const   *s___0 ) ;
#line 336 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
void dfaerror(char const   *s___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 339
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c", 339);
#line 339
  r_fatal("%s", s___0);
#line 340
  exit(2);
  }
}
}
#line 345 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
Regexp *re_update(NODE *t ) 
{ 
  NODE *t1 ;
  int tmp___1 ;

  {
#line 350
  if ((t->sub.nodep.reflags & 1UL) == (unsigned long )IGNORECASE) {
#line 352
    if ((t->sub.nodep.reflags & 2UL) != 0UL) {
#line 355
      return (t->sub.nodep.r.preg);
    }
#line 357
    t1 = t->sub.nodep.x.extra;
#line 358
    if ((unsigned long )t->sub.nodep.l.lptr != (unsigned long )((void *)0)) {
      {
#line 360
      tmp___1 = cmp_nodes(t->sub.nodep.l.lptr, t1);
      }
#line 360
      if (tmp___1 == 0) {
#line 361
        return (t->sub.nodep.r.preg);
      }
      {
#line 363
      unref(t->sub.nodep.l.lptr);
      }
    }
    {
#line 366
    t->sub.nodep.l.lptr = dupnode(t1);
    }
  }
#line 371
  if ((unsigned long )t->sub.nodep.r.preg != (unsigned long )((void *)0)) {
    {
#line 372
    refree(t->sub.nodep.r.preg);
    }
  }
#line 373
  if (t->flags > 0U) {
#line 374
    (t->flags) ++;
  }
#line 375
  if (t->flags > 10U) {
#line 376
    t->flags = 0U;
  }
#line 377
  if ((unsigned long )t->sub.nodep.l.lptr == (unsigned long )((void *)0)) {
    {
#line 379
    t1 = t->sub.nodep.x.extra;
#line 380
    unref(t->sub.nodep.l.lptr);
#line 381
    t->sub.nodep.l.lptr = dupnode(t1);
    }
  } else
#line 377
  if ((t->sub.nodep.reflags & 1UL) != (unsigned long )IGNORECASE) {
    {
#line 379
    t1 = t->sub.nodep.x.extra;
#line 380
    unref(t->sub.nodep.l.lptr);
#line 381
    t->sub.nodep.l.lptr = dupnode(t1);
    }
  }
  {
#line 384
  t->sub.nodep.r.preg = make_regexp((char const   *)(t->sub.nodep.l.lptr)->sub.val.sp,
                                    (t->sub.nodep.l.lptr)->sub.val.slen, (_Bool )IGNORECASE,
                                    (_Bool )t->flags, (_Bool)1);
#line 388
  t->sub.nodep.reflags &= 0xfffffffffffffffeUL;
#line 390
  t->sub.nodep.reflags |= (unsigned long )IGNORECASE;
  }
#line 391
  return (t->sub.nodep.r.preg);
}
}
#line 396 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
void resetup(void) 
{ 


  {
#line 399
  if (do_flags & 16) {
#line 400
    syn = ((((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else
#line 401
  if (do_flags & 8) {
#line 402
    syn = (((((((((1UL | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((1UL << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 404
    syn = (((((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | 1UL) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ~ (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((1UL << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1));
  }
#line 411
  if (do_flags & 128) {
#line 412
    syn |= ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
  {
#line 414
  re_set_syntax(syn);
#line 415
  dfasyntax(syn, 0, (unsigned char )'\n');
  }
#line 416
  return;
}
}
#line 420 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
int avoid_dfa(NODE *re , char *str , size_t len ) 
{ 
  char *end ;

  {
#line 425
  if (! (re->sub.nodep.r.preg)->has_anchor) {
#line 426
    return (0);
  }
#line 428
  end = str + len;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! ((unsigned long )str < (unsigned long )end)) {
#line 428
      goto while_break;
    }
#line 429
    if ((int )*str == 10) {
#line 430
      return (1);
    }
#line 428
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  return (0);
}
}
#line 437 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
int reisstring(char const   *text , size_t len , Regexp *re , char const   *buf___7 ) 
{ 
  int res ;
  char const   *matched ;
  int tmp___1 ;

  {
#line 444
  if (re->has_meta) {
#line 445
    return (0);
  }
  {
#line 448
  matched = buf___7 + *(re->regs.start + 0);
#line 450
  tmp___1 = memcmp((void const   *)text, (void const   *)matched, len);
#line 450
  res = tmp___1 == 0;
  }
#line 452
  return (res);
}
}
#line 460
char const   *reflags2str(int flagval ) ;
#line 460 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static struct flagtab  const  values[26]  = 
#line 460
  {      {1, "RE_BACKSLASH_ESCAPE_IN_LISTS"}, 
        {(int )(1UL << 1), "RE_BK_PLUS_QM"}, 
        {(int )((1UL << 1) << 1), "RE_CHAR_CLASSES"}, 
        {(int )(((1UL << 1) << 1) << 1), "RE_CONTEXT_INDEP_ANCHORS"}, 
        {(int )((((1UL << 1) << 1) << 1) << 1), "RE_CONTEXT_INDEP_OPS"}, 
        {(int )(((((1UL << 1) << 1) << 1) << 1) << 1), "RE_CONTEXT_INVALID_OPS"}, 
        {(int )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1), "RE_DOT_NEWLINE"}, 
        {(int )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1), "RE_DOT_NOT_NULL"}, 
        {(int )((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_HAT_LISTS_NOT_NEWLINE"}, 
        {(int )(((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1), "RE_INTERVALS"}, 
        {(int )((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_LIMITED_OPS"}, 
        {(int )(((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NEWLINE_ALT"}, 
        {(int )((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_BK_BRACES"}, 
        {(int )(((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_BK_PARENS"}, 
        {(int )((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_BK_REFS"}, 
        {(int )(((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_BK_VBAR"}, 
        {(int )((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_EMPTY_RANGES"}, 
        {(int )(((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_UNMATCHED_RIGHT_PAREN_ORD"}, 
        {(int )((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_POSIX_BACKTRACKING"}, 
        {(int )(((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_GNU_OPS"}, 
        {(int )(((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_INVALID_INTERVAL_ORD"}, 
        {(int )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_ICASE"}, 
        {(int )(((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_CARET_ANCHORS_HERE"}, 
        {(int )((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_CONTEXT_INVALID_DUP"}, 
        {(int )(((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_SUB"}, 
        {0, (char const   *)((void *)0)}};
#line 457 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
char const   *reflags2str(int flagval ) 
{ 
  char const   *tmp___1 ;
  char *__cil_tmp3 ;

  {
#line 489
  if (flagval == 0) {
#line 490
    return ("RE_SYNTAX_EMACS");
  }
  {
#line 492
  tmp___1 = genflags2str(flagval, values);
  }
#line 492
  return (tmp___1);
}
}
#line 500 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
void dfawarn(char const   *dfa_warning ) 
{ 


  {
#line 507
  return;
}
}
#line 514 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static struct reclass classes[13]  = 
#line 514
  {      {"[:alpha:]", (size_t )9, (_Bool)0}, 
        {"[:digit:]", (size_t )9, (_Bool)0}, 
        {"[:alnum:]", (size_t )9, (_Bool)0}, 
        {"[:upper:]", (size_t )9, (_Bool)0}, 
        {"[:lower:]", (size_t )9, (_Bool)0}, 
        {"[:space:]", (size_t )9, (_Bool)0}, 
        {"[:xdigit:]", (size_t )10, (_Bool)0}, 
        {"[:punct:]", (size_t )9, (_Bool)0}, 
        {"[:print:]", (size_t )9, (_Bool)0}, 
        {"[:graph:]", (size_t )9, (_Bool)0}, 
        {"[:cntrl:]", (size_t )9, (_Bool)0}, 
        {"[:blank:]", (size_t )9, (_Bool)0}, 
        {(char const   *)((void *)0), (size_t )0, (_Bool)0}};
#line 558 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static _Bool range_warned  =    (_Bool)0;
#line 511 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static void check_bracket_exp(char *s___0 , size_t length ) 
{ 
  int i___0 ;
  _Bool found ;
  char save ;
  char *sp___0 ;
  char *sp2 ;
  char *end ;
  int len ;
  int count ;
  void *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 538
  found = (_Bool)0;
#line 542
  count = 0;
#line 544
  if (length == 0UL) {
#line 545
    return;
  }
#line 547
  end = s___0 + length;
#line 548
  save = *(s___0 + length);
#line 549
  *(s___0 + length) = (char )'\000';
#line 550
  sp___0 = s___0;
  again: 
  {
#line 553
  tmp___1 = memchr((void const   *)sp___0, '[', (size_t )(end - sp___0));
#line 553
  sp2 = (char *)tmp___1;
#line 553
  sp___0 = sp2;
  }
#line 554
  if ((unsigned long )sp___0 == (unsigned long )((void *)0)) {
#line 555
    goto done;
  }
#line 557
  count ++;
#line 557
  sp___0 ++;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! ((int )*sp___0 != 0)) {
#line 557
      goto while_break;
    }
#line 560
    if ((int )*sp___0 == 91) {
#line 561
      count ++;
    }
#line 567
    if ((int )*sp___0 == 93) {
#line 567
      if ((unsigned long )sp___0 > (unsigned long )sp2) {
#line 568
        if ((int )*(sp___0 + -1) != 91) {
#line 568
          if (! ((int )*(sp___0 + -1) != 92)) {
#line 568
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 571
        if (sp___0 - sp2 >= 2L) {
#line 571
          if ((int )*(sp___0 + -1) == 94) {
#line 571
            if (! ((int )*(sp___0 + -2) == 91)) {
#line 575
              count --;
            }
          } else {
#line 575
            count --;
          }
        } else {
#line 575
          count --;
        }
      }
    }
#line 578
    if ((int )*sp___0 == 45) {
#line 578
      if (do_flags & 3) {
#line 578
        if (! range_warned) {
#line 578
          if (count == 1) {
#line 578
            if ((int )*(sp___0 + -1) != 91) {
#line 578
              if ((int )*(sp___0 + 1) != 93) {
                {
#line 578
                tmp___3 = __ctype_b_loc();
                }
#line 578
                if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*(sp___0 + -1))) & 2048)) {
                  {
#line 578
                  tmp___4 = __ctype_b_loc();
                  }
#line 578
                  if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*(sp___0 + 1))) & 2048)) {
#line 578
                    if ((int )*(sp___0 + -2) == 91) {
#line 578
                      if (! ((int )*(sp___0 + -1) == 94)) {
                        {
#line 582
                        range_warned = (_Bool)1;
#line 583
                        tmp___2 = gettext("range of the form `[%c-%c]\' is locale dependent");
#line 583
                        warning((char const   *)tmp___2, (int )*(sp___0 + -1), (int )*(sp___0 + 1));
                        }
                      }
                    } else {
                      {
#line 582
                      range_warned = (_Bool)1;
#line 583
                      tmp___2 = gettext("range of the form `[%c-%c]\' is locale dependent");
#line 583
                      warning((char const   *)tmp___2, (int )*(sp___0 + -1), (int )*(sp___0 + 1));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 586
    if (count == 0) {
#line 587
      sp___0 ++;
#line 588
      goto while_break;
    }
#line 557
    sp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  if (count > 0) {
#line 593
    goto done;
  }
#line 598
  i___0 = 0;
  {
#line 598
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 598
    if (! ((unsigned long )classes[i___0].name != (unsigned long )((void *)0))) {
#line 598
      goto while_break___0;
    }
#line 599
    if (classes[i___0].warned) {
#line 600
      goto __Cont;
    }
#line 601
    len = (int )classes[i___0].len;
#line 602
    if ((long )len == sp___0 - sp2) {
      {
#line 602
      tmp___5 = memcmp((void const   *)sp2, (void const   *)classes[i___0].name, (size_t )len);
      }
#line 602
      if (tmp___5 == 0) {
#line 604
        found = (_Bool)1;
#line 605
        goto while_break___0;
      }
    }
    __Cont: /* CIL Label */ 
#line 598
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 609
  if (found) {
#line 609
    if (! classes[i___0].warned) {
      {
#line 610
      tmp___6 = gettext("regexp component `%.*s\' should probably be `[%.*s]\'");
#line 610
      warning((char const   *)tmp___6, len, sp2, len, sp2);
#line 612
      classes[i___0].warned = (_Bool)1;
      }
    }
  }
#line 615
  if ((unsigned long )sp___0 < (unsigned long )end) {
#line 616
    found = (_Bool)0;
#line 617
    goto again;
  }
  done: 
#line 620
  *(s___0 + length) = save;
#line 621
  return;
}
}
#line 628 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
static struct flagtab  const  regextab[26]  = 
#line 628
  {      {1, "RE_BACKSLASH_ESCAPE_IN_LISTS"}, 
        {(int )(1UL << 1), "RE_BK_PLUS_QM"}, 
        {(int )((1UL << 1) << 1), "RE_CHAR_CLASSES"}, 
        {(int )(((1UL << 1) << 1) << 1), "RE_CONTEXT_INDEP_ANCHORS"}, 
        {(int )((((1UL << 1) << 1) << 1) << 1), "RE_CONTEXT_INDEP_OPS"}, 
        {(int )(((((1UL << 1) << 1) << 1) << 1) << 1), "RE_CONTEXT_INVALID_OPS"}, 
        {(int )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1), "RE_DOT_NEWLINE"}, 
        {(int )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1), "RE_DOT_NOT_NULL"}, 
        {(int )((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_HAT_LISTS_NOT_NEWLINE"}, 
        {(int )(((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1), "RE_INTERVALS"}, 
        {(int )((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_LIMITED_OPS"}, 
        {(int )(((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NEWLINE_ALT"}, 
        {(int )((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_BK_BRACES"}, 
        {(int )(((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_BK_PARENS"}, 
        {(int )((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_BK_REFS"}, 
        {(int )(((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_BK_VBAR"}, 
        {(int )((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_EMPTY_RANGES"}, 
        {(int )(((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_UNMATCHED_RIGHT_PAREN_ORD"}, 
        {(int )((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_POSIX_BACKTRACKING"}, 
        {(int )(((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_NO_GNU_OPS"}, 
        {(int )((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_DEBUG"}, 
        {(int )(((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_INVALID_INTERVAL_ORD"}, 
        {(int )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_ICASE"}, 
        {(int )(((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_CARET_ANCHORS_HERE"}, 
        {(int )((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
      "RE_CONTEXT_INVALID_DUP"}, 
        {0, (char const   *)((void *)0)}};
#line 625 "/home/wslee/gnu_benchmarks/gawk-4.1.0/re.c"
char const   *regexflags2str(int flags___0 ) 
{ 
  char const   *tmp___1 ;

  {
  {
#line 657
  tmp___1 = genflags2str(flags___0, regextab);
  }
#line 657
  return (tmp___1);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 43 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.h"
long gawk_random(void) ;
#line 186 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static int const   degrees[5]  = {      (int const   )0,      (int const   )7,      (int const   )15,      (int const   )31, 
        (int const   )63};
#line 187 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static int const   seps[5]  = {      (int const   )0,      (int const   )3,      (int const   )1,      (int const   )3, 
        (int const   )1};
#line 203 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static gawk_uint32_t randtbl[32]  = 
#line 203
  {      (gawk_uint32_t )3,      2568305073U,      (gawk_uint32_t )379960547,      (gawk_uint32_t )1735697613, 
        (gawk_uint32_t )1040273694,      (gawk_uint32_t )1313901226,      (gawk_uint32_t )1627687941,      4115662359U, 
        2221633813U,      (gawk_uint32_t )1780058412,      2305464239U,      3678992694U, 
        (gawk_uint32_t )344556628,      (gawk_uint32_t )939512070,      3045851036U,      (gawk_uint32_t )1507946756, 
        3482421833U,      (gawk_uint32_t )154635395,      (gawk_uint32_t )1388815473,      2368290473U, 
        (gawk_uint32_t )525320961,      3285938622U,      (gawk_uint32_t )968117788,      4171517689U, 
        (gawk_uint32_t )1284210865,      (gawk_uint32_t )435012392,      2277460957U,      3383902437U, 
        3924708123U,      (gawk_uint32_t )1132637927,      (gawk_uint32_t )1398500161,      4089365978U};
#line 238 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static gawk_uint32_t *fptr  =    & randtbl[4];
#line 239 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static gawk_uint32_t *rptr  =    & randtbl[1];
#line 251 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static gawk_uint32_t *state  =    & randtbl[1];
#line 252 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static int rand_type  =    3;
#line 253 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static int rand_deg  =    31;
#line 254 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static int rand_sep  =    3;
#line 255 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
static gawk_uint32_t *end_ptr  =    & randtbl[32];
#line 257
__inline static gawk_uint32_t good_rand(gawk_int32_t x ) ;
#line 259 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
__inline static gawk_uint32_t good_rand(gawk_int32_t x ) 
{ 
  gawk_int32_t hi ;
  gawk_int32_t lo ;

  {
#line 281
  if (x == 0) {
#line 282
    x = 123459876;
  }
#line 283
  hi = x / 127773;
#line 284
  lo = x % 127773;
#line 285
  x = 16807 * lo - 2836 * hi;
#line 286
  if (x < 0) {
#line 287
    x += 2147483647;
  }
#line 288
  return ((gawk_uint32_t )x);
}
}
#line 304 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
void gawk_srandom(unsigned long x ) 
{ 
  int i___0 ;
  int lim ;

  {
#line 310
  *(state + 0) = (gawk_uint32_t )x;
#line 311
  if (rand_type == 0) {
#line 312
    lim = 50;
  } else {
#line 314
    i___0 = 1;
    {
#line 314
    while (1) {
      while_continue: /* CIL Label */ ;
#line 314
      if (! (i___0 < rand_deg)) {
#line 314
        goto while_break;
      }
      {
#line 315
      *(state + i___0) = good_rand((gawk_int32_t )*(state + (i___0 - 1)));
#line 314
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 316
    fptr = state + rand_sep;
#line 317
    rptr = state + 0;
#line 318
    lim = 10 * rand_deg;
  }
#line 320
  i___0 = 0;
  {
#line 320
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 320
    if (! (i___0 < lim)) {
#line 320
      goto while_break___0;
    }
    {
#line 321
    gawk_random();
#line 320
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 322
  return;
}
}
#line 394 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
char *gawk_initstate(unsigned long seed___0 , char *arg_state , long n ) 
{ 
  char *ostate ;
  gawk_uint32_t *int_arg_state ;
  char *__cil_tmp6 ;

  {
#line 400
  ostate = (char *)(state + -1);
#line 401
  int_arg_state = (gawk_uint32_t *)arg_state;
#line 403
  if (rand_type == 0) {
#line 404
    *(state + -1) = (gawk_uint32_t )rand_type;
  } else {
#line 406
    *(state + -1) = (gawk_uint32_t )(5L * (rptr - state) + (long )rand_type);
  }
#line 407
  if (n < 8L) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"random: not enough state (%ld bytes); ignored.\n",
            n);
    }
#line 410
    return ((char *)0);
  }
#line 412
  if (n < 32L) {
#line 413
    rand_type = 0;
#line 414
    rand_deg = 0;
#line 415
    rand_sep = 0;
  } else
#line 416
  if (n < 64L) {
#line 417
    rand_type = 1;
#line 418
    rand_deg = 7;
#line 419
    rand_sep = 3;
  } else
#line 420
  if (n < 128L) {
#line 421
    rand_type = 2;
#line 422
    rand_deg = 15;
#line 423
    rand_sep = 1;
  } else
#line 424
  if (n < 256L) {
#line 425
    rand_type = 3;
#line 426
    rand_deg = 31;
#line 427
    rand_sep = 3;
  } else {
#line 429
    rand_type = 4;
#line 430
    rand_deg = 63;
#line 431
    rand_sep = 1;
  }
  {
#line 433
  state = int_arg_state + 1;
#line 434
  end_ptr = state + rand_deg;
#line 435
  gawk_srandom(seed___0);
  }
#line 436
  if (rand_type == 0) {
#line 437
    *(int_arg_state + 0) = (gawk_uint32_t )rand_type;
  } else {
#line 439
    *(int_arg_state + 0) = (gawk_uint32_t )(5L * (rptr - state) + (long )rand_type);
  }
#line 440
  return (ostate);
}
}
#line 462 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
char *gawk_setstate(char *arg_state ) 
{ 
  gawk_uint32_t *new_state ;
  gawk_uint32_t type ;
  gawk_uint32_t rear ;
  char *ostate ;
  char *__cil_tmp6 ;

  {
#line 466
  new_state = (gawk_uint32_t *)arg_state;
#line 467
  type = *(new_state + 0) % 5U;
#line 468
  rear = *(new_state + 0) / 5U;
#line 469
  ostate = (char *)(state + -1);
#line 471
  if (rand_type == 0) {
#line 472
    *(state + -1) = (gawk_uint32_t )rand_type;
  } else {
#line 474
    *(state + -1) = (gawk_uint32_t )(5L * (rptr - state) + (long )rand_type);
  }
  {
#line 480
  if (type == 4U) {
#line 480
    goto case_4;
  }
#line 480
  if (type == 3U) {
#line 480
    goto case_4;
  }
#line 480
  if (type == 2U) {
#line 480
    goto case_4;
  }
#line 480
  if (type == 1U) {
#line 480
    goto case_4;
  }
#line 480
  if (type == 0U) {
#line 480
    goto case_4;
  }
#line 485
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 481
  rand_type = (int )type;
#line 482
  rand_deg = (int )degrees[type];
#line 483
  rand_sep = (int )seps[type];
#line 484
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 486
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"random: state info corrupted; not changed.\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 489
  state = new_state + 1;
#line 490
  if (rand_type != 0) {
#line 491
    rptr = state + rear;
#line 492
    fptr = state + (rear + (gawk_uint32_t )rand_sep) % (unsigned int )rand_deg;
  }
#line 494
  end_ptr = state + rand_deg;
#line 495
  return (ostate);
}
}
#line 515 "/home/wslee/gnu_benchmarks/gawk-4.1.0/random.c"
long gawk_random(void) 
{ 
  gawk_uint32_t i___0 ;
  gawk_uint32_t *f ;
  gawk_uint32_t *r ;
  gawk_uint32_t tmp___1 ;

  {
#line 521
  if (rand_type == 0) {
    {
#line 522
    i___0 = *(state + 0);
#line 523
    tmp___1 = good_rand((gawk_int32_t )i___0);
#line 523
    i___0 = tmp___1 & 2147483647U;
#line 523
    *(state + 0) = i___0;
    }
  } else {
#line 528
    f = fptr;
#line 528
    r = rptr;
#line 529
    *f += *r;
#line 530
    i___0 = (*f >> 1) & 2147483647U;
#line 531
    f ++;
#line 531
    if ((unsigned long )f >= (unsigned long )end_ptr) {
#line 532
      f = state;
#line 533
      r ++;
    } else {
#line 535
      r ++;
#line 535
      if ((unsigned long )r >= (unsigned long )end_ptr) {
#line 536
        r = state;
      }
    }
#line 539
    fptr = f;
#line 539
    rptr = r;
  }
#line 541
  return ((long )i___0);
}
}
#line 219 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 258
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 373 "/usr/include/mpfr.h"
extern int mpfr_sprintf(char * , char const   *  , ...) ;
#line 279 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
char const   * const  ruletab[6] ;
#line 1129
mpfr_rnd_t ROUND_MODE ;
#line 1364
void dump_funcs(void) ;
#line 1366
char const   *getfname(NODE *(*fptr___0)(int  ) ) ;
#line 1443
char const   *nodetype2str(NODETYPE type ) ;
#line 1447
char const   *op2str(OPCODE op ) ;
#line 1450
void dump_fcall_stack(FILE *fp___0 ) ;
#line 1570
 __attribute__((__noreturn__)) void final_exit(int status ) ;
#line 1583
void init_profiling_signals(void) ;
#line 1584
void set_prof_file(char const   *file ) ;
#line 1585
void dump_prog(INSTRUCTION *code ) ;
#line 1586
char *pp_number(NODE *n ) ;
#line 1587
char *pp_string(char const   *in_str , size_t len , int delim ) ;
#line 1588
char *pp_node(NODE *n ) ;
#line 1589
int pp_func(INSTRUCTION *pc , void *data  __attribute__((__unused__)) ) ;
#line 1590
void pp_string_fp(int (*print_func)(FILE * , char const   *  , ...) , FILE *fp___0 ,
                  char const   *in_str , size_t len , int delim , _Bool breaklines ) ;
#line 28 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void pprint(INSTRUCTION *startp , INSTRUCTION *endp , _Bool in_for_header ) ;
#line 29
static void pp_parenthesize(NODE *sp___0 ) ;
#line 30
static void parenthesize(int type , NODE *left , NODE *right ) ;
#line 31
static char *pp_list(int nargs , char const   *paren , char const   *delim ) ;
#line 32
static char *pp_concat(char const   *s1 , char const   *s2 , char const   *s3 ) ;
#line 33
static int is_binary(int type ) ;
#line 34
static int prec_level(int type ) ;
#line 35
static void pp_push(int type , char *s___0 , int flag ) ;
#line 36
static NODE *pp_pop(void) ;
#line 37
static void pp_free(NODE *n ) ;
#line 38
char const   *redir2str(int redirtype ) ;
#line 48
static  __attribute__((__noreturn__)) void dump_and_exit(int signum ) ;
#line 49
static void just_dump(int signum ) ;
#line 53 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static NODE *pp_stack  =    (NODE *)((void *)0);
#line 54 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static NODE *func_params  ;
#line 55 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static FILE *prof_fp  ;
#line 57 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static long indent_level  =    0L;
#line 64 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
void set_prof_file(char const   *file ) 
{ 
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 68
  prof_fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
#line 69
  if ((unsigned long )prof_fp == (unsigned long )((void *)0)) {
    {
#line 70
    tmp___1 = __errno_location();
#line 70
    tmp___2 = strerror(*tmp___1);
#line 70
    tmp___3 = gettext("could not open `%s\' for writing: %s");
#line 70
    warning((char const   *)tmp___3, file, tmp___2);
#line 72
    tmp___4 = gettext("sending profile to standard error");
#line 72
    warning((char const   *)tmp___4);
#line 73
    prof_fp = stderr;
    }
  }
#line 75
  return;
}
}
#line 79 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
void init_profiling_signals(void) 
{ 


  {
  {
#line 87
  signal(1, & dump_and_exit);
#line 90
  signal(10, & just_dump);
  }
#line 93
  return;
}
}
#line 97 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void indent___0(long count ) 
{ 
  int i___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 102
  if (count == 0L) {
    {
#line 103
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\t");
    }
  } else {
    {
#line 105
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%6ld  ",
            count);
    }
  }
#line 108
  i___0 = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((long )i___0 < indent_level)) {
#line 108
      goto while_break;
    }
    {
#line 109
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\t");
#line 108
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 114 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void indent_in(void) 
{ 


  {
#line 118
  indent_level ++;
#line 119
  return;
}
}
#line 123 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void indent_out(void) 
{ 


  {
#line 126
  indent_level --;
#line 128
  return;
}
}
#line 130 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void pp_push(int type , char *s___0 , int flag ) 
{ 
  NODE *n ;
  void *tmp___1 ;

  {
#line 134
  n = (NODE *)nextfree[1].freep;
#line 134
  if (n) {
#line 134
    nextfree[1].freep = ((BLOCK *)n)->freep;
  } else {
    {
#line 134
    tmp___1 = more_blocks(1);
#line 134
    n = (NODE *)tmp___1;
    }
  }
  {
#line 135
  n->sub.nodep.name = s___0;
#line 136
  n->sub.nodep.reserved = strlen((char const   *)s___0);
#line 137
  n->flags = (unsigned int )flag;
#line 138
  n->type = (NODETYPE )type;
#line 139
  n->sub.nodep.r.rptr = pp_stack;
#line 140
  pp_stack = n;
  }
#line 141
  return;
}
}
#line 143 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static NODE *pp_pop(void) 
{ 
  NODE *n ;

  {
#line 147
  n = pp_stack;
#line 148
  pp_stack = n->sub.nodep.r.rptr;
#line 149
  return (n);
}
}
#line 152 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void pp_free(NODE *n ) 
{ 


  {
#line 155
  if ((n->flags & 2U) != 0U) {
    {
#line 156
    free((void *)n->sub.nodep.name);
    }
  }
#line 157
  ((BLOCK *)n)->freep = nextfree[1].freep;
#line 157
  nextfree[1].freep = (BLOCK *)n;
#line 158
  return;
}
}
#line 175 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static int rule_count[6]  ;
#line 164 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void pprint(INSTRUCTION *startp , INSTRUCTION *endp , _Bool in_for_header ) 
{ 
  INSTRUCTION *pc ;
  NODE *t1 ;
  char *str ;
  NODE *t2 ;
  INSTRUCTION *ip ;
  NODE *m ;
  char *tmp___1 ;
  int rule___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char *array ;
  char *sub ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char *array___0 ;
  char *sub___0 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char const   *fname ;
  char const   *fname___0 ;
  char *tmp___36 ;
  char const   *tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  NODE *re ;
  char *restr ;
  char *txt ;
  int tmp___43 ;
  int tmp___44 ;
  char const   *tmp___45 ;
  NODE *re___0 ;
  char const   *tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___48 ;
  int before ;
  int tmp___49 ;
  int tmp___50 ;
  char const   *tmp___51 ;
  char const   *tmp___52 ;
  char *fname___1 ;
  char *pre ;
  int pcount ;
  char const   *tmp___53 ;
  int tmp___54 ;
  char const   *tmp___55 ;
  char const   *tmp___56 ;
  char const   *tmp___57 ;
  char const   *tmp___58 ;
  char const   *tmp___59 ;
  char *array___1 ;
  char const   *item ;
  char const   *tmp___60 ;
  char const   *tmp___61 ;
  char const   *tmp___62 ;
  char const   *tmp___63 ;
  char const   *tmp___64 ;
  char const   *tmp___65 ;
  char const   *tmp___66 ;
  NODE *f ;
  NODE *t ;
  NODE *cond ;
  size_t len ;
  void *tmp___67 ;
  int *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  int tmp___71 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;

  {
#line 177
  pc = startp;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! ((unsigned long )pc != (unsigned long )endp)) {
#line 177
      goto while_break;
    }
#line 178
    if ((int )pc->source_line > 0) {
#line 179
      sourceline = (int )pc->source_line;
    }
    {
#line 182
    if ((unsigned int )pc->opcode == 49U) {
#line 182
      goto case_49;
    }
#line 220
    if ((unsigned int )pc->opcode == 101U) {
#line 220
      goto case_101;
    }
#line 223
    if ((unsigned int )pc->opcode == 102U) {
#line 223
      goto case_102;
    }
#line 227
    if ((unsigned int )pc->opcode == 74U) {
#line 227
      goto case_74;
    }
#line 244
    if ((unsigned int )pc->opcode == 26U) {
#line 244
      goto case_26;
    }
#line 254
    if ((unsigned int )pc->opcode == 73U) {
#line 254
      goto case_73;
    }
#line 254
    if ((unsigned int )pc->opcode == 72U) {
#line 254
      goto case_73;
    }
#line 254
    if ((unsigned int )pc->opcode == 76U) {
#line 254
      goto case_73;
    }
#line 254
    if ((unsigned int )pc->opcode == 77U) {
#line 254
      goto case_73;
    }
#line 254
    if ((unsigned int )pc->opcode == 78U) {
#line 254
      goto case_73;
    }
#line 254
    if ((unsigned int )pc->opcode == 35U) {
#line 254
      goto case_73;
    }
#line 254
    if ((unsigned int )pc->opcode == 27U) {
#line 254
      goto case_73;
    }
#line 311
    if ((unsigned int )pc->opcode == 16U) {
#line 311
      goto case_16;
    }
#line 311
    if ((unsigned int )pc->opcode == 79U) {
#line 311
      goto case_16;
    }
#line 311
    if ((unsigned int )pc->opcode == 17U) {
#line 311
      goto case_16;
    }
#line 321
    if ((unsigned int )pc->opcode == 38U) {
#line 321
      goto case_38;
    }
#line 321
    if ((unsigned int )pc->opcode == 36U) {
#line 321
      goto case_38;
    }
#line 338
    if ((unsigned int )pc->opcode == 6U) {
#line 338
      goto case_6___0;
    }
#line 338
    if ((unsigned int )pc->opcode == 4U) {
#line 338
      goto case_6___0;
    }
#line 338
    if ((unsigned int )pc->opcode == 12U) {
#line 338
      goto case_6___0;
    }
#line 338
    if ((unsigned int )pc->opcode == 2U) {
#line 338
      goto case_6___0;
    }
#line 338
    if ((unsigned int )pc->opcode == 10U) {
#line 338
      goto case_6___0;
    }
#line 338
    if ((unsigned int )pc->opcode == 8U) {
#line 338
      goto case_6___0;
    }
#line 365
    if ((unsigned int )pc->opcode == 45U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 44U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 43U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 42U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 41U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 40U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 5U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 3U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 11U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 1U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 9U) {
#line 365
      goto case_45;
    }
#line 365
    if ((unsigned int )pc->opcode == 7U) {
#line 365
      goto case_45;
    }
#line 378
    if ((unsigned int )pc->opcode == 21U) {
#line 378
      goto case_21;
    }
#line 378
    if ((unsigned int )pc->opcode == 20U) {
#line 378
      goto case_21;
    }
#line 378
    if ((unsigned int )pc->opcode == 19U) {
#line 378
      goto case_21;
    }
#line 378
    if ((unsigned int )pc->opcode == 18U) {
#line 378
      goto case_21;
    }
#line 391
    if ((unsigned int )pc->opcode == 24U) {
#line 391
      goto case_24;
    }
#line 391
    if ((unsigned int )pc->opcode == 22U) {
#line 391
      goto case_24;
    }
#line 391
    if ((unsigned int )pc->opcode == 80U) {
#line 391
      goto case_24;
    }
#line 391
    if ((unsigned int )pc->opcode == 23U) {
#line 391
      goto case_24;
    }
#line 408
    if ((unsigned int )pc->opcode == 34U) {
#line 408
      goto case_34;
    }
#line 408
    if ((unsigned int )pc->opcode == 31U) {
#line 408
      goto case_34;
    }
#line 408
    if ((unsigned int )pc->opcode == 30U) {
#line 408
      goto case_34;
    }
#line 408
    if ((unsigned int )pc->opcode == 29U) {
#line 408
      goto case_34;
    }
#line 408
    if ((unsigned int )pc->opcode == 33U) {
#line 408
      goto case_34;
    }
#line 408
    if ((unsigned int )pc->opcode == 32U) {
#line 408
      goto case_34;
    }
#line 408
    if ((unsigned int )pc->opcode == 25U) {
#line 408
      goto case_34;
    }
#line 417
    if ((unsigned int )pc->opcode == 28U) {
#line 417
      goto case_28;
    }
#line 429
    if ((unsigned int )pc->opcode == 13U) {
#line 429
      goto case_13;
    }
#line 435
    if ((unsigned int )pc->opcode == 60U) {
#line 435
      goto case_60;
    }
#line 453
    if ((unsigned int )pc->opcode == 61U) {
#line 453
      goto case_61;
    }
#line 458
    if ((unsigned int )pc->opcode == 69U) {
#line 458
      goto case_69;
    }
#line 496
    if ((unsigned int )pc->opcode == 96U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 95U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 15U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 39U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 37U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 81U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 84U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 85U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 83U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 100U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 86U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 87U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 90U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 89U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 88U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 94U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 93U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 92U) {
#line 496
      goto case_96;
    }
#line 496
    if ((unsigned int )pc->opcode == 91U) {
#line 496
      goto case_96;
    }
#line 499
    if ((unsigned int )pc->opcode == 66U) {
#line 499
      goto case_66;
    }
#line 514
    if ((unsigned int )pc->opcode == 67U) {
#line 514
      goto case_67;
    }
#line 514
    if ((unsigned int )pc->opcode == 65U) {
#line 514
      goto case_67;
    }
#line 536
    if ((unsigned int )pc->opcode == 55U) {
#line 536
      goto case_55;
    }
#line 536
    if ((unsigned int )pc->opcode == 56U) {
#line 536
      goto case_55;
    }
#line 536
    if ((unsigned int )pc->opcode == 54U) {
#line 536
      goto case_55;
    }
#line 560
    if ((unsigned int )pc->opcode == 75U) {
#line 560
      goto case_75;
    }
#line 565
    if ((unsigned int )pc->opcode == 47U) {
#line 565
      goto case_47;
    }
#line 574
    if ((unsigned int )pc->opcode == 46U) {
#line 574
      goto case_46;
    }
#line 574
    if ((unsigned int )pc->opcode == 48U) {
#line 574
      goto case_46;
    }
#line 602
    if ((unsigned int )pc->opcode == 62U) {
#line 602
      goto case_62;
    }
#line 602
    if ((unsigned int )pc->opcode == 63U) {
#line 602
      goto case_62;
    }
#line 629
    if ((unsigned int )pc->opcode == 70U) {
#line 629
      goto case_70;
    }
#line 629
    if ((unsigned int )pc->opcode == 71U) {
#line 629
      goto case_70;
    }
#line 657
    if ((unsigned int )pc->opcode == 57U) {
#line 657
      goto case_57;
    }
#line 657
    if ((unsigned int )pc->opcode == 64U) {
#line 657
      goto case_57;
    }
#line 657
    if ((unsigned int )pc->opcode == 52U) {
#line 657
      goto case_57;
    }
#line 657
    if ((unsigned int )pc->opcode == 53U) {
#line 657
      goto case_57;
    }
#line 662
    if ((unsigned int )pc->opcode == 58U) {
#line 662
      goto case_58;
    }
#line 662
    if ((unsigned int )pc->opcode == 59U) {
#line 662
      goto case_58;
    }
#line 671
    if ((unsigned int )pc->opcode == 82U) {
#line 671
      goto case_82;
    }
#line 679
    if ((unsigned int )pc->opcode == 14U) {
#line 679
      goto case_14;
    }
#line 692
    if ((unsigned int )pc->opcode == 109U) {
#line 692
      goto case_109;
    }
#line 708
    if ((unsigned int )pc->opcode == 106U) {
#line 708
      goto case_106;
    }
#line 723
    if ((unsigned int )pc->opcode == 107U) {
#line 723
      goto case_107;
    }
#line 750
    if ((unsigned int )pc->opcode == 108U) {
#line 750
      goto case_108;
    }
#line 776
    if ((unsigned int )pc->opcode == 110U) {
#line 776
      goto case_110;
    }
#line 790
    if ((unsigned int )pc->opcode == 51U) {
#line 790
      goto case_51;
    }
#line 790
    if ((unsigned int )pc->opcode == 50U) {
#line 790
      goto case_51;
    }
#line 803
    if ((unsigned int )pc->opcode == 111U) {
#line 803
      goto case_111;
    }
#line 824
    if ((unsigned int )pc->opcode == 112U) {
#line 824
      goto case_112;
    }
#line 834
    if ((unsigned int )pc->opcode == 114U) {
#line 834
      goto case_114;
    }
#line 864
    if ((unsigned int )pc->opcode == 98U) {
#line 864
      goto case_98;
    }
#line 869
    goto switch_default___1;
    case_49: /* CIL Label */ 
#line 183
    source = pc->d.name;
#line 184
    rule___0 = (int )pc->x.xl;
#line 186
    if (rule___0 != 2) {
#line 187
      tmp___3 = rule_count[rule___0];
#line 187
      (rule_count[rule___0]) ++;
#line 187
      if (! tmp___3) {
        {
#line 188
        tmp___2 = gettext("\t# %s block(s)\n\n");
#line 188
        fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)tmp___2,
                ruletab[rule___0]);
        }
      }
      {
#line 189
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\t%s {\n",
              ruletab[rule___0]);
#line 190
      ip = (pc + 1)->x.xi;
      }
    } else {
#line 192
      tmp___5 = rule_count[rule___0];
#line 192
      (rule_count[rule___0]) ++;
#line 192
      if (! tmp___5) {
        {
#line 193
        tmp___4 = gettext("\t# Rule(s)\n\n");
#line 193
        fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)tmp___4);
        }
      }
      {
#line 194
      ip = pc->nexti;
#line 195
      indent___0(ip->d.dl);
      }
#line 196
      if ((unsigned long )ip != (unsigned long )(pc + 1)->x.xi) {
        {
#line 197
        pprint(ip->nexti, (pc + 1)->x.xi, (_Bool)0);
#line 198
        t1 = pp_pop();
#line 199
        fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s {",
                t1->sub.nodep.name);
#line 200
        pp_free(t1);
#line 201
        ip = (pc + 1)->x.xi;
        }
#line 203
        if (do_flags & 4096) {
#line 203
          if (ip->d.dl > 0L) {
            {
#line 204
            fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)" # %ld",
                    ip->d.dl);
            }
          }
        }
        {
#line 206
        fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\n");
        }
      } else {
        {
#line 208
        fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"{\n");
#line 209
        ip = (pc + 1)->x.xi;
        }
      }
#line 211
      ip = ip->nexti;
    }
    {
#line 213
    indent_in();
#line 214
    pprint(ip, (pc + 1)->d.di, (_Bool)0);
#line 215
    indent_out();
#line 216
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\t}\n\n");
#line 217
    pc = (pc + 1)->d.di;
    }
#line 218
    goto switch_break;
    case_101: /* CIL Label */ 
#line 221
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 224
    memset((void *)(rule_count), 0, 6UL * sizeof(int ));
    }
#line 225
    goto switch_break;
    case_74: /* CIL Label */ 
#line 228
    m = pc->d.dn;
#line 229
    if ((unsigned long )m == (unsigned long )Nnull_string) {
      {
#line 230
      pp_push((int )pc->opcode, m->sub.val.sp, 1);
      }
    } else
#line 231
    if ((m->flags & 16U) != 0U) {
      {
#line 232
      tmp___6 = pp_number(m);
#line 232
      pp_push((int )pc->opcode, tmp___6, 2);
      }
    } else {
      {
#line 234
      str = pp_string((char const   *)m->sub.val.sp, m->sub.val.slen, '\"');
      }
#line 235
      if ((m->flags & 128U) != 0U) {
        {
#line 236
        tmp___7 = str;
#line 237
        str = pp_concat("_", (char const   *)tmp___7, "");
#line 238
        free((void *)tmp___7);
        }
      }
      {
#line 240
      pp_push((int )pc->opcode, str, 2);
      }
    }
#line 242
    goto switch_break;
    case_26: /* CIL Label */ 
#line 245
    if ((unsigned long )pc->x.xn != (unsigned long )((void *)0)) {
      {
#line 246
      tmp___8 = pp_node(pc->x.xn);
#line 246
      pp_push(74, tmp___8, 2);
      }
    }
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 255
    m = pc->d.dn;
    {
#line 257
    if ((unsigned int )m->type == 7U) {
#line 257
      goto case_7;
    }
#line 263
    if ((unsigned int )m->type == 5U) {
#line 263
      goto case_5;
    }
#line 263
    if ((unsigned int )m->type == 6U) {
#line 263
      goto case_5;
    }
#line 263
    if ((unsigned int )m->type == 4U) {
#line 263
      goto case_5;
    }
#line 271
    goto switch_default;
    case_7: /* CIL Label */ 
    {
#line 258
    pp_push((int )pc->opcode, (func_params + m->sub.nodep.l.ll)->sub.nodep.name, 1);
    }
#line 259
    goto switch_break___0;
    case_5: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 264
    if ((unsigned long )m->sub.nodep.name != (unsigned long )((void *)0)) {
      {
#line 265
      pp_push((int )pc->opcode, m->sub.nodep.name, 1);
      }
    } else {
      {
#line 267
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 267);
#line 267
      tmp___9 = nodetype2str(m->type);
#line 267
      tmp___10 = gettext("internal error: %s with null vname");
#line 267
      r_fatal((char const   *)tmp___10, tmp___9);
      }
    }
#line 269
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 272
    r_fatal("internal error line %d, file: %s", 272, "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c");
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 276
    if ((unsigned int )pc->opcode == 26U) {
#line 276
      goto case_26___0;
    }
#line 282
    if ((unsigned int )pc->opcode == 27U) {
#line 282
      goto case_27___0;
    }
#line 291
    if ((unsigned int )pc->opcode == 35U) {
#line 291
      goto case_35___0;
    }
#line 304
    goto switch_default___0;
    case_26___0: /* CIL Label */ 
    {
#line 277
    t2 = pp_pop();
#line 278
    t1 = pp_pop();
#line 279
    tmp___11 = op2str(pc->opcode);
#line 279
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s%s%s",
            t2->sub.nodep.name, tmp___11, t1->sub.nodep.name);
    }
#line 280
    goto cleanup;
    case_27___0: /* CIL Label */ 
    {
#line 283
    t1 = pp_pop();
#line 284
    tmp___12 = op2str((OPCODE )16);
#line 284
    tmp___1 = pp_list((int )pc->x.xl, tmp___12, ", ");
#line 285
    t2 = pp_pop();
#line 286
    tmp___13 = op2str(pc->opcode);
#line 286
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s%s%s%s",
            t1->sub.nodep.name, tmp___1, tmp___13, t2->sub.nodep.name);
#line 288
    free((void *)tmp___1);
    }
#line 289
    goto cleanup;
    case_35___0: /* CIL Label */ 
    {
#line 292
    t2 = pp_pop();
#line 293
    t1 = pp_pop();
#line 294
    tmp___14 = op2str((OPCODE )13);
#line 294
    tmp___1 = pp_concat((char const   *)t2->sub.nodep.name, tmp___14, (char const   *)t1->sub.nodep.name);
#line 295
    tmp___15 = op2str((OPCODE )25);
#line 295
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s%s%s",
            t2->sub.nodep.name, tmp___15, tmp___1);
#line 296
    free((void *)tmp___1);
    }
    cleanup: 
    {
#line 298
    pp_free(t2);
#line 299
    pp_free(t1);
    }
#line 300
    if (! in_for_header) {
      {
#line 301
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\n");
      }
    }
#line 302
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 305
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 307
    goto switch_break;
    case_16: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_17: /* CIL Label */ 
    {
#line 312
    tmp___16 = op2str(pc->opcode);
#line 312
    tmp___1 = pp_list((int )pc->d.dl, tmp___16, ", ");
#line 313
    t1 = pp_pop();
#line 314
    str = pp_concat((char const   *)t1->sub.nodep.name, (char const   *)tmp___1, "");
#line 315
    free((void *)tmp___1);
#line 316
    pp_free(t1);
#line 317
    pp_push((int )pc->opcode, str, 2);
    }
#line 318
    goto switch_break;
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    {
#line 322
    pprint(pc->nexti, pc->d.di, in_for_header);
#line 323
    t2 = pp_pop();
#line 324
    t1 = pp_pop();
#line 325
    parenthesize((int )pc->opcode, t1, t2);
#line 326
    tmp___17 = op2str(pc->opcode);
#line 326
    str = pp_concat((char const   *)t1->sub.nodep.name, tmp___17, (char const   *)t2->sub.nodep.name);
#line 327
    pp_free(t1);
#line 328
    pp_free(t2);
#line 329
    pp_push((int )pc->opcode, str, 2);
#line 330
    pc = pc->d.di;
    }
#line 331
    goto switch_break;
    case_6___0: /* CIL Label */ 
    case_4___0: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
    {
#line 339
    m = pc->d.dn;
#line 340
    t1 = pp_pop();
#line 341
    tmp___18 = prec_level((int )pc->opcode);
#line 341
    tmp___19 = prec_level((int )t1->type);
    }
#line 341
    if (tmp___18 > tmp___19) {
      {
#line 341
      tmp___20 = is_binary((int )t1->type);
      }
#line 341
      if (tmp___20) {
        {
#line 343
        pp_parenthesize(t1);
        }
      }
    }
#line 344
    if ((m->flags & 16U) != 0U) {
      {
#line 345
      tmp___1 = pp_number(m);
      }
    } else {
      {
#line 347
      tmp___1 = pp_string((char const   *)m->sub.val.sp, m->sub.val.slen, '\"');
      }
    }
    {
#line 348
    tmp___21 = op2str(pc->opcode);
#line 348
    str = pp_concat((char const   *)t1->sub.nodep.name, tmp___21, (char const   *)tmp___1);
#line 349
    free((void *)tmp___1);
#line 350
    pp_free(t1);
#line 351
    pp_push((int )pc->opcode, str, 2);
    }
#line 352
    goto switch_break;
    case_45: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_7___0: /* CIL Label */ 
    {
#line 366
    t2 = pp_pop();
#line 367
    t1 = pp_pop();
#line 368
    parenthesize((int )pc->opcode, t1, t2);
#line 369
    tmp___22 = op2str(pc->opcode);
#line 369
    str = pp_concat((char const   *)t1->sub.nodep.name, tmp___22, (char const   *)t2->sub.nodep.name);
#line 370
    pp_free(t1);
#line 371
    pp_free(t2);
#line 372
    pp_push((int )pc->opcode, str, 2);
    }
#line 373
    goto switch_break;
    case_21: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_18: /* CIL Label */ 
    {
#line 379
    t1 = pp_pop();
    }
#line 380
    if ((unsigned int )pc->opcode == 18U) {
      {
#line 381
      tmp___23 = op2str(pc->opcode);
#line 381
      str = pp_concat(tmp___23, (char const   *)t1->sub.nodep.name, "");
      }
    } else
#line 380
    if ((unsigned int )pc->opcode == 19U) {
      {
#line 381
      tmp___23 = op2str(pc->opcode);
#line 381
      str = pp_concat(tmp___23, (char const   *)t1->sub.nodep.name, "");
      }
    } else {
      {
#line 383
      tmp___24 = op2str(pc->opcode);
#line 383
      str = pp_concat((char const   *)t1->sub.nodep.name, tmp___24, "");
      }
    }
    {
#line 384
    pp_free(t1);
#line 385
    pp_push((int )pc->opcode, str, 2);
    }
#line 386
    goto switch_break;
    case_24: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_23: /* CIL Label */ 
    {
#line 392
    t1 = pp_pop();
#line 393
    tmp___25 = is_binary((int )t1->type);
    }
#line 393
    if (tmp___25) {
      {
#line 394
      pp_parenthesize(t1);
      }
    }
    {
#line 397
    tmp___26 = op2str(pc->opcode);
#line 397
    str = pp_concat(tmp___26, (char const   *)t1->sub.nodep.name, "");
#line 398
    pp_free(t1);
#line 399
    pp_push((int )pc->opcode, str, 2);
    }
#line 400
    goto switch_break;
    case_34: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_25: /* CIL Label */ 
    {
#line 409
    t2 = pp_pop();
#line 410
    t1 = pp_pop();
#line 411
    tmp___27 = op2str(pc->opcode);
#line 411
    str = pp_concat((char const   *)t2->sub.nodep.name, tmp___27, (char const   *)t1->sub.nodep.name);
#line 412
    pp_free(t2);
#line 413
    pp_free(t1);
#line 414
    pp_push((int )pc->opcode, str, 2);
    }
#line 415
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 418
    t1 = pp_pop();
#line 419
    tmp___28 = is_binary((int )t1->type);
    }
#line 419
    if (tmp___28) {
      {
#line 420
      pp_parenthesize(t1);
      }
    }
    {
#line 421
    t2 = pp_pop();
#line 422
    tmp___29 = op2str(pc->opcode);
#line 422
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"$%s%s%s",
            t1->sub.nodep.name, tmp___29, t2->sub.nodep.name);
#line 423
    pp_free(t2);
#line 424
    pp_free(t1);
    }
#line 425
    if (! in_for_header) {
      {
#line 426
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\n");
      }
    }
#line 427
    goto switch_break;
    case_13: /* CIL Label */ 
#line 430
    if ((pc->d.dl & 1L) != 0L) {
#line 430
      tmp___31 = ", ";
    } else {
      {
#line 430
      tmp___30 = op2str((OPCODE )13);
#line 430
      tmp___31 = tmp___30;
      }
    }
    {
#line 430
    str = pp_list((int )pc->x.xl, (char const   *)((void *)0), tmp___31);
#line 432
    pp_push(13, str, 2);
    }
#line 433
    goto switch_break;
    case_60: /* CIL Label */ 
    {
#line 438
    t1 = pp_pop();
#line 439
    array = t1->sub.nodep.name;
    }
#line 440
    if (pc->x.xl > 0L) {
      {
#line 442
      sub = pp_list((int )pc->x.xl, (char const   *)((void *)0), ", ");
#line 443
      tmp___32 = op2str((OPCODE )60);
#line 443
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s %s[%s]",
              tmp___32, array, sub);
#line 444
      free((void *)sub);
      }
    } else {
      {
#line 446
      tmp___33 = op2str((OPCODE )60);
#line 446
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s %s",
              tmp___33, array);
      }
    }
#line 447
    if (! in_for_header) {
      {
#line 448
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 449
    pp_free(t1);
    }
#line 451
    goto switch_break;
    case_61: /* CIL Label */ 
    {
#line 455
    r_fatal("internal error line %d, file: %s", 455, "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c");
    }
#line 456
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 461
    t1 = pp_pop();
#line 462
    array___0 = t1->sub.nodep.name;
    }
#line 463
    if (pc->x.xl > 1L) {
      {
#line 464
      sub___0 = pp_list((int )pc->x.xl, "()", ", ");
#line 465
      tmp___34 = op2str((OPCODE )69);
#line 465
      str = pp_concat((char const   *)sub___0, tmp___34, (char const   *)array___0);
#line 466
      free((void *)sub___0);
      }
    } else {
      {
#line 468
      t2 = pp_pop();
#line 469
      sub___0 = t2->sub.nodep.name;
#line 470
      tmp___35 = op2str((OPCODE )69);
#line 470
      str = pp_concat((char const   *)sub___0, tmp___35, (char const   *)array___0);
#line 471
      pp_free(t2);
      }
    }
    {
#line 473
    pp_free(t1);
#line 474
    pp_push(69, str, 2);
    }
#line 476
    goto switch_break;
    case_96: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
#line 497
    goto switch_break;
    case_66: /* CIL Label */ 
#line 501
    fname = "sub";
#line 502
    if ((pc->d.dl & 1L) != 0L) {
#line 503
      fname = "gsub";
    } else
#line 504
    if ((pc->d.dl & 2L) != 0L) {
#line 505
      fname = "gensub";
    }
    {
#line 506
    tmp___1 = pp_list((int )pc->x.xl, "()", ", ");
#line 507
    str = pp_concat(fname, (char const   *)tmp___1, "");
#line 508
    free((void *)tmp___1);
#line 509
    pp_push(66, str, 2);
    }
#line 511
    goto switch_break;
    case_67: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 517
    if ((unsigned int )pc->opcode == 65U) {
      {
#line 518
      fname___0 = getfname(pc->d.fptr);
      }
    } else {
#line 520
      fname___0 = (char const   *)(pc + 1)->d.name;
    }
#line 521
    if ((unsigned long )fname___0 != (unsigned long )((void *)0)) {
#line 522
      if (pc->x.xl > 0L) {
        {
#line 523
        tmp___1 = pp_list((int )pc->x.xl, "()", ", ");
#line 524
        str = pp_concat(fname___0, (char const   *)tmp___1, "");
#line 525
        free((void *)tmp___1);
        }
      } else {
        {
#line 527
        str = pp_concat(fname___0, "()", "");
        }
      }
      {
#line 528
      pp_push(65, str, 2);
      }
    } else {
      {
#line 530
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 530);
#line 530
      tmp___36 = gettext("internal error: builtin with null fname");
#line 530
      r_fatal((char const   *)tmp___36);
      }
    }
#line 532
    goto switch_break;
    case_55: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_54: /* CIL Label */ 
#line 537
    if ((unsigned int )pc->opcode == 55U) {
      {
#line 538
      tmp___37 = op2str((OPCODE )23);
#line 538
      tmp___1 = pp_concat(" ", tmp___37, "0");
      }
    } else
#line 539
    if (pc->d.dl != 0L) {
      {
#line 540
      tmp___1 = pp_list((int )pc->x.xl, "()", ", ");
      }
    } else {
      {
#line 542
      tmp___1 = pp_list((int )pc->x.xl, "  ", ", ");
#line 543
      tmp___38 = strlen((char const   *)tmp___1);
#line 543
      *(tmp___1 + (tmp___38 - 1UL)) = (char )'\000';
      }
    }
#line 546
    if (pc->d.dl != 0L) {
      {
#line 547
      t1 = pp_pop();
#line 548
      tmp___39 = is_binary((int )t1->type);
      }
#line 548
      if (tmp___39) {
        {
#line 549
        pp_parenthesize(t1);
        }
      }
      {
#line 550
      tmp___40 = redir2str((int )pc->d.dl);
#line 550
      tmp___41 = op2str(pc->opcode);
#line 550
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s%s%s%s",
              tmp___41, tmp___1, tmp___40, t1->sub.nodep.name);
#line 552
      pp_free(t1);
      }
    } else {
      {
#line 554
      tmp___42 = op2str(pc->opcode);
#line 554
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s%s",
              tmp___42, tmp___1);
      }
    }
    {
#line 555
    free((void *)tmp___1);
    }
#line 556
    if (! in_for_header) {
      {
#line 557
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\n");
      }
    }
#line 558
    goto switch_break;
    case_75: /* CIL Label */ 
#line 561
    if ((unsigned int )(pc->d.dn)->type != 2U) {
#line 562
      goto switch_break;
    }
    case_47: /* CIL Label */ 
    {
#line 567
    re = (pc->d.dn)->sub.nodep.x.extra;
#line 568
    str = pp_string((char const   *)re->sub.val.sp, re->sub.val.slen, '/');
#line 569
    pp_push((int )pc->opcode, str, 2);
    }
#line 571
    goto switch_break;
    case_46: /* CIL Label */ 
    case_48: /* CIL Label */ 
    {
#line 577
    t1 = pp_pop();
#line 578
    tmp___43 = is_binary((int )t1->type);
    }
#line 578
    if (tmp___43) {
      {
#line 579
      pp_parenthesize(t1);
      }
    }
#line 580
    txt = t1->sub.nodep.name;
#line 581
    m = pc->d.dn;
#line 582
    if ((unsigned int )m->type == 3U) {
      {
#line 583
      restr = txt;
#line 584
      t2 = pp_pop();
#line 585
      tmp___44 = is_binary((int )t2->type);
      }
#line 585
      if (tmp___44) {
        {
#line 586
        pp_parenthesize(t2);
        }
      }
      {
#line 587
      txt = t2->sub.nodep.name;
#line 588
      tmp___45 = op2str(pc->opcode);
#line 588
      str = pp_concat((char const   *)txt, tmp___45, (char const   *)restr);
#line 589
      pp_free(t2);
      }
    } else {
      {
#line 591
      re___0 = m->sub.nodep.x.extra;
#line 592
      restr = pp_string((char const   *)re___0->sub.val.sp, re___0->sub.val.slen,
                        '/');
#line 593
      tmp___46 = op2str(pc->opcode);
#line 593
      str = pp_concat((char const   *)txt, tmp___46, (char const   *)restr);
#line 594
      free((void *)restr);
      }
    }
    {
#line 596
    pp_free(t1);
#line 597
    pp_push((int )pc->opcode, str, 2);
    }
#line 599
    goto switch_break;
    case_62: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 603
    if (pc->x.xl) {
      {
#line 604
      t1 = pp_pop();
#line 605
      tmp___47 = op2str((OPCODE )63);
#line 605
      tmp___1 = pp_concat(tmp___47, " ", (char const   *)t1->sub.nodep.name);
#line 606
      pp_free(t1);
      }
    } else {
      {
#line 608
      tmp___48 = op2str((OPCODE )63);
#line 608
      tmp___1 = pp_concat(tmp___48, "", "");
      }
    }
#line 610
    if (pc->d.dl != 0L) {
#line 611
      if (pc->d.dl == 4L) {
#line 611
        tmp___49 = 1;
      } else
#line 611
      if (pc->d.dl == 6L) {
#line 611
        tmp___49 = 1;
      } else {
#line 611
        tmp___49 = 0;
      }
      {
#line 611
      before = tmp___49;
#line 614
      t2 = pp_pop();
#line 615
      tmp___50 = is_binary((int )t2->type);
      }
#line 615
      if (tmp___50) {
        {
#line 616
        pp_parenthesize(t2);
        }
      }
#line 617
      if (before) {
        {
#line 618
        tmp___51 = redir2str((int )pc->d.dl);
#line 618
        str = pp_concat((char const   *)t2->sub.nodep.name, tmp___51, (char const   *)tmp___1);
        }
      } else {
        {
#line 620
        tmp___52 = redir2str((int )pc->d.dl);
#line 620
        str = pp_concat((char const   *)tmp___1, tmp___52, (char const   *)t2->sub.nodep.name);
        }
      }
      {
#line 621
      free((void *)tmp___1);
#line 622
      pp_free(t2);
      }
    } else {
#line 624
      str = tmp___1;
    }
    {
#line 625
    pp_push((int )pc->opcode, str, 2);
    }
#line 626
    goto switch_break;
    case_70: /* CIL Label */ 
    case_71: /* CIL Label */ 
#line 631
    fname___1 = pc->d.name;
#line 635
    if ((unsigned int )pc->opcode == 71U) {
#line 636
      pre = (char *)"@";
    } else {
#line 638
      pre = (char *)"";
    }
#line 639
    pcount = (int )(pc + 1)->x.xl;
#line 640
    if (pcount > 0) {
      {
#line 641
      tmp___1 = pp_list(pcount, "()", ", ");
#line 642
      str = pp_concat((char const   *)pre, (char const   *)fname___1, (char const   *)tmp___1);
#line 643
      free((void *)tmp___1);
      }
    } else {
      {
#line 645
      str = pp_concat((char const   *)pre, (char const   *)fname___1, "()");
      }
    }
#line 646
    if ((unsigned int )pc->opcode == 71U) {
      {
#line 647
      t1 = pp_pop();
#line 648
      pp_free(t1);
      }
    }
    {
#line 650
    pp_push((int )pc->opcode, str, 2);
    }
#line 652
    goto switch_break;
    case_57: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_53: /* CIL Label */ 
    {
#line 658
    tmp___53 = op2str(pc->opcode);
#line 658
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s\n",
            tmp___53);
    }
#line 659
    goto switch_break;
    case_58: /* CIL Label */ 
    case_59: /* CIL Label */ 
    {
#line 663
    t1 = pp_pop();
#line 664
    tmp___54 = is_binary((int )t1->type);
    }
#line 664
    if (tmp___54) {
      {
#line 665
      pp_parenthesize(t1);
      }
    }
#line 666
    if ((int )pc->source_line > 0) {
      {
#line 667
      tmp___55 = op2str(pc->opcode);
#line 667
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s %s\n",
              tmp___55, t1->sub.nodep.name);
      }
    }
    {
#line 668
    pp_free(t1);
    }
#line 669
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 672
    t1 = pp_pop();
#line 673
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s",
            t1->sub.nodep.name);
    }
#line 674
    if (! in_for_header) {
      {
#line 675
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\n");
      }
    }
    {
#line 676
    pp_free(t1);
    }
#line 677
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 680
    ip = pc + 1;
#line 681
    pprint(pc->nexti, ip->d.di, (_Bool)0);
#line 682
    pprint((ip->d.di)->nexti, ip->x.xi, (_Bool)0);
#line 683
    t2 = pp_pop();
#line 684
    t1 = pp_pop();
#line 685
    str = pp_concat((char const   *)t1->sub.nodep.name, ", ", (char const   *)t2->sub.nodep.name);
#line 686
    pp_free(t1);
#line 687
    pp_free(t2);
#line 688
    pp_push(14, str, 2);
#line 689
    pc = ip->x.xi;
    }
#line 690
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 693
    ip = pc + 1;
#line 694
    indent___0((ip->d.di)->d.dl);
#line 695
    tmp___56 = op2str(pc->opcode);
#line 695
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s (",
            tmp___56);
#line 696
    pprint(pc->nexti, ip->d.di, (_Bool)0);
#line 697
    t1 = pp_pop();
#line 698
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s) {\n",
            t1->sub.nodep.name);
#line 699
    pp_free(t1);
#line 700
    indent_in();
#line 701
    pprint((ip->d.di)->nexti, pc->x.xi, (_Bool)0);
#line 702
    indent_out();
#line 703
    indent___0(0L);
#line 704
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"}\n");
#line 705
    pc = pc->x.xi;
    }
#line 706
    goto switch_break;
    case_106: /* CIL Label */ 
    {
#line 709
    ip = pc + 1;
#line 710
    indent___0((pc->nexti)->d.dl);
#line 711
    tmp___57 = op2str(pc->opcode);
#line 711
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s {\n",
            tmp___57);
#line 712
    indent_in();
#line 713
    pprint((pc->nexti)->nexti, ip->d.di, (_Bool)0);
#line 714
    indent_out();
#line 715
    pprint(ip->d.di, pc->x.xi, (_Bool)0);
#line 716
    indent___0(0L);
#line 717
    t1 = pp_pop();
#line 718
    tmp___58 = op2str((OPCODE )109);
#line 718
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"} %s (%s)\n",
            tmp___58, t1->sub.nodep.name);
#line 719
    pp_free(t1);
#line 720
    pc = pc->x.xi;
    }
#line 721
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 724
    ip = pc + 1;
#line 725
    indent___0((ip->x.xi)->d.dl);
#line 726
    tmp___59 = op2str(pc->opcode);
#line 726
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s (",
            tmp___59);
#line 727
    pprint(pc->nexti, ip->d.di, (_Bool)1);
#line 728
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"; ");
    }
#line 730
    if ((unsigned int )(ip->d.di)->opcode == 81U) {
#line 730
      if ((unsigned long )(ip->d.di)->nexti == (unsigned long )ip->x.xi) {
        {
#line 732
        fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"; ");
        }
      } else {
        {
#line 734
        pprint(ip->d.di, ip->x.xi, (_Bool)1);
#line 735
        t1 = pp_pop();
#line 736
        fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s; ",
                t1->sub.nodep.name);
#line 737
        pp_free(t1);
        }
      }
    } else {
      {
#line 734
      pprint(ip->d.di, ip->x.xi, (_Bool)1);
#line 735
      t1 = pp_pop();
#line 736
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s; ",
              t1->sub.nodep.name);
#line 737
      pp_free(t1);
      }
    }
    {
#line 740
    pprint(pc->d.di, pc->x.xi, (_Bool)1);
#line 741
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)") {\n");
#line 742
    indent_in();
#line 743
    pprint((ip->x.xi)->nexti, pc->d.di, (_Bool)0);
#line 744
    indent_out();
#line 745
    indent___0(0L);
#line 746
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"}\n");
#line 747
    pc = pc->x.xi;
    }
#line 748
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 755
    ip = pc + 1;
#line 756
    t1 = pp_pop();
#line 757
    array___1 = t1->sub.nodep.name;
#line 758
    m = (ip->d.di)->x.xn;
    }
#line 759
    if ((unsigned int )m->type == 7U) {
#line 760
      item = (char const   *)(func_params + m->sub.nodep.l.ll)->sub.nodep.name;
    } else {
#line 762
      item = (char const   *)m->sub.nodep.name;
    }
    {
#line 763
    indent___0((ip->x.xi)->d.dl);
#line 764
    tmp___60 = op2str((OPCODE )69);
#line 764
    tmp___61 = op2str((OPCODE )108);
#line 764
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s (%s%s%s) {\n",
            tmp___61, item, tmp___60, array___1);
#line 766
    indent_in();
#line 767
    pp_free(t1);
#line 768
    pprint((ip->x.xi)->nexti, pc->x.xi, (_Bool)0);
#line 769
    indent_out();
#line 770
    indent___0(0L);
#line 771
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"}\n");
#line 772
    pc = pc->x.xi;
    }
#line 774
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 777
    ip = pc + 1;
#line 778
    tmp___62 = op2str(pc->opcode);
#line 778
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s (",
            tmp___62);
#line 779
    pprint(pc->nexti, ip->d.di, (_Bool)0);
#line 780
    t1 = pp_pop();
#line 781
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s) {\n",
            t1->sub.nodep.name);
#line 782
    pp_free(t1);
#line 783
    pprint(ip->d.di, ip->x.xi, (_Bool)0);
#line 784
    indent___0(0L);
#line 785
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"}\n");
#line 786
    pc = pc->x.xi;
    }
#line 787
    goto switch_break;
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    {
#line 791
    indent___0((pc->d.di)->d.dl);
    }
#line 792
    if ((unsigned int )pc->opcode == 50U) {
      {
#line 793
      t1 = pp_pop();
#line 794
      tmp___63 = op2str(pc->opcode);
#line 794
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s %s:\n",
              tmp___63, t1->sub.nodep.name);
#line 795
      pp_free(t1);
      }
    } else {
      {
#line 797
      tmp___64 = op2str(pc->opcode);
#line 797
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s:\n",
              tmp___64);
      }
    }
    {
#line 798
    indent_in();
#line 799
    pprint((pc->d.di)->nexti, (pc->x.xi)->nexti, (_Bool)0);
#line 800
    indent_out();
    }
#line 801
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 804
    tmp___65 = op2str(pc->opcode);
#line 804
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s (",
            tmp___65);
#line 805
    pprint(pc->nexti, pc->d.di, (_Bool)0);
#line 806
    t1 = pp_pop();
#line 807
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s) {",
            t1->sub.nodep.name);
#line 808
    pp_free(t1);
#line 810
    ip = pc->d.di;
    }
#line 811
    if (ip->d.dl > 0L) {
      {
#line 812
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)" # %ld",
              ip->d.dl);
      }
    }
    {
#line 813
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\n");
#line 814
    indent_in();
#line 815
    pprint(ip->nexti, pc->x.xi, (_Bool)0);
#line 816
    indent_out();
#line 817
    pc = pc->x.xi;
    }
#line 818
    if ((unsigned int )(pc->nexti)->opcode == 81U) {
      {
#line 819
      indent___0(0L);
#line 820
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"}\n");
      }
    }
#line 822
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 825
    tmp___66 = op2str(pc->opcode);
#line 825
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"} %s {\n",
            tmp___66);
#line 826
    indent_in();
#line 827
    pprint(pc->nexti, pc->x.xi, (_Bool)0);
#line 828
    indent_out();
#line 829
    indent___0(0L);
#line 830
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"}\n");
#line 831
    pc = pc->x.xi;
    }
#line 832
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 839
    pprint(pc->nexti, pc->d.di, (_Bool)0);
#line 840
    ip = pc->d.di;
#line 841
    pprint(ip->nexti, pc->x.xi, (_Bool)0);
#line 842
    ip = (pc->x.xi)->nexti;
#line 844
    pc = ip->nexti;
#line 846
    pprint(pc->nexti, pc->x.xi, (_Bool)0);
#line 848
    f = pp_pop();
#line 849
    t = pp_pop();
#line 850
    cond = pp_pop();
#line 852
    len = ((f->sub.nodep.reserved + t->sub.nodep.reserved) + cond->sub.nodep.reserved) + 12UL;
#line 853
    tmp___67 = malloc(len);
#line 853
    str = (char *)tmp___67;
    }
#line 853
    if (str) {
#line 853
      tmp___71 = 1;
    } else {
      {
#line 853
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 853);
#line 853
      tmp___68 = __errno_location();
#line 853
      tmp___69 = strerror(*tmp___68);
#line 853
      tmp___70 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 853
      r_fatal((char const   *)tmp___70, "pprint", "str", (long )len, tmp___69);
#line 853
      tmp___71 = 0;
      }
    }
    {
#line 854
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"(%s ? %s : %s)",
            cond->sub.nodep.name, t->sub.nodep.name, f->sub.nodep.name);
#line 856
    pp_free(cond);
#line 857
    pp_free(t);
#line 858
    pp_free(f);
#line 859
    pp_push(114, str, 2);
#line 860
    pc = pc->x.xi;
    }
#line 862
    goto switch_break;
    case_98: /* CIL Label */ 
#line 865
    if (! in_for_header) {
      {
#line 866
      indent___0(pc->d.dl);
      }
    }
#line 867
    goto switch_break;
    switch_default___1: /* CIL Label */ 
    {
#line 870
    r_fatal("internal error line %d, file: %s", 870, "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c");
    }
    switch_break: /* CIL Label */ ;
    }
#line 873
    if ((unsigned long )pc == (unsigned long )endp) {
#line 874
      goto while_break;
    }
#line 177
    pc = pc->nexti;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return;
}
}
#line 885 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
void pp_string_fp(int (*print_func)(FILE * , char const   *  , ...) , FILE *fp___0 ,
                  char const   *in_str , size_t len , int delim , _Bool breaklines ) 
{ 
  char *s___0 ;
  char *tmp___1 ;
  int count ;
  size_t slen ;
  char const   *str ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 889
  tmp___1 = pp_string(in_str, len, delim);
#line 889
  s___0 = tmp___1;
#line 892
  str = (char const   *)s___0;
#line 895
  slen = strlen(str);
#line 896
  count = 0;
  }
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 896
    if (! (slen > 0UL)) {
#line 896
      goto while_break;
    }
#line 897
    count ++;
#line 897
    if (count >= 70) {
#line 897
      if (breaklines) {
        {
#line 898
        (*print_func)(fp___0, "%c\n%c", delim, delim);
#line 899
        count = 0;
        }
      } else {
        {
#line 901
        (*print_func)(fp___0, "%c", (int const   )*str);
        }
      }
    } else {
      {
#line 901
      (*print_func)(fp___0, "%c", (int const   )*str);
      }
    }
#line 896
    slen --;
#line 896
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 903
  free((void *)s___0);
  }
#line 904
  return;
}
}
#line 912
INSTRUCTION *code_block ;
#line 909 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void just_dump(int signum ) 
{ 


  {
  {
#line 914
  dump_prog(code_block);
#line 915
  dump_funcs();
#line 916
  dump_fcall_stack(prof_fp);
#line 917
  fflush(prof_fp);
#line 918
  signal(signum, & just_dump);
  }
#line 919
  return;
}
}
#line 923
static  __attribute__((__noreturn__)) void dump_and_exit(int signum ) ;
#line 923 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void dump_and_exit(int signum ) 
{ 


  {
  {
#line 926
  just_dump(signum);
#line 927
  final_exit(1);
  }
}
}
#line 936
static void print_lib_list(FILE *prof_fp___0 ) ;
#line 936 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static _Bool printed_header  =    (_Bool)0;
#line 932 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void print_lib_list(FILE *prof_fp___0 ) 
{ 
  SRCFILE *s___0 ;
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 938
  s___0 = srcfiles->next;
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    if (! ((unsigned long )s___0 != (unsigned long )srcfiles)) {
#line 938
      goto while_break;
    }
#line 939
    if ((unsigned int )s___0->stype == 5U) {
#line 940
      if (! printed_header) {
        {
#line 941
        printed_header = (_Bool)1;
#line 942
        tmp___1 = gettext("\t# Loaded extensions (-l and/or @load)\n\n");
#line 942
        fprintf((FILE */* __restrict  */)prof_fp___0, (char const   */* __restrict  */)tmp___1);
        }
      }
      {
#line 944
      fprintf((FILE */* __restrict  */)prof_fp___0, (char const   */* __restrict  */)"\t@load \"%s\"\n",
              s___0->src);
      }
    }
#line 938
    s___0 = s___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  if (printed_header) {
    {
#line 948
    fprintf((FILE */* __restrict  */)prof_fp___0, (char const   */* __restrict  */)"\n");
    }
  }
#line 949
  return;
}
}
#line 958 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
void dump_prog(INSTRUCTION *code ) 
{ 
  time_t now ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp5 ;

  {
  {
#line 963
  time(& now);
#line 965
  tmp___1 = ctime((time_t const   *)(& now));
#line 965
  tmp___2 = gettext("\t# gawk profile, created %s\n");
#line 965
  fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)tmp___2,
          tmp___1);
#line 966
  print_lib_list(prof_fp);
#line 967
  pprint(code, (INSTRUCTION *)((void *)0), (_Bool)0);
  }
#line 968
  return;
}
}
#line 972 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static int prec_level(int type ) 
{ 


  {
  {
#line 987
  if (type == 65) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 61) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 70) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 79) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 16) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 47) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 75) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 74) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 72) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 76) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 77) {
#line 987
    goto case_65;
  }
#line 987
  if (type == 78) {
#line 987
    goto case_65;
  }
#line 991
  if (type == 80) {
#line 991
    goto case_80;
  }
#line 991
  if (type == 23) {
#line 991
    goto case_80;
  }
#line 995
  if (type == 12) {
#line 995
    goto case_12;
  }
#line 995
  if (type == 11) {
#line 995
    goto case_12;
  }
#line 1001
  if (type == 21) {
#line 1001
    goto case_21;
  }
#line 1001
  if (type == 20) {
#line 1001
    goto case_21;
  }
#line 1001
  if (type == 19) {
#line 1001
    goto case_21;
  }
#line 1001
  if (type == 18) {
#line 1001
    goto case_21;
  }
#line 1005
  if (type == 24) {
#line 1005
    goto case_24;
  }
#line 1005
  if (type == 22) {
#line 1005
    goto case_24;
  }
#line 1013
  if (type == 6) {
#line 1013
    goto case_6;
  }
#line 1013
  if (type == 5) {
#line 1013
    goto case_6;
  }
#line 1013
  if (type == 4) {
#line 1013
    goto case_6;
  }
#line 1013
  if (type == 3) {
#line 1013
    goto case_6;
  }
#line 1013
  if (type == 2) {
#line 1013
    goto case_6;
  }
#line 1013
  if (type == 1) {
#line 1013
    goto case_6;
  }
#line 1019
  if (type == 10) {
#line 1019
    goto case_10;
  }
#line 1019
  if (type == 9) {
#line 1019
    goto case_10;
  }
#line 1019
  if (type == 8) {
#line 1019
    goto case_10;
  }
#line 1019
  if (type == 7) {
#line 1019
    goto case_10;
  }
#line 1023
  if (type == 35) {
#line 1023
    goto case_35;
  }
#line 1023
  if (type == 13) {
#line 1023
    goto case_35;
  }
#line 1032
  if (type == 48) {
#line 1032
    goto case_48;
  }
#line 1032
  if (type == 46) {
#line 1032
    goto case_48;
  }
#line 1032
  if (type == 45) {
#line 1032
    goto case_48;
  }
#line 1032
  if (type == 44) {
#line 1032
    goto case_48;
  }
#line 1032
  if (type == 43) {
#line 1032
    goto case_48;
  }
#line 1032
  if (type == 41) {
#line 1032
    goto case_48;
  }
#line 1032
  if (type == 40) {
#line 1032
    goto case_48;
  }
#line 1036
  if (type == 62) {
#line 1036
    goto case_62;
  }
#line 1036
  if (type == 63) {
#line 1036
    goto case_62;
  }
#line 1039
  if (type == 42) {
#line 1039
    goto case_42;
  }
#line 1042
  if (type == 69) {
#line 1042
    goto case_69;
  }
#line 1045
  if (type == 36) {
#line 1045
    goto case_36;
  }
#line 1048
  if (type == 38) {
#line 1048
    goto case_38;
  }
#line 1051
  if (type == 114) {
#line 1051
    goto case_114;
  }
#line 1060
  if (type == 34) {
#line 1060
    goto case_34;
  }
#line 1060
  if (type == 33) {
#line 1060
    goto case_34;
  }
#line 1060
  if (type == 32) {
#line 1060
    goto case_34;
  }
#line 1060
  if (type == 31) {
#line 1060
    goto case_34;
  }
#line 1060
  if (type == 30) {
#line 1060
    goto case_34;
  }
#line 1060
  if (type == 29) {
#line 1060
    goto case_34;
  }
#line 1060
  if (type == 25) {
#line 1060
    goto case_34;
  }
#line 1063
  goto switch_default;
  case_65: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_78: /* CIL Label */ 
#line 988
  return (15);
  case_80: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 992
  return (14);
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 996
  return (13);
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 1002
  return (12);
  case_24: /* CIL Label */ 
  case_22: /* CIL Label */ 
#line 1006
  return (11);
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1014
  return (10);
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 1020
  return (9);
  case_35: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 1024
  return (8);
  case_48: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
#line 1033
  return (7);
  case_62: /* CIL Label */ 
  case_63: /* CIL Label */ 
#line 1037
  return (6);
  case_42: /* CIL Label */ 
#line 1040
  return (5);
  case_69: /* CIL Label */ 
#line 1043
  return (5);
  case_36: /* CIL Label */ 
#line 1046
  return (4);
  case_38: /* CIL Label */ 
#line 1049
  return (3);
  case_114: /* CIL Label */ 
#line 1052
  return (2);
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_25: /* CIL Label */ 
#line 1061
  return (1);
  switch_default: /* CIL Label */ 
#line 1064
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1068 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static int is_binary(int type ) 
{ 


  {
  {
#line 1106
  if (type == 63) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 62) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 69) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 38) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 36) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 114) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 34) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 33) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 32) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 31) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 30) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 29) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 25) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 48) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 46) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 35) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 13) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 10) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 8) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 6) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 4) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 2) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 12) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 9) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 7) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 5) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 3) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 1) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 11) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 40) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 41) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 42) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 43) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 44) {
#line 1106
    goto case_63;
  }
#line 1106
  if (type == 45) {
#line 1106
    goto case_63;
  }
#line 1109
  goto switch_default;
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_45: /* CIL Label */ 
#line 1107
  return (1);
  switch_default: /* CIL Label */ 
#line 1110
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1116 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void pp_parenthesize(NODE *sp___0 ) 
{ 
  char *p ;
  size_t len ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1119
  p = sp___0->sub.nodep.name;
#line 1120
  len = sp___0->sub.nodep.reserved;
#line 1122
  tmp___1 = malloc(len + 3UL);
#line 1122
  p = (char *)tmp___1;
  }
#line 1122
  if (p) {
#line 1122
    tmp___5 = 1;
  } else {
    {
#line 1122
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1122);
#line 1122
    tmp___2 = __errno_location();
#line 1122
    tmp___3 = strerror(*tmp___2);
#line 1122
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1122
    r_fatal((char const   *)tmp___4, "pp_parenthesize", "p", (long )(len + 3UL), tmp___3);
#line 1122
    tmp___5 = 0;
    }
  }
  {
#line 1123
  *p = (char )'(';
#line 1124
  memcpy((void */* __restrict  */)(p + 1), (void const   */* __restrict  */)sp___0->sub.nodep.name,
         len);
#line 1125
  *(p + (len + 1UL)) = (char )')';
#line 1126
  *(p + (len + 2UL)) = (char )'\000';
  }
#line 1127
  if ((sp___0->flags & 2U) != 0U) {
    {
#line 1128
    free((void *)sp___0->sub.nodep.name);
    }
  }
#line 1129
  sp___0->sub.nodep.name = p;
#line 1130
  sp___0->sub.nodep.reserved += 2UL;
#line 1131
  sp___0->flags |= 2U;
#line 1132
  return;
}
}
#line 1134 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static void parenthesize(int type , NODE *left , NODE *right ) 
{ 
  int rprec ;
  int tmp___1 ;
  int lprec ;
  int tmp___2 ;
  int prec ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1137
  tmp___1 = prec_level((int )right->type);
#line 1137
  rprec = tmp___1;
#line 1138
  tmp___2 = prec_level((int )left->type);
#line 1138
  lprec = tmp___2;
#line 1139
  tmp___3 = prec_level(type);
#line 1139
  prec = tmp___3;
  }
#line 1141
  if (prec > lprec) {
    {
#line 1142
    tmp___4 = is_binary((int )left->type);
    }
#line 1142
    if (tmp___4) {
      {
#line 1143
      pp_parenthesize(left);
      }
    }
#line 1144
    if (prec >= rprec) {
      {
#line 1144
      tmp___5 = is_binary((int )right->type);
      }
#line 1144
      if (tmp___5) {
        {
#line 1145
        pp_parenthesize(right);
        }
      }
    }
  } else
#line 1147
  if (prec >= rprec) {
    {
#line 1147
    tmp___6 = is_binary((int )right->type);
    }
#line 1147
    if (tmp___6) {
      {
#line 1148
      pp_parenthesize(right);
      }
    }
  }
#line 1150
  return;
}
}
#line 1157 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static char str_escapes[9]  = 
#line 1157
  {      (char )'\a',      (char )'\b',      (char )'\f',      (char )'\n', 
        (char )'\r',      (char )'\t',      (char )'\v',      (char )'\\', 
        (char )'\000'};
#line 1158 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static char str_printables[9]  = 
#line 1158
  {      (char )'a',      (char )'b',      (char )'f',      (char )'n', 
        (char )'r',      (char )'t',      (char )'v',      (char )'\\', 
        (char )'\000'};
#line 1159 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static char re_escapes[8]  = 
#line 1159
  {      (char )'\a',      (char )'\b',      (char )'\f',      (char )'\n', 
        (char )'\r',      (char )'\t',      (char )'\v',      (char )'\000'};
#line 1160 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static char re_printables[8]  = 
#line 1160
  {      (char )'a',      (char )'b',      (char )'f',      (char )'n', 
        (char )'r',      (char )'t',      (char )'v',      (char )'\000'};
#line 1154 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
char *pp_string(char const   *in_str , size_t len , int delim ) 
{ 
  char *escapes ;
  char *printables ;
  char *cp ;
  int i___0 ;
  unsigned char const   *str ;
  size_t ofre ;
  size_t osiz ;
  char *obuf ;
  char *obufout ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  long olen ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  size_t len___0 ;
  long olen___0 ;
  void *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  long olen___1 ;
  void *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 1165
  str = (unsigned char const   *)in_str;
#line 1171
  if (delim == 47) {
#line 1172
    escapes = re_escapes;
#line 1173
    printables = re_printables;
  } else {
#line 1175
    escapes = str_escapes;
#line 1176
    printables = str_printables;
  }
  {
#line 1188
  osiz = (len + 3UL) + 2UL;
#line 1189
  tmp___1 = malloc(osiz);
#line 1189
  obuf = (char *)tmp___1;
  }
#line 1189
  if (obuf) {
#line 1189
    tmp___5 = 1;
  } else {
    {
#line 1189
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1189);
#line 1189
    tmp___2 = __errno_location();
#line 1189
    tmp___3 = strerror(*tmp___2);
#line 1189
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1189
    r_fatal((char const   *)tmp___4, "pp_string", "obuf", (long )osiz, tmp___3);
#line 1189
    tmp___5 = 0;
    }
  }
#line 1190
  obufout = obuf;
#line 1191
  ofre = osiz - 1UL;
#line 1193
  tmp___6 = obufout;
#line 1193
  obufout ++;
#line 1193
  *tmp___6 = (char )delim;
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (! (len > 0UL)) {
#line 1194
      goto while_break;
    }
#line 1195
    if (2UL > ofre) {
      {
#line 1195
      olen = obufout - obuf;
#line 1195
      tmp___7 = realloc((void *)obuf, osiz * 2UL);
#line 1195
      obuf = (char *)tmp___7;
      }
#line 1195
      if (obuf) {
#line 1195
        tmp___11 = 1;
      } else {
        {
#line 1195
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1195);
#line 1195
        tmp___8 = __errno_location();
#line 1195
        tmp___9 = strerror(*tmp___8);
#line 1195
        tmp___10 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1195
        r_fatal((char const   *)tmp___10, "pp_string", "obuf", (long )(osiz * 2UL),
                tmp___9);
#line 1195
        tmp___11 = 0;
        }
      }
#line 1195
      obufout = obuf + olen;
#line 1195
      ofre += osiz;
#line 1195
      osiz *= 2UL;
    }
#line 1195
    ofre -= 2UL;
#line 1196
    if (delim != 47) {
#line 1196
      if ((int const   )*str == (int const   )delim) {
#line 1197
        tmp___12 = obufout;
#line 1197
        obufout ++;
#line 1197
        *tmp___12 = (char )'\\';
#line 1198
        tmp___13 = obufout;
#line 1198
        obufout ++;
#line 1198
        *tmp___13 = (char )delim;
      } else {
#line 1196
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 1199
      cp = strchr((char const   *)escapes, (int )*str);
      }
#line 1199
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 1200
        i___0 = (int )(cp - escapes);
#line 1201
        tmp___14 = obufout;
#line 1201
        obufout ++;
#line 1201
        *tmp___14 = (char )'\\';
#line 1202
        tmp___15 = obufout;
#line 1202
        obufout ++;
#line 1202
        *tmp___15 = *(printables + i___0);
      } else
#line 1204
      if (((int const   )*str & -128) == 0) {
        {
#line 1204
        tmp___22 = __ctype_b_loc();
        }
#line 1204
        if ((int const   )*(*tmp___22 + (int )*str) & 16384) {
#line 1205
          tmp___16 = obufout;
#line 1205
          obufout ++;
#line 1205
          *tmp___16 = (char )*str;
#line 1206
          ofre ++;
        } else {
#line 1204
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1210
        if (8UL > ofre) {
          {
#line 1210
          olen___0 = obufout - obuf;
#line 1210
          tmp___17 = realloc((void *)obuf, osiz * 2UL);
#line 1210
          obuf = (char *)tmp___17;
          }
#line 1210
          if (obuf) {
#line 1210
            tmp___21 = 1;
          } else {
            {
#line 1210
            set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1210);
#line 1210
            tmp___18 = __errno_location();
#line 1210
            tmp___19 = strerror(*tmp___18);
#line 1210
            tmp___20 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1210
            r_fatal((char const   *)tmp___20, "pp_string", "obuf", (long )(osiz * 2UL),
                    tmp___19);
#line 1210
            tmp___21 = 0;
            }
          }
#line 1210
          obufout = obuf + olen___0;
#line 1210
          ofre += osiz;
#line 1210
          osiz *= 2UL;
        }
        {
#line 1210
        ofre -= 8UL;
#line 1212
        sprintf((char */* __restrict  */)obufout, (char const   */* __restrict  */)"\\%03o",
                (int const   )*str & 255);
#line 1213
        len___0 = strlen((char const   *)obufout);
#line 1214
        ofre += 10UL - len___0;
#line 1215
        obufout += len___0;
        }
      }
    }
#line 1194
    len --;
#line 1194
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1218
  if (1UL > ofre) {
    {
#line 1218
    olen___1 = obufout - obuf;
#line 1218
    tmp___23 = realloc((void *)obuf, osiz * 2UL);
#line 1218
    obuf = (char *)tmp___23;
    }
#line 1218
    if (obuf) {
#line 1218
      tmp___27 = 1;
    } else {
      {
#line 1218
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1218);
#line 1218
      tmp___24 = __errno_location();
#line 1218
      tmp___25 = strerror(*tmp___24);
#line 1218
      tmp___26 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1218
      r_fatal((char const   *)tmp___26, "pp_string", "obuf", (long )(osiz * 2UL),
              tmp___25);
#line 1218
      tmp___27 = 0;
      }
    }
#line 1218
    obufout = obuf + olen___1;
#line 1218
    ofre += osiz;
#line 1218
    osiz *= 2UL;
  }
#line 1218
  ofre --;
#line 1219
  tmp___28 = obufout;
#line 1219
  obufout ++;
#line 1219
  *tmp___28 = (char )delim;
#line 1220
  *obufout = (char )'\000';
#line 1221
  return (obuf);
}
}
#line 1227 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
char *pp_number(NODE *n ) 
{ 
  char *str ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1233
  tmp___1 = malloc((size_t )16);
#line 1233
  str = (char *)tmp___1;
  }
#line 1233
  if (str) {
#line 1233
    tmp___5 = 1;
  } else {
    {
#line 1233
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1233);
#line 1233
    tmp___2 = __errno_location();
#line 1233
    tmp___3 = strerror(*tmp___2);
#line 1233
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1233
    r_fatal((char const   *)tmp___4, "pp_number", "str", 16L, tmp___3);
#line 1233
    tmp___5 = 0;
    }
  }
#line 1235
  if ((n->flags & 2048U) != 0U) {
    {
#line 1236
    mpfr_sprintf(str, "%0.*R*g", 6, (int )ROUND_MODE, n->sub.val.nm.mpnum);
    }
  } else
#line 1237
  if ((n->flags & 4096U) != 0U) {
    {
#line 1238
    mpfr_sprintf(str, "%Zd", n->sub.val.nm.mpi);
    }
  } else {
    {
#line 1241
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%0.*g",
            6, n->sub.val.nm.fltnum);
    }
  }
#line 1242
  return (str);
}
}
#line 1248 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
char *pp_node(NODE *n ) 
{ 
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 1251
  if ((n->flags & 16U) != 0U) {
    {
#line 1252
    tmp___1 = pp_number(n);
    }
#line 1252
    return (tmp___1);
  }
  {
#line 1253
  tmp___2 = pp_string((char const   *)n->sub.val.sp, n->sub.val.slen, '\"');
  }
#line 1253
  return (tmp___2);
}
}
#line 1256 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static NODE **pp_args  =    (NODE **)((void *)0);
#line 1257 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static int npp_args  ;
#line 1259 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static char *pp_list(int nargs , char const   *paren , char const   *delim ) 
{ 
  NODE *r ;
  char *str ;
  char *s___0 ;
  size_t len ;
  size_t delimlen ;
  int i___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  NODE *tmp___11 ;
  void *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 1268
  if ((unsigned long )pp_args == (unsigned long )((void *)0)) {
    {
#line 1269
    npp_args = nargs;
#line 1270
    tmp___1 = malloc((unsigned long )(nargs + 2) * sizeof(NODE *));
#line 1270
    pp_args = (NODE **)tmp___1;
    }
#line 1270
    if (pp_args) {
#line 1270
      tmp___5 = 1;
    } else {
      {
#line 1270
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1270);
#line 1270
      tmp___2 = __errno_location();
#line 1270
      tmp___3 = strerror(*tmp___2);
#line 1270
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1270
      r_fatal((char const   *)tmp___4, "pp_list", "pp_args", (long )((unsigned long )(nargs + 2) * sizeof(NODE *)),
              tmp___3);
#line 1270
      tmp___5 = 0;
      }
    }
  } else
#line 1271
  if (nargs > npp_args) {
    {
#line 1272
    npp_args = nargs;
#line 1273
    tmp___6 = realloc((void *)((char *)pp_args), (unsigned long )(nargs + 2) * sizeof(NODE *));
#line 1273
    pp_args = (NODE **)tmp___6;
    }
#line 1273
    if (pp_args) {
#line 1273
      tmp___10 = 1;
    } else {
      {
#line 1273
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1273);
#line 1273
      tmp___7 = __errno_location();
#line 1273
      tmp___8 = strerror(*tmp___7);
#line 1273
      tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1273
      r_fatal((char const   *)tmp___9, "pp_list", "pp_args", (long )((unsigned long )(nargs + 2) * sizeof(NODE *)),
              tmp___8);
#line 1273
      tmp___10 = 0;
      }
    }
  }
  {
#line 1276
  delimlen = strlen(delim);
#line 1277
  len = - delimlen;
#line 1278
  i___0 = 1;
  }
  {
#line 1278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1278
    if (! (i___0 <= nargs)) {
#line 1278
      goto while_break;
    }
    {
#line 1279
    tmp___11 = pp_pop();
#line 1279
    *(pp_args + i___0) = tmp___11;
#line 1279
    r = tmp___11;
#line 1280
    len += r->sub.nodep.reserved + delimlen;
#line 1278
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1282
  if ((unsigned long )paren != (unsigned long )((void *)0)) {
#line 1284
    len += 2UL;
  }
  {
#line 1287
  tmp___12 = malloc(len + 1UL);
#line 1287
  str = (char *)tmp___12;
  }
#line 1287
  if (str) {
#line 1287
    tmp___16 = 1;
  } else {
    {
#line 1287
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1287);
#line 1287
    tmp___13 = __errno_location();
#line 1287
    tmp___14 = strerror(*tmp___13);
#line 1287
    tmp___15 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1287
    r_fatal((char const   *)tmp___15, "pp_list", "str", (long )(len + 1UL), tmp___14);
#line 1287
    tmp___16 = 0;
    }
  }
#line 1288
  s___0 = str;
#line 1289
  if ((unsigned long )paren != (unsigned long )((void *)0)) {
#line 1290
    tmp___17 = s___0;
#line 1290
    s___0 ++;
#line 1290
    *tmp___17 = (char )*(paren + 0);
  }
  {
#line 1291
  r = *(pp_args + nargs);
#line 1292
  memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)r->sub.nodep.name,
         r->sub.nodep.reserved);
#line 1293
  s___0 += r->sub.nodep.reserved;
#line 1294
  pp_free(r);
#line 1295
  i___0 = nargs - 1;
  }
  {
#line 1295
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1295
    if (! (i___0 > 0)) {
#line 1295
      goto while_break___0;
    }
#line 1296
    if (delimlen > 0UL) {
      {
#line 1297
      memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)delim,
             delimlen);
#line 1298
      s___0 += delimlen;
      }
    }
    {
#line 1300
    r = *(pp_args + i___0);
#line 1301
    memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)r->sub.nodep.name,
           r->sub.nodep.reserved);
#line 1302
    s___0 += r->sub.nodep.reserved;
#line 1303
    pp_free(r);
#line 1295
    i___0 --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1305
  if ((unsigned long )paren != (unsigned long )((void *)0)) {
#line 1306
    tmp___18 = s___0;
#line 1306
    s___0 ++;
#line 1306
    *tmp___18 = (char )*(paren + 1);
  }
#line 1307
  *s___0 = (char )'\000';
#line 1308
  return (str);
}
}
#line 1311 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static char *pp_concat(char const   *s1 , char const   *s2 , char const   *s3 ) 
{ 
  size_t len1 ;
  size_t len2 ;
  size_t len3 ;
  size_t l ;
  char *str ;
  char *s___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 1317
  len1 = strlen(s1);
#line 1318
  len2 = strlen(s2);
#line 1319
  len3 = strlen(s3);
#line 1320
  l = ((len1 + len2) + len3) + 2UL;
#line 1321
  tmp___1 = malloc(l);
#line 1321
  str = (char *)tmp___1;
  }
#line 1321
  if (str) {
#line 1321
    tmp___5 = 1;
  } else {
    {
#line 1321
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1321);
#line 1321
    tmp___2 = __errno_location();
#line 1321
    tmp___3 = strerror(*tmp___2);
#line 1321
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1321
    r_fatal((char const   *)tmp___4, "pp_concat", "str", (long )l, tmp___3);
#line 1321
    tmp___5 = 0;
    }
  }
#line 1322
  s___0 = str;
#line 1323
  if (len1 > 0UL) {
    {
#line 1324
    memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)s1, len1);
#line 1325
    s___0 += len1;
    }
  }
#line 1327
  if (len2 > 0UL) {
    {
#line 1328
    memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)s2, len2);
#line 1329
    s___0 += len2;
    }
  }
#line 1331
  if (len3 > 0UL) {
    {
#line 1332
    memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)s3, len3);
#line 1333
    s___0 += len3;
    }
  }
#line 1335
  *s___0 = (char )'\000';
#line 1336
  return (str);
}
}
#line 1345 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static _Bool first___0  =    (_Bool)1;
#line 1341 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
int pp_func(INSTRUCTION *pc , void *data  __attribute__((__unused__)) ) 
{ 
  int j ;
  NODE *func___1 ;
  int pcount ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1349
  if (first___0) {
    {
#line 1350
    first___0 = (_Bool)0;
#line 1351
    tmp___1 = gettext("\n\t# Functions, listed alphabetically\n");
#line 1351
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)tmp___1);
    }
  }
  {
#line 1354
  func___1 = pc->x.xn;
#line 1355
  fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\n");
#line 1356
  indent___0((pc->nexti)->d.dl);
#line 1357
  tmp___2 = op2str((OPCODE )113);
#line 1357
  fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s %s(",
          tmp___2, func___1->sub.nodep.name);
#line 1358
  pcount = (int )func___1->sub.nodep.l.ll;
#line 1359
  func_params = func___1->sub.nodep.rn;
#line 1360
  j = 0;
  }
  {
#line 1360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1360
    if (! (j < pcount)) {
#line 1360
      goto while_break;
    }
    {
#line 1361
    fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"%s",
            (func_params + j)->sub.nodep.name);
    }
#line 1362
    if (j < pcount - 1) {
      {
#line 1363
      fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)", ");
      }
    }
#line 1360
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1365
  fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)")\n\t{\n");
#line 1366
  indent_in();
#line 1367
  pprint((pc->nexti)->nexti, (INSTRUCTION *)((void *)0), (_Bool)0);
#line 1368
  indent_out();
#line 1369
  fprintf((FILE */* __restrict  */)prof_fp, (char const   */* __restrict  */)"\t}\n");
  }
#line 1370
  return (0);
}
}
#line 1378 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
static char const   * const  redirtab[7]  = {      (char const   */* const  */)"",      (char const   */* const  */)" > ",      (char const   */* const  */)" >> ",      (char const   */* const  */)" | ", 
        (char const   */* const  */)" | ",      (char const   */* const  */)" < ",      (char const   */* const  */)" |& "};
#line 1375 "/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c"
char const   *redir2str(int redirtype ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1388
  if (redirtype < 0) {
    {
#line 1389
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1389);
#line 1389
    tmp___1 = gettext("redir2str: unknown redirection type %d");
#line 1389
    r_fatal((char const   *)tmp___1, redirtype);
    }
  } else
#line 1388
  if (redirtype > 6) {
    {
#line 1389
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/profile.c", 1389);
#line 1389
    tmp___1 = gettext("redir2str: unknown redirection type %d");
#line 1389
    r_fatal((char const   *)tmp___1, redirtype);
    }
  }
#line 1390
  return ((char const   *)redirtab[redirtype]);
}
}
#line 165 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 1048 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *Null_field ;
#line 1053
NODE *(*make_number)(double  ) ;
#line 1056
int (*cmp_numbers)(NODE const   * , NODE const   * ) ;
#line 1124
struct lconv loc ;
#line 1376
double double_to_int(double d ) ;
#line 1404
NODE *format_tree(char const   *fmt_string , size_t n0 , NODE **the_args , long num_args ) ;
#line 1412
double nondec2awknum(char *str , size_t len ) ;
#line 1425
int cmp_awknums(NODE const   *t1 , NODE const   *t2 ) ;
#line 1541
void mpfr_unset(NODE *n ) ;
#line 1578
void ( /* format attribute */  (*lintfunc))(char const   *mesg  , ...) ;
#line 1593
NODE *r_force_number(NODE *n ) ;
#line 1594
NODE *r_format_val(char const   *format , int index___0 , NODE *s___0 ) ;
#line 1600
NODE *str2wstr(NODE *n , size_t **ptr ) ;
#line 1601
NODE *wstr2str(NODE *n ) ;
#line 1603
wchar_t const   *wstrstr(wchar_t const   *haystack , size_t hs_len , wchar_t const   *needle ,
                         size_t needle_len ) ;
#line 1605
wchar_t const   *wcasestrstr(wchar_t const   *haystack , size_t hs_len , wchar_t const   *needle ,
                             size_t needle_len ) ;
#line 1607
void r_free_wstr(NODE *n ) ;
#line 1609 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
wint_t btowc_cache[256]  ;
#line 1611
void init_btowc_cache(void) ;
#line 1626
int get_numbase(char const   *s___0 , _Bool use_locale ) ;
#line 110 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 157
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 231
extern  __attribute__((__nothrow__)) int __isnan(double __value )  __attribute__((__const__)) ;
#line 231
extern  __attribute__((__nothrow__)) int __isnanf(float __value )  __attribute__((__const__)) ;
#line 231
extern  __attribute__((__nothrow__)) int __isnanl(long double __value )  __attribute__((__const__)) ;
#line 31 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static int is_ieee_magic_val(char const   *val ) ;
#line 32
static NODE *r_make_number(double x ) ;
#line 33
static double get_ieee_magic_val(char const   *val ) ;
#line 34
NODE **fmt_list ;
#line 36 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
NODE *(*make_number)(double  )  =    & r_make_number;
#line 37 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
NODE *(*str2number)(NODE * )  =    & r_force_number;
#line 38 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
NODE *(*format_val)(char const   * , int  , NODE * )  =    & r_format_val;
#line 39 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
int (*cmp_numbers)(NODE const   * , NODE const   * )  =    & cmp_awknums;
#line 43 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
NODE *r_force_number(NODE *n ) 
{ 
  char *cp ;
  char *cpend ;
  char save ;
  char *ptr ;
  unsigned int newflags ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  double tmp___9 ;
  unsigned short const   **tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
#line 53
  if ((n->flags & 8U) != 0U) {
#line 54
    return (n);
  }
#line 60
  n->sub.val.nm.fltnum = 0.0;
#line 62
  if (n->sub.val.slen == 0UL) {
#line 63
    return (n);
  }
#line 66
  cp = n->sub.val.sp;
#line 74
  if (! (do_flags & 16)) {
    {
#line 75
    tmp___2 = __ctype_b_loc();
    }
#line 75
    if ((int const   )*(*tmp___2 + (int )((unsigned char )*cp)) & 1024) {
#line 76
      return (n);
    } else
#line 77
    if (n->sub.val.slen == 4UL) {
      {
#line 77
      tmp___1 = is_ieee_magic_val((char const   *)n->sub.val.sp);
      }
#line 77
      if (tmp___1) {
#line 78
        if ((n->flags & 32U) != 0U) {
#line 79
          n->flags &= 4294967263U;
        }
        {
#line 80
        n->flags |= 24U;
#line 81
        n->sub.val.nm.fltnum = get_ieee_magic_val((char const   *)n->sub.val.sp);
        }
#line 83
        return (n);
      }
    }
  }
#line 91
  cpend = cp + n->sub.val.slen;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )cp < (unsigned long )cpend) {
      {
#line 92
      tmp___3 = __ctype_b_loc();
      }
#line 92
      if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*cp)) & 8192)) {
#line 92
        goto while_break;
      }
    } else {
#line 92
      goto while_break;
    }
#line 93
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if ((unsigned long )cp == (unsigned long )cpend) {
#line 101
    return (n);
  } else
#line 95
  if (! (do_flags & 16)) {
    {
#line 95
    tmp___4 = __ctype_b_loc();
    }
#line 95
    if ((int const   )*(*tmp___4 + (int )((unsigned char )*cp)) & 1024) {
#line 101
      return (n);
    } else
#line 95
    if (! (do_flags & 64)) {
#line 95
      if ((int )*(cp + 0) == 48) {
#line 95
        if ((int )*(cp + 1) == 120) {
#line 101
          return (n);
        } else
#line 95
        if ((int )*(cp + 1) == 88) {
#line 101
          return (n);
        }
      }
    }
  }
#line 104
  if ((n->flags & 32U) != 0U) {
#line 105
    newflags = 16U;
#line 106
    n->flags &= 4294967263U;
  } else {
#line 108
    newflags = 0U;
  }
#line 110
  if (cpend - cp == 1L) {
    {
#line 111
    tmp___5 = __ctype_b_loc();
    }
#line 111
    if ((int const   )*(*tmp___5 + (int )((unsigned char )*cp)) & 2048) {
#line 112
      n->sub.val.nm.fltnum = (double )((int )*cp - 48);
#line 113
      n->flags |= newflags;
#line 114
      n->flags |= 8U;
#line 115
      if ((unsigned long )cp == (unsigned long )n->sub.val.sp) {
#line 116
        n->flags |= 256U;
      }
    }
#line 118
    return (n);
  }
#line 121
  if (do_flags & 64) {
    {
#line 122
    tmp___6 = __errno_location();
#line 122
    *tmp___6 = 0;
    }
#line 123
    if (! (do_flags & 8)) {
      {
#line 123
      tmp___7 = get_numbase((char const   *)cp, (_Bool)1);
      }
#line 123
      if (tmp___7 != 10) {
        {
#line 124
        n->sub.val.nm.fltnum = nondec2awknum(cp, (size_t )(cpend - cp));
#line 125
        n->flags |= 8U;
#line 126
        ptr = cpend;
        }
#line 127
        goto finish;
      }
    }
  }
  {
#line 131
  tmp___8 = __errno_location();
#line 131
  *tmp___8 = 0;
#line 132
  save = *cpend;
#line 133
  *cpend = (char )'\000';
#line 134
  tmp___9 = strtod((char const   */* __restrict  */)((char const   *)cp), (char **/* __restrict  */)(& ptr));
#line 134
  n->sub.val.nm.fltnum = tmp___9;
  }
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 137
    tmp___10 = __ctype_b_loc();
    }
#line 137
    if (! ((int const   )*(*tmp___10 + (int )((unsigned char )*ptr)) & 8192)) {
#line 137
      goto while_break___0;
    }
#line 138
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  *cpend = save;
  finish: 
  {
#line 141
  tmp___12 = __errno_location();
  }
#line 141
  if (*tmp___12 == 0) {
#line 141
    if ((unsigned long )ptr == (unsigned long )cpend) {
#line 142
      n->flags |= newflags;
#line 143
      n->flags |= 8U;
    } else {
      {
#line 145
      tmp___11 = __errno_location();
#line 145
      *tmp___11 = 0;
      }
    }
  } else {
    {
#line 145
    tmp___11 = __errno_location();
#line 145
    *tmp___11 = 0;
    }
  }
#line 148
  return (n);
}
}
#line 157 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static char const   *values___0[10]  = 
#line 157
  {      "0",      "1",      "2",      "3", 
        "4",      "5",      "6",      "7", 
        "8",      "9"};
#line 173 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
NODE *r_format_val(char const   *format , int index___0 , NODE *s___0 ) 
{ 
  char buf___7[8192] ;
  char *sp___0 ;
  double val ;
  NODE *dummy[2] ;
  NODE *r ;
  unsigned int oflags ;
  long num ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 177
  sp___0 = buf___7;
#line 198
  val = double_to_int(s___0->sub.val.nm.fltnum);
  }
#line 198
  if (val != s___0->sub.val.nm.fltnum) {
#line 198
    goto _L;
  } else
#line 198
  if (val <= (double )(-0x7FFFFFFFFFFFFFFF-1)) {
#line 198
    goto _L;
  } else
#line 198
  if (val >= (double )9223372036854775807L) {
    _L: /* CIL Label */ 
#line 214
    dummy[1] = s___0;
#line 215
    oflags = s___0->flags;
#line 217
    if (val == s___0->sub.val.nm.fltnum) {
      {
#line 219
      r = format_tree("%.0f", (size_t )4, dummy, 2L);
#line 220
      s___0->sub.val.idx = -1;
      }
    } else {
      {
#line 222
      r = format_tree(format, (*(fmt_list + index___0))->sub.val.slen, dummy, 2L);
#line 224
      s___0->sub.val.idx = (int )((char )index___0);
      }
    }
#line 226
    s___0->flags = oflags;
#line 227
    s___0->sub.val.slen = r->sub.val.slen;
#line 228
    if ((s___0->flags & 4U) != 0U) {
      {
#line 229
      free((void *)s___0->sub.val.sp);
      }
    }
#line 230
    s___0->sub.val.sp = r->sub.val.sp;
#line 231
    ((BLOCK *)r)->freep = nextfree[1].freep;
#line 231
    nextfree[1].freep = (BLOCK *)r;
#line 233
    goto no_malloc;
  } else {
#line 238
    num = (long )val;
#line 240
    if ((unsigned long )num < sizeof(values___0) / sizeof(values___0[0])) {
#line 240
      if (num >= 0L) {
#line 241
        sp___0 = (char *)values___0[num];
#line 242
        s___0->sub.val.slen = (size_t )1;
      } else {
        {
#line 244
        sprintf((char */* __restrict  */)sp___0, (char const   */* __restrict  */)"%ld",
                num);
#line 245
        s___0->sub.val.slen = strlen((char const   *)sp___0);
        }
      }
    } else {
      {
#line 244
      sprintf((char */* __restrict  */)sp___0, (char const   */* __restrict  */)"%ld",
              num);
#line 245
      s___0->sub.val.slen = strlen((char const   *)sp___0);
      }
    }
#line 247
    s___0->sub.val.idx = -1;
#line 248
    if ((s___0->flags & 512U) != 0U) {
#line 249
      s___0->flags &= 4294966767U;
#line 250
      s___0->flags |= 2U;
    }
  }
#line 253
  if ((unsigned long )s___0->sub.val.sp != (unsigned long )((void *)0)) {
    {
#line 254
    free((void *)s___0->sub.val.sp);
    }
  }
  {
#line 255
  tmp___2 = malloc(s___0->sub.val.slen + 2UL);
#line 255
  tmp___1 = (char *)tmp___2;
#line 255
  s___0->sub.val.sp = tmp___1;
  }
#line 255
  if (tmp___1) {
#line 255
    tmp___6 = 1;
  } else {
    {
#line 255
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 255);
#line 255
    tmp___3 = __errno_location();
#line 255
    tmp___4 = strerror(*tmp___3);
#line 255
    tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 255
    r_fatal((char const   *)tmp___5, "format_val", "s->stptr", (long )(s___0->sub.val.slen + 2UL),
            tmp___4);
#line 255
    tmp___6 = 0;
    }
  }
  {
#line 256
  memcpy((void */* __restrict  */)s___0->sub.val.sp, (void const   */* __restrict  */)sp___0,
         s___0->sub.val.slen + 1UL);
  }
  no_malloc: 
#line 258
  s___0->flags |= 4U;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (s___0->flags & 1024U) {
      {
#line 259
      r_free_wstr(s___0);
      }
    }
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return (s___0);
}
}
#line 265 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
NODE *r_dupnode(NODE *n ) 
{ 
  NODE *r ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  wchar_t *tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 279
  r = (NODE *)nextfree[1].freep;
#line 279
  if (r) {
#line 279
    nextfree[1].freep = ((BLOCK *)r)->freep;
  } else {
    {
#line 279
    tmp___1 = more_blocks(1);
#line 279
    r = (NODE *)tmp___1;
    }
  }
#line 280
  *r = *n;
#line 281
  r->flags &= 4294967231U;
#line 282
  r->flags |= 1U;
#line 283
  r->sub.val.sref = 1L;
#line 290
  r->sub.val.wsp = (wchar_t *)((void *)0);
#line 291
  r->sub.val.wslen = (size_t )0;
#line 294
  if ((n->flags & 4U) != 0U) {
    {
#line 295
    tmp___3 = malloc(n->sub.val.slen + 2UL);
#line 295
    tmp___2 = (char *)tmp___3;
#line 295
    r->sub.val.sp = tmp___2;
    }
#line 295
    if (tmp___2) {
#line 295
      tmp___7 = 1;
    } else {
      {
#line 295
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 295);
#line 295
      tmp___4 = __errno_location();
#line 295
      tmp___5 = strerror(*tmp___4);
#line 295
      tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 295
      r_fatal((char const   *)tmp___6, "r_dupnode", "r->stptr", (long )(n->sub.val.slen + 2UL),
              tmp___5);
#line 295
      tmp___7 = 0;
      }
    }
    {
#line 296
    memcpy((void */* __restrict  */)r->sub.val.sp, (void const   */* __restrict  */)n->sub.val.sp,
           n->sub.val.slen);
#line 297
    *(r->sub.val.sp + n->sub.val.slen) = (char )'\000';
    }
#line 299
    if ((n->flags & 1024U) != 0U) {
      {
#line 300
      r->sub.val.wslen = n->sub.val.wslen;
#line 301
      tmp___9 = malloc(sizeof(wchar_t ) * (n->sub.val.wslen + 2UL));
#line 301
      tmp___8 = (wchar_t *)tmp___9;
#line 301
      r->sub.val.wsp = tmp___8;
      }
#line 301
      if (tmp___8) {
#line 301
        tmp___13 = 1;
      } else {
        {
#line 301
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 301);
#line 301
        tmp___10 = __errno_location();
#line 301
        tmp___11 = strerror(*tmp___10);
#line 301
        tmp___12 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 301
        r_fatal((char const   *)tmp___12, "r_dupnode", "r->wstptr", (long )(sizeof(wchar_t ) * (n->sub.val.wslen + 2UL)),
                tmp___11);
#line 301
        tmp___13 = 0;
        }
      }
      {
#line 302
      memcpy((void */* __restrict  */)r->sub.val.wsp, (void const   */* __restrict  */)n->sub.val.wsp,
             n->sub.val.wslen * sizeof(wchar_t ));
#line 303
      *(r->sub.val.wsp + n->sub.val.wslen) = 0;
#line 304
      r->flags |= 1024U;
      }
    }
  }
#line 309
  return (r);
}
}
#line 314 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static NODE *r_make_number(double x ) 
{ 
  NODE *r ;
  void *tmp___1 ;

  {
#line 318
  r = (NODE *)nextfree[1].freep;
#line 318
  if (r) {
#line 318
    nextfree[1].freep = ((BLOCK *)r)->freep;
  } else {
    {
#line 318
    tmp___1 = more_blocks(1);
#line 318
    r = (NODE *)tmp___1;
    }
  }
#line 319
  r->type = (NODETYPE )1;
#line 320
  r->sub.val.nm.fltnum = x;
#line 321
  r->flags = 25U;
#line 322
  r->sub.val.sref = 1L;
#line 323
  r->sub.val.sp = (char *)((void *)0);
#line 324
  r->sub.val.slen = (size_t )0;
#line 326
  r->sub.val.wsp = (wchar_t *)((void *)0);
#line 327
  r->sub.val.wslen = (size_t )0;
#line 329
  return (r);
}
}
#line 334 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
int cmp_awknums(NODE const   *t1 , NODE const   *t2 ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 346
  if (sizeof(t1->sub.val.nm.fltnum) == sizeof(float )) {
    {
#line 346
    tmp___7 = __isnanf((float )t1->sub.val.nm.fltnum);
#line 346
    tmp___11 = tmp___7;
    }
  } else {
#line 346
    if (sizeof(t1->sub.val.nm.fltnum) == sizeof(double )) {
      {
#line 346
      tmp___8 = __isnan((double )t1->sub.val.nm.fltnum);
#line 346
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 346
      tmp___9 = __isnanl((long double )t1->sub.val.nm.fltnum);
#line 346
      tmp___10 = tmp___9;
      }
    }
#line 346
    tmp___11 = tmp___10;
  }
#line 346
  if (tmp___11) {
#line 347
    if (sizeof(t2->sub.val.nm.fltnum) == sizeof(float )) {
      {
#line 347
      tmp___1 = __isnanf((float )t2->sub.val.nm.fltnum);
#line 347
      tmp___5 = tmp___1;
      }
    } else {
#line 347
      if (sizeof(t2->sub.val.nm.fltnum) == sizeof(double )) {
        {
#line 347
        tmp___2 = __isnan((double )t2->sub.val.nm.fltnum);
#line 347
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 347
        tmp___3 = __isnanl((long double )t2->sub.val.nm.fltnum);
#line 347
        tmp___4 = tmp___3;
        }
      }
#line 347
      tmp___5 = tmp___4;
    }
#line 347
    if (tmp___5) {
#line 347
      tmp___6 = 0;
    } else {
#line 347
      tmp___6 = 1;
    }
#line 347
    return (tmp___6);
  }
#line 348
  if (sizeof(t2->sub.val.nm.fltnum) == sizeof(float )) {
    {
#line 348
    tmp___12 = __isnanf((float )t2->sub.val.nm.fltnum);
#line 348
    tmp___16 = tmp___12;
    }
  } else {
#line 348
    if (sizeof(t2->sub.val.nm.fltnum) == sizeof(double )) {
      {
#line 348
      tmp___13 = __isnan((double )t2->sub.val.nm.fltnum);
#line 348
      tmp___15 = tmp___13;
      }
    } else {
      {
#line 348
      tmp___14 = __isnanl((long double )t2->sub.val.nm.fltnum);
#line 348
      tmp___15 = tmp___14;
      }
    }
#line 348
    tmp___16 = tmp___15;
  }
#line 348
  if (tmp___16) {
#line 349
    return (-1);
  }
#line 351
  if (t1->sub.val.nm.fltnum == t2->sub.val.nm.fltnum) {
#line 352
    return (0);
  }
#line 353
  if (t1->sub.val.nm.fltnum < t2->sub.val.nm.fltnum) {
#line 354
    return (-1);
  }
#line 355
  return (1);
}
}
#line 361 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
NODE *make_str_node(char const   *s___0 , size_t len , int flags___0 ) 
{ 
  NODE *r ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *pf ;
  char *ptm ;
  int c ;
  char const   *end ;
  mbstate_t cur_state ;
  int mblen___0 ;
  size_t tmp___8 ;
  int i___0 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 365
  r = (NODE *)nextfree[1].freep;
#line 365
  if (r) {
#line 365
    nextfree[1].freep = ((BLOCK *)r)->freep;
  } else {
    {
#line 365
    tmp___1 = more_blocks(1);
#line 365
    r = (NODE *)tmp___1;
    }
  }
#line 366
  r->type = (NODETYPE )1;
#line 367
  r->sub.val.nm.fltnum = (double )0;
#line 368
  r->flags = 7U;
#line 369
  r->sub.val.sref = 1L;
#line 370
  r->sub.val.idx = -1;
#line 373
  r->sub.val.wsp = (wchar_t *)((void *)0);
#line 374
  r->sub.val.wslen = (size_t )0;
#line 377
  if ((flags___0 & 2) != 0) {
#line 378
    r->sub.val.sp = (char *)s___0;
  } else {
    {
#line 380
    tmp___3 = malloc(len + 2UL);
#line 380
    tmp___2 = (char *)tmp___3;
#line 380
    r->sub.val.sp = tmp___2;
    }
#line 380
    if (tmp___2) {
#line 380
      tmp___7 = 1;
    } else {
      {
#line 380
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 380);
#line 380
      tmp___4 = __errno_location();
#line 380
      tmp___5 = strerror(*tmp___4);
#line 380
      tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 380
      r_fatal((char const   *)tmp___6, "make_str_node", "r->stptr", (long )(len + 2UL),
              tmp___5);
#line 380
      tmp___7 = 0;
      }
    }
    {
#line 381
    memcpy((void */* __restrict  */)r->sub.val.sp, (void const   */* __restrict  */)s___0,
           len);
    }
  }
#line 383
  *(r->sub.val.sp + len) = (char )'\000';
#line 385
  if ((flags___0 & 1) != 0) {
    {
#line 393
    memset((void *)(& cur_state), 0, sizeof(cur_state));
#line 396
    end = (char const   *)(r->sub.val.sp + len);
#line 397
    ptm = r->sub.val.sp;
#line 397
    pf = (char const   *)ptm;
    }
    {
#line 397
    while (1) {
      while_continue: /* CIL Label */ ;
#line 397
      if (! ((unsigned long )pf < (unsigned long )end)) {
#line 397
        goto while_break;
      }
#line 404
      if (gawk_mb_cur_max > 1) {
        {
#line 405
        tmp___8 = mbrlen((char const   */* __restrict  */)pf, (size_t )(end - pf),
                         (mbstate_t */* __restrict  */)(& cur_state));
#line 405
        mblen___0 = (int )tmp___8;
        }
#line 407
        if (mblen___0 > 1) {
#line 410
          i___0 = 0;
          {
#line 410
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 410
            if (! (i___0 < mblen___0)) {
#line 410
              goto while_break___0;
            }
#line 411
            tmp___9 = ptm;
#line 411
            ptm ++;
#line 411
            tmp___10 = pf;
#line 411
            pf ++;
#line 411
            *tmp___9 = (char )*tmp___10;
#line 410
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 412
          goto __Cont;
        }
      }
#line 416
      tmp___11 = pf;
#line 416
      pf ++;
#line 416
      c = (int )*tmp___11;
#line 417
      if (c == 92) {
        {
#line 418
        c = parse_escape(& pf);
        }
#line 419
        if (c < 0) {
#line 420
          if (do_flags & 3) {
            {
#line 421
            set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 421);
#line 421
            tmp___12 = gettext("backslash at end of string");
#line 421
            (*lintfunc)((char const   *)tmp___12);
            }
          }
#line 422
          c = '\\';
        }
#line 424
        tmp___13 = ptm;
#line 424
        ptm ++;
#line 424
        *tmp___13 = (char )c;
      } else {
#line 426
        tmp___14 = ptm;
#line 426
        ptm ++;
#line 426
        *tmp___14 = (char )c;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 428
    len = (size_t )(ptm - r->sub.val.sp);
#line 429
    tmp___16 = realloc((void *)r->sub.val.sp, len + 1UL);
#line 429
    tmp___15 = (char *)tmp___16;
#line 429
    r->sub.val.sp = tmp___15;
    }
#line 429
    if (tmp___15) {
#line 429
      tmp___20 = 1;
    } else {
      {
#line 429
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 429);
#line 429
      tmp___17 = __errno_location();
#line 429
      tmp___18 = strerror(*tmp___17);
#line 429
      tmp___19 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 429
      r_fatal((char const   *)tmp___19, "make_str_node", "r->stptr", (long )(len + 1UL),
              tmp___18);
#line 429
      tmp___20 = 0;
      }
    }
#line 430
    *(r->sub.val.sp + len) = (char )'\000';
  }
#line 432
  r->sub.val.slen = len;
#line 434
  return (r);
}
}
#line 440 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
void r_unref(NODE *tmp___1 ) 
{ 


  {
#line 455
  if ((tmp___1->flags & 5U) == 5U) {
    {
#line 456
    free((void *)tmp___1->sub.val.sp);
    }
  }
  {
#line 459
  mpfr_unset(tmp___1);
  }
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (tmp___1->flags & 1024U) {
      {
#line 461
      r_free_wstr(tmp___1);
      }
    }
#line 461
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  ((BLOCK *)tmp___1)->freep = nextfree[1].freep;
#line 462
  nextfree[1].freep = (BLOCK *)tmp___1;
#line 463
  return;
}
}
#line 547 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static _Bool warned  =    (_Bool)0;
#line 586 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static _Bool warned___0[256]  ;
#line 485 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
int parse_escape(char const   **string_ptr ) 
{ 
  int c ;
  char const   *tmp___1 ;
  int i___0 ;
  int count ;
  int j ;
  char const   *start ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;
  unsigned char uc ;
  char *tmp___12 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 488
  tmp___1 = *string_ptr;
#line 488
  (*string_ptr) ++;
#line 488
  c = (int )*tmp___1;
#line 494
  if (do_flags & 4) {
    {
#line 499
    if (c == 114) {
#line 499
      goto case_114;
    }
#line 499
    if (c == 102) {
#line 499
      goto case_114;
    }
#line 499
    if (c == 98) {
#line 499
      goto case_114;
    }
#line 499
    if (c == 97) {
#line 499
      goto case_114;
    }
#line 495
    goto switch_break;
    case_114: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    {
#line 500
    tmp___2 = gettext("old awk does not support the `\\%c\' escape sequence");
#line 500
    warning((char const   *)tmp___2, c);
    }
#line 501
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 506
  if (c == 97) {
#line 506
    goto case_97___0;
  }
#line 508
  if (c == 98) {
#line 508
    goto case_98___0;
  }
#line 510
  if (c == 102) {
#line 510
    goto case_102___0;
  }
#line 512
  if (c == 110) {
#line 512
    goto case_110;
  }
#line 514
  if (c == 114) {
#line 514
    goto case_114___0;
  }
#line 516
  if (c == 116) {
#line 516
    goto case_116;
  }
#line 518
  if (c == 118) {
#line 518
    goto case_118;
  }
#line 520
  if (c == 10) {
#line 520
    goto case_10;
  }
#line 522
  if (c == 0) {
#line 522
    goto case_0;
  }
#line 532
  if (c == 55) {
#line 532
    goto case_55;
  }
#line 532
  if (c == 54) {
#line 532
    goto case_55;
  }
#line 532
  if (c == 53) {
#line 532
    goto case_55;
  }
#line 532
  if (c == 52) {
#line 532
    goto case_55;
  }
#line 532
  if (c == 51) {
#line 532
    goto case_55;
  }
#line 532
  if (c == 50) {
#line 532
    goto case_55;
  }
#line 532
  if (c == 49) {
#line 532
    goto case_55;
  }
#line 532
  if (c == 48) {
#line 532
    goto case_55;
  }
#line 545
  if (c == 120) {
#line 545
    goto case_120;
  }
#line 582
  if (c == 34) {
#line 582
    goto case_34;
  }
#line 582
  if (c == 92) {
#line 582
    goto case_34;
  }
#line 584
  goto switch_default;
  case_97___0: /* CIL Label */ 
#line 507
  return ('\a');
  case_98___0: /* CIL Label */ 
#line 509
  return ('\b');
  case_102___0: /* CIL Label */ 
#line 511
  return ('\f');
  case_110: /* CIL Label */ 
#line 513
  return ('\n');
  case_114___0: /* CIL Label */ 
#line 515
  return ('\r');
  case_116: /* CIL Label */ 
#line 517
  return ('\t');
  case_118: /* CIL Label */ 
#line 519
  return ('\v');
  case_10: /* CIL Label */ 
#line 521
  return (-2);
  case_0: /* CIL Label */ 
#line 523
  (*string_ptr) --;
#line 524
  return (-1);
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 533
  i___0 = c - 48;
#line 534
  count = 0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    count ++;
#line 535
    if (! (count < 3)) {
#line 535
      goto while_break;
    }
#line 536
    tmp___3 = *string_ptr;
#line 536
    (*string_ptr) ++;
#line 536
    c = (int )*tmp___3;
#line 536
    if (c >= 48) {
#line 536
      if (c <= 55) {
#line 537
        i___0 *= 8;
#line 538
        i___0 += c - 48;
      } else {
#line 540
        (*string_ptr) --;
#line 541
        goto while_break;
      }
    } else {
#line 540
      (*string_ptr) --;
#line 541
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return (i___0);
  case_120: /* CIL Label */ 
#line 546
  if (do_flags & 3) {
#line 549
    if (! warned) {
      {
#line 550
      warned = (_Bool)1;
#line 551
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 551);
#line 551
      tmp___4 = gettext("POSIX does not allow `\\x\' escapes");
#line 551
      (*lintfunc)((char const   *)tmp___4);
      }
    }
  }
#line 554
  if (do_flags & 16) {
#line 555
    return ('x');
  }
  {
#line 556
  tmp___6 = __ctype_b_loc();
  }
#line 556
  if (! ((int const   )*(*tmp___6 + (int )((unsigned char )*(*string_ptr + 0))) & 4096)) {
    {
#line 557
    tmp___5 = gettext("no hex digits in `\\x\' escape sequence");
#line 557
    warning((char const   *)tmp___5);
    }
#line 558
    return ('x');
  }
#line 560
  j = 0;
#line 560
  i___0 = j;
#line 561
  start = *string_ptr;
  {
#line 562
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 564
    tmp___7 = *string_ptr;
#line 564
    (*string_ptr) ++;
#line 564
    c = (int )*tmp___7;
#line 565
    tmp___10 = __ctype_b_loc();
    }
#line 565
    if ((int const   )*(*tmp___10 + c) & 4096) {
      {
#line 566
      i___0 *= 16;
#line 567
      tmp___9 = __ctype_b_loc();
      }
#line 567
      if ((int const   )*(*tmp___9 + c) & 2048) {
#line 568
        i___0 += c - 48;
      } else {
        {
#line 569
        tmp___8 = __ctype_b_loc();
        }
#line 569
        if ((int const   )*(*tmp___8 + c) & 256) {
#line 570
          i___0 += (c - 65) + 10;
        } else {
#line 572
          i___0 += (c - 97) + 10;
        }
      }
    } else {
#line 574
      (*string_ptr) --;
#line 575
      goto while_break___0;
    }
#line 562
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 578
  if (do_flags & 3) {
#line 578
    if (j > 2) {
      {
#line 579
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 579);
#line 579
      tmp___11 = gettext("hex escape \\x%.*s of %d characters probably not interpreted the way you expect");
#line 579
      (*lintfunc)((char const   *)tmp___11, j, start, j);
      }
    }
  }
#line 580
  return (i___0);
  case_34: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 583
  return (c);
  switch_default: /* CIL Label */ 
#line 587
  uc = (unsigned char )c;
#line 591
  if (! warned___0[uc]) {
    {
#line 592
    warned___0[uc] = (_Bool)1;
#line 594
    tmp___12 = gettext("escape sequence `\\%c\' treated as plain `%c\'");
#line 594
    warning((char const   *)tmp___12, (int )uc, (int )uc);
    }
  }
#line 597
  return (c);
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 603 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
int get_numbase(char const   *s___0 , _Bool use_locale ) 
{ 
  int dec_point ;
  char const   *str ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 606
  dec_point = '.';
#line 607
  str = s___0;
#line 614
  if (use_locale) {
#line 614
    if ((unsigned long )loc.decimal_point != (unsigned long )((void *)0)) {
#line 614
      if ((int )*(loc.decimal_point + 0) != 0) {
#line 615
        dec_point = (int )*(loc.decimal_point + 0);
      }
    }
  }
#line 618
  if ((int const   )*(str + 0) != 48) {
#line 619
    return (10);
  }
#line 622
  if ((int const   )*(str + 1) == 120) {
#line 623
    return (16);
  } else
#line 622
  if ((int const   )*(str + 1) == 88) {
#line 623
    return (16);
  }
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! ((int const   )*str != 0)) {
#line 631
      goto while_break;
    }
#line 632
    if ((int const   )*str == 101) {
#line 633
      return (10);
    } else
#line 632
    if ((int const   )*str == 69) {
#line 633
      return (10);
    } else
#line 632
    if ((int const   )*str == (int const   )dec_point) {
#line 633
      return (10);
    } else {
      {
#line 634
      tmp___1 = __ctype_b_loc();
      }
#line 634
      if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*str)) & 2048)) {
#line 635
        goto while_break;
      }
    }
#line 631
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 638
  tmp___2 = __ctype_b_loc();
  }
#line 638
  if ((int const   )*(*tmp___2 + (int )((unsigned char )*(s___0 + 1))) & 2048) {
#line 638
    if ((int const   )*(s___0 + 1) == 56) {
#line 641
      return (10);
    } else
#line 638
    if ((int const   )*(s___0 + 1) == 57) {
#line 641
      return (10);
    }
  } else {
#line 641
    return (10);
  }
#line 642
  return (8);
}
}
#line 655 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static _Bool warned___1  =    (_Bool)0;
#line 648 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
NODE *str2wstr(NODE *n , size_t **ptr ) 
{ 
  size_t i___0 ;
  size_t count ;
  size_t src_count ;
  char *sp___0 ;
  mbstate_t mbs___0 ;
  wchar_t wc ;
  wchar_t *wsp ;
  wchar_t *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t *tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  wchar_t *tmp___14 ;
  size_t tmp___15 ;
  wchar_t *tmp___16 ;
  void *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 665
  if ((unsigned long )n == (unsigned long )Nnull_string) {
#line 666
    return (n);
  } else
#line 665
  if ((unsigned long )n == (unsigned long )Null_field) {
#line 666
    return (n);
  }
#line 668
  if ((n->flags & 1024U) != 0U) {
#line 669
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 670
      return (n);
    }
    {
#line 673
    while (1) {
      while_continue: /* CIL Label */ ;
#line 673
      if (n->flags & 1024U) {
        {
#line 673
        r_free_wstr(n);
        }
      }
#line 673
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 689
  tmp___2 = malloc(sizeof(wchar_t ) * (n->sub.val.slen + 2UL));
#line 689
  tmp___1 = (wchar_t *)tmp___2;
#line 689
  n->sub.val.wsp = tmp___1;
  }
#line 689
  if (tmp___1) {
#line 689
    tmp___6 = 1;
  } else {
    {
#line 689
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 689);
#line 689
    tmp___3 = __errno_location();
#line 689
    tmp___4 = strerror(*tmp___3);
#line 689
    tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 689
    r_fatal((char const   *)tmp___5, "str2wstr", "n->wstptr", (long )(sizeof(wchar_t ) * (n->sub.val.slen + 2UL)),
            tmp___4);
#line 689
    tmp___6 = 0;
    }
  }
#line 690
  wsp = n->sub.val.wsp;
#line 700
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 701
    tmp___8 = malloc(sizeof(size_t ) * n->sub.val.slen);
#line 701
    tmp___7 = (size_t *)tmp___8;
#line 701
    *ptr = tmp___7;
    }
#line 701
    if (tmp___7) {
#line 701
      tmp___12 = 1;
    } else {
      {
#line 701
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 701);
#line 701
      tmp___9 = __errno_location();
#line 701
      tmp___10 = strerror(*tmp___9);
#line 701
      tmp___11 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 701
      r_fatal((char const   *)tmp___11, "str2wstr", "*ptr", (long )(sizeof(size_t ) * n->sub.val.slen),
              tmp___10);
#line 701
      tmp___12 = 0;
      }
    }
    {
#line 702
    memset((void *)*ptr, 0, sizeof(size_t ) * n->sub.val.slen);
    }
  }
  {
#line 705
  sp___0 = n->sub.val.sp;
#line 706
  src_count = n->sub.val.slen;
#line 707
  memset((void *)(& mbs___0), 0, sizeof(mbs___0));
#line 708
  i___0 = (size_t )0;
  }
  {
#line 708
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 708
    if (! (src_count > 0UL)) {
#line 708
      goto while_break___0;
    }
#line 715
    if (btowc_cache[(int )*sp___0 & 255] != 4294967295U) {
#line 716
      count = (size_t )1;
#line 717
      wc = (wchar_t )btowc_cache[(int )*sp___0 & 255];
    } else {
      {
#line 719
      count = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)sp___0,
                      src_count, & mbs___0);
      }
    }
    {
#line 722
    if (count == 0xffffffffffffffffUL) {
#line 722
      goto case_18446744073709551615;
    }
#line 722
    if (count == 0xfffffffffffffffeUL) {
#line 722
      goto case_18446744073709551615;
    }
#line 743
    if (count == 0UL) {
#line 743
      goto case_0;
    }
#line 746
    goto switch_default;
    case_18446744073709551615: /* CIL Label */ 
    case_18446744073709551614: /* CIL Label */ 
    {
#line 729
    sp___0 ++;
#line 730
    src_count --;
#line 735
    memset((void *)(& mbs___0), 0, sizeof(mbs___0));
    }
#line 737
    if (do_flags & 3) {
#line 737
      if (! warned___1) {
        {
#line 738
        warned___1 = (_Bool)1;
#line 739
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 739);
#line 739
        tmp___13 = gettext("Invalid multibyte data detected. There may be a mismatch between your data and your locale.");
#line 739
        (*lintfunc)((char const   *)tmp___13);
        }
      }
    }
#line 741
    goto switch_break;
    case_0: /* CIL Label */ 
#line 744
    count = (size_t )1;
    switch_default: /* CIL Label */ 
#line 747
    tmp___14 = wsp;
#line 747
    wsp ++;
#line 747
    *tmp___14 = wc;
#line 748
    src_count -= count;
    {
#line 749
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 749
      tmp___15 = count;
#line 749
      count --;
#line 749
      if (! tmp___15) {
#line 749
        goto while_break___1;
      }
#line 750
      if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 751
        *(*ptr + (sp___0 - n->sub.val.sp)) = i___0;
      }
#line 752
      sp___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 754
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 708
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 758
  *wsp = 0;
#line 759
  n->sub.val.wslen = (size_t )(wsp - n->sub.val.wsp);
#line 760
  n->flags |= 1024U;
#line 762
  if (n->sub.val.slen - n->sub.val.wslen > 100UL) {
    {
#line 763
    tmp___17 = realloc((void *)((char *)n->sub.val.wsp), sizeof(wchar_t ) * (n->sub.val.wslen + 2UL));
#line 763
    tmp___16 = (wchar_t *)tmp___17;
#line 763
    n->sub.val.wsp = tmp___16;
    }
#line 763
    if (tmp___16) {
#line 763
      tmp___21 = 1;
    } else {
      {
#line 763
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 763);
#line 763
      tmp___18 = __errno_location();
#line 763
      tmp___19 = strerror(*tmp___18);
#line 763
      tmp___20 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 763
      r_fatal((char const   *)tmp___20, "str2wstr", "n->wstptr", (long )(sizeof(wchar_t ) * (n->sub.val.wslen + 2UL)),
              tmp___19);
#line 763
      tmp___21 = 0;
      }
    }
  }
#line 765
  return (n);
}
}
#line 770 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
NODE *wstr2str(NODE *n ) 
{ 
  size_t result ;
  size_t length ;
  wchar_t *wp ;
  mbstate_t mbs___0 ;
  char *newval ;
  char *cp ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 787
  memset((void *)(& mbs___0), 0, sizeof(mbs___0));
#line 789
  length = n->sub.val.wslen;
#line 790
  tmp___1 = malloc(length * (size_t )gawk_mb_cur_max + 2UL);
#line 790
  newval = (char *)tmp___1;
  }
#line 790
  if (newval) {
#line 790
    tmp___5 = 1;
  } else {
    {
#line 790
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 790);
#line 790
    tmp___2 = __errno_location();
#line 790
    tmp___3 = strerror(*tmp___2);
#line 790
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 790
    r_fatal((char const   *)tmp___4, "wstr2str", "newval", (long )(length * (size_t )gawk_mb_cur_max + 2UL),
            tmp___3);
#line 790
    tmp___5 = 0;
    }
  }
#line 792
  wp = n->sub.val.wsp;
#line 793
  cp = newval;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! (length > 0UL)) {
#line 793
      goto while_break;
    }
    {
#line 794
    result = wcrtomb((char */* __restrict  */)cp, *wp, (mbstate_t */* __restrict  */)(& mbs___0));
    }
#line 795
    if (result == 0xffffffffffffffffUL) {
#line 796
      goto while_break;
    }
#line 797
    cp += result;
#line 798
    wp ++;
#line 793
    length --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 800
  *cp = (char )'\000';
#line 802
  free((void *)n->sub.val.sp);
#line 803
  n->sub.val.sp = newval;
#line 804
  n->sub.val.slen = (size_t )(cp - newval);
  }
#line 806
  return (n);
}
}
#line 811 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
void r_free_wstr(NODE *n ) 
{ 


  {
#line 816
  if ((n->flags & 1024U) != 0U) {
    {
#line 818
    free((void *)n->sub.val.wsp);
    }
  }
#line 820
  n->sub.val.wsp = (wchar_t *)((void *)0);
#line 821
  n->sub.val.wslen = (size_t )0;
#line 822
  n->flags &= 4294966271U;
#line 823
  return;
}
}
#line 837 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
wchar_t const   *wstrstr(wchar_t const   *haystack , size_t hs_len , wchar_t const   *needle ,
                         size_t needle_len ) 
{ 
  size_t i___0 ;
  int tmp___1 ;

  {
#line 843
  if ((unsigned long )haystack == (unsigned long )((void *)0)) {
#line 844
    return ((wchar_t const   *)((void *)0));
  } else
#line 843
  if ((unsigned long )needle == (unsigned long )((void *)0)) {
#line 844
    return ((wchar_t const   *)((void *)0));
  } else
#line 843
  if (needle_len > hs_len) {
#line 844
    return ((wchar_t const   *)((void *)0));
  }
#line 846
  i___0 = (size_t )0;
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (! (i___0 < hs_len)) {
#line 846
      goto while_break;
    }
#line 847
    if (*(haystack + i___0) == *(needle + 0)) {
#line 847
      if ((i___0 + needle_len) - 1UL < hs_len) {
#line 847
        if (*(haystack + ((i___0 + needle_len) - 1UL)) == *(needle + (needle_len - 1UL))) {
          {
#line 851
          tmp___1 = memcmp((void const   *)(haystack + i___0), (void const   *)needle,
                           sizeof(wchar_t ) * needle_len);
          }
#line 851
          if (tmp___1 == 0) {
#line 852
            return (haystack + i___0);
          }
        }
      }
    }
#line 846
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  return ((wchar_t const   *)((void *)0));
}
}
#line 862 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
wchar_t const   *wcasestrstr(wchar_t const   *haystack , size_t hs_len , wchar_t const   *needle ,
                             size_t needle_len ) 
{ 
  size_t i___0 ;
  size_t j ;
  wchar_t const   *start ;
  wchar_t h ;
  wchar_t n ;
  wint_t tmp___1 ;
  wint_t tmp___2 ;
  wint_t tmp___3 ;
  wint_t tmp___4 ;
  wint_t tmp___5 ;
  wint_t tmp___6 ;

  {
#line 868
  if ((unsigned long )haystack == (unsigned long )((void *)0)) {
#line 869
    return ((wchar_t const   *)((void *)0));
  } else
#line 868
  if ((unsigned long )needle == (unsigned long )((void *)0)) {
#line 869
    return ((wchar_t const   *)((void *)0));
  } else
#line 868
  if (needle_len > hs_len) {
#line 869
    return ((wchar_t const   *)((void *)0));
  }
#line 871
  i___0 = (size_t )0;
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 871
    if (! (i___0 < hs_len)) {
#line 871
      goto while_break;
    }
    {
#line 872
    tmp___3 = towlower((wint_t )*(haystack + i___0));
#line 872
    tmp___4 = towlower((wint_t )*(needle + 0));
    }
#line 872
    if (tmp___3 == tmp___4) {
#line 872
      if ((i___0 + needle_len) - 1UL < hs_len) {
        {
#line 872
        tmp___5 = towlower((wint_t )*(haystack + ((i___0 + needle_len) - 1UL)));
#line 872
        tmp___6 = towlower((wint_t )*(needle + (needle_len - 1UL)));
        }
#line 872
        if (tmp___5 == tmp___6) {
#line 878
          start = haystack + i___0;
#line 879
          j = (size_t )0;
          {
#line 879
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 879
            if (! (j < needle_len)) {
#line 879
              goto while_break___0;
            }
            {
#line 882
            tmp___1 = towlower((wint_t )*start);
#line 882
            h = (wchar_t )tmp___1;
#line 883
            tmp___2 = towlower((wint_t )*(needle + j));
#line 883
            n = (wchar_t )tmp___2;
            }
#line 884
            if (h != n) {
#line 885
              goto out;
            }
#line 879
            j ++;
#line 879
            start ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 887
          return (haystack + i___0);
        }
      }
    }
    out: 
#line 871
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 892
  return ((wchar_t const   *)((void *)0));
}
}
#line 898 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static int is_ieee_magic_val(char const   *val ) 
{ 
  int tmp___1 ;

  {
#line 905
  if ((int const   )*(val + 0) == 43) {
#line 905
    goto _L___5;
  } else
#line 905
  if ((int const   )*(val + 0) == 45) {
    _L___5: /* CIL Label */ 
#line 905
    if ((int const   )*(val + 1) == 105) {
#line 905
      goto _L___4;
    } else
#line 905
    if ((int const   )*(val + 1) == 73) {
      _L___4: /* CIL Label */ 
#line 905
      if ((int const   )*(val + 2) == 110) {
#line 905
        goto _L___3;
      } else
#line 905
      if ((int const   )*(val + 2) == 78) {
        _L___3: /* CIL Label */ 
#line 905
        if ((int const   )*(val + 3) == 102) {
#line 905
          tmp___1 = 1;
        } else
#line 905
        if ((int const   )*(val + 3) == 70) {
#line 905
          tmp___1 = 1;
        } else {
#line 905
          goto _L___2;
        }
      } else {
#line 905
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 905
    if ((int const   )*(val + 1) == 110) {
#line 905
      goto _L___0;
    } else
#line 905
    if ((int const   )*(val + 1) == 78) {
      _L___0: /* CIL Label */ 
#line 905
      if ((int const   )*(val + 2) == 97) {
#line 905
        goto _L;
      } else
#line 905
      if ((int const   )*(val + 2) == 65) {
        _L: /* CIL Label */ 
#line 905
        if ((int const   )*(val + 3) == 110) {
#line 905
          tmp___1 = 1;
        } else
#line 905
        if ((int const   )*(val + 3) == 78) {
#line 905
          tmp___1 = 1;
        } else {
#line 905
          tmp___1 = 0;
        }
      } else {
#line 905
        tmp___1 = 0;
      }
    } else {
#line 905
      tmp___1 = 0;
    }
  } else {
#line 905
    tmp___1 = 0;
  }
#line 905
  return (tmp___1);
}
}
#line 919 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static _Bool first___1  =    (_Bool)1;
#line 920 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static double inf  ;
#line 921 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static double nan___0  ;
#line 916 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
static double get_ieee_magic_val(char const   *val ) 
{ 
  char *ptr ;
  double v ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 924
  tmp___1 = strtod((char const   */* __restrict  */)val, (char **/* __restrict  */)(& ptr));
#line 924
  v = tmp___1;
  }
#line 926
  if ((unsigned long )val == (unsigned long )ptr) {
#line 927
    if (first___1) {
      {
#line 928
      first___1 = (_Bool)0;
#line 929
      nan___0 = sqrt(- 1.0);
#line 930
      tmp___2 = log(0.0);
#line 930
      inf = - tmp___2;
      }
    }
#line 933
    if ((int const   )*(val + 1) == 105) {
#line 933
      v = inf;
    } else
#line 933
    if ((int const   )*(val + 1) == 73) {
#line 933
      v = inf;
    } else {
#line 933
      v = nan___0;
    }
#line 934
    if ((int const   )*(val + 0) == 45) {
#line 935
      v = - v;
    }
  }
#line 938
  return (v);
}
}
#line 946 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
void init_btowc_cache(void) 
{ 
  int i___0 ;

  {
#line 950
  i___0 = 0;
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 950
    if (! (i___0 < 255)) {
#line 950
      goto while_break;
    }
    {
#line 951
    btowc_cache[i___0] = btowc(i___0);
#line 950
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 953
  return;
}
}
#line 958 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
BLOCK nextfree[3]  = {      {(size_t )0, (struct block_item *)((void *)0)}, 
        {sizeof(NODE ), (struct block_item *)((void *)0)}, 
        {sizeof(BUCKET ), (struct block_item *)((void *)0)}};
#line 969 "/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c"
void *more_blocks(int id ) 
{ 
  BLOCK *freep ;
  BLOCK *np ;
  BLOCK *next ;
  char *p ;
  char *endp ;
  size_t size ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 976
  size = nextfree[id].size;
#line 978
  tmp___1 = malloc(100UL * size);
#line 978
  freep = (BLOCK *)tmp___1;
  }
#line 978
  if (freep) {
#line 978
    tmp___5 = 1;
  } else {
    {
#line 978
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/node.c", 978);
#line 978
    tmp___2 = __errno_location();
#line 978
    tmp___3 = strerror(*tmp___2);
#line 978
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 978
    r_fatal((char const   *)tmp___4, "more_blocks", "freep", (long )(100UL * size),
            tmp___3);
#line 978
    tmp___5 = 0;
    }
  }
#line 979
  p = (char *)freep;
#line 980
  endp = p + 100UL * size;
#line 982
  np = freep;
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
#line 983
    p += size;
#line 983
    next = (BLOCK *)p;
#line 984
    if ((unsigned long )p >= (unsigned long )endp) {
#line 985
      np->freep = (struct block_item *)((void *)0);
#line 986
      goto while_break;
    }
#line 988
    np->freep = next;
#line 982
    np = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 990
  nextfree[id].freep = freep->freep;
#line 991
  return ((void *)freep);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 348 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 82 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 367 "/usr/include/mpfr.h"
extern int __gmpfr_fprintf(FILE * , char const   *  , ...) ;
#line 1028 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
long FNR ;
#line 1041
NODE *FILENAME_node ;
#line 1042
NODE *FNR_node ;
#line 1103
int exit_val ;
#line 1137
char const   *myname ;
#line 1303 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
jmp_buf fatal_tag  ;
#line 1304
_Bool fatal_tag_valid ;
#line 1456
void close_extensions(void) ;
#line 1492
void run_ext_exit_handlers(int exitval ) ;
#line 1545
NODE *mpg_update_var(NODE *n ) ;
#line 1569
void gawk_exit(int status ) ;
#line 1571
void ( /* format attribute */  err)(_Bool isfatal , char const   *s___0 , char const   *emsg ,
                                    va_list argp ) ;
#line 1572
void ( /* format attribute */  msg)(char const   *mesg  , ...) ;
#line 30 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
int sourceline  =    0;
#line 31 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
char *source  =    (char *)((void *)0);
#line 32 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
static char const   *srcfile  =    (char const   *)((void *)0);
#line 33 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
static int srcline  ;
#line 36 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
_Bool fatal_tag_valid  =    (_Bool)0;
#line 41 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
void ( /* format attribute */  err)(_Bool isfatal , char const   *s___0 , char const   *emsg ,
                                    va_list argp ) 
{ 
  char *file ;
  char const   *me ;
  char *tmp___1 ;
  NODE *val ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 47
  fflush(output_fp);
#line 48
  me = myname;
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          me);
  }
#line 57
  if (sourceline > 0) {
#line 58
    if ((unsigned long )source != (unsigned long )((void *)0)) {
      {
#line 59
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:",
              source);
      }
    } else {
      {
#line 61
      tmp___1 = gettext("cmd. line:");
#line 61
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
      }
    }
    {
#line 63
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d: ",
            sourceline);
    }
  }
#line 67
  if (FNR_node) {
#line 67
    if (((FNR_node->sub.nodep.l.lptr)->flags & 6144U) != 0U) {
      {
#line 69
      val = mpg_update_var(FNR_node);
      }
#line 71
      if (val->sub.val.nm.mpi[0]._mp_size < 0) {
#line 71
        tmp___2 = -1;
      } else {
#line 71
        tmp___2 = val->sub.val.nm.mpi[0]._mp_size > 0;
      }
#line 71
      if (tmp___2 > 0) {
        {
#line 72
        file = (FILENAME_node->sub.nodep.l.lptr)->sub.val.sp;
#line 73
        _IO_putc('(', stderr);
        }
#line 74
        if (file) {
          {
#line 75
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FILENAME=%s ",
                  file);
          }
        }
        {
#line 76
        __gmpfr_fprintf(stderr, "FNR=%Zd) ", val->sub.val.nm.mpi);
        }
      }
    } else {
#line 67
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 80
  if (FNR > 0L) {
    {
#line 81
    file = (FILENAME_node->sub.nodep.l.lptr)->sub.val.sp;
#line 82
    _IO_putc('(', stderr);
    }
#line 83
    if (file) {
      {
#line 84
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FILENAME=%s ",
              file);
      }
    }
    {
#line 85
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FNR=%ld) ",
            FNR);
    }
  }
  {
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          s___0);
#line 89
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)emsg,
           argp);
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 91
  fflush(stderr);
  }
#line 93
  if (isfatal) {
    {
#line 97
    gawk_exit(2);
    }
  }
#line 99
  return;
}
}
#line 103 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
void ( /* format attribute */  msg)(char const   *mesg  , ...) 
{ 
  va_list args ;
  char *__cil_tmp3 ;

  {
  {
#line 107
  __builtin_va_start(args, mesg);
#line 108
  err((_Bool)0, "", mesg, args);
#line 109
  __builtin_va_end(args);
  }
#line 110
  return;
}
}
#line 114 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
void ( /* format attribute */  warning)(char const   *mesg  , ...) 
{ 
  va_list args ;
  char *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 118
  __builtin_va_start(args, mesg);
#line 119
  tmp___1 = gettext("warning: ");
#line 119
  err((_Bool)0, (char const   *)tmp___1, mesg, args);
#line 120
  __builtin_va_end(args);
  }
#line 121
  return;
}
}
#line 123 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
void ( /* format attribute */  error)(char const   *mesg  , ...) 
{ 
  va_list args ;
  char *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 127
  __builtin_va_start(args, mesg);
#line 128
  tmp___1 = gettext("error: ");
#line 128
  err((_Bool)0, (char const   *)tmp___1, mesg, args);
#line 129
  __builtin_va_end(args);
  }
#line 130
  return;
}
}
#line 134 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
void set_loc(char const   *file , int line ) 
{ 


  {
#line 137
  srcfile = file;
#line 138
  srcline = line;
#line 141
  file = srcfile;
#line 141
  line = srcline;
#line 142
  return;
}
}
#line 146
 __attribute__((__noreturn__)) void ( /* format attribute */  r_fatal)(char const   *mesg 
                                                                       , ...) ;
#line 146 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
void ( /* format attribute */  r_fatal)(char const   *mesg  , ...) 
{ 
  va_list args ;
  char *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 150
  __builtin_va_start(args, mesg);
#line 151
  tmp___1 = gettext("fatal: ");
#line 151
  err((_Bool)1, (char const   *)tmp___1, mesg, args);
#line 152
  __builtin_va_end(args);
  }
#line 153
  return;
}
}
#line 157 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
void gawk_exit(int status ) 
{ 


  {
#line 160
  if (fatal_tag_valid) {
    {
#line 161
    exit_val = status;
#line 162
    longjmp((struct __jmp_buf_tag *)(fatal_tag), 1);
    }
  }
  {
#line 165
  final_exit(status);
  }
}
}
#line 170
 __attribute__((__noreturn__)) void final_exit(int status ) ;
#line 170 "/home/wslee/gnu_benchmarks/gawk-4.1.0/msg.c"
void final_exit(int status ) 
{ 


  {
  {
#line 174
  run_ext_exit_handlers(status);
#line 177
  close_extensions();
#line 179
  exit(status);
  }
}
}
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 579 "/usr/include/gmp-x86_64.h"
extern void __gmp_randinit_mt(__gmp_randstate_struct * ) ;
#line 585
extern void __gmp_randseed(__gmp_randstate_struct * , mpz_srcptr  ) ;
#line 696
extern void __gmpz_add(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 699
extern void __gmpz_add_ui(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 705
extern void __gmpz_addmul_ui(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 708
extern void __gmpz_and(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 747
extern void __gmpz_clear(mpz_ptr  ) ;
#line 753
extern int __gmpz_cmp(mpz_srcptr  , mpz_srcptr  )  __attribute__((__pure__)) ;
#line 774
extern void __gmpz_com(mpz_ptr  , mpz_srcptr  ) ;
#line 789
extern void __gmpz_divexact(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 795
extern int __gmpz_divisible_p(mpz_srcptr  , mpz_srcptr  )  __attribute__((__pure__)) ;
#line 816
extern void __gmpz_fdiv_q_2exp(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 819
extern unsigned long __gmpz_fdiv_q_ui(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 885
extern long __gmpz_get_si(mpz_srcptr  )  __attribute__((__pure__)) ;
#line 907
extern void __gmpz_init(mpz_ptr  ) ;
#line 941
extern void __gmpz_ior(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 978
extern void __gmpz_mod(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 983
extern void __gmpz_mul(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 986
extern void __gmpz_mul_2exp(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 1026
extern void __gmpz_pow_ui(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 1062
extern unsigned long __gmpz_scan1(mpz_srcptr  , unsigned long  )  __attribute__((__pure__)) ;
#line 1068
extern void __gmpz_set_d(mpz_ptr  , double  ) ;
#line 1079
extern void __gmpz_set_si(mpz_ptr  , long  ) ;
#line 1082
extern int __gmpz_set_str(mpz_ptr  , char const   * , int  ) ;
#line 1085
extern void __gmpz_set_ui(mpz_ptr  , unsigned long  ) ;
#line 1096
extern size_t __gmpz_sizeinbase(mpz_srcptr  , int  )  __attribute__((__pure__)) ;
#line 1105
extern void __gmpz_sub(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 1108
extern void __gmpz_sub_ui(mpz_ptr  , mpz_srcptr  , unsigned long  ) ;
#line 1163
extern void __gmpz_xor(mpz_ptr  , mpz_srcptr  , mpz_srcptr  ) ;
#line 208 "/usr/include/mpfr.h"
extern int mpfr_set_emin(mp_exp_t  ) ;
#line 212
extern int mpfr_set_emax(mp_exp_t  ) ;
#line 216
extern void mpfr_set_default_rounding_mode(mpfr_rnd_t  ) ;
#line 232
extern void mpfr_set_erangeflag(void) ;
#line 240
extern int mpfr_check_range(mpfr_ptr  , int  , mpfr_rnd_t  ) ;
#line 243
extern void mpfr_init2(mpfr_ptr  , mpfr_prec_t  ) ;
#line 244
extern void mpfr_init(mpfr_ptr  ) ;
#line 245
extern void mpfr_clear(mpfr_ptr  ) ;
#line 263
extern void mpfr_set_prec(mpfr_ptr  , mpfr_prec_t  ) ;
#line 265
extern void mpfr_set_default_prec(mpfr_prec_t  ) ;
#line 268
extern int mpfr_set_d(mpfr_ptr  , double  , mpfr_rnd_t  ) ;
#line 275
extern int mpfr_set_z(mpfr_ptr  , mpz_srcptr  , mpfr_rnd_t  ) ;
#line 297
extern int mpfr_set4(mpfr_ptr  , mpfr_srcptr  , mpfr_rnd_t  , int  ) ;
#line 303
extern int mpfr_neg(mpfr_ptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 340
extern long mpfr_get_si(mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 345
extern void mpfr_get_z(mpz_ptr z , mpfr_srcptr f , mpfr_rnd_t  ) ;
#line 348
extern void mpfr_free_str(char * ) ;
#line 353
extern int mpfr_urandomb(mpfr_ptr  , __gmp_randstate_struct * ) ;
#line 389
extern int __gmpfr_vasprintf(char ** , char const   * , va_list  ) ;
#line 397
extern int mpfr_pow(mpfr_ptr  , mpfr_srcptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 407
extern int mpfr_pow_z(mpfr_ptr  , mpfr_srcptr  , mpz_srcptr  , mpfr_rnd_t  ) ;
#line 410
extern int mpfr_sqrt(mpfr_ptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 417
extern int mpfr_add(mpfr_ptr  , mpfr_srcptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 419
extern int mpfr_sub(mpfr_ptr  , mpfr_srcptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 421
extern int mpfr_mul(mpfr_ptr  , mpfr_srcptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 423
extern int mpfr_div(mpfr_ptr  , mpfr_srcptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 439
extern int mpfr_add_si(mpfr_ptr  , mpfr_srcptr  , long  , mpfr_rnd_t  ) ;
#line 475
extern int mpfr_log(mpfr_ptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 482
extern int mpfr_exp(mpfr_ptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 492
extern int mpfr_cmp3(mpfr_srcptr  , mpfr_srcptr  , int  ) ;
#line 541
extern int mpfr_fmod(mpfr_ptr  , mpfr_srcptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 560
extern int mpfr_number_p(mpfr_srcptr  ) ;
#line 561
extern int mpfr_integer_p(mpfr_srcptr  ) ;
#line 589
extern int mpfr_sin(mpfr_ptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 592
extern int mpfr_cos(mpfr_ptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 594
extern int mpfr_atan2(mpfr_ptr  , mpfr_srcptr  , mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 629
extern int mpfr_mul_z(mpfr_ptr  , mpfr_srcptr  , mpz_srcptr  , mpfr_rnd_t  ) ;
#line 633
extern int mpfr_add_z(mpfr_ptr  , mpfr_srcptr  , mpz_srcptr  , mpfr_rnd_t  ) ;
#line 635
extern int mpfr_sub_z(mpfr_ptr  , mpfr_srcptr  , mpz_srcptr  , mpfr_rnd_t  ) ;
#line 637
extern int mpfr_cmp_z(mpfr_srcptr  , mpz_srcptr  ) ;
#line 660
extern int mpfr_subnormalize(mpfr_ptr  , int  , mpfr_rnd_t  ) ;
#line 663
extern int mpfr_strtofr(mpfr_ptr  , char const   * , char ** , int  , mpfr_rnd_t  ) ;
#line 1027 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
long NR ;
#line 1043
NODE *NR_node ;
#line 1046
NODE *PREC_node ;
#line 1046
NODE *ROUNDMODE_node ;
#line 1102
int use_lc_numeric ;
#line 1129 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
mpfr_rnd_t ROUND_MODE  ;
#line 1130 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
mpz_t MNR  ;
#line 1131 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
mpz_t MFNR  ;
#line 1132 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
mpz_t mpzval  ;
#line 1133 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
_Bool do_ieee_fmt  ;
#line 1154
STACK_ITEM *stack_ptr ;
#line 1187 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static void DEREF(NODE *r ) 
{ 


  {
#line 1190
  (r->sub.val.sref) --;
#line 1190
  if (r->sub.val.sref == 0L) {
    {
#line 1191
    r_unref(r);
    }
  }
#line 1192
  return;
}
}
#line 1451
int register_exec_hook(int (*preh)(INSTRUCTION ** ) , void (*posth)(INSTRUCTION * ) ) ;
#line 1539
void set_PREC(void) ;
#line 1540
void set_ROUNDMODE(void) ;
#line 1543
int mpg_cmp(NODE const   *t1 , NODE const   *t2 ) ;
#line 1544
int format_ieee(mpfr_ptr x , int tval ) ;
#line 1546
long mpg_set_var(NODE *n ) ;
#line 1547
NODE *do_mpfr_and(int nargs ) ;
#line 1548
NODE *do_mpfr_atan2(int nargs ) ;
#line 1549
NODE *do_mpfr_compl(int nargs ) ;
#line 1550
NODE *do_mpfr_cos(int nargs ) ;
#line 1551
NODE *do_mpfr_exp(int nargs ) ;
#line 1552
NODE *do_mpfr_int(int nargs ) ;
#line 1553
NODE *do_mpfr_log(int nargs ) ;
#line 1554
NODE *do_mpfr_lshift(int nargs ) ;
#line 1555
NODE *do_mpfr_or(int nargs ) ;
#line 1556
NODE *do_mpfr_rand(int nargs  __attribute__((__unused__)) ) ;
#line 1557
NODE *do_mpfr_rshift(int nargs ) ;
#line 1558
NODE *do_mpfr_sin(int nargs ) ;
#line 1559
NODE *do_mpfr_sqrt(int nargs ) ;
#line 1560
NODE *do_mpfr_srand(int nargs ) ;
#line 1561
NODE *do_mpfr_strtonum(int nargs ) ;
#line 1562
NODE *do_mpfr_xor(int nargs ) ;
#line 1563
void init_mpfr(mpfr_prec_t prec , char const   *rmode ) ;
#line 1564
NODE *mpg_node(unsigned int tp ) ;
#line 1565
char const   *mpg_fmt(char const   *mesg  , ...) ;
#line 1566
int mpg_strtoui(mpz_ptr zi , char *str , size_t len , char **end , int base ) ;
#line 1734 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static NODE *POP_SCALAR(void) 
{ 
  NODE *t ;
  STACK_ITEM *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1737
  tmp___1 = stack_ptr;
#line 1737
  stack_ptr --;
#line 1737
  t = tmp___1->rptr;
#line 1739
  if ((unsigned int )t->type == 5U) {
    {
#line 1740
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h", 1740);
#line 1740
    tmp___2 = array_vname((NODE const   *)t);
#line 1740
    tmp___3 = gettext("attempt to use array `%s\' in a scalar context");
#line 1740
    r_fatal((char const   *)tmp___3, tmp___2);
    }
  }
#line 1742
  return (t);
}
}
#line 1747 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static NODE *TOP_SCALAR(void) 
{ 
  NODE *t ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1750
  t = stack_ptr->rptr;
#line 1752
  if ((unsigned int )t->type == 5U) {
    {
#line 1753
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h", 1753);
#line 1753
    tmp___1 = array_vname((NODE const   *)t);
#line 1753
    tmp___2 = gettext("attempt to use array `%s\' in a scalar context");
#line 1753
    r_fatal((char const   *)tmp___2, tmp___1);
    }
  }
#line 1755
  return (t);
}
}
#line 42 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static mpfr_rnd_t get_rnd_mode(char const   rmode ) ;
#line 43
static NODE *mpg_force_number(NODE *n ) ;
#line 44
static NODE *mpg_make_number(double x ) ;
#line 45
static NODE *mpg_format_val(char const   *format , int index___0 , NODE *s___0 ) ;
#line 46
static int mpg_interpret(INSTRUCTION **cp ) ;
#line 48 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static mpfr_exp_t min_exp  =    - ((mp_exp_t )((1UL << 30) - 1UL));
#line 49 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static mpfr_exp_t max_exp  =    (mp_exp_t )((1UL << 30) - 1UL);
#line 52 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static mpfr_t _mpf_t1  ;
#line 53 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static mpfr_t _mpf_t2  ;
#line 63
__inline static mpfr_ptr mpg_tofloat(mpfr_ptr mf , mpz_ptr mz ) ;
#line 70 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
void init_mpfr(mpfr_prec_t prec , char const   *rmode ) 
{ 


  {
  {
#line 73
  mpfr_set_default_prec(prec);
#line 74
  ROUND_MODE = get_rnd_mode(*(rmode + 0));
#line 75
  mpfr_set_default_rounding_mode(ROUND_MODE);
#line 76
  make_number = & mpg_make_number;
#line 77
  str2number = & mpg_force_number;
#line 78
  format_val = & mpg_format_val;
#line 79
  cmp_numbers = & mpg_cmp;
#line 81
  __gmpz_init(MNR);
#line 82
  __gmpz_init(MFNR);
#line 83
  do_ieee_fmt = (_Bool)0;
#line 85
  mpfr_init2(_mpf_t1, (mpfr_prec_t )64);
#line 86
  mpfr_init2(_mpf_t2, (mpfr_prec_t )64);
#line 87
  __gmpz_init(mpzval);
#line 89
  register_exec_hook(& mpg_interpret, (void (*)(INSTRUCTION * ))0);
  }
#line 90
  return;
}
}
#line 94 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *mpg_node(unsigned int tp ) 
{ 
  NODE *r ;
  void *tmp___1 ;

  {
#line 98
  r = (NODE *)nextfree[1].freep;
#line 98
  if (r) {
#line 98
    nextfree[1].freep = ((BLOCK *)r)->freep;
  } else {
    {
#line 98
    tmp___1 = more_blocks(1);
#line 98
    r = (NODE *)tmp___1;
    }
  }
#line 99
  r->type = (NODETYPE )1;
#line 101
  if (tp == 2048U) {
    {
#line 103
    mpfr_init(r->sub.val.nm.mpnum);
#line 104
    r->flags = 2048U;
    }
  } else {
    {
#line 107
    __gmpz_init(r->sub.val.nm.mpi);
#line 108
    r->flags = 4096U;
    }
  }
#line 111
  r->sub.val.sref = 1L;
#line 112
  r->flags |= 25U;
#line 113
  r->sub.val.sp = (char *)((void *)0);
#line 114
  r->sub.val.slen = (size_t )0;
#line 116
  r->sub.val.wsp = (wchar_t *)((void *)0);
#line 117
  r->sub.val.wslen = (size_t )0;
#line 119
  return (r);
}
}
#line 127 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static NODE *mpg_make_number(double x ) 
{ 
  NODE *r ;
  double ival ;
  int tval ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 133
  ival = double_to_int(x);
  }
#line 133
  if (ival != x) {
    {
#line 135
    r = mpg_node(2048U);
#line 136
    tval = mpfr_set_d(r->sub.val.nm.mpnum, x, ROUND_MODE);
    }
#line 137
    if (do_ieee_fmt) {
      {
#line 137
      tmp___1 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 137
      if (tmp___1) {
#line 137
        tmp___2 = 1;
      } else {
#line 137
        tmp___2 = 0;
      }
    } else {
#line 137
      tmp___2 = 0;
    }
  } else {
    {
#line 139
    r = mpg_node(4096U);
#line 140
    __gmpz_set_d(r->sub.val.nm.mpi, ival);
    }
  }
#line 142
  return (r);
}
}
#line 147 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
int mpg_strtoui(mpz_ptr zi , char *str , size_t len , char **end , int base ) 
{ 
  char *s___0 ;
  char *start ;
  int ret ;
  char save ;

  {
#line 150
  s___0 = str;
#line 152
  ret = -1;
#line 158
  if (base == 16) {
#line 158
    if (len >= 2UL) {
#line 158
      if ((int )*s___0 == 48) {
#line 158
        if ((int )*(s___0 + 1) == 120) {
#line 159
          s___0 += 2;
#line 159
          len -= 2UL;
        } else
#line 158
        if ((int )*(s___0 + 1) == 88) {
#line 159
          s___0 += 2;
#line 159
          len -= 2UL;
        } else {
#line 158
          goto _L___1;
        }
      } else {
#line 158
        goto _L___1;
      }
    } else {
#line 158
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 160
  if (base == 8) {
#line 160
    if (len >= 1UL) {
#line 160
      if ((int )*s___0 == 48) {
#line 161
        s___0 ++;
#line 161
        len --;
      }
    }
  }
#line 163
  start = s___0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (len > 0UL)) {
#line 165
      goto while_break;
    }
    {
#line 174
    if ((int )*s___0 == 55) {
#line 174
      goto case_55;
    }
#line 174
    if ((int )*s___0 == 54) {
#line 174
      goto case_55;
    }
#line 174
    if ((int )*s___0 == 53) {
#line 174
      goto case_55;
    }
#line 174
    if ((int )*s___0 == 52) {
#line 174
      goto case_55;
    }
#line 174
    if ((int )*s___0 == 51) {
#line 174
      goto case_55;
    }
#line 174
    if ((int )*s___0 == 50) {
#line 174
      goto case_55;
    }
#line 174
    if ((int )*s___0 == 49) {
#line 174
      goto case_55;
    }
#line 174
    if ((int )*s___0 == 48) {
#line 174
      goto case_55;
    }
#line 177
    if ((int )*s___0 == 57) {
#line 177
      goto case_57;
    }
#line 177
    if ((int )*s___0 == 56) {
#line 177
      goto case_57;
    }
#line 192
    if ((int )*s___0 == 70) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 69) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 68) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 67) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 66) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 65) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 102) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 101) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 100) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 99) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 98) {
#line 192
      goto case_70;
    }
#line 192
    if ((int )*s___0 == 97) {
#line 192
      goto case_70;
    }
#line 195
    goto switch_default;
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 175
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
#line 178
    if (base == 8) {
#line 179
      goto done;
    }
#line 180
    goto switch_break;
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 193
    if (base == 16) {
#line 194
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 196
    goto done;
    switch_break: /* CIL Label */ ;
    }
#line 198
    s___0 ++;
#line 198
    len --;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 201
  if ((unsigned long )s___0 > (unsigned long )start) {
    {
#line 202
    save = *s___0;
#line 203
    *s___0 = (char )'\000';
#line 204
    ret = __gmpz_set_str(zi, (char const   *)start, base);
#line 205
    *s___0 = save;
    }
  }
#line 207
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 208
    *end = s___0;
  }
#line 209
  return (ret);
}
}
#line 215 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static int mpg_maybe_float(char const   *str , int use_locale ) 
{ 
  int dec_point ;
  char const   *s___0 ;
  size_t tmp___1 ;

  {
#line 218
  dec_point = '.';
#line 219
  s___0 = str;
#line 226
  if (use_locale) {
#line 226
    if ((unsigned long )loc.decimal_point != (unsigned long )((void *)0)) {
#line 226
      if ((int )*(loc.decimal_point + 0) != 0) {
#line 227
        dec_point = (int )*(loc.decimal_point + 0);
      }
    }
  }
  {
#line 230
  tmp___1 = strlen(s___0);
  }
#line 230
  if (tmp___1 >= 3UL) {
#line 230
    if ((int const   )*(s___0 + 0) == 105) {
#line 230
      goto _L___4;
    } else
#line 230
    if ((int const   )*(s___0 + 0) == 73) {
      _L___4: /* CIL Label */ 
#line 230
      if ((int const   )*(s___0 + 1) == 110) {
#line 230
        goto _L___3;
      } else
#line 230
      if ((int const   )*(s___0 + 1) == 78) {
        _L___3: /* CIL Label */ 
#line 230
        if ((int const   )*(s___0 + 2) == 102) {
#line 237
          return (1);
        } else
#line 230
        if ((int const   )*(s___0 + 2) == 70) {
#line 237
          return (1);
        } else {
#line 230
          goto _L___2;
        }
      } else {
#line 230
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 230
    if ((int const   )*(s___0 + 0) == 110) {
#line 230
      goto _L___0;
    } else
#line 230
    if ((int const   )*(s___0 + 0) == 78) {
      _L___0: /* CIL Label */ 
#line 230
      if ((int const   )*(s___0 + 1) == 97) {
#line 230
        goto _L;
      } else
#line 230
      if ((int const   )*(s___0 + 1) == 65) {
        _L: /* CIL Label */ 
#line 230
        if ((int const   )*(s___0 + 2) == 110) {
#line 237
          return (1);
        } else
#line 230
        if ((int const   )*(s___0 + 2) == 78) {
#line 237
          return (1);
        }
      }
    }
  }
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! ((int const   )*s___0 != 0)) {
#line 239
      goto while_break;
    }
#line 240
    if ((int const   )*s___0 == (int const   )dec_point) {
#line 241
      return (1);
    } else
#line 240
    if ((int const   )*s___0 == 101) {
#line 241
      return (1);
    } else
#line 240
    if ((int const   )*s___0 == 69) {
#line 241
      return (1);
    }
#line 239
    s___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return (0);
}
}
#line 250 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
__inline static void mpg_zero(NODE *n ) 
{ 


  {
#line 253
  if ((n->flags & 2048U) != 0U) {
    {
#line 254
    mpfr_clear(n->sub.val.nm.mpnum);
#line 255
    n->flags &= 4294965247U;
    }
  }
#line 257
  if (! ((n->flags & 4096U) != 0U)) {
    {
#line 258
    __gmpz_init(n->sub.val.nm.mpi);
#line 259
    n->flags |= 4096U;
    }
  } else {
    {
#line 261
    __gmpz_set_si(n->sub.val.nm.mpi, 0L);
    }
  }
#line 262
  return;
}
}
#line 267 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static int force_mpnum(NODE *n , int do_nondec , int use_locale ) 
{ 
  char *cp ;
  char *cpend ;
  char *ptr ;
  char *cp1 ;
  char save ;
  int tval ;
  int base ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 272
  base = 10;
#line 274
  if (n->sub.val.slen == 0UL) {
    {
#line 275
    mpg_zero(n);
    }
#line 276
    return (0);
  }
#line 279
  cp = n->sub.val.sp;
#line 280
  cpend = n->sub.val.sp + n->sub.val.slen;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if ((unsigned long )cp < (unsigned long )cpend) {
      {
#line 281
      tmp___1 = __ctype_b_loc();
      }
#line 281
      if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*cp)) & 8192)) {
#line 281
        goto while_break;
      }
    } else {
#line 281
      goto while_break;
    }
#line 282
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  if ((unsigned long )cp == (unsigned long )cpend) {
    {
#line 284
    mpg_zero(n);
    }
#line 285
    return (0);
  }
#line 288
  save = *cpend;
#line 289
  *cpend = (char )'\000';
#line 291
  if ((int )*cp == 43) {
#line 292
    cp1 = cp + 1;
  } else
#line 291
  if ((int )*cp == 45) {
#line 292
    cp1 = cp + 1;
  } else {
#line 294
    cp1 = cp;
  }
#line 296
  if (do_nondec) {
    {
#line 297
    base = get_numbase((char const   *)cp1, (_Bool )use_locale);
    }
  }
  {
#line 299
  tmp___3 = mpg_maybe_float((char const   *)cp1, use_locale);
  }
#line 299
  if (! tmp___3) {
    {
#line 300
    mpg_zero(n);
#line 301
    tmp___2 = __errno_location();
#line 301
    *tmp___2 = 0;
#line 302
    mpg_strtoui(n->sub.val.nm.mpi, cp1, (size_t )(cpend - cp1), & ptr, base);
    }
#line 303
    if ((int )*cp == 45) {
      {
#line 304
      __gmpz_neg(n->sub.val.nm.mpi, (mpz_srcptr )(n->sub.val.nm.mpi));
      }
    }
#line 305
    goto done;
  }
#line 308
  if ((n->flags & 4096U) != 0U) {
    {
#line 309
    __gmpz_clear(n->sub.val.nm.mpi);
#line 310
    n->flags &= 4294963199U;
    }
  }
#line 313
  if (! ((n->flags & 2048U) != 0U)) {
    {
#line 314
    mpfr_init(n->sub.val.nm.mpnum);
#line 315
    n->flags |= 2048U;
    }
  }
  {
#line 318
  tmp___4 = __errno_location();
#line 318
  *tmp___4 = 0;
#line 319
  tval = mpfr_strtofr(n->sub.val.nm.mpnum, (char const   *)cp, & ptr, base, ROUND_MODE);
  }
#line 320
  if (do_ieee_fmt) {
    {
#line 320
    tmp___5 = format_ieee(n->sub.val.nm.mpnum, tval);
    }
#line 320
    if (tmp___5) {
#line 320
      tmp___6 = 1;
    } else {
#line 320
      tmp___6 = 0;
    }
  } else {
#line 320
    tmp___6 = 0;
  }
  done: 
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 323
    tmp___7 = __ctype_b_loc();
    }
#line 323
    if (! ((int const   )*(*tmp___7 + (int )((unsigned char )*ptr)) & 8192)) {
#line 323
      goto while_break___0;
    }
#line 324
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 325
  *cpend = save;
#line 326
  tmp___8 = __errno_location();
  }
#line 326
  if (*tmp___8 == 0) {
#line 326
    if ((unsigned long )ptr == (unsigned long )cpend) {
#line 327
      return (1);
    }
  }
  {
#line 328
  tmp___9 = __errno_location();
#line 328
  *tmp___9 = 0;
  }
#line 329
  return (0);
}
}
#line 334 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static NODE *mpg_force_number(NODE *n ) 
{ 
  unsigned int newflags ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 337
  newflags = 0U;
#line 339
  if ((n->flags & 6144U) != 0U) {
#line 339
    if ((n->flags & 8U) != 0U) {
#line 340
      return (n);
    }
  }
#line 342
  if ((n->flags & 32U) != 0U) {
#line 343
    n->flags &= 4294967263U;
#line 344
    newflags = 16U;
  }
#line 347
  if (do_flags & 64) {
#line 347
    if (! (do_flags & 8)) {
#line 347
      tmp___1 = 1;
    } else {
#line 347
      tmp___1 = 0;
    }
  } else {
#line 347
    tmp___1 = 0;
  }
  {
#line 347
  tmp___2 = force_mpnum(n, tmp___1, 1);
  }
#line 347
  if (tmp___2) {
#line 348
    n->flags |= newflags;
#line 349
    n->flags |= 8U;
  }
#line 351
  return (n);
}
}
#line 356 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static NODE *mpg_format_val(char const   *format , int index___0 , NODE *s___0 ) 
{ 
  NODE *dummy[2] ;
  NODE *r ;
  unsigned int oflags ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 363
  dummy[1] = s___0;
#line 364
  oflags = s___0->flags;
#line 366
  if ((s___0->flags & 4096U) != 0U) {
    {
#line 368
    r = format_tree("%d", (size_t )2, dummy, 2L);
#line 369
    s___0->sub.val.idx = -1;
    }
  } else {
    {
#line 366
    tmp___1 = mpfr_integer_p((mpfr_srcptr )(s___0->sub.val.nm.mpnum));
    }
#line 366
    if (tmp___1) {
      {
#line 368
      r = format_tree("%d", (size_t )2, dummy, 2L);
#line 369
      s___0->sub.val.idx = -1;
      }
    } else {
      {
#line 371
      r = format_tree(format, (*(fmt_list + index___0))->sub.val.slen, dummy, 2L);
#line 373
      s___0->sub.val.idx = (int )((char )index___0);
      }
    }
  }
#line 375
  s___0->flags = oflags;
#line 376
  s___0->sub.val.slen = r->sub.val.slen;
#line 377
  if ((s___0->flags & 4U) != 0U) {
    {
#line 378
    free((void *)s___0->sub.val.sp);
    }
  }
#line 379
  s___0->sub.val.sp = r->sub.val.sp;
#line 380
  ((BLOCK *)r)->freep = nextfree[1].freep;
#line 380
  nextfree[1].freep = (BLOCK *)r;
#line 382
  s___0->flags |= 4U;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (s___0->flags & 1024U) {
      {
#line 383
      r_free_wstr(s___0);
      }
    }
#line 383
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  return (s___0);
}
}
#line 389 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
int mpg_cmp(NODE const   *t1 , NODE const   *t2 ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  int ret ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 397
  if ((t1->flags & 2048U) != 0U) {
#line 398
    if ((t2->flags & 2048U) != 0U) {
#line 399
      if (t1->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t const   )((mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 2UL))) {
#line 400
        return (! (t2->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t const   )((mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 2UL))));
      }
#line 401
      if (t2->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t const   )((mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 2UL))) {
#line 402
        return (-1);
      }
      {
#line 403
      tmp___1 = mpfr_cmp3((mpfr_srcptr )(t1->sub.val.nm.mpnum), (mpfr_srcptr )(t2->sub.val.nm.mpnum),
                          1);
      }
#line 403
      return (tmp___1);
    }
#line 405
    if (t1->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t const   )((mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 2UL))) {
#line 406
      return (1);
    }
    {
#line 407
    tmp___2 = mpfr_cmp_z((mpfr_srcptr )(t1->sub.val.nm.mpnum), (mpz_srcptr )(t2->sub.val.nm.mpi));
    }
#line 407
    return (tmp___2);
  } else
#line 408
  if ((t2->flags & 2048U) != 0U) {
#line 410
    if (t2->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t const   )((mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 2UL))) {
#line 411
      return (-1);
    }
    {
#line 412
    ret = mpfr_cmp_z((mpfr_srcptr )(t2->sub.val.nm.mpnum), (mpz_srcptr )(t1->sub.val.nm.mpi));
    }
#line 413
    if (ret > 0) {
#line 413
      tmp___3 = -1;
    } else {
#line 413
      tmp___3 = ret < 0;
    }
#line 413
    return (tmp___3);
  } else
#line 414
  if ((t1->flags & 4096U) != 0U) {
    {
#line 415
    tmp___4 = __gmpz_cmp((mpz_srcptr )(t1->sub.val.nm.mpi), (mpz_srcptr )(t2->sub.val.nm.mpi));
    }
#line 415
    return (tmp___4);
  }
  {
#line 419
  tmp___5 = cmp_awknums(t1, t2);
  }
#line 419
  return (tmp___5);
}
}
#line 428 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *mpg_update_var(NODE *n ) 
{ 
  NODE *val ;
  long nr ;
  mpz_ptr nq ;
  struct exp_node *tmp___1 ;
  long tmp___2 ;
  struct exp_node *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 431
  val = n->sub.nodep.l.lptr;
#line 432
  nr = 0L;
#line 433
  nq = (mpz_ptr )0;
#line 435
  if ((unsigned long )n == (unsigned long )NR_node) {
#line 436
    nr = NR;
#line 437
    nq = MNR;
  } else
#line 438
  if ((unsigned long )n == (unsigned long )FNR_node) {
#line 439
    nr = FNR;
#line 440
    nq = MFNR;
  } else {
    {
#line 442
    r_fatal("internal error line %d, file: %s", 442, "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c");
    }
  }
#line 444
  if (nq->_mp_size < 0) {
#line 444
    tmp___4 = -1;
  } else {
#line 444
    tmp___4 = nq->_mp_size > 0;
  }
#line 444
  if (tmp___4 == 0) {
#line 446
    if ((val->flags & 2048U) != 0U) {
      {
#line 447
      unref(n->sub.nodep.l.lptr);
#line 448
      tmp___1 = mpg_node(4096U);
#line 448
      n->sub.nodep.l.lptr = tmp___1;
#line 448
      val = tmp___1;
#line 449
      __gmpz_set_si(val->sub.val.nm.mpi, nr);
      }
    } else {
      {
#line 446
      tmp___2 = __gmpz_get_si((mpz_srcptr )(val->sub.val.nm.mpi));
      }
#line 446
      if (tmp___2 != nr) {
        {
#line 447
        unref(n->sub.nodep.l.lptr);
#line 448
        tmp___1 = mpg_node(4096U);
#line 448
        n->sub.nodep.l.lptr = tmp___1;
#line 448
        val = tmp___1;
#line 449
        __gmpz_set_si(val->sub.val.nm.mpi, nr);
        }
      }
    }
  } else {
    {
#line 452
    unref(n->sub.nodep.l.lptr);
#line 453
    tmp___3 = mpg_node(4096U);
#line 453
    n->sub.nodep.l.lptr = tmp___3;
#line 453
    val = tmp___3;
#line 454
    __gmpz_set_si(val->sub.val.nm.mpi, nr);
#line 455
    __gmpz_addmul_ui(val->sub.val.nm.mpi, (mpz_srcptr )nq, 9223372036854775807UL);
    }
  }
#line 457
  return (val);
}
}
#line 462 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
long mpg_set_var(NODE *n ) 
{ 
  long nr ;
  mpz_ptr nq ;
  mpz_ptr r ;
  NODE *val ;
  unsigned long tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 465
  nr = 0L;
#line 466
  nq = (mpz_ptr )0;
#line 467
  val = n->sub.nodep.l.lptr;
#line 469
  if ((unsigned long )n == (unsigned long )NR_node) {
#line 470
    nq = MNR;
  } else
#line 471
  if ((unsigned long )n == (unsigned long )FNR_node) {
#line 472
    nq = MFNR;
  } else {
    {
#line 474
    r_fatal("internal error line %d, file: %s", 474, "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c");
    }
  }
#line 476
  if ((val->flags & 4096U) != 0U) {
#line 477
    r = val->sub.val.nm.mpi;
  } else {
    {
#line 480
    mpfr_get_z(mpzval, (mpfr_srcptr )(val->sub.val.nm.mpnum), (mpfr_rnd_t )1);
#line 481
    r = mpzval;
    }
  }
  {
#line 483
  tmp___1 = __gmpz_fdiv_q_ui(nq, (mpz_srcptr )r, 9223372036854775807UL);
#line 483
  nr = (long )tmp___1;
  }
#line 484
  return (nr);
}
}
#line 494 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static struct ieee_fmt  const  ieee_fmts[5]  = {      {"half", (mpfr_prec_t )11, (mpfr_exp_t )16, (mpfr_exp_t )-23}, 
        {"single", (mpfr_prec_t )24, (mpfr_exp_t )128, (mpfr_exp_t )-148}, 
        {"double", (mpfr_prec_t )53, (mpfr_exp_t )1024, (mpfr_exp_t )-1073}, 
        {"quad", (mpfr_prec_t )113, (mpfr_exp_t )16384, (mpfr_exp_t )-16493}, 
        {"oct", (mpfr_prec_t )237, (mpfr_exp_t )262144, (mpfr_exp_t )-262377}};
#line 489 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
void set_PREC(void) 
{ 
  long prec ;
  NODE *val ;
  int i___0 ;
  int j ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 492
  prec = 0L;
#line 514
  if (! (do_flags & 16384)) {
#line 515
    return;
  }
#line 517
  val = PREC_node->sub.nodep.l.lptr;
#line 518
  if ((val->flags & 32U) != 0U) {
    {
#line 519
    force_number(val);
    }
  }
#line 521
  if ((val->flags & 18U) == 2U) {
#line 526
    i___0 = 0;
#line 526
    j = (int )(sizeof(ieee_fmts) / sizeof(ieee_fmts[0]));
    {
#line 526
    while (1) {
      while_continue: /* CIL Label */ ;
#line 526
      if (! (i___0 < j)) {
#line 526
        goto while_break;
      }
      {
#line 527
      tmp___1 = strcasecmp((char const   *)ieee_fmts[i___0].name, (char const   *)val->sub.val.sp);
      }
#line 527
      if (tmp___1 == 0) {
#line 528
        goto while_break;
      }
#line 526
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 531
    if (i___0 < j) {
#line 532
      prec = (long )ieee_fmts[i___0].precision;
#line 538
      max_exp = (mpfr_exp_t )ieee_fmts[i___0].emax;
#line 539
      min_exp = (mpfr_exp_t )ieee_fmts[i___0].emin;
#line 541
      do_ieee_fmt = (_Bool)1;
    }
  }
#line 545
  if (prec <= 0L) {
    {
#line 546
    force_number(val);
    }
#line 547
    if (val->flags & 2048U) {
      {
#line 547
      tmp___2 = mpfr_get_si((mpfr_srcptr )(val->sub.val.nm.mpnum), ROUND_MODE);
#line 547
      prec = tmp___2;
      }
    } else {
#line 547
      if (val->flags & 4096U) {
        {
#line 547
        tmp___3 = __gmpz_get_si((mpz_srcptr )(val->sub.val.nm.mpi));
#line 547
        tmp___4 = tmp___3;
        }
      } else {
#line 547
        tmp___4 = (long )val->sub.val.nm.fltnum;
      }
#line 547
      prec = tmp___4;
    }
#line 548
    if (prec < 2L) {
      {
#line 549
      force_string(val);
#line 550
      tmp___5 = gettext("PREC value `%.*s\' is invalid");
#line 550
      warning((char const   *)tmp___5, (int )val->sub.val.slen, val->sub.val.sp);
#line 551
      prec = 0L;
      }
    } else
#line 548
    if ((mpfr_prec_t )prec > 0xffffffffffffffffUL >> 1) {
      {
#line 549
      force_string(val);
#line 550
      tmp___5 = gettext("PREC value `%.*s\' is invalid");
#line 550
      warning((char const   *)tmp___5, (int )val->sub.val.slen, val->sub.val.sp);
#line 551
      prec = 0L;
      }
    } else {
#line 553
      do_ieee_fmt = (_Bool)0;
    }
  }
#line 556
  if (prec > 0L) {
    {
#line 557
    mpfr_set_default_prec((mpfr_prec_t )prec);
    }
  }
#line 558
  return;
}
}
#line 563 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static mpfr_rnd_t get_rnd_mode(char const   rmode ) 
{ 


  {
  {
#line 568
  if ((int const   )rmode == 110) {
#line 568
    goto case_110;
  }
#line 568
  if ((int const   )rmode == 78) {
#line 568
    goto case_110;
  }
#line 571
  if ((int const   )rmode == 122) {
#line 571
    goto case_122;
  }
#line 571
  if ((int const   )rmode == 90) {
#line 571
    goto case_122;
  }
#line 574
  if ((int const   )rmode == 117) {
#line 574
    goto case_117;
  }
#line 574
  if ((int const   )rmode == 85) {
#line 574
    goto case_117;
  }
#line 577
  if ((int const   )rmode == 100) {
#line 577
    goto case_100;
  }
#line 577
  if ((int const   )rmode == 68) {
#line 577
    goto case_100;
  }
#line 584
  goto switch_default;
  case_110: /* CIL Label */ 
  case_78: /* CIL Label */ 
#line 569
  return ((mpfr_rnd_t )0);
  case_122: /* CIL Label */ 
  case_90: /* CIL Label */ 
#line 572
  return ((mpfr_rnd_t )1);
  case_117: /* CIL Label */ 
  case_85: /* CIL Label */ 
#line 575
  return ((mpfr_rnd_t )2);
  case_100: /* CIL Label */ 
  case_68: /* CIL Label */ 
#line 578
  return ((mpfr_rnd_t )3);
  switch_default: /* CIL Label */ 
#line 585
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 587
  return ((mpfr_rnd_t )-1);
}
}
#line 595 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
void set_ROUNDMODE(void) 
{ 
  mpfr_rnd_t rndm ;
  NODE *n ;
  char *tmp___1 ;
  char *__cil_tmp4 ;

  {
#line 598
  if (do_flags & 16384) {
    {
#line 599
    rndm = (mpfr_rnd_t )-1;
#line 601
    n = force_string(ROUNDMODE_node->sub.nodep.l.lptr);
    }
#line 602
    if (n->sub.val.slen == 1UL) {
      {
#line 603
      rndm = get_rnd_mode((char const   )*(n->sub.val.sp + 0));
      }
    }
#line 604
    if ((int )rndm != -1) {
      {
#line 605
      mpfr_set_default_rounding_mode(rndm);
#line 606
      ROUND_MODE = rndm;
      }
    } else {
      {
#line 608
      tmp___1 = gettext("RNDMODE value `%.*s\' is invalid");
#line 608
      warning((char const   *)tmp___1, (int )n->sub.val.slen, n->sub.val.sp);
      }
    }
  }
#line 610
  return;
}
}
#line 615 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
int format_ieee(mpfr_ptr x , int tval ) 
{ 


  {
  {
#line 648
  mpfr_set_emin(min_exp);
#line 649
  mpfr_set_emax(max_exp);
#line 650
  tval = mpfr_check_range(x, tval, ROUND_MODE);
#line 651
  tval = mpfr_subnormalize(x, tval, ROUND_MODE);
#line 652
  mpfr_set_emin(- ((mp_exp_t )((1UL << 30) - 1UL)));
#line 653
  mpfr_set_emax((mp_exp_t )((1UL << 30) - 1UL));
  }
#line 654
  return (tval);
}
}
#line 660 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_atan2(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  NODE *res ;
  mpfr_ptr p1 ;
  mpfr_ptr p2 ;
  int tval ;
  char *tmp___1 ;
  char *tmp___2 ;
  mpfr_ptr tmp___3 ;
  mpfr_ptr tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 667
  t2 = POP_SCALAR();
#line 668
  t1 = POP_SCALAR();
  }
#line 670
  if (do_flags & 3) {
#line 671
    if ((t1->flags & 24U) == 0U) {
      {
#line 672
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 672);
#line 672
      tmp___1 = gettext("atan2: received non-numeric first argument");
#line 672
      (*lintfunc)((char const   *)tmp___1);
      }
    }
#line 673
    if ((t2->flags & 24U) == 0U) {
      {
#line 674
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 674);
#line 674
      tmp___2 = gettext("atan2: received non-numeric second argument");
#line 674
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 676
  force_number(t1);
#line 677
  force_number(t2);
  }
#line 679
  if ((t1->flags & 4096U) != 0U) {
    {
#line 679
    tmp___3 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 679
    p1 = tmp___3;
    }
  } else {
#line 679
    p1 = t1->sub.val.nm.mpnum;
  }
#line 680
  if ((t2->flags & 4096U) != 0U) {
    {
#line 680
    tmp___4 = mpg_tofloat(_mpf_t2, t2->sub.val.nm.mpi);
#line 680
    p2 = tmp___4;
    }
  } else {
#line 680
    p2 = t2->sub.val.nm.mpnum;
  }
  {
#line 681
  res = mpg_node(2048U);
#line 683
  tval = mpfr_atan2(res->sub.val.nm.mpnum, (mpfr_srcptr )p1, (mpfr_srcptr )p2, ROUND_MODE);
  }
#line 684
  if (do_ieee_fmt) {
    {
#line 684
    tmp___5 = format_ieee(res->sub.val.nm.mpnum, tval);
    }
#line 684
    if (tmp___5) {
#line 684
      tmp___6 = 1;
    } else {
#line 684
      tmp___6 = 0;
    }
  } else {
#line 684
    tmp___6 = 0;
  }
  {
#line 686
  DEREF(t1);
#line 687
  DEREF(t2);
  }
#line 688
  return (res);
}
}
#line 710 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_sin(int nargs ) 
{ 
  NODE *t1 ;
  NODE *res ;
  mpfr_ptr p1 ;
  int tval ;
  char *tmp___1 ;
  mpfr_ptr tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 713
  t1 = POP_SCALAR();
  }
#line 713
  if (do_flags & 3) {
#line 713
    if ((t1->flags & 24U) == 0U) {
      {
#line 713
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 713);
#line 713
      tmp___1 = gettext("%s: received non-numeric argument");
#line 713
      (*lintfunc)((char const   *)tmp___1, "sin");
      }
    }
  }
  {
#line 713
  force_number(t1);
  }
#line 713
  if ((t1->flags & 4096U) != 0U) {
    {
#line 713
    tmp___2 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 713
    p1 = tmp___2;
    }
  } else {
#line 713
    p1 = t1->sub.val.nm.mpnum;
  }
  {
#line 713
  res = mpg_node(2048U);
#line 713
  tval = mpfr_sin(res->sub.val.nm.mpnum, (mpfr_srcptr )p1, ROUND_MODE);
  }
#line 713
  if (do_ieee_fmt) {
    {
#line 713
    tmp___3 = format_ieee(res->sub.val.nm.mpnum, tval);
    }
#line 713
    if (tmp___3) {
#line 713
      tmp___4 = 1;
    } else {
#line 713
      tmp___4 = 0;
    }
  } else {
#line 713
    tmp___4 = 0;
  }
  {
#line 713
  DEREF(t1);
  }
#line 713
  return (res);
}
}
#line 718 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_cos(int nargs ) 
{ 
  NODE *t1 ;
  NODE *res ;
  mpfr_ptr p1 ;
  int tval ;
  char *tmp___1 ;
  mpfr_ptr tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 721
  t1 = POP_SCALAR();
  }
#line 721
  if (do_flags & 3) {
#line 721
    if ((t1->flags & 24U) == 0U) {
      {
#line 721
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 721);
#line 721
      tmp___1 = gettext("%s: received non-numeric argument");
#line 721
      (*lintfunc)((char const   *)tmp___1, "cos");
      }
    }
  }
  {
#line 721
  force_number(t1);
  }
#line 721
  if ((t1->flags & 4096U) != 0U) {
    {
#line 721
    tmp___2 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 721
    p1 = tmp___2;
    }
  } else {
#line 721
    p1 = t1->sub.val.nm.mpnum;
  }
  {
#line 721
  res = mpg_node(2048U);
#line 721
  tval = mpfr_cos(res->sub.val.nm.mpnum, (mpfr_srcptr )p1, ROUND_MODE);
  }
#line 721
  if (do_ieee_fmt) {
    {
#line 721
    tmp___3 = format_ieee(res->sub.val.nm.mpnum, tval);
    }
#line 721
    if (tmp___3) {
#line 721
      tmp___4 = 1;
    } else {
#line 721
      tmp___4 = 0;
    }
  } else {
#line 721
    tmp___4 = 0;
  }
  {
#line 721
  DEREF(t1);
  }
#line 721
  return (res);
}
}
#line 726 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_exp(int nargs ) 
{ 
  NODE *t1 ;
  NODE *res ;
  mpfr_ptr p1 ;
  int tval ;
  char *tmp___1 ;
  mpfr_ptr tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 729
  t1 = POP_SCALAR();
  }
#line 729
  if (do_flags & 3) {
#line 729
    if ((t1->flags & 24U) == 0U) {
      {
#line 729
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 729);
#line 729
      tmp___1 = gettext("%s: received non-numeric argument");
#line 729
      (*lintfunc)((char const   *)tmp___1, "exp");
      }
    }
  }
  {
#line 729
  force_number(t1);
  }
#line 729
  if ((t1->flags & 4096U) != 0U) {
    {
#line 729
    tmp___2 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 729
    p1 = tmp___2;
    }
  } else {
#line 729
    p1 = t1->sub.val.nm.mpnum;
  }
  {
#line 729
  res = mpg_node(2048U);
#line 729
  tval = mpfr_exp(res->sub.val.nm.mpnum, (mpfr_srcptr )p1, ROUND_MODE);
  }
#line 729
  if (do_ieee_fmt) {
    {
#line 729
    tmp___3 = format_ieee(res->sub.val.nm.mpnum, tval);
    }
#line 729
    if (tmp___3) {
#line 729
      tmp___4 = 1;
    } else {
#line 729
      tmp___4 = 0;
    }
  } else {
#line 729
    tmp___4 = 0;
  }
  {
#line 729
  DEREF(t1);
  }
#line 729
  return (res);
}
}
#line 734 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_log(int nargs ) 
{ 
  NODE *t1 ;
  NODE *res ;
  mpfr_ptr p1 ;
  int tval ;
  char *tmp___1 ;
  mpfr_ptr tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 737
  t1 = POP_SCALAR();
  }
#line 737
  if (do_flags & 3) {
#line 737
    if ((t1->flags & 24U) == 0U) {
      {
#line 737
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 737);
#line 737
      tmp___1 = gettext("%s: received non-numeric argument");
#line 737
      (*lintfunc)((char const   *)tmp___1, "log");
      }
    }
  }
  {
#line 737
  force_number(t1);
  }
#line 737
  if ((t1->flags & 4096U) != 0U) {
    {
#line 737
    tmp___2 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 737
    p1 = tmp___2;
    }
  } else {
#line 737
    p1 = t1->sub.val.nm.mpnum;
  }
  {
#line 737
  res = mpg_node(2048U);
#line 737
  tval = mpfr_log(res->sub.val.nm.mpnum, (mpfr_srcptr )p1, ROUND_MODE);
  }
#line 737
  if (do_ieee_fmt) {
    {
#line 737
    tmp___3 = format_ieee(res->sub.val.nm.mpnum, tval);
    }
#line 737
    if (tmp___3) {
#line 737
      tmp___4 = 1;
    } else {
#line 737
      tmp___4 = 0;
    }
  } else {
#line 737
    tmp___4 = 0;
  }
  {
#line 737
  DEREF(t1);
  }
#line 737
  return (res);
}
}
#line 742 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_sqrt(int nargs ) 
{ 
  NODE *t1 ;
  NODE *res ;
  mpfr_ptr p1 ;
  int tval ;
  char *tmp___1 ;
  mpfr_ptr tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 745
  t1 = POP_SCALAR();
  }
#line 745
  if (do_flags & 3) {
#line 745
    if ((t1->flags & 24U) == 0U) {
      {
#line 745
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 745);
#line 745
      tmp___1 = gettext("%s: received non-numeric argument");
#line 745
      (*lintfunc)((char const   *)tmp___1, "sqrt");
      }
    }
  }
  {
#line 745
  force_number(t1);
  }
#line 745
  if ((t1->flags & 4096U) != 0U) {
    {
#line 745
    tmp___2 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 745
    p1 = tmp___2;
    }
  } else {
#line 745
    p1 = t1->sub.val.nm.mpnum;
  }
  {
#line 745
  res = mpg_node(2048U);
#line 745
  tval = mpfr_sqrt(res->sub.val.nm.mpnum, (mpfr_srcptr )p1, ROUND_MODE);
  }
#line 745
  if (do_ieee_fmt) {
    {
#line 745
    tmp___3 = format_ieee(res->sub.val.nm.mpnum, tval);
    }
#line 745
    if (tmp___3) {
#line 745
      tmp___4 = 1;
    } else {
#line 745
      tmp___4 = 0;
    }
  } else {
#line 745
    tmp___4 = 0;
  }
  {
#line 745
  DEREF(t1);
  }
#line 745
  return (res);
}
}
#line 750 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_int(int nargs ) 
{ 
  NODE *tmp___1 ;
  NODE *r ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 755
  tmp___1 = POP_SCALAR();
  }
#line 756
  if (do_flags & 3) {
#line 756
    if ((tmp___1->flags & 24U) == 0U) {
      {
#line 757
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 757);
#line 757
      tmp___2 = gettext("int: received non-numeric argument");
#line 757
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 758
  force_number(tmp___1);
  }
#line 760
  if ((tmp___1->flags & 4096U) != 0U) {
    {
#line 761
    r = mpg_node(4096U);
#line 762
    __gmpz_set(r->sub.val.nm.mpi, (mpz_srcptr )(tmp___1->sub.val.nm.mpi));
    }
  } else {
    {
#line 764
    tmp___3 = mpfr_number_p((mpfr_srcptr )(tmp___1->sub.val.nm.mpnum));
    }
#line 764
    if (! tmp___3) {
#line 766
      return (tmp___1);
    }
    {
#line 769
    r = mpg_node(4096U);
#line 770
    mpfr_get_z(r->sub.val.nm.mpi, (mpfr_srcptr )(tmp___1->sub.val.nm.mpnum), (mpfr_rnd_t )1);
    }
  }
  {
#line 773
  DEREF(tmp___1);
  }
#line 774
  return (r);
}
}
#line 779 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_compl(int nargs ) 
{ 
  NODE *tmp___1 ;
  NODE *r ;
  mpz_ptr zptr ;
  char *tmp___2 ;
  mpfr_ptr p ;
  int tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 785
  tmp___1 = POP_SCALAR();
  }
#line 786
  if (do_flags & 3) {
#line 786
    if ((tmp___1->flags & 24U) == 0U) {
      {
#line 787
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 787);
#line 787
      tmp___2 = gettext("compl: received non-numeric argument");
#line 787
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 789
  force_number(tmp___1);
  }
#line 790
  if ((tmp___1->flags & 2048U) != 0U) {
    {
#line 791
    p = tmp___1->sub.val.nm.mpnum;
#line 793
    tmp___3 = mpfr_number_p((mpfr_srcptr )p);
    }
#line 793
    if (! tmp___3) {
#line 795
      return (tmp___1);
    }
#line 797
    if (do_flags & 3) {
#line 798
      if (p->_mpfr_exp < (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 3UL)) {
#line 798
        if (p->_mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 2UL)) {
          {
#line 798
          mpfr_set_erangeflag();
          }
        }
#line 798
        tmp___6 = 0;
      } else {
#line 798
        tmp___6 = p->_mpfr_sign;
      }
#line 798
      if (tmp___6 < 0) {
        {
#line 799
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 799);
#line 799
        tmp___4 = gettext("compl(%Rg): negative value will give strange results");
#line 799
        tmp___5 = mpg_fmt((char const   *)tmp___4, p);
#line 799
        (*lintfunc)("%s", tmp___5);
        }
      }
      {
#line 802
      tmp___9 = mpfr_integer_p((mpfr_srcptr )p);
      }
#line 802
      if (! tmp___9) {
        {
#line 803
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 803);
#line 803
        tmp___7 = gettext("comp(%Rg): fractional value will be truncated");
#line 803
        tmp___8 = mpg_fmt((char const   *)tmp___7, p);
#line 803
        (*lintfunc)("%s", tmp___8);
        }
      }
    }
    {
#line 808
    mpfr_get_z(mpzval, (mpfr_srcptr )p, (mpfr_rnd_t )1);
#line 809
    zptr = mpzval;
    }
  } else {
#line 812
    zptr = tmp___1->sub.val.nm.mpi;
#line 813
    if (do_flags & 3) {
#line 814
      if (zptr->_mp_size < 0) {
#line 814
        tmp___12 = -1;
      } else {
#line 814
        tmp___12 = zptr->_mp_size > 0;
      }
#line 814
      if (tmp___12 < 0) {
        {
#line 815
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 815);
#line 815
        tmp___10 = gettext("cmpl(%Zd): negative values will give strange results");
#line 815
        tmp___11 = mpg_fmt((char const   *)tmp___10, zptr);
#line 815
        (*lintfunc)("%s", tmp___11);
        }
      }
    }
  }
  {
#line 821
  r = mpg_node(4096U);
#line 822
  __gmpz_com(r->sub.val.nm.mpi, (mpz_srcptr )zptr);
#line 823
  DEREF(tmp___1);
  }
#line 824
  return (r);
}
}
#line 829 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static mpz_ptr get_intval(NODE *t1 , int argnum , char const   *op ) 
{ 
  mpz_ptr pz ;
  char *tmp___1 ;
  mpfr_ptr left ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
#line 834
  if (do_flags & 3) {
#line 834
    if ((t1->flags & 24U) == 0U) {
      {
#line 835
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 835);
#line 835
      tmp___1 = gettext("%s: received non-numeric argument #%d");
#line 835
      (*lintfunc)((char const   *)tmp___1, op, argnum);
      }
    }
  }
  {
#line 837
  force_number(t1);
  }
#line 839
  if ((t1->flags & 2048U) != 0U) {
    {
#line 840
    left = t1->sub.val.nm.mpnum;
#line 841
    tmp___9 = mpfr_number_p((mpfr_srcptr )left);
    }
#line 841
    if (! tmp___9) {
#line 843
      if (do_flags & 3) {
        {
#line 844
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 844);
#line 844
        tmp___2 = gettext("%s: argument #%d has invalid value %Rg, using 0");
#line 844
        tmp___3 = mpg_fmt((char const   *)tmp___2, op, argnum, left);
#line 844
        (*lintfunc)("%s", tmp___3);
        }
      }
      {
#line 849
      tmp___4 = malloc(sizeof(mpz_t ));
#line 849
      pz = (mpz_ptr )tmp___4;
      }
#line 849
      if (pz) {
#line 849
        tmp___8 = 1;
      } else {
        {
#line 849
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 849);
#line 849
        tmp___5 = __errno_location();
#line 849
        tmp___6 = strerror(*tmp___5);
#line 849
        tmp___7 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 849
        r_fatal((char const   *)tmp___7, "get_intval", "pz", (long )sizeof(mpz_t ),
                tmp___6);
#line 849
        tmp___8 = 0;
        }
      }
      {
#line 850
      __gmpz_init(pz);
      }
#line 851
      return (pz);
    }
#line 854
    if (do_flags & 3) {
#line 855
      if (left->_mpfr_exp < (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 3UL)) {
#line 855
        if (left->_mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 2UL)) {
          {
#line 855
          mpfr_set_erangeflag();
          }
        }
#line 855
        tmp___12 = 0;
      } else {
#line 855
        tmp___12 = left->_mpfr_sign;
      }
#line 855
      if (tmp___12 < 0) {
        {
#line 856
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 856);
#line 856
        tmp___10 = gettext("%s: argument #%d negative value %Rg will give strange results");
#line 856
        tmp___11 = mpg_fmt((char const   *)tmp___10, op, argnum, left);
#line 856
        (*lintfunc)("%s", tmp___11);
        }
      }
      {
#line 861
      tmp___15 = mpfr_integer_p((mpfr_srcptr )left);
      }
#line 861
      if (! tmp___15) {
        {
#line 862
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 862);
#line 862
        tmp___13 = gettext("%s: argument #%d fractional value %Rg will be truncated");
#line 862
        tmp___14 = mpg_fmt((char const   *)tmp___13, op, argnum, left);
#line 862
        (*lintfunc)("%s", tmp___14);
        }
      }
    }
    {
#line 868
    tmp___16 = malloc(sizeof(mpz_t ));
#line 868
    pz = (mpz_ptr )tmp___16;
    }
#line 868
    if (pz) {
#line 868
      tmp___20 = 1;
    } else {
      {
#line 868
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 868);
#line 868
      tmp___17 = __errno_location();
#line 868
      tmp___18 = strerror(*tmp___17);
#line 868
      tmp___19 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 868
      r_fatal((char const   *)tmp___19, "get_intval", "pz", (long )sizeof(mpz_t ),
              tmp___18);
#line 868
      tmp___20 = 0;
      }
    }
    {
#line 869
    __gmpz_init(pz);
#line 870
    mpfr_get_z(pz, (mpfr_srcptr )left, (mpfr_rnd_t )1);
    }
#line 871
    return (pz);
  }
#line 874
  pz = t1->sub.val.nm.mpi;
#line 875
  if (do_flags & 3) {
#line 876
    if (pz->_mp_size < 0) {
#line 876
      tmp___23 = -1;
    } else {
#line 876
      tmp___23 = pz->_mp_size > 0;
    }
#line 876
    if (tmp___23 < 0) {
      {
#line 877
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 877);
#line 877
      tmp___21 = gettext("%s: argument #%d negative value %Zd will give strange results");
#line 877
      tmp___22 = mpg_fmt((char const   *)tmp___21, op, argnum, pz);
#line 877
      (*lintfunc)("%s", tmp___22);
      }
    }
  }
#line 882
  return (pz);
}
}
#line 888 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
__inline static void free_intval(NODE *t , mpz_ptr pz ) 
{ 


  {
#line 891
  if ((t->flags & 4096U) == 0U) {
    {
#line 892
    __gmpz_clear(pz);
#line 893
    free((void *)pz);
    }
  }
#line 895
  return;
}
}
#line 900 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_lshift(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  NODE *res ;
  unsigned long shift ;
  mpz_ptr pz1 ;
  mpz_ptr pz2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 907
  t2 = POP_SCALAR();
#line 908
  t1 = POP_SCALAR();
#line 910
  pz1 = get_intval(t1, 1, "lshift");
#line 911
  pz2 = get_intval(t2, 2, "lshift");
#line 919
  shift = __gmpz_get_ui((mpz_srcptr )pz2);
#line 920
  res = mpg_node(4096U);
#line 921
  __gmpz_mul_2exp(res->sub.val.nm.mpi, (mpz_srcptr )pz1, shift);
#line 923
  free_intval(t1, pz1);
#line 924
  free_intval(t2, pz2);
#line 925
  DEREF(t2);
#line 926
  DEREF(t1);
  }
#line 927
  return (res);
}
}
#line 932 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_rshift(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  NODE *res ;
  unsigned long shift ;
  mpz_ptr pz1 ;
  mpz_ptr pz2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 939
  t2 = POP_SCALAR();
#line 940
  t1 = POP_SCALAR();
#line 942
  pz1 = get_intval(t1, 1, "rshift");
#line 943
  pz2 = get_intval(t2, 2, "rshift");
#line 946
  shift = __gmpz_get_ui((mpz_srcptr )pz2);
#line 947
  res = mpg_node(4096U);
#line 948
  __gmpz_fdiv_q_2exp(res->sub.val.nm.mpi, (mpz_srcptr )pz1, shift);
#line 950
  free_intval(t1, pz1);
#line 951
  free_intval(t2, pz2);
#line 952
  DEREF(t2);
#line 953
  DEREF(t1);
  }
#line 954
  return (res);
}
}
#line 960 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_and(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  NODE *res ;
  mpz_ptr pz1 ;
  mpz_ptr pz2 ;
  int i___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 967
  if (nargs < 2) {
    {
#line 968
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 968);
#line 968
    tmp___1 = gettext("and: called with less than two arguments");
#line 968
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 970
  t2 = POP_SCALAR();
#line 971
  pz2 = get_intval(t2, nargs, "and");
#line 973
  res = mpg_node(4096U);
#line 974
  i___0 = 1;
  }
  {
#line 974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 974
    if (! (i___0 < nargs)) {
#line 974
      goto while_break;
    }
    {
#line 975
    t1 = POP_SCALAR();
#line 976
    pz1 = get_intval(t1, nargs - i___0, "and");
#line 977
    __gmpz_and(res->sub.val.nm.mpi, (mpz_srcptr )pz1, (mpz_srcptr )pz2);
#line 978
    free_intval(t1, pz1);
#line 979
    DEREF(t1);
    }
#line 980
    if (i___0 == 1) {
      {
#line 981
      free_intval(t2, pz2);
#line 982
      DEREF(t2);
      }
    }
#line 984
    pz2 = res->sub.val.nm.mpi;
#line 974
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 986
  return (res);
}
}
#line 992 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_or(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  NODE *res ;
  mpz_ptr pz1 ;
  mpz_ptr pz2 ;
  int i___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 999
  if (nargs < 2) {
    {
#line 1000
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 1000);
#line 1000
    tmp___1 = gettext("or: called with less than two arguments");
#line 1000
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 1002
  t2 = POP_SCALAR();
#line 1003
  pz2 = get_intval(t2, nargs, "or");
#line 1005
  res = mpg_node(4096U);
#line 1006
  i___0 = 1;
  }
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    if (! (i___0 < nargs)) {
#line 1006
      goto while_break;
    }
    {
#line 1007
    t1 = POP_SCALAR();
#line 1008
    pz1 = get_intval(t1, nargs - i___0, "or");
#line 1009
    __gmpz_ior(res->sub.val.nm.mpi, (mpz_srcptr )pz1, (mpz_srcptr )pz2);
#line 1010
    free_intval(t1, pz1);
#line 1011
    DEREF(t1);
    }
#line 1012
    if (i___0 == 1) {
      {
#line 1013
      free_intval(t2, pz2);
#line 1014
      DEREF(t2);
      }
    }
#line 1016
    pz2 = res->sub.val.nm.mpi;
#line 1006
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1018
  return (res);
}
}
#line 1023 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_xor(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  NODE *res ;
  mpz_ptr pz1 ;
  mpz_ptr pz2 ;
  int i___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1030
  if (nargs < 2) {
    {
#line 1031
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 1031);
#line 1031
    tmp___1 = gettext("xor: called with less than two arguments");
#line 1031
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 1033
  t2 = POP_SCALAR();
#line 1034
  pz2 = get_intval(t2, nargs, "xor");
#line 1036
  res = mpg_node(4096U);
#line 1037
  i___0 = 1;
  }
  {
#line 1037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1037
    if (! (i___0 < nargs)) {
#line 1037
      goto while_break;
    }
    {
#line 1038
    t1 = POP_SCALAR();
#line 1039
    pz1 = get_intval(t1, nargs - i___0, "xor");
#line 1040
    __gmpz_xor(res->sub.val.nm.mpi, (mpz_srcptr )pz1, (mpz_srcptr )pz2);
#line 1041
    free_intval(t1, pz1);
#line 1042
    DEREF(t1);
    }
#line 1043
    if (i___0 == 1) {
      {
#line 1044
      free_intval(t2, pz2);
#line 1045
      DEREF(t2);
      }
    }
#line 1047
    pz2 = res->sub.val.nm.mpi;
#line 1037
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  return (res);
}
}
#line 1054 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_strtonum(int nargs ) 
{ 
  NODE *tmp___1 ;
  NODE *r ;
  int tval ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1059
  tmp___1 = POP_SCALAR();
  }
#line 1060
  if ((tmp___1->flags & 24U) == 0U) {
    {
#line 1061
    r = mpg_node(4096U);
#line 1062
    r->sub.val.sp = tmp___1->sub.val.sp;
#line 1063
    r->sub.val.slen = tmp___1->sub.val.slen;
#line 1064
    force_mpnum(r, 1, use_lc_numeric);
#line 1065
    r->sub.val.sp = (char *)((void *)0);
#line 1066
    r->sub.val.slen = (size_t )0;
    }
  } else {
    {
#line 1068
    force_number(tmp___1);
    }
#line 1069
    if ((tmp___1->flags & 2048U) != 0U) {
      {
#line 1071
      r = mpg_node(2048U);
#line 1072
      tval = mpfr_set4(r->sub.val.nm.mpnum, (mpfr_srcptr )(tmp___1->sub.val.nm.mpnum),
                       ROUND_MODE, tmp___1->sub.val.nm.mpnum[0]._mpfr_sign);
      }
#line 1073
      if (do_ieee_fmt) {
        {
#line 1073
        tmp___2 = format_ieee(r->sub.val.nm.mpnum, tval);
        }
#line 1073
        if (tmp___2) {
#line 1073
          tmp___3 = 1;
        } else {
#line 1073
          tmp___3 = 0;
        }
      } else {
#line 1073
        tmp___3 = 0;
      }
    } else {
      {
#line 1075
      r = mpg_node(4096U);
#line 1076
      __gmpz_set(r->sub.val.nm.mpi, (mpz_srcptr )(tmp___1->sub.val.nm.mpi));
      }
    }
  }
  {
#line 1080
  DEREF(tmp___1);
  }
#line 1081
  return (r);
}
}
#line 1085 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static _Bool firstrand  =    (_Bool)1;
#line 1086 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static gmp_randstate_t state___0  ;
#line 1087 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static mpz_t seed  ;
#line 1091 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_rand(int nargs  __attribute__((__unused__)) ) 
{ 
  NODE *res ;
  int tval ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1097
  if (firstrand) {
    {
#line 1107
    __gmp_randinit_mt((__gmp_randstate_struct *)(state___0));
#line 1109
    __gmpz_init(seed);
#line 1110
    __gmpz_set_ui(seed, 1UL);
#line 1112
    __gmp_randseed((__gmp_randstate_struct *)(state___0), (mpz_srcptr )(seed));
#line 1113
    firstrand = (_Bool)0;
    }
  }
  {
#line 1115
  res = mpg_node(2048U);
#line 1116
  tval = mpfr_urandomb(res->sub.val.nm.mpnum, (__gmp_randstate_struct *)(state___0));
  }
#line 1117
  if (do_ieee_fmt) {
    {
#line 1117
    tmp___1 = format_ieee(res->sub.val.nm.mpnum, tval);
    }
#line 1117
    if (tmp___1) {
#line 1117
      tmp___2 = 1;
    } else {
#line 1117
      tmp___2 = 0;
    }
  } else {
#line 1117
    tmp___2 = 0;
  }
#line 1118
  return (res);
}
}
#line 1124 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
NODE *do_mpfr_srand(int nargs ) 
{ 
  NODE *res ;
  time_t tmp___1 ;
  NODE *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1129
  if (firstrand) {
    {
#line 1139
    __gmp_randinit_mt((__gmp_randstate_struct *)(state___0));
#line 1141
    __gmpz_init(seed);
#line 1142
    __gmpz_set_ui(seed, 1UL);
#line 1144
    firstrand = (_Bool)0;
    }
  }
  {
#line 1147
  res = mpg_node(4096U);
#line 1148
  __gmpz_set(res->sub.val.nm.mpi, (mpz_srcptr )(seed));
  }
#line 1150
  if (nargs == 0) {
    {
#line 1151
    tmp___1 = time((time_t *)0);
#line 1151
    __gmpz_set_ui(seed, (unsigned long )tmp___1);
    }
  } else {
    {
#line 1154
    tmp___2 = POP_SCALAR();
    }
#line 1155
    if (do_flags & 3) {
#line 1155
      if ((tmp___2->flags & 24U) == 0U) {
        {
#line 1156
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c", 1156);
#line 1156
        tmp___3 = gettext("srand: received non-numeric argument");
#line 1156
        (*lintfunc)((char const   *)tmp___3);
        }
      }
    }
    {
#line 1157
    force_number(tmp___2);
    }
#line 1158
    if ((tmp___2->flags & 2048U) != 0U) {
      {
#line 1159
      mpfr_get_z(seed, (mpfr_srcptr )(tmp___2->sub.val.nm.mpnum), (mpfr_rnd_t )1);
      }
    } else {
      {
#line 1161
      __gmpz_set(seed, (mpz_srcptr )(tmp___2->sub.val.nm.mpi));
      }
    }
    {
#line 1162
    DEREF(tmp___2);
    }
  }
  {
#line 1165
  __gmp_randseed((__gmp_randstate_struct *)(state___0), (mpz_srcptr )(seed));
  }
#line 1166
  return (res);
}
}
#line 1175 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
__inline static mpfr_ptr mpg_tofloat(mpfr_ptr mf , mpz_ptr mz ) 
{ 
  size_t prec ;
  unsigned long tmp___1 ;

  {
  {
#line 1192
  prec = __gmpz_sizeinbase((mpz_srcptr )mz, 2);
  }
#line 1193
  if (prec > 64UL) {
    {
#line 1194
    tmp___1 = __gmpz_scan1((mpz_srcptr )mz, 0UL);
#line 1194
    prec -= tmp___1;
    }
#line 1195
    if (prec > 0xffffffffffffffffUL >> 1) {
#line 1196
      prec = 0xffffffffffffffffUL >> 1;
    }
#line 1197
    if (prec > 64UL) {
      {
#line 1198
      mpfr_set_prec(mf, prec);
      }
    }
  }
  {
#line 1201
  mpfr_set_z(mf, (mpz_srcptr )mz, ROUND_MODE);
  }
#line 1202
  return (mf);
}
}
#line 1208 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static NODE *mpg_add(NODE *t1 , NODE *t2 ) 
{ 
  NODE *r ;
  int tval ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1214
  if ((t1->flags & 4096U) != 0U) {
#line 1214
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1215
      r = mpg_node(4096U);
#line 1216
      __gmpz_add(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), (mpz_srcptr )(t2->sub.val.nm.mpi));
      }
    } else {
#line 1214
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1218
    r = mpg_node(2048U);
    }
#line 1219
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1220
      tval = mpfr_add_z(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum),
                        (mpz_srcptr )(t2->sub.val.nm.mpi), ROUND_MODE);
      }
    } else
#line 1221
    if ((t1->flags & 4096U) != 0U) {
      {
#line 1222
      tval = mpfr_add_z(r->sub.val.nm.mpnum, (mpfr_srcptr )(t2->sub.val.nm.mpnum),
                        (mpz_srcptr )(t1->sub.val.nm.mpi), ROUND_MODE);
      }
    } else {
      {
#line 1224
      tval = mpfr_add(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum), (mpfr_srcptr )(t2->sub.val.nm.mpnum),
                      ROUND_MODE);
      }
    }
#line 1225
    if (do_ieee_fmt) {
      {
#line 1225
      tmp___1 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 1225
      if (tmp___1) {
#line 1225
        tmp___2 = 1;
      } else {
#line 1225
        tmp___2 = 0;
      }
    } else {
#line 1225
      tmp___2 = 0;
    }
  }
#line 1227
  return (r);
}
}
#line 1232 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static NODE *mpg_sub(NODE *t1 , NODE *t2 ) 
{ 
  NODE *r ;
  int tval ;
  NODE *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1238
  if ((t1->flags & 4096U) != 0U) {
#line 1238
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1239
      r = mpg_node(4096U);
#line 1240
      __gmpz_sub(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), (mpz_srcptr )(t2->sub.val.nm.mpi));
      }
    } else {
#line 1238
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1242
    r = mpg_node(2048U);
    }
#line 1243
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1244
      tval = mpfr_sub_z(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum),
                        (mpz_srcptr )(t2->sub.val.nm.mpi), ROUND_MODE);
      }
    } else
#line 1245
    if ((t1->flags & 4096U) != 0U) {
      {
#line 1247
      tmp___1 = t1;
#line 1248
      t1 = t2;
#line 1249
      t2 = tmp___1;
#line 1250
      tval = mpfr_sub_z(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum),
                        (mpz_srcptr )(t2->sub.val.nm.mpi), ROUND_MODE);
#line 1251
      tval = mpfr_neg(r->sub.val.nm.mpnum, (mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 1252
      t2 = t1;
#line 1253
      t1 = tmp___1;
      }
    } else {
      {
#line 1258
      tval = mpfr_sub(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum), (mpfr_srcptr )(t2->sub.val.nm.mpnum),
                      ROUND_MODE);
      }
    }
#line 1259
    if (do_ieee_fmt) {
      {
#line 1259
      tmp___2 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 1259
      if (tmp___2) {
#line 1259
        tmp___3 = 1;
      } else {
#line 1259
        tmp___3 = 0;
      }
    } else {
#line 1259
      tmp___3 = 0;
    }
  }
#line 1261
  return (r);
}
}
#line 1266 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static NODE *mpg_mul(NODE *t1 , NODE *t2 ) 
{ 
  NODE *r ;
  int tval ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1272
  if ((t1->flags & 4096U) != 0U) {
#line 1272
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1273
      r = mpg_node(4096U);
#line 1274
      __gmpz_mul(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), (mpz_srcptr )(t2->sub.val.nm.mpi));
      }
    } else {
#line 1272
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1276
    r = mpg_node(2048U);
    }
#line 1277
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1278
      tval = mpfr_mul_z(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum),
                        (mpz_srcptr )(t2->sub.val.nm.mpi), ROUND_MODE);
      }
    } else
#line 1279
    if ((t1->flags & 4096U) != 0U) {
      {
#line 1280
      tval = mpfr_mul_z(r->sub.val.nm.mpnum, (mpfr_srcptr )(t2->sub.val.nm.mpnum),
                        (mpz_srcptr )(t1->sub.val.nm.mpi), ROUND_MODE);
      }
    } else {
      {
#line 1282
      tval = mpfr_mul(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum), (mpfr_srcptr )(t2->sub.val.nm.mpnum),
                      ROUND_MODE);
      }
    }
#line 1283
    if (do_ieee_fmt) {
      {
#line 1283
      tmp___1 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 1283
      if (tmp___1) {
#line 1283
        tmp___2 = 1;
      } else {
#line 1283
        tmp___2 = 0;
      }
    } else {
#line 1283
      tmp___2 = 0;
    }
  }
#line 1285
  return (r);
}
}
#line 1291 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static NODE *mpg_pow(NODE *t1 , NODE *t2 ) 
{ 
  NODE *r ;
  int tval ;
  unsigned long tmp___1 ;
  mpfr_ptr p1 ;
  mpfr_ptr p2 ;
  mpfr_ptr tmp___2 ;
  mpfr_ptr tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  mpfr_ptr p1___0 ;
  mpfr_ptr tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1297
  if ((t1->flags & 4096U) != 0U) {
#line 1297
    if ((t2->flags & 4096U) != 0U) {
#line 1298
      if (t2->sub.val.nm.mpi[0]._mp_size < 0) {
#line 1298
        tmp___6 = -1;
      } else {
#line 1298
        tmp___6 = t2->sub.val.nm.mpi[0]._mp_size > 0;
      }
#line 1298
      if (tmp___6 >= 0) {
        {
#line 1298
        tmp___7 = __gmpz_fits_ulong_p((mpz_srcptr )(t2->sub.val.nm.mpi));
        }
#line 1298
        if (tmp___7) {
          {
#line 1299
          r = mpg_node(4096U);
#line 1300
          tmp___1 = __gmpz_get_ui((mpz_srcptr )(t2->sub.val.nm.mpi));
#line 1300
          __gmpz_pow_ui(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), tmp___1);
          }
        } else {
#line 1298
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1303
        if ((t1->flags & 4096U) != 0U) {
          {
#line 1303
          tmp___2 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 1303
          p1 = tmp___2;
          }
        } else {
#line 1303
          p1 = t1->sub.val.nm.mpnum;
        }
#line 1304
        if ((t2->flags & 4096U) != 0U) {
          {
#line 1304
          tmp___3 = mpg_tofloat(_mpf_t2, t2->sub.val.nm.mpi);
#line 1304
          p2 = tmp___3;
          }
        } else {
#line 1304
          p2 = t2->sub.val.nm.mpnum;
        }
        {
#line 1305
        r = mpg_node(2048U);
#line 1306
        tval = mpfr_pow(r->sub.val.nm.mpnum, (mpfr_srcptr )p1, (mpfr_srcptr )p2, ROUND_MODE);
        }
#line 1307
        if (do_ieee_fmt) {
          {
#line 1307
          tmp___4 = format_ieee(r->sub.val.nm.mpnum, tval);
          }
#line 1307
          if (tmp___4) {
#line 1307
            tmp___5 = 1;
          } else {
#line 1307
            tmp___5 = 0;
          }
        } else {
#line 1307
          tmp___5 = 0;
        }
      }
    } else {
#line 1297
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 1310
    r = mpg_node(2048U);
    }
#line 1311
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1312
      tval = mpfr_pow_z(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum),
                        (mpz_srcptr )(t2->sub.val.nm.mpi), ROUND_MODE);
      }
    } else {
#line 1315
      if ((t1->flags & 4096U) != 0U) {
        {
#line 1315
        tmp___8 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 1315
        p1___0 = tmp___8;
        }
      } else {
#line 1315
        p1___0 = t1->sub.val.nm.mpnum;
      }
      {
#line 1316
      tval = mpfr_pow(r->sub.val.nm.mpnum, (mpfr_srcptr )p1___0, (mpfr_srcptr )(t2->sub.val.nm.mpnum),
                      ROUND_MODE);
      }
    }
#line 1318
    if (do_ieee_fmt) {
      {
#line 1318
      tmp___9 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 1318
      if (tmp___9) {
#line 1318
        tmp___10 = 1;
      } else {
#line 1318
        tmp___10 = 0;
      }
    } else {
#line 1318
      tmp___10 = 0;
    }
  }
#line 1320
  return (r);
}
}
#line 1325 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static NODE *mpg_div(NODE *t1 , NODE *t2 ) 
{ 
  NODE *r ;
  int tval ;
  mpfr_ptr p1 ;
  mpfr_ptr p2 ;
  mpfr_ptr tmp___1 ;
  mpfr_ptr tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1331
  if ((t1->flags & 4096U) != 0U) {
#line 1331
    if ((t2->flags & 4096U) != 0U) {
#line 1331
      if (t2->sub.val.nm.mpi[0]._mp_size < 0) {
#line 1331
        tmp___5 = -1;
      } else {
#line 1331
        tmp___5 = t2->sub.val.nm.mpi[0]._mp_size > 0;
      }
#line 1331
      if (tmp___5 != 0) {
        {
#line 1331
        tmp___6 = __gmpz_divisible_p((mpz_srcptr )(t1->sub.val.nm.mpi), (mpz_srcptr )(t2->sub.val.nm.mpi));
        }
#line 1331
        if (tmp___6) {
          {
#line 1335
          r = mpg_node(4096U);
#line 1336
          __gmpz_divexact(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), (mpz_srcptr )(t2->sub.val.nm.mpi));
          }
        } else {
#line 1331
          goto _L___1;
        }
      } else {
#line 1331
        goto _L___1;
      }
    } else {
#line 1331
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1339
    if ((t1->flags & 4096U) != 0U) {
      {
#line 1339
      tmp___1 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 1339
      p1 = tmp___1;
      }
    } else {
#line 1339
      p1 = t1->sub.val.nm.mpnum;
    }
#line 1340
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1340
      tmp___2 = mpg_tofloat(_mpf_t2, t2->sub.val.nm.mpi);
#line 1340
      p2 = tmp___2;
      }
    } else {
#line 1340
      p2 = t2->sub.val.nm.mpnum;
    }
    {
#line 1341
    r = mpg_node(2048U);
#line 1342
    tval = mpfr_div(r->sub.val.nm.mpnum, (mpfr_srcptr )p1, (mpfr_srcptr )p2, ROUND_MODE);
    }
#line 1343
    if (do_ieee_fmt) {
      {
#line 1343
      tmp___3 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 1343
      if (tmp___3) {
#line 1343
        tmp___4 = 1;
      } else {
#line 1343
        tmp___4 = 0;
      }
    } else {
#line 1343
      tmp___4 = 0;
    }
  }
#line 1345
  return (r);
}
}
#line 1350 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static NODE *mpg_mod(NODE *t1 , NODE *t2 ) 
{ 
  NODE *r ;
  int tval ;
  mpfr_ptr p1 ;
  mpfr_ptr p2 ;
  mpfr_ptr tmp___1 ;
  mpfr_ptr tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1356
  if ((t1->flags & 4096U) != 0U) {
#line 1356
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1357
      r = mpg_node(4096U);
#line 1358
      __gmpz_mod(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), (mpz_srcptr )(t2->sub.val.nm.mpi));
      }
    } else {
#line 1356
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1361
    if ((t1->flags & 4096U) != 0U) {
      {
#line 1361
      tmp___1 = mpg_tofloat(_mpf_t1, t1->sub.val.nm.mpi);
#line 1361
      p1 = tmp___1;
      }
    } else {
#line 1361
      p1 = t1->sub.val.nm.mpnum;
    }
#line 1362
    if ((t2->flags & 4096U) != 0U) {
      {
#line 1362
      tmp___2 = mpg_tofloat(_mpf_t2, t2->sub.val.nm.mpi);
#line 1362
      p2 = tmp___2;
      }
    } else {
#line 1362
      p2 = t2->sub.val.nm.mpnum;
    }
    {
#line 1363
    r = mpg_node(2048U);
#line 1364
    tval = mpfr_fmod(r->sub.val.nm.mpnum, (mpfr_srcptr )p1, (mpfr_srcptr )p2, ROUND_MODE);
    }
#line 1365
    if (do_ieee_fmt) {
      {
#line 1365
      tmp___3 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 1365
      if (tmp___3) {
#line 1365
        tmp___4 = 1;
      } else {
#line 1365
        tmp___4 = 0;
      }
    } else {
#line 1365
      tmp___4 = 0;
    }
  }
#line 1367
  return (r);
}
}
#line 1375 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static int mpg_interpret(INSTRUCTION **cp ) 
{ 
  INSTRUCTION *pc ;
  OPCODE op ;
  NODE *r ;
  NODE *t1 ;
  NODE *t2 ;
  NODE **lhs ;
  int tval ;
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  NODE *tmp___5 ;
  NODE *tmp___6 ;
  NODE *tmp___7 ;
  NODE *tmp___8 ;
  NODE *tmp___9 ;
  NODE *tmp___10 ;
  NODE *tmp___11 ;
  NODE *tmp___12 ;
  NODE *tmp___13 ;
  NODE *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  NODE *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  NODE *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  NODE *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  STACK_ITEM *tmp___28 ;
  NODE *tmp___29 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 1378
  pc = *cp;
#line 1380
  r = (NODE *)((void *)0);
#line 1385
  op = pc->opcode;
  {
#line 1386
  if ((unsigned int )op == 8U) {
#line 1386
    goto case_8;
  }
#line 1389
  if ((unsigned int )op == 7U) {
#line 1389
    goto case_7;
  }
#line 1400
  if ((unsigned int )op == 10U) {
#line 1400
    goto case_10;
  }
#line 1403
  if ((unsigned int )op == 9U) {
#line 1403
    goto case_9;
  }
#line 1414
  if ((unsigned int )op == 2U) {
#line 1414
    goto case_2;
  }
#line 1417
  if ((unsigned int )op == 1U) {
#line 1417
    goto case_1;
  }
#line 1428
  if ((unsigned int )op == 12U) {
#line 1428
    goto case_12;
  }
#line 1431
  if ((unsigned int )op == 11U) {
#line 1431
    goto case_11;
  }
#line 1442
  if ((unsigned int )op == 4U) {
#line 1442
    goto case_4;
  }
#line 1445
  if ((unsigned int )op == 3U) {
#line 1445
    goto case_3;
  }
#line 1456
  if ((unsigned int )op == 6U) {
#line 1456
    goto case_6;
  }
#line 1459
  if ((unsigned int )op == 5U) {
#line 1459
    goto case_5;
  }
#line 1471
  if ((unsigned int )op == 19U) {
#line 1471
    goto case_19;
  }
#line 1471
  if ((unsigned int )op == 18U) {
#line 1471
    goto case_19;
  }
#line 1508
  if ((unsigned int )op == 21U) {
#line 1508
    goto case_21;
  }
#line 1508
  if ((unsigned int )op == 20U) {
#line 1508
    goto case_21;
  }
#line 1540
  if ((unsigned int )op == 22U) {
#line 1540
    goto case_22;
  }
#line 1559
  if ((unsigned int )op == 34U) {
#line 1559
    goto case_34;
  }
#line 1559
  if ((unsigned int )op == 31U) {
#line 1559
    goto case_34;
  }
#line 1559
  if ((unsigned int )op == 30U) {
#line 1559
    goto case_34;
  }
#line 1559
  if ((unsigned int )op == 29U) {
#line 1559
    goto case_34;
  }
#line 1559
  if ((unsigned int )op == 33U) {
#line 1559
    goto case_34;
  }
#line 1559
  if ((unsigned int )op == 32U) {
#line 1559
    goto case_34;
  }
#line 1595
  goto switch_default___0;
  case_8: /* CIL Label */ 
  {
#line 1387
  t2 = force_number(pc->d.dn);
  }
#line 1388
  goto plus;
  case_7: /* CIL Label */ 
  {
#line 1390
  tmp___1 = POP_SCALAR();
#line 1390
  t2 = force_number(tmp___1);
  }
  plus: 
  {
#line 1392
  tmp___2 = TOP_SCALAR();
#line 1392
  t1 = force_number(tmp___2);
#line 1393
  r = mpg_add(t1, t2);
#line 1394
  DEREF(t1);
  }
#line 1395
  if ((unsigned int )op == 7U) {
    {
#line 1396
    DEREF(t2);
    }
  }
#line 1397
  stack_ptr->rptr = r;
#line 1398
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1401
  t2 = force_number(pc->d.dn);
  }
#line 1402
  goto minus;
  case_9: /* CIL Label */ 
  {
#line 1404
  tmp___3 = POP_SCALAR();
#line 1404
  t2 = force_number(tmp___3);
  }
  minus: 
  {
#line 1406
  tmp___4 = TOP_SCALAR();
#line 1406
  t1 = force_number(tmp___4);
#line 1407
  r = mpg_sub(t1, t2);
#line 1408
  DEREF(t1);
  }
#line 1409
  if ((unsigned int )op == 9U) {
    {
#line 1410
    DEREF(t2);
    }
  }
#line 1411
  stack_ptr->rptr = r;
#line 1412
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1415
  t2 = force_number(pc->d.dn);
  }
#line 1416
  goto times;
  case_1: /* CIL Label */ 
  {
#line 1418
  tmp___5 = POP_SCALAR();
#line 1418
  t2 = force_number(tmp___5);
  }
  times: 
  {
#line 1420
  tmp___6 = TOP_SCALAR();
#line 1420
  t1 = force_number(tmp___6);
#line 1421
  r = mpg_mul(t1, t2);
#line 1422
  DEREF(t1);
  }
#line 1423
  if ((unsigned int )op == 1U) {
    {
#line 1424
    DEREF(t2);
    }
  }
#line 1425
  stack_ptr->rptr = r;
#line 1426
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1429
  t2 = force_number(pc->d.dn);
  }
#line 1430
  goto exp;
  case_11: /* CIL Label */ 
  {
#line 1432
  tmp___7 = POP_SCALAR();
#line 1432
  t2 = force_number(tmp___7);
  }
  exp: 
  {
#line 1434
  tmp___8 = TOP_SCALAR();
#line 1434
  t1 = force_number(tmp___8);
#line 1435
  r = mpg_pow(t1, t2);
#line 1436
  DEREF(t1);
  }
#line 1437
  if ((unsigned int )op == 11U) {
    {
#line 1438
    DEREF(t2);
    }
  }
#line 1439
  stack_ptr->rptr = r;
#line 1440
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1443
  t2 = force_number(pc->d.dn);
  }
#line 1444
  goto quotient;
  case_3: /* CIL Label */ 
  {
#line 1446
  tmp___9 = POP_SCALAR();
#line 1446
  t2 = force_number(tmp___9);
  }
  quotient: 
  {
#line 1448
  tmp___10 = TOP_SCALAR();
#line 1448
  t1 = force_number(tmp___10);
#line 1449
  r = mpg_div(t1, t2);
#line 1450
  DEREF(t1);
  }
#line 1451
  if ((unsigned int )op == 3U) {
    {
#line 1452
    DEREF(t2);
    }
  }
#line 1453
  stack_ptr->rptr = r;
#line 1454
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1457
  t2 = force_number(pc->d.dn);
  }
#line 1458
  goto mod;
  case_5: /* CIL Label */ 
  {
#line 1460
  tmp___11 = POP_SCALAR();
#line 1460
  t2 = force_number(tmp___11);
  }
  mod: 
  {
#line 1462
  tmp___12 = TOP_SCALAR();
#line 1462
  t1 = force_number(tmp___12);
#line 1463
  r = mpg_mod(t1, t2);
#line 1464
  DEREF(t1);
  }
#line 1465
  if ((unsigned int )op == 5U) {
    {
#line 1466
    DEREF(t2);
    }
  }
#line 1467
  stack_ptr->rptr = r;
#line 1468
  goto switch_break;
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  {
#line 1472
  lhs = stack_ptr->lptr;
#line 1473
  t1 = *lhs;
#line 1474
  force_number(t1);
  }
#line 1476
  if ((t1->flags & 4096U) != 0U) {
#line 1477
    if (t1->sub.val.sref == 1L) {
#line 1477
      if (t1->flags == 4121U) {
#line 1479
        r = t1;
      } else {
        {
#line 1481
        tmp___13 = mpg_node(4096U);
#line 1481
        *lhs = tmp___13;
#line 1481
        r = tmp___13;
        }
      }
    } else {
      {
#line 1481
      tmp___13 = mpg_node(4096U);
#line 1481
      *lhs = tmp___13;
#line 1481
      r = tmp___13;
      }
    }
#line 1482
    if ((unsigned int )op == 18U) {
      {
#line 1483
      __gmpz_add_ui(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), 1UL);
      }
    } else {
      {
#line 1485
      __gmpz_sub_ui(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), 1UL);
      }
    }
  } else {
    {
#line 1495
    tmp___14 = mpg_node(2048U);
#line 1495
    *lhs = tmp___14;
#line 1495
    r = tmp___14;
    }
#line 1496
    if ((unsigned int )op == 18U) {
#line 1496
      tmp___15 = 1;
    } else {
#line 1496
      tmp___15 = -1;
    }
    {
#line 1496
    tval = mpfr_add_si(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum),
                       (long )tmp___15, ROUND_MODE);
    }
#line 1499
    if (do_ieee_fmt) {
      {
#line 1499
      tmp___16 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 1499
      if (tmp___16) {
#line 1499
        tmp___17 = 1;
      } else {
#line 1499
        tmp___17 = 0;
      }
    } else {
#line 1499
      tmp___17 = 0;
    }
  }
#line 1501
  if ((unsigned long )r != (unsigned long )t1) {
    {
#line 1502
    unref(t1);
    }
  }
#line 1503
  (r->sub.val.sref) ++;
#line 1504
  stack_ptr->rptr = r;
#line 1505
  goto switch_break;
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
#line 1509
  lhs = stack_ptr->lptr;
#line 1510
  t1 = *lhs;
#line 1511
  force_number(t1);
  }
#line 1513
  if ((t1->flags & 4096U) != 0U) {
    {
#line 1514
    r = mpg_node(4096U);
#line 1515
    __gmpz_set(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi));
    }
#line 1516
    if (t1->sub.val.sref == 1L) {
#line 1516
      if (t1->flags == 4121U) {
#line 1518
        t2 = t1;
      } else {
        {
#line 1520
        tmp___18 = mpg_node(4096U);
#line 1520
        *lhs = tmp___18;
#line 1520
        t2 = tmp___18;
        }
      }
    } else {
      {
#line 1520
      tmp___18 = mpg_node(4096U);
#line 1520
      *lhs = tmp___18;
#line 1520
      t2 = tmp___18;
      }
    }
#line 1521
    if ((unsigned int )op == 20U) {
      {
#line 1522
      __gmpz_add_ui(t2->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), 1UL);
      }
    } else {
      {
#line 1524
      __gmpz_sub_ui(t2->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi), 1UL);
      }
    }
  } else {
    {
#line 1526
    r = mpg_node(2048U);
#line 1527
    tval = mpfr_set4(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum), ROUND_MODE,
                     t1->sub.val.nm.mpnum[0]._mpfr_sign);
    }
#line 1528
    if (do_ieee_fmt) {
      {
#line 1528
      tmp___19 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 1528
      if (tmp___19) {
#line 1528
        tmp___20 = 1;
      } else {
#line 1528
        tmp___20 = 0;
      }
    } else {
#line 1528
      tmp___20 = 0;
    }
    {
#line 1529
    tmp___21 = mpg_node(2048U);
#line 1529
    *lhs = tmp___21;
#line 1529
    t2 = tmp___21;
    }
#line 1530
    if ((unsigned int )op == 20U) {
#line 1530
      tmp___22 = 1;
    } else {
#line 1530
      tmp___22 = -1;
    }
    {
#line 1530
    tval = mpfr_add_si(t2->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum),
                       (long )tmp___22, ROUND_MODE);
    }
#line 1533
    if (do_ieee_fmt) {
      {
#line 1533
      tmp___23 = format_ieee(t2->sub.val.nm.mpnum, tval);
      }
#line 1533
      if (tmp___23) {
#line 1533
        tmp___24 = 1;
      } else {
#line 1533
        tmp___24 = 0;
      }
    } else {
#line 1533
      tmp___24 = 0;
    }
  }
#line 1535
  if ((unsigned long )t2 != (unsigned long )t1) {
    {
#line 1536
    unref(t1);
    }
  }
#line 1537
  stack_ptr->rptr = r;
#line 1538
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 1541
  tmp___25 = TOP_SCALAR();
#line 1541
  t1 = force_number(tmp___25);
  }
#line 1542
  if ((t1->flags & 2048U) != 0U) {
    {
#line 1543
    r = mpg_node(2048U);
#line 1544
    tval = mpfr_neg(r->sub.val.nm.mpnum, (mpfr_srcptr )(t1->sub.val.nm.mpnum), ROUND_MODE);
    }
#line 1545
    if (do_ieee_fmt) {
      {
#line 1545
      tmp___26 = format_ieee(r->sub.val.nm.mpnum, tval);
      }
#line 1545
      if (tmp___26) {
#line 1545
        tmp___27 = 1;
      } else {
#line 1545
        tmp___27 = 0;
      }
    } else {
#line 1545
      tmp___27 = 0;
    }
  } else {
    {
#line 1547
    r = mpg_node(4096U);
#line 1548
    __gmpz_neg(r->sub.val.nm.mpi, (mpz_srcptr )(t1->sub.val.nm.mpi));
    }
  }
  {
#line 1550
  DEREF(t1);
#line 1551
  stack_ptr->rptr = r;
  }
#line 1552
  goto switch_break;
  case_34: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 1560
  tmp___28 = stack_ptr;
#line 1560
  stack_ptr --;
#line 1560
  lhs = tmp___28->lptr;
#line 1561
  t1 = *lhs;
#line 1562
  force_number(t1);
#line 1563
  tmp___29 = TOP_SCALAR();
#line 1563
  t2 = force_number(tmp___29);
  }
  {
#line 1566
  if ((unsigned int )op == 32U) {
#line 1566
    goto case_32___0;
  }
#line 1569
  if ((unsigned int )op == 33U) {
#line 1569
    goto case_33___0;
  }
#line 1572
  if ((unsigned int )op == 29U) {
#line 1572
    goto case_29___0;
  }
#line 1575
  if ((unsigned int )op == 30U) {
#line 1575
    goto case_30___0;
  }
#line 1578
  if ((unsigned int )op == 31U) {
#line 1578
    goto case_31___0;
  }
#line 1581
  if ((unsigned int )op == 34U) {
#line 1581
    goto case_34___0;
  }
#line 1584
  goto switch_default;
  case_32___0: /* CIL Label */ 
  {
#line 1567
  r = mpg_add(t1, t2);
  }
#line 1568
  goto switch_break___0;
  case_33___0: /* CIL Label */ 
  {
#line 1570
  r = mpg_sub(t1, t2);
  }
#line 1571
  goto switch_break___0;
  case_29___0: /* CIL Label */ 
  {
#line 1573
  r = mpg_mul(t1, t2);
  }
#line 1574
  goto switch_break___0;
  case_30___0: /* CIL Label */ 
  {
#line 1576
  r = mpg_div(t1, t2);
  }
#line 1577
  goto switch_break___0;
  case_31___0: /* CIL Label */ 
  {
#line 1579
  r = mpg_mod(t1, t2);
  }
#line 1580
  goto switch_break___0;
  case_34___0: /* CIL Label */ 
  {
#line 1582
  r = mpg_pow(t1, t2);
  }
#line 1583
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 1585
  r_fatal("internal error line %d, file: %s", 1585, "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c");
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1588
  DEREF(t2);
#line 1589
  unref(*lhs);
#line 1590
  *lhs = r;
#line 1591
  (r->sub.val.sref) ++;
#line 1592
  stack_ptr->rptr = r;
  }
#line 1593
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 1596
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 1599
  *cp = pc->nexti;
#line 1600
  return (0);
}
}
#line 1609 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
static char *tmp  =    (char *)((void *)0);
#line 1606 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
char const   *mpg_fmt(char const   *mesg  , ...) 
{ 
  int ret ;
  va_list args ;

  {
#line 1613
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    {
#line 1614
    mpfr_free_str(tmp);
#line 1615
    tmp = (char *)((void *)0);
    }
  }
  {
#line 1617
  __builtin_va_start(args, mesg);
#line 1618
  ret = __gmpfr_vasprintf(& tmp, mesg, args);
#line 1619
  __builtin_va_end(args);
  }
#line 1620
  if (ret >= 0) {
#line 1620
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1621
      return ((char const   *)tmp);
    }
  }
#line 1622
  return (mesg);
}
}
#line 1627 "/home/wslee/gnu_benchmarks/gawk-4.1.0/mpfr.c"
void mpfr_unset(NODE *n ) 
{ 


  {
#line 1630
  if ((n->flags & 2048U) != 0U) {
    {
#line 1631
    mpfr_clear(n->sub.val.nm.mpnum);
    }
  } else
#line 1632
  if ((n->flags & 4096U) != 0U) {
    {
#line 1633
    __gmpz_clear(n->sub.val.nm.mpi);
    }
  }
#line 1634
  return;
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 128
extern  __attribute__((__nothrow__)) struct lconv *localeconv(void) ;
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 540 "/usr/include/unistd.h"
extern char **environ ;
#line 623
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 626
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 692
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 695
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 698
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 701
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 706
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 57 "./getopt.h"
char *optarg ;
#line 71
int optind ;
#line 76
int opterr ;
#line 80
int optopt ;
#line 65 "/usr/include/sigsegv.h"
extern int sigsegv_install_handler(int (*handler)(void *fault_address , int serious ) ) ;
#line 108
extern int stackoverflow_install_handler(void (*handler)(int emergency , stackoverflow_context_t scp ) ,
                                         void *extra_stack , unsigned long extra_stack_size ) ;
#line 558 "/usr/include/gmp-x86_64.h"
extern char const   * const  __gmp_version ;
#line 204 "/usr/include/mpfr.h"
extern char const   *mpfr_get_version(void) ;
#line 1026 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
long NF  ;
#line 1027 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
long NR  ;
#line 1028 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
long FNR  ;
#line 1029 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int BINMODE  ;
#line 1030 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int IGNORECASE  ;
#line 1032 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
char *OFS  ;
#line 1034 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
char *ORS  ;
#line 1036 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
char *OFMT  ;
#line 1040 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
char *TEXTDOMAIN  ;
#line 1041 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *BINMODE_node  ;
#line 1041 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *CONVFMT_node  ;
#line 1041 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *FIELDWIDTHS_node  ;
#line 1041 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *FILENAME_node  ;
#line 1042 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *FNR_node  ;
#line 1042 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *FS_node  ;
#line 1042 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *IGNORECASE_node  ;
#line 1042 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *NF_node  ;
#line 1043 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *NR_node  ;
#line 1043 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *OFMT_node  ;
#line 1043 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *OFS_node  ;
#line 1043 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *ORS_node  ;
#line 1043 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *RLENGTH_node  ;
#line 1044 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *RSTART_node  ;
#line 1044 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *RS_node  ;
#line 1044 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *RT_node  ;
#line 1044 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *SUBSEP_node  ;
#line 1044 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *PROCINFO_node  ;
#line 1045 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *LINT_node  ;
#line 1045 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *ERRNO_node  ;
#line 1045 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *TEXTDOMAIN_node  ;
#line 1045 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *FPAT_node  ;
#line 1046 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *PREC_node  ;
#line 1046 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *ROUNDMODE_node  ;
#line 1047 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *Nnull_string  ;
#line 1052
int (*interpret)(INSTRUCTION * ) ;
#line 1068 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
SRCFILE *srcfiles  ;
#line 1101
_Bool do_optimize ;
#line 1113 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int gawk_mb_cur_max  ;
#line 1119 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
gid_t *groupset  ;
#line 1120 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int ngroups  ;
#line 1124 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
struct lconv loc  ;
#line 1137 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
char const   *myname  ;
#line 1138
char const   def_strftime_format[24] ;
#line 1140
char quote ;
#line 1141
char *defpath ;
#line 1142
char *deflibpath ;
#line 1343
void array_init(void) ;
#line 1347
void set_SUBSEP(void) ;
#line 1361
NODE *variable(int location , char *name , NODETYPE type ) ;
#line 1362
int parse_program(INSTRUCTION **pcode ) ;
#line 1365
void dump_vars(char const   *fname ) ;
#line 1368
void shadow_funcs(void) ;
#line 1369
int check_special(char const   *name ) ;
#line 1370
SRCFILE *add_srcfile(int stype , char *src , SRCFILE *thisfile , _Bool *already_included ,
                     int *errcode ) ;
#line 1371
void register_deferred_variable(char const   *name , NODE *(*load_func)(void) ) ;
#line 1423
void init_interpret(void) ;
#line 1426
void set_IGNORECASE(void) ;
#line 1427
void set_OFS(void) ;
#line 1428
void set_ORS(void) ;
#line 1429
void set_OFMT(void) ;
#line 1430
void set_CONVFMT(void) ;
#line 1431
void set_BINMODE(void) ;
#line 1432
void set_LINT(void) ;
#line 1433
void set_TEXTDOMAIN(void) ;
#line 1437
void update_NR(void) ;
#line 1438
void update_NF(void) ;
#line 1439
void update_FNR(void) ;
#line 1448
NODE **r_get_lhs(NODE *n , _Bool reference ) ;
#line 1454
void load_ext(char const   *lib_name ) ;
#line 1466
void init_fields(void) ;
#line 1469
void set_NF(void) ;
#line 1473
void set_FS(void) ;
#line 1474
void set_RS(void) ;
#line 1475
void set_FIELDWIDTHS(void) ;
#line 1476
void set_FPAT(void) ;
#line 1477
void update_PROCINFO_str(char const   *subscript , char const   *str ) ;
#line 1478
void update_PROCINFO_num(char const   *subscript , double val ) ;
#line 1485
field_sep_type current_field_sep(void) ;
#line 1489
void init_ext_api(void) ;
#line 1493
extern void print_ext_versions(void) ;
#line 1496
char *gawk_name(char const   *filespec ) ;
#line 1497
void os_arg_fixup(int *argcp , char ***argvp ) ;
#line 1500
int os_isatty(int fd ) ;
#line 1503
int os_is_setuid(void) ;
#line 1504
int os_setbinmode(int fd , int mode ) ;
#line 1511
void init_io(void) ;
#line 1515
void set_FNR(void) ;
#line 1516
void set_NR(void) ;
#line 1522
int devopen(char const   *name , char const   *mode ) ;
#line 1531
int arg_assign(char *arg , _Bool initing ) ;
#line 1532
int is_std_var(char const   *var ) ;
#line 1533
int is_off_limits_var(char const   *var ) ;
#line 173 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.h"
 __attribute__((__nothrow__)) int getopt_long(int argc , char * const  *argv , char const   *options ,
                                              struct option  const  *long_options ,
                                              int *opt_index ) ;
#line 41 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static char const   *varfile  =    "awkvars.out";
#line 42 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
char const   *command_file  =    (char const   *)((void *)0);
#line 44
static  __attribute__((__noreturn__)) void usage(int exitval , FILE *fp___0 ) ;
#line 45
static  __attribute__((__noreturn__)) void copyleft(void) ;
#line 46
static void cmdline_fs(char *str ) ;
#line 47
static void init_args(int argc0 , int argc , char const   *argv0 , char **argv ) ;
#line 48
static void init_vars(void) ;
#line 49
static NODE *load_environ(void) ;
#line 50
static NODE *load_procinfo(void) ;
#line 51
static void catchsig(int sig ) ;
#line 53
static int catchsegv(void *fault_address , int serious ) ;
#line 54
static void catchstackoverflow(int emergency , stackoverflow_context_t scp ) ;
#line 56
static  __attribute__((__noreturn__)) void nostalgia(void) ;
#line 57
static  __attribute__((__noreturn__)) void version(void) ;
#line 58
static void init_fds(void) ;
#line 59
static void init_groupset(void) ;
#line 60
static void save_argv(int argc , char **argv ) ;
#line 62
int debug_prog(INSTRUCTION *pc ) ;
#line 63
extern int init_debug() ;
#line 66 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
NODE *ARGC_node  ;
#line 66 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
NODE *ARGIND_node  ;
#line 66 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
NODE *ARGV_node  ;
#line 67 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
NODE *ENVIRON_node  ;
#line 90 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
char *CONVFMT  =    (char *)"%.6g";
#line 96
static void init_locale(struct lconv *l ) ;
#line 103 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
INSTRUCTION *code_block  =    (INSTRUCTION *)((void *)0);
#line 105 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
char **d_argv  ;
#line 110 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
INSTRUCTION *rule_list  ;
#line 112 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
int exit_val  =    0;
#line 128 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static struct pre_assign *preassigns  =    (struct pre_assign *)((void *)0);
#line 129 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static long numassigns  =    -1L;
#line 131 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static _Bool disallow_var_assigns  =    (_Bool)0;
#line 133
static void add_preassign(enum assign_type type , char *val ) ;
#line 135 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
int do_flags  =    0;
#line 136 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
_Bool do_optimize  =    (_Bool)1;
#line 137 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static int do_nostalgia  =    0;
#line 138 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static int do_binary  =    0;
#line 139 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static int do_version  =    0;
#line 141 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
int use_lc_numeric  =    0;
#line 147 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
FILE *output_fp  ;
#line 148 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
_Bool output_is_tty  =    (_Bool)0;
#line 151 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
char const   def_strftime_format[24]  = 
#line 151
  {      (char const   )'%',      (char const   )'a',      (char const   )' ',      (char const   )'%', 
        (char const   )'b',      (char const   )' ',      (char const   )'%',      (char const   )'e', 
        (char const   )' ',      (char const   )'%',      (char const   )'H',      (char const   )':', 
        (char const   )'%',      (char const   )'M',      (char const   )':',      (char const   )'%', 
        (char const   )'S',      (char const   )' ',      (char const   )'%',      (char const   )'Z', 
        (char const   )' ',      (char const   )'%',      (char const   )'Y',      (char const   )'\000'};
#line 160 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
void ( /* format attribute */  (*lintfunc))(char const   *mesg  , ...)  =    & warning;
#line 162 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static struct option  const  optab[27]  = 
#line 162
  {      {"traditional", 0, (int *)((void *)0), 'c'}, 
        {"lint", 2, (int *)((void *)0), 'L'}, 
        {"lint-old", 0, (int *)((void *)0), 't'}, 
        {"optimize", 0, (int *)((void *)0), 'O'}, 
        {"posix", 0, (int *)((void *)0), 'P'}, 
        {"nostalgia", 0, & do_nostalgia, 1}, 
        {"gen-pot", 0, (int *)((void *)0), 'g'}, 
        {"non-decimal-data", 0, (int *)((void *)0), 'n'}, 
        {"pretty-print", 2, (int *)((void *)0), 'o'}, 
        {"profile", 2, (int *)((void *)0), 'p'}, 
        {"debug", 2, (int *)((void *)0), 'D'}, 
        {"copyright", 0, (int *)((void *)0), 'C'}, 
        {"field-separator", 1, (int *)((void *)0), 'F'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"re-interval", 0, (int *)((void *)0), 'r'}, 
        {"source", 1, (int *)((void *)0), 'e'}, 
        {"load", 1, (int *)((void *)0), 'l'}, 
        {"dump-variables", 2, (int *)((void *)0), 'd'}, 
        {"assign", 1, (int *)((void *)0), 'v'}, 
        {"version", 0, & do_version, 'V'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"exec", 1, (int *)((void *)0), 'E'}, 
        {"use-lc-numeric", 0, & use_lc_numeric, 1}, 
        {"characters-as-bytes", 0, & do_binary, 'b'}, 
        {"sandbox", 0, (int *)((void *)0), 'S'}, 
        {"bignum", 0, (int *)((void *)0), 'M'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 198 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
int main(int argc , char **argv ) 
{ 
  char const   *optlist ;
  _Bool stopped_early ;
  int old_optind ;
  int i___0 ;
  int c ;
  char *scan ;
  char *src ;
  char *extra_stack ;
  int have_srcfile ;
  SRCFILE *s___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  AWK_CONTEXT *tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  char const   *tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;

  {
  {
#line 204
  optlist = "+F:f:v:W;bcCd::D::e:E:gh:i:l:L:nNo::Op::MPrStVY";
#line 205
  stopped_early = (_Bool)0;
#line 211
  have_srcfile = 0;
#line 215
  tmp___1 = getenv("TIDYMEM");
  }
#line 215
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 216
    do_flags |= 1024;
  }
  {
#line 226
  setlocale(0, "");
#line 229
  setlocale(3, "");
#line 232
  setlocale(5, "");
#line 248
  setlocale(1, "");
#line 249
  init_locale(& loc);
#line 250
  setlocale(1, "C");
#line 253
  setlocale(2, "");
#line 262
  tmp___2 = __ctype_get_mb_cur_max();
#line 262
  gawk_mb_cur_max = (int )tmp___2;
#line 277
  init_btowc_cache();
#line 280
  bindtextdomain("gawk", "/usr/local/share/locale");
#line 281
  textdomain("gawk");
#line 283
  signal(8, & catchsig);
#line 285
  signal(7, & catchsig);
#line 288
  sigsegv_install_handler(& catchsegv);
#line 290
  tmp___3 = malloc((size_t )16384);
#line 290
  extra_stack = (char *)tmp___3;
  }
#line 290
  if (extra_stack) {
#line 290
    tmp___7 = 1;
  } else {
    {
#line 290
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 290);
#line 290
    tmp___4 = __errno_location();
#line 290
    tmp___5 = strerror(*tmp___4);
#line 290
    tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 290
    r_fatal((char const   *)tmp___6, "main", "extra_stack", 16384L, tmp___5);
#line 290
    tmp___7 = 0;
    }
  }
  {
#line 291
  stackoverflow_install_handler(& catchstackoverflow, (void *)extra_stack, 16384UL);
#line 294
  tmp___8 = gawk_name((char const   *)*(argv + 0));
#line 294
  myname = (char const   *)tmp___8;
#line 295
  os_arg_fixup(& argc, & argv);
  }
#line 297
  if (argc < 2) {
    {
#line 298
    usage(1, stderr);
    }
  }
  {
#line 301
  Nnull_string = make_str_node("", (size_t )0, 0);
#line 304
  init_fds();
#line 307
  array_init();
#line 310
  init_symbol_table();
#line 312
  output_fp = stdout;
#line 315
  opterr = 0;
#line 318
  save_argv(argc, argv);
#line 321
  tmp___9 = new_context();
#line 321
  push_context(tmp___9);
#line 324
  optopt = 0;
#line 324
  old_optind = 1;
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 324
    c = getopt_long(argc, (char * const  *)argv, optlist, optab, (int *)((void *)0));
    }
#line 324
    if (! (c != -1)) {
#line 324
      goto while_break;
    }
#line 327
    if (do_flags & 16) {
#line 328
      opterr = 1;
    }
    {
#line 331
    if (c == 70) {
#line 331
      goto case_70;
    }
#line 335
    if (c == 69) {
#line 335
      goto case_69;
    }
#line 338
    if (c == 102) {
#line 338
      goto case_102;
    }
#line 358
    if (c == 118) {
#line 358
      goto case_118;
    }
#line 362
    if (c == 98) {
#line 362
      goto case_98;
    }
#line 366
    if (c == 99) {
#line 366
      goto case_99;
    }
#line 370
    if (c == 67) {
#line 370
      goto case_67;
    }
#line 374
    if (c == 100) {
#line 374
      goto case_100;
    }
#line 380
    if (c == 68) {
#line 380
      goto case_68;
    }
#line 386
    if (c == 101) {
#line 386
      goto case_101;
    }
#line 393
    if (c == 103) {
#line 393
      goto case_103;
    }
#line 397
    if (c == 104) {
#line 397
      goto case_104;
    }
#line 402
    if (c == 105) {
#line 402
      goto case_105;
    }
#line 406
    if (c == 108) {
#line 406
      goto case_108;
    }
#line 411
    if (c == 76) {
#line 411
      goto case_76;
    }
#line 423
    if (c == 116) {
#line 423
      goto case_116;
    }
#line 432
    if (c == 110) {
#line 432
      goto case_110;
    }
#line 436
    if (c == 78) {
#line 436
      goto case_78;
    }
#line 440
    if (c == 79) {
#line 440
      goto case_79;
    }
#line 444
    if (c == 112) {
#line 444
      goto case_112;
    }
#line 447
    if (c == 111) {
#line 447
      goto case_111;
    }
#line 455
    if (c == 77) {
#line 455
      goto case_77;
    }
#line 461
    if (c == 80) {
#line 461
      goto case_80;
    }
#line 465
    if (c == 114) {
#line 465
      goto case_114;
    }
#line 469
    if (c == 83) {
#line 469
      goto case_83;
    }
#line 473
    if (c == 86) {
#line 473
      goto case_86;
    }
#line 477
    if (c == 87) {
#line 477
      goto case_87;
    }
#line 482
    if (c == 0) {
#line 482
      goto case_0;
    }
#line 499
    goto switch_default;
    case_70: /* CIL Label */ 
    {
#line 332
    add_preassign((enum assign_type )2, optarg);
    }
#line 333
    goto switch_break;
    case_69: /* CIL Label */ 
#line 336
    disallow_var_assigns = (_Bool)1;
    case_102: /* CIL Label */ 
#line 347
    scan = optarg;
#line 348
    if ((unsigned long )*(argv + (optind - 1)) != (unsigned long )optarg) {
      {
#line 349
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 349
        tmp___10 = __ctype_b_loc();
        }
#line 349
        if (! ((int const   )*(*tmp___10 + (int )((unsigned char )*scan)) & 8192)) {
#line 349
          goto while_break___0;
        }
#line 350
        scan ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 351
    if ((int )*scan == 0) {
#line 351
      tmp___11 = optind;
#line 351
      optind ++;
#line 351
      src = *(argv + tmp___11);
    } else {
#line 351
      src = optarg;
    }
#line 352
    if (src) {
#line 352
      if ((int )*(src + 0) == 45) {
#line 352
        if ((int )*(src + 1) == 0) {
#line 352
          tmp___12 = 2;
        } else {
#line 352
          tmp___12 = 3;
        }
      } else {
#line 352
        tmp___12 = 3;
      }
    } else {
#line 352
      tmp___12 = 3;
    }
    {
#line 352
    add_srcfile(tmp___12, src, srcfiles, (_Bool *)((void *)0), (int *)((void *)0));
    }
#line 356
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 359
    add_preassign((enum assign_type )1, optarg);
    }
#line 360
    goto switch_break;
    case_98: /* CIL Label */ 
#line 363
    do_binary = 1;
#line 364
    goto switch_break;
    case_99: /* CIL Label */ 
#line 367
    do_flags |= 8;
#line 368
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 371
    copyleft();
    }
#line 372
    goto switch_break;
    case_100: /* CIL Label */ 
#line 375
    do_flags |= 512;
#line 376
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
#line 376
      if ((int )*(optarg + 0) != 0) {
#line 377
        varfile = (char const   *)optarg;
      }
    }
#line 378
    goto switch_break;
    case_68: /* CIL Label */ 
#line 381
    do_flags |= 8192;
#line 382
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
#line 382
      if ((int )*(optarg + 0) != 0) {
#line 383
        command_file = (char const   *)optarg;
      }
    }
#line 384
    goto switch_break;
    case_101: /* CIL Label */ 
#line 387
    if ((int )*(optarg + 0) == 0) {
      {
#line 388
      tmp___13 = gettext("empty argument to `-e/--source\' ignored");
#line 388
      warning((char const   *)tmp___13);
      }
    } else {
      {
#line 390
      add_srcfile(1, optarg, srcfiles, (_Bool *)((void *)0), (int *)((void *)0));
      }
    }
#line 391
    goto switch_break;
    case_103: /* CIL Label */ 
#line 394
    do_flags |= 32;
#line 395
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 399
    usage(0, stdout);
    }
#line 400
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 403
    add_srcfile(4, optarg, srcfiles, (_Bool *)((void *)0), (int *)((void *)0));
    }
#line 404
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 407
    add_srcfile(5, optarg, srcfiles, (_Bool *)((void *)0), (int *)((void *)0));
    }
#line 408
    goto switch_break;
    case_76: /* CIL Label */ 
#line 412
    do_flags |= 2;
#line 413
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
      {
#line 414
      tmp___15 = strcmp((char const   *)optarg, "fatal");
      }
#line 414
      if (tmp___15 == 0) {
#line 415
        lintfunc = & r_fatal;
      } else {
        {
#line 416
        tmp___14 = strcmp((char const   *)optarg, "invalid");
        }
#line 416
        if (tmp___14 == 0) {
#line 417
          do_flags &= -3;
#line 418
          do_flags |= 1;
        }
      }
    }
#line 421
    goto switch_break;
    case_116: /* CIL Label */ 
#line 424
    do_flags |= 4;
#line 425
    goto switch_break;
    case_110: /* CIL Label */ 
#line 433
    do_flags |= 64;
#line 434
    goto switch_break;
    case_78: /* CIL Label */ 
#line 437
    use_lc_numeric = 1;
#line 438
    goto switch_break;
    case_79: /* CIL Label */ 
#line 441
    do_optimize = (_Bool )((int )do_optimize + 1);
#line 442
    goto switch_break;
    case_112: /* CIL Label */ 
#line 445
    do_flags |= 4096;
    case_111: /* CIL Label */ 
#line 448
    do_flags |= 256;
#line 449
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
      {
#line 450
      set_prof_file((char const   *)optarg);
      }
    } else {
      {
#line 452
      set_prof_file("awkprof.out");
      }
    }
#line 453
    goto switch_break;
    case_77: /* CIL Label */ 
#line 457
    do_flags |= 16384;
#line 459
    goto switch_break;
    case_80: /* CIL Label */ 
#line 462
    do_flags |= 16;
#line 463
    goto switch_break;
    case_114: /* CIL Label */ 
#line 466
    do_flags |= 128;
#line 467
    goto switch_break;
    case_83: /* CIL Label */ 
#line 470
    do_flags |= 2048;
#line 471
    goto switch_break;
    case_86: /* CIL Label */ 
#line 474
    do_version = 1;
#line 475
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 478
    tmp___16 = gettext("%s: option `-W %s\' unrecognized, ignored\n");
#line 478
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
            *(argv + 0), optarg);
    }
#line 480
    goto switch_break;
    case_0: /* CIL Label */ 
#line 488
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 511
    if (! (do_flags & 16)) {
#line 511
      if (optopt == 0) {
#line 518
        optind = old_optind;
#line 519
        stopped_early = (_Bool)1;
#line 520
        goto out;
      } else {
        {
#line 511
        tmp___18 = strchr(optlist, optopt);
        }
#line 511
        if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
#line 518
          optind = old_optind;
#line 519
          stopped_early = (_Bool)1;
#line 520
          goto out;
        } else {
#line 511
          goto _L;
        }
      }
    } else
    _L: /* CIL Label */ 
#line 521
    if (optopt != 0) {
      {
#line 523
      tmp___17 = gettext("%s: option requires an argument -- %c\n");
#line 523
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
              myname, optopt);
#line 526
      usage(1, stderr);
      }
    }
#line 530
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 532
    if (c == 69) {
#line 533
      goto while_break;
    }
#line 324
    optopt = 0;
#line 324
    old_optind = optind;
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 537
  if (do_nostalgia) {
    {
#line 538
    nostalgia();
    }
  }
#line 541
  if (! (do_flags & 16)) {
    {
#line 541
    tmp___20 = getenv("POSIXLY_CORRECT");
    }
#line 541
    if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
#line 542
      do_flags |= 16;
#line 543
      if (do_flags & 3) {
        {
#line 544
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 544);
#line 544
        tmp___19 = gettext("environment variable `POSIXLY_CORRECT\' set: turning on `--posix\'");
#line 544
        (*lintfunc)((char const   *)tmp___19);
        }
      }
    }
  }
#line 548
  if (do_flags & 16) {
#line 549
    use_lc_numeric = 1;
#line 550
    if (do_flags & 8) {
      {
#line 551
      tmp___21 = gettext("`--posix\' overrides `--traditional\'");
#line 551
      warning((char const   *)tmp___21);
      }
    } else {
#line 553
      do_flags |= 8;
    }
  }
#line 560
  if (do_flags & 8) {
#line 560
    if (do_flags & 64) {
      {
#line 561
      do_flags &= -65;
#line 562
      tmp___22 = gettext("`--posix\'/`--traditional\' overrides `--non-decimal-data\'");
#line 562
      warning((char const   *)tmp___22);
      }
    }
  }
#line 565
  if (do_flags & 3) {
    {
#line 565
    tmp___24 = os_is_setuid();
    }
#line 565
    if (tmp___24) {
      {
#line 566
      tmp___23 = gettext("running %s setuid root may be a security problem");
#line 566
      warning((char const   *)tmp___23, myname);
      }
    }
  }
#line 569
  if (do_binary) {
#line 570
    if (do_flags & 16) {
      {
#line 571
      tmp___25 = gettext("`--posix\' overrides `--characters-as-bytes\'");
#line 571
      warning((char const   *)tmp___25);
      }
    } else {
#line 573
      gawk_mb_cur_max = 1;
    }
    {
#line 575
    setlocale(6, "C");
    }
  }
#line 580
  if (do_flags & 8192) {
    {
#line 581
    init_debug();
    }
  }
#line 585
  if (do_flags & 16384) {
    {
#line 586
    init_mpfr((mpfr_prec_t )53, "N");
    }
  }
  {
#line 590
  init_groupset();
  }
#line 593
  if (do_flags & 16384) {
    {
#line 594
    __gmpz_init(Nnull_string->sub.val.nm.mpi);
#line 595
    Nnull_string->flags = 4127U;
    }
  } else {
#line 599
    Nnull_string->sub.val.nm.fltnum = 0.0;
#line 600
    Nnull_string->flags = 31U;
  }
  {
#line 608
  resetup();
#line 611
  init_vars();
#line 614
  init_fields();
#line 617
  i___0 = 0;
  }
  {
#line 617
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 617
    if (! ((long )i___0 <= numassigns)) {
#line 617
      goto while_break___1;
    }
#line 618
    if ((unsigned int )(preassigns + i___0)->type == 1U) {
      {
#line 619
      arg_assign((preassigns + i___0)->val, (_Bool)1);
      }
    } else {
      {
#line 621
      cmdline_fs((preassigns + i___0)->val);
      }
    }
    {
#line 622
    free((void *)(preassigns + i___0)->val);
#line 617
    i___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 625
  if ((unsigned long )preassigns != (unsigned long )((void *)0)) {
    {
#line 626
    free((void *)preassigns);
    }
  }
#line 628
  if ((BINMODE & 1) != 0) {
    {
#line 629
    tmp___29 = fileno(stdin);
#line 629
    tmp___30 = os_setbinmode(tmp___29, 0);
    }
#line 629
    if (tmp___30 == -1) {
      {
#line 630
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 630);
#line 630
      tmp___26 = __errno_location();
#line 630
      tmp___27 = strerror(*tmp___26);
#line 630
      tmp___28 = gettext("can\'t set binary mode on stdin (%s)");
#line 630
      r_fatal((char const   *)tmp___28, tmp___27);
      }
    }
  }
#line 631
  if ((BINMODE & 2) != 0) {
    {
#line 632
    tmp___34 = fileno(stdout);
#line 632
    tmp___35 = os_setbinmode(tmp___34, 0);
    }
#line 632
    if (tmp___35 == -1) {
      {
#line 633
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 633);
#line 633
      tmp___31 = __errno_location();
#line 633
      tmp___32 = strerror(*tmp___31);
#line 633
      tmp___33 = gettext("can\'t set binary mode on stdout (%s)");
#line 633
      r_fatal((char const   *)tmp___33, tmp___32);
      }
    }
    {
#line 634
    tmp___39 = fileno(stderr);
#line 634
    tmp___40 = os_setbinmode(tmp___39, 0);
    }
#line 634
    if (tmp___40 == -1) {
      {
#line 635
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 635);
#line 635
      tmp___36 = __errno_location();
#line 635
      tmp___37 = strerror(*tmp___36);
#line 635
      tmp___38 = gettext("can\'t set binary mode on stderr (%s)");
#line 635
      r_fatal((char const   *)tmp___38, tmp___37);
      }
    }
  }
  {
#line 641
  tmp___41 = fileno(stdout);
#line 641
  tmp___42 = os_isatty(tmp___41);
  }
#line 641
  if (tmp___42) {
#line 642
    output_is_tty = (_Bool)1;
  }
  {
#line 645
  init_ext_api();
#line 648
  s___0 = srcfiles->next;
  }
  {
#line 648
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 648
    if (! ((unsigned long )s___0 != (unsigned long )srcfiles)) {
#line 648
      goto while_break___2;
    }
#line 649
    if ((unsigned int )s___0->stype == 5U) {
      {
#line 650
      load_ext((char const   *)s___0->fullpath);
      }
    } else
#line 651
    if ((unsigned int )s___0->stype != 4U) {
#line 652
      have_srcfile ++;
    }
#line 648
    s___0 = s___0->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 656
  if (do_version) {
    {
#line 657
    version();
    }
  }
#line 660
  if (! have_srcfile) {
#line 661
    if (optind > argc - 1) {
      {
#line 662
      usage(1, stderr);
      }
    } else
#line 661
    if (stopped_early) {
      {
#line 662
      usage(1, stderr);
      }
    }
    {
#line 663
    add_srcfile(1, *(argv + optind), srcfiles, (_Bool *)((void *)0), (int *)((void *)0));
#line 664
    optind ++;
    }
  }
  {
#line 668
  init_interpret();
  }
#line 670
  if (do_flags & 16) {
#line 670
    tmp___43 = (char const   *)*(argv + 0);
  } else {
#line 670
    tmp___43 = myname;
  }
  {
#line 670
  init_args(optind, argc, tmp___43, argv);
#line 680
  setlocale(1, "C");
#line 683
  tmp___44 = parse_program(& code_block);
  }
#line 683
  if (tmp___44 != 0) {
    {
#line 684
    exit(1);
    }
  }
#line 686
  if (do_flags & 32) {
    {
#line 687
    exit(0);
    }
  }
#line 689
  if (do_flags & 3) {
    {
#line 690
    shadow_funcs();
    }
  }
#line 692
  if (do_flags & 3) {
#line 692
    if ((unsigned int )(code_block->nexti)->opcode == 101U) {
      {
#line 693
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 693);
#line 693
      tmp___45 = gettext("no program text at all!");
#line 693
      (*lintfunc)((char const   *)tmp___45);
      }
    }
  }
  {
#line 695
  load_symbols();
  }
#line 697
  if (do_flags & 4096) {
    {
#line 698
    init_profiling_signals();
    }
  }
#line 716
  if (use_lc_numeric) {
    {
#line 717
    setlocale(1, "");
    }
  }
  {
#line 720
  init_io();
#line 721
  output_fp = stdout;
  }
#line 723
  if (do_flags & 8192) {
    {
#line 724
    debug_prog(code_block);
    }
  } else {
    {
#line 726
    (*interpret)(code_block);
    }
  }
#line 728
  if (do_flags & 256) {
    {
#line 729
    dump_prog(code_block);
#line 730
    dump_funcs();
    }
  }
#line 733
  if (do_flags & 512) {
    {
#line 734
    dump_vars(varfile);
    }
  }
#line 736
  if (do_flags & 1024) {
    {
#line 737
    release_all_vars();
    }
  }
#line 740
  if (extra_stack) {
    {
#line 741
    free((void *)extra_stack);
    }
  }
  {
#line 743
  final_exit(exit_val);
  }
#line 744
  return (exit_val);
}
}
#line 752 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static long alloc_assigns  ;
#line 749 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void add_preassign(enum assign_type type , char *val ) 
{ 
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 756
  numassigns ++;
#line 758
  if ((unsigned long )preassigns == (unsigned long )((void *)0)) {
    {
#line 759
    tmp___1 = malloc(4UL * sizeof(struct pre_assign ));
#line 759
    preassigns = (struct pre_assign *)tmp___1;
    }
#line 759
    if (preassigns) {
#line 759
      tmp___5 = 1;
    } else {
      {
#line 759
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 760);
#line 759
      tmp___2 = __errno_location();
#line 759
      tmp___3 = strerror(*tmp___2);
#line 759
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 759
      r_fatal((char const   *)tmp___4, "add_preassign", "preassigns", (long )(4UL * sizeof(struct pre_assign )),
              tmp___3);
#line 759
      tmp___5 = 0;
      }
    }
#line 761
    alloc_assigns = 4L;
  } else
#line 762
  if (numassigns >= alloc_assigns) {
    {
#line 763
    alloc_assigns *= 2L;
#line 764
    tmp___6 = realloc((void *)((char *)preassigns), (unsigned long )alloc_assigns * sizeof(struct pre_assign ));
#line 764
    preassigns = (struct pre_assign *)tmp___6;
    }
#line 764
    if (preassigns) {
#line 764
      tmp___10 = 1;
    } else {
      {
#line 764
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 765);
#line 764
      tmp___7 = __errno_location();
#line 764
      tmp___8 = strerror(*tmp___7);
#line 764
      tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 764
      r_fatal((char const   *)tmp___9, "add_preassigns", "preassigns", (long )((unsigned long )alloc_assigns * sizeof(struct pre_assign )),
              tmp___8);
#line 764
      tmp___10 = 0;
      }
    }
  }
  {
#line 767
  (preassigns + numassigns)->type = type;
#line 768
  tmp___11 = strlen((char const   *)val);
#line 768
  (preassigns + numassigns)->val = estrdup((char const   *)val, tmp___11);
  }
#line 771
  return;
}
}
#line 775
static  __attribute__((__noreturn__)) void usage(int exitval , FILE *fp___0 ) ;
#line 775 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void usage(int exitval , FILE *fp___0 ) 
{ 
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
  {
#line 779
  tmp___1 = gettext("Usage: %s [POSIX or GNU style options] -f progfile [--] file ...\n");
#line 779
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)tmp___1,
          myname);
#line 781
  tmp___2 = gettext("Usage: %s [POSIX or GNU style options] [--] %cprogram%c file ...\n");
#line 781
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)tmp___2,
          myname, (int )quote, (int )quote);
#line 786
  tmp___3 = gettext("POSIX options:\t\tGNU long options: (standard)\n");
#line 786
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)fp___0);
#line 787
  tmp___4 = gettext("\t-f progfile\t\t--file=progfile\n");
#line 787
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)fp___0);
#line 788
  tmp___5 = gettext("\t-F fs\t\t\t--field-separator=fs\n");
#line 788
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)fp___0);
#line 789
  tmp___6 = gettext("\t-v var=val\t\t--assign=var=val\n");
#line 789
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)fp___0);
#line 790
  tmp___7 = gettext("Short options:\t\tGNU long options: (extensions)\n");
#line 790
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)fp___0);
#line 791
  tmp___8 = gettext("\t-b\t\t\t--characters-as-bytes\n");
#line 791
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)fp___0);
#line 792
  tmp___9 = gettext("\t-c\t\t\t--traditional\n");
#line 792
  fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)fp___0);
#line 793
  tmp___10 = gettext("\t-C\t\t\t--copyright\n");
#line 793
  fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)fp___0);
#line 794
  tmp___11 = gettext("\t-d[file]\t\t--dump-variables[=file]\n");
#line 794
  fputs((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)fp___0);
#line 795
  tmp___12 = gettext("\t-D[file]\t\t--debug[=file]\n");
#line 795
  fputs((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)fp___0);
#line 796
  tmp___13 = gettext("\t-e \'program-text\'\t--source=\'program-text\'\n");
#line 796
  fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)fp___0);
#line 797
  tmp___14 = gettext("\t-E file\t\t\t--exec=file\n");
#line 797
  fputs((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)fp___0);
#line 798
  tmp___15 = gettext("\t-g\t\t\t--gen-pot\n");
#line 798
  fputs((char const   */* __restrict  */)tmp___15, (FILE */* __restrict  */)fp___0);
#line 799
  tmp___16 = gettext("\t-h\t\t\t--help\n");
#line 799
  fputs((char const   */* __restrict  */)tmp___16, (FILE */* __restrict  */)fp___0);
#line 800
  tmp___17 = gettext("\t-i includefile\t\t--include=includefile\n");
#line 800
  fputs((char const   */* __restrict  */)tmp___17, (FILE */* __restrict  */)fp___0);
#line 801
  tmp___18 = gettext("\t-l library\t\t--load=library\n");
#line 801
  fputs((char const   */* __restrict  */)tmp___18, (FILE */* __restrict  */)fp___0);
#line 802
  tmp___19 = gettext("\t-L [fatal]\t\t--lint[=fatal]\n");
#line 802
  fputs((char const   */* __restrict  */)tmp___19, (FILE */* __restrict  */)fp___0);
#line 803
  tmp___20 = gettext("\t-n\t\t\t--non-decimal-data\n");
#line 803
  fputs((char const   */* __restrict  */)tmp___20, (FILE */* __restrict  */)fp___0);
#line 804
  tmp___21 = gettext("\t-M\t\t\t--bignum\n");
#line 804
  fputs((char const   */* __restrict  */)tmp___21, (FILE */* __restrict  */)fp___0);
#line 805
  tmp___22 = gettext("\t-N\t\t\t--use-lc-numeric\n");
#line 805
  fputs((char const   */* __restrict  */)tmp___22, (FILE */* __restrict  */)fp___0);
#line 806
  tmp___23 = gettext("\t-o[file]\t\t--pretty-print[=file]\n");
#line 806
  fputs((char const   */* __restrict  */)tmp___23, (FILE */* __restrict  */)fp___0);
#line 807
  tmp___24 = gettext("\t-O\t\t\t--optimize\n");
#line 807
  fputs((char const   */* __restrict  */)tmp___24, (FILE */* __restrict  */)fp___0);
#line 808
  tmp___25 = gettext("\t-p[file]\t\t--profile[=file]\n");
#line 808
  fputs((char const   */* __restrict  */)tmp___25, (FILE */* __restrict  */)fp___0);
#line 809
  tmp___26 = gettext("\t-P\t\t\t--posix\n");
#line 809
  fputs((char const   */* __restrict  */)tmp___26, (FILE */* __restrict  */)fp___0);
#line 810
  tmp___27 = gettext("\t-r\t\t\t--re-interval\n");
#line 810
  fputs((char const   */* __restrict  */)tmp___27, (FILE */* __restrict  */)fp___0);
#line 811
  tmp___28 = gettext("\t-S\t\t\t--sandbox\n");
#line 811
  fputs((char const   */* __restrict  */)tmp___28, (FILE */* __restrict  */)fp___0);
#line 812
  tmp___29 = gettext("\t-t\t\t\t--lint-old\n");
#line 812
  fputs((char const   */* __restrict  */)tmp___29, (FILE */* __restrict  */)fp___0);
#line 813
  tmp___30 = gettext("\t-V\t\t\t--version\n");
#line 813
  fputs((char const   */* __restrict  */)tmp___30, (FILE */* __restrict  */)fp___0);
#line 827
  tmp___31 = gettext("\nTo report bugs, see node `Bugs\' in `gawk.info\', which is\nsection `Reporting Problems and Bugs\' in the printed version.\n\n");
#line 827
  fputs((char const   */* __restrict  */)tmp___31, (FILE */* __restrict  */)fp___0);
#line 831
  tmp___32 = gettext("gawk is a pattern scanning and processing language.\nBy default it reads standard input and writes standard output.\n\n");
#line 831
  fputs((char const   */* __restrict  */)tmp___32, (FILE */* __restrict  */)fp___0);
#line 835
  tmp___33 = gettext("Examples:\n\tgawk \'{ sum += $1 }; END { print sum }\' file\n\tgawk -F: \'{ print $1 }\' /etc/passwd\n");
#line 835
  fputs((char const   */* __restrict  */)tmp___33, (FILE */* __restrict  */)fp___0);
#line 838
  fflush(fp___0);
#line 840
  tmp___37 = ferror(fp___0);
  }
#line 840
  if (tmp___37) {
#line 841
    if ((unsigned long )fp___0 == (unsigned long )stdout) {
      {
#line 842
      tmp___34 = __errno_location();
#line 842
      tmp___35 = strerror(*tmp___34);
#line 842
      tmp___36 = gettext("error writing standard output (%s)");
#line 842
      warning((char const   *)tmp___36, tmp___35);
      }
    }
    {
#line 843
    exit(1);
    }
  }
  {
#line 846
  exit(exitval);
  }
}
}
#line 854 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static char const   blurb_part1[297]  = 
#line 854
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'C', 
        (char const   )')',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'8',      (char const   )'9',      (char const   )',',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'1', 
        (char const   )'-',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'.',      (char const   )'\n',      (char const   )'\n',      (char const   )'T', 
        (char const   )'h',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'g', 
        (char const   )'r',      (char const   )'a',      (char const   )'m',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'f', 
        (char const   )'r',      (char const   )'e',      (char const   )'e',      (char const   )' ', 
        (char const   )'s',      (char const   )'o',      (char const   )'f',      (char const   )'t', 
        (char const   )'w',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )';',      (char const   )' ',      (char const   )'y',      (char const   )'o', 
        (char const   )'u',      (char const   )' ',      (char const   )'c',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'b',      (char const   )'u', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'i', 
        (char const   )'t',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'/',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'m',      (char const   )'o',      (char const   )'d', 
        (char const   )'i',      (char const   )'f',      (char const   )'y',      (char const   )'\n', 
        (char const   )'i',      (char const   )'t',      (char const   )' ',      (char const   )'u', 
        (char const   )'n',      (char const   )'d',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'G',      (char const   )'N', 
        (char const   )'U',      (char const   )' ',      (char const   )'G',      (char const   )'e', 
        (char const   )'n',      (char const   )'e',      (char const   )'r',      (char const   )'a', 
        (char const   )'l',      (char const   )' ',      (char const   )'P',      (char const   )'u', 
        (char const   )'b',      (char const   )'l',      (char const   )'i',      (char const   )'c', 
        (char const   )' ',      (char const   )'L',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )' ',      (char const   )'a',      (char const   )'s',      (char const   )' ', 
        (char const   )'p',      (char const   )'u',      (char const   )'b',      (char const   )'l', 
        (char const   )'i',      (char const   )'s',      (char const   )'h',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'b',      (char const   )'y', 
        (char const   )'\n',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'F',      (char const   )'r',      (char const   )'e', 
        (char const   )'e',      (char const   )' ',      (char const   )'S',      (char const   )'o', 
        (char const   )'f',      (char const   )'t',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'e',      (char const   )' ',      (char const   )'F', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )';',      (char const   )' ',      (char const   )'e', 
        (char const   )'i',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'3',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'L', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'n', 
        (char const   )'s',      (char const   )'e',      (char const   )',',      (char const   )' ', 
        (char const   )'o',      (char const   )'r',      (char const   )'\n',      (char const   )'(', 
        (char const   )'a',      (char const   )'t',      (char const   )' ',      (char const   )'y', 
        (char const   )'o',      (char const   )'u',      (char const   )'r',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )')',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'y',      (char const   )' ', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'.',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'\000'};
#line 862 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static char const   blurb_part2[236]  = 
#line 862
  {      (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'m', 
        (char const   )' ',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'d',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'b',      (char const   )'u', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'h', 
        (char const   )'o',      (char const   )'p',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'a',      (char const   )'t', 
        (char const   )' ',      (char const   )'i',      (char const   )'t',      (char const   )' ', 
        (char const   )'w',      (char const   )'i',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'b',      (char const   )'e',      (char const   )' ', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'f', 
        (char const   )'u',      (char const   )'l',      (char const   )',',      (char const   )'\n', 
        (char const   )'b',      (char const   )'u',      (char const   )'t',      (char const   )' ', 
        (char const   )'W',      (char const   )'I',      (char const   )'T',      (char const   )'H', 
        (char const   )'O',      (char const   )'U',      (char const   )'T',      (char const   )' ', 
        (char const   )'A',      (char const   )'N',      (char const   )'Y',      (char const   )' ', 
        (char const   )'W',      (char const   )'A',      (char const   )'R',      (char const   )'R', 
        (char const   )'A',      (char const   )'N',      (char const   )'T',      (char const   )'Y', 
        (char const   )';',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )' ',      (char const   )'e',      (char const   )'v', 
        (char const   )'e',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'i', 
        (char const   )'m',      (char const   )'p',      (char const   )'l',      (char const   )'i', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'w', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'t',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )'\n',      (char const   )'M', 
        (char const   )'E',      (char const   )'R',      (char const   )'C',      (char const   )'H', 
        (char const   )'A',      (char const   )'N',      (char const   )'T',      (char const   )'A', 
        (char const   )'B',      (char const   )'I',      (char const   )'L',      (char const   )'I', 
        (char const   )'T',      (char const   )'Y',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'F',      (char const   )'I', 
        (char const   )'T',      (char const   )'N',      (char const   )'E',      (char const   )'S', 
        (char const   )'S',      (char const   )' ',      (char const   )'F',      (char const   )'O', 
        (char const   )'R',      (char const   )' ',      (char const   )'A',      (char const   )' ', 
        (char const   )'P',      (char const   )'A',      (char const   )'R',      (char const   )'T', 
        (char const   )'I',      (char const   )'C',      (char const   )'U',      (char const   )'L', 
        (char const   )'A',      (char const   )'R',      (char const   )' ',      (char const   )'P', 
        (char const   )'U',      (char const   )'R',      (char const   )'P',      (char const   )'O', 
        (char const   )'S',      (char const   )'E',      (char const   )'.',      (char const   )' ', 
        (char const   )' ',      (char const   )'S',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )'\n',      (char const   )'G',      (char const   )'N',      (char const   )'U', 
        (char const   )' ',      (char const   )'G',      (char const   )'e',      (char const   )'n', 
        (char const   )'e',      (char const   )'r',      (char const   )'a',      (char const   )'l', 
        (char const   )' ',      (char const   )'P',      (char const   )'u',      (char const   )'b', 
        (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )' ', 
        (char const   )'L',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'t', 
        (char const   )'a',      (char const   )'i',      (char const   )'l',      (char const   )'s', 
        (char const   )'.',      (char const   )'\n',      (char const   )'\n',      (char const   )'\000'};
#line 868 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static char const   blurb_part3[134]  = 
#line 868
  {      (char const   )'Y',      (char const   )'o',      (char const   )'u',      (char const   )' ', 
        (char const   )'s',      (char const   )'h',      (char const   )'o',      (char const   )'u', 
        (char const   )'l',      (char const   )'d',      (char const   )' ',      (char const   )'h', 
        (char const   )'a',      (char const   )'v',      (char const   )'e',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'i',      (char const   )'v',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'a',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'G', 
        (char const   )'N',      (char const   )'U',      (char const   )' ',      (char const   )'G', 
        (char const   )'e',      (char const   )'n',      (char const   )'e',      (char const   )'r', 
        (char const   )'a',      (char const   )'l',      (char const   )' ',      (char const   )'P', 
        (char const   )'u',      (char const   )'b',      (char const   )'l',      (char const   )'i', 
        (char const   )'c',      (char const   )' ',      (char const   )'L',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'e',      (char const   )'\n',      (char const   )'a',      (char const   )'l', 
        (char const   )'o',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'w',      (char const   )'i',      (char const   )'t',      (char const   )'h', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'p',      (char const   )'r', 
        (char const   )'o',      (char const   )'g',      (char const   )'r',      (char const   )'a', 
        (char const   )'m',      (char const   )'.',      (char const   )' ',      (char const   )'I', 
        (char const   )'f',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )',',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'e',      (char const   )' ',      (char const   )'h', 
        (char const   )'t',      (char const   )'t',      (char const   )'p',      (char const   )':', 
        (char const   )'/',      (char const   )'/',      (char const   )'w',      (char const   )'w', 
        (char const   )'w',      (char const   )'.',      (char const   )'g',      (char const   )'n', 
        (char const   )'u',      (char const   )'.',      (char const   )'o',      (char const   )'r', 
        (char const   )'g',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'e',      (char const   )'s',      (char const   )'/',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\000'};
#line 851
static  __attribute__((__noreturn__)) void copyleft(void) ;
#line 851 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void copyleft(void) 
{ 
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp8 ;

  {
  {
#line 873
  tmp___1 = gettext(blurb_part1);
#line 873
  printf((char const   */* __restrict  */)tmp___1, 2013);
#line 874
  tmp___2 = gettext(blurb_part2);
#line 874
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
#line 875
  tmp___3 = gettext(blurb_part3);
#line 875
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)stdout);
#line 876
  fflush(stdout);
#line 878
  tmp___7 = ferror(stdout);
  }
#line 878
  if (tmp___7) {
    {
#line 879
    tmp___4 = __errno_location();
#line 879
    tmp___5 = strerror(*tmp___4);
#line 879
    tmp___6 = gettext("error writing standard output (%s)");
#line 879
    warning((char const   *)tmp___6, tmp___5);
#line 880
    exit(1);
    }
  }
  {
#line 883
  exit(0);
  }
}
}
#line 888 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void cmdline_fs(char *str ) 
{ 
  NODE **tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 893
  tmp___1 = & FS_node->sub.nodep.l.lptr;
#line 894
  unref(*tmp___1);
  }
#line 902
  if ((int )*(str + 0) == 116) {
#line 902
    if ((int )*(str + 1) == 0) {
#line 903
      if (do_flags & 3) {
        {
#line 904
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 904);
#line 904
        tmp___2 = gettext("-Ft does not set FS to tab in POSIX awk");
#line 904
        (*lintfunc)((char const   *)tmp___2);
        }
      }
#line 905
      if (do_flags & 8) {
#line 905
        if (! (do_flags & 16)) {
#line 906
          *(str + 0) = (char )'\t';
        }
      }
    }
  }
  {
#line 909
  tmp___3 = strlen((char const   *)str);
#line 909
  *tmp___1 = make_str_node((char const   *)str, tmp___3, 1);
#line 910
  set_FS();
  }
#line 911
  return;
}
}
#line 915 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void init_args(int argc0 , int argc , char const   *argv0 , char **argv ) 
{ 
  int i___0 ;
  int j ;
  NODE **aptr ;
  NODE *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 922
  tmp___2 = estrdup("ARGV", (size_t )4);
#line 922
  ARGV_node = install_symbol(tmp___2, (NODETYPE )5);
#line 923
  tmp___1 = (*make_number)(0.0);
#line 924
  aptr = (*(*(ARGV_node->sub.nodep.l.lp + 3)))(ARGV_node, tmp___1);
#line 925
  unref(tmp___1);
#line 926
  unref(*aptr);
#line 927
  tmp___3 = strlen(argv0);
#line 927
  *aptr = make_str_node(argv0, tmp___3, 0);
#line 928
  (*aptr)->flags |= 32U;
#line 929
  i___0 = argc0;
#line 929
  j = 1;
  }
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 929
    if (! (i___0 < argc)) {
#line 929
      goto while_break;
    }
    {
#line 930
    tmp___1 = (*make_number)((double )j);
#line 931
    aptr = (*(*(ARGV_node->sub.nodep.l.lp + 3)))(ARGV_node, tmp___1);
#line 932
    unref(tmp___1);
#line 933
    unref(*aptr);
#line 934
    tmp___4 = strlen((char const   *)*(argv + i___0));
#line 934
    *aptr = make_str_node((char const   *)*(argv + i___0), tmp___4, 0);
#line 935
    (*aptr)->flags |= 32U;
#line 929
    i___0 ++;
#line 929
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 938
  tmp___5 = estrdup("ARGC", (size_t )4);
#line 938
  ARGC_node = install_symbol(tmp___5, (NODETYPE )4);
#line 939
  ARGC_node->sub.nodep.l.lptr = (*make_number)((double )j);
  }
#line 940
  return;
}
}
#line 965 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static struct varinit  const  varinit[29]  = 
#line 965
  {      {(NODE **)((void *)0), "ARGC", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      (void (*)(void))((void *)0), (_Bool)0, 1}, 
        {& ARGIND_node, "ARGIND", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      (void (*)(void))((void *)0), (_Bool)0, 2}, 
        {(NODE **)((void *)0), "ARGV", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      (void (*)(void))((void *)0), (_Bool)0, 1}, 
        {& BINMODE_node, "BINMODE", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      & set_BINMODE, (_Bool)0, 2}, 
        {& CONVFMT_node, "CONVFMT", "%.6g", (double )0, (void (*)(void))((void *)0),
      & set_CONVFMT, (_Bool)1, 0}, 
        {(NODE **)((void *)0), "ENVIRON", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      (void (*)(void))((void *)0), (_Bool)0, 1}, 
        {& ERRNO_node, "ERRNO", "", (double )0, (void (*)(void))((void *)0), (void (*)(void))((void *)0),
      (_Bool)0, 2}, 
        {& FIELDWIDTHS_node, "FIELDWIDTHS", "", (double )0, (void (*)(void))((void *)0),
      & set_FIELDWIDTHS, (_Bool)0, 2}, 
        {& FILENAME_node, "FILENAME", "", (double )0, (void (*)(void))((void *)0), (void (*)(void))((void *)0),
      (_Bool)0, 0}, 
        {& FNR_node, "FNR", (char const   *)((void *)0), (double )0, & update_FNR, & set_FNR,
      (_Bool)1, 0}, 
        {& FS_node, "FS", " ", (double )0, (void (*)(void))((void *)0), & set_FS, (_Bool)0,
      0}, 
        {& FPAT_node, "FPAT", "[^[:space:]]+", (double )0, (void (*)(void))((void *)0),
      & set_FPAT, (_Bool)0, 2}, 
        {& IGNORECASE_node, "IGNORECASE", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      & set_IGNORECASE, (_Bool)0, 2}, 
        {& LINT_node, "LINT", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      & set_LINT, (_Bool)0, 2}, 
        {& PREC_node, "PREC", (char const   *)((void *)0), (double )53, (void (*)(void))((void *)0),
      & set_PREC, (_Bool)0, 2}, 
        {& NF_node, "NF", (char const   *)((void *)0), (double )-1, & update_NF, & set_NF,
      (_Bool)0, 0}, 
        {& NR_node, "NR", (char const   *)((void *)0), (double )0, & update_NR, & set_NR,
      (_Bool)1, 0}, 
        {& OFMT_node, "OFMT", "%.6g", (double )0, (void (*)(void))((void *)0), & set_OFMT,
      (_Bool)1, 0}, 
        {& OFS_node, "OFS", " ", (double )0, (void (*)(void))((void *)0), & set_OFS,
      (_Bool)1, 0}, 
        {& ORS_node, "ORS", "\n", (double )0, (void (*)(void))((void *)0), & set_ORS,
      (_Bool)1, 0}, 
        {(NODE **)((void *)0), "PROCINFO", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      (void (*)(void))((void *)0), (_Bool)0, 7}, 
        {& RLENGTH_node, "RLENGTH", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      (void (*)(void))((void *)0), (_Bool)0, 0}, 
        {& ROUNDMODE_node, "ROUNDMODE", "N", (double )0, (void (*)(void))((void *)0),
      & set_ROUNDMODE, (_Bool)0, 2}, 
        {& RS_node, "RS", "\n", (double )0, (void (*)(void))((void *)0), & set_RS, (_Bool)1,
      0}, 
        {& RSTART_node, "RSTART", (char const   *)((void *)0), (double )0, (void (*)(void))((void *)0),
      (void (*)(void))((void *)0), (_Bool)0, 0}, 
        {& RT_node, "RT", "", (double )0, (void (*)(void))((void *)0), (void (*)(void))((void *)0),
      (_Bool)0, 2}, 
        {& SUBSEP_node, "SUBSEP", "\034", (double )0, (void (*)(void))((void *)0), & set_SUBSEP,
      (_Bool)1, 0}, 
        {& TEXTDOMAIN_node, "TEXTDOMAIN", "messages", (double )0, (void (*)(void))((void *)0),
      & set_TEXTDOMAIN, (_Bool)1, 2}, 
        {(NODE **)0, (char const   *)((void *)0), (char const   *)((void *)0), (double )0,
      (void (*)(void))((void *)0), (void (*)(void))((void *)0), (_Bool)0, 0}};
#line 999 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void init_vars(void) 
{ 
  struct varinit  const  *vp ;
  NODE *n ;
  NODE *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1005
  vp = varinit;
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1005
    if (! ((unsigned long )vp->name != (unsigned long )((void *)0))) {
#line 1005
      goto while_break;
    }
#line 1006
    if ((vp->flags & 1) != 0) {
#line 1007
      goto __Cont;
    }
    {
#line 1008
    tmp___2 = strlen((char const   *)vp->name);
#line 1008
    tmp___3 = estrdup((char const   *)vp->name, tmp___2);
#line 1008
    tmp___1 = install_symbol(tmp___3, (NODETYPE )4);
#line 1008
    *(vp->spec) = tmp___1;
#line 1008
    n = tmp___1;
    }
#line 1009
    if ((unsigned long )vp->strval != (unsigned long )((void *)0)) {
      {
#line 1010
      tmp___4 = strlen((char const   *)vp->strval);
#line 1010
      n->sub.nodep.l.lptr = make_str_node((char const   *)vp->strval, tmp___4, 0);
      }
    } else {
      {
#line 1012
      n->sub.nodep.l.lptr = (*make_number)((double )vp->numval);
      }
    }
#line 1013
    n->sub.nodep.x.aptr = (void (*)(void))vp->assign;
#line 1014
    n->sub.nodep.r.uptr = (void (*)(void))vp->update;
#line 1015
    if (vp->do_assign) {
      {
#line 1016
      (*(vp->assign))();
      }
    }
    __Cont: /* CIL Label */ 
#line 1005
    vp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1020
  if (! (do_flags & 8)) {
    {
#line 1021
    register_deferred_variable("PROCINFO", & load_procinfo);
    }
  }
  {
#line 1022
  register_deferred_variable("ENVIRON", & load_environ);
  }
#line 1023
  return;
}
}
#line 1027 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void path_environ(char const   *pname , char const   *dflt ) 
{ 
  char const   *val ;
  NODE **aptr ;
  NODE *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  NODE *tmp___5 ;

  {
  {
#line 1034
  tmp___2 = strlen(pname);
#line 1034
  tmp___1 = make_str_node(pname, tmp___2, 0);
#line 1035
  tmp___5 = in_array(ENVIRON_node, tmp___1);
  }
#line 1035
  if (! tmp___5) {
    {
#line 1040
    tmp___3 = getenv(pname);
#line 1040
    val = (char const   *)tmp___3;
    }
#line 1041
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1042
      val = dflt;
    }
    {
#line 1043
    aptr = (*(*(ENVIRON_node->sub.nodep.l.lp + 3)))(ENVIRON_node, tmp___1);
#line 1044
    unref(*aptr);
#line 1045
    tmp___4 = strlen(val);
#line 1045
    *aptr = make_str_node(val, tmp___4, 0);
    }
  }
  {
#line 1047
  unref(tmp___1);
  }
#line 1048
  return;
}
}
#line 1062 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static _Bool been_here  =    (_Bool)0;
#line 1071 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static char nullstr[1]  = {      (char )'\000'};
#line 1052 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static NODE *load_environ(void) 
{ 
  char *var ;
  char *val ;
  NODE **aptr ;
  int i___0 ;
  NODE *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1064
  if (been_here) {
#line 1065
    return (ENVIRON_node);
  }
  {
#line 1067
  been_here = (_Bool)1;
#line 1069
  tmp___2 = estrdup("ENVIRON", (size_t )7);
#line 1069
  ENVIRON_node = install_symbol(tmp___2, (NODETYPE )5);
#line 1070
  i___0 = 0;
  }
  {
#line 1070
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1070
    if (! ((unsigned long )*(environ + i___0) != (unsigned long )((void *)0))) {
#line 1070
      goto while_break;
    }
    {
#line 1073
    var = *(environ + i___0);
#line 1074
    val = strchr((char const   *)var, '=');
    }
#line 1075
    if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 1076
      tmp___3 = val;
#line 1076
      val ++;
#line 1076
      *tmp___3 = (char )'\000';
    } else {
#line 1078
      val = nullstr;
    }
    {
#line 1079
    tmp___4 = strlen((char const   *)var);
#line 1079
    tmp___1 = make_str_node((char const   *)var, tmp___4, 0);
#line 1080
    aptr = (*(*(ENVIRON_node->sub.nodep.l.lp + 3)))(ENVIRON_node, tmp___1);
#line 1081
    unref(tmp___1);
#line 1082
    unref(*aptr);
#line 1083
    tmp___5 = strlen((char const   *)val);
#line 1083
    *aptr = make_str_node((char const   *)val, tmp___5, 0);
#line 1084
    (*aptr)->flags |= 32U;
    }
#line 1087
    if ((unsigned long )val != (unsigned long )(nullstr)) {
#line 1088
      val --;
#line 1088
      *val = (char )'=';
    }
#line 1070
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1094
  path_environ("AWKPATH", (char const   *)defpath);
#line 1095
  path_environ("AWKLIBPATH", (char const   *)deflibpath);
  }
#line 1096
  return (ENVIRON_node);
}
}
#line 1111 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static _Bool been_here___0  =    (_Bool)0;
#line 1101 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static NODE *load_procinfo(void) 
{ 
  int i___0 ;
  char name[100] ;
  double value ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  __pid_t tmp___3 ;
  __pid_t tmp___4 ;
  __pid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  __gid_t tmp___8 ;
  __gid_t tmp___9 ;
  field_sep_type tmp___10 ;
  field_sep_type tmp___11 ;
  char *tmp___12 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 1113
  if (been_here___0) {
#line 1114
    return (PROCINFO_node);
  }
  {
#line 1116
  been_here___0 = (_Bool)1;
#line 1118
  tmp___1 = estrdup("PROCINFO", (size_t )8);
#line 1118
  PROCINFO_node = install_symbol(tmp___1, (NODETYPE )5);
#line 1120
  update_PROCINFO_str("version", "4.1.0");
#line 1121
  update_PROCINFO_str("strftime", def_strftime_format);
#line 1124
  tmp___2 = mpfr_get_version();
#line 1124
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"GNU MPFR %s",
          tmp___2);
#line 1125
  update_PROCINFO_str("mpfr_version", (char const   *)(name));
#line 1126
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"GNU MP %s",
          __gmp_version);
#line 1127
  update_PROCINFO_str("gmp_version", (char const   *)(name));
#line 1128
  update_PROCINFO_num("prec_max", (double )(0xffffffffffffffffUL >> 1));
#line 1129
  update_PROCINFO_num("prec_min", (double )2);
#line 1133
  update_PROCINFO_num("api_major", (double )1);
#line 1134
  update_PROCINFO_num("api_minor", (double )0);
#line 1143
  tmp___3 = getpgrp();
#line 1143
  value = (double )tmp___3;
#line 1144
  update_PROCINFO_num("pgrpid", value);
#line 1152
  tmp___4 = getpid();
#line 1152
  value = (double )tmp___4;
#line 1153
  update_PROCINFO_num("pid", value);
#line 1155
  tmp___5 = getppid();
#line 1155
  value = (double )tmp___5;
#line 1156
  update_PROCINFO_num("ppid", value);
#line 1158
  tmp___6 = getuid();
#line 1158
  value = (double )tmp___6;
#line 1159
  update_PROCINFO_num("uid", value);
#line 1161
  tmp___7 = geteuid();
#line 1161
  value = (double )tmp___7;
#line 1162
  update_PROCINFO_num("euid", value);
#line 1164
  tmp___8 = getgid();
#line 1164
  value = (double )tmp___8;
#line 1165
  update_PROCINFO_num("gid", value);
#line 1167
  tmp___9 = getegid();
#line 1167
  value = (double )tmp___9;
#line 1168
  update_PROCINFO_num("egid", value);
#line 1170
  tmp___10 = current_field_sep();
  }
  {
#line 1171
  if ((unsigned int )tmp___10 == 1U) {
#line 1171
    goto case_1;
  }
#line 1174
  if ((unsigned int )tmp___10 == 2U) {
#line 1174
    goto case_2;
  }
#line 1177
  if ((unsigned int )tmp___10 == 0U) {
#line 1177
    goto case_0;
  }
#line 1180
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1172
  update_PROCINFO_str("FS", "FIELDWIDTHS");
  }
#line 1173
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1175
  update_PROCINFO_str("FS", "FPAT");
  }
#line 1176
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1178
  update_PROCINFO_str("FS", "FS");
  }
#line 1179
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1181
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1181);
#line 1181
  tmp___11 = current_field_sep();
#line 1181
  tmp___12 = gettext("unknown value for field spec: %d\n");
#line 1181
  r_fatal((char const   *)tmp___12, (unsigned int )tmp___11);
  }
#line 1183
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1188
  i___0 = 0;
  {
#line 1188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1188
    if (! (i___0 < ngroups)) {
#line 1188
      goto while_break;
    }
    {
#line 1189
    sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"group%d",
            i___0 + 1);
#line 1190
    value = (double )*(groupset + i___0);
#line 1191
    update_PROCINFO_num((char const   *)(name), value);
#line 1188
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1193
  if (groupset) {
    {
#line 1194
    free((void *)groupset);
#line 1195
    groupset = (gid_t *)((void *)0);
    }
  }
#line 1198
  return (PROCINFO_node);
}
}
#line 1203 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
int is_std_var(char const   *var ) 
{ 
  struct varinit  const  *vp ;
  int tmp___1 ;

  {
#line 1208
  vp = varinit;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1208
    if (! ((unsigned long )vp->name != (unsigned long )((void *)0))) {
#line 1208
      goto while_break;
    }
    {
#line 1209
    tmp___1 = strcmp((char const   *)vp->name, var);
    }
#line 1209
    if (tmp___1 == 0) {
#line 1210
      if (do_flags & 8) {
#line 1210
        goto _L;
      } else
#line 1210
      if (do_flags & 16) {
        _L: /* CIL Label */ 
#line 1210
        if ((vp->flags & 2) != 0) {
#line 1211
          return (0);
        }
      }
#line 1213
      return (1);
    }
#line 1208
    vp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1217
  return (0);
}
}
#line 1225 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
int is_off_limits_var(char const   *var ) 
{ 
  struct varinit  const  *vp ;
  int tmp___1 ;

  {
#line 1230
  vp = varinit;
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1230
    if (! ((unsigned long )vp->name != (unsigned long )((void *)0))) {
#line 1230
      goto while_break;
    }
    {
#line 1231
    tmp___1 = strcmp((char const   *)vp->name, var);
    }
#line 1231
    if (tmp___1 == 0) {
#line 1232
      return ((vp->flags & 4) == 0);
    }
#line 1230
    vp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  return (0);
}
}
#line 1242 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
char const   *get_spec_varname(void (*fptr___0)(void) ) 
{ 
  struct varinit  const  *vp ;

  {
#line 1247
  if (! fptr___0) {
#line 1248
    return ((char const   *)((void *)0));
  }
#line 1249
  vp = varinit;
  {
#line 1249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1249
    if (! ((unsigned long )vp->name != (unsigned long )((void *)0))) {
#line 1249
      goto while_break;
    }
#line 1250
    if ((unsigned long )vp->assign == (unsigned long )fptr___0) {
#line 1251
      return ((char const   *)vp->name);
    } else
#line 1250
    if ((unsigned long )vp->update == (unsigned long )fptr___0) {
#line 1251
      return ((char const   *)vp->name);
    }
#line 1249
    vp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1253
  return ((char const   *)((void *)0));
}
}
#line 1259 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
int arg_assign(char *arg , _Bool initing ) 
{ 
  char *cp ;
  char *cp2 ;
  _Bool badvar ;
  NODE *var ;
  NODE *it ;
  NODE **lhs ;
  long save_FNR ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  NODE **tmp___11 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 1269
  if (! initing) {
#line 1269
    if (disallow_var_assigns) {
#line 1270
      return (0);
    }
  }
  {
#line 1272
  cp = strchr((char const   *)arg, '=');
  }
#line 1274
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 1275
    if (! initing) {
#line 1276
      return (0);
    }
    {
#line 1278
    tmp___1 = gettext("%s: `%s\' argument to `-v\' not in `var=value\' form\n\n");
#line 1278
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            myname, arg);
#line 1281
    usage(1, stderr);
    }
  }
  {
#line 1284
  tmp___2 = cp;
#line 1284
  cp ++;
#line 1284
  *tmp___2 = (char )'\000';
#line 1287
  source = (char *)((void *)0);
#line 1288
  sourceline = 0;
#line 1289
  save_FNR = FNR;
#line 1290
  FNR = 0L;
#line 1293
  badvar = (_Bool)0;
#line 1294
  tmp___4 = __ctype_b_loc();
  }
#line 1294
  if ((int const   )*(*tmp___4 + (int )((unsigned char )*(arg + 0))) & 1024) {
    _L: /* CIL Label */ 
#line 1297
    cp2 = arg + 1;
    {
#line 1297
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1297
      if (! *cp2) {
#line 1297
        goto while_break;
      }
      {
#line 1298
      tmp___3 = __ctype_b_loc();
      }
#line 1298
      if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*cp2)) & 8)) {
#line 1298
        if ((int )*cp2 != 95) {
#line 1299
          badvar = (_Bool)1;
#line 1300
          goto while_break;
        }
      }
#line 1297
      cp2 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1294
  if ((int )*(arg + 0) != 95) {
#line 1295
    badvar = (_Bool)1;
  } else {
#line 1294
    goto _L;
  }
#line 1303
  if (badvar) {
#line 1304
    if (initing) {
      {
#line 1305
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1305);
#line 1305
      tmp___5 = gettext("`%s\' is not a legal variable name");
#line 1305
      r_fatal((char const   *)tmp___5, arg);
      }
    }
#line 1307
    if (do_flags & 3) {
      {
#line 1308
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1308);
#line 1308
      tmp___6 = gettext("`%s\' is not a variable name, looking for file `%s=%s\'");
#line 1308
      (*lintfunc)((char const   *)tmp___6, arg, arg, cp);
      }
    }
  } else {
    {
#line 1311
    tmp___8 = check_special((char const   *)arg);
    }
#line 1311
    if (tmp___8 >= 0) {
      {
#line 1312
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1312);
#line 1312
      tmp___7 = gettext("cannot use gawk builtin `%s\' as variable name");
#line 1312
      r_fatal((char const   *)tmp___7, arg);
      }
    }
#line 1314
    if (! initing) {
      {
#line 1315
      var = lookup((char const   *)arg);
      }
#line 1316
      if ((unsigned long )var != (unsigned long )((void *)0)) {
#line 1316
        if ((unsigned int )var->type == 8U) {
          {
#line 1317
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1317);
#line 1317
          tmp___9 = gettext("cannot use function `%s\' as variable name");
#line 1317
          r_fatal((char const   *)tmp___9, arg);
          }
        }
      }
    }
    {
#line 1324
    tmp___10 = strlen((char const   *)cp);
#line 1324
    it = make_str_node((char const   *)cp, tmp___10, 1);
#line 1325
    it->flags |= 32U;
    }
#line 1330
    if (do_flags & 16) {
      {
#line 1331
      setlocale(1, "C");
      }
    }
    {
#line 1332
    force_number(it);
    }
#line 1333
    if (do_flags & 16) {
      {
#line 1334
      setlocale(1, "");
      }
    }
    {
#line 1343
    cp2 = estrdup((char const   *)arg, (size_t )(cp - arg));
#line 1345
    var = variable(0, cp2, (NODETYPE )4);
    }
#line 1346
    if ((unsigned long )var == (unsigned long )((void *)0)) {
      {
#line 1347
      final_exit(2);
      }
    }
#line 1348
    if ((unsigned int )var->type == 4U) {
#line 1348
      if (var->sub.nodep.r.uptr) {
        {
#line 1349
        (*(var->sub.nodep.r.uptr))();
        }
      }
    }
#line 1350
    if ((unsigned int )var->type == 4U) {
#line 1350
      if (! ((unsigned long )var->sub.nodep.l.lptr == (unsigned long )Nnull_string)) {
#line 1350
        lhs = & var->sub.nodep.l.lptr;
      } else {
        {
#line 1350
        tmp___11 = r_get_lhs(var, (_Bool)0);
#line 1350
        lhs = tmp___11;
        }
      }
    } else {
      {
#line 1350
      tmp___11 = r_get_lhs(var, (_Bool)0);
#line 1350
      lhs = tmp___11;
      }
    }
    {
#line 1351
    unref(*lhs);
#line 1352
    *lhs = it;
    }
#line 1354
    if ((unsigned int )var->type == 4U) {
#line 1354
      if (var->sub.nodep.x.aptr) {
        {
#line 1355
        (*(var->sub.nodep.x.aptr))();
        }
      }
    }
  }
#line 1358
  if (! initing) {
#line 1359
    cp --;
#line 1359
    *cp = (char )'=';
  }
#line 1360
  FNR = save_FNR;
#line 1361
  return (! badvar);
}
}
#line 1366 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void catchsig(int sig ) 
{ 
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1369
  if (sig == 8) {
    {
#line 1370
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1370);
#line 1370
    tmp___1 = gettext("floating point exception");
#line 1370
    r_fatal((char const   *)tmp___1);
    }
  } else
#line 1371
  if (sig == 11) {
    {
#line 1376
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1376);
#line 1377
    tmp___2 = gettext("fatal error: internal error");
#line 1377
    msg((char const   *)tmp___2);
#line 1379
    abort();
    }
  } else
#line 1371
  if (sig == 7) {
    {
#line 1376
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1376);
#line 1377
    tmp___2 = gettext("fatal error: internal error");
#line 1377
    msg((char const   *)tmp___2);
#line 1379
    abort();
    }
  } else {
    {
#line 1381
    r_fatal("internal error line %d, file: %s", 1381, "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c");
    }
  }
#line 1383
  return;
}
}
#line 1388 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static int catchsegv(void *fault_address , int serious ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1391
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1391);
#line 1392
  tmp___1 = gettext("fatal error: internal error: segfault");
#line 1392
  msg((char const   *)tmp___1);
#line 1393
  abort();
  }
#line 1395
  return (0);
}
}
#line 1400 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void catchstackoverflow(int emergency , stackoverflow_context_t scp ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1403
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1403);
#line 1404
  tmp___1 = gettext("fatal error: internal error: stack overflow");
#line 1404
  msg((char const   *)tmp___1);
#line 1405
  abort();
  }
#line 1407
  return;
}
}
#line 1413
static  __attribute__((__noreturn__)) void nostalgia(void) ;
#line 1413 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void nostalgia(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1420
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"awk: bailing out near line 1\n");
#line 1421
  fflush(stderr);
#line 1422
  abort();
  }
}
}
#line 1427
static  __attribute__((__noreturn__)) void version(void) ;
#line 1427 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void version(void) 
{ 
  char const   *tmp___1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1430
  printf((char const   */* __restrict  */)"%s", version_string);
#line 1432
  printf((char const   */* __restrict  */)", API: %d.%d", 1, 0);
#line 1435
  tmp___1 = mpfr_get_version();
#line 1435
  printf((char const   */* __restrict  */)" (GNU MPFR %s, GNU MP %s)", tmp___1, __gmp_version);
#line 1437
  printf((char const   */* __restrict  */)"\n");
#line 1438
  print_ext_versions();
#line 1444
  copyleft();
#line 1445
  exit(0);
  }
}
}
#line 1450 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void init_fds(void) 
{ 
  struct stat sbuf ;
  int fd ;
  int newfd ;
  char const   *opposite_mode[3] ;
  int tmp___1 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1456
  opposite_mode[0] = "w";
#line 1456
  opposite_mode[1] = "r";
#line 1456
  opposite_mode[2] = "r";
#line 1459
  fd = 0;
  {
#line 1459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1459
    if (! (fd <= 2)) {
#line 1459
      goto while_break;
    }
    {
#line 1460
    tmp___1 = fstat(fd, & sbuf);
    }
#line 1460
    if (tmp___1 < 0) {
      {
#line 1465
      newfd = devopen("/dev/null", opposite_mode[fd]);
#line 1467
      newfd = newfd;
      }
    }
#line 1459
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1474
  return;
}
}
#line 1478 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void init_groupset(void) 
{ 
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1490
  ngroups = getgroups(0, (__gid_t *)((void *)0));
  }
#line 1493
  if (ngroups <= 0) {
#line 1494
    return;
  }
  {
#line 1497
  tmp___1 = malloc((unsigned long )ngroups * sizeof(gid_t ));
#line 1497
  groupset = (gid_t *)tmp___1;
  }
#line 1497
  if (groupset) {
#line 1497
    tmp___5 = 1;
  } else {
    {
#line 1497
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1497);
#line 1497
    tmp___2 = __errno_location();
#line 1497
    tmp___3 = strerror(*tmp___2);
#line 1497
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1497
    r_fatal((char const   *)tmp___4, "init_groupset", "groupset", (long )((unsigned long )ngroups * sizeof(gid_t )),
            tmp___3);
#line 1497
    tmp___5 = 0;
    }
  }
  {
#line 1499
  ngroups = getgroups(ngroups, groupset);
  }
#line 1501
  if (ngroups == -1) {
    {
#line 1502
    free((void *)groupset);
#line 1503
    ngroups = 0;
#line 1504
    groupset = (gid_t *)((void *)0);
    }
  }
#line 1507
  return;
}
}
#line 1511 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
char *estrdup(char const   *str , size_t len ) 
{ 
  char *s___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1515
  tmp___1 = malloc(len + 1UL);
#line 1515
  s___0 = (char *)tmp___1;
  }
#line 1515
  if (s___0) {
#line 1515
    tmp___5 = 1;
  } else {
    {
#line 1515
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1515);
#line 1515
    tmp___2 = __errno_location();
#line 1515
    tmp___3 = strerror(*tmp___2);
#line 1515
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1515
    r_fatal((char const   *)tmp___4, "estrdup", "s", (long )(len + 1UL), tmp___3);
#line 1515
    tmp___5 = 0;
    }
  }
  {
#line 1516
  memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)str, len);
#line 1517
  *(s___0 + len) = (char )'\000';
  }
#line 1518
  return (s___0);
}
}
#line 1533 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void init_locale(struct lconv *l ) 
{ 
  struct lconv *t ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 1538
  t = localeconv();
#line 1539
  *l = *t;
#line 1540
  tmp___1 = strlen((char const   *)t->thousands_sep);
#line 1540
  l->thousands_sep = estrdup((char const   *)t->thousands_sep, tmp___1);
#line 1541
  tmp___2 = strlen((char const   *)t->decimal_point);
#line 1541
  l->decimal_point = estrdup((char const   *)t->decimal_point, tmp___2);
#line 1542
  tmp___3 = strlen((char const   *)t->grouping);
#line 1542
  l->grouping = estrdup((char const   *)t->grouping, tmp___3);
#line 1543
  tmp___4 = strlen((char const   *)t->int_curr_symbol);
#line 1543
  l->int_curr_symbol = estrdup((char const   *)t->int_curr_symbol, tmp___4);
#line 1544
  tmp___5 = strlen((char const   *)t->currency_symbol);
#line 1544
  l->currency_symbol = estrdup((char const   *)t->currency_symbol, tmp___5);
#line 1545
  tmp___6 = strlen((char const   *)t->mon_decimal_point);
#line 1545
  l->mon_decimal_point = estrdup((char const   *)t->mon_decimal_point, tmp___6);
#line 1546
  tmp___7 = strlen((char const   *)t->mon_thousands_sep);
#line 1546
  l->mon_thousands_sep = estrdup((char const   *)t->mon_thousands_sep, tmp___7);
#line 1547
  tmp___8 = strlen((char const   *)t->mon_grouping);
#line 1547
  l->mon_grouping = estrdup((char const   *)t->mon_grouping, tmp___8);
#line 1548
  tmp___9 = strlen((char const   *)t->positive_sign);
#line 1548
  l->positive_sign = estrdup((char const   *)t->positive_sign, tmp___9);
#line 1549
  tmp___10 = strlen((char const   *)t->negative_sign);
#line 1549
  l->negative_sign = estrdup((char const   *)t->negative_sign, tmp___10);
  }
#line 1550
  return;
}
}
#line 1555 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
static void save_argv(int argc , char **argv ) 
{ 
  int i___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1560
  tmp___1 = malloc((unsigned long )(argc + 1) * sizeof(char *));
#line 1560
  d_argv = (char **)tmp___1;
  }
#line 1560
  if (d_argv) {
#line 1560
    tmp___5 = 1;
  } else {
    {
#line 1560
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c", 1560);
#line 1560
    tmp___2 = __errno_location();
#line 1560
    tmp___3 = strerror(*tmp___2);
#line 1560
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1560
    r_fatal((char const   *)tmp___4, "save_argv", "d_argv", (long )((unsigned long )(argc + 1) * sizeof(char *)),
            tmp___3);
#line 1560
    tmp___5 = 0;
    }
  }
#line 1561
  i___0 = 0;
  {
#line 1561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1561
    if (! (i___0 < argc)) {
#line 1561
      goto while_break;
    }
    {
#line 1562
    tmp___6 = strlen((char const   *)*(argv + i___0));
#line 1562
    *(d_argv + i___0) = estrdup((char const   *)*(argv + i___0), tmp___6);
#line 1561
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1563
  *(d_argv + argc) = (char *)((void *)0);
#line 1564
  return;
}
}
#line 1573 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
void update_global_values(void) 
{ 
  struct varinit  const  *vp ;

  {
#line 1578
  vp = varinit;
  {
#line 1578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1578
    if (! vp->name) {
#line 1578
      goto while_break;
    }
#line 1579
    if ((unsigned long )vp->update != (unsigned long )((void *)0)) {
      {
#line 1580
      (*(vp->update))();
      }
    }
#line 1578
    vp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1582
  return;
}
}
#line 1586 "/home/wslee/gnu_benchmarks/gawk-4.1.0/main.c"
long getenv_long(char const   *name ) 
{ 
  char const   *val ;
  long newval ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 1591
  tmp___2 = getenv(name);
#line 1591
  val = (char const   *)tmp___2;
  }
#line 1591
  if ((unsigned long )val != (unsigned long )((void *)0)) {
    {
#line 1591
    tmp___3 = __ctype_b_loc();
    }
#line 1591
    if ((int const   )*(*tmp___3 + (int )((unsigned char )*val)) & 2048) {
#line 1592
      newval = 0L;
      {
#line 1592
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1592
        if (*val) {
          {
#line 1592
          tmp___1 = __ctype_b_loc();
          }
#line 1592
          if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*val)) & 2048)) {
#line 1592
            goto while_break;
          }
        } else {
#line 1592
          goto while_break;
        }
#line 1593
        newval = (newval * 10L + (long )*val) - 48L;
#line 1592
        val ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1594
      return (newval);
    }
  }
#line 1596
  return (-1L);
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 852
extern int pclose(FILE *__stream ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 126 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 188
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 907 "/usr/include/stdlib.h"
extern int posix_openpt(int __oflag ) ;
#line 915
extern  __attribute__((__nothrow__)) int grantpt(int __fd ) ;
#line 919
extern  __attribute__((__nothrow__)) int unlockpt(int __fd ) ;
#line 924
extern  __attribute__((__nothrow__)) char *ptsname(int __fd ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 73
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 350
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 414
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 456
extern int usleep(__useconds_t __useconds ) ;
#line 507
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 526
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 568
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execl)(char const   *__path ,
                                                                                  char const   *__arg 
                                                                                  , ...) ;
#line 598
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 684
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 1031 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
_Bool RS_is_null  ;
#line 1049
NODE **fields_arr ;
#line 1143
char envsep ;
#line 1434
void update_ERRNO_int(int errcode ) ;
#line 1435
void update_ERRNO_string(char const   *string ) ;
#line 1440
char const   *redflags2str(int flags___0 ) ;
#line 1467
void set_record(char const   *buf___7 , int cnt ) ;
#line 1498
int os_devopen(char const   *name , int flag ) ;
#line 1499
void os_close_on_exec(int fd , char const   *name , char const   *what , char const   *dir ) ;
#line 1502
int os_isreadable(awk_input_buf_t const   *iobuf , _Bool *isdir ) ;
#line 1505
void os_restore_mode(int fd ) ;
#line 1506
size_t optimal_bufsize(int fd , struct stat *stb ) ;
#line 1507
int ispath(char const   *file ) ;
#line 1508
int isdirpunct(int c ) ;
#line 1512
void register_input_parser(awk_input_parser_t *input_parser ) ;
#line 1513
void register_output_wrapper(awk_output_wrapper_t *wrapper ) ;
#line 1514
void register_two_way_processor(awk_two_way_processor_t *processor ) ;
#line 1518
struct redirect *redirect(NODE *redir_exp , int redirtype , int *errflg ) ;
#line 1519
NODE *do_close(int nargs ) ;
#line 1520
int flush_io(void) ;
#line 1521
int close_io(_Bool *stdio_problem ) ;
#line 1523
int srcopen(SRCFILE *s___0 ) ;
#line 1524
char *find_source(char const   *src , struct stat *stb , int *errcode , int is_extlib ) ;
#line 1525
NODE *do_getline_redir(int into_variable , enum redirval redirtype ) ;
#line 1526
NODE *do_getline(int into_variable , IOBUF *iop ) ;
#line 1527
struct redirect *getredirect(char const   *str , int len ) ;
#line 1528
int inrec(IOBUF *iop , int *errcode ) ;
#line 1529
int nextfile(IOBUF **curfile___0 , _Bool skipping ) ;
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 166
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 197
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 204
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 232
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 638 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 644
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 206 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int iop_close(IOBUF *iop ) ;
#line 208
static void close_one(void) ;
#line 209
static int close_redir(struct redirect *rp , _Bool exitwarn , two_way_close_type how ) ;
#line 211
static int wait_any(int interesting ) ;
#line 213
static IOBUF *gawk_popen(char const   *cmd , struct redirect *rp ) ;
#line 214
static IOBUF *iop_alloc(int fd , char const   *name , int errno_val ) ;
#line 215
static IOBUF *iop_finish(IOBUF *iop ) ;
#line 216
static int gawk_pclose(struct redirect *rp ) ;
#line 217
static int str2mode(char const   *mode ) ;
#line 218
static int two_way_open(char const   *str , struct redirect *rp ) ;
#line 219
static int pty_vs_pipe(char const   *command ) ;
#line 220
static void find_input_parser(IOBUF *iop ) ;
#line 221
static _Bool find_output_wrapper(awk_output_buf_t *outbuf ) ;
#line 222
static void init_output_wrapper(awk_output_buf_t *outbuf ) ;
#line 223
static _Bool find_two_way_processor(char const   *name , struct redirect *rp ) ;
#line 225
static RECVALUE rs1scan(IOBUF *iop , struct recmatch *recm , SCANSTATE *state___2 ) ;
#line 226
static RECVALUE rsnullscan(IOBUF *iop , struct recmatch *recm , SCANSTATE *state___2 ) ;
#line 227
static RECVALUE rsrescan(IOBUF *iop , struct recmatch *recm , SCANSTATE *state___2 ) ;
#line 229 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static RECVALUE (*matchrec)(IOBUF *iop , struct recmatch *recm , SCANSTATE *state )  =    & rs1scan;
#line 231
static int get_a_record(char **out , IOBUF *iop , int *errcode ) ;
#line 233
static void free_rp(struct redirect *rp ) ;
#line 234
static int inetfile(char const   *str , int *length , int *family ) ;
#line 236
static NODE *in_PROCINFO(char const   *pidx1 , char const   *pidx2 , NODE **full_idx___0 ) ;
#line 237
static long get_read_timeout(IOBUF *iop ) ;
#line 238
static ssize_t read_with_timeout(int fd , char *buf___7 , size_t size ) ;
#line 240 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static _Bool read_can_timeout  =    (_Bool)0;
#line 241 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static long read_timeout  ;
#line 242 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static long read_default_timeout  ;
#line 244 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static struct redirect *red_head  =    (struct redirect *)((void *)0);
#line 245 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static NODE *RS  =    (NODE *)((void *)0);
#line 246 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static Regexp *RS_re_yes_case  ;
#line 247 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static Regexp *RS_re_no_case  ;
#line 248 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static Regexp *RS_regexp  ;
#line 259 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
void init_io(void) 
{ 
  long tmout ;
  char *__cil_tmp2 ;

  {
  {
#line 270
  tmout = getenv_long("GAWK_READ_TIMEOUT");
  }
#line 271
  if (tmout > 0L) {
#line 272
    read_default_timeout = tmout;
#line 273
    read_can_timeout = (_Bool)1;
  }
#line 280
  if ((unsigned long )PROCINFO_node != (unsigned long )((void *)0)) {
#line 281
    read_can_timeout = (_Bool)1;
  }
#line 282
  return;
}
}
#line 319 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
void after_beginfile(IOBUF **curfile___0 ) 
{ 
  IOBUF *iop ;
  char const   *fname ;
  int errcode ;
  _Bool valid ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 324
  iop = *curfile___0;
#line 332
  find_input_parser(iop);
  }
#line 334
  if (! iop->valid) {
    {
#line 339
    fname = iop->public.name;
#line 340
    errcode = iop->errcode;
#line 341
    valid = iop->valid;
#line 342
    tmp___1 = __errno_location();
#line 342
    *tmp___1 = 0;
#line 343
    update_ERRNO_int(errcode);
#line 344
    iop_close(iop);
#line 345
    *curfile___0 = (IOBUF *)((void *)0);
    }
#line 346
    if (! valid) {
#line 346
      if (errcode == 21) {
#line 346
        if (! (do_flags & 8)) {
          {
#line 347
          tmp___2 = gettext("command line argument `%s\' is a directory: skipped");
#line 347
          warning((char const   *)tmp___2, fname);
          }
#line 348
          return;
        }
      }
    }
    {
#line 350
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 350);
#line 350
    tmp___3 = strerror(errcode);
#line 350
    tmp___4 = gettext("cannot open file `%s\' for reading (%s)");
#line 350
    r_fatal((char const   *)tmp___4, fname, tmp___3);
    }
  }
#line 353
  return;
}
}
#line 364 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static long i  =    1L;
#line 365 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static _Bool files  =    (_Bool)0;
#line 361 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
int nextfile(IOBUF **curfile___0 , _Bool skipping ) 
{ 
  NODE *arg ;
  NODE *tmp___1 ;
  char const   *fname ;
  int fd ;
  int errcode ;
  IOBUF *iop ;
  long argc ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 368
  fd = -1;
#line 369
  errcode = 0;
#line 370
  iop = *curfile___0;
#line 373
  if (skipping) {
#line 374
    errcode = 0;
#line 375
    if ((unsigned long )iop != (unsigned long )((void *)0)) {
      {
#line 376
      errcode = iop->errcode;
#line 377
      iop_close(iop);
      }
    }
#line 379
    *curfile___0 = (IOBUF *)((void *)0);
#line 380
    return (errcode == 0);
  }
#line 383
  if ((unsigned long )iop != (unsigned long )((void *)0)) {
#line 384
    if ((iop->flag & 2) != 0) {
      {
#line 386
      iop_close(iop);
#line 387
      *curfile___0 = (IOBUF *)((void *)0);
      }
#line 388
      return (1);
    } else {
#line 390
      return (0);
    }
  }
#line 393
  if ((ARGC_node->sub.nodep.l.lptr)->flags & 2048U) {
    {
#line 393
    tmp___2 = mpfr_get_si((mpfr_srcptr )((ARGC_node->sub.nodep.l.lptr)->sub.val.nm.mpnum),
                          ROUND_MODE);
#line 393
    argc = tmp___2;
    }
  } else {
#line 393
    if ((ARGC_node->sub.nodep.l.lptr)->flags & 4096U) {
      {
#line 393
      tmp___3 = __gmpz_get_si((mpz_srcptr )((ARGC_node->sub.nodep.l.lptr)->sub.val.nm.mpi));
#line 393
      tmp___4 = tmp___3;
      }
    } else {
#line 393
      tmp___4 = (long )(ARGC_node->sub.nodep.l.lptr)->sub.val.nm.fltnum;
    }
#line 393
    argc = tmp___4;
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! (i < argc)) {
#line 395
      goto while_break;
    }
    {
#line 396
    tmp___1 = (*make_number)((double )i);
#line 397
    force_string(tmp___1);
#line 398
    arg = in_array(ARGV_node, tmp___1);
#line 399
    unref(tmp___1);
    }
#line 400
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 401
      goto __Cont;
    } else
#line 400
    if (arg->sub.val.slen == 0UL) {
#line 401
      goto __Cont;
    }
    {
#line 402
    arg = force_string(arg);
#line 403
    *(arg->sub.val.sp + arg->sub.val.slen) = (char )'\000';
    }
#line 404
    if (! (do_flags & 8)) {
      {
#line 405
      unref(ARGIND_node->sub.nodep.l.lptr);
#line 406
      ARGIND_node->sub.nodep.l.lptr = (*make_number)((double )i);
      }
    }
    {
#line 409
    tmp___8 = arg_assign(arg->sub.val.sp, (_Bool)0);
    }
#line 409
    if (! tmp___8) {
      {
#line 410
      files = (_Bool)1;
#line 411
      fname = (char const   *)arg->sub.val.sp;
#line 414
      unref(FILENAME_node->sub.nodep.l.lptr);
#line 415
      FILENAME_node->sub.nodep.l.lptr = dupnode(arg);
      }
#line 417
      if (((FNR_node->sub.nodep.l.lptr)->flags & 6144U) != 0U) {
        {
#line 418
        __gmpz_set_ui(MFNR, 0UL);
        }
      }
      {
#line 420
      FNR = 0L;
#line 423
      tmp___5 = __errno_location();
#line 423
      *tmp___5 = 0;
#line 424
      fd = devopen(fname, "r");
#line 425
      tmp___6 = __errno_location();
#line 425
      errcode = *tmp___6;
      }
#line 426
      if (! (do_flags & 8)) {
        {
#line 427
        tmp___7 = __errno_location();
#line 427
        update_ERRNO_int(*tmp___7);
        }
      }
      {
#line 428
      iop = iop_alloc(fd, fname, errcode);
#line 429
      *curfile___0 = iop_finish(iop);
      }
#line 430
      if (iop->public.fd == -1) {
#line 431
        iop->errcode = errcode;
      } else
#line 432
      if (iop->valid) {
#line 433
        iop->errcode = 0;
      }
#line 435
      if (! (do_flags & 8)) {
#line 435
        if (iop->errcode != 0) {
          {
#line 436
          update_ERRNO_int(iop->errcode);
          }
        }
      }
#line 438
      i ++;
#line 438
      return ((int )i);
    }
    __Cont: /* CIL Label */ 
#line 395
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  if ((int )files == 0) {
    {
#line 443
    files = (_Bool)1;
#line 446
    tmp___9 = __errno_location();
#line 446
    *tmp___9 = 0;
    }
#line 447
    if (! (do_flags & 8)) {
      {
#line 448
      tmp___10 = __errno_location();
#line 448
      update_ERRNO_int(*tmp___10);
      }
    }
    {
#line 450
    unref(FILENAME_node->sub.nodep.l.lptr);
#line 451
    FILENAME_node->sub.nodep.l.lptr = make_str_node("-", (size_t )1, 0);
#line 452
    (FILENAME_node->sub.nodep.l.lptr)->flags |= 32U;
#line 453
    fname = "-";
#line 454
    tmp___11 = fileno(stdin);
#line 454
    iop = iop_alloc(tmp___11, fname, 0);
#line 455
    *curfile___0 = iop_finish(iop);
    }
#line 457
    if (iop->public.fd == -1) {
      {
#line 458
      tmp___12 = __errno_location();
#line 458
      errcode = *tmp___12;
#line 459
      tmp___13 = __errno_location();
#line 459
      *tmp___13 = 0;
#line 460
      tmp___14 = __errno_location();
#line 460
      update_ERRNO_int(*tmp___14);
#line 461
      iop_close(iop);
#line 462
      *curfile___0 = (IOBUF *)((void *)0);
#line 463
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 463);
#line 463
      tmp___15 = strerror(errcode);
#line 463
      tmp___16 = gettext("cannot open file `%s\' for reading (%s)");
#line 463
      r_fatal((char const   *)tmp___16, fname, tmp___15);
      }
    }
#line 466
    i ++;
#line 466
    return ((int )i);
  }
#line 469
  return (-1);
}
}
#line 474 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
void set_FNR(void) 
{ 
  NODE *n ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 477
  n = FNR_node->sub.nodep.l.lptr;
#line 478
  force_number(n);
  }
#line 480
  if ((n->flags & 6144U) != 0U) {
    {
#line 481
    FNR = mpg_set_var(FNR_node);
    }
  } else
#line 484
  if (n->flags & 2048U) {
    {
#line 484
    tmp___1 = mpfr_get_si((mpfr_srcptr )(n->sub.val.nm.mpnum), ROUND_MODE);
#line 484
    FNR = tmp___1;
    }
  } else {
#line 484
    if (n->flags & 4096U) {
      {
#line 484
      tmp___2 = __gmpz_get_si((mpz_srcptr )(n->sub.val.nm.mpi));
#line 484
      tmp___3 = tmp___2;
      }
    } else {
#line 484
      tmp___3 = (long )n->sub.val.nm.fltnum;
    }
#line 484
    FNR = tmp___3;
  }
#line 485
  return;
}
}
#line 489 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
void set_NR(void) 
{ 
  NODE *n ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 492
  n = NR_node->sub.nodep.l.lptr;
#line 493
  force_number(n);
  }
#line 495
  if ((n->flags & 6144U) != 0U) {
    {
#line 496
    NR = mpg_set_var(NR_node);
    }
  } else
#line 499
  if (n->flags & 2048U) {
    {
#line 499
    tmp___1 = mpfr_get_si((mpfr_srcptr )(n->sub.val.nm.mpnum), ROUND_MODE);
#line 499
    NR = tmp___1;
    }
  } else {
#line 499
    if (n->flags & 4096U) {
      {
#line 499
      tmp___2 = __gmpz_get_si((mpz_srcptr )(n->sub.val.nm.mpi));
#line 499
      tmp___3 = tmp___2;
      }
    } else {
#line 499
      tmp___3 = (long )n->sub.val.nm.fltnum;
    }
#line 499
    NR = tmp___3;
  }
#line 500
  return;
}
}
#line 504 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
int inrec(IOBUF *iop , int *errcode ) 
{ 
  char *begin ;
  int cnt ;
  int retval ;

  {
#line 509
  retval = 0;
#line 511
  if ((iop->flag & 2) != 0) {
#line 511
    if ((unsigned long )iop->off >= (unsigned long )iop->dataend) {
#line 512
      cnt = -1;
    } else {
#line 511
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 513
  if ((iop->flag & 4) != 0) {
#line 514
    cnt = -1;
  } else {
    {
#line 516
    cnt = get_a_record(& begin, iop, errcode);
    }
  }
#line 518
  if (cnt == -1) {
#line 519
    retval = 1;
#line 520
    if (*errcode > 0) {
      {
#line 521
      update_ERRNO_int(*errcode);
      }
    }
  } else {
#line 523
    if (do_flags & 16384) {
#line 523
      if (NR == 9223372036854775806L) {
        {
#line 523
        __gmpz_add_ui(MNR, (mpz_srcptr )(MNR), 1UL);
#line 523
        NR = 0L;
        }
      } else {
#line 523
        NR ++;
      }
    } else {
#line 523
      NR ++;
    }
#line 524
    if (do_flags & 16384) {
#line 524
      if (FNR == 9223372036854775806L) {
        {
#line 524
        __gmpz_add_ui(MFNR, (mpz_srcptr )(MFNR), 1UL);
#line 524
        FNR = 0L;
        }
      } else {
#line 524
        FNR ++;
      }
    } else {
#line 524
      FNR ++;
    }
    {
#line 525
    set_record((char const   *)begin, cnt);
    }
  }
#line 528
  return (retval);
}
}
#line 533 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int remap_std_file(int oldfd ) 
{ 
  int newfd ;
  int ret ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 537
  ret = -1;
#line 543
  newfd = os_devopen("/dev/null", 2);
  }
#line 544
  if (newfd == -1) {
    {
#line 545
    newfd = open("/dev/null", 2);
    }
  }
#line 546
  if (newfd >= 0) {
    {
#line 548
    ret = dup2(newfd, oldfd);
    }
#line 549
    if (ret == 0) {
      {
#line 550
      close(newfd);
      }
    }
  } else {
#line 552
    ret = 0;
  }
#line 554
  return (ret);
}
}
#line 559 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int iop_close(IOBUF *iop ) 
{ 
  int ret ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  NODE *t ;
  int tmp___8 ;
  char *__cil_tmp12 ;

  {
#line 562
  ret = 0;
#line 564
  if ((unsigned long )iop == (unsigned long )((void *)0)) {
#line 565
    return (0);
  }
  {
#line 567
  tmp___1 = __errno_location();
#line 567
  *tmp___1 = 0;
#line 569
  iop->flag &= -3;
#line 570
  iop->flag |= 4;
#line 571
  iop->dataend = (char *)((void *)0);
  }
#line 577
  if ((unsigned long )iop->public.close_func != (unsigned long )((void *)0)) {
    {
#line 578
    (*(iop->public.close_func))(& iop->public);
    }
  }
#line 580
  if (iop->public.fd != -1) {
    {
#line 581
    tmp___2 = fileno(stdin);
    }
#line 581
    if (iop->public.fd == tmp___2) {
      {
#line 584
      ret = remap_std_file(iop->public.fd);
      }
    } else {
      {
#line 581
      tmp___3 = fileno(stdout);
      }
#line 581
      if (iop->public.fd == tmp___3) {
        {
#line 584
        ret = remap_std_file(iop->public.fd);
        }
      } else {
        {
#line 581
        tmp___4 = fileno(stderr);
        }
#line 581
        if (iop->public.fd == tmp___4) {
          {
#line 584
          ret = remap_std_file(iop->public.fd);
          }
        } else {
          {
#line 586
          ret = close(iop->public.fd);
          }
        }
      }
    }
  }
#line 589
  if (ret == -1) {
    {
#line 590
    tmp___5 = __errno_location();
#line 590
    tmp___6 = strerror(*tmp___5);
#line 590
    tmp___7 = gettext("close of fd %d (`%s\') failed (%s)");
#line 590
    warning((char const   *)tmp___7, iop->public.fd, iop->public.name, tmp___6);
    }
  }
#line 597
  if (iop->buf) {
#line 598
    if ((unsigned long )(*(fields_arr + 0))->sub.val.sp >= (unsigned long )iop->buf) {
#line 598
      if ((unsigned long )(*(fields_arr + 0))->sub.val.sp < (unsigned long )(iop->buf + iop->size)) {
        {
#line 602
        t = make_str_node((char const   *)(*(fields_arr + 0))->sub.val.sp, (*(fields_arr + 0))->sub.val.slen,
                          0);
#line 604
        unref(*(fields_arr + 0));
#line 605
        *(fields_arr + 0) = t;
        }
      }
    }
    {
#line 616
    free((void *)iop->buf);
#line 617
    iop->buf = (char *)((void *)0);
    }
  }
  {
#line 619
  free((void *)iop);
  }
#line 620
  if (ret == -1) {
#line 620
    tmp___8 = 1;
  } else {
#line 620
    tmp___8 = 0;
  }
#line 620
  return (tmp___8);
}
}
#line 628 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static struct flagtab  const  redtab[12]  = 
#line 628
  {      {1, "RED_FILE"}, 
        {2, "RED_PIPE"}, 
        {4, "RED_READ"}, 
        {8, "RED_WRITE"}, 
        {16, "RED_APPEND"}, 
        {32, "RED_NOBUF"}, 
        {128, "RED_EOF"}, 
        {256, "RED_TWOWAY"}, 
        {512, "RED_PTY"}, 
        {1024, "RED_SOCKET"}, 
        {2048, "RED_TCP"}, 
        {0, (char const   *)((void *)0)}};
#line 625 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
char const   *redflags2str(int flags___0 ) 
{ 
  char const   *tmp___1 ;

  {
  {
#line 643
  tmp___1 = genflags2str(flags___0, redtab);
  }
#line 643
  return (tmp___1);
}
}
#line 661 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static struct redirect *save_rp  =    (struct redirect *)((void *)0);
#line 648 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
struct redirect *redirect(NODE *redir_exp , int redirtype , int *errflg ) 
{ 
  struct redirect *rp ;
  char *str ;
  int tflag ;
  int outflag ;
  char const   *direction ;
  char const   *mode ;
  int fd ;
  char const   *what ;
  _Bool new_rp ;
  int len ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int rpflag ;
  int newflag ;
  char *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  FILE *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  IOBUF *tmp___32 ;
  int *tmp___33 ;
  int *tmp___34 ;
  int *tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char const   *omode ;
  int fd_flags ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  struct redirect *tmp___46 ;
  int *tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  int *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  int *tmp___54 ;
  int *tmp___55 ;
  void *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;

  {
#line 653
  tflag = 0;
#line 654
  outflag = 0;
#line 655
  direction = "to";
#line 658
  what = (char const   *)((void *)0);
#line 659
  new_rp = (_Bool)0;
#line 665
  if (do_flags & 2048) {
    {
#line 666
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 666);
#line 666
    tmp___1 = gettext("redirection not allowed in sandbox mode");
#line 666
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 669
  if (redirtype == 2) {
#line 669
    goto case_2;
  }
#line 672
  if (redirtype == 1) {
#line 672
    goto case_1;
  }
#line 680
  if (redirtype == 3) {
#line 680
    goto case_3;
  }
#line 684
  if (redirtype == 4) {
#line 684
    goto case_4;
  }
#line 688
  if (redirtype == 5) {
#line 688
    goto case_5;
  }
#line 692
  if (redirtype == 6) {
#line 692
    goto case_6;
  }
#line 696
  goto switch_default;
  case_2: /* CIL Label */ 
#line 670
  tflag = 16;
  case_1: /* CIL Label */ 
#line 673
  outflag = 9;
#line 674
  tflag |= outflag;
#line 675
  if (redirtype == 1) {
#line 676
    what = ">";
  } else {
#line 678
    what = ">>";
  }
#line 679
  goto switch_break;
  case_3: /* CIL Label */ 
#line 681
  tflag = 10;
#line 682
  what = "|";
#line 683
  goto switch_break;
  case_4: /* CIL Label */ 
#line 685
  tflag = 6;
#line 686
  what = "|";
#line 687
  goto switch_break;
  case_5: /* CIL Label */ 
#line 689
  tflag = 5;
#line 690
  what = "<";
#line 691
  goto switch_break;
  case_6: /* CIL Label */ 
#line 693
  tflag = 268;
#line 694
  what = "|&";
#line 695
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 697
  r_fatal("internal error line %d, file: %s", 697, "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c");
  }
  switch_break: /* CIL Label */ ;
  }
#line 699
  if (do_flags & 3) {
#line 699
    if ((redir_exp->flags & 4U) == 0U) {
      {
#line 700
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 700);
#line 700
      tmp___2 = gettext("expression in `%s\' redirection only has numeric value");
#line 700
      (*lintfunc)((char const   *)tmp___2, what);
      }
    }
  }
  {
#line 702
  redir_exp = force_string(redir_exp);
#line 703
  str = redir_exp->sub.val.sp;
  }
#line 705
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    {
#line 706
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 706);
#line 706
    tmp___3 = gettext("expression for `%s\' redirection has null string value");
#line 706
    r_fatal((char const   *)tmp___3, what);
    }
  } else
#line 705
  if ((int )*str == 0) {
    {
#line 706
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 706);
#line 706
    tmp___3 = gettext("expression for `%s\' redirection has null string value");
#line 706
    r_fatal((char const   *)tmp___3, what);
    }
  }
#line 709
  if (do_flags & 3) {
    {
#line 709
    tmp___5 = strncmp((char const   *)str, "0", redir_exp->sub.val.slen);
    }
#line 709
    if (tmp___5 == 0) {
      {
#line 711
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 711);
#line 711
      tmp___4 = gettext("filename `%s\' for `%s\' redirection may be result of logical expression");
#line 711
      (*lintfunc)((char const   *)tmp___4, str, what);
      }
    } else {
      {
#line 709
      tmp___6 = strncmp((char const   *)str, "1", redir_exp->sub.val.slen);
      }
#line 709
      if (tmp___6 == 0) {
        {
#line 711
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 711);
#line 711
        tmp___4 = gettext("filename `%s\' for `%s\' redirection may be result of logical expression");
#line 711
        (*lintfunc)((char const   *)tmp___4, str, what);
        }
      }
    }
  }
  {
#line 719
  tmp___8 = inetfile((char const   *)str, & len, (int *)((void *)0));
  }
#line 719
  if (tmp___8) {
    {
#line 720
    tflag |= 1024;
#line 721
    tmp___7 = strncmp((char const   *)(str + len), "tcp/", (size_t )4);
    }
#line 721
    if (tmp___7 == 0) {
#line 722
      tflag |= 2048;
    }
  }
#line 726
  rp = red_head;
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 726
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 726
      goto while_break;
    }
#line 736
    if ((rp->flag & 128U) != 0U) {
#line 736
      if (redirtype == 4) {
#line 737
        if (rp->pid != -1) {
          {
#line 738
          wait_any(0);
          }
        }
      }
    }
    {
#line 743
    tmp___10 = strlen((char const   *)rp->value);
    }
#line 743
    if (tmp___10 == redir_exp->sub.val.slen) {
      {
#line 743
      tmp___11 = memcmp((void const   *)rp->value, (void const   *)str, redir_exp->sub.val.slen);
      }
#line 743
      if (tmp___11 == 0) {
#line 743
        if ((rp->flag & 4294966623U) == (unsigned int )tflag) {
#line 743
          goto _L;
        } else
#line 743
        if (outflag != 0) {
#line 743
          if ((rp->flag & 9U) == (unsigned int )outflag) {
            _L: /* CIL Label */ 
#line 749
            rpflag = (int )(rp->flag & 4294966623U);
#line 750
            newflag = tflag & -673;
#line 752
            if (do_flags & 3) {
#line 752
              if (rpflag != newflag) {
                {
#line 753
                set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 753);
#line 753
                tmp___9 = gettext("unnecessary mixing of `>\' and `>>\' for file `%.*s\'");
#line 753
                (*lintfunc)((char const   *)tmp___9, (int )redir_exp->sub.val.slen,
                            rp->value);
                }
              }
            }
#line 757
            goto while_break;
          }
        }
      }
    }
#line 726
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 761
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 762
    new_rp = (_Bool)1;
#line 763
    if ((unsigned long )save_rp != (unsigned long )((void *)0)) {
      {
#line 764
      rp = save_rp;
#line 765
      free((void *)rp->value);
      }
    } else {
      {
#line 767
      tmp___12 = malloc(sizeof(struct redirect ));
#line 767
      rp = (struct redirect *)tmp___12;
      }
#line 767
      if (rp) {
#line 767
        tmp___16 = 1;
      } else {
        {
#line 767
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 767);
#line 767
        tmp___13 = __errno_location();
#line 767
        tmp___14 = strerror(*tmp___13);
#line 767
        tmp___15 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 767
        r_fatal((char const   *)tmp___15, "redirect", "rp", (long )sizeof(struct redirect ),
                tmp___14);
#line 767
        tmp___16 = 0;
        }
      }
    }
    {
#line 768
    tmp___17 = malloc(redir_exp->sub.val.slen + 1UL);
#line 768
    str = (char *)tmp___17;
    }
#line 768
    if (str) {
#line 768
      tmp___21 = 1;
    } else {
      {
#line 768
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 768);
#line 768
      tmp___18 = __errno_location();
#line 768
      tmp___19 = strerror(*tmp___18);
#line 768
      tmp___20 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 768
      r_fatal((char const   *)tmp___20, "redirect", "str", (long )(redir_exp->sub.val.slen + 1UL),
              tmp___19);
#line 768
      tmp___21 = 0;
      }
    }
    {
#line 769
    memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)redir_exp->sub.val.sp,
           redir_exp->sub.val.slen);
#line 770
    *(str + redir_exp->sub.val.slen) = (char )'\000';
#line 771
    rp->value = str;
#line 772
    rp->flag = (unsigned int )tflag;
#line 773
    init_output_wrapper(& rp->output);
#line 774
    rp->output.name = (char const   *)str;
#line 775
    rp->iop = (IOBUF *)((void *)0);
#line 776
    rp->pid = -1;
#line 777
    rp->status = 0;
    }
  } else {
#line 779
    str = rp->value;
  }
#line 780
  save_rp = rp;
  {
#line 782
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 782
    if ((unsigned long )rp->output.fp == (unsigned long )((void *)0)) {
#line 782
      if (! ((unsigned long )rp->iop == (unsigned long )((void *)0))) {
#line 782
        goto while_break___0;
      }
    } else {
#line 782
      goto while_break___0;
    }
#line 783
    if (! new_rp) {
#line 783
      if ((rp->flag & 128U) != 0U) {
#line 788
        save_rp = (struct redirect *)((void *)0);
#line 789
        return (rp);
      }
    }
    {
#line 791
    mode = (char const   *)((void *)0);
#line 792
    tmp___22 = __errno_location();
#line 792
    *tmp___22 = 0;
    }
    {
#line 794
    if (redirtype == 1) {
#line 794
      goto case_1___0;
    }
#line 799
    if (redirtype == 2) {
#line 799
      goto case_2___0;
    }
#line 802
    if (redirtype == 3) {
#line 802
      goto case_3___0;
    }
#line 815
    if (redirtype == 4) {
#line 815
      goto case_4___0;
    }
#line 821
    if (redirtype == 5) {
#line 821
      goto case_5___0;
    }
#line 839
    if (redirtype == 6) {
#line 839
      goto case_6___0;
    }
#line 853
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 795
    mode = "w";
#line 796
    if ((rp->flag & 64U) != 0U) {
#line 797
      if ((int const   )*(rp->mode + 1) == 98) {
#line 797
        mode = "ab";
      } else {
#line 797
        mode = "a";
      }
    }
#line 798
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 800
    mode = "a";
#line 801
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 804
    flush_io();
#line 806
    tmp___23 = fileno(stdin);
#line 806
    os_restore_mode(tmp___23);
#line 807
    tmp___27 = popen((char const   *)str, "w");
#line 807
    rp->output.fp = tmp___27;
    }
#line 807
    if ((unsigned long )tmp___27 == (unsigned long )((void *)0)) {
      {
#line 808
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 808);
#line 808
      tmp___24 = __errno_location();
#line 808
      tmp___25 = strerror(*tmp___24);
#line 808
      tmp___26 = gettext("can\'t open pipe `%s\' for output (%s)");
#line 808
      r_fatal((char const   *)tmp___26, str, tmp___25);
      }
    }
    {
#line 812
    tmp___28 = fileno(rp->output.fp);
#line 812
    os_close_on_exec(tmp___28, (char const   *)str, "pipe", "to");
#line 813
    rp->flag |= 32U;
    }
#line 814
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 816
    direction = "from";
#line 817
    tmp___32 = gawk_popen((char const   *)str, rp);
    }
#line 817
    if ((unsigned long )tmp___32 == (unsigned long )((void *)0)) {
      {
#line 818
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 818);
#line 818
      tmp___29 = __errno_location();
#line 818
      tmp___30 = strerror(*tmp___29);
#line 818
      tmp___31 = gettext("can\'t open pipe `%s\' for input (%s)");
#line 818
      r_fatal((char const   *)tmp___31, str, tmp___30);
      }
    }
#line 820
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 822
    direction = "from";
#line 823
    fd = devopen((char const   *)str, "r");
    }
#line 824
    if (fd == -1) {
      {
#line 824
      tmp___33 = __errno_location();
      }
#line 824
      if (*tmp___33 == 21) {
#line 825
        *errflg = 21;
#line 827
        return ((struct redirect *)((void *)0));
      }
    }
    {
#line 829
    tmp___34 = __errno_location();
#line 829
    rp->iop = iop_alloc(fd, (char const   *)str, *tmp___34);
#line 830
    find_input_parser(rp->iop);
#line 831
    iop_finish(rp->iop);
    }
#line 832
    if (! (rp->iop)->valid) {
#line 833
      if (! (do_flags & 8)) {
#line 833
        if ((rp->iop)->errcode != 0) {
          {
#line 834
          update_ERRNO_int((rp->iop)->errcode);
          }
        }
      }
      {
#line 835
      iop_close(rp->iop);
#line 836
      rp->iop = (IOBUF *)((void *)0);
      }
    }
#line 838
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
    {
#line 840
    direction = "to/from";
#line 841
    tmp___40 = two_way_open((char const   *)str, rp);
    }
#line 841
    if (! tmp___40) {
      {
#line 843
      tmp___39 = inetfile((char const   *)str, (int *)((void *)0), (int *)((void *)0));
      }
#line 843
      if (tmp___39) {
        {
#line 844
        tmp___35 = __errno_location();
#line 844
        *errflg = *tmp___35;
        }
#line 846
        return ((struct redirect *)((void *)0));
      } else {
        {
#line 849
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 849);
#line 849
        tmp___36 = __errno_location();
#line 849
        tmp___37 = strerror(*tmp___36);
#line 849
        tmp___38 = gettext("can\'t open two way pipe `%s\' for input/output (%s)");
#line 849
        r_fatal((char const   *)tmp___38, str, tmp___37);
        }
      }
    }
#line 852
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 854
    r_fatal("internal error line %d, file: %s", 854, "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c");
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 857
    if ((unsigned long )mode != (unsigned long )((void *)0)) {
      {
#line 858
      tmp___41 = __errno_location();
#line 858
      *tmp___41 = 0;
#line 859
      rp->output.mode = mode;
#line 860
      fd = devopen((char const   *)str, mode);
      }
#line 862
      if (fd > -1) {
        {
#line 863
        tmp___44 = fileno(stdin);
        }
#line 863
        if (fd == tmp___44) {
#line 864
          rp->output.fp = stdin;
        } else {
          {
#line 865
          tmp___43 = fileno(stdout);
          }
#line 865
          if (fd == tmp___43) {
#line 866
            rp->output.fp = stdout;
          } else {
            {
#line 867
            tmp___42 = fileno(stderr);
            }
#line 867
            if (fd == tmp___42) {
#line 868
              rp->output.fp = stderr;
            } else {
              {
#line 870
              omode = mode;
#line 874
              fd_flags = fcntl(fd, 3);
              }
#line 875
              if (fd_flags != -1) {
#line 875
                if ((fd_flags & 1024) == 1024) {
#line 876
                  omode = "a";
                }
              }
              {
#line 878
              os_close_on_exec(fd, (char const   *)str, "file", "");
#line 879
              rp->output.fp = fdopen(fd, omode);
#line 880
              rp->mode = mode;
              }
#line 882
              if ((unsigned long )rp->output.fp == (unsigned long )((void *)0)) {
                {
#line 883
                close(fd);
                }
              }
            }
          }
        }
#line 885
        if ((unsigned long )rp->output.fp != (unsigned long )((void *)0)) {
          {
#line 885
          tmp___45 = os_isatty(fd);
          }
#line 885
          if (tmp___45) {
#line 886
            rp->flag |= 32U;
          }
        }
#line 889
        if (! new_rp) {
#line 889
          if ((unsigned long )red_head != (unsigned long )rp) {
#line 890
            tmp___46 = rp->next;
#line 890
            (rp->prev)->next = tmp___46;
#line 890
            if ((unsigned long )tmp___46 != (unsigned long )((void *)0)) {
#line 891
              (rp->next)->prev = rp->prev;
            }
#line 892
            red_head->prev = rp;
#line 893
            rp->prev = (struct redirect *)((void *)0);
#line 894
            rp->next = red_head;
#line 895
            red_head = rp;
          }
        }
      }
      {
#line 898
      find_output_wrapper(& rp->output);
      }
    }
#line 901
    if ((unsigned long )rp->output.fp == (unsigned long )((void *)0)) {
#line 901
      if ((unsigned long )rp->iop == (unsigned long )((void *)0)) {
        {
#line 903
        tmp___54 = __errno_location();
        }
#line 903
        if (*tmp___54 == 24) {
          {
#line 904
          close_one();
          }
        } else {
          {
#line 903
          tmp___55 = __errno_location();
          }
#line 903
          if (*tmp___55 == 23) {
            {
#line 904
            close_one();
            }
          } else {
#line 922
            if ((unsigned long )errflg != (unsigned long )((void *)0)) {
              {
#line 923
              tmp___47 = __errno_location();
#line 923
              *errflg = *tmp___47;
              }
            }
#line 924
            if (redirtype == 1) {
#line 924
              goto _L___0;
            } else
#line 924
            if (redirtype == 2) {
              _L___0: /* CIL Label */ 
#line 927
              if ((int const   )*direction == 102) {
                {
#line 928
                set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 928);
#line 928
                tmp___48 = __errno_location();
#line 928
                tmp___49 = strerror(*tmp___48);
#line 928
                tmp___50 = gettext("can\'t redirect from `%s\' (%s)");
#line 928
                r_fatal((char const   *)tmp___50, str, tmp___49);
                }
              } else {
                {
#line 931
                set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 931);
#line 931
                tmp___51 = __errno_location();
#line 931
                tmp___52 = strerror(*tmp___51);
#line 931
                tmp___53 = gettext("can\'t redirect to `%s\' (%s)");
#line 931
                r_fatal((char const   *)tmp___53, str, tmp___52);
                }
              }
            } else {
#line 935
              return ((struct redirect *)((void *)0));
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 941
  if (new_rp) {
#line 946
    if ((unsigned long )red_head != (unsigned long )((void *)0)) {
#line 947
      red_head->prev = rp;
    }
#line 948
    rp->prev = (struct redirect *)((void *)0);
#line 949
    rp->next = red_head;
#line 950
    red_head = rp;
  }
#line 952
  save_rp = (struct redirect *)((void *)0);
#line 953
  return (rp);
}
}
#line 958 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
struct redirect *getredirect(char const   *str , int len ) 
{ 
  struct redirect *rp ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 963
  rp = red_head;
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 963
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 963
      goto while_break;
    }
    {
#line 964
    tmp___1 = strlen((char const   *)rp->value);
    }
#line 964
    if (tmp___1 == (size_t )len) {
      {
#line 964
      tmp___2 = memcmp((void const   *)rp->value, (void const   *)str, (size_t )len);
      }
#line 964
      if (tmp___2 == 0) {
#line 965
        return (rp);
      }
    }
#line 963
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 967
  return ((struct redirect *)((void *)0));
}
}
#line 978 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static _Bool warned___2  =    (_Bool)0;
#line 972 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static void close_one(void) 
{ 
  struct redirect *rp ;
  struct redirect *rplast ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 976
  rplast = (struct redirect *)((void *)0);
#line 980
  if (do_flags & 3) {
#line 980
    if (! warned___2) {
      {
#line 981
      warned___2 = (_Bool)1;
#line 982
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 982);
#line 982
      tmp___1 = gettext("reached system limit for open files: starting to multiplex file descriptors");
#line 982
      (*lintfunc)((char const   *)tmp___1);
      }
    }
  }
#line 986
  rp = red_head;
  {
#line 986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 986
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 986
      goto while_break;
    }
#line 987
    rplast = rp;
#line 986
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 989
  rp = rplast;
  {
#line 989
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 989
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 989
      goto while_break___0;
    }
#line 991
    if ((unsigned long )rp->output.fp == (unsigned long )((void *)0)) {
#line 992
      goto __Cont;
    } else
#line 991
    if ((unsigned long )rp->output.fp == (unsigned long )stderr) {
#line 992
      goto __Cont;
    } else
#line 991
    if ((unsigned long )rp->output.fp == (unsigned long )stdout) {
#line 992
      goto __Cont;
    }
#line 994
    if ((rp->flag & 9U) == 9U) {
      {
#line 995
      rp->flag |= 64U;
#line 996
      tmp___2 = __errno_location();
#line 996
      *tmp___2 = 0;
#line 997
      tmp___6 = (*(rp->output.gawk_fclose))(rp->output.fp, rp->output.opaque);
      }
#line 997
      if (tmp___6 != 0) {
        {
#line 998
        tmp___3 = __errno_location();
#line 998
        tmp___4 = strerror(*tmp___3);
#line 998
        tmp___5 = gettext("close of `%s\' failed (%s).");
#line 998
        warning((char const   *)tmp___5, rp->value, tmp___4);
        }
      }
#line 1000
      rp->output.fp = (FILE *)((void *)0);
#line 1001
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 989
    rp = rp->prev;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1004
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 1006
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1006);
#line 1006
    tmp___7 = gettext("too many pipes or input files open");
#line 1006
    r_fatal((char const   *)tmp___7);
    }
  }
#line 1007
  return;
}
}
#line 1011 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
NODE *do_close(int nargs ) 
{ 
  NODE *tmp___1 ;
  NODE *tmp2 ;
  struct redirect *rp ;
  two_way_close_type how ;
  NODE *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  NODE *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char *cp ;
  char *tmp___9 ;
  NODE *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 1016
  how = (two_way_close_type )0;
#line 1018
  if (nargs == 2) {
    {
#line 1021
    tmp___2 = POP_SCALAR();
#line 1021
    tmp2 = force_string(tmp___2);
#line 1022
    tmp___5 = strcasecmp((char const   *)tmp2->sub.val.sp, "to");
    }
#line 1022
    if (tmp___5 == 0) {
#line 1023
      how = (two_way_close_type )1;
    } else {
      {
#line 1024
      tmp___4 = strcasecmp((char const   *)tmp2->sub.val.sp, "from");
      }
#line 1024
      if (tmp___4 == 0) {
#line 1025
        how = (two_way_close_type )2;
      } else {
        {
#line 1027
        DEREF(tmp2);
#line 1028
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1028);
#line 1028
        tmp___3 = gettext("close: second argument must be `to\' or `from\'");
#line 1028
        r_fatal((char const   *)tmp___3);
        }
      }
    }
    {
#line 1030
    DEREF(tmp2);
    }
  }
  {
#line 1033
  tmp___6 = POP_SCALAR();
#line 1033
  tmp___1 = force_string(tmp___6);
#line 1035
  rp = red_head;
  }
  {
#line 1035
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1035
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 1035
      goto while_break;
    }
    {
#line 1036
    tmp___7 = strlen((char const   *)rp->value);
    }
#line 1036
    if (tmp___7 == tmp___1->sub.val.slen) {
      {
#line 1036
      tmp___8 = memcmp((void const   *)rp->value, (void const   *)tmp___1->sub.val.sp,
                       tmp___1->sub.val.slen);
      }
#line 1036
      if (tmp___8 == 0) {
#line 1038
        goto while_break;
      }
    }
#line 1035
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 1044
    if (do_flags & 3) {
      {
#line 1045
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1045);
#line 1045
      tmp___9 = gettext("close: `%.*s\' is not an open file, pipe or co-process");
#line 1045
      (*lintfunc)((char const   *)tmp___9, (int )tmp___1->sub.val.slen, tmp___1->sub.val.sp);
      }
    }
#line 1048
    if (! (do_flags & 8)) {
      {
#line 1050
      cp = gettext("close of redirection that was never opened");
#line 1051
      update_ERRNO_string((char const   *)cp);
      }
    }
    {
#line 1054
    DEREF(tmp___1);
#line 1055
    tmp___10 = (*make_number)(- 1.0);
    }
#line 1055
    return (tmp___10);
  }
  {
#line 1057
  DEREF(tmp___1);
#line 1058
  fflush(stdout);
#line 1059
  tmp___11 = close_redir(rp, (_Bool)0, how);
#line 1059
  tmp___1 = (*make_number)((double )tmp___11);
#line 1060
  rp = (struct redirect *)((void *)0);
  }
#line 1067
  if (do_flags & 16) {
    {
#line 1068
    unref(tmp___1);
#line 1069
    tmp___1 = (*make_number)((double )0);
    }
  }
#line 1071
  return (tmp___1);
}
}
#line 1076 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int close_rp(struct redirect *rp , two_way_close_type how ) 
{ 
  int status ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1079
  status = 0;
#line 1081
  tmp___1 = __errno_location();
#line 1081
  *tmp___1 = 0;
  }
#line 1082
  if ((rp->flag & 256U) != 0U) {
#line 1084
    if ((unsigned int )how == 0U) {
#line 1084
      goto _L;
    } else
#line 1084
    if ((unsigned int )how == 1U) {
      _L: /* CIL Label */ 
#line 1084
      if ((unsigned long )rp->output.fp != (unsigned long )((void *)0)) {
#line 1086
        if ((rp->flag & 2048U) != 0U) {
          {
#line 1087
          tmp___2 = fileno(rp->output.fp);
#line 1087
          shutdown(tmp___2, 1);
          }
        }
#line 1090
        if ((rp->flag & 512U) != 0U) {
          {
#line 1091
          (*(rp->output.gawk_fwrite))((void const   *)"\004\n", sizeof("\004\n") - 1UL,
                                      (size_t )1, rp->output.fp, rp->output.opaque);
#line 1092
          (*(rp->output.gawk_fflush))(rp->output.fp, rp->output.opaque);
          }
        }
        {
#line 1094
        status = (*(rp->output.gawk_fclose))(rp->output.fp, rp->output.opaque);
#line 1095
        rp->output.fp = (FILE *)((void *)0);
        }
      }
    }
#line 1099
    if ((unsigned int )how == 0U) {
#line 1099
      goto _L___0;
    } else
#line 1099
    if ((unsigned int )how == 2U) {
      _L___0: /* CIL Label */ 
#line 1100
      if ((rp->flag & 1024U) != 0U) {
#line 1100
        if ((unsigned long )rp->iop != (unsigned long )((void *)0)) {
#line 1102
          if ((rp->flag & 2048U) != 0U) {
            {
#line 1103
            shutdown((rp->iop)->public.fd, 0);
            }
          }
          {
#line 1105
          iop_close(rp->iop);
          }
        } else {
          {
#line 1107
          status = gawk_pclose(rp);
          }
        }
      } else {
        {
#line 1107
        status = gawk_pclose(rp);
        }
      }
#line 1109
      rp->iop = (IOBUF *)((void *)0);
    }
  } else
#line 1111
  if ((rp->flag & 10U) == 10U) {
    {
#line 1113
    status = pclose(rp->output.fp);
    }
#line 1114
    if ((BINMODE & 1) != 0) {
      {
#line 1115
      tmp___3 = fileno(stdin);
#line 1115
      os_setbinmode(tmp___3, 0);
      }
    }
#line 1117
    rp->output.fp = (FILE *)((void *)0);
  } else
#line 1118
  if ((unsigned long )rp->output.fp != (unsigned long )((void *)0)) {
    {
#line 1119
    status = (*(rp->output.gawk_fclose))(rp->output.fp, rp->output.opaque);
#line 1120
    rp->output.fp = (FILE *)((void *)0);
    }
  } else
#line 1121
  if ((unsigned long )rp->iop != (unsigned long )((void *)0)) {
#line 1122
    if ((rp->flag & 2U) != 0U) {
      {
#line 1123
      status = gawk_pclose(rp);
      }
    } else {
      {
#line 1126
      status = iop_close(rp->iop);
#line 1127
      rp->iop = (IOBUF *)((void *)0);
      }
    }
  }
#line 1131
  return (status);
}
}
#line 1136 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int close_redir(struct redirect *rp , _Bool exitwarn , two_way_close_type how ) 
{ 
  int status ;
  char *tmp___1 ;
  int save_errno ;
  int *tmp___2 ;
  char *s___0 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 1139
  status = 0;
#line 1141
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 1142
    return (0);
  }
#line 1143
  if ((unsigned long )rp->output.fp == (unsigned long )stdout) {
#line 1144
    goto checkwarn;
  } else
#line 1143
  if ((unsigned long )rp->output.fp == (unsigned long )stderr) {
#line 1144
    goto checkwarn;
  }
#line 1146
  if (do_flags & 3) {
#line 1146
    if ((rp->flag & 256U) == 0U) {
#line 1146
      if ((unsigned int )how != 0U) {
        {
#line 1147
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1147);
#line 1147
        tmp___1 = gettext("close: redirection `%s\' not opened with `|&\', second argument ignored");
#line 1147
        (*lintfunc)((char const   *)tmp___1, rp->value);
        }
      }
    }
  }
  {
#line 1150
  status = close_rp(rp, how);
  }
#line 1152
  if (status != 0) {
    {
#line 1153
    tmp___2 = __errno_location();
#line 1153
    save_errno = *tmp___2;
#line 1154
    tmp___3 = strerror(save_errno);
#line 1154
    s___0 = tmp___3;
    }
#line 1162
    if (do_flags & 3) {
#line 1163
      if ((rp->flag & 2U) != 0U) {
        {
#line 1164
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1164);
#line 1164
        tmp___4 = gettext("failure status (%d) on pipe close of `%s\' (%s)");
#line 1164
        (*lintfunc)((char const   *)tmp___4, status, rp->value, s___0);
        }
      } else {
        {
#line 1167
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1167);
#line 1167
        tmp___5 = gettext("failure status (%d) on file close of `%s\' (%s)");
#line 1167
        (*lintfunc)((char const   *)tmp___5, status, rp->value, s___0);
        }
      }
    }
#line 1171
    if (! (do_flags & 8)) {
      {
#line 1173
      update_ERRNO_int(save_errno);
      }
    }
  }
  checkwarn: 
#line 1178
  if (exitwarn) {
#line 1186
    if ((rp->flag & 1024U) != 0U) {
      {
#line 1187
      tmp___6 = gettext("no explicit close of socket `%s\' provided");
#line 1187
      warning((char const   *)tmp___6, rp->value);
      }
    } else
#line 1189
    if ((rp->flag & 256U) != 0U) {
      {
#line 1190
      tmp___7 = gettext("no explicit close of co-process `%s\' provided");
#line 1190
      warning((char const   *)tmp___7, rp->value);
      }
    } else
#line 1192
    if ((rp->flag & 2U) != 0U) {
      {
#line 1193
      tmp___8 = gettext("no explicit close of pipe `%s\' provided");
#line 1193
      warning((char const   *)tmp___8, rp->value);
      }
    } else {
      {
#line 1196
      tmp___9 = gettext("no explicit close of file `%s\' provided");
#line 1196
      warning((char const   *)tmp___9, rp->value);
      }
    }
  }
#line 1201
  if ((unsigned int )how == 0U) {
#line 1201
    goto _L;
  } else
#line 1201
  if ((unsigned long )rp->iop == (unsigned long )((void *)0)) {
#line 1201
    if ((unsigned long )rp->output.fp == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 1202
      if ((unsigned long )rp->next != (unsigned long )((void *)0)) {
#line 1203
        (rp->next)->prev = rp->prev;
      }
#line 1204
      if ((unsigned long )rp->prev != (unsigned long )((void *)0)) {
#line 1205
        (rp->prev)->next = rp->next;
      } else {
#line 1207
        red_head = rp->next;
      }
      {
#line 1208
      free_rp(rp);
      }
    }
  }
#line 1211
  return (status);
}
}
#line 1216 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
int flush_io(void) 
{ 
  struct redirect *rp ;
  int status ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 1220
  status = 0;
#line 1222
  tmp___1 = __errno_location();
#line 1222
  *tmp___1 = 0;
#line 1223
  tmp___5 = fflush(stdout);
  }
#line 1223
  if (tmp___5) {
    {
#line 1224
    tmp___2 = __errno_location();
#line 1224
    tmp___3 = strerror(*tmp___2);
#line 1224
    tmp___4 = gettext("error writing standard output (%s)");
#line 1224
    warning((char const   *)tmp___4, tmp___3);
#line 1225
    status ++;
    }
  }
  {
#line 1227
  tmp___9 = fflush(stderr);
  }
#line 1227
  if (tmp___9) {
    {
#line 1228
    tmp___6 = __errno_location();
#line 1228
    tmp___7 = strerror(*tmp___6);
#line 1228
    tmp___8 = gettext("error writing standard error (%s)");
#line 1228
    warning((char const   *)tmp___8, tmp___7);
#line 1229
    status ++;
    }
  }
#line 1231
  rp = red_head;
  {
#line 1231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1231
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 1231
      goto while_break;
    }
#line 1233
    if ((rp->flag & 8U) != 0U) {
#line 1233
      if ((unsigned long )rp->output.fp != (unsigned long )((void *)0)) {
        {
#line 1234
        tmp___19 = (*(rp->output.gawk_fflush))(rp->output.fp, rp->output.opaque);
        }
#line 1234
        if (tmp___19) {
#line 1235
          if ((rp->flag & 2U) != 0U) {
            {
#line 1236
            tmp___10 = __errno_location();
#line 1236
            tmp___11 = strerror(*tmp___10);
#line 1236
            tmp___12 = gettext("pipe flush of `%s\' failed (%s).");
#line 1236
            warning((char const   *)tmp___12, rp->value, tmp___11);
            }
          } else
#line 1238
          if ((rp->flag & 256U) != 0U) {
            {
#line 1239
            tmp___13 = __errno_location();
#line 1239
            tmp___14 = strerror(*tmp___13);
#line 1239
            tmp___15 = gettext("co-process flush of pipe to `%s\' failed (%s).");
#line 1239
            warning((char const   *)tmp___15, rp->value, tmp___14);
            }
          } else {
            {
#line 1242
            tmp___16 = __errno_location();
#line 1242
            tmp___17 = strerror(*tmp___16);
#line 1242
            tmp___18 = gettext("file flush of `%s\' failed (%s).");
#line 1242
            warning((char const   *)tmp___18, rp->value, tmp___17);
            }
          }
#line 1244
          status ++;
        }
      }
    }
#line 1231
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1247
  if (status != 0) {
#line 1248
    status = -1;
  }
#line 1249
  return (status);
}
}
#line 1254 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
int close_io(_Bool *stdio_problem ) 
{ 
  struct redirect *rp ;
  struct redirect *next ;
  int status ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 1259
  status = 0;
#line 1261
  tmp___1 = __errno_location();
#line 1261
  *tmp___1 = 0;
#line 1262
  rp = red_head;
  }
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1262
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 1262
      goto while_break;
    }
    {
#line 1263
    next = rp->next;
#line 1268
    tmp___2 = close_redir(rp, (_Bool )(do_flags & 3), (two_way_close_type )0);
    }
#line 1268
    if (tmp___2) {
#line 1269
      status ++;
    }
#line 1270
    rp = (struct redirect *)((void *)0);
#line 1262
    rp = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1277
  *stdio_problem = (_Bool)0;
#line 1278
  tmp___6 = fflush(stdout);
  }
#line 1278
  if (tmp___6) {
    {
#line 1279
    tmp___3 = __errno_location();
#line 1279
    tmp___4 = strerror(*tmp___3);
#line 1279
    tmp___5 = gettext("error writing standard output (%s)");
#line 1279
    warning((char const   *)tmp___5, tmp___4);
#line 1280
    status ++;
#line 1281
    *stdio_problem = (_Bool)1;
    }
  }
  {
#line 1283
  tmp___10 = fflush(stderr);
  }
#line 1283
  if (tmp___10) {
    {
#line 1284
    tmp___7 = __errno_location();
#line 1284
    tmp___8 = strerror(*tmp___7);
#line 1284
    tmp___9 = gettext("error writing standard error (%s)");
#line 1284
    warning((char const   *)tmp___9, tmp___8);
#line 1285
    status ++;
#line 1286
    *stdio_problem = (_Bool)1;
    }
  }
#line 1288
  return (status);
}
}
#line 1293 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int str2mode(char const   *mode ) 
{ 
  int ret ;
  char const   *second ;
  char *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1297
  second = mode + 1;
#line 1299
  if ((int const   )*second == 98) {
#line 1300
    second ++;
  }
  {
#line 1303
  if ((int const   )*(mode + 0) == 114) {
#line 1303
    goto case_114;
  }
#line 1309
  if ((int const   )*(mode + 0) == 119) {
#line 1309
    goto case_119;
  }
#line 1315
  if ((int const   )*(mode + 0) == 97) {
#line 1315
    goto case_97;
  }
#line 1321
  goto switch_default;
  case_114: /* CIL Label */ 
#line 1304
  ret = 0;
#line 1305
  if ((int const   )*second == 43) {
#line 1306
    ret = 2;
  } else
#line 1305
  if ((int const   )*second == 119) {
#line 1306
    ret = 2;
  }
#line 1307
  goto switch_break;
  case_119: /* CIL Label */ 
#line 1310
  ret = 577;
#line 1311
  if ((int const   )*second == 43) {
#line 1312
    ret = 578;
  } else
#line 1311
  if ((int const   )*second == 114) {
#line 1312
    ret = 578;
  }
#line 1313
  goto switch_break;
  case_97: /* CIL Label */ 
#line 1316
  ret = 1089;
#line 1317
  if ((int const   )*second == 43) {
#line 1318
    ret = 1090;
  }
#line 1319
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1322
  ret = 0;
#line 1323
  r_fatal("internal error line %d, file: %s", 1323, "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1325
  tmp___1 = strchr(mode, 'b');
  }
#line 1325
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1326
    ret = ret;
  }
#line 1327
  return (ret);
}
}
#line 1334 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int socketopen(int family , int type , char const   *localpname , char const   *remotepname ,
                      char const   *remotehostname ) 
{ 
  struct addrinfo *lres ;
  struct addrinfo *lres0 ;
  struct addrinfo lhints ;
  struct addrinfo *rres ;
  struct addrinfo *rres0 ;
  struct addrinfo rhints ;
  int lerror ;
  int rerror ;
  int socket_fd ;
  int any_remote_host ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int on ;
  struct linger linger ;
  int tmp___6 ;
  int tmp___7 ;
  int clientsocket_fd ;
  struct sockaddr_storage remote_addr ;
  socklen_t namelen ;
  int tmp___8 ;
  char buf___7[10] ;
  struct sockaddr_storage remote_addr___0 ;
  socklen_t read_len ;
  ssize_t tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
#line 1345
  socket_fd = -1;
#line 1346
  tmp___1 = strcmp(remotehostname, "0");
#line 1346
  any_remote_host = tmp___1 == 0;
#line 1348
  memset((void *)(& lhints), '\000', sizeof(lhints));
#line 1349
  lhints.ai_flags = 33;
#line 1350
  lhints.ai_socktype = type;
#line 1351
  lhints.ai_family = family;
#line 1353
  lerror = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)localpname,
                       (struct addrinfo  const  */* __restrict  */)(& lhints), (struct addrinfo **/* __restrict  */)(& lres));
  }
#line 1354
  if (lerror) {
    {
#line 1355
    tmp___3 = strcmp(localpname, "0");
    }
#line 1355
    if (tmp___3 != 0) {
      {
#line 1356
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1356);
#line 1356
      tmp___2 = gettext("local port %s invalid in `/inet\'");
#line 1356
      r_fatal((char const   *)tmp___2, localpname);
      }
    }
#line 1357
    lres0 = (struct addrinfo *)((void *)0);
#line 1358
    lres = & lhints;
  } else {
#line 1360
    lres0 = lres;
  }
  {
#line 1362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1362
    if (! ((unsigned long )lres != (unsigned long )((void *)0))) {
#line 1362
      goto while_break;
    }
    {
#line 1363
    memset((void *)(& rhints), '\000', sizeof(rhints));
#line 1364
    rhints.ai_flags = lhints.ai_flags;
#line 1365
    rhints.ai_socktype = lhints.ai_socktype;
#line 1366
    rhints.ai_family = lhints.ai_family;
#line 1367
    rhints.ai_protocol = lhints.ai_protocol;
    }
#line 1369
    if (any_remote_host) {
#line 1369
      tmp___4 = (char const   *)((void *)0);
    } else {
#line 1369
      tmp___4 = remotehostname;
    }
    {
#line 1369
    rerror = getaddrinfo((char const   */* __restrict  */)tmp___4, (char const   */* __restrict  */)remotepname,
                         (struct addrinfo  const  */* __restrict  */)(& rhints), (struct addrinfo **/* __restrict  */)(& rres));
    }
#line 1371
    if (rerror) {
#line 1372
      if ((unsigned long )lres0 != (unsigned long )((void *)0)) {
        {
#line 1373
        freeaddrinfo(lres0);
        }
      }
      {
#line 1374
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1374);
#line 1374
      tmp___5 = gettext("remote host and port information (%s, %s) invalid");
#line 1374
      r_fatal((char const   *)tmp___5, remotehostname, remotepname);
      }
    }
#line 1376
    rres0 = rres;
#line 1377
    socket_fd = -1;
    {
#line 1378
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1378
      if (! ((unsigned long )rres != (unsigned long )((void *)0))) {
#line 1378
        goto while_break___0;
      }
      {
#line 1379
      socket_fd = socket(rres->ai_family, rres->ai_socktype, rres->ai_protocol);
      }
#line 1381
      if (socket_fd < 0) {
#line 1382
        goto nextrres;
      } else
#line 1381
      if (socket_fd == -1) {
#line 1382
        goto nextrres;
      }
#line 1384
      if (type == 1) {
        {
#line 1385
        on = 1;
#line 1388
        memset((void *)(& linger), '\000', sizeof(linger));
#line 1390
        setsockopt(socket_fd, 1, 2, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
#line 1393
        linger.l_onoff = 1;
#line 1395
        linger.l_linger = 30;
#line 1396
        setsockopt(socket_fd, 1, 13, (void const   *)((char *)(& linger)), (socklen_t )sizeof(linger));
        }
      }
      {
#line 1400
      tmp___6 = bind(socket_fd, (struct sockaddr  const  */* __restrict  */)lres->ai_addr,
                     lres->ai_addrlen);
      }
#line 1400
      if (tmp___6 != 0) {
#line 1401
        goto nextrres;
      }
#line 1403
      if (! any_remote_host) {
        {
#line 1404
        tmp___7 = connect(socket_fd, (struct sockaddr  const  */* __restrict  */)rres->ai_addr,
                          rres->ai_addrlen);
        }
#line 1404
        if (tmp___7 == 0) {
#line 1405
          goto while_break___0;
        }
      } else
#line 1407
      if (type == 1) {
        {
#line 1408
        clientsocket_fd = -1;
#line 1411
        namelen = (socklen_t )sizeof(remote_addr);
#line 1413
        tmp___8 = listen(socket_fd, 1);
        }
#line 1413
        if (tmp___8 >= 0) {
          {
#line 1413
          clientsocket_fd = accept(socket_fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& remote_addr)),
                                   (socklen_t */* __restrict  */)(& namelen));
          }
#line 1413
          if (clientsocket_fd >= 0) {
            {
#line 1417
            close(socket_fd);
#line 1418
            socket_fd = clientsocket_fd;
            }
#line 1419
            goto while_break___0;
          }
        }
      } else
#line 1421
      if (type == 2) {
        {
#line 1427
        tmp___9 = recvfrom(socket_fd, (void */* __restrict  */)(buf___7), (size_t )1,
                           2, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& remote_addr___0)),
                           (socklen_t */* __restrict  */)(& read_len));
        }
#line 1427
        if (tmp___9 >= 0L) {
#line 1427
          if (read_len) {
            {
#line 1427
            tmp___10 = connect(socket_fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& remote_addr___0)),
                               read_len);
            }
#line 1427
            if (tmp___10 == 0) {
#line 1434
              goto while_break___0;
            }
          }
        }
      }
      nextrres: 
#line 1440
      if (socket_fd != -1) {
        {
#line 1441
        close(socket_fd);
        }
      }
#line 1442
      socket_fd = -1;
#line 1443
      rres = rres->ai_next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1445
    freeaddrinfo(rres0);
    }
#line 1446
    if (socket_fd != -1) {
#line 1447
      goto while_break;
    }
#line 1448
    lres = lres->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1450
  if (lres0) {
    {
#line 1451
    freeaddrinfo(lres0);
    }
  }
#line 1453
  return (socket_fd);
}
}
#line 1580 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static unsigned long def_retries  =    20UL;
#line 1581 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static _Bool first_time  =    (_Bool)1;
#line 1583 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static long msleep  =    1000L;
#line 1464 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
int devopen(char const   *name , char const   *mode ) 
{ 
  int openfd ;
  char *cp ;
  char *ptr ;
  int flag ;
  int len ;
  int family ;
  int tmp___1 ;
  int tmp___2 ;
  struct stat sbuf ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int protocol ;
  char *hostname ;
  char *hostnameslastcharp ;
  char *localpname ;
  char *localpnamelastcharp ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned long retries ;
  char *cp___0 ;
  char *end ;
  unsigned long count ;
  char *ms2 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;

  {
  {
#line 1470
  flag = 0;
#line 1474
  tmp___2 = strcmp(name, "-");
  }
#line 1474
  if (tmp___2 == 0) {
    {
#line 1475
    tmp___1 = fileno(stdin);
    }
#line 1475
    return (tmp___1);
  }
  {
#line 1477
  flag = str2mode(mode);
#line 1478
  openfd = -1;
  }
#line 1480
  if (do_flags & 8) {
#line 1481
    goto strictopen;
  }
  {
#line 1483
  openfd = os_devopen(name, flag);
  }
#line 1483
  if (openfd != -1) {
    {
#line 1484
    os_close_on_exec(openfd, name, "file", "");
    }
#line 1485
    return (openfd);
  }
  {
#line 1488
  tmp___17 = strncmp(name, "/dev/", (size_t )5);
  }
#line 1488
  if (tmp___17 == 0) {
    {
#line 1489
    cp = (char *)name + 5;
#line 1491
    tmp___8 = strcmp((char const   *)cp, "stdin");
    }
#line 1491
    if (tmp___8 == 0) {
#line 1491
      if ((flag & 3) == 0) {
        {
#line 1492
        openfd = fileno(stdin);
        }
      } else {
#line 1491
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 1493
      tmp___7 = strcmp((char const   *)cp, "stdout");
      }
#line 1493
      if (tmp___7 == 0) {
#line 1493
        if ((flag & 3) == 1) {
          {
#line 1494
          openfd = fileno(stdout);
          }
        } else {
#line 1493
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1495
        tmp___6 = strcmp((char const   *)cp, "stderr");
        }
#line 1495
        if (tmp___6 == 0) {
#line 1495
          if ((flag & 3) == 1) {
            {
#line 1496
            openfd = fileno(stderr);
            }
          } else {
#line 1495
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1497
          tmp___5 = strncmp((char const   *)cp, "fd/", (size_t )3);
          }
#line 1497
          if (tmp___5 == 0) {
            {
#line 1500
            cp += 3;
#line 1501
            tmp___3 = strtoul((char const   */* __restrict  */)cp, (char **/* __restrict  */)(& ptr),
                              10);
#line 1501
            openfd = (int )tmp___3;
            }
#line 1502
            if (openfd <= -1) {
#line 1504
              openfd = -1;
            } else
#line 1502
            if ((unsigned long )ptr == (unsigned long )cp) {
#line 1504
              openfd = -1;
            } else {
              {
#line 1502
              tmp___4 = fstat(openfd, & sbuf);
              }
#line 1502
              if (tmp___4 < 0) {
#line 1504
                openfd = -1;
              }
            }
          }
        }
      }
    }
#line 1507
    if (openfd != -1) {
#line 1508
      return (openfd);
    }
  } else {
    {
#line 1509
    tmp___16 = inetfile(name, & len, & family);
    }
#line 1509
    if (tmp___16) {
      {
#line 1518
      cp = (char *)name + len;
#line 1520
      tmp___11 = strncmp((char const   *)cp, "tcp/", (size_t )4);
      }
#line 1520
      if (tmp___11 == 0) {
#line 1521
        protocol = 1;
      } else {
        {
#line 1522
        tmp___10 = strncmp((char const   *)cp, "udp/", (size_t )4);
        }
#line 1522
        if (tmp___10 == 0) {
#line 1523
          protocol = 2;
        } else {
          {
#line 1525
          protocol = 1;
#line 1526
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1526);
#line 1526
          tmp___9 = gettext("no (known) protocol supplied in special filename `%s\'");
#line 1526
          r_fatal((char const   *)tmp___9, name);
          }
        }
      }
#line 1529
      cp += 4;
#line 1532
      localpname = cp;
      {
#line 1533
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1533
        if ((int )*cp != 47) {
#line 1533
          if (! ((int )*cp != 0)) {
#line 1533
            goto while_break;
          }
        } else {
#line 1533
          goto while_break;
        }
#line 1534
        cp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1539
      if ((int )*cp != 47) {
        {
#line 1540
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1540);
#line 1540
        tmp___12 = gettext("special file name `%s\' is incomplete");
#line 1540
        r_fatal((char const   *)tmp___12, name);
        }
      } else
#line 1539
      if ((unsigned long )cp == (unsigned long )localpname) {
        {
#line 1540
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1540);
#line 1540
        tmp___12 = gettext("special file name `%s\' is incomplete");
#line 1540
        r_fatal((char const   *)tmp___12, name);
        }
      }
#line 1547
      *cp = (char )'\000';
#line 1548
      localpnamelastcharp = cp;
#line 1551
      cp ++;
#line 1552
      hostname = cp;
      {
#line 1553
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1553
        if ((int )*cp != 47) {
#line 1553
          if (! ((int )*cp != 0)) {
#line 1553
            goto while_break___0;
          }
        } else {
#line 1553
          goto while_break___0;
        }
#line 1554
        cp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1555
      if ((int )*cp != 47) {
        {
#line 1556
        *localpnamelastcharp = (char )'/';
#line 1557
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1557);
#line 1557
        tmp___13 = gettext("must supply a remote hostname to `/inet\'");
#line 1557
        r_fatal((char const   *)tmp___13);
        }
      } else
#line 1555
      if ((unsigned long )cp == (unsigned long )hostname) {
        {
#line 1556
        *localpnamelastcharp = (char )'/';
#line 1557
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1557);
#line 1557
        tmp___13 = gettext("must supply a remote hostname to `/inet\'");
#line 1557
        r_fatal((char const   *)tmp___13);
        }
      }
#line 1559
      *cp = (char )'\000';
#line 1560
      hostnameslastcharp = cp;
#line 1563
      cp ++;
#line 1572
      if ((int )*cp == 0) {
        {
#line 1573
        *localpnamelastcharp = (char )'/';
#line 1574
        *hostnameslastcharp = (char )'/';
#line 1575
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1575);
#line 1575
        tmp___14 = gettext("must supply a remote port to `/inet\'");
#line 1575
        r_fatal((char const   *)tmp___14);
        }
      }
#line 1582
      retries = 0UL;
#line 1585
      if (first_time) {
        {
#line 1587
        count = 0UL;
#line 1590
        first_time = (_Bool)0;
#line 1591
        cp___0 = getenv("GAWK_SOCK_RETRIES");
        }
#line 1591
        if ((unsigned long )cp___0 != (unsigned long )((void *)0)) {
          {
#line 1592
          count = strtoul((char const   */* __restrict  */)cp___0, (char **/* __restrict  */)(& end),
                          10);
          }
#line 1593
          if ((unsigned long )end != (unsigned long )cp___0) {
#line 1593
            if (count > 0UL) {
#line 1594
              def_retries = count;
            }
          }
        }
        {
#line 1602
        ms2 = getenv("GAWK_MSEC_SLEEP");
        }
#line 1602
        if ((unsigned long )ms2 != (unsigned long )((void *)0)) {
          {
#line 1603
          msleep = strtol((char const   */* __restrict  */)ms2, (char **/* __restrict  */)(& end),
                          10);
          }
#line 1604
          if ((unsigned long )end == (unsigned long )ms2) {
#line 1605
            msleep = 1000L;
          } else
#line 1604
          if (msleep < 0L) {
#line 1605
            msleep = 1000L;
          } else {
#line 1607
            msleep *= 1000L;
          }
        }
      }
#line 1610
      retries = def_retries;
      {
#line 1612
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1613
        openfd = socketopen(family, protocol, (char const   *)localpname, (char const   *)cp,
                            (char const   *)hostname);
#line 1614
        retries --;
        }
#line 1612
        if (openfd == -1) {
#line 1612
          if (retries > 0UL) {
            {
#line 1612
            tmp___15 = usleep((__useconds_t )msleep);
            }
#line 1612
            if (! (tmp___15 == 0)) {
#line 1612
              goto while_break___1;
            }
          } else {
#line 1612
            goto while_break___1;
          }
        } else {
#line 1612
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1618
      *localpnamelastcharp = (char )'/';
#line 1619
      *hostnameslastcharp = (char )'/';
    }
  }
  strictopen: 
#line 1626
  if (openfd == -1) {
    {
#line 1627
    openfd = open(name, flag, 438);
    }
  }
#line 1637
  if (openfd != -1) {
    {
#line 1638
    tmp___18 = fileno(stderr);
    }
#line 1638
    if (openfd > tmp___18) {
      {
#line 1639
      os_close_on_exec(openfd, name, "file", "");
      }
    }
  }
#line 1642
  return (openfd);
}
}
#line 1650 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static _Bool no_ptys  =    (_Bool)0;
#line 1696 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static _Bool initialized  =    (_Bool)0;
#line 1697 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static char first_pty_letter  ;
#line 1710 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static char pty_chars[27]  = 
#line 1710
  {      (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'a', 
        (char )'b',      (char )'c',      (char )'d',      (char )'e', 
        (char )'f',      (char )'g',      (char )'h',      (char )'i', 
        (char )'j',      (char )'k',      (char )'l',      (char )'m', 
        (char )'n',      (char )'o',      (char )'\000'};
#line 1647 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int two_way_open(char const   *str , struct redirect *rp ) 
{ 
  int fd ;
  int newfd ;
  int tmp___1 ;
  _Bool tmp___2 ;
  char slavenam[32] ;
  char c ;
  int master ;
  int dup_master ;
  int slave ;
  int save_errno ;
  pid_t pid ;
  struct stat statb ;
  struct termios st ;
  int i___0 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tem ;
  int i___1 ;
  char *cp ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int *tmp___33 ;
  int *tmp___34 ;
  int *tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  FILE *tmp___40 ;
  int tmp___41 ;
  int ptoc[2] ;
  int ctop[2] ;
  int pid___0 ;
  int save_errno___0 ;
  int tmp___42 ;
  int *tmp___43 ;
  int *tmp___44 ;
  int tmp___45 ;
  int *tmp___46 ;
  int *tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  int *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;
  int *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  int tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  int tmp___63 ;
  int *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int *tmp___72 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  void *__cil_tmp98 ;
  void *__cil_tmp99 ;
  void *__cil_tmp100 ;
  void *__cil_tmp101 ;
  void *__cil_tmp102 ;
  void *__cil_tmp103 ;
  void *__cil_tmp104 ;
  void *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;

  {
  {
#line 1654
  tmp___1 = inetfile(str, (int *)((void *)0), (int *)((void *)0));
  }
#line 1654
  if (tmp___1) {
    {
#line 1657
    fd = devopen(str, "rw");
    }
#line 1658
    if (fd == -1) {
#line 1659
      return (0);
    }
    {
#line 1660
    rp->output.fp = fdopen(fd, "w");
    }
#line 1661
    if ((unsigned long )rp->output.fp == (unsigned long )((void *)0)) {
      {
#line 1662
      close(fd);
      }
#line 1663
      return (0);
    }
    {
#line 1665
    newfd = dup(fd);
    }
#line 1666
    if (newfd < 0) {
      {
#line 1667
      (*(rp->output.gawk_fclose))(rp->output.fp, rp->output.opaque);
      }
#line 1668
      return (0);
    }
    {
#line 1670
    os_close_on_exec(fd, str, "socket", "to/from");
#line 1671
    os_close_on_exec(newfd, str, "socket", "to/from");
#line 1672
    rp->iop = iop_alloc(newfd, str, 0);
#line 1673
    rp->output.name = str;
#line 1674
    find_input_parser(rp->iop);
#line 1675
    iop_finish(rp->iop);
    }
#line 1676
    if (! (rp->iop)->valid) {
#line 1677
      if (! (do_flags & 8)) {
#line 1677
        if ((rp->iop)->errcode != 0) {
          {
#line 1678
          update_ERRNO_int((rp->iop)->errcode);
          }
        }
      }
      {
#line 1679
      iop_close(rp->iop);
#line 1680
      rp->iop = (IOBUF *)((void *)0);
#line 1681
      (*(rp->output.gawk_fclose))(rp->output.fp, rp->output.opaque);
      }
#line 1682
      return (0);
    }
#line 1684
    rp->flag |= 1024U;
#line 1685
    return (1);
  }
  {
#line 1690
  tmp___2 = find_two_way_processor(str, rp);
  }
#line 1690
  if (tmp___2) {
#line 1691
    return (1);
  }
#line 1695
  if (! no_ptys) {
    {
#line 1695
    tmp___41 = pty_vs_pipe(str);
    }
#line 1695
    if (tmp___41) {
#line 1713
      if (! initialized) {
#line 1714
        initialized = (_Bool)1;
#line 1718
        i___0 = 0;
        {
#line 1719
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1720
          tmp___3 = i___0;
#line 1720
          i___0 ++;
#line 1720
          c = pty_chars[tmp___3];
#line 1721
          sprintf((char */* __restrict  */)(slavenam), (char const   */* __restrict  */)"/dev/pty%c0",
                  (int )c);
#line 1722
          tmp___4 = stat((char const   */* __restrict  */)(slavenam), (struct stat */* __restrict  */)(& statb));
          }
#line 1722
          if (tmp___4 >= 0) {
#line 1723
            first_pty_letter = c;
#line 1724
            goto while_break;
          }
#line 1719
          if (! ((int )pty_chars[i___0] != 0)) {
#line 1719
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 1732
      master = posix_openpt(258);
      }
#line 1737
      if (master >= 0) {
        {
#line 1740
        grantpt(master);
#line 1741
        unlockpt(master);
#line 1742
        tem = ptsname(master);
        }
#line 1743
        if ((unsigned long )tem != (unsigned long )((void *)0)) {
          {
#line 1744
          strcpy((char */* __restrict  */)(slavenam), (char const   */* __restrict  */)tem);
          }
#line 1745
          goto got_the_pty;
        }
        {
#line 1747
        close(master);
        }
      }
#line 1752
      if (first_pty_letter) {
#line 1760
        c = first_pty_letter;
        {
#line 1761
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1765
          i___1 = 0;
          {
#line 1765
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1765
            if (! (i___1 < 16)) {
#line 1765
              goto while_break___1;
            }
            {
#line 1766
            sprintf((char */* __restrict  */)(slavenam), (char const   */* __restrict  */)"/dev/pty%c%x",
                    (int )c, i___1);
#line 1767
            tmp___5 = stat((char const   */* __restrict  */)(slavenam), (struct stat */* __restrict  */)(& statb));
            }
#line 1767
            if (tmp___5 < 0) {
#line 1768
              no_ptys = (_Bool)1;
#line 1769
              goto use_pipes;
            }
            {
#line 1772
            master = open((char const   *)(slavenam), 2);
            }
#line 1772
            if (master >= 0) {
              {
#line 1773
              slavenam[sizeof("/dev/") - 1UL] = (char )'t';
#line 1774
              tmp___6 = access((char const   *)(slavenam), 6);
              }
#line 1774
              if (tmp___6 == 0) {
#line 1775
                goto got_the_pty;
              }
              {
#line 1776
              close(master);
              }
            }
#line 1765
            i___1 ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 1780
          cp = strchr((char const   *)(pty_chars), (int )c);
          }
#line 1781
          if ((int )*(cp + 1) != 0) {
#line 1782
            cp ++;
          } else {
#line 1784
            cp = pty_chars;
          }
#line 1785
          c = *cp;
#line 1761
          if (! ((int )c != (int )first_pty_letter)) {
#line 1761
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 1788
        no_ptys = (_Bool)1;
      }
#line 1791
      goto use_pipes;
      got_the_pty: 
      {
#line 1794
      slave = open((char const   *)(slavenam), 2);
      }
#line 1794
      if (slave < 0) {
        {
#line 1795
        close(master);
#line 1796
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1796);
#line 1796
        tmp___7 = gettext("could not open `%s\', mode `%s\'");
#line 1796
        r_fatal((char const   *)tmp___7, slavenam, "r+");
        }
      }
      {
#line 1805
      ioctl(slave, (unsigned long )((83 << 8) | 2), "ptem");
#line 1806
      ioctl(slave, (unsigned long )((83 << 8) | 2), "ldterm");
#line 1809
      tcgetattr(slave, & st);
#line 1810
      st.c_iflag &= 4294962975U;
#line 1811
      st.c_iflag |= 1286U;
#line 1812
      st.c_oflag &= 4294967294U;
#line 1813
      st.c_cflag &= 4294967247U;
#line 1814
      st.c_cflag |= 2224U;
#line 1815
      st.c_lflag &= 4294966855U;
#line 1816
      st.c_lflag |= 1U;
#line 1820
      st.c_cc[0] = (cc_t )'\003';
#line 1823
      st.c_cc[1] = (cc_t )'\034';
#line 1826
      st.c_cc[2] = (cc_t )'\177';
#line 1829
      st.c_cc[3] = (cc_t )'\025';
#line 1832
      st.c_cc[4] = (cc_t )'\004';
#line 1834
      tcsetattr(slave, 0, (struct termios  const  *)(& st));
#line 1836
      pid = fork();
      }
      {
#line 1837
      if (pid == 0) {
#line 1837
        goto case_0;
      }
#line 1867
      if (pid == -1) {
#line 1867
        goto case_neg_1;
      }
#line 1836
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 1839
      setsid();
#line 1842
      ioctl(slave, 21518UL, 0);
#line 1845
      tmp___11 = close(master);
      }
#line 1845
      if (tmp___11 == -1) {
        {
#line 1846
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1846);
#line 1846
        tmp___8 = __errno_location();
#line 1846
        tmp___9 = strerror(*tmp___8);
#line 1846
        tmp___10 = gettext("close of master pty failed (%s)");
#line 1846
        r_fatal((char const   *)tmp___10, tmp___9);
        }
      }
      {
#line 1847
      tmp___15 = close(1);
      }
#line 1847
      if (tmp___15 == -1) {
        {
#line 1848
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1848);
#line 1848
        tmp___12 = __errno_location();
#line 1848
        tmp___13 = strerror(*tmp___12);
#line 1848
        tmp___14 = gettext("close of stdout in child failed (%s)");
#line 1848
        r_fatal((char const   *)tmp___14, tmp___13);
        }
      }
      {
#line 1850
      tmp___19 = dup(slave);
      }
#line 1850
      if (tmp___19 != 1) {
        {
#line 1851
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1851);
#line 1851
        tmp___16 = __errno_location();
#line 1851
        tmp___17 = strerror(*tmp___16);
#line 1851
        tmp___18 = gettext("moving slave pty to stdout in child failed (dup: %s)");
#line 1851
        r_fatal((char const   *)tmp___18, tmp___17);
        }
      }
      {
#line 1852
      tmp___23 = close(0);
      }
#line 1852
      if (tmp___23 == -1) {
        {
#line 1853
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1853);
#line 1853
        tmp___20 = __errno_location();
#line 1853
        tmp___21 = strerror(*tmp___20);
#line 1853
        tmp___22 = gettext("close of stdin in child failed (%s)");
#line 1853
        r_fatal((char const   *)tmp___22, tmp___21);
        }
      }
      {
#line 1855
      tmp___27 = dup(slave);
      }
#line 1855
      if (tmp___27 != 0) {
        {
#line 1856
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1856);
#line 1856
        tmp___24 = __errno_location();
#line 1856
        tmp___25 = strerror(*tmp___24);
#line 1856
        tmp___26 = gettext("moving slave pty to stdin in child failed (dup: %s)");
#line 1856
        r_fatal((char const   *)tmp___26, tmp___25);
        }
      }
      {
#line 1857
      tmp___31 = close(slave);
      }
#line 1857
      if (tmp___31) {
        {
#line 1858
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1858);
#line 1858
        tmp___28 = __errno_location();
#line 1858
        tmp___29 = strerror(*tmp___28);
#line 1858
        tmp___30 = gettext("close of slave pty failed (%s)");
#line 1858
        r_fatal((char const   *)tmp___30, tmp___29);
        }
      }
      {
#line 1862
      signal(13, (void (*)(int  ))0);
#line 1864
      execl("/bin/sh", "sh", "-c", str, (void *)0);
#line 1865
      tmp___33 = __errno_location();
      }
#line 1865
      if (*tmp___33 == 2) {
#line 1865
        tmp___32 = 127;
      } else {
#line 1865
        tmp___32 = 126;
      }
      {
#line 1865
      _exit(tmp___32);
      }
      case_neg_1: /* CIL Label */ 
      {
#line 1868
      tmp___34 = __errno_location();
#line 1868
      save_errno = *tmp___34;
#line 1869
      close(master);
#line 1870
      tmp___35 = __errno_location();
#line 1870
      *tmp___35 = save_errno;
      }
#line 1871
      return (0);
      switch_break: /* CIL Label */ ;
      }
      {
#line 1876
      tmp___39 = close(slave);
      }
#line 1876
      if (tmp___39 != 0) {
        {
#line 1877
        close(master);
#line 1878
        kill(pid, 9);
#line 1879
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 1879);
#line 1879
        tmp___36 = __errno_location();
#line 1879
        tmp___37 = strerror(*tmp___36);
#line 1879
        tmp___38 = gettext("close of slave pty failed (%s)");
#line 1879
        r_fatal((char const   *)tmp___38, tmp___37);
        }
      }
      {
#line 1882
      rp->pid = pid;
#line 1883
      rp->iop = iop_alloc(master, str, 0);
#line 1884
      find_input_parser(rp->iop);
#line 1885
      iop_finish(rp->iop);
      }
#line 1886
      if (! (rp->iop)->valid) {
#line 1887
        if (! (do_flags & 8)) {
#line 1887
          if ((rp->iop)->errcode != 0) {
            {
#line 1888
            update_ERRNO_int((rp->iop)->errcode);
            }
          }
        }
        {
#line 1889
        iop_close(rp->iop);
#line 1890
        rp->iop = (IOBUF *)((void *)0);
#line 1891
        kill(pid, 9);
        }
#line 1892
        return (0);
      }
      {
#line 1895
      rp->output.name = str;
#line 1900
      rp->output.mode = "w";
#line 1901
      dup_master = dup(master);
      }
#line 1901
      if (dup_master < 0) {
#line 1901
        goto _L;
      } else {
        {
#line 1901
        tmp___40 = fdopen(dup_master, "w");
#line 1901
        rp->output.fp = tmp___40;
        }
#line 1901
        if ((unsigned long )tmp___40 == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          {
#line 1903
          iop_close(rp->iop);
#line 1904
          rp->iop = (IOBUF *)((void *)0);
#line 1905
          close(master);
#line 1906
          kill(pid, 9);
          }
#line 1907
          if (dup_master > 0) {
            {
#line 1908
            close(dup_master);
            }
          }
#line 1909
          return (0);
        } else {
          {
#line 1911
          find_output_wrapper(& rp->output);
          }
        }
      }
      {
#line 1912
      rp->flag |= 512U;
#line 1913
      os_close_on_exec(master, str, "pipe", "from");
#line 1914
      os_close_on_exec(dup_master, str, "pipe", "to");
#line 1915
      first_pty_letter = (char )'\000';
      }
#line 1916
      return (1);
    }
  }
  use_pipes: 
  {
#line 1931
  tmp___42 = pipe((int *)(ptoc));
  }
#line 1931
  if (tmp___42 < 0) {
#line 1932
    return (0);
  }
  {
#line 1934
  tmp___45 = pipe((int *)(ctop));
  }
#line 1934
  if (tmp___45 < 0) {
    {
#line 1935
    tmp___43 = __errno_location();
#line 1935
    save_errno___0 = *tmp___43;
#line 1936
    close(ptoc[0]);
#line 1937
    close(ptoc[1]);
#line 1938
    tmp___44 = __errno_location();
#line 1938
    *tmp___44 = save_errno___0;
    }
#line 1939
    return (0);
  }
  {
#line 2014
  pid___0 = fork();
  }
#line 2014
  if (pid___0 < 0) {
    {
#line 2015
    tmp___46 = __errno_location();
#line 2015
    save_errno___0 = *tmp___46;
#line 2016
    close(ptoc[0]);
#line 2016
    close(ptoc[1]);
#line 2017
    close(ctop[0]);
#line 2017
    close(ctop[1]);
#line 2018
    tmp___47 = __errno_location();
#line 2018
    *tmp___47 = save_errno___0;
    }
#line 2019
    return (0);
  }
#line 2022
  if (pid___0 == 0) {
    {
#line 2023
    tmp___51 = close(1);
    }
#line 2023
    if (tmp___51 == -1) {
      {
#line 2024
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2024);
#line 2024
      tmp___48 = __errno_location();
#line 2024
      tmp___49 = strerror(*tmp___48);
#line 2024
      tmp___50 = gettext("close of stdout in child failed (%s)");
#line 2024
      r_fatal((char const   *)tmp___50, tmp___49);
      }
    }
    {
#line 2026
    tmp___55 = dup(ctop[1]);
    }
#line 2026
    if (tmp___55 != 1) {
      {
#line 2027
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2027);
#line 2027
      tmp___52 = __errno_location();
#line 2027
      tmp___53 = strerror(*tmp___52);
#line 2027
      tmp___54 = gettext("moving pipe to stdout in child failed (dup: %s)");
#line 2027
      r_fatal((char const   *)tmp___54, tmp___53);
      }
    }
    {
#line 2028
    tmp___59 = close(0);
    }
#line 2028
    if (tmp___59 == -1) {
      {
#line 2029
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2029);
#line 2029
      tmp___56 = __errno_location();
#line 2029
      tmp___57 = strerror(*tmp___56);
#line 2029
      tmp___58 = gettext("close of stdin in child failed (%s)");
#line 2029
      r_fatal((char const   *)tmp___58, tmp___57);
      }
    }
    {
#line 2031
    tmp___63 = dup(ptoc[0]);
    }
#line 2031
    if (tmp___63 != 0) {
      {
#line 2032
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2032);
#line 2032
      tmp___60 = __errno_location();
#line 2032
      tmp___61 = strerror(*tmp___60);
#line 2032
      tmp___62 = gettext("moving pipe to stdin in child failed (dup: %s)");
#line 2032
      r_fatal((char const   *)tmp___62, tmp___61);
      }
    }
    {
#line 2033
    tmp___67 = close(ptoc[0]);
    }
#line 2033
    if (tmp___67 == -1) {
      {
#line 2035
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2035);
#line 2035
      tmp___64 = __errno_location();
#line 2035
      tmp___65 = strerror(*tmp___64);
#line 2035
      tmp___66 = gettext("close of pipe failed (%s)");
#line 2035
      r_fatal((char const   *)tmp___66, tmp___65);
      }
    } else {
      {
#line 2033
      tmp___68 = close(ptoc[1]);
      }
#line 2033
      if (tmp___68 == -1) {
        {
#line 2035
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2035);
#line 2035
        tmp___64 = __errno_location();
#line 2035
        tmp___65 = strerror(*tmp___64);
#line 2035
        tmp___66 = gettext("close of pipe failed (%s)");
#line 2035
        r_fatal((char const   *)tmp___66, tmp___65);
        }
      } else {
        {
#line 2033
        tmp___69 = close(ctop[0]);
        }
#line 2033
        if (tmp___69 == -1) {
          {
#line 2035
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2035);
#line 2035
          tmp___64 = __errno_location();
#line 2035
          tmp___65 = strerror(*tmp___64);
#line 2035
          tmp___66 = gettext("close of pipe failed (%s)");
#line 2035
          r_fatal((char const   *)tmp___66, tmp___65);
          }
        } else {
          {
#line 2033
          tmp___70 = close(ctop[1]);
          }
#line 2033
          if (tmp___70 == -1) {
            {
#line 2035
            set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2035);
#line 2035
            tmp___64 = __errno_location();
#line 2035
            tmp___65 = strerror(*tmp___64);
#line 2035
            tmp___66 = gettext("close of pipe failed (%s)");
#line 2035
            r_fatal((char const   *)tmp___66, tmp___65);
            }
          }
        }
      }
    }
    {
#line 2037
    execl("/bin/sh", "sh", "-c", str, (void *)0);
#line 2038
    tmp___72 = __errno_location();
    }
#line 2038
    if (*tmp___72 == 2) {
#line 2038
      tmp___71 = 127;
    } else {
#line 2038
      tmp___71 = 126;
    }
    {
#line 2038
    _exit(tmp___71);
    }
  }
  {
#line 2043
  rp->pid = pid___0;
#line 2044
  rp->iop = iop_alloc(ctop[0], str, 0);
#line 2045
  find_input_parser(rp->iop);
#line 2046
  iop_finish(rp->iop);
  }
#line 2047
  if (! (rp->iop)->valid) {
#line 2048
    if (! (do_flags & 8)) {
#line 2048
      if ((rp->iop)->errcode != 0) {
        {
#line 2049
        update_ERRNO_int((rp->iop)->errcode);
        }
      }
    }
    {
#line 2050
    iop_close(rp->iop);
#line 2051
    rp->iop = (IOBUF *)((void *)0);
#line 2052
    close(ctop[1]);
#line 2053
    close(ptoc[0]);
#line 2054
    close(ptoc[1]);
#line 2055
    kill(pid___0, 9);
    }
#line 2057
    return (0);
  }
  {
#line 2059
  rp->output.fp = fdopen(ptoc[1], "w");
#line 2060
  rp->output.mode = "w";
#line 2061
  rp->output.name = str;
  }
#line 2062
  if ((unsigned long )rp->output.fp == (unsigned long )((void *)0)) {
    {
#line 2063
    iop_close(rp->iop);
#line 2064
    rp->iop = (IOBUF *)((void *)0);
#line 2065
    close(ctop[0]);
#line 2066
    close(ctop[1]);
#line 2067
    close(ptoc[0]);
#line 2068
    close(ptoc[1]);
#line 2069
    kill(pid___0, 9);
    }
#line 2071
    return (0);
  } else {
    {
#line 2074
    find_output_wrapper(& rp->output);
    }
  }
  {
#line 2077
  os_close_on_exec(ctop[0], str, "pipe", "from");
#line 2078
  os_close_on_exec(ptoc[1], str, "pipe", "from");
#line 2080
  close(ptoc[0]);
#line 2081
  close(ctop[1]);
  }
#line 2084
  return (1);
}
}
#line 2100 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int wait_any(int interesting ) 
{ 
  void (*hstat)(int  ) ;
  void (*istat)(int  ) ;
  void (*qstat)(int  ) ;
  int pid ;
  int status ;
  struct redirect *redp ;
  int *tmp___1 ;

  {
  {
#line 2105
  status = 0;
#line 2108
  hstat = signal(1, (void (*)(int  ))1);
#line 2109
  istat = signal(2, (void (*)(int  ))1);
#line 2110
  qstat = signal(3, (void (*)(int  ))1);
  }
  {
#line 2111
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2113
    pid = wait((union wait *)(& status));
    }
#line 2117
    if (interesting) {
#line 2117
      if (pid == interesting) {
#line 2118
        goto while_break;
      } else {
#line 2117
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2119
    if (pid != -1) {
#line 2120
      redp = red_head;
      {
#line 2120
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2120
        if (! ((unsigned long )redp != (unsigned long )((void *)0))) {
#line 2120
          goto while_break___0;
        }
#line 2121
        if (pid == redp->pid) {
#line 2122
          redp->pid = -1;
#line 2123
          redp->status = status;
#line 2124
          goto while_break___0;
        }
#line 2120
        redp = redp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2127
    if (pid == -1) {
      {
#line 2127
      tmp___1 = __errno_location();
      }
#line 2127
      if (*tmp___1 == 10) {
#line 2128
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2130
  signal(1, hstat);
#line 2131
  signal(2, istat);
#line 2132
  signal(3, qstat);
  }
#line 2133
  return (status);
}
}
#line 2138 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static IOBUF *gawk_popen(char const   *cmd , struct redirect *rp ) 
{ 
  int p[2] ;
  int pid ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
  {
#line 2155
  tmp___4 = pipe((int *)(p));
  }
#line 2155
  if (tmp___4 < 0) {
    {
#line 2156
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2156);
#line 2156
    tmp___1 = __errno_location();
#line 2156
    tmp___2 = strerror(*tmp___1);
#line 2156
    tmp___3 = gettext("cannot open pipe `%s\' (%s)");
#line 2156
    r_fatal((char const   *)tmp___3, cmd, tmp___2);
    }
  }
  {
#line 2192
  pid = fork();
  }
#line 2192
  if (pid == 0) {
    {
#line 2193
    tmp___8 = close(1);
    }
#line 2193
    if (tmp___8 == -1) {
      {
#line 2194
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2194);
#line 2194
      tmp___5 = __errno_location();
#line 2194
      tmp___6 = strerror(*tmp___5);
#line 2194
      tmp___7 = gettext("close of stdout in child failed (%s)");
#line 2194
      r_fatal((char const   *)tmp___7, tmp___6);
      }
    }
    {
#line 2196
    tmp___12 = dup(p[1]);
    }
#line 2196
    if (tmp___12 != 1) {
      {
#line 2197
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2197);
#line 2197
      tmp___9 = __errno_location();
#line 2197
      tmp___10 = strerror(*tmp___9);
#line 2197
      tmp___11 = gettext("moving pipe to stdout in child failed (dup: %s)");
#line 2197
      r_fatal((char const   *)tmp___11, tmp___10);
      }
    }
    {
#line 2198
    tmp___16 = close(p[0]);
    }
#line 2198
    if (tmp___16 == -1) {
      {
#line 2199
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2199);
#line 2199
      tmp___13 = __errno_location();
#line 2199
      tmp___14 = strerror(*tmp___13);
#line 2199
      tmp___15 = gettext("close of pipe failed (%s)");
#line 2199
      r_fatal((char const   *)tmp___15, tmp___14);
      }
    } else {
      {
#line 2198
      tmp___17 = close(p[1]);
      }
#line 2198
      if (tmp___17 == -1) {
        {
#line 2199
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2199);
#line 2199
        tmp___13 = __errno_location();
#line 2199
        tmp___14 = strerror(*tmp___13);
#line 2199
        tmp___15 = gettext("close of pipe failed (%s)");
#line 2199
        r_fatal((char const   *)tmp___15, tmp___14);
        }
      }
    }
    {
#line 2200
    execl("/bin/sh", "sh", "-c", cmd, (void *)0);
#line 2201
    tmp___19 = __errno_location();
    }
#line 2201
    if (*tmp___19 == 2) {
#line 2201
      tmp___18 = 127;
    } else {
#line 2201
      tmp___18 = 126;
    }
    {
#line 2201
    _exit(tmp___18);
    }
  }
#line 2205
  if (pid == -1) {
    {
#line 2206
    close(p[0]);
#line 2206
    close(p[1]);
#line 2207
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2207);
#line 2207
    tmp___20 = __errno_location();
#line 2207
    tmp___21 = strerror(*tmp___20);
#line 2207
    tmp___22 = gettext("cannot create child process for `%s\' (fork: %s)");
#line 2207
    r_fatal((char const   *)tmp___22, cmd, tmp___21);
    }
  }
  {
#line 2209
  rp->pid = pid;
#line 2211
  tmp___26 = close(p[1]);
  }
#line 2211
  if (tmp___26 == -1) {
    {
#line 2212
    close(p[0]);
#line 2213
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2213);
#line 2213
    tmp___23 = __errno_location();
#line 2213
    tmp___24 = strerror(*tmp___23);
#line 2213
    tmp___25 = gettext("close of pipe failed (%s)");
#line 2213
    r_fatal((char const   *)tmp___25, tmp___24);
    }
  }
  {
#line 2216
  os_close_on_exec(p[0], cmd, "pipe", "from");
#line 2217
  rp->iop = iop_alloc(p[0], cmd, 0);
#line 2218
  find_input_parser(rp->iop);
#line 2219
  iop_finish(rp->iop);
  }
#line 2220
  if (! (rp->iop)->valid) {
#line 2221
    if (! (do_flags & 8)) {
#line 2221
      if ((rp->iop)->errcode != 0) {
        {
#line 2222
        update_ERRNO_int((rp->iop)->errcode);
        }
      }
    }
    {
#line 2223
    iop_close(rp->iop);
#line 2224
    rp->iop = (IOBUF *)((void *)0);
    }
  }
#line 2227
  return (rp->iop);
}
}
#line 2232 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int gawk_pclose(struct redirect *rp ) 
{ 


  {
#line 2235
  if ((unsigned long )rp->iop != (unsigned long )((void *)0)) {
    {
#line 2236
    iop_close(rp->iop);
    }
  }
#line 2237
  rp->iop = (IOBUF *)((void *)0);
#line 2240
  if (rp->pid == -1) {
#line 2241
    return (rp->status);
  }
  {
#line 2242
  rp->status = wait_any(rp->pid);
#line 2243
  rp->pid = -1;
  }
#line 2244
  return (rp->status);
}
}
#line 2305 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
NODE *do_getline_redir(int into_variable , enum redirval redirtype ) 
{ 
  struct redirect *rp ;
  IOBUF *iop ;
  int cnt ;
  char *s___0 ;
  int errcode ;
  NODE *redir_exp ;
  NODE **lhs ;
  int redir_error ;
  STACK_ITEM *tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  NODE *tmp___5 ;
  NODE *tmp___6 ;

  {
#line 2308
  rp = (struct redirect *)((void *)0);
#line 2310
  cnt = -1;
#line 2311
  s___0 = (char *)((void *)0);
#line 2313
  redir_exp = (NODE *)((void *)0);
#line 2314
  lhs = (NODE **)((void *)0);
#line 2315
  redir_error = 0;
#line 2317
  if (into_variable) {
#line 2318
    tmp___1 = stack_ptr;
#line 2318
    stack_ptr --;
#line 2318
    lhs = tmp___1->lptr;
  }
  {
#line 2321
  redir_exp = stack_ptr->rptr;
#line 2322
  rp = redirect(redir_exp, (int )redirtype, & redir_error);
#line 2323
  DEREF(redir_exp);
#line 2324
  stack_ptr --;
  }
#line 2325
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 2326
    if (redir_error) {
#line 2327
      if (! (do_flags & 8)) {
        {
#line 2328
        update_ERRNO_int(redir_error);
        }
      }
    }
    {
#line 2330
    tmp___2 = (*make_number)(- 1.0);
    }
#line 2330
    return (tmp___2);
  }
#line 2332
  iop = rp->iop;
#line 2333
  if ((unsigned long )iop == (unsigned long )((void *)0)) {
    {
#line 2334
    tmp___3 = (*make_number)(0.0);
    }
#line 2334
    return (tmp___3);
  }
  {
#line 2336
  errcode = 0;
#line 2337
  cnt = get_a_record(& s___0, iop, & errcode);
  }
#line 2338
  if (errcode != 0) {
#line 2339
    if (! (do_flags & 8)) {
#line 2339
      if (errcode != -1) {
        {
#line 2340
        update_ERRNO_int(errcode);
        }
      }
    }
    {
#line 2341
    tmp___4 = (*make_number)(- 1.0);
    }
#line 2341
    return (tmp___4);
  }
#line 2344
  if (cnt == -1) {
#line 2350
    if ((rp->flag & 258U) == 0U) {
      {
#line 2351
      iop_close(iop);
#line 2352
      rp->iop = (IOBUF *)((void *)0);
      }
    }
    {
#line 2354
    rp->flag |= 128U;
#line 2355
    tmp___5 = (*make_number)(0.0);
    }
#line 2355
    return (tmp___5);
  }
#line 2358
  if ((unsigned long )lhs == (unsigned long )((void *)0)) {
    {
#line 2359
    set_record((char const   *)s___0, cnt);
    }
  } else {
    {
#line 2361
    unref(*lhs);
#line 2362
    *lhs = make_str_node((char const   *)s___0, (size_t )cnt, 0);
#line 2363
    (*lhs)->flags |= 32U;
    }
  }
  {
#line 2366
  tmp___6 = (*make_number)(1.0);
  }
#line 2366
  return (tmp___6);
}
}
#line 2371 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
NODE *do_getline(int into_variable , IOBUF *iop ) 
{ 
  int cnt ;
  char *s___0 ;
  int errcode ;
  STACK_ITEM *tmp___1 ;
  NODE *tmp___2 ;
  STACK_ITEM *tmp___3 ;
  NODE *tmp___4 ;
  NODE **lhs ;
  STACK_ITEM *tmp___5 ;
  NODE *tmp___6 ;

  {
#line 2374
  cnt = -1;
#line 2375
  s___0 = (char *)((void *)0);
#line 2378
  if ((unsigned long )iop == (unsigned long )((void *)0)) {
#line 2379
    if (into_variable) {
#line 2380
      tmp___1 = stack_ptr;
#line 2380
      stack_ptr --;
    }
    {
#line 2381
    tmp___2 = (*make_number)(0.0);
    }
#line 2381
    return (tmp___2);
  }
  {
#line 2384
  errcode = 0;
#line 2385
  cnt = get_a_record(& s___0, iop, & errcode);
  }
#line 2386
  if (errcode != 0) {
#line 2387
    if (! (do_flags & 8)) {
#line 2387
      if (errcode != -1) {
        {
#line 2388
        update_ERRNO_int(errcode);
        }
      }
    }
#line 2389
    if (into_variable) {
#line 2390
      tmp___3 = stack_ptr;
#line 2390
      stack_ptr --;
    }
    {
#line 2391
    tmp___4 = (*make_number)(- 1.0);
    }
#line 2391
    return (tmp___4);
  }
#line 2394
  if (cnt == -1) {
#line 2395
    return ((NODE *)((void *)0));
  }
#line 2396
  if (do_flags & 16384) {
#line 2396
    if (NR == 9223372036854775806L) {
      {
#line 2396
      __gmpz_add_ui(MNR, (mpz_srcptr )(MNR), 1UL);
#line 2396
      NR = 0L;
      }
    } else {
#line 2396
      NR ++;
    }
  } else {
#line 2396
    NR ++;
  }
#line 2397
  if (do_flags & 16384) {
#line 2397
    if (FNR == 9223372036854775806L) {
      {
#line 2397
      __gmpz_add_ui(MFNR, (mpz_srcptr )(MFNR), 1UL);
#line 2397
      FNR = 0L;
      }
    } else {
#line 2397
      FNR ++;
    }
  } else {
#line 2397
    FNR ++;
  }
#line 2399
  if (! into_variable) {
    {
#line 2400
    set_record((char const   *)s___0, cnt);
    }
  } else {
    {
#line 2403
    tmp___5 = stack_ptr;
#line 2403
    stack_ptr --;
#line 2403
    lhs = tmp___5->lptr;
#line 2404
    unref(*lhs);
#line 2405
    *lhs = make_str_node((char const   *)s___0, (size_t )cnt, 0);
#line 2406
    (*lhs)->flags |= 32U;
    }
  }
  {
#line 2408
  tmp___6 = (*make_number)(1.0);
  }
#line 2408
  return (tmp___6);
}
}
#line 2419 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static path_info pi_awkpath  =    {"AWKPATH", & defpath, (char)1, (char **)0, 0};
#line 2425 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static path_info pi_awklibpath  =    {"AWKLIBPATH", & deflibpath, (char)0, (char **)0, 0};
#line 2433 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static void init_awkpath(path_info *pi ) 
{ 
  char *path ;
  char *start ;
  char *end ;
  char *p ;
  int len ;
  int i___0 ;
  int max_path ;
  char **tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char **tmp___14 ;
  void *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 2443
  pi->max_pathlen = 0;
#line 2444
  path = getenv(pi->envname);
  }
#line 2444
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 2445
    path = *(pi->dfltp + 0);
  } else
#line 2444
  if ((int )*path == 0) {
#line 2445
    path = *(pi->dfltp + 0);
  }
  {
#line 2447
  max_path = 5;
#line 2448
  tmp___2 = malloc((unsigned long )(max_path + 1) * sizeof(char *));
#line 2448
  tmp___1 = (char **)tmp___2;
#line 2448
  pi->awkpath = tmp___1;
  }
#line 2448
  if (tmp___1) {
#line 2448
    tmp___6 = 1;
  } else {
    {
#line 2448
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2448);
#line 2448
    tmp___3 = __errno_location();
#line 2448
    tmp___4 = strerror(*tmp___3);
#line 2448
    tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2448
    r_fatal((char const   *)tmp___5, "init_awkpath", "pi->awkpath", (long )((unsigned long )(max_path + 1) * sizeof(char *)),
            tmp___4);
#line 2448
    tmp___6 = 0;
    }
  }
  {
#line 2449
  memset((void *)pi->awkpath, 0, (unsigned long )(max_path + 1) * sizeof(char *));
#line 2451
  start = path;
#line 2451
  end = start;
#line 2452
  i___0 = 0;
  }
  {
#line 2453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2453
    if (! *start) {
#line 2453
      goto while_break;
    }
    {
#line 2454
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2454
      if (*end) {
#line 2454
        if (! ((int )*end != (int )envsep)) {
#line 2454
          goto while_break___0;
        }
      } else {
#line 2454
        goto while_break___0;
      }
#line 2455
      end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2456
    len = (int )(end - start);
#line 2457
    if (len > 0) {
      {
#line 2458
      tmp___7 = malloc((size_t )(len + 2));
#line 2458
      p = (char *)tmp___7;
      }
#line 2458
      if (p) {
#line 2458
        tmp___11 = 1;
      } else {
        {
#line 2458
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2458);
#line 2458
        tmp___8 = __errno_location();
#line 2458
        tmp___9 = strerror(*tmp___8);
#line 2458
        tmp___10 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2458
        r_fatal((char const   *)tmp___10, "init_awkpath", "p", (long )(len + 2), tmp___9);
#line 2458
        tmp___11 = 0;
        }
      }
      {
#line 2459
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)start, (size_t )len);
#line 2462
      tmp___13 = isdirpunct((int )*(end + -1));
      }
#line 2462
      if (! tmp___13) {
#line 2463
        tmp___12 = len;
#line 2463
        len ++;
#line 2463
        *(p + tmp___12) = (char )'/';
      }
#line 2464
      *(p + len) = (char )'\000';
#line 2466
      if (i___0 == max_path) {
        {
#line 2467
        max_path += 5;
#line 2468
        tmp___15 = realloc((void *)((char *)pi->awkpath), (unsigned long )(max_path + 1) * sizeof(char *));
#line 2468
        tmp___14 = (char **)tmp___15;
#line 2468
        pi->awkpath = tmp___14;
        }
#line 2468
        if (tmp___14) {
#line 2468
          tmp___19 = 1;
        } else {
          {
#line 2468
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2468);
#line 2468
          tmp___16 = __errno_location();
#line 2468
          tmp___17 = strerror(*tmp___16);
#line 2468
          tmp___18 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2468
          r_fatal((char const   *)tmp___18, "init_awkpath", "pi->awkpath", (long )((unsigned long )(max_path + 1) * sizeof(char *)),
                  tmp___17);
#line 2468
          tmp___19 = 0;
          }
        }
        {
#line 2469
        memset((void *)(pi->awkpath + i___0), 0, 6UL * sizeof(char *));
        }
      }
#line 2471
      tmp___20 = i___0;
#line 2471
      i___0 ++;
#line 2471
      *(pi->awkpath + tmp___20) = p;
#line 2472
      if (len > pi->max_pathlen) {
#line 2473
        pi->max_pathlen = len;
      }
    }
    {
#line 2477
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2477
      if (*end) {
#line 2477
        if (! ((int )*end == (int )envsep)) {
#line 2477
          goto while_break___1;
        }
      } else {
#line 2477
        goto while_break___1;
      }
#line 2478
      end ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2479
    start = end;
  }
  while_break: /* CIL Label */ ;
  }
#line 2481
  *(pi->awkpath + i___0) = (char *)((void *)0);
#line 2484
  return;
}
}
#line 2488 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static char *get_cwd(void) 
{ 
  char *buf___7 ;
  size_t bsize ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 2493
  bsize = (size_t )100;
#line 2495
  tmp___1 = malloc(bsize * sizeof(char ));
#line 2495
  buf___7 = (char *)tmp___1;
  }
#line 2495
  if (buf___7) {
#line 2495
    tmp___5 = 1;
  } else {
    {
#line 2495
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2495);
#line 2495
    tmp___2 = __errno_location();
#line 2495
    tmp___3 = strerror(*tmp___2);
#line 2495
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2495
    r_fatal((char const   *)tmp___4, "get_cwd", "buf", (long )(bsize * sizeof(char )),
            tmp___3);
#line 2495
    tmp___5 = 0;
    }
  }
  {
#line 2496
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2497
    tmp___6 = getcwd(buf___7, bsize);
    }
#line 2497
    if ((unsigned long )tmp___6 == (unsigned long )buf___7) {
#line 2498
      return (buf___7);
    }
    {
#line 2499
    tmp___7 = __errno_location();
    }
#line 2499
    if (*tmp___7 != 34) {
      {
#line 2500
      free((void *)buf___7);
      }
#line 2501
      return ((char *)((void *)0));
    }
    {
#line 2503
    bsize *= 2UL;
#line 2504
    tmp___8 = realloc((void *)buf___7, bsize * sizeof(char ));
#line 2504
    buf___7 = (char *)tmp___8;
    }
#line 2504
    if (buf___7) {
#line 2504
      tmp___12 = 1;
    } else {
      {
#line 2504
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2504);
#line 2504
      tmp___9 = __errno_location();
#line 2504
      tmp___10 = strerror(*tmp___9);
#line 2504
      tmp___11 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2504
      r_fatal((char const   *)tmp___11, "get_cwd", "buf", (long )(bsize * sizeof(char )),
              tmp___10);
#line 2504
      tmp___12 = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2512 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static char *do_find_source(char const   *src , struct stat *stb , int *errcode ,
                            path_info *pi ) 
{ 
  char *path ;
  int i___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
#line 2521
  tmp___10 = ispath(src);
  }
#line 2521
  if (tmp___10) {
    {
#line 2522
    tmp___1 = strlen(src);
#line 2522
    tmp___2 = malloc(tmp___1 + 1UL);
#line 2522
    path = (char *)tmp___2;
    }
#line 2522
    if (path) {
#line 2522
      tmp___7 = 1;
    } else {
      {
#line 2522
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2522);
#line 2522
      tmp___3 = __errno_location();
#line 2522
      tmp___4 = strerror(*tmp___3);
#line 2522
      tmp___5 = strlen(src);
#line 2522
      tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2522
      r_fatal((char const   *)tmp___6, "do_find_source", "path", (long )(tmp___5 + 1UL),
              tmp___4);
#line 2522
      tmp___7 = 0;
      }
    }
    {
#line 2523
    strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)src);
#line 2524
    tmp___8 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)stb);
    }
#line 2524
    if (tmp___8 == 0) {
#line 2525
      return (path);
    }
    {
#line 2526
    tmp___9 = __errno_location();
#line 2526
    *errcode = *tmp___9;
#line 2527
    free((void *)path);
    }
#line 2528
    return ((char *)((void *)0));
  }
#line 2532
  if (pi->try_cwd) {
    {
#line 2532
    tmp___21 = stat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)stb);
    }
#line 2532
    if (tmp___21 == 0) {
      {
#line 2533
      path = get_cwd();
      }
#line 2534
      if ((unsigned long )path == (unsigned long )((void *)0)) {
        {
#line 2535
        tmp___11 = __errno_location();
#line 2535
        *errcode = *tmp___11;
        }
#line 2536
        return ((char *)((void *)0));
      }
      {
#line 2538
      tmp___12 = strlen((char const   *)path);
#line 2538
      tmp___13 = strlen(src);
#line 2538
      tmp___14 = realloc((void *)path, (tmp___12 + tmp___13) + 2UL);
#line 2538
      path = (char *)tmp___14;
      }
#line 2538
      if (path) {
#line 2538
        tmp___20 = 1;
      } else {
        {
#line 2538
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2538);
#line 2538
        tmp___15 = __errno_location();
#line 2538
        tmp___16 = strerror(*tmp___15);
#line 2538
        tmp___17 = strlen((char const   *)path);
#line 2538
        tmp___18 = strlen(src);
#line 2538
        tmp___19 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2538
        r_fatal((char const   *)tmp___19, "do_find_source", "path", (long )((tmp___17 + tmp___18) + 2UL),
                tmp___16);
#line 2538
        tmp___20 = 0;
        }
      }
      {
#line 2540
      strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
#line 2542
      strcat((char */* __restrict  */)path, (char const   */* __restrict  */)src);
      }
#line 2543
      return (path);
    }
  }
#line 2546
  if ((unsigned long )pi->awkpath == (unsigned long )((void *)0)) {
    {
#line 2547
    init_awkpath(pi);
    }
  }
  {
#line 2549
  tmp___22 = strlen(src);
#line 2549
  tmp___23 = malloc(((size_t )pi->max_pathlen + tmp___22) + 1UL);
#line 2549
  path = (char *)tmp___23;
  }
#line 2549
  if (path) {
#line 2549
    tmp___28 = 1;
  } else {
    {
#line 2549
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2549);
#line 2549
    tmp___24 = __errno_location();
#line 2549
    tmp___25 = strerror(*tmp___24);
#line 2549
    tmp___26 = strlen(src);
#line 2549
    tmp___27 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2549
    r_fatal((char const   *)tmp___27, "do_find_source", "path", (long )(((size_t )pi->max_pathlen + tmp___26) + 1UL),
            tmp___25);
#line 2549
    tmp___28 = 0;
    }
  }
#line 2550
  i___0 = 0;
  {
#line 2550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2550
    if (! ((unsigned long )*(pi->awkpath + i___0) != (unsigned long )((void *)0))) {
#line 2550
      goto while_break;
    }
    {
#line 2551
    tmp___29 = strcmp((char const   *)*(pi->awkpath + i___0), "./");
    }
#line 2551
    if (tmp___29 == 0) {
#line 2552
      *path = (char )'\000';
    } else {
      {
#line 2551
      tmp___30 = strcmp((char const   *)*(pi->awkpath + i___0), ".");
      }
#line 2551
      if (tmp___30 == 0) {
#line 2552
        *path = (char )'\000';
      } else {
        {
#line 2554
        strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)*(pi->awkpath + i___0));
        }
      }
    }
    {
#line 2555
    strcat((char */* __restrict  */)path, (char const   */* __restrict  */)src);
#line 2556
    tmp___31 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)stb);
    }
#line 2556
    if (tmp___31 == 0) {
#line 2557
      return (path);
    }
#line 2550
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2561
  tmp___32 = __errno_location();
#line 2561
  *errcode = *tmp___32;
#line 2562
  free((void *)path);
  }
#line 2563
  return ((char *)((void *)0));
}
}
#line 2568 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
char *find_source(char const   *src , struct stat *stb , int *errcode , int is_extlib ) 
{ 
  char *path ;
  path_info *pi ;
  path_info *tmp___1 ;
  char *file_ext ;
  int save_errno ;
  size_t src_len ;
  size_t suffix_len ;
  int tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *file_awk ;
  int save_errno___0 ;
  int *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 2572
  if (is_extlib) {
#line 2572
    tmp___1 = & pi_awklibpath;
  } else {
#line 2572
    tmp___1 = & pi_awkpath;
  }
#line 2572
  pi = tmp___1;
#line 2574
  *errcode = 0;
#line 2575
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 2576
    return ((char *)((void *)0));
  } else
#line 2575
  if ((int const   )*src == 0) {
#line 2576
    return ((char *)((void *)0));
  }
  {
#line 2577
  path = do_find_source(src, stb, errcode, pi);
  }
#line 2579
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 2579
    if (is_extlib) {
      {
#line 2586
      src_len = strlen(src);
#line 2587
      suffix_len = strlen(".so");
      }
#line 2590
      if (src_len >= suffix_len) {
        {
#line 2590
        tmp___2 = strcmp(src + (src_len - suffix_len), ".so");
        }
#line 2590
        if (tmp___2 == 0) {
#line 2591
          return ((char *)((void *)0));
        }
      }
      {
#line 2594
      tmp___3 = __errno_location();
#line 2594
      save_errno = *tmp___3;
#line 2595
      tmp___4 = malloc((src_len + suffix_len) + 1UL);
#line 2595
      file_ext = (char *)tmp___4;
      }
#line 2595
      if (file_ext) {
#line 2595
        tmp___8 = 1;
      } else {
        {
#line 2595
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2595);
#line 2595
        tmp___5 = __errno_location();
#line 2595
        tmp___6 = strerror(*tmp___5);
#line 2595
        tmp___7 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2595
        r_fatal((char const   *)tmp___7, "find_source", "file_ext", (long )((src_len + suffix_len) + 1UL),
                tmp___6);
#line 2595
        tmp___8 = 0;
        }
      }
      {
#line 2596
      sprintf((char */* __restrict  */)file_ext, (char const   */* __restrict  */)"%s%s",
              src, ".so");
#line 2597
      path = do_find_source((char const   *)file_ext, stb, errcode, pi);
#line 2598
      free((void *)file_ext);
      }
#line 2599
      if ((unsigned long )path == (unsigned long )((void *)0)) {
        {
#line 2600
        tmp___9 = __errno_location();
#line 2600
        *tmp___9 = save_errno;
        }
      }
#line 2601
      return (path);
    }
  }
#line 2614
  if (! (do_flags & 8)) {
#line 2614
    if ((unsigned long )path == (unsigned long )((void *)0)) {
      {
#line 2616
      tmp___10 = __errno_location();
#line 2616
      save_errno___0 = *tmp___10;
#line 2622
      tmp___11 = strlen(src);
#line 2622
      tmp___12 = malloc((tmp___11 + sizeof(".awk")) + 1UL);
#line 2622
      file_awk = (char *)tmp___12;
      }
#line 2622
      if (file_awk) {
#line 2622
        tmp___17 = 1;
      } else {
        {
#line 2622
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2623);
#line 2622
        tmp___13 = __errno_location();
#line 2622
        tmp___14 = strerror(*tmp___13);
#line 2622
        tmp___15 = strlen(src);
#line 2622
        tmp___16 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2622
        r_fatal((char const   *)tmp___16, "find_source", "file_awk", (long )((tmp___15 + sizeof(".awk")) + 1UL),
                tmp___14);
#line 2622
        tmp___17 = 0;
        }
      }
      {
#line 2624
      sprintf((char */* __restrict  */)file_awk, (char const   */* __restrict  */)"%s%s",
              src, ".awk");
#line 2625
      path = do_find_source((char const   *)file_awk, stb, errcode, pi);
#line 2626
      free((void *)file_awk);
      }
#line 2627
      if ((unsigned long )path == (unsigned long )((void *)0)) {
        {
#line 2628
        tmp___18 = __errno_location();
#line 2628
        *tmp___18 = save_errno___0;
        }
      }
    }
  }
#line 2636
  return (path);
}
}
#line 2642 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
int srcopen(SRCFILE *s___0 ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 2645
  if ((unsigned int )s___0->stype == 2U) {
    {
#line 2646
    tmp___1 = fileno(stdin);
    }
#line 2646
    return (tmp___1);
  }
#line 2647
  if ((unsigned int )s___0->stype == 3U) {
    {
#line 2648
    tmp___2 = devopen((char const   *)s___0->fullpath, "r");
    }
#line 2648
    return (tmp___2);
  } else
#line 2647
  if ((unsigned int )s___0->stype == 4U) {
    {
#line 2648
    tmp___2 = devopen((char const   *)s___0->fullpath, "r");
    }
#line 2648
    return (tmp___2);
  }
#line 2649
  return (-1);
}
}
#line 2654 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static awk_input_parser_t *ip_head  ;
#line 2654 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static awk_input_parser_t *ip_tail  ;
#line 2663 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
void register_input_parser(awk_input_parser_t *input_parser ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 2666
  if ((unsigned long )input_parser == (unsigned long )((void *)0)) {
    {
#line 2667
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2667);
#line 2667
    tmp___1 = gettext("register_input_parser: received NULL pointer");
#line 2667
    r_fatal((char const   *)tmp___1);
    }
  }
#line 2669
  input_parser->next = (struct awk_input_parser *)((void *)0);
#line 2670
  if ((unsigned long )ip_head == (unsigned long )((void *)0)) {
#line 2671
    ip_tail = input_parser;
#line 2671
    ip_head = ip_tail;
  } else {
#line 2673
    ip_tail->next = input_parser;
#line 2674
    ip_tail = ip_tail->next;
  }
#line 2676
  return;
}
}
#line 2680 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static void find_input_parser(IOBUF *iop ) 
{ 
  awk_input_parser_t *ip ;
  awk_input_parser_t *ip2 ;
  char *tmp___1 ;
  awk_bool_t tmp___2 ;
  char *tmp___3 ;
  awk_bool_t tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 2686
  if ((unsigned long )iop->public.get_record != (unsigned long )((void *)0)) {
#line 2687
    return;
  }
#line 2689
  ip2 = (awk_input_parser_t *)((void *)0);
#line 2689
  ip = ip2;
#line 2690
  ip2 = ip_head;
  {
#line 2690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2690
    if (! ((unsigned long )ip2 != (unsigned long )((void *)0))) {
#line 2690
      goto while_break;
    }
    {
#line 2691
    tmp___2 = (*(ip2->can_take_file))((awk_input_buf_t const   *)(& iop->public));
    }
#line 2691
    if (tmp___2) {
#line 2692
      if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 2693
        ip = ip2;
      } else {
        {
#line 2695
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2695);
#line 2695
        tmp___1 = gettext("input parser `%s\' conflicts with previously installed input parser `%s\'");
#line 2695
        r_fatal((char const   *)tmp___1, ip2->name, ip->name);
        }
      }
    }
#line 2690
    ip2 = ip2->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2700
  if ((unsigned long )ip != (unsigned long )((void *)0)) {
    {
#line 2701
    tmp___4 = (*(ip->take_control_of))(& iop->public);
    }
#line 2701
    if (tmp___4) {
#line 2705
      iop->valid = (_Bool)1;
    } else {
      {
#line 2702
      tmp___3 = gettext("input parser `%s\' failed to open `%s\'");
#line 2702
      warning((char const   *)tmp___3, ip->name, iop->public.name);
      }
    }
  }
#line 2707
  return;
}
}
#line 2711 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static awk_output_wrapper_t *op_head  ;
#line 2711 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static awk_output_wrapper_t *op_tail  ;
#line 2718 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
void register_output_wrapper(awk_output_wrapper_t *wrapper ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 2721
  if ((unsigned long )wrapper == (unsigned long )((void *)0)) {
    {
#line 2722
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2722);
#line 2722
    tmp___1 = gettext("register_output_wrapper: received NULL pointer");
#line 2722
    r_fatal((char const   *)tmp___1);
    }
  }
#line 2724
  wrapper->next = (struct awk_output_wrapper *)((void *)0);
#line 2725
  if ((unsigned long )op_head == (unsigned long )((void *)0)) {
#line 2726
    op_tail = wrapper;
#line 2726
    op_head = op_tail;
  } else {
#line 2728
    op_tail->next = wrapper;
#line 2729
    op_tail = op_tail->next;
  }
#line 2731
  return;
}
}
#line 2735 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static _Bool find_output_wrapper(awk_output_buf_t *outbuf ) 
{ 
  awk_output_wrapper_t *op ;
  awk_output_wrapper_t *op2 ;
  char *tmp___1 ;
  awk_bool_t tmp___2 ;
  char *tmp___3 ;
  awk_bool_t tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 2741
  if (outbuf->redirected) {
#line 2742
    return ((_Bool)0);
  }
#line 2744
  op2 = (awk_output_wrapper_t *)((void *)0);
#line 2744
  op = op2;
#line 2745
  op2 = op_head;
  {
#line 2745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2745
    if (! ((unsigned long )op2 != (unsigned long )((void *)0))) {
#line 2745
      goto while_break;
    }
    {
#line 2746
    tmp___2 = (*(op2->can_take_file))((awk_output_buf_t const   *)outbuf);
    }
#line 2746
    if (tmp___2) {
#line 2747
      if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 2748
        op = op2;
      } else {
        {
#line 2750
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2750);
#line 2750
        tmp___1 = gettext("output wrapper `%s\' conflicts with previously installed output wrapper `%s\'");
#line 2750
        r_fatal((char const   *)tmp___1, op2->name, op->name);
        }
      }
    }
#line 2745
    op2 = op2->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2755
  if ((unsigned long )op != (unsigned long )((void *)0)) {
    {
#line 2756
    tmp___4 = (*(op->take_control_of))(outbuf);
    }
#line 2756
    if (! tmp___4) {
      {
#line 2757
      tmp___3 = gettext("output wrapper `%s\' failed to open `%s\'");
#line 2757
      warning((char const   *)tmp___3, op->name, outbuf->name);
      }
#line 2759
      return ((_Bool)0);
    }
#line 2761
    return ((_Bool)1);
  }
#line 2764
  return ((_Bool)0);
}
}
#line 2770 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static awk_two_way_processor_t *tw_head  ;
#line 2770 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static awk_two_way_processor_t *tw_tail  ;
#line 2774 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
void register_two_way_processor(awk_two_way_processor_t *processor ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 2777
  if ((unsigned long )processor == (unsigned long )((void *)0)) {
    {
#line 2778
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2778);
#line 2778
    tmp___1 = gettext("register_output_processor: received NULL pointer");
#line 2778
    r_fatal((char const   *)tmp___1);
    }
  }
#line 2780
  processor->next = (struct awk_two_way_processor *)((void *)0);
#line 2781
  if ((unsigned long )tw_head == (unsigned long )((void *)0)) {
#line 2782
    tw_tail = processor;
#line 2782
    tw_head = tw_tail;
  } else {
#line 2784
    tw_tail->next = processor;
#line 2785
    tw_tail = tw_tail->next;
  }
#line 2787
  return;
}
}
#line 2791 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static _Bool find_two_way_processor(char const   *name , struct redirect *rp ) 
{ 
  awk_two_way_processor_t *tw ;
  awk_two_way_processor_t *tw2 ;
  char *tmp___1 ;
  awk_bool_t tmp___2 ;
  char *tmp___3 ;
  awk_bool_t tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 2797
  if ((unsigned long )rp->iop != (unsigned long )((void *)0)) {
#line 2797
    if ((rp->iop)->public.fd != -1) {
#line 2799
      return ((_Bool)0);
    } else {
#line 2797
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2797
  if ((unsigned long )rp->output.fp != (unsigned long )((void *)0)) {
#line 2799
    return ((_Bool)0);
  }
#line 2801
  tw2 = (awk_two_way_processor_t *)((void *)0);
#line 2801
  tw = tw2;
#line 2802
  tw2 = tw_head;
  {
#line 2802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2802
    if (! ((unsigned long )tw2 != (unsigned long )((void *)0))) {
#line 2802
      goto while_break;
    }
    {
#line 2803
    tmp___2 = (*(tw2->can_take_two_way))(name);
    }
#line 2803
    if (tmp___2) {
#line 2804
      if ((unsigned long )tw == (unsigned long )((void *)0)) {
#line 2805
        tw = tw2;
      } else {
        {
#line 2807
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2807);
#line 2807
        tmp___1 = gettext("two-way processor `%s\' conflicts with previously installed two-way processor `%s\'");
#line 2807
        r_fatal((char const   *)tmp___1, tw2->name, tw->name);
        }
      }
    }
#line 2802
    tw2 = tw2->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2812
  if ((unsigned long )tw != (unsigned long )((void *)0)) {
#line 2813
    if ((unsigned long )rp->iop == (unsigned long )((void *)0)) {
      {
#line 2814
      rp->iop = iop_alloc(-1, name, 0);
      }
    }
    {
#line 2815
    tmp___4 = (*(tw->take_control_of))(name, & (rp->iop)->public, & rp->output);
    }
#line 2815
    if (! tmp___4) {
      {
#line 2816
      tmp___3 = gettext("two way processor `%s\' failed to open `%s\'");
#line 2816
      warning((char const   *)tmp___3, tw->name, name);
      }
#line 2818
      return ((_Bool)0);
    }
    {
#line 2820
    iop_finish(rp->iop);
    }
#line 2821
    return ((_Bool)1);
  }
#line 2824
  return ((_Bool)0);
}
}
#line 2870 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static IOBUF *iop_alloc(int fd , char const   *name , int errno_val ) 
{ 
  IOBUF *iop ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 2875
  tmp___1 = malloc(sizeof(IOBUF ));
#line 2875
  iop = (IOBUF *)tmp___1;
  }
#line 2875
  if (iop) {
#line 2875
    tmp___5 = 1;
  } else {
    {
#line 2875
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2875);
#line 2875
    tmp___2 = __errno_location();
#line 2875
    tmp___3 = strerror(*tmp___2);
#line 2875
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2875
    r_fatal((char const   *)tmp___4, "iop_alloc", "iop", (long )sizeof(IOBUF ), tmp___3);
#line 2875
    tmp___5 = 0;
    }
  }
  {
#line 2877
  memset((void *)iop, '\000', sizeof(IOBUF ));
#line 2878
  iop->public.fd = fd;
#line 2879
  iop->public.name = name;
#line 2880
  iop->public.read_func = (ssize_t (*)())(& read);
#line 2881
  iop->valid = (_Bool)0;
#line 2882
  iop->errcode = errno_val;
  }
#line 2884
  if (fd != -1) {
    {
#line 2885
    fstat(fd, & iop->public.sbuf);
    }
  }
#line 2887
  return (iop);
}
}
#line 2892 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static IOBUF *iop_finish(IOBUF *iop ) 
{ 
  _Bool isdir ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 2895
  isdir = (_Bool)0;
#line 2897
  if (iop->public.fd != -1) {
    {
#line 2898
    tmp___1 = os_isreadable((awk_input_buf_t const   *)(& iop->public), & isdir);
    }
#line 2898
    if (tmp___1) {
#line 2899
      iop->valid = (_Bool)1;
    } else
#line 2901
    if (isdir) {
#line 2902
      iop->errcode = 21;
    } else {
      {
#line 2904
      iop->errcode = 5;
#line 2905
      close(iop->public.fd);
#line 2906
      iop->public.fd = -1;
      }
    }
  }
#line 2915
  if (! iop->valid) {
#line 2916
    return (iop);
  } else
#line 2915
  if (iop->public.fd == -1) {
#line 2916
    return (iop);
  }
  {
#line 2918
  tmp___2 = os_isatty(iop->public.fd);
  }
#line 2918
  if (tmp___2) {
#line 2919
    iop->flag |= 1;
  }
  {
#line 2921
  tmp___3 = optimal_bufsize(iop->public.fd, & iop->public.sbuf);
#line 2921
  iop->size = tmp___3;
#line 2921
  iop->readsize = tmp___3;
  }
#line 2922
  if (do_flags & 3) {
#line 2922
    if ((iop->public.sbuf.st_mode & 61440U) == 32768U) {
#line 2922
      if (iop->public.sbuf.st_size == 0L) {
        {
#line 2923
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2923);
#line 2923
        tmp___4 = gettext("data file `%s\' is empty");
#line 2923
        (*lintfunc)((char const   *)tmp___4, iop->public.name);
        }
      }
    }
  }
  {
#line 2924
  tmp___5 = __errno_location();
#line 2924
  tmp___6 = 0;
#line 2924
  *tmp___5 = tmp___6;
#line 2924
  iop->errcode = tmp___6;
#line 2925
  tmp___7 = (size_t )0;
#line 2925
  iop->scanoff = tmp___7;
#line 2925
  iop->count = (ssize_t )tmp___7;
#line 2926
  tmp___9 = iop->size + 2UL;
#line 2926
  iop->size = tmp___9;
#line 2926
  tmp___10 = malloc(tmp___9);
#line 2926
  tmp___8 = (char *)tmp___10;
#line 2926
  iop->buf = tmp___8;
  }
#line 2926
  if (tmp___8) {
#line 2926
    tmp___15 = 1;
  } else {
    {
#line 2926
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2926);
#line 2926
    tmp___11 = __errno_location();
#line 2926
    tmp___12 = strerror(*tmp___11);
#line 2926
    tmp___13 = iop->size + 2UL;
#line 2926
    iop->size = tmp___13;
#line 2926
    tmp___14 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2926
    r_fatal((char const   *)tmp___14, "iop_finish", "iop->buf", (long )tmp___13, tmp___12);
#line 2926
    tmp___15 = 0;
    }
  }
#line 2927
  iop->off = iop->buf;
#line 2928
  iop->dataend = (char *)((void *)0);
#line 2929
  iop->end = iop->buf + iop->size;
#line 2930
  iop->flag |= 8;
#line 2932
  return (iop);
}
}
#line 2950 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static void grow_iop_buffer(IOBUF *iop ) 
{ 
  size_t valid ;
  size_t off ;
  size_t newsize ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2953
  valid = (size_t )(iop->dataend - iop->off);
#line 2954
  off = (size_t )(iop->off - iop->buf);
#line 2961
  newsize = (iop->size - 2UL) * 2UL + 2UL;
#line 2964
  if (newsize <= iop->size) {
    {
#line 2965
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2965);
#line 2965
    tmp___1 = gettext("could not allocate more input memory");
#line 2965
    r_fatal((char const   *)tmp___1);
    }
  }
#line 2968
  if (newsize - valid < iop->readsize) {
#line 2969
    newsize += iop->readsize + 2UL;
  }
#line 2972
  if (newsize <= iop->size) {
    {
#line 2973
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2973);
#line 2973
    tmp___2 = gettext("could not allocate more input memory");
#line 2973
    r_fatal((char const   *)tmp___2);
    }
  }
  {
#line 2975
  iop->size = newsize;
#line 2976
  tmp___4 = realloc((void *)iop->buf, iop->size);
#line 2976
  tmp___3 = (char *)tmp___4;
#line 2976
  iop->buf = tmp___3;
  }
#line 2976
  if (tmp___3) {
#line 2976
    tmp___8 = 1;
  } else {
    {
#line 2976
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 2976);
#line 2976
    tmp___5 = __errno_location();
#line 2976
    tmp___6 = strerror(*tmp___5);
#line 2976
    tmp___7 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2976
    r_fatal((char const   *)tmp___7, "grow_iop_buffer", "iop->buf", (long )iop->size,
            tmp___6);
#line 2976
    tmp___8 = 0;
    }
  }
#line 2977
  iop->off = iop->buf + off;
#line 2978
  iop->dataend = iop->off + valid;
#line 2979
  iop->end = iop->buf + iop->size;
#line 2980
  return;
}
}
#line 2986 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static RECVALUE rs1scan(IOBUF *iop , struct recmatch *recm , SCANSTATE *state___2 ) 
{ 
  char *bp ;
  char rs ;
  size_t mbclen ;
  mbstate_t mbs___0 ;
  int len ;
  int found ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
  {
#line 2992
  mbclen = (size_t )0;
#line 2996
  memset((void *)recm, '\000', sizeof(struct recmatch ));
#line 2997
  rs = *(RS->sub.val.sp + 0);
#line 2998
  *(iop->dataend) = rs;
#line 2999
  recm->start = iop->off;
#line 3001
  bp = iop->off;
  }
#line 3002
  if ((unsigned int )*state___2 == 2U) {
#line 3003
    bp += iop->scanoff;
  }
#line 3060
  if ((int )rs != 10) {
#line 3060
    if (gawk_mb_cur_max > 1) {
      {
#line 3061
      len = (int )(iop->dataend - bp);
#line 3062
      found = 0;
#line 3064
      memset((void *)(& mbs___0), 0, sizeof(mbstate_t ));
      }
      {
#line 3065
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3066
        if ((int )*bp == (int )rs) {
#line 3067
          found = 1;
        }
#line 3068
        if (btowc_cache[(int )*bp & 255] != 4294967295U) {
#line 3069
          mbclen = (size_t )1;
        } else {
          {
#line 3071
          mbclen = mbrlen((char const   */* __restrict  */)bp, (size_t )len, (mbstate_t */* __restrict  */)(& mbs___0));
          }
        }
#line 3072
        if (mbclen == 1UL) {
#line 3077
          mbclen = (size_t )1;
        } else
#line 3072
        if (mbclen == 0xffffffffffffffffUL) {
#line 3077
          mbclen = (size_t )1;
        } else
#line 3072
        if (mbclen == 0xfffffffffffffffeUL) {
#line 3077
          mbclen = (size_t )1;
        } else
#line 3072
        if (mbclen == 0UL) {
#line 3077
          mbclen = (size_t )1;
        }
#line 3079
        len = (int )((size_t )len - mbclen);
#line 3080
        bp += mbclen;
#line 3065
        if (len > 0) {
#line 3065
          if (! (! found)) {
#line 3065
            goto while_break;
          }
        } else {
#line 3065
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 3084
      if (found) {
#line 3084
        if ((unsigned long )(bp - mbclen) < (unsigned long )iop->dataend) {
#line 3089
          recm->len = (size_t )(bp - recm->start) - mbclen;
#line 3090
          recm->rt_start = bp - mbclen;
#line 3091
          recm->rt_len = mbclen;
#line 3092
          *state___2 = (SCANSTATE )0;
#line 3093
          return ((RECVALUE )0);
        } else {
#line 3096
          recm->len = (size_t )(bp - recm->start);
#line 3097
          *state___2 = (SCANSTATE )2;
#line 3098
          iop->scanoff = (size_t )(bp - iop->off);
#line 3099
          return ((RECVALUE )1);
        }
      } else {
#line 3096
        recm->len = (size_t )(bp - recm->start);
#line 3097
        *state___2 = (SCANSTATE )2;
#line 3098
        iop->scanoff = (size_t )(bp - iop->off);
#line 3099
        return ((RECVALUE )1);
      }
    }
  }
  {
#line 3103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3103
    if (! ((int )*bp != (int )rs)) {
#line 3103
      goto while_break___0;
    }
#line 3104
    bp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3107
  recm->len = (size_t )(bp - recm->start);
#line 3109
  if ((unsigned long )bp < (unsigned long )iop->dataend) {
#line 3110
    recm->rt_start = bp;
#line 3111
    recm->rt_len = (size_t )1;
#line 3112
    *state___2 = (SCANSTATE )0;
#line 3113
    return ((RECVALUE )0);
  } else {
#line 3115
    *state___2 = (SCANSTATE )2;
#line 3116
    iop->scanoff = (size_t )(bp - iop->off);
#line 3117
    return ((RECVALUE )1);
  }
}
}
#line 3123 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static RECVALUE rsrescan(IOBUF *iop , struct recmatch *recm , SCANSTATE *state___2 ) 
{ 
  char *bp ;
  size_t restart___0 ;
  size_t reend ;
  Regexp *RSre ;
  int regex_flags ;
  int tmp___1 ;
  int tmp___2 ;
  char *matchend ;

  {
  {
#line 3127
  restart___0 = (size_t )0;
#line 3127
  reend = (size_t )0;
#line 3128
  RSre = RS_regexp;
#line 3129
  regex_flags = 1;
#line 3131
  memset((void *)recm, '\000', sizeof(struct recmatch ));
#line 3132
  recm->start = iop->off;
#line 3134
  bp = iop->off;
  }
#line 3135
  if ((unsigned int )*state___2 == 2U) {
#line 3136
    bp += iop->scanoff;
  }
#line 3138
  if ((iop->flag & 8) == 0) {
#line 3139
    regex_flags |= 2;
  }
  again: 
  {
#line 3142
  tmp___1 = research(RSre, bp, 0, (size_t )(iop->dataend - bp), regex_flags);
  }
#line 3142
  if (tmp___1 == -1) {
#line 3144
    recm->len = (size_t )(iop->dataend - iop->off);
#line 3145
    return ((RECVALUE )1);
  }
#line 3149
  restart___0 = (size_t )*(RSre->regs.start + 0);
#line 3150
  reend = (size_t )*(RSre->regs.end + 0);
#line 3153
  if (restart___0 == reend) {
#line 3154
    *state___2 = (SCANSTATE )2;
#line 3155
    iop->scanoff = reend + 1UL;
#line 3160
    if ((unsigned long )(bp + iop->scanoff) < (unsigned long )iop->dataend) {
#line 3161
      bp += iop->scanoff;
#line 3162
      goto again;
    }
#line 3164
    recm->len = (size_t )(bp - iop->off) + restart___0;
#line 3165
    return ((RECVALUE )1);
  }
#line 3174
  recm->len = restart___0;
#line 3175
  recm->rt_start = bp + restart___0;
#line 3176
  recm->rt_len = reend - restart___0;
#line 3177
  *state___2 = (SCANSTATE )0;
#line 3187
  if ((unsigned long )(iop->off + reend) >= (unsigned long )iop->dataend) {
    {
#line 3188
    tmp___2 = reisstring((char const   *)RS->sub.val.sp, RS->sub.val.slen, RSre, (char const   *)iop->off);
    }
#line 3188
    if (tmp___2) {
#line 3189
      return ((RECVALUE )0);
    } else {
#line 3191
      return ((RECVALUE )2);
    }
  }
#line 3218
  if (RSre->maybe_long) {
#line 3219
    matchend = iop->off + reend;
#line 3221
    if ((size_t )(iop->dataend - matchend) < RS->sub.val.slen) {
#line 3222
      return ((RECVALUE )3);
    }
  }
#line 3225
  return ((RECVALUE )0);
}
}
#line 3230 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static RECVALUE rsnullscan(IOBUF *iop , struct recmatch *recm , SCANSTATE *state___2 ) 
{ 
  char *bp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
#line 3235
  if ((unsigned int )*state___2 == 0U) {
    {
#line 3236
    memset((void *)recm, '\000', sizeof(struct recmatch ));
    }
  } else
#line 3235
  if ((unsigned int )*state___2 == 1U) {
    {
#line 3236
    memset((void *)recm, '\000', sizeof(struct recmatch ));
    }
  }
#line 3238
  recm->start = iop->off;
#line 3240
  bp = iop->off;
#line 3241
  if ((unsigned int )*state___2 != 0U) {
#line 3242
    bp += iop->scanoff;
  }
#line 3245
  *(iop->dataend) = (char )'\n';
#line 3247
  if ((unsigned int )*state___2 == 3U) {
#line 3248
    goto find_longest_terminator;
  } else
#line 3249
  if ((unsigned int )*state___2 == 2U) {
#line 3250
    goto scan_data;
  }
  {
#line 3257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3257
    if ((int )*bp == 10) {
#line 3257
      if (! ((unsigned long )bp < (unsigned long )iop->dataend)) {
#line 3257
        goto while_break;
      }
    } else {
#line 3257
      goto while_break;
    }
#line 3258
    bp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3260
  if ((unsigned long )bp >= (unsigned long )iop->dataend) {
#line 3261
    *state___2 = (SCANSTATE )1;
#line 3262
    iop->scanoff = (size_t )(bp - iop->off);
#line 3263
    return ((RECVALUE )1);
  }
#line 3266
  tmp___1 = bp;
#line 3266
  recm->start = tmp___1;
#line 3266
  iop->off = tmp___1;
  scan_data: 
  {
#line 3268
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3268
    tmp___2 = bp;
#line 3268
    bp ++;
#line 3268
    if (! ((int )*tmp___2 != 10)) {
#line 3268
      goto while_break___0;
    }
#line 3269
    goto while_continue___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3271
  if ((unsigned long )bp >= (unsigned long )iop->dataend) {
#line 3272
    tmp___3 = (size_t )((bp - iop->off) - 1L);
#line 3272
    recm->len = tmp___3;
#line 3272
    iop->scanoff = tmp___3;
#line 3273
    if ((unsigned long )bp == (unsigned long )iop->dataend) {
#line 3274
      recm->rt_start = bp - 1;
#line 3275
      recm->rt_len = (size_t )1;
    }
#line 3277
    *state___2 = (SCANSTATE )2;
#line 3278
    return ((RECVALUE )1);
  }
#line 3282
  if ((int )*bp != 10) {
#line 3283
    goto scan_data;
  }
#line 3286
  *state___2 = (SCANSTATE )3;
#line 3287
  recm->len = (size_t )((bp - iop->off) - 1L);
#line 3288
  recm->rt_start = bp - 1;
  find_longest_terminator: 
  {
#line 3292
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3292
    if ((int )*bp == 10) {
#line 3292
      if (! ((unsigned long )bp < (unsigned long )iop->dataend)) {
#line 3292
        goto while_break___1;
      }
    } else {
#line 3292
      goto while_break___1;
    }
#line 3293
    bp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3295
  recm->rt_len = (size_t )(bp - recm->rt_start);
#line 3296
  iop->scanoff = (size_t )(bp - iop->off);
#line 3298
  if ((unsigned long )bp >= (unsigned long )iop->dataend) {
#line 3299
    return ((RECVALUE )2);
  }
#line 3301
  return ((RECVALUE )0);
}
}
#line 3320 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static RECVALUE (*lastmatchrec)(IOBUF *iop , struct recmatch *recm , SCANSTATE *state )  =    (RECVALUE (*)(IOBUF *iop ,
                 struct recmatch *recm , SCANSTATE *state ))((void *)0);
#line 3310 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int get_a_record(char **out , IOBUF *iop , int *errcode ) 
{ 
  struct recmatch recm ;
  SCANSTATE state___2 ;
  RECVALUE ret ;
  int retval ;
  NODE *rtval ;
  char *rt_start ;
  size_t rt_len ;
  int rc ;
  int tmp___1 ;
  struct exp_node *tmp___2 ;
  int tmp___3 ;
  struct exp_node *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  size_t dataend_off ;
  size_t room_left ;
  size_t amt_to_read ;
  int *tmp___7 ;
  struct exp_node *tmp___8 ;
  int tmp___9 ;
  struct exp_node *tmp___10 ;
  int tmp___11 ;
  struct exp_node *tmp___12 ;
  int tmp___13 ;
  struct exp_node *tmp___14 ;
  int tmp___15 ;
  struct exp_node *tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp32 ;

  {
#line 3319
  rtval = (NODE *)((void *)0);
#line 3322
  if ((iop->flag & 2) != 0) {
#line 3322
    if ((unsigned long )iop->off >= (unsigned long )iop->dataend) {
#line 3323
      return (-1);
    }
  }
#line 3325
  if (read_can_timeout) {
    {
#line 3326
    read_timeout = get_read_timeout(iop);
    }
  }
#line 3328
  if ((unsigned long )iop->public.get_record != (unsigned long )((void *)0)) {
    {
#line 3331
    tmp___1 = (*(iop->public.get_record))(out, & iop->public, errcode, & rt_start,
                                          & rt_len);
#line 3331
    rc = tmp___1;
    }
#line 3333
    if (rc == -1) {
#line 3334
      iop->flag |= 2;
    } else
#line 3336
    if (rt_len != 0UL) {
#line 3337
      if (! (do_flags & 8)) {
        {
#line 3337
        unref(RT_node->sub.nodep.l.lptr);
#line 3337
        tmp___2 = make_str_node((char const   *)rt_start, rt_len, 0);
#line 3337
        RT_node->sub.nodep.l.lptr = tmp___2;
        }
#line 3337
        if (tmp___2) {
#line 3337
          tmp___3 = 1;
        } else {
#line 3337
          tmp___3 = 0;
        }
      } else {
#line 3337
        tmp___3 = 0;
      }
    } else
#line 3339
    if (! (do_flags & 8)) {
      {
#line 3339
      unref(RT_node->sub.nodep.l.lptr);
#line 3339
      tmp___4 = dupnode(Nnull_string);
#line 3339
      RT_node->sub.nodep.l.lptr = tmp___4;
      }
#line 3339
      if (tmp___4) {
#line 3339
        tmp___5 = 1;
      } else {
#line 3339
        tmp___5 = 0;
      }
    } else {
#line 3339
      tmp___5 = 0;
    }
#line 3341
    return (rc);
  }
#line 3345
  if ((unsigned long )iop->dataend == (unsigned long )((void *)0)) {
#line 3345
    goto _L;
  } else
#line 3345
  if ((unsigned long )iop->off >= (unsigned long )iop->dataend) {
    _L: /* CIL Label */ 
    {
#line 3346
    iop->count = (*(iop->public.read_func))(iop->public.fd, iop->buf, iop->readsize);
    }
#line 3347
    if (iop->count == 0L) {
#line 3348
      iop->flag |= 2;
#line 3349
      return (-1);
    } else
#line 3350
    if (iop->count == -1L) {
      {
#line 3351
      iop->flag |= 2;
#line 3352
      tmp___6 = __errno_location();
#line 3352
      *errcode = *tmp___6;
      }
#line 3353
      return (-1);
    } else {
#line 3355
      iop->dataend = iop->buf + iop->count;
#line 3356
      iop->off = iop->buf;
    }
  }
#line 3361
  state___2 = (SCANSTATE )0;
  {
#line 3362
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3367
    ret = (*matchrec)(iop, & recm, & state___2);
#line 3368
    iop->flag &= -9;
    }
#line 3369
    if ((unsigned int )ret == 0U) {
#line 3370
      goto while_break;
    }
    {
#line 3374
    dataend_off = (size_t )(iop->dataend - iop->off);
#line 3375
    memmove((void *)iop->buf, (void const   *)iop->off, dataend_off);
#line 3376
    iop->off = iop->buf;
#line 3377
    iop->dataend = iop->buf + dataend_off;
#line 3380
    recm.start = iop->off;
    }
#line 3381
    if ((unsigned long )recm.rt_start != (unsigned long )((void *)0)) {
#line 3382
      recm.rt_start = iop->off + recm.len;
    }
#line 3387
    room_left = (size_t )((iop->end - iop->dataend) - 1L);
#line 3388
    if (iop->readsize < room_left) {
#line 3388
      amt_to_read = iop->readsize;
    } else {
#line 3388
      amt_to_read = room_left;
    }
#line 3390
    if (amt_to_read < iop->readsize) {
      {
#line 3391
      grow_iop_buffer(iop);
#line 3393
      recm.start = iop->off;
      }
#line 3394
      if ((unsigned long )recm.rt_start != (unsigned long )((void *)0)) {
#line 3395
        recm.rt_start = iop->off + recm.len;
      }
#line 3398
      room_left = (size_t )((iop->end - iop->dataend) - 1L);
#line 3399
      if (iop->readsize < room_left) {
#line 3399
        amt_to_read = iop->readsize;
      } else {
#line 3399
        amt_to_read = room_left;
      }
    }
    {
#line 3401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3401
      if (! (amt_to_read + iop->readsize < room_left)) {
#line 3401
        goto while_break___0;
      }
#line 3402
      amt_to_read += iop->readsize;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3409
    if (amt_to_read < 9223372036854775807UL) {
#line 3409
      amt_to_read = amt_to_read;
    } else {
#line 3409
      amt_to_read = (size_t )9223372036854775807L;
    }
    {
#line 3412
    iop->count = (*(iop->public.read_func))(iop->public.fd, iop->dataend, amt_to_read);
    }
#line 3413
    if (iop->count == -1L) {
      {
#line 3414
      tmp___7 = __errno_location();
#line 3414
      *errcode = *tmp___7;
#line 3415
      iop->flag |= 2;
      }
#line 3416
      goto while_break;
    } else
#line 3417
    if (iop->count == 0L) {
#line 3422
      iop->flag |= 2;
#line 3423
      goto while_break;
    } else {
#line 3425
      iop->dataend += iop->count;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3436
  rtval = RT_node->sub.nodep.l.lptr;
#line 3438
  if (recm.rt_len == 0UL) {
#line 3439
    if (! (do_flags & 8)) {
      {
#line 3439
      unref(RT_node->sub.nodep.l.lptr);
#line 3439
      tmp___8 = dupnode(Nnull_string);
#line 3439
      RT_node->sub.nodep.l.lptr = tmp___8;
      }
#line 3439
      if (tmp___8) {
#line 3439
        tmp___9 = 1;
      } else {
#line 3439
        tmp___9 = 0;
      }
    } else {
#line 3439
      tmp___9 = 0;
    }
#line 3440
    lastmatchrec = (RECVALUE (*)(IOBUF *iop , struct recmatch *recm , SCANSTATE *state ))((void *)0);
  } else
#line 3456
  if ((unsigned long )lastmatchrec == (unsigned long )((void *)0)) {
#line 3456
    goto _L___1;
  } else
#line 3456
  if ((unsigned long )lastmatchrec != (unsigned long )matchrec) {
    _L___1: /* CIL Label */ 
#line 3457
    lastmatchrec = matchrec;
#line 3458
    if (! (do_flags & 8)) {
      {
#line 3458
      unref(RT_node->sub.nodep.l.lptr);
#line 3458
      tmp___10 = make_str_node((char const   *)recm.rt_start, recm.rt_len, 0);
#line 3458
      RT_node->sub.nodep.l.lptr = tmp___10;
      }
#line 3458
      if (tmp___10) {
#line 3458
        tmp___11 = 1;
      } else {
#line 3458
        tmp___11 = 0;
      }
    } else {
#line 3458
      tmp___11 = 0;
    }
  } else
#line 3459
  if ((unsigned long )matchrec == (unsigned long )(& rs1scan)) {
#line 3460
    if (rtval->sub.val.slen != 1UL) {
#line 3460
      goto _L___0;
    } else
#line 3460
    if ((int )*(rtval->sub.val.sp + 0) != (int )*(recm.rt_start + 0)) {
      _L___0: /* CIL Label */ 
#line 3461
      if (! (do_flags & 8)) {
        {
#line 3461
        unref(RT_node->sub.nodep.l.lptr);
#line 3461
        tmp___12 = make_str_node((char const   *)recm.rt_start, recm.rt_len, 0);
#line 3461
        RT_node->sub.nodep.l.lptr = tmp___12;
        }
#line 3461
        if (tmp___12) {
#line 3461
          tmp___13 = 1;
        } else {
#line 3461
          tmp___13 = 0;
        }
      } else {
#line 3461
        tmp___13 = 0;
      }
    }
  } else
#line 3464
  if ((unsigned long )matchrec == (unsigned long )(& rsnullscan)) {
#line 3465
    if (rtval->sub.val.slen >= recm.rt_len) {
#line 3466
      rtval->sub.val.slen = recm.rt_len;
      {
#line 3467
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3467
        if (rtval->flags & 1024U) {
          {
#line 3467
          r_free_wstr(rtval);
          }
        }
#line 3467
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 3469
    if (! (do_flags & 8)) {
      {
#line 3469
      unref(RT_node->sub.nodep.l.lptr);
#line 3469
      tmp___14 = make_str_node((char const   *)recm.rt_start, recm.rt_len, 0);
#line 3469
      RT_node->sub.nodep.l.lptr = tmp___14;
      }
#line 3469
      if (tmp___14) {
#line 3469
        tmp___15 = 1;
      } else {
#line 3469
        tmp___15 = 0;
      }
    } else {
#line 3469
      tmp___15 = 0;
    }
  } else
#line 3471
  if (! (do_flags & 8)) {
    {
#line 3471
    unref(RT_node->sub.nodep.l.lptr);
#line 3471
    tmp___16 = make_str_node((char const   *)recm.rt_start, recm.rt_len, 0);
#line 3471
    RT_node->sub.nodep.l.lptr = tmp___16;
    }
#line 3471
    if (tmp___16) {
#line 3471
      tmp___17 = 1;
    } else {
#line 3471
      tmp___17 = 0;
    }
  } else {
#line 3471
    tmp___17 = 0;
  }
#line 3474
  if (recm.len == 0UL) {
#line 3475
    *out = (char *)((void *)0);
#line 3476
    retval = 0;
  } else {
#line 3479
    *out = recm.start;
#line 3480
    retval = (int )recm.len;
  }
#line 3483
  iop->off += recm.len + recm.rt_len;
#line 3485
  if (recm.len == 0UL) {
#line 3485
    if (recm.rt_len == 0UL) {
#line 3485
      if ((iop->flag & 2) != 0) {
#line 3486
        return (-1);
      } else {
#line 3488
        return (retval);
      }
    } else {
#line 3488
      return (retval);
    }
  } else {
#line 3488
    return (retval);
  }
}
}
#line 3496 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static NODE *save_rs  =    (NODE *)((void *)0);
#line 3530 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static _Bool warned___3  =    (_Bool)0;
#line 3493 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
void set_RS(void) 
{ 
  int tmp___1 ;
  char *tmp___2 ;
  field_sep_type tmp___3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 3501
  if (save_rs) {
#line 3501
    if ((RS_node->sub.nodep.l.lptr)->sub.val.slen == save_rs->sub.val.slen) {
      {
#line 3501
      tmp___1 = memcmp((void const   *)(RS_node->sub.nodep.l.lptr)->sub.val.sp, (void const   *)save_rs->sub.val.sp,
                       save_rs->sub.val.slen);
      }
#line 3501
      if (tmp___1 == 0) {
#line 3510
        if (IGNORECASE) {
#line 3510
          RS_regexp = RS_re_no_case;
        } else {
#line 3510
          RS_regexp = RS_re_yes_case;
        }
#line 3511
        goto set_FS;
      }
    }
  }
  {
#line 3513
  unref(save_rs);
#line 3514
  save_rs = dupnode(RS_node->sub.nodep.l.lptr);
#line 3515
  RS_is_null = (_Bool)0;
#line 3516
  RS = force_string(RS_node->sub.nodep.l.lptr);
#line 3522
  refree(RS_re_yes_case);
#line 3523
  refree(RS_re_no_case);
#line 3524
  RS_regexp = (Regexp *)((void *)0);
#line 3524
  RS_re_no_case = RS_regexp;
#line 3524
  RS_re_yes_case = RS_re_no_case;
  }
#line 3526
  if (RS->sub.val.slen == 0UL) {
#line 3527
    RS_is_null = (_Bool)1;
#line 3528
    matchrec = & rsnullscan;
  } else
#line 3529
  if (RS->sub.val.slen > 1UL) {
    {
#line 3532
    RS_re_yes_case = make_regexp((char const   *)RS->sub.val.sp, RS->sub.val.slen,
                                 (_Bool)0, (_Bool)1, (_Bool)1);
#line 3533
    RS_re_no_case = make_regexp((char const   *)RS->sub.val.sp, RS->sub.val.slen,
                                (_Bool)1, (_Bool)1, (_Bool)1);
    }
#line 3534
    if (IGNORECASE) {
#line 3534
      RS_regexp = RS_re_no_case;
    } else {
#line 3534
      RS_regexp = RS_re_yes_case;
    }
#line 3536
    matchrec = & rsrescan;
#line 3538
    if (do_flags & 3) {
#line 3538
      if (! warned___3) {
        {
#line 3539
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 3539);
#line 3539
        tmp___2 = gettext("multicharacter value of `RS\' is a gawk extension");
#line 3539
        (*lintfunc)((char const   *)tmp___2);
#line 3540
        warned___3 = (_Bool)1;
        }
      }
    }
  } else {
#line 3543
    matchrec = & rs1scan;
  }
  set_FS: 
  {
#line 3545
  tmp___3 = current_field_sep();
  }
#line 3545
  if ((unsigned int )tmp___3 == 0U) {
    {
#line 3546
    set_FS();
    }
  }
#line 3547
  return;
}
}
#line 3556 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int pty_vs_pipe(char const   *command ) 
{ 
  NODE *val ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp7 ;

  {
#line 3562
  if ((unsigned long )PROCINFO_node == (unsigned long )((void *)0)) {
#line 3563
    return (0);
  }
  {
#line 3564
  val = in_PROCINFO(command, "pty", (NODE **)((void *)0));
  }
#line 3565
  if (val) {
#line 3566
    if ((val->flags & 32U) != 0U) {
      {
#line 3567
      force_number(val);
      }
    }
#line 3568
    if ((val->flags & 16U) != 0U) {
#line 3569
      if (val->flags & 2048U) {
#line 3569
        tmp___3 = val->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 1UL);
      } else {
#line 3569
        if (val->flags & 4096U) {
#line 3569
          if (val->sub.val.nm.mpi[0]._mp_size < 0) {
#line 3569
            tmp___1 = -1;
          } else {
#line 3569
            tmp___1 = val->sub.val.nm.mpi[0]._mp_size > 0;
          }
#line 3569
          tmp___2 = tmp___1 == 0;
        } else {
#line 3569
          tmp___2 = val->sub.val.nm.fltnum == 0.0;
        }
#line 3569
        tmp___3 = tmp___2;
      }
#line 3569
      if (tmp___3) {
#line 3569
        tmp___4 = 0;
      } else {
#line 3569
        tmp___4 = 1;
      }
#line 3569
      return (tmp___4);
    } else {
#line 3571
      return (val->sub.val.slen != 0UL);
    }
  }
#line 3574
  return (0);
}
}
#line 3582
char const   *iopflags2str(int flag ) ;
#line 3582 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static struct flagtab  const  values___1[5]  = {      {1, "IOP_IS_TTY"}, 
        {2, "IOP_AT_EOF"}, 
        {4, "IOP_CLOSED"}, 
        {8, "IOP_AT_START"}, 
        {0, (char const   *)((void *)0)}};
#line 3579 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
char const   *iopflags2str(int flag ) 
{ 
  char const   *tmp___1 ;

  {
  {
#line 3590
  tmp___1 = genflags2str(flag, values___1);
  }
#line 3590
  return (tmp___1);
}
}
#line 3595 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static void free_rp(struct redirect *rp ) 
{ 


  {
  {
#line 3598
  free((void *)rp->value);
#line 3599
  free((void *)rp);
  }
#line 3600
  return;
}
}
#line 3604 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int inetfile(char const   *str , int *length , int *family ) 
{ 
  _Bool ret ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 3607
  ret = (_Bool)0;
#line 3609
  tmp___3 = strncmp(str, "/inet/", (size_t )6);
  }
#line 3609
  if (tmp___3 == 0) {
#line 3610
    ret = (_Bool)1;
#line 3611
    if ((unsigned long )length != (unsigned long )((void *)0)) {
#line 3612
      *length = 6;
    }
#line 3613
    if ((unsigned long )family != (unsigned long )((void *)0)) {
#line 3614
      *family = 0;
    }
  } else {
    {
#line 3615
    tmp___2 = strncmp(str, "/inet4/", (size_t )7);
    }
#line 3615
    if (tmp___2 == 0) {
#line 3616
      ret = (_Bool)1;
#line 3617
      if ((unsigned long )length != (unsigned long )((void *)0)) {
#line 3618
        *length = 7;
      }
#line 3619
      if ((unsigned long )family != (unsigned long )((void *)0)) {
#line 3620
        *family = 2;
      }
    } else {
      {
#line 3621
      tmp___1 = strncmp(str, "/inet6/", (size_t )7);
      }
#line 3621
      if (tmp___1 == 0) {
#line 3622
        ret = (_Bool)1;
#line 3623
        if ((unsigned long )length != (unsigned long )((void *)0)) {
#line 3624
          *length = 7;
        }
#line 3625
        if ((unsigned long )family != (unsigned long )((void *)0)) {
#line 3626
          *family = 10;
        }
      }
    }
  }
#line 3632
  return ((int )ret);
}
}
#line 3640 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static NODE *in_PROCINFO(char const   *pidx1 , char const   *pidx2 , NODE **full_idx___0 ) 
{ 
  char *str ;
  size_t str_len ;
  NODE *r ;
  NODE *sub ;
  NODE *subsep ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 3645
  sub = (NODE *)((void *)0);
#line 3646
  subsep = SUBSEP_node->sub.nodep.l.lptr;
#line 3650
  if (full_idx___0) {
#line 3651
    sub = *full_idx___0;
  }
  {
#line 3653
  tmp___1 = strlen(pidx1);
#line 3653
  tmp___2 = strlen(pidx2);
#line 3653
  str_len = (tmp___1 + subsep->sub.val.slen) + tmp___2;
  }
#line 3654
  if ((unsigned long )sub == (unsigned long )((void *)0)) {
    {
#line 3655
    tmp___3 = malloc(str_len + 1UL);
#line 3655
    str = (char *)tmp___3;
    }
#line 3655
    if (str) {
#line 3655
      tmp___7 = 1;
    } else {
      {
#line 3655
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 3655);
#line 3655
      tmp___4 = __errno_location();
#line 3655
      tmp___5 = strerror(*tmp___4);
#line 3655
      tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 3655
      r_fatal((char const   *)tmp___6, "in_PROCINFO", "str", (long )(str_len + 1UL),
              tmp___5);
#line 3655
      tmp___7 = 0;
      }
    }
    {
#line 3656
    sub = make_str_node((char const   *)str, str_len, 2);
    }
#line 3657
    if (full_idx___0) {
#line 3658
      *full_idx___0 = sub;
    }
  } else
#line 3659
  if (str_len != sub->sub.val.slen) {
    {
#line 3663
    tmp___9 = realloc((void *)sub->sub.val.sp, str_len + 1UL);
#line 3663
    tmp___8 = (char *)tmp___9;
#line 3663
    sub->sub.val.sp = tmp___8;
    }
#line 3663
    if (tmp___8) {
#line 3663
      tmp___13 = 1;
    } else {
      {
#line 3663
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c", 3663);
#line 3663
      tmp___10 = __errno_location();
#line 3663
      tmp___11 = strerror(*tmp___10);
#line 3663
      tmp___12 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 3663
      r_fatal((char const   *)tmp___12, "in_PROCINFO", "sub->stptr", (long )(str_len + 1UL),
              tmp___11);
#line 3663
      tmp___13 = 0;
      }
    }
#line 3664
    sub->sub.val.slen = str_len;
  }
  {
#line 3667
  sprintf((char */* __restrict  */)sub->sub.val.sp, (char const   */* __restrict  */)"%s%.*s%s",
          pidx1, (int )subsep->sub.val.slen, subsep->sub.val.sp, pidx2);
#line 3669
  r = in_array(PROCINFO_node, sub);
  }
#line 3670
  if (! full_idx___0) {
    {
#line 3671
    unref(sub);
    }
  }
#line 3672
  return (r);
}
}
#line 3686 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static NODE *full_idx  =    (NODE *)((void *)0);
#line 3687 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static char const   *last_name  =    (char const   *)((void *)0);
#line 3678 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static long get_read_timeout(IOBUF *iop ) 
{ 
  long tmout ;
  char const   *name ;
  NODE *val ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  char *__cil_tmp11 ;

  {
#line 3681
  tmout = 0L;
#line 3683
  if ((unsigned long )PROCINFO_node != (unsigned long )((void *)0)) {
#line 3684
    name = iop->public.name;
#line 3685
    val = (NODE *)((void *)0);
#line 3693
    if ((unsigned long )full_idx == (unsigned long )((void *)0)) {
#line 3693
      goto _L;
    } else {
      {
#line 3693
      tmp___3 = strcmp(name, last_name);
      }
#line 3693
      if (tmp___3 != 0) {
        _L: /* CIL Label */ 
        {
#line 3694
        val = in_PROCINFO(name, "READ_TIMEOUT", & full_idx);
        }
#line 3695
        if ((unsigned long )last_name != (unsigned long )((void *)0)) {
          {
#line 3696
          free((void *)last_name);
          }
        }
        {
#line 3697
        tmp___1 = strlen(name);
#line 3697
        tmp___2 = estrdup(name, tmp___1);
#line 3697
        last_name = (char const   *)tmp___2;
        }
      } else {
        {
#line 3699
        val = in_array(PROCINFO_node, full_idx);
        }
      }
    }
#line 3701
    if ((unsigned long )val != (unsigned long )((void *)0)) {
      {
#line 3702
      force_number(val);
      }
#line 3703
      if (val->flags & 2048U) {
        {
#line 3703
        tmp___4 = mpfr_get_si((mpfr_srcptr )(val->sub.val.nm.mpnum), ROUND_MODE);
#line 3703
        tmout = tmp___4;
        }
      } else {
#line 3703
        if (val->flags & 4096U) {
          {
#line 3703
          tmp___5 = __gmpz_get_si((mpz_srcptr )(val->sub.val.nm.mpi));
#line 3703
          tmp___6 = tmp___5;
          }
        } else {
#line 3703
          tmp___6 = (long )val->sub.val.nm.fltnum;
        }
#line 3703
        tmout = tmp___6;
      }
    }
  } else {
#line 3706
    tmout = read_default_timeout;
  }
#line 3709
  if ((unsigned long )iop->public.read_func == (unsigned long )((ssize_t (*)())(& read))) {
#line 3709
    if (tmout > 0L) {
#line 3710
      iop->public.read_func = (ssize_t (*)())(& read_with_timeout);
    }
  }
#line 3712
  return (tmout);
}
}
#line 3720 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static ssize_t read_with_timeout(int fd , char *buf___7 , size_t size ) 
{ 
  fd_set readfds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
#line 3727
  tv.tv_sec = read_timeout / 1000L;
#line 3728
  tv.tv_usec = 1000L * (read_timeout - 1000L * tv.tv_sec);
  {
#line 3730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3730
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.fds_bits[0]): "memory");
#line 3730
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3731
  readfds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 3733
  tmp___1 = __errno_location();
#line 3733
  *tmp___1 = 0;
#line 3734
  tmp___2 = select(fd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 3734
  if (tmp___2 < 0) {
#line 3735
    return ((ssize_t )-1);
  }
#line 3737
  if ((readfds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 3738
    tmp___3 = read(fd, (void *)buf___7, size);
    }
#line 3738
    return (tmp___3);
  }
  {
#line 3744
  tmp___4 = __errno_location();
#line 3744
  *tmp___4 = 110;
  }
#line 3748
  return ((ssize_t )-1);
}
}
#line 3760 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static size_t gawk_fwrite(void const   *buf___7 , size_t size , size_t count , FILE *fp___0 ,
                          void *opaque ) 
{ 
  size_t tmp___1 ;

  {
  {
#line 3765
  tmp___1 = fwrite((void const   */* __restrict  */)buf___7, size, count, (FILE */* __restrict  */)fp___0);
  }
#line 3765
  return (tmp___1);
}
}
#line 3768 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int gawk_fflush(FILE *fp___0 , void *opaque ) 
{ 
  int tmp___1 ;

  {
  {
#line 3773
  tmp___1 = fflush(fp___0);
  }
#line 3773
  return (tmp___1);
}
}
#line 3776 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int gawk_ferror(FILE *fp___0 , void *opaque ) 
{ 
  int tmp___1 ;

  {
  {
#line 3781
  tmp___1 = ferror(fp___0);
  }
#line 3781
  return (tmp___1);
}
}
#line 3784 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static int gawk_fclose(FILE *fp___0 , void *opaque ) 
{ 
  int tmp___1 ;

  {
  {
#line 3789
  tmp___1 = fclose(fp___0);
  }
#line 3789
  return (tmp___1);
}
}
#line 3795 "/home/wslee/gnu_benchmarks/gawk-4.1.0/io.c"
static void init_output_wrapper(awk_output_buf_t *outbuf ) 
{ 


  {
#line 3798
  outbuf->name = (char const   *)((void *)0);
#line 3799
  outbuf->mode = (char const   *)((void *)0);
#line 3800
  outbuf->fp = (FILE *)((void *)0);
#line 3801
  outbuf->opaque = (void *)0;
#line 3802
  outbuf->redirected = (awk_bool_t )0;
#line 3803
  outbuf->gawk_fwrite = & gawk_fwrite;
#line 3804
  outbuf->gawk_fflush = & gawk_fflush;
#line 3805
  outbuf->gawk_ferror = & gawk_ferror;
#line 3806
  outbuf->gawk_fclose = & gawk_fclose;
#line 3807
  return;
}
}
#line 1061 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
afunc_t int_array_func[11] ;
#line 30 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
NODE **is_integer(NODE *symbol , NODE *subs ) ;
#line 32 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static size_t INT_CHAIN_MAX  =    (size_t )2;
#line 34
static NODE **int_array_init(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) ;
#line 35
static NODE **int_lookup(NODE *symbol , NODE *subs ) ;
#line 36
static NODE **int_exists(NODE *symbol , NODE *subs ) ;
#line 37
static NODE **int_clear(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) ;
#line 38
static NODE **int_remove(NODE *symbol , NODE *subs ) ;
#line 39
static NODE **int_list(NODE *symbol , NODE *t ) ;
#line 40
static NODE **int_copy(NODE *symbol , NODE *newsymb ) ;
#line 41
static NODE **int_dump(NODE *symbol , NODE *ndump___0 ) ;
#line 43
static uint32_t int_hash(uint32_t k , uint32_t hsize ) ;
#line 44
__inline static NODE **int_find(NODE *symbol , long k , uint32_t hash1 ) ;
#line 45
static NODE **int_insert(NODE *symbol , long k , uint32_t hash1 ) ;
#line 46
static void grow_int_table(NODE *symbol ) ;
#line 48 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
afunc_t int_array_func[11]  = 
#line 48
  {      & int_array_init,      & is_integer,      & null_length,      & int_lookup, 
        & int_exists,      & int_clear,      & int_remove,      & int_list, 
        & int_copy,      & int_dump,      (struct exp_node **(*)(struct exp_node * , struct exp_node * ))0};
#line 65 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static NODE **int_array_init(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) 
{ 
  long newval ;
  char *__cil_tmp4 ;

  {
#line 68
  if ((unsigned long )symbol == (unsigned long )((void *)0)) {
    {
#line 72
    newval = getenv_long("INT_CHAIN_MAX");
    }
#line 72
    if (newval > 0L) {
#line 73
      INT_CHAIN_MAX = (size_t )newval;
    }
  } else {
    {
#line 75
    null_array(symbol);
    }
  }
#line 77
  return ((NODE **)(! ((void *)0)));
}
}
#line 82 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
NODE **is_integer(NODE *symbol , NODE *subs ) 
{ 
  long l ;
  double d ;
  char *cp ;
  char *cpend ;
  char *ptr ;
  char save ;
  size_t len ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 88
  if ((unsigned long )subs == (unsigned long )Nnull_string) {
#line 89
    return ((NODE **)((void *)0));
  } else
#line 88
  if (do_flags & 16384) {
#line 89
    return ((NODE **)((void *)0));
  }
#line 91
  if ((subs->flags & 256U) != 0U) {
#line 92
    return ((NODE **)(! ((void *)0)));
  }
#line 94
  if ((subs->flags & 16U) != 0U) {
#line 95
    d = subs->sub.val.nm.fltnum;
#line 96
    if (d <= (double )2147483647) {
#line 96
      if (d >= (double )(-0x7FFFFFFF-1)) {
#line 96
        if (d == (double )((int32_t )d)) {
#line 97
          subs->flags |= 256U;
#line 98
          return ((NODE **)(! ((void *)0)));
        }
      }
    }
#line 100
    return ((NODE **)((void *)0));
  }
#line 109
  if ((subs->flags & 6U) != 0U) {
#line 110
    cp = subs->sub.val.sp;
#line 112
    len = subs->sub.val.slen;
#line 114
    if (len == 0UL) {
#line 115
      return ((NODE **)((void *)0));
    } else {
      {
#line 114
      tmp___1 = __ctype_b_loc();
      }
#line 114
      if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*cp)) & 2048)) {
#line 114
        if ((int )*cp != 45) {
#line 115
          return ((NODE **)((void *)0));
        }
      }
    }
#line 116
    if (len > 1UL) {
#line 116
      if ((int )*cp == 48) {
#line 121
        return ((NODE **)((void *)0));
      } else
#line 116
      if ((int )*cp == 45) {
#line 116
        if ((int )*(cp + 1) == 48) {
#line 121
          return ((NODE **)((void *)0));
        }
      }
    }
#line 122
    if (len == 1UL) {
#line 122
      if ((int )*cp != 45) {
#line 123
        subs->sub.val.nm.fltnum = (double )((long )((int )*cp - 48));
#line 124
        if ((subs->flags & 32U) != 0U) {
#line 125
          subs->flags &= 4294967263U;
#line 126
          subs->flags |= 16U;
        }
#line 128
        subs->flags |= 264U;
#line 129
        return ((NODE **)(! ((void *)0)));
      }
    }
    {
#line 132
    cpend = cp + len;
#line 133
    save = *cpend;
#line 134
    *cpend = (char )'\000';
#line 136
    tmp___2 = __errno_location();
#line 136
    *tmp___2 = 0;
#line 137
    l = strtol((char const   */* __restrict  */)cp, (char **/* __restrict  */)(& ptr),
               10);
#line 138
    *cpend = save;
#line 139
    tmp___3 = __errno_location();
    }
#line 139
    if (*tmp___3 != 0) {
#line 140
      return ((NODE **)((void *)0));
    } else
#line 139
    if ((unsigned long )ptr != (unsigned long )cpend) {
#line 140
      return ((NODE **)((void *)0));
    }
#line 141
    subs->sub.val.nm.fltnum = (double )l;
#line 142
    if ((subs->flags & 32U) != 0U) {
#line 143
      subs->flags &= 4294967263U;
#line 144
      subs->flags |= 16U;
    }
#line 146
    subs->flags |= 8U;
#line 147
    if (l <= 2147483647L) {
#line 147
      if (l >= (-0x7FFFFFFF-1)) {
#line 148
        subs->flags |= 256U;
#line 149
        return ((NODE **)(! ((void *)0)));
      }
    }
  }
#line 152
  return ((NODE **)((void *)0));
}
}
#line 161 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static NODE **int_lookup(NODE *symbol , NODE *subs ) 
{ 
  uint32_t hash1 ;
  long k ;
  unsigned long size ;
  NODE **lhs ;
  NODE *xn ;
  struct exp_node *tmp___1 ;
  struct exp_node **tmp___2 ;
  NODE **tmp___3 ;
  NODE **tmp___4 ;

  {
  {
#line 178
  tmp___3 = is_integer(symbol, subs);
  }
#line 178
  if (! tmp___3) {
#line 179
    xn = symbol->sub.nodep.rn;
#line 180
    if ((unsigned long )xn == (unsigned long )((void *)0)) {
      {
#line 181
      tmp___1 = make_array();
#line 181
      symbol->sub.nodep.rn = tmp___1;
#line 181
      xn = tmp___1;
#line 182
      xn->sub.nodep.name = symbol->sub.nodep.name;
#line 183
      xn->flags |= 65536U;
      }
    } else {
      {
#line 184
      lhs = (*(*(xn->sub.nodep.l.lp + 4)))(xn, subs);
      }
#line 184
      if ((unsigned long )lhs != (unsigned long )((void *)0)) {
#line 185
        return (lhs);
      }
    }
    {
#line 186
    (symbol->sub.nodep.reflags) ++;
#line 187
    tmp___2 = (*(*(xn->sub.nodep.l.lp + 3)))(xn, subs);
    }
#line 187
    return (tmp___2);
  }
#line 190
  k = (long )subs->sub.val.nm.fltnum;
#line 191
  if ((unsigned long )symbol->sub.nodep.r.bv == (unsigned long )((void *)0)) {
    {
#line 192
    grow_int_table(symbol);
    }
  }
  {
#line 194
  hash1 = int_hash((uint32_t )k, (uint32_t )symbol->sub.nodep.cnt);
#line 195
  lhs = int_find(symbol, k, hash1);
  }
#line 195
  if ((unsigned long )lhs != (unsigned long )((void *)0)) {
#line 196
    return (lhs);
  }
#line 200
  (symbol->sub.nodep.reflags) ++;
#line 203
  size = symbol->sub.nodep.reflags;
#line 204
  xn = symbol->sub.nodep.rn;
#line 204
  if ((unsigned long )xn != (unsigned long )((void *)0)) {
#line 205
    size -= xn->sub.nodep.reflags;
  }
#line 207
  if ((symbol->flags & 16384U) == 0U) {
#line 207
    if (size / symbol->sub.nodep.cnt > INT_CHAIN_MAX) {
      {
#line 209
      grow_int_table(symbol);
#line 211
      hash1 = int_hash((uint32_t )k, (uint32_t )symbol->sub.nodep.cnt);
      }
    }
  }
  {
#line 214
  tmp___4 = int_insert(symbol, k, hash1);
  }
#line 214
  return (tmp___4);
}
}
#line 223 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static NODE **int_exists(NODE *symbol , NODE *subs ) 
{ 
  long k ;
  uint32_t hash1 ;
  NODE *xn ;
  struct exp_node **tmp___1 ;
  NODE **tmp___2 ;
  NODE **tmp___3 ;

  {
  {
#line 229
  tmp___2 = is_integer(symbol, subs);
  }
#line 229
  if (! tmp___2) {
#line 230
    xn = symbol->sub.nodep.rn;
#line 231
    if ((unsigned long )xn == (unsigned long )((void *)0)) {
#line 232
      return ((NODE **)((void *)0));
    }
    {
#line 233
    tmp___1 = (*(*(xn->sub.nodep.l.lp + 4)))(xn, subs);
    }
#line 233
    return (tmp___1);
  }
#line 235
  if ((unsigned long )symbol->sub.nodep.r.bv == (unsigned long )((void *)0)) {
#line 236
    return ((NODE **)((void *)0));
  }
  {
#line 238
  k = (long )subs->sub.val.nm.fltnum;
#line 239
  hash1 = int_hash((uint32_t )k, (uint32_t )symbol->sub.nodep.cnt);
#line 240
  tmp___3 = int_find(symbol, k, hash1);
  }
#line 240
  return (tmp___3);
}
}
#line 245 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static NODE **int_clear(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) 
{ 
  unsigned long i___0 ;
  int j ;
  BUCKET *b___0 ;
  BUCKET *next ;
  NODE *r ;
  NODE *xn ;

  {
#line 253
  if ((unsigned long )symbol->sub.nodep.rn != (unsigned long )((void *)0)) {
    {
#line 254
    xn = symbol->sub.nodep.rn;
#line 255
    (*(*(xn->sub.nodep.l.lp + 5)))(xn, (struct exp_node *)((void *)0));
#line 256
    ((BLOCK *)xn)->freep = nextfree[1].freep;
#line 256
    nextfree[1].freep = (BLOCK *)xn;
#line 257
    symbol->sub.nodep.rn = (struct exp_node *)((void *)0);
    }
  }
#line 260
  i___0 = 0UL;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i___0 < symbol->sub.nodep.cnt)) {
#line 260
      goto while_break;
    }
#line 261
    b___0 = *(symbol->sub.nodep.r.bv + i___0);
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 261
        goto while_break___0;
      }
#line 262
      next = b___0->hi.next;
#line 263
      j = 0;
      {
#line 263
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 263
        if (! ((size_t )j < b___0->hi.cnt)) {
#line 263
          goto while_break___1;
        }
#line 264
        r = b___0->hi.val[j];
#line 265
        if ((unsigned int )r->type == 5U) {
          {
#line 266
          (*(*(r->sub.nodep.l.lp + 5)))(r, (struct exp_node *)((void *)0));
#line 267
          free((void *)r->sub.nodep.name);
#line 268
          ((BLOCK *)r)->freep = nextfree[1].freep;
#line 268
          nextfree[1].freep = (BLOCK *)r;
          }
        } else {
          {
#line 270
          unref(r);
          }
        }
#line 263
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 272
      ((BLOCK *)b___0)->freep = nextfree[2].freep;
#line 272
      nextfree[2].freep = (BLOCK *)b___0;
#line 261
      b___0 = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 274
    *(symbol->sub.nodep.r.bv + i___0) = (BUCKET *)((void *)0);
#line 260
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if ((unsigned long )symbol->sub.nodep.r.bv != (unsigned long )((void *)0)) {
    {
#line 277
    free((void *)symbol->sub.nodep.r.bv);
    }
  }
  {
#line 278
  (*(*(symbol->sub.nodep.l.lp + 0)))(symbol, (struct exp_node *)((void *)0));
  }
#line 279
  return ((NODE **)((void *)0));
}
}
#line 285 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static NODE **int_remove(NODE *symbol , NODE *subs ) 
{ 
  uint32_t hash1 ;
  BUCKET *b___0 ;
  BUCKET *prev ;
  long k ;
  int i___0 ;
  NODE *xn ;
  struct exp_node **tmp___1 ;
  NODE **tmp___2 ;
  BUCKET *head ;

  {
#line 289
  prev = (BUCKET *)((void *)0);
#line 292
  xn = symbol->sub.nodep.rn;
#line 294
  if (symbol->sub.nodep.reflags == 0UL) {
#line 295
    return ((NODE **)((void *)0));
  } else
#line 294
  if ((unsigned long )symbol->sub.nodep.r.bv == (unsigned long )((void *)0)) {
#line 295
    return ((NODE **)((void *)0));
  }
  {
#line 297
  tmp___2 = is_integer(symbol, subs);
  }
#line 297
  if (! tmp___2) {
#line 298
    if ((unsigned long )xn == (unsigned long )((void *)0)) {
#line 299
      return ((NODE **)((void *)0));
    } else {
      {
#line 298
      tmp___1 = (*(*(xn->sub.nodep.l.lp + 6)))(xn, subs);
      }
#line 298
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 299
        return ((NODE **)((void *)0));
      }
    }
#line 300
    if (xn->sub.nodep.reflags == 0UL) {
#line 301
      ((BLOCK *)xn)->freep = nextfree[1].freep;
#line 301
      nextfree[1].freep = (BLOCK *)xn;
#line 302
      symbol->sub.nodep.rn = (struct exp_node *)((void *)0);
    }
#line 304
    (symbol->sub.nodep.reflags) --;
#line 306
    return ((NODE **)(! ((void *)0)));
  }
  {
#line 309
  k = (long )subs->sub.val.nm.fltnum;
#line 310
  hash1 = int_hash((uint32_t )k, (uint32_t )symbol->sub.nodep.cnt);
#line 312
  b___0 = *(symbol->sub.nodep.r.bv + hash1);
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 312
      goto while_break;
    }
#line 313
    i___0 = 0;
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (! ((size_t )i___0 < b___0->hi.cnt)) {
#line 313
        goto while_break___0;
      }
#line 314
      if (k != b___0->hi.li[i___0]) {
#line 315
        goto __Cont;
      }
#line 318
      if (i___0 == 0) {
#line 318
        if (b___0->hi.cnt == 2UL) {
#line 321
          b___0->hi.li[0] = b___0->hi.li[1];
#line 322
          b___0->hi.val[0] = b___0->hi.val[1];
        }
      }
#line 326
      goto removed;
      __Cont: /* CIL Label */ 
#line 313
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 312
    prev = b___0;
#line 312
    b___0 = b___0->hi.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
#line 331
    return ((NODE **)((void *)0));
  }
  removed: 
#line 334
  (b___0->hi.cnt) --;
#line 336
  if (b___0->hi.cnt == 0UL) {
#line 338
    if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 339
      prev->hi.next = b___0->hi.next;
    } else {
#line 341
      *(symbol->sub.nodep.r.bv + hash1) = b___0->hi.next;
    }
#line 344
    ((BLOCK *)b___0)->freep = nextfree[2].freep;
#line 344
    nextfree[2].freep = (BLOCK *)b___0;
  } else
#line 345
  if ((unsigned long )b___0 != (unsigned long )*(symbol->sub.nodep.r.bv + hash1)) {
#line 346
    head = *(symbol->sub.nodep.r.bv + hash1);
#line 350
    (head->hi.cnt) --;
#line 350
    i___0 = (int )head->hi.cnt;
#line 351
    b___0->hi.li[1] = head->hi.li[i___0];
#line 352
    b___0->hi.val[1] = head->hi.val[i___0];
#line 353
    (b___0->hi.cnt) ++;
#line 354
    if (i___0 == 0) {
#line 356
      *(symbol->sub.nodep.r.bv + hash1) = head->hi.next;
#line 357
      ((BLOCK *)head)->freep = nextfree[2].freep;
#line 357
      nextfree[2].freep = (BLOCK *)head;
    }
  }
#line 362
  (symbol->sub.nodep.reflags) --;
#line 363
  if ((unsigned long )xn == (unsigned long )((void *)0)) {
#line 363
    if (symbol->sub.nodep.reflags == 0UL) {
      {
#line 364
      free((void *)symbol->sub.nodep.r.bv);
#line 365
      (*(*(symbol->sub.nodep.l.lp + 0)))(symbol, (struct exp_node *)((void *)0));
      }
    } else {
#line 363
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 366
  if ((unsigned long )xn != (unsigned long )((void *)0)) {
#line 366
    if (symbol->sub.nodep.reflags == xn->sub.nodep.reflags) {
      {
#line 368
      xn->flags &= 4294901759U;
#line 369
      xn->sub.nodep.x.extra = symbol->sub.nodep.x.extra;
#line 370
      free((void *)symbol->sub.nodep.r.bv);
#line 371
      *symbol = *xn;
#line 372
      ((BLOCK *)xn)->freep = nextfree[1].freep;
#line 372
      nextfree[1].freep = (BLOCK *)xn;
      }
    }
  }
#line 375
  return ((NODE **)(! ((void *)0)));
}
}
#line 381 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static NODE **int_copy(NODE *symbol , NODE *newsymb ) 
{ 
  BUCKET **old ;
  BUCKET **new ;
  BUCKET **pnew ;
  BUCKET *chain ;
  BUCKET *newchain ;
  int j ;
  unsigned long i___0 ;
  unsigned long cursize ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  NODE *oldval ;
  NODE *r ;
  size_t tmp___7 ;
  NODE *xn ;
  NODE *n ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 392
  cursize = symbol->sub.nodep.cnt;
#line 395
  tmp___1 = malloc(cursize * sizeof(BUCKET *));
#line 395
  new = (BUCKET **)tmp___1;
  }
#line 395
  if (new) {
#line 395
    tmp___5 = 1;
  } else {
    {
#line 395
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c", 395);
#line 395
    tmp___2 = __errno_location();
#line 395
    tmp___3 = strerror(*tmp___2);
#line 395
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 395
    r_fatal((char const   *)tmp___4, "int_copy", "new", (long )(cursize * sizeof(BUCKET *)),
            tmp___3);
#line 395
    tmp___5 = 0;
    }
  }
  {
#line 396
  memset((void *)new, '\000', cursize * sizeof(BUCKET *));
#line 398
  old = symbol->sub.nodep.r.bv;
#line 400
  i___0 = 0UL;
  }
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (i___0 < cursize)) {
#line 400
      goto while_break;
    }
#line 401
    chain = *(old + i___0);
#line 401
    pnew = new + i___0;
    {
#line 401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
#line 401
        goto while_break___0;
      }
#line 404
      newchain = (BUCKET *)nextfree[2].freep;
#line 404
      if (newchain) {
#line 404
        nextfree[2].freep = ((BLOCK *)newchain)->freep;
      } else {
        {
#line 404
        tmp___6 = more_blocks(2);
#line 404
        newchain = (BUCKET *)tmp___6;
        }
      }
#line 405
      newchain->hi.cnt = chain->hi.cnt;
#line 406
      newchain->hi.next = (union bucket_item *)((void *)0);
#line 407
      j = 0;
      {
#line 407
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 407
        if (! ((size_t )j < chain->hi.cnt)) {
#line 407
          goto while_break___1;
        }
#line 414
        newchain->hi.li[j] = chain->hi.li[j];
#line 416
        oldval = chain->hi.val[j];
#line 417
        if ((unsigned int )oldval->type == 1U) {
          {
#line 418
          newchain->hi.val[j] = dupnode(oldval);
          }
        } else {
          {
#line 421
          r = make_array();
#line 422
          tmp___7 = strlen((char const   *)oldval->sub.nodep.name);
#line 422
          r->sub.nodep.name = estrdup((char const   *)oldval->sub.nodep.name, tmp___7);
#line 423
          r->sub.nodep.x.extra = newsymb;
#line 424
          newchain->hi.val[j] = assoc_copy(oldval, r);
          }
        }
#line 407
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 428
      *pnew = newchain;
#line 429
      newchain->hi.next = (union bucket_item *)((void *)0);
#line 430
      pnew = & newchain->hi.next;
#line 401
      chain = chain->hi.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 400
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  if ((unsigned long )symbol->sub.nodep.rn != (unsigned long )((void *)0)) {
    {
#line 436
    xn = symbol->sub.nodep.rn;
#line 437
    n = make_array();
#line 438
    n->sub.nodep.name = newsymb->sub.nodep.name;
#line 439
    (*(*(xn->sub.nodep.l.lp + 8)))(xn, n);
#line 440
    newsymb->sub.nodep.rn = n;
    }
  } else {
#line 442
    newsymb->sub.nodep.rn = (struct exp_node *)((void *)0);
  }
#line 444
  newsymb->sub.nodep.reflags = symbol->sub.nodep.reflags;
#line 445
  newsymb->sub.nodep.r.bv = new;
#line 446
  newsymb->sub.nodep.cnt = cursize;
#line 447
  newsymb->flags = symbol->flags;
#line 449
  return ((NODE **)((void *)0));
}
}
#line 464 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static char buf___0[100]  ;
#line 455 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static NODE **int_list(NODE *symbol , NODE *t ) 
{ 
  NODE **list ;
  unsigned long num_elems ;
  unsigned long list_size___0 ;
  unsigned long i___0 ;
  unsigned long k ;
  BUCKET *b___0 ;
  NODE *r ;
  NODE *subs ;
  NODE *xn ;
  int j ;
  int elem_size ;
  long num ;
  assoc_kind_t assoc_kind ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 458
  list = (NODE **)((void *)0);
#line 459
  k = 0UL;
#line 462
  elem_size = 1;
#line 467
  if (symbol->sub.nodep.reflags == 0UL) {
#line 468
    return ((NODE **)((void *)0));
  }
#line 470
  assoc_kind = (assoc_kind_t )t->flags;
#line 471
  num_elems = symbol->sub.nodep.reflags;
#line 472
  if (((unsigned int )assoc_kind & 259U) == 257U) {
#line 473
    num_elems = 1UL;
  }
#line 475
  if (((unsigned int )assoc_kind & 3U) == 3U) {
#line 476
    elem_size = 2;
  }
#line 477
  list_size___0 = (unsigned long )elem_size * num_elems;
#line 479
  if ((unsigned long )symbol->sub.nodep.rn != (unsigned long )((void *)0)) {
    {
#line 480
    xn = symbol->sub.nodep.rn;
#line 481
    list = (*(*(xn->sub.nodep.l.lp + 7)))(xn, t);
    }
#line 483
    if (num_elems == 1UL) {
#line 484
      return (list);
    } else
#line 483
    if (num_elems == xn->sub.nodep.reflags) {
#line 484
      return (list);
    }
    {
#line 485
    tmp___1 = realloc((void *)((char *)list), list_size___0 * sizeof(NODE *));
#line 485
    list = (NODE **)tmp___1;
    }
#line 485
    if (list) {
#line 485
      tmp___5 = 1;
    } else {
      {
#line 485
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c", 485);
#line 485
      tmp___2 = __errno_location();
#line 485
      tmp___3 = strerror(*tmp___2);
#line 485
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 485
      r_fatal((char const   *)tmp___4, "int_list", "list", (long )(list_size___0 * sizeof(NODE *)),
              tmp___3);
#line 485
      tmp___5 = 0;
      }
    }
#line 486
    k = (unsigned long )elem_size * xn->sub.nodep.reflags;
  } else {
    {
#line 488
    tmp___6 = malloc(list_size___0 * sizeof(NODE *));
#line 488
    list = (NODE **)tmp___6;
    }
#line 488
    if (list) {
#line 488
      tmp___10 = 1;
    } else {
      {
#line 488
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c", 488);
#line 488
      tmp___7 = __errno_location();
#line 488
      tmp___8 = strerror(*tmp___7);
#line 488
      tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 488
      r_fatal((char const   *)tmp___9, "int_list", "list", (long )(list_size___0 * sizeof(NODE *)),
              tmp___8);
#line 488
      tmp___10 = 0;
      }
    }
  }
#line 492
  i___0 = 0UL;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! (i___0 < symbol->sub.nodep.cnt)) {
#line 492
      goto while_break;
    }
#line 493
    b___0 = *(symbol->sub.nodep.r.bv + i___0);
    {
#line 493
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 493
      if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 493
        goto while_break___0;
      }
#line 494
      j = 0;
      {
#line 494
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 494
        if (! ((size_t )j < b___0->hi.cnt)) {
#line 494
          goto while_break___1;
        }
#line 496
        num = b___0->hi.li[j];
#line 497
        if (((unsigned int )assoc_kind & 8U) != 0U) {
          {
#line 498
          sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%ld",
                  num);
#line 499
          tmp___11 = strlen((char const   *)(buf___0));
#line 499
          subs = make_str_node((char const   *)(buf___0), tmp___11, 0);
#line 500
          subs->sub.val.nm.fltnum = (double )num;
#line 501
          subs->flags |= 264U;
          }
        } else {
          {
#line 503
          subs = (*make_number)((double )num);
#line 504
          subs->flags |= 768U;
          }
        }
#line 506
        tmp___12 = k;
#line 506
        k ++;
#line 506
        *(list + tmp___12) = subs;
#line 509
        if (((unsigned int )assoc_kind & 2U) != 0U) {
#line 510
          r = b___0->hi.val[j];
#line 511
          if ((unsigned int )r->type == 1U) {
#line 512
            if (((unsigned int )assoc_kind & 16U) != 0U) {
              {
#line 513
              force_number(r);
              }
            } else
#line 514
            if (((unsigned int )assoc_kind & 32U) != 0U) {
              {
#line 515
              r = force_string(r);
              }
            }
          }
#line 517
          tmp___13 = k;
#line 517
          k ++;
#line 517
          *(list + tmp___13) = r;
        }
#line 520
        if (k >= list_size___0) {
#line 521
          return (list);
        }
#line 494
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 493
      b___0 = b___0->hi.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 492
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return (list);
}
}
#line 531 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
double int_kilobytes(NODE *symbol ) 
{ 
  unsigned long i___0 ;
  unsigned long bucket_cnt ;
  BUCKET *b___0 ;
  double kb ;
  double tmp___1 ;

  {
#line 534
  bucket_cnt = 0UL;
#line 539
  i___0 = 0UL;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! (i___0 < symbol->sub.nodep.cnt)) {
#line 539
      goto while_break;
    }
#line 540
    b___0 = *(symbol->sub.nodep.r.bv + i___0);
    {
#line 540
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 540
      if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 540
        goto while_break___0;
      }
#line 541
      bucket_cnt ++;
#line 540
      b___0 = b___0->hi.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 539
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  kb = ((double )bucket_cnt * (double )sizeof(BUCKET ) + (double )symbol->sub.nodep.cnt * (double )sizeof(BUCKET *)) / 1024.0;
#line 546
  if ((unsigned long )symbol->sub.nodep.rn != (unsigned long )((void *)0)) {
    {
#line 547
    tmp___1 = str_kilobytes(symbol->sub.nodep.rn);
#line 547
    kb += tmp___1;
    }
  }
#line 549
  return (kb);
}
}
#line 566 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static size_t hash_dist___0[32]  ;
#line 555 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static NODE **int_dump(NODE *symbol , NODE *ndump___0 ) 
{ 
  int indent_level___0 ;
  BUCKET *b___0 ;
  NODE *xn ;
  unsigned long str_size ;
  unsigned long int_size ;
  unsigned long i___0 ;
  size_t j ;
  size_t bucket_cnt ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  double tmp___4 ;
  NODE *subs ;
  char const   *aname___0 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 562
  xn = (NODE *)((void *)0);
#line 563
  str_size = 0UL;
#line 563
  int_size = 0UL;
#line 568
  indent_level___0 = (int )ndump___0->sub.nodep.x.xl;
#line 570
  if ((unsigned long )symbol->sub.nodep.rn != (unsigned long )((void *)0)) {
#line 571
    xn = symbol->sub.nodep.rn;
#line 572
    str_size = xn->sub.nodep.reflags;
  }
#line 574
  int_size = symbol->sub.nodep.reflags - str_size;
#line 576
  if ((symbol->flags & 65536U) == 0U) {
    {
#line 577
    tmp___1 = array_vname((NODE const   *)symbol);
    }
#line 577
    if ((unsigned long )symbol->sub.nodep.x.extra == (unsigned long )((void *)0)) {
#line 577
      tmp___2 = "array";
    } else {
#line 577
      tmp___2 = "sub-array";
    }
    {
#line 577
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"%s `%s\'\n",
            tmp___2, tmp___1);
    }
  }
  {
#line 581
  indent_level___0 ++;
#line 582
  indent(indent_level___0);
#line 583
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"array_func: int_array_func\n");
  }
#line 584
  if (symbol->flags != 0U) {
    {
#line 585
    indent(indent_level___0);
#line 586
    tmp___3 = flags2str((int )symbol->flags);
#line 586
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"flags: %s\n",
            tmp___3);
    }
  }
  {
#line 588
  indent(indent_level___0);
#line 589
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"INT_CHAIN_MAX: %lu\n",
          INT_CHAIN_MAX);
#line 590
  indent(indent_level___0);
#line 591
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"array_size: %lu (int)\n",
          symbol->sub.nodep.cnt);
#line 592
  indent(indent_level___0);
#line 593
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"table_size: %lu (total), %lu (int), %lu (str)\n",
          symbol->sub.nodep.reflags, int_size, str_size);
#line 595
  indent(indent_level___0);
#line 596
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"Avg # of items per chain (int): %.2g\n",
          (double )int_size / (double )symbol->sub.nodep.cnt);
#line 599
  indent(indent_level___0);
#line 600
  tmp___4 = int_kilobytes(symbol);
#line 600
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"memory: %.2g kB (total)\n",
          tmp___4);
#line 604
  memset((void *)(hash_dist___0), '\000', 32UL * sizeof(size_t ));
#line 605
  i___0 = 0UL;
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i___0 < symbol->sub.nodep.cnt)) {
#line 605
      goto while_break;
    }
#line 606
    bucket_cnt = (size_t )0;
#line 607
    b___0 = *(symbol->sub.nodep.r.bv + i___0);
    {
#line 607
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 607
      if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 607
        goto while_break___0;
      }
#line 608
      bucket_cnt += b___0->hi.cnt;
#line 607
      b___0 = b___0->hi.next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 609
    if (bucket_cnt >= 31UL) {
#line 610
      bucket_cnt = (size_t )31;
    }
#line 611
    (hash_dist___0[bucket_cnt]) ++;
#line 605
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 614
  indent(indent_level___0);
#line 615
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"Hash distribution:\n");
#line 616
  indent_level___0 ++;
#line 617
  j = (size_t )0;
  }
  {
#line 617
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 617
    if (! (j <= 31UL)) {
#line 617
      goto while_break___1;
    }
#line 618
    if (hash_dist___0[j] > 0UL) {
      {
#line 619
      indent(indent_level___0);
      }
#line 620
      if (j == 31UL) {
        {
#line 621
        fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"[>=%lu]:%lu\n",
                31UL, hash_dist___0[j]);
        }
      } else {
        {
#line 624
        fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"[%lu]:%lu\n",
                j, hash_dist___0[j]);
        }
      }
    }
#line 617
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 628
  indent_level___0 --;
#line 632
  if (ndump___0->sub.nodep.l.ll >= 0L) {
    {
#line 636
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"\n");
#line 638
    aname___0 = make_aname((NODE const   *)symbol);
#line 639
    subs = (*make_number)((double )0);
#line 640
    subs->flags |= 768U;
#line 642
    i___0 = 0UL;
    }
    {
#line 642
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 642
      if (! (i___0 < symbol->sub.nodep.cnt)) {
#line 642
        goto while_break___2;
      }
#line 643
      b___0 = *(symbol->sub.nodep.r.bv + i___0);
      {
#line 643
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 643
        if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 643
          goto while_break___3;
        }
#line 644
        j = (size_t )0;
        {
#line 644
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 644
          if (! (j < b___0->hi.cnt)) {
#line 644
            goto while_break___4;
          }
          {
#line 645
          subs->sub.val.nm.fltnum = (double )b___0->hi.li[j];
#line 646
          assoc_info(subs, b___0->hi.val[j], ndump___0, aname___0);
#line 644
          j ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 643
        b___0 = b___0->hi.next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 642
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 650
    unref(subs);
    }
  }
#line 653
  if ((unsigned long )xn != (unsigned long )((void *)0)) {
    {
#line 654
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"\n");
#line 655
    (*(*(xn->sub.nodep.l.lp + 9)))(xn, ndump___0);
    }
  }
#line 658
  return ((NODE **)((void *)0));
}
}
#line 666 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static uint32_t int_hash(uint32_t k , uint32_t hsize ) 
{ 


  {
#line 678
  k ^= k << 3;
#line 679
  k += k >> 5;
#line 680
  k ^= k << 4;
#line 681
  k += k >> 17;
#line 682
  k ^= k << 25;
#line 683
  k += k >> 6;
#line 685
  if (k >= hsize) {
#line 686
    k %= hsize;
  }
#line 687
  return (k);
}
}
#line 692 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
__inline static NODE **int_find(NODE *symbol , long k , uint32_t hash1 ) 
{ 
  BUCKET *b___0 ;
  int i___0 ;

  {
#line 699
  b___0 = *(symbol->sub.nodep.r.bv + hash1);
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! ((unsigned long )b___0 != (unsigned long )((void *)0))) {
#line 699
      goto while_break;
    }
#line 700
    i___0 = 0;
    {
#line 700
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 700
      if (! ((size_t )i___0 < b___0->hi.cnt)) {
#line 700
        goto while_break___0;
      }
#line 701
      if (b___0->hi.li[i___0] == k) {
#line 702
        return (b___0->hi.val + i___0);
      }
#line 700
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 699
    b___0 = b___0->hi.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  return ((NODE **)((void *)0));
}
}
#line 711 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static NODE **int_insert(NODE *symbol , long k , uint32_t hash1 ) 
{ 
  BUCKET *b___0 ;
  int i___0 ;
  void *tmp___1 ;

  {
#line 717
  b___0 = *(symbol->sub.nodep.r.bv + hash1);
#line 721
  if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
#line 721
    goto _L;
  } else {
#line 721
    i___0 = (int )b___0->hi.cnt;
#line 721
    if (i___0 == 2) {
      _L: /* CIL Label */ 
#line 722
      b___0 = (BUCKET *)nextfree[2].freep;
#line 722
      if (b___0) {
#line 722
        nextfree[2].freep = ((BLOCK *)b___0)->freep;
      } else {
        {
#line 722
        tmp___1 = more_blocks(2);
#line 722
        b___0 = (BUCKET *)tmp___1;
        }
      }
#line 723
      b___0->hi.cnt = (size_t )0;
#line 724
      b___0->hi.next = *(symbol->sub.nodep.r.bv + hash1);
#line 725
      *(symbol->sub.nodep.r.bv + hash1) = b___0;
#line 726
      i___0 = 0;
    }
  }
  {
#line 729
  b___0->hi.li[i___0] = k;
#line 730
  b___0->hi.val[i___0] = dupnode(Nnull_string);
#line 731
  (b___0->hi.cnt) ++;
  }
#line 732
  return (& b___0->hi.val[i___0]);
}
}
#line 756 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static unsigned long const   sizes___0[21]  = 
#line 756
  {      (unsigned long const   )13,      (unsigned long const   )127,      (unsigned long const   )1021,      (unsigned long const   )8191, 
        (unsigned long const   )16381,      (unsigned long const   )32749,      (unsigned long const   )65497,      (unsigned long const   )131101, 
        (unsigned long const   )262147,      (unsigned long const   )524309,      (unsigned long const   )1048583,      (unsigned long const   )2097169, 
        (unsigned long const   )4194319,      (unsigned long const   )8388617,      (unsigned long const   )16777259,      (unsigned long const   )33554467, 
        (unsigned long const   )67108879,      (unsigned long const   )134217757,      (unsigned long const   )268435459,      (unsigned long const   )536870923, 
        (unsigned long const   )1073741827};
#line 738 "/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c"
static void grow_int_table(NODE *symbol ) 
{ 
  BUCKET **old ;
  BUCKET **new ;
  BUCKET *chain ;
  BUCKET *next ;
  int i___0 ;
  int j ;
  unsigned long oldsize ;
  unsigned long newsize ;
  unsigned long k ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  long num ;
  uint32_t tmp___6 ;
  NODE **tmp___7 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 765
  oldsize = symbol->sub.nodep.cnt;
#line 765
  newsize = oldsize;
#line 767
  i___0 = 0;
#line 767
  j = (int )(sizeof(sizes___0) / sizeof(sizes___0[0]));
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 767
    if (! (i___0 < j)) {
#line 767
      goto while_break;
    }
#line 768
    if (oldsize < (unsigned long )sizes___0[i___0]) {
#line 769
      newsize = (unsigned long )sizes___0[i___0];
#line 770
      goto while_break;
    }
#line 767
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  if (newsize == oldsize) {
#line 774
    symbol->flags |= 16384U;
#line 775
    return;
  }
  {
#line 779
  tmp___1 = malloc(newsize * sizeof(BUCKET *));
#line 779
  new = (BUCKET **)tmp___1;
  }
#line 779
  if (new) {
#line 779
    tmp___5 = 1;
  } else {
    {
#line 779
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/int_array.c", 779);
#line 779
    tmp___2 = __errno_location();
#line 779
    tmp___3 = strerror(*tmp___2);
#line 779
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 779
    r_fatal((char const   *)tmp___4, "grow_int_table", "new", (long )(newsize * sizeof(BUCKET *)),
            tmp___3);
#line 779
    tmp___5 = 0;
    }
  }
  {
#line 780
  memset((void *)new, '\000', newsize * sizeof(BUCKET *));
#line 782
  old = symbol->sub.nodep.r.bv;
#line 783
  symbol->sub.nodep.r.bv = new;
#line 784
  symbol->sub.nodep.cnt = newsize;
  }
#line 787
  if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 788
    return;
  }
#line 793
  k = 0UL;
  {
#line 793
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 793
    if (! (k < oldsize)) {
#line 793
      goto while_break___0;
    }
#line 795
    chain = *(old + k);
    {
#line 795
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 795
      if (! ((unsigned long )chain != (unsigned long )((void *)0))) {
#line 795
        goto while_break___1;
      }
#line 796
      i___0 = 0;
      {
#line 796
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 796
        if (! ((size_t )i___0 < chain->hi.cnt)) {
#line 796
          goto while_break___2;
        }
        {
#line 797
        num = chain->hi.li[i___0];
#line 798
        tmp___6 = int_hash((uint32_t )num, (uint32_t )newsize);
#line 798
        tmp___7 = int_insert(symbol, num, tmp___6);
#line 798
        *tmp___7 = chain->hi.val[i___0];
#line 796
        i___0 ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 800
      next = chain->hi.next;
#line 801
      ((BLOCK *)chain)->freep = nextfree[2].freep;
#line 801
      nextfree[2].freep = (BLOCK *)chain;
#line 795
      chain = next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 793
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 804
  free((void *)old);
  }
#line 805
  return;
}
}
#line 177 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.h"
 __attribute__((__nothrow__)) int getopt_long_only(int argc , char * const  *argv ,
                                                   char const   *options , struct option  const  *long_options ,
                                                   int *opt_index ) ;
#line 22 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt_int.h"
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only , int posixly_correct ) ;
#line 112
int _getopt_internal_r(int argc , char * const  *argv , char const   *optstring ,
                       struct option  const  *longopts , int *longind , int long_only ,
                       struct _getopt_data *d , int posixly_correct ) ;
#line 118
int _getopt_long_r(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 123
int _getopt_long_only_r(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 66 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt1.c"
 __attribute__((__nothrow__)) int getopt_long(int argc , char * const  *argv , char const   *options ,
                                              struct option  const  *long_options ,
                                              int *opt_index ) ;
#line 66 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt1.c"
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) 
{ 
  int tmp___1 ;

  {
  {
#line 70
  tmp___1 = _getopt_internal(argc, argv, options, long_options, opt_index, 0, 0);
  }
#line 70
  return (tmp___1);
}
}
#line 73 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt1.c"
int _getopt_long_r(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp___1 ;

  {
  {
#line 78
  tmp___1 = _getopt_internal_r(argc, argv, options, long_options, opt_index, 0, d,
                               0);
  }
#line 78
  return (tmp___1);
}
}
#line 87
 __attribute__((__nothrow__)) int getopt_long_only(int argc , char * const  *argv ,
                                                   char const   *options , struct option  const  *long_options ,
                                                   int *opt_index ) ;
#line 87 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt1.c"
int getopt_long_only(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                     int *opt_index ) 
{ 
  int tmp___1 ;

  {
  {
#line 91
  tmp___1 = _getopt_internal(argc, argv, options, long_options, opt_index, 1, 0);
  }
#line 91
  return (tmp___1);
}
}
#line 94 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt1.c"
int _getopt_long_only_r(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp___1 ;

  {
  {
#line 99
  tmp___1 = _getopt_internal_r(argc, argv, options, long_options, opt_index, 1, d,
                               0);
  }
#line 99
  return (tmp___1);
}
}
#line 555 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 57 "./getopt.h"
char *optarg  ;
#line 150
 __attribute__((__nothrow__)) int getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 129 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
int optind  =    1;
#line 134 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
int opterr  =    1;
#line 140 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
int optopt  =    '?';
#line 144 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
static struct _getopt_data getopt_data  ;
#line 197 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ 
  int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i___0 ;
  int len___0 ;
  register int i___1 ;

  {
#line 200
  bottom = d->__first_nonopt;
#line 201
  middle = d->__last_nonopt;
#line 202
  top = d->optind;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (top > middle) {
#line 232
      if (! (middle > bottom)) {
#line 232
        goto while_break;
      }
    } else {
#line 232
      goto while_break;
    }
#line 234
    if (top - middle > middle - bottom) {
#line 237
      len = middle - bottom;
#line 241
      i___0 = 0;
      {
#line 241
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 241
        if (! (i___0 < len)) {
#line 241
          goto while_break___0;
        }
#line 243
        tem = *(argv + (bottom + i___0));
#line 244
        *(argv + (bottom + i___0)) = *(argv + ((top - (middle - bottom)) + i___0));
#line 245
        *(argv + ((top - (middle - bottom)) + i___0)) = tem;
#line 241
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 249
      top -= len;
    } else {
#line 254
      len___0 = top - middle;
#line 258
      i___1 = 0;
      {
#line 258
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 258
        if (! (i___1 < len___0)) {
#line 258
          goto while_break___1;
        }
#line 260
        tem = *(argv + (bottom + i___1));
#line 261
        *(argv + (bottom + i___1)) = *(argv + (middle + i___1));
#line 262
        *(argv + (middle + i___1)) = tem;
#line 258
        i___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 266
      bottom += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  d->__first_nonopt += d->optind - d->__last_nonopt;
#line 273
  d->__last_nonopt = d->optind;
#line 274
  return;
}
}
#line 278 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
static char const   *_getopt_initialize(int argc , char * const  *argv , char const   *optstring ,
                                        struct _getopt_data *d , int posixly_correct ) 
{ 
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
#line 286
  tmp___1 = d->optind;
#line 286
  d->__last_nonopt = tmp___1;
#line 286
  d->__first_nonopt = tmp___1;
#line 288
  d->__nextchar = (char *)((void *)0);
#line 290
  tmp___2 = getenv("POSIXLY_CORRECT");
  }
#line 290
  if (tmp___2) {
#line 290
    tmp___3 = 1;
  } else {
#line 290
    tmp___3 = 0;
  }
#line 290
  d->__posixly_correct = posixly_correct | tmp___3;
#line 294
  if ((int const   )*(optstring + 0) == 45) {
#line 296
    d->__ordering = (enum __anonenum___ordering_3 )2;
#line 297
    optstring ++;
  } else
#line 299
  if ((int const   )*(optstring + 0) == 43) {
#line 301
    d->__ordering = (enum __anonenum___ordering_3 )0;
#line 302
    optstring ++;
  } else
#line 304
  if (d->__posixly_correct) {
#line 305
    d->__ordering = (enum __anonenum___ordering_3 )0;
  } else {
#line 307
    d->__ordering = (enum __anonenum___ordering_3 )1;
  }
#line 339
  return (optstring);
}
}
#line 398 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
int _getopt_internal_r(int argc , char * const  *argv , char const   *optstring ,
                       struct option  const  *longopts , int *longind , int long_only ,
                       struct _getopt_data *d , int posixly_correct ) 
{ 
  int print_errors ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *nameend ;
  unsigned int namelen ;
  struct option  const  *p ;
  struct option  const  *pfound ;
  struct option_list *ambig_list ;
  int exact___0 ;
  int indfound ;
  int option_index ;
  struct option_list *newp ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  struct option_list first___3 ;
  char *tmp___7 ;
  struct option_list *tmp_next ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char c ;
  char *tmp___21 ;
  char *temp ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *nameend___0 ;
  struct option  const  *p___0 ;
  struct option  const  *pfound___0 ;
  int exact___1 ;
  int ambig ;
  int indfound___0 ;
  int option_index___0 ;
  char *tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  size_t tmp___29 ;
  char *tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  size_t tmp___34 ;
  int tmp___35 ;
  size_t tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  void *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;

  {
#line 403
  print_errors = d->opterr;
#line 405
  if (argc < 1) {
#line 406
    return (-1);
  }
#line 408
  d->optarg = (char *)((void *)0);
#line 410
  if (d->optind == 0) {
#line 410
    goto _L;
  } else
#line 410
  if (! d->__initialized) {
    _L: /* CIL Label */ 
#line 412
    if (d->optind == 0) {
#line 413
      d->optind = 1;
    }
    {
#line 414
    optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct);
#line 416
    d->__initialized = 1;
    }
  } else
#line 418
  if ((int const   )*(optstring + 0) == 45) {
#line 419
    optstring ++;
  } else
#line 418
  if ((int const   )*(optstring + 0) == 43) {
#line 419
    optstring ++;
  }
#line 420
  if ((int const   )*(optstring + 0) == 58) {
#line 421
    print_errors = 0;
  }
#line 435
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
#line 435
    goto _L___3;
  } else
#line 435
  if ((int )*(d->__nextchar) == 0) {
    _L___3: /* CIL Label */ 
#line 441
    if (d->__last_nonopt > d->optind) {
#line 442
      d->__last_nonopt = d->optind;
    }
#line 443
    if (d->__first_nonopt > d->optind) {
#line 444
      d->__first_nonopt = d->optind;
    }
#line 446
    if ((unsigned int )d->__ordering == 1U) {
#line 451
      if (d->__first_nonopt != d->__last_nonopt) {
#line 451
        if (d->__last_nonopt != d->optind) {
          {
#line 453
          exchange((char **)argv, d);
          }
        } else {
#line 451
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 454
      if (d->__last_nonopt != d->optind) {
#line 455
        d->__first_nonopt = d->optind;
      }
      {
#line 460
      while (1) {
        while_continue: /* CIL Label */ ;
#line 460
        if (d->optind < argc) {
#line 460
          if (! ((int )*(*(argv + d->optind) + 0) != 45)) {
#line 460
            if (! ((int )*(*(argv + d->optind) + 1) == 0)) {
#line 460
              goto while_break;
            }
          }
        } else {
#line 460
          goto while_break;
        }
#line 461
        (d->optind) ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 462
      d->__last_nonopt = d->optind;
    }
#line 470
    if (d->optind != argc) {
      {
#line 470
      tmp___1 = strcmp((char const   *)*(argv + d->optind), "--");
      }
#line 470
      if (! tmp___1) {
#line 472
        (d->optind) ++;
#line 474
        if (d->__first_nonopt != d->__last_nonopt) {
#line 474
          if (d->__last_nonopt != d->optind) {
            {
#line 476
            exchange((char **)argv, d);
            }
          } else {
#line 474
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 477
        if (d->__first_nonopt == d->__last_nonopt) {
#line 478
          d->__first_nonopt = d->optind;
        }
#line 479
        d->__last_nonopt = argc;
#line 481
        d->optind = argc;
      }
    }
#line 487
    if (d->optind == argc) {
#line 491
      if (d->__first_nonopt != d->__last_nonopt) {
#line 492
        d->optind = d->__first_nonopt;
      }
#line 493
      return (-1);
    }
#line 499
    if ((int )*(*(argv + d->optind) + 0) != 45) {
#line 499
      goto _L___2;
    } else
#line 499
    if ((int )*(*(argv + d->optind) + 1) == 0) {
      _L___2: /* CIL Label */ 
#line 501
      if ((unsigned int )d->__ordering == 0U) {
#line 502
        return (-1);
      }
#line 503
      tmp___2 = d->optind;
#line 503
      (d->optind) ++;
#line 503
      d->optarg = (char *)*(argv + tmp___2);
#line 504
      return (1);
    }
#line 510
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 510
      if ((int )*(*(argv + d->optind) + 1) == 45) {
#line 510
        tmp___3 = 1;
      } else {
#line 510
        tmp___3 = 0;
      }
    } else {
#line 510
      tmp___3 = 0;
    }
#line 510
    d->__nextchar = (char *)((*(argv + d->optind) + 1) + tmp___3);
  }
#line 529
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 529
    if ((int )*(*(argv + d->optind) + 1) == 45) {
#line 529
      goto _L___7;
    } else
#line 529
    if (long_only) {
#line 529
      if (*(*(argv + d->optind) + 2)) {
#line 529
        goto _L___7;
      } else {
        {
#line 529
        tmp___20 = strchr(optstring, (int )*(*(argv + d->optind) + 1));
        }
#line 529
        if (! tmp___20) {
          _L___7: /* CIL Label */ 
#line 537
          pfound = (struct option  const  *)((void *)0);
#line 538
          ambig_list = (struct option_list *)((void *)0);
#line 544
          exact___0 = 0;
#line 545
          indfound = -1;
#line 548
          nameend = d->__nextchar;
          {
#line 548
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 548
            if (*nameend) {
#line 548
              if (! ((int )*nameend != 61)) {
#line 548
                goto while_break___0;
              }
            } else {
#line 548
              goto while_break___0;
            }
#line 548
            nameend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 550
          namelen = (unsigned int )(nameend - d->__nextchar);
#line 554
          p = longopts;
#line 554
          option_index = 0;
          {
#line 554
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 554
            if (! p->name) {
#line 554
              goto while_break___1;
            }
            {
#line 555
            tmp___6 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                              (size_t )namelen);
            }
#line 555
            if (! tmp___6) {
              {
#line 557
              tmp___5 = strlen((char const   *)p->name);
              }
#line 557
              if (namelen == (unsigned int )tmp___5) {
#line 560
                pfound = p;
#line 561
                indfound = option_index;
#line 562
                exact___0 = 1;
#line 563
                goto while_break___1;
              } else
#line 565
              if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 568
                pfound = p;
#line 569
                indfound = option_index;
              } else
#line 571
              if (long_only) {
#line 571
                goto _L___4;
              } else
#line 571
              if (pfound->has_arg != p->has_arg) {
#line 571
                goto _L___4;
              } else
#line 571
              if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
#line 571
                goto _L___4;
              } else
#line 571
              if (pfound->val != p->val) {
                _L___4: /* CIL Label */ 
                {
#line 577
                tmp___4 = malloc(sizeof(*newp));
#line 577
                newp = (struct option_list *)tmp___4;
#line 578
                newp->p = p;
#line 579
                newp->needs_free = 1;
#line 580
                newp->next = ambig_list;
#line 581
                ambig_list = newp;
                }
              }
            }
#line 554
            p ++;
#line 554
            option_index ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 585
          if ((unsigned long )ambig_list != (unsigned long )((void *)0)) {
#line 585
            if (! exact___0) {
#line 587
              if (print_errors) {
                {
#line 590
                first___3.p = pfound;
#line 591
                first___3.next = ambig_list;
#line 592
                first___3.needs_free = 0;
#line 593
                ambig_list = & first___3;
#line 631
                tmp___7 = gettext("%s: option \'%s\' is ambiguous; possibilities:");
#line 631
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
                        *(argv + 0), *(argv + d->optind));
                }
                {
#line 634
                while (1) {
                  while_continue___2: /* CIL Label */ ;
                  {
#line 638
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" \'--%s\'",
                          (ambig_list->p)->name);
#line 639
                  tmp_next = ambig_list->next;
                  }
#line 640
                  if (ambig_list->needs_free) {
                    {
#line 641
                    free((void *)ambig_list);
                    }
                  }
#line 642
                  ambig_list = tmp_next;
#line 634
                  if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 634
                    goto while_break___2;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
                {
#line 646
                fputc('\n', stderr);
                }
              }
              {
#line 649
              tmp___8 = strlen((char const   *)d->__nextchar);
#line 649
              d->__nextchar += tmp___8;
#line 650
              (d->optind) ++;
#line 651
              d->optopt = 0;
              }
#line 652
              return ('?');
            }
          }
#line 655
          if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 657
            option_index = indfound;
#line 658
            (d->optind) ++;
#line 659
            if (*nameend) {
#line 663
              if (pfound->has_arg) {
#line 664
                d->optarg = nameend + 1;
              } else {
#line 667
                if (print_errors) {
#line 674
                  if ((int )*(*(argv + (d->optind - 1)) + 1) == 45) {
                    {
#line 682
                    tmp___9 = gettext("%s: option \'--%s\' doesn\'t allow an argument\n");
#line 682
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
                            *(argv + 0), pfound->name);
                    }
                  } else {
                    {
#line 696
                    tmp___10 = gettext("%s: option \'%c%s\' doesn\'t allow an argument\n");
#line 696
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
                            *(argv + 0), (int )*(*(argv + (d->optind - 1)) + 0), pfound->name);
                    }
                  }
                }
                {
#line 722
                tmp___11 = strlen((char const   *)d->__nextchar);
#line 722
                d->__nextchar += tmp___11;
#line 724
                d->optopt = (int )pfound->val;
                }
#line 725
                return ('?');
              }
            } else
#line 728
            if (pfound->has_arg == 1) {
#line 730
              if (d->optind < argc) {
#line 731
                tmp___12 = d->optind;
#line 731
                (d->optind) ++;
#line 731
                d->optarg = (char *)*(argv + tmp___12);
              } else {
#line 734
                if (print_errors) {
                  {
#line 757
                  tmp___13 = gettext("%s: option \'--%s\' requires an argument\n");
#line 757
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
                          *(argv + 0), pfound->name);
                  }
                }
                {
#line 762
                tmp___14 = strlen((char const   *)d->__nextchar);
#line 762
                d->__nextchar += tmp___14;
#line 763
                d->optopt = (int )pfound->val;
                }
#line 764
                if ((int const   )*(optstring + 0) == 58) {
#line 764
                  tmp___15 = ':';
                } else {
#line 764
                  tmp___15 = '?';
                }
#line 764
                return (tmp___15);
              }
            }
            {
#line 767
            tmp___16 = strlen((char const   *)d->__nextchar);
#line 767
            d->__nextchar += tmp___16;
            }
#line 768
            if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 769
              *longind = option_index;
            }
#line 770
            if (pfound->flag) {
#line 772
              *(pfound->flag) = (int )pfound->val;
#line 773
              return (0);
            }
#line 775
            return ((int )pfound->val);
          }
#line 782
          if (! long_only) {
#line 782
            goto _L___5;
          } else
#line 782
          if ((int )*(*(argv + d->optind) + 1) == 45) {
#line 782
            goto _L___5;
          } else {
            {
#line 782
            tmp___19 = strchr(optstring, (int )*(d->__nextchar));
            }
#line 782
            if ((unsigned long )tmp___19 == (unsigned long )((void *)0)) {
              _L___5: /* CIL Label */ 
#line 785
              if (print_errors) {
#line 792
                if ((int )*(*(argv + d->optind) + 1) == 45) {
                  {
#line 799
                  tmp___17 = gettext("%s: unrecognized option \'--%s\'\n");
#line 799
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
                          *(argv + 0), d->__nextchar);
                  }
                } else {
                  {
#line 810
                  tmp___18 = gettext("%s: unrecognized option \'%c%s\'\n");
#line 810
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18,
                          *(argv + 0), (int )*(*(argv + d->optind) + 0), d->__nextchar);
                  }
                }
              }
#line 832
              d->__nextchar = (char *)"";
#line 833
              (d->optind) ++;
#line 834
              d->optopt = 0;
#line 835
              return ('?');
            }
          }
        }
      }
    }
  }
  {
#line 842
  tmp___21 = d->__nextchar;
#line 842
  (d->__nextchar) ++;
#line 842
  c = *tmp___21;
#line 843
  tmp___22 = strchr(optstring, (int )c);
#line 843
  temp = tmp___22;
  }
#line 846
  if ((int )*(d->__nextchar) == 0) {
#line 847
    (d->optind) ++;
  }
#line 849
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 849
    goto _L___8;
  } else
#line 849
  if ((int )c == 58) {
#line 849
    goto _L___8;
  } else
#line 849
  if ((int )c == 59) {
    _L___8: /* CIL Label */ 
#line 851
    if (print_errors) {
      {
#line 862
      tmp___23 = gettext("%s: invalid option -- \'%c\'\n");
#line 862
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___23,
              *(argv + 0), (int )c);
      }
    }
#line 882
    d->optopt = (int )c;
#line 883
    return ('?');
  }
#line 886
  if ((int )*(temp + 0) == 87) {
#line 886
    if ((int )*(temp + 1) == 59) {
#line 890
      pfound___0 = (struct option  const  *)((void *)0);
#line 891
      exact___1 = 0;
#line 892
      ambig = 0;
#line 893
      indfound___0 = 0;
#line 896
      if ((unsigned long )longopts == (unsigned long )((void *)0)) {
#line 897
        goto no_longs;
      }
#line 900
      if ((int )*(d->__nextchar) != 0) {
#line 902
        d->optarg = d->__nextchar;
#line 905
        (d->optind) ++;
      } else
#line 907
      if (d->optind == argc) {
#line 909
        if (print_errors) {
          {
#line 931
          tmp___24 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 931
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
                  *(argv + 0), (int )c);
          }
        }
#line 936
        d->optopt = (int )c;
#line 937
        if ((int const   )*(optstring + 0) == 58) {
#line 938
          c = (char )':';
        } else {
#line 940
          c = (char )'?';
        }
#line 941
        return ((int )c);
      } else {
#line 946
        tmp___25 = d->optind;
#line 946
        (d->optind) ++;
#line 946
        d->optarg = (char *)*(argv + tmp___25);
      }
#line 951
      nameend___0 = d->optarg;
#line 951
      d->__nextchar = nameend___0;
      {
#line 951
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 951
        if (*nameend___0) {
#line 951
          if (! ((int )*nameend___0 != 61)) {
#line 951
            goto while_break___3;
          }
        } else {
#line 951
          goto while_break___3;
        }
#line 951
        nameend___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 957
      p___0 = longopts;
#line 957
      option_index___0 = 0;
      {
#line 957
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 957
        if (! p___0->name) {
#line 957
          goto while_break___4;
        }
        {
#line 958
        tmp___27 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                           (size_t )(nameend___0 - d->__nextchar));
        }
#line 958
        if (! tmp___27) {
          {
#line 960
          tmp___26 = strlen((char const   *)p___0->name);
          }
#line 960
          if ((size_t )((unsigned int )(nameend___0 - d->__nextchar)) == tmp___26) {
#line 963
            pfound___0 = p___0;
#line 964
            indfound___0 = option_index___0;
#line 965
            exact___1 = 1;
#line 966
            goto while_break___4;
          } else
#line 968
          if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
#line 971
            pfound___0 = p___0;
#line 972
            indfound___0 = option_index___0;
          } else
#line 974
          if (long_only) {
#line 979
            ambig = 1;
          } else
#line 974
          if (pfound___0->has_arg != p___0->has_arg) {
#line 979
            ambig = 1;
          } else
#line 974
          if ((unsigned long )pfound___0->flag != (unsigned long )p___0->flag) {
#line 979
            ambig = 1;
          } else
#line 974
          if (pfound___0->val != p___0->val) {
#line 979
            ambig = 1;
          }
        }
#line 957
        p___0 ++;
#line 957
        option_index___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 981
      if (ambig) {
#line 981
        if (! exact___1) {
#line 983
          if (print_errors) {
            {
#line 1004
            tmp___28 = gettext("%s: option \'-W %s\' is ambiguous\n");
#line 1004
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___28,
                    *(argv + 0), d->optarg);
            }
          }
          {
#line 1008
          tmp___29 = strlen((char const   *)d->__nextchar);
#line 1008
          d->__nextchar += tmp___29;
#line 1009
          (d->optind) ++;
          }
#line 1010
          return ('?');
        }
      }
#line 1012
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
#line 1014
        option_index___0 = indfound___0;
#line 1015
        if (*nameend___0) {
#line 1019
          if (pfound___0->has_arg) {
#line 1020
            d->optarg = nameend___0 + 1;
          } else {
#line 1023
            if (print_errors) {
              {
#line 1046
              tmp___30 = gettext("%s: option \'-W %s\' doesn\'t allow an argument\n");
#line 1046
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___30,
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 1052
            tmp___31 = strlen((char const   *)d->__nextchar);
#line 1052
            d->__nextchar += tmp___31;
            }
#line 1053
            return ('?');
          }
        } else
#line 1056
        if (pfound___0->has_arg == 1) {
#line 1058
          if (d->optind < argc) {
#line 1059
            tmp___32 = d->optind;
#line 1059
            (d->optind) ++;
#line 1059
            d->optarg = (char *)*(argv + tmp___32);
          } else {
#line 1062
            if (print_errors) {
              {
#line 1085
              tmp___33 = gettext("%s: option \'-W %s\' requires an argument\n");
#line 1085
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___33,
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 1090
            tmp___34 = strlen((char const   *)d->__nextchar);
#line 1090
            d->__nextchar += tmp___34;
            }
#line 1091
            if ((int const   )*(optstring + 0) == 58) {
#line 1091
              tmp___35 = ':';
            } else {
#line 1091
              tmp___35 = '?';
            }
#line 1091
            return (tmp___35);
          }
        } else {
#line 1095
          d->optarg = (char *)((void *)0);
        }
        {
#line 1096
        tmp___36 = strlen((char const   *)d->__nextchar);
#line 1096
        d->__nextchar += tmp___36;
        }
#line 1097
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 1098
          *longind = option_index___0;
        }
#line 1099
        if (pfound___0->flag) {
#line 1101
          *(pfound___0->flag) = (int )pfound___0->val;
#line 1102
          return (0);
        }
#line 1104
        return ((int )pfound___0->val);
      }
      no_longs: 
#line 1108
      d->__nextchar = (char *)((void *)0);
#line 1109
      return ('W');
    }
  }
#line 1111
  if ((int )*(temp + 1) == 58) {
#line 1113
    if ((int )*(temp + 2) == 58) {
#line 1116
      if ((int )*(d->__nextchar) != 0) {
#line 1118
        d->optarg = d->__nextchar;
#line 1119
        (d->optind) ++;
      } else {
#line 1122
        d->optarg = (char *)((void *)0);
      }
#line 1123
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1128
      if ((int )*(d->__nextchar) != 0) {
#line 1130
        d->optarg = d->__nextchar;
#line 1133
        (d->optind) ++;
      } else
#line 1135
      if (d->optind == argc) {
#line 1137
        if (print_errors) {
          {
#line 1159
          tmp___37 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 1159
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___37,
                  *(argv + 0), (int )c);
          }
        }
#line 1164
        d->optopt = (int )c;
#line 1165
        if ((int const   )*(optstring + 0) == 58) {
#line 1166
          c = (char )':';
        } else {
#line 1168
          c = (char )'?';
        }
      } else {
#line 1173
        tmp___38 = d->optind;
#line 1173
        (d->optind) ++;
#line 1173
        d->optarg = (char *)*(argv + tmp___38);
      }
#line 1174
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1177
  return ((int )c);
}
}
#line 1181 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only , int posixly_correct ) 
{ 
  int result ;

  {
  {
#line 1188
  getopt_data.optind = optind;
#line 1189
  getopt_data.opterr = opterr;
#line 1191
  result = _getopt_internal_r(argc, argv, optstring, longopts, longind, long_only,
                              & getopt_data, posixly_correct);
#line 1195
  optind = getopt_data.optind;
#line 1196
  optarg = getopt_data.optarg;
#line 1197
  optopt = getopt_data.optopt;
  }
#line 1199
  return (result);
}
}
#line 1202
 __attribute__((__nothrow__)) int getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 1202 "/home/wslee/gnu_benchmarks/gawk-4.1.0/getopt.c"
int getopt(int argc , char * const  *argv , char const   *optstring ) 
{ 
  int tmp___1 ;

  {
  {
#line 1205
  tmp___1 = _getopt_internal(argc, argv, optstring, (struct option  const  *)0, (int *)0,
                             0, 0);
  }
#line 1205
  return (tmp___1);
}
}
#line 260 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 795 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 1372 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int files_are_same(char *path , SRCFILE *src ) ;
#line 1501
int os_isdir(int fd ) ;
#line 27 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
char quote  =    (char )'\'';
#line 28 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
char *defpath  =    (char *)".:/usr/local/share/awk";
#line 29 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
char *deflibpath  =    (char *)"/usr/local/lib/gawk";
#line 30 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
char envsep  =    (char )':';
#line 39 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
char *gawk_name(char const   *filespec ) 
{ 
  char *p ;
  char *tmp___1 ;

  {
  {
#line 45
  p = strrchr(filespec, '/');
  }
#line 46
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 46
    tmp___1 = (char *)filespec;
  } else {
#line 46
    tmp___1 = p + 1;
  }
#line 46
  return (tmp___1);
}
}
#line 51 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
void os_arg_fixup(int *argcp , char ***argvp ) 
{ 


  {
#line 55
  return;
}
}
#line 60 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
int os_devopen(char const   *name , int flag ) 
{ 


  {
#line 64
  return (-1);
}
}
#line 95 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
static size_t env_val  =    (size_t )0;
#line 96 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
static _Bool first___2  =    (_Bool)1;
#line 97 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
static _Bool exact  =    (_Bool)0;
#line 91 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
size_t optimal_bufsize(int fd , struct stat *stb ) 
{ 
  char *val ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  __blksize_t tmp___7 ;
  __blksize_t tmp___8 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 100
  memset((void *)stb, '\000', sizeof(struct stat ));
#line 103
  tmp___3 = fstat(fd, stb);
  }
#line 103
  if (tmp___3 == -1) {
    {
#line 104
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c", 104);
#line 104
    tmp___1 = __errno_location();
#line 104
    tmp___2 = strerror(*tmp___1);
#line 104
    r_fatal("can\'t stat fd %d (%s)", fd, tmp___2);
    }
  }
#line 106
  if (first___2) {
    {
#line 107
    first___2 = (_Bool)0;
#line 109
    val = getenv("AWKBUFSIZE");
    }
#line 109
    if ((unsigned long )val != (unsigned long )((void *)0)) {
      {
#line 110
      tmp___6 = strcmp((char const   *)val, "exact");
      }
#line 110
      if (tmp___6 == 0) {
#line 111
        exact = (_Bool)1;
      } else {
        {
#line 112
        tmp___5 = __ctype_b_loc();
        }
#line 112
        if ((int const   )*(*tmp___5 + (int )((unsigned char )*val)) & 2048) {
          {
#line 113
          while (1) {
            while_continue: /* CIL Label */ ;
#line 113
            if (*val) {
              {
#line 113
              tmp___4 = __ctype_b_loc();
              }
#line 113
              if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*val)) & 2048)) {
#line 113
                goto while_break;
              }
            } else {
#line 113
              goto while_break;
            }
#line 114
            env_val = (env_val * 10UL + (size_t )*val) - 48UL;
#line 113
            val ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 116
          return (env_val);
        }
      }
    }
  } else
#line 119
  if (! exact) {
#line 119
    if (env_val > 0UL) {
#line 120
      return (env_val);
    }
  }
#line 136
  if ((stb->st_mode & 61440U) == 32768U) {
#line 136
    if (0L < stb->st_size) {
#line 136
      if (stb->st_blksize > 0L) {
#line 136
        tmp___7 = stb->st_blksize;
      } else {
#line 136
        tmp___7 = (__blksize_t )8192;
      }
#line 136
      if (stb->st_size < tmp___7) {
#line 140
        return ((size_t )stb->st_size);
      } else
#line 136
      if (exact) {
#line 140
        return ((size_t )stb->st_size);
      }
    }
  }
#line 142
  if (stb->st_blksize > 0L) {
#line 142
    tmp___8 = stb->st_blksize;
  } else {
#line 142
    tmp___8 = (__blksize_t )8192;
  }
#line 142
  return ((size_t )tmp___8);
}
}
#line 147 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
int ispath(char const   *file ) 
{ 
  char *tmp___1 ;

  {
  {
#line 150
  tmp___1 = strchr(file, '/');
  }
#line 150
  return ((unsigned long )tmp___1 != (unsigned long )((void *)0));
}
}
#line 155 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
int isdirpunct(int c ) 
{ 


  {
#line 158
  return (c == 47);
}
}
#line 163 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
void os_close_on_exec(int fd , char const   *name , char const   *what , char const   *dir ) 
{ 
  int curflags ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 166
  curflags = 0;
#line 168
  if (fd <= 2) {
#line 169
    return;
  }
  {
#line 176
  curflags = fcntl(fd, 1);
  }
#line 176
  if (curflags < 0) {
    {
#line 177
    tmp___1 = __errno_location();
#line 177
    tmp___2 = strerror(*tmp___1);
#line 177
    tmp___3 = gettext("%s %s `%s\': could not get fd flags: (fcntl F_GETFD: %s)");
#line 177
    warning((char const   *)tmp___3, what, dir, name, tmp___2);
    }
#line 179
    return;
  }
  {
#line 186
  curflags |= 1;
#line 188
  tmp___7 = fcntl(fd, 2, curflags);
  }
#line 188
  if (tmp___7 < 0) {
    {
#line 189
    tmp___4 = __errno_location();
#line 189
    tmp___5 = strerror(*tmp___4);
#line 189
    tmp___6 = gettext("%s %s `%s\': could not set close-on-exec: (fcntl F_SETFD: %s)");
#line 189
    warning((char const   *)tmp___6, what, dir, name, tmp___5);
    }
  }
#line 191
  return;
}
}
#line 199 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
int os_isdir(int fd ) 
{ 
  struct stat sbuf ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 204
  tmp___1 = fstat(fd, & sbuf);
  }
#line 204
  if (tmp___1 == 0) {
#line 204
    if ((sbuf.st_mode & 61440U) == 16384U) {
#line 204
      tmp___2 = 1;
    } else {
#line 204
      tmp___2 = 0;
    }
  } else {
#line 204
    tmp___2 = 0;
  }
#line 204
  return (tmp___2);
}
}
#line 209 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
int os_isreadable(awk_input_buf_t const   *iobuf , _Bool *isdir ) 
{ 


  {
#line 212
  *isdir = (_Bool)0;
#line 214
  if (iobuf->fd == -1) {
#line 215
    return (0);
  }
  {
#line 224
  if ((iobuf->sbuf.st_mode & 61440U) == 4096U) {
#line 224
    goto case_4096;
  }
#line 224
  if ((iobuf->sbuf.st_mode & 61440U) == 49152U) {
#line 224
    goto case_4096;
  }
#line 224
  if ((iobuf->sbuf.st_mode & 61440U) == 8192U) {
#line 224
    goto case_4096;
  }
#line 224
  if ((iobuf->sbuf.st_mode & 61440U) == 32768U) {
#line 224
    goto case_4096;
  }
#line 227
  if ((iobuf->sbuf.st_mode & 61440U) == 16384U) {
#line 227
    goto case_16384;
  }
#line 230
  goto switch_default;
  case_4096: /* CIL Label */ 
  case_49152: /* CIL Label */ 
  case_8192: /* CIL Label */ 
  case_32768: /* CIL Label */ 
#line 226
  return (1);
  case_16384: /* CIL Label */ 
#line 228
  *isdir = (_Bool)1;
  switch_default: /* CIL Label */ 
#line 231
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 237 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
int os_is_setuid(void) 
{ 
  long uid ;
  long euid ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 242
  tmp___1 = getuid();
#line 242
  uid = (long )tmp___1;
#line 243
  tmp___2 = geteuid();
#line 243
  euid = (long )tmp___2;
  }
#line 245
  if (euid == 0L) {
#line 245
    if (euid != uid) {
#line 245
      tmp___3 = 1;
    } else {
#line 245
      tmp___3 = 0;
    }
  } else {
#line 245
    tmp___3 = 0;
  }
#line 245
  return (tmp___3);
}
}
#line 250 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
int os_setbinmode(int fd , int mode ) 
{ 


  {
#line 256
  return (0);
}
}
#line 261 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
void os_restore_mode(int fd ) 
{ 


  {
#line 265
  return;
}
}
#line 270 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
int os_isatty(int fd ) 
{ 
  int tmp___1 ;

  {
  {
#line 273
  tmp___1 = isatty(fd);
  }
#line 273
  return (tmp___1);
}
}
#line 278 "/home/wslee/gnu_benchmarks/gawk-4.1.0/posix/gawkmisc.c"
int files_are_same(char *path , SRCFILE *src ) 
{ 
  struct stat st ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 283
  tmp___1 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 283
  if (tmp___1 == 0) {
#line 283
    if (st.st_dev == src->sbuf.st_dev) {
#line 283
      if (st.st_ino == src->sbuf.st_ino) {
#line 283
        tmp___2 = 1;
      } else {
#line 283
        tmp___2 = 0;
      }
    } else {
#line 283
      tmp___2 = 0;
    }
  } else {
#line 283
    tmp___2 = 0;
  }
#line 283
  return (tmp___2);
}
}
#line 49 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkmisc.c"
void *xmalloc(size_t bytes )  __attribute__((__malloc__)) ;
#line 51
void *xmalloc(size_t bytes )  __attribute__((__malloc__)) ;
#line 51 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkmisc.c"
void *xmalloc(size_t bytes ) 
{ 
  pointer p ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 55
  tmp___1 = malloc(bytes);
#line 55
  p = tmp___1;
  }
#line 55
  if (p) {
#line 55
    tmp___5 = 1;
  } else {
    {
#line 55
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkmisc.c", 55);
#line 55
    tmp___2 = __errno_location();
#line 55
    tmp___3 = strerror(*tmp___2);
#line 55
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 55
    r_fatal((char const   *)tmp___4, "xmalloc", "p", (long )bytes, tmp___3);
#line 55
    tmp___5 = 0;
    }
  }
#line 56
  return (p);
}
}
#line 879 "/usr/include/gmp-x86_64.h"
extern double __gmpz_get_d(mpz_srcptr  )  __attribute__((__pure__)) ;
#line 328 "/usr/include/mpfr.h"
extern double mpfr_get_d(mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 1436 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
void unset_ERRNO(void) ;
#line 1459
awk_bool_t make_builtin(awk_ext_func_t const   *funcinfo ) ;
#line 1460
NODE *get_argument(int i___0 ) ;
#line 1461
NODE *get_actual_argument(int i___0 , _Bool optional , _Bool want_array ) ;
#line 1488
gawk_api_t api_impl ;
#line 1490
void update_ext_api(void) ;
#line 1491
NODE *awk_value_to_node(awk_value_t const   *retval ) ;
#line 28 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t node_to_awk_value(NODE *node , awk_value_t *val , awk_valtype_t wanted ) ;
#line 38 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_get_argument(awk_ext_id_t id , size_t count , awk_valtype_t wanted ,
                                   awk_value_t *result ) 
{ 
  NODE *arg ;
  awk_bool_t tmp___1 ;
  awk_bool_t tmp___2 ;

  {
#line 45
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 46
    return ((awk_bool_t )0);
  }
  {
#line 51
  memset((void *)result, 0, sizeof(*result));
#line 52
  result->val_type = (awk_valtype_t )0;
#line 60
  arg = get_argument((int )count);
  }
#line 61
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 62
    return ((awk_bool_t )0);
  }
#line 65
  if ((unsigned int )arg->type == 6U) {
#line 66
    if ((unsigned int )wanted == 0U) {
#line 67
      return ((awk_bool_t )1);
    } else
#line 68
    if ((unsigned int )wanted == 3U) {
#line 69
      goto array;
    } else {
#line 71
      goto scalar;
    }
  }
#line 76
  if ((unsigned int )arg->type == 5U) {
#line 76
    goto _L;
  } else
#line 76
  if ((unsigned int )arg->type == 11U) {
    _L: /* CIL Label */ 
#line 77
    if ((unsigned int )wanted != 3U) {
#line 77
      if ((unsigned int )wanted != 0U) {
#line 78
        return ((awk_bool_t )0);
      }
    }
#line 79
    goto array;
  } else {
#line 81
    goto scalar;
  }
  array: 
  {
#line 85
  arg = get_actual_argument((int )count, (_Bool)0, (_Bool)1);
  }
#line 86
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 87
    return ((awk_bool_t )0);
  }
  {
#line 89
  tmp___1 = node_to_awk_value(arg, result, wanted);
  }
#line 89
  return (tmp___1);
  scalar: 
  {
#line 93
  arg = get_actual_argument((int )count, (_Bool)0, (_Bool)0);
  }
#line 94
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 95
    return ((awk_bool_t )0);
  }
  {
#line 97
  tmp___2 = node_to_awk_value(arg, result, wanted);
  }
#line 97
  return (tmp___2);
}
}
#line 105 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_set_argument(awk_ext_id_t id , size_t count , awk_array_t new_array ) 
{ 
  NODE *arg ;
  NODE *array ;

  {
#line 112
  array = (NODE *)new_array;
#line 116
  if ((unsigned long )array == (unsigned long )((void *)0)) {
#line 117
    return ((awk_bool_t )0);
  } else
#line 116
  if ((unsigned int )array->type != 5U) {
#line 117
    return ((awk_bool_t )0);
  }
  {
#line 119
  arg = get_argument((int )count);
  }
#line 119
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 121
    return ((awk_bool_t )0);
  } else
#line 119
  if ((unsigned int )arg->type != 6U) {
#line 121
    return ((awk_bool_t )0);
  }
  {
#line 123
  arg = get_actual_argument((int )count, (_Bool)0, (_Bool)1);
  }
#line 124
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 125
    return ((awk_bool_t )0);
  }
#line 127
  array->sub.nodep.name = arg->sub.nodep.name;
#line 128
  *arg = *array;
#line 129
  ((BLOCK *)array)->freep = nextfree[1].freep;
#line 129
  nextfree[1].freep = (BLOCK *)array;
#line 131
  return ((awk_bool_t )1);
}
}
#line 139 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
NODE *awk_value_to_node(awk_value_t const   *retval ) 
{ 
  NODE *ext_ret_val ;
  NODE *v ;
  char *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 145
  if ((unsigned long )retval == (unsigned long )((void *)0)) {
    {
#line 146
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 146);
#line 146
    tmp___1 = gettext("awk_value_to_node: received null retval");
#line 146
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 149
  if ((unsigned int const   )retval->val_type == 3U) {
#line 149
    goto case_3;
  }
#line 152
  if ((unsigned int const   )retval->val_type == 0U) {
#line 152
    goto case_0;
  }
#line 155
  if ((unsigned int const   )retval->val_type == 1U) {
#line 155
    goto case_1;
  }
#line 158
  if ((unsigned int const   )retval->val_type == 2U) {
#line 158
    goto case_2;
  }
#line 162
  if ((unsigned int const   )retval->val_type == 4U) {
#line 162
    goto case_4;
  }
#line 169
  if ((unsigned int const   )retval->val_type == 5U) {
#line 169
    goto case_5;
  }
#line 172
  goto switch_default;
  case_3: /* CIL Label */ 
#line 150
  ext_ret_val = (NODE *)retval->u.a;
#line 151
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 153
  ext_ret_val = dupnode(Nnull_string);
  }
#line 154
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 156
  ext_ret_val = (*make_number)((double )retval->u.d);
  }
#line 157
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 159
  ext_ret_val = make_str_node((char const   *)retval->u.s.str, (size_t )retval->u.s.len,
                              2);
  }
#line 161
  goto switch_break;
  case_4: /* CIL Label */ 
#line 163
  v = (NODE *)retval->u.scl;
#line 164
  if ((unsigned int )v->type != 4U) {
#line 165
    ext_ret_val = (NODE *)((void *)0);
  } else {
    {
#line 167
    ext_ret_val = dupnode(v->sub.nodep.l.lptr);
    }
  }
#line 168
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 170
  ext_ret_val = dupnode((NODE *)retval->u.vc);
  }
#line 171
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 173
  ext_ret_val = (NODE *)((void *)0);
#line 174
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 177
  return (ext_ret_val);
}
}
#line 184 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_fatal(awk_ext_id_t id , char const   *format  , ...) 
{ 
  va_list args ;
  char *tmp___1 ;
  char *__cil_tmp5 ;

  {
  {
#line 191
  __builtin_va_start(args, format);
#line 192
  tmp___1 = gettext("fatal: ");
#line 192
  err((_Bool)1, (char const   *)tmp___1, format, args);
#line 193
  __builtin_va_end(args);
  }
#line 194
  return;
}
}
#line 198 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_warning(awk_ext_id_t id , char const   *format  , ...) 
{ 
  va_list args ;
  char *tmp___1 ;
  char *__cil_tmp5 ;

  {
  {
#line 205
  __builtin_va_start(args, format);
#line 206
  tmp___1 = gettext("warning: ");
#line 206
  err((_Bool)0, (char const   *)tmp___1, format, args);
#line 207
  __builtin_va_end(args);
  }
#line 208
  return;
}
}
#line 212 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_lintwarn(awk_ext_id_t id , char const   *format  , ...) 
{ 
  va_list args ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 219
  __builtin_va_start(args, format);
#line 220
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 220);
  }
#line 220
  if ((unsigned long )lintfunc == (unsigned long )(& r_fatal)) {
    {
#line 221
    tmp___1 = gettext("fatal: ");
#line 221
    err((_Bool)1, (char const   *)tmp___1, format, args);
#line 222
    __builtin_va_end(args);
    }
  } else {
    {
#line 224
    tmp___2 = gettext("warning: ");
#line 224
    err((_Bool)0, (char const   *)tmp___2, format, args);
#line 225
    __builtin_va_end(args);
    }
  }
#line 227
  return;
}
}
#line 231 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_register_input_parser(awk_ext_id_t id , awk_input_parser_t *input_parser ) 
{ 


  {
#line 236
  if ((unsigned long )input_parser == (unsigned long )((void *)0)) {
#line 237
    return;
  }
  {
#line 239
  register_input_parser(input_parser);
  }
#line 240
  return;
}
}
#line 244 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_register_output_wrapper(awk_ext_id_t id , awk_output_wrapper_t *output_wrapper ) 
{ 


  {
#line 249
  if ((unsigned long )output_wrapper == (unsigned long )((void *)0)) {
#line 250
    return;
  }
  {
#line 252
  register_output_wrapper(output_wrapper);
  }
#line 253
  return;
}
}
#line 257 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_register_two_way_processor(awk_ext_id_t id , awk_two_way_processor_t *two_way_processor ) 
{ 


  {
#line 263
  if ((unsigned long )two_way_processor == (unsigned long )((void *)0)) {
#line 264
    return;
  }
  {
#line 266
  register_two_way_processor(two_way_processor);
  }
#line 267
  return;
}
}
#line 273 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_update_ERRNO_int(awk_ext_id_t id , int errno_val ) 
{ 


  {
  {
#line 278
  update_ERRNO_int(errno_val);
  }
#line 279
  return;
}
}
#line 283 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_update_ERRNO_string(awk_ext_id_t id , char const   *string ) 
{ 


  {
#line 289
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 290
    return;
  }
  {
#line 292
  update_ERRNO_string(string);
  }
#line 293
  return;
}
}
#line 297 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_unset_ERRNO(awk_ext_id_t id ) 
{ 


  {
  {
#line 302
  unset_ERRNO();
  }
#line 303
  return;
}
}
#line 308 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_add_ext_func(awk_ext_id_t id , char const   *namespace , awk_ext_func_t const   *func___1 ) 
{ 
  awk_bool_t tmp___1 ;

  {
#line 316
  if ((unsigned long )func___1 == (unsigned long )((void *)0)) {
#line 317
    return ((awk_bool_t )0);
  }
  {
#line 320
  tmp___1 = make_builtin(func___1);
  }
#line 320
  return (tmp___1);
}
}
#line 333 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static struct ext_exit_handler *list_head  =    (struct ext_exit_handler *)((void *)0);
#line 337 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
void run_ext_exit_handlers(int exitval ) 
{ 
  struct ext_exit_handler *p ;
  struct ext_exit_handler *next ;

  {
#line 342
  p = list_head;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 342
      goto while_break;
    }
    {
#line 343
    next = p->next;
#line 344
    (*(p->funcp))(p->arg0, exitval);
#line 345
    free((void *)p);
#line 342
    p = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  list_head = (struct ext_exit_handler *)((void *)0);
#line 348
  return;
}
}
#line 352 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_awk_atexit(awk_ext_id_t id , void (*funcp)(void *data , int exit_status ) ,
                           void *arg0 ) 
{ 
  struct ext_exit_handler *p ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 361
  if ((unsigned long )funcp == (unsigned long )((void *)0)) {
#line 362
    return;
  }
  {
#line 365
  tmp___1 = malloc(sizeof(struct ext_exit_handler ));
#line 365
  p = (struct ext_exit_handler *)tmp___1;
  }
#line 365
  if (p) {
#line 365
    tmp___5 = 1;
  } else {
    {
#line 365
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 365);
#line 365
    tmp___2 = __errno_location();
#line 365
    tmp___3 = strerror(*tmp___2);
#line 365
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 365
    r_fatal((char const   *)tmp___4, "api_awk_atexit", "p", (long )sizeof(struct ext_exit_handler ),
            tmp___3);
#line 365
    tmp___5 = 0;
    }
  }
#line 368
  p->funcp = funcp;
#line 369
  p->arg0 = arg0;
#line 372
  p->next = list_head;
#line 373
  list_head = p;
#line 374
  return;
}
}
#line 378 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t node_to_awk_value(NODE *node , awk_value_t *val , awk_valtype_t wanted ) 
{ 
  awk_bool_t ret ;
  char *tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 381
  ret = (awk_bool_t )0;
#line 383
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 384
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 384);
#line 384
    tmp___1 = gettext("node_to_awk_value: received null node");
#line 384
    r_fatal((char const   *)tmp___1);
    }
  }
#line 386
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 387
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 387);
#line 387
    tmp___2 = gettext("node_to_awk_value: received null val");
#line 387
    r_fatal((char const   *)tmp___2);
    }
  }
  {
#line 390
  if ((unsigned int )node->type == 6U) {
#line 390
    goto case_6;
  }
#line 397
  if ((unsigned int )node->type == 4U) {
#line 397
    goto case_4;
  }
#line 408
  if ((unsigned int )node->type == 1U) {
#line 408
    goto case_1;
  }
#line 463
  if ((unsigned int )node->type == 5U) {
#line 463
    goto case_5___0;
  }
#line 473
  goto switch_default;
  case_6: /* CIL Label */ 
#line 391
  val->val_type = (awk_valtype_t )0;
#line 392
  if ((unsigned int )wanted == 0U) {
#line 393
    ret = (awk_bool_t )1;
  }
#line 395
  goto switch_break;
  case_4: /* CIL Label */ 
#line 399
  if ((unsigned int )wanted == 4U) {
#line 400
    val->val_type = (awk_valtype_t )4;
#line 401
    val->u.scl = (void *)node;
#line 402
    ret = (awk_bool_t )1;
#line 403
    goto switch_break;
  }
#line 406
  node = node->sub.nodep.l.lptr;
  case_1: /* CIL Label */ 
  {
#line 411
  if ((unsigned int )wanted == 1U) {
#line 411
    goto case_1___0;
  }
#line 421
  if ((unsigned int )wanted == 2U) {
#line 421
    goto case_2;
  }
#line 432
  if ((unsigned int )wanted == 4U) {
#line 432
    goto case_4___0;
  }
#line 442
  if ((unsigned int )wanted == 0U) {
#line 442
    goto case_0;
  }
#line 458
  if ((unsigned int )wanted == 5U) {
#line 458
    goto case_5;
  }
#line 458
  if ((unsigned int )wanted == 3U) {
#line 458
    goto case_5;
  }
#line 410
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 412
  val->val_type = (awk_valtype_t )1;
#line 414
  force_number(node);
  }
#line 415
  if ((node->flags & 8U) != 0U) {
#line 416
    if (node->flags & 2048U) {
      {
#line 416
      tmp___3 = mpfr_get_d((mpfr_srcptr )(node->sub.val.nm.mpnum), ROUND_MODE);
#line 416
      val->u.d = tmp___3;
      }
    } else {
#line 416
      if (node->flags & 4096U) {
        {
#line 416
        tmp___4 = __gmpz_get_d((mpz_srcptr )(node->sub.val.nm.mpi));
#line 416
        tmp___5 = tmp___4;
        }
      } else {
#line 416
        tmp___5 = node->sub.val.nm.fltnum;
      }
#line 416
      val->u.d = tmp___5;
    }
#line 417
    ret = (awk_bool_t )1;
  }
#line 419
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 422
  val->val_type = (awk_valtype_t )2;
#line 424
  force_string(node);
  }
#line 425
  if ((node->flags & 4U) != 0U) {
#line 426
    val->u.s.str = node->sub.val.sp;
#line 427
    val->u.s.len = node->sub.val.slen;
#line 428
    ret = (awk_bool_t )1;
  }
#line 430
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 433
  if ((node->flags & 16U) != 0U) {
#line 434
    val->val_type = (awk_valtype_t )1;
  } else
#line 435
  if ((node->flags & 2U) != 0U) {
#line 436
    val->val_type = (awk_valtype_t )2;
  } else {
#line 438
    val->val_type = (awk_valtype_t )0;
  }
#line 439
  ret = (awk_bool_t )0;
#line 440
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 444
  if ((node->flags & 16U) != 0U) {
#line 445
    val->val_type = (awk_valtype_t )1;
#line 446
    if (node->flags & 2048U) {
      {
#line 446
      tmp___6 = mpfr_get_d((mpfr_srcptr )(node->sub.val.nm.mpnum), ROUND_MODE);
#line 446
      val->u.d = tmp___6;
      }
    } else {
#line 446
      if (node->flags & 4096U) {
        {
#line 446
        tmp___7 = __gmpz_get_d((mpz_srcptr )(node->sub.val.nm.mpi));
#line 446
        tmp___8 = tmp___7;
        }
      } else {
#line 446
        tmp___8 = node->sub.val.nm.fltnum;
      }
#line 446
      val->u.d = tmp___8;
    }
#line 447
    ret = (awk_bool_t )1;
  } else
#line 448
  if ((node->flags & 2U) != 0U) {
#line 449
    val->val_type = (awk_valtype_t )2;
#line 450
    val->u.s.str = node->sub.val.sp;
#line 451
    val->u.s.len = node->sub.val.slen;
#line 452
    ret = (awk_bool_t )1;
  } else {
#line 454
    val->val_type = (awk_valtype_t )0;
  }
#line 455
  goto switch_break___0;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 459
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 461
  goto switch_break;
  case_5___0: /* CIL Label */ 
#line 464
  val->val_type = (awk_valtype_t )3;
#line 465
  if ((unsigned int )wanted == 3U) {
#line 466
    val->u.a = (awk_array_t )node;
#line 467
    ret = (awk_bool_t )1;
  } else
#line 465
  if ((unsigned int )wanted == 0U) {
#line 466
    val->u.a = (awk_array_t )node;
#line 467
    ret = (awk_bool_t )1;
  } else {
#line 469
    ret = (awk_bool_t )0;
  }
#line 471
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 474
  val->val_type = (awk_valtype_t )0;
#line 475
  ret = (awk_bool_t )0;
#line 476
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 479
  return (ret);
}
}
#line 499 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_sym_lookup(awk_ext_id_t id , char const   *name , awk_valtype_t wanted ,
                                 awk_value_t *result ) 
{ 
  NODE *node ;
  int tmp___1 ;
  awk_bool_t tmp___2 ;

  {
  {
#line 507
  update_global_values();
  }
#line 509
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 513
    return ((awk_bool_t )0);
  } else
#line 509
  if ((int const   )*name == 0) {
#line 513
    return ((awk_bool_t )0);
  } else
#line 509
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 513
    return ((awk_bool_t )0);
  } else {
    {
#line 509
    node = lookup(name);
    }
#line 509
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 513
      return ((awk_bool_t )0);
    }
  }
  {
#line 515
  tmp___1 = is_off_limits_var(name);
  }
#line 515
  if (tmp___1) {
#line 516
    node->flags |= 8192U;
  }
  {
#line 518
  tmp___2 = node_to_awk_value(node, result, wanted);
  }
#line 518
  return (tmp___2);
}
}
#line 523 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_sym_lookup_scalar(awk_ext_id_t id , awk_scalar_t cookie , awk_valtype_t wanted ,
                                        awk_value_t *result ) 
{ 
  NODE *node ;
  awk_bool_t tmp___1 ;

  {
#line 529
  node = (NODE *)cookie;
#line 531
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 534
    return ((awk_bool_t )0);
  } else
#line 531
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 534
    return ((awk_bool_t )0);
  } else
#line 531
  if ((unsigned int )node->type != 4U) {
#line 534
    return ((awk_bool_t )0);
  }
  {
#line 536
  update_global_values();
#line 538
  tmp___1 = node_to_awk_value(node, result, wanted);
  }
#line 538
  return (tmp___1);
}
}
#line 543 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_sym_update(awk_ext_id_t id , char const   *name , awk_value_t *value ) 
{ 
  NODE *node ;
  NODE *array_node ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 551
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 554
    return ((awk_bool_t )0);
  } else
#line 551
  if ((int const   )*name == 0) {
#line 554
    return ((awk_bool_t )0);
  } else
#line 551
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 554
    return ((awk_bool_t )0);
  }
  {
#line 562
  if ((unsigned int )value->val_type == 5U) {
#line 562
    goto case_5;
  }
#line 562
  if ((unsigned int )value->val_type == 4U) {
#line 562
    goto case_5;
  }
#line 562
  if ((unsigned int )value->val_type == 3U) {
#line 562
    goto case_5;
  }
#line 562
  if ((unsigned int )value->val_type == 0U) {
#line 562
    goto case_5;
  }
#line 562
  if ((unsigned int )value->val_type == 2U) {
#line 562
    goto case_5;
  }
#line 562
  if ((unsigned int )value->val_type == 1U) {
#line 562
    goto case_5;
  }
#line 565
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 563
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 567
  return ((awk_bool_t )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 570
  node = lookup(name);
  }
#line 572
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 574
    if ((unsigned int )value->val_type == 3U) {
      {
#line 575
      array_node = awk_value_to_node((awk_value_t const   *)value);
#line 576
      tmp___1 = strlen(name);
#line 576
      tmp___2 = estrdup((char const   *)((char *)name), tmp___1);
#line 576
      node = install_symbol(tmp___2, (NODETYPE )5);
#line 578
      array_node->sub.nodep.name = node->sub.nodep.name;
#line 579
      *node = *array_node;
#line 580
      ((BLOCK *)array_node)->freep = nextfree[1].freep;
#line 580
      nextfree[1].freep = (BLOCK *)array_node;
#line 581
      value->u.a = (awk_array_t )node;
      }
    } else {
      {
#line 584
      tmp___3 = strlen(name);
#line 584
      tmp___4 = estrdup((char const   *)((char *)name), tmp___3);
#line 584
      node = install_symbol(tmp___4, (NODETYPE )4);
#line 586
      node->sub.nodep.l.lptr = awk_value_to_node((awk_value_t const   *)value);
      }
    }
#line 589
    return ((awk_bool_t )1);
  }
#line 596
  if ((node->flags & 8192U) != 0U) {
#line 598
    node->flags |= 8192U;
#line 599
    return ((awk_bool_t )0);
  } else {
    {
#line 596
    tmp___5 = is_off_limits_var(name);
    }
#line 596
    if (tmp___5) {
#line 598
      node->flags |= 8192U;
#line 599
      return ((awk_bool_t )0);
    }
  }
#line 602
  if ((unsigned int )value->val_type != 3U) {
#line 602
    if ((unsigned int )node->type == 4U) {
#line 602
      goto _L;
    } else
#line 602
    if ((unsigned int )node->type == 6U) {
      _L: /* CIL Label */ 
      {
#line 604
      unref(node->sub.nodep.l.lptr);
#line 605
      node->sub.nodep.l.lptr = awk_value_to_node((awk_value_t const   *)value);
      }
#line 606
      if ((unsigned int )node->type == 6U) {
#line 606
        if ((unsigned int )value->val_type != 0U) {
#line 607
          node->type = (NODETYPE )4;
        }
      }
#line 609
      return ((awk_bool_t )1);
    }
  }
#line 612
  return ((awk_bool_t )0);
}
}
#line 617 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_sym_update_scalar(awk_ext_id_t id , awk_scalar_t cookie , awk_value_t *value ) 
{ 
  NODE *node ;
  NODE *r ;
  NODE *r___0 ;

  {
#line 622
  node = (NODE *)cookie;
#line 624
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 628
    return ((awk_bool_t )0);
  } else
#line 624
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 628
    return ((awk_bool_t )0);
  } else
#line 624
  if ((unsigned int )node->type != 4U) {
#line 628
    return ((awk_bool_t )0);
  } else
#line 624
  if ((node->flags & 8192U) != 0U) {
#line 628
    return ((awk_bool_t )0);
  }
  {
#line 639
  if ((unsigned int )value->val_type == 1U) {
#line 639
    goto case_1;
  }
#line 656
  if ((unsigned int )value->val_type == 2U) {
#line 656
    goto case_2;
  }
#line 678
  if ((unsigned int )value->val_type == 5U) {
#line 678
    goto case_5;
  }
#line 678
  if ((unsigned int )value->val_type == 4U) {
#line 678
    goto case_5;
  }
#line 678
  if ((unsigned int )value->val_type == 0U) {
#line 678
    goto case_5;
  }
#line 681
  goto switch_default;
  case_1: /* CIL Label */ 
#line 640
  if ((node->sub.nodep.l.lptr)->sub.val.sref == 1L) {
#line 640
    if (! (do_flags & 16384)) {
#line 641
      r = node->sub.nodep.l.lptr;
#line 644
      if ((r->flags & 5U) == 5U) {
        {
#line 645
        free((void *)r->sub.val.sp);
        }
      }
      {
#line 646
      while (1) {
        while_continue: /* CIL Label */ ;
#line 646
        if (r->flags & 1024U) {
          {
#line 646
          r_free_wstr(r);
          }
        }
#line 646
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 649
      r->sub.val.nm.fltnum = value->u.d;
#line 650
      r->flags = 25U;
#line 651
      r->sub.val.sp = (char *)((void *)0);
#line 652
      r->sub.val.slen = (size_t )0;
#line 653
      return ((awk_bool_t )1);
    }
  }
#line 655
  goto switch_break;
  case_2: /* CIL Label */ 
#line 657
  if ((node->sub.nodep.l.lptr)->sub.val.sref == 1L) {
#line 658
    r___0 = node->sub.nodep.l.lptr;
#line 661
    if ((r___0->flags & 5U) == 5U) {
      {
#line 662
      free((void *)r___0->sub.val.sp);
      }
    }
    {
#line 664
    mpfr_unset(r___0);
    }
    {
#line 665
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 665
      if (r___0->flags & 1024U) {
        {
#line 665
        r_free_wstr(r___0);
        }
      }
#line 665
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 668
    r___0->sub.val.nm.fltnum = (double )0;
#line 669
    r___0->flags = 7U;
#line 670
    r___0->sub.val.idx = -1;
#line 671
    r___0->sub.val.sp = value->u.s.str;
#line 672
    r___0->sub.val.slen = value->u.s.len;
#line 673
    return ((awk_bool_t )1);
  }
#line 675
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 679
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 682
  return ((awk_bool_t )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 686
  unref(node->sub.nodep.l.lptr);
#line 687
  node->sub.nodep.l.lptr = awk_value_to_node((awk_value_t const   *)value);
  }
#line 688
  return ((awk_bool_t )1);
}
}
#line 697 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
__inline static int valid_subscript_type(awk_valtype_t valtype ) 
{ 


  {
  {
#line 705
  if ((unsigned int )valtype == 5U) {
#line 705
    goto case_5;
  }
#line 705
  if ((unsigned int )valtype == 4U) {
#line 705
    goto case_5;
  }
#line 705
  if ((unsigned int )valtype == 2U) {
#line 705
    goto case_5;
  }
#line 705
  if ((unsigned int )valtype == 1U) {
#line 705
    goto case_5;
  }
#line 705
  if ((unsigned int )valtype == 0U) {
#line 705
    goto case_5;
  }
#line 707
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 706
  return (1);
  switch_default: /* CIL Label */ 
#line 708
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 719 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_get_array_element(awk_ext_id_t id , awk_array_t a_cookie , awk_value_t const   * const  index___0 ,
                                        awk_valtype_t wanted , awk_value_t *result ) 
{ 
  NODE *array ;
  NODE *subscript ;
  NODE **aptr ;
  int tmp___1 ;
  NODE *tmp___2 ;
  awk_bool_t tmp___3 ;

  {
#line 726
  array = (NODE *)a_cookie;
#line 731
  if ((unsigned long )array == (unsigned long )((void *)0)) {
#line 736
    return ((awk_bool_t )0);
  } else
#line 731
  if ((unsigned int )array->type != 5U) {
#line 736
    return ((awk_bool_t )0);
  } else
#line 731
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 736
    return ((awk_bool_t )0);
  } else
#line 731
  if ((unsigned long )index___0 == (unsigned long )((void *)0)) {
#line 736
    return ((awk_bool_t )0);
  } else {
    {
#line 731
    tmp___1 = valid_subscript_type((awk_valtype_t )index___0->val_type);
    }
#line 731
    if (! tmp___1) {
#line 736
      return ((awk_bool_t )0);
    }
  }
  {
#line 738
  subscript = awk_value_to_node((awk_value_t const   *)index___0);
#line 741
  tmp___2 = in_array(array, subscript);
  }
#line 741
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 742
    unref(subscript);
    }
#line 743
    return ((awk_bool_t )0);
  }
  {
#line 746
  aptr = (*(*(array->sub.nodep.l.lp + 3)))(array, subscript);
  }
#line 748
  if ((unsigned long )aptr == (unsigned long )((void *)0)) {
    {
#line 749
    unref(subscript);
    }
#line 750
    return ((awk_bool_t )0);
  }
  {
#line 753
  unref(subscript);
#line 755
  tmp___3 = node_to_awk_value(*aptr, result, wanted);
  }
#line 755
  return (tmp___3);
}
}
#line 763 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_set_array_element(awk_ext_id_t id , awk_array_t a_cookie , awk_value_t const   * const  index___0 ,
                                        awk_value_t const   * const  value ) 
{ 
  NODE *array ;
  NODE *tmp___1 ;
  NODE *elem ;
  NODE **aptr ;
  int tmp___2 ;
  NODE *tmp___3 ;

  {
#line 768
  array = (NODE *)a_cookie;
#line 774
  if ((unsigned long )array == (unsigned long )((void *)0)) {
#line 780
    return ((awk_bool_t )0);
  } else
#line 774
  if ((unsigned int )array->type != 5U) {
#line 780
    return ((awk_bool_t )0);
  } else
#line 774
  if ((array->flags & 8192U) != 0U) {
#line 780
    return ((awk_bool_t )0);
  } else
#line 774
  if ((unsigned long )index___0 == (unsigned long )((void *)0)) {
#line 780
    return ((awk_bool_t )0);
  } else
#line 774
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 780
    return ((awk_bool_t )0);
  } else {
    {
#line 774
    tmp___2 = valid_subscript_type((awk_valtype_t )index___0->val_type);
    }
#line 774
    if (! tmp___2) {
#line 780
      return ((awk_bool_t )0);
    }
  }
  {
#line 782
  tmp___1 = awk_value_to_node((awk_value_t const   *)index___0);
#line 783
  aptr = (*(*(array->sub.nodep.l.lp + 3)))(array, tmp___1);
#line 784
  unref(tmp___1);
#line 785
  unref(*aptr);
#line 786
  tmp___3 = awk_value_to_node((awk_value_t const   *)value);
#line 786
  *aptr = tmp___3;
#line 786
  elem = tmp___3;
  }
#line 787
  if ((unsigned int )elem->type == 5U) {
    {
#line 788
    elem->sub.nodep.x.extra = array;
#line 789
    elem->sub.nodep.name = estrdup((char const   *)index___0->u.s.str, (size_t )index___0->u.s.len);
#line 791
    make_aname((NODE const   *)elem);
    }
  }
#line 794
  return ((awk_bool_t )1);
}
}
#line 802 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void remove_element(NODE *array , NODE *subscript ) 
{ 
  NODE *val ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct exp_node **tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 807
  if ((unsigned long )array == (unsigned long )((void *)0)) {
    {
#line 808
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 808);
#line 808
    tmp___1 = gettext("remove_element: received null array");
#line 808
    r_fatal((char const   *)tmp___1);
    }
  }
#line 810
  if ((unsigned long )subscript == (unsigned long )((void *)0)) {
    {
#line 811
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 811);
#line 811
    tmp___2 = gettext("remove_element: received null subscript");
#line 811
    r_fatal((char const   *)tmp___2);
    }
  }
  {
#line 813
  val = in_array(array, subscript);
  }
#line 815
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 816
    return;
  }
#line 818
  if ((unsigned int )val->type == 5U) {
    {
#line 819
    (*(*(val->sub.nodep.l.lp + 5)))(val, (struct exp_node *)((void *)0));
#line 821
    free((void *)val->sub.nodep.name);
#line 822
    ((BLOCK *)val)->freep = nextfree[1].freep;
#line 822
    nextfree[1].freep = (BLOCK *)val;
    }
  } else {
    {
#line 824
    unref(val);
    }
  }
  {
#line 826
  tmp___3 = (*(*(array->sub.nodep.l.lp + 6)))(array, subscript);
  }
#line 827
  return;
}
}
#line 834 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_del_array_element(awk_ext_id_t id , awk_array_t a_cookie , awk_value_t const   * const  index___0 ) 
{ 
  NODE *array ;
  NODE *sub ;
  int tmp___1 ;

  {
#line 840
  array = (NODE *)a_cookie;
#line 841
  if ((unsigned long )array == (unsigned long )((void *)0)) {
#line 846
    return ((awk_bool_t )0);
  } else
#line 841
  if ((unsigned int )array->type != 5U) {
#line 846
    return ((awk_bool_t )0);
  } else
#line 841
  if ((array->flags & 8192U) != 0U) {
#line 846
    return ((awk_bool_t )0);
  } else
#line 841
  if ((unsigned long )index___0 == (unsigned long )((void *)0)) {
#line 846
    return ((awk_bool_t )0);
  } else {
    {
#line 841
    tmp___1 = valid_subscript_type((awk_valtype_t )index___0->val_type);
    }
#line 841
    if (! tmp___1) {
#line 846
      return ((awk_bool_t )0);
    }
  }
  {
#line 848
  sub = awk_value_to_node((awk_value_t const   *)index___0);
#line 849
  remove_element(array, sub);
#line 850
  unref(sub);
  }
#line 852
  return ((awk_bool_t )1);
}
}
#line 860 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_get_element_count(awk_ext_id_t id , awk_array_t a_cookie , size_t *count ) 
{ 
  NODE *node ;

  {
#line 864
  node = (NODE *)a_cookie;
#line 866
  if ((unsigned long )count == (unsigned long )((void *)0)) {
#line 867
    return ((awk_bool_t )0);
  } else
#line 866
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 867
    return ((awk_bool_t )0);
  } else
#line 866
  if ((unsigned int )node->type != 5U) {
#line 867
    return ((awk_bool_t )0);
  }
#line 869
  *count = node->sub.nodep.reflags;
#line 870
  return ((awk_bool_t )1);
}
}
#line 875 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_array_t api_create_array(awk_ext_id_t id ) 
{ 
  NODE *n ;
  void *tmp___1 ;

  {
#line 880
  n = (NODE *)nextfree[1].freep;
#line 880
  if (n) {
#line 880
    nextfree[1].freep = ((BLOCK *)n)->freep;
  } else {
    {
#line 880
    tmp___1 = more_blocks(1);
#line 880
    n = (NODE *)tmp___1;
    }
  }
  {
#line 881
  memset((void *)n, 0, sizeof(NODE ));
#line 882
  null_array(n);
  }
#line 884
  return ((awk_array_t )n);
}
}
#line 889 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_clear_array(awk_ext_id_t id , awk_array_t a_cookie ) 
{ 
  NODE *node ;

  {
#line 892
  node = (NODE *)a_cookie;
#line 894
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 897
    return ((awk_bool_t )0);
  } else
#line 894
  if ((unsigned int )node->type != 5U) {
#line 897
    return ((awk_bool_t )0);
  } else
#line 894
  if ((node->flags & 8192U) != 0U) {
#line 897
    return ((awk_bool_t )0);
  }
  {
#line 899
  (*(*(node->sub.nodep.l.lp + 5)))(node, (struct exp_node *)((void *)0));
  }
#line 900
  return ((awk_bool_t )1);
}
}
#line 905 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_flatten_array(awk_ext_id_t id , awk_array_t a_cookie , awk_flat_array_t **data ) 
{ 
  NODE **list ;
  size_t i___0 ;
  size_t j ;
  NODE *array ;
  size_t alloc_size ;
  awk_flat_array_t *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  NODE *index___0 ;
  NODE *value ;
  char *tmp___7 ;
  awk_bool_t tmp___8 ;
  char *tmp___9 ;
  awk_bool_t tmp___10 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 912
  array = (NODE *)a_cookie;
#line 915
  if ((unsigned long )array == (unsigned long )((void *)0)) {
#line 919
    return ((awk_bool_t )0);
  } else
#line 915
  if ((unsigned int )array->type != 5U) {
#line 919
    return ((awk_bool_t )0);
  } else
#line 915
  if (array->sub.nodep.reflags == 0UL) {
#line 919
    return ((awk_bool_t )0);
  } else
#line 915
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 919
    return ((awk_bool_t )0);
  }
  {
#line 921
  alloc_size = sizeof(awk_flat_array_t ) + (array->sub.nodep.reflags - 1UL) * sizeof(awk_element_t );
#line 924
  tmp___2 = malloc(alloc_size);
#line 924
  tmp___1 = (awk_flat_array_t *)tmp___2;
#line 924
  *data = tmp___1;
  }
#line 924
  if (tmp___1) {
#line 924
    tmp___6 = 1;
  } else {
    {
#line 924
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 925);
#line 924
    tmp___3 = __errno_location();
#line 924
    tmp___4 = strerror(*tmp___3);
#line 924
    tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 924
    r_fatal((char const   *)tmp___5, "api_flatten_array", "*data", (long )alloc_size,
            tmp___4);
#line 924
    tmp___6 = 0;
    }
  }
  {
#line 926
  memset((void *)*data, 0, alloc_size);
#line 928
  list = assoc_list(array, "@unsorted", (sort_context_t )3);
#line 930
  (*data)->opaque1 = (void *)array;
#line 931
  (*data)->opaque2 = (void *)list;
#line 932
  (*data)->count = array->sub.nodep.reflags;
#line 934
  j = (size_t )0;
#line 934
  i___0 = j;
  }
  {
#line 934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 934
    if (! (i___0 < 2UL * array->sub.nodep.reflags)) {
#line 934
      goto while_break;
    }
    {
#line 937
    index___0 = force_string(*(list + i___0));
#line 938
    value = *(list + (i___0 + 1UL));
#line 941
    tmp___8 = node_to_awk_value(index___0, & (*data)->elements[j].index, (awk_valtype_t )0);
    }
#line 941
    if (! tmp___8) {
      {
#line 943
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 943);
#line 943
      tmp___7 = gettext("api_flatten_array: could not convert index %d\n");
#line 943
      r_fatal((char const   *)tmp___7, (int )i___0);
      }
    }
    {
#line 946
    tmp___10 = node_to_awk_value(value, & (*data)->elements[j].value, (awk_valtype_t )0);
    }
#line 946
    if (! tmp___10) {
      {
#line 948
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 948);
#line 948
      tmp___9 = gettext("api_flatten_array: could not convert value %d\n");
#line 948
      r_fatal((char const   *)tmp___9, (int )i___0);
      }
    }
#line 934
    i___0 += 2UL;
#line 934
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 952
  return ((awk_bool_t )1);
}
}
#line 961 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_release_flattened_array(awk_ext_id_t id , awk_array_t a_cookie ,
                                              awk_flat_array_t *data ) 
{ 
  NODE *array ;
  NODE **list ;
  size_t i___0 ;
  size_t j ;
  size_t k ;

  {
#line 966
  array = (NODE *)a_cookie;
#line 970
  if ((unsigned long )array == (unsigned long )((void *)0)) {
#line 976
    return ((awk_bool_t )0);
  } else
#line 970
  if ((unsigned int )array->type != 5U) {
#line 976
    return ((awk_bool_t )0);
  } else
#line 970
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 976
    return ((awk_bool_t )0);
  } else
#line 970
  if ((unsigned long )array != (unsigned long )((NODE *)data->opaque1)) {
#line 976
    return ((awk_bool_t )0);
  } else
#line 970
  if (data->count != array->sub.nodep.reflags) {
#line 976
    return ((awk_bool_t )0);
  } else
#line 970
  if ((unsigned long )data->opaque2 == (unsigned long )((void *)0)) {
#line 976
    return ((awk_bool_t )0);
  }
#line 978
  list = (NODE **)data->opaque2;
#line 981
  j = (size_t )0;
#line 981
  i___0 = j;
#line 981
  k = 2UL * array->sub.nodep.reflags;
  {
#line 981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 981
    if (! (i___0 < k)) {
#line 981
      goto while_break;
    }
#line 983
    if (((unsigned int )data->elements[j].flags & 1U) != 0U) {
#line 983
      if ((array->flags & 8192U) == 0U) {
        {
#line 985
        remove_element(array, *(list + i___0));
        }
      }
    }
    {
#line 987
    unref(*(list + i___0));
#line 981
    i___0 += 2UL;
#line 981
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 990
  free((void *)list);
#line 991
  free((void *)data);
  }
#line 993
  return ((awk_bool_t )1);
}
}
#line 998 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_create_value(awk_ext_id_t id , awk_value_t *value , awk_value_cookie_t *result ) 
{ 
  awk_value_cookie_t tmp___1 ;
  NODE *tmp___2 ;

  {
#line 1002
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1003
    return ((awk_bool_t )0);
  } else
#line 1002
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 1003
    return ((awk_bool_t )0);
  }
  {
#line 1007
  if ((unsigned int )value->val_type == 2U) {
#line 1007
    goto case_2;
  }
#line 1007
  if ((unsigned int )value->val_type == 1U) {
#line 1007
    goto case_2;
  }
#line 1009
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1008
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1011
  return ((awk_bool_t )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1014
  tmp___2 = awk_value_to_node((awk_value_t const   *)value);
#line 1014
  tmp___1 = (awk_value_cookie_t )tmp___2;
#line 1014
  *result = tmp___1;
  }
#line 1014
  return ((awk_bool_t )((unsigned long )tmp___1 != (unsigned long )((void *)0)));
}
}
#line 1019 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static awk_bool_t api_release_value(awk_ext_id_t id , awk_value_cookie_t value ) 
{ 
  NODE *val ;

  {
#line 1022
  val = (NODE *)value;
#line 1024
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1025
    return ((awk_bool_t )0);
  }
  {
#line 1027
  unref(val);
  }
#line 1028
  return ((awk_bool_t )1);
}
}
#line 1040 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static struct version_info *vi_head  ;
#line 1044 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
static void api_register_ext_version(awk_ext_id_t id , char const   *version___0 ) 
{ 
  struct version_info *info ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1049
  if ((unsigned long )version___0 == (unsigned long )((void *)0)) {
#line 1050
    return;
  }
  {
#line 1054
  tmp___1 = malloc(sizeof(struct version_info ));
#line 1054
  info = (struct version_info *)tmp___1;
  }
#line 1054
  if (info) {
#line 1054
    tmp___5 = 1;
  } else {
    {
#line 1054
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c", 1054);
#line 1054
    tmp___2 = __errno_location();
#line 1054
    tmp___3 = strerror(*tmp___2);
#line 1054
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1054
    r_fatal((char const   *)tmp___4, "register_ext_version", "info", (long )sizeof(struct version_info ),
            tmp___3);
#line 1054
    tmp___5 = 0;
    }
  }
#line 1055
  info->version = version___0;
#line 1056
  info->next = vi_head;
#line 1057
  vi_head = info;
#line 1058
  return;
}
}
#line 1061 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
gawk_api_t api_impl  = 
#line 1061
     {1, 0, {0}, & api_add_ext_func, & api_register_input_parser, & api_register_output_wrapper,
    & api_register_two_way_processor, & api_awk_atexit, & api_register_ext_version,
    & api_fatal, & api_warning, & api_lintwarn, & api_update_ERRNO_int, & api_update_ERRNO_string,
    & api_unset_ERRNO, & api_get_argument, & api_set_argument, & api_sym_lookup, & api_sym_update,
    & api_sym_lookup_scalar, & api_sym_update_scalar, & api_create_value, & api_release_value,
    & api_get_element_count, & api_get_array_element, & api_set_array_element, & api_del_array_element,
    & api_create_array, & api_clear_array, & api_flatten_array, & api_release_flattened_array};
#line 1114 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
void init_ext_api(void) 
{ 


  {
#line 1118
  if (do_flags & 3) {
#line 1118
    api_impl.do_flags[0] = 1;
  } else {
#line 1118
    api_impl.do_flags[0] = 0;
  }
#line 1119
  if (do_flags & 8) {
#line 1119
    api_impl.do_flags[1] = 1;
  } else {
#line 1119
    api_impl.do_flags[1] = 0;
  }
#line 1120
  if (do_flags & 4096) {
#line 1120
    api_impl.do_flags[2] = 1;
  } else {
#line 1120
    api_impl.do_flags[2] = 0;
  }
#line 1121
  if (do_flags & 2048) {
#line 1121
    api_impl.do_flags[3] = 1;
  } else {
#line 1121
    api_impl.do_flags[3] = 0;
  }
#line 1122
  if (do_flags & 8192) {
#line 1122
    api_impl.do_flags[4] = 1;
  } else {
#line 1122
    api_impl.do_flags[4] = 0;
  }
#line 1123
  if (do_flags & 16384) {
#line 1123
    api_impl.do_flags[5] = 1;
  } else {
#line 1123
    api_impl.do_flags[5] = 0;
  }
#line 1124
  return;
}
}
#line 1128 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
void update_ext_api(void) 
{ 


  {
#line 1131
  if (do_flags & 3) {
#line 1131
    api_impl.do_flags[0] = 1;
  } else {
#line 1131
    api_impl.do_flags[0] = 0;
  }
#line 1132
  return;
}
}
#line 1136 "/home/wslee/gnu_benchmarks/gawk-4.1.0/gawkapi.c"
extern void print_ext_versions(void) 
{ 
  struct version_info *p ;
  char *__cil_tmp2 ;

  {
#line 1141
  p = vi_head;
  {
#line 1141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1141
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1141
      goto while_break;
    }
    {
#line 1142
    printf((char const   */* __restrict  */)"%s\n", p->version);
#line 1141
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1143
  return;
}
}
#line 1661 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
double Floor(double n ) ;
#line 1662
double Ceil(double n ) ;
#line 1664
uintmax_t adjust_uint(uintmax_t n ) ;
#line 179 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
#line 79 "/home/wslee/gnu_benchmarks/gawk-4.1.0/floatcomp.c"
double Floor(double n ) 
{ 
  double tmp___1 ;

  {
  {
#line 82
  tmp___1 = floor(n);
  }
#line 82
  return (tmp___1);
}
}
#line 87 "/home/wslee/gnu_benchmarks/gawk-4.1.0/floatcomp.c"
double Ceil(double n ) 
{ 
  double tmp___1 ;

  {
  {
#line 90
  tmp___1 = ceil(n);
  }
#line 90
  return (tmp___1);
}
}
#line 96 "/home/wslee/gnu_benchmarks/gawk-4.1.0/floatcomp.c"
uintmax_t adjust_uint(uintmax_t n ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 107
  if (sizeof(double ) == sizeof(long double )) {
#line 107
    tmp___4 = 64;
  } else {
#line 107
    if (sizeof(double ) == sizeof(double )) {
#line 107
      tmp___3 = 53;
    } else {
#line 107
      tmp___3 = 24;
    }
#line 107
    tmp___4 = tmp___3;
  }
#line 107
  if ((unsigned long )tmp___4 < 8UL * sizeof(n)) {
#line 108
    if (sizeof(double ) == sizeof(long double )) {
#line 108
      tmp___2 = 64;
    } else {
#line 108
      if (sizeof(double ) == sizeof(double )) {
#line 108
        tmp___1 = 53;
      } else {
#line 108
        tmp___1 = 24;
      }
#line 108
      tmp___2 = tmp___1;
    }
#line 108
    n &= (1UL << tmp___2) - 1UL;
  }
#line 110
  return (n);
}
}
#line 1049 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE **fields_arr  ;
#line 1064 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
_Bool field0_valid  ;
#line 1340
NODE *force_array(NODE *symbol , _Bool canfatal ) ;
#line 1468
void reset_record(void) ;
#line 1470
NODE **get_field(long requested , Func_ptr *assign ) ;
#line 1471
NODE *do_split(int nargs ) ;
#line 1472
NODE *do_patsplit(int nargs ) ;
#line 1724 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static NODE *POP_PARAM(void) 
{ 
  NODE *t ;
  STACK_ITEM *tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;

  {
#line 1727
  tmp___1 = stack_ptr;
#line 1727
  stack_ptr --;
#line 1727
  t = tmp___1->rptr;
#line 1729
  if ((unsigned int )t->type == 5U) {
#line 1729
    tmp___3 = t;
  } else {
    {
#line 1729
    tmp___2 = force_array(t, (_Bool)0);
#line 1729
    tmp___3 = tmp___2;
    }
  }
#line 1729
  return (tmp___3);
}
}
#line 33 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static int is_blank___0(int c ) 
{ 
  int tmp___1 ;

  {
#line 36
  if (c == 32) {
#line 36
    tmp___1 = 1;
  } else
#line 36
  if (c == 9) {
#line 36
    tmp___1 = 1;
  } else {
#line 36
    tmp___1 = 0;
  }
#line 36
  return (tmp___1);
}
}
#line 41 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long (*parse_field)(long  , char ** , int  , NODE * , Regexp * , void (*)(long  ,
                                                                                 char * ,
                                                                                 long  ,
                                                                                 NODE * ) ,
                           NODE * , NODE * , _Bool  )  ;
#line 43
static void rebuild_record(void) ;
#line 44
static long re_parse_field(long up_to , char **buf___7 , int len , NODE *fs  __attribute__((__unused__)) ,
                           Regexp *rp , void (*set)(long  , char * , long  , NODE * ) ,
                           NODE *n , NODE *sep_arr , _Bool in_middle ) ;
#line 46
static long def_parse_field(long up_to , char **buf___7 , int len , NODE *fs , Regexp *rp  __attribute__((__unused__)) ,
                            void (*set)(long  , char * , long  , NODE * ) , NODE *n ,
                            NODE *sep_arr , _Bool in_middle  __attribute__((__unused__)) ) ;
#line 48
static long posix_def_parse_field(long up_to , char **buf___7 , int len , NODE *fs ,
                                  Regexp *rp  __attribute__((__unused__)) , void (*set)(long  ,
                                                                                        char * ,
                                                                                        long  ,
                                                                                        NODE * ) ,
                                  NODE *n , NODE *dummy  __attribute__((__unused__)) ,
                                  _Bool in_middle  __attribute__((__unused__)) ) ;
#line 50
static long null_parse_field(long up_to , char **buf___7 , int len , NODE *fs  __attribute__((__unused__)) ,
                             Regexp *rp  __attribute__((__unused__)) , void (*set)(long  ,
                                                                                   char * ,
                                                                                   long  ,
                                                                                   NODE * ) ,
                             NODE *n , NODE *sep_arr , _Bool in_middle  __attribute__((__unused__)) ) ;
#line 52
static long sc_parse_field(long up_to , char **buf___7 , int len , NODE *fs , Regexp *rp  __attribute__((__unused__)) ,
                           void (*set)(long  , char * , long  , NODE * ) , NODE *n ,
                           NODE *sep_arr , _Bool in_middle  __attribute__((__unused__)) ) ;
#line 54
static long fw_parse_field(long up_to , char **buf___7 , int len , NODE *fs  __attribute__((__unused__)) ,
                           Regexp *rp  __attribute__((__unused__)) , void (*set)(long  ,
                                                                                 char * ,
                                                                                 long  ,
                                                                                 NODE * ) ,
                           NODE *n , NODE *dummy  __attribute__((__unused__)) , _Bool in_middle  __attribute__((__unused__)) ) ;
#line 56
static long fpat_parse_field(long up_to , char **buf___7 , int len , NODE *fs  __attribute__((__unused__)) ,
                             Regexp *rp , void (*set)(long  , char * , long  , NODE * ) ,
                             NODE *n , NODE *sep_arr , _Bool in_middle ) ;
#line 58
static void set_element(long num , char *s___0 , long len , NODE *n ) ;
#line 59
static void grow_fields_arr(long num ) ;
#line 60
static void set_field(long num , char *str , long len , NODE *dummy  __attribute__((__unused__)) ) ;
#line 62 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static char *parse_extent  ;
#line 63 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long parse_high_water  =    0L;
#line 64 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long nf_high_water  =    0L;
#line 65 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static _Bool resave_fs  ;
#line 66 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static NODE *save_FS  ;
#line 69 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static int *FIELDWIDTHS  =    (int *)((void *)0);
#line 73 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
int default_FS  ;
#line 74 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
Regexp *FS_re_yes_case  =    (Regexp *)((void *)0);
#line 75 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
Regexp *FS_re_no_case  =    (Regexp *)((void *)0);
#line 76 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
Regexp *FS_regexp  =    (Regexp *)((void *)0);
#line 77 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
Regexp *FPAT_re_yes_case  =    (Regexp *)((void *)0);
#line 78 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
Regexp *FPAT_re_no_case  =    (Regexp *)((void *)0);
#line 79 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
Regexp *FPAT_regexp  =    (Regexp *)((void *)0);
#line 80 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
NODE *Null_field  =    (NODE *)((void *)0);
#line 84 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void init_fields(void) 
{ 
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 87
  tmp___1 = malloc(sizeof(NODE *));
#line 87
  fields_arr = (NODE **)tmp___1;
  }
#line 87
  if (fields_arr) {
#line 87
    tmp___5 = 1;
  } else {
    {
#line 87
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 87);
#line 87
    tmp___2 = __errno_location();
#line 87
    tmp___3 = strerror(*tmp___2);
#line 87
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 87
    r_fatal((char const   *)tmp___4, "init_fields", "fields_arr", (long )sizeof(NODE *),
            tmp___3);
#line 87
    tmp___5 = 0;
    }
  }
  {
#line 88
  *(fields_arr + 0) = dupnode(Nnull_string);
#line 89
  parse_extent = (*(fields_arr + 0))->sub.val.sp;
#line 90
  save_FS = dupnode(FS_node->sub.nodep.l.lptr);
#line 91
  Null_field = (NODE *)nextfree[1].freep;
  }
#line 91
  if (Null_field) {
#line 91
    nextfree[1].freep = ((BLOCK *)Null_field)->freep;
  } else {
    {
#line 91
    tmp___6 = more_blocks(1);
#line 91
    Null_field = (NODE *)tmp___6;
    }
  }
#line 92
  *Null_field = *Nnull_string;
#line 93
  Null_field->sub.val.sref = 1L;
#line 94
  Null_field->flags = 70U;
#line 95
  field0_valid = (_Bool)1;
#line 96
  return;
}
}
#line 100 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static void grow_fields_arr(long num ) 
{ 
  int t ;
  NODE *n ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 106
  tmp___1 = realloc((void *)((char *)fields_arr), (unsigned long )(num + 1L) * sizeof(NODE *));
#line 106
  fields_arr = (NODE **)tmp___1;
  }
#line 106
  if (fields_arr) {
#line 106
    tmp___5 = 1;
  } else {
    {
#line 106
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 106);
#line 106
    tmp___2 = __errno_location();
#line 106
    tmp___3 = strerror(*tmp___2);
#line 106
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 106
    r_fatal((char const   *)tmp___4, "grow_fields_arr", "fields_arr", (long )((unsigned long )(num + 1L) * sizeof(NODE *)),
            tmp___3);
#line 106
    tmp___5 = 0;
    }
  }
#line 107
  t = (int )(nf_high_water + 1L);
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! ((long )t <= num)) {
#line 107
      goto while_break;
    }
#line 108
    n = (NODE *)nextfree[1].freep;
#line 108
    if (n) {
#line 108
      nextfree[1].freep = ((BLOCK *)n)->freep;
    } else {
      {
#line 108
      tmp___6 = more_blocks(1);
#line 108
      n = (NODE *)tmp___6;
      }
    }
#line 109
    *n = *Null_field;
#line 110
    *(fields_arr + t) = n;
#line 107
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  nf_high_water = num;
#line 113
  return;
}
}
#line 118 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static void set_field(long num , char *str , long len , NODE *dummy  __attribute__((__unused__)) ) 
{ 
  NODE *n ;

  {
#line 126
  if (num > nf_high_water) {
    {
#line 127
    grow_fields_arr(num);
    }
  }
#line 128
  n = *(fields_arr + num);
#line 129
  n->sub.val.sp = str;
#line 130
  n->sub.val.slen = (size_t )len;
#line 131
  n->flags = 102U;
#line 132
  return;
}
}
#line 137 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static void rebuild_record(void) 
{ 
  unsigned long tlen ;
  unsigned long ofslen ;
  NODE *tmp___1 ;
  NODE *ofs ;
  char *ops ;
  char *cops ;
  long i___0 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  NODE *r ;
  NODE *n ;
  void *tmp___9 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 154
  tlen = 0UL;
#line 155
  ofs = force_string(OFS_node->sub.nodep.l.lptr);
#line 156
  ofslen = ofs->sub.val.slen;
#line 157
  i___0 = NF;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i___0 > 0L)) {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp___1 = *(fields_arr + i___0);
#line 159
    tmp___1 = force_string(tmp___1);
#line 160
    tlen += tmp___1->sub.val.slen;
#line 157
    i___0 --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  tlen += (unsigned long )(NF - 1L) * ofslen;
#line 163
  if ((long )tlen < 0L) {
#line 164
    tlen = 0UL;
  }
  {
#line 165
  tmp___2 = malloc(tlen + 2UL);
#line 165
  ops = (char *)tmp___2;
  }
#line 165
  if (ops) {
#line 165
    tmp___6 = 1;
  } else {
    {
#line 165
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 165);
#line 165
    tmp___3 = __errno_location();
#line 165
    tmp___4 = strerror(*tmp___3);
#line 165
    tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 165
    r_fatal((char const   *)tmp___5, "rebuild_record", "ops", (long )(tlen + 2UL),
            tmp___4);
#line 165
    tmp___6 = 0;
    }
  }
#line 166
  cops = ops;
#line 167
  *(ops + 0) = (char )'\000';
#line 168
  i___0 = 1L;
  {
#line 168
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 168
    if (! (i___0 <= NF)) {
#line 168
      goto while_break___0;
    }
    {
#line 169
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 169
      if ((*(fields_arr + i___0))->flags & 1024U) {
        {
#line 169
        r_free_wstr(*(fields_arr + i___0));
        }
      }
#line 169
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 170
    tmp___1 = *(fields_arr + i___0);
#line 172
    if (tmp___1->sub.val.slen == 1UL) {
#line 173
      tmp___7 = cops;
#line 173
      cops ++;
#line 173
      *tmp___7 = *(tmp___1->sub.val.sp + 0);
    } else
#line 174
    if (tmp___1->sub.val.slen != 0UL) {
      {
#line 175
      memcpy((void */* __restrict  */)cops, (void const   */* __restrict  */)tmp___1->sub.val.sp,
             tmp___1->sub.val.slen);
#line 176
      cops += tmp___1->sub.val.slen;
      }
    }
#line 179
    if (i___0 != NF) {
#line 180
      if (ofslen == 1UL) {
#line 181
        tmp___8 = cops;
#line 181
        cops ++;
#line 181
        *tmp___8 = *(ofs->sub.val.sp + 0);
      } else
#line 182
      if (ofslen != 0UL) {
        {
#line 183
        memcpy((void */* __restrict  */)cops, (void const   */* __restrict  */)ofs->sub.val.sp,
               ofslen);
#line 184
        cops += ofslen;
        }
      }
    }
#line 168
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 188
  tmp___1 = make_str_node((char const   *)ops, tlen, 2);
#line 196
  cops = ops;
#line 196
  i___0 = 1L;
  }
  {
#line 196
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 196
    if (! (i___0 <= NF)) {
#line 196
      goto while_break___2;
    }
#line 197
    r = *(fields_arr + i___0);
#line 198
    if (r->sub.val.slen > 0UL) {
#line 200
      n = (NODE *)nextfree[1].freep;
#line 200
      if (n) {
#line 200
        nextfree[1].freep = ((BLOCK *)n)->freep;
      } else {
        {
#line 200
        tmp___9 = more_blocks(1);
#line 200
        n = (NODE *)tmp___9;
        }
      }
#line 202
      if ((r->flags & 64U) == 0U) {
#line 203
        *n = *Null_field;
#line 204
        n->sub.val.slen = r->sub.val.slen;
#line 205
        if ((r->flags & 24U) != 0U) {
#line 206
          n->flags |= r->flags & 6168U;
#line 208
          if ((r->flags & 2048U) != 0U) {
            {
#line 209
            mpfr_init(n->sub.val.nm.mpnum);
#line 210
            mpfr_set4(n->sub.val.nm.mpnum, (mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE,
                      r->sub.val.nm.mpnum[0]._mpfr_sign);
            }
          } else
#line 211
          if ((r->flags & 4096U) != 0U) {
            {
#line 212
            __gmpz_init(n->sub.val.nm.mpi);
#line 213
            __gmpz_set(n->sub.val.nm.mpi, (mpz_srcptr )(r->sub.val.nm.mpi));
            }
          } else {
#line 216
            n->sub.val.nm.fltnum = r->sub.val.nm.fltnum;
          }
        }
      } else {
#line 219
        *n = *r;
#line 220
        n->flags &= 4294967292U;
      }
      {
#line 223
      n->sub.val.sp = cops;
#line 224
      unref(r);
#line 225
      *(fields_arr + i___0) = n;
      }
    }
#line 228
    cops += (*(fields_arr + i___0))->sub.val.slen + ofslen;
#line 196
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 231
  unref(*(fields_arr + 0));
#line 233
  *(fields_arr + 0) = tmp___1;
#line 234
  field0_valid = (_Bool)1;
  }
#line 235
  return;
}
}
#line 251 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static char *databuf  ;
#line 252 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static unsigned long databuf_size  ;
#line 247 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void set_record(char const   *buf___7 , int cnt ) 
{ 
  NODE *n ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 256
  reset_record();
  }
#line 259
  if (databuf_size == 0UL) {
    {
#line 260
    tmp___1 = malloc((size_t )512);
#line 260
    databuf = (char *)tmp___1;
    }
#line 260
    if (databuf) {
#line 260
      tmp___5 = 1;
    } else {
      {
#line 260
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 260);
#line 260
      tmp___2 = __errno_location();
#line 260
      tmp___3 = strerror(*tmp___2);
#line 260
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 260
      r_fatal((char const   *)tmp___4, "set_record", "databuf", 512L, tmp___3);
#line 260
      tmp___5 = 0;
      }
    }
    {
#line 261
    databuf_size = 512UL;
#line 262
    memset((void *)databuf, '\000', (size_t )512);
    }
  }
#line 270
  if ((unsigned long )cnt >= databuf_size) {
    {
#line 271
    while (1) {
      while_continue: /* CIL Label */ ;
#line 271
      if ((unsigned long )cnt >= databuf_size) {
#line 271
        if (! (databuf_size <= 0xffffffffffffffffUL)) {
#line 271
          goto while_break;
        }
      } else {
#line 271
        goto while_break;
      }
#line 272
      databuf_size *= 2UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 273
    tmp___6 = realloc((void *)databuf, databuf_size);
#line 273
    databuf = (char *)tmp___6;
    }
#line 273
    if (databuf) {
#line 273
      tmp___10 = 1;
    } else {
      {
#line 273
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 273);
#line 273
      tmp___7 = __errno_location();
#line 273
      tmp___8 = strerror(*tmp___7);
#line 273
      tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 273
      r_fatal((char const   *)tmp___9, "set_record", "databuf", (long )databuf_size,
              tmp___8);
#line 273
      tmp___10 = 0;
      }
    }
    {
#line 274
    memset((void *)databuf, '\000', databuf_size);
    }
  }
  {
#line 277
  memcpy((void */* __restrict  */)databuf, (void const   */* __restrict  */)buf___7,
         (size_t )cnt);
#line 280
  unref(*(fields_arr + 0));
#line 281
  n = (NODE *)nextfree[1].freep;
  }
#line 281
  if (n) {
#line 281
    nextfree[1].freep = ((BLOCK *)n)->freep;
  } else {
    {
#line 281
    tmp___11 = more_blocks(1);
#line 281
    n = (NODE *)tmp___11;
    }
  }
#line 282
  n->sub.val.sp = databuf;
#line 283
  n->sub.val.slen = (size_t )cnt;
#line 284
  n->sub.val.sref = 1L;
#line 285
  n->type = (NODETYPE )1;
#line 286
  n->sub.val.idx = -1;
#line 287
  n->flags = 102U;
#line 288
  *(fields_arr + 0) = n;
#line 292
  return;
}
}
#line 296 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void reset_record(void) 
{ 
  int i___0 ;
  NODE *n ;
  void *tmp___1 ;

  {
  {
#line 302
  *(fields_arr + 0) = force_string(*(fields_arr + 0));
#line 304
  NF = -1L;
#line 305
  i___0 = 1;
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! ((long )i___0 <= parse_high_water)) {
#line 305
      goto while_break;
    }
    {
#line 306
    unref(*(fields_arr + i___0));
#line 307
    n = (NODE *)nextfree[1].freep;
    }
#line 307
    if (n) {
#line 307
      nextfree[1].freep = ((BLOCK *)n)->freep;
    } else {
      {
#line 307
      tmp___1 = more_blocks(1);
#line 307
      n = (NODE *)tmp___1;
      }
    }
#line 308
    *n = *Null_field;
#line 309
    *(fields_arr + i___0) = n;
#line 305
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  parse_high_water = 0L;
#line 316
  if (resave_fs) {
    {
#line 317
    resave_fs = (_Bool)0;
#line 318
    unref(save_FS);
#line 319
    save_FS = dupnode(FS_node->sub.nodep.l.lptr);
    }
  }
#line 322
  field0_valid = (_Bool)1;
#line 323
  return;
}
}
#line 327 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void set_NF(void) 
{ 
  int i___0 ;
  long nf ;
  NODE *n ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 336
  force_number(NF_node->sub.nodep.l.lptr);
  }
#line 337
  if ((NF_node->sub.nodep.l.lptr)->flags & 2048U) {
    {
#line 337
    tmp___1 = mpfr_get_si((mpfr_srcptr )((NF_node->sub.nodep.l.lptr)->sub.val.nm.mpnum),
                          ROUND_MODE);
#line 337
    nf = tmp___1;
    }
  } else {
#line 337
    if ((NF_node->sub.nodep.l.lptr)->flags & 4096U) {
      {
#line 337
      tmp___2 = __gmpz_get_si((mpz_srcptr )((NF_node->sub.nodep.l.lptr)->sub.val.nm.mpi));
#line 337
      tmp___3 = tmp___2;
      }
    } else {
#line 337
      tmp___3 = (long )(NF_node->sub.nodep.l.lptr)->sub.val.nm.fltnum;
    }
#line 337
    nf = tmp___3;
  }
#line 338
  if (nf < 0L) {
    {
#line 339
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 339);
#line 339
    tmp___4 = gettext("NF set to negative value");
#line 339
    r_fatal((char const   *)tmp___4);
    }
  }
#line 340
  NF = nf;
#line 342
  if (NF > nf_high_water) {
    {
#line 343
    grow_fields_arr(NF);
    }
  }
#line 344
  if (parse_high_water < NF) {
#line 345
    i___0 = (int )(parse_high_water + 1L);
    {
#line 345
    while (1) {
      while_continue: /* CIL Label */ ;
#line 345
      if (i___0 >= 0) {
#line 345
        if (! ((long )i___0 <= NF)) {
#line 345
          goto while_break;
        }
      } else {
#line 345
        goto while_break;
      }
      {
#line 346
      unref(*(fields_arr + i___0));
#line 347
      n = (NODE *)nextfree[1].freep;
      }
#line 347
      if (n) {
#line 347
        nextfree[1].freep = ((BLOCK *)n)->freep;
      } else {
        {
#line 347
        tmp___5 = more_blocks(1);
#line 347
        n = (NODE *)tmp___5;
        }
      }
#line 348
      *n = *Null_field;
#line 349
      *(fields_arr + i___0) = n;
#line 345
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 351
  if (parse_high_water > 0L) {
#line 352
    i___0 = (int )(NF + 1L);
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (i___0 >= 0) {
#line 352
        if (! ((long )i___0 <= parse_high_water)) {
#line 352
          goto while_break___0;
        }
      } else {
#line 352
        goto while_break___0;
      }
      {
#line 353
      unref(*(fields_arr + i___0));
#line 354
      n = (NODE *)nextfree[1].freep;
      }
#line 354
      if (n) {
#line 354
        nextfree[1].freep = ((BLOCK *)n)->freep;
      } else {
        {
#line 354
        tmp___6 = more_blocks(1);
#line 354
        n = (NODE *)tmp___6;
        }
      }
#line 355
      *n = *Null_field;
#line 356
      *(fields_arr + i___0) = n;
#line 352
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 358
    parse_high_water = NF;
  }
#line 360
  field0_valid = (_Bool)0;
#line 361
  return;
}
}
#line 370 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long re_parse_field(long up_to , char **buf___7 , int len , NODE *fs  __attribute__((__unused__)) ,
                           Regexp *rp , void (*set)(long  , char * , long  , NODE * ) ,
                           NODE *n , NODE *sep_arr , _Bool in_middle ) 
{ 
  char *scan ;
  long nf ;
  char *field ;
  char *end ;
  int regex_flags ;
  char *sep ;
  size_t mbclen ;
  mbstate_t mbs___0 ;
  int tmp___1 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
#line 381
  scan = *buf___7;
#line 382
  nf = parse_high_water;
#line 384
  end = scan + len;
#line 385
  regex_flags = 1;
#line 388
  mbclen = (size_t )0;
#line 390
  if (gawk_mb_cur_max > 1) {
    {
#line 391
    memset((void *)(& mbs___0), 0, sizeof(mbstate_t ));
    }
  }
#line 394
  if (in_middle) {
#line 395
    regex_flags |= 2;
  }
#line 397
  if (up_to == 9223372036854775807L) {
#line 398
    nf = 0L;
  }
#line 399
  if (len == 0) {
#line 400
    return (nf);
  }
#line 402
  if (RS_is_null) {
#line 402
    if (default_FS) {
#line 403
      sep = scan;
      {
#line 404
      while (1) {
        while_continue: /* CIL Label */ ;
#line 404
        if ((unsigned long )scan < (unsigned long )end) {
#line 404
          if (! ((int )*scan == 32)) {
#line 404
            if (! ((int )*scan == 9)) {
#line 404
              if (! ((int )*scan == 10)) {
#line 404
                goto while_break;
              }
            }
          }
        } else {
#line 404
          goto while_break;
        }
#line 405
        scan ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 406
      if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
#line 406
        if ((unsigned long )sep < (unsigned long )scan) {
          {
#line 407
          set_element(nf, sep, scan - sep, sep_arr);
          }
        }
      }
    }
  }
#line 410
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 411
    rp = FS_regexp;
  }
#line 413
  field = scan;
  {
#line 414
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 414
    if ((unsigned long )scan < (unsigned long )end) {
      {
#line 414
      tmp___1 = research(rp, scan, 0, (size_t )(end - scan), regex_flags);
      }
#line 414
      if (tmp___1 != -1) {
#line 414
        if (! (nf < up_to)) {
#line 414
          goto while_break___0;
        }
      } else {
#line 414
        goto while_break___0;
      }
    } else {
#line 414
      goto while_break___0;
    }
#line 417
    regex_flags |= 2;
#line 418
    if (*(rp->regs.end + 0) == *(rp->regs.start + 0)) {
#line 420
      if (gawk_mb_cur_max > 1) {
        {
#line 421
        mbclen = mbrlen((char const   */* __restrict  */)scan, (size_t )(end - scan),
                        (mbstate_t */* __restrict  */)(& mbs___0));
        }
#line 422
        if (mbclen == 1UL) {
#line 425
          mbclen = (size_t )1;
        } else
#line 422
        if (mbclen == 0xffffffffffffffffUL) {
#line 425
          mbclen = (size_t )1;
        } else
#line 422
        if (mbclen == 0xfffffffffffffffeUL) {
#line 425
          mbclen = (size_t )1;
        } else
#line 422
        if (mbclen == 0UL) {
#line 425
          mbclen = (size_t )1;
        }
#line 427
        scan += mbclen;
      } else {
#line 430
        scan ++;
      }
#line 431
      if ((unsigned long )scan == (unsigned long )end) {
        {
#line 432
        nf ++;
#line 432
        (*set)(nf, field, scan - field, n);
#line 433
        up_to = nf;
        }
#line 434
        goto while_break___0;
      }
#line 436
      goto while_continue___0;
    }
    {
#line 438
    nf ++;
#line 438
    (*set)(nf, field, (scan + *(rp->regs.start + 0)) - field, n);
    }
#line 440
    if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
      {
#line 441
      set_element(nf, scan + *(rp->regs.start + 0), (long )(*(rp->regs.end + 0) - *(rp->regs.start + 0)),
                  sep_arr);
      }
    }
#line 443
    scan += *(rp->regs.end + 0);
#line 444
    field = scan;
#line 445
    if ((unsigned long )scan == (unsigned long )end) {
      {
#line 446
      nf ++;
#line 446
      (*set)(nf, field, 0L, n);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 448
  if (nf != up_to) {
#line 448
    if ((unsigned long )scan < (unsigned long )end) {
      {
#line 449
      nf ++;
#line 449
      (*set)(nf, scan, end - scan, n);
#line 450
      scan = end;
      }
    }
  }
#line 452
  *buf___7 = scan;
#line 453
  return (nf);
}
}
#line 464 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long def_parse_field(long up_to , char **buf___7 , int len , NODE *fs , Regexp *rp  __attribute__((__unused__)) ,
                            void (*set)(long  , char * , long  , NODE * ) , NODE *n ,
                            NODE *sep_arr , _Bool in_middle  __attribute__((__unused__)) ) 
{ 
  char *scan ;
  long nf ;
  char *field ;
  char *end ;
  char sav ;
  char *sep ;

  {
#line 475
  scan = *buf___7;
#line 476
  nf = parse_high_water;
#line 478
  end = scan + len;
#line 482
  if (up_to == 9223372036854775807L) {
#line 483
    nf = 0L;
  }
#line 484
  if (len == 0) {
#line 485
    return (nf);
  }
#line 491
  if (fs->sub.val.slen == 0UL) {
    {
#line 492
    nf ++;
#line 492
    (*set)(nf, *buf___7, (long )len, n);
#line 493
    *buf___7 += len;
    }
#line 494
    return (nf);
  }
#line 498
  sav = *end;
#line 501
  *end = (char )' ';
#line 502
  sep = scan;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (nf < up_to)) {
#line 503
      goto while_break;
    }
    {
#line 507
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 507
      if ((unsigned long )scan < (unsigned long )end) {
#line 507
        if (! ((int )*scan == 32)) {
#line 507
          if (! ((int )*scan == 9)) {
#line 507
            if (! ((int )*scan == 10)) {
#line 507
              goto while_break___0;
            }
          }
        }
      } else {
#line 507
        goto while_break___0;
      }
#line 508
      scan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 510
    if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
#line 510
      if ((unsigned long )scan > (unsigned long )sep) {
        {
#line 511
        set_element(nf, sep, scan - sep, sep_arr);
        }
      }
    }
#line 513
    if ((unsigned long )scan >= (unsigned long )end) {
#line 514
      goto while_break;
    }
#line 516
    field = scan;
    {
#line 518
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 518
      if ((int )*scan != 32) {
#line 518
        if ((int )*scan != 9) {
#line 518
          if (! ((int )*scan != 10)) {
#line 518
            goto while_break___1;
          }
        } else {
#line 518
          goto while_break___1;
        }
      } else {
#line 518
        goto while_break___1;
      }
#line 519
      scan ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 521
    nf ++;
#line 521
    (*set)(nf, field, scan - field, n);
    }
#line 523
    if ((unsigned long )scan == (unsigned long )end) {
#line 524
      goto while_break;
    }
#line 526
    sep = scan;
#line 503
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  *end = sav;
#line 532
  *buf___7 = scan;
#line 533
  return (nf);
}
}
#line 545 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long posix_def_parse_field(long up_to , char **buf___7 , int len , NODE *fs ,
                                  Regexp *rp  __attribute__((__unused__)) , void (*set)(long  ,
                                                                                        char * ,
                                                                                        long  ,
                                                                                        NODE * ) ,
                                  NODE *n , NODE *dummy  __attribute__((__unused__)) ,
                                  _Bool in_middle  __attribute__((__unused__)) ) 
{ 
  char *scan ;
  long nf ;
  char *field ;
  char *end ;
  char sav ;

  {
#line 556
  scan = *buf___7;
#line 557
  nf = parse_high_water;
#line 559
  end = scan + len;
#line 562
  if (up_to == 9223372036854775807L) {
#line 563
    nf = 0L;
  }
#line 564
  if (len == 0) {
#line 565
    return (nf);
  }
#line 571
  if (fs->sub.val.slen == 0UL) {
    {
#line 572
    nf ++;
#line 572
    (*set)(nf, *buf___7, (long )len, n);
#line 573
    *buf___7 += len;
    }
#line 574
    return (nf);
  }
#line 578
  sav = *end;
#line 581
  *end = (char )' ';
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (! (nf < up_to)) {
#line 582
      goto while_break;
    }
    {
#line 586
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 586
      if ((unsigned long )scan < (unsigned long )end) {
#line 586
        if (! ((int )*scan == 32)) {
#line 586
          if (! ((int )*scan == 9)) {
#line 586
            goto while_break___0;
          }
        }
      } else {
#line 586
        goto while_break___0;
      }
#line 587
      scan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 588
    if ((unsigned long )scan >= (unsigned long )end) {
#line 589
      goto while_break;
    }
#line 590
    field = scan;
    {
#line 591
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 591
      if ((int )*scan != 32) {
#line 591
        if (! ((int )*scan != 9)) {
#line 591
          goto while_break___1;
        }
      } else {
#line 591
        goto while_break___1;
      }
#line 592
      scan ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 593
    nf ++;
#line 593
    (*set)(nf, field, scan - field, n);
    }
#line 594
    if ((unsigned long )scan == (unsigned long )end) {
#line 595
      goto while_break;
    }
#line 582
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  *end = sav;
#line 601
  *buf___7 = scan;
#line 602
  return (nf);
}
}
#line 611 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long null_parse_field(long up_to , char **buf___7 , int len , NODE *fs  __attribute__((__unused__)) ,
                             Regexp *rp  __attribute__((__unused__)) , void (*set)(long  ,
                                                                                   char * ,
                                                                                   long  ,
                                                                                   NODE * ) ,
                             NODE *n , NODE *sep_arr , _Bool in_middle  __attribute__((__unused__)) ) 
{ 
  char *scan ;
  long nf ;
  char *end ;
  mbstate_t mbs___0 ;
  size_t mbclen ;
  size_t tmp___1 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;

  {
#line 622
  scan = *buf___7;
#line 623
  nf = parse_high_water;
#line 624
  end = scan + len;
#line 626
  if (up_to == 9223372036854775807L) {
#line 627
    nf = 0L;
  }
#line 628
  if (len == 0) {
#line 629
    return (nf);
  }
#line 632
  if (gawk_mb_cur_max > 1) {
    {
#line 634
    memset((void *)(& mbs___0), 0, sizeof(mbstate_t ));
    }
    {
#line 635
    while (1) {
      while_continue: /* CIL Label */ ;
#line 635
      if (nf < up_to) {
#line 635
        if (! ((unsigned long )scan < (unsigned long )end)) {
#line 635
          goto while_break;
        }
      } else {
#line 635
        goto while_break;
      }
      {
#line 636
      tmp___1 = mbrlen((char const   */* __restrict  */)scan, (size_t )(end - scan),
                       (mbstate_t */* __restrict  */)(& mbs___0));
#line 636
      mbclen = tmp___1;
      }
#line 637
      if (mbclen == 1UL) {
#line 640
        mbclen = (size_t )1;
      } else
#line 637
      if (mbclen == 0xffffffffffffffffUL) {
#line 640
        mbclen = (size_t )1;
      } else
#line 637
      if (mbclen == 0xfffffffffffffffeUL) {
#line 640
        mbclen = (size_t )1;
      } else
#line 637
      if (mbclen == 0UL) {
#line 640
        mbclen = (size_t )1;
      }
#line 642
      if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
#line 642
        if (nf > 0L) {
          {
#line 643
          set_element(nf, scan, 0L, sep_arr);
          }
        }
      }
      {
#line 644
      nf ++;
#line 644
      (*set)(nf, scan, (long )mbclen, n);
#line 645
      scan += mbclen;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 649
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 649
      if (nf < up_to) {
#line 649
        if (! ((unsigned long )scan < (unsigned long )end)) {
#line 649
          goto while_break___0;
        }
      } else {
#line 649
        goto while_break___0;
      }
#line 650
      if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
#line 650
        if (nf > 0L) {
          {
#line 651
          set_element(nf, scan, 0L, sep_arr);
          }
        }
      }
      {
#line 652
      nf ++;
#line 652
      (*set)(nf, scan, 1L, n);
#line 649
      scan ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 655
  *buf___7 = scan;
#line 656
  return (nf);
}
}
#line 666 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long sc_parse_field(long up_to , char **buf___7 , int len , NODE *fs , Regexp *rp  __attribute__((__unused__)) ,
                           void (*set)(long  , char * , long  , NODE * ) , NODE *n ,
                           NODE *sep_arr , _Bool in_middle  __attribute__((__unused__)) ) 
{ 
  char *scan ;
  char fschar ;
  long nf ;
  char *field ;
  char *end ;
  char sav ;
  size_t mbclen ;
  mbstate_t mbs___0 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
#line 677
  scan = *buf___7;
#line 679
  nf = parse_high_water;
#line 681
  end = scan + len;
#line 684
  mbclen = (size_t )0;
#line 686
  if (gawk_mb_cur_max > 1) {
    {
#line 687
    memset((void *)(& mbs___0), 0, sizeof(mbstate_t ));
    }
  }
#line 690
  if (up_to == 9223372036854775807L) {
#line 691
    nf = 0L;
  }
#line 692
  if (len == 0) {
#line 693
    return (nf);
  }
#line 695
  if (RS_is_null) {
#line 695
    if (fs->sub.val.slen == 0UL) {
#line 696
      fschar = (char )'\n';
    } else {
#line 698
      fschar = *(fs->sub.val.sp + 0);
    }
  } else {
#line 698
    fschar = *(fs->sub.val.sp + 0);
  }
#line 701
  sav = *end;
#line 703
  *end = fschar;
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;
#line 705
    if (! (nf < up_to)) {
#line 705
      goto while_break;
    }
#line 706
    field = scan;
#line 708
    if (gawk_mb_cur_max > 1) {
      {
#line 709
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 709
        if (! ((int )*scan != (int )fschar)) {
#line 709
          goto while_break___0;
        }
        {
#line 710
        mbclen = mbrlen((char const   */* __restrict  */)scan, (size_t )(end - scan),
                        (mbstate_t */* __restrict  */)(& mbs___0));
        }
#line 711
        if (mbclen == 1UL) {
#line 714
          mbclen = (size_t )1;
        } else
#line 711
        if (mbclen == 0xffffffffffffffffUL) {
#line 714
          mbclen = (size_t )1;
        } else
#line 711
        if (mbclen == 0xfffffffffffffffeUL) {
#line 714
          mbclen = (size_t )1;
        } else
#line 711
        if (mbclen == 0UL) {
#line 714
          mbclen = (size_t )1;
        }
#line 716
        scan += mbclen;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 720
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 720
        if (! ((int )*scan != (int )fschar)) {
#line 720
          goto while_break___1;
        }
#line 721
        scan ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 722
    nf ++;
#line 722
    (*set)(nf, field, scan - field, n);
    }
#line 723
    if ((unsigned long )scan == (unsigned long )end) {
#line 724
      goto while_break;
    }
#line 725
    if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
      {
#line 726
      set_element(nf, scan, 1L, sep_arr);
      }
    }
#line 727
    scan ++;
#line 728
    if ((unsigned long )scan == (unsigned long )end) {
      {
#line 729
      nf ++;
#line 729
      (*set)(nf, field, 0L, n);
      }
#line 730
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  *end = sav;
#line 737
  *buf___7 = scan;
#line 738
  return (nf);
}
}
#line 747 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long fw_parse_field(long up_to , char **buf___7 , int len , NODE *fs  __attribute__((__unused__)) ,
                           Regexp *rp  __attribute__((__unused__)) , void (*set)(long  ,
                                                                                 char * ,
                                                                                 long  ,
                                                                                 NODE * ) ,
                           NODE *n , NODE *dummy  __attribute__((__unused__)) , _Bool in_middle  __attribute__((__unused__)) ) 
{ 
  char *scan ;
  long nf ;
  char *end ;
  int nmbc ;
  size_t mbclen ;
  size_t mbslen ;
  size_t lenrest ;
  char *mbscan ;
  mbstate_t mbs___0 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
#line 758
  scan = *buf___7;
#line 759
  nf = parse_high_water;
#line 760
  end = scan + len;
#line 769
  memset((void *)(& mbs___0), 0, sizeof(mbstate_t ));
  }
#line 772
  if (up_to == 9223372036854775807L) {
#line 773
    nf = 0L;
  }
#line 774
  if (len == 0) {
#line 775
    return (nf);
  }
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 776
    if (nf < up_to) {
#line 776
      len = *(FIELDWIDTHS + (nf + 1L));
#line 776
      if (! (len != -1)) {
#line 776
        goto while_break;
      }
    } else {
#line 776
      goto while_break;
    }
#line 778
    if (gawk_mb_cur_max > 1) {
#line 779
      nmbc = 0;
#line 780
      mbslen = (size_t )0;
#line 781
      mbscan = scan;
#line 782
      lenrest = (size_t )(end - scan);
      {
#line 783
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 783
        if (nmbc < len) {
#line 783
          if (! (mbslen < lenrest)) {
#line 783
            goto while_break___0;
          }
        } else {
#line 783
          goto while_break___0;
        }
        {
#line 784
        mbclen = mbrlen((char const   */* __restrict  */)mbscan, (size_t )(end - mbscan),
                        (mbstate_t */* __restrict  */)(& mbs___0));
        }
#line 785
        if (mbclen == 1UL) {
#line 790
          mbclen = (size_t )1;
        } else
#line 785
        if (mbclen == 0xffffffffffffffffUL) {
#line 790
          mbclen = (size_t )1;
        } else
#line 785
        if (mbclen == 0xfffffffffffffffeUL) {
#line 790
          mbclen = (size_t )1;
        } else
#line 785
        if (mbclen == 0UL) {
#line 790
          mbclen = (size_t )1;
        }
#line 792
        if (mbclen <= (size_t )(end - mbscan)) {
#line 793
          mbscan += mbclen;
#line 794
          mbslen += mbclen;
#line 795
          nmbc ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 798
      nf ++;
#line 798
      (*set)(nf, scan, (long )mbslen, n);
#line 799
      scan += mbslen;
      }
    } else {
#line 804
      if ((long )len > end - scan) {
#line 805
        len = (int )(end - scan);
      }
      {
#line 806
      nf ++;
#line 806
      (*set)(nf, scan, (long )len, n);
#line 807
      scan += len;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 810
  if (len == -1) {
#line 811
    *buf___7 = end;
  } else {
#line 813
    *buf___7 = scan;
  }
#line 814
  return (nf);
}
}
#line 819 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void invalidate_field0(void) 
{ 


  {
#line 822
  field0_valid = (_Bool)0;
#line 823
  return;
}
}
#line 829 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
NODE **get_field(long requested , Func_ptr *assign ) 
{ 
  _Bool in_middle ;
  char *rec_start ;
  char *rec_end ;

  {
#line 832
  in_middle = (_Bool)0;
#line 837
  if (requested == 0L) {
#line 838
    if (! field0_valid) {
#line 840
      if (NF == -1L) {
        {
#line 841
        NF = (*parse_field)(9223372036854775806L, & parse_extent, (int )((*(fields_arr + 0))->sub.val.slen - (size_t )(parse_extent - (*(fields_arr + 0))->sub.val.sp)),
                            save_FS, FS_regexp, & set_field, (NODE *)((void *)0),
                            (NODE *)((void *)0), in_middle);
#line 848
        parse_high_water = NF;
        }
      }
      {
#line 850
      rebuild_record();
      }
    }
#line 852
    if ((unsigned long )assign != (unsigned long )((void *)0)) {
#line 853
      *assign = & reset_record;
    }
#line 854
    return (fields_arr + 0);
  }
#line 871
  if ((unsigned long )assign != (unsigned long )((void *)0)) {
#line 872
    *assign = & invalidate_field0;
  }
#line 875
  if (requested <= parse_high_water) {
#line 876
    return (fields_arr + requested);
  }
#line 878
  if (NF == -1L) {
#line 883
    if (parse_high_water == 0L) {
#line 884
      parse_extent = (*(fields_arr + 0))->sub.val.sp;
    } else {
#line 886
      in_middle = (_Bool)1;
    }
    {
#line 887
    parse_high_water = (*parse_field)(requested, & parse_extent, (int )((*(fields_arr + 0))->sub.val.slen - (size_t )(parse_extent - (*(fields_arr + 0))->sub.val.sp)),
                                      save_FS, (Regexp *)((void *)0), & set_field,
                                      (NODE *)((void *)0), (NODE *)((void *)0), in_middle);
    }
#line 899
    if ((unsigned long )parse_extent == (unsigned long )((*(fields_arr + 0))->sub.val.sp + (*(fields_arr + 0))->sub.val.slen)) {
#line 900
      NF = parse_high_water;
    } else
#line 901
    if ((unsigned long )parse_field == (unsigned long )(& fpat_parse_field)) {
#line 903
      rec_start = (*(fields_arr + 0))->sub.val.sp;
#line 904
      rec_end = (*(fields_arr + 0))->sub.val.sp + (*(fields_arr + 0))->sub.val.slen;
#line 906
      if ((unsigned long )parse_extent > (unsigned long )rec_end) {
#line 908
        NF = parse_high_water;
      } else
#line 906
      if ((unsigned long )parse_extent > (unsigned long )rec_start) {
#line 906
        if ((unsigned long )parse_extent < (unsigned long )rec_end) {
#line 906
          if (requested == 9223372036854775806L) {
#line 908
            NF = parse_high_water;
          } else {
#line 906
            goto _L___0;
          }
        } else {
#line 906
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 909
      if ((unsigned long )parse_extent == (unsigned long )rec_start) {
#line 910
        NF = 0L;
      }
    }
#line 912
    if (requested == 9223372036854775806L) {
#line 913
      requested = parse_high_water;
    }
  }
#line 915
  if (parse_high_water < requested) {
#line 916
    if ((unsigned long )assign != (unsigned long )((void *)0)) {
#line 917
      if (requested > nf_high_water) {
        {
#line 918
        grow_fields_arr(requested);
        }
      }
#line 920
      NF = requested;
#line 921
      parse_high_water = requested;
    } else {
#line 923
      return (& Null_field);
    }
  }
#line 926
  return (fields_arr + requested);
}
}
#line 931 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static void set_element(long num , char *s___0 , long len , NODE *n ) 
{ 
  NODE *it ;
  NODE **lhs ;
  NODE *sub ;

  {
  {
#line 938
  it = make_str_node((char const   *)s___0, (size_t )len, 0);
#line 939
  it->flags |= 32U;
#line 940
  sub = (*make_number)((double )num);
#line 941
  lhs = (*(*(n->sub.nodep.l.lp + 3)))(n, sub);
#line 942
  unref(*lhs);
#line 943
  *lhs = it;
  }
#line 944
  if ((unsigned long )*(n->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
    {
#line 945
    (*(*(n->sub.nodep.l.lp + 10)))(n, sub);
    }
  }
  {
#line 946
  unref(sub);
  }
#line 947
  return;
}
}
#line 961 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static _Bool warned1  =    (_Bool)0;
#line 961 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static _Bool warned2  =    (_Bool)0;
#line 1017 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static _Bool warned___4  =    (_Bool)0;
#line 951 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
NODE *do_split(int nargs ) 
{ 
  NODE *src ;
  NODE *arr ;
  NODE *sep ;
  NODE *fs ;
  NODE *tmp___1 ;
  NODE *sep_arr ;
  char *s___0 ;
  long (*parseit)(long  , char ** , int  , NODE * , Regexp * , void (*)(long  , char * ,
                                                                        long  , NODE * ) ,
                  NODE * , NODE * , _Bool  ) ;
  Regexp *rp ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  STACK_ITEM *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  NODE *tmp___11 ;
  NODE *tmp___12 ;
  char *tmp___13 ;
  field_sep_type tmp___14 ;
  long tmp___15 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 954
  sep_arr = (NODE *)((void *)0);
#line 958
  rp = (Regexp *)((void *)0);
#line 960
  if (nargs == 4) {
#line 963
    if (do_flags & 8) {
      {
#line 964
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 964);
#line 964
      tmp___2 = gettext("split: fourth argument is a gawk extension");
#line 964
      r_fatal((char const   *)tmp___2);
      }
    } else
#line 963
    if (do_flags & 16) {
      {
#line 964
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 964);
#line 964
      tmp___2 = gettext("split: fourth argument is a gawk extension");
#line 964
      r_fatal((char const   *)tmp___2);
      }
    }
    {
#line 966
    sep_arr = POP_PARAM();
    }
#line 967
    if ((unsigned int )sep_arr->type != 5U) {
      {
#line 968
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 968);
#line 968
      tmp___3 = gettext("split: fourth argument is not an array");
#line 968
      r_fatal((char const   *)tmp___3);
      }
    }
#line 969
    if (do_flags & 3) {
#line 969
      if (! warned1) {
        {
#line 970
        warned1 = (_Bool)1;
#line 971
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 971);
#line 971
        tmp___4 = gettext("split: fourth argument is a gawk extension");
#line 971
        (*lintfunc)((char const   *)tmp___4);
        }
      }
    }
#line 973
    if (do_flags & 4) {
#line 973
      if (! warned2) {
        {
#line 974
        warned2 = (_Bool)1;
#line 975
        tmp___5 = gettext("split: fourth argument is a gawk extension");
#line 975
        warning((char const   *)tmp___5);
        }
      }
    }
  }
  {
#line 979
  tmp___6 = stack_ptr;
#line 979
  stack_ptr --;
#line 979
  sep = tmp___6->rptr;
#line 980
  arr = POP_PARAM();
  }
#line 981
  if ((unsigned int )arr->type != 5U) {
    {
#line 982
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 982);
#line 982
    tmp___7 = gettext("split: second argument is not an array");
#line 982
    r_fatal((char const   *)tmp___7);
    }
  }
#line 984
  if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
#line 985
    if ((unsigned long )sep_arr == (unsigned long )arr) {
      {
#line 986
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 986);
#line 986
      tmp___8 = gettext("split: cannot use the same array for second and fourth args");
#line 986
      r_fatal((char const   *)tmp___8);
      }
    }
#line 989
    tmp___1 = sep_arr->sub.nodep.x.extra;
    {
#line 989
    while (1) {
      while_continue: /* CIL Label */ ;
#line 989
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 989
        goto while_break;
      }
#line 990
      if ((unsigned long )tmp___1 == (unsigned long )arr) {
        {
#line 991
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 991);
#line 991
        tmp___9 = gettext("split: cannot use a subarray of second arg for fourth arg");
#line 991
        r_fatal((char const   *)tmp___9);
        }
      }
#line 989
      tmp___1 = tmp___1->sub.nodep.x.extra;
    }
    while_break: /* CIL Label */ ;
    }
#line 992
    tmp___1 = arr->sub.nodep.x.extra;
    {
#line 992
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 992
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 992
        goto while_break___0;
      }
#line 993
      if ((unsigned long )tmp___1 == (unsigned long )sep_arr) {
        {
#line 994
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 994);
#line 994
        tmp___10 = gettext("split: cannot use a subarray of fourth arg for second arg");
#line 994
        r_fatal((char const   *)tmp___10);
        }
      }
#line 992
      tmp___1 = tmp___1->sub.nodep.x.extra;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 995
    (*(*(sep_arr->sub.nodep.l.lp + 5)))(sep_arr, (struct exp_node *)((void *)0));
    }
  }
  {
#line 997
  (*(*(arr->sub.nodep.l.lp + 5)))(arr, (struct exp_node *)((void *)0));
#line 999
  tmp___11 = TOP_SCALAR();
#line 999
  src = force_string(tmp___11);
  }
#line 1000
  if (src->sub.val.slen == 0UL) {
    {
#line 1004
    tmp___1 = POP_SCALAR();
#line 1005
    DEREF(tmp___1);
#line 1006
    tmp___12 = (*make_number)((double )0);
    }
#line 1006
    return (tmp___12);
  }
#line 1009
  if ((sep->sub.nodep.reflags & 4UL) != 0UL) {
    {
#line 1009
    tmp___14 = current_field_sep();
    }
#line 1009
    if ((unsigned int )tmp___14 != 1U) {
#line 1009
      if (! RS_is_null) {
        {
#line 1010
        parseit = parse_field;
#line 1011
        fs = force_string(FS_node->sub.nodep.l.lptr);
#line 1012
        rp = FS_regexp;
        }
      } else {
#line 1009
        goto _L___0;
      }
    } else {
#line 1009
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1014
    fs = sep->sub.nodep.x.extra;
#line 1016
    if (fs->sub.val.slen == 0UL) {
#line 1019
      parseit = & null_parse_field;
#line 1021
      if (do_flags & 3) {
#line 1021
        if (! warned___4) {
          {
#line 1022
          warned___4 = (_Bool)1;
#line 1023
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1023);
#line 1023
          tmp___13 = gettext("split: null string for third arg is a gawk extension");
#line 1023
          (*lintfunc)((char const   *)tmp___13);
          }
        }
      }
    } else
#line 1025
    if (fs->sub.val.slen == 1UL) {
#line 1025
      if ((sep->sub.nodep.reflags & 2UL) == 0UL) {
#line 1026
        if ((int )*(fs->sub.val.sp + 0) == 32) {
#line 1027
          if (do_flags & 16) {
#line 1028
            parseit = & posix_def_parse_field;
          } else {
#line 1030
            parseit = & def_parse_field;
          }
        } else {
#line 1032
          parseit = & sc_parse_field;
        }
      } else {
        {
#line 1034
        parseit = & re_parse_field;
#line 1035
        rp = re_update(sep);
        }
      }
    } else {
      {
#line 1034
      parseit = & re_parse_field;
#line 1035
      rp = re_update(sep);
      }
    }
  }
  {
#line 1039
  s___0 = src->sub.val.sp;
#line 1040
  tmp___15 = (*parseit)(9223372036854775807L, & s___0, (int )src->sub.val.slen, fs,
                        rp, & set_element, arr, sep_arr, (_Bool)0);
#line 1040
  tmp___1 = (*make_number)((double )tmp___15);
#line 1043
  src = POP_SCALAR();
#line 1044
  DEREF(src);
  }
#line 1045
  return (tmp___1);
}
}
#line 1053 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
NODE *do_patsplit(int nargs ) 
{ 
  NODE *src ;
  NODE *arr ;
  NODE *sep ;
  NODE *fpat ;
  NODE *tmp___1 ;
  NODE *sep_arr ;
  char *s___0 ;
  Regexp *rp ;
  char *tmp___2 ;
  STACK_ITEM *tmp___3 ;
  char *tmp___4 ;
  NODE *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  long tmp___10 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 1056
  sep_arr = (NODE *)((void *)0);
#line 1058
  rp = (Regexp *)((void *)0);
#line 1060
  if (nargs == 4) {
    {
#line 1061
    sep_arr = POP_PARAM();
    }
#line 1062
    if ((unsigned int )sep_arr->type != 5U) {
      {
#line 1063
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1063);
#line 1063
      tmp___2 = gettext("patsplit: fourth argument is not an array");
#line 1063
      r_fatal((char const   *)tmp___2);
      }
    }
  }
  {
#line 1065
  tmp___3 = stack_ptr;
#line 1065
  stack_ptr --;
#line 1065
  sep = tmp___3->rptr;
#line 1066
  arr = POP_PARAM();
  }
#line 1067
  if ((unsigned int )arr->type != 5U) {
    {
#line 1068
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1068);
#line 1068
    tmp___4 = gettext("patsplit: second argument is not an array");
#line 1068
    r_fatal((char const   *)tmp___4);
    }
  }
  {
#line 1070
  tmp___5 = TOP_SCALAR();
#line 1070
  src = force_string(tmp___5);
#line 1072
  fpat = sep->sub.nodep.x.extra;
  }
#line 1073
  if (fpat->sub.val.slen == 0UL) {
    {
#line 1074
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1074);
#line 1074
    tmp___6 = gettext("patsplit: third argument must be non-null");
#line 1074
    r_fatal((char const   *)tmp___6);
    }
  }
#line 1076
  if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
#line 1077
    if ((unsigned long )sep_arr == (unsigned long )arr) {
      {
#line 1078
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1078);
#line 1078
      tmp___7 = gettext("patsplit: cannot use the same array for second and fourth args");
#line 1078
      r_fatal((char const   *)tmp___7);
      }
    }
#line 1081
    tmp___1 = sep_arr->sub.nodep.x.extra;
    {
#line 1081
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1081
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 1081
        goto while_break;
      }
#line 1082
      if ((unsigned long )tmp___1 == (unsigned long )arr) {
        {
#line 1083
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1083);
#line 1083
        tmp___8 = gettext("patsplit: cannot use a subarray of second arg for fourth arg");
#line 1083
        r_fatal((char const   *)tmp___8);
        }
      }
#line 1081
      tmp___1 = tmp___1->sub.nodep.x.extra;
    }
    while_break: /* CIL Label */ ;
    }
#line 1084
    tmp___1 = arr->sub.nodep.x.extra;
    {
#line 1084
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1084
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 1084
        goto while_break___0;
      }
#line 1085
      if ((unsigned long )tmp___1 == (unsigned long )sep_arr) {
        {
#line 1086
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1086);
#line 1086
        tmp___9 = gettext("patsplit: cannot use a subarray of fourth arg for second arg");
#line 1086
        r_fatal((char const   *)tmp___9);
        }
      }
#line 1084
      tmp___1 = tmp___1->sub.nodep.x.extra;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1087
    (*(*(sep_arr->sub.nodep.l.lp + 5)))(sep_arr, (struct exp_node *)((void *)0));
    }
  }
  {
#line 1089
  (*(*(arr->sub.nodep.l.lp + 5)))(arr, (struct exp_node *)((void *)0));
  }
#line 1091
  if (src->sub.val.slen == 0UL) {
    {
#line 1095
    tmp___1 = (*make_number)((double )0);
    }
  } else {
    {
#line 1097
    rp = re_update(sep);
#line 1098
    s___0 = src->sub.val.sp;
#line 1099
    tmp___10 = fpat_parse_field(9223372036854775807L, & s___0, (int )src->sub.val.slen,
                                fpat, rp, & set_element, arr, sep_arr, (_Bool)0);
#line 1099
    tmp___1 = (*make_number)((double )tmp___10);
    }
  }
  {
#line 1104
  src = POP_SCALAR();
#line 1105
  DEREF(src);
  }
#line 1106
  return (tmp___1);
}
}
#line 1117 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static int fw_alloc  =    4;
#line 1118 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static _Bool warned___5  =    (_Bool)0;
#line 1111 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void set_FIELDWIDTHS(void) 
{ 
  char *scan ;
  char *end ;
  int i___0 ;
  _Bool fatal_error ;
  NODE *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  unsigned long tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 1119
  fatal_error = (_Bool)0;
#line 1122
  if (do_flags & 3) {
#line 1122
    if (! warned___5) {
      {
#line 1123
      warned___5 = (_Bool)1;
#line 1124
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1124);
#line 1124
      tmp___2 = gettext("`FIELDWIDTHS\' is a gawk extension");
#line 1124
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
#line 1126
  if (do_flags & 8) {
#line 1127
    return;
  }
#line 1133
  if ((unsigned long )fields_arr != (unsigned long )((void *)0)) {
    {
#line 1134
    get_field(9223372036854775806L, (Func_ptr *)0);
    }
  }
  {
#line 1136
  parse_field = & fw_parse_field;
#line 1137
  tmp___1 = force_string(FIELDWIDTHS_node->sub.nodep.l.lptr);
#line 1138
  scan = tmp___1->sub.val.sp;
  }
#line 1140
  if ((unsigned long )FIELDWIDTHS == (unsigned long )((void *)0)) {
    {
#line 1141
    tmp___3 = malloc((unsigned long )fw_alloc * sizeof(int ));
#line 1141
    FIELDWIDTHS = (int *)tmp___3;
    }
#line 1141
    if (FIELDWIDTHS) {
#line 1141
      tmp___7 = 1;
    } else {
      {
#line 1141
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1141);
#line 1141
      tmp___4 = __errno_location();
#line 1141
      tmp___5 = strerror(*tmp___4);
#line 1141
      tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1141
      r_fatal((char const   *)tmp___6, "set_FIELDWIDTHS", "FIELDWIDTHS", (long )((unsigned long )fw_alloc * sizeof(int )),
              tmp___5);
#line 1141
      tmp___7 = 0;
      }
    }
  }
#line 1142
  *(FIELDWIDTHS + 0) = 0;
#line 1143
  i___0 = 1;
  {
#line 1143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1145
    if (i___0 + 2 >= fw_alloc) {
      {
#line 1146
      fw_alloc *= 2;
#line 1147
      tmp___9 = realloc((void *)((char *)FIELDWIDTHS), (unsigned long )fw_alloc * sizeof(int ));
#line 1147
      FIELDWIDTHS = (int *)tmp___9;
      }
#line 1147
      if (FIELDWIDTHS) {
#line 1147
        tmp___13 = 1;
      } else {
        {
#line 1147
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1147);
#line 1147
        tmp___10 = __errno_location();
#line 1147
        tmp___11 = strerror(*tmp___10);
#line 1147
        tmp___12 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1147
        r_fatal((char const   *)tmp___12, "set_FIELDWIDTHS", "FIELDWIDTHS", (long )((unsigned long )fw_alloc * sizeof(int )),
                tmp___11);
#line 1147
        tmp___13 = 0;
        }
      }
    }
#line 1150
    *(FIELDWIDTHS + i___0) = -1;
    {
#line 1153
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1153
      tmp___14 = is_blank___0((int )*scan);
      }
#line 1153
      if (! tmp___14) {
#line 1153
        goto while_break___0;
      }
#line 1154
      scan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1156
    if ((int )*scan == 45) {
#line 1157
      fatal_error = (_Bool)1;
#line 1158
      goto while_break;
    }
#line 1160
    if ((int )*scan == 0) {
#line 1161
      goto while_break;
    }
    {
#line 1166
    tmp___15 = __errno_location();
#line 1166
    *tmp___15 = 0;
#line 1167
    tmp___8 = strtoul((char const   */* __restrict  */)scan, (char **/* __restrict  */)(& end),
                      10);
#line 1168
    tmp___16 = __errno_location();
    }
#line 1168
    if (*tmp___16 != 0) {
#line 1172
      fatal_error = (_Bool)1;
#line 1173
      goto while_break;
    } else
#line 1168
    if ((int )*end != 0) {
      {
#line 1168
      tmp___17 = is_blank___0((int )*end);
      }
#line 1168
      if (tmp___17) {
#line 1168
        goto _L;
      } else {
#line 1172
        fatal_error = (_Bool)1;
#line 1173
        goto while_break;
      }
    } else
    _L: /* CIL Label */ 
#line 1168
    if (0UL < tmp___8) {
#line 1168
      if (! (tmp___8 <= 2147483647UL)) {
#line 1172
        fatal_error = (_Bool)1;
#line 1173
        goto while_break;
      }
    } else {
#line 1172
      fatal_error = (_Bool)1;
#line 1173
      goto while_break;
    }
#line 1175
    *(FIELDWIDTHS + i___0) = (int )tmp___8;
#line 1176
    scan = end;
    {
#line 1178
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1178
      tmp___18 = is_blank___0((int )*scan);
      }
#line 1178
      if (! tmp___18) {
#line 1178
        goto while_break___1;
      }
#line 1179
      scan ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1181
    if ((int )*scan == 0) {
#line 1182
      goto while_break;
    }
#line 1143
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1184
  *(FIELDWIDTHS + (i___0 + 1)) = -1;
#line 1186
  update_PROCINFO_str("FS", "FIELDWIDTHS");
  }
#line 1187
  if (fatal_error) {
    {
#line 1188
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1188);
#line 1188
    tmp___19 = gettext("invalid FIELDWIDTHS value, near `%s\'");
#line 1188
    r_fatal((char const   *)tmp___19, scan);
    }
  }
#line 1190
  return;
}
}
#line 1199 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static NODE *save_fs  =    (NODE *)((void *)0);
#line 1200 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static NODE *save_rs___0  =    (NODE *)((void *)0);
#line 1255 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static _Bool warned___6  =    (_Bool)0;
#line 1194 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void set_FS(void) 
{ 
  char buf___7[10] ;
  NODE *fs ;
  _Bool remake_re ;
  field_sep_type tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1201
  remake_re = (_Bool)1;
#line 1207
  if ((unsigned long )fields_arr != (unsigned long )((void *)0)) {
    {
#line 1208
    get_field(9223372036854775806L, (Func_ptr *)0);
    }
  }
#line 1215
  if (save_fs) {
#line 1215
    if ((FS_node->sub.nodep.l.lptr)->sub.val.slen == save_fs->sub.val.slen) {
      {
#line 1215
      tmp___2 = memcmp((void const   *)(FS_node->sub.nodep.l.lptr)->sub.val.sp, (void const   *)save_fs->sub.val.sp,
                       save_fs->sub.val.slen);
      }
#line 1215
      if (tmp___2 == 0) {
#line 1215
        if (save_rs___0) {
#line 1215
          if ((RS_node->sub.nodep.l.lptr)->sub.val.slen == save_rs___0->sub.val.slen) {
            {
#line 1215
            tmp___3 = memcmp((void const   *)(RS_node->sub.nodep.l.lptr)->sub.val.sp,
                             (void const   *)save_rs___0->sub.val.sp, save_rs___0->sub.val.slen);
            }
#line 1215
            if (tmp___3 == 0) {
#line 1221
              if ((unsigned long )FS_regexp != (unsigned long )((void *)0)) {
#line 1222
                if (IGNORECASE) {
#line 1222
                  FS_regexp = FS_re_no_case;
                } else {
#line 1222
                  FS_regexp = FS_re_yes_case;
                }
              }
              {
#line 1225
              tmp___1 = current_field_sep();
              }
#line 1225
              if ((unsigned int )tmp___1 == 0U) {
#line 1226
                return;
              } else {
#line 1228
                remake_re = (_Bool)0;
#line 1229
                goto choose_fs_function;
              }
            }
          }
        }
      }
    }
  }
  {
#line 1233
  unref(save_fs);
#line 1234
  save_fs = dupnode(FS_node->sub.nodep.l.lptr);
#line 1235
  unref(save_rs___0);
#line 1236
  save_rs___0 = dupnode(RS_node->sub.nodep.l.lptr);
#line 1237
  resave_fs = (_Bool)1;
#line 1244
  refree(FS_re_yes_case);
#line 1245
  refree(FS_re_no_case);
#line 1246
  FS_regexp = (Regexp *)((void *)0);
#line 1246
  FS_re_no_case = FS_regexp;
#line 1246
  FS_re_yes_case = FS_re_no_case;
  }
  choose_fs_function: 
  {
#line 1250
  buf___7[0] = (char )'\000';
#line 1251
  default_FS = 0;
#line 1252
  fs = force_string(FS_node->sub.nodep.l.lptr);
  }
#line 1254
  if (! (do_flags & 8)) {
#line 1254
    if (fs->sub.val.slen == 0UL) {
#line 1257
      parse_field = & null_parse_field;
#line 1259
      if (do_flags & 3) {
#line 1259
        if (! warned___6) {
          {
#line 1260
          warned___6 = (_Bool)1;
#line 1261
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1261);
#line 1261
          tmp___4 = gettext("null string for `FS\' is a gawk extension");
#line 1261
          (*lintfunc)((char const   *)tmp___4);
          }
        }
      }
    } else {
#line 1254
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1263
  if (fs->sub.val.slen > 1UL) {
#line 1264
    if (do_flags & 4) {
      {
#line 1265
      tmp___5 = gettext("old awk does not support regexps as value of `FS\'");
#line 1265
      warning((char const   *)tmp___5);
      }
    }
#line 1266
    parse_field = & re_parse_field;
  } else
#line 1267
  if (RS_is_null) {
#line 1269
    parse_field = & sc_parse_field;
#line 1270
    if (fs->sub.val.slen == 1UL) {
#line 1271
      if ((int )*(fs->sub.val.sp + 0) == 32) {
        {
#line 1272
        default_FS = 1;
#line 1273
        strcpy((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"[ \t\n]+");
        }
      } else
#line 1274
      if ((int )*(fs->sub.val.sp + 0) == 92) {
        {
#line 1276
        strcpy((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"[\\\\\n]");
        }
      } else
#line 1277
      if ((int )*(fs->sub.val.sp + 0) != 10) {
        {
#line 1278
        sprintf((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"[%c\n]",
                (int )*(fs->sub.val.sp + 0));
        }
      }
    }
  } else {
#line 1281
    if (do_flags & 16) {
#line 1282
      parse_field = & posix_def_parse_field;
    } else {
#line 1284
      parse_field = & def_parse_field;
    }
#line 1286
    if (fs->sub.val.slen == 1UL) {
#line 1287
      if ((int )*(fs->sub.val.sp + 0) == 32) {
#line 1288
        default_FS = 1;
      } else
#line 1289
      if ((int )*(fs->sub.val.sp + 0) == 92) {
        {
#line 1291
        strcpy((char */* __restrict  */)(buf___7), (char const   */* __restrict  */)"[\\\\]");
        }
      } else {
#line 1293
        parse_field = & sc_parse_field;
      }
    }
  }
#line 1296
  if (remake_re) {
    {
#line 1297
    refree(FS_re_yes_case);
#line 1298
    refree(FS_re_no_case);
#line 1299
    FS_regexp = (Regexp *)((void *)0);
#line 1299
    FS_re_no_case = FS_regexp;
#line 1299
    FS_re_yes_case = FS_re_no_case;
    }
#line 1301
    if ((int )buf___7[0] != 0) {
      {
#line 1302
      tmp___6 = strlen((char const   *)(buf___7));
#line 1302
      FS_re_yes_case = make_regexp((char const   *)(buf___7), tmp___6, (_Bool)0, (_Bool)1,
                                   (_Bool)1);
#line 1303
      tmp___7 = strlen((char const   *)(buf___7));
#line 1303
      FS_re_no_case = make_regexp((char const   *)(buf___7), tmp___7, (_Bool)1, (_Bool)1,
                                  (_Bool)1);
      }
#line 1304
      if (IGNORECASE) {
#line 1304
        FS_regexp = FS_re_no_case;
      } else {
#line 1304
        FS_regexp = FS_re_yes_case;
      }
#line 1305
      parse_field = & re_parse_field;
    } else
#line 1306
    if ((unsigned long )parse_field == (unsigned long )(& re_parse_field)) {
      {
#line 1307
      FS_re_yes_case = make_regexp((char const   *)fs->sub.val.sp, fs->sub.val.slen,
                                   (_Bool)0, (_Bool)1, (_Bool)1);
#line 1308
      FS_re_no_case = make_regexp((char const   *)fs->sub.val.sp, fs->sub.val.slen,
                                  (_Bool)1, (_Bool)1, (_Bool)1);
      }
#line 1309
      if (IGNORECASE) {
#line 1309
        FS_regexp = FS_re_no_case;
      } else {
#line 1309
        FS_regexp = FS_re_yes_case;
      }
    } else {
#line 1311
      FS_regexp = (Regexp *)((void *)0);
#line 1311
      FS_re_no_case = FS_regexp;
#line 1311
      FS_re_yes_case = FS_re_no_case;
    }
  }
#line 1319
  if (fs->sub.val.slen == 1UL) {
#line 1319
    if ((unsigned long )parse_field == (unsigned long )(& re_parse_field)) {
#line 1320
      FS_regexp = FS_re_yes_case;
    }
  }
  {
#line 1322
  update_PROCINFO_str("FS", "FS");
  }
#line 1323
  return;
}
}
#line 1327 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
field_sep_type current_field_sep(void) 
{ 


  {
#line 1330
  if ((unsigned long )parse_field == (unsigned long )(& fw_parse_field)) {
#line 1331
    return ((field_sep_type )1);
  } else
#line 1332
  if ((unsigned long )parse_field == (unsigned long )(& fpat_parse_field)) {
#line 1333
    return ((field_sep_type )2);
  } else {
#line 1335
    return ((field_sep_type )0);
  }
}
}
#line 1340 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void update_PROCINFO_str(char const   *subscript , char const   *str ) 
{ 
  NODE **aptr ;
  NODE *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 1346
  if ((unsigned long )PROCINFO_node == (unsigned long )((void *)0)) {
#line 1347
    return;
  }
  {
#line 1348
  tmp___2 = strlen(subscript);
#line 1348
  tmp___1 = make_str_node(subscript, tmp___2, 0);
#line 1349
  aptr = (*(*(PROCINFO_node->sub.nodep.l.lp + 3)))(PROCINFO_node, tmp___1);
#line 1350
  unref(tmp___1);
#line 1351
  unref(*aptr);
#line 1352
  tmp___3 = strlen(str);
#line 1352
  *aptr = make_str_node(str, tmp___3, 0);
  }
#line 1353
  return;
}
}
#line 1357 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void update_PROCINFO_num(char const   *subscript , double val ) 
{ 
  NODE **aptr ;
  NODE *tmp___1 ;
  size_t tmp___2 ;

  {
#line 1363
  if ((unsigned long )PROCINFO_node == (unsigned long )((void *)0)) {
#line 1364
    return;
  }
  {
#line 1365
  tmp___2 = strlen(subscript);
#line 1365
  tmp___1 = make_str_node(subscript, tmp___2, 0);
#line 1366
  aptr = (*(*(PROCINFO_node->sub.nodep.l.lp + 3)))(PROCINFO_node, tmp___1);
#line 1367
  unref(tmp___1);
#line 1368
  unref(*aptr);
#line 1369
  *aptr = (*make_number)(val);
  }
#line 1370
  return;
}
}
#line 1377 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static _Bool warned___7  =    (_Bool)0;
#line 1378 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static NODE *save_fpat  =    (NODE *)((void *)0);
#line 1374 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
void set_FPAT(void) 
{ 
  _Bool remake_re ;
  NODE *fpat ;
  char *tmp___1 ;
  field_sep_type tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1379
  remake_re = (_Bool)1;
#line 1382
  if (do_flags & 3) {
#line 1382
    if (! warned___7) {
      {
#line 1383
      warned___7 = (_Bool)1;
#line 1384
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c", 1384);
#line 1384
      tmp___1 = gettext("`FPAT\' is a gawk extension");
#line 1384
      (*lintfunc)((char const   *)tmp___1);
      }
    }
  }
#line 1386
  if (do_flags & 8) {
#line 1387
    return;
  }
#line 1393
  if ((unsigned long )fields_arr != (unsigned long )((void *)0)) {
    {
#line 1394
    get_field(9223372036854775806L, (Func_ptr *)0);
    }
  }
#line 1401
  if (save_fpat) {
#line 1401
    if ((FPAT_node->sub.nodep.l.lptr)->sub.val.slen == save_fpat->sub.val.slen) {
      {
#line 1401
      tmp___3 = memcmp((void const   *)(FPAT_node->sub.nodep.l.lptr)->sub.val.sp,
                       (void const   *)save_fpat->sub.val.sp, save_fpat->sub.val.slen);
      }
#line 1401
      if (tmp___3 == 0) {
#line 1404
        if ((unsigned long )FPAT_regexp != (unsigned long )((void *)0)) {
#line 1405
          if (IGNORECASE) {
#line 1405
            FPAT_regexp = FPAT_re_no_case;
          } else {
#line 1405
            FPAT_regexp = FPAT_re_yes_case;
          }
        }
        {
#line 1408
        tmp___2 = current_field_sep();
        }
#line 1408
        if ((unsigned int )tmp___2 == 2U) {
#line 1409
          return;
        } else {
#line 1411
          remake_re = (_Bool)0;
#line 1412
          goto set_fpat_function;
        }
      }
    }
  }
  {
#line 1416
  unref(save_fpat);
#line 1417
  save_fpat = dupnode(FPAT_node->sub.nodep.l.lptr);
#line 1418
  refree(FPAT_re_yes_case);
#line 1419
  refree(FPAT_re_no_case);
#line 1420
  FPAT_regexp = (Regexp *)((void *)0);
#line 1420
  FPAT_re_no_case = FPAT_regexp;
#line 1420
  FPAT_re_yes_case = FPAT_re_no_case;
  }
  set_fpat_function: 
  {
#line 1423
  fpat = force_string(FPAT_node->sub.nodep.l.lptr);
#line 1424
  parse_field = & fpat_parse_field;
  }
#line 1426
  if (remake_re) {
    {
#line 1427
    refree(FPAT_re_yes_case);
#line 1428
    refree(FPAT_re_no_case);
#line 1429
    FPAT_regexp = (Regexp *)((void *)0);
#line 1429
    FPAT_re_no_case = FPAT_regexp;
#line 1429
    FPAT_re_yes_case = FPAT_re_no_case;
#line 1431
    FPAT_re_yes_case = make_regexp((char const   *)fpat->sub.val.sp, fpat->sub.val.slen,
                                   (_Bool)0, (_Bool)1, (_Bool)1);
#line 1432
    FPAT_re_no_case = make_regexp((char const   *)fpat->sub.val.sp, fpat->sub.val.slen,
                                  (_Bool)1, (_Bool)1, (_Bool)1);
    }
#line 1433
    if (IGNORECASE) {
#line 1433
      FPAT_regexp = FPAT_re_no_case;
    } else {
#line 1433
      FPAT_regexp = FPAT_re_yes_case;
    }
  }
  {
#line 1436
  update_PROCINFO_str("FS", "FPAT");
  }
#line 1437
  return;
}
}
#line 1453 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static void incr_scan(char **scanp , size_t len , mbstate_t *mbs___0 ) 
{ 
  size_t mbclen ;

  {
#line 1456
  mbclen = (size_t )0;
#line 1458
  if (gawk_mb_cur_max > 1) {
    {
#line 1459
    mbclen = mbrlen((char const   */* __restrict  */)*scanp, len, (mbstate_t */* __restrict  */)mbs___0);
    }
#line 1460
    if (mbclen == 1UL) {
#line 1465
      mbclen = (size_t )1;
    } else
#line 1460
    if (mbclen == 0xffffffffffffffffUL) {
#line 1465
      mbclen = (size_t )1;
    } else
#line 1460
    if (mbclen == 0xfffffffffffffffeUL) {
#line 1465
      mbclen = (size_t )1;
    } else
#line 1460
    if (mbclen == 0UL) {
#line 1465
      mbclen = (size_t )1;
    }
#line 1467
    *scanp += mbclen;
  } else {
#line 1469
    (*scanp) ++;
  }
#line 1470
  return;
}
}
#line 1577 "/home/wslee/gnu_benchmarks/gawk-4.1.0/field.c"
static long fpat_parse_field(long up_to , char **buf___7 , int len , NODE *fs  __attribute__((__unused__)) ,
                             Regexp *rp , void (*set)(long  , char * , long  , NODE * ) ,
                             NODE *n , NODE *sep_arr , _Bool in_middle ) 
{ 
  char *scan ;
  long nf ;
  char *start ;
  char *end ;
  int regex_flags ;
  _Bool need_to_set_sep ;
  _Bool non_empty ;
  _Bool eosflag ;
  mbstate_t mbs___0 ;
  int tmp___1 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;

  {
#line 1588
  scan = *buf___7;
#line 1589
  nf = parse_high_water;
#line 1591
  end = scan + len;
#line 1592
  regex_flags = 1;
#line 1599
  if (gawk_mb_cur_max > 1) {
    {
#line 1600
    memset((void *)(& mbs___0), 0, sizeof(mbstate_t ));
    }
  }
#line 1603
  if (up_to == 9223372036854775807L) {
#line 1604
    nf = 0L;
  }
#line 1606
  if (len == 0) {
#line 1607
    return (nf);
  }
#line 1609
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 1610
    rp = FPAT_regexp;
  }
#line 1612
  if (in_middle) {
#line 1613
    regex_flags |= 2;
#line 1614
    non_empty = (_Bool )rp->non_empty;
  } else {
#line 1616
    non_empty = (_Bool)0;
  }
#line 1618
  eosflag = (_Bool)0;
#line 1619
  need_to_set_sep = (_Bool)1;
#line 1620
  start = scan;
  {
#line 1621
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1621
    tmp___1 = research(rp, scan, 0, (size_t )(end - scan), regex_flags);
    }
#line 1621
    if (tmp___1 != -1) {
#line 1621
      if (! (nf < up_to)) {
#line 1621
        goto while_break;
      }
    } else {
#line 1621
      goto while_break;
    }
#line 1624
    if (*(rp->regs.end + 0) > *(rp->regs.start + 0)) {
#line 1625
      non_empty = (_Bool)1;
#line 1626
      if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
#line 1626
        if (need_to_set_sep) {
#line 1627
          if (*(rp->regs.start + 0) == 0) {
            {
#line 1628
            set_element(nf, start, 0L, sep_arr);
            }
          } else {
            {
#line 1630
            set_element(nf, start, (long )*(rp->regs.start + 0), sep_arr);
            }
          }
        }
      }
      {
#line 1636
      nf ++;
#line 1636
      (*set)(nf, scan + *(rp->regs.start + 0), (long )(*(rp->regs.end + 0) - *(rp->regs.start + 0)),
             n);
#line 1641
      scan += *(rp->regs.end + 0);
      }
#line 1642
      if ((unsigned long )scan >= (unsigned long )end) {
#line 1643
        goto while_break;
      }
#line 1644
      need_to_set_sep = (_Bool)1;
    } else
#line 1645
    if (non_empty) {
#line 1651
      non_empty = (_Bool)0;
#line 1652
      if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
        {
#line 1653
        need_to_set_sep = (_Bool)0;
#line 1654
        set_element(nf, start, 1L, sep_arr);
        }
      }
      {
#line 1656
      incr_scan(& scan, (size_t )(end - scan), & mbs___0);
      }
    } else {
#line 1659
      if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
#line 1659
        if (need_to_set_sep) {
#line 1660
          if (*(rp->regs.start + 0) == 0) {
            {
#line 1661
            set_element(nf, start, 0L, sep_arr);
            }
          } else {
            {
#line 1663
            set_element(nf, start, (long )*(rp->regs.start + 0), sep_arr);
            }
          }
        }
      }
      {
#line 1667
      need_to_set_sep = (_Bool)1;
#line 1668
      nf ++;
#line 1668
      (*set)(nf, scan, 0L, n);
      }
#line 1669
      if (! non_empty) {
#line 1669
        if (! eosflag) {
#line 1670
          if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
            {
#line 1671
            set_element(nf, start, 1L, sep_arr);
#line 1672
            need_to_set_sep = (_Bool)0;
            }
          }
        }
      }
#line 1675
      if (*(rp->regs.start + 0) == 0) {
        {
#line 1676
        incr_scan(& scan, (size_t )(end - scan), & mbs___0);
        }
      } else {
#line 1678
        scan += *(rp->regs.start + 0);
      }
#line 1680
      non_empty = (_Bool)0;
    }
#line 1682
    if ((unsigned long )scan >= (unsigned long )end) {
#line 1683
      if (eosflag) {
#line 1684
        goto while_break;
      } else {
#line 1686
        eosflag = (_Bool)1;
      }
    }
#line 1689
    start = scan;
  }
  while_break: /* CIL Label */ ;
  }
#line 1691
  if ((unsigned long )scan < (unsigned long )end) {
#line 1692
    if ((unsigned long )sep_arr != (unsigned long )((void *)0)) {
      {
#line 1693
      set_element(nf, scan, end - scan, sep_arr);
      }
    }
  }
#line 1696
  *buf___7 = scan;
#line 1697
  rp->non_empty = (short )non_empty;
#line 1698
  return (nf);
}
}
#line 1155 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *frame_ptr ;
#line 1363
void track_ext_func(char const   *name ) ;
#line 1453
NODE *do_ext(int nargs ) ;
#line 1455
NODE *load_old_ext(SRCFILE *s___0 , char const   *init_func , char const   *fini_func ,
                   NODE *obj ) ;
#line 1458
void make_old_builtin(char const   *name , NODE *(*func___1)(int  ) , int count ) ;
#line 57 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 65
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2))) dlsym)(void * __restrict  __handle ,
                                                                                    char const   * __restrict  __name ) ;
#line 83
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
#line 46 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
static _Bool is_letter(unsigned char c ) 
{ 


  {
  {
#line 60
  if ((int )c == 95) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 90) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 89) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 88) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 87) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 86) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 85) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 84) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 83) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 82) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 81) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 80) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 79) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 78) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 77) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 76) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 75) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 74) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 73) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 72) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 71) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 70) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 69) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 68) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 67) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 66) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 65) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 122) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 121) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 120) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 119) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 118) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 117) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 116) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 115) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 114) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 113) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 112) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 111) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 110) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 109) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 108) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 107) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 106) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 105) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 104) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 103) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 102) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 101) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 100) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 99) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 98) {
#line 60
    goto case_95;
  }
#line 60
  if ((int )c == 97) {
#line 60
    goto case_95;
  }
#line 62
  goto switch_default;
  case_95: /* CIL Label */ 
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 61
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 63
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 69 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
static _Bool is_identifier_char(unsigned char c ) 
{ 
  _Bool tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  {
#line 72
  tmp___1 = is_letter(c);
  }
#line 72
  if (tmp___1) {
#line 72
    tmp___3 = 1;
  } else {
    {
#line 72
    tmp___2 = __ctype_b_loc();
    }
#line 72
    if ((int const   )*(*tmp___2 + (int )c) & 2048) {
#line 72
      tmp___3 = 1;
    } else {
#line 72
      tmp___3 = 0;
    }
  }
#line 72
  return ((_Bool )tmp___3);
}
}
#line 80 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
void load_ext(char const   *lib_name ) 
{ 
  int (*install_func___0)(gawk_api_t const   * const   , awk_ext_id_t  ) ;
  void *dl ;
  int flags___0 ;
  int *gpl_compat ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 85
  flags___0 = 1;
#line 88
  if (do_flags & 2048) {
    {
#line 89
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 89);
#line 89
    tmp___1 = gettext("extensions are not allowed in sandbox mode");
#line 89
    r_fatal((char const   *)tmp___1);
    }
  }
#line 91
  if (do_flags & 8) {
    {
#line 92
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 92);
#line 92
    tmp___2 = gettext("-l / @load are gawk extensions");
#line 92
    r_fatal((char const   *)tmp___2);
    }
  } else
#line 91
  if (do_flags & 16) {
    {
#line 92
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 92);
#line 92
    tmp___2 = gettext("-l / @load are gawk extensions");
#line 92
    r_fatal((char const   *)tmp___2);
    }
  }
#line 94
  if ((unsigned long )lib_name == (unsigned long )((void *)0)) {
    {
#line 95
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 95);
#line 95
    tmp___3 = gettext("load_ext: received NULL lib_name");
#line 95
    r_fatal((char const   *)tmp___3);
    }
  }
  {
#line 97
  dl = dlopen(lib_name, flags___0);
  }
#line 97
  if ((unsigned long )dl == (unsigned long )((void *)0)) {
    {
#line 98
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 98);
#line 98
    tmp___4 = dlerror();
#line 98
    tmp___5 = gettext("load_ext: cannot open library `%s\' (%s)\n");
#line 98
    r_fatal((char const   *)tmp___5, lib_name, tmp___4);
    }
  }
  {
#line 102
  tmp___6 = dlsym((void */* __restrict  */)dl, (char const   */* __restrict  */)"plugin_is_GPL_compatible");
#line 102
  gpl_compat = (int *)tmp___6;
  }
#line 103
  if ((unsigned long )gpl_compat == (unsigned long )((void *)0)) {
    {
#line 104
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 104);
#line 104
    tmp___7 = dlerror();
#line 104
    tmp___8 = gettext("load_ext: library `%s\': does not define `plugin_is_GPL_compatible\' (%s)\n");
#line 104
    r_fatal((char const   *)tmp___8, lib_name, tmp___7);
    }
  }
  {
#line 107
  tmp___9 = dlsym((void */* __restrict  */)dl, (char const   */* __restrict  */)"dl_load");
#line 107
  install_func___0 = (int (*)(gawk_api_t const   * const   , awk_ext_id_t  ))tmp___9;
  }
#line 109
  if ((unsigned long )install_func___0 == (unsigned long )((void *)0)) {
    {
#line 110
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 110);
#line 110
    tmp___10 = dlerror();
#line 110
    tmp___11 = gettext("load_ext: library `%s\': cannot call function `%s\' (%s)\n");
#line 110
    r_fatal((char const   *)tmp___11, lib_name, "dl_load", tmp___10);
    }
  }
  {
#line 113
  tmp___13 = (*install_func___0)((gawk_api_t const   */* const  */)(& api_impl), (void *)0);
  }
#line 113
  if (tmp___13 == 0) {
    {
#line 114
    tmp___12 = gettext("load_ext: library `%s\' initialization routine `%s\' failed\n");
#line 114
    warning((char const   *)tmp___12, lib_name, "dl_load");
    }
  }
#line 116
  return;
}
}
#line 120 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
NODE *do_ext(int nargs ) 
{ 
  NODE *obj ;
  NODE *init ;
  NODE *fini ;
  NODE *ret ;
  SRCFILE *s___0 ;
  char *init_func ;
  char *fini_func ;
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;

  {
#line 123
  init = (NODE *)((void *)0);
#line 123
  fini = (NODE *)((void *)0);
#line 123
  ret = (NODE *)((void *)0);
#line 125
  init_func = (char *)((void *)0);
#line 126
  fini_func = (char *)((void *)0);
#line 128
  if (nargs == 3) {
    {
#line 129
    tmp___1 = POP_SCALAR();
#line 129
    fini = force_string(tmp___1);
#line 130
    fini_func = fini->sub.val.sp;
    }
  }
#line 132
  if (nargs >= 2) {
    {
#line 133
    tmp___2 = POP_SCALAR();
#line 133
    init = force_string(tmp___2);
#line 134
    init_func = init->sub.val.sp;
    }
  }
  {
#line 136
  tmp___3 = POP_SCALAR();
#line 136
  obj = force_string(tmp___3);
#line 138
  s___0 = add_srcfile(5, obj->sub.val.sp, srcfiles, (_Bool *)((void *)0), (int *)((void *)0));
  }
#line 139
  if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
    {
#line 140
    ret = load_old_ext(s___0, (char const   *)init_func, (char const   *)fini_func,
                       obj);
    }
  }
  {
#line 142
  DEREF(obj);
  }
#line 143
  if ((unsigned long )fini != (unsigned long )((void *)0)) {
    {
#line 144
    DEREF(fini);
    }
  }
#line 145
  if ((unsigned long )init != (unsigned long )((void *)0)) {
    {
#line 146
    DEREF(init);
    }
  }
#line 147
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 148
    ret = dupnode(Nnull_string);
    }
  }
#line 149
  return (ret);
}
}
#line 154 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
NODE *load_old_ext(SRCFILE *s___0 , char const   *init_func , char const   *fini_func ,
                   NODE *obj ) 
{ 
  NODE *(*func___1)(NODE * , void * ) ;
  NODE *tmp___1 ;
  void *dl ;
  int flags___0 ;
  int *gpl_compat ;
  char const   *lib_name ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 160
  flags___0 = 1;
#line 162
  lib_name = (char const   *)s___0->fullpath;
#line 164
  if ((unsigned long )init_func == (unsigned long )((void *)0)) {
#line 165
    init_func = "dlload";
  } else
#line 164
  if ((int const   )*(init_func + 0) == 0) {
#line 165
    init_func = "dlload";
  }
#line 167
  if ((unsigned long )fini_func == (unsigned long )((void *)0)) {
#line 168
    fini_func = "dlunload";
  } else
#line 167
  if ((int const   )*(fini_func + 0) == 0) {
#line 168
    fini_func = "dlunload";
  }
#line 170
  if (do_flags & 2048) {
    {
#line 171
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 171);
#line 171
    tmp___2 = gettext("extensions are not allowed in sandbox mode");
#line 171
    r_fatal((char const   *)tmp___2);
    }
  }
#line 173
  if (do_flags & 8) {
    {
#line 174
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 174);
#line 174
    tmp___3 = gettext("`extension\' is a gawk extension");
#line 174
    r_fatal((char const   *)tmp___3);
    }
  } else
#line 173
  if (do_flags & 16) {
    {
#line 174
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 174);
#line 174
    tmp___3 = gettext("`extension\' is a gawk extension");
#line 174
    r_fatal((char const   *)tmp___3);
    }
  }
#line 176
  if ((unsigned long )lib_name == (unsigned long )((void *)0)) {
    {
#line 177
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 177);
#line 177
    tmp___4 = gettext("load_ext: received NULL lib_name");
#line 177
    r_fatal((char const   *)tmp___4);
    }
  }
  {
#line 179
  dl = dlopen((char const   *)s___0->fullpath, flags___0);
  }
#line 179
  if ((unsigned long )dl == (unsigned long )((void *)0)) {
    {
#line 180
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 180);
#line 180
    tmp___5 = dlerror();
#line 180
    tmp___6 = gettext("extension: cannot open library `%s\' (%s)");
#line 180
    r_fatal((char const   *)tmp___6, lib_name, tmp___5);
    }
  }
  {
#line 184
  tmp___7 = dlsym((void */* __restrict  */)dl, (char const   */* __restrict  */)"plugin_is_GPL_compatible");
#line 184
  gpl_compat = (int *)tmp___7;
  }
#line 185
  if ((unsigned long )gpl_compat == (unsigned long )((void *)0)) {
    {
#line 186
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 186);
#line 186
    tmp___8 = dlerror();
#line 186
    tmp___9 = gettext("extension: library `%s\': does not define `plugin_is_GPL_compatible\' (%s)");
#line 186
    r_fatal((char const   *)tmp___9, lib_name, tmp___8);
    }
  }
  {
#line 188
  tmp___10 = dlsym((void */* __restrict  */)dl, (char const   */* __restrict  */)init_func);
#line 188
  func___1 = (NODE *(*)(NODE * , void * ))tmp___10;
  }
#line 189
  if ((unsigned long )func___1 == (unsigned long )((void *)0)) {
    {
#line 190
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 190);
#line 190
    tmp___11 = dlerror();
#line 190
    tmp___12 = gettext("extension: library `%s\': cannot call function `%s\' (%s)");
#line 190
    r_fatal((char const   *)tmp___12, lib_name, init_func, tmp___11);
    }
  }
#line 193
  if ((unsigned long )obj == (unsigned long )((void *)0)) {
    {
#line 194
    tmp___13 = strlen(lib_name);
#line 194
    obj = make_str_node(lib_name, tmp___13, 0);
#line 195
    tmp___1 = (*func___1)(obj, dl);
#line 196
    unref(tmp___1);
#line 197
    unref(obj);
#line 198
    tmp___1 = (NODE *)((void *)0);
    }
  } else {
    {
#line 200
    tmp___1 = (*func___1)(obj, dl);
    }
  }
  {
#line 202
  tmp___14 = dlsym((void */* __restrict  */)dl, (char const   */* __restrict  */)fini_func);
#line 202
  s___0->fini_func = (void (*)(void))tmp___14;
  }
#line 203
  return (tmp___1);
}
}
#line 209 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
awk_bool_t make_builtin(awk_ext_func_t const   *funcinfo ) 
{ 
  NODE *symbol ;
  NODE *f ;
  INSTRUCTION *b___0 ;
  char const   *sp___0 ;
  char c ;
  char const   *name ;
  int count ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 216
  name = (char const   *)funcinfo->name;
#line 217
  count = (int )funcinfo->num_expected_args;
#line 219
  sp___0 = name;
#line 220
  if ((unsigned long )sp___0 == (unsigned long )((void *)0)) {
    {
#line 221
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 221);
#line 221
    tmp___1 = gettext("make_builtin: missing function name");
#line 221
    r_fatal((char const   *)tmp___1);
    }
  } else
#line 220
  if ((int const   )*sp___0 == 0) {
    {
#line 221
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 221);
#line 221
    tmp___1 = gettext("make_builtin: missing function name");
#line 221
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 223
  tmp___2 = is_letter((unsigned char )*sp___0);
  }
#line 223
  if (! tmp___2) {
#line 224
    return ((awk_bool_t )0);
  }
#line 226
  sp___0 ++;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    tmp___4 = sp___0;
#line 228
    sp___0 ++;
#line 228
    c = (char )*tmp___4;
#line 228
    if (! ((int )c != 0)) {
#line 228
      goto while_break;
    }
    {
#line 229
    tmp___3 = is_identifier_char((unsigned char )c);
    }
#line 229
    if (! tmp___3) {
#line 230
      return ((awk_bool_t )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  f = lookup(name);
  }
#line 235
  if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 236
    if ((unsigned int )f->type == 8U) {
      {
#line 238
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 238);
#line 238
      tmp___5 = gettext("make_builtin: can\'t redefine function `%s\'");
#line 238
      r_fatal((char const   *)tmp___5, name);
      }
    } else
#line 239
    if ((unsigned int )f->type == 9U) {
#line 241
      if (do_flags & 3) {
        {
#line 242
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 242);
#line 242
        tmp___6 = gettext("make_builtin: function `%s\' already defined");
#line 242
        (*lintfunc)((char const   *)tmp___6, name);
        }
      }
#line 243
      return ((awk_bool_t )0);
    } else {
      {
#line 246
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 246);
#line 246
      tmp___7 = gettext("make_builtin: function name `%s\' previously defined");
#line 246
      r_fatal((char const   *)tmp___7, name);
      }
    }
  } else {
    {
#line 247
    tmp___9 = check_special(name);
    }
#line 247
    if (tmp___9 >= 0) {
      {
#line 248
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 248);
#line 248
      tmp___8 = gettext("make_builtin: can\'t use gawk built-in `%s\' as function name");
#line 248
      r_fatal((char const   *)tmp___8, name);
      }
    }
  }
#line 250
  if (count < 0) {
    {
#line 251
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 251);
#line 251
    tmp___10 = gettext("make_builtin: negative argument count for function `%s\'");
#line 251
    r_fatal((char const   *)tmp___10, name);
    }
  }
  {
#line 254
  b___0 = bcalloc((OPCODE )104, 1, 0);
#line 255
  b___0->d.efptr = (awk_value_t *(*)(int  , awk_value_t * ))funcinfo->function;
#line 256
  b___0->x.xl = (long )count;
#line 260
  tmp___11 = strlen(name);
#line 260
  tmp___12 = estrdup(name, tmp___11);
#line 260
  symbol = install_symbol(tmp___12, (NODETYPE )9);
#line 261
  symbol->sub.nodep.r.iptr = b___0;
#line 262
  track_ext_func(name);
  }
#line 263
  return ((awk_bool_t )1);
}
}
#line 268 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
void make_old_builtin(char const   *name , NODE *(*func___1)(int  ) , int count ) 
{ 
  NODE *symbol ;
  NODE *f ;
  INSTRUCTION *b___0 ;
  char const   *sp___0 ;
  char c ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  _Bool tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 276
  sp___0 = name;
#line 277
  if ((unsigned long )sp___0 == (unsigned long )((void *)0)) {
    {
#line 278
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 278);
#line 278
    tmp___1 = gettext("extension: missing function name");
#line 278
    r_fatal((char const   *)tmp___1);
    }
  } else
#line 277
  if ((int const   )*sp___0 == 0) {
    {
#line 278
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 278);
#line 278
    tmp___1 = gettext("extension: missing function name");
#line 278
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    tmp___5 = sp___0;
#line 280
    sp___0 ++;
#line 280
    c = (char )*tmp___5;
#line 280
    if (! ((int )c != 0)) {
#line 280
      goto while_break;
    }
#line 281
    if ((unsigned long )sp___0 == (unsigned long )(name + 1)) {
#line 281
      if ((int )c != 95) {
        {
#line 281
        tmp___3 = __ctype_b_loc();
        }
#line 281
        if ((int const   )*(*tmp___3 + (int )((unsigned char )c)) & 1024) {
#line 281
          goto _L___0;
        } else {
          {
#line 283
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 283);
#line 283
          tmp___2 = gettext("extension: illegal character `%c\' in function name `%s\'");
#line 283
          r_fatal((char const   *)tmp___2, (int )c, name);
          }
        }
      } else {
#line 281
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 281
    if ((unsigned long )sp___0 > (unsigned long )(name + 1)) {
      {
#line 281
      tmp___4 = is_identifier_char((unsigned char )c);
      }
#line 281
      if (! tmp___4) {
        {
#line 283
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 283);
#line 283
        tmp___2 = gettext("extension: illegal character `%c\' in function name `%s\'");
#line 283
        r_fatal((char const   *)tmp___2, (int )c, name);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 286
  f = lookup(name);
  }
#line 288
  if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 289
    if ((unsigned int )f->type == 8U) {
      {
#line 291
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 291);
#line 291
      tmp___6 = gettext("extension: can\'t redefine function `%s\'");
#line 291
      r_fatal((char const   *)tmp___6, name);
      }
    } else
#line 292
    if ((unsigned int )f->type == 9U) {
#line 294
      if (do_flags & 3) {
        {
#line 295
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 295);
#line 295
        tmp___7 = gettext("extension: function `%s\' already defined");
#line 295
        (*lintfunc)((char const   *)tmp___7, name);
        }
      }
#line 296
      return;
    } else {
      {
#line 299
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 299);
#line 299
      tmp___8 = gettext("extension: function name `%s\' previously defined");
#line 299
      r_fatal((char const   *)tmp___8, name);
      }
    }
  } else {
    {
#line 300
    tmp___10 = check_special(name);
    }
#line 300
    if (tmp___10 >= 0) {
      {
#line 301
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 301);
#line 301
      tmp___9 = gettext("extension: can\'t use gawk built-in `%s\' as function name");
#line 301
      r_fatal((char const   *)tmp___9, name);
      }
    }
  }
#line 303
  if (count < 0) {
    {
#line 304
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 304);
#line 304
    tmp___11 = gettext("make_builtin: negative argument count for function `%s\'");
#line 304
    r_fatal((char const   *)tmp___11, name);
    }
  }
  {
#line 307
  b___0 = bcalloc((OPCODE )104, 1, 0);
#line 308
  b___0->d.fptr = func___1;
#line 309
  b___0->x.xl = (long )count;
#line 313
  tmp___12 = strlen(name);
#line 313
  tmp___13 = estrdup(name, tmp___12);
#line 313
  symbol = install_symbol(tmp___13, (NODETYPE )10);
#line 314
  symbol->sub.nodep.r.iptr = b___0;
  }
#line 315
  return;
}
}
#line 320 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
NODE *get_argument(int i___0 ) 
{ 
  NODE *t ;
  int arg_count ;
  int pcount ;
  INSTRUCTION *pc ;

  {
#line 327
  pc = (stack_ptr->rptr)->sub.nodep.r.iptr;
#line 328
  pcount = (int )(pc + 1)->x.xl;
#line 329
  arg_count = (int )pc->x.xl;
#line 331
  if (i___0 < 0) {
#line 332
    return ((NODE *)((void *)0));
  } else
#line 331
  if (i___0 >= pcount) {
#line 332
    return ((NODE *)((void *)0));
  } else
#line 331
  if (i___0 >= arg_count) {
#line 332
    return ((NODE *)((void *)0));
  }
#line 334
  t = (stack_ptr - (arg_count - i___0))->rptr;
#line 335
  if ((unsigned int )t->type == 7U) {
#line 336
    t = *(frame_ptr->sub.nodep.r.av + t->sub.nodep.l.ll);
  }
#line 338
  if ((unsigned int )t->type == 11U) {
#line 339
    if ((unsigned int )(t->sub.nodep.l.lptr)->type == 4U) {
#line 341
      t->type = (NODETYPE )4;
#line 342
      t->sub.nodep.l.lptr = Nnull_string;
#line 343
      return (t);
    }
#line 345
    return (t->sub.nodep.l.lptr);
  }
#line 347
  if ((unsigned int )t->type == 4U) {
#line 348
    return (Nnull_string);
  }
#line 350
  return (t);
}
}
#line 359 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
NODE *get_actual_argument(int i___0 , _Bool optional , _Bool want_array ) 
{ 
  NODE *t ;
  char *fname ;
  int pcount ;
  INSTRUCTION *pc ;
  char *tmp___1 ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 367
  pc = (stack_ptr->rptr)->sub.nodep.r.iptr;
#line 368
  fname = (pc + 1)->d.name;
#line 369
  pcount = (int )(pc + 1)->x.xl;
#line 371
  t = get_argument(i___0);
  }
#line 372
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 373
    if (i___0 >= pcount) {
      {
#line 374
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 374);
#line 374
      tmp___1 = gettext("function `%s\' defined to take no more than %d argument(s)");
#line 374
      r_fatal((char const   *)tmp___1, fname, pcount);
      }
    }
#line 376
    if (! optional) {
      {
#line 377
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 377);
#line 377
      tmp___2 = gettext("function `%s\': missing argument #%d");
#line 377
      r_fatal((char const   *)tmp___2, fname, i___0 + 1);
      }
    }
#line 379
    return ((NODE *)((void *)0));
  }
#line 382
  if ((unsigned int )t->type == 6U) {
#line 383
    if (want_array) {
      {
#line 384
      tmp___3 = force_array(t, (_Bool)0);
      }
#line 384
      return (tmp___3);
    } else {
      {
#line 386
      t->type = (NODETYPE )4;
#line 387
      t->sub.nodep.l.lptr = dupnode(Nnull_string);
      }
#line 388
      return (t->sub.nodep.l.lptr);
    }
  }
#line 392
  if (want_array) {
#line 393
    if ((unsigned int )t->type != 5U) {
      {
#line 394
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 394);
#line 394
      tmp___4 = gettext("function `%s\': argument #%d: attempt to use scalar as an array");
#line 394
      r_fatal((char const   *)tmp___4, fname, i___0 + 1);
      }
    }
  } else
#line 397
  if ((unsigned int )t->type != 1U) {
    {
#line 398
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c", 398);
#line 398
    tmp___5 = gettext("function `%s\': argument #%d: attempt to use array as a scalar");
#line 398
    r_fatal((char const   *)tmp___5, fname, i___0 + 1);
    }
  }
#line 402
  return (t);
}
}
#line 418 "/home/wslee/gnu_benchmarks/gawk-4.1.0/ext.c"
void close_extensions(void) 
{ 
  SRCFILE *s___0 ;

  {
#line 423
  s___0 = srcfiles->next;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! ((unsigned long )s___0 != (unsigned long )srcfiles)) {
#line 423
      goto while_break;
    }
#line 424
    if ((unsigned int )s___0->stype == 5U) {
#line 424
      if (s___0->fini_func) {
        {
#line 425
        (*(s___0->fini_func))();
        }
      }
    }
#line 423
    s___0 = s___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return;
}
}
#line 45 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 149 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcoll)(char const   *__s1 ,
                                                                                      char const   *__s2 )  __attribute__((__pure__)) ;
#line 189 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int wcscoll(wchar_t const   *__s1 , wchar_t const   *__s2 ) ;
#line 284
extern  __attribute__((__nothrow__)) size_t wcslen(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 1033 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int OFSlen  ;
#line 1035 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int ORSlen  ;
#line 1038 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int CONVFMTidx  ;
#line 1039 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int OFMTidx  ;
#line 1052 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int (*interpret)(INSTRUCTION * )  ;
#line 1155 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *frame_ptr  ;
#line 1156 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
STACK_ITEM *stack_bottom  ;
#line 1157 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
STACK_ITEM *stack_top  ;
#line 1348
NODE *concat_exp(int nargs , _Bool do_subsep ) ;
#line 1353
void do_delete(NODE *symbol , int nsubs ) ;
#line 1354
void do_delete_loop(NODE *symbol , NODE **lhs ) ;
#line 1386
void do_printf(int nargs , int redirtype ) ;
#line 1393
void do_print(int nargs , int redirtype ) ;
#line 1394
void do_print_rec(int nargs , int redirtype ) ;
#line 1403
NODE *do_sub(int nargs , unsigned int flags___0 ) ;
#line 1417
int strncasecmpmbs(unsigned char const   *s1 , unsigned char const   *s2 , size_t n ) ;
#line 1421
void PUSH_CODE(INSTRUCTION *cp ) ;
#line 1422
INSTRUCTION *POP_CODE(void) ;
#line 1444
void load_casetable(void) ;
#line 1445
double calc_exp(double x1 , double x2 ) ;
#line 1446
char const   *opcode2str(OPCODE op ) ;
#line 1449
STACK_ITEM *grow_stack(void) ;
#line 1714 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
__inline static NODE *POP_ARRAY(void) 
{ 
  NODE *t ;
  STACK_ITEM *tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;

  {
#line 1717
  tmp___1 = stack_ptr;
#line 1717
  stack_ptr --;
#line 1717
  t = tmp___1->rptr;
#line 1719
  if ((unsigned int )t->type == 5U) {
#line 1719
    tmp___3 = t;
  } else {
    {
#line 1719
    tmp___2 = force_array(t, (_Bool)1);
#line 1719
    tmp___3 = tmp___2;
    }
  }
#line 1719
  return (tmp___3);
}
}
#line 29 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
extern double pow(double x , double y ) ;
#line 31
extern double fmod(double x , double y ) ;
#line 32 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
NODE **fcall_list  =    (NODE **)((void *)0);
#line 33 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
long fcall_count  =    0L;
#line 34 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
int currule  =    0;
#line 35 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
IOBUF *curfile  =    (IOBUF *)((void *)0);
#line 36 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
_Bool exiting  =    (_Bool)0;
#line 40 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static int num_exec_hook  =    0;
#line 41 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static Func_pre_exec pre_execute[10]  ;
#line 42 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static void (*post_execute)(INSTRUCTION * )  =    (void (*)(INSTRUCTION * ))((void *)0);
#line 44
void frame_popped(void) ;
#line 51 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static NODE *node_Boolean[2]  ;
#line 77 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
char casetable[256]  = 
#line 77
  {      (char )'\000',      (char )'\001',      (char )'\002',      (char )'\003', 
        (char )'\004',      (char )'\005',      (char )'\006',      (char )'\a', 
        (char )'\b',      (char )'\t',      (char )'\n',      (char )'\v', 
        (char )'\f',      (char )'\r',      (char )'\016',      (char )'\017', 
        (char )'\020',      (char )'\021',      (char )'\022',      (char )'\023', 
        (char )'\024',      (char )'\025',      (char )'\026',      (char )'\027', 
        (char )'\030',      (char )'\031',      (char )'\032',      (char )'\033', 
        (char )'\034',      (char )'\035',      (char )'\036',      (char )'\037', 
        (char )' ',      (char )'!',      (char )'\"',      (char )'#', 
        (char )'$',      (char )'%',      (char )'&',      (char )'\'', 
        (char )'(',      (char )')',      (char )'*',      (char )'+', 
        (char )',',      (char )'-',      (char )'.',      (char )'/', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )':',      (char )';', 
        (char )'<',      (char )'=',      (char )'>',      (char )'?', 
        (char )'@',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'[', 
        (char )'\\',      (char )']',      (char )'^',      (char )'_', 
        (char )'`',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'r',      (char )'s', 
        (char )'t',      (char )'u',      (char )'v',      (char )'w', 
        (char )'x',      (char )'y',      (char )'z',      (char )'{', 
        (char )'|',      (char )'}',      (char )'~',      (char )'\177', 
        (char )'\200',      (char )'\201',      (char )'\202',      (char )'\203', 
        (char )'\204',      (char )'\205',      (char )'\206',      (char )'\207', 
        (char )'\210',      (char )'\211',      (char )'\212',      (char )'\213', 
        (char )'\214',      (char )'\215',      (char )'\216',      (char )'\217', 
        (char )'\220',      (char )'\221',      (char )'\222',      (char )'\223', 
        (char )'\224',      (char )'\225',      (char )'\226',      (char )'\227', 
        (char )'\230',      (char )'\231',      (char )'\232',      (char )'\233', 
        (char )'\234',      (char )'\235',      (char )'\236',      (char )'\237', 
        (char )'\240',      (char )'\241',      (char )'\242',      (char )'\243', 
        (char )'\244',      (char )'\245',      (char )'\246',      (char )'\247', 
        (char )'\250',      (char )'\251',      (char )'\252',      (char )'\253', 
        (char )'\254',      (char )'\255',      (char )'\256',      (char )'\257', 
        (char )'\260',      (char )'\261',      (char )'\262',      (char )'\263', 
        (char )'\264',      (char )'\265',      (char )'\266',      (char )'\267', 
        (char )'\270',      (char )'\271',      (char )'\272',      (char )'\273', 
        (char )'\274',      (char )'\275',      (char )'\276',      (char )'\277', 
        (char )'\340',      (char )'\341',      (char )'\342',      (char )'\343', 
        (char )'\344',      (char )'\345',      (char )'\346',      (char )'\347', 
        (char )'\350',      (char )'\351',      (char )'\352',      (char )'\353', 
        (char )'\354',      (char )'\355',      (char )'\356',      (char )'\357', 
        (char )'\360',      (char )'\361',      (char )'\362',      (char )'\363', 
        (char )'\364',      (char )'\365',      (char )'\366',      (char )'\327', 
        (char )'\370',      (char )'\371',      (char )'\372',      (char )'\373', 
        (char )'\374',      (char )'\375',      (char )'\376',      (char )'\337', 
        (char )'\340',      (char )'\341',      (char )'\342',      (char )'\343', 
        (char )'\344',      (char )'\345',      (char )'\346',      (char )'\347', 
        (char )'\350',      (char )'\351',      (char )'\352',      (char )'\353', 
        (char )'\354',      (char )'\355',      (char )'\356',      (char )'\357', 
        (char )'\360',      (char )'\361',      (char )'\362',      (char )'\363', 
        (char )'\364',      (char )'\365',      (char )'\366',      (char )'\367', 
        (char )'\370',      (char )'\371',      (char )'\372',      (char )'\373', 
        (char )'\374',      (char )'\375',      (char )'\376',      (char )'\377'};
#line 206 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static _Bool loaded  =    (_Bool)0;
#line 200 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void load_casetable(void) 
{ 
  int i___0 ;
  char *cp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 208
  if (loaded) {
#line 209
    return;
  } else
#line 208
  if (do_flags & 8) {
#line 209
    return;
  }
  {
#line 211
  loaded = (_Bool)1;
#line 212
  cp = setlocale(0, (char const   *)((void *)0));
  }
#line 215
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 216
    return;
  } else {
    {
#line 215
    tmp___1 = strcmp((char const   *)cp, "C");
    }
#line 215
    if (tmp___1 == 0) {
#line 216
      return;
    } else {
      {
#line 215
      tmp___2 = strcmp((char const   *)cp, "POSIX");
      }
#line 215
      if (tmp___2 == 0) {
#line 216
        return;
      }
    }
  }
#line 219
  i___0 = 128;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (i___0 <= 255)) {
#line 219
      goto while_break;
    }
    {
#line 220
    tmp___4 = __ctype_b_loc();
    }
#line 220
    if ((int const   )*(*tmp___4 + i___0) & 1024) {
      {
#line 220
      tmp___5 = __ctype_b_loc();
      }
#line 220
      if ((int const   )*(*tmp___5 + i___0) & 512) {
        {
#line 220
        tmp___6 = toupper(i___0);
        }
#line 220
        if (i___0 != tmp___6) {
          {
#line 221
          tmp___3 = toupper(i___0);
#line 221
          casetable[i___0] = (char )tmp___3;
          }
        }
      }
    }
#line 219
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 232 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static char const   * const  nodetypes[20]  = 
#line 232
  {      (char const   */* const  */)"Node_illegal",      (char const   */* const  */)"Node_val",      (char const   */* const  */)"Node_regex",      (char const   */* const  */)"Node_dynregex", 
        (char const   */* const  */)"Node_var",      (char const   */* const  */)"Node_var_array",      (char const   */* const  */)"Node_var_new",      (char const   */* const  */)"Node_param_list", 
        (char const   */* const  */)"Node_func",      (char const   */* const  */)"Node_ext_func",      (char const   */* const  */)"Node_old_ext_func",      (char const   */* const  */)"Node_array_ref", 
        (char const   */* const  */)"Node_array_tree",      (char const   */* const  */)"Node_array_leaf",      (char const   */* const  */)"Node_dump_array",      (char const   */* const  */)"Node_arrayfor", 
        (char const   */* const  */)"Node_frame",      (char const   */* const  */)"Node_instruction",      (char const   */* const  */)"Node_final --- this should never appear",      (char const   */* const  */)((void *)0)};
#line 261 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static struct optypetab optypes[117]  = 
#line 261
  {      {(char *)"Op_illegal", (char *)((void *)0)}, 
        {(char *)"Op_times", (char *)" * "}, 
        {(char *)"Op_times_i", (char *)" * "}, 
        {(char *)"Op_quotient", (char *)" / "}, 
        {(char *)"Op_quotient_i", (char *)" / "}, 
        {(char *)"Op_mod", (char *)" % "}, 
        {(char *)"Op_mod_i", (char *)" % "}, 
        {(char *)"Op_plus", (char *)" + "}, 
        {(char *)"Op_plus_i", (char *)" + "}, 
        {(char *)"Op_minus", (char *)" - "}, 
        {(char *)"Op_minus_i", (char *)" - "}, 
        {(char *)"Op_exp", (char *)" ^ "}, 
        {(char *)"Op_exp_i", (char *)" ^ "}, 
        {(char *)"Op_concat", (char *)" "}, 
        {(char *)"Op_line_range", (char *)((void *)0)}, 
        {(char *)"Op_cond_pair", (char *)", "}, 
        {(char *)"Op_subscript", (char *)"[]"}, 
        {(char *)"Op_sub_array", (char *)"[]"}, 
        {(char *)"Op_preincrement", (char *)"++"}, 
        {(char *)"Op_predecrement", (char *)"--"}, 
        {(char *)"Op_postincrement", (char *)"++"}, 
        {(char *)"Op_postdecrement", (char *)"--"}, 
        {(char *)"Op_unary_minus", (char *)"-"}, 
        {(char *)"Op_field_spec", (char *)"$"}, 
        {(char *)"Op_not", (char *)"! "}, 
        {(char *)"Op_assign", (char *)" = "}, 
        {(char *)"Op_store_var", (char *)" = "}, 
        {(char *)"Op_store_sub", (char *)" = "}, 
        {(char *)"Op_store_field", (char *)" = "}, 
        {(char *)"Op_assign_times", (char *)" *= "}, 
        {(char *)"Op_assign_quotient", (char *)" /= "}, 
        {(char *)"Op_assign_mod", (char *)" %= "}, 
        {(char *)"Op_assign_plus", (char *)" += "}, 
        {(char *)"Op_assign_minus", (char *)" -= "}, 
        {(char *)"Op_assign_exp", (char *)" ^= "}, 
        {(char *)"Op_assign_concat", (char *)" "}, 
        {(char *)"Op_and", (char *)" && "}, 
        {(char *)"Op_and_final", (char *)((void *)0)}, 
        {(char *)"Op_or", (char *)" || "}, 
        {(char *)"Op_or_final", (char *)((void *)0)}, 
        {(char *)"Op_equal", (char *)" == "}, 
        {(char *)"Op_notequal", (char *)" != "}, 
        {(char *)"Op_less", (char *)" < "}, 
        {(char *)"Op_greater", (char *)" > "}, 
        {(char *)"Op_leq", (char *)" <= "}, 
        {(char *)"Op_geq", (char *)" >= "}, 
        {(char *)"Op_match", (char *)" ~ "}, 
        {(char *)"Op_match_rec", (char *)((void *)0)}, 
        {(char *)"Op_nomatch", (char *)" !~ "}, 
        {(char *)"Op_rule", (char *)((void *)0)}, 
        {(char *)"Op_K_case", (char *)"case"}, 
        {(char *)"Op_K_default", (char *)"default"}, 
        {(char *)"Op_K_break", (char *)"break"}, 
        {(char *)"Op_K_continue", (char *)"continue"}, 
        {(char *)"Op_K_print", (char *)"print"}, 
        {(char *)"Op_K_print_rec", (char *)"print"}, 
        {(char *)"Op_K_printf", (char *)"printf"}, 
        {(char *)"Op_K_next", (char *)"next"}, 
        {(char *)"Op_K_exit", (char *)"exit"}, 
        {(char *)"Op_K_return", (char *)"return"}, 
        {(char *)"Op_K_delete", (char *)"delete"}, 
        {(char *)"Op_K_delete_loop", (char *)((void *)0)}, 
        {(char *)"Op_K_getline_redir", (char *)"getline"}, 
        {(char *)"Op_K_getline", (char *)"getline"}, 
        {(char *)"Op_K_nextfile", (char *)"nextfile"}, 
        {(char *)"Op_builtin", (char *)((void *)0)}, 
        {(char *)"Op_sub_builtin", (char *)((void *)0)}, 
        {(char *)"Op_ext_builtin", (char *)((void *)0)}, 
        {(char *)"Op_old_ext_builtin", (char *)((void *)0)}, 
        {(char *)"Op_in_array", (char *)" in "}, 
        {(char *)"Op_func_call", (char *)((void *)0)}, 
        {(char *)"Op_indirect_func_call", (char *)((void *)0)}, 
        {(char *)"Op_push", (char *)((void *)0)}, 
        {(char *)"Op_push_arg", (char *)((void *)0)}, 
        {(char *)"Op_push_i", (char *)((void *)0)}, 
        {(char *)"Op_push_re", (char *)((void *)0)}, 
        {(char *)"Op_push_array", (char *)((void *)0)}, 
        {(char *)"Op_push_param", (char *)((void *)0)}, 
        {(char *)"Op_push_lhs", (char *)((void *)0)}, 
        {(char *)"Op_subscript_lhs", (char *)"[]"}, 
        {(char *)"Op_field_spec_lhs", (char *)"$"}, 
        {(char *)"Op_no_op", (char *)((void *)0)}, 
        {(char *)"Op_pop", (char *)((void *)0)}, 
        {(char *)"Op_jmp", (char *)((void *)0)}, 
        {(char *)"Op_jmp_true", (char *)((void *)0)}, 
        {(char *)"Op_jmp_false", (char *)((void *)0)}, 
        {(char *)"Op_get_record", (char *)((void *)0)}, 
        {(char *)"Op_newfile", (char *)((void *)0)}, 
        {(char *)"Op_arrayfor_init", (char *)((void *)0)}, 
        {(char *)"Op_arrayfor_incr", (char *)((void *)0)}, 
        {(char *)"Op_arrayfor_final", (char *)((void *)0)}, 
        {(char *)"Op_var_update", (char *)((void *)0)}, 
        {(char *)"Op_var_assign", (char *)((void *)0)}, 
        {(char *)"Op_field_assign", (char *)((void *)0)}, 
        {(char *)"Op_subscript_assign", (char *)((void *)0)}, 
        {(char *)"Op_after_beginfile", (char *)((void *)0)}, 
        {(char *)"Op_after_endfile", (char *)((void *)0)}, 
        {(char *)"Op_func", (char *)((void *)0)}, 
        {(char *)"Op_exec_count", (char *)((void *)0)}, 
        {(char *)"Op_breakpoint", (char *)((void *)0)}, 
        {(char *)"Op_lint", (char *)((void *)0)}, 
        {(char *)"Op_atexit", (char *)((void *)0)}, 
        {(char *)"Op_stop", (char *)((void *)0)}, 
        {(char *)"Op_token", (char *)((void *)0)}, 
        {(char *)"Op_symbol", (char *)((void *)0)}, 
        {(char *)"Op_list", (char *)((void *)0)}, 
        {(char *)"Op_K_do", (char *)"do"}, 
        {(char *)"Op_K_for", (char *)"for"}, 
        {(char *)"Op_K_arrayfor", (char *)"for"}, 
        {(char *)"Op_K_while", (char *)"while"}, 
        {(char *)"Op_K_switch", (char *)"switch"}, 
        {(char *)"Op_K_if", (char *)"if"}, 
        {(char *)"Op_K_else", (char *)"else"}, 
        {(char *)"Op_K_function", (char *)"function"}, 
        {(char *)"Op_cond_exp", (char *)((void *)0)}, 
        {(char *)"Op_final --- this should never appear", (char *)((void *)0)}, 
        {(char *)((void *)0), (char *)((void *)0)}};
#line 389 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static char buf___1[40]  ;
#line 386 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
char const   *nodetype2str(NODETYPE type ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp3 ;

  {
#line 391
  if ((unsigned int )type >= 0U) {
#line 391
    if ((unsigned int )type <= 18U) {
#line 392
      return ((char const   *)nodetypes[(int )type]);
    }
  }
  {
#line 394
  tmp___1 = gettext("unknown nodetype %d");
#line 394
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)tmp___1,
          (int )type);
  }
#line 395
  return ((char const   *)(buf___1));
}
}
#line 400 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
char const   *opcode2str(OPCODE op ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 403
  if ((unsigned int )op >= 0U) {
#line 403
    if ((unsigned int )op < 115U) {
#line 404
      return ((char const   *)optypes[(int )op].desc);
    }
  }
  {
#line 405
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 405);
#line 405
  tmp___1 = gettext("unknown opcode %d");
#line 405
  r_fatal((char const   *)tmp___1, (int )op);
  }
#line 406
  return ((char const   *)((void *)0));
}
}
#line 409 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
char const   *op2str(OPCODE op ) 
{ 
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 412
  if ((unsigned int )op >= 0U) {
#line 412
    if ((unsigned int )op < 115U) {
#line 413
      if ((unsigned long )optypes[(int )op].operator != (unsigned long )((void *)0)) {
#line 414
        return ((char const   *)optypes[(int )op].operator);
      } else {
        {
#line 416
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 416);
#line 416
        tmp___1 = gettext("opcode %s not an operator or keyword");
#line 416
        r_fatal((char const   *)tmp___1, optypes[(int )op].desc);
        }
      }
    } else {
      {
#line 419
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 419);
#line 419
      tmp___2 = gettext("unknown opcode %d");
#line 419
      r_fatal((char const   *)tmp___2, (int )op);
      }
    }
  } else {
    {
#line 419
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 419);
#line 419
    tmp___2 = gettext("unknown opcode %d");
#line 419
    r_fatal((char const   *)tmp___2, (int )op);
    }
  }
#line 420
  return ((char const   *)((void *)0));
}
}
#line 429 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static struct flagtab  const  values___2[17]  = 
#line 429
  {      {1, "MALLOC"}, 
        {2, "STRING"}, 
        {4, "STRCUR"}, 
        {8, "NUMCUR"}, 
        {16, "NUMBER"}, 
        {32, "MAYBE_NUM"}, 
        {64, "FIELD"}, 
        {128, "INTLSTR"}, 
        {256, "NUMINT"}, 
        {512, "INTIND"}, 
        {1024, "WSTRCUR"}, 
        {2048, "MPFN"}, 
        {4096, "MPZN"}, 
        {16384, "ARRAYMAXED"}, 
        {32768, "HALFHAT"}, 
        {65536, "XARRAY"}, 
        {0, (char const   *)((void *)0)}};
#line 426 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
char const   *flags2str(int flagval ) 
{ 
  char const   *tmp___1 ;

  {
  {
#line 449
  tmp___1 = genflags2str(flagval, values___2);
  }
#line 449
  return (tmp___1);
}
}
#line 457 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static char buffer[8192]  ;
#line 454 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
char const   *genflags2str(int flagval , struct flagtab  const  *tab ) 
{ 
  char *sp___0 ;
  int i___0 ;
  int space_left ;
  int space_needed ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 461
  sp___0 = buffer;
#line 462
  space_left = 8192;
#line 463
  i___0 = 0;
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    if (! ((unsigned long )(tab + i___0)->name != (unsigned long )((void *)0))) {
#line 463
      goto while_break;
    }
#line 464
    if ((flagval & (int )(tab + i___0)->val) != 0) {
      {
#line 469
      tmp___1 = strlen((char const   *)(tab + i___0)->name);
#line 469
      space_needed = (int )(tmp___1 + (size_t )((unsigned long )sp___0 != (unsigned long )(buffer)));
      }
#line 470
      if (space_left <= space_needed) {
        {
#line 471
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 471);
#line 471
        tmp___2 = gettext("buffer overflow in genflags2str");
#line 471
        r_fatal((char const   *)tmp___2);
        }
      }
#line 473
      if ((unsigned long )sp___0 != (unsigned long )(buffer)) {
#line 474
        tmp___3 = sp___0;
#line 474
        sp___0 ++;
#line 474
        *tmp___3 = (char )'|';
#line 475
        space_left --;
      }
      {
#line 477
      strcpy((char */* __restrict  */)sp___0, (char const   */* __restrict  */)(tab + i___0)->name);
#line 479
      tmp___4 = strlen((char const   *)sp___0);
#line 479
      space_left = (int )((size_t )space_left - tmp___4);
#line 480
      tmp___5 = strlen((char const   *)sp___0);
#line 480
      sp___0 += tmp___5;
      }
    }
#line 463
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  *sp___0 = (char )'\000';
#line 485
  return ((char const   *)(buffer));
}
}
#line 490 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static int posix_compare(NODE *s1 , NODE *s2 ) 
{ 
  int ret ;
  char save1 ;
  char save2 ;
  size_t l ;
  char b1[2] ;
  char b2[2] ;
  char *p1 ;
  char *p2 ;
  size_t i___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  wchar_t b1___0[2] ;
  wchar_t b2___0[2] ;
  wchar_t *p1___0 ;
  wchar_t *p2___0 ;
  size_t i___1 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
#line 493
  ret = 0;
#line 495
  l = (size_t )0;
#line 497
  save1 = *(s1->sub.val.sp + s1->sub.val.slen);
#line 498
  *(s1->sub.val.sp + s1->sub.val.slen) = (char )'\000';
#line 500
  save2 = *(s2->sub.val.sp + s2->sub.val.slen);
#line 501
  *(s2->sub.val.sp + s2->sub.val.slen) = (char )'\000';
#line 503
  if (gawk_mb_cur_max == 1) {
    {
#line 504
    tmp___1 = strlen((char const   *)s1->sub.val.sp);
    }
#line 504
    if (tmp___1 == s1->sub.val.slen) {
      {
#line 504
      tmp___2 = strlen((char const   *)s2->sub.val.sp);
      }
#line 504
      if (tmp___2 == s2->sub.val.slen) {
        {
#line 505
        ret = strcoll((char const   *)s1->sub.val.sp, (char const   *)s2->sub.val.sp);
        }
      } else {
#line 504
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 511
      if (s1->sub.val.slen < s2->sub.val.slen) {
#line 512
        l = s1->sub.val.slen;
      } else {
#line 514
        l = s2->sub.val.slen;
      }
#line 516
      b2[1] = (char )'\000';
#line 516
      b1[1] = b2[1];
#line 517
      ret = 0;
#line 517
      i___0 = (size_t )ret;
#line 517
      p1 = s1->sub.val.sp;
#line 517
      p2 = s2->sub.val.sp;
      {
#line 517
      while (1) {
        while_continue: /* CIL Label */ ;
#line 517
        if (ret == 0) {
#line 517
          if (! (i___0 < l)) {
#line 517
            goto while_break;
          }
        } else {
#line 517
          goto while_break;
        }
        {
#line 520
        b1[0] = *p1;
#line 521
        b2[0] = *p2;
#line 522
        ret = strcoll((char const   *)(b1), (char const   *)(b2));
#line 517
        p1 ++;
#line 517
        p2 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 533
    str2wstr(s1, (size_t **)((void *)0));
#line 534
    str2wstr(s2, (size_t **)((void *)0));
#line 536
    tmp___3 = wcslen((wchar_t const   *)s1->sub.val.wsp);
    }
#line 536
    if (tmp___3 == s1->sub.val.wslen) {
      {
#line 536
      tmp___4 = wcslen((wchar_t const   *)s2->sub.val.wsp);
      }
#line 536
      if (tmp___4 == s2->sub.val.wslen) {
        {
#line 537
        ret = wcscoll((wchar_t const   *)s1->sub.val.wsp, (wchar_t const   *)s2->sub.val.wsp);
        }
      } else {
#line 536
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 543
      if (s1->sub.val.wslen < s2->sub.val.wslen) {
#line 544
        l = s1->sub.val.wslen;
      } else {
#line 546
        l = s2->sub.val.wslen;
      }
#line 548
      b2___0[1] = 0;
#line 548
      b1___0[1] = b2___0[1];
#line 549
      ret = 0;
#line 549
      i___1 = (size_t )ret;
#line 549
      p1___0 = s1->sub.val.wsp;
#line 549
      p2___0 = s2->sub.val.wsp;
      {
#line 549
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 549
        if (ret == 0) {
#line 549
          if (! (i___1 < l)) {
#line 549
            goto while_break___0;
          }
        } else {
#line 549
          goto while_break___0;
        }
        {
#line 552
        b1___0[0] = *p1___0;
#line 553
        b2___0[0] = *p2___0;
#line 554
        ret = wcscoll((wchar_t const   *)(b1___0), (wchar_t const   *)(b2___0));
#line 549
        p1___0 ++;
#line 549
        p2___0 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 564
  *(s1->sub.val.sp + s1->sub.val.slen) = save1;
#line 565
  *(s2->sub.val.sp + s2->sub.val.slen) = save2;
#line 566
  return (ret);
}
}
#line 572 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
int cmp_nodes(NODE *t1 , NODE *t2 ) 
{ 
  int ret ;
  size_t len1 ;
  size_t len2 ;
  int l ;
  int ldiff ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char const   *cp1 ;
  unsigned char const   *cp2 ;
  int tmp___3 ;

  {
#line 575
  ret = 0;
#line 579
  if ((unsigned long )t1 == (unsigned long )t2) {
#line 580
    return (0);
  }
#line 582
  if ((t1->flags & 32U) != 0U) {
    {
#line 583
    force_number(t1);
    }
  }
#line 584
  if ((t2->flags & 32U) != 0U) {
    {
#line 585
    force_number(t2);
    }
  }
#line 586
  if ((t1->flags & 512U) != 0U) {
    {
#line 587
    t1 = force_string(t1);
    }
  }
#line 588
  if ((t2->flags & 512U) != 0U) {
    {
#line 589
    t2 = force_string(t2);
    }
  }
#line 591
  if ((t1->flags & 16U) != 0U) {
#line 591
    if ((t2->flags & 16U) != 0U) {
      {
#line 592
      tmp___1 = (*cmp_numbers)((NODE const   *)t1, (NODE const   *)t2);
      }
#line 592
      return (tmp___1);
    }
  }
  {
#line 594
  force_string(t1);
#line 595
  force_string(t2);
#line 596
  len1 = t1->sub.val.slen;
#line 597
  len2 = t2->sub.val.slen;
#line 598
  ldiff = (int )(len1 - len2);
  }
#line 599
  if (len1 == 0UL) {
#line 600
    return (ldiff);
  } else
#line 599
  if (len2 == 0UL) {
#line 600
    return (ldiff);
  }
#line 602
  if (do_flags & 16) {
    {
#line 603
    tmp___2 = posix_compare(t1, t2);
    }
#line 603
    return (tmp___2);
  }
#line 605
  if (ldiff <= 0) {
#line 605
    l = (int )len1;
  } else {
#line 605
    l = (int )len2;
  }
#line 606
  if (IGNORECASE) {
#line 607
    cp1 = (unsigned char const   *)t1->sub.val.sp;
#line 608
    cp2 = (unsigned char const   *)t2->sub.val.sp;
#line 611
    if (gawk_mb_cur_max > 1) {
      {
#line 612
      ret = strncasecmpmbs(cp1, cp2, (size_t )l);
      }
    } else {
#line 617
      ret = 0;
      {
#line 617
      while (1) {
        while_continue: /* CIL Label */ ;
#line 617
        tmp___3 = l;
#line 617
        l --;
#line 617
        if (tmp___3 > 0) {
#line 617
          if (! (ret == 0)) {
#line 617
            goto while_break;
          }
        } else {
#line 617
          goto while_break;
        }
#line 618
        ret = (int )casetable[*cp1] - (int )casetable[*cp2];
#line 617
        cp1 ++;
#line 617
        cp2 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 620
    ret = memcmp((void const   *)t1->sub.val.sp, (void const   *)t2->sub.val.sp, (size_t )l);
    }
  }
#line 622
  if (ret == 0) {
#line 622
    ret = ldiff;
  } else {
#line 622
    ret = ret;
  }
#line 623
  return (ret);
}
}
#line 631 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static long max_fcall  ;
#line 628 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static void push_frame(NODE *f ) 
{ 
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 635
  fcall_count ++;
#line 636
  if ((unsigned long )fcall_list == (unsigned long )((void *)0)) {
    {
#line 637
    max_fcall = 10L;
#line 638
    tmp___1 = malloc((unsigned long )(max_fcall + 1L) * sizeof(NODE *));
#line 638
    fcall_list = (NODE **)tmp___1;
    }
#line 638
    if (fcall_list) {
#line 638
      tmp___5 = 1;
    } else {
      {
#line 638
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 638);
#line 638
      tmp___2 = __errno_location();
#line 638
      tmp___3 = strerror(*tmp___2);
#line 638
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 638
      r_fatal((char const   *)tmp___4, "push_frame", "fcall_list", (long )((unsigned long )(max_fcall + 1L) * sizeof(NODE *)),
              tmp___3);
#line 638
      tmp___5 = 0;
      }
    }
  } else
#line 639
  if (fcall_count == max_fcall) {
    {
#line 640
    max_fcall *= 2L;
#line 641
    tmp___6 = realloc((void *)((char *)fcall_list), (unsigned long )(max_fcall + 1L) * sizeof(NODE *));
#line 641
    fcall_list = (NODE **)tmp___6;
    }
#line 641
    if (fcall_list) {
#line 641
      tmp___10 = 1;
    } else {
      {
#line 641
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 641);
#line 641
      tmp___7 = __errno_location();
#line 641
      tmp___8 = strerror(*tmp___7);
#line 641
      tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 641
      r_fatal((char const   *)tmp___9, "push_frame", "fcall_list", (long )((unsigned long )(max_fcall + 1L) * sizeof(NODE *)),
              tmp___8);
#line 641
      tmp___10 = 0;
      }
    }
  }
#line 644
  if (fcall_count > 1L) {
    {
#line 645
    memmove((void *)(fcall_list + 2), (void const   *)(fcall_list + 1), (unsigned long )(fcall_count - 1L) * sizeof(NODE *));
    }
  }
#line 646
  *(fcall_list + 1) = f;
#line 647
  return;
}
}
#line 652 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static void pop_frame(void) 
{ 


  {
#line 655
  if (fcall_count > 1L) {
    {
#line 656
    memmove((void *)(fcall_list + 1), (void const   *)(fcall_list + 2), (unsigned long )(fcall_count - 1L) * sizeof(NODE *));
    }
  }
#line 657
  fcall_count --;
#line 659
  if (do_flags & 8192) {
    {
#line 660
    frame_popped();
    }
  }
#line 661
  return;
}
}
#line 666 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void dump_fcall_stack(FILE *fp___0 ) 
{ 
  NODE *f ;
  NODE *func___1 ;
  long i___0 ;
  long j ;
  long k ;
  char *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 670
  i___0 = 0L;
#line 670
  k = 0L;
#line 672
  if (fcall_count == 0L) {
#line 673
    return;
  }
  {
#line 674
  tmp___1 = gettext("\n\t# Function Call Stack:\n\n");
#line 674
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)tmp___1);
#line 677
  func___1 = frame_ptr->sub.nodep.x.extra;
#line 678
  j = 0L;
  }
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 678
    if (! ((unsigned long )j <= frame_ptr->sub.nodep.cnt)) {
#line 678
      goto while_break;
    }
    {
#line 679
    tmp___2 = k;
#line 679
    k ++;
#line 679
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\t# %3ld. %s\n",
            tmp___2, func___1->sub.nodep.name);
#line 678
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  i___0 = 1L;
  {
#line 682
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 682
    if (! (i___0 < fcall_count)) {
#line 682
      goto while_break___0;
    }
#line 683
    f = *(fcall_list + i___0);
#line 684
    func___1 = f->sub.nodep.x.extra;
#line 685
    j = 0L;
    {
#line 685
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 685
      if (! ((unsigned long )j <= f->sub.nodep.cnt)) {
#line 685
        goto while_break___1;
      }
      {
#line 686
      tmp___3 = k;
#line 686
      k ++;
#line 686
      fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\t# %3ld. %s\n",
              tmp___3, func___1->sub.nodep.name);
#line 685
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 682
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 689
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\t# %3ld. -- main --\n",
          k);
  }
#line 690
  return;
}
}
#line 698 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static _Bool warned___8  =    (_Bool)0;
#line 695 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void set_IGNORECASE(void) 
{ 
  NODE *n ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 699
  n = IGNORECASE_node->sub.nodep.l.lptr;
#line 701
  if (do_flags & 3) {
#line 701
    goto _L;
  } else
#line 701
  if (do_flags & 8) {
    _L: /* CIL Label */ 
#line 701
    if (! warned___8) {
      {
#line 702
      warned___8 = (_Bool)1;
#line 703
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 703);
#line 703
      tmp___1 = gettext("`IGNORECASE\' is a gawk extension");
#line 703
      (*lintfunc)((char const   *)tmp___1);
      }
    }
  }
  {
#line 705
  load_casetable();
  }
#line 706
  if (do_flags & 8) {
#line 707
    IGNORECASE = 0;
  } else
#line 708
  if ((n->flags & 6U) != 0U) {
#line 709
    if ((n->flags & 32U) == 0U) {
      {
#line 710
      force_string(n);
#line 711
      IGNORECASE = n->sub.val.slen > 0UL;
      }
    } else {
      {
#line 713
      force_number(n);
      }
#line 714
      if (n->flags & 2048U) {
#line 714
        tmp___4 = n->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 1UL);
      } else {
#line 714
        if (n->flags & 4096U) {
#line 714
          if (n->sub.val.nm.mpi[0]._mp_size < 0) {
#line 714
            tmp___2 = -1;
          } else {
#line 714
            tmp___2 = n->sub.val.nm.mpi[0]._mp_size > 0;
          }
#line 714
          tmp___3 = tmp___2 == 0;
        } else {
#line 714
          tmp___3 = n->sub.val.nm.fltnum == 0.0;
        }
#line 714
        tmp___4 = tmp___3;
      }
#line 714
      if (tmp___4) {
#line 714
        tmp___5 = 0;
      } else {
#line 714
        tmp___5 = 1;
      }
#line 714
      IGNORECASE = tmp___5;
    }
  } else
#line 716
  if ((n->flags & 24U) != 0U) {
#line 717
    if (n->flags & 2048U) {
#line 717
      tmp___8 = n->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 1UL);
    } else {
#line 717
      if (n->flags & 4096U) {
#line 717
        if (n->sub.val.nm.mpi[0]._mp_size < 0) {
#line 717
          tmp___6 = -1;
        } else {
#line 717
          tmp___6 = n->sub.val.nm.mpi[0]._mp_size > 0;
        }
#line 717
        tmp___7 = tmp___6 == 0;
      } else {
#line 717
        tmp___7 = n->sub.val.nm.fltnum == 0.0;
      }
#line 717
      tmp___8 = tmp___7;
    }
#line 717
    if (tmp___8) {
#line 717
      tmp___9 = 0;
    } else {
#line 717
      tmp___9 = 1;
    }
#line 717
    IGNORECASE = tmp___9;
  } else {
#line 719
    IGNORECASE = 0;
  }
  {
#line 721
  set_RS();
  }
#line 722
  return;
}
}
#line 729 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static _Bool warned___9  =    (_Bool)0;
#line 726 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void set_BINMODE(void) 
{ 
  char *p ;
  NODE *v ;
  char *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 731
  v = BINMODE_node->sub.nodep.l.lptr;
#line 733
  if (do_flags & 3) {
#line 733
    goto _L;
  } else
#line 733
  if (do_flags & 8) {
    _L: /* CIL Label */ 
#line 733
    if (! warned___9) {
      {
#line 734
      warned___9 = (_Bool)1;
#line 735
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 735);
#line 735
      tmp___1 = gettext("`BINMODE\' is a gawk extension");
#line 735
      (*lintfunc)((char const   *)tmp___1);
      }
    }
  }
#line 737
  if (do_flags & 8) {
#line 738
    BINMODE = 0;
  } else
#line 739
  if ((v->flags & 16U) != 0U) {
    {
#line 740
    force_number(v);
    }
#line 741
    if (v->flags & 2048U) {
      {
#line 741
      tmp___2 = mpfr_get_si((mpfr_srcptr )(v->sub.val.nm.mpnum), ROUND_MODE);
#line 741
      BINMODE = (int )tmp___2;
      }
    } else {
#line 741
      if (v->flags & 4096U) {
        {
#line 741
        tmp___3 = __gmpz_get_si((mpz_srcptr )(v->sub.val.nm.mpi));
#line 741
        tmp___4 = tmp___3;
        }
      } else {
#line 741
        tmp___4 = (long )v->sub.val.nm.fltnum;
      }
#line 741
      BINMODE = (int )tmp___4;
    }
#line 743
    if (BINMODE < 0) {
#line 744
      BINMODE = 0;
    } else
#line 745
    if (BINMODE > 3) {
#line 746
      BINMODE = 3;
    }
  } else
#line 747
  if ((v->flags & 2U) != 0U) {
#line 748
    p = v->sub.val.sp;
    {
#line 757
    if (v->sub.val.slen == 1UL) {
#line 757
      goto case_1;
    }
#line 777
    if (v->sub.val.slen == 2UL) {
#line 777
      goto case_2;
    }
#line 791
    goto bad_value;
    case_1: /* CIL Label */ 
    {
#line 762
    if ((int )*(p + 0) == 51) {
#line 762
      goto case_51;
    }
#line 762
    if ((int )*(p + 0) == 50) {
#line 762
      goto case_51;
    }
#line 762
    if ((int )*(p + 0) == 49) {
#line 762
      goto case_51;
    }
#line 762
    if ((int )*(p + 0) == 48) {
#line 762
      goto case_51;
    }
#line 765
    if ((int )*(p + 0) == 114) {
#line 765
      goto case_114;
    }
#line 768
    if ((int )*(p + 0) == 119) {
#line 768
      goto case_119;
    }
#line 771
    goto switch_default;
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 763
    BINMODE = (int )*(p + 0) - 48;
#line 764
    goto switch_break___0;
    case_114: /* CIL Label */ 
#line 766
    BINMODE = 1;
#line 767
    goto switch_break___0;
    case_119: /* CIL Label */ 
#line 769
    BINMODE = 2;
#line 770
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 772
    BINMODE = 3;
#line 773
    goto bad_value;
#line 774
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 776
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 779
    if ((int )*(p + 0) == 114) {
#line 779
      goto case_114___0;
    }
#line 784
    if ((int )*(p + 0) == 119) {
#line 784
      goto case_119___0;
    }
#line 778
    goto switch_break___1;
    case_114___0: /* CIL Label */ 
#line 780
    BINMODE = 3;
#line 781
    if ((int )*(p + 1) != 119) {
#line 782
      goto bad_value;
    }
#line 783
    goto switch_break___1;
    case_119___0: /* CIL Label */ 
#line 785
    BINMODE = 3;
#line 786
    if ((int )*(p + 1) != 114) {
#line 787
      goto bad_value;
    }
#line 788
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 790
    goto switch_break;
    bad_value: 
    switch_default___0: /* CIL Label */ 
    {
#line 793
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 793);
#line 793
    tmp___5 = gettext("BINMODE value `%s\' is invalid, treated as 3");
#line 793
    (*lintfunc)((char const   *)tmp___5, p);
    }
#line 794
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 797
    BINMODE = 3;
  }
#line 798
  return;
}
}
#line 802 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void set_OFS(void) 
{ 


  {
  {
#line 805
  OFS_node->sub.nodep.l.lptr = force_string(OFS_node->sub.nodep.l.lptr);
#line 806
  OFS = (OFS_node->sub.nodep.l.lptr)->sub.val.sp;
#line 807
  OFSlen = (int )(OFS_node->sub.nodep.l.lptr)->sub.val.slen;
#line 808
  *(OFS + OFSlen) = (char )'\000';
  }
#line 809
  return;
}
}
#line 813 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void set_ORS(void) 
{ 


  {
  {
#line 816
  ORS_node->sub.nodep.l.lptr = force_string(ORS_node->sub.nodep.l.lptr);
#line 817
  ORS = (ORS_node->sub.nodep.l.lptr)->sub.val.sp;
#line 818
  ORSlen = (int )(ORS_node->sub.nodep.l.lptr)->sub.val.slen;
#line 819
  *(ORS + ORSlen) = (char )'\000';
  }
#line 820
  return;
}
}
#line 824 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
NODE **fmt_list  =    (NODE **)((void *)0);
#line 825
static int fmt_ok(NODE *n ) ;
#line 826
static int fmt_index(NODE *n ) ;
#line 837 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static char const   float_formats[7]  = {      (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'E', 
        (char const   )'F',      (char const   )'G',      (char const   )'\000'};
#line 840 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static char const   flags[6]  = {      (char const   )' ',      (char const   )'+',      (char const   )'-',      (char const   )'#', 
        (char const   )'\'',      (char const   )'\000'};
#line 828 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static int fmt_ok(NODE *n ) 
{ 
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  char const   *p ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 831
  tmp___2 = force_string(n);
#line 831
  tmp___1 = tmp___2;
#line 832
  p = (char const   *)tmp___1->sub.val.sp;
#line 845
  tmp___3 = p;
#line 845
  p ++;
  }
#line 845
  if ((int const   )*tmp___3 != 37) {
#line 846
    return (0);
  }
  {
#line 847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    if (*p) {
      {
#line 847
      tmp___4 = strchr(flags, (int )*p);
      }
#line 847
      if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 847
        goto while_break;
      }
    } else {
#line 847
      goto while_break;
    }
#line 848
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 849
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 849
    if (*p) {
      {
#line 849
      tmp___5 = __ctype_b_loc();
      }
#line 849
      if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 2048)) {
#line 849
        goto while_break___0;
      }
    } else {
#line 849
      goto while_break___0;
    }
#line 850
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 851
  if ((int const   )*p == 0) {
#line 852
    return (0);
  } else
#line 851
  if ((int const   )*p != 46) {
    {
#line 851
    tmp___6 = __ctype_b_loc();
    }
#line 851
    if (! ((int const   )*(*tmp___6 + (int )((unsigned char )*p)) & 2048)) {
#line 852
      return (0);
    }
  }
#line 853
  if ((int const   )*p == 46) {
#line 854
    p ++;
  }
  {
#line 855
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 855
    if (*p) {
      {
#line 855
      tmp___7 = __ctype_b_loc();
      }
#line 855
      if (! ((int const   )*(*tmp___7 + (int )((unsigned char )*p)) & 2048)) {
#line 855
        goto while_break___1;
      }
    } else {
#line 855
      goto while_break___1;
    }
#line 856
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 857
  if ((int const   )*p == 0) {
#line 858
    return (0);
  } else {
    {
#line 857
    tmp___8 = strchr(float_formats, (int )*p);
    }
#line 857
    if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 858
      return (0);
    }
  }
#line 859
  p ++;
#line 859
  if ((int const   )*p != 0) {
#line 860
    return (0);
  }
#line 861
  return (1);
}
}
#line 870 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static int fmt_num  =    4;
#line 871 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static int fmt_hiwater  =    0;
#line 866 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static int fmt_index(NODE *n ) 
{ 
  int ix ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 869
  ix = 0;
#line 873
  if ((unsigned long )fmt_list == (unsigned long )((void *)0)) {
    {
#line 874
    tmp___1 = malloc((unsigned long )fmt_num * sizeof(*fmt_list));
#line 874
    fmt_list = (NODE **)tmp___1;
    }
#line 874
    if (fmt_list) {
#line 874
      tmp___5 = 1;
    } else {
      {
#line 874
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 874);
#line 874
      tmp___2 = __errno_location();
#line 874
      tmp___3 = strerror(*tmp___2);
#line 874
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 874
      r_fatal((char const   *)tmp___4, "fmt_index", "fmt_list", (long )((unsigned long )fmt_num * sizeof(*fmt_list)),
              tmp___3);
#line 874
      tmp___5 = 0;
      }
    }
  }
  {
#line 875
  n = force_string(n);
  }
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (ix < fmt_hiwater)) {
#line 876
      goto while_break;
    }
    {
#line 877
    tmp___6 = cmp_nodes(*(fmt_list + ix), n);
    }
#line 877
    if (tmp___6 == 0) {
#line 878
      return (ix);
    }
#line 879
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  *(n->sub.val.sp + n->sub.val.slen) = (char )'\000';
#line 883
  if (do_flags & 3) {
    {
#line 883
    tmp___10 = fmt_ok(n);
    }
#line 883
    if (! tmp___10) {
      {
#line 884
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 884);
      }
#line 884
      if ((unsigned long )n == (unsigned long )CONVFMT_node->sub.nodep.l.lptr) {
#line 884
        tmp___8 = "CONV";
      } else {
#line 884
        if ((unsigned long )n == (unsigned long )OFMT_node->sub.nodep.l.lptr) {
#line 884
          tmp___7 = "O";
        } else {
#line 884
          tmp___7 = "";
        }
#line 884
        tmp___8 = tmp___7;
      }
      {
#line 884
      tmp___9 = gettext("bad `%sFMT\' specification `%s\'");
#line 884
      (*lintfunc)((char const   *)tmp___9, tmp___8, n->sub.val.sp);
      }
    }
  }
#line 889
  if (fmt_hiwater >= fmt_num) {
    {
#line 890
    fmt_num *= 2;
#line 891
    tmp___11 = realloc((void *)((char *)fmt_list), (unsigned long )fmt_num * sizeof(*fmt_list));
#line 891
    fmt_list = (NODE **)tmp___11;
    }
#line 891
    if (fmt_list) {
#line 891
      tmp___15 = 1;
    } else {
      {
#line 891
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 891);
#line 891
      tmp___12 = __errno_location();
#line 891
      tmp___13 = strerror(*tmp___12);
#line 891
      tmp___14 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 891
      r_fatal((char const   *)tmp___14, "fmt_index", "fmt_list", (long )((unsigned long )fmt_num * sizeof(*fmt_list)),
              tmp___13);
#line 891
      tmp___15 = 0;
      }
    }
  }
  {
#line 893
  *(fmt_list + fmt_hiwater) = dupnode(n);
#line 894
  tmp___16 = fmt_hiwater;
#line 894
  fmt_hiwater ++;
  }
#line 894
  return (tmp___16);
}
}
#line 899 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void set_OFMT(void) 
{ 


  {
  {
#line 902
  OFMTidx = fmt_index(OFMT_node->sub.nodep.l.lptr);
#line 903
  OFMT = (*(fmt_list + OFMTidx))->sub.val.sp;
  }
#line 904
  return;
}
}
#line 908 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void set_CONVFMT(void) 
{ 


  {
  {
#line 911
  CONVFMTidx = fmt_index(CONVFMT_node->sub.nodep.l.lptr);
#line 912
  CONVFMT = (*(fmt_list + CONVFMTidx))->sub.val.sp;
  }
#line 913
  return;
}
}
#line 917 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void set_LINT(void) 
{ 
  int old_lint ;
  NODE *n ;
  char const   *lintval ;
  size_t lintlen ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 921
  old_lint = do_flags & 3;
#line 922
  n = LINT_node->sub.nodep.l.lptr;
#line 924
  if ((n->flags & 6U) != 0U) {
#line 925
    if ((n->flags & 32U) == 0U) {
      {
#line 929
      n = force_string(LINT_node->sub.nodep.l.lptr);
#line 930
      lintval = (char const   *)n->sub.val.sp;
#line 931
      lintlen = n->sub.val.slen;
      }
#line 932
      if (lintlen > 0UL) {
#line 933
        do_flags |= 2;
#line 934
        if (lintlen == 5UL) {
          {
#line 934
          tmp___2 = strncmp(lintval, "fatal", (size_t )5);
          }
#line 934
          if (tmp___2 == 0) {
#line 935
            lintfunc = & r_fatal;
          } else {
#line 934
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 936
        if (lintlen == 7UL) {
          {
#line 936
          tmp___1 = strncmp(lintval, "invalid", (size_t )7);
          }
#line 936
          if (tmp___1 == 0) {
#line 937
            do_flags &= -3;
#line 938
            do_flags |= 1;
          } else {
#line 940
            lintfunc = & warning;
          }
        } else {
#line 940
          lintfunc = & warning;
        }
      } else {
#line 942
        do_flags &= -4;
#line 943
        lintfunc = & warning;
      }
    } else {
      {
#line 946
      force_number(n);
      }
#line 947
      if (n->flags & 2048U) {
#line 947
        tmp___5 = n->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 1UL);
      } else {
#line 947
        if (n->flags & 4096U) {
#line 947
          if (n->sub.val.nm.mpi[0]._mp_size < 0) {
#line 947
            tmp___3 = -1;
          } else {
#line 947
            tmp___3 = n->sub.val.nm.mpi[0]._mp_size > 0;
          }
#line 947
          tmp___4 = tmp___3 == 0;
        } else {
#line 947
          tmp___4 = n->sub.val.nm.fltnum == 0.0;
        }
#line 947
        tmp___5 = tmp___4;
      }
#line 947
      if (tmp___5) {
#line 950
        do_flags &= -4;
      } else {
#line 948
        do_flags |= 2;
      }
#line 951
      lintfunc = & warning;
    }
  } else
#line 953
  if ((n->flags & 24U) != 0U) {
    {
#line 954
    force_number(n);
    }
#line 955
    if (n->flags & 2048U) {
#line 955
      tmp___8 = n->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 1UL);
    } else {
#line 955
      if (n->flags & 4096U) {
#line 955
        if (n->sub.val.nm.mpi[0]._mp_size < 0) {
#line 955
          tmp___6 = -1;
        } else {
#line 955
          tmp___6 = n->sub.val.nm.mpi[0]._mp_size > 0;
        }
#line 955
        tmp___7 = tmp___6 == 0;
      } else {
#line 955
        tmp___7 = n->sub.val.nm.fltnum == 0.0;
      }
#line 955
      tmp___8 = tmp___7;
    }
#line 955
    if (tmp___8) {
#line 958
      do_flags &= -4;
    } else {
#line 956
      do_flags |= 2;
    }
#line 959
    lintfunc = & warning;
  } else {
#line 961
    do_flags &= -4;
  }
#line 963
  if (! (do_flags & 3)) {
#line 964
    lintfunc = & warning;
  }
#line 967
  if (old_lint != (do_flags & 3)) {
#line 967
    if (old_lint) {
#line 967
      if (! (do_flags & 3)) {
        {
#line 968
        tmp___9 = gettext("turning off `--lint\' due to assignment to `LINT\'");
#line 968
        warning((char const   *)tmp___9);
        }
      }
    }
  }
  {
#line 971
  update_ext_api();
  }
#line 973
  return;
}
}
#line 977 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void set_TEXTDOMAIN(void) 
{ 
  int len ;
  NODE *tmp___1 ;
  struct exp_node *tmp___2 ;

  {
  {
#line 983
  tmp___2 = force_string(TEXTDOMAIN_node->sub.nodep.l.lptr);
#line 983
  TEXTDOMAIN_node->sub.nodep.l.lptr = tmp___2;
#line 983
  tmp___1 = tmp___2;
#line 984
  TEXTDOMAIN = tmp___1->sub.val.sp;
#line 985
  len = (int )tmp___1->sub.val.slen;
#line 986
  *(TEXTDOMAIN + len) = (char )'\000';
  }
#line 991
  return;
}
}
#line 995 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void update_ERRNO_int(int errcode ) 
{ 
  char *cp ;
  size_t tmp___1 ;
  char *__cil_tmp4 ;

  {
#line 1000
  if (errcode) {
    {
#line 1001
    cp = strerror(errcode);
#line 1002
    cp = gettext((char const   *)cp);
    }
  } else {
#line 1004
    cp = (char *)"";
  }
  {
#line 1005
  unref(ERRNO_node->sub.nodep.l.lptr);
#line 1006
  tmp___1 = strlen((char const   *)cp);
#line 1006
  ERRNO_node->sub.nodep.l.lptr = make_str_node((char const   *)cp, tmp___1, 0);
  }
#line 1007
  return;
}
}
#line 1011 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void update_ERRNO_string(char const   *string ) 
{ 
  size_t tmp___1 ;

  {
  {
#line 1014
  unref(ERRNO_node->sub.nodep.l.lptr);
#line 1015
  tmp___1 = strlen(string);
#line 1015
  ERRNO_node->sub.nodep.l.lptr = make_str_node(string, tmp___1, 0);
  }
#line 1016
  return;
}
}
#line 1020 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void unset_ERRNO(void) 
{ 


  {
  {
#line 1023
  unref(ERRNO_node->sub.nodep.l.lptr);
#line 1024
  ERRNO_node->sub.nodep.l.lptr = dupnode(Nnull_string);
  }
#line 1025
  return;
}
}
#line 1029 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void update_NR(void) 
{ 


  {
#line 1033
  if (((NR_node->sub.nodep.l.lptr)->flags & 6144U) != 0U) {
    {
#line 1034
    mpg_update_var(NR_node);
    }
  } else
#line 1037
  if ((NR_node->sub.nodep.l.lptr)->sub.val.nm.fltnum != (double )NR) {
    {
#line 1038
    unref(NR_node->sub.nodep.l.lptr);
#line 1039
    NR_node->sub.nodep.l.lptr = (*make_number)((double )NR);
    }
  }
#line 1041
  return;
}
}
#line 1045 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void update_NF(void) 
{ 
  long l ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 1050
  if ((NF_node->sub.nodep.l.lptr)->flags & 2048U) {
    {
#line 1050
    tmp___1 = mpfr_get_si((mpfr_srcptr )((NF_node->sub.nodep.l.lptr)->sub.val.nm.mpnum),
                          ROUND_MODE);
#line 1050
    l = tmp___1;
    }
  } else {
#line 1050
    if ((NF_node->sub.nodep.l.lptr)->flags & 4096U) {
      {
#line 1050
      tmp___2 = __gmpz_get_si((mpz_srcptr )((NF_node->sub.nodep.l.lptr)->sub.val.nm.mpi));
#line 1050
      tmp___3 = tmp___2;
      }
    } else {
#line 1050
      tmp___3 = (long )(NF_node->sub.nodep.l.lptr)->sub.val.nm.fltnum;
    }
#line 1050
    l = tmp___3;
  }
#line 1051
  if (NF == -1L) {
#line 1051
    goto _L;
  } else
#line 1051
  if (l != NF) {
    _L: /* CIL Label */ 
#line 1052
    if (NF == -1L) {
      {
#line 1053
      get_field(9223372036854775806L, (Func_ptr *)((void *)0));
      }
    }
    {
#line 1054
    unref(NF_node->sub.nodep.l.lptr);
#line 1055
    NF_node->sub.nodep.l.lptr = (*make_number)((double )NF);
    }
  }
#line 1057
  return;
}
}
#line 1061 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void update_FNR(void) 
{ 


  {
#line 1065
  if (((FNR_node->sub.nodep.l.lptr)->flags & 6144U) != 0U) {
    {
#line 1066
    mpg_update_var(FNR_node);
    }
  } else
#line 1069
  if ((FNR_node->sub.nodep.l.lptr)->sub.val.nm.fltnum != (double )FNR) {
    {
#line 1070
    unref(FNR_node->sub.nodep.l.lptr);
#line 1071
    FNR_node->sub.nodep.l.lptr = (*make_number)((double )FNR);
    }
  }
#line 1073
  return;
}
}
#line 1077 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
STACK_ITEM *stack_ptr  =    (STACK_ITEM *)((void *)0);
#line 1080 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static unsigned long STACK_SIZE  =    256UL;
#line 1081 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
int max_args  =    0;
#line 1085 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
NODE **args_array  =    (NODE **)((void *)0);
#line 1093 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
STACK_ITEM *grow_stack(void) 
{ 
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1096
  STACK_SIZE *= 2UL;
#line 1097
  tmp___1 = realloc((void *)((char *)stack_bottom), STACK_SIZE * sizeof(STACK_ITEM ));
#line 1097
  stack_bottom = (STACK_ITEM *)tmp___1;
  }
#line 1097
  if (stack_bottom) {
#line 1097
    tmp___5 = 1;
  } else {
    {
#line 1097
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1097);
#line 1097
    tmp___2 = __errno_location();
#line 1097
    tmp___3 = strerror(*tmp___2);
#line 1097
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1097
    r_fatal((char const   *)tmp___4, "grow_stack", "stack_bottom", (long )(STACK_SIZE * sizeof(STACK_ITEM )),
            tmp___3);
#line 1097
    tmp___5 = 0;
    }
  }
#line 1098
  stack_top = (stack_bottom + STACK_SIZE) - 1;
#line 1099
  stack_ptr = stack_bottom + STACK_SIZE / 2UL;
#line 1100
  return (stack_ptr);
}
}
#line 1109 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
NODE **r_get_lhs(NODE *n , _Bool reference ) 
{ 
  _Bool isparam ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1112
  isparam = (_Bool)0;
#line 1114
  if ((unsigned int )n->type == 7U) {
#line 1115
    isparam = (_Bool)1;
#line 1116
    n = *(frame_ptr->sub.nodep.r.av + n->sub.nodep.l.ll);
  }
  {
#line 1120
  if ((unsigned int )n->type == 5U) {
#line 1120
    goto case_5;
  }
#line 1123
  if ((unsigned int )n->type == 11U) {
#line 1123
    goto case_11;
  }
#line 1132
  if ((unsigned int )n->type == 6U) {
#line 1132
    goto case_6;
  }
#line 1137
  if ((unsigned int )n->type == 4U) {
#line 1137
    goto case_4;
  }
#line 1140
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 1121
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1121);
#line 1121
  tmp___1 = array_vname((NODE const   *)n);
#line 1121
  tmp___2 = gettext("attempt to use array `%s\' in a scalar context");
#line 1121
  r_fatal((char const   *)tmp___2, tmp___1);
  }
  case_11: /* CIL Label */ 
#line 1124
  if ((unsigned int )(n->sub.nodep.l.lptr)->type == 5U) {
    {
#line 1125
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1125);
#line 1125
    tmp___3 = array_vname((NODE const   *)n);
#line 1125
    tmp___4 = gettext("attempt to use array `%s\' in a scalar context");
#line 1125
    r_fatal((char const   *)tmp___4, tmp___3);
    }
  }
#line 1127
  if ((unsigned int )(n->sub.nodep.l.lptr)->type != 4U) {
#line 1128
    (n->sub.nodep.l.lptr)->type = (NODETYPE )4;
#line 1129
    (n->sub.nodep.l.lptr)->sub.nodep.l.lptr = Nnull_string;
  }
  case_6: /* CIL Label */ 
  {
#line 1133
  n->type = (NODETYPE )4;
#line 1134
  n->sub.nodep.l.lptr = dupnode(Nnull_string);
  }
#line 1135
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1138
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1141
  r_fatal("internal error line %d, file: %s", 1141, "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c");
  }
  switch_break: /* CIL Label */ ;
  }
#line 1144
  if (do_flags & 3) {
#line 1144
    if (reference) {
#line 1144
      if ((unsigned long )n->sub.nodep.l.lptr == (unsigned long )Nnull_string) {
        {
#line 1145
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1145);
        }
#line 1145
        if (isparam) {
          {
#line 1145
          tmp___5 = gettext("reference to uninitialized argument `%s\'");
#line 1145
          tmp___7 = tmp___5;
          }
        } else {
          {
#line 1145
          tmp___6 = gettext("reference to uninitialized variable `%s\'");
#line 1145
          tmp___7 = tmp___6;
          }
        }
        {
#line 1145
        (*lintfunc)((char const   *)tmp___7, n->sub.nodep.name);
        }
      }
    }
  }
#line 1149
  return (& n->sub.nodep.l.lptr);
}
}
#line 1155 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
__inline static NODE **r_get_field(NODE *n , Func_ptr *assign , _Bool reference ) 
{ 
  long field_num ;
  NODE **lhs ;
  char *tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 1161
  if (assign) {
#line 1162
    *assign = (Func_ptr )((void *)0);
  }
#line 1163
  if (do_flags & 3) {
#line 1164
    if ((n->flags & 16U) == 0U) {
      {
#line 1165
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1165);
#line 1165
      tmp___1 = gettext("attempt to field reference from non-numeric value");
#line 1165
      (*lintfunc)((char const   *)tmp___1);
      }
#line 1166
      if (n->sub.val.slen == 0UL) {
        {
#line 1167
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1167);
#line 1167
        tmp___2 = gettext("attempt to field reference from null string");
#line 1167
        (*lintfunc)((char const   *)tmp___2);
        }
      }
    }
  }
  {
#line 1171
  force_number(n);
  }
#line 1172
  if (n->flags & 2048U) {
    {
#line 1172
    tmp___3 = mpfr_get_si((mpfr_srcptr )(n->sub.val.nm.mpnum), ROUND_MODE);
#line 1172
    field_num = tmp___3;
    }
  } else {
#line 1172
    if (n->flags & 4096U) {
      {
#line 1172
      tmp___4 = __gmpz_get_si((mpz_srcptr )(n->sub.val.nm.mpi));
#line 1172
      tmp___5 = tmp___4;
      }
    } else {
#line 1172
      tmp___5 = (long )n->sub.val.nm.fltnum;
    }
#line 1172
    field_num = tmp___5;
  }
#line 1174
  if (field_num < 0L) {
    {
#line 1175
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1175);
#line 1175
    tmp___6 = gettext("attempt to access field %ld");
#line 1175
    r_fatal((char const   *)tmp___6, field_num);
    }
  }
#line 1177
  if (field_num == 0L) {
#line 1177
    if (field0_valid) {
#line 1178
      lhs = fields_arr + 0;
#line 1179
      if (assign) {
#line 1180
        *assign = & reset_record;
      }
    } else {
      {
#line 1182
      lhs = get_field(field_num, assign);
      }
    }
  } else {
    {
#line 1182
    lhs = get_field(field_num, assign);
    }
  }
#line 1183
  if (do_flags & 3) {
#line 1183
    if (reference) {
#line 1183
      if ((unsigned long )*lhs == (unsigned long )Null_field) {
        {
#line 1184
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1184);
#line 1184
        tmp___7 = gettext("reference to uninitialized field `$%ld\'");
#line 1184
        (*lintfunc)((char const   *)tmp___7, field_num);
        }
      } else
#line 1183
      if ((unsigned long )*lhs == (unsigned long )Nnull_string) {
        {
#line 1184
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1184);
#line 1184
        tmp___7 = gettext("reference to uninitialized field `$%ld\'");
#line 1184
        (*lintfunc)((char const   *)tmp___7, field_num);
        }
      }
    }
  }
#line 1186
  return (lhs);
}
}
#line 1195 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static double calc_exp_posint(double x , long n ) 
{ 
  double mult ;

  {
#line 1198
  mult = (double )1;
  {
#line 1200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1200
    if (! (n > 1L)) {
#line 1200
      goto while_break;
    }
#line 1201
    if (n % 2L == 1L) {
#line 1202
      mult *= x;
    }
#line 1203
    x *= x;
#line 1204
    n /= 2L;
  }
  while_break: /* CIL Label */ ;
  }
#line 1206
  return (mult * x);
}
}
#line 1211 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
double calc_exp(double x1 , double x2 ) 
{ 
  long lx ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 1216
  lx = (long )x2;
#line 1216
  if ((double )lx == x2) {
#line 1217
    if (lx == 0L) {
#line 1218
      return ((double )1);
    }
#line 1219
    if (lx > 0L) {
      {
#line 1219
      tmp___1 = calc_exp_posint(x1, lx);
#line 1219
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 1219
      tmp___2 = calc_exp_posint(x1, - lx);
#line 1219
      tmp___3 = 1.0 / tmp___2;
      }
    }
#line 1219
    return (tmp___3);
  }
  {
#line 1222
  tmp___4 = pow(x1, x2);
  }
#line 1222
  return (tmp___4);
}
}
#line 1228 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static INSTRUCTION *setup_frame(INSTRUCTION *pc ) 
{ 
  NODE *r ;
  NODE *m ;
  NODE *f ;
  NODE *fp___0 ;
  NODE **sp___0 ;
  int pcount ;
  int arg_count ;
  int i___0 ;
  int j ;
  _Bool tail_optimize ;
  int tmp___1 ;
  NODE *func___1 ;
  int n ;
  NODE **tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  STACK_ITEM *tmp___9 ;
  void *tmp___10 ;
  struct exp_node *tmp___11 ;
  STACK_ITEM *tmp___12 ;
  STACK_ITEM *tmp___13 ;
  STACK_ITEM *tmp___14 ;
  void *tmp___15 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 1231
  r = (NODE *)((void *)0);
#line 1233
  sp___0 = (NODE **)((void *)0);
#line 1235
  tail_optimize = (_Bool)0;
#line 1237
  f = pc->x.xn;
#line 1238
  pcount = (int )f->sub.nodep.l.ll;
#line 1239
  fp___0 = f->sub.nodep.rn;
#line 1240
  arg_count = (int )(pc + 1)->x.xl;
#line 1243
  if ((pc + 1)->d.dl) {
#line 1243
    if ((int )do_optimize > 1) {
#line 1243
      if (! (do_flags & 8192)) {
#line 1243
        if (! (do_flags & 4096)) {
#line 1243
          tmp___1 = 1;
        } else {
#line 1243
          tmp___1 = 0;
        }
      } else {
#line 1243
        tmp___1 = 0;
      }
    } else {
#line 1243
      tmp___1 = 0;
    }
  } else {
#line 1243
    tmp___1 = 0;
  }
#line 1243
  tail_optimize = (_Bool )tmp___1;
#line 1246
  if (tail_optimize) {
#line 1252
    func___1 = frame_ptr->sub.nodep.x.extra;
#line 1253
    n = (int )func___1->sub.nodep.l.ll;
#line 1253
    sp___0 = frame_ptr->sub.nodep.r.av;
    {
#line 1253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1253
      if (! (n > 0)) {
#line 1253
        goto while_break;
      }
#line 1254
      tmp___2 = sp___0;
#line 1254
      sp___0 ++;
#line 1254
      r = *tmp___2;
#line 1255
      if ((unsigned int )r->type == 4U) {
        {
#line 1256
        DEREF(r->sub.nodep.l.lptr);
        }
      } else
#line 1257
      if ((unsigned int )r->type == 5U) {
        {
#line 1258
        (*(*(r->sub.nodep.l.lp + 5)))(r, (struct exp_node *)((void *)0));
        }
      }
#line 1253
      n --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1260
    sp___0 = frame_ptr->sub.nodep.r.av;
  } else
#line 1262
  if (pcount > 0) {
    {
#line 1263
    tmp___3 = malloc((unsigned long )pcount * sizeof(NODE *));
#line 1263
    sp___0 = (NODE **)tmp___3;
    }
#line 1263
    if (sp___0) {
#line 1263
      tmp___7 = 1;
    } else {
      {
#line 1263
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1263);
#line 1263
      tmp___4 = __errno_location();
#line 1263
      tmp___5 = strerror(*tmp___4);
#line 1263
      tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1263
      r_fatal((char const   *)tmp___6, "setup_frame", "sp", (long )((unsigned long )pcount * sizeof(NODE *)),
              tmp___5);
#line 1263
      tmp___7 = 0;
      }
    }
    {
#line 1264
    memset((void *)sp___0, 0, (unsigned long )pcount * sizeof(NODE *));
    }
  }
#line 1269
  if (arg_count > pcount) {
    {
#line 1270
    tmp___8 = gettext("function `%s\' called with more arguments than declared");
#line 1270
    warning((char const   *)tmp___8, f->sub.nodep.name);
    }
    {
#line 1273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1274
      tmp___9 = stack_ptr;
#line 1274
      stack_ptr --;
#line 1274
      r = tmp___9->rptr;
#line 1275
      if ((unsigned int )r->type == 1U) {
        {
#line 1276
        DEREF(r);
        }
      }
#line 1273
      arg_count --;
#line 1273
      if (! (arg_count > pcount)) {
#line 1273
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1280
  i___0 = 0;
#line 1280
  j = arg_count - 1;
  {
#line 1280
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1280
    if (! (i___0 < pcount)) {
#line 1280
      goto while_break___1;
    }
#line 1281
    if (tail_optimize) {
#line 1282
      r = *(sp___0 + i___0);
    } else {
#line 1284
      r = (NODE *)nextfree[1].freep;
#line 1284
      if (r) {
#line 1284
        nextfree[1].freep = ((BLOCK *)r)->freep;
      } else {
        {
#line 1284
        tmp___10 = more_blocks(1);
#line 1284
        r = (NODE *)tmp___10;
        }
      }
      {
#line 1285
      memset((void *)r, 0, sizeof(NODE ));
#line 1286
      *(sp___0 + i___0) = r;
      }
    }
#line 1289
    if (i___0 >= arg_count) {
#line 1291
      r->type = (NODETYPE )6;
#line 1292
      r->sub.nodep.name = (fp___0 + i___0)->sub.nodep.name;
#line 1293
      goto __Cont;
    }
#line 1296
    m = (stack_ptr - j)->rptr;
#line 1298
    if ((unsigned int )m->type == 7U) {
#line 1299
      m = *(frame_ptr->sub.nodep.r.av + m->sub.nodep.l.ll);
    }
    {
#line 1303
    if ((unsigned int )m->type == 5U) {
#line 1303
      goto case_5;
    }
#line 1303
    if ((unsigned int )m->type == 6U) {
#line 1303
      goto case_5;
    }
#line 1308
    if ((unsigned int )m->type == 11U) {
#line 1308
      goto case_11;
    }
#line 1314
    if ((unsigned int )m->type == 4U) {
#line 1314
      goto case_4;
    }
#line 1323
    if ((unsigned int )m->type == 1U) {
#line 1323
      goto case_1;
    }
#line 1328
    goto switch_default;
    case_5: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 1304
    r->type = (NODETYPE )11;
#line 1305
    tmp___11 = m;
#line 1305
    r->sub.nodep.r.rptr = tmp___11;
#line 1305
    r->sub.nodep.l.lptr = tmp___11;
#line 1306
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1309
    r->type = (NODETYPE )11;
#line 1310
    r->sub.nodep.l.lptr = m->sub.nodep.l.lptr;
#line 1311
    r->sub.nodep.r.rptr = m;
#line 1312
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1319
    r->type = (NODETYPE )4;
#line 1320
    r->sub.nodep.l.lptr = dupnode(Nnull_string);
    }
#line 1321
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1324
    r->type = (NODETYPE )4;
#line 1325
    r->sub.nodep.l.lptr = m;
#line 1326
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1329
    r_fatal("internal error line %d, file: %s", 1329, "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c");
    }
    switch_break: /* CIL Label */ ;
    }
#line 1331
    r->sub.nodep.name = (fp___0 + i___0)->sub.nodep.name;
    __Cont: /* CIL Label */ 
#line 1280
    i___0 ++;
#line 1280
    j --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1334
  stack_ptr += - arg_count;
#line 1336
  if (tail_optimize) {
#line 1337
    (frame_ptr->sub.nodep.cnt) ++;
#line 1338
    return (f->sub.nodep.r.iptr);
  }
#line 1341
  if ((unsigned int )pc->opcode == 71U) {
    {
#line 1342
    tmp___12 = stack_ptr;
#line 1342
    stack_ptr --;
#line 1342
    r = tmp___12->rptr;
#line 1343
    DEREF(r);
    }
  }
#line 1346
  frame_ptr->sub.nodep.name = source;
#line 1348
  if (do_flags & 4096) {
    {
#line 1349
    push_frame(frame_ptr);
    }
  } else
#line 1348
  if (do_flags & 8192) {
    {
#line 1349
    push_frame(frame_ptr);
    }
  }
#line 1352
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1352
    stack_ptr ++;
#line 1352
    tmp___14 = stack_ptr;
  } else {
    {
#line 1352
    tmp___13 = grow_stack();
#line 1352
    tmp___14 = tmp___13;
    }
  }
#line 1352
  tmp___14->rptr = frame_ptr;
#line 1355
  frame_ptr = (NODE *)nextfree[1].freep;
#line 1355
  if (frame_ptr) {
#line 1355
    nextfree[1].freep = ((BLOCK *)frame_ptr)->freep;
  } else {
    {
#line 1355
    tmp___15 = more_blocks(1);
#line 1355
    frame_ptr = (NODE *)tmp___15;
    }
  }
#line 1356
  frame_ptr->type = (NODETYPE )16;
#line 1357
  frame_ptr->sub.nodep.r.av = sp___0;
#line 1358
  frame_ptr->sub.nodep.reflags = (unsigned long )(stack_ptr - stack_bottom);
#line 1359
  frame_ptr->sub.nodep.x.extra = f;
#line 1360
  frame_ptr->sub.nodep.cnt = 0UL;
#line 1361
  frame_ptr->sub.nodep.name = (char *)((void *)0);
#line 1362
  frame_ptr->sub.nodep.l.li = pc;
#line 1364
  return (f->sub.nodep.r.iptr);
}
}
#line 1370 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static INSTRUCTION *restore_frame(NODE *fp___0 ) 
{ 
  NODE *r ;
  NODE **sp___0 ;
  int n ;
  NODE *func___1 ;
  INSTRUCTION *ri ;
  NODE **tmp___1 ;

  {
#line 1379
  func___1 = frame_ptr->sub.nodep.x.extra;
#line 1380
  n = (int )func___1->sub.nodep.l.ll;
#line 1381
  sp___0 = frame_ptr->sub.nodep.r.av;
  {
#line 1383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1383
    if (! (n > 0)) {
#line 1383
      goto while_break;
    }
#line 1384
    tmp___1 = sp___0;
#line 1384
    sp___0 ++;
#line 1384
    r = *tmp___1;
#line 1385
    if ((unsigned int )r->type == 4U) {
      {
#line 1386
      DEREF(r->sub.nodep.l.lptr);
      }
    } else
#line 1387
    if ((unsigned int )r->type == 5U) {
      {
#line 1388
      (*(*(r->sub.nodep.l.lp + 5)))(r, (struct exp_node *)((void *)0));
      }
    }
#line 1389
    ((BLOCK *)r)->freep = nextfree[1].freep;
#line 1389
    nextfree[1].freep = (BLOCK *)r;
#line 1383
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1392
  if ((unsigned long )frame_ptr->sub.nodep.r.av != (unsigned long )((void *)0)) {
    {
#line 1393
    free((void *)frame_ptr->sub.nodep.r.av);
    }
  }
#line 1394
  ri = frame_ptr->sub.nodep.l.li;
#line 1397
  ((BLOCK *)frame_ptr)->freep = nextfree[1].freep;
#line 1397
  nextfree[1].freep = (BLOCK *)frame_ptr;
#line 1398
  if (do_flags & 4096) {
    {
#line 1399
    pop_frame();
    }
  } else
#line 1398
  if (do_flags & 8192) {
    {
#line 1399
    pop_frame();
    }
  }
#line 1402
  frame_ptr = fp___0;
#line 1404
  source = fp___0->sub.nodep.name;
#line 1405
  fp___0->sub.nodep.name = (char *)((void *)0);
#line 1407
  return (ri->nexti);
}
}
#line 1413 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
__inline static void free_arrayfor(NODE *r ) 
{ 
  NODE *n ;
  size_t num_elems ;
  NODE **list ;

  {
#line 1416
  if ((unsigned long )r->sub.nodep.r.av != (unsigned long )((void *)0)) {
#line 1418
    num_elems = r->sub.nodep.reflags;
#line 1419
    list = r->sub.nodep.r.av;
    {
#line 1420
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1420
      if (! (num_elems > 0UL)) {
#line 1420
        goto while_break;
      }
      {
#line 1421
      num_elems --;
#line 1421
      n = *(list + num_elems);
#line 1422
      unref(n);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1424
    free((void *)list);
    }
  }
#line 1426
  ((BLOCK *)r)->freep = nextfree[1].freep;
#line 1426
  nextfree[1].freep = (BLOCK *)r;
#line 1427
  return;
}
}
#line 1435 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
INSTRUCTION *unwind_stack(long n ) 
{ 
  NODE *r ;
  INSTRUCTION *cp ;
  STACK_ITEM *sp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  STACK_ITEM *tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1439
  cp = (INSTRUCTION *)((void *)0);
#line 1442
  if ((unsigned long )stack_ptr < (unsigned long )stack_bottom) {
#line 1443
    return ((INSTRUCTION *)((void *)0));
  }
#line 1445
  sp___0 = stack_bottom + n;
#line 1447
  if ((unsigned long )stack_ptr < (unsigned long )sp___0) {
#line 1448
    return ((INSTRUCTION *)((void *)0));
  }
  {
#line 1450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1450
    tmp___4 = stack_ptr;
#line 1450
    stack_ptr --;
#line 1450
    r = tmp___4->rptr;
#line 1450
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 1450
      goto while_break;
    }
    {
#line 1452
    if ((unsigned int )r->type == 16U) {
#line 1452
      goto case_16;
    }
#line 1455
    if ((unsigned int )r->type == 15U) {
#line 1455
      goto case_15;
    }
#line 1458
    if ((unsigned int )r->type == 1U) {
#line 1458
      goto case_1;
    }
#line 1461
    if ((unsigned int )r->type == 17U) {
#line 1461
      goto case_17;
    }
#line 1464
    goto switch_default;
    case_16: /* CIL Label */ 
    {
#line 1453
    cp = restore_frame(r);
    }
#line 1454
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 1456
    free_arrayfor(r);
    }
#line 1457
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1459
    DEREF(r);
    }
#line 1460
    goto switch_break;
    case_17: /* CIL Label */ 
#line 1462
    ((BLOCK *)r)->freep = nextfree[1].freep;
#line 1462
    nextfree[1].freep = (BLOCK *)r;
#line 1463
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1465
    tmp___3 = in_main_context();
    }
#line 1465
    if (tmp___3) {
      {
#line 1466
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1466);
#line 1466
      tmp___1 = nodetype2str(r->type);
#line 1466
      tmp___2 = gettext("unwind_stack: unexpected type `%s\'");
#line 1466
      r_fatal((char const   *)tmp___2, tmp___1);
      }
    }
#line 1475
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1478
    if ((unsigned long )stack_ptr < (unsigned long )sp___0) {
#line 1479
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1481
  return (cp);
}
}
#line 1492 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
__inline static int eval_condition(NODE *t ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1495
  if ((unsigned long )t == (unsigned long )node_Boolean[0]) {
#line 1496
    return (0);
  }
#line 1498
  if ((unsigned long )t == (unsigned long )node_Boolean[1]) {
#line 1499
    return (1);
  }
#line 1501
  if ((t->flags & 32U) != 0U) {
    {
#line 1502
    force_number(t);
    }
  } else
#line 1503
  if ((t->flags & 512U) != 0U) {
    {
#line 1504
    force_string(t);
    }
  }
#line 1506
  if ((t->flags & 16U) != 0U) {
#line 1507
    if (t->flags & 2048U) {
#line 1507
      tmp___3 = t->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 1UL);
    } else {
#line 1507
      if (t->flags & 4096U) {
#line 1507
        if (t->sub.val.nm.mpi[0]._mp_size < 0) {
#line 1507
          tmp___1 = -1;
        } else {
#line 1507
          tmp___1 = t->sub.val.nm.mpi[0]._mp_size > 0;
        }
#line 1507
        tmp___2 = tmp___1 == 0;
      } else {
#line 1507
        tmp___2 = t->sub.val.nm.fltnum == 0.0;
      }
#line 1507
      tmp___3 = tmp___2;
    }
#line 1507
    if (tmp___3) {
#line 1507
      tmp___4 = 0;
    } else {
#line 1507
      tmp___4 = 1;
    }
#line 1507
    return (tmp___4);
  }
#line 1509
  return (t->sub.val.slen != 0UL);
}
}
#line 1514 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
__inline static int cmp_scalars(void) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  int di ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1520
  t2 = POP_SCALAR();
#line 1521
  t1 = stack_ptr->rptr;
  }
#line 1522
  if ((unsigned int )t1->type == 5U) {
    {
#line 1523
    DEREF(t2);
#line 1524
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1524);
#line 1524
    tmp___1 = array_vname((NODE const   *)t1);
#line 1524
    tmp___2 = gettext("attempt to use array `%s\' in a scalar context");
#line 1524
    r_fatal((char const   *)tmp___2, tmp___1);
    }
  }
  {
#line 1526
  di = cmp_nodes(t1, t2);
#line 1527
  DEREF(t1);
#line 1528
  DEREF(t2);
  }
#line 1529
  return (di);
}
}
#line 1534 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static void op_assign(OPCODE op ) 
{ 
  NODE **lhs ;
  NODE *t1 ;
  NODE *t2 ;
  double x ;
  double x1 ;
  double x2 ;
  STACK_ITEM *tmp___1 ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  NODE *tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1539
  x = 0.0;
#line 1541
  tmp___1 = stack_ptr;
#line 1541
  stack_ptr --;
#line 1541
  lhs = tmp___1->lptr;
#line 1542
  t1 = *lhs;
#line 1543
  tmp___2 = force_number(t1);
#line 1543
  x1 = tmp___2->sub.val.nm.fltnum;
#line 1545
  t2 = TOP_SCALAR();
#line 1546
  tmp___3 = force_number(t2);
#line 1546
  x2 = tmp___3->sub.val.nm.fltnum;
#line 1547
  DEREF(t2);
  }
  {
#line 1550
  if ((unsigned int )op == 32U) {
#line 1550
    goto case_32;
  }
#line 1553
  if ((unsigned int )op == 33U) {
#line 1553
    goto case_33;
  }
#line 1556
  if ((unsigned int )op == 29U) {
#line 1556
    goto case_29;
  }
#line 1559
  if ((unsigned int )op == 30U) {
#line 1559
    goto case_30;
  }
#line 1566
  if ((unsigned int )op == 31U) {
#line 1566
    goto case_31;
  }
#line 1578
  if ((unsigned int )op == 34U) {
#line 1578
    goto case_34;
  }
#line 1581
  goto switch_default;
  case_32: /* CIL Label */ 
#line 1551
  x = x1 + x2;
#line 1552
  goto switch_break;
  case_33: /* CIL Label */ 
#line 1554
  x = x1 - x2;
#line 1555
  goto switch_break;
  case_29: /* CIL Label */ 
#line 1557
  x = x1 * x2;
#line 1558
  goto switch_break;
  case_30: /* CIL Label */ 
#line 1560
  if (x2 == (double )0) {
    {
#line 1561
    stack_ptr --;
#line 1562
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1562);
#line 1562
    tmp___4 = gettext("division by zero attempted in `/=\'");
#line 1562
    r_fatal((char const   *)tmp___4);
    }
  }
#line 1564
  x = x1 / x2;
#line 1565
  goto switch_break;
  case_31: /* CIL Label */ 
#line 1567
  if (x2 == (double )0) {
    {
#line 1568
    stack_ptr --;
#line 1569
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1569);
#line 1569
    tmp___5 = gettext("division by zero attempted in `%%=\'");
#line 1569
    r_fatal((char const   *)tmp___5);
    }
  }
  {
#line 1572
  x = fmod(x1, x2);
  }
#line 1577
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 1579
  x = calc_exp(x1, x2);
  }
#line 1580
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1582
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1585
  if (t1->sub.val.sref == 1L) {
#line 1585
    if (t1->flags == 25U) {
#line 1587
      t1->sub.val.nm.fltnum = x;
    } else {
      {
#line 1589
      unref(t1);
#line 1590
      tmp___6 = (*make_number)(x);
#line 1590
      *lhs = tmp___6;
#line 1590
      t1 = tmp___6;
      }
    }
  } else {
    {
#line 1589
    unref(t1);
#line 1590
    tmp___6 = (*make_number)(x);
#line 1590
    *lhs = tmp___6;
#line 1590
    t1 = tmp___6;
    }
  }
#line 1593
  (t1->sub.val.sref) ++;
#line 1594
  stack_ptr->rptr = t1;
#line 1595
  return;
}
}
#line 1599 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void PUSH_CODE(INSTRUCTION *cp ) 
{ 
  NODE *r ;
  void *tmp___1 ;
  STACK_ITEM *tmp___2 ;
  STACK_ITEM *tmp___3 ;

  {
#line 1603
  r = (NODE *)nextfree[1].freep;
#line 1603
  if (r) {
#line 1603
    nextfree[1].freep = ((BLOCK *)r)->freep;
  } else {
    {
#line 1603
    tmp___1 = more_blocks(1);
#line 1603
    r = (NODE *)tmp___1;
    }
  }
#line 1604
  r->type = (NODETYPE )17;
#line 1605
  r->sub.nodep.r.iptr = cp;
#line 1606
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1606
    stack_ptr ++;
#line 1606
    tmp___3 = stack_ptr;
  } else {
    {
#line 1606
    tmp___2 = grow_stack();
#line 1606
    tmp___3 = tmp___2;
    }
  }
#line 1606
  tmp___3->rptr = r;
#line 1607
  return;
}
}
#line 1611 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
INSTRUCTION *POP_CODE(void) 
{ 
  NODE *r ;
  INSTRUCTION *cp ;
  STACK_ITEM *tmp___1 ;

  {
#line 1616
  tmp___1 = stack_ptr;
#line 1616
  stack_ptr --;
#line 1616
  r = tmp___1->rptr;
#line 1617
  cp = r->sub.nodep.r.iptr;
#line 1618
  ((BLOCK *)r)->freep = nextfree[1].freep;
#line 1618
  nextfree[1].freep = (BLOCK *)r;
#line 1619
  return (cp);
}
}
#line 1650 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static EXEC_STATE exec_state_stack  ;
#line 1654 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static void push_exec_state(INSTRUCTION *cp , int rule___0 , char *src , STACK_ITEM *sp___0 ) 
{ 
  EXEC_STATE *es ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1659
  tmp___1 = malloc(sizeof(EXEC_STATE ));
#line 1659
  es = (EXEC_STATE *)tmp___1;
  }
#line 1659
  if (es) {
#line 1659
    tmp___5 = 1;
  } else {
    {
#line 1659
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1659);
#line 1659
    tmp___2 = __errno_location();
#line 1659
    tmp___3 = strerror(*tmp___2);
#line 1659
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1659
    r_fatal((char const   *)tmp___4, "push_exec_state", "es", (long )sizeof(EXEC_STATE ),
            tmp___3);
#line 1659
    tmp___5 = 0;
    }
  }
#line 1660
  es->rule = rule___0;
#line 1661
  es->cptr = cp;
#line 1662
  es->stack_size = (sp___0 - stack_bottom) + 1L;
#line 1663
  es->source = (char const   *)src;
#line 1664
  es->next = exec_state_stack.next;
#line 1665
  exec_state_stack.next = es;
#line 1666
  return;
}
}
#line 1671 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
static INSTRUCTION *pop_exec_state(int *rule___0 , char **src , long *sz ) 
{ 
  INSTRUCTION *cp ;
  EXEC_STATE *es ;

  {
#line 1677
  es = exec_state_stack.next;
#line 1678
  if ((unsigned long )es == (unsigned long )((void *)0)) {
#line 1679
    return ((INSTRUCTION *)((void *)0));
  }
#line 1680
  cp = es->cptr;
#line 1681
  if ((unsigned long )rule___0 != (unsigned long )((void *)0)) {
#line 1682
    *rule___0 = es->rule;
  }
#line 1683
  if ((unsigned long )src != (unsigned long )((void *)0)) {
#line 1684
    *src = (char *)es->source;
  }
#line 1685
  if ((unsigned long )sz != (unsigned long )((void *)0)) {
#line 1686
    *sz = es->stack_size;
  }
  {
#line 1687
  exec_state_stack.next = es->next;
#line 1688
  free((void *)es);
  }
#line 1689
  return (cp);
}
}
#line 1695 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
int register_exec_hook(int (*preh)(INSTRUCTION ** ) , void (*posth)(INSTRUCTION * ) ) 
{ 
  int pos ;

  {
#line 1698
  pos = 0;
#line 1705
  if (! preh) {
#line 1706
    return (0);
  } else
#line 1705
  if (post_execute) {
#line 1705
    if (posth) {
#line 1706
      return (0);
    }
  }
#line 1708
  if (num_exec_hook == 10) {
#line 1709
    return (0);
  }
#line 1715
  if (num_exec_hook > 0) {
#line 1716
    pos = ! (! (do_flags & 8192));
#line 1717
    if (num_exec_hook > pos) {
      {
#line 1718
      memmove((void *)((pre_execute + pos) + 1), (void const   *)(pre_execute + pos),
              (unsigned long )(num_exec_hook - pos) * sizeof(preh));
      }
    }
  }
#line 1721
  pre_execute[pos] = preh;
#line 1722
  num_exec_hook ++;
#line 1724
  if (posth) {
#line 1725
    post_execute = posth;
  }
#line 1727
  return (1);
}
}
#line 226 "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h"
int r_interpret(INSTRUCTION *code ) ;
#line 226 "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h"
static _Bool warned___10  =    (_Bool)0;
#line 244 "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h"
static _Bool warned___11  =    (_Bool)0;
#line 854 "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h"
static NODE *sorted_in  =    (NODE *)((void *)0);
#line 27 "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h"
int r_interpret(INSTRUCTION *code ) 
{ 
  INSTRUCTION *pc ;
  OPCODE op ;
  NODE *r ;
  NODE *m ;
  INSTRUCTION *ni ;
  NODE *t1 ;
  NODE *t2 ;
  NODE **lhs ;
  double x ;
  double x2 ;
  int di ;
  Regexp *rp ;
  NODE *set_array ;
  NODE *set_idx ;
  _Bool stdio_problem ;
  char *orig ;
  char *trans ;
  char save ;
  size_t tmp___1 ;
  STACK_ITEM *tmp___2 ;
  STACK_ITEM *tmp___3 ;
  NODE *save_symbol ;
  _Bool isparam ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  STACK_ITEM *tmp___7 ;
  STACK_ITEM *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  STACK_ITEM *tmp___12 ;
  STACK_ITEM *tmp___13 ;
  STACK_ITEM *tmp___14 ;
  STACK_ITEM *tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  STACK_ITEM *tmp___18 ;
  STACK_ITEM *tmp___19 ;
  STACK_ITEM *tmp___20 ;
  STACK_ITEM *tmp___21 ;
  NODE **tmp___22 ;
  STACK_ITEM *tmp___23 ;
  STACK_ITEM *tmp___24 ;
  NODE *tmp___25 ;
  NODE *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  NODE *tmp___31 ;
  char *tmp___32 ;
  struct exp_node **tmp___33 ;
  char *tmp___34 ;
  STACK_ITEM *tmp___35 ;
  STACK_ITEM *tmp___36 ;
  NODE *tmp___37 ;
  NODE *tmp___38 ;
  char const   *tmp___39 ;
  char *tmp___40 ;
  STACK_ITEM *tmp___41 ;
  STACK_ITEM *tmp___42 ;
  NODE *tmp___43 ;
  NODE *tmp___44 ;
  char const   *tmp___45 ;
  char *tmp___46 ;
  char const   *tmp___47 ;
  char *tmp___48 ;
  NODE *tmp___49 ;
  char const   *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  STACK_ITEM *tmp___53 ;
  STACK_ITEM *tmp___54 ;
  STACK_ITEM *tmp___55 ;
  STACK_ITEM *tmp___56 ;
  STACK_ITEM *tmp___57 ;
  STACK_ITEM *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  STACK_ITEM *tmp___61 ;
  STACK_ITEM *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  NODE *tmp___72 ;
  NODE *tmp___73 ;
  NODE *tmp___74 ;
  NODE *tmp___75 ;
  NODE *tmp___76 ;
  NODE *tmp___77 ;
  NODE *tmp___78 ;
  NODE *tmp___79 ;
  NODE *tmp___80 ;
  NODE *tmp___81 ;
  NODE *tmp___82 ;
  NODE *tmp___83 ;
  double tmp___84 ;
  NODE *tmp___85 ;
  NODE *tmp___86 ;
  NODE *tmp___87 ;
  char *tmp___88 ;
  NODE *tmp___89 ;
  NODE *tmp___90 ;
  NODE *tmp___91 ;
  char *tmp___92 ;
  NODE *tmp___93 ;
  NODE *tmp___94 ;
  NODE *tmp___95 ;
  NODE *tmp___96 ;
  char const   *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  NODE **tmp___100 ;
  void (*assign)(void) ;
  NODE **tmp___101 ;
  NODE *tmp___102 ;
  size_t nlen ;
  char *tmp___103 ;
  void *tmp___104 ;
  int *tmp___105 ;
  char *tmp___106 ;
  char *tmp___107 ;
  int tmp___108 ;
  size_t wlen ;
  wchar_t *tmp___109 ;
  void *tmp___110 ;
  int *tmp___111 ;
  char *tmp___112 ;
  char *tmp___113 ;
  int tmp___114 ;
  size_t nlen___0 ;
  char *p ;
  void *tmp___115 ;
  int *tmp___116 ;
  char *tmp___117 ;
  char *tmp___118 ;
  int tmp___119 ;
  NODE *tmp___120 ;
  STACK_ITEM *tmp___121 ;
  long tmp___122 ;
  long tmp___123 ;
  long tmp___124 ;
  long tmp___125 ;
  long tmp___126 ;
  long tmp___127 ;
  long tmp___128 ;
  long tmp___129 ;
  long tmp___130 ;
  long tmp___131 ;
  long tmp___132 ;
  long tmp___133 ;
  long tmp___134 ;
  long tmp___135 ;
  long tmp___136 ;
  long tmp___137 ;
  STACK_ITEM *tmp___138 ;
  STACK_ITEM *tmp___139 ;
  STACK_ITEM *tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  STACK_ITEM *tmp___144 ;
  NODE *tmp___145 ;
  NODE *tmp___146 ;
  NODE *tmp___147 ;
  STACK_ITEM *tmp___148 ;
  STACK_ITEM *tmp___149 ;
  NODE **list ;
  NODE *array ;
  NODE *sort_str ;
  size_t num_elems ;
  char const   *how_to_sort ;
  struct exp_node **tmp___150 ;
  void *tmp___151 ;
  STACK_ITEM *tmp___152 ;
  STACK_ITEM *tmp___153 ;
  NODE *array___0 ;
  char const   *tmp___154 ;
  char *tmp___155 ;
  NODE **tmp___156 ;
  STACK_ITEM *tmp___157 ;
  STACK_ITEM *tmp___158 ;
  STACK_ITEM *tmp___159 ;
  int arg_count ;
  awk_value_t result ;
  awk_value_t *tmp___160 ;
  STACK_ITEM *tmp___161 ;
  int tmp___162 ;
  STACK_ITEM *tmp___163 ;
  STACK_ITEM *tmp___164 ;
  STACK_ITEM *tmp___165 ;
  STACK_ITEM *tmp___166 ;
  NODE *tmp___167 ;
  STACK_ITEM *tmp___168 ;
  STACK_ITEM *tmp___169 ;
  NODE **tmp___170 ;
  int tmp___171 ;
  STACK_ITEM *tmp___172 ;
  STACK_ITEM *tmp___173 ;
  NODE *tmp___174 ;
  NODE *tmp___175 ;
  NODE *f ;
  int arg_count___0 ;
  char *tmp___176 ;
  int tmp___177 ;
  char *tmp___178 ;
  char *tmp___179 ;
  NODE *f___0 ;
  char *tmp___180 ;
  INSTRUCTION *bc ;
  char *fname ;
  int arg_count___1 ;
  STACK_ITEM *tmp___181 ;
  STACK_ITEM *tmp___182 ;
  char *tmp___183 ;
  STACK_ITEM *tmp___184 ;
  STACK_ITEM *tmp___185 ;
  char *tmp___186 ;
  int ret ;
  STACK_ITEM *tmp___187 ;
  STACK_ITEM *tmp___188 ;
  int ret___0 ;
  int errcode ;
  char *tmp___189 ;
  char *tmp___190 ;
  int tmp___191 ;
  int ret___1 ;
  char *tmp___192 ;
  long stack_size ;
  char *tmp___193 ;
  NODE *tmp___194 ;
  long tmp___195 ;
  long tmp___196 ;
  long tmp___197 ;
  long tmp___198 ;
  char *tmp___199 ;
  int result___0 ;
  INSTRUCTION *ip ;
  int tmp___200 ;
  int tmp___201 ;
  char const   *tmp___202 ;
  char *tmp___203 ;
  void *__cil_tmp251 ;
  void *__cil_tmp252 ;
  void *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;
  char *__cil_tmp278 ;
  char *__cil_tmp279 ;
  char *__cil_tmp280 ;
  char *__cil_tmp281 ;
  char *__cil_tmp282 ;
  char *__cil_tmp283 ;
  char *__cil_tmp284 ;
  char *__cil_tmp285 ;
  char *__cil_tmp286 ;
  char *__cil_tmp287 ;
  char *__cil_tmp288 ;
  char *__cil_tmp289 ;
  char *__cil_tmp290 ;
  char *__cil_tmp291 ;
  char *__cil_tmp292 ;
  char *__cil_tmp293 ;
  char *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;

  {
#line 32
  r = (NODE *)((void *)0);
#line 40
  set_array = (NODE *)((void *)0);
#line 41
  set_idx = (NODE *)((void *)0);
#line 53
  pc = code;
  top: 
#line 65
  if ((int )pc->source_line > 0) {
#line 66
    sourceline = (int )pc->source_line;
  }
#line 75
  op = pc->opcode;
  {
#line 76
  if ((unsigned int )op == 49U) {
#line 76
    goto case_49;
  }
#line 79
  if ((unsigned int )op == 97U) {
#line 79
    goto case_97;
  }
#line 83
  if ((unsigned int )op == 101U) {
#line 83
    goto case_101;
  }
#line 114
  if ((unsigned int )op == 102U) {
#line 114
    goto case_102;
  }
#line 117
  if ((unsigned int )op == 74U) {
#line 117
    goto case_74;
  }
#line 134
  if ((unsigned int )op == 73U) {
#line 134
    goto case_73;
  }
#line 134
  if ((unsigned int )op == 72U) {
#line 134
    goto case_73;
  }
#line 191
  if ((unsigned int )op == 77U) {
#line 191
    goto case_77;
  }
#line 203
  if ((unsigned int )op == 76U) {
#line 203
    goto case_76;
  }
#line 207
  if ((unsigned int )op == 78U) {
#line 207
    goto case_78;
  }
#line 212
  if ((unsigned int )op == 16U) {
#line 212
    goto case_16;
  }
#line 259
  if ((unsigned int )op == 17U) {
#line 259
    goto case_17;
  }
#line 285
  if ((unsigned int )op == 79U) {
#line 285
    goto case_79;
  }
#line 338
  if ((unsigned int )op == 23U) {
#line 338
    goto case_23;
  }
#line 347
  if ((unsigned int )op == 80U) {
#line 347
    goto case_80;
  }
#line 355
  if ((unsigned int )op == 100U) {
#line 355
    goto case_100;
  }
#line 374
  if ((unsigned int )op == 83U) {
#line 374
    goto case_83;
  }
#line 374
  if ((unsigned int )op == 53U) {
#line 374
    goto case_83;
  }
#line 374
  if ((unsigned int )op == 52U) {
#line 374
    goto case_83;
  }
#line 378
  if ((unsigned int )op == 85U) {
#line 378
    goto case_85;
  }
#line 386
  if ((unsigned int )op == 84U) {
#line 386
    goto case_84;
  }
#line 395
  if ((unsigned int )op == 38U) {
#line 395
    goto case_38;
  }
#line 395
  if ((unsigned int )op == 36U) {
#line 395
    goto case_38;
  }
#line 408
  if ((unsigned int )op == 39U) {
#line 408
    goto case_39;
  }
#line 408
  if ((unsigned int )op == 37U) {
#line 408
    goto case_39;
  }
#line 416
  if ((unsigned int )op == 24U) {
#line 416
    goto case_24;
  }
#line 424
  if ((unsigned int )op == 40U) {
#line 424
    goto case_40;
  }
#line 430
  if ((unsigned int )op == 41U) {
#line 430
    goto case_41;
  }
#line 436
  if ((unsigned int )op == 42U) {
#line 436
    goto case_42;
  }
#line 442
  if ((unsigned int )op == 43U) {
#line 442
    goto case_43;
  }
#line 448
  if ((unsigned int )op == 44U) {
#line 448
    goto case_44;
  }
#line 454
  if ((unsigned int )op == 45U) {
#line 454
    goto case_45;
  }
#line 460
  if ((unsigned int )op == 8U) {
#line 460
    goto case_8;
  }
#line 463
  if ((unsigned int )op == 7U) {
#line 463
    goto case_7;
  }
#line 474
  if ((unsigned int )op == 10U) {
#line 474
    goto case_10;
  }
#line 477
  if ((unsigned int )op == 9U) {
#line 477
    goto case_9;
  }
#line 488
  if ((unsigned int )op == 2U) {
#line 488
    goto case_2___0;
  }
#line 491
  if ((unsigned int )op == 1U) {
#line 491
    goto case_1___0;
  }
#line 502
  if ((unsigned int )op == 12U) {
#line 502
    goto case_12;
  }
#line 505
  if ((unsigned int )op == 11U) {
#line 505
    goto case_11;
  }
#line 516
  if ((unsigned int )op == 4U) {
#line 516
    goto case_4___0;
  }
#line 519
  if ((unsigned int )op == 3U) {
#line 519
    goto case_3;
  }
#line 532
  if ((unsigned int )op == 6U) {
#line 532
    goto case_6___0;
  }
#line 535
  if ((unsigned int )op == 5U) {
#line 535
    goto case_5___0;
  }
#line 556
  if ((unsigned int )op == 19U) {
#line 556
    goto case_19;
  }
#line 556
  if ((unsigned int )op == 18U) {
#line 556
    goto case_19;
  }
#line 574
  if ((unsigned int )op == 21U) {
#line 574
    goto case_21;
  }
#line 574
  if ((unsigned int )op == 20U) {
#line 574
    goto case_21;
  }
#line 590
  if ((unsigned int )op == 22U) {
#line 590
    goto case_22;
  }
#line 597
  if ((unsigned int )op == 27U) {
#line 597
    goto case_27;
  }
#line 643
  if ((unsigned int )op == 26U) {
#line 643
    goto case_26;
  }
#line 660
  if ((unsigned int )op == 28U) {
#line 660
    goto case_28;
  }
#line 678
  if ((unsigned int )op == 35U) {
#line 678
    goto case_35;
  }
#line 724
  if ((unsigned int )op == 25U) {
#line 724
    goto case_25;
  }
#line 733
  if ((unsigned int )op == 94U) {
#line 733
    goto case_94;
  }
#line 763
  if ((unsigned int )op == 34U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 31U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 30U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 29U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 33U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 32U) {
#line 763
    goto case_34;
  }
#line 767
  if ((unsigned int )op == 91U) {
#line 767
    goto case_91;
  }
#line 772
  if ((unsigned int )op == 93U) {
#line 772
    goto case_93;
  }
#line 772
  if ((unsigned int )op == 92U) {
#line 772
    goto case_93;
  }
#line 798
  if ((unsigned int )op == 13U) {
#line 798
    goto case_13;
  }
#line 803
  if ((unsigned int )op == 50U) {
#line 803
    goto case_50;
  }
#line 828
  if ((unsigned int )op == 60U) {
#line 828
    goto case_60;
  }
#line 834
  if ((unsigned int )op == 61U) {
#line 834
    goto case_61;
  }
#line 840
  if ((unsigned int )op == 69U) {
#line 840
    goto case_69;
  }
#line 849
  if ((unsigned int )op == 88U) {
#line 849
    goto case_88;
  }
#line 898
  if ((unsigned int )op == 89U) {
#line 898
    goto case_89;
  }
#line 915
  if ((unsigned int )op == 90U) {
#line 915
    goto case_90;
  }
#line 921
  if ((unsigned int )op == 65U) {
#line 921
    goto case_65;
  }
#line 927
  if ((unsigned int )op == 68U) {
#line 927
    goto case_68;
  }
#line 927
  if ((unsigned int )op == 67U) {
#line 927
    goto case_68;
  }
#line 947
  if ((unsigned int )op == 66U) {
#line 947
    goto case_66;
  }
#line 952
  if ((unsigned int )op == 54U) {
#line 952
    goto case_54;
  }
#line 956
  if ((unsigned int )op == 56U) {
#line 956
    goto case_56;
  }
#line 960
  if ((unsigned int )op == 55U) {
#line 960
    goto case_55;
  }
#line 964
  if ((unsigned int )op == 75U) {
#line 964
    goto case_75;
  }
#line 974
  if ((unsigned int )op == 47U) {
#line 974
    goto case_47;
  }
#line 1005
  if ((unsigned int )op == 46U) {
#line 1005
    goto case_46;
  }
#line 1005
  if ((unsigned int )op == 48U) {
#line 1005
    goto case_46;
  }
#line 1017
  if ((unsigned int )op == 71U) {
#line 1017
    goto case_71;
  }
#line 1054
  if ((unsigned int )op == 70U) {
#line 1054
    goto case_70;
  }
#line 1090
  if ((unsigned int )op == 59U) {
#line 1090
    goto case_59;
  }
#line 1100
  if ((unsigned int )op == 62U) {
#line 1100
    goto case_62;
  }
#line 1109
  if ((unsigned int )op == 63U) {
#line 1109
    goto case_63;
  }
#line 1137
  if ((unsigned int )op == 96U) {
#line 1137
    goto case_96;
  }
#line 1144
  if ((unsigned int )op == 95U) {
#line 1144
    goto case_95;
  }
#line 1158
  if ((unsigned int )op == 87U) {
#line 1158
    goto case_87;
  }
#line 1182
  if ((unsigned int )op == 86U) {
#line 1182
    goto case_86;
  }
#line 1209
  if ((unsigned int )op == 64U) {
#line 1209
    goto case_64;
  }
#line 1256
  if ((unsigned int )op == 58U) {
#line 1256
    goto case_58;
  }
#line 1299
  if ((unsigned int )op == 57U) {
#line 1299
    goto case_57;
  }
#line 1306
  if ((unsigned int )op == 82U) {
#line 1306
    goto case_82;
  }
#line 1311
  if ((unsigned int )op == 14U) {
#line 1311
    goto case_14;
  }
#line 1318
  if ((unsigned int )op == 15U) {
#line 1318
    goto case_15;
  }
#line 1344
  if ((unsigned int )op == 98U) {
#line 1344
    goto case_98;
  }
#line 1358
  if ((unsigned int )op == 114U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 112U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 111U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 51U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 110U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 108U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 107U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 109U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 106U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 81U) {
#line 1358
    goto case_114;
  }
#line 1361
  goto switch_default___1;
  case_49: /* CIL Label */ 
#line 77
  currule = (int )pc->x.xl;
  case_97: /* CIL Label */ 
#line 80
  source = pc->d.name;
#line 81
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 85
  stdio_problem = (_Bool)0;
#line 88
  source = (char *)((void *)0);
#line 89
  sourceline = 0;
#line 90
  nextfile(& curfile, (_Bool)1);
#line 101
  close_io(& stdio_problem);
  }
#line 107
  if (stdio_problem) {
#line 107
    if (! exiting) {
#line 107
      if (exit_val == 0) {
#line 108
        exit_val = 1;
      }
    }
  }
  {
#line 110
  close_extensions();
  }
#line 112
  goto switch_break;
  case_102: /* CIL Label */ 
#line 115
  return (0);
  case_74: /* CIL Label */ 
#line 118
  m = pc->d.dn;
#line 119
  if (! (do_flags & 8)) {
#line 119
    if ((m->flags & 128U) != 0U) {
      {
#line 122
      save = *(m->sub.val.sp + m->sub.val.slen);
#line 123
      *(m->sub.val.sp + m->sub.val.slen) = (char )'\000';
#line 124
      orig = m->sub.val.sp;
#line 125
      trans = dgettext((char const   *)TEXTDOMAIN, (char const   *)orig);
#line 126
      *(m->sub.val.sp + m->sub.val.slen) = save;
#line 127
      tmp___1 = strlen((char const   *)trans);
#line 127
      m = make_str_node((char const   *)trans, tmp___1, 0);
      }
    } else {
#line 129
      (m->sub.val.sref) ++;
    }
  } else {
#line 129
    (m->sub.val.sref) ++;
  }
#line 130
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 130
    stack_ptr ++;
#line 130
    tmp___3 = stack_ptr;
  } else {
    {
#line 130
    tmp___2 = grow_stack();
#line 130
    tmp___3 = tmp___2;
    }
  }
#line 130
  tmp___3->rptr = m;
#line 131
  goto switch_break;
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 137
  isparam = (_Bool)0;
#line 139
  m = pc->d.dn;
#line 139
  save_symbol = m;
#line 140
  if ((unsigned int )m->type == 7U) {
#line 141
    isparam = (_Bool)1;
#line 142
    m = *(frame_ptr->sub.nodep.r.av + m->sub.nodep.l.ll);
#line 142
    save_symbol = m;
#line 143
    if ((unsigned int )m->type == 11U) {
#line 144
      if ((unsigned int )(m->sub.nodep.l.lptr)->type == 4U) {
#line 146
        goto uninitialized_scalar;
      }
#line 148
      m = m->sub.nodep.l.lptr;
    }
  }
  {
#line 153
  if ((unsigned int )m->type == 4U) {
#line 153
    goto case_4;
  }
#line 164
  if ((unsigned int )m->type == 6U) {
#line 164
    goto uninitialized_scalar;
  }
#line 177
  if ((unsigned int )m->type == 5U) {
#line 177
    goto case_5;
  }
#line 185
  goto switch_default;
  case_4: /* CIL Label */ 
#line 154
  if (do_flags & 3) {
#line 154
    if ((unsigned long )m->sub.nodep.l.lptr == (unsigned long )Nnull_string) {
      {
#line 155
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 155);
      }
#line 155
      if (isparam) {
        {
#line 155
        tmp___4 = gettext("reference to uninitialized argument `%s\'");
#line 155
        tmp___6 = tmp___4;
        }
      } else {
        {
#line 155
        tmp___5 = gettext("reference to uninitialized variable `%s\'");
#line 155
        tmp___6 = tmp___5;
        }
      }
      {
#line 155
      (*lintfunc)((char const   *)tmp___6, save_symbol->sub.nodep.name);
      }
    }
  }
#line 159
  m = m->sub.nodep.l.lptr;
#line 160
  (m->sub.val.sref) ++;
#line 161
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 161
    stack_ptr ++;
#line 161
    tmp___8 = stack_ptr;
  } else {
    {
#line 161
    tmp___7 = grow_stack();
#line 161
    tmp___8 = tmp___7;
    }
  }
#line 161
  tmp___8->rptr = m;
#line 162
  goto switch_break___0;
  uninitialized_scalar: 
  case_6: /* CIL Label */ 
  {
#line 166
  m->type = (NODETYPE )4;
#line 167
  m->sub.nodep.l.lptr = dupnode(Nnull_string);
  }
#line 168
  if (do_flags & 3) {
    {
#line 169
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 169);
    }
#line 169
    if (isparam) {
      {
#line 169
      tmp___9 = gettext("reference to uninitialized argument `%s\'");
#line 169
      tmp___11 = tmp___9;
      }
    } else {
      {
#line 169
      tmp___10 = gettext("reference to uninitialized variable `%s\'");
#line 169
      tmp___11 = tmp___10;
      }
    }
    {
#line 169
    (*lintfunc)((char const   *)tmp___11, save_symbol->sub.nodep.name);
    }
  }
  {
#line 173
  m = dupnode(Nnull_string);
  }
#line 174
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 174
    stack_ptr ++;
#line 174
    tmp___13 = stack_ptr;
  } else {
    {
#line 174
    tmp___12 = grow_stack();
#line 174
    tmp___13 = tmp___12;
    }
  }
#line 174
  tmp___13->rptr = m;
#line 175
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 178
  if ((unsigned int )op == 73U) {
#line 179
    if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 179
      stack_ptr ++;
#line 179
      tmp___15 = stack_ptr;
    } else {
      {
#line 179
      tmp___14 = grow_stack();
#line 179
      tmp___15 = tmp___14;
      }
    }
#line 179
    tmp___15->rptr = m;
  } else {
    {
#line 181
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 181);
#line 181
    tmp___16 = array_vname((NODE const   *)save_symbol);
#line 181
    tmp___17 = gettext("attempt to use array `%s\' in a scalar context");
#line 181
    r_fatal((char const   *)tmp___17, tmp___16);
    }
  }
#line 183
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 186
  r_fatal("internal error line %d, file: %s", 186, "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 189
  goto switch_break;
  case_77: /* CIL Label */ 
#line 192
  m = pc->d.dn;
#line 193
  if ((unsigned int )m->type == 7U) {
#line 194
    m = *(frame_ptr->sub.nodep.r.av + m->sub.nodep.l.ll);
  }
#line 195
  if ((unsigned int )m->type == 4U) {
#line 196
    m = m->sub.nodep.l.lptr;
#line 197
    (m->sub.val.sref) ++;
#line 198
    if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 198
      stack_ptr ++;
#line 198
      tmp___19 = stack_ptr;
    } else {
      {
#line 198
      tmp___18 = grow_stack();
#line 198
      tmp___19 = tmp___18;
      }
    }
#line 198
    tmp___19->rptr = m;
#line 199
    goto switch_break;
  }
  case_76: /* CIL Label */ 
#line 204
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 204
    stack_ptr ++;
#line 204
    tmp___21 = stack_ptr;
  } else {
    {
#line 204
    tmp___20 = grow_stack();
#line 204
    tmp___21 = tmp___20;
    }
  }
#line 204
  tmp___21->rptr = pc->d.dn;
#line 205
  goto switch_break;
  case_78: /* CIL Label */ 
#line 208
  if ((unsigned int )(pc->d.dn)->type == 4U) {
#line 208
    if (! ((unsigned long )(pc->d.dn)->sub.nodep.l.lptr == (unsigned long )Nnull_string)) {
#line 208
      lhs = & (pc->d.dn)->sub.nodep.l.lptr;
    } else {
      {
#line 208
      tmp___22 = r_get_lhs(pc->d.dn, (_Bool )pc->x.xl);
#line 208
      lhs = tmp___22;
      }
    }
  } else {
    {
#line 208
    tmp___22 = r_get_lhs(pc->d.dn, (_Bool )pc->x.xl);
#line 208
    lhs = tmp___22;
    }
  }
#line 209
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 209
    stack_ptr ++;
#line 209
    tmp___24 = stack_ptr;
  } else {
    {
#line 209
    tmp___23 = grow_stack();
#line 209
    tmp___24 = tmp___23;
    }
  }
#line 209
  tmp___24->lptr = lhs;
#line 210
  goto switch_break;
  case_16: /* CIL Label */ 
#line 213
  if (pc->d.dl == 1L) {
    {
#line 213
    tmp___25 = POP_SCALAR();
#line 213
    t2 = tmp___25;
    }
  } else {
    {
#line 213
    tmp___26 = concat_exp((int )pc->d.dl, (_Bool)1);
#line 213
    t2 = tmp___26;
    }
  }
  {
#line 214
  t1 = POP_ARRAY();
  }
#line 216
  if (do_flags & 3) {
    {
#line 216
    tmp___31 = in_array(t1, t2);
    }
#line 216
    if ((unsigned long )tmp___31 == (unsigned long )((void *)0)) {
      {
#line 217
      t2 = force_string(t2);
#line 218
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 218);
#line 218
      tmp___27 = array_vname((NODE const   *)t1);
#line 218
      tmp___28 = gettext("reference to uninitialized element `%s[\"%.*s\"]\'");
#line 218
      (*lintfunc)((char const   *)tmp___28, tmp___27, (int )t2->sub.val.slen, t2->sub.val.sp);
      }
#line 220
      if (t2->sub.val.slen == 0UL) {
        {
#line 221
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 221);
#line 221
        tmp___29 = array_vname((NODE const   *)t1);
#line 221
        tmp___30 = gettext("subscript of array `%s\' is null string");
#line 221
        (*lintfunc)((char const   *)tmp___30, tmp___29);
        }
      }
    }
  }
#line 225
  if ((unsigned long )t1 == (unsigned long )func_table) {
#line 228
    if (do_flags & 3) {
#line 228
      if (! warned___10) {
        {
#line 229
        warned___10 = (_Bool)1;
#line 230
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 230);
#line 230
        tmp___32 = gettext("FUNCTAB is a gawk extension");
#line 230
        (*lintfunc)((char const   *)tmp___32);
        }
      }
    }
#line 232
    r = t2;
  } else {
#line 235
    if ((unsigned long )t1 == (unsigned long )symbol_table) {
      {
#line 236
      update_global_values();
      }
    }
    {
#line 238
    tmp___33 = (*(*(t1->sub.nodep.l.lp + 3)))(t1, t2);
#line 238
    r = *tmp___33;
    }
  }
  {
#line 240
  DEREF(t2);
  }
#line 243
  if ((unsigned long )t1 == (unsigned long )symbol_table) {
#line 246
    if (do_flags & 3) {
#line 246
      if (! warned___11) {
        {
#line 247
        warned___11 = (_Bool)1;
#line 248
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 248);
#line 248
        tmp___34 = gettext("SYMTAB is a gawk extension");
#line 248
        (*lintfunc)((char const   *)tmp___34);
        }
      }
    }
#line 250
    if ((unsigned int )r->type == 4U) {
#line 251
      r = r->sub.nodep.l.lptr;
    }
  }
#line 254
  if ((unsigned int )r->type == 1U) {
#line 255
    (r->sub.val.sref) ++;
  }
#line 256
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 256
    stack_ptr ++;
#line 256
    tmp___36 = stack_ptr;
  } else {
    {
#line 256
    tmp___35 = grow_stack();
#line 256
    tmp___36 = tmp___35;
    }
  }
#line 256
  tmp___36->rptr = r;
#line 257
  goto switch_break;
  case_17: /* CIL Label */ 
#line 260
  if (pc->d.dl == 1L) {
    {
#line 260
    tmp___37 = POP_SCALAR();
#line 260
    t2 = tmp___37;
    }
  } else {
    {
#line 260
    tmp___38 = concat_exp((int )pc->d.dl, (_Bool)1);
#line 260
    t2 = tmp___38;
    }
  }
  {
#line 261
  t1 = POP_ARRAY();
#line 262
  r = in_array(t1, t2);
  }
#line 263
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 264
    r = make_array();
#line 265
    r->sub.nodep.x.extra = t1;
#line 266
    lhs = (*(*(t1->sub.nodep.l.lp + 3)))(t1, t2);
#line 267
    unref(*lhs);
#line 268
    *lhs = r;
#line 269
    t2 = force_string(t2);
#line 270
    r->sub.nodep.name = estrdup((char const   *)t2->sub.val.sp, t2->sub.val.slen);
    }
#line 273
    if ((unsigned long )*(t1->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
      {
#line 274
      (*(*(t1->sub.nodep.l.lp + 10)))(t1, t2);
      }
    }
  } else
#line 275
  if ((unsigned int )r->type != 5U) {
    {
#line 276
    t2 = force_string(t2);
#line 277
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 277);
#line 277
    tmp___39 = array_vname((NODE const   *)t1);
#line 277
    tmp___40 = gettext("attempt to use scalar `%s[\"%.*s\"]\' as an array");
#line 277
    r_fatal((char const   *)tmp___40, tmp___39, (int )t2->sub.val.slen, t2->sub.val.sp);
    }
  }
  {
#line 281
  DEREF(t2);
  }
#line 282
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 282
    stack_ptr ++;
#line 282
    tmp___42 = stack_ptr;
  } else {
    {
#line 282
    tmp___41 = grow_stack();
#line 282
    tmp___42 = tmp___41;
    }
  }
#line 282
  tmp___42->rptr = r;
#line 283
  goto switch_break;
  case_79: /* CIL Label */ 
#line 286
  if (pc->d.dl == 1L) {
    {
#line 286
    tmp___43 = POP_SCALAR();
#line 286
    t2 = tmp___43;
    }
  } else {
    {
#line 286
    tmp___44 = concat_exp((int )pc->d.dl, (_Bool)1);
#line 286
    t2 = tmp___44;
    }
  }
  {
#line 287
  t1 = POP_ARRAY();
  }
#line 288
  if (do_flags & 3) {
    {
#line 288
    tmp___49 = in_array(t1, t2);
    }
#line 288
    if ((unsigned long )tmp___49 == (unsigned long )((void *)0)) {
      {
#line 289
      t2 = force_string(t2);
      }
#line 290
      if (pc->x.xl) {
        {
#line 291
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 291);
#line 291
        tmp___45 = array_vname((NODE const   *)t1);
#line 291
        tmp___46 = gettext("reference to uninitialized element `%s[\"%.*s\"]\'");
#line 291
        (*lintfunc)((char const   *)tmp___46, tmp___45, (int )t2->sub.val.slen, t2->sub.val.sp);
        }
      }
#line 293
      if (t2->sub.val.slen == 0UL) {
        {
#line 294
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 294);
#line 294
        tmp___47 = array_vname((NODE const   *)t1);
#line 294
        tmp___48 = gettext("subscript of array `%s\' is null string");
#line 294
        (*lintfunc)((char const   *)tmp___48, tmp___47);
        }
      }
    }
  }
  {
#line 297
  lhs = (*(*(t1->sub.nodep.l.lp + 3)))(t1, t2);
  }
#line 298
  if ((unsigned int )(*lhs)->type == 5U) {
    {
#line 299
    t2 = force_string(t2);
#line 300
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 300);
#line 300
    tmp___50 = array_vname((NODE const   *)t1);
#line 300
    tmp___51 = gettext("attempt to use array `%s[\"%.*s\"]\' in a scalar context");
#line 300
    r_fatal((char const   *)tmp___51, tmp___50, (int )t2->sub.val.slen, t2->sub.val.sp);
    }
  }
#line 316
  if ((unsigned long )t1 == (unsigned long )func_table) {
    {
#line 317
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 317);
#line 317
    tmp___52 = gettext("cannot assign to elements of FUNCTAB");
#line 317
    r_fatal((char const   *)tmp___52);
    }
  } else
#line 318
  if ((unsigned long )t1 == (unsigned long )symbol_table) {
#line 318
    if ((unsigned int )(*lhs)->type == 4U) {
      {
#line 321
      update_global_values();
#line 322
      (*lhs)->type = (NODETYPE )4;
#line 323
      lhs = & (*lhs)->sub.nodep.l.lptr;
      }
    } else
#line 318
    if ((unsigned int )(*lhs)->type == 6U) {
      {
#line 321
      update_global_values();
#line 322
      (*lhs)->type = (NODETYPE )4;
#line 323
      lhs = & (*lhs)->sub.nodep.l.lptr;
      }
    }
  }
#line 328
  if (*(t1->sub.nodep.l.lp + 10)) {
#line 330
    set_array = t1;
#line 331
    set_idx = t2;
  } else {
    {
#line 333
    DEREF(t2);
    }
  }
#line 335
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 335
    stack_ptr ++;
#line 335
    tmp___54 = stack_ptr;
  } else {
    {
#line 335
    tmp___53 = grow_stack();
#line 335
    tmp___54 = tmp___53;
    }
  }
#line 335
  tmp___54->lptr = lhs;
#line 336
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 339
  t1 = TOP_SCALAR();
#line 340
  lhs = r_get_field(t1, (Func_ptr *)0, (_Bool)1);
#line 341
  stack_ptr --;
#line 342
  DEREF(t1);
#line 343
  r = dupnode(*lhs);
  }
#line 344
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 344
    stack_ptr ++;
#line 344
    tmp___56 = stack_ptr;
  } else {
    {
#line 344
    tmp___55 = grow_stack();
#line 344
    tmp___56 = tmp___55;
    }
  }
#line 344
  tmp___56->rptr = r;
#line 345
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 348
  t1 = TOP_SCALAR();
#line 349
  lhs = r_get_field(t1, & (pc->d.di)->x.aptr, (_Bool )pc->x.xl);
#line 350
  stack_ptr --;
#line 351
  DEREF(t1);
  }
#line 352
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 352
    stack_ptr ++;
#line 352
    tmp___58 = stack_ptr;
  } else {
    {
#line 352
    tmp___57 = grow_stack();
#line 352
    tmp___58 = tmp___57;
    }
  }
#line 352
  tmp___58->lptr = lhs;
#line 353
  goto switch_break;
  case_100: /* CIL Label */ 
#line 356
  if (do_flags & 3) {
    {
#line 358
    if (pc->d.dl == 1L) {
#line 358
      goto case_1;
    }
#line 362
    if (pc->d.dl == 2L) {
#line 362
      goto case_2;
    }
#line 366
    goto switch_default___0;
    case_1: /* CIL Label */ 
    {
#line 359
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 359);
#line 359
    tmp___59 = gettext("assignment used in conditional context");
#line 359
    (*lintfunc)((char const   *)tmp___59);
    }
#line 360
    goto switch_break___1;
    case_2: /* CIL Label */ 
    {
#line 363
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 363);
#line 363
    tmp___60 = gettext("statement has no effect");
#line 363
    (*lintfunc)((char const   *)tmp___60);
    }
#line 364
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 367
    r_fatal("internal error line %d, file: %s", 367, "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h");
    }
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 370
  goto switch_break;
  case_83: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ ;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    pc = pc->d.di;
#line 376
    goto top;
#line 376
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  case_85: /* CIL Label */ 
  {
#line 379
  r = POP_SCALAR();
#line 380
  di = eval_condition(r);
#line 381
  DEREF(r);
  }
#line 382
  if (! di) {
    {
#line 383
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 383
      pc = pc->d.di;
#line 383
      goto top;
#line 383
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 384
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 387
  r = POP_SCALAR();
#line 388
  di = eval_condition(r);
#line 389
  DEREF(r);
  }
#line 390
  if (di) {
    {
#line 391
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 391
      pc = pc->d.di;
#line 391
      goto top;
#line 391
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 392
  goto switch_break;
  case_38: /* CIL Label */ 
  case_36: /* CIL Label */ 
  {
#line 396
  t1 = POP_SCALAR();
#line 397
  di = eval_condition(t1);
#line 398
  DEREF(t1);
  }
#line 399
  if ((unsigned int )op == 36U) {
#line 399
    if (di) {
#line 400
      goto switch_break;
    } else {
#line 399
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 399
  if ((unsigned int )op == 38U) {
#line 399
    if (! di) {
#line 400
      goto switch_break;
    }
  }
#line 401
  r = node_Boolean[di];
#line 402
  (r->sub.val.sref) ++;
#line 403
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 403
    stack_ptr ++;
#line 403
    tmp___62 = stack_ptr;
  } else {
    {
#line 403
    tmp___61 = grow_stack();
#line 403
    tmp___62 = tmp___61;
    }
  }
#line 403
  tmp___62->rptr = r;
#line 404
  ni = pc->d.di;
  {
#line 405
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 405
    pc = ni->nexti;
#line 405
    goto top;
#line 405
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  case_39: /* CIL Label */ 
  case_37: /* CIL Label */ 
  {
#line 409
  t1 = TOP_SCALAR();
#line 410
  tmp___63 = eval_condition(t1);
#line 410
  r = node_Boolean[tmp___63];
#line 411
  DEREF(t1);
#line 412
  (r->sub.val.sref) ++;
#line 413
  stack_ptr->rptr = r;
  }
#line 414
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 417
  t1 = TOP_SCALAR();
#line 418
  tmp___64 = eval_condition(t1);
  }
#line 418
  if (tmp___64) {
#line 418
    tmp___65 = 0;
  } else {
#line 418
    tmp___65 = 1;
  }
  {
#line 418
  r = node_Boolean[tmp___65];
#line 419
  DEREF(t1);
#line 420
  (r->sub.val.sref) ++;
#line 421
  stack_ptr->rptr = r;
  }
#line 422
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 425
  tmp___66 = cmp_scalars();
#line 425
  r = node_Boolean[tmp___66 == 0];
#line 426
  (r->sub.val.sref) ++;
#line 427
  stack_ptr->rptr = r;
  }
#line 428
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 431
  tmp___67 = cmp_scalars();
#line 431
  r = node_Boolean[tmp___67 != 0];
#line 432
  (r->sub.val.sref) ++;
#line 433
  stack_ptr->rptr = r;
  }
#line 434
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 437
  tmp___68 = cmp_scalars();
#line 437
  r = node_Boolean[tmp___68 < 0];
#line 438
  (r->sub.val.sref) ++;
#line 439
  stack_ptr->rptr = r;
  }
#line 440
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 443
  tmp___69 = cmp_scalars();
#line 443
  r = node_Boolean[tmp___69 > 0];
#line 444
  (r->sub.val.sref) ++;
#line 445
  stack_ptr->rptr = r;
  }
#line 446
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 449
  tmp___70 = cmp_scalars();
#line 449
  r = node_Boolean[tmp___70 <= 0];
#line 450
  (r->sub.val.sref) ++;
#line 451
  stack_ptr->rptr = r;
  }
#line 452
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 455
  tmp___71 = cmp_scalars();
#line 455
  r = node_Boolean[tmp___71 >= 0];
#line 456
  (r->sub.val.sref) ++;
#line 457
  stack_ptr->rptr = r;
  }
#line 458
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 461
  tmp___72 = force_number(pc->d.dn);
#line 461
  x2 = tmp___72->sub.val.nm.fltnum;
  }
#line 462
  goto plus;
  case_7: /* CIL Label */ 
  {
#line 464
  tmp___73 = POP_SCALAR();
#line 464
  t2 = force_number(tmp___73);
#line 465
  x2 = t2->sub.val.nm.fltnum;
#line 466
  DEREF(t2);
  }
  plus: 
  {
#line 468
  tmp___74 = TOP_SCALAR();
#line 468
  t1 = force_number(tmp___74);
#line 469
  r = (*make_number)(t1->sub.val.nm.fltnum + x2);
#line 470
  DEREF(t1);
#line 471
  stack_ptr->rptr = r;
  }
#line 472
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 475
  tmp___75 = force_number(pc->d.dn);
#line 475
  x2 = tmp___75->sub.val.nm.fltnum;
  }
#line 476
  goto minus;
  case_9: /* CIL Label */ 
  {
#line 478
  tmp___76 = POP_SCALAR();
#line 478
  t2 = force_number(tmp___76);
#line 479
  x2 = t2->sub.val.nm.fltnum;
#line 480
  DEREF(t2);
  }
  minus: 
  {
#line 482
  tmp___77 = TOP_SCALAR();
#line 482
  t1 = force_number(tmp___77);
#line 483
  r = (*make_number)(t1->sub.val.nm.fltnum - x2);
#line 484
  DEREF(t1);
#line 485
  stack_ptr->rptr = r;
  }
#line 486
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 489
  tmp___78 = force_number(pc->d.dn);
#line 489
  x2 = tmp___78->sub.val.nm.fltnum;
  }
#line 490
  goto times;
  case_1___0: /* CIL Label */ 
  {
#line 492
  tmp___79 = POP_SCALAR();
#line 492
  t2 = force_number(tmp___79);
#line 493
  x2 = t2->sub.val.nm.fltnum;
#line 494
  DEREF(t2);
  }
  times: 
  {
#line 496
  tmp___80 = TOP_SCALAR();
#line 496
  t1 = force_number(tmp___80);
#line 497
  r = (*make_number)(t1->sub.val.nm.fltnum * x2);
#line 498
  DEREF(t1);
#line 499
  stack_ptr->rptr = r;
  }
#line 500
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 503
  tmp___81 = force_number(pc->d.dn);
#line 503
  x2 = tmp___81->sub.val.nm.fltnum;
  }
#line 504
  goto exp;
  case_11: /* CIL Label */ 
  {
#line 506
  tmp___82 = POP_SCALAR();
#line 506
  t2 = force_number(tmp___82);
#line 507
  x2 = t2->sub.val.nm.fltnum;
#line 508
  DEREF(t2);
  }
  exp: 
  {
#line 510
  tmp___83 = TOP_SCALAR();
#line 510
  t1 = force_number(tmp___83);
#line 511
  tmp___84 = calc_exp(t1->sub.val.nm.fltnum, x2);
#line 511
  r = (*make_number)(tmp___84);
#line 512
  DEREF(t1);
#line 513
  stack_ptr->rptr = r;
  }
#line 514
  goto switch_break;
  case_4___0: /* CIL Label */ 
  {
#line 517
  tmp___85 = force_number(pc->d.dn);
#line 517
  x2 = tmp___85->sub.val.nm.fltnum;
  }
#line 518
  goto quotient;
  case_3: /* CIL Label */ 
  {
#line 520
  tmp___86 = POP_SCALAR();
#line 520
  t2 = force_number(tmp___86);
#line 521
  x2 = t2->sub.val.nm.fltnum;
#line 522
  DEREF(t2);
  }
  quotient: 
  {
#line 524
  tmp___87 = TOP_SCALAR();
#line 524
  t1 = force_number(tmp___87);
  }
#line 525
  if (x2 == (double )0) {
    {
#line 526
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 526);
#line 526
    tmp___88 = gettext("division by zero attempted");
#line 526
    r_fatal((char const   *)tmp___88);
    }
  }
  {
#line 527
  r = (*make_number)(t1->sub.val.nm.fltnum / x2);
#line 528
  DEREF(t1);
#line 529
  stack_ptr->rptr = r;
  }
#line 530
  goto switch_break;
  case_6___0: /* CIL Label */ 
  {
#line 533
  tmp___89 = force_number(pc->d.dn);
#line 533
  x2 = tmp___89->sub.val.nm.fltnum;
  }
#line 534
  goto mod;
  case_5___0: /* CIL Label */ 
  {
#line 536
  tmp___90 = POP_SCALAR();
#line 536
  t2 = force_number(tmp___90);
#line 537
  x2 = t2->sub.val.nm.fltnum;
#line 538
  DEREF(t2);
  }
  mod: 
  {
#line 540
  tmp___91 = TOP_SCALAR();
#line 540
  t1 = force_number(tmp___91);
  }
#line 541
  if (x2 == (double )0) {
    {
#line 542
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 542);
#line 542
    tmp___92 = gettext("division by zero attempted in `%%\'");
#line 542
    r_fatal((char const   *)tmp___92);
    }
  }
  {
#line 544
  x = fmod(t1->sub.val.nm.fltnum, x2);
#line 549
  r = (*make_number)(x);
#line 551
  DEREF(t1);
#line 552
  stack_ptr->rptr = r;
  }
#line 553
  goto switch_break;
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 557
  if ((unsigned int )op == 18U) {
#line 557
    x = 1.0;
  } else {
#line 557
    x = - 1.0;
  }
  {
#line 558
  lhs = stack_ptr->lptr;
#line 559
  t1 = *lhs;
#line 560
  force_number(t1);
  }
#line 561
  if (t1->sub.val.sref == 1L) {
#line 561
    if (t1->flags == 25U) {
#line 563
      t1->sub.val.nm.fltnum += x;
#line 564
      r = t1;
    } else {
      {
#line 566
      tmp___93 = (*make_number)(t1->sub.val.nm.fltnum + x);
#line 566
      *lhs = tmp___93;
#line 566
      r = tmp___93;
#line 567
      unref(t1);
      }
    }
  } else {
    {
#line 566
    tmp___93 = (*make_number)(t1->sub.val.nm.fltnum + x);
#line 566
    *lhs = tmp___93;
#line 566
    r = tmp___93;
#line 567
    unref(t1);
    }
  }
#line 569
  (r->sub.val.sref) ++;
#line 570
  stack_ptr->rptr = r;
#line 571
  goto switch_break;
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
#line 575
  if ((unsigned int )op == 20U) {
#line 575
    x = 1.0;
  } else {
#line 575
    x = - 1.0;
  }
  {
#line 576
  lhs = stack_ptr->lptr;
#line 577
  t1 = *lhs;
#line 578
  force_number(t1);
#line 579
  r = (*make_number)(t1->sub.val.nm.fltnum);
  }
#line 580
  if (t1->sub.val.sref == 1L) {
#line 580
    if (t1->flags == 25U) {
#line 582
      t1->sub.val.nm.fltnum += x;
    } else {
      {
#line 584
      *lhs = (*make_number)(t1->sub.val.nm.fltnum + x);
#line 585
      unref(t1);
      }
    }
  } else {
    {
#line 584
    *lhs = (*make_number)(t1->sub.val.nm.fltnum + x);
#line 585
    unref(t1);
    }
  }
#line 587
  stack_ptr->rptr = r;
#line 588
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 591
  tmp___94 = TOP_SCALAR();
#line 591
  t1 = force_number(tmp___94);
#line 592
  r = (*make_number)(- t1->sub.val.nm.fltnum);
#line 593
  DEREF(t1);
#line 594
  stack_ptr->rptr = r;
  }
#line 595
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 602
  t1 = force_array(pc->d.dn, (_Bool)1);
  }
#line 603
  if (pc->x.xl == 1L) {
    {
#line 603
    tmp___95 = POP_SCALAR();
#line 603
    t2 = tmp___95;
    }
  } else {
    {
#line 603
    tmp___96 = concat_exp((int )pc->x.xl, (_Bool)1);
#line 603
    t2 = tmp___96;
    }
  }
  {
#line 604
  lhs = (*(*(t1->sub.nodep.l.lp + 3)))(t1, t2);
  }
#line 605
  if ((unsigned int )(*lhs)->type == 5U) {
    {
#line 606
    t2 = force_string(t2);
#line 607
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 607);
#line 607
    tmp___97 = array_vname((NODE const   *)t1);
#line 607
    tmp___98 = gettext("attempt to use array `%s[\"%.*s\"]\' in a scalar context");
#line 607
    r_fatal((char const   *)tmp___98, tmp___97, (int )t2->sub.val.slen, t2->sub.val.sp);
    }
  }
  {
#line 610
  DEREF(t2);
  }
#line 624
  if ((unsigned long )t1 == (unsigned long )func_table) {
    {
#line 625
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 625);
#line 625
    tmp___99 = gettext("cannot assign to elements of FUNCTAB");
#line 625
    r_fatal((char const   *)tmp___99);
    }
  } else
#line 626
  if ((unsigned long )t1 == (unsigned long )symbol_table) {
#line 626
    if ((unsigned int )(*lhs)->type == 4U) {
#line 629
      (*lhs)->type = (NODETYPE )4;
#line 630
      lhs = & (*lhs)->sub.nodep.l.lptr;
    } else
#line 626
    if ((unsigned int )(*lhs)->type == 6U) {
#line 629
      (*lhs)->type = (NODETYPE )4;
#line 630
      lhs = & (*lhs)->sub.nodep.l.lptr;
    }
  }
  {
#line 633
  unref(*lhs);
#line 634
  *lhs = POP_SCALAR();
  }
#line 637
  if ((unsigned long )*(t1->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
    {
#line 638
    (*(*(t1->sub.nodep.l.lp + 10)))(t1, t2);
    }
  }
  {
#line 640
  DEREF(t2);
  }
#line 641
  goto switch_break;
  case_26: /* CIL Label */ 
#line 649
  if ((unsigned int )(pc->d.dn)->type == 4U) {
#line 649
    if (! ((unsigned long )(pc->d.dn)->sub.nodep.l.lptr == (unsigned long )Nnull_string)) {
#line 649
      lhs = & (pc->d.dn)->sub.nodep.l.lptr;
    } else {
      {
#line 649
      tmp___100 = r_get_lhs(pc->d.dn, (_Bool)0);
#line 649
      lhs = tmp___100;
      }
    }
  } else {
    {
#line 649
    tmp___100 = r_get_lhs(pc->d.dn, (_Bool)0);
#line 649
    lhs = tmp___100;
    }
  }
  {
#line 650
  unref(*lhs);
#line 651
  r = pc->x.xn;
  }
#line 652
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 653
    *lhs = POP_SCALAR();
    }
  } else {
#line 655
    (r->sub.val.sref) ++;
#line 656
    *lhs = r;
  }
#line 658
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 667
  t1 = TOP_SCALAR();
#line 668
  lhs = r_get_field(t1, & assign, (_Bool)0);
#line 669
  stack_ptr --;
#line 670
  DEREF(t1);
#line 671
  unref(*lhs);
#line 672
  *lhs = POP_SCALAR();
#line 674
  (*assign)();
  }
#line 676
  goto switch_break;
  case_35: /* CIL Label */ 
#line 680
  if ((unsigned int )(pc->d.dn)->type == 4U) {
#line 680
    if (! ((unsigned long )(pc->d.dn)->sub.nodep.l.lptr == (unsigned long )Nnull_string)) {
#line 680
      lhs = & (pc->d.dn)->sub.nodep.l.lptr;
    } else {
      {
#line 680
      tmp___101 = r_get_lhs(pc->d.dn, (_Bool)0);
#line 680
      lhs = tmp___101;
      }
    }
  } else {
    {
#line 680
    tmp___101 = r_get_lhs(pc->d.dn, (_Bool)0);
#line 680
    lhs = tmp___101;
    }
  }
  {
#line 681
  t1 = force_string(*lhs);
#line 682
  tmp___102 = POP_SCALAR();
#line 682
  t2 = force_string(tmp___102);
  }
#line 684
  if ((unsigned long )t1 != (unsigned long )*lhs) {
    {
#line 685
    unref(*lhs);
#line 686
    *lhs = dupnode(t1);
    }
  }
#line 689
  if ((unsigned long )t1 != (unsigned long )t2) {
#line 689
    if (t1->sub.val.sref == 1L) {
#line 689
      if ((t1->flags & 2048U) == 0U) {
        {
#line 690
        nlen = t1->sub.val.slen + t2->sub.val.slen;
#line 692
        tmp___104 = realloc((void *)t1->sub.val.sp, nlen + 2UL);
#line 692
        tmp___103 = (char *)tmp___104;
#line 692
        t1->sub.val.sp = tmp___103;
        }
#line 692
        if (tmp___103) {
#line 692
          tmp___108 = 1;
        } else {
          {
#line 692
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 692);
#line 692
          tmp___105 = __errno_location();
#line 692
          tmp___106 = strerror(*tmp___105);
#line 692
          tmp___107 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 692
          r_fatal((char const   *)tmp___107, "r_interpret", "t1->stptr", (long )(nlen + 2UL),
                  tmp___106);
#line 692
          tmp___108 = 0;
          }
        }
        {
#line 693
        memcpy((void */* __restrict  */)(t1->sub.val.sp + t1->sub.val.slen), (void const   */* __restrict  */)t2->sub.val.sp,
               t2->sub.val.slen);
#line 694
        t1->sub.val.slen = nlen;
#line 695
        *(t1->sub.val.sp + nlen) = (char )'\000';
#line 696
        t1->flags &= 4294967015U;
        }
#line 699
        if ((t1->flags & 1024U) != 0U) {
#line 699
          if ((t2->flags & 1024U) != 0U) {
            {
#line 700
            wlen = t1->sub.val.wslen + t2->sub.val.wslen;
#line 702
            tmp___110 = realloc((void *)((char *)t1->sub.val.wsp), sizeof(wchar_t ) * (wlen + 2UL));
#line 702
            tmp___109 = (wchar_t *)tmp___110;
#line 702
            t1->sub.val.wsp = tmp___109;
            }
#line 702
            if (tmp___109) {
#line 702
              tmp___114 = 1;
            } else {
              {
#line 702
              set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 703);
#line 702
              tmp___111 = __errno_location();
#line 702
              tmp___112 = strerror(*tmp___111);
#line 702
              tmp___113 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 702
              r_fatal((char const   *)tmp___113, "r_interpret", "t1->wstptr", (long )(sizeof(wchar_t ) * (wlen + 2UL)),
                      tmp___112);
#line 702
              tmp___114 = 0;
              }
            }
            {
#line 704
            memcpy((void */* __restrict  */)(t1->sub.val.wsp + t1->sub.val.wslen),
                   (void const   */* __restrict  */)t2->sub.val.wsp, t2->sub.val.wslen);
#line 705
            t1->sub.val.wslen = wlen;
#line 706
            *(t1->sub.val.wsp + wlen) = 0;
#line 707
            t1->flags |= 1024U;
            }
          } else {
#line 699
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 709
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 709
            if ((*lhs)->flags & 1024U) {
              {
#line 709
              r_free_wstr(*lhs);
              }
            }
#line 709
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      } else {
#line 689
        goto _L___2;
      }
    } else {
#line 689
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 712
    nlen___0 = t1->sub.val.slen + t2->sub.val.slen;
#line 715
    tmp___115 = malloc(nlen___0 + 2UL);
#line 715
    p = (char *)tmp___115;
    }
#line 715
    if (p) {
#line 715
      tmp___119 = 1;
    } else {
      {
#line 715
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 715);
#line 715
      tmp___116 = __errno_location();
#line 715
      tmp___117 = strerror(*tmp___116);
#line 715
      tmp___118 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 715
      r_fatal((char const   *)tmp___118, "r_interpret", "p", (long )(nlen___0 + 2UL),
              tmp___117);
#line 715
      tmp___119 = 0;
      }
    }
    {
#line 716
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)t1->sub.val.sp,
           t1->sub.val.slen);
#line 717
    memcpy((void */* __restrict  */)(p + t1->sub.val.slen), (void const   */* __restrict  */)t2->sub.val.sp,
           t2->sub.val.slen);
#line 718
    unref(*lhs);
#line 719
    tmp___120 = make_str_node((char const   *)p, nlen___0, 2);
#line 719
    *lhs = tmp___120;
#line 719
    t1 = tmp___120;
    }
  }
  {
#line 721
  DEREF(t2);
  }
#line 722
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 725
  tmp___121 = stack_ptr;
#line 725
  stack_ptr --;
#line 725
  lhs = tmp___121->lptr;
#line 726
  r = TOP_SCALAR();
#line 727
  unref(*lhs);
#line 728
  *lhs = r;
#line 729
  (r->sub.val.sref) ++;
#line 730
  stack_ptr->rptr = r;
  }
#line 731
  goto switch_break;
  case_94: /* CIL Label */ 
#line 736
  if ((unsigned long )set_idx != (unsigned long )((void *)0)) {
#line 737
    di = 1;
#line 738
    if (pc->d.dl == 66L) {
#line 738
      r = stack_ptr->rptr;
#line 738
      if (r) {
#line 738
        if (r->flags & 2048U) {
          {
#line 738
          tmp___126 = mpfr_get_si((mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 738
          tmp___129 = tmp___126;
          }
        } else {
#line 738
          if (r->flags & 4096U) {
            {
#line 738
            tmp___127 = __gmpz_get_si((mpz_srcptr )(r->sub.val.nm.mpi));
#line 738
            tmp___128 = tmp___127;
            }
          } else {
#line 738
            tmp___128 = (long )r->sub.val.nm.fltnum;
          }
#line 738
          tmp___129 = tmp___128;
        }
#line 738
        if (tmp___129 == 0L) {
#line 742
          di = 0;
        } else {
#line 738
          goto _L___5;
        }
      } else {
#line 738
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 743
    if (pc->d.dl == 63L) {
#line 743
      goto _L___3;
    } else
#line 743
    if (pc->d.dl == 62L) {
      _L___3: /* CIL Label */ 
#line 743
      r = stack_ptr->rptr;
#line 743
      if (r) {
#line 743
        if (r->flags & 2048U) {
          {
#line 743
          tmp___122 = mpfr_get_si((mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 743
          tmp___125 = tmp___122;
          }
        } else {
#line 743
          if (r->flags & 4096U) {
            {
#line 743
            tmp___123 = __gmpz_get_si((mpz_srcptr )(r->sub.val.nm.mpi));
#line 743
            tmp___124 = tmp___123;
            }
          } else {
#line 743
            tmp___124 = (long )r->sub.val.nm.fltnum;
          }
#line 743
          tmp___125 = tmp___124;
        }
#line 743
        if (tmp___125 <= 0L) {
#line 748
          di = 0;
        }
      }
    }
#line 750
    if (di) {
      {
#line 751
      (*(*(set_array->sub.nodep.l.lp + 10)))(set_array, set_idx);
      }
    }
    {
#line 752
    unref(set_idx);
#line 753
    set_idx = (NODE *)((void *)0);
    }
  }
#line 755
  goto switch_break;
  case_34: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 764
  op_assign(op);
  }
#line 765
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 768
  (*(pc->x.aptr))();
  }
#line 769
  goto switch_break;
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 773
  r = stack_ptr->rptr;
#line 774
  if (pc->d.dl == 66L) {
#line 774
    if (r->flags & 2048U) {
      {
#line 774
      tmp___134 = mpfr_get_si((mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 774
      tmp___137 = tmp___134;
      }
    } else {
#line 774
      if (r->flags & 4096U) {
        {
#line 774
        tmp___135 = __gmpz_get_si((mpz_srcptr )(r->sub.val.nm.mpi));
#line 774
        tmp___136 = tmp___135;
        }
      } else {
#line 774
        tmp___136 = (long )r->sub.val.nm.fltnum;
      }
#line 774
      tmp___137 = tmp___136;
    }
#line 774
    if (tmp___137 == 0L) {
#line 782
      goto switch_break;
    } else {
#line 774
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 783
  if (pc->d.dl == 63L) {
#line 783
    goto _L___6;
  } else
#line 783
  if (pc->d.dl == 62L) {
    _L___6: /* CIL Label */ 
#line 783
    if (r->flags & 2048U) {
      {
#line 783
      tmp___130 = mpfr_get_si((mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 783
      tmp___133 = tmp___130;
      }
    } else {
#line 783
      if (r->flags & 4096U) {
        {
#line 783
        tmp___131 = __gmpz_get_si((mpz_srcptr )(r->sub.val.nm.mpi));
#line 783
        tmp___132 = tmp___131;
        }
      } else {
#line 783
        tmp___132 = (long )r->sub.val.nm.fltnum;
      }
#line 783
      tmp___133 = tmp___132;
    }
#line 783
    if (tmp___133 <= 0L) {
#line 789
      goto switch_break;
    }
  }
#line 792
  if ((unsigned int )op == 92U) {
    {
#line 793
    (*(pc->x.aptr))();
    }
  } else {
    {
#line 795
    (*(pc->x.aptr))();
    }
  }
#line 796
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 799
  r = concat_exp((int )pc->x.xl, (_Bool )(pc->d.dl & 1L));
  }
#line 800
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 800
    stack_ptr ++;
#line 800
    tmp___139 = stack_ptr;
  } else {
    {
#line 800
    tmp___138 = grow_stack();
#line 800
    tmp___139 = tmp___138;
    }
  }
#line 800
  tmp___139->rptr = r;
#line 801
  goto switch_break;
  case_50: /* CIL Label */ 
#line 804
  if ((pc + 1)->x.xl) {
    {
#line 807
    tmp___140 = stack_ptr;
#line 807
    stack_ptr --;
#line 807
    m = tmp___140->rptr;
#line 808
    t2 = TOP_SCALAR();
#line 809
    t2 = force_string(t2);
#line 810
    rp = re_update(m);
#line 811
    tmp___141 = avoid_dfa(m, t2->sub.val.sp, t2->sub.val.slen);
#line 811
    tmp___142 = research(rp, t2->sub.val.sp, 0, t2->sub.val.slen, tmp___141);
#line 811
    di = tmp___142 >= 0;
    }
  } else {
    {
#line 814
    t1 = POP_SCALAR();
#line 815
    t2 = TOP_SCALAR();
#line 816
    tmp___143 = cmp_nodes(t2, t1);
#line 816
    di = tmp___143 == 0;
#line 817
    DEREF(t1);
    }
  }
#line 820
  if (di) {
    {
#line 822
    t2 = POP_SCALAR();
#line 823
    DEREF(t2);
    }
    {
#line 824
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 824
      pc = pc->d.di;
#line 824
      goto top;
#line 824
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 826
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 829
  t1 = POP_ARRAY();
#line 830
  do_delete(t1, (int )pc->x.xl);
#line 831
  stack_ptr += - pc->x.xl;
  }
#line 832
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 835
  t1 = POP_ARRAY();
#line 836
  tmp___144 = stack_ptr;
#line 836
  stack_ptr --;
#line 836
  lhs = tmp___144->lptr;
#line 837
  do_delete_loop(t1, lhs);
  }
#line 838
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 841
  t1 = POP_ARRAY();
  }
#line 842
  if (pc->x.xl == 1L) {
    {
#line 842
    tmp___145 = POP_SCALAR();
#line 842
    t2 = tmp___145;
    }
  } else {
    {
#line 842
    tmp___146 = concat_exp((int )pc->x.xl, (_Bool)1);
#line 842
    t2 = tmp___146;
    }
  }
  {
#line 843
  tmp___147 = in_array(t1, t2);
#line 843
  r = node_Boolean[(unsigned long )tmp___147 != (unsigned long )((void *)0)];
#line 844
  DEREF(t2);
#line 845
  (r->sub.val.sref) ++;
  }
#line 846
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 846
    stack_ptr ++;
#line 846
    tmp___149 = stack_ptr;
  } else {
    {
#line 846
    tmp___148 = grow_stack();
#line 846
    tmp___149 = tmp___148;
    }
  }
#line 846
  tmp___149->rptr = r;
#line 847
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 851
  list = (NODE **)((void *)0);
#line 853
  num_elems = (size_t )0;
#line 855
  how_to_sort = "@unsorted";
#line 858
  array = POP_ARRAY();
#line 861
  tmp___150 = (*(*(array->sub.nodep.l.lp + 2)))(array, (struct exp_node *)((void *)0));
#line 861
  num_elems = (*tmp___150)->sub.nodep.reflags;
  }
#line 862
  if (num_elems == 0UL) {
#line 863
    goto arrayfor;
  }
#line 865
  if ((unsigned long )sorted_in == (unsigned long )((void *)0)) {
    {
#line 866
    sorted_in = make_str_node("sorted_in", (size_t )9, 0);
    }
  }
#line 868
  sort_str = (NODE *)((void *)0);
#line 873
  if (! (do_flags & 16)) {
#line 873
    if ((unsigned long )PROCINFO_node != (unsigned long )((void *)0)) {
      {
#line 874
      sort_str = in_array(PROCINFO_node, sorted_in);
      }
    }
  }
#line 876
  if ((unsigned long )sort_str != (unsigned long )((void *)0)) {
    {
#line 877
    sort_str = force_string(sort_str);
    }
#line 878
    if (sort_str->sub.val.slen > 0UL) {
#line 879
      how_to_sort = (char const   *)sort_str->sub.val.sp;
    }
  }
  {
#line 882
  list = assoc_list(array, how_to_sort, (sort_context_t )1);
  }
  arrayfor: 
#line 885
  r = (NODE *)nextfree[1].freep;
#line 885
  if (r) {
#line 885
    nextfree[1].freep = ((BLOCK *)r)->freep;
  } else {
    {
#line 885
    tmp___151 = more_blocks(1);
#line 885
    r = (NODE *)tmp___151;
    }
  }
#line 886
  r->type = (NODETYPE )15;
#line 887
  r->sub.nodep.r.av = list;
#line 888
  r->sub.nodep.reflags = num_elems;
#line 889
  r->sub.nodep.l.ll = -1L;
#line 890
  r->sub.nodep.rn = array;
#line 891
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 891
    stack_ptr ++;
#line 891
    tmp___153 = stack_ptr;
  } else {
    {
#line 891
    tmp___152 = grow_stack();
#line 891
    tmp___153 = tmp___152;
    }
  }
#line 891
  tmp___153->rptr = r;
#line 893
  if (num_elems == 0UL) {
    {
#line 894
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 894
      pc = pc->d.di;
#line 894
      goto top;
#line 894
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 896
  goto switch_break;
  case_89: /* CIL Label */ 
#line 899
  r = stack_ptr->rptr;
#line 900
  (r->sub.nodep.l.ll) ++;
#line 900
  if ((unsigned long )r->sub.nodep.l.ll == r->sub.nodep.reflags) {
#line 902
    array___0 = r->sub.nodep.rn;
#line 903
    if (do_flags & 3) {
#line 903
      if (array___0->sub.nodep.reflags != r->sub.nodep.reflags) {
        {
#line 904
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 904);
#line 904
        tmp___154 = array_vname((NODE const   *)array___0);
#line 904
        tmp___155 = gettext("for loop: array `%s\' changed size from %ld to %ld during loop execution");
#line 904
        (*lintfunc)((char const   *)tmp___155, tmp___154, (long )r->sub.nodep.reflags,
                    (long )array___0->sub.nodep.reflags);
        }
      }
    }
    {
#line 906
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 906
      pc = pc->d.di;
#line 906
      goto top;
#line 906
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 909
  t1 = *(r->sub.nodep.r.av + r->sub.nodep.l.ll);
#line 910
  if ((unsigned int )(pc->x.xn)->type == 4U) {
#line 910
    if (! ((unsigned long )(pc->x.xn)->sub.nodep.l.lptr == (unsigned long )Nnull_string)) {
#line 910
      lhs = & (pc->x.xn)->sub.nodep.l.lptr;
    } else {
      {
#line 910
      tmp___156 = r_get_lhs(pc->x.xn, (_Bool)0);
#line 910
      lhs = tmp___156;
      }
    }
  } else {
    {
#line 910
    tmp___156 = r_get_lhs(pc->x.xn, (_Bool)0);
#line 910
    lhs = tmp___156;
    }
  }
  {
#line 911
  unref(*lhs);
#line 912
  *lhs = dupnode(t1);
  }
#line 913
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 916
  tmp___157 = stack_ptr;
#line 916
  stack_ptr --;
#line 916
  r = tmp___157->rptr;
#line 918
  free_arrayfor(r);
  }
#line 919
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 922
  r = (*(pc->d.fptr))((int )pc->x.xl);
  }
#line 923
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 923
    stack_ptr ++;
#line 923
    tmp___159 = stack_ptr;
  } else {
    {
#line 923
    tmp___158 = grow_stack();
#line 923
    tmp___159 = tmp___158;
    }
  }
#line 923
  tmp___159->rptr = r;
#line 924
  goto switch_break;
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  {
#line 929
  arg_count = (int )pc->x.xl;
#line 932
  PUSH_CODE(pc);
  }
#line 933
  if ((unsigned int )op == 67U) {
    {
#line 934
    tmp___160 = (*(pc->d.efptr))(arg_count, & result);
#line 934
    r = awk_value_to_node((awk_value_t const   *)tmp___160);
    }
  } else {
    {
#line 936
    r = (*(pc->d.fptr))(arg_count);
    }
  }
  {
#line 937
  POP_CODE();
  }
  {
#line 938
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 938
    tmp___162 = arg_count;
#line 938
    arg_count --;
#line 938
    if (! (tmp___162 > 0)) {
#line 938
      goto while_break___7;
    }
#line 939
    tmp___161 = stack_ptr;
#line 939
    stack_ptr --;
#line 939
    t1 = tmp___161->rptr;
#line 940
    if ((unsigned int )t1->type == 1U) {
      {
#line 941
      DEREF(t1);
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 943
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 943
    stack_ptr ++;
#line 943
    tmp___164 = stack_ptr;
  } else {
    {
#line 943
    tmp___163 = grow_stack();
#line 943
    tmp___164 = tmp___163;
    }
  }
#line 943
  tmp___164->rptr = r;
#line 945
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 948
  r = do_sub((int )pc->x.xl, (unsigned int )pc->d.dl);
  }
#line 949
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 949
    stack_ptr ++;
#line 949
    tmp___166 = stack_ptr;
  } else {
    {
#line 949
    tmp___165 = grow_stack();
#line 949
    tmp___166 = tmp___165;
    }
  }
#line 949
  tmp___166->rptr = r;
#line 950
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 953
  do_print((int )pc->x.xl, (int )pc->d.dl);
  }
#line 954
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 957
  do_printf((int )pc->x.xl, (int )pc->d.dl);
  }
#line 958
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 961
  do_print_rec((int )pc->x.xl, (int )pc->d.dl);
  }
#line 962
  goto switch_break;
  case_75: /* CIL Label */ 
#line 965
  m = pc->d.dn;
#line 966
  if ((unsigned int )m->type == 3U) {
    {
#line 967
    tmp___167 = POP_SCALAR();
#line 967
    r = force_string(tmp___167);
#line 968
    unref(m->sub.nodep.x.extra);
#line 969
    m->sub.nodep.x.extra = r;
    }
  }
#line 971
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 971
    stack_ptr ++;
#line 971
    tmp___169 = stack_ptr;
  } else {
    {
#line 971
    tmp___168 = grow_stack();
#line 971
    tmp___169 = tmp___168;
    }
  }
#line 971
  tmp___169->rptr = m;
#line 972
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 975
  m = pc->d.dn;
#line 976
  tmp___170 = get_field(0L, (Func_ptr *)0);
#line 976
  t1 = *tmp___170;
  }
  match_re: 
  {
#line 978
  rp = re_update(m);
#line 991
  tmp___171 = avoid_dfa(m, t1->sub.val.sp, t1->sub.val.slen);
#line 991
  di = research(rp, t1->sub.val.sp, 0, t1->sub.val.slen, tmp___171);
#line 993
  di = (di == -1) ^ ((unsigned int )op != 48U);
  }
#line 994
  if ((unsigned int )op != 47U) {
    {
#line 995
    stack_ptr --;
#line 996
    DEREF(t1);
    }
  }
#line 998
  r = node_Boolean[di];
#line 999
  (r->sub.val.sref) ++;
#line 1000
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1000
    stack_ptr ++;
#line 1000
    tmp___173 = stack_ptr;
  } else {
    {
#line 1000
    tmp___172 = grow_stack();
#line 1000
    tmp___173 = tmp___172;
    }
  }
#line 1000
  tmp___173->rptr = r;
#line 1001
  goto switch_break;
  case_46: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 1006
  m = pc->d.dn;
#line 1007
  tmp___174 = TOP_SCALAR();
#line 1007
  t1 = force_string(tmp___174);
  }
#line 1008
  if ((unsigned int )m->type == 3U) {
    {
#line 1009
    unref(m->sub.nodep.x.extra);
#line 1010
    m->sub.nodep.x.extra = t1;
#line 1011
    stack_ptr --;
#line 1012
    tmp___175 = TOP_SCALAR();
#line 1012
    t1 = force_string(tmp___175);
    }
  }
#line 1014
  goto match_re;
#line 1015
  goto switch_break;
  case_71: /* CIL Label */ 
#line 1019
  f = (NODE *)((void *)0);
#line 1022
  arg_count___0 = (int )(pc + 1)->x.xl;
#line 1023
  t1 = (stack_ptr - arg_count___0)->rptr;
#line 1025
  if ((unsigned int )t1->type != 1U) {
    {
#line 1026
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1026);
#line 1026
    tmp___176 = gettext("indirect function call requires a simple scalar value");
#line 1026
    r_fatal((char const   *)tmp___176);
    }
  }
  {
#line 1028
  t1 = force_string(t1);
  }
#line 1029
  if (t1->sub.val.slen > 0UL) {
#line 1031
    f = pc->x.xn;
#line 1032
    if ((unsigned long )f != (unsigned long )((void *)0)) {
      {
#line 1032
      tmp___177 = strcmp((char const   *)f->sub.nodep.name, (char const   *)t1->sub.val.sp);
      }
#line 1032
      if (tmp___177 == 0) {
        {
#line 1035
        ni = setup_frame(pc);
        }
        {
#line 1036
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1036
          pc = ni;
#line 1036
          goto top;
#line 1036
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
    {
#line 1038
    f = lookup((char const   *)t1->sub.val.sp);
    }
  }
#line 1041
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1041
    goto _L___8;
  } else
#line 1041
  if ((unsigned int )f->type != 8U) {
    _L___8: /* CIL Label */ 
#line 1042
    if ((unsigned int )f->type == 9U) {
      {
#line 1043
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1043);
#line 1043
      tmp___178 = gettext("cannot (yet) call extension functions indirectly");
#line 1043
      r_fatal((char const   *)tmp___178);
      }
    } else
#line 1042
    if ((unsigned int )f->type == 10U) {
      {
#line 1043
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1043);
#line 1043
      tmp___178 = gettext("cannot (yet) call extension functions indirectly");
#line 1043
      r_fatal((char const   *)tmp___178);
      }
    } else {
      {
#line 1045
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1045);
#line 1045
      tmp___179 = gettext("function called indirectly through `%s\' does not exist");
#line 1045
      r_fatal((char const   *)tmp___179, pc->d.name);
      }
    }
  }
  {
#line 1048
  pc->x.xn = f;
#line 1050
  ni = setup_frame(pc);
  }
  {
#line 1051
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1051
    pc = ni;
#line 1051
    goto top;
#line 1051
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  case_70: /* CIL Label */ 
#line 1059
  f___0 = pc->x.xn;
#line 1060
  if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
    {
#line 1061
    f___0 = lookup((char const   *)pc->d.name);
    }
#line 1062
    if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
      {
#line 1063
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1063);
#line 1063
      tmp___180 = gettext("function `%s\' not defined");
#line 1063
      r_fatal((char const   *)tmp___180, pc->d.name);
      }
    } else
#line 1062
    if ((unsigned int )f___0->type != 8U) {
#line 1062
      if ((unsigned int )f___0->type != 9U) {
#line 1062
        if ((unsigned int )f___0->type != 10U) {
          {
#line 1063
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1063);
#line 1063
          tmp___180 = gettext("function `%s\' not defined");
#line 1063
          r_fatal((char const   *)tmp___180, pc->d.name);
          }
        }
      }
    }
#line 1064
    pc->x.xn = f___0;
  }
#line 1067
  if ((unsigned int )f___0->type == 9U) {
#line 1067
    goto _L___9;
  } else
#line 1067
  if ((unsigned int )f___0->type == 10U) {
    _L___9: /* CIL Label */ 
#line 1069
    fname = pc->d.name;
#line 1070
    arg_count___1 = (int )(pc + 1)->x.xl;
#line 1072
    bc = f___0->sub.nodep.r.iptr;
#line 1074
    if ((unsigned int )f___0->type == 9U) {
#line 1075
      pc->opcode = (OPCODE )67;
    } else {
#line 1077
      pc->opcode = (OPCODE )68;
    }
#line 1078
    pc->d.efptr = bc->d.efptr;
#line 1079
    pc->x.xl = (long )arg_count___1;
#line 1080
    (pc + 1)->d.name = fname;
#line 1081
    (pc + 1)->x.xl = bc->x.xl;
#line 1082
    ni = pc;
    {
#line 1083
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1083
      pc = ni;
#line 1083
      goto top;
#line 1083
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  {
#line 1086
  ni = setup_frame(pc);
  }
  {
#line 1087
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1087
    pc = ni;
#line 1087
    goto top;
#line 1087
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  case_59: /* CIL Label */ 
  {
#line 1091
  m = POP_SCALAR();
#line 1093
  ni = unwind_stack((long )frame_ptr->sub.nodep.reflags);
  }
#line 1096
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1096
    stack_ptr ++;
#line 1096
    tmp___182 = stack_ptr;
  } else {
    {
#line 1096
    tmp___181 = grow_stack();
#line 1096
    tmp___182 = tmp___181;
    }
  }
#line 1096
  tmp___182->rptr = m;
  {
#line 1098
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1098
    pc = ni;
#line 1098
    goto top;
#line 1098
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  case_62: /* CIL Label */ 
#line 1101
  if (currule == 4) {
#line 1101
    goto _L___10;
  } else
#line 1101
  if (currule == 5) {
    _L___10: /* CIL Label */ 
#line 1101
    if (pc->x.xl == 0L) {
#line 1101
      if (pc->d.dl == 5L) {
        {
#line 1104
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1104);
#line 1104
        tmp___183 = gettext("`getline\' invalid inside `%s\' rule");
#line 1104
        r_fatal((char const   *)tmp___183, ruletab[currule]);
        }
      }
    }
  }
  {
#line 1105
  r = do_getline_redir((int )pc->x.xl, (enum redirval )pc->d.dl);
  }
#line 1106
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1106
    stack_ptr ++;
#line 1106
    tmp___185 = stack_ptr;
  } else {
    {
#line 1106
    tmp___184 = grow_stack();
#line 1106
    tmp___185 = tmp___184;
    }
  }
#line 1106
  tmp___185->rptr = r;
#line 1107
  goto switch_break;
  case_63: /* CIL Label */ 
#line 1110
  if (! currule) {
    {
#line 1111
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1111);
#line 1111
    tmp___186 = gettext("non-redirected `getline\' invalid inside `%s\' rule");
#line 1111
    r_fatal((char const   *)tmp___186, ruletab[currule]);
    }
  } else
#line 1110
  if (currule == 4) {
    {
#line 1111
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1111);
#line 1111
    tmp___186 = gettext("non-redirected `getline\' invalid inside `%s\' rule");
#line 1111
    r_fatal((char const   *)tmp___186, ruletab[currule]);
    }
  } else
#line 1110
  if (currule == 5) {
    {
#line 1111
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1111);
#line 1111
    tmp___186 = gettext("non-redirected `getline\' invalid inside `%s\' rule");
#line 1111
    r_fatal((char const   *)tmp___186, ruletab[currule]);
    }
  }
  {
#line 1114
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 1116
    ret = nextfile(& curfile, (_Bool)0);
    }
#line 1117
    if (ret <= 0) {
      {
#line 1118
      r = do_getline((int )pc->x.xl, curfile);
      }
    } else {
      {
#line 1125
      push_exec_state(pc, currule, source, stack_ptr);
      }
#line 1127
      if ((unsigned long )curfile == (unsigned long )((void *)0)) {
        {
#line 1128
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 1128
          pc = (pc + 1)->x.xi;
#line 1128
          goto top;
#line 1128
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      } else {
        {
#line 1130
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 1130
          pc = (pc + 1)->d.di;
#line 1130
          goto top;
#line 1130
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
    }
#line 1114
    if (! ((unsigned long )r == (unsigned long )((void *)0))) {
#line 1114
      goto while_break___13;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 1134
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1134
    stack_ptr ++;
#line 1134
    tmp___188 = stack_ptr;
  } else {
    {
#line 1134
    tmp___187 = grow_stack();
#line 1134
    tmp___188 = tmp___187;
    }
  }
#line 1134
  tmp___188->rptr = r;
#line 1135
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 1139
  ni = pop_exec_state(& currule, & source, (long *)((void *)0));
  }
  {
#line 1142
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1142
    pc = ni;
#line 1142
    goto top;
#line 1142
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  case_95: /* CIL Label */ 
  {
#line 1145
  after_beginfile(& curfile);
#line 1148
  ni = pop_exec_state(& currule, & source, (long *)((void *)0));
  }
#line 1151
  if ((unsigned int )ni->opcode == 63U) {
#line 1151
    goto _L___11;
  } else
#line 1151
  if ((unsigned long )curfile == (unsigned long )((void *)0)) {
    _L___11: /* CIL Label */ 
    {
#line 1154
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1154
      pc = ni;
#line 1154
      goto top;
#line 1154
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
#line 1156
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 1162
  ret___0 = nextfile(& curfile, (_Bool)0);
  }
#line 1164
  if (ret___0 < 0) {
    {
#line 1165
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1165
      pc = pc->d.di;
#line 1165
      goto top;
#line 1165
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
  }
#line 1167
  if (ret___0 == 0) {
    {
#line 1168
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1168
      pc = (pc + 1)->x.xi;
#line 1168
      goto top;
#line 1168
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
  }
  {
#line 1173
  push_exec_state(pc, currule, source, stack_ptr);
  }
#line 1175
  if ((unsigned long )curfile == (unsigned long )((void *)0)) {
    {
#line 1176
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 1176
      pc = pc->x.xi;
#line 1176
      goto top;
#line 1176
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
  }
#line 1180
  goto switch_break;
  case_86: /* CIL Label */ 
#line 1184
  errcode = 0;
#line 1186
  ni = pc->d.di;
#line 1187
  if ((unsigned long )curfile == (unsigned long )((void *)0)) {
#line 1194
    ni = ni->d.di;
    {
#line 1195
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1195
      pc = ni;
#line 1195
      goto top;
#line 1195
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
  }
  {
#line 1198
  tmp___191 = inrec(curfile, & errcode);
  }
#line 1198
  if (tmp___191 != 0) {
#line 1199
    if (errcode > 0) {
#line 1199
      if (do_flags & 8) {
        {
#line 1200
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1200);
#line 1200
        tmp___189 = strerror(errcode);
#line 1200
        tmp___190 = gettext("error reading input file `%s\': %s");
#line 1200
        r_fatal((char const   *)tmp___190, curfile->public.name, tmp___189);
        }
      } else
#line 1199
      if (! pc->x.xl) {
        {
#line 1200
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1200);
#line 1200
        tmp___189 = strerror(errcode);
#line 1200
        tmp___190 = gettext("error reading input file `%s\': %s");
#line 1200
        r_fatal((char const   *)tmp___190, curfile->public.name, tmp___189);
        }
      }
    }
    {
#line 1203
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1203
      pc = ni;
#line 1203
      goto top;
#line 1203
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
  }
#line 1207
  goto switch_break;
  case_64: /* CIL Label */ 
#line 1213
  if (currule != 2) {
#line 1213
    if (currule != 4) {
      {
#line 1214
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1214);
#line 1214
      tmp___192 = gettext("`nextfile\' cannot be called from a `%s\' rule");
#line 1214
      r_fatal((char const   *)tmp___192, ruletab[currule]);
      }
    }
  }
  {
#line 1217
  ret___1 = nextfile(& curfile, (_Bool)1);
  }
#line 1219
  if (currule == 4) {
    {
#line 1222
    ni = pop_exec_state(& currule, & source, & stack_size);
#line 1227
    unwind_stack(stack_size);
    }
#line 1229
    if (ret___1 == 0) {
      {
#line 1234
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 1234
        pc = ni;
#line 1234
        goto top;
#line 1234
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
    } else {
      {
#line 1239
      push_exec_state(ni, currule, source, stack_ptr);
      }
      {
#line 1241
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 1241
        pc = pc->x.xi;
#line 1241
        goto top;
#line 1241
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
    }
  }
  {
#line 1247
  unwind_stack(0L);
#line 1250
  push_exec_state(pc->d.di, currule, source, stack_ptr);
  }
  {
#line 1252
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 1252
    pc = pc->x.xi;
#line 1252
    goto top;
#line 1252
    goto while_break___25;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 1254
  goto switch_break;
  case_58: /* CIL Label */ 
#line 1260
  if (! currule) {
    {
#line 1261
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1261);
#line 1261
    tmp___193 = gettext("`exit\' cannot be called in the current context");
#line 1261
    r_fatal((char const   *)tmp___193);
    }
  }
  {
#line 1263
  exiting = (_Bool)1;
#line 1264
  tmp___194 = POP_SCALAR();
#line 1264
  t1 = force_number(tmp___194);
  }
#line 1265
  if (t1->flags & 2048U) {
    {
#line 1265
    tmp___195 = mpfr_get_si((mpfr_srcptr )(t1->sub.val.nm.mpnum), ROUND_MODE);
#line 1265
    tmp___198 = tmp___195;
    }
  } else {
#line 1265
    if (t1->flags & 4096U) {
      {
#line 1265
      tmp___196 = __gmpz_get_si((mpz_srcptr )(t1->sub.val.nm.mpi));
#line 1265
      tmp___197 = tmp___196;
      }
    } else {
#line 1265
      tmp___197 = (long )t1->sub.val.nm.fltnum;
    }
#line 1265
    tmp___198 = tmp___197;
  }
  {
#line 1265
  exit_val = (int )tmp___198;
#line 1266
  DEREF(t1);
  }
#line 1276
  if (currule == 4) {
    {
#line 1284
    pop_exec_state(& currule, & source, (long *)((void *)0));
    }
  } else
#line 1276
  if (currule == 5) {
    {
#line 1284
    pop_exec_state(& currule, & source, (long *)((void *)0));
    }
  }
  {
#line 1287
  unwind_stack(0L);
  }
#line 1293
  if (currule == 3) {
#line 1294
    ni = pc->x.xi;
  } else {
#line 1296
    ni = pc->d.di;
  }
  {
#line 1297
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 1297
    pc = ni;
#line 1297
    goto top;
#line 1297
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
  case_57: /* CIL Label */ 
#line 1300
  if (currule != 2) {
    {
#line 1301
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1301);
#line 1301
    tmp___199 = gettext("`next\' cannot be called from a `%s\' rule");
#line 1301
    r_fatal((char const   *)tmp___199, ruletab[currule]);
    }
  }
  {
#line 1303
  unwind_stack(0L);
  }
  {
#line 1304
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 1304
    pc = pc->d.di;
#line 1304
    goto top;
#line 1304
    goto while_break___27;
  }
  while_break___27: /* CIL Label */ ;
  }
  case_82: /* CIL Label */ 
  {
#line 1307
  r = POP_SCALAR();
#line 1308
  DEREF(r);
  }
#line 1309
  goto switch_break;
  case_14: /* CIL Label */ 
#line 1312
  if (pc->x.xl) {
    {
#line 1313
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1313
      pc = pc->d.di;
#line 1313
      goto top;
#line 1313
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
  }
#line 1316
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 1323
  t1 = TOP_SCALAR();
#line 1324
  tmp___200 = eval_condition(t1);
#line 1324
  di = tmp___200 != 0;
#line 1325
  DEREF(t1);
#line 1327
  ip = pc->x.xi;
  }
#line 1329
  if (! ip->x.xl) {
#line 1329
    if (di) {
#line 1331
      stack_ptr --;
#line 1332
      ip->x.xl = 1L;
      {
#line 1333
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 1333
        pc = ip->d.di;
#line 1333
        goto top;
#line 1333
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
    }
  }
#line 1336
  if (ip->x.xl) {
#line 1336
    tmp___201 = 1;
  } else
#line 1336
  if (di) {
#line 1336
    tmp___201 = 1;
  } else {
#line 1336
    tmp___201 = 0;
  }
#line 1336
  result___0 = tmp___201;
#line 1337
  ip->x.xl ^= (long )di;
#line 1338
  r = node_Boolean[result___0];
#line 1339
  (r->sub.val.sref) ++;
#line 1340
  stack_ptr->rptr = r;
  {
#line 1341
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 1341
    pc = pc->d.di;
#line 1341
    goto top;
#line 1341
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
  case_98: /* CIL Label */ 
#line 1345
  if (do_flags & 4096) {
#line 1346
    (pc->d.dl) ++;
  }
#line 1347
  goto switch_break;
  case_114: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_81: /* CIL Label */ 
#line 1359
  goto switch_break;
  switch_default___1: /* CIL Label */ 
  {
#line 1362
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1362);
#line 1362
  tmp___202 = opcode2str(op);
#line 1362
  tmp___203 = gettext("Sorry, don\'t know how to interpret `%s\'");
#line 1362
  r_fatal((char const   *)tmp___203, tmp___202);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1365
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 1365
    pc = pc->nexti;
#line 1365
    goto top;
#line 1365
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
#line 1370
  return (0);
}
}
#line 226
int h_interpret(INSTRUCTION *code ) ;
#line 226 "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h"
static _Bool warned___12  =    (_Bool)0;
#line 244 "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h"
static _Bool warned___13  =    (_Bool)0;
#line 854 "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h"
static NODE *sorted_in___0  =    (NODE *)((void *)0);
#line 27 "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h"
int h_interpret(INSTRUCTION *code ) 
{ 
  INSTRUCTION *pc ;
  OPCODE op ;
  NODE *r ;
  NODE *m ;
  INSTRUCTION *ni ;
  NODE *t1 ;
  NODE *t2 ;
  NODE **lhs ;
  double x ;
  double x2 ;
  int di ;
  Regexp *rp ;
  NODE *set_array ;
  NODE *set_idx ;
  int tmp___1 ;
  _Bool stdio_problem ;
  char *orig ;
  char *trans ;
  char save ;
  size_t tmp___2 ;
  STACK_ITEM *tmp___3 ;
  STACK_ITEM *tmp___4 ;
  NODE *save_symbol ;
  _Bool isparam ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  STACK_ITEM *tmp___8 ;
  STACK_ITEM *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  STACK_ITEM *tmp___13 ;
  STACK_ITEM *tmp___14 ;
  STACK_ITEM *tmp___15 ;
  STACK_ITEM *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  STACK_ITEM *tmp___19 ;
  STACK_ITEM *tmp___20 ;
  STACK_ITEM *tmp___21 ;
  STACK_ITEM *tmp___22 ;
  NODE **tmp___23 ;
  STACK_ITEM *tmp___24 ;
  STACK_ITEM *tmp___25 ;
  NODE *tmp___26 ;
  NODE *tmp___27 ;
  char const   *tmp___28 ;
  char *tmp___29 ;
  char const   *tmp___30 ;
  char *tmp___31 ;
  NODE *tmp___32 ;
  char *tmp___33 ;
  struct exp_node **tmp___34 ;
  char *tmp___35 ;
  STACK_ITEM *tmp___36 ;
  STACK_ITEM *tmp___37 ;
  NODE *tmp___38 ;
  NODE *tmp___39 ;
  char const   *tmp___40 ;
  char *tmp___41 ;
  STACK_ITEM *tmp___42 ;
  STACK_ITEM *tmp___43 ;
  NODE *tmp___44 ;
  NODE *tmp___45 ;
  char const   *tmp___46 ;
  char *tmp___47 ;
  char const   *tmp___48 ;
  char *tmp___49 ;
  NODE *tmp___50 ;
  char const   *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  STACK_ITEM *tmp___54 ;
  STACK_ITEM *tmp___55 ;
  STACK_ITEM *tmp___56 ;
  STACK_ITEM *tmp___57 ;
  STACK_ITEM *tmp___58 ;
  STACK_ITEM *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  STACK_ITEM *tmp___62 ;
  STACK_ITEM *tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  NODE *tmp___73 ;
  NODE *tmp___74 ;
  NODE *tmp___75 ;
  NODE *tmp___76 ;
  NODE *tmp___77 ;
  NODE *tmp___78 ;
  NODE *tmp___79 ;
  NODE *tmp___80 ;
  NODE *tmp___81 ;
  NODE *tmp___82 ;
  NODE *tmp___83 ;
  NODE *tmp___84 ;
  double tmp___85 ;
  NODE *tmp___86 ;
  NODE *tmp___87 ;
  NODE *tmp___88 ;
  char *tmp___89 ;
  NODE *tmp___90 ;
  NODE *tmp___91 ;
  NODE *tmp___92 ;
  char *tmp___93 ;
  NODE *tmp___94 ;
  NODE *tmp___95 ;
  NODE *tmp___96 ;
  NODE *tmp___97 ;
  char const   *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  NODE **tmp___101 ;
  void (*assign)(void) ;
  NODE **tmp___102 ;
  NODE *tmp___103 ;
  size_t nlen ;
  char *tmp___104 ;
  void *tmp___105 ;
  int *tmp___106 ;
  char *tmp___107 ;
  char *tmp___108 ;
  int tmp___109 ;
  size_t wlen ;
  wchar_t *tmp___110 ;
  void *tmp___111 ;
  int *tmp___112 ;
  char *tmp___113 ;
  char *tmp___114 ;
  int tmp___115 ;
  size_t nlen___0 ;
  char *p ;
  void *tmp___116 ;
  int *tmp___117 ;
  char *tmp___118 ;
  char *tmp___119 ;
  int tmp___120 ;
  NODE *tmp___121 ;
  STACK_ITEM *tmp___122 ;
  long tmp___123 ;
  long tmp___124 ;
  long tmp___125 ;
  long tmp___126 ;
  long tmp___127 ;
  long tmp___128 ;
  long tmp___129 ;
  long tmp___130 ;
  long tmp___131 ;
  long tmp___132 ;
  long tmp___133 ;
  long tmp___134 ;
  long tmp___135 ;
  long tmp___136 ;
  long tmp___137 ;
  long tmp___138 ;
  STACK_ITEM *tmp___139 ;
  STACK_ITEM *tmp___140 ;
  STACK_ITEM *tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  STACK_ITEM *tmp___145 ;
  NODE *tmp___146 ;
  NODE *tmp___147 ;
  NODE *tmp___148 ;
  STACK_ITEM *tmp___149 ;
  STACK_ITEM *tmp___150 ;
  NODE **list ;
  NODE *array ;
  NODE *sort_str ;
  size_t num_elems ;
  char const   *how_to_sort ;
  struct exp_node **tmp___151 ;
  void *tmp___152 ;
  STACK_ITEM *tmp___153 ;
  STACK_ITEM *tmp___154 ;
  NODE *array___0 ;
  char const   *tmp___155 ;
  char *tmp___156 ;
  NODE **tmp___157 ;
  STACK_ITEM *tmp___158 ;
  STACK_ITEM *tmp___159 ;
  STACK_ITEM *tmp___160 ;
  int arg_count ;
  awk_value_t result ;
  awk_value_t *tmp___161 ;
  STACK_ITEM *tmp___162 ;
  int tmp___163 ;
  STACK_ITEM *tmp___164 ;
  STACK_ITEM *tmp___165 ;
  STACK_ITEM *tmp___166 ;
  STACK_ITEM *tmp___167 ;
  NODE *tmp___168 ;
  STACK_ITEM *tmp___169 ;
  STACK_ITEM *tmp___170 ;
  NODE **tmp___171 ;
  int tmp___172 ;
  STACK_ITEM *tmp___173 ;
  STACK_ITEM *tmp___174 ;
  NODE *tmp___175 ;
  NODE *tmp___176 ;
  NODE *f ;
  int arg_count___0 ;
  char *tmp___177 ;
  int tmp___178 ;
  char *tmp___179 ;
  char *tmp___180 ;
  NODE *f___0 ;
  char *tmp___181 ;
  INSTRUCTION *bc ;
  char *fname ;
  int arg_count___1 ;
  STACK_ITEM *tmp___182 ;
  STACK_ITEM *tmp___183 ;
  char *tmp___184 ;
  STACK_ITEM *tmp___185 ;
  STACK_ITEM *tmp___186 ;
  char *tmp___187 ;
  int ret ;
  STACK_ITEM *tmp___188 ;
  STACK_ITEM *tmp___189 ;
  int ret___0 ;
  int errcode ;
  char *tmp___190 ;
  char *tmp___191 ;
  int tmp___192 ;
  int ret___1 ;
  char *tmp___193 ;
  long stack_size ;
  char *tmp___194 ;
  NODE *tmp___195 ;
  long tmp___196 ;
  long tmp___197 ;
  long tmp___198 ;
  long tmp___199 ;
  char *tmp___200 ;
  int result___0 ;
  INSTRUCTION *ip ;
  int tmp___201 ;
  int tmp___202 ;
  char const   *tmp___203 ;
  char *tmp___204 ;
  void *__cil_tmp252 ;
  void *__cil_tmp253 ;
  void *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;
  char *__cil_tmp278 ;
  char *__cil_tmp279 ;
  char *__cil_tmp280 ;
  char *__cil_tmp281 ;
  char *__cil_tmp282 ;
  char *__cil_tmp283 ;
  char *__cil_tmp284 ;
  char *__cil_tmp285 ;
  char *__cil_tmp286 ;
  char *__cil_tmp287 ;
  char *__cil_tmp288 ;
  char *__cil_tmp289 ;
  char *__cil_tmp290 ;
  char *__cil_tmp291 ;
  char *__cil_tmp292 ;
  char *__cil_tmp293 ;
  char *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;

  {
#line 32
  r = (NODE *)((void *)0);
#line 40
  set_array = (NODE *)((void *)0);
#line 41
  set_idx = (NODE *)((void *)0);
#line 53
  pc = code;
  top: 
#line 65
  if ((int )pc->source_line > 0) {
#line 66
    sourceline = (int )pc->source_line;
  }
#line 69
  di = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! (di < num_exec_hook)) {
#line 69
      goto while_break;
    }
    {
#line 70
    tmp___1 = (*(pre_execute[di]))(& pc);
    }
#line 70
    if (! tmp___1) {
#line 71
      goto top;
    }
#line 69
    di ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  op = pc->opcode;
  {
#line 76
  if ((unsigned int )op == 49U) {
#line 76
    goto case_49;
  }
#line 79
  if ((unsigned int )op == 97U) {
#line 79
    goto case_97;
  }
#line 83
  if ((unsigned int )op == 101U) {
#line 83
    goto case_101;
  }
#line 114
  if ((unsigned int )op == 102U) {
#line 114
    goto case_102;
  }
#line 117
  if ((unsigned int )op == 74U) {
#line 117
    goto case_74;
  }
#line 134
  if ((unsigned int )op == 73U) {
#line 134
    goto case_73;
  }
#line 134
  if ((unsigned int )op == 72U) {
#line 134
    goto case_73;
  }
#line 191
  if ((unsigned int )op == 77U) {
#line 191
    goto case_77;
  }
#line 203
  if ((unsigned int )op == 76U) {
#line 203
    goto case_76;
  }
#line 207
  if ((unsigned int )op == 78U) {
#line 207
    goto case_78;
  }
#line 212
  if ((unsigned int )op == 16U) {
#line 212
    goto case_16;
  }
#line 259
  if ((unsigned int )op == 17U) {
#line 259
    goto case_17;
  }
#line 285
  if ((unsigned int )op == 79U) {
#line 285
    goto case_79;
  }
#line 338
  if ((unsigned int )op == 23U) {
#line 338
    goto case_23;
  }
#line 347
  if ((unsigned int )op == 80U) {
#line 347
    goto case_80;
  }
#line 355
  if ((unsigned int )op == 100U) {
#line 355
    goto case_100;
  }
#line 374
  if ((unsigned int )op == 83U) {
#line 374
    goto case_83;
  }
#line 374
  if ((unsigned int )op == 53U) {
#line 374
    goto case_83;
  }
#line 374
  if ((unsigned int )op == 52U) {
#line 374
    goto case_83;
  }
#line 378
  if ((unsigned int )op == 85U) {
#line 378
    goto case_85;
  }
#line 386
  if ((unsigned int )op == 84U) {
#line 386
    goto case_84;
  }
#line 395
  if ((unsigned int )op == 38U) {
#line 395
    goto case_38;
  }
#line 395
  if ((unsigned int )op == 36U) {
#line 395
    goto case_38;
  }
#line 408
  if ((unsigned int )op == 39U) {
#line 408
    goto case_39;
  }
#line 408
  if ((unsigned int )op == 37U) {
#line 408
    goto case_39;
  }
#line 416
  if ((unsigned int )op == 24U) {
#line 416
    goto case_24;
  }
#line 424
  if ((unsigned int )op == 40U) {
#line 424
    goto case_40;
  }
#line 430
  if ((unsigned int )op == 41U) {
#line 430
    goto case_41;
  }
#line 436
  if ((unsigned int )op == 42U) {
#line 436
    goto case_42;
  }
#line 442
  if ((unsigned int )op == 43U) {
#line 442
    goto case_43;
  }
#line 448
  if ((unsigned int )op == 44U) {
#line 448
    goto case_44;
  }
#line 454
  if ((unsigned int )op == 45U) {
#line 454
    goto case_45;
  }
#line 460
  if ((unsigned int )op == 8U) {
#line 460
    goto case_8;
  }
#line 463
  if ((unsigned int )op == 7U) {
#line 463
    goto case_7;
  }
#line 474
  if ((unsigned int )op == 10U) {
#line 474
    goto case_10;
  }
#line 477
  if ((unsigned int )op == 9U) {
#line 477
    goto case_9;
  }
#line 488
  if ((unsigned int )op == 2U) {
#line 488
    goto case_2___0;
  }
#line 491
  if ((unsigned int )op == 1U) {
#line 491
    goto case_1___0;
  }
#line 502
  if ((unsigned int )op == 12U) {
#line 502
    goto case_12;
  }
#line 505
  if ((unsigned int )op == 11U) {
#line 505
    goto case_11;
  }
#line 516
  if ((unsigned int )op == 4U) {
#line 516
    goto case_4___0;
  }
#line 519
  if ((unsigned int )op == 3U) {
#line 519
    goto case_3;
  }
#line 532
  if ((unsigned int )op == 6U) {
#line 532
    goto case_6___0;
  }
#line 535
  if ((unsigned int )op == 5U) {
#line 535
    goto case_5___0;
  }
#line 556
  if ((unsigned int )op == 19U) {
#line 556
    goto case_19;
  }
#line 556
  if ((unsigned int )op == 18U) {
#line 556
    goto case_19;
  }
#line 574
  if ((unsigned int )op == 21U) {
#line 574
    goto case_21;
  }
#line 574
  if ((unsigned int )op == 20U) {
#line 574
    goto case_21;
  }
#line 590
  if ((unsigned int )op == 22U) {
#line 590
    goto case_22;
  }
#line 597
  if ((unsigned int )op == 27U) {
#line 597
    goto case_27;
  }
#line 643
  if ((unsigned int )op == 26U) {
#line 643
    goto case_26;
  }
#line 660
  if ((unsigned int )op == 28U) {
#line 660
    goto case_28;
  }
#line 678
  if ((unsigned int )op == 35U) {
#line 678
    goto case_35;
  }
#line 724
  if ((unsigned int )op == 25U) {
#line 724
    goto case_25;
  }
#line 733
  if ((unsigned int )op == 94U) {
#line 733
    goto case_94;
  }
#line 763
  if ((unsigned int )op == 34U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 31U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 30U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 29U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 33U) {
#line 763
    goto case_34;
  }
#line 763
  if ((unsigned int )op == 32U) {
#line 763
    goto case_34;
  }
#line 767
  if ((unsigned int )op == 91U) {
#line 767
    goto case_91;
  }
#line 772
  if ((unsigned int )op == 93U) {
#line 772
    goto case_93;
  }
#line 772
  if ((unsigned int )op == 92U) {
#line 772
    goto case_93;
  }
#line 798
  if ((unsigned int )op == 13U) {
#line 798
    goto case_13;
  }
#line 803
  if ((unsigned int )op == 50U) {
#line 803
    goto case_50;
  }
#line 828
  if ((unsigned int )op == 60U) {
#line 828
    goto case_60;
  }
#line 834
  if ((unsigned int )op == 61U) {
#line 834
    goto case_61;
  }
#line 840
  if ((unsigned int )op == 69U) {
#line 840
    goto case_69;
  }
#line 849
  if ((unsigned int )op == 88U) {
#line 849
    goto case_88;
  }
#line 898
  if ((unsigned int )op == 89U) {
#line 898
    goto case_89;
  }
#line 915
  if ((unsigned int )op == 90U) {
#line 915
    goto case_90;
  }
#line 921
  if ((unsigned int )op == 65U) {
#line 921
    goto case_65;
  }
#line 927
  if ((unsigned int )op == 68U) {
#line 927
    goto case_68;
  }
#line 927
  if ((unsigned int )op == 67U) {
#line 927
    goto case_68;
  }
#line 947
  if ((unsigned int )op == 66U) {
#line 947
    goto case_66;
  }
#line 952
  if ((unsigned int )op == 54U) {
#line 952
    goto case_54;
  }
#line 956
  if ((unsigned int )op == 56U) {
#line 956
    goto case_56;
  }
#line 960
  if ((unsigned int )op == 55U) {
#line 960
    goto case_55;
  }
#line 964
  if ((unsigned int )op == 75U) {
#line 964
    goto case_75;
  }
#line 974
  if ((unsigned int )op == 47U) {
#line 974
    goto case_47;
  }
#line 1005
  if ((unsigned int )op == 46U) {
#line 1005
    goto case_46;
  }
#line 1005
  if ((unsigned int )op == 48U) {
#line 1005
    goto case_46;
  }
#line 1017
  if ((unsigned int )op == 71U) {
#line 1017
    goto case_71;
  }
#line 1054
  if ((unsigned int )op == 70U) {
#line 1054
    goto case_70;
  }
#line 1090
  if ((unsigned int )op == 59U) {
#line 1090
    goto case_59;
  }
#line 1100
  if ((unsigned int )op == 62U) {
#line 1100
    goto case_62;
  }
#line 1109
  if ((unsigned int )op == 63U) {
#line 1109
    goto case_63;
  }
#line 1137
  if ((unsigned int )op == 96U) {
#line 1137
    goto case_96;
  }
#line 1144
  if ((unsigned int )op == 95U) {
#line 1144
    goto case_95;
  }
#line 1158
  if ((unsigned int )op == 87U) {
#line 1158
    goto case_87;
  }
#line 1182
  if ((unsigned int )op == 86U) {
#line 1182
    goto case_86;
  }
#line 1209
  if ((unsigned int )op == 64U) {
#line 1209
    goto case_64;
  }
#line 1256
  if ((unsigned int )op == 58U) {
#line 1256
    goto case_58;
  }
#line 1299
  if ((unsigned int )op == 57U) {
#line 1299
    goto case_57;
  }
#line 1306
  if ((unsigned int )op == 82U) {
#line 1306
    goto case_82;
  }
#line 1311
  if ((unsigned int )op == 14U) {
#line 1311
    goto case_14;
  }
#line 1318
  if ((unsigned int )op == 15U) {
#line 1318
    goto case_15;
  }
#line 1344
  if ((unsigned int )op == 98U) {
#line 1344
    goto case_98;
  }
#line 1358
  if ((unsigned int )op == 114U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 112U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 111U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 51U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 110U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 108U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 107U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 109U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 106U) {
#line 1358
    goto case_114;
  }
#line 1358
  if ((unsigned int )op == 81U) {
#line 1358
    goto case_114;
  }
#line 1361
  goto switch_default___1;
  case_49: /* CIL Label */ 
#line 77
  currule = (int )pc->x.xl;
  case_97: /* CIL Label */ 
#line 80
  source = pc->d.name;
#line 81
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 85
  stdio_problem = (_Bool)0;
#line 88
  source = (char *)((void *)0);
#line 89
  sourceline = 0;
#line 90
  nextfile(& curfile, (_Bool)1);
#line 101
  close_io(& stdio_problem);
  }
#line 107
  if (stdio_problem) {
#line 107
    if (! exiting) {
#line 107
      if (exit_val == 0) {
#line 108
        exit_val = 1;
      }
    }
  }
  {
#line 110
  close_extensions();
  }
#line 112
  goto switch_break;
  case_102: /* CIL Label */ 
#line 115
  return (0);
  case_74: /* CIL Label */ 
#line 118
  m = pc->d.dn;
#line 119
  if (! (do_flags & 8)) {
#line 119
    if ((m->flags & 128U) != 0U) {
      {
#line 122
      save = *(m->sub.val.sp + m->sub.val.slen);
#line 123
      *(m->sub.val.sp + m->sub.val.slen) = (char )'\000';
#line 124
      orig = m->sub.val.sp;
#line 125
      trans = dgettext((char const   *)TEXTDOMAIN, (char const   *)orig);
#line 126
      *(m->sub.val.sp + m->sub.val.slen) = save;
#line 127
      tmp___2 = strlen((char const   *)trans);
#line 127
      m = make_str_node((char const   *)trans, tmp___2, 0);
      }
    } else {
#line 129
      (m->sub.val.sref) ++;
    }
  } else {
#line 129
    (m->sub.val.sref) ++;
  }
#line 130
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 130
    stack_ptr ++;
#line 130
    tmp___4 = stack_ptr;
  } else {
    {
#line 130
    tmp___3 = grow_stack();
#line 130
    tmp___4 = tmp___3;
    }
  }
#line 130
  tmp___4->rptr = m;
#line 131
  goto switch_break;
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 137
  isparam = (_Bool)0;
#line 139
  m = pc->d.dn;
#line 139
  save_symbol = m;
#line 140
  if ((unsigned int )m->type == 7U) {
#line 141
    isparam = (_Bool)1;
#line 142
    m = *(frame_ptr->sub.nodep.r.av + m->sub.nodep.l.ll);
#line 142
    save_symbol = m;
#line 143
    if ((unsigned int )m->type == 11U) {
#line 144
      if ((unsigned int )(m->sub.nodep.l.lptr)->type == 4U) {
#line 146
        goto uninitialized_scalar;
      }
#line 148
      m = m->sub.nodep.l.lptr;
    }
  }
  {
#line 153
  if ((unsigned int )m->type == 4U) {
#line 153
    goto case_4;
  }
#line 164
  if ((unsigned int )m->type == 6U) {
#line 164
    goto uninitialized_scalar;
  }
#line 177
  if ((unsigned int )m->type == 5U) {
#line 177
    goto case_5;
  }
#line 185
  goto switch_default;
  case_4: /* CIL Label */ 
#line 154
  if (do_flags & 3) {
#line 154
    if ((unsigned long )m->sub.nodep.l.lptr == (unsigned long )Nnull_string) {
      {
#line 155
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 155);
      }
#line 155
      if (isparam) {
        {
#line 155
        tmp___5 = gettext("reference to uninitialized argument `%s\'");
#line 155
        tmp___7 = tmp___5;
        }
      } else {
        {
#line 155
        tmp___6 = gettext("reference to uninitialized variable `%s\'");
#line 155
        tmp___7 = tmp___6;
        }
      }
      {
#line 155
      (*lintfunc)((char const   *)tmp___7, save_symbol->sub.nodep.name);
      }
    }
  }
#line 159
  m = m->sub.nodep.l.lptr;
#line 160
  (m->sub.val.sref) ++;
#line 161
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 161
    stack_ptr ++;
#line 161
    tmp___9 = stack_ptr;
  } else {
    {
#line 161
    tmp___8 = grow_stack();
#line 161
    tmp___9 = tmp___8;
    }
  }
#line 161
  tmp___9->rptr = m;
#line 162
  goto switch_break___0;
  uninitialized_scalar: 
  case_6: /* CIL Label */ 
  {
#line 166
  m->type = (NODETYPE )4;
#line 167
  m->sub.nodep.l.lptr = dupnode(Nnull_string);
  }
#line 168
  if (do_flags & 3) {
    {
#line 169
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 169);
    }
#line 169
    if (isparam) {
      {
#line 169
      tmp___10 = gettext("reference to uninitialized argument `%s\'");
#line 169
      tmp___12 = tmp___10;
      }
    } else {
      {
#line 169
      tmp___11 = gettext("reference to uninitialized variable `%s\'");
#line 169
      tmp___12 = tmp___11;
      }
    }
    {
#line 169
    (*lintfunc)((char const   *)tmp___12, save_symbol->sub.nodep.name);
    }
  }
  {
#line 173
  m = dupnode(Nnull_string);
  }
#line 174
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 174
    stack_ptr ++;
#line 174
    tmp___14 = stack_ptr;
  } else {
    {
#line 174
    tmp___13 = grow_stack();
#line 174
    tmp___14 = tmp___13;
    }
  }
#line 174
  tmp___14->rptr = m;
#line 175
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 178
  if ((unsigned int )op == 73U) {
#line 179
    if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 179
      stack_ptr ++;
#line 179
      tmp___16 = stack_ptr;
    } else {
      {
#line 179
      tmp___15 = grow_stack();
#line 179
      tmp___16 = tmp___15;
      }
    }
#line 179
    tmp___16->rptr = m;
  } else {
    {
#line 181
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 181);
#line 181
    tmp___17 = array_vname((NODE const   *)save_symbol);
#line 181
    tmp___18 = gettext("attempt to use array `%s\' in a scalar context");
#line 181
    r_fatal((char const   *)tmp___18, tmp___17);
    }
  }
#line 183
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 186
  r_fatal("internal error line %d, file: %s", 186, "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 189
  goto switch_break;
  case_77: /* CIL Label */ 
#line 192
  m = pc->d.dn;
#line 193
  if ((unsigned int )m->type == 7U) {
#line 194
    m = *(frame_ptr->sub.nodep.r.av + m->sub.nodep.l.ll);
  }
#line 195
  if ((unsigned int )m->type == 4U) {
#line 196
    m = m->sub.nodep.l.lptr;
#line 197
    (m->sub.val.sref) ++;
#line 198
    if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 198
      stack_ptr ++;
#line 198
      tmp___20 = stack_ptr;
    } else {
      {
#line 198
      tmp___19 = grow_stack();
#line 198
      tmp___20 = tmp___19;
      }
    }
#line 198
    tmp___20->rptr = m;
#line 199
    goto switch_break;
  }
  case_76: /* CIL Label */ 
#line 204
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 204
    stack_ptr ++;
#line 204
    tmp___22 = stack_ptr;
  } else {
    {
#line 204
    tmp___21 = grow_stack();
#line 204
    tmp___22 = tmp___21;
    }
  }
#line 204
  tmp___22->rptr = pc->d.dn;
#line 205
  goto switch_break;
  case_78: /* CIL Label */ 
#line 208
  if ((unsigned int )(pc->d.dn)->type == 4U) {
#line 208
    if (! ((unsigned long )(pc->d.dn)->sub.nodep.l.lptr == (unsigned long )Nnull_string)) {
#line 208
      lhs = & (pc->d.dn)->sub.nodep.l.lptr;
    } else {
      {
#line 208
      tmp___23 = r_get_lhs(pc->d.dn, (_Bool )pc->x.xl);
#line 208
      lhs = tmp___23;
      }
    }
  } else {
    {
#line 208
    tmp___23 = r_get_lhs(pc->d.dn, (_Bool )pc->x.xl);
#line 208
    lhs = tmp___23;
    }
  }
#line 209
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 209
    stack_ptr ++;
#line 209
    tmp___25 = stack_ptr;
  } else {
    {
#line 209
    tmp___24 = grow_stack();
#line 209
    tmp___25 = tmp___24;
    }
  }
#line 209
  tmp___25->lptr = lhs;
#line 210
  goto switch_break;
  case_16: /* CIL Label */ 
#line 213
  if (pc->d.dl == 1L) {
    {
#line 213
    tmp___26 = POP_SCALAR();
#line 213
    t2 = tmp___26;
    }
  } else {
    {
#line 213
    tmp___27 = concat_exp((int )pc->d.dl, (_Bool)1);
#line 213
    t2 = tmp___27;
    }
  }
  {
#line 214
  t1 = POP_ARRAY();
  }
#line 216
  if (do_flags & 3) {
    {
#line 216
    tmp___32 = in_array(t1, t2);
    }
#line 216
    if ((unsigned long )tmp___32 == (unsigned long )((void *)0)) {
      {
#line 217
      t2 = force_string(t2);
#line 218
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 218);
#line 218
      tmp___28 = array_vname((NODE const   *)t1);
#line 218
      tmp___29 = gettext("reference to uninitialized element `%s[\"%.*s\"]\'");
#line 218
      (*lintfunc)((char const   *)tmp___29, tmp___28, (int )t2->sub.val.slen, t2->sub.val.sp);
      }
#line 220
      if (t2->sub.val.slen == 0UL) {
        {
#line 221
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 221);
#line 221
        tmp___30 = array_vname((NODE const   *)t1);
#line 221
        tmp___31 = gettext("subscript of array `%s\' is null string");
#line 221
        (*lintfunc)((char const   *)tmp___31, tmp___30);
        }
      }
    }
  }
#line 225
  if ((unsigned long )t1 == (unsigned long )func_table) {
#line 228
    if (do_flags & 3) {
#line 228
      if (! warned___12) {
        {
#line 229
        warned___12 = (_Bool)1;
#line 230
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 230);
#line 230
        tmp___33 = gettext("FUNCTAB is a gawk extension");
#line 230
        (*lintfunc)((char const   *)tmp___33);
        }
      }
    }
#line 232
    r = t2;
  } else {
#line 235
    if ((unsigned long )t1 == (unsigned long )symbol_table) {
      {
#line 236
      update_global_values();
      }
    }
    {
#line 238
    tmp___34 = (*(*(t1->sub.nodep.l.lp + 3)))(t1, t2);
#line 238
    r = *tmp___34;
    }
  }
  {
#line 240
  DEREF(t2);
  }
#line 243
  if ((unsigned long )t1 == (unsigned long )symbol_table) {
#line 246
    if (do_flags & 3) {
#line 246
      if (! warned___13) {
        {
#line 247
        warned___13 = (_Bool)1;
#line 248
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 248);
#line 248
        tmp___35 = gettext("SYMTAB is a gawk extension");
#line 248
        (*lintfunc)((char const   *)tmp___35);
        }
      }
    }
#line 250
    if ((unsigned int )r->type == 4U) {
#line 251
      r = r->sub.nodep.l.lptr;
    }
  }
#line 254
  if ((unsigned int )r->type == 1U) {
#line 255
    (r->sub.val.sref) ++;
  }
#line 256
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 256
    stack_ptr ++;
#line 256
    tmp___37 = stack_ptr;
  } else {
    {
#line 256
    tmp___36 = grow_stack();
#line 256
    tmp___37 = tmp___36;
    }
  }
#line 256
  tmp___37->rptr = r;
#line 257
  goto switch_break;
  case_17: /* CIL Label */ 
#line 260
  if (pc->d.dl == 1L) {
    {
#line 260
    tmp___38 = POP_SCALAR();
#line 260
    t2 = tmp___38;
    }
  } else {
    {
#line 260
    tmp___39 = concat_exp((int )pc->d.dl, (_Bool)1);
#line 260
    t2 = tmp___39;
    }
  }
  {
#line 261
  t1 = POP_ARRAY();
#line 262
  r = in_array(t1, t2);
  }
#line 263
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 264
    r = make_array();
#line 265
    r->sub.nodep.x.extra = t1;
#line 266
    lhs = (*(*(t1->sub.nodep.l.lp + 3)))(t1, t2);
#line 267
    unref(*lhs);
#line 268
    *lhs = r;
#line 269
    t2 = force_string(t2);
#line 270
    r->sub.nodep.name = estrdup((char const   *)t2->sub.val.sp, t2->sub.val.slen);
    }
#line 273
    if ((unsigned long )*(t1->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
      {
#line 274
      (*(*(t1->sub.nodep.l.lp + 10)))(t1, t2);
      }
    }
  } else
#line 275
  if ((unsigned int )r->type != 5U) {
    {
#line 276
    t2 = force_string(t2);
#line 277
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 277);
#line 277
    tmp___40 = array_vname((NODE const   *)t1);
#line 277
    tmp___41 = gettext("attempt to use scalar `%s[\"%.*s\"]\' as an array");
#line 277
    r_fatal((char const   *)tmp___41, tmp___40, (int )t2->sub.val.slen, t2->sub.val.sp);
    }
  }
  {
#line 281
  DEREF(t2);
  }
#line 282
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 282
    stack_ptr ++;
#line 282
    tmp___43 = stack_ptr;
  } else {
    {
#line 282
    tmp___42 = grow_stack();
#line 282
    tmp___43 = tmp___42;
    }
  }
#line 282
  tmp___43->rptr = r;
#line 283
  goto switch_break;
  case_79: /* CIL Label */ 
#line 286
  if (pc->d.dl == 1L) {
    {
#line 286
    tmp___44 = POP_SCALAR();
#line 286
    t2 = tmp___44;
    }
  } else {
    {
#line 286
    tmp___45 = concat_exp((int )pc->d.dl, (_Bool)1);
#line 286
    t2 = tmp___45;
    }
  }
  {
#line 287
  t1 = POP_ARRAY();
  }
#line 288
  if (do_flags & 3) {
    {
#line 288
    tmp___50 = in_array(t1, t2);
    }
#line 288
    if ((unsigned long )tmp___50 == (unsigned long )((void *)0)) {
      {
#line 289
      t2 = force_string(t2);
      }
#line 290
      if (pc->x.xl) {
        {
#line 291
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 291);
#line 291
        tmp___46 = array_vname((NODE const   *)t1);
#line 291
        tmp___47 = gettext("reference to uninitialized element `%s[\"%.*s\"]\'");
#line 291
        (*lintfunc)((char const   *)tmp___47, tmp___46, (int )t2->sub.val.slen, t2->sub.val.sp);
        }
      }
#line 293
      if (t2->sub.val.slen == 0UL) {
        {
#line 294
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 294);
#line 294
        tmp___48 = array_vname((NODE const   *)t1);
#line 294
        tmp___49 = gettext("subscript of array `%s\' is null string");
#line 294
        (*lintfunc)((char const   *)tmp___49, tmp___48);
        }
      }
    }
  }
  {
#line 297
  lhs = (*(*(t1->sub.nodep.l.lp + 3)))(t1, t2);
  }
#line 298
  if ((unsigned int )(*lhs)->type == 5U) {
    {
#line 299
    t2 = force_string(t2);
#line 300
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 300);
#line 300
    tmp___51 = array_vname((NODE const   *)t1);
#line 300
    tmp___52 = gettext("attempt to use array `%s[\"%.*s\"]\' in a scalar context");
#line 300
    r_fatal((char const   *)tmp___52, tmp___51, (int )t2->sub.val.slen, t2->sub.val.sp);
    }
  }
#line 316
  if ((unsigned long )t1 == (unsigned long )func_table) {
    {
#line 317
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 317);
#line 317
    tmp___53 = gettext("cannot assign to elements of FUNCTAB");
#line 317
    r_fatal((char const   *)tmp___53);
    }
  } else
#line 318
  if ((unsigned long )t1 == (unsigned long )symbol_table) {
#line 318
    if ((unsigned int )(*lhs)->type == 4U) {
      {
#line 321
      update_global_values();
#line 322
      (*lhs)->type = (NODETYPE )4;
#line 323
      lhs = & (*lhs)->sub.nodep.l.lptr;
      }
    } else
#line 318
    if ((unsigned int )(*lhs)->type == 6U) {
      {
#line 321
      update_global_values();
#line 322
      (*lhs)->type = (NODETYPE )4;
#line 323
      lhs = & (*lhs)->sub.nodep.l.lptr;
      }
    }
  }
#line 328
  if (*(t1->sub.nodep.l.lp + 10)) {
#line 330
    set_array = t1;
#line 331
    set_idx = t2;
  } else {
    {
#line 333
    DEREF(t2);
    }
  }
#line 335
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 335
    stack_ptr ++;
#line 335
    tmp___55 = stack_ptr;
  } else {
    {
#line 335
    tmp___54 = grow_stack();
#line 335
    tmp___55 = tmp___54;
    }
  }
#line 335
  tmp___55->lptr = lhs;
#line 336
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 339
  t1 = TOP_SCALAR();
#line 340
  lhs = r_get_field(t1, (Func_ptr *)0, (_Bool)1);
#line 341
  stack_ptr --;
#line 342
  DEREF(t1);
#line 343
  r = dupnode(*lhs);
  }
#line 344
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 344
    stack_ptr ++;
#line 344
    tmp___57 = stack_ptr;
  } else {
    {
#line 344
    tmp___56 = grow_stack();
#line 344
    tmp___57 = tmp___56;
    }
  }
#line 344
  tmp___57->rptr = r;
#line 345
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 348
  t1 = TOP_SCALAR();
#line 349
  lhs = r_get_field(t1, & (pc->d.di)->x.aptr, (_Bool )pc->x.xl);
#line 350
  stack_ptr --;
#line 351
  DEREF(t1);
  }
#line 352
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 352
    stack_ptr ++;
#line 352
    tmp___59 = stack_ptr;
  } else {
    {
#line 352
    tmp___58 = grow_stack();
#line 352
    tmp___59 = tmp___58;
    }
  }
#line 352
  tmp___59->lptr = lhs;
#line 353
  goto switch_break;
  case_100: /* CIL Label */ 
#line 356
  if (do_flags & 3) {
    {
#line 358
    if (pc->d.dl == 1L) {
#line 358
      goto case_1;
    }
#line 362
    if (pc->d.dl == 2L) {
#line 362
      goto case_2;
    }
#line 366
    goto switch_default___0;
    case_1: /* CIL Label */ 
    {
#line 359
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 359);
#line 359
    tmp___60 = gettext("assignment used in conditional context");
#line 359
    (*lintfunc)((char const   *)tmp___60);
    }
#line 360
    goto switch_break___1;
    case_2: /* CIL Label */ 
    {
#line 363
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 363);
#line 363
    tmp___61 = gettext("statement has no effect");
#line 363
    (*lintfunc)((char const   *)tmp___61);
    }
#line 364
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 367
    r_fatal("internal error line %d, file: %s", 367, "/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h");
    }
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 370
  goto switch_break;
  case_83: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ ;
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    if (post_execute) {
      {
#line 376
      (*post_execute)(pc);
      }
    }
#line 376
    pc = pc->d.di;
#line 376
    goto top;
#line 376
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  case_85: /* CIL Label */ 
  {
#line 379
  r = POP_SCALAR();
#line 380
  di = eval_condition(r);
#line 381
  DEREF(r);
  }
#line 382
  if (! di) {
    {
#line 383
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 383
      if (post_execute) {
        {
#line 383
        (*post_execute)(pc);
        }
      }
#line 383
      pc = pc->d.di;
#line 383
      goto top;
#line 383
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 384
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 387
  r = POP_SCALAR();
#line 388
  di = eval_condition(r);
#line 389
  DEREF(r);
  }
#line 390
  if (di) {
    {
#line 391
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 391
      if (post_execute) {
        {
#line 391
        (*post_execute)(pc);
        }
      }
#line 391
      pc = pc->d.di;
#line 391
      goto top;
#line 391
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 392
  goto switch_break;
  case_38: /* CIL Label */ 
  case_36: /* CIL Label */ 
  {
#line 396
  t1 = POP_SCALAR();
#line 397
  di = eval_condition(t1);
#line 398
  DEREF(t1);
  }
#line 399
  if ((unsigned int )op == 36U) {
#line 399
    if (di) {
#line 400
      goto switch_break;
    } else {
#line 399
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 399
  if ((unsigned int )op == 38U) {
#line 399
    if (! di) {
#line 400
      goto switch_break;
    }
  }
#line 401
  r = node_Boolean[di];
#line 402
  (r->sub.val.sref) ++;
#line 403
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 403
    stack_ptr ++;
#line 403
    tmp___63 = stack_ptr;
  } else {
    {
#line 403
    tmp___62 = grow_stack();
#line 403
    tmp___63 = tmp___62;
    }
  }
#line 403
  tmp___63->rptr = r;
#line 404
  ni = pc->d.di;
  {
#line 405
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 405
    if (post_execute) {
      {
#line 405
      (*post_execute)(pc);
      }
    }
#line 405
    pc = ni->nexti;
#line 405
    goto top;
#line 405
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  case_39: /* CIL Label */ 
  case_37: /* CIL Label */ 
  {
#line 409
  t1 = TOP_SCALAR();
#line 410
  tmp___64 = eval_condition(t1);
#line 410
  r = node_Boolean[tmp___64];
#line 411
  DEREF(t1);
#line 412
  (r->sub.val.sref) ++;
#line 413
  stack_ptr->rptr = r;
  }
#line 414
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 417
  t1 = TOP_SCALAR();
#line 418
  tmp___65 = eval_condition(t1);
  }
#line 418
  if (tmp___65) {
#line 418
    tmp___66 = 0;
  } else {
#line 418
    tmp___66 = 1;
  }
  {
#line 418
  r = node_Boolean[tmp___66];
#line 419
  DEREF(t1);
#line 420
  (r->sub.val.sref) ++;
#line 421
  stack_ptr->rptr = r;
  }
#line 422
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 425
  tmp___67 = cmp_scalars();
#line 425
  r = node_Boolean[tmp___67 == 0];
#line 426
  (r->sub.val.sref) ++;
#line 427
  stack_ptr->rptr = r;
  }
#line 428
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 431
  tmp___68 = cmp_scalars();
#line 431
  r = node_Boolean[tmp___68 != 0];
#line 432
  (r->sub.val.sref) ++;
#line 433
  stack_ptr->rptr = r;
  }
#line 434
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 437
  tmp___69 = cmp_scalars();
#line 437
  r = node_Boolean[tmp___69 < 0];
#line 438
  (r->sub.val.sref) ++;
#line 439
  stack_ptr->rptr = r;
  }
#line 440
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 443
  tmp___70 = cmp_scalars();
#line 443
  r = node_Boolean[tmp___70 > 0];
#line 444
  (r->sub.val.sref) ++;
#line 445
  stack_ptr->rptr = r;
  }
#line 446
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 449
  tmp___71 = cmp_scalars();
#line 449
  r = node_Boolean[tmp___71 <= 0];
#line 450
  (r->sub.val.sref) ++;
#line 451
  stack_ptr->rptr = r;
  }
#line 452
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 455
  tmp___72 = cmp_scalars();
#line 455
  r = node_Boolean[tmp___72 >= 0];
#line 456
  (r->sub.val.sref) ++;
#line 457
  stack_ptr->rptr = r;
  }
#line 458
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 461
  tmp___73 = force_number(pc->d.dn);
#line 461
  x2 = tmp___73->sub.val.nm.fltnum;
  }
#line 462
  goto plus;
  case_7: /* CIL Label */ 
  {
#line 464
  tmp___74 = POP_SCALAR();
#line 464
  t2 = force_number(tmp___74);
#line 465
  x2 = t2->sub.val.nm.fltnum;
#line 466
  DEREF(t2);
  }
  plus: 
  {
#line 468
  tmp___75 = TOP_SCALAR();
#line 468
  t1 = force_number(tmp___75);
#line 469
  r = (*make_number)(t1->sub.val.nm.fltnum + x2);
#line 470
  DEREF(t1);
#line 471
  stack_ptr->rptr = r;
  }
#line 472
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 475
  tmp___76 = force_number(pc->d.dn);
#line 475
  x2 = tmp___76->sub.val.nm.fltnum;
  }
#line 476
  goto minus;
  case_9: /* CIL Label */ 
  {
#line 478
  tmp___77 = POP_SCALAR();
#line 478
  t2 = force_number(tmp___77);
#line 479
  x2 = t2->sub.val.nm.fltnum;
#line 480
  DEREF(t2);
  }
  minus: 
  {
#line 482
  tmp___78 = TOP_SCALAR();
#line 482
  t1 = force_number(tmp___78);
#line 483
  r = (*make_number)(t1->sub.val.nm.fltnum - x2);
#line 484
  DEREF(t1);
#line 485
  stack_ptr->rptr = r;
  }
#line 486
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 489
  tmp___79 = force_number(pc->d.dn);
#line 489
  x2 = tmp___79->sub.val.nm.fltnum;
  }
#line 490
  goto times;
  case_1___0: /* CIL Label */ 
  {
#line 492
  tmp___80 = POP_SCALAR();
#line 492
  t2 = force_number(tmp___80);
#line 493
  x2 = t2->sub.val.nm.fltnum;
#line 494
  DEREF(t2);
  }
  times: 
  {
#line 496
  tmp___81 = TOP_SCALAR();
#line 496
  t1 = force_number(tmp___81);
#line 497
  r = (*make_number)(t1->sub.val.nm.fltnum * x2);
#line 498
  DEREF(t1);
#line 499
  stack_ptr->rptr = r;
  }
#line 500
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 503
  tmp___82 = force_number(pc->d.dn);
#line 503
  x2 = tmp___82->sub.val.nm.fltnum;
  }
#line 504
  goto exp;
  case_11: /* CIL Label */ 
  {
#line 506
  tmp___83 = POP_SCALAR();
#line 506
  t2 = force_number(tmp___83);
#line 507
  x2 = t2->sub.val.nm.fltnum;
#line 508
  DEREF(t2);
  }
  exp: 
  {
#line 510
  tmp___84 = TOP_SCALAR();
#line 510
  t1 = force_number(tmp___84);
#line 511
  tmp___85 = calc_exp(t1->sub.val.nm.fltnum, x2);
#line 511
  r = (*make_number)(tmp___85);
#line 512
  DEREF(t1);
#line 513
  stack_ptr->rptr = r;
  }
#line 514
  goto switch_break;
  case_4___0: /* CIL Label */ 
  {
#line 517
  tmp___86 = force_number(pc->d.dn);
#line 517
  x2 = tmp___86->sub.val.nm.fltnum;
  }
#line 518
  goto quotient;
  case_3: /* CIL Label */ 
  {
#line 520
  tmp___87 = POP_SCALAR();
#line 520
  t2 = force_number(tmp___87);
#line 521
  x2 = t2->sub.val.nm.fltnum;
#line 522
  DEREF(t2);
  }
  quotient: 
  {
#line 524
  tmp___88 = TOP_SCALAR();
#line 524
  t1 = force_number(tmp___88);
  }
#line 525
  if (x2 == (double )0) {
    {
#line 526
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 526);
#line 526
    tmp___89 = gettext("division by zero attempted");
#line 526
    r_fatal((char const   *)tmp___89);
    }
  }
  {
#line 527
  r = (*make_number)(t1->sub.val.nm.fltnum / x2);
#line 528
  DEREF(t1);
#line 529
  stack_ptr->rptr = r;
  }
#line 530
  goto switch_break;
  case_6___0: /* CIL Label */ 
  {
#line 533
  tmp___90 = force_number(pc->d.dn);
#line 533
  x2 = tmp___90->sub.val.nm.fltnum;
  }
#line 534
  goto mod;
  case_5___0: /* CIL Label */ 
  {
#line 536
  tmp___91 = POP_SCALAR();
#line 536
  t2 = force_number(tmp___91);
#line 537
  x2 = t2->sub.val.nm.fltnum;
#line 538
  DEREF(t2);
  }
  mod: 
  {
#line 540
  tmp___92 = TOP_SCALAR();
#line 540
  t1 = force_number(tmp___92);
  }
#line 541
  if (x2 == (double )0) {
    {
#line 542
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 542);
#line 542
    tmp___93 = gettext("division by zero attempted in `%%\'");
#line 542
    r_fatal((char const   *)tmp___93);
    }
  }
  {
#line 544
  x = fmod(t1->sub.val.nm.fltnum, x2);
#line 549
  r = (*make_number)(x);
#line 551
  DEREF(t1);
#line 552
  stack_ptr->rptr = r;
  }
#line 553
  goto switch_break;
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 557
  if ((unsigned int )op == 18U) {
#line 557
    x = 1.0;
  } else {
#line 557
    x = - 1.0;
  }
  {
#line 558
  lhs = stack_ptr->lptr;
#line 559
  t1 = *lhs;
#line 560
  force_number(t1);
  }
#line 561
  if (t1->sub.val.sref == 1L) {
#line 561
    if (t1->flags == 25U) {
#line 563
      t1->sub.val.nm.fltnum += x;
#line 564
      r = t1;
    } else {
      {
#line 566
      tmp___94 = (*make_number)(t1->sub.val.nm.fltnum + x);
#line 566
      *lhs = tmp___94;
#line 566
      r = tmp___94;
#line 567
      unref(t1);
      }
    }
  } else {
    {
#line 566
    tmp___94 = (*make_number)(t1->sub.val.nm.fltnum + x);
#line 566
    *lhs = tmp___94;
#line 566
    r = tmp___94;
#line 567
    unref(t1);
    }
  }
#line 569
  (r->sub.val.sref) ++;
#line 570
  stack_ptr->rptr = r;
#line 571
  goto switch_break;
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
#line 575
  if ((unsigned int )op == 20U) {
#line 575
    x = 1.0;
  } else {
#line 575
    x = - 1.0;
  }
  {
#line 576
  lhs = stack_ptr->lptr;
#line 577
  t1 = *lhs;
#line 578
  force_number(t1);
#line 579
  r = (*make_number)(t1->sub.val.nm.fltnum);
  }
#line 580
  if (t1->sub.val.sref == 1L) {
#line 580
    if (t1->flags == 25U) {
#line 582
      t1->sub.val.nm.fltnum += x;
    } else {
      {
#line 584
      *lhs = (*make_number)(t1->sub.val.nm.fltnum + x);
#line 585
      unref(t1);
      }
    }
  } else {
    {
#line 584
    *lhs = (*make_number)(t1->sub.val.nm.fltnum + x);
#line 585
    unref(t1);
    }
  }
#line 587
  stack_ptr->rptr = r;
#line 588
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 591
  tmp___95 = TOP_SCALAR();
#line 591
  t1 = force_number(tmp___95);
#line 592
  r = (*make_number)(- t1->sub.val.nm.fltnum);
#line 593
  DEREF(t1);
#line 594
  stack_ptr->rptr = r;
  }
#line 595
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 602
  t1 = force_array(pc->d.dn, (_Bool)1);
  }
#line 603
  if (pc->x.xl == 1L) {
    {
#line 603
    tmp___96 = POP_SCALAR();
#line 603
    t2 = tmp___96;
    }
  } else {
    {
#line 603
    tmp___97 = concat_exp((int )pc->x.xl, (_Bool)1);
#line 603
    t2 = tmp___97;
    }
  }
  {
#line 604
  lhs = (*(*(t1->sub.nodep.l.lp + 3)))(t1, t2);
  }
#line 605
  if ((unsigned int )(*lhs)->type == 5U) {
    {
#line 606
    t2 = force_string(t2);
#line 607
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 607);
#line 607
    tmp___98 = array_vname((NODE const   *)t1);
#line 607
    tmp___99 = gettext("attempt to use array `%s[\"%.*s\"]\' in a scalar context");
#line 607
    r_fatal((char const   *)tmp___99, tmp___98, (int )t2->sub.val.slen, t2->sub.val.sp);
    }
  }
  {
#line 610
  DEREF(t2);
  }
#line 624
  if ((unsigned long )t1 == (unsigned long )func_table) {
    {
#line 625
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 625);
#line 625
    tmp___100 = gettext("cannot assign to elements of FUNCTAB");
#line 625
    r_fatal((char const   *)tmp___100);
    }
  } else
#line 626
  if ((unsigned long )t1 == (unsigned long )symbol_table) {
#line 626
    if ((unsigned int )(*lhs)->type == 4U) {
#line 629
      (*lhs)->type = (NODETYPE )4;
#line 630
      lhs = & (*lhs)->sub.nodep.l.lptr;
    } else
#line 626
    if ((unsigned int )(*lhs)->type == 6U) {
#line 629
      (*lhs)->type = (NODETYPE )4;
#line 630
      lhs = & (*lhs)->sub.nodep.l.lptr;
    }
  }
  {
#line 633
  unref(*lhs);
#line 634
  *lhs = POP_SCALAR();
  }
#line 637
  if ((unsigned long )*(t1->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
    {
#line 638
    (*(*(t1->sub.nodep.l.lp + 10)))(t1, t2);
    }
  }
  {
#line 640
  DEREF(t2);
  }
#line 641
  goto switch_break;
  case_26: /* CIL Label */ 
#line 649
  if ((unsigned int )(pc->d.dn)->type == 4U) {
#line 649
    if (! ((unsigned long )(pc->d.dn)->sub.nodep.l.lptr == (unsigned long )Nnull_string)) {
#line 649
      lhs = & (pc->d.dn)->sub.nodep.l.lptr;
    } else {
      {
#line 649
      tmp___101 = r_get_lhs(pc->d.dn, (_Bool)0);
#line 649
      lhs = tmp___101;
      }
    }
  } else {
    {
#line 649
    tmp___101 = r_get_lhs(pc->d.dn, (_Bool)0);
#line 649
    lhs = tmp___101;
    }
  }
  {
#line 650
  unref(*lhs);
#line 651
  r = pc->x.xn;
  }
#line 652
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 653
    *lhs = POP_SCALAR();
    }
  } else {
#line 655
    (r->sub.val.sref) ++;
#line 656
    *lhs = r;
  }
#line 658
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 667
  t1 = TOP_SCALAR();
#line 668
  lhs = r_get_field(t1, & assign, (_Bool)0);
#line 669
  stack_ptr --;
#line 670
  DEREF(t1);
#line 671
  unref(*lhs);
#line 672
  *lhs = POP_SCALAR();
#line 674
  (*assign)();
  }
#line 676
  goto switch_break;
  case_35: /* CIL Label */ 
#line 680
  if ((unsigned int )(pc->d.dn)->type == 4U) {
#line 680
    if (! ((unsigned long )(pc->d.dn)->sub.nodep.l.lptr == (unsigned long )Nnull_string)) {
#line 680
      lhs = & (pc->d.dn)->sub.nodep.l.lptr;
    } else {
      {
#line 680
      tmp___102 = r_get_lhs(pc->d.dn, (_Bool)0);
#line 680
      lhs = tmp___102;
      }
    }
  } else {
    {
#line 680
    tmp___102 = r_get_lhs(pc->d.dn, (_Bool)0);
#line 680
    lhs = tmp___102;
    }
  }
  {
#line 681
  t1 = force_string(*lhs);
#line 682
  tmp___103 = POP_SCALAR();
#line 682
  t2 = force_string(tmp___103);
  }
#line 684
  if ((unsigned long )t1 != (unsigned long )*lhs) {
    {
#line 685
    unref(*lhs);
#line 686
    *lhs = dupnode(t1);
    }
  }
#line 689
  if ((unsigned long )t1 != (unsigned long )t2) {
#line 689
    if (t1->sub.val.sref == 1L) {
#line 689
      if ((t1->flags & 2048U) == 0U) {
        {
#line 690
        nlen = t1->sub.val.slen + t2->sub.val.slen;
#line 692
        tmp___105 = realloc((void *)t1->sub.val.sp, nlen + 2UL);
#line 692
        tmp___104 = (char *)tmp___105;
#line 692
        t1->sub.val.sp = tmp___104;
        }
#line 692
        if (tmp___104) {
#line 692
          tmp___109 = 1;
        } else {
          {
#line 692
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 692);
#line 692
          tmp___106 = __errno_location();
#line 692
          tmp___107 = strerror(*tmp___106);
#line 692
          tmp___108 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 692
          r_fatal((char const   *)tmp___108, "r_interpret", "t1->stptr", (long )(nlen + 2UL),
                  tmp___107);
#line 692
          tmp___109 = 0;
          }
        }
        {
#line 693
        memcpy((void */* __restrict  */)(t1->sub.val.sp + t1->sub.val.slen), (void const   */* __restrict  */)t2->sub.val.sp,
               t2->sub.val.slen);
#line 694
        t1->sub.val.slen = nlen;
#line 695
        *(t1->sub.val.sp + nlen) = (char )'\000';
#line 696
        t1->flags &= 4294967015U;
        }
#line 699
        if ((t1->flags & 1024U) != 0U) {
#line 699
          if ((t2->flags & 1024U) != 0U) {
            {
#line 700
            wlen = t1->sub.val.wslen + t2->sub.val.wslen;
#line 702
            tmp___111 = realloc((void *)((char *)t1->sub.val.wsp), sizeof(wchar_t ) * (wlen + 2UL));
#line 702
            tmp___110 = (wchar_t *)tmp___111;
#line 702
            t1->sub.val.wsp = tmp___110;
            }
#line 702
            if (tmp___110) {
#line 702
              tmp___115 = 1;
            } else {
              {
#line 702
              set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 703);
#line 702
              tmp___112 = __errno_location();
#line 702
              tmp___113 = strerror(*tmp___112);
#line 702
              tmp___114 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 702
              r_fatal((char const   *)tmp___114, "r_interpret", "t1->wstptr", (long )(sizeof(wchar_t ) * (wlen + 2UL)),
                      tmp___113);
#line 702
              tmp___115 = 0;
              }
            }
            {
#line 704
            memcpy((void */* __restrict  */)(t1->sub.val.wsp + t1->sub.val.wslen),
                   (void const   */* __restrict  */)t2->sub.val.wsp, t2->sub.val.wslen);
#line 705
            t1->sub.val.wslen = wlen;
#line 706
            *(t1->sub.val.wsp + wlen) = 0;
#line 707
            t1->flags |= 1024U;
            }
          } else {
#line 699
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 709
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 709
            if ((*lhs)->flags & 1024U) {
              {
#line 709
              r_free_wstr(*lhs);
              }
            }
#line 709
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      } else {
#line 689
        goto _L___2;
      }
    } else {
#line 689
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 712
    nlen___0 = t1->sub.val.slen + t2->sub.val.slen;
#line 715
    tmp___116 = malloc(nlen___0 + 2UL);
#line 715
    p = (char *)tmp___116;
    }
#line 715
    if (p) {
#line 715
      tmp___120 = 1;
    } else {
      {
#line 715
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 715);
#line 715
      tmp___117 = __errno_location();
#line 715
      tmp___118 = strerror(*tmp___117);
#line 715
      tmp___119 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 715
      r_fatal((char const   *)tmp___119, "r_interpret", "p", (long )(nlen___0 + 2UL),
              tmp___118);
#line 715
      tmp___120 = 0;
      }
    }
    {
#line 716
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)t1->sub.val.sp,
           t1->sub.val.slen);
#line 717
    memcpy((void */* __restrict  */)(p + t1->sub.val.slen), (void const   */* __restrict  */)t2->sub.val.sp,
           t2->sub.val.slen);
#line 718
    unref(*lhs);
#line 719
    tmp___121 = make_str_node((char const   *)p, nlen___0, 2);
#line 719
    *lhs = tmp___121;
#line 719
    t1 = tmp___121;
    }
  }
  {
#line 721
  DEREF(t2);
  }
#line 722
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 725
  tmp___122 = stack_ptr;
#line 725
  stack_ptr --;
#line 725
  lhs = tmp___122->lptr;
#line 726
  r = TOP_SCALAR();
#line 727
  unref(*lhs);
#line 728
  *lhs = r;
#line 729
  (r->sub.val.sref) ++;
#line 730
  stack_ptr->rptr = r;
  }
#line 731
  goto switch_break;
  case_94: /* CIL Label */ 
#line 736
  if ((unsigned long )set_idx != (unsigned long )((void *)0)) {
#line 737
    di = 1;
#line 738
    if (pc->d.dl == 66L) {
#line 738
      r = stack_ptr->rptr;
#line 738
      if (r) {
#line 738
        if (r->flags & 2048U) {
          {
#line 738
          tmp___127 = mpfr_get_si((mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 738
          tmp___130 = tmp___127;
          }
        } else {
#line 738
          if (r->flags & 4096U) {
            {
#line 738
            tmp___128 = __gmpz_get_si((mpz_srcptr )(r->sub.val.nm.mpi));
#line 738
            tmp___129 = tmp___128;
            }
          } else {
#line 738
            tmp___129 = (long )r->sub.val.nm.fltnum;
          }
#line 738
          tmp___130 = tmp___129;
        }
#line 738
        if (tmp___130 == 0L) {
#line 742
          di = 0;
        } else {
#line 738
          goto _L___5;
        }
      } else {
#line 738
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 743
    if (pc->d.dl == 63L) {
#line 743
      goto _L___3;
    } else
#line 743
    if (pc->d.dl == 62L) {
      _L___3: /* CIL Label */ 
#line 743
      r = stack_ptr->rptr;
#line 743
      if (r) {
#line 743
        if (r->flags & 2048U) {
          {
#line 743
          tmp___123 = mpfr_get_si((mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 743
          tmp___126 = tmp___123;
          }
        } else {
#line 743
          if (r->flags & 4096U) {
            {
#line 743
            tmp___124 = __gmpz_get_si((mpz_srcptr )(r->sub.val.nm.mpi));
#line 743
            tmp___125 = tmp___124;
            }
          } else {
#line 743
            tmp___125 = (long )r->sub.val.nm.fltnum;
          }
#line 743
          tmp___126 = tmp___125;
        }
#line 743
        if (tmp___126 <= 0L) {
#line 748
          di = 0;
        }
      }
    }
#line 750
    if (di) {
      {
#line 751
      (*(*(set_array->sub.nodep.l.lp + 10)))(set_array, set_idx);
      }
    }
    {
#line 752
    unref(set_idx);
#line 753
    set_idx = (NODE *)((void *)0);
    }
  }
#line 755
  goto switch_break;
  case_34: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 764
  op_assign(op);
  }
#line 765
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 768
  (*(pc->x.aptr))();
  }
#line 769
  goto switch_break;
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 773
  r = stack_ptr->rptr;
#line 774
  if (pc->d.dl == 66L) {
#line 774
    if (r->flags & 2048U) {
      {
#line 774
      tmp___135 = mpfr_get_si((mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 774
      tmp___138 = tmp___135;
      }
    } else {
#line 774
      if (r->flags & 4096U) {
        {
#line 774
        tmp___136 = __gmpz_get_si((mpz_srcptr )(r->sub.val.nm.mpi));
#line 774
        tmp___137 = tmp___136;
        }
      } else {
#line 774
        tmp___137 = (long )r->sub.val.nm.fltnum;
      }
#line 774
      tmp___138 = tmp___137;
    }
#line 774
    if (tmp___138 == 0L) {
#line 782
      goto switch_break;
    } else {
#line 774
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 783
  if (pc->d.dl == 63L) {
#line 783
    goto _L___6;
  } else
#line 783
  if (pc->d.dl == 62L) {
    _L___6: /* CIL Label */ 
#line 783
    if (r->flags & 2048U) {
      {
#line 783
      tmp___131 = mpfr_get_si((mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 783
      tmp___134 = tmp___131;
      }
    } else {
#line 783
      if (r->flags & 4096U) {
        {
#line 783
        tmp___132 = __gmpz_get_si((mpz_srcptr )(r->sub.val.nm.mpi));
#line 783
        tmp___133 = tmp___132;
        }
      } else {
#line 783
        tmp___133 = (long )r->sub.val.nm.fltnum;
      }
#line 783
      tmp___134 = tmp___133;
    }
#line 783
    if (tmp___134 <= 0L) {
#line 789
      goto switch_break;
    }
  }
#line 792
  if ((unsigned int )op == 92U) {
    {
#line 793
    (*(pc->x.aptr))();
    }
  } else {
    {
#line 795
    (*(pc->x.aptr))();
    }
  }
#line 796
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 799
  r = concat_exp((int )pc->x.xl, (_Bool )(pc->d.dl & 1L));
  }
#line 800
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 800
    stack_ptr ++;
#line 800
    tmp___140 = stack_ptr;
  } else {
    {
#line 800
    tmp___139 = grow_stack();
#line 800
    tmp___140 = tmp___139;
    }
  }
#line 800
  tmp___140->rptr = r;
#line 801
  goto switch_break;
  case_50: /* CIL Label */ 
#line 804
  if ((pc + 1)->x.xl) {
    {
#line 807
    tmp___141 = stack_ptr;
#line 807
    stack_ptr --;
#line 807
    m = tmp___141->rptr;
#line 808
    t2 = TOP_SCALAR();
#line 809
    t2 = force_string(t2);
#line 810
    rp = re_update(m);
#line 811
    tmp___142 = avoid_dfa(m, t2->sub.val.sp, t2->sub.val.slen);
#line 811
    tmp___143 = research(rp, t2->sub.val.sp, 0, t2->sub.val.slen, tmp___142);
#line 811
    di = tmp___143 >= 0;
    }
  } else {
    {
#line 814
    t1 = POP_SCALAR();
#line 815
    t2 = TOP_SCALAR();
#line 816
    tmp___144 = cmp_nodes(t2, t1);
#line 816
    di = tmp___144 == 0;
#line 817
    DEREF(t1);
    }
  }
#line 820
  if (di) {
    {
#line 822
    t2 = POP_SCALAR();
#line 823
    DEREF(t2);
    }
    {
#line 824
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 824
      if (post_execute) {
        {
#line 824
        (*post_execute)(pc);
        }
      }
#line 824
      pc = pc->d.di;
#line 824
      goto top;
#line 824
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 826
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 829
  t1 = POP_ARRAY();
#line 830
  do_delete(t1, (int )pc->x.xl);
#line 831
  stack_ptr += - pc->x.xl;
  }
#line 832
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 835
  t1 = POP_ARRAY();
#line 836
  tmp___145 = stack_ptr;
#line 836
  stack_ptr --;
#line 836
  lhs = tmp___145->lptr;
#line 837
  do_delete_loop(t1, lhs);
  }
#line 838
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 841
  t1 = POP_ARRAY();
  }
#line 842
  if (pc->x.xl == 1L) {
    {
#line 842
    tmp___146 = POP_SCALAR();
#line 842
    t2 = tmp___146;
    }
  } else {
    {
#line 842
    tmp___147 = concat_exp((int )pc->x.xl, (_Bool)1);
#line 842
    t2 = tmp___147;
    }
  }
  {
#line 843
  tmp___148 = in_array(t1, t2);
#line 843
  r = node_Boolean[(unsigned long )tmp___148 != (unsigned long )((void *)0)];
#line 844
  DEREF(t2);
#line 845
  (r->sub.val.sref) ++;
  }
#line 846
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 846
    stack_ptr ++;
#line 846
    tmp___150 = stack_ptr;
  } else {
    {
#line 846
    tmp___149 = grow_stack();
#line 846
    tmp___150 = tmp___149;
    }
  }
#line 846
  tmp___150->rptr = r;
#line 847
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 851
  list = (NODE **)((void *)0);
#line 853
  num_elems = (size_t )0;
#line 855
  how_to_sort = "@unsorted";
#line 858
  array = POP_ARRAY();
#line 861
  tmp___151 = (*(*(array->sub.nodep.l.lp + 2)))(array, (struct exp_node *)((void *)0));
#line 861
  num_elems = (*tmp___151)->sub.nodep.reflags;
  }
#line 862
  if (num_elems == 0UL) {
#line 863
    goto arrayfor;
  }
#line 865
  if ((unsigned long )sorted_in___0 == (unsigned long )((void *)0)) {
    {
#line 866
    sorted_in___0 = make_str_node("sorted_in", (size_t )9, 0);
    }
  }
#line 868
  sort_str = (NODE *)((void *)0);
#line 873
  if (! (do_flags & 16)) {
#line 873
    if ((unsigned long )PROCINFO_node != (unsigned long )((void *)0)) {
      {
#line 874
      sort_str = in_array(PROCINFO_node, sorted_in___0);
      }
    }
  }
#line 876
  if ((unsigned long )sort_str != (unsigned long )((void *)0)) {
    {
#line 877
    sort_str = force_string(sort_str);
    }
#line 878
    if (sort_str->sub.val.slen > 0UL) {
#line 879
      how_to_sort = (char const   *)sort_str->sub.val.sp;
    }
  }
  {
#line 882
  list = assoc_list(array, how_to_sort, (sort_context_t )1);
  }
  arrayfor: 
#line 885
  r = (NODE *)nextfree[1].freep;
#line 885
  if (r) {
#line 885
    nextfree[1].freep = ((BLOCK *)r)->freep;
  } else {
    {
#line 885
    tmp___152 = more_blocks(1);
#line 885
    r = (NODE *)tmp___152;
    }
  }
#line 886
  r->type = (NODETYPE )15;
#line 887
  r->sub.nodep.r.av = list;
#line 888
  r->sub.nodep.reflags = num_elems;
#line 889
  r->sub.nodep.l.ll = -1L;
#line 890
  r->sub.nodep.rn = array;
#line 891
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 891
    stack_ptr ++;
#line 891
    tmp___154 = stack_ptr;
  } else {
    {
#line 891
    tmp___153 = grow_stack();
#line 891
    tmp___154 = tmp___153;
    }
  }
#line 891
  tmp___154->rptr = r;
#line 893
  if (num_elems == 0UL) {
    {
#line 894
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 894
      if (post_execute) {
        {
#line 894
        (*post_execute)(pc);
        }
      }
#line 894
      pc = pc->d.di;
#line 894
      goto top;
#line 894
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 896
  goto switch_break;
  case_89: /* CIL Label */ 
#line 899
  r = stack_ptr->rptr;
#line 900
  (r->sub.nodep.l.ll) ++;
#line 900
  if ((unsigned long )r->sub.nodep.l.ll == r->sub.nodep.reflags) {
#line 902
    array___0 = r->sub.nodep.rn;
#line 903
    if (do_flags & 3) {
#line 903
      if (array___0->sub.nodep.reflags != r->sub.nodep.reflags) {
        {
#line 904
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 904);
#line 904
        tmp___155 = array_vname((NODE const   *)array___0);
#line 904
        tmp___156 = gettext("for loop: array `%s\' changed size from %ld to %ld during loop execution");
#line 904
        (*lintfunc)((char const   *)tmp___156, tmp___155, (long )r->sub.nodep.reflags,
                    (long )array___0->sub.nodep.reflags);
        }
      }
    }
    {
#line 906
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 906
      if (post_execute) {
        {
#line 906
        (*post_execute)(pc);
        }
      }
#line 906
      pc = pc->d.di;
#line 906
      goto top;
#line 906
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 909
  t1 = *(r->sub.nodep.r.av + r->sub.nodep.l.ll);
#line 910
  if ((unsigned int )(pc->x.xn)->type == 4U) {
#line 910
    if (! ((unsigned long )(pc->x.xn)->sub.nodep.l.lptr == (unsigned long )Nnull_string)) {
#line 910
      lhs = & (pc->x.xn)->sub.nodep.l.lptr;
    } else {
      {
#line 910
      tmp___157 = r_get_lhs(pc->x.xn, (_Bool)0);
#line 910
      lhs = tmp___157;
      }
    }
  } else {
    {
#line 910
    tmp___157 = r_get_lhs(pc->x.xn, (_Bool)0);
#line 910
    lhs = tmp___157;
    }
  }
  {
#line 911
  unref(*lhs);
#line 912
  *lhs = dupnode(t1);
  }
#line 913
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 916
  tmp___158 = stack_ptr;
#line 916
  stack_ptr --;
#line 916
  r = tmp___158->rptr;
#line 918
  free_arrayfor(r);
  }
#line 919
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 922
  r = (*(pc->d.fptr))((int )pc->x.xl);
  }
#line 923
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 923
    stack_ptr ++;
#line 923
    tmp___160 = stack_ptr;
  } else {
    {
#line 923
    tmp___159 = grow_stack();
#line 923
    tmp___160 = tmp___159;
    }
  }
#line 923
  tmp___160->rptr = r;
#line 924
  goto switch_break;
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  {
#line 929
  arg_count = (int )pc->x.xl;
#line 932
  PUSH_CODE(pc);
  }
#line 933
  if ((unsigned int )op == 67U) {
    {
#line 934
    tmp___161 = (*(pc->d.efptr))(arg_count, & result);
#line 934
    r = awk_value_to_node((awk_value_t const   *)tmp___161);
    }
  } else {
    {
#line 936
    r = (*(pc->d.fptr))(arg_count);
    }
  }
  {
#line 937
  POP_CODE();
  }
  {
#line 938
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 938
    tmp___163 = arg_count;
#line 938
    arg_count --;
#line 938
    if (! (tmp___163 > 0)) {
#line 938
      goto while_break___8;
    }
#line 939
    tmp___162 = stack_ptr;
#line 939
    stack_ptr --;
#line 939
    t1 = tmp___162->rptr;
#line 940
    if ((unsigned int )t1->type == 1U) {
      {
#line 941
      DEREF(t1);
      }
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 943
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 943
    stack_ptr ++;
#line 943
    tmp___165 = stack_ptr;
  } else {
    {
#line 943
    tmp___164 = grow_stack();
#line 943
    tmp___165 = tmp___164;
    }
  }
#line 943
  tmp___165->rptr = r;
#line 945
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 948
  r = do_sub((int )pc->x.xl, (unsigned int )pc->d.dl);
  }
#line 949
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 949
    stack_ptr ++;
#line 949
    tmp___167 = stack_ptr;
  } else {
    {
#line 949
    tmp___166 = grow_stack();
#line 949
    tmp___167 = tmp___166;
    }
  }
#line 949
  tmp___167->rptr = r;
#line 950
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 953
  do_print((int )pc->x.xl, (int )pc->d.dl);
  }
#line 954
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 957
  do_printf((int )pc->x.xl, (int )pc->d.dl);
  }
#line 958
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 961
  do_print_rec((int )pc->x.xl, (int )pc->d.dl);
  }
#line 962
  goto switch_break;
  case_75: /* CIL Label */ 
#line 965
  m = pc->d.dn;
#line 966
  if ((unsigned int )m->type == 3U) {
    {
#line 967
    tmp___168 = POP_SCALAR();
#line 967
    r = force_string(tmp___168);
#line 968
    unref(m->sub.nodep.x.extra);
#line 969
    m->sub.nodep.x.extra = r;
    }
  }
#line 971
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 971
    stack_ptr ++;
#line 971
    tmp___170 = stack_ptr;
  } else {
    {
#line 971
    tmp___169 = grow_stack();
#line 971
    tmp___170 = tmp___169;
    }
  }
#line 971
  tmp___170->rptr = m;
#line 972
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 975
  m = pc->d.dn;
#line 976
  tmp___171 = get_field(0L, (Func_ptr *)0);
#line 976
  t1 = *tmp___171;
  }
  match_re: 
  {
#line 978
  rp = re_update(m);
#line 991
  tmp___172 = avoid_dfa(m, t1->sub.val.sp, t1->sub.val.slen);
#line 991
  di = research(rp, t1->sub.val.sp, 0, t1->sub.val.slen, tmp___172);
#line 993
  di = (di == -1) ^ ((unsigned int )op != 48U);
  }
#line 994
  if ((unsigned int )op != 47U) {
    {
#line 995
    stack_ptr --;
#line 996
    DEREF(t1);
    }
  }
#line 998
  r = node_Boolean[di];
#line 999
  (r->sub.val.sref) ++;
#line 1000
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1000
    stack_ptr ++;
#line 1000
    tmp___174 = stack_ptr;
  } else {
    {
#line 1000
    tmp___173 = grow_stack();
#line 1000
    tmp___174 = tmp___173;
    }
  }
#line 1000
  tmp___174->rptr = r;
#line 1001
  goto switch_break;
  case_46: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 1006
  m = pc->d.dn;
#line 1007
  tmp___175 = TOP_SCALAR();
#line 1007
  t1 = force_string(tmp___175);
  }
#line 1008
  if ((unsigned int )m->type == 3U) {
    {
#line 1009
    unref(m->sub.nodep.x.extra);
#line 1010
    m->sub.nodep.x.extra = t1;
#line 1011
    stack_ptr --;
#line 1012
    tmp___176 = TOP_SCALAR();
#line 1012
    t1 = force_string(tmp___176);
    }
  }
#line 1014
  goto match_re;
#line 1015
  goto switch_break;
  case_71: /* CIL Label */ 
#line 1019
  f = (NODE *)((void *)0);
#line 1022
  arg_count___0 = (int )(pc + 1)->x.xl;
#line 1023
  t1 = (stack_ptr - arg_count___0)->rptr;
#line 1025
  if ((unsigned int )t1->type != 1U) {
    {
#line 1026
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1026);
#line 1026
    tmp___177 = gettext("indirect function call requires a simple scalar value");
#line 1026
    r_fatal((char const   *)tmp___177);
    }
  }
  {
#line 1028
  t1 = force_string(t1);
  }
#line 1029
  if (t1->sub.val.slen > 0UL) {
#line 1031
    f = pc->x.xn;
#line 1032
    if ((unsigned long )f != (unsigned long )((void *)0)) {
      {
#line 1032
      tmp___178 = strcmp((char const   *)f->sub.nodep.name, (char const   *)t1->sub.val.sp);
      }
#line 1032
      if (tmp___178 == 0) {
        {
#line 1035
        ni = setup_frame(pc);
        }
        {
#line 1036
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1036
          if (post_execute) {
            {
#line 1036
            (*post_execute)(pc);
            }
          }
#line 1036
          pc = ni;
#line 1036
          goto top;
#line 1036
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
    {
#line 1038
    f = lookup((char const   *)t1->sub.val.sp);
    }
  }
#line 1041
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1041
    goto _L___8;
  } else
#line 1041
  if ((unsigned int )f->type != 8U) {
    _L___8: /* CIL Label */ 
#line 1042
    if ((unsigned int )f->type == 9U) {
      {
#line 1043
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1043);
#line 1043
      tmp___179 = gettext("cannot (yet) call extension functions indirectly");
#line 1043
      r_fatal((char const   *)tmp___179);
      }
    } else
#line 1042
    if ((unsigned int )f->type == 10U) {
      {
#line 1043
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1043);
#line 1043
      tmp___179 = gettext("cannot (yet) call extension functions indirectly");
#line 1043
      r_fatal((char const   *)tmp___179);
      }
    } else {
      {
#line 1045
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1045);
#line 1045
      tmp___180 = gettext("function called indirectly through `%s\' does not exist");
#line 1045
      r_fatal((char const   *)tmp___180, pc->d.name);
      }
    }
  }
  {
#line 1048
  pc->x.xn = f;
#line 1050
  ni = setup_frame(pc);
  }
  {
#line 1051
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1051
    if (post_execute) {
      {
#line 1051
      (*post_execute)(pc);
      }
    }
#line 1051
    pc = ni;
#line 1051
    goto top;
#line 1051
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  case_70: /* CIL Label */ 
#line 1059
  f___0 = pc->x.xn;
#line 1060
  if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
    {
#line 1061
    f___0 = lookup((char const   *)pc->d.name);
    }
#line 1062
    if ((unsigned long )f___0 == (unsigned long )((void *)0)) {
      {
#line 1063
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1063);
#line 1063
      tmp___181 = gettext("function `%s\' not defined");
#line 1063
      r_fatal((char const   *)tmp___181, pc->d.name);
      }
    } else
#line 1062
    if ((unsigned int )f___0->type != 8U) {
#line 1062
      if ((unsigned int )f___0->type != 9U) {
#line 1062
        if ((unsigned int )f___0->type != 10U) {
          {
#line 1063
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1063);
#line 1063
          tmp___181 = gettext("function `%s\' not defined");
#line 1063
          r_fatal((char const   *)tmp___181, pc->d.name);
          }
        }
      }
    }
#line 1064
    pc->x.xn = f___0;
  }
#line 1067
  if ((unsigned int )f___0->type == 9U) {
#line 1067
    goto _L___9;
  } else
#line 1067
  if ((unsigned int )f___0->type == 10U) {
    _L___9: /* CIL Label */ 
#line 1069
    fname = pc->d.name;
#line 1070
    arg_count___1 = (int )(pc + 1)->x.xl;
#line 1072
    bc = f___0->sub.nodep.r.iptr;
#line 1074
    if ((unsigned int )f___0->type == 9U) {
#line 1075
      pc->opcode = (OPCODE )67;
    } else {
#line 1077
      pc->opcode = (OPCODE )68;
    }
#line 1078
    pc->d.efptr = bc->d.efptr;
#line 1079
    pc->x.xl = (long )arg_count___1;
#line 1080
    (pc + 1)->d.name = fname;
#line 1081
    (pc + 1)->x.xl = bc->x.xl;
#line 1082
    ni = pc;
    {
#line 1083
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1083
      if (post_execute) {
        {
#line 1083
        (*post_execute)(pc);
        }
      }
#line 1083
      pc = ni;
#line 1083
      goto top;
#line 1083
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  {
#line 1086
  ni = setup_frame(pc);
  }
  {
#line 1087
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1087
    if (post_execute) {
      {
#line 1087
      (*post_execute)(pc);
      }
    }
#line 1087
    pc = ni;
#line 1087
    goto top;
#line 1087
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  case_59: /* CIL Label */ 
  {
#line 1091
  m = POP_SCALAR();
#line 1093
  ni = unwind_stack((long )frame_ptr->sub.nodep.reflags);
  }
#line 1096
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1096
    stack_ptr ++;
#line 1096
    tmp___183 = stack_ptr;
  } else {
    {
#line 1096
    tmp___182 = grow_stack();
#line 1096
    tmp___183 = tmp___182;
    }
  }
#line 1096
  tmp___183->rptr = m;
  {
#line 1098
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1098
    if (post_execute) {
      {
#line 1098
      (*post_execute)(pc);
      }
    }
#line 1098
    pc = ni;
#line 1098
    goto top;
#line 1098
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
  case_62: /* CIL Label */ 
#line 1101
  if (currule == 4) {
#line 1101
    goto _L___10;
  } else
#line 1101
  if (currule == 5) {
    _L___10: /* CIL Label */ 
#line 1101
    if (pc->x.xl == 0L) {
#line 1101
      if (pc->d.dl == 5L) {
        {
#line 1104
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1104);
#line 1104
        tmp___184 = gettext("`getline\' invalid inside `%s\' rule");
#line 1104
        r_fatal((char const   *)tmp___184, ruletab[currule]);
        }
      }
    }
  }
  {
#line 1105
  r = do_getline_redir((int )pc->x.xl, (enum redirval )pc->d.dl);
  }
#line 1106
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1106
    stack_ptr ++;
#line 1106
    tmp___186 = stack_ptr;
  } else {
    {
#line 1106
    tmp___185 = grow_stack();
#line 1106
    tmp___186 = tmp___185;
    }
  }
#line 1106
  tmp___186->rptr = r;
#line 1107
  goto switch_break;
  case_63: /* CIL Label */ 
#line 1110
  if (! currule) {
    {
#line 1111
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1111);
#line 1111
    tmp___187 = gettext("non-redirected `getline\' invalid inside `%s\' rule");
#line 1111
    r_fatal((char const   *)tmp___187, ruletab[currule]);
    }
  } else
#line 1110
  if (currule == 4) {
    {
#line 1111
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1111);
#line 1111
    tmp___187 = gettext("non-redirected `getline\' invalid inside `%s\' rule");
#line 1111
    r_fatal((char const   *)tmp___187, ruletab[currule]);
    }
  } else
#line 1110
  if (currule == 5) {
    {
#line 1111
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1111);
#line 1111
    tmp___187 = gettext("non-redirected `getline\' invalid inside `%s\' rule");
#line 1111
    r_fatal((char const   *)tmp___187, ruletab[currule]);
    }
  }
  {
#line 1114
  while (1) {
    while_continue___14: /* CIL Label */ ;
    {
#line 1116
    ret = nextfile(& curfile, (_Bool)0);
    }
#line 1117
    if (ret <= 0) {
      {
#line 1118
      r = do_getline((int )pc->x.xl, curfile);
      }
    } else {
      {
#line 1125
      push_exec_state(pc, currule, source, stack_ptr);
      }
#line 1127
      if ((unsigned long )curfile == (unsigned long )((void *)0)) {
        {
#line 1128
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 1128
          if (post_execute) {
            {
#line 1128
            (*post_execute)(pc);
            }
          }
#line 1128
          pc = (pc + 1)->x.xi;
#line 1128
          goto top;
#line 1128
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      } else {
        {
#line 1130
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 1130
          if (post_execute) {
            {
#line 1130
            (*post_execute)(pc);
            }
          }
#line 1130
          pc = (pc + 1)->d.di;
#line 1130
          goto top;
#line 1130
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
    }
#line 1114
    if (! ((unsigned long )r == (unsigned long )((void *)0))) {
#line 1114
      goto while_break___14;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 1134
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1134
    stack_ptr ++;
#line 1134
    tmp___189 = stack_ptr;
  } else {
    {
#line 1134
    tmp___188 = grow_stack();
#line 1134
    tmp___189 = tmp___188;
    }
  }
#line 1134
  tmp___189->rptr = r;
#line 1135
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 1139
  ni = pop_exec_state(& currule, & source, (long *)((void *)0));
  }
  {
#line 1142
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 1142
    if (post_execute) {
      {
#line 1142
      (*post_execute)(pc);
      }
    }
#line 1142
    pc = ni;
#line 1142
    goto top;
#line 1142
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  case_95: /* CIL Label */ 
  {
#line 1145
  after_beginfile(& curfile);
#line 1148
  ni = pop_exec_state(& currule, & source, (long *)((void *)0));
  }
#line 1151
  if ((unsigned int )ni->opcode == 63U) {
#line 1151
    goto _L___11;
  } else
#line 1151
  if ((unsigned long )curfile == (unsigned long )((void *)0)) {
    _L___11: /* CIL Label */ 
    {
#line 1154
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1154
      if (post_execute) {
        {
#line 1154
        (*post_execute)(pc);
        }
      }
#line 1154
      pc = ni;
#line 1154
      goto top;
#line 1154
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
  }
#line 1156
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 1162
  ret___0 = nextfile(& curfile, (_Bool)0);
  }
#line 1164
  if (ret___0 < 0) {
    {
#line 1165
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1165
      if (post_execute) {
        {
#line 1165
        (*post_execute)(pc);
        }
      }
#line 1165
      pc = pc->d.di;
#line 1165
      goto top;
#line 1165
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
  }
#line 1167
  if (ret___0 == 0) {
    {
#line 1168
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 1168
      if (post_execute) {
        {
#line 1168
        (*post_execute)(pc);
        }
      }
#line 1168
      pc = (pc + 1)->x.xi;
#line 1168
      goto top;
#line 1168
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
  }
  {
#line 1173
  push_exec_state(pc, currule, source, stack_ptr);
  }
#line 1175
  if ((unsigned long )curfile == (unsigned long )((void *)0)) {
    {
#line 1176
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1176
      if (post_execute) {
        {
#line 1176
        (*post_execute)(pc);
        }
      }
#line 1176
      pc = pc->x.xi;
#line 1176
      goto top;
#line 1176
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
  }
#line 1180
  goto switch_break;
  case_86: /* CIL Label */ 
#line 1184
  errcode = 0;
#line 1186
  ni = pc->d.di;
#line 1187
  if ((unsigned long )curfile == (unsigned long )((void *)0)) {
#line 1194
    ni = ni->d.di;
    {
#line 1195
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1195
      if (post_execute) {
        {
#line 1195
        (*post_execute)(pc);
        }
      }
#line 1195
      pc = ni;
#line 1195
      goto top;
#line 1195
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
  }
  {
#line 1198
  tmp___192 = inrec(curfile, & errcode);
  }
#line 1198
  if (tmp___192 != 0) {
#line 1199
    if (errcode > 0) {
#line 1199
      if (do_flags & 8) {
        {
#line 1200
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1200);
#line 1200
        tmp___190 = strerror(errcode);
#line 1200
        tmp___191 = gettext("error reading input file `%s\': %s");
#line 1200
        r_fatal((char const   *)tmp___191, curfile->public.name, tmp___190);
        }
      } else
#line 1199
      if (! pc->x.xl) {
        {
#line 1200
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1200);
#line 1200
        tmp___190 = strerror(errcode);
#line 1200
        tmp___191 = gettext("error reading input file `%s\': %s");
#line 1200
        r_fatal((char const   *)tmp___191, curfile->public.name, tmp___190);
        }
      }
    }
    {
#line 1203
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 1203
      if (post_execute) {
        {
#line 1203
        (*post_execute)(pc);
        }
      }
#line 1203
      pc = ni;
#line 1203
      goto top;
#line 1203
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
  }
#line 1207
  goto switch_break;
  case_64: /* CIL Label */ 
#line 1213
  if (currule != 2) {
#line 1213
    if (currule != 4) {
      {
#line 1214
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1214);
#line 1214
      tmp___193 = gettext("`nextfile\' cannot be called from a `%s\' rule");
#line 1214
      r_fatal((char const   *)tmp___193, ruletab[currule]);
      }
    }
  }
  {
#line 1217
  ret___1 = nextfile(& curfile, (_Bool)1);
  }
#line 1219
  if (currule == 4) {
    {
#line 1222
    ni = pop_exec_state(& currule, & source, & stack_size);
#line 1227
    unwind_stack(stack_size);
    }
#line 1229
    if (ret___1 == 0) {
      {
#line 1234
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 1234
        if (post_execute) {
          {
#line 1234
          (*post_execute)(pc);
          }
        }
#line 1234
        pc = ni;
#line 1234
        goto top;
#line 1234
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
    } else {
      {
#line 1239
      push_exec_state(ni, currule, source, stack_ptr);
      }
      {
#line 1241
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 1241
        if (post_execute) {
          {
#line 1241
          (*post_execute)(pc);
          }
        }
#line 1241
        pc = pc->x.xi;
#line 1241
        goto top;
#line 1241
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
  {
#line 1247
  unwind_stack(0L);
#line 1250
  push_exec_state(pc->d.di, currule, source, stack_ptr);
  }
  {
#line 1252
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 1252
    if (post_execute) {
      {
#line 1252
      (*post_execute)(pc);
      }
    }
#line 1252
    pc = pc->x.xi;
#line 1252
    goto top;
#line 1252
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 1254
  goto switch_break;
  case_58: /* CIL Label */ 
#line 1260
  if (! currule) {
    {
#line 1261
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1261);
#line 1261
    tmp___194 = gettext("`exit\' cannot be called in the current context");
#line 1261
    r_fatal((char const   *)tmp___194);
    }
  }
  {
#line 1263
  exiting = (_Bool)1;
#line 1264
  tmp___195 = POP_SCALAR();
#line 1264
  t1 = force_number(tmp___195);
  }
#line 1265
  if (t1->flags & 2048U) {
    {
#line 1265
    tmp___196 = mpfr_get_si((mpfr_srcptr )(t1->sub.val.nm.mpnum), ROUND_MODE);
#line 1265
    tmp___199 = tmp___196;
    }
  } else {
#line 1265
    if (t1->flags & 4096U) {
      {
#line 1265
      tmp___197 = __gmpz_get_si((mpz_srcptr )(t1->sub.val.nm.mpi));
#line 1265
      tmp___198 = tmp___197;
      }
    } else {
#line 1265
      tmp___198 = (long )t1->sub.val.nm.fltnum;
    }
#line 1265
    tmp___199 = tmp___198;
  }
  {
#line 1265
  exit_val = (int )tmp___199;
#line 1266
  DEREF(t1);
  }
#line 1276
  if (currule == 4) {
    {
#line 1284
    pop_exec_state(& currule, & source, (long *)((void *)0));
    }
  } else
#line 1276
  if (currule == 5) {
    {
#line 1284
    pop_exec_state(& currule, & source, (long *)((void *)0));
    }
  }
  {
#line 1287
  unwind_stack(0L);
  }
#line 1293
  if (currule == 3) {
#line 1294
    ni = pc->x.xi;
  } else {
#line 1296
    ni = pc->d.di;
  }
  {
#line 1297
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 1297
    if (post_execute) {
      {
#line 1297
      (*post_execute)(pc);
      }
    }
#line 1297
    pc = ni;
#line 1297
    goto top;
#line 1297
    goto while_break___27;
  }
  while_break___27: /* CIL Label */ ;
  }
  case_57: /* CIL Label */ 
#line 1300
  if (currule != 2) {
    {
#line 1301
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1301);
#line 1301
    tmp___200 = gettext("`next\' cannot be called from a `%s\' rule");
#line 1301
    r_fatal((char const   *)tmp___200, ruletab[currule]);
    }
  }
  {
#line 1303
  unwind_stack(0L);
  }
  {
#line 1304
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 1304
    if (post_execute) {
      {
#line 1304
      (*post_execute)(pc);
      }
    }
#line 1304
    pc = pc->d.di;
#line 1304
    goto top;
#line 1304
    goto while_break___28;
  }
  while_break___28: /* CIL Label */ ;
  }
  case_82: /* CIL Label */ 
  {
#line 1307
  r = POP_SCALAR();
#line 1308
  DEREF(r);
  }
#line 1309
  goto switch_break;
  case_14: /* CIL Label */ 
#line 1312
  if (pc->x.xl) {
    {
#line 1313
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 1313
      if (post_execute) {
        {
#line 1313
        (*post_execute)(pc);
        }
      }
#line 1313
      pc = pc->d.di;
#line 1313
      goto top;
#line 1313
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
  }
#line 1316
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 1323
  t1 = TOP_SCALAR();
#line 1324
  tmp___201 = eval_condition(t1);
#line 1324
  di = tmp___201 != 0;
#line 1325
  DEREF(t1);
#line 1327
  ip = pc->x.xi;
  }
#line 1329
  if (! ip->x.xl) {
#line 1329
    if (di) {
#line 1331
      stack_ptr --;
#line 1332
      ip->x.xl = 1L;
      {
#line 1333
      while (1) {
        while_continue___30: /* CIL Label */ ;
#line 1333
        if (post_execute) {
          {
#line 1333
          (*post_execute)(pc);
          }
        }
#line 1333
        pc = ip->d.di;
#line 1333
        goto top;
#line 1333
        goto while_break___30;
      }
      while_break___30: /* CIL Label */ ;
      }
    }
  }
#line 1336
  if (ip->x.xl) {
#line 1336
    tmp___202 = 1;
  } else
#line 1336
  if (di) {
#line 1336
    tmp___202 = 1;
  } else {
#line 1336
    tmp___202 = 0;
  }
#line 1336
  result___0 = tmp___202;
#line 1337
  ip->x.xl ^= (long )di;
#line 1338
  r = node_Boolean[result___0];
#line 1339
  (r->sub.val.sref) ++;
#line 1340
  stack_ptr->rptr = r;
  {
#line 1341
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 1341
    if (post_execute) {
      {
#line 1341
      (*post_execute)(pc);
      }
    }
#line 1341
    pc = pc->d.di;
#line 1341
    goto top;
#line 1341
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
  case_98: /* CIL Label */ 
#line 1345
  if (do_flags & 4096) {
#line 1346
    (pc->d.dl) ++;
  }
#line 1347
  goto switch_break;
  case_114: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_81: /* CIL Label */ 
#line 1359
  goto switch_break;
  switch_default___1: /* CIL Label */ 
  {
#line 1362
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/interpret.h", 1362);
#line 1362
  tmp___203 = opcode2str(op);
#line 1362
  tmp___204 = gettext("Sorry, don\'t know how to interpret `%s\'");
#line 1362
  r_fatal((char const   *)tmp___204, tmp___203);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1365
  while (1) {
    while_continue___32: /* CIL Label */ ;
#line 1365
    if (post_execute) {
      {
#line 1365
      (*post_execute)(pc);
      }
    }
#line 1365
    pc = pc->nexti;
#line 1365
    goto top;
#line 1365
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
#line 1370
  return (0);
}
}
#line 1742 "/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c"
void init_interpret(void) 
{ 
  long newval ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1747
  newval = getenv_long("GAWK_STACKSIZE");
  }
#line 1747
  if (newval > 0L) {
#line 1748
    STACK_SIZE = (unsigned long )newval;
  }
  {
#line 1750
  tmp___1 = malloc(STACK_SIZE * sizeof(STACK_ITEM ));
#line 1750
  stack_bottom = (STACK_ITEM *)tmp___1;
  }
#line 1750
  if (stack_bottom) {
#line 1750
    tmp___5 = 1;
  } else {
    {
#line 1750
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/eval.c", 1750);
#line 1750
    tmp___2 = __errno_location();
#line 1750
    tmp___3 = strerror(*tmp___2);
#line 1750
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1750
    r_fatal((char const   *)tmp___4, "grow_stack", "stack_bottom", (long )(STACK_SIZE * sizeof(STACK_ITEM )),
            tmp___3);
#line 1750
    tmp___5 = 0;
    }
  }
#line 1751
  stack_ptr = stack_bottom - 1;
#line 1752
  stack_top = (stack_bottom + STACK_SIZE) - 1;
#line 1755
  frame_ptr = (NODE *)nextfree[1].freep;
#line 1755
  if (frame_ptr) {
#line 1755
    nextfree[1].freep = ((BLOCK *)frame_ptr)->freep;
  } else {
    {
#line 1755
    tmp___6 = more_blocks(1);
#line 1755
    frame_ptr = (NODE *)tmp___6;
    }
  }
  {
#line 1756
  frame_ptr->type = (NODETYPE )16;
#line 1757
  frame_ptr->sub.nodep.r.av = (struct exp_node **)((void *)0);
#line 1758
  frame_ptr->sub.nodep.x.extra = (struct exp_node *)((void *)0);
#line 1759
  frame_ptr->sub.nodep.cnt = 0UL;
#line 1760
  frame_ptr->sub.nodep.name = (char *)((void *)0);
#line 1763
  node_Boolean[0] = (*make_number)(0.0);
#line 1764
  node_Boolean[1] = (*make_number)(1.0);
  }
#line 1765
  if (! (((node_Boolean[0])->flags & 6144U) != 0U)) {
#line 1766
    (node_Boolean[0])->flags |= 256U;
#line 1767
    (node_Boolean[1])->flags |= 256U;
  }
#line 1776
  if (num_exec_hook > 0) {
#line 1777
    interpret = & h_interpret;
  } else {
#line 1779
    interpret = & r_interpret;
  }
#line 1780
  return;
}
}
#line 102 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 103
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 104
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 105
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 106
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 107
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 108
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 44 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.h"
struct dfamust * __attribute__((__pure__)) dfamusts(struct dfa  const  *d ) ;
#line 77
void dfainit(struct dfa *d ) ;
#line 80
void dfaparse(char const   *s___0 , size_t len , struct dfa *d ) ;
#line 84
void dfaanalyze(struct dfa *d , int searchflag ) ;
#line 88
void dfastate(ptrdiff_t s___0 , struct dfa *d , ptrdiff_t *trans ) ;
#line 355 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int wctob(wint_t __c ) ;
#line 118 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswalpha(wint_t __wc ) ;
#line 152
extern  __attribute__((__nothrow__)) int iswupper(wint_t __wc ) ;
#line 54 "/home/wslee/gnu_benchmarks/gawk-4.1.0/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 57
__inline void *xzalloc(size_t s___0 )  __attribute__((__malloc__)) ;
#line 58
void *xcalloc(size_t nmemb , size_t size )  __attribute__((__malloc__)) ;
#line 59
void *xrealloc(void *p , size_t size ) ;
#line 61
void *xmemdup(void const   *p , size_t s___0 )  __attribute__((__malloc__)) ;
#line 128
__inline static void *xnmalloc(size_t n , size_t s___0 )  __attribute__((__malloc__)) ;
#line 129
__inline static void *xnmalloc(size_t n , size_t s___0 )  __attribute__((__malloc__)) ;
#line 129 "/home/wslee/gnu_benchmarks/gawk-4.1.0/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s___0 ) 
{ 
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 132
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 132
    tmp___1 = -1;
  } else {
#line 132
    tmp___1 = -2;
  }
#line 132
  if ((size_t )tmp___1 / s___0 < n) {
    {
#line 133
    xalloc_die();
    }
  }
  {
#line 134
  tmp___2 = xmalloc(n * s___0);
  }
#line 134
  return (tmp___2);
}
}
#line 143
void *xcalloc(size_t nmemb , size_t size )  __attribute__((__malloc__)) ;
#line 143 "/home/wslee/gnu_benchmarks/gawk-4.1.0/xalloc.h"
void *xcalloc(size_t nmemb , size_t size ) 
{ 
  void *p ;
  void *tmp___1 ;

  {
  {
#line 146
  tmp___1 = xmalloc(nmemb * size);
#line 146
  p = tmp___1;
#line 147
  memset(p, '\000', nmemb * size);
  }
#line 148
  return (p);
}
}
#line 153 "/home/wslee/gnu_benchmarks/gawk-4.1.0/xalloc.h"
void *xrealloc(void *p , size_t size ) 
{ 
  void *new_p ;
  void *tmp___1 ;

  {
  {
#line 156
  tmp___1 = realloc(p, size);
#line 156
  new_p = tmp___1;
  }
#line 157
  if ((unsigned long )new_p == (unsigned long )((void *)0)) {
    {
#line 158
    xalloc_die();
    }
  }
#line 160
  return (new_p);
}
}
#line 165
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 165 "/home/wslee/gnu_benchmarks/gawk-4.1.0/xalloc.h"
void xalloc_die(void) 
{ 
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp4 ;

  {
  {
#line 170
  tmp___1 = __errno_location();
#line 170
  tmp___2 = strerror(*tmp___1);
#line 170
  tmp___3 = gettext("xalloc: malloc failed: %s");
#line 170
  r_fatal((char const   *)tmp___3, tmp___2);
  }
}
}
#line 177
void *xmemdup(void const   *p , size_t s___0 )  __attribute__((__malloc__)) ;
#line 177 "/home/wslee/gnu_benchmarks/gawk-4.1.0/xalloc.h"
void *xmemdup(void const   *p , size_t s___0 ) 
{ 
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 180
  tmp___1 = xmalloc(s___0);
#line 180
  tmp___2 = memcpy((void */* __restrict  */)tmp___1, (void const   */* __restrict  */)p,
                   s___0);
  }
#line 180
  return (tmp___2);
}
}
#line 187 "/home/wslee/gnu_benchmarks/gawk-4.1.0/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s___0 ) 
{ 
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 190
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 190
    tmp___1 = -1;
  } else {
#line 190
    tmp___1 = -2;
  }
#line 190
  if ((size_t )tmp___1 / s___0 < n) {
    {
#line 191
    xalloc_die();
    }
  }
  {
#line 192
  tmp___2 = xrealloc(p, n * s___0);
  }
#line 192
  return (tmp___2);
}
}
#line 250 "/home/wslee/gnu_benchmarks/gawk-4.1.0/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s___0 ) 
{ 
  size_t n ;
  void *tmp___1 ;

  {
#line 253
  n = *pn;
#line 255
  if (! p) {
#line 257
    if (! n) {
#line 265
      n = 64UL / s___0;
#line 266
      n += (size_t )(! n);
    }
  } else {
#line 275
    if (0xaaaaaaaaaaaaaaaaUL / s___0 <= n) {
      {
#line 276
      xalloc_die();
      }
    }
#line 277
    n += (n + 1UL) / 2UL;
  }
  {
#line 280
  *pn = n;
#line 281
  tmp___1 = xrealloc(p, n * s___0);
  }
#line 281
  return (tmp___1);
}
}
#line 298
__inline void *xzalloc(size_t s___0 )  __attribute__((__malloc__)) ;
#line 298 "/home/wslee/gnu_benchmarks/gawk-4.1.0/xalloc.h"
__inline void *xzalloc(size_t s___0 ) 
{ 
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 301
  tmp___1 = xmalloc(s___0);
#line 301
  tmp___2 = memset(tmp___1, 0, s___0);
  }
#line 301
  return (tmp___2);
}
}
#line 88 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int is_blank___1(int c ) 
{ 
  int tmp___1 ;

  {
#line 91
  if (c == 32) {
#line 91
    tmp___1 = 1;
  } else
#line 91
  if (c == 9) {
#line 91
    tmp___1 = 1;
  } else {
#line 91
    tmp___1 = 0;
  }
#line 91
  return (tmp___1);
}
}
#line 133 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
__inline static unsigned char to_uchar(char ch ) 
{ 


  {
#line 136
  return ((unsigned char )ch);
}
}
#line 470
static void dfamust(struct dfa *d ) ;
#line 471
static void regexp(void) ;
#line 589 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int tstbit(unsigned int b___0 , int * const  c ) 
{ 


  {
#line 592
  return (*(c + (unsigned long )b___0 / (8UL * sizeof(int ))) & (1 << (unsigned long )b___0 % (8UL * sizeof(int ))));
}
}
#line 595 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void setbit(unsigned int b___0 , int *c ) 
{ 


  {
#line 598
  *(c + (unsigned long )b___0 / (8UL * sizeof(int ))) |= 1 << (unsigned long )b___0 % (8UL * sizeof(int ));
#line 599
  return;
}
}
#line 601 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void clrbit(unsigned int b___0 , int *c ) 
{ 


  {
#line 604
  *(c + (unsigned long )b___0 / (8UL * sizeof(int ))) &= ~ (1 << (unsigned long )b___0 % (8UL * sizeof(int )));
#line 605
  return;
}
}
#line 607 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void copyset(int * const  src , int *dst ) 
{ 


  {
  {
#line 610
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, sizeof(charclass ));
  }
#line 611
  return;
}
}
#line 613 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void zeroset(int *s___0 ) 
{ 


  {
  {
#line 616
  memset((void *)s___0, 0, sizeof(charclass ));
  }
#line 617
  return;
}
}
#line 619 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void notset(int *s___0 ) 
{ 
  int i___0 ;

  {
#line 624
  i___0 = 0;
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! ((unsigned long )i___0 < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 624
      goto while_break;
    }
#line 625
    *(s___0 + i___0) = ~ *(s___0 + i___0);
#line 624
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 626
  return;
}
}
#line 628 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int equal(int * const  s1 , int * const  s2 ) 
{ 
  int tmp___1 ;

  {
  {
#line 631
  tmp___1 = memcmp((void const   *)s1, (void const   *)s2, sizeof(charclass ));
  }
#line 631
  return (tmp___1 == 0);
}
}
#line 635 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static struct dfa *dfa  ;
#line 638 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static size_t charclass_index(int * const  s___0 ) 
{ 
  size_t i___0 ;
  int tmp___1 ;
  size_t new_n_alloc ;
  void *tmp___2 ;

  {
#line 643
  i___0 = (size_t )0;
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! (i___0 < dfa->cindex)) {
#line 643
      goto while_break;
    }
    {
#line 644
    tmp___1 = equal(s___0, (int */* const  */)(*(dfa->charclasses + i___0)));
    }
#line 644
    if (tmp___1) {
#line 645
      return (i___0);
    }
#line 643
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 646
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 646
    if (dfa->calloc <= dfa->cindex + 1UL) {
      {
#line 646
      new_n_alloc = (dfa->cindex + 1UL) + (size_t )(! dfa->charclasses);
#line 646
      tmp___2 = x2nrealloc((void *)dfa->charclasses, & new_n_alloc, sizeof(*(dfa->charclasses)));
#line 646
      dfa->charclasses = (charclass *)tmp___2;
#line 646
      dfa->calloc = new_n_alloc;
      }
    }
#line 646
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 647
  (dfa->cindex) ++;
#line 648
  copyset(s___0, *(dfa->charclasses + i___0));
  }
#line 649
  return (i___0);
}
}
#line 653 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static reg_syntax_t syntax_bits  ;
#line 653 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static reg_syntax_t syntax_bits_set  ;
#line 656 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int case_fold  ;
#line 659 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static unsigned char eolbyte  ;
#line 662 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int sbit[1 << 8]  ;
#line 665 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static charclass letters  ;
#line 668 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static charclass newline  ;
#line 683 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int char_context(unsigned char c ) 
{ 
  unsigned short const   **tmp___1 ;

  {
#line 686
  if ((int )c == (int )eolbyte) {
#line 687
    return (4);
  } else
#line 686
  if ((int )c == 0) {
#line 687
    return (4);
  }
  {
#line 688
  tmp___1 = __ctype_b_loc();
  }
#line 688
  if ((int const   )*(*tmp___1 + (int )c) & 8) {
#line 689
    return (2);
  } else
#line 688
  if ((int )c == 95) {
#line 689
    return (2);
  }
#line 690
  return (1);
}
}
#line 693 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int wchar_context(wint_t wc ) 
{ 
  int tmp___1 ;

  {
#line 696
  if (wc == (wint_t )((wchar_t )eolbyte)) {
#line 697
    return (4);
  } else
#line 696
  if (wc == 0U) {
#line 697
    return (4);
  }
#line 698
  if (wc == 95U) {
#line 699
    return (2);
  } else {
    {
#line 698
    tmp___1 = iswalnum(wc);
    }
#line 698
    if (tmp___1) {
#line 699
      return (2);
    }
  }
#line 700
  return (1);
}
}
#line 704 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
void dfasyntax(reg_syntax_t bits , int fold , unsigned char eol ) 
{ 
  unsigned int i___0 ;

  {
#line 709
  syntax_bits_set = (reg_syntax_t )1;
#line 710
  syntax_bits = bits;
#line 711
  case_fold = fold;
#line 712
  eolbyte = eol;
#line 714
  i___0 = 0U;
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (i___0 < (unsigned int )(1 << 8))) {
#line 714
      goto while_break;
    }
    {
#line 716
    sbit[i___0] = char_context((unsigned char )i___0);
    }
    {
#line 719
    if (sbit[i___0] == 2) {
#line 719
      goto case_2;
    }
#line 722
    if (sbit[i___0] == 4) {
#line 722
      goto case_4;
    }
#line 717
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 720
    setbit(i___0, letters);
    }
#line 721
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 723
    setbit(i___0, newline);
    }
#line 724
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 714
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return;
}
}
#line 735 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static _Bool setbit_wc(wint_t wc , int *c ) 
{ 
  int b___0 ;
  int tmp___1 ;

  {
  {
#line 738
  tmp___1 = wctob(wc);
#line 738
  b___0 = tmp___1;
  }
#line 739
  if (b___0 == -1) {
#line 740
    return ((_Bool)0);
  }
  {
#line 742
  setbit((unsigned int )b___0, c);
  }
#line 743
  return ((_Bool)1);
}
}
#line 748 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void setbit_c(int b___0 , int *c ) 
{ 
  size_t tmp___1 ;
  wint_t tmp___2 ;

  {
  {
#line 752
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 752
  if (tmp___1 > 1UL) {
    {
#line 752
    tmp___2 = btowc(b___0);
    }
#line 752
    if (tmp___2 == 4294967295U) {
#line 753
      return;
    }
  }
  {
#line 754
  setbit((unsigned int )b___0, c);
  }
#line 755
  return;
}
}
#line 770 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void setbit_case_fold_c(int b___0 , int *c ) 
{ 
  wint_t wc ;
  wint_t tmp___1 ;
  wint_t tmp___2 ;
  wint_t tmp___3 ;
  wint_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 773
  tmp___12 = __ctype_get_mb_cur_max();
  }
#line 773
  if (tmp___12 > 1UL) {
    {
#line 775
    tmp___1 = btowc(b___0);
#line 775
    wc = tmp___1;
    }
#line 776
    if (wc == 4294967295U) {
#line 777
      return;
    }
    {
#line 778
    setbit((unsigned int )b___0, c);
    }
#line 779
    if (case_fold) {
      {
#line 779
      tmp___6 = iswalpha(wc);
      }
#line 779
      if (tmp___6) {
        {
#line 780
        tmp___5 = iswupper(wc);
        }
#line 780
        if (tmp___5) {
          {
#line 780
          tmp___2 = towlower(wc);
#line 780
          tmp___4 = tmp___2;
          }
        } else {
          {
#line 780
          tmp___3 = towupper(wc);
#line 780
          tmp___4 = tmp___3;
          }
        }
        {
#line 780
        setbit_wc(tmp___4, c);
        }
      }
    }
  } else {
    {
#line 784
    setbit((unsigned int )b___0, c);
    }
#line 785
    if (case_fold) {
      {
#line 785
      tmp___11 = __ctype_b_loc();
      }
#line 785
      if ((int const   )*(*tmp___11 + b___0) & 1024) {
        {
#line 786
        tmp___10 = __ctype_b_loc();
        }
#line 786
        if ((int const   )*(*tmp___10 + b___0) & 256) {
          {
#line 786
          tmp___7 = tolower(b___0);
#line 786
          tmp___9 = tmp___7;
          }
        } else {
          {
#line 786
          tmp___8 = toupper(b___0);
#line 786
          tmp___9 = tmp___8;
          }
        }
        {
#line 786
        setbit_c(tmp___9, c);
        }
      }
    }
  }
#line 788
  return;
}
}
#line 797
__inline static int using_utf8(void) ;
#line 797 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int utf8  =    -1;
#line 794 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
__inline static int using_utf8(void) 
{ 
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp3 ;

  {
#line 798
  if (utf8 == -1) {
    {
#line 801
    tmp___1 = nl_langinfo(14);
#line 801
    tmp___2 = strcmp((char const   *)tmp___1, "UTF-8");
#line 801
    utf8 = tmp___2 == 0;
    }
  }
#line 811
  return (utf8);
}
}
#line 819 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static char const   *lexptr  ;
#line 820 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static size_t lexleft  ;
#line 821 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static token lasttok  ;
#line 822 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int laststart  ;
#line 824 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static size_t parens  ;
#line 825 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int minrep  ;
#line 825 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int maxrep  ;
#line 827 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int cur_mb_len  =    1;
#line 830 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static mbstate_t mbs  ;
#line 831 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static wchar_t wctok  ;
#line 833 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static unsigned char *mblen_buf  ;
#line 842 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static wchar_t *inputwcs  ;
#line 849 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static unsigned char const   *buf_begin  ;
#line 850 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static unsigned char const   *buf_end  ;
#line 925 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static struct dfa_ctype  const  prednames[13]  = 
#line 925
  {      {"alpha", & isalpha, (_Bool)0}, 
        {"upper", & isupper, (_Bool)0}, 
        {"lower", & islower, (_Bool)0}, 
        {"digit", & isdigit, (_Bool)1}, 
        {"xdigit", & isxdigit, (_Bool)1}, 
        {"space", & isspace, (_Bool)0}, 
        {"punct", & ispunct, (_Bool)0}, 
        {"alnum", & isalnum, (_Bool)0}, 
        {"print", & isprint, (_Bool)0}, 
        {"graph", & isgraph, (_Bool)0}, 
        {"cntrl", & iscntrl, (_Bool)0}, 
        {"blank", & is_blank___1, (_Bool)0}, 
        {(char const   *)((void *)0), (predicate *)((void *)0), (_Bool)0}};
#line 941 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static struct dfa_ctype  const  * __attribute__((__pure__)) find_pred(char const   *str ) 
{ 
  unsigned int i___0 ;
  int tmp___1 ;

  {
#line 945
  i___0 = 0U;
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 945
    if (! prednames[i___0].name) {
#line 945
      goto while_break;
    }
    {
#line 946
    tmp___1 = strcmp(str, (char const   *)prednames[i___0].name);
    }
#line 946
    if (tmp___1 == 0) {
#line 947
      goto while_break;
    }
#line 945
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 949
  return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)(& prednames[i___0]));
}
}
#line 1233 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static charclass zeroclass  ;
#line 955 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static token parse_bracket_exp___0(void) 
{ 
  int invert ;
  int c ;
  int c1 ;
  int c2 ;
  charclass ccl ;
  int colon_warning_state ;
  wint_t wc ;
  wint_t wc2 ;
  wint_t wc1 ;
  struct mb_char_classes *work_mbc ;
  size_t chars_al ;
  size_t range_sts_al ;
  size_t range_ends_al ;
  size_t ch_classes_al ;
  size_t equivs_al ;
  size_t coll_elems_al ;
  size_t new_n_alloc ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  wchar_t _wc ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  unsigned char tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  wchar_t _wc___0 ;
  size_t tmp___11 ;
  char const   *tmp___12 ;
  unsigned char tmp___13 ;
  char str[128] ;
  char *tmp___14 ;
  char *tmp___15 ;
  wchar_t _wc___1 ;
  size_t tmp___16 ;
  char const   *tmp___17 ;
  unsigned char tmp___18 ;
  size_t len ;
  char *tmp___19 ;
  char *tmp___20 ;
  wchar_t _wc___2 ;
  size_t tmp___21 ;
  char const   *tmp___22 ;
  unsigned char tmp___23 ;
  size_t tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  wchar_t _wc___3 ;
  size_t tmp___27 ;
  char const   *tmp___28 ;
  unsigned char tmp___29 ;
  char const   *class ;
  char const   *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  * __attribute__((__pure__)) tmp___33 ;
  char *tmp___34 ;
  wctype_t wt ;
  wctype_t tmp___35 ;
  size_t new_n_alloc___0 ;
  void *tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;
  char *elem ;
  void *tmp___40 ;
  size_t new_n_alloc___1 ;
  void *tmp___41 ;
  size_t tmp___42 ;
  size_t new_n_alloc___2 ;
  void *tmp___43 ;
  size_t tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  wchar_t _wc___4 ;
  size_t tmp___47 ;
  char const   *tmp___48 ;
  unsigned char tmp___49 ;
  size_t tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  wchar_t _wc___5 ;
  size_t tmp___53 ;
  char const   *tmp___54 ;
  unsigned char tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  wchar_t _wc___6 ;
  size_t tmp___58 ;
  char const   *tmp___59 ;
  unsigned char tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  wchar_t _wc___7 ;
  size_t tmp___63 ;
  char const   *tmp___64 ;
  unsigned char tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  wchar_t _wc___8 ;
  size_t tmp___68 ;
  char const   *tmp___69 ;
  unsigned char tmp___70 ;
  size_t new_n_alloc___3 ;
  void *tmp___71 ;
  size_t new_n_alloc___4 ;
  void *tmp___72 ;
  wint_t tmp___73 ;
  size_t tmp___74 ;
  wint_t tmp___75 ;
  size_t new_n_alloc___5 ;
  void *tmp___76 ;
  wint_t tmp___77 ;
  size_t new_n_alloc___6 ;
  void *tmp___78 ;
  size_t tmp___79 ;
  wint_t tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  size_t tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  wchar_t _wc___9 ;
  size_t tmp___86 ;
  char const   *tmp___87 ;
  unsigned char tmp___88 ;
  int tmp___89 ;
  size_t tmp___90 ;
  size_t new_n_alloc___7 ;
  void *tmp___91 ;
  size_t tmp___92 ;
  _Bool tmp___93 ;
  int tmp___94 ;
  size_t new_n_alloc___8 ;
  void *tmp___95 ;
  size_t tmp___96 ;
  _Bool tmp___97 ;
  char *tmp___98 ;
  size_t tmp___100 ;
  int tmp___101 ;
  size_t tmp___102 ;
  size_t tmp___103 ;
  void *__cil_tmp149 ;
  void *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;

  {
  {
#line 971
  wc1 = (wint_t )0;
#line 978
  chars_al = (size_t )0;
#line 979
  range_ends_al = (size_t )0;
#line 979
  range_sts_al = range_ends_al;
#line 980
  coll_elems_al = (size_t )0;
#line 980
  equivs_al = coll_elems_al;
#line 980
  ch_classes_al = equivs_al;
#line 981
  tmp___3 = __ctype_get_mb_cur_max();
  }
#line 981
  if (tmp___3 > 1UL) {
    {
#line 983
    while (1) {
      while_continue: /* CIL Label */ ;
#line 983
      if (dfa->mbcsets_alloc <= dfa->nmbcsets + 1UL) {
        {
#line 983
        new_n_alloc = (dfa->nmbcsets + 1UL) + (size_t )(! dfa->mbcsets);
#line 983
        tmp___1 = x2nrealloc((void *)dfa->mbcsets, & new_n_alloc, sizeof(*(dfa->mbcsets)));
#line 983
        dfa->mbcsets = (struct mb_char_classes *)tmp___1;
#line 983
        dfa->mbcsets_alloc = new_n_alloc;
        }
      }
#line 983
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 991
    tmp___2 = dfa->nmbcsets;
#line 991
    (dfa->nmbcsets) ++;
#line 991
    work_mbc = dfa->mbcsets + tmp___2;
#line 992
    memset((void *)work_mbc, 0, sizeof(*work_mbc));
    }
  } else {
#line 995
    work_mbc = (struct mb_char_classes *)((void *)0);
  }
  {
#line 997
  memset((void *)(ccl), 0, sizeof(ccl));
  }
  {
#line 998
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 998
    if (! lexleft) {
      {
#line 998
      tmp___5 = gettext("unbalanced [");
      }
#line 998
      if ((unsigned long )tmp___5 != (unsigned long )((char *)0)) {
        {
#line 998
        tmp___4 = gettext("unbalanced [");
#line 998
        dfaerror((char const   *)tmp___4);
        }
      } else {
#line 998
        lasttok = (token )-1;
#line 998
        return (lasttok);
      }
    } else {
      {
#line 998
      tmp___6 = mbrtowc((wchar_t */* __restrict  */)(& _wc), (char const   */* __restrict  */)lexptr,
                        lexleft, & mbs);
#line 998
      cur_mb_len = (int )tmp___6;
      }
#line 998
      if (cur_mb_len <= 0) {
        {
#line 998
        cur_mb_len = 1;
#line 998
        lexleft --;
#line 998
        tmp___7 = lexptr;
#line 998
        lexptr ++;
#line 998
        tmp___8 = to_uchar((char )*tmp___7);
#line 998
        c = (int )tmp___8;
#line 998
        wc = (wint_t )c;
        }
      } else {
        {
#line 998
        lexptr += cur_mb_len;
#line 998
        lexleft -= (size_t )cur_mb_len;
#line 998
        wc = (wint_t )_wc;
#line 998
        c = wctob(wc);
        }
      }
    }
#line 998
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 999
  if (c == 94) {
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1001
      if (! lexleft) {
        {
#line 1001
        tmp___10 = gettext("unbalanced [");
        }
#line 1001
        if ((unsigned long )tmp___10 != (unsigned long )((char *)0)) {
          {
#line 1001
          tmp___9 = gettext("unbalanced [");
#line 1001
          dfaerror((char const   *)tmp___9);
          }
        } else {
#line 1001
          lasttok = (token )-1;
#line 1001
          return (lasttok);
        }
      } else {
        {
#line 1001
        tmp___11 = mbrtowc((wchar_t */* __restrict  */)(& _wc___0), (char const   */* __restrict  */)lexptr,
                           lexleft, & mbs);
#line 1001
        cur_mb_len = (int )tmp___11;
        }
#line 1001
        if (cur_mb_len <= 0) {
          {
#line 1001
          cur_mb_len = 1;
#line 1001
          lexleft --;
#line 1001
          tmp___12 = lexptr;
#line 1001
          lexptr ++;
#line 1001
          tmp___13 = to_uchar((char )*tmp___12);
#line 1001
          c = (int )tmp___13;
#line 1001
          wc = (wint_t )c;
          }
        } else {
          {
#line 1001
          lexptr += cur_mb_len;
#line 1001
          lexleft -= (size_t )cur_mb_len;
#line 1001
          wc = (wint_t )_wc___0;
#line 1001
          c = wctob(wc);
          }
        }
      }
#line 1001
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1002
    invert = 1;
  } else {
#line 1005
    invert = 0;
  }
#line 1007
  colon_warning_state = c == 58;
  {
#line 1008
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1010
    c1 = -1;
#line 1011
    colon_warning_state &= -3;
#line 1017
    if (c == 91) {
#line 1017
      if (syntax_bits & ((1UL << 1) << 1)) {
        {
#line 1021
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1021
          if (! lexleft) {
            {
#line 1021
            tmp___15 = gettext("unbalanced [");
            }
#line 1021
            if ((unsigned long )tmp___15 != (unsigned long )((char *)0)) {
              {
#line 1021
              tmp___14 = gettext("unbalanced [");
#line 1021
              dfaerror((char const   *)tmp___14);
              }
            } else {
#line 1021
              lasttok = (token )-1;
#line 1021
              return (lasttok);
            }
          } else {
            {
#line 1021
            tmp___16 = mbrtowc((wchar_t */* __restrict  */)(& _wc___1), (char const   */* __restrict  */)lexptr,
                               lexleft, & mbs);
#line 1021
            cur_mb_len = (int )tmp___16;
            }
#line 1021
            if (cur_mb_len <= 0) {
              {
#line 1021
              cur_mb_len = 1;
#line 1021
              lexleft --;
#line 1021
              tmp___17 = lexptr;
#line 1021
              lexptr ++;
#line 1021
              tmp___18 = to_uchar((char )*tmp___17);
#line 1021
              c1 = (int )tmp___18;
#line 1021
              wc1 = (wint_t )c1;
              }
            } else {
              {
#line 1021
              lexptr += cur_mb_len;
#line 1021
              lexleft -= (size_t )cur_mb_len;
#line 1021
              wc1 = (wint_t )_wc___1;
#line 1021
              c1 = wctob(wc1);
              }
            }
          }
#line 1021
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1024
        if (c1 == 58) {
#line 1024
          goto _L___2;
        } else {
          {
#line 1024
          tmp___50 = __ctype_get_mb_cur_max();
          }
#line 1024
          if (tmp___50 > 1UL) {
#line 1024
            if (c1 == 46) {
#line 1024
              goto _L___2;
            } else
#line 1024
            if (c1 == 61) {
              _L___2: /* CIL Label */ 
#line 1028
              len = (size_t )0;
              {
#line 1029
              while (1) {
                while_continue___4: /* CIL Label */ ;
                {
#line 1031
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 1031
                  if (! lexleft) {
                    {
#line 1031
                    tmp___20 = gettext("unbalanced [");
                    }
#line 1031
                    if ((unsigned long )tmp___20 != (unsigned long )((char *)0)) {
                      {
#line 1031
                      tmp___19 = gettext("unbalanced [");
#line 1031
                      dfaerror((char const   *)tmp___19);
                      }
                    } else {
#line 1031
                      lasttok = (token )-1;
#line 1031
                      return (lasttok);
                    }
                  } else {
                    {
#line 1031
                    tmp___21 = mbrtowc((wchar_t */* __restrict  */)(& _wc___2), (char const   */* __restrict  */)lexptr,
                                       lexleft, & mbs);
#line 1031
                    cur_mb_len = (int )tmp___21;
                    }
#line 1031
                    if (cur_mb_len <= 0) {
                      {
#line 1031
                      cur_mb_len = 1;
#line 1031
                      lexleft --;
#line 1031
                      tmp___22 = lexptr;
#line 1031
                      lexptr ++;
#line 1031
                      tmp___23 = to_uchar((char )*tmp___22);
#line 1031
                      c = (int )tmp___23;
#line 1031
                      wc = (wint_t )c;
                      }
                    } else {
                      {
#line 1031
                      lexptr += cur_mb_len;
#line 1031
                      lexleft -= (size_t )cur_mb_len;
#line 1031
                      wc = (wint_t )_wc___2;
#line 1031
                      c = wctob(wc);
                      }
                    }
                  }
#line 1031
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 1032
                if (c == c1) {
#line 1032
                  if ((int const   )*lexptr == 93) {
#line 1033
                    goto while_break___4;
                  } else {
#line 1032
                    goto _L;
                  }
                } else
                _L: /* CIL Label */ 
#line 1032
                if (lexleft == 0UL) {
#line 1033
                  goto while_break___4;
                }
#line 1034
                if (len < 128UL) {
#line 1035
                  tmp___24 = len;
#line 1035
                  len ++;
#line 1035
                  str[tmp___24] = (char )c;
                } else {
#line 1038
                  str[0] = (char )'\000';
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1040
              str[len] = (char )'\000';
              {
#line 1043
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1043
                if (! lexleft) {
                  {
#line 1043
                  tmp___26 = gettext("unbalanced [");
                  }
#line 1043
                  if ((unsigned long )tmp___26 != (unsigned long )((char *)0)) {
                    {
#line 1043
                    tmp___25 = gettext("unbalanced [");
#line 1043
                    dfaerror((char const   *)tmp___25);
                    }
                  } else {
#line 1043
                    lasttok = (token )-1;
#line 1043
                    return (lasttok);
                  }
                } else {
                  {
#line 1043
                  tmp___27 = mbrtowc((wchar_t */* __restrict  */)(& _wc___3), (char const   */* __restrict  */)lexptr,
                                     lexleft, & mbs);
#line 1043
                  cur_mb_len = (int )tmp___27;
                  }
#line 1043
                  if (cur_mb_len <= 0) {
                    {
#line 1043
                    cur_mb_len = 1;
#line 1043
                    lexleft --;
#line 1043
                    tmp___28 = lexptr;
#line 1043
                    lexptr ++;
#line 1043
                    tmp___29 = to_uchar((char )*tmp___28);
#line 1043
                    c = (int )tmp___29;
#line 1043
                    wc = (wint_t )c;
                    }
                  } else {
                    {
#line 1043
                    lexptr += cur_mb_len;
#line 1043
                    lexleft -= (size_t )cur_mb_len;
#line 1043
                    wc = (wint_t )_wc___3;
#line 1043
                    c = wctob(wc);
                    }
                  }
                }
#line 1043
                goto while_break___6;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 1044
              if (c1 == 58) {
#line 1047
                if (case_fold) {
                  {
#line 1047
                  tmp___31 = strcmp((char const   *)(str), "upper");
                  }
#line 1047
                  if (tmp___31 == 0) {
#line 1047
                    tmp___30 = "alpha";
                  } else {
                    {
#line 1047
                    tmp___32 = strcmp((char const   *)(str), "lower");
                    }
#line 1047
                    if (tmp___32 == 0) {
#line 1047
                      tmp___30 = "alpha";
                    } else {
#line 1047
                      tmp___30 = (char const   *)(str);
                    }
                  }
                } else {
#line 1047
                  tmp___30 = (char const   *)(str);
                }
                {
#line 1047
                class = tmp___30;
#line 1050
                tmp___33 = find_pred(class);
#line 1050
                pred = (struct dfa_ctype  const  *)tmp___33;
                }
#line 1051
                if (! pred) {
                  {
#line 1052
                  tmp___34 = gettext("invalid character class");
#line 1052
                  dfaerror((char const   *)tmp___34);
                  }
                }
                {
#line 1054
                tmp___38 = __ctype_get_mb_cur_max();
                }
#line 1054
                if (tmp___38 > 1UL) {
#line 1054
                  if (! pred->single_byte_only) {
                    {
#line 1057
                    tmp___35 = wctype(class);
#line 1057
                    wt = tmp___35;
                    }
                    {
#line 1059
                    while (1) {
                      while_continue___7: /* CIL Label */ ;
#line 1059
                      if (ch_classes_al <= work_mbc->nch_classes + 1UL) {
                        {
#line 1059
                        new_n_alloc___0 = (work_mbc->nch_classes + 1UL) + (size_t )(! work_mbc->ch_classes);
#line 1059
                        tmp___36 = x2nrealloc((void *)work_mbc->ch_classes, & new_n_alloc___0,
                                              sizeof(*(work_mbc->ch_classes)));
#line 1059
                        work_mbc->ch_classes = (wctype_t *)tmp___36;
#line 1059
                        ch_classes_al = new_n_alloc___0;
                        }
                      }
#line 1059
                      goto while_break___7;
                    }
                    while_break___7: /* CIL Label */ ;
                    }
#line 1062
                    tmp___37 = work_mbc->nch_classes;
#line 1062
                    (work_mbc->nch_classes) ++;
#line 1062
                    *(work_mbc->ch_classes + tmp___37) = wt;
                  }
                }
#line 1065
                c2 = 0;
                {
#line 1065
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 1065
                  if (! (c2 < 1 << 8)) {
#line 1065
                    goto while_break___8;
                  }
                  {
#line 1066
                  tmp___39 = (*(pred->func))(c2);
                  }
#line 1066
                  if (tmp___39) {
                    {
#line 1067
                    setbit_case_fold_c(c2, ccl);
                    }
                  }
#line 1065
                  c2 ++;
                }
                while_break___8: /* CIL Label */ ;
                }
              } else
#line 1070
              if (c1 == 61) {
#line 1070
                goto _L___0;
              } else
#line 1070
              if (c1 == 46) {
                _L___0: /* CIL Label */ 
                {
#line 1072
                tmp___40 = xmemdup((void const   *)(str), len + 1UL);
#line 1072
                elem = (char *)tmp___40;
                }
#line 1074
                if (c1 == 61) {
                  {
#line 1077
                  while (1) {
                    while_continue___9: /* CIL Label */ ;
#line 1077
                    if (equivs_al <= work_mbc->nequivs + 1UL) {
                      {
#line 1077
                      new_n_alloc___1 = (work_mbc->nequivs + 1UL) + (size_t )(! work_mbc->equivs);
#line 1077
                      tmp___41 = x2nrealloc((void *)work_mbc->equivs, & new_n_alloc___1,
                                            sizeof(*(work_mbc->equivs)));
#line 1077
                      work_mbc->equivs = (char **)tmp___41;
#line 1077
                      equivs_al = new_n_alloc___1;
                      }
                    }
#line 1077
                    goto while_break___9;
                  }
                  while_break___9: /* CIL Label */ ;
                  }
#line 1079
                  tmp___42 = work_mbc->nequivs;
#line 1079
                  (work_mbc->nequivs) ++;
#line 1079
                  *(work_mbc->equivs + tmp___42) = elem;
                }
#line 1082
                if (c1 == 46) {
                  {
#line 1085
                  while (1) {
                    while_continue___10: /* CIL Label */ ;
#line 1085
                    if (coll_elems_al <= work_mbc->ncoll_elems + 1UL) {
                      {
#line 1085
                      new_n_alloc___2 = (work_mbc->ncoll_elems + 1UL) + (size_t )(! work_mbc->coll_elems);
#line 1085
                      tmp___43 = x2nrealloc((void *)work_mbc->coll_elems, & new_n_alloc___2,
                                            sizeof(*(work_mbc->coll_elems)));
#line 1085
                      work_mbc->coll_elems = (char **)tmp___43;
#line 1085
                      coll_elems_al = new_n_alloc___2;
                      }
                    }
#line 1085
                    goto while_break___10;
                  }
                  while_break___10: /* CIL Label */ ;
                  }
#line 1088
                  tmp___44 = work_mbc->ncoll_elems;
#line 1088
                  (work_mbc->ncoll_elems) ++;
#line 1088
                  *(work_mbc->coll_elems + tmp___44) = elem;
                }
              }
#line 1091
              colon_warning_state |= 8;
              {
#line 1094
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 1094
                if (! lexleft) {
                  {
#line 1094
                  tmp___46 = gettext("unbalanced [");
                  }
#line 1094
                  if ((unsigned long )tmp___46 != (unsigned long )((char *)0)) {
                    {
#line 1094
                    tmp___45 = gettext("unbalanced [");
#line 1094
                    dfaerror((char const   *)tmp___45);
                    }
                  } else {
#line 1094
                    lasttok = (token )-1;
#line 1094
                    return (lasttok);
                  }
                } else {
                  {
#line 1094
                  tmp___47 = mbrtowc((wchar_t */* __restrict  */)(& _wc___4), (char const   */* __restrict  */)lexptr,
                                     lexleft, & mbs);
#line 1094
                  cur_mb_len = (int )tmp___47;
                  }
#line 1094
                  if (cur_mb_len <= 0) {
                    {
#line 1094
                    cur_mb_len = 1;
#line 1094
                    lexleft --;
#line 1094
                    tmp___48 = lexptr;
#line 1094
                    lexptr ++;
#line 1094
                    tmp___49 = to_uchar((char )*tmp___48);
#line 1094
                    c1 = (int )tmp___49;
#line 1094
                    wc1 = (wint_t )c1;
                    }
                  } else {
                    {
#line 1094
                    lexptr += cur_mb_len;
#line 1094
                    lexleft -= (size_t )cur_mb_len;
#line 1094
                    wc1 = (wint_t )_wc___4;
#line 1094
                    c1 = wctob(wc1);
                    }
                  }
                }
#line 1094
                goto while_break___11;
              }
              while_break___11: /* CIL Label */ ;
              }
#line 1095
              goto __Cont;
            }
          }
        }
      }
    }
#line 1102
    if (c == 92) {
#line 1102
      if (syntax_bits & 1UL) {
        {
#line 1103
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1103
          if (! lexleft) {
            {
#line 1103
            tmp___52 = gettext("unbalanced [");
            }
#line 1103
            if ((unsigned long )tmp___52 != (unsigned long )((char *)0)) {
              {
#line 1103
              tmp___51 = gettext("unbalanced [");
#line 1103
              dfaerror((char const   *)tmp___51);
              }
            } else {
#line 1103
              lasttok = (token )-1;
#line 1103
              return (lasttok);
            }
          } else {
            {
#line 1103
            tmp___53 = mbrtowc((wchar_t */* __restrict  */)(& _wc___5), (char const   */* __restrict  */)lexptr,
                               lexleft, & mbs);
#line 1103
            cur_mb_len = (int )tmp___53;
            }
#line 1103
            if (cur_mb_len <= 0) {
              {
#line 1103
              cur_mb_len = 1;
#line 1103
              lexleft --;
#line 1103
              tmp___54 = lexptr;
#line 1103
              lexptr ++;
#line 1103
              tmp___55 = to_uchar((char )*tmp___54);
#line 1103
              c = (int )tmp___55;
#line 1103
              wc = (wint_t )c;
              }
            } else {
              {
#line 1103
              lexptr += cur_mb_len;
#line 1103
              lexleft -= (size_t )cur_mb_len;
#line 1103
              wc = (wint_t )_wc___5;
#line 1103
              c = wctob(wc);
              }
            }
          }
#line 1103
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
#line 1105
    if (c1 == -1) {
      {
#line 1106
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1106
        if (! lexleft) {
          {
#line 1106
          tmp___57 = gettext("unbalanced [");
          }
#line 1106
          if ((unsigned long )tmp___57 != (unsigned long )((char *)0)) {
            {
#line 1106
            tmp___56 = gettext("unbalanced [");
#line 1106
            dfaerror((char const   *)tmp___56);
            }
          } else {
#line 1106
            lasttok = (token )-1;
#line 1106
            return (lasttok);
          }
        } else {
          {
#line 1106
          tmp___58 = mbrtowc((wchar_t */* __restrict  */)(& _wc___6), (char const   */* __restrict  */)lexptr,
                             lexleft, & mbs);
#line 1106
          cur_mb_len = (int )tmp___58;
          }
#line 1106
          if (cur_mb_len <= 0) {
            {
#line 1106
            cur_mb_len = 1;
#line 1106
            lexleft --;
#line 1106
            tmp___59 = lexptr;
#line 1106
            lexptr ++;
#line 1106
            tmp___60 = to_uchar((char )*tmp___59);
#line 1106
            c1 = (int )tmp___60;
#line 1106
            wc1 = (wint_t )c1;
            }
          } else {
            {
#line 1106
            lexptr += cur_mb_len;
#line 1106
            lexleft -= (size_t )cur_mb_len;
#line 1106
            wc1 = (wint_t )_wc___6;
#line 1106
            c1 = wctob(wc1);
            }
          }
        }
#line 1106
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 1108
    if (c1 == 45) {
      {
#line 1111
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1111
        if (! lexleft) {
          {
#line 1111
          tmp___62 = gettext("unbalanced [");
          }
#line 1111
          if ((unsigned long )tmp___62 != (unsigned long )((char *)0)) {
            {
#line 1111
            tmp___61 = gettext("unbalanced [");
#line 1111
            dfaerror((char const   *)tmp___61);
            }
          } else {
#line 1111
            lasttok = (token )-1;
#line 1111
            return (lasttok);
          }
        } else {
          {
#line 1111
          tmp___63 = mbrtowc((wchar_t */* __restrict  */)(& _wc___7), (char const   */* __restrict  */)lexptr,
                             lexleft, & mbs);
#line 1111
          cur_mb_len = (int )tmp___63;
          }
#line 1111
          if (cur_mb_len <= 0) {
            {
#line 1111
            cur_mb_len = 1;
#line 1111
            lexleft --;
#line 1111
            tmp___64 = lexptr;
#line 1111
            lexptr ++;
#line 1111
            tmp___65 = to_uchar((char )*tmp___64);
#line 1111
            c2 = (int )tmp___65;
#line 1111
            wc2 = (wint_t )c2;
            }
          } else {
            {
#line 1111
            lexptr += cur_mb_len;
#line 1111
            lexleft -= (size_t )cur_mb_len;
#line 1111
            wc2 = (wint_t )_wc___7;
#line 1111
            c2 = wctob(wc2);
            }
          }
        }
#line 1111
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 1112
      if (c2 == 93) {
#line 1116
        lexptr -= cur_mb_len;
#line 1117
        lexleft += (size_t )cur_mb_len;
      }
    }
#line 1121
    if (c1 == 45) {
#line 1121
      if (c2 != 93) {
#line 1123
        if (c2 == 92) {
#line 1123
          if (syntax_bits & 1UL) {
            {
#line 1124
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 1124
              if (! lexleft) {
                {
#line 1124
                tmp___67 = gettext("unbalanced [");
                }
#line 1124
                if ((unsigned long )tmp___67 != (unsigned long )((char *)0)) {
                  {
#line 1124
                  tmp___66 = gettext("unbalanced [");
#line 1124
                  dfaerror((char const   *)tmp___66);
                  }
                } else {
#line 1124
                  lasttok = (token )-1;
#line 1124
                  return (lasttok);
                }
              } else {
                {
#line 1124
                tmp___68 = mbrtowc((wchar_t */* __restrict  */)(& _wc___8), (char const   */* __restrict  */)lexptr,
                                   lexleft, & mbs);
#line 1124
                cur_mb_len = (int )tmp___68;
                }
#line 1124
                if (cur_mb_len <= 0) {
                  {
#line 1124
                  cur_mb_len = 1;
#line 1124
                  lexleft --;
#line 1124
                  tmp___69 = lexptr;
#line 1124
                  lexptr ++;
#line 1124
                  tmp___70 = to_uchar((char )*tmp___69);
#line 1124
                  c2 = (int )tmp___70;
#line 1124
                  wc2 = (wint_t )c2;
                  }
                } else {
                  {
#line 1124
                  lexptr += cur_mb_len;
#line 1124
                  lexleft -= (size_t )cur_mb_len;
#line 1124
                  wc2 = (wint_t )_wc___8;
#line 1124
                  c2 = wctob(wc2);
                  }
                }
              }
#line 1124
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
          }
        }
        {
#line 1126
        tmp___83 = __ctype_get_mb_cur_max();
        }
#line 1126
        if (tmp___83 > 1UL) {
          {
#line 1130
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 1130
            if (range_sts_al <= work_mbc->nranges + 1UL) {
              {
#line 1130
              new_n_alloc___3 = (work_mbc->nranges + 1UL) + (size_t )(! work_mbc->range_sts);
#line 1130
              tmp___71 = x2nrealloc((void *)work_mbc->range_sts, & new_n_alloc___3,
                                    sizeof(*(work_mbc->range_sts)));
#line 1130
              work_mbc->range_sts = (wchar_t *)tmp___71;
#line 1130
              range_sts_al = new_n_alloc___3;
              }
            }
#line 1130
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
          {
#line 1132
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 1132
            if (range_ends_al <= work_mbc->nranges + 1UL) {
              {
#line 1132
              new_n_alloc___4 = (work_mbc->nranges + 1UL) + (size_t )(! work_mbc->range_ends);
#line 1132
              tmp___72 = x2nrealloc((void *)work_mbc->range_ends, & new_n_alloc___4,
                                    sizeof(*(work_mbc->range_ends)));
#line 1132
              work_mbc->range_ends = (wchar_t *)tmp___72;
#line 1132
              range_ends_al = new_n_alloc___4;
              }
            }
#line 1132
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 1134
          if (case_fold) {
            {
#line 1134
            tmp___73 = towlower(wc);
#line 1134
            *(work_mbc->range_sts + work_mbc->nranges) = (wchar_t )tmp___73;
            }
          } else {
#line 1134
            *(work_mbc->range_sts + work_mbc->nranges) = (wchar_t )wc;
          }
#line 1136
          tmp___74 = work_mbc->nranges;
#line 1136
          (work_mbc->nranges) ++;
#line 1136
          if (case_fold) {
            {
#line 1136
            tmp___75 = towlower(wc2);
#line 1136
            *(work_mbc->range_ends + tmp___74) = (wchar_t )tmp___75;
            }
          } else {
#line 1136
            *(work_mbc->range_ends + tmp___74) = (wchar_t )wc2;
          }
#line 1140
          if (case_fold) {
            {
#line 1140
            tmp___81 = iswalpha(wc);
            }
#line 1140
            if (tmp___81) {
#line 1140
              goto _L___3;
            } else {
              {
#line 1140
              tmp___82 = iswalpha(wc2);
              }
#line 1140
              if (tmp___82) {
                _L___3: /* CIL Label */ 
                {
#line 1142
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 1142
                  if (range_sts_al <= work_mbc->nranges + 1UL) {
                    {
#line 1142
                    new_n_alloc___5 = (work_mbc->nranges + 1UL) + (size_t )(! work_mbc->range_sts);
#line 1142
                    tmp___76 = x2nrealloc((void *)work_mbc->range_sts, & new_n_alloc___5,
                                          sizeof(*(work_mbc->range_sts)));
#line 1142
                    work_mbc->range_sts = (wchar_t *)tmp___76;
#line 1142
                    range_sts_al = new_n_alloc___5;
                    }
                  }
#line 1142
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
                {
#line 1144
                tmp___77 = towupper(wc);
#line 1144
                *(work_mbc->range_sts + work_mbc->nranges) = (wchar_t )tmp___77;
                }
                {
#line 1145
                while (1) {
                  while_continue___19: /* CIL Label */ ;
#line 1145
                  if (range_ends_al <= work_mbc->nranges + 1UL) {
                    {
#line 1145
                    new_n_alloc___6 = (work_mbc->nranges + 1UL) + (size_t )(! work_mbc->range_ends);
#line 1145
                    tmp___78 = x2nrealloc((void *)work_mbc->range_ends, & new_n_alloc___6,
                                          sizeof(*(work_mbc->range_ends)));
#line 1145
                    work_mbc->range_ends = (wchar_t *)tmp___78;
#line 1145
                    range_ends_al = new_n_alloc___6;
                    }
                  }
#line 1145
                  goto while_break___19;
                }
                while_break___19: /* CIL Label */ ;
                }
                {
#line 1147
                tmp___79 = work_mbc->nranges;
#line 1147
                (work_mbc->nranges) ++;
#line 1147
                tmp___80 = towupper(wc2);
#line 1147
                *(work_mbc->range_ends + tmp___79) = (wchar_t )tmp___80;
                }
              }
            }
          }
        } else {
#line 1180
          c1 = c;
#line 1181
          if (case_fold) {
            {
#line 1183
            c1 = tolower(c1);
#line 1184
            c2 = tolower(c2);
            }
          }
#line 1186
          c = c1;
          {
#line 1186
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 1186
            if (! (c <= c2)) {
#line 1186
              goto while_break___20;
            }
            {
#line 1187
            setbit_case_fold_c(c, ccl);
#line 1186
            c ++;
            }
          }
          while_break___20: /* CIL Label */ ;
          }
        }
#line 1191
        colon_warning_state |= 8;
        {
#line 1192
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 1192
          if (! lexleft) {
            {
#line 1192
            tmp___85 = gettext("unbalanced [");
            }
#line 1192
            if ((unsigned long )tmp___85 != (unsigned long )((char *)0)) {
              {
#line 1192
              tmp___84 = gettext("unbalanced [");
#line 1192
              dfaerror((char const   *)tmp___84);
              }
            } else {
#line 1192
              lasttok = (token )-1;
#line 1192
              return (lasttok);
            }
          } else {
            {
#line 1192
            tmp___86 = mbrtowc((wchar_t */* __restrict  */)(& _wc___9), (char const   */* __restrict  */)lexptr,
                               lexleft, & mbs);
#line 1192
            cur_mb_len = (int )tmp___86;
            }
#line 1192
            if (cur_mb_len <= 0) {
              {
#line 1192
              cur_mb_len = 1;
#line 1192
              lexleft --;
#line 1192
              tmp___87 = lexptr;
#line 1192
              lexptr ++;
#line 1192
              tmp___88 = to_uchar((char )*tmp___87);
#line 1192
              c1 = (int )tmp___88;
#line 1192
              wc1 = (wint_t )c1;
              }
            } else {
              {
#line 1192
              lexptr += cur_mb_len;
#line 1192
              lexleft -= (size_t )cur_mb_len;
#line 1192
              wc1 = (wint_t )_wc___9;
#line 1192
              c1 = wctob(wc1);
              }
            }
          }
#line 1192
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 1193
        goto __Cont;
      }
    }
#line 1196
    if (c == 58) {
#line 1196
      tmp___89 = 2;
    } else {
#line 1196
      tmp___89 = 4;
    }
    {
#line 1196
    colon_warning_state |= tmp___89;
#line 1198
    tmp___90 = __ctype_get_mb_cur_max();
    }
#line 1198
    if (tmp___90 == 1UL) {
      {
#line 1200
      setbit_case_fold_c(c, ccl);
      }
#line 1201
      goto __Cont;
    }
#line 1204
    if (case_fold) {
      {
#line 1204
      tmp___94 = iswalpha(wc);
      }
#line 1204
      if (tmp___94) {
        {
#line 1206
        wc = towlower(wc);
#line 1207
        tmp___93 = setbit_wc(wc, ccl);
        }
#line 1207
        if (! tmp___93) {
          {
#line 1209
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 1209
            if (chars_al <= work_mbc->nchars + 1UL) {
              {
#line 1209
              new_n_alloc___7 = (work_mbc->nchars + 1UL) + (size_t )(! work_mbc->chars);
#line 1209
              tmp___91 = x2nrealloc((void *)work_mbc->chars, & new_n_alloc___7, sizeof(*(work_mbc->chars)));
#line 1209
              work_mbc->chars = (wchar_t *)tmp___91;
#line 1209
              chars_al = new_n_alloc___7;
              }
            }
#line 1209
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 1211
          tmp___92 = work_mbc->nchars;
#line 1211
          (work_mbc->nchars) ++;
#line 1211
          *(work_mbc->chars + tmp___92) = (wchar_t )wc;
        }
        {
#line 1216
        wc = towupper(wc);
        }
      }
    }
    {
#line 1219
    tmp___97 = setbit_wc(wc, ccl);
    }
#line 1219
    if (! tmp___97) {
      {
#line 1221
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 1221
        if (chars_al <= work_mbc->nchars + 1UL) {
          {
#line 1221
          new_n_alloc___8 = (work_mbc->nchars + 1UL) + (size_t )(! work_mbc->chars);
#line 1221
          tmp___95 = x2nrealloc((void *)work_mbc->chars, & new_n_alloc___8, sizeof(*(work_mbc->chars)));
#line 1221
          work_mbc->chars = (wchar_t *)tmp___95;
#line 1221
          chars_al = new_n_alloc___8;
          }
        }
#line 1221
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 1223
      tmp___96 = work_mbc->nchars;
#line 1223
      (work_mbc->nchars) ++;
#line 1223
      *(work_mbc->chars + tmp___96) = (wchar_t )wc;
    }
    __Cont: /* CIL Label */ 
#line 1008
    wc = wc1;
#line 1008
    c = c1;
#line 1008
    if (! (c != 93)) {
#line 1008
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1228
  if (colon_warning_state == 7) {
    {
#line 1229
    tmp___98 = gettext("character class syntax is [[:space:]], not [:space:]");
#line 1229
    dfawarn((char const   *)tmp___98);
    }
  }
  {
#line 1231
  tmp___102 = __ctype_get_mb_cur_max();
  }
#line 1231
  if (tmp___102 > 1UL) {
    {
#line 1234
    work_mbc->invert = invert;
#line 1235
    tmp___101 = equal((int */* const  */)(ccl), (int */* const  */)(zeroclass));
    }
#line 1235
    if (tmp___101) {
#line 1235
      work_mbc->cset = (ptrdiff_t )-1;
    } else {
      {
#line 1235
      tmp___100 = charclass_index((int */* const  */)(ccl));
#line 1235
      work_mbc->cset = (ptrdiff_t )tmp___100;
      }
    }
#line 1236
    return ((token )273);
  }
#line 1239
  if (invert) {
    {
#line 1242
    notset(ccl);
    }
#line 1243
    if (syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1244
      clrbit((unsigned int )eolbyte, ccl);
      }
    }
  }
  {
#line 1247
  tmp___103 = charclass_index((int */* const  */)(ccl));
  }
#line 1247
  return ((token )(275UL + tmp___103));
}
}
#line 1250 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static token lex(void) 
{ 
  unsigned int c ;
  unsigned int c2 ;
  int backslash ;
  charclass ccl ;
  int i___0 ;
  wchar_t _wc ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  unsigned char tmp___3 ;
  int tmp___4 ;
  wint_t wc ;
  wchar_t _wc___0 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *p ;
  char const   *lim ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  unsigned short const   **tmp___23 ;
  size_t tmp___24 ;
  unsigned short const   **tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  unsigned short const   **tmp___29 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 1254
  backslash = 0;
#line 1264
  i___0 = 0;
  {
#line 1264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1264
    if (! (i___0 < 2)) {
#line 1264
      goto while_break;
    }
    {
#line 1266
    tmp___9 = __ctype_get_mb_cur_max();
    }
#line 1266
    if (tmp___9 > 1UL) {
      {
#line 1268
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1268
        if (! lexleft) {
#line 1268
          lasttok = (token )-1;
#line 1268
          return (lasttok);
        } else {
          {
#line 1268
          tmp___1 = mbrtowc((wchar_t */* __restrict  */)(& _wc), (char const   */* __restrict  */)lexptr,
                            lexleft, & mbs);
#line 1268
          cur_mb_len = (int )tmp___1;
          }
#line 1268
          if (cur_mb_len <= 0) {
            {
#line 1268
            cur_mb_len = 1;
#line 1268
            lexleft --;
#line 1268
            tmp___2 = lexptr;
#line 1268
            lexptr ++;
#line 1268
            tmp___3 = to_uchar((char )*tmp___2);
#line 1268
            c = (unsigned int )tmp___3;
#line 1268
            wctok = (wchar_t )c;
            }
          } else {
            {
#line 1268
            lexptr += cur_mb_len;
#line 1268
            lexleft -= (size_t )cur_mb_len;
#line 1268
            wctok = _wc;
#line 1268
            tmp___4 = wctob((wint_t )wctok);
#line 1268
            c = (unsigned int )tmp___4;
            }
          }
        }
#line 1268
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1269
      if ((int )c == -1) {
#line 1270
        goto normal_char;
      }
    } else {
      {
#line 1273
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1273
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1273
          if (! lexleft) {
#line 1273
            lasttok = (token )-1;
#line 1273
            return (lasttok);
          } else {
            {
#line 1273
            tmp___5 = mbrtowc((wchar_t */* __restrict  */)(& _wc___0), (char const   */* __restrict  */)lexptr,
                              lexleft, & mbs);
#line 1273
            cur_mb_len = (int )tmp___5;
            }
#line 1273
            if (cur_mb_len <= 0) {
              {
#line 1273
              cur_mb_len = 1;
#line 1273
              lexleft --;
#line 1273
              tmp___6 = lexptr;
#line 1273
              lexptr ++;
#line 1273
              tmp___7 = to_uchar((char )*tmp___6);
#line 1273
              c = (unsigned int )tmp___7;
#line 1273
              wc = c;
              }
            } else {
              {
#line 1273
              lexptr += cur_mb_len;
#line 1273
              lexleft -= (size_t )cur_mb_len;
#line 1273
              wc = (wint_t )_wc___0;
#line 1273
              tmp___8 = wctob(wc);
#line 1273
              c = (unsigned int )tmp___8;
              }
            }
          }
#line 1273
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1273
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1277
    if (c == 92U) {
#line 1277
      goto case_92;
    }
#line 1285
    if (c == 94U) {
#line 1285
      goto case_94;
    }
#line 1293
    if (c == 36U) {
#line 1293
      goto case_36;
    }
#line 1317
    if (c == 57U) {
#line 1317
      goto case_57;
    }
#line 1317
    if (c == 56U) {
#line 1317
      goto case_57;
    }
#line 1317
    if (c == 55U) {
#line 1317
      goto case_57;
    }
#line 1317
    if (c == 54U) {
#line 1317
      goto case_57;
    }
#line 1317
    if (c == 53U) {
#line 1317
      goto case_57;
    }
#line 1317
    if (c == 52U) {
#line 1317
      goto case_57;
    }
#line 1317
    if (c == 51U) {
#line 1317
      goto case_57;
    }
#line 1317
    if (c == 50U) {
#line 1317
      goto case_57;
    }
#line 1317
    if (c == 49U) {
#line 1317
      goto case_57;
    }
#line 1325
    if (c == 96U) {
#line 1325
      goto case_96;
    }
#line 1330
    if (c == 39U) {
#line 1330
      goto case_39;
    }
#line 1335
    if (c == 60U) {
#line 1335
      goto case_60;
    }
#line 1340
    if (c == 62U) {
#line 1340
      goto case_62;
    }
#line 1345
    if (c == 98U) {
#line 1345
      goto case_98;
    }
#line 1350
    if (c == 66U) {
#line 1350
      goto case_66;
    }
#line 1355
    if (c == 63U) {
#line 1355
      goto case_63;
    }
#line 1364
    if (c == 42U) {
#line 1364
      goto case_42;
    }
#line 1371
    if (c == 43U) {
#line 1371
      goto case_43;
    }
#line 1380
    if (c == 123U) {
#line 1380
      goto case_123;
    }
#line 1438
    if (c == 124U) {
#line 1438
      goto case_124;
    }
#line 1446
    if (c == 10U) {
#line 1446
      goto case_10;
    }
#line 1453
    if (c == 40U) {
#line 1453
      goto case_40;
    }
#line 1460
    if (c == 41U) {
#line 1460
      goto case_41;
    }
#line 1469
    if (c == 46U) {
#line 1469
      goto case_46;
    }
#line 1489
    if (c == 83U) {
#line 1489
      goto case_83;
    }
#line 1489
    if (c == 115U) {
#line 1489
      goto case_83;
    }
#line 1502
    if (c == 87U) {
#line 1502
      goto case_87;
    }
#line 1502
    if (c == 119U) {
#line 1502
      goto case_87;
    }
#line 1514
    if (c == 91U) {
#line 1514
      goto case_91;
    }
#line 1520
    goto normal_char;
    case_92: /* CIL Label */ 
#line 1278
    if (backslash) {
#line 1279
      goto normal_char;
    }
#line 1280
    if (lexleft == 0UL) {
      {
#line 1281
      tmp___10 = gettext("unfinished \\ escape");
#line 1281
      dfaerror((char const   *)tmp___10);
      }
    }
#line 1282
    backslash = 1;
#line 1283
    goto switch_break;
    case_94: /* CIL Label */ 
#line 1286
    if (backslash) {
#line 1287
      goto normal_char;
    }
#line 1288
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1290
      lasttok = (token )258;
#line 1290
      return (lasttok);
    } else
#line 1288
    if (lasttok == -1L) {
#line 1290
      lasttok = (token )258;
#line 1290
      return (lasttok);
    } else
#line 1288
    if (lasttok == 270L) {
#line 1290
      lasttok = (token )258;
#line 1290
      return (lasttok);
    } else
#line 1288
    if (lasttok == 269L) {
#line 1290
      lasttok = (token )258;
#line 1290
      return (lasttok);
    }
#line 1291
    goto normal_char;
    case_36: /* CIL Label */ 
#line 1294
    if (backslash) {
#line 1295
      goto normal_char;
    }
#line 1296
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1306
      lasttok = (token )259;
#line 1306
      return (lasttok);
    } else
#line 1296
    if (lexleft == 0UL) {
#line 1306
      lasttok = (token )259;
#line 1306
      return (lasttok);
    } else {
#line 1296
      if (syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1296
        if (lexleft > 0UL) {
#line 1296
          if ((int const   )*lexptr == 41) {
#line 1296
            tmp___11 = 1;
          } else {
#line 1296
            tmp___11 = 0;
          }
        } else {
#line 1296
          tmp___11 = 0;
        }
#line 1296
        tmp___13 = tmp___11;
      } else {
#line 1296
        if (lexleft > 1UL) {
#line 1296
          if ((int const   )*(lexptr + 0) == 92) {
#line 1296
            if ((int const   )*(lexptr + 1) == 41) {
#line 1296
              tmp___12 = 1;
            } else {
#line 1296
              tmp___12 = 0;
            }
          } else {
#line 1296
            tmp___12 = 0;
          }
        } else {
#line 1296
          tmp___12 = 0;
        }
#line 1296
        tmp___13 = tmp___12;
      }
#line 1296
      if (tmp___13) {
#line 1306
        lasttok = (token )259;
#line 1306
        return (lasttok);
      } else {
#line 1296
        if (syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1296
          if (lexleft > 0UL) {
#line 1296
            if ((int const   )*lexptr == 124) {
#line 1296
              tmp___14 = 1;
            } else {
#line 1296
              tmp___14 = 0;
            }
          } else {
#line 1296
            tmp___14 = 0;
          }
#line 1296
          tmp___16 = tmp___14;
        } else {
#line 1296
          if (lexleft > 1UL) {
#line 1296
            if ((int const   )*(lexptr + 0) == 92) {
#line 1296
              if ((int const   )*(lexptr + 1) == 124) {
#line 1296
                tmp___15 = 1;
              } else {
#line 1296
                tmp___15 = 0;
              }
            } else {
#line 1296
              tmp___15 = 0;
            }
          } else {
#line 1296
            tmp___15 = 0;
          }
#line 1296
          tmp___16 = tmp___15;
        }
#line 1296
        if (tmp___16) {
#line 1306
          lasttok = (token )259;
#line 1306
          return (lasttok);
        } else
#line 1296
        if (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1296
          if (lexleft > 0UL) {
#line 1296
            if ((int const   )*lexptr == 10) {
#line 1306
              lasttok = (token )259;
#line 1306
              return (lasttok);
            }
          }
        }
      }
    }
#line 1307
    goto normal_char;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1318
    if (backslash) {
#line 1318
      if (! (syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1320
        laststart = 0;
#line 1321
        lasttok = (token )257;
#line 1321
        return (lasttok);
      }
    }
#line 1323
    goto normal_char;
    case_96: /* CIL Label */ 
#line 1326
    if (backslash) {
#line 1326
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1327
        lasttok = (token )258;
#line 1327
        return (lasttok);
      }
    }
#line 1328
    goto normal_char;
    case_39: /* CIL Label */ 
#line 1331
    if (backslash) {
#line 1331
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1332
        lasttok = (token )259;
#line 1332
        return (lasttok);
      }
    }
#line 1333
    goto normal_char;
    case_60: /* CIL Label */ 
#line 1336
    if (backslash) {
#line 1336
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1337
        lasttok = (token )260;
#line 1337
        return (lasttok);
      }
    }
#line 1338
    goto normal_char;
    case_62: /* CIL Label */ 
#line 1341
    if (backslash) {
#line 1341
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1342
        lasttok = (token )261;
#line 1342
        return (lasttok);
      }
    }
#line 1343
    goto normal_char;
    case_98: /* CIL Label */ 
#line 1346
    if (backslash) {
#line 1346
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1347
        lasttok = (token )262;
#line 1347
        return (lasttok);
      }
    }
#line 1348
    goto normal_char;
    case_66: /* CIL Label */ 
#line 1351
    if (backslash) {
#line 1351
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1352
        lasttok = (token )263;
#line 1352
        return (lasttok);
      }
    }
#line 1353
    goto normal_char;
    case_63: /* CIL Label */ 
#line 1356
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1357
      goto normal_char;
    }
#line 1358
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
#line 1359
      goto normal_char;
    }
#line 1360
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1360
      if (laststart) {
#line 1361
        goto normal_char;
      }
    }
#line 1362
    lasttok = (token )264;
#line 1362
    return (lasttok);
    case_42: /* CIL Label */ 
#line 1365
    if (backslash) {
#line 1366
      goto normal_char;
    }
#line 1367
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1367
      if (laststart) {
#line 1368
        goto normal_char;
      }
    }
#line 1369
    lasttok = (token )265;
#line 1369
    return (lasttok);
    case_43: /* CIL Label */ 
#line 1372
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1373
      goto normal_char;
    }
#line 1374
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
#line 1375
      goto normal_char;
    }
#line 1376
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1376
      if (laststart) {
#line 1377
        goto normal_char;
      }
    }
#line 1378
    lasttok = (token )266;
#line 1378
    return (lasttok);
    case_123: /* CIL Label */ 
#line 1381
    if (! (syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1382
      goto normal_char;
    }
#line 1383
    if (backslash != ((syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1384
      goto normal_char;
    }
#line 1385
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1385
      if (laststart) {
#line 1386
        goto normal_char;
      }
    }
#line 1395
    p = lexptr;
#line 1396
    lim = p + lexleft;
#line 1397
    maxrep = -1;
#line 1397
    minrep = maxrep;
    {
#line 1398
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1398
      if ((unsigned long )p != (unsigned long )lim) {
#line 1398
        if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1398
          goto while_break___3;
        }
      } else {
#line 1398
        goto while_break___3;
      }
#line 1400
      if (minrep < 0) {
#line 1401
        minrep = (int )((int const   )*p - 48);
      } else
#line 1403
      if (32768 < (minrep * 10 + (int )*p) - 48) {
#line 1403
        minrep = 32768;
      } else {
#line 1403
        minrep = (minrep * 10 + (int )*p) - 48;
      }
#line 1398
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1405
    if ((unsigned long )p != (unsigned long )lim) {
#line 1407
      if ((int const   )*p != 44) {
#line 1408
        maxrep = minrep;
      } else {
#line 1411
        if (minrep < 0) {
#line 1412
          minrep = 0;
        }
        {
#line 1413
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1413
          p ++;
#line 1413
          if ((unsigned long )p != (unsigned long )lim) {
#line 1413
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1413
              goto while_break___4;
            }
          } else {
#line 1413
            goto while_break___4;
          }
#line 1415
          if (maxrep < 0) {
#line 1416
            maxrep = (int )((int const   )*p - 48);
          } else
#line 1418
          if (32768 < (maxrep * 10 + (int )*p) - 48) {
#line 1418
            maxrep = 32768;
          } else {
#line 1418
            maxrep = (maxrep * 10 + (int )*p) - 48;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 1422
    if (! backslash) {
#line 1422
      goto _L___3;
    } else
#line 1422
    if ((unsigned long )p != (unsigned long )lim) {
#line 1422
      tmp___18 = p;
#line 1422
      p ++;
#line 1422
      if ((int const   )*tmp___18 == 92) {
        _L___3: /* CIL Label */ 
#line 1422
        if ((unsigned long )p != (unsigned long )lim) {
#line 1422
          tmp___19 = p;
#line 1422
          p ++;
#line 1422
          if ((int const   )*tmp___19 == 125) {
#line 1422
            if (0 <= minrep) {
#line 1422
              if (! (maxrep < 0)) {
#line 1422
                if (! (minrep <= maxrep)) {
#line 1422
                  goto _L___4;
                }
              }
            } else {
#line 1422
              goto _L___4;
            }
          } else {
#line 1422
            goto _L___4;
          }
        } else {
#line 1422
          goto _L___4;
        }
      } else {
#line 1422
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 1426
      if (syntax_bits & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1427
        goto normal_char;
      }
      {
#line 1428
      tmp___17 = gettext("Invalid content of \\{\\}");
#line 1428
      dfaerror((char const   *)tmp___17);
      }
    }
#line 1430
    if (32767 < maxrep) {
      {
#line 1431
      tmp___20 = gettext("Regular expression too big");
#line 1431
      dfaerror((char const   *)tmp___20);
      }
    }
#line 1432
    lexptr = p;
#line 1433
    lexleft = (size_t )(lim - p);
#line 1435
    laststart = 0;
#line 1436
    lasttok = (token )267;
#line 1436
    return (lasttok);
    case_124: /* CIL Label */ 
#line 1439
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1440
      goto normal_char;
    }
#line 1441
    if (backslash != ((syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1442
      goto normal_char;
    }
#line 1443
    laststart = 1;
#line 1444
    lasttok = (token )269;
#line 1444
    return (lasttok);
    case_10: /* CIL Label */ 
#line 1447
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1449
      goto normal_char;
    } else
#line 1447
    if (backslash) {
#line 1449
      goto normal_char;
    } else
#line 1447
    if (! (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1449
      goto normal_char;
    }
#line 1450
    laststart = 1;
#line 1451
    lasttok = (token )269;
#line 1451
    return (lasttok);
    case_40: /* CIL Label */ 
#line 1454
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1455
      goto normal_char;
    }
#line 1456
    parens ++;
#line 1457
    laststart = 1;
#line 1458
    lasttok = (token )270;
#line 1458
    return (lasttok);
    case_41: /* CIL Label */ 
#line 1461
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1462
      goto normal_char;
    }
#line 1463
    if (parens == 0UL) {
#line 1463
      if (syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1464
        goto normal_char;
      }
    }
#line 1465
    parens --;
#line 1466
    laststart = 0;
#line 1467
    lasttok = (token )271;
#line 1467
    return (lasttok);
    case_46: /* CIL Label */ 
#line 1470
    if (backslash) {
#line 1471
      goto normal_char;
    }
    {
#line 1472
    tmp___21 = __ctype_get_mb_cur_max();
    }
#line 1472
    if (tmp___21 > 1UL) {
#line 1476
      laststart = 0;
#line 1477
      lasttok = (token )272;
#line 1477
      return (lasttok);
    }
    {
#line 1479
    zeroset(ccl);
#line 1480
    notset(ccl);
    }
#line 1481
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
      {
#line 1482
      clrbit((unsigned int )eolbyte, ccl);
      }
    }
#line 1483
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1484
      clrbit((unsigned int )'\000', ccl);
      }
    }
    {
#line 1485
    laststart = 0;
#line 1486
    tmp___22 = charclass_index((int */* const  */)(ccl));
#line 1486
    lasttok = (token )(275UL + tmp___22);
    }
#line 1486
    return (lasttok);
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1490
    if (! backslash) {
#line 1491
      goto normal_char;
    } else
#line 1490
    if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1491
      goto normal_char;
    }
    {
#line 1492
    zeroset(ccl);
#line 1493
    c2 = 0U;
    }
    {
#line 1493
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1493
      if (! (c2 < (unsigned int )(1 << 8))) {
#line 1493
        goto while_break___5;
      }
      {
#line 1494
      tmp___23 = __ctype_b_loc();
      }
#line 1494
      if ((int const   )*(*tmp___23 + (int )c2) & 8192) {
        {
#line 1495
        setbit(c2, ccl);
        }
      }
#line 1493
      c2 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1496
    if (c == 83U) {
      {
#line 1497
      notset(ccl);
      }
    }
    {
#line 1498
    laststart = 0;
#line 1499
    tmp___24 = charclass_index((int */* const  */)(ccl));
#line 1499
    lasttok = (token )(275UL + tmp___24);
    }
#line 1499
    return (lasttok);
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 1503
    if (! backslash) {
#line 1504
      goto normal_char;
    } else
#line 1503
    if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1504
      goto normal_char;
    }
    {
#line 1505
    zeroset(ccl);
#line 1506
    c2 = 0U;
    }
    {
#line 1506
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1506
      if (! (c2 < (unsigned int )(1 << 8))) {
#line 1506
        goto while_break___6;
      }
      {
#line 1507
      tmp___25 = __ctype_b_loc();
      }
#line 1507
      if ((int const   )*(*tmp___25 + (int )c2) & 8) {
        {
#line 1508
        setbit(c2, ccl);
        }
      } else
#line 1507
      if (c2 == 95U) {
        {
#line 1508
        setbit(c2, ccl);
        }
      }
#line 1506
      c2 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1509
    if (c == 87U) {
      {
#line 1510
      notset(ccl);
      }
    }
    {
#line 1511
    laststart = 0;
#line 1512
    tmp___26 = charclass_index((int */* const  */)(ccl));
#line 1512
    lasttok = (token )(275UL + tmp___26);
    }
#line 1512
    return (lasttok);
    case_91: /* CIL Label */ 
#line 1515
    if (backslash) {
#line 1516
      goto normal_char;
    }
    {
#line 1517
    laststart = 0;
#line 1518
    lasttok = parse_bracket_exp___0();
    }
#line 1518
    return (lasttok);
    normal_char: 
    switch_default: /* CIL Label */ 
    {
#line 1522
    laststart = 0;
#line 1525
    tmp___27 = __ctype_get_mb_cur_max();
    }
#line 1525
    if (tmp___27 > 1UL) {
#line 1526
      lasttok = (token )274;
#line 1526
      return (lasttok);
    }
#line 1528
    if (case_fold) {
      {
#line 1528
      tmp___29 = __ctype_b_loc();
      }
#line 1528
      if ((int const   )*(*tmp___29 + (int )c) & 1024) {
        {
#line 1530
        zeroset(ccl);
#line 1531
        setbit_case_fold_c((int )c, ccl);
#line 1532
        tmp___28 = charclass_index((int */* const  */)(ccl));
#line 1532
        lasttok = (token )(275UL + tmp___28);
        }
#line 1532
        return (lasttok);
      }
    }
#line 1535
    lasttok = (token )c;
#line 1535
    return (lasttok);
    switch_break: /* CIL Label */ ;
    }
#line 1264
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1541
  abort();
  }
#line 1542
  return ((token )-1);
}
}
#line 1547 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static token tok  ;
#line 1548 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static size_t depth  ;
#line 1554 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void addtok_mb(token t , int mbprop ) 
{ 
  size_t new_n_alloc ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t new_n_alloc___0 ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 1557
  tmp___2 = __ctype_get_mb_cur_max();
  }
#line 1557
  if (tmp___2 > 1UL) {
    {
#line 1559
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1559
      if (dfa->nmultibyte_prop <= dfa->tindex + 1UL) {
        {
#line 1559
        new_n_alloc = (dfa->tindex + 1UL) + (size_t )(! dfa->multibyte_prop);
#line 1559
        tmp___1 = x2nrealloc((void *)dfa->multibyte_prop, & new_n_alloc, sizeof(*(dfa->multibyte_prop)));
#line 1559
        dfa->multibyte_prop = (int *)tmp___1;
#line 1559
        dfa->nmultibyte_prop = new_n_alloc;
        }
      }
#line 1559
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1561
    *(dfa->multibyte_prop + dfa->tindex) = mbprop;
  }
  {
#line 1564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1564
    if (dfa->talloc <= dfa->tindex + 1UL) {
      {
#line 1564
      new_n_alloc___0 = (dfa->tindex + 1UL) + (size_t )(! dfa->tokens);
#line 1564
      tmp___3 = x2nrealloc((void *)dfa->tokens, & new_n_alloc___0, sizeof(*(dfa->tokens)));
#line 1564
      dfa->tokens = (token *)tmp___3;
#line 1564
      dfa->talloc = new_n_alloc___0;
      }
    }
#line 1564
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1565
  tmp___4 = dfa->tindex;
#line 1565
  (dfa->tindex) ++;
#line 1565
  *(dfa->tokens + tmp___4) = t;
  {
#line 1571
  if (t == 266L) {
#line 1571
    goto case_266;
  }
#line 1571
  if (t == 265L) {
#line 1571
    goto case_266;
  }
#line 1571
  if (t == 264L) {
#line 1571
    goto case_266;
  }
#line 1575
  if (t == 269L) {
#line 1575
    goto case_269;
  }
#line 1575
  if (t == 268L) {
#line 1575
    goto case_269;
  }
#line 1581
  if (t == 256L) {
#line 1581
    goto case_256;
  }
#line 1579
  goto switch_default;
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 1572
  goto switch_break;
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 1576
  depth --;
#line 1577
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1580
  (dfa->nleaves) ++;
  case_256: /* CIL Label */ 
#line 1582
  depth ++;
#line 1583
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1585
  if (depth > dfa->depth) {
#line 1586
    dfa->depth = depth;
  }
#line 1587
  return;
}
}
#line 1589
static void addtok_wc(wint_t wc ) ;
#line 1593 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void addtok(token t ) 
{ 
  _Bool need_or ;
  struct mb_char_classes *work_mbc ;
  size_t i___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1596
  tmp___2 = __ctype_get_mb_cur_max();
  }
#line 1596
  if (tmp___2 > 1UL) {
#line 1596
    if (t == 273L) {
#line 1598
      need_or = (_Bool)0;
#line 1599
      work_mbc = dfa->mbcsets + (dfa->nmbcsets - 1UL);
#line 1603
      if (! work_mbc->invert) {
#line 1606
        i___0 = (size_t )0;
        {
#line 1606
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1606
          if (! (i___0 < work_mbc->nchars)) {
#line 1606
            goto while_break;
          }
          {
#line 1608
          addtok_wc((wint_t )*(work_mbc->chars + i___0));
          }
#line 1609
          if (need_or) {
            {
#line 1610
            addtok((token )269);
            }
          }
#line 1611
          need_or = (_Bool)1;
#line 1606
          i___0 ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 1613
        work_mbc->nchars = (size_t )0;
      }
#line 1617
      if (work_mbc->invert) {
#line 1617
        goto _L;
      } else {
        {
#line 1617
        tmp___1 = using_utf8();
        }
#line 1617
        if (tmp___1) {
          _L___0: /* CIL Label */ 
#line 1617
          if (work_mbc->nchars != 0UL) {
#line 1617
            goto _L;
          } else
#line 1617
          if (work_mbc->nch_classes != 0UL) {
#line 1617
            goto _L;
          } else
#line 1617
          if (work_mbc->nranges != 0UL) {
#line 1617
            goto _L;
          } else
#line 1617
          if (work_mbc->nequivs != 0UL) {
#line 1617
            goto _L;
          } else
#line 1617
          if (work_mbc->ncoll_elems != 0UL) {
            _L: /* CIL Label */ 
            {
#line 1624
            addtok_mb((token )273, (int )(((dfa->nmbcsets - 1UL) << 2) + 3UL));
            }
#line 1625
            if (need_or) {
              {
#line 1626
              addtok((token )269);
              }
            }
          } else
#line 1632
          if (work_mbc->cset != -1L) {
            {
#line 1635
            addtok(275L + work_mbc->cset);
            }
#line 1636
            if (need_or) {
              {
#line 1637
              addtok((token )269);
              }
            }
          }
        } else
#line 1617
        if (work_mbc->cset != -1L) {
#line 1617
          goto _L;
        } else {
#line 1617
          goto _L___0;
        }
      }
    } else {
      {
#line 1643
      addtok_mb(t, 3);
      }
    }
  } else {
    {
#line 1643
    addtok_mb(t, 3);
    }
  }
#line 1645
  return;
}
}
#line 1654 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void addtok_wc(wint_t wc ) 
{ 
  unsigned char buf___7[16] ;
  mbstate_t s___0 ;
  int i___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
#line 1660
  memset((void *)(& s___0), 0, sizeof(s___0));
#line 1661
  tmp___1 = wcrtomb((char */* __restrict  */)((char *)(buf___7)), (wchar_t )wc, (mbstate_t */* __restrict  */)(& s___0));
#line 1661
  cur_mb_len = (int )tmp___1;
  }
#line 1666
  if (cur_mb_len <= 0) {
#line 1667
    buf___7[0] = (unsigned char)0;
  }
#line 1669
  if (cur_mb_len == 1) {
#line 1669
    tmp___2 = 3;
  } else {
#line 1669
    tmp___2 = 1;
  }
  {
#line 1669
  addtok_mb((token )buf___7[0], tmp___2);
#line 1670
  i___0 = 1;
  }
  {
#line 1670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1670
    if (! (i___0 < cur_mb_len)) {
#line 1670
      goto while_break;
    }
#line 1672
    if (i___0 == cur_mb_len - 1) {
#line 1672
      tmp___3 = 2;
    } else {
#line 1672
      tmp___3 = 0;
    }
    {
#line 1672
    addtok_mb((token )buf___7[i___0], tmp___3);
#line 1673
    addtok((token )268);
#line 1670
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1675
  return;
}
}
#line 1687
static void add_utf8_anychar(void) ;
#line 1687 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static charclass const   utf8_classes[5]  = { {        0,        0,        0,        0, 
            ~ 0,        ~ 0,        0,        0}, 
   {        ~ 0,        ~ 0,        ~ 0,        ~ 0, 
            0,        0,        0,        0}, 
   {        0,        0,        0,        0, 
            0,        0,        ~ 3,        0}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        65535}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        16711680}};
#line 1683 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void add_utf8_anychar(void) 
{ 
  unsigned int n ;
  unsigned int i___0 ;
  charclass c ;
  size_t tmp___1 ;
  void *__cil_tmp5 ;

  {
#line 1694
  n = (unsigned int )(sizeof(utf8_classes) / sizeof(utf8_classes[0]));
#line 1698
  if (dfa->utf8_anychar_classes[0] == 0L) {
#line 1699
    i___0 = 0U;
    {
#line 1699
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1699
      if (! (i___0 < n)) {
#line 1699
        goto while_break;
      }
      {
#line 1702
      copyset(utf8_classes[i___0], c);
      }
#line 1703
      if (i___0 == 1U) {
#line 1705
        if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 1706
          clrbit((unsigned int )eolbyte, c);
          }
        }
#line 1707
        if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          {
#line 1708
          clrbit((unsigned int )'\000', c);
          }
        }
      }
      {
#line 1710
      tmp___1 = charclass_index((int */* const  */)(c));
#line 1710
      dfa->utf8_anychar_classes[i___0] = (token )(275UL + tmp___1);
#line 1699
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1723
  i___0 = 1U;
  {
#line 1723
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1723
    if (! (i___0 < n)) {
#line 1723
      goto while_break___0;
    }
    {
#line 1724
    addtok(dfa->utf8_anychar_classes[i___0]);
#line 1723
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1725
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1725
    i___0 --;
#line 1725
    if (! (i___0 > 1U)) {
#line 1725
      goto while_break___1;
    }
    {
#line 1727
    addtok(dfa->utf8_anychar_classes[0]);
#line 1728
    addtok((token )268);
#line 1729
    addtok((token )269);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1732
  return;
}
}
#line 1769 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void atom(void) 
{ 
  wint_t tmp___1 ;
  wint_t tmp___2 ;
  wint_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp7 ;

  {
#line 1776
  if (tok == 274L) {
#line 1778
    if (case_fold) {
      {
#line 1778
      tmp___1 = towlower((wint_t )wctok);
#line 1778
      tmp___2 = tmp___1;
      }
    } else {
#line 1778
      tmp___2 = (wint_t )wctok;
    }
    {
#line 1778
    addtok_wc(tmp___2);
    }
#line 1780
    if (case_fold) {
      {
#line 1780
      tmp___4 = iswalpha((wint_t )wctok);
      }
#line 1780
      if (tmp___4) {
        {
#line 1782
        tmp___3 = towupper((wint_t )wctok);
#line 1782
        addtok_wc(tmp___3);
#line 1783
        addtok((token )269);
        }
      }
    }
    {
#line 1787
    tok = lex();
    }
  } else
#line 1789
  if (tok == 272L) {
    {
#line 1789
    tmp___6 = using_utf8();
    }
#line 1789
    if (tmp___6) {
      {
#line 1798
      add_utf8_anychar();
#line 1799
      tok = lex();
      }
    } else {
#line 1789
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1801
  if (tok >= 0L) {
#line 1801
    if (tok < (token )(1 << 8)) {
      {
#line 1808
      addtok(tok);
#line 1809
      tok = lex();
      }
    } else {
#line 1801
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1801
  if (tok >= 275L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1801
  if (tok == 257L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1801
  if (tok == 258L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1801
  if (tok == 259L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1801
  if (tok == 260L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1801
  if (tok == 272L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1801
  if (tok == 273L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1801
  if (tok == 261L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1801
  if (tok == 262L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1801
  if (tok == 263L) {
    {
#line 1808
    addtok(tok);
#line 1809
    tok = lex();
    }
  } else
#line 1811
  if (tok == 270L) {
    {
#line 1813
    tok = lex();
#line 1814
    regexp();
    }
#line 1815
    if (tok != 271L) {
      {
#line 1816
      tmp___5 = gettext("unbalanced (");
#line 1816
      dfaerror((char const   *)tmp___5);
      }
    }
    {
#line 1817
    tok = lex();
    }
  } else {
    {
#line 1820
    addtok((token )256);
    }
  }
#line 1821
  return;
}
}
#line 1824 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static size_t __attribute__((__pure__))  nsubtoks(size_t tindex ) 
{ 
  size_t ntoks1 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  size_t __attribute__((__pure__))  tmp___3 ;

  {
  {
#line 1835
  if (*(dfa->tokens + (tindex - 1UL)) == 266L) {
#line 1835
    goto case_266;
  }
#line 1835
  if (*(dfa->tokens + (tindex - 1UL)) == 265L) {
#line 1835
    goto case_266;
  }
#line 1835
  if (*(dfa->tokens + (tindex - 1UL)) == 264L) {
#line 1835
    goto case_266;
  }
#line 1838
  if (*(dfa->tokens + (tindex - 1UL)) == 269L) {
#line 1838
    goto case_269;
  }
#line 1838
  if (*(dfa->tokens + (tindex - 1UL)) == 268L) {
#line 1838
    goto case_269;
  }
#line 1831
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1832
  return ((size_t __attribute__((__pure__))  )1);
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
#line 1836
  tmp___1 = nsubtoks(tindex - 1UL);
  }
#line 1836
  return ((size_t __attribute__((__pure__))  )1 + tmp___1);
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  {
#line 1839
  tmp___2 = nsubtoks(tindex - 1UL);
#line 1839
  ntoks1 = (size_t )tmp___2;
#line 1840
  tmp___3 = nsubtoks((tindex - 1UL) - ntoks1);
  }
#line 1840
  return ((size_t __attribute__((__pure__))  )((1UL + ntoks1) + (size_t )tmp___3));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1845 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void copytoks(size_t tindex , size_t ntokens ) 
{ 
  size_t i___0 ;
  size_t tmp___1 ;

  {
#line 1850
  i___0 = (size_t )0;
  {
#line 1850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1850
    if (! (i___0 < ntokens)) {
#line 1850
      goto while_break;
    }
    {
#line 1852
    addtok(*(dfa->tokens + (tindex + i___0)));
#line 1854
    tmp___1 = __ctype_get_mb_cur_max();
    }
#line 1854
    if (tmp___1 > 1UL) {
#line 1854
      if (*(dfa->tokens + (tindex + i___0)) == 273L) {
#line 1855
        *(dfa->multibyte_prop + (dfa->tindex - 1UL)) = *(dfa->multibyte_prop + (tindex + i___0));
      }
    }
#line 1850
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1857
  return;
}
}
#line 1859 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void closure(void) 
{ 
  int i___0 ;
  size_t tindex ;
  size_t ntokens ;
  size_t __attribute__((__pure__))  tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;

  {
  {
#line 1865
  atom();
  }
  {
#line 1866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1866
    if (! (tok == 264L)) {
#line 1866
      if (! (tok == 265L)) {
#line 1866
        if (! (tok == 266L)) {
#line 1866
          if (! (tok == 267L)) {
#line 1866
            goto while_break;
          }
        }
      }
    }
#line 1867
    if (tok == 267L) {
#line 1867
      if (minrep) {
#line 1867
        goto _L___0;
      } else
#line 1867
      if (maxrep) {
        _L___0: /* CIL Label */ 
        {
#line 1869
        tmp___1 = nsubtoks(dfa->tindex);
#line 1869
        ntokens = (size_t )tmp___1;
#line 1870
        tindex = dfa->tindex - ntokens;
        }
#line 1871
        if (maxrep < 0) {
          {
#line 1872
          addtok((token )266);
          }
        }
#line 1873
        if (minrep == 0) {
          {
#line 1874
          addtok((token )264);
          }
        }
#line 1875
        i___0 = 1;
        {
#line 1875
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1875
          if (! (i___0 < minrep)) {
#line 1875
            goto while_break___0;
          }
          {
#line 1877
          copytoks(tindex, ntokens);
#line 1878
          addtok((token )268);
#line 1875
          i___0 ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1880
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1880
          if (! (i___0 < maxrep)) {
#line 1880
            goto while_break___1;
          }
          {
#line 1882
          copytoks(tindex, ntokens);
#line 1883
          addtok((token )264);
#line 1884
          addtok((token )268);
#line 1880
          i___0 ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1886
        tok = lex();
        }
      } else {
#line 1867
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1888
    if (tok == 267L) {
      {
#line 1890
      tmp___2 = nsubtoks(dfa->tindex);
#line 1890
      dfa->tindex -= (size_t )tmp___2;
#line 1891
      tok = lex();
#line 1892
      closure();
      }
    } else {
      {
#line 1896
      addtok(tok);
#line 1897
      tok = lex();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1899
  return;
}
}
#line 1901 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void branch(void) 
{ 


  {
  {
#line 1904
  closure();
  }
  {
#line 1905
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1905
    if (tok != 271L) {
#line 1905
      if (tok != 269L) {
#line 1905
        if (! (tok >= 0L)) {
#line 1905
          goto while_break;
        }
      } else {
#line 1905
        goto while_break;
      }
    } else {
#line 1905
      goto while_break;
    }
    {
#line 1907
    closure();
#line 1908
    addtok((token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1910
  return;
}
}
#line 1912 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void regexp(void) 
{ 


  {
  {
#line 1915
  branch();
  }
  {
#line 1916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1916
    if (! (tok == 269L)) {
#line 1916
      goto while_break;
    }
    {
#line 1918
    tok = lex();
#line 1919
    branch();
#line 1920
    addtok((token )269);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1922
  return;
}
}
#line 1927 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
void dfaparse(char const   *s___0 , size_t len , struct dfa *d ) 
{ 
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1930
  dfa = d;
#line 1931
  lexptr = s___0;
#line 1932
  lexleft = len;
#line 1933
  lasttok = (token )-1;
#line 1934
  laststart = 1;
#line 1935
  parens = (size_t )0;
#line 1936
  tmp___1 = __ctype_get_mb_cur_max();
  }
#line 1936
  if (tmp___1 > 1UL) {
    {
#line 1938
    cur_mb_len = 0;
#line 1939
    memset((void *)(& mbs), 0, sizeof(mbs));
    }
  }
#line 1942
  if (! syntax_bits_set) {
    {
#line 1943
    tmp___2 = gettext("no syntax specified");
#line 1943
    dfaerror((char const   *)tmp___2);
    }
  }
  {
#line 1945
  tok = lex();
#line 1946
  depth = d->depth;
#line 1948
  regexp();
  }
#line 1950
  if (tok != -1L) {
    {
#line 1951
    tmp___3 = gettext("unbalanced )");
#line 1951
    dfaerror((char const   *)tmp___3);
    }
  }
  {
#line 1953
  addtok((token )(0xffffffffffffffffUL - d->nregexps));
#line 1954
  addtok((token )268);
  }
#line 1956
  if (d->nregexps) {
    {
#line 1957
    addtok((token )269);
    }
  }
#line 1959
  (d->nregexps) ++;
#line 1960
  return;
}
}
#line 1965 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void copy(position_set const   *src , position_set *dst ) 
{ 
  size_t new_n_alloc ;
  void *tmp___1 ;

  {
  {
#line 1968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1968
    if (dst->alloc <= (size_t )src->nelem) {
      {
#line 1968
      new_n_alloc = (size_t )(src->nelem + (size_t const   )(! dst->elems));
#line 1968
      tmp___1 = x2nrealloc((void *)dst->elems, & new_n_alloc, sizeof(*(dst->elems)));
#line 1968
      dst->elems = (position *)tmp___1;
#line 1968
      dst->alloc = new_n_alloc;
      }
    }
#line 1968
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1969
  memcpy((void */* __restrict  */)dst->elems, (void const   */* __restrict  */)src->elems,
         sizeof(*(dst->elems + 0)) * (unsigned long )src->nelem);
#line 1970
  dst->nelem = (size_t )src->nelem;
  }
#line 1971
  return;
}
}
#line 1973 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void alloc_position_set(position_set *s___0 , size_t size ) 
{ 
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1976
    if (sizeof(*(s___0->elems)) == 1UL) {
      {
#line 1976
      tmp___1 = xmalloc(size);
#line 1976
      s___0->elems = (position *)tmp___1;
      }
    } else {
      {
#line 1976
      tmp___2 = xnmalloc(size, sizeof(*(s___0->elems)));
#line 1976
      s___0->elems = (position *)tmp___2;
      }
    }
#line 1976
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1977
  s___0->alloc = size;
#line 1978
  s___0->nelem = (size_t )0;
#line 1979
  return;
}
}
#line 1985 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void insert(position p , position_set *s___0 ) 
{ 
  size_t count ;
  size_t lo ;
  size_t hi ;
  size_t i___0 ;
  size_t mid ;
  size_t new_n_alloc ;
  void *tmp___1 ;

  {
#line 1988
  count = s___0->nelem;
#line 1989
  lo = (size_t )0;
#line 1989
  hi = count;
  {
#line 1991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1991
    if (! (lo < hi)) {
#line 1991
      goto while_break;
    }
#line 1993
    mid = (lo + hi) >> 1;
#line 1994
    if ((s___0->elems + mid)->index > p.index) {
#line 1995
      lo = mid + 1UL;
    } else {
#line 1997
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2000
  if (lo < count) {
#line 2000
    if (p.index == (s___0->elems + lo)->index) {
#line 2002
      (s___0->elems + lo)->constraint |= p.constraint;
#line 2003
      return;
    }
  }
  {
#line 2006
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2006
    if (s___0->alloc <= count + 1UL) {
      {
#line 2006
      new_n_alloc = (count + 1UL) + (size_t )(! s___0->elems);
#line 2006
      tmp___1 = x2nrealloc((void *)s___0->elems, & new_n_alloc, sizeof(*(s___0->elems)));
#line 2006
      s___0->elems = (position *)tmp___1;
#line 2006
      s___0->alloc = new_n_alloc;
      }
    }
#line 2006
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2007
  i___0 = count;
  {
#line 2007
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2007
    if (! (i___0 > lo)) {
#line 2007
      goto while_break___1;
    }
#line 2008
    *(s___0->elems + i___0) = *(s___0->elems + (i___0 - 1UL));
#line 2007
    i___0 --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2009
  *(s___0->elems + lo) = p;
#line 2010
  (s___0->nelem) ++;
#line 2011
  return;
}
}
#line 2015 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void merge(position_set const   *s1 , position_set const   *s2 , position_set *m ) 
{ 
  size_t i___0 ;
  size_t j ;
  size_t new_n_alloc ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
#line 2018
  i___0 = (size_t )0;
#line 2018
  j = (size_t )0;
  {
#line 2020
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2020
    if (m->alloc <= (size_t )(s1->nelem + s2->nelem)) {
      {
#line 2020
      new_n_alloc = (size_t )((s1->nelem + s2->nelem) + (size_t const   )(! m->elems));
#line 2020
      tmp___1 = x2nrealloc((void *)m->elems, & new_n_alloc, sizeof(*(m->elems)));
#line 2020
      m->elems = (position *)tmp___1;
#line 2020
      m->alloc = new_n_alloc;
      }
    }
#line 2020
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2021
  m->nelem = (size_t )0;
  {
#line 2022
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2022
    if (i___0 < (size_t )s1->nelem) {
#line 2022
      if (! (j < (size_t )s2->nelem)) {
#line 2022
        goto while_break___0;
      }
    } else {
#line 2022
      goto while_break___0;
    }
#line 2023
    if ((s1->elems + i___0)->index > (s2->elems + j)->index) {
#line 2024
      tmp___2 = m->nelem;
#line 2024
      (m->nelem) ++;
#line 2024
      tmp___3 = i___0;
#line 2024
      i___0 ++;
#line 2024
      *(m->elems + tmp___2) = *(s1->elems + tmp___3);
    } else
#line 2025
    if ((s1->elems + i___0)->index < (s2->elems + j)->index) {
#line 2026
      tmp___4 = m->nelem;
#line 2026
      (m->nelem) ++;
#line 2026
      tmp___5 = j;
#line 2026
      j ++;
#line 2026
      *(m->elems + tmp___4) = *(s2->elems + tmp___5);
    } else {
#line 2029
      tmp___6 = i___0;
#line 2029
      i___0 ++;
#line 2029
      *(m->elems + m->nelem) = *(s1->elems + tmp___6);
#line 2030
      tmp___7 = m->nelem;
#line 2030
      (m->nelem) ++;
#line 2030
      tmp___8 = j;
#line 2030
      j ++;
#line 2030
      (m->elems + tmp___7)->constraint |= (s2->elems + tmp___8)->constraint;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2032
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2032
    if (! (i___0 < (size_t )s1->nelem)) {
#line 2032
      goto while_break___1;
    }
#line 2033
    tmp___9 = m->nelem;
#line 2033
    (m->nelem) ++;
#line 2033
    tmp___10 = i___0;
#line 2033
    i___0 ++;
#line 2033
    *(m->elems + tmp___9) = *(s1->elems + tmp___10);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2034
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2034
    if (! (j < (size_t )s2->nelem)) {
#line 2034
      goto while_break___2;
    }
#line 2035
    tmp___11 = m->nelem;
#line 2035
    (m->nelem) ++;
#line 2035
    tmp___12 = j;
#line 2035
    j ++;
#line 2035
    *(m->elems + tmp___11) = *(s2->elems + tmp___12);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2036
  return;
}
}
#line 2039 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void delete(position p , position_set *s___0 ) 
{ 
  size_t i___0 ;

  {
#line 2044
  i___0 = (size_t )0;
  {
#line 2044
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2044
    if (! (i___0 < s___0->nelem)) {
#line 2044
      goto while_break;
    }
#line 2045
    if (p.index == (s___0->elems + i___0)->index) {
#line 2046
      goto while_break;
    }
#line 2044
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2047
  if (i___0 < s___0->nelem) {
#line 2048
    (s___0->nelem) --;
    {
#line 2048
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2048
      if (! (i___0 < s___0->nelem)) {
#line 2048
        goto while_break___0;
      }
#line 2049
      *(s___0->elems + i___0) = *(s___0->elems + (i___0 + 1UL));
#line 2048
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2050
  return;
}
}
#line 2055 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static state_num state_index(struct dfa *d , position_set const   *s___0 , int context ) 
{ 
  size_t hash___0 ;
  int constraint ;
  state_num i___0 ;
  state_num j ;
  size_t new_n_alloc ;
  void *tmp___1 ;

  {
#line 2058
  hash___0 = (size_t )0;
#line 2062
  i___0 = (state_num )0;
  {
#line 2062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2062
    if (! ((size_t const   )i___0 < s___0->nelem)) {
#line 2062
      goto while_break;
    }
#line 2063
    hash___0 ^= (s___0->elems + i___0)->index + (size_t )(s___0->elems + i___0)->constraint;
#line 2062
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2066
  i___0 = (state_num )0;
  {
#line 2066
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2066
    if (! (i___0 < d->sindex)) {
#line 2066
      goto while_break___0;
    }
#line 2068
    if (hash___0 != (d->states + i___0)->hash) {
#line 2070
      goto __Cont;
    } else
#line 2068
    if (s___0->nelem != (size_t const   )(d->states + i___0)->elems.nelem) {
#line 2070
      goto __Cont;
    } else
#line 2068
    if (context != (int )(d->states + i___0)->context) {
#line 2070
      goto __Cont;
    }
#line 2071
    j = (state_num )0;
    {
#line 2071
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2071
      if (! ((size_t const   )j < s___0->nelem)) {
#line 2071
        goto while_break___1;
      }
#line 2072
      if ((s___0->elems + j)->constraint != ((d->states + i___0)->elems.elems + j)->constraint) {
#line 2075
        goto while_break___1;
      } else
#line 2072
      if ((s___0->elems + j)->index != ((d->states + i___0)->elems.elems + j)->index) {
#line 2075
        goto while_break___1;
      }
#line 2071
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2076
    if ((size_t const   )j == s___0->nelem) {
#line 2077
      return (i___0);
    }
    __Cont: /* CIL Label */ 
#line 2066
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2081
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2081
    if (d->salloc <= d->sindex + 1L) {
      {
#line 2081
      new_n_alloc = (size_t )((d->sindex + 1L) + (state_num )(! d->states));
#line 2081
      tmp___1 = x2nrealloc((void *)d->states, & new_n_alloc, sizeof(*(d->states)));
#line 2081
      d->states = (dfa_state *)tmp___1;
#line 2081
      d->salloc = (state_num )new_n_alloc;
      }
    }
#line 2081
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2082
  (d->states + i___0)->hash = hash___0;
#line 2083
  alloc_position_set(& (d->states + i___0)->elems, (size_t )s___0->nelem);
#line 2084
  copy(s___0, & (d->states + i___0)->elems);
#line 2085
  (d->states + i___0)->context = (unsigned char )context;
#line 2086
  (d->states + i___0)->backref = (char)0;
#line 2087
  (d->states + i___0)->constraint = (unsigned short)0;
#line 2088
  (d->states + i___0)->first_end = (token )0;
#line 2091
  (d->states + i___0)->mbps.nelem = (size_t )0;
#line 2092
  (d->states + i___0)->mbps.elems = (position *)((void *)0);
#line 2094
  j = (state_num )0;
  }
  {
#line 2094
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2094
    if (! ((size_t const   )j < s___0->nelem)) {
#line 2094
      goto while_break___3;
    }
#line 2095
    if (*(d->tokens + (s___0->elems + j)->index) < 0L) {
#line 2097
      constraint = (int )(s___0->elems + j)->constraint;
#line 2098
      if ((((constraint & 15) | ((constraint >> 4) & 15)) | ((constraint >> 8) & 15)) & context) {
#line 2099
        (d->states + i___0)->constraint = (unsigned short )((int )(d->states + i___0)->constraint | constraint);
      }
#line 2100
      if (! (d->states + i___0)->first_end) {
#line 2101
        (d->states + i___0)->first_end = *(d->tokens + (s___0->elems + j)->index);
      }
    } else
#line 2103
    if (*(d->tokens + (s___0->elems + j)->index) == 257L) {
#line 2105
      (d->states + i___0)->constraint = (unsigned short)1911;
#line 2106
      (d->states + i___0)->backref = (char)1;
    }
#line 2094
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2109
  (d->sindex) ++;
#line 2111
  return (i___0);
}
}
#line 2119 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void epsclosure(position_set *s___0 , struct dfa  const  *d ) 
{ 
  size_t i___0 ;
  size_t j ;
  char *visited ;
  position p ;
  position old ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
#line 2126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2126
    if (sizeof(*visited) == 1UL) {
      {
#line 2126
      tmp___1 = xzalloc((size_t )d->tindex);
#line 2126
      visited = (char *)tmp___1;
      }
    } else {
      {
#line 2126
      tmp___2 = xcalloc((size_t )d->tindex, sizeof(*visited));
#line 2126
      visited = (char *)tmp___2;
      }
    }
#line 2126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2128
  i___0 = (size_t )0;
  {
#line 2128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2128
    if (! (i___0 < s___0->nelem)) {
#line 2128
      goto while_break___0;
    }
#line 2129
    if (*(d->tokens + (s___0->elems + i___0)->index) >= (token )(1 << 8)) {
#line 2129
      if (*(d->tokens + (s___0->elems + i___0)->index) != 257L) {
#line 2129
        if (*(d->tokens + (s___0->elems + i___0)->index) != 272L) {
#line 2129
          if (*(d->tokens + (s___0->elems + i___0)->index) != 273L) {
#line 2129
            if (*(d->tokens + (s___0->elems + i___0)->index) < 275L) {
              {
#line 2137
              old = *(s___0->elems + i___0);
#line 2138
              p.constraint = old.constraint;
#line 2139
              delete(*(s___0->elems + i___0), s___0);
              }
#line 2140
              if (*(visited + old.index)) {
#line 2142
                i___0 --;
#line 2143
                goto __Cont;
              }
#line 2145
              *(visited + old.index) = (char)1;
              {
#line 2148
              if (*(d->tokens + old.index) == 258L) {
#line 2148
                goto case_258;
              }
#line 2151
              if (*(d->tokens + old.index) == 259L) {
#line 2151
                goto case_259;
              }
#line 2154
              if (*(d->tokens + old.index) == 260L) {
#line 2154
                goto case_260;
              }
#line 2157
              if (*(d->tokens + old.index) == 261L) {
#line 2157
                goto case_261;
              }
#line 2160
              if (*(d->tokens + old.index) == 262L) {
#line 2160
                goto case_262;
              }
#line 2163
              if (*(d->tokens + old.index) == 263L) {
#line 2163
                goto case_263;
              }
#line 2166
              goto switch_default;
              case_258: /* CIL Label */ 
#line 2149
              p.constraint &= 1092U;
#line 2150
              goto switch_break;
              case_259: /* CIL Label */ 
#line 2152
              p.constraint &= 1792U;
#line 2153
              goto switch_break;
              case_260: /* CIL Label */ 
#line 2155
              p.constraint &= 80U;
#line 2156
              goto switch_break;
              case_261: /* CIL Label */ 
#line 2158
              p.constraint &= 514U;
#line 2159
              goto switch_break;
              case_262: /* CIL Label */ 
#line 2161
              p.constraint &= 594U;
#line 2162
              goto switch_break;
              case_263: /* CIL Label */ 
#line 2164
              p.constraint &= 1317U;
#line 2165
              goto switch_break;
              switch_default: /* CIL Label */ 
#line 2167
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
#line 2169
              j = (size_t )0;
              {
#line 2169
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 2169
                if (! (j < (d->follows + old.index)->nelem)) {
#line 2169
                  goto while_break___1;
                }
                {
#line 2171
                p.index = ((d->follows + old.index)->elems + j)->index;
#line 2172
                insert(p, s___0);
#line 2169
                j ++;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 2175
              i___0 = (size_t )-1;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2128
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2178
  free((void *)visited);
  }
#line 2179
  return;
}
}
#line 2184 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int charclass_context(int *c ) 
{ 
  int context ;
  unsigned int j ;
  int tmp___1 ;

  {
  {
#line 2187
  context = 0;
#line 2190
  tmp___1 = tstbit((unsigned int )eolbyte, (int */* const  */)c);
  }
#line 2190
  if (tmp___1) {
#line 2191
    context |= 4;
  }
#line 2193
  j = 0U;
  {
#line 2193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2193
    if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2193
      goto while_break;
    }
#line 2195
    if (*(c + j) & letters[j]) {
#line 2196
      context |= 2;
    }
#line 2197
    if (*(c + j) & ~ (letters[j] | newline[j])) {
#line 2198
      context |= 1;
    }
#line 2193
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2201
  return (context);
}
}
#line 2210 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int __attribute__((__pure__))  state_separate_contexts(position_set const   *s___0 ) 
{ 
  int separate_contexts ;
  size_t j ;

  {
#line 2213
  separate_contexts = 0;
#line 2216
  j = (size_t )0;
  {
#line 2216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2216
    if (! (j < (size_t )s___0->nelem)) {
#line 2216
      goto while_break;
    }
#line 2218
    if ((((s___0->elems + j)->constraint >> 2) & 273U) != ((s___0->elems + j)->constraint & 273U)) {
#line 2219
      separate_contexts |= 4;
    }
#line 2220
    if ((((s___0->elems + j)->constraint >> 1) & 273U) != ((s___0->elems + j)->constraint & 273U)) {
#line 2221
      separate_contexts |= 2;
    }
#line 2216
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2224
  return ((int __attribute__((__pure__))  )separate_contexts);
}
}
#line 2280 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
void dfaanalyze(struct dfa *d , int searchflag ) 
{ 
  int *nullable ;
  size_t *nfirstpos ;
  position *firstpos ;
  size_t *nlastpos ;
  position *lastpos ;
  position_set tmp___1 ;
  position_set merged ;
  int separate_contexts ;
  int *o_nullable ;
  size_t *o_nfirst ;
  size_t *o_nlast ;
  position *o_firstpos ;
  position *o_lastpos ;
  size_t i___0 ;
  size_t j ;
  position *pos ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  int *tmp___14 ;
  size_t *tmp___15 ;
  size_t *tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  size_t *tmp___22 ;
  size_t *tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  unsigned int tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  int __attribute__((__pure__))  tmp___29 ;
  int tmp___30 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;

  {
#line 2307
  d->searchflag = searchflag;
  {
#line 2309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2309
    if (sizeof(*nullable) == 1UL) {
      {
#line 2309
      tmp___2 = xmalloc(d->depth);
#line 2309
      nullable = (int *)tmp___2;
      }
    } else {
      {
#line 2309
      tmp___3 = xnmalloc(d->depth, sizeof(*nullable));
#line 2309
      nullable = (int *)tmp___3;
      }
    }
#line 2309
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2310
  o_nullable = nullable;
  {
#line 2311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2311
    if (sizeof(*nfirstpos) == 1UL) {
      {
#line 2311
      tmp___4 = xmalloc(d->depth);
#line 2311
      nfirstpos = (size_t *)tmp___4;
      }
    } else {
      {
#line 2311
      tmp___5 = xnmalloc(d->depth, sizeof(*nfirstpos));
#line 2311
      nfirstpos = (size_t *)tmp___5;
      }
    }
#line 2311
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2312
  o_nfirst = nfirstpos;
  {
#line 2313
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2313
    if (sizeof(*firstpos) == 1UL) {
      {
#line 2313
      tmp___6 = xmalloc(d->nleaves);
#line 2313
      firstpos = (position *)tmp___6;
      }
    } else {
      {
#line 2313
      tmp___7 = xnmalloc(d->nleaves, sizeof(*firstpos));
#line 2313
      firstpos = (position *)tmp___7;
      }
    }
#line 2313
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2314
  o_firstpos = firstpos;
#line 2314
  firstpos += d->nleaves;
  {
#line 2315
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2315
    if (sizeof(*nlastpos) == 1UL) {
      {
#line 2315
      tmp___8 = xmalloc(d->depth);
#line 2315
      nlastpos = (size_t *)tmp___8;
      }
    } else {
      {
#line 2315
      tmp___9 = xnmalloc(d->depth, sizeof(*nlastpos));
#line 2315
      nlastpos = (size_t *)tmp___9;
      }
    }
#line 2315
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2316
  o_nlast = nlastpos;
  {
#line 2317
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2317
    if (sizeof(*lastpos) == 1UL) {
      {
#line 2317
      tmp___10 = xmalloc(d->nleaves);
#line 2317
      lastpos = (position *)tmp___10;
      }
    } else {
      {
#line 2317
      tmp___11 = xnmalloc(d->nleaves, sizeof(*lastpos));
#line 2317
      lastpos = (position *)tmp___11;
      }
    }
#line 2317
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2318
  o_lastpos = lastpos;
#line 2318
  lastpos += d->nleaves;
#line 2319
  alloc_position_set(& merged, d->nleaves);
  }
  {
#line 2321
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2321
    if (sizeof(*(d->follows)) == 1UL) {
      {
#line 2321
      tmp___12 = xzalloc(d->tindex);
#line 2321
      d->follows = (position_set *)tmp___12;
      }
    } else {
      {
#line 2321
      tmp___13 = xcalloc(d->tindex, sizeof(*(d->follows)));
#line 2321
      d->follows = (position_set *)tmp___13;
      }
    }
#line 2321
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2323
  i___0 = (size_t )0;
  {
#line 2323
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2323
    if (! (i___0 < d->tindex)) {
#line 2323
      goto while_break___5;
    }
    {
#line 2327
    if (*(d->tokens + i___0) == 256L) {
#line 2327
      goto case_256;
    }
#line 2336
    if (*(d->tokens + i___0) == 266L) {
#line 2336
      goto case_266;
    }
#line 2336
    if (*(d->tokens + i___0) == 265L) {
#line 2336
      goto case_266;
    }
#line 2348
    if (*(d->tokens + i___0) == 264L) {
#line 2348
      goto case_264;
    }
#line 2354
    if (*(d->tokens + i___0) == 268L) {
#line 2354
      goto case_268;
    }
#line 2393
    if (*(d->tokens + i___0) == 269L) {
#line 2393
      goto case_269;
    }
#line 2407
    goto switch_default;
    case_256: /* CIL Label */ 
#line 2329
    tmp___14 = nullable;
#line 2329
    nullable ++;
#line 2329
    *tmp___14 = 1;
#line 2332
    tmp___15 = nfirstpos;
#line 2332
    nfirstpos ++;
#line 2332
    tmp___16 = nlastpos;
#line 2332
    nlastpos ++;
#line 2332
    tmp___17 = (size_t )0;
#line 2332
    *tmp___16 = tmp___17;
#line 2332
    *tmp___15 = tmp___17;
#line 2333
    goto switch_break;
    case_266: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 2339
    tmp___1.nelem = *(nfirstpos + -1);
#line 2340
    tmp___1.elems = firstpos;
#line 2341
    pos = lastpos;
#line 2342
    j = (size_t )0;
    {
#line 2342
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2342
      if (! (j < *(nlastpos + -1))) {
#line 2342
        goto while_break___6;
      }
      {
#line 2344
      merge((position_set const   *)(& tmp___1), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2345
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2342
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
#line 2350
    if (*(d->tokens + i___0) != 266L) {
#line 2351
      *(nullable + -1) = 1;
    }
#line 2352
    goto switch_break;
    case_268: /* CIL Label */ 
#line 2357
    tmp___1.nelem = *(nfirstpos + -1);
#line 2358
    tmp___1.elems = firstpos;
#line 2359
    pos = lastpos + *(nlastpos + -1);
#line 2360
    j = (size_t )0;
    {
#line 2360
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2360
      if (! (j < *(nlastpos + -2))) {
#line 2360
        goto while_break___7;
      }
      {
#line 2362
      merge((position_set const   *)(& tmp___1), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2363
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2360
      j ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2368
    if (*(nullable + -2)) {
#line 2369
      *(nfirstpos + -2) += *(nfirstpos + -1);
    } else {
#line 2371
      firstpos += *(nfirstpos + -1);
    }
#line 2372
    nfirstpos --;
#line 2376
    if (*(nullable + -1)) {
#line 2377
      *(nlastpos + -2) += *(nlastpos + -1);
    } else {
#line 2380
      pos = lastpos + *(nlastpos + -2);
#line 2381
      j = *(nlastpos + -1);
      {
#line 2381
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2381
        tmp___18 = j;
#line 2381
        j --;
#line 2381
        if (! (tmp___18 > 0UL)) {
#line 2381
          goto while_break___8;
        }
#line 2382
        *(pos + j) = *(lastpos + j);
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2383
      lastpos += *(nlastpos + -2);
#line 2384
      *(nlastpos + -2) = *(nlastpos + -1);
    }
#line 2386
    nlastpos --;
#line 2389
    if (*(nullable + -1)) {
#line 2389
      if (*(nullable + -2)) {
#line 2389
        tmp___19 = 1;
      } else {
#line 2389
        tmp___19 = 0;
      }
    } else {
#line 2389
      tmp___19 = 0;
    }
#line 2389
    *(nullable + -2) = tmp___19;
#line 2390
    nullable --;
#line 2391
    goto switch_break;
    case_269: /* CIL Label */ 
#line 2395
    *(nfirstpos + -2) += *(nfirstpos + -1);
#line 2396
    nfirstpos --;
#line 2399
    *(nlastpos + -2) += *(nlastpos + -1);
#line 2400
    nlastpos --;
#line 2403
    if (*(nullable + -1)) {
#line 2403
      tmp___20 = 1;
    } else
#line 2403
    if (*(nullable + -2)) {
#line 2403
      tmp___20 = 1;
    } else {
#line 2403
      tmp___20 = 0;
    }
#line 2403
    *(nullable + -2) = tmp___20;
#line 2404
    nullable --;
#line 2405
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2413
    tmp___21 = nullable;
#line 2413
    nullable ++;
#line 2413
    *tmp___21 = *(d->tokens + i___0) == 257L;
#line 2416
    tmp___22 = nfirstpos;
#line 2416
    nfirstpos ++;
#line 2416
    tmp___23 = nlastpos;
#line 2416
    nlastpos ++;
#line 2416
    tmp___24 = (size_t )1;
#line 2416
    *tmp___23 = tmp___24;
#line 2416
    *tmp___22 = tmp___24;
#line 2417
    firstpos --;
#line 2417
    lastpos --;
#line 2418
    tmp___25 = i___0;
#line 2418
    lastpos->index = tmp___25;
#line 2418
    firstpos->index = tmp___25;
#line 2419
    tmp___26 = 1911U;
#line 2419
    lastpos->constraint = tmp___26;
#line 2419
    firstpos->constraint = tmp___26;
#line 2422
    alloc_position_set(d->follows + i___0, (size_t )1);
    }
#line 2423
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2323
    i___0 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2449
  i___0 = (size_t )0;
  {
#line 2449
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2449
    if (! (i___0 < d->tindex)) {
#line 2449
      goto while_break___9;
    }
#line 2450
    if (*(d->tokens + i___0) < (token )(1 << 8)) {
      {
#line 2467
      copy((position_set const   *)(d->follows + i___0), & merged);
#line 2468
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2469
      copy((position_set const   *)(& merged), d->follows + i___0);
      }
    } else
#line 2450
    if (*(d->tokens + i___0) == 257L) {
      {
#line 2467
      copy((position_set const   *)(d->follows + i___0), & merged);
#line 2468
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2469
      copy((position_set const   *)(& merged), d->follows + i___0);
      }
    } else
#line 2450
    if (*(d->tokens + i___0) == 272L) {
      {
#line 2467
      copy((position_set const   *)(d->follows + i___0), & merged);
#line 2468
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2469
      copy((position_set const   *)(& merged), d->follows + i___0);
      }
    } else
#line 2450
    if (*(d->tokens + i___0) == 273L) {
      {
#line 2467
      copy((position_set const   *)(d->follows + i___0), & merged);
#line 2468
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2469
      copy((position_set const   *)(& merged), d->follows + i___0);
      }
    } else
#line 2450
    if (*(d->tokens + i___0) >= 275L) {
      {
#line 2467
      copy((position_set const   *)(d->follows + i___0), & merged);
#line 2468
      epsclosure(& merged, (struct dfa  const  *)d);
#line 2469
      copy((position_set const   *)(& merged), d->follows + i___0);
      }
    }
#line 2449
    i___0 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2474
  merged.nelem = (size_t )0;
#line 2475
  i___0 = (size_t )0;
  {
#line 2475
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2475
    if (! (i___0 < *(nfirstpos + -1))) {
#line 2475
      goto while_break___10;
    }
    {
#line 2476
    insert(*(firstpos + i___0), & merged);
#line 2475
    i___0 ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 2477
  epsclosure(& merged, (struct dfa  const  *)d);
#line 2480
  d->salloc = (state_num )1;
#line 2481
  d->sindex = (state_num )0;
  }
  {
#line 2482
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2482
    if (sizeof(*(d->states)) == 1UL) {
      {
#line 2482
      tmp___27 = xmalloc((size_t )d->salloc);
#line 2482
      d->states = (dfa_state *)tmp___27;
      }
    } else {
      {
#line 2482
      tmp___28 = xnmalloc((size_t )d->salloc, sizeof(*(d->states)));
#line 2482
      d->states = (dfa_state *)tmp___28;
      }
    }
#line 2482
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 2484
  tmp___29 = state_separate_contexts((position_set const   *)(& merged));
#line 2484
  separate_contexts = (int )tmp___29;
  }
#line 2485
  if (separate_contexts & 4) {
#line 2485
    tmp___30 = 4;
  } else {
#line 2485
    tmp___30 = separate_contexts ^ 7;
  }
  {
#line 2485
  state_index(d, (position_set const   *)(& merged), tmp___30);
#line 2489
  free((void *)o_nullable);
#line 2490
  free((void *)o_nfirst);
#line 2491
  free((void *)o_firstpos);
#line 2492
  free((void *)o_nlast);
#line 2493
  free((void *)o_lastpos);
#line 2494
  free((void *)merged.elems);
  }
#line 2495
  return;
}
}
#line 2528 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
void dfastate(ptrdiff_t s___0 , struct dfa *d , ptrdiff_t *trans ) 
{ 
  leaf_set *grps ;
  charclass *labels ;
  size_t ngrps ;
  position pos ;
  charclass matches ;
  int matchesf ;
  charclass intersect ;
  int intersectf ;
  charclass leftovers ;
  int leftoversf ;
  position_set follows ;
  position_set tmp___1 ;
  int possible_contexts ;
  int separate_contexts ;
  state_num state___2 ;
  state_num state_newline ;
  state_num state_letter ;
  int next_isnt_1st_byte ;
  size_t i___0 ;
  size_t j ;
  size_t k ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int match ;
  int label ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  int __attribute__((__pure__))  tmp___15 ;
  unsigned short const   **tmp___16 ;
  int __attribute__((__pure__))  tmp___17 ;
  int c ;
  unsigned short const   **tmp___18 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;

  {
#line 2533
  ngrps = (size_t )0;
#line 2548
  next_isnt_1st_byte = 0;
  {
#line 2551
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2551
    if (sizeof(*grps) == 1UL) {
      {
#line 2551
      tmp___2 = xmalloc((size_t )(1 << 8));
#line 2551
      grps = (leaf_set *)tmp___2;
      }
    } else {
      {
#line 2551
      tmp___3 = xnmalloc((size_t )(1 << 8), sizeof(*grps));
#line 2551
      grps = (leaf_set *)tmp___3;
      }
    }
#line 2551
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2552
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2552
    if (sizeof(*labels) == 1UL) {
      {
#line 2552
      tmp___4 = xmalloc((size_t )(1 << 8));
#line 2552
      labels = (charclass *)tmp___4;
      }
    } else {
      {
#line 2552
      tmp___5 = xnmalloc((size_t )(1 << 8), sizeof(*labels));
#line 2552
      labels = (charclass *)tmp___5;
      }
    }
#line 2552
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2554
  zeroset(matches);
#line 2556
  i___0 = (size_t )0;
  }
  {
#line 2556
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2556
    if (! (i___0 < (d->states + s___0)->elems.nelem)) {
#line 2556
      goto while_break___1;
    }
#line 2558
    pos = *((d->states + s___0)->elems.elems + i___0);
#line 2559
    if (*(d->tokens + pos.index) >= 0L) {
#line 2559
      if (*(d->tokens + pos.index) < (token )(1 << 8)) {
        {
#line 2560
        setbit((unsigned int )*(d->tokens + pos.index), matches);
        }
      } else {
#line 2559
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2561
    if (*(d->tokens + pos.index) >= 275L) {
      {
#line 2562
      copyset((int */* const  */)(*(d->charclasses + (*(d->tokens + pos.index) - 275L))),
              matches);
      }
    } else
#line 2563
    if (*(d->tokens + pos.index) == 272L) {
#line 2563
      goto _L;
    } else
#line 2563
    if (*(d->tokens + pos.index) == 273L) {
      _L: /* CIL Label */ 
#line 2571
      if ((d->states + s___0)->mbps.nelem == 0UL) {
        {
#line 2572
        alloc_position_set(& (d->states + s___0)->mbps, (size_t )1);
        }
      }
      {
#line 2573
      insert(pos, & (d->states + s___0)->mbps);
      }
#line 2574
      goto __Cont;
    } else {
#line 2577
      goto __Cont;
    }
#line 2581
    if (pos.constraint != 1911U) {
#line 2583
      if (! (((pos.constraint >> 8) & 15U) & (unsigned int )(d->states + s___0)->context)) {
#line 2585
        j = (size_t )0;
        {
#line 2585
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2585
          if (! (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2585
            goto while_break___2;
          }
#line 2586
          matches[j] &= ~ newline[j];
#line 2585
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 2587
      if (! (((pos.constraint >> 4) & 15U) & (unsigned int )(d->states + s___0)->context)) {
#line 2589
        j = (size_t )0;
        {
#line 2589
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2589
          if (! (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2589
            goto while_break___3;
          }
#line 2590
          matches[j] &= ~ letters[j];
#line 2589
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2591
      if (! ((pos.constraint & 15U) & (unsigned int )(d->states + s___0)->context)) {
#line 2593
        j = (size_t )0;
        {
#line 2593
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2593
          if (! (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2593
            goto while_break___4;
          }
#line 2594
          matches[j] &= letters[j] | newline[j];
#line 2593
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 2597
      j = (size_t )0;
      {
#line 2597
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2597
        if (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2597
          if (! (! matches[j])) {
#line 2597
            goto while_break___5;
          }
        } else {
#line 2597
          goto while_break___5;
        }
#line 2598
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 2597
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2599
      if (j == (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2600
        goto __Cont;
      }
    }
#line 2603
    j = (size_t )0;
    {
#line 2603
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2603
      if (! (j < ngrps)) {
#line 2603
        goto while_break___6;
      }
#line 2608
      if (*(d->tokens + pos.index) >= 0L) {
#line 2608
        if (*(d->tokens + pos.index) < (token )(1 << 8)) {
          {
#line 2608
          tmp___6 = tstbit((unsigned int )*(d->tokens + pos.index), (int */* const  */)(*(labels + j)));
          }
#line 2608
          if (! tmp___6) {
#line 2610
            goto __Cont___1;
          }
        }
      }
#line 2614
      intersectf = 0;
#line 2615
      k = (size_t )0;
      {
#line 2615
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2615
        if (! (k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2615
          goto while_break___7;
        }
#line 2616
        tmp___7 = matches[k] & (*(labels + j))[k];
#line 2616
        intersect[k] = tmp___7;
#line 2616
        if (tmp___7) {
#line 2616
          intersectf = 1;
        }
#line 2615
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 2617
      if (! intersectf) {
#line 2618
        goto __Cont___1;
      }
#line 2621
      matchesf = 0;
#line 2621
      leftoversf = matchesf;
#line 2622
      k = (size_t )0;
      {
#line 2622
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2622
        if (! (k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2622
          goto while_break___8;
        }
#line 2625
        match = matches[k];
#line 2625
        label = (*(labels + j))[k];
#line 2627
        tmp___8 = ~ match & label;
#line 2627
        leftovers[k] = tmp___8;
#line 2627
        if (tmp___8) {
#line 2627
          leftoversf = 1;
        }
#line 2628
        tmp___9 = match & ~ label;
#line 2628
        matches[k] = tmp___9;
#line 2628
        if (tmp___9) {
#line 2628
          matchesf = 1;
        }
#line 2622
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2632
      if (leftoversf) {
        {
#line 2634
        copyset((int */* const  */)(leftovers), *(labels + ngrps));
#line 2635
        copyset((int */* const  */)(intersect), *(labels + j));
        }
        {
#line 2636
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2636
          if (sizeof(*((grps + ngrps)->elems)) == 1UL) {
            {
#line 2636
            tmp___10 = xmalloc(d->nleaves);
#line 2636
            (grps + ngrps)->elems = (size_t *)tmp___10;
            }
          } else {
            {
#line 2636
            tmp___11 = xnmalloc(d->nleaves, sizeof(*((grps + ngrps)->elems)));
#line 2636
            (grps + ngrps)->elems = (size_t *)tmp___11;
            }
          }
#line 2636
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 2637
        memcpy((void */* __restrict  */)(grps + ngrps)->elems, (void const   */* __restrict  */)(grps + j)->elems,
               sizeof(*((grps + j)->elems + 0)) * (grps + j)->nelem);
#line 2639
        (grps + ngrps)->nelem = (grps + j)->nelem;
#line 2640
        ngrps ++;
        }
      }
#line 2645
      tmp___12 = (grps + j)->nelem;
#line 2645
      ((grps + j)->nelem) ++;
#line 2645
      *((grps + j)->elems + tmp___12) = pos.index;
#line 2649
      if (! matchesf) {
#line 2650
        goto while_break___6;
      }
      __Cont___1: /* CIL Label */ 
#line 2603
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2655
    if (j == ngrps) {
      {
#line 2657
      copyset((int */* const  */)(matches), *(labels + ngrps));
#line 2658
      zeroset(matches);
      }
      {
#line 2659
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2659
        if (sizeof(*((grps + ngrps)->elems)) == 1UL) {
          {
#line 2659
          tmp___13 = xmalloc(d->nleaves);
#line 2659
          (grps + ngrps)->elems = (size_t *)tmp___13;
          }
        } else {
          {
#line 2659
          tmp___14 = xnmalloc(d->nleaves, sizeof(*((grps + ngrps)->elems)));
#line 2659
          (grps + ngrps)->elems = (size_t *)tmp___14;
          }
        }
#line 2659
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 2660
      (grps + ngrps)->nelem = (size_t )1;
#line 2661
      *((grps + ngrps)->elems + 0) = pos.index;
#line 2662
      ngrps ++;
    }
    __Cont: /* CIL Label */ 
#line 2556
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2666
  alloc_position_set(& follows, d->nleaves);
#line 2667
  alloc_position_set(& tmp___1, d->nleaves);
  }
#line 2672
  if (d->searchflag) {
    {
#line 2675
    copy((position_set const   *)(& (d->states + 0)->elems), & follows);
#line 2676
    tmp___15 = state_separate_contexts((position_set const   *)(& follows));
#line 2676
    separate_contexts = (int )tmp___15;
#line 2677
    state___2 = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
    }
#line 2678
    if (separate_contexts & 4) {
      {
#line 2679
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2681
      state_newline = state___2;
    }
#line 2682
    if (separate_contexts & 2) {
      {
#line 2683
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2685
      state_letter = state___2;
    }
#line 2687
    i___0 = (size_t )0;
    {
#line 2687
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2687
      if (! (i___0 < (size_t )(1 << 8))) {
#line 2687
        goto while_break___11;
      }
      {
#line 2688
      tmp___16 = __ctype_b_loc();
      }
#line 2688
      if ((int const   )*(*tmp___16 + (int )i___0) & 8) {
#line 2688
        *(trans + i___0) = state_letter;
      } else
#line 2688
      if (i___0 == 95UL) {
#line 2688
        *(trans + i___0) = state_letter;
      } else {
#line 2688
        *(trans + i___0) = state___2;
      }
#line 2687
      i___0 ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 2689
    *(trans + eolbyte) = state_newline;
  } else {
#line 2692
    i___0 = (size_t )0;
    {
#line 2692
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 2692
      if (! (i___0 < (size_t )(1 << 8))) {
#line 2692
        goto while_break___12;
      }
#line 2693
      *(trans + i___0) = (ptrdiff_t )-1;
#line 2692
      i___0 ++;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 2695
  i___0 = (size_t )0;
  {
#line 2695
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 2695
    if (! (i___0 < ngrps)) {
#line 2695
      goto while_break___13;
    }
#line 2697
    follows.nelem = (size_t )0;
#line 2701
    j = (size_t )0;
    {
#line 2701
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 2701
      if (! (j < (grps + i___0)->nelem)) {
#line 2701
        goto while_break___14;
      }
#line 2702
      k = (size_t )0;
      {
#line 2702
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 2702
        if (! (k < (d->follows + *((grps + i___0)->elems + j))->nelem)) {
#line 2702
          goto while_break___15;
        }
        {
#line 2703
        insert(*((d->follows + *((grps + i___0)->elems + j))->elems + k), & follows);
#line 2702
        k ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
#line 2701
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 2705
    if (d->mb_cur_max > 1U) {
#line 2725
      next_isnt_1st_byte = 0;
#line 2726
      j = (size_t )0;
      {
#line 2726
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 2726
        if (! (j < follows.nelem)) {
#line 2726
          goto while_break___16;
        }
#line 2728
        if (! (*(d->multibyte_prop + (follows.elems + j)->index) & 1)) {
#line 2730
          next_isnt_1st_byte = 1;
#line 2731
          goto while_break___16;
        }
#line 2726
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
#line 2738
    if (d->searchflag) {
#line 2738
      if (d->mb_cur_max == 1U) {
#line 2738
        goto _L___1;
      } else
#line 2738
      if (! next_isnt_1st_byte) {
        _L___1: /* CIL Label */ 
#line 2740
        j = (size_t )0;
        {
#line 2740
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 2740
          if (! (j < (d->states + 0)->elems.nelem)) {
#line 2740
            goto while_break___17;
          }
          {
#line 2741
          insert(*((d->states + 0)->elems.elems + j), & follows);
#line 2740
          j ++;
          }
        }
        while_break___17: /* CIL Label */ ;
        }
      }
    }
    {
#line 2744
    possible_contexts = charclass_context(*(labels + i___0));
#line 2745
    tmp___17 = state_separate_contexts((position_set const   *)(& follows));
#line 2745
    separate_contexts = (int )tmp___17;
    }
#line 2748
    if ((separate_contexts & possible_contexts) != possible_contexts) {
      {
#line 2749
      state___2 = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
      }
    } else {
#line 2751
      state___2 = (state_num )-1;
    }
#line 2752
    if ((separate_contexts & possible_contexts) & 4) {
      {
#line 2753
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2755
      state_newline = state___2;
    }
#line 2756
    if ((separate_contexts & possible_contexts) & 2) {
      {
#line 2757
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2759
      state_letter = state___2;
    }
#line 2762
    j = (size_t )0;
    {
#line 2762
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 2762
      if (! (j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2762
        goto while_break___18;
      }
#line 2763
      k = (size_t )0;
      {
#line 2763
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 2763
        if (! (k < 8UL * sizeof(int ))) {
#line 2763
          goto while_break___19;
        }
#line 2764
        if ((*(labels + i___0))[j] & (1 << k)) {
#line 2766
          c = (int )(j * (8UL * sizeof(int )) + k);
#line 2768
          if (c == (int )eolbyte) {
#line 2769
            *(trans + c) = state_newline;
          } else {
            {
#line 2770
            tmp___18 = __ctype_b_loc();
            }
#line 2770
            if ((int const   )*(*tmp___18 + c) & 8) {
#line 2771
              *(trans + c) = state_letter;
            } else
#line 2770
            if (c == 95) {
#line 2771
              *(trans + c) = state_letter;
            } else
#line 2772
            if (c < 1 << 8) {
#line 2773
              *(trans + c) = state___2;
            }
          }
        }
#line 2763
        k ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 2762
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 2695
    i___0 ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 2777
  i___0 = (size_t )0;
  {
#line 2777
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 2777
    if (! (i___0 < ngrps)) {
#line 2777
      goto while_break___20;
    }
    {
#line 2778
    free((void *)(grps + i___0)->elems);
#line 2777
    i___0 ++;
    }
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 2779
  free((void *)follows.elems);
#line 2780
  free((void *)tmp___1.elems);
#line 2781
  free((void *)grps);
#line 2782
  free((void *)labels);
  }
#line 2783
  return;
}
}
#line 2792 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void build_state(state_num s___0 , struct dfa *d ) 
{ 
  state_num *trans ;
  state_num i___0 ;
  state_num *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  state_num oldalloc ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  state_num tmp___8 ;

  {
#line 2802
  if (d->trcount >= 1024) {
#line 2804
    i___0 = (state_num )0;
    {
#line 2804
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2804
      if (! (i___0 < d->tralloc)) {
#line 2804
        goto while_break;
      }
      {
#line 2806
      free((void *)*(d->trans + i___0));
#line 2807
      free((void *)*(d->fails + i___0));
#line 2808
      tmp___1 = (state_num *)((void *)0);
#line 2808
      *(d->fails + i___0) = tmp___1;
#line 2808
      *(d->trans + i___0) = tmp___1;
#line 2804
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2810
    d->trcount = 0;
  }
#line 2813
  (d->trcount) ++;
#line 2816
  *(d->success + s___0) = 0;
#line 2817
  if ((((int )(d->states + s___0)->constraint >> 8) & 15) & (int )(d->states + s___0)->context) {
#line 2818
    *(d->success + s___0) |= 4;
  }
#line 2819
  if ((((int )(d->states + s___0)->constraint >> 4) & 15) & (int )(d->states + s___0)->context) {
#line 2820
    *(d->success + s___0) |= 2;
  }
#line 2821
  if (((int )(d->states + s___0)->constraint & 15) & (int )(d->states + s___0)->context) {
#line 2822
    *(d->success + s___0) |= 1;
  }
  {
#line 2824
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2824
    if (sizeof(*trans) == 1UL) {
      {
#line 2824
      tmp___2 = xmalloc((size_t )(1 << 8));
#line 2824
      trans = (state_num *)tmp___2;
      }
    } else {
      {
#line 2824
      tmp___3 = xnmalloc((size_t )(1 << 8), sizeof(*trans));
#line 2824
      trans = (state_num *)tmp___3;
      }
    }
#line 2824
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2825
  dfastate(s___0, d, trans);
#line 2830
  i___0 = (state_num )0;
  }
  {
#line 2830
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2830
    if (! (i___0 < (state_num )(1 << 8))) {
#line 2830
      goto while_break___1;
    }
#line 2831
    if (*(trans + i___0) >= d->tralloc) {
#line 2833
      oldalloc = d->tralloc;
      {
#line 2835
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2835
        if (! (*(trans + i___0) >= d->tralloc)) {
#line 2835
          goto while_break___2;
        }
#line 2836
        d->tralloc *= 2L;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2837
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 2837
        tmp___4 = xnrealloc((void *)d->realtrans, (size_t )(d->tralloc + 1L), sizeof(*(d->realtrans)));
#line 2837
        d->realtrans = (state_num **)tmp___4;
        }
#line 2837
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2838
      d->trans = d->realtrans + 1;
      {
#line 2839
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 2839
        tmp___5 = xnrealloc((void *)d->fails, (size_t )d->tralloc, sizeof(*(d->fails)));
#line 2839
        d->fails = (state_num **)tmp___5;
        }
#line 2839
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2840
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 2840
        tmp___6 = xnrealloc((void *)d->success, (size_t )d->tralloc, sizeof(*(d->success)));
#line 2840
        d->success = (int *)tmp___6;
        }
#line 2840
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 2841
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 2841
        tmp___7 = xnrealloc((void *)d->newlines, (size_t )d->tralloc, sizeof(*(d->newlines)));
#line 2841
        d->newlines = (state_num *)tmp___7;
        }
#line 2841
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2842
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2842
        if (! (oldalloc < d->tralloc)) {
#line 2842
          goto while_break___7;
        }
#line 2844
        *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2845
        tmp___8 = oldalloc;
#line 2845
        oldalloc ++;
#line 2845
        *(d->fails + tmp___8) = (state_num *)((void *)0);
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 2830
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2851
  *(d->newlines + s___0) = *(trans + eolbyte);
#line 2852
  *(trans + eolbyte) = (state_num )-1;
#line 2854
  if ((d->states + s___0)->constraint) {
#line 2855
    *(d->fails + s___0) = trans;
  } else {
#line 2857
    *(d->trans + s___0) = trans;
  }
#line 2858
  return;
}
}
#line 2860 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void build_state_zero(struct dfa *d ) 
{ 
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 2863
  d->tralloc = (state_num )1;
#line 2864
  d->trcount = 0;
  {
#line 2865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2865
    if (sizeof(*(d->realtrans)) == 1UL) {
      {
#line 2865
      tmp___1 = xzalloc((size_t )(d->tralloc + 1L));
#line 2865
      d->realtrans = (state_num **)tmp___1;
      }
    } else {
      {
#line 2865
      tmp___2 = xcalloc((size_t )(d->tralloc + 1L), sizeof(*(d->realtrans)));
#line 2865
      d->realtrans = (state_num **)tmp___2;
      }
    }
#line 2865
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2866
  d->trans = d->realtrans + 1;
  {
#line 2867
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2867
    if (sizeof(*(d->fails)) == 1UL) {
      {
#line 2867
      tmp___3 = xzalloc((size_t )d->tralloc);
#line 2867
      d->fails = (state_num **)tmp___3;
      }
    } else {
      {
#line 2867
      tmp___4 = xcalloc((size_t )d->tralloc, sizeof(*(d->fails)));
#line 2867
      d->fails = (state_num **)tmp___4;
      }
    }
#line 2867
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2868
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2868
    if (sizeof(*(d->success)) == 1UL) {
      {
#line 2868
      tmp___5 = xmalloc((size_t )d->tralloc);
#line 2868
      d->success = (int *)tmp___5;
      }
    } else {
      {
#line 2868
      tmp___6 = xnmalloc((size_t )d->tralloc, sizeof(*(d->success)));
#line 2868
      d->success = (int *)tmp___6;
      }
    }
#line 2868
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2869
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2869
    if (sizeof(*(d->newlines)) == 1UL) {
      {
#line 2869
      tmp___7 = xmalloc((size_t )d->tralloc);
#line 2869
      d->newlines = (state_num *)tmp___7;
      }
    } else {
      {
#line 2869
      tmp___8 = xnmalloc((size_t )d->tralloc, sizeof(*(d->newlines)));
#line 2869
      d->newlines = (state_num *)tmp___8;
      }
    }
#line 2869
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2870
  build_state((state_num )0, d);
  }
#line 2871
  return;
}
}
#line 2898 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void realloc_trans_if_necessary(struct dfa *d , state_num new_state ) 
{ 
  state_num oldalloc ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  state_num tmp___5 ;

  {
#line 2903
  if (new_state >= d->tralloc) {
#line 2905
    oldalloc = d->tralloc;
    {
#line 2907
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2907
      if (! (new_state >= d->tralloc)) {
#line 2907
        goto while_break;
      }
#line 2908
      d->tralloc *= 2L;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2909
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2909
      tmp___1 = xnrealloc((void *)d->realtrans, (size_t )(d->tralloc + 1L), sizeof(*(d->realtrans)));
#line 2909
      d->realtrans = (state_num **)tmp___1;
      }
#line 2909
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2910
    d->trans = d->realtrans + 1;
    {
#line 2911
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2911
      tmp___2 = xnrealloc((void *)d->fails, (size_t )d->tralloc, sizeof(*(d->fails)));
#line 2911
      d->fails = (state_num **)tmp___2;
      }
#line 2911
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2912
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 2912
      tmp___3 = xnrealloc((void *)d->success, (size_t )d->tralloc, sizeof(*(d->success)));
#line 2912
      d->success = (int *)tmp___3;
      }
#line 2912
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2913
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 2913
      tmp___4 = xnrealloc((void *)d->newlines, (size_t )d->tralloc, sizeof(*(d->newlines)));
#line 2913
      d->newlines = (state_num *)tmp___4;
      }
#line 2913
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2914
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2914
      if (! (oldalloc < d->tralloc)) {
#line 2914
        goto while_break___4;
      }
#line 2916
      *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2917
      tmp___5 = oldalloc;
#line 2917
      oldalloc ++;
#line 2917
      *(d->fails + tmp___5) = (state_num *)((void *)0);
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 2920
  return;
}
}
#line 2935 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static status_transit_state transit_state_singlebyte(struct dfa *d , state_num s___0 ,
                                                     unsigned char const   *p , state_num *next_state ) 
{ 
  state_num *t ;
  state_num works ;
  status_transit_state rval ;

  {
#line 2940
  works = s___0;
#line 2942
  rval = (status_transit_state )0;
  {
#line 2944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2944
    if (! ((unsigned int )rval == 0U)) {
#line 2944
      goto while_break;
    }
#line 2946
    t = *(d->trans + works);
#line 2946
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 2948
      works = *(t + *p);
#line 2949
      rval = (status_transit_state )1;
#line 2950
      if (works < 0L) {
#line 2951
        works = (state_num )0;
      }
    } else
#line 2953
    if (works < 0L) {
#line 2955
      if ((unsigned long )p == (unsigned long )buf_end) {
        {
#line 2958
        abort();
        }
      }
#line 2960
      works = (state_num )0;
    } else
#line 2962
    if (*(d->fails + works)) {
#line 2964
      works = *(*(d->fails + works) + *p);
#line 2965
      rval = (status_transit_state )1;
    } else {
      {
#line 2969
      build_state(works, d);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2972
  *next_state = works;
#line 2973
  return (rval);
}
}
#line 2979 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int match_anychar(struct dfa *d , state_num s___0 , position pos , size_t idx___3 ) 
{ 
  int context ;
  wchar_t wc ;
  int mbclen ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 2986
  wc = *(inputwcs + idx___3);
#line 2987
  if ((int )*(mblen_buf + idx___3) == 0) {
#line 2987
    mbclen = 1;
  } else {
#line 2987
    mbclen = (int )*(mblen_buf + idx___3);
  }
#line 2990
  if (wc == (wchar_t )eolbyte) {
#line 2992
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2993
      return (0);
    }
  } else
#line 2995
  if (wc == 0) {
#line 2997
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2998
      return (0);
    }
  }
  {
#line 3001
  context = wchar_context((wint_t )wc);
  }
#line 3002
  if (context & 1) {
#line 3002
    tmp___1 = pos.constraint & 15U;
  } else {
#line 3002
    tmp___1 = 0U;
  }
#line 3002
  if (context & 2) {
#line 3002
    tmp___2 = (pos.constraint >> 4) & 15U;
  } else {
#line 3002
    tmp___2 = 0U;
  }
#line 3002
  if (context & 4) {
#line 3002
    tmp___3 = (pos.constraint >> 8) & 15U;
  } else {
#line 3002
    tmp___3 = 0U;
  }
#line 3002
  if (! (((tmp___1 | tmp___2) | tmp___3) & (unsigned int )(d->states + s___0)->context)) {
#line 3003
    return (0);
  }
#line 3005
  return (mbclen);
}
}
#line 3012 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int match_mb_charset(struct dfa *d , state_num s___0 , position pos , size_t idx___3 ) 
{ 
  size_t i___0 ;
  int match ;
  int match_len ;
  int op_len ;
  char buffer___0[128] ;
  struct mb_char_classes *work_mbc ;
  int context ;
  wchar_t wc ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp23 ;

  {
#line 3028
  wc = *(inputwcs + idx___3);
#line 3031
  if (wc == (wchar_t )eolbyte) {
#line 3033
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3034
      return (0);
    }
  } else
#line 3036
  if (wc == 0) {
#line 3038
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3039
      return (0);
    }
  }
  {
#line 3042
  context = wchar_context((wint_t )wc);
  }
#line 3043
  if (context & 1) {
#line 3043
    tmp___1 = pos.constraint & 15U;
  } else {
#line 3043
    tmp___1 = 0U;
  }
#line 3043
  if (context & 2) {
#line 3043
    tmp___2 = (pos.constraint >> 4) & 15U;
  } else {
#line 3043
    tmp___2 = 0U;
  }
#line 3043
  if (context & 4) {
#line 3043
    tmp___3 = (pos.constraint >> 8) & 15U;
  } else {
#line 3043
    tmp___3 = 0U;
  }
#line 3043
  if (! (((tmp___1 | tmp___2) | tmp___3) & (unsigned int )(d->states + s___0)->context)) {
#line 3044
    return (0);
  }
#line 3047
  work_mbc = d->mbcsets + (*(d->multibyte_prop + pos.index) >> 2);
#line 3048
  match = ! work_mbc->invert;
#line 3049
  if ((int )*(mblen_buf + idx___3) == 0) {
#line 3049
    match_len = 1;
  } else {
#line 3049
    match_len = (int )*(mblen_buf + idx___3);
  }
#line 3052
  if (wc < 1 << 8) {
#line 3052
    if (work_mbc->cset != -1L) {
      {
#line 3052
      tmp___4 = tstbit((unsigned int )((unsigned char )wc), (int */* const  */)(*(d->charclasses + work_mbc->cset)));
      }
#line 3052
      if (tmp___4) {
#line 3054
        goto charset_matched;
      }
    }
  }
#line 3057
  i___0 = (size_t )0;
  {
#line 3057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3057
    if (! (i___0 < work_mbc->nch_classes)) {
#line 3057
      goto while_break;
    }
    {
#line 3059
    tmp___5 = iswctype((wint_t )wc, *(work_mbc->ch_classes + i___0));
    }
#line 3059
    if (tmp___5) {
#line 3060
      goto charset_matched;
    }
#line 3057
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3063
  strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)((char const   *)buf_begin + idx___3),
          (size_t )match_len);
#line 3064
  buffer___0[match_len] = (char )'\000';
#line 3067
  i___0 = (size_t )0;
  }
  {
#line 3067
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3067
    if (! (i___0 < work_mbc->nequivs)) {
#line 3067
      goto while_break___0;
    }
    {
#line 3069
    tmp___6 = strlen((char const   *)*(work_mbc->equivs + i___0));
#line 3069
    op_len = (int )tmp___6;
#line 3070
    strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)((char const   *)buf_begin + idx___3),
            (size_t )op_len);
#line 3071
    buffer___0[op_len] = (char )'\000';
#line 3072
    tmp___7 = strcoll((char const   *)*(work_mbc->equivs + i___0), (char const   *)(buffer___0));
    }
#line 3072
    if (tmp___7 == 0) {
#line 3074
      match_len = op_len;
#line 3075
      goto charset_matched;
    }
#line 3067
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3080
  i___0 = (size_t )0;
  {
#line 3080
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3080
    if (! (i___0 < work_mbc->ncoll_elems)) {
#line 3080
      goto while_break___1;
    }
    {
#line 3082
    tmp___8 = strlen((char const   *)*(work_mbc->coll_elems + i___0));
#line 3082
    op_len = (int )tmp___8;
#line 3083
    strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)((char const   *)buf_begin + idx___3),
            (size_t )op_len);
#line 3084
    buffer___0[op_len] = (char )'\000';
#line 3086
    tmp___9 = strcoll((char const   *)*(work_mbc->coll_elems + i___0), (char const   *)(buffer___0));
    }
#line 3086
    if (tmp___9 == 0) {
#line 3088
      match_len = op_len;
#line 3089
      goto charset_matched;
    }
#line 3080
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3094
  i___0 = (size_t )0;
  {
#line 3094
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3094
    if (! (i___0 < work_mbc->nranges)) {
#line 3094
      goto while_break___2;
    }
#line 3096
    if (*(work_mbc->range_sts + i___0) <= wc) {
#line 3096
      if (wc <= *(work_mbc->range_ends + i___0)) {
#line 3097
        goto charset_matched;
      }
    }
#line 3094
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3101
  i___0 = (size_t )0;
  {
#line 3101
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3101
    if (! (i___0 < work_mbc->nchars)) {
#line 3101
      goto while_break___3;
    }
#line 3103
    if (wc == *(work_mbc->chars + i___0)) {
#line 3104
      goto charset_matched;
    }
#line 3101
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3107
  match = ! match;
  charset_matched: 
#line 3110
  if (match) {
#line 3110
    tmp___10 = match_len;
  } else {
#line 3110
    tmp___10 = 0;
  }
#line 3110
  return (tmp___10);
}
}
#line 3120 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static int *check_matching_with_multibyte_ops(struct dfa *d , state_num s___0 , size_t idx___3 ) 
{ 
  size_t i___0 ;
  int *rarray ;
  void *tmp___1 ;
  void *tmp___2 ;
  position pos ;
  void *__cil_tmp9 ;

  {
  {
#line 3126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3126
    if (sizeof(*rarray) == 1UL) {
      {
#line 3126
      tmp___1 = xmalloc((d->states + s___0)->mbps.nelem);
#line 3126
      rarray = (int *)tmp___1;
      }
    } else {
      {
#line 3126
      tmp___2 = xnmalloc((d->states + s___0)->mbps.nelem, sizeof(*rarray));
#line 3126
      rarray = (int *)tmp___2;
      }
    }
#line 3126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3127
  i___0 = (size_t )0;
  {
#line 3127
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3127
    if (! (i___0 < (d->states + s___0)->mbps.nelem)) {
#line 3127
      goto while_break___0;
    }
#line 3129
    pos = *((d->states + s___0)->mbps.elems + i___0);
    {
#line 3132
    if (*(d->tokens + pos.index) == 272L) {
#line 3132
      goto case_272;
    }
#line 3135
    if (*(d->tokens + pos.index) == 273L) {
#line 3135
      goto case_273;
    }
#line 3138
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3133
    *(rarray + i___0) = match_anychar(d, s___0, pos, idx___3);
    }
#line 3134
    goto switch_break;
    case_273: /* CIL Label */ 
    {
#line 3136
    *(rarray + i___0) = match_mb_charset(d, s___0, pos, idx___3);
    }
#line 3137
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3139
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3127
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3142
  return (rarray);
}
}
#line 3151 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static status_transit_state transit_state_consume_1char(struct dfa *d , state_num s___0 ,
                                                        unsigned char const   **pp ,
                                                        int *match_lens , int *mbclen ,
                                                        position_set *pps ) 
{ 
  size_t i___0 ;
  size_t j ;
  int k ;
  state_num s1 ;
  state_num s2 ;
  int *work_mbls ;
  status_transit_state rs ;
  unsigned char const   *tmp___1 ;

  {
#line 3160
  rs = (status_transit_state )1;
#line 3164
  if ((int )*(mblen_buf + (*pp - buf_begin)) == 0) {
#line 3164
    *mbclen = 1;
  } else {
#line 3164
    *mbclen = (int )*(mblen_buf + (*pp - buf_begin));
  }
#line 3168
  s1 = s___0;
#line 3169
  k = 0;
  {
#line 3169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3169
    if (! (k < *mbclen)) {
#line 3169
      goto while_break;
    }
    {
#line 3171
    s2 = s1;
#line 3172
    tmp___1 = *pp;
#line 3172
    (*pp) ++;
#line 3172
    rs = transit_state_singlebyte(d, s2, tmp___1, & s1);
#line 3169
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3175
  copy((position_set const   *)(& (d->states + s1)->elems), pps);
  }
#line 3178
  if ((unsigned long )match_lens == (unsigned long )((void *)0)) {
#line 3178
    if ((d->states + s___0)->mbps.nelem != 0UL) {
      {
#line 3179
      work_mbls = check_matching_with_multibyte_ops(d, s___0, (size_t )(*pp - buf_begin));
      }
    } else {
#line 3181
      work_mbls = match_lens;
    }
  } else {
#line 3181
    work_mbls = match_lens;
  }
#line 3185
  i___0 = (size_t )0;
  {
#line 3185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3185
    if (! (i___0 < (d->states + s___0)->mbps.nelem)) {
#line 3185
      goto while_break___0;
    }
#line 3187
    if (*(work_mbls + i___0) == *mbclen) {
#line 3188
      j = (size_t )0;
      {
#line 3188
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3188
        if (! (j < (d->follows + ((d->states + s___0)->mbps.elems + i___0)->index)->nelem)) {
#line 3188
          goto while_break___1;
        }
        {
#line 3190
        insert(*((d->follows + ((d->states + s___0)->mbps.elems + i___0)->index)->elems + j),
               pps);
#line 3188
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 3185
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3193
  if ((unsigned long )match_lens == (unsigned long )((void *)0)) {
#line 3193
    if ((unsigned long )work_mbls != (unsigned long )((void *)0)) {
      {
#line 3194
      free((void *)work_mbls);
      }
    }
  }
#line 3197
  return (rs);
}
}
#line 3203 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static state_num transit_state___0(struct dfa *d , state_num s___0 , unsigned char const   **pp ) 
{ 
  state_num s1 ;
  int mbclen ;
  int maxlen ;
  size_t i___0 ;
  size_t j ;
  int *match_lens ;
  size_t nelem ;
  position_set follows ;
  unsigned char const   *p1 ;
  wchar_t wc ;
  status_transit_state rs ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp17 ;

  {
#line 3208
  maxlen = 0;
#line 3210
  match_lens = (int *)((void *)0);
#line 3211
  nelem = (d->states + s___0)->mbps.nelem;
#line 3213
  p1 = *pp;
#line 3216
  if (nelem > 0UL) {
    {
#line 3221
    match_lens = check_matching_with_multibyte_ops(d, s___0, (size_t )(*pp - buf_begin));
#line 3223
    i___0 = (size_t )0;
    }
    {
#line 3223
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3223
      if (! (i___0 < nelem)) {
#line 3223
        goto while_break;
      }
#line 3227
      if (*(match_lens + i___0) > maxlen) {
#line 3228
        maxlen = *(match_lens + i___0);
      }
#line 3223
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3232
  if (nelem == 0UL) {
#line 3232
    goto _L;
  } else
#line 3232
  if (maxlen == 0) {
    _L: /* CIL Label */ 
    {
#line 3237
    rs = transit_state_singlebyte(d, s___0, *pp, & s1);
    }
#line 3240
    if ((unsigned int )rs == 1U) {
#line 3241
      (*pp) ++;
    }
    {
#line 3243
    free((void *)match_lens);
    }
#line 3244
    return (s1);
  }
  {
#line 3248
  alloc_position_set(& follows, d->nleaves);
#line 3254
  transit_state_consume_1char(d, s___0, pp, match_lens, & mbclen, & follows);
#line 3256
  wc = *(inputwcs + ((*pp - mbclen) - buf_begin));
#line 3257
  tmp___1 = wchar_context((wint_t )wc);
#line 3257
  s1 = state_index(d, (position_set const   *)(& follows), tmp___1);
#line 3258
  realloc_trans_if_necessary(d, s1);
  }
  {
#line 3260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3260
    if (! (*pp - p1 < (long )maxlen)) {
#line 3260
      goto while_break___0;
    }
    {
#line 3262
    transit_state_consume_1char(d, s1, pp, (int *)((void *)0), & mbclen, & follows);
#line 3264
    i___0 = (size_t )0;
    }
    {
#line 3264
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3264
      if (! (i___0 < nelem)) {
#line 3264
        goto while_break___1;
      }
#line 3266
      if ((long )*(match_lens + i___0) == *pp - p1) {
#line 3267
        j = (size_t )0;
        {
#line 3267
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3267
          if (! (j < (d->follows + ((d->states + s1)->mbps.elems + i___0)->index)->nelem)) {
#line 3267
            goto while_break___2;
          }
          {
#line 3269
          insert(*((d->follows + ((d->states + s1)->mbps.elems + i___0)->index)->elems + j),
                 & follows);
#line 3267
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 3264
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3273
    wc = *(inputwcs + ((*pp - mbclen) - buf_begin));
#line 3274
    tmp___2 = wchar_context((wint_t )wc);
#line 3274
    s1 = state_index(d, (position_set const   *)(& follows), tmp___2);
#line 3275
    realloc_trans_if_necessary(d, s1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3277
  free((void *)match_lens);
#line 3278
  free((void *)follows.elems);
  }
#line 3279
  return (s1);
}
}
#line 3285 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void prepare_wc_buf(char const   *begin , char const   *end ) 
{ 
  unsigned char eol ;
  size_t remain_bytes ;
  size_t i___0 ;

  {
#line 3289
  eol = eolbyte;
#line 3292
  buf_begin = (unsigned char const   *)((unsigned char *)begin);
#line 3294
  remain_bytes = (size_t )0;
#line 3295
  i___0 = (size_t )0;
  {
#line 3295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3295
    if (! (i___0 < (size_t )((end - begin) + 1L))) {
#line 3295
      goto while_break;
    }
#line 3297
    if (remain_bytes == 0UL) {
      {
#line 3299
      remain_bytes = mbrtowc((wchar_t */* __restrict  */)(inputwcs + i___0), (char const   */* __restrict  */)(begin + i___0),
                             ((size_t )(end - begin) - i___0) + 1UL, & mbs);
      }
#line 3301
      if (remain_bytes < 1UL) {
#line 3301
        goto _L;
      } else
#line 3301
      if (remain_bytes == 0xffffffffffffffffUL) {
#line 3301
        goto _L;
      } else
#line 3301
      if (remain_bytes == 0xfffffffffffffffeUL) {
#line 3301
        goto _L;
      } else
#line 3301
      if (remain_bytes == 1UL) {
#line 3301
        if (*(inputwcs + i___0) == (wchar_t )*(begin + i___0)) {
          _L: /* CIL Label */ 
#line 3306
          remain_bytes = (size_t )0;
#line 3307
          *(inputwcs + i___0) = (wchar_t )*(begin + i___0);
#line 3308
          *(mblen_buf + i___0) = (unsigned char)0;
#line 3309
          if ((int const   )*(begin + i___0) == (int const   )eol) {
#line 3310
            goto while_break;
          }
        } else {
#line 3314
          *(mblen_buf + i___0) = (unsigned char )remain_bytes;
#line 3315
          remain_bytes --;
        }
      } else {
#line 3314
        *(mblen_buf + i___0) = (unsigned char )remain_bytes;
#line 3315
        remain_bytes --;
      }
    } else {
#line 3320
      *(mblen_buf + i___0) = (unsigned char )remain_bytes;
#line 3321
      *(inputwcs + i___0) = 0;
#line 3322
      remain_bytes --;
    }
#line 3295
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3326
  buf_end = (unsigned char const   *)((unsigned char *)(begin + i___0));
#line 3327
  *(mblen_buf + i___0) = (unsigned char)0;
#line 3328
  *(inputwcs + i___0) = 0;
#line 3330
  return;
}
}
#line 3344 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
char *dfaexec(struct dfa *d , char const   *begin , char *end , int allow_nl , size_t *count ,
              int *backref ) 
{ 
  state_num s___0 ;
  state_num s1 ;
  unsigned char const   *p ;
  state_num **trans ;
  state_num *t ;
  unsigned char eol ;
  unsigned char saved_end ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  state_num tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char const   *tmp___9 ;

  {
#line 3352
  eol = eolbyte;
#line 3355
  if (! d->tralloc) {
    {
#line 3356
    build_state_zero(d);
    }
  }
#line 3358
  s1 = (state_num )0;
#line 3358
  s___0 = s1;
#line 3359
  p = (unsigned char const   *)begin;
#line 3360
  trans = d->trans;
#line 3361
  saved_end = *((unsigned char *)end);
#line 3362
  *end = (char )eol;
#line 3364
  if (d->mb_cur_max > 1U) {
    {
#line 3366
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3366
      if (sizeof(*mblen_buf) == 1UL) {
        {
#line 3366
        tmp___1 = xmalloc((size_t )((end - (char *)begin) + 2L));
#line 3366
        mblen_buf = (unsigned char *)tmp___1;
        }
      } else {
        {
#line 3366
        tmp___2 = xnmalloc((size_t )((end - (char *)begin) + 2L), sizeof(*mblen_buf));
#line 3366
        mblen_buf = (unsigned char *)tmp___2;
        }
      }
#line 3366
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3367
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3367
      if (sizeof(*inputwcs) == 1UL) {
        {
#line 3367
        tmp___3 = xmalloc((size_t )((end - (char *)begin) + 2L));
#line 3367
        inputwcs = (wchar_t *)tmp___3;
        }
      } else {
        {
#line 3367
        tmp___4 = xnmalloc((size_t )((end - (char *)begin) + 2L), sizeof(*inputwcs));
#line 3367
        inputwcs = (wchar_t *)tmp___4;
        }
      }
#line 3367
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3368
    memset((void *)(& mbs), 0, sizeof(mbstate_t ));
#line 3369
    prepare_wc_buf((char const   *)p, (char const   *)end);
    }
  }
  {
#line 3372
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3374
    if (d->mb_cur_max > 1U) {
      {
#line 3375
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3375
        t = *(trans + s___0);
#line 3375
        if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3375
          goto while_break___2;
        }
#line 3377
        if ((unsigned long )p > (unsigned long )buf_end) {
#line 3378
          goto while_break___2;
        }
#line 3379
        s1 = s___0;
#line 3380
        if (s___0 == 0L) {
          {
#line 3380
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3380
            if (*(inputwcs + (p - buf_begin)) == 0) {
#line 3380
              if ((int )*(mblen_buf + (p - buf_begin)) > 0) {
#line 3380
                if (! ((unsigned long )p < (unsigned long )buf_end)) {
#line 3380
                  goto while_break___3;
                }
              } else {
#line 3380
                goto while_break___3;
              }
            } else {
#line 3380
              goto while_break___3;
            }
#line 3380
            p ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 3380
          if ((unsigned long )((char *)p) >= (unsigned long )end) {
            {
#line 3380
            free((void *)mblen_buf);
#line 3380
            free((void *)inputwcs);
#line 3380
            *end = (char )saved_end;
            }
#line 3380
            return ((char *)((void *)0));
          }
        }
#line 3382
        if ((d->states + s___0)->mbps.nelem == 0UL) {
#line 3384
          tmp___5 = p;
#line 3384
          p ++;
#line 3384
          s___0 = *(t + *tmp___5);
#line 3385
          goto while_continue___2;
        }
#line 3392
        if (backref) {
          {
#line 3394
          *backref = 1;
#line 3395
          free((void *)mblen_buf);
#line 3396
          free((void *)inputwcs);
#line 3397
          *end = (char )saved_end;
          }
#line 3398
          return ((char *)p);
        }
        {
#line 3403
        s___0 = transit_state___0(d, s___0, & p);
#line 3404
        trans = d->trans;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 3408
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3408
        t = *(trans + s___0);
#line 3408
        if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3408
          goto while_break___4;
        }
#line 3410
        tmp___6 = p;
#line 3410
        p ++;
#line 3410
        s1 = *(t + *tmp___6);
#line 3411
        t = *(trans + s1);
#line 3411
        if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 3413
          tmp___7 = s___0;
#line 3414
          s___0 = s1;
#line 3415
          s1 = tmp___7;
#line 3416
          goto while_break___4;
        }
#line 3418
        tmp___8 = p;
#line 3418
        p ++;
#line 3418
        s___0 = *(t + *tmp___8);
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 3422
    if (s___0 >= 0L) {
#line 3422
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3422
        if (*(d->fails + s___0)) {
#line 3424
          if (*(d->success + s___0) & sbit[*p]) {
#line 3426
            if (backref) {
#line 3427
              *backref = (int )(d->states + s___0)->backref != 0;
            }
#line 3428
            if (d->mb_cur_max > 1U) {
              {
#line 3430
              free((void *)mblen_buf);
#line 3431
              free((void *)inputwcs);
              }
            }
#line 3433
            *end = (char )saved_end;
#line 3434
            return ((char *)p);
          }
#line 3437
          s1 = s___0;
#line 3438
          if (d->mb_cur_max > 1U) {
            {
#line 3442
            s___0 = transit_state___0(d, s___0, & p);
#line 3443
            trans = d->trans;
            }
          } else {
#line 3446
            tmp___9 = p;
#line 3446
            p ++;
#line 3446
            s___0 = *(*(d->fails + s___0) + *tmp___9);
          }
#line 3447
          goto __Cont;
        }
      }
    }
#line 3451
    if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3451
      if ((int const   )*(p + -1) == (int const   )eol) {
#line 3453
        if (count) {
#line 3454
          (*count) ++;
        }
#line 3456
        if (d->mb_cur_max > 1U) {
          {
#line 3457
          prepare_wc_buf((char const   *)p, (char const   *)end);
          }
        }
      }
    }
#line 3461
    if ((unsigned long )((char *)p) > (unsigned long )end) {
#line 3463
      if (d->mb_cur_max > 1U) {
        {
#line 3465
        free((void *)mblen_buf);
#line 3466
        free((void *)inputwcs);
        }
      }
#line 3468
      *end = (char )saved_end;
#line 3469
      return ((char *)((void *)0));
    }
#line 3472
    if (s___0 >= 0L) {
      {
#line 3474
      build_state(s___0, d);
#line 3475
      trans = d->trans;
      }
#line 3476
      goto __Cont;
    }
#line 3479
    if ((int const   )*(p + -1) == (int const   )eol) {
#line 3479
      if (allow_nl) {
#line 3481
        s___0 = *(d->newlines + s1);
#line 3482
        goto __Cont;
      }
    }
#line 3485
    s___0 = (state_num )0;
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 3489 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void free_mbdata(struct dfa *d ) 
{ 
  size_t i___0 ;
  size_t j ;
  struct mb_char_classes *p ;

  {
  {
#line 3494
  free((void *)d->multibyte_prop);
#line 3495
  d->multibyte_prop = (int *)((void *)0);
#line 3497
  i___0 = (size_t )0;
  }
  {
#line 3497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3497
    if (! (i___0 < d->nmbcsets)) {
#line 3497
      goto while_break;
    }
    {
#line 3500
    p = d->mbcsets + i___0;
#line 3501
    free((void *)p->chars);
#line 3502
    free((void *)p->ch_classes);
#line 3503
    free((void *)p->range_sts);
#line 3504
    free((void *)p->range_ends);
#line 3506
    j = (size_t )0;
    }
    {
#line 3506
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3506
      if (! (j < p->nequivs)) {
#line 3506
        goto while_break___0;
      }
      {
#line 3507
      free((void *)*(p->equivs + j));
#line 3506
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3508
    free((void *)p->equivs);
#line 3510
    j = (size_t )0;
    }
    {
#line 3510
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3510
      if (! (j < p->ncoll_elems)) {
#line 3510
        goto while_break___1;
      }
      {
#line 3511
      free((void *)*(p->coll_elems + j));
#line 3510
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3512
    free((void *)p->coll_elems);
#line 3497
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3515
  free((void *)d->mbcsets);
#line 3516
  d->mbcsets = (struct mb_char_classes *)((void *)0);
#line 3517
  d->nmbcsets = (size_t )0;
  }
#line 3518
  return;
}
}
#line 3522 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
void dfainit(struct dfa *d ) 
{ 
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 3525
  memset((void *)d, 0, sizeof(*d));
#line 3527
  d->calloc = (size_t )1;
  }
  {
#line 3528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3528
    if (sizeof(*(d->charclasses)) == 1UL) {
      {
#line 3528
      tmp___1 = xmalloc(d->calloc);
#line 3528
      d->charclasses = (charclass *)tmp___1;
      }
    } else {
      {
#line 3528
      tmp___2 = xnmalloc(d->calloc, sizeof(*(d->charclasses)));
#line 3528
      d->charclasses = (charclass *)tmp___2;
      }
    }
#line 3528
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3530
  d->talloc = (size_t )1;
  {
#line 3531
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3531
    if (sizeof(*(d->tokens)) == 1UL) {
      {
#line 3531
      tmp___3 = xmalloc(d->talloc);
#line 3531
      d->tokens = (token *)tmp___3;
      }
    } else {
      {
#line 3531
      tmp___4 = xnmalloc(d->talloc, sizeof(*(d->tokens)));
#line 3531
      d->tokens = (token *)tmp___4;
      }
    }
#line 3531
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3533
  tmp___5 = __ctype_get_mb_cur_max();
#line 3533
  d->mb_cur_max = (unsigned int )tmp___5;
  }
#line 3535
  if (d->mb_cur_max > 1U) {
#line 3537
    d->nmultibyte_prop = (size_t )1;
    {
#line 3538
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3538
      if (sizeof(*(d->multibyte_prop)) == 1UL) {
        {
#line 3538
        tmp___6 = xmalloc(d->nmultibyte_prop);
#line 3538
        d->multibyte_prop = (int *)tmp___6;
        }
      } else {
        {
#line 3538
        tmp___7 = xnmalloc(d->nmultibyte_prop, sizeof(*(d->multibyte_prop)));
#line 3538
        d->multibyte_prop = (int *)tmp___7;
        }
      }
#line 3538
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3539
    d->mbcsets_alloc = (size_t )1;
    {
#line 3540
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3540
      if (sizeof(*(d->mbcsets)) == 1UL) {
        {
#line 3540
        tmp___8 = xmalloc(d->mbcsets_alloc);
#line 3540
        d->mbcsets = (struct mb_char_classes *)tmp___8;
        }
      } else {
        {
#line 3540
        tmp___9 = xnmalloc(d->mbcsets_alloc, sizeof(*(d->mbcsets)));
#line 3540
        d->mbcsets = (struct mb_char_classes *)tmp___9;
        }
      }
#line 3540
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 3542
  return;
}
}
#line 3544 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void dfaoptimize(struct dfa *d ) 
{ 
  size_t i___0 ;
  int tmp___1 ;

  {
  {
#line 3549
  tmp___1 = using_utf8();
  }
#line 3549
  if (! tmp___1) {
#line 3550
    return;
  }
#line 3552
  i___0 = (size_t )0;
  {
#line 3552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3552
    if (! (i___0 < d->tindex)) {
#line 3552
      goto while_break;
    }
    {
#line 3556
    if (*(d->tokens + i___0) == 272L) {
#line 3556
      goto case_272;
    }
#line 3559
    if (*(d->tokens + i___0) == 273L) {
#line 3559
      goto case_273;
    }
#line 3562
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3558
    abort();
    }
    case_273: /* CIL Label */ 
#line 3561
    return;
    switch_default: /* CIL Label */ 
#line 3563
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3552
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3567
  free_mbdata(d);
#line 3568
  d->mb_cur_max = 1U;
  }
#line 3569
  return;
}
}
#line 3572 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
void dfacomp(char const   *s___0 , size_t len , struct dfa *d , int searchflag ) 
{ 


  {
  {
#line 3575
  dfainit(d);
#line 3576
  dfaparse(s___0, len, d);
#line 3577
  dfamust(d);
#line 3578
  dfaoptimize(d);
#line 3579
  dfaanalyze(d, searchflag);
  }
#line 3580
  return;
}
}
#line 3583 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
void dfafree(struct dfa *d ) 
{ 
  size_t i___0 ;
  struct dfamust *dm ;
  struct dfamust *ndm ;

  {
  {
#line 3589
  free((void *)d->charclasses);
#line 3590
  free((void *)d->tokens);
  }
#line 3592
  if (d->mb_cur_max > 1U) {
    {
#line 3593
    free_mbdata(d);
    }
  }
#line 3595
  i___0 = (size_t )0;
  {
#line 3595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3595
    if (! (i___0 < (size_t )d->sindex)) {
#line 3595
      goto while_break;
    }
    {
#line 3597
    free((void *)(d->states + i___0)->elems.elems);
#line 3599
    free((void *)(d->states + i___0)->mbps.elems);
#line 3595
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3601
  free((void *)d->states);
#line 3602
  i___0 = (size_t )0;
  }
  {
#line 3602
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3602
    if (! (i___0 < d->tindex)) {
#line 3602
      goto while_break___0;
    }
    {
#line 3603
    free((void *)(d->follows + i___0)->elems);
#line 3602
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3604
  free((void *)d->follows);
#line 3605
  i___0 = (size_t )0;
  }
  {
#line 3605
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3605
    if (! (i___0 < (size_t )d->tralloc)) {
#line 3605
      goto while_break___1;
    }
    {
#line 3607
    free((void *)*(d->trans + i___0));
#line 3608
    free((void *)*(d->fails + i___0));
#line 3605
    i___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3610
  free((void *)d->realtrans);
#line 3611
  free((void *)d->fails);
#line 3612
  free((void *)d->newlines);
#line 3613
  free((void *)d->success);
#line 3614
  dm = d->musts;
  }
  {
#line 3614
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3614
    if (! dm) {
#line 3614
      goto while_break___2;
    }
    {
#line 3616
    ndm = dm->next;
#line 3617
    free((void *)dm->must);
#line 3618
    free((void *)dm);
#line 3614
    dm = ndm;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3620
  return;
}
}
#line 3706 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static char *icatalloc(char *old , char const   *new ) 
{ 
  char *result ;
  size_t oldsize ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t newsize ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 3710
  if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 3710
    tmp___2 = (size_t )0;
  } else {
    {
#line 3710
    tmp___1 = strlen((char const   *)old);
#line 3710
    tmp___2 = tmp___1;
    }
  }
#line 3710
  oldsize = tmp___2;
#line 3711
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 3711
    tmp___4 = (size_t )0;
  } else {
    {
#line 3711
    tmp___3 = strlen(new);
#line 3711
    tmp___4 = tmp___3;
    }
  }
#line 3711
  newsize = tmp___4;
#line 3712
  if (newsize == 0UL) {
#line 3713
    return (old);
  }
  {
#line 3714
  tmp___5 = xrealloc((void *)old, (oldsize + newsize) + 1UL);
#line 3714
  result = (char *)tmp___5;
#line 3715
  memcpy((void */* __restrict  */)(result + oldsize), (void const   */* __restrict  */)new,
         newsize + 1UL);
  }
#line 3716
  return (result);
}
}
#line 3719 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static char *icpyalloc(char const   *string ) 
{ 
  char *tmp___1 ;

  {
  {
#line 3722
  tmp___1 = icatalloc((char *)((void *)0), string);
  }
#line 3722
  return (tmp___1);
}
}
#line 3725 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static char * __attribute__((__pure__)) istrstr(char const   *lookin , char const   *lookfor ) 
{ 
  char const   *cp ;
  size_t len ;
  int tmp___1 ;

  {
  {
#line 3731
  len = strlen(lookfor);
#line 3732
  cp = lookin;
  }
  {
#line 3732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3732
    if (! ((int const   )*cp != 0)) {
#line 3732
      goto while_break;
    }
    {
#line 3733
    tmp___1 = strncmp(cp, lookfor, len);
    }
#line 3733
    if (tmp___1 == 0) {
#line 3734
      return ((char */* __attribute__((__pure__)) */)((char *)cp));
    }
#line 3732
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3735
  return ((char */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 3738 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void freelist(char **cpp ) 
{ 
  size_t i___0 ;

  {
#line 3743
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3744
    return;
  }
#line 3745
  i___0 = (size_t )0;
  {
#line 3745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3745
    if (! ((unsigned long )*(cpp + i___0) != (unsigned long )((void *)0))) {
#line 3745
      goto while_break;
    }
    {
#line 3747
    free((void *)*(cpp + i___0));
#line 3748
    *(cpp + i___0) = (char *)((void *)0);
#line 3745
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3750
  return;
}
}
#line 3752 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static char **enlist(char **cpp , char *new , size_t len ) 
{ 
  size_t i___0 ;
  size_t j ;
  char * __attribute__((__pure__)) tmp___1 ;
  char * __attribute__((__pure__)) tmp___2 ;
  void *tmp___3 ;

  {
#line 3757
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3758
    return ((char **)((void *)0));
  }
  {
#line 3759
  new = icpyalloc((char const   *)new);
  }
#line 3759
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
#line 3761
    freelist(cpp);
    }
#line 3762
    return ((char **)((void *)0));
  }
#line 3764
  *(new + len) = (char )'\000';
#line 3766
  i___0 = (size_t )0;
  {
#line 3766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3766
    if (! ((unsigned long )*(cpp + i___0) != (unsigned long )((void *)0))) {
#line 3766
      goto while_break;
    }
    {
#line 3767
    tmp___1 = istrstr((char const   *)*(cpp + i___0), (char const   *)new);
    }
#line 3767
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 3769
      free((void *)new);
      }
#line 3770
      return (cpp);
    }
#line 3766
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3773
  j = (size_t )0;
  {
#line 3774
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3774
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3774
      goto while_break___0;
    }
    {
#line 3775
    tmp___2 = istrstr((char const   *)new, (char const   *)*(cpp + j));
    }
#line 3775
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3776
      j ++;
    } else {
      {
#line 3779
      free((void *)*(cpp + j));
#line 3780
      i___0 --;
      }
#line 3780
      if (i___0 == j) {
#line 3781
        goto while_break___0;
      }
#line 3782
      *(cpp + j) = *(cpp + i___0);
#line 3783
      *(cpp + i___0) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3786
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 3786
    tmp___3 = xnrealloc((void *)cpp, i___0 + 2UL, sizeof(*cpp));
#line 3786
    cpp = (char **)tmp___3;
    }
#line 3786
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3787
  *(cpp + i___0) = new;
#line 3788
  *(cpp + (i___0 + 1UL)) = (char *)((void *)0);
#line 3789
  return (cpp);
}
}
#line 3795 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static char **comsubs(char *left , char const   *right ) 
{ 
  char **cpp ;
  char *lcp ;
  char *rcp ;
  size_t i___0 ;
  size_t len ;
  void *tmp___1 ;
  char **p ;
  char **tmp___2 ;

  {
#line 3803
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 3804
    return ((char **)((void *)0));
  } else
#line 3803
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 3804
    return ((char **)((void *)0));
  }
  {
#line 3805
  tmp___1 = malloc(sizeof(*cpp));
#line 3805
  cpp = (char **)tmp___1;
  }
#line 3806
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3807
    return ((char **)((void *)0));
  }
#line 3808
  *(cpp + 0) = (char *)((void *)0);
#line 3809
  lcp = left;
  {
#line 3809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3809
    if (! ((int )*lcp != 0)) {
#line 3809
      goto while_break;
    }
    {
#line 3811
    len = (size_t )0;
#line 3812
    rcp = strchr(right, (int )*lcp);
    }
    {
#line 3813
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3813
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3813
        goto while_break___0;
      }
#line 3815
      i___0 = (size_t )1;
      {
#line 3815
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3815
        if ((int )*(lcp + i___0) != 0) {
#line 3815
          if (! ((int )*(lcp + i___0) == (int )*(rcp + i___0))) {
#line 3815
            goto while_break___1;
          }
        } else {
#line 3815
          goto while_break___1;
        }
#line 3816
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 3815
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3817
      if (i___0 > len) {
#line 3818
        len = i___0;
      }
      {
#line 3819
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3821
    if (len == 0UL) {
#line 3822
      goto __Cont___0;
    }
    {
#line 3824
    tmp___2 = enlist(cpp, lcp, len);
#line 3824
    p = tmp___2;
    }
#line 3825
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 3827
      freelist(cpp);
#line 3828
      cpp = (char **)((void *)0);
      }
#line 3829
      goto while_break;
    }
#line 3831
    cpp = p;
    __Cont___0: /* CIL Label */ 
#line 3809
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3834
  return (cpp);
}
}
#line 3837 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static char **addlists(char **old , char **new ) 
{ 
  size_t i___0 ;
  size_t tmp___1 ;

  {
#line 3842
  if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 3843
    return ((char **)((void *)0));
  } else
#line 3842
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 3843
    return ((char **)((void *)0));
  }
#line 3844
  i___0 = (size_t )0;
  {
#line 3844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3844
    if (! ((unsigned long )*(new + i___0) != (unsigned long )((void *)0))) {
#line 3844
      goto while_break;
    }
    {
#line 3846
    tmp___1 = strlen((char const   *)*(new + i___0));
#line 3846
    old = enlist(old, *(new + i___0), tmp___1);
    }
#line 3847
    if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 3848
      goto while_break;
    }
#line 3844
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3850
  return (old);
}
}
#line 3855 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static char **inboth(char **left , char **right ) 
{ 
  char **both ;
  char **temp ;
  size_t lnum ;
  size_t rnum ;
  void *tmp___1 ;

  {
#line 3862
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 3863
    return ((char **)((void *)0));
  } else
#line 3862
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 3863
    return ((char **)((void *)0));
  }
  {
#line 3864
  tmp___1 = malloc(sizeof(*both));
#line 3864
  both = (char **)tmp___1;
  }
#line 3865
  if ((unsigned long )both == (unsigned long )((void *)0)) {
#line 3866
    return ((char **)((void *)0));
  }
#line 3867
  *(both + 0) = (char *)((void *)0);
#line 3868
  lnum = (size_t )0;
  {
#line 3868
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3868
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3868
      goto while_break;
    }
#line 3870
    rnum = (size_t )0;
    {
#line 3870
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3870
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3870
        goto while_break___0;
      }
      {
#line 3872
      temp = comsubs(*(left + lnum), (char const   *)*(right + rnum));
      }
#line 3873
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        {
#line 3875
        freelist(both);
        }
#line 3876
        return ((char **)((void *)0));
      }
      {
#line 3878
      both = addlists(both, temp);
#line 3879
      freelist(temp);
#line 3880
      free((void *)temp);
      }
#line 3881
      if ((unsigned long )both == (unsigned long )((void *)0)) {
#line 3882
        return ((char **)((void *)0));
      }
#line 3870
      rnum ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3868
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3885
  return (both);
}
}
#line 3896 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void resetmust(must *mp ) 
{ 
  char tmp___1 ;
  char tmp___2 ;

  {
  {
#line 3899
  tmp___2 = (char )'\000';
#line 3899
  *(mp->is + 0) = tmp___2;
#line 3899
  tmp___1 = tmp___2;
#line 3899
  *(mp->right + 0) = tmp___1;
#line 3899
  *(mp->left + 0) = tmp___1;
#line 3900
  freelist(mp->in);
  }
#line 3901
  return;
}
}
#line 3913 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static must must0  ;
#line 3915 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static char empty_string[1]  = {      (char )'\000'};
#line 3903 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
static void dfamust(struct dfa *d ) 
{ 
  must *musts ;
  must *mp ;
  char *result ;
  size_t ri ;
  size_t i___0 ;
  int exact___0 ;
  token t ;
  struct dfamust *dm ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char tmp___7 ;
  char tmp___8 ;
  char **new ;
  must *lmp ;
  must *rmp ;
  size_t j ;
  size_t ln ;
  size_t rn ;
  size_t n ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  must *lmp___0 ;
  must *rmp___0 ;
  char *tp ;
  size_t tmp___13 ;
  char tmp___14 ;
  char tmp___15 ;
  char tmp___16 ;
  char tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  size_t tmp___22 ;

  {
#line 3917
  result = empty_string;
#line 3918
  exact___0 = 0;
  {
#line 3919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3919
    if (sizeof(*musts) == 1UL) {
      {
#line 3919
      tmp___1 = xmalloc(d->tindex + 1UL);
#line 3919
      musts = (must *)tmp___1;
      }
    } else {
      {
#line 3919
      tmp___2 = xnmalloc(d->tindex + 1UL, sizeof(*musts));
#line 3919
      musts = (must *)tmp___2;
      }
    }
#line 3919
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3920
  mp = musts;
#line 3921
  i___0 = (size_t )0;
  {
#line 3921
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3921
    if (! (i___0 <= d->tindex)) {
#line 3921
      goto while_break___0;
    }
#line 3922
    *(mp + i___0) = must0;
#line 3921
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3923
  i___0 = (size_t )0;
  {
#line 3923
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3923
    if (! (i___0 <= d->tindex)) {
#line 3923
      goto while_break___1;
    }
    {
#line 3925
    tmp___3 = xmalloc(sizeof(*((mp + i___0)->in)));
#line 3925
    (mp + i___0)->in = (char **)tmp___3;
#line 3926
    tmp___4 = xmalloc((size_t )2);
#line 3926
    (mp + i___0)->left = (char *)tmp___4;
#line 3927
    tmp___5 = xmalloc((size_t )2);
#line 3927
    (mp + i___0)->right = (char *)tmp___5;
#line 3928
    tmp___6 = xmalloc((size_t )2);
#line 3928
    (mp + i___0)->is = (char *)tmp___6;
#line 3929
    tmp___8 = (char )'\000';
#line 3929
    *((mp + i___0)->is + 0) = tmp___8;
#line 3929
    tmp___7 = tmp___8;
#line 3929
    *((mp + i___0)->right + 0) = tmp___7;
#line 3929
    *((mp + i___0)->left + 0) = tmp___7;
#line 3930
    *((mp + i___0)->in + 0) = (char *)((void *)0);
#line 3923
    i___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3941
  ri = (size_t )0;
  {
#line 3941
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3941
    if (! (ri < d->tindex)) {
#line 3941
      goto while_break___2;
    }
#line 3943
    t = *(d->tokens + ri);
    {
#line 3946
    if (t == 271L) {
#line 3946
      goto case_271;
    }
#line 3946
    if (t == 270L) {
#line 3946
      goto case_271;
    }
#line 3955
    if (t == 257L) {
#line 3955
      goto case_257;
    }
#line 3955
    if (t == 263L) {
#line 3955
      goto case_257;
    }
#line 3955
    if (t == 262L) {
#line 3955
      goto case_257;
    }
#line 3955
    if (t == 261L) {
#line 3955
      goto case_257;
    }
#line 3955
    if (t == 260L) {
#line 3955
      goto case_257;
    }
#line 3955
    if (t == 259L) {
#line 3955
      goto case_257;
    }
#line 3955
    if (t == 258L) {
#line 3955
      goto case_257;
    }
#line 3955
    if (t == 256L) {
#line 3955
      goto case_257;
    }
#line 3959
    if (t == 264L) {
#line 3959
      goto case_264;
    }
#line 3959
    if (t == 265L) {
#line 3959
      goto case_264;
    }
#line 3964
    if (t == 269L) {
#line 3964
      goto case_269;
    }
#line 4002
    if (t == 266L) {
#line 4002
      goto case_266;
    }
#line 4007
    if (t == -1L) {
#line 4007
      goto case_neg_1;
    }
#line 4015
    if (t == 268L) {
#line 4015
      goto case_268;
    }
#line 4064
    goto switch_default;
    case_271: /* CIL Label */ 
    case_270: /* CIL Label */ ;
    case_257: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_259: /* CIL Label */ 
    case_258: /* CIL Label */ 
    case_256: /* CIL Label */ 
    {
#line 3956
    resetmust(mp);
    }
#line 3957
    goto switch_break;
    case_264: /* CIL Label */ 
    case_265: /* CIL Label */ 
    {
#line 3961
    mp --;
#line 3962
    resetmust(mp);
    }
#line 3963
    goto switch_break;
    case_269: /* CIL Label */ 
    {
#line 3972
    mp --;
#line 3972
    rmp = mp;
#line 3973
    mp --;
#line 3973
    lmp = mp;
#line 3975
    tmp___9 = strcmp((char const   *)lmp->is, (char const   *)rmp->is);
    }
#line 3975
    if (! (tmp___9 == 0)) {
#line 3976
      *(lmp->is + 0) = (char )'\000';
    }
#line 3978
    i___0 = (size_t )0;
    {
#line 3979
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3979
      if ((int )*(lmp->left + i___0) != 0) {
#line 3979
        if (! ((int )*(lmp->left + i___0) == (int )*(rmp->left + i___0))) {
#line 3979
          goto while_break___3;
        }
      } else {
#line 3979
        goto while_break___3;
      }
#line 3980
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3981
    *(lmp->left + i___0) = (char )'\000';
#line 3983
    ln = strlen((char const   *)lmp->right);
#line 3984
    rn = strlen((char const   *)rmp->right);
#line 3985
    n = ln;
    }
#line 3986
    if (n > rn) {
#line 3987
      n = rn;
    }
#line 3988
    i___0 = (size_t )0;
    {
#line 3988
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3988
      if (! (i___0 < n)) {
#line 3988
        goto while_break___4;
      }
#line 3989
      if ((int )*(lmp->right + ((ln - i___0) - 1UL)) != (int )*(rmp->right + ((rn - i___0) - 1UL))) {
#line 3990
        goto while_break___4;
      }
#line 3988
      i___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3991
    j = (size_t )0;
    {
#line 3991
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3991
      if (! (j < i___0)) {
#line 3991
        goto while_break___5;
      }
#line 3992
      *(lmp->right + j) = *(lmp->right + ((ln - i___0) + j));
#line 3991
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 3993
    *(lmp->right + j) = (char )'\000';
#line 3994
    new = inboth(lmp->in, rmp->in);
    }
#line 3995
    if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 3996
      goto done;
    }
    {
#line 3997
    freelist(lmp->in);
#line 3998
    free((void *)lmp->in);
#line 3999
    lmp->in = new;
    }
#line 4001
    goto switch_break;
    case_266: /* CIL Label */ 
#line 4004
    mp --;
#line 4005
    *(mp->is + 0) = (char )'\000';
#line 4006
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 4009
    i___0 = (size_t )0;
    {
#line 4009
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 4009
      if (! ((unsigned long )*((musts + 0)->in + i___0) != (unsigned long )((void *)0))) {
#line 4009
        goto while_break___6;
      }
      {
#line 4010
      tmp___10 = strlen((char const   *)*((musts + 0)->in + i___0));
#line 4010
      tmp___11 = strlen((char const   *)result);
      }
#line 4010
      if (tmp___10 > tmp___11) {
#line 4011
        result = *((musts + 0)->in + i___0);
      }
#line 4009
      i___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 4012
    tmp___12 = strcmp((char const   *)result, (char const   *)(musts + 0)->is);
    }
#line 4012
    if (tmp___12 == 0) {
#line 4013
      exact___0 = 1;
    }
#line 4014
    goto done;
    case_268: /* CIL Label */ 
    {
#line 4021
    mp --;
#line 4021
    rmp___0 = mp;
#line 4022
    mp --;
#line 4022
    lmp___0 = mp;
#line 4026
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    }
#line 4027
    if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
#line 4028
      goto done;
    }
#line 4029
    if ((int )*(lmp___0->right + 0) != 0) {
#line 4029
      if ((int )*(rmp___0->left + 0) != 0) {
        {
#line 4033
        tp = icpyalloc((char const   *)lmp___0->right);
#line 4034
        tp = icatalloc(tp, (char const   *)rmp___0->left);
#line 4035
        tmp___13 = strlen((char const   *)tp);
#line 4035
        lmp___0->in = enlist(lmp___0->in, tp, tmp___13);
#line 4036
        free((void *)tp);
        }
#line 4037
        if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
#line 4038
          goto done;
        }
      }
    }
#line 4041
    if ((int )*(lmp___0->is + 0) != 0) {
      {
#line 4043
      lmp___0->left = icatalloc(lmp___0->left, (char const   *)rmp___0->left);
      }
#line 4044
      if ((unsigned long )lmp___0->left == (unsigned long )((void *)0)) {
#line 4045
        goto done;
      }
    }
#line 4048
    if ((int )*(rmp___0->is + 0) == 0) {
#line 4049
      *(lmp___0->right + 0) = (char )'\000';
    }
    {
#line 4050
    lmp___0->right = icatalloc(lmp___0->right, (char const   *)rmp___0->right);
    }
#line 4051
    if ((unsigned long )lmp___0->right == (unsigned long )((void *)0)) {
#line 4052
      goto done;
    }
#line 4054
    if ((int )*(lmp___0->is + 0) != 0) {
#line 4054
      if ((int )*(rmp___0->is + 0) != 0) {
        {
#line 4056
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
        }
#line 4057
        if ((unsigned long )lmp___0->is == (unsigned long )((void *)0)) {
#line 4058
          goto done;
        }
      } else {
#line 4061
        *(lmp___0->is + 0) = (char )'\000';
      }
    } else {
#line 4061
      *(lmp___0->is + 0) = (char )'\000';
    }
#line 4063
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 4065
    if (! (t < -1L)) {
#line 4069
      if (t == 0L) {
#line 4072
        goto done;
      } else
#line 4074
      if (t >= 275L) {
        {
#line 4077
        resetmust(mp);
        }
      } else
#line 4074
      if (t == 272L) {
        {
#line 4077
        resetmust(mp);
        }
      } else
#line 4074
      if (t == 273L) {
        {
#line 4077
        resetmust(mp);
        }
      } else {
        {
#line 4082
        resetmust(mp);
#line 4083
        tmp___15 = (char )t;
#line 4083
        *(mp->right + 0) = tmp___15;
#line 4083
        tmp___14 = tmp___15;
#line 4083
        *(mp->left + 0) = tmp___14;
#line 4083
        *(mp->is + 0) = tmp___14;
#line 4084
        tmp___17 = (char )'\000';
#line 4084
        *(mp->right + 1) = tmp___17;
#line 4084
        tmp___16 = tmp___17;
#line 4084
        *(mp->left + 1) = tmp___16;
#line 4084
        *(mp->is + 1) = tmp___16;
#line 4085
        mp->in = enlist(mp->in, mp->is, (size_t )1);
        }
#line 4086
        if ((unsigned long )mp->in == (unsigned long )((void *)0)) {
#line 4087
          goto done;
        }
      }
    }
#line 4089
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4101
    mp ++;
#line 3941
    ri ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  done: 
  {
#line 4104
  tmp___22 = strlen((char const   *)result);
  }
#line 4104
  if (tmp___22) {
    {
#line 4106
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 4106
      if (sizeof(*dm) == 1UL) {
        {
#line 4106
        tmp___18 = xmalloc((size_t )1);
#line 4106
        dm = (struct dfamust *)tmp___18;
        }
      } else {
        {
#line 4106
        tmp___19 = xnmalloc((size_t )1, sizeof(*dm));
#line 4106
        dm = (struct dfamust *)tmp___19;
        }
      }
#line 4106
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 4107
    dm->exact = exact___0;
#line 4108
    tmp___20 = strlen((char const   *)result);
#line 4108
    tmp___21 = xmemdup((void const   *)result, tmp___20 + 1UL);
#line 4108
    dm->must = (char *)tmp___21;
#line 4109
    dm->next = d->musts;
#line 4110
    d->musts = dm;
    }
  }
#line 4112
  mp = musts;
#line 4113
  i___0 = (size_t )0;
  {
#line 4113
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 4113
    if (! (i___0 <= d->tindex)) {
#line 4113
      goto while_break___8;
    }
    {
#line 4115
    freelist((mp + i___0)->in);
#line 4116
    free((void *)(mp + i___0)->in);
#line 4117
    free((void *)(mp + i___0)->left);
#line 4118
    free((void *)(mp + i___0)->right);
#line 4119
    free((void *)(mp + i___0)->is);
#line 4113
    i___0 ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 4121
  free((void *)mp);
  }
#line 4122
  return;
}
}
#line 4124 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct dfa *dfaalloc(void) 
{ 
  void *tmp___1 ;

  {
  {
#line 4127
  tmp___1 = xmalloc(sizeof(struct dfa ));
  }
#line 4127
  return ((struct dfa *)tmp___1);
}
}
#line 4130 "/home/wslee/gnu_benchmarks/gawk-4.1.0/dfa.c"
struct dfamust * __attribute__((__pure__)) dfamusts(struct dfa  const  *d ) 
{ 


  {
#line 4133
  return ((struct dfamust */* __attribute__((__pure__)) */)d->musts);
}
}
#line 309 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void setbuf(FILE * __restrict  __stream , char * __restrict  __buf ) ;
#line 363
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 367
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 65 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 284 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execvp)(char const   *__file ,
                                                                                   char * const  *__argv ) ;
#line 285 "/usr/include/readline/readline.h"
extern char *readline(char const   * ) ;
#line 407
extern int rl_reset_terminal(char const   * ) ;
#line 410
extern void rl_get_screen_size(int * , int * ) ;
#line 497
extern char const   *rl_readline_name ;
#line 544
extern FILE *rl_outstream ;
#line 632
extern rl_completion_func_t *rl_attempted_completion_function ;
#line 84 "/usr/include/readline/history.h"
extern void add_history(char const   * ) ;
#line 123
extern HIST_ENTRY **history_list(void) ;
#line 187
extern int read_history(char const   * ) ;
#line 199
extern int write_history(char const   * ) ;
#line 206
extern int history_truncate_file(char const   * , int  ) ;
#line 243
extern int history_length ;
#line 29 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
char **command_completion(char const   *text , int start , int end ) ;
#line 30
void initialize_pager(FILE *fp___0 ) ;
#line 31
NODE *get_function(void) ;
#line 37
int gprintf(FILE *fp___0 , char const   *format  , ...) ;
#line 38 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
jmp_buf pager_quit_tag  ;
#line 39
_Bool pager_quit_tag_valid ;
#line 42 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
int input_fd  ;
#line 43
_Bool input_from_tty ;
#line 44 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
FILE *out_fp  ;
#line 45 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
char *dbg_prompt  ;
#line 46
char *commands_prompt ;
#line 47
char *eval_prompt ;
#line 48
char *dgawk_prompt ;
#line 157
void free_cmdarg(CMDARG *list ) ;
#line 158
Func_cmd get_command(int ctype ) ;
#line 162
void d_error(char const   *mesg  , ...) ;
#line 165
int find_option(char *name ) ;
#line 166
void option_help(void) ;
#line 167
char *(*read_a_line)(char const   *prompt ) ;
#line 168
char *read_commands_string(char const   *prompt  __attribute__((__unused__)) ) ;
#line 169
int in_cmd_src(char const   *filename ) ;
#line 170
int get_eof_status(void) ;
#line 171
void push_cmd_src(int fd , _Bool istty , char *(*readfunc___0)(char const   * ) ,
                  int (*closefunc___0)(int  ) , int ctype , int eofstatus ) ;
#line 173
int pop_cmd_src(void) ;
#line 174
int has_break_or_watch_point(int *pnum , _Bool any ) ;
#line 175
int do_list(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 176
int do_info(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 177
int do_print_var(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 178
int do_backtrace(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 179
int do_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 180
int do_tmp_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 181
int do_delete_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 182
int do_enable_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 183
int do_disable_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 184
int do_ignore_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 185
int do_run(CMDARG *arg  __attribute__((__unused__)) , int cmd  __attribute__((__unused__)) ) ;
#line 186
int do_quit(CMDARG *arg  __attribute__((__unused__)) , int cmd  __attribute__((__unused__)) ) ;
#line 187
int do_continue(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 188
int do_step(CMDARG *arg , int cmd ) ;
#line 189
int do_stepi(CMDARG *arg , int cmd ) ;
#line 190
int do_next(CMDARG *arg , int cmd ) ;
#line 191
int do_nexti(CMDARG *arg , int cmd ) ;
#line 192
int do_clear(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 193
int do_finish(CMDARG *arg  __attribute__((__unused__)) , int cmd ) ;
#line 195
int do_up(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 196
int do_down(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 197
int do_frame(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 198
int do_until(CMDARG *arg , int cmd ) ;
#line 199
int do_set_var(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 200
int do_return(CMDARG *arg , int cmd ) ;
#line 201
int do_display(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 202
int do_undisplay(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 203
int do_watch(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 204
int do_unwatch(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 205
int do_dump_instructions(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 206
int do_trace_instruction(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 207
int do_option(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 208
int do_commands(CMDARG *arg , int cmd ) ;
#line 209
int do_print_f(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 210
int do_source(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 211
int do_save(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 212
int do_eval(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 213
int do_condition(CMDARG *arg , int cmd  __attribute__((__unused__)) ) ;
#line 43 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int zzparse(void) ;
#line 48 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char *linebuf  =    (char *)((void *)0);
#line 49 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static size_t linebuf_len  ;
#line 53 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
char *commands_prompt  =    (char *)"> ";
#line 54 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
char *eval_prompt  =    (char *)"@> ";
#line 56 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
_Bool input_from_tty  =    (_Bool)0;
#line 59 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static SRCFILE *cur_srcfile  ;
#line 60 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static long cur_frame  =    0L;
#line 61 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static INSTRUCTION *cur_pc  ;
#line 62 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int cur_rule  =    0;
#line 64 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static _Bool prog_running  =    (_Bool)0;
#line 104 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static BREAKPOINT breakpoints  = 
#line 104
     {& breakpoints, & breakpoints, 0, 0L, 0L, (char *)0, (INSTRUCTION *)0, {(struct commands_item *)0,
                                                                           (struct commands_item *)0,
                                                                           0, (char *)0,
                                                                           (CMDARG *)0},
    (_Bool)0, {(INSTRUCTION *)0, (AWK_CONTEXT *)0, (char *)0}, (short)0};
#line 108 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int sess_history_base  =    0;
#line 112 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int last_printed_line  =    0;
#line 113 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int last_print_count  ;
#line 155 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct list_item display_list  = 
#line 155
     {& display_list, & display_list, 0, (NODE *)0, (NODE **)0, 0, (char *)0, 0L, {(struct commands_item *)0,
                                                                                 (struct commands_item *)0,
                                                                                 0,
                                                                                 (char *)0,
                                                                                 (CMDARG *)0},
    0, {(INSTRUCTION *)0, (AWK_CONTEXT *)0, (char *)0}, {{(NODE *)0}, {(NODE *)0}},
    0};
#line 156 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct list_item watch_list  = 
#line 156
     {& watch_list, & watch_list, 0, (NODE *)0, (NODE **)0, 0, (char *)0, 0L, {(struct commands_item *)0,
                                                                             (struct commands_item *)0,
                                                                             0, (char *)0,
                                                                             (CMDARG *)0},
    0, {(INSTRUCTION *)0, (AWK_CONTEXT *)0, (char *)0}, {{(NODE *)0}, {(NODE *)0}},
    0};
#line 161 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct __anonstruct_stop_88 stop  ;
#line 187 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static _Bool need_restart  =    (_Bool)0;
#line 189 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char const   * const  env_variable[6]  = {      (char const   */* const  */)"",      (char const   */* const  */)"DGAWK_BREAK",      (char const   */* const  */)"DGAWK_WATCH",      (char const   */* const  */)"DGAWK_DISPLAY", 
        (char const   */* const  */)"DGAWK_HISTORY",      (char const   */* const  */)"DGAWK_OPTION"};
#line 197
static void serialize(int type ) ;
#line 198
static void unserialize(int type ) ;
#line 199 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char const   *commands_string  =    (char const   *)((void *)0);
#line 200 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int commands_string_len  =    0;
#line 201 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char line_sep  ;
#line 222
static void set_gawk_output(char const   *file ) ;
#line 223
static void set_prompt(char const   *value ) ;
#line 224
static void set_listsize(char const   *value ) ;
#line 225
static void set_trace(char const   *value ) ;
#line 226
static void set_save_history(char const   *value ) ;
#line 227
static void set_save_options(char const   *value ) ;
#line 228
static void set_history_size(char const   *value ) ;
#line 229 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char const   *options_file  =    "./.gawkrc";
#line 231 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char const   *history_file  =    "./.gawk_history";
#line 236 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char *output_file  =    (char *)"/dev/stdout";
#line 237 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
char *dgawk_prompt  =    (char *)((void *)0);
#line 238 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int list_size  =    15;
#line 239 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int do_trace  =    0;
#line 240 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int do_save_history  =    1;
#line 241 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int do_save_options  =    1;
#line 242 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int history_size  =    100;
#line 244 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct dbg_option  const  option_list[8]  = 
#line 244
  {      {"history_size", & history_size, (char **)((void *)0), & set_history_size, "set or show the number of lines to keep in history file."}, 
        {"listsize",
      & list_size, (char **)((void *)0), & set_listsize, "set or show the list command window size."}, 
        {"outfile",
      (int *)((void *)0), & output_file, & set_gawk_output, "set or show gawk output file."}, 
        {"prompt",
      (int *)((void *)0), & dgawk_prompt, & set_prompt, "set or show debugger prompt."}, 
        {"save_history",
      & do_save_history, (char **)((void *)0), & set_save_history, "(un)set or show saving of command history (value=on|off)."}, 
        {"save_options",
      & do_save_options, (char **)((void *)0), & set_save_options, "(un)set or show saving of options (value=on|off)."}, 
        {"trace",
      & do_trace, (char **)((void *)0), & set_trace, "(un)set or show instruction tracing (value=on|off)."}, 
        {(char const   *)0,
      (int *)((void *)0), (char **)((void *)0), (void (*)(char const   * ))((void *)0),
      (char const   *)0}};
#line 262
static void save_options(char const   *file ) ;
#line 267 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
_Bool pager_quit_tag_valid  =    (_Bool)0;
#line 268 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int screen_width  =    2147483647;
#line 269 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int screen_height  =    2147483647;
#line 270 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int pager_lines_printed  =    0;
#line 272
static  __attribute__((__noreturn__)) void restart(_Bool run ) ;
#line 273
static void close_all(void) ;
#line 274
static int open_readfd(char const   *file ) ;
#line 275
static int find_lines(SRCFILE *s___0 ) ;
#line 276
static SRCFILE *source_find(char *src ) ;
#line 277
static int print_lines(char *src , int start_line , int nlines ) ;
#line 278
static void print_symbol(NODE *r , _Bool isparam ) ;
#line 279
static NODE *find_frame(long num ) ;
#line 280
static NODE *find_param(char const   *name , long num , char **pname ) ;
#line 281
static NODE *find_symbol(char const   *name , char **pname ) ;
#line 282
static NODE *find_array(char const   *name ) ;
#line 283
static void print_field(long field_num ) ;
#line 284
static int print_function(INSTRUCTION *pc , void *x ) ;
#line 285
static void print_frame(NODE *func___1 , char *src , int srcline___0 ) ;
#line 286
static void print_numbered_frame(long num ) ;
#line 287
static void print_cur_frame_and_sourceline(void) ;
#line 288
static INSTRUCTION *find_rule(char *src , long lineno ) ;
#line 289
static INSTRUCTION *mk_breakpoint(char *src , int srcline___0 ) ;
#line 290
static int execute_commands(struct commands_item *commands___0 ) ;
#line 291
static void delete_commands_item(struct commands_item *c ) ;
#line 292
static NODE *execute_code(INSTRUCTION volatile   *code ) ;
#line 293
static int pre_execute_code(INSTRUCTION **pi ) ;
#line 294
static int parse_condition(int type , int num , char *expr ) ;
#line 295
static BREAKPOINT *add_breakpoint(INSTRUCTION *prevp , INSTRUCTION *ip , char *src ,
                                  _Bool silent ) ;
#line 296
static BREAKPOINT *set_breakpoint_next(INSTRUCTION *rp , INSTRUCTION *ip ) ;
#line 297
static BREAKPOINT *set_breakpoint_at(INSTRUCTION *rp , int lineno , _Bool silent ) ;
#line 298
static void delete_breakpoint(BREAKPOINT *b___0 ) ;
#line 299
static BREAKPOINT *find_breakpoint(long num ) ;
#line 300
static void display(struct list_item *d ) ;
#line 301
static struct list_item *find_item(struct list_item *list , long num ) ;
#line 302
static struct list_item *add_item(struct list_item *list , int type , NODE *symbol ,
                                  char *pname ) ;
#line 303
static void delete_item(struct list_item *d ) ;
#line 304
static int breakpoint_triggered(BREAKPOINT *b___0 ) ;
#line 305
static int watchpoint_triggered(struct list_item *w___0 ) ;
#line 306
static void print_instruction(INSTRUCTION *pc , int (*print_func)(FILE * , char const   * 
                                                                  , ...) , FILE *fp___0 ,
                              int in_dump ) ;
#line 307
static int print_code(INSTRUCTION *pc , void *x ) ;
#line 308
static void next_command(void) ;
#line 309
static void debug_post_execute(INSTRUCTION *pc ) ;
#line 310
static int debug_pre_execute(INSTRUCTION **pi ) ;
#line 311
static char *g_readline(char const   *prompt ) ;
#line 312
static int prompt_yes_no(char const   *mesg , char res_true , int res_default , FILE *fp___0 ) ;
#line 313 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct pf_data pf_data  ;
#line 319 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
char *(*read_a_line)(char const   *prompt )  =    (char *(*)(char const   *prompt ))0;
#line 333 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct command_source *cmd_src  =    (struct command_source *)((void *)0);
#line 355 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char buf___2[2]  ;
#line 350 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char *g_readline(char const   *prompt ) 
{ 
  char *line ;
  size_t line_size ;
  char *p ;
  char *end ;
  int n ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  ssize_t tmp___12 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 354
  line_size = (size_t )100;
#line 359
  if (input_from_tty) {
#line 359
    if (prompt) {
#line 359
      if (*prompt) {
        {
#line 360
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s",
                prompt);
        }
      }
    }
  }
  {
#line 362
  tmp___1 = malloc(line_size + 1UL);
#line 362
  line = (char *)tmp___1;
  }
#line 362
  if (line) {
#line 362
    tmp___5 = 1;
  } else {
    {
#line 362
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 362);
#line 362
    tmp___2 = __errno_location();
#line 362
    tmp___3 = strerror(*tmp___2);
#line 362
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 362
    r_fatal((char const   *)tmp___4, "g_readline", "line", (long )(line_size + 1UL),
            tmp___3);
#line 362
    tmp___5 = 0;
    }
  }
#line 363
  p = line;
#line 364
  end = line + line_size;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 365
    tmp___12 = read(input_fd, (void *)(buf___2), (size_t )1);
#line 365
    n = (int )tmp___12;
    }
#line 365
    if (! (n > 0)) {
#line 365
      goto while_break;
    }
#line 366
    if ((int )buf___2[0] == 10) {
#line 367
      if ((unsigned long )p > (unsigned long )line) {
#line 367
        if ((int )*(p + -1) == 13) {
#line 368
          p --;
        }
      }
#line 369
      goto while_break;
    }
#line 371
    if ((unsigned long )p == (unsigned long )end) {
      {
#line 372
      tmp___6 = realloc((void *)line, 2UL * line_size + 1UL);
#line 372
      line = (char *)tmp___6;
      }
#line 372
      if (line) {
#line 372
        tmp___10 = 1;
      } else {
        {
#line 372
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 372);
#line 372
        tmp___7 = __errno_location();
#line 372
        tmp___8 = strerror(*tmp___7);
#line 372
        tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 372
        r_fatal((char const   *)tmp___9, "g_readline", "line", (long )(2UL * line_size + 1UL),
                tmp___8);
#line 372
        tmp___10 = 0;
        }
      }
#line 373
      p = line + line_size;
#line 374
      line_size *= 2UL;
#line 375
      end = line + line_size;
    }
#line 377
    tmp___11 = p;
#line 377
    p ++;
#line 377
    *tmp___11 = buf___2[0];
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  if (n == -1) {
    {
#line 380
    free((void *)line);
    }
#line 381
    return ((char *)((void *)0));
  } else
#line 379
  if (n == 0) {
#line 379
    if ((unsigned long )p == (unsigned long )line) {
      {
#line 380
      free((void *)line);
      }
#line 381
      return ((char *)((void *)0));
    }
  }
#line 383
  *p = (char )'\000';
#line 384
  return (line);
}
}
#line 390 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
void d_error(char const   *mesg  , ...) 
{ 
  va_list args ;
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 394
  __builtin_va_start(args, mesg);
#line 395
  tmp___1 = gettext("error: ");
#line 395
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1);
#line 396
  vfprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)mesg,
           args);
#line 397
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\n");
#line 398
  __builtin_va_end(args);
  }
#line 399
  return;
}
}
#line 403 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int find_lines(SRCFILE *s___0 ) 
{ 
  char *buf___7 ;
  char *p ;
  char *end ;
  int n ;
  int ofs ;
  int *pos ;
  int pos_size ;
  int maxlen ;
  int numlines ;
  char lastchar ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  void *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 408
  ofs = 0;
#line 411
  maxlen = 0;
#line 412
  numlines = 0;
#line 413
  lastchar = (char )'\000';
#line 415
  tmp___1 = malloc(s___0->bufsize);
#line 415
  buf___7 = (char *)tmp___1;
  }
#line 415
  if (buf___7) {
#line 415
    tmp___5 = 1;
  } else {
    {
#line 415
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 415);
#line 415
    tmp___2 = __errno_location();
#line 415
    tmp___3 = strerror(*tmp___2);
#line 415
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 415
    r_fatal((char const   *)tmp___4, "find_lines", "buf", (long )s___0->bufsize, tmp___3);
#line 415
    tmp___5 = 0;
    }
  }
  {
#line 416
  pos_size = s___0->srclines;
#line 417
  tmp___7 = malloc((unsigned long )(pos_size + 2) * sizeof(int ));
#line 417
  tmp___6 = (int *)tmp___7;
#line 417
  s___0->line_offset = tmp___6;
  }
#line 417
  if (tmp___6) {
#line 417
    tmp___11 = 1;
  } else {
    {
#line 417
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 417);
#line 417
    tmp___8 = __errno_location();
#line 417
    tmp___9 = strerror(*tmp___8);
#line 417
    tmp___10 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 417
    r_fatal((char const   *)tmp___10, "find_lines", "s->line_offset", (long )((unsigned long )(pos_size + 2) * sizeof(int )),
            tmp___9);
#line 417
    tmp___11 = 0;
    }
  }
#line 418
  pos = s___0->line_offset;
#line 419
  *(pos + 0) = 0;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 421
    tmp___19 = read(s___0->fd, (void *)buf___7, s___0->bufsize);
#line 421
    n = (int )tmp___19;
    }
#line 421
    if (! (n > 0)) {
#line 421
      goto while_break;
    }
#line 422
    end = buf___7 + n;
#line 423
    lastchar = *(buf___7 + (n - 1));
#line 424
    p = buf___7;
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 425
      if (! ((unsigned long )p < (unsigned long )end)) {
#line 425
        goto while_break___0;
      }
#line 426
      tmp___18 = p;
#line 426
      p ++;
#line 426
      if ((int )*tmp___18 == 10) {
#line 427
        numlines ++;
#line 427
        if (numlines > pos_size) {
          {
#line 428
          tmp___13 = realloc((void *)((char *)s___0->line_offset), (unsigned long )(2 * pos_size + 2) * sizeof(int ));
#line 428
          tmp___12 = (int *)tmp___13;
#line 428
          s___0->line_offset = tmp___12;
          }
#line 428
          if (tmp___12) {
#line 428
            tmp___17 = 1;
          } else {
            {
#line 428
            set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 428);
#line 428
            tmp___14 = __errno_location();
#line 428
            tmp___15 = strerror(*tmp___14);
#line 428
            tmp___16 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 428
            r_fatal((char const   *)tmp___16, "find_lines", "s->line_offset", (long )((unsigned long )(2 * pos_size + 2) * sizeof(int )),
                    tmp___15);
#line 428
            tmp___17 = 0;
            }
          }
#line 429
          pos = s___0->line_offset + pos_size;
#line 430
          pos_size *= 2;
        }
#line 432
        pos ++;
#line 432
        *pos = (int )((long )ofs + (p - buf___7));
#line 433
        if (*(pos + 0) - *(pos + -1) > maxlen) {
#line 434
          maxlen = *(pos + 0) - *(pos + -1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 437
    ofs += n;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 439
  free((void *)buf___7);
  }
#line 441
  if (n == -1) {
    {
#line 442
    tmp___20 = __errno_location();
#line 442
    tmp___21 = strerror(*tmp___20);
#line 442
    tmp___22 = gettext("can\'t read source file `%s\' (%s)");
#line 442
    d_error((char const   *)tmp___22, s___0->src, tmp___21);
    }
#line 444
    return (-1);
  }
#line 446
  if (ofs <= 0) {
    {
#line 447
    tmp___23 = gettext("source file `%s\' is empty.\n");
#line 447
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___23,
            s___0->src);
    }
#line 448
    return (-1);
  }
#line 451
  if ((int )lastchar != 10) {
#line 453
    pos ++;
#line 453
    *pos = ofs + 1;
#line 454
    numlines ++;
#line 455
    if (*(pos + 0) - *(pos + -1) > maxlen) {
#line 456
      maxlen = *(pos + 0) - *(pos + -1);
    }
  }
#line 458
  s___0->maxlen = maxlen;
#line 459
  s___0->srclines = numlines;
#line 460
  return (0);
}
}
#line 465 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static SRCFILE *source_find(char *src ) 
{ 
  SRCFILE *s___0 ;
  struct stat sbuf ;
  char *path ;
  int errno_val ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 471
  errno_val = 0;
#line 473
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 474
    tmp___1 = gettext("no current source file.");
#line 474
    d_error((char const   *)tmp___1);
    }
#line 475
    return ((SRCFILE *)((void *)0));
  } else
#line 473
  if ((int )*src == 0) {
    {
#line 474
    tmp___1 = gettext("no current source file.");
#line 474
    d_error((char const   *)tmp___1);
    }
#line 475
    return ((SRCFILE *)((void *)0));
  }
#line 478
  if ((unsigned long )cur_srcfile->src == (unsigned long )src) {
#line 479
    return (cur_srcfile);
  }
#line 481
  s___0 = srcfiles->next;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! ((unsigned long )s___0 != (unsigned long )srcfiles)) {
#line 481
      goto while_break;
    }
#line 482
    if ((unsigned int )s___0->stype == 3U) {
#line 482
      goto _L;
    } else
#line 482
    if ((unsigned int )s___0->stype == 4U) {
      _L: /* CIL Label */ 
      {
#line 482
      tmp___2 = strcmp((char const   *)s___0->src, (char const   *)src);
      }
#line 482
      if (tmp___2 == 0) {
#line 484
        return (s___0);
      }
    }
#line 481
    s___0 = s___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 487
  path = find_source((char const   *)src, & sbuf, & errno_val, 0);
  }
#line 488
  if ((unsigned long )path != (unsigned long )((void *)0)) {
#line 489
    s___0 = srcfiles->next;
    {
#line 489
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 489
      if (! ((unsigned long )s___0 != (unsigned long )srcfiles)) {
#line 489
        goto while_break___0;
      }
#line 490
      if ((unsigned int )s___0->stype == 3U) {
#line 490
        goto _L___0;
      } else
#line 490
      if ((unsigned int )s___0->stype == 4U) {
        _L___0: /* CIL Label */ 
        {
#line 490
        tmp___3 = files_are_same(path, s___0);
        }
#line 490
        if (tmp___3) {
          {
#line 492
          free((void *)path);
          }
#line 493
          return (s___0);
        }
      }
#line 489
      s___0 = s___0->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 496
    free((void *)path);
    }
  }
  {
#line 499
  tmp___4 = strerror(errno_val);
#line 499
  tmp___5 = gettext("cannot find source file named `%s\' (%s)");
#line 499
  d_error((char const   *)tmp___5, src, tmp___4);
  }
#line 500
  return ((SRCFILE *)((void *)0));
}
}
#line 505 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int print_lines(char *src , int start_line , int nlines ) 
{ 
  SRCFILE *s___0 ;
  int *pos ;
  int i___0 ;
  struct stat sbuf ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  __off_t tmp___15 ;
  void *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  void *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int supposed_len ;
  int len ;
  char *p ;
  BREAKPOINT *b___0 ;
  _Bool has_bpt ;
  size_t tmp___26 ;
  ssize_t tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
  {
#line 513
  s___0 = source_find(src);
  }
#line 514
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 515
    return (-1);
  }
#line 516
  if (s___0->fd <= -1) {
    {
#line 516
    tmp___4 = srcopen(s___0);
#line 516
    s___0->fd = tmp___4;
    }
#line 516
    if (tmp___4 <= -1) {
      {
#line 517
      tmp___1 = __errno_location();
#line 517
      tmp___2 = strerror(*tmp___1);
#line 517
      tmp___3 = gettext("can\'t open source file `%s\' for reading (%s)");
#line 517
      d_error((char const   *)tmp___3, src, tmp___2);
      }
#line 519
      return (-1);
    }
  }
  {
#line 522
  tmp___10 = fstat(s___0->fd, & sbuf);
  }
#line 522
  if (tmp___10 == 0) {
#line 522
    if (s___0->mtime < sbuf.st_mtim.tv_sec) {
      {
#line 523
      tmp___5 = gettext("WARNING: source file `%s\' modified since program compilation.\n");
#line 523
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___5,
              src);
#line 525
      free((void *)s___0->line_offset);
#line 526
      s___0->line_offset = (int *)((void *)0);
#line 527
      s___0->mtime = sbuf.st_mtim.tv_sec;
#line 530
      close(s___0->fd);
#line 531
      s___0->fd = -1;
#line 532
      tmp___9 = srcopen(s___0);
#line 532
      s___0->fd = tmp___9;
      }
#line 532
      if (tmp___9 <= -1) {
        {
#line 533
        tmp___6 = __errno_location();
#line 533
        tmp___7 = strerror(*tmp___6);
#line 533
        tmp___8 = gettext("can\'t open source file `%s\' for reading (%s)");
#line 533
        d_error((char const   *)tmp___8, src, tmp___7);
        }
#line 535
        return (-1);
      }
    }
  }
#line 539
  if ((unsigned long )s___0->line_offset == (unsigned long )((void *)0)) {
    {
#line 539
    tmp___11 = find_lines(s___0);
    }
#line 539
    if (tmp___11 != 0) {
#line 540
      return (-1);
    }
  }
#line 541
  if (start_line < 1) {
    {
#line 542
    tmp___12 = gettext("line number %d out of range; `%s\' has %d lines");
#line 542
    d_error((char const   *)tmp___12, start_line, src, s___0->srclines);
    }
#line 544
    return (-1);
  } else
#line 541
  if (start_line > s___0->srclines) {
    {
#line 542
    tmp___12 = gettext("line number %d out of range; `%s\' has %d lines");
#line 542
    d_error((char const   *)tmp___12, start_line, src, s___0->srclines);
    }
#line 544
    return (-1);
  }
#line 548
  if ((start_line + nlines) - 1 > s___0->srclines) {
#line 549
    nlines = (s___0->srclines - start_line) + 1;
  }
  {
#line 551
  pos = s___0->line_offset;
#line 552
  tmp___15 = lseek(s___0->fd, (off_t )*(pos + (start_line - 1)), 0);
  }
#line 552
  if (tmp___15 < 0L) {
    {
#line 553
    tmp___13 = __errno_location();
#line 553
    tmp___14 = strerror(*tmp___13);
#line 553
    d_error("%s: %s", src, tmp___14);
    }
#line 554
    return (-1);
  }
#line 557
  if ((unsigned long )linebuf == (unsigned long )((void *)0)) {
    {
#line 558
    tmp___16 = malloc((size_t )(s___0->maxlen + 20));
#line 558
    linebuf = (char *)tmp___16;
    }
#line 558
    if (linebuf) {
#line 558
      tmp___20 = 1;
    } else {
      {
#line 558
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 558);
#line 558
      tmp___17 = __errno_location();
#line 558
      tmp___18 = strerror(*tmp___17);
#line 558
      tmp___19 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 558
      r_fatal((char const   *)tmp___19, "print_lines", "linebuf", (long )(s___0->maxlen + 20),
              tmp___18);
#line 558
      tmp___20 = 0;
      }
    }
#line 559
    linebuf_len = (size_t )s___0->maxlen;
  } else
#line 560
  if (linebuf_len < (size_t )s___0->maxlen) {
    {
#line 561
    tmp___21 = realloc((void *)linebuf, (size_t )(s___0->maxlen + 20));
#line 561
    linebuf = (char *)tmp___21;
    }
#line 561
    if (linebuf) {
#line 561
      tmp___25 = 1;
    } else {
      {
#line 561
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 561);
#line 561
      tmp___22 = __errno_location();
#line 561
      tmp___23 = strerror(*tmp___22);
#line 561
      tmp___24 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 561
      r_fatal((char const   *)tmp___24, "print_lines", "linebuf", (long )(s___0->maxlen + 20),
              tmp___23);
#line 561
      tmp___25 = 0;
      }
    }
#line 562
    linebuf_len = (size_t )s___0->maxlen;
  }
#line 565
  i___0 = start_line;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! (i___0 < start_line + nlines)) {
#line 565
      goto while_break;
    }
    {
#line 569
    sprintf((char */* __restrict  */)linebuf, (char const   */* __restrict  */)"%-8d",
            i___0);
    }
#line 574
    if (nlines > 1) {
#line 576
      has_bpt = (_Bool)0;
#line 577
      b___0 = breakpoints.prev;
      {
#line 577
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 577
        if (! ((unsigned long )b___0 != (unsigned long )(& breakpoints))) {
#line 577
          goto while_break___0;
        }
#line 578
        if ((unsigned long )src == (unsigned long )b___0->src) {
#line 578
          if (i___0 == (int )(b___0->bpi)->source_line) {
#line 579
            has_bpt = (_Bool)1;
#line 580
            goto while_break___0;
          }
        }
#line 577
        b___0 = b___0->prev;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 583
      if (prog_running) {
#line 583
        if ((unsigned long )src == (unsigned long )source) {
#line 583
          if (i___0 == sourceline) {
#line 584
            if (has_bpt) {
              {
#line 585
              sprintf((char */* __restrict  */)linebuf, (char const   */* __restrict  */)"%-4d:b=>",
                      i___0);
              }
            } else {
              {
#line 587
              sprintf((char */* __restrict  */)linebuf, (char const   */* __restrict  */)"%-4d  =>",
                      i___0);
              }
            }
          } else {
#line 583
            goto _L___0;
          }
        } else {
#line 583
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 588
      if (has_bpt) {
        {
#line 589
        sprintf((char */* __restrict  */)linebuf, (char const   */* __restrict  */)"%-4d:b  ",
                i___0);
        }
      }
    }
    {
#line 592
    tmp___26 = strlen((char const   *)linebuf);
#line 592
    p = linebuf + tmp___26;
#line 593
    supposed_len = *(pos + i___0) - *(pos + (i___0 - 1));
#line 594
    tmp___27 = read(s___0->fd, (void *)p, (size_t )supposed_len);
#line 594
    len = (int )tmp___27;
    }
    {
#line 596
    if (len == -1) {
#line 596
      goto case_neg_1;
    }
#line 601
    if (len == 0) {
#line 601
      goto case_0;
    }
#line 606
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 597
    tmp___28 = __errno_location();
#line 597
    tmp___29 = strerror(*tmp___28);
#line 597
    tmp___30 = gettext("can\'t read source file `%s\' (%s)");
#line 597
    d_error((char const   *)tmp___30, src, tmp___29);
    }
#line 599
    return (-1);
    case_0: /* CIL Label */ 
    {
#line 602
    tmp___31 = gettext("unexpected eof while reading file `%s\', line %d");
#line 602
    d_error((char const   *)tmp___31, src, i___0);
    }
#line 604
    return (-1);
    switch_default: /* CIL Label */ 
#line 607
    if (i___0 == s___0->srclines) {
#line 607
      if ((int )*(p + (len - 1)) != 10) {
#line 608
        tmp___32 = len;
#line 608
        len ++;
#line 608
        *(p + tmp___32) = (char )'\n';
      }
    }
    {
#line 616
    len = (int )((long )len + (p - linebuf));
#line 617
    tmp___33 = fwrite((void const   */* __restrict  */)linebuf, sizeof(char ), (size_t )len,
                      (FILE */* __restrict  */)out_fp);
    }
#line 617
    if (tmp___33 != (size_t )len) {
#line 618
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 565
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  if ((unsigned long )cur_srcfile != (unsigned long )s___0) {
#line 623
    if (cur_srcfile->fd != -1) {
      {
#line 624
      close(cur_srcfile->fd);
#line 625
      cur_srcfile->fd = -1;
      }
    }
#line 627
    cur_srcfile = s___0;
  }
#line 629
  return (i___0 - 1);
}
}
#line 634 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_list(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  long line_first ;
  long line_last ;
  long count ;
  INSTRUCTION *rp ;
  char *src ;
  int tmp___1 ;

  {
#line 638
  count = (long )list_size;
#line 640
  src = cur_srcfile->src;
#line 642
  line_first = (long )(last_printed_line + 1);
#line 643
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 644
    goto list;
  }
  {
#line 647
  if ((unsigned int )arg->type == 43U) {
#line 647
    goto case_43;
  }
#line 664
  if ((unsigned int )arg->type == 51U) {
#line 664
    goto range;
  }
#line 673
  if ((unsigned int )arg->type == 44U) {
#line 673
    goto case_44;
  }
#line 689
  if ((unsigned int )arg->type == 50U) {
#line 689
    goto func;
  }
#line 698
  goto switch_default;
  case_43: /* CIL Label */ 
#line 648
  if (arg->value.lval < 0L) {
#line 649
    line_first = (long )(((last_printed_line - last_print_count) - list_size) + 1);
#line 650
    if (line_first < 1L) {
#line 651
      if (last_printed_line != last_print_count) {
#line 652
        line_first = 1L;
      } else {
#line 654
        return (0);
      }
    }
  } else {
    line: 
#line 658
    line_first = arg->value.lval - (long )(list_size / 2);
#line 659
    if (line_first < 1L) {
#line 660
      line_first = 1L;
    }
  }
#line 662
  goto switch_break;
  range: 
  case_51: /* CIL Label */ 
#line 666
  line_first = arg->value.lval;
#line 667
  arg = arg->next;
#line 670
  count = (arg->value.lval - line_first) + 1L;
#line 671
  goto switch_break;
  case_44: /* CIL Label */ 
#line 674
  src = arg->value.sval;
#line 675
  if ((unsigned long )arg->next != (unsigned long )((void *)0)) {
#line 676
    arg = arg->next;
#line 677
    if ((unsigned int )arg->type == 43U) {
#line 678
      goto line;
    } else
#line 679
    if ((unsigned int )arg->type == 51U) {
#line 680
      goto range;
    } else
#line 681
    if ((unsigned int )arg->type == 50U) {
#line 682
      goto func;
    } else {
#line 684
      line_first = 1L;
    }
  } else {
#line 686
    line_first = 1L;
  }
#line 687
  goto switch_break;
  func: 
  case_50: /* CIL Label */ 
#line 691
  rp = (arg->value.nodeval)->sub.nodep.r.iptr;
#line 692
  src = rp->d.name;
#line 693
  line_first = (long )((int )rp->source_line - list_size / 2);
#line 694
  if (line_first < 1L) {
#line 695
    line_first = 1L;
  }
#line 696
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 699
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  list: 
  {
#line 703
  tmp___1 = print_lines(src, (int )line_first, (int )count);
#line 703
  line_last = (long )tmp___1;
  }
#line 704
  if (line_last != -1L) {
#line 705
    last_printed_line = (int )line_last;
#line 706
    last_print_count = (int )((line_last - line_first) + 1L);
  }
#line 708
  return (0);
}
}
#line 713 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_info(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  NODE **table ;
  char *tmp___1 ;
  char *tmp___2 ;
  SRCFILE *s___0 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  BREAKPOINT *b___0 ;
  struct commands_item *c ;
  char *tmp___5 ;
  char *disp ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *start ;
  char *end ;
  CMDARG *a ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  NODE *f ;
  NODE *func___1 ;
  INSTRUCTION *pc ;
  int arg_count ;
  int pcount ;
  int i___0 ;
  int from ;
  int to ;
  char *tmp___16 ;
  char *tmp___17 ;
  NODE *r ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  struct list_item *d ;
  struct list_item *list ;
  char *tmp___25 ;
  char *tmp___26 ;
  int i___1 ;
  struct commands_item *c___0 ;
  NODE *symbol ;
  NODE *sub ;
  long tmp___27 ;
  long tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *start___0 ;
  char *end___0 ;
  CMDARG *a___0 ;
  int tmp___33 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;

  {
#line 718
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 719
    return (0);
  } else
#line 718
  if ((unsigned int )arg->type != 42U) {
#line 719
    return (0);
  }
  {
#line 722
  if (arg->value.lval == 9L) {
#line 722
    goto case_9;
  }
#line 727
  if (arg->value.lval == 10L) {
#line 727
    goto case_10;
  }
#line 739
  if (arg->value.lval == 2L) {
#line 739
    goto case_2;
  }
#line 782
  if (arg->value.lval == 5L) {
#line 782
    goto case_5;
  }
#line 797
  if (arg->value.lval == 7L) {
#line 797
    goto case_7;
  }
#line 797
  if (arg->value.lval == 1L) {
#line 797
    goto case_7;
  }
#line 844
  if (arg->value.lval == 13L) {
#line 844
    goto case_13;
  }
#line 854
  if (arg->value.lval == 6L) {
#line 854
    goto case_6;
  }
#line 870
  if (arg->value.lval == 14L) {
#line 870
    goto case_14;
  }
#line 870
  if (arg->value.lval == 4L) {
#line 870
    goto case_14;
  }
#line 923
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 723
  tmp___1 = gettext("Current source file: %s\n");
#line 723
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
          cur_srcfile->src);
#line 724
  tmp___2 = gettext("Number of lines: %d\n");
#line 724
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2,
          cur_srcfile->srclines);
  }
#line 725
  goto switch_break;
  case_10: /* CIL Label */ 
#line 730
  s___0 = srcfiles->next;
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 730
    if (! ((unsigned long )s___0 != (unsigned long )srcfiles)) {
#line 730
      goto while_break;
    }
#line 731
    if ((unsigned int )s___0->stype == 3U) {
#line 731
      tmp___3 = (char const   *)s___0->src;
    } else
#line 731
    if ((unsigned int )s___0->stype == 4U) {
#line 731
      tmp___3 = (char const   *)s___0->src;
    } else {
#line 731
      tmp___3 = "cmd. line";
    }
    {
#line 731
    tmp___4 = gettext("Source file (lines): %s (%d)\n");
#line 731
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___4,
            tmp___3, s___0->srclines);
#line 730
    s___0 = s___0->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 740
  initialize_pager(out_fp);
#line 741
  tmp___11 = _setjmp((struct __jmp_buf_tag *)(pager_quit_tag));
  }
#line 741
  if (tmp___11 == 0) {
    {
#line 745
    tmp___5 = gettext("Number  Disp  Enabled  Location\n\n");
#line 745
    gprintf(out_fp, (char const   *)tmp___5);
#line 746
    b___0 = breakpoints.prev;
    }
    {
#line 746
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 746
      if (! ((unsigned long )b___0 != (unsigned long )(& breakpoints))) {
#line 746
        goto while_break___0;
      }
#line 747
      disp = (char *)"keep";
#line 748
      if (((int )b___0->flags & 2) != 0) {
#line 749
        disp = (char *)"dis";
      } else
#line 750
      if (((int )b___0->flags & 4) != 0) {
#line 751
        disp = (char *)"del";
      }
#line 752
      if (((int )b___0->flags & 1) != 0) {
#line 752
        tmp___6 = "yes";
      } else {
#line 752
        tmp___6 = "no";
      }
      {
#line 752
      gprintf(out_fp, "%-6d  %-4.4s  %-7.7s  file %s, line #%d\n", b___0->number,
              disp, tmp___6, b___0->src, (int )(b___0->bpi)->source_line);
      }
#line 755
      if (b___0->hit_count > 0L) {
        {
#line 756
        tmp___7 = gettext("\tno of hits = %ld\n");
#line 756
        gprintf(out_fp, (char const   *)tmp___7, b___0->hit_count);
        }
      }
#line 757
      if (((int )b___0->flags & 8) != 0) {
        {
#line 758
        tmp___8 = gettext("\tignore next %ld hit(s)\n");
#line 758
        gprintf(out_fp, (char const   *)tmp___8, b___0->ignore_count);
        }
      }
#line 759
      if ((unsigned long )b___0->cndn.code != (unsigned long )((void *)0)) {
        {
#line 760
        tmp___9 = gettext("\tstop condition: %s\n");
#line 760
        gprintf(out_fp, (char const   *)tmp___9, b___0->cndn.expr);
        }
      }
#line 761
      if ((unsigned long )b___0->commands.next != (unsigned long )(& b___0->commands)) {
        {
#line 762
        tmp___10 = gettext("\tcommands:\n");
#line 762
        gprintf(out_fp, (char const   *)tmp___10);
        }
      }
#line 763
      c = b___0->commands.next;
      {
#line 763
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 763
        if (! ((unsigned long )c != (unsigned long )(& b___0->commands))) {
#line 763
          goto while_break___1;
        }
        {
#line 764
        gprintf(out_fp, "\t%s\n", c->cmd_string);
        }
#line 765
        if (c->cmd == 14) {
          {
#line 767
          a = c->arg;
#line 768
          start = strchr((char const   *)a->value.sval, '{');
#line 769
          end = strrchr((char const   *)a->value.sval, '}');
          }
#line 770
          if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 771
            goto __Cont;
          } else
#line 770
          if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 771
            goto __Cont;
          }
          {
#line 772
          start ++;
#line 773
          *end = (char )'\000';
#line 774
          gprintf(out_fp, "%s", start);
#line 775
          *end = (char )'}';
          }
        }
        __Cont: /* CIL Label */ 
#line 763
        c = c->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 746
      b___0 = b___0->prev;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 780
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 783
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 783
    if (! prog_running) {
      {
#line 783
      tmp___12 = gettext("program not running.");
#line 783
      d_error((char const   *)tmp___12);
      }
#line 783
      return (0);
    }
#line 783
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 784
  tmp___13 = gettext("Current frame: ");
#line 784
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___13);
#line 785
  print_numbered_frame(cur_frame);
  }
#line 786
  if (cur_frame < fcall_count) {
    {
#line 787
    tmp___14 = gettext("Called by frame: ");
#line 787
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___14);
#line 788
    print_numbered_frame(cur_frame + 1L);
    }
  }
#line 790
  if (cur_frame > 0L) {
    {
#line 791
    tmp___15 = gettext("Caller of frame: ");
#line 791
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___15);
#line 792
    print_numbered_frame(cur_frame - 1L);
    }
  }
#line 794
  goto switch_break;
  case_7: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 804
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 804
    if (! prog_running) {
      {
#line 804
      tmp___16 = gettext("program not running.");
#line 804
      d_error((char const   *)tmp___16);
      }
#line 804
      return (0);
    }
#line 804
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 805
  f = find_frame(cur_frame);
#line 806
  func___1 = f->sub.nodep.x.extra;
  }
#line 807
  if ((unsigned long )func___1 == (unsigned long )((void *)0)) {
    {
#line 809
    tmp___17 = gettext("None in main().\n");
#line 809
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___17);
    }
#line 810
    return (0);
  }
#line 813
  pcount = (int )func___1->sub.nodep.l.ll;
#line 815
  pc = f->sub.nodep.l.li;
#line 816
  arg_count = (int )(pc + 1)->x.xl;
#line 818
  if (arg_count > pcount) {
#line 819
    arg_count = pcount;
  }
#line 820
  if (arg->value.lval == 1L) {
#line 821
    from = 0;
#line 822
    to = arg_count - 1;
  } else {
#line 824
    from = arg_count;
#line 825
    to = pcount - 1;
  }
#line 828
  i___0 = from;
  {
#line 828
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 828
    if (! (i___0 <= to)) {
#line 828
      goto while_break___4;
    }
#line 830
    r = *(f->sub.nodep.r.av + i___0);
#line 831
    if ((unsigned int )r->type == 11U) {
#line 832
      r = r->sub.nodep.l.lptr;
    }
    {
#line 833
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s = ",
            (func___1->sub.nodep.rn + i___0)->sub.nodep.name);
#line 834
    print_symbol(r, (_Bool)1);
#line 828
    i___0 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 836
  if (to < from) {
#line 837
    if (arg->value.lval == 1L) {
      {
#line 837
      tmp___18 = gettext("No arguments.\n");
#line 837
      tmp___20 = tmp___18;
      }
    } else {
      {
#line 837
      tmp___19 = gettext("No locals.\n");
#line 837
      tmp___20 = tmp___19;
      }
    }
    {
#line 837
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s",
            tmp___20);
    }
  }
#line 842
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 845
  table = variable_list();
#line 846
  initialize_pager(out_fp);
#line 847
  tmp___22 = _setjmp((struct __jmp_buf_tag *)(pager_quit_tag));
  }
#line 847
  if (tmp___22 == 0) {
    {
#line 848
    tmp___21 = gettext("All defined variables:\n\n");
#line 848
    gprintf(out_fp, (char const   *)tmp___21);
#line 849
    print_vars(table, & gprintf, out_fp);
    }
  }
  {
#line 851
  free((void *)table);
  }
#line 852
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 855
  table = function_list((_Bool)1);
#line 856
  initialize_pager(out_fp);
#line 857
  tmp___24 = _setjmp((struct __jmp_buf_tag *)(pager_quit_tag));
  }
#line 857
  if (tmp___24 == 0) {
    {
#line 858
    tmp___23 = gettext("All defined functions:\n\n");
#line 858
    gprintf(out_fp, (char const   *)tmp___23);
#line 859
    pf_data.print_func = & gprintf;
#line 860
    pf_data.fp = out_fp;
#line 861
    pf_data.defn = (_Bool)1;
#line 862
    foreach_func(table, & print_function, (void *)(& pf_data));
    }
  }
  {
#line 866
  free((void *)table);
  }
#line 867
  goto switch_break;
  case_14: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 871
  initialize_pager(out_fp);
#line 872
  tmp___33 = _setjmp((struct __jmp_buf_tag *)(pager_quit_tag));
  }
#line 872
  if (tmp___33 == 0) {
#line 875
    if (arg->value.lval == 4L) {
      {
#line 876
      list = & display_list;
#line 877
      tmp___25 = gettext("Auto-display variables:\n\n");
#line 877
      gprintf(out_fp, (char const   *)tmp___25);
      }
    } else {
      {
#line 879
      list = & watch_list;
#line 880
      tmp___26 = gettext("Watch variables:\n\n");
#line 880
      gprintf(out_fp, (char const   *)tmp___26);
      }
    }
#line 882
    d = list->prev;
    {
#line 882
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 882
      if (! ((unsigned long )d != (unsigned long )list)) {
#line 882
        goto while_break___5;
      }
#line 885
      symbol = d->symbol;
#line 887
      if ((d->flags & 2) != 0) {
        {
#line 888
        gprintf(out_fp, "%d:\t%s", d->number, d->sname);
#line 889
        i___1 = 0;
        }
        {
#line 889
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 889
          if (! (i___1 < d->num_subs)) {
#line 889
            goto while_break___6;
          }
          {
#line 891
          sub = *(d->subs + i___1);
#line 892
          gprintf(out_fp, "[\"%s\"]", sub->sub.val.sp);
#line 889
          i___1 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 894
        gprintf(out_fp, "\n");
        }
      } else
#line 895
      if ((d->flags & 4) != 0) {
#line 896
        if (symbol->flags & 2048U) {
          {
#line 896
          tmp___27 = mpfr_get_si((mpfr_srcptr )(symbol->sub.val.nm.mpnum), ROUND_MODE);
#line 896
          tmp___30 = tmp___27;
          }
        } else {
#line 896
          if (symbol->flags & 4096U) {
            {
#line 896
            tmp___28 = __gmpz_get_si((mpz_srcptr )(symbol->sub.val.nm.mpi));
#line 896
            tmp___29 = tmp___28;
            }
          } else {
#line 896
            tmp___29 = (long )symbol->sub.val.nm.fltnum;
          }
#line 896
          tmp___30 = tmp___29;
        }
        {
#line 896
        gprintf(out_fp, "%d:\t$%ld\n", d->number, tmp___30);
        }
      } else {
        {
#line 898
        gprintf(out_fp, "%d:\t%s\n", d->number, d->sname);
        }
      }
#line 899
      if ((unsigned long )d->cndn.code != (unsigned long )((void *)0)) {
        {
#line 900
        tmp___31 = gettext("\tstop condition: %s\n");
#line 900
        gprintf(out_fp, (char const   *)tmp___31, d->cndn.expr);
        }
      }
#line 901
      if ((unsigned long )d->commands.next != (unsigned long )(& d->commands)) {
        {
#line 902
        tmp___32 = gettext("\tcommands:\n");
#line 902
        gprintf(out_fp, (char const   *)tmp___32);
        }
      }
#line 903
      c___0 = d->commands.next;
      {
#line 903
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 903
        if (! ((unsigned long )c___0 != (unsigned long )(& d->commands))) {
#line 903
          goto while_break___7;
        }
        {
#line 904
        gprintf(out_fp, "\t%s\n", c___0->cmd_string);
        }
#line 905
        if (c___0->cmd == 14) {
          {
#line 907
          a___0 = c___0->arg;
#line 908
          start___0 = strchr((char const   *)a___0->value.sval, '{');
#line 909
          end___0 = strrchr((char const   *)a___0->value.sval, '}');
          }
#line 910
          if ((unsigned long )start___0 == (unsigned long )((void *)0)) {
#line 911
            goto __Cont___0;
          } else
#line 910
          if ((unsigned long )end___0 == (unsigned long )((void *)0)) {
#line 911
            goto __Cont___0;
          }
          {
#line 912
          start___0 ++;
#line 913
          *end___0 = (char )'\000';
#line 914
          gprintf(out_fp, "%s", start___0);
#line 915
          *end___0 = (char )'}';
          }
        }
        __Cont___0: /* CIL Label */ 
#line 903
        c___0 = c___0->next;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 882
      d = d->prev;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 921
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 924
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 927
  return (0);
}
}
#line 932 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void print_symbol(NODE *r , _Bool isparam ) 
{ 
  struct exp_node **tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 936
  if ((unsigned int )r->type == 6U) {
#line 936
    goto case_6;
  }
#line 939
  if ((unsigned int )r->type == 4U) {
#line 939
    goto case_4;
  }
#line 944
  if ((unsigned int )r->type == 5U) {
#line 944
    goto case_5;
  }
#line 947
  if ((unsigned int )r->type == 8U) {
#line 947
    goto case_8;
  }
#line 950
  goto switch_default;
  case_6: /* CIL Label */ 
  {
#line 937
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"untyped variable\n");
  }
#line 938
  goto switch_break;
  case_4: /* CIL Label */ 
#line 940
  if (! isparam) {
#line 940
    if (r->sub.nodep.r.uptr) {
      {
#line 941
      (*(r->sub.nodep.r.uptr))();
      }
    }
  }
  {
#line 942
  valinfo(r->sub.nodep.l.lptr, (int (*)(FILE * , char const   *  , ...))(& fprintf),
          out_fp);
  }
#line 943
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 945
  tmp___1 = (*(*(r->sub.nodep.l.lp + 2)))(r, (struct exp_node *)((void *)0));
#line 945
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"array, %ld elements\n",
          (*tmp___1)->sub.nodep.reflags);
  }
#line 946
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 948
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"`function\'\n");
  }
#line 949
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 951
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 953
  return;
}
}
#line 957 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static NODE *find_frame(long num ) 
{ 


  {
#line 961
  if (num == 0L) {
#line 962
    return (frame_ptr);
  }
#line 967
  return (*(fcall_list + num));
}
}
#line 972 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static NODE *find_param(char const   *name , long num , char **pname ) 
{ 
  NODE *r ;
  NODE *f ;
  char *fparam ;
  NODE *func___1 ;
  int i___0 ;
  int pcount ;
  int tmp___1 ;

  {
#line 975
  r = (NODE *)((void *)0);
#line 979
  if (pname) {
#line 980
    *pname = (char *)((void *)0);
  }
#line 982
  if (num < 0L) {
#line 983
    return ((NODE *)((void *)0));
  } else
#line 982
  if (num > fcall_count) {
#line 983
    return ((NODE *)((void *)0));
  } else
#line 982
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 983
    return ((NODE *)((void *)0));
  }
  {
#line 984
  f = find_frame(num);
  }
#line 985
  if ((unsigned long )f->sub.nodep.x.extra != (unsigned long )((void *)0)) {
#line 989
    func___1 = f->sub.nodep.x.extra;
#line 990
    pcount = (int )func___1->sub.nodep.l.ll;
#line 991
    i___0 = 0;
    {
#line 991
    while (1) {
      while_continue: /* CIL Label */ ;
#line 991
      if (! (i___0 < pcount)) {
#line 991
        goto while_break;
      }
      {
#line 992
      fparam = (func___1->sub.nodep.rn + i___0)->sub.nodep.name;
#line 993
      tmp___1 = strcmp(name, (char const   *)fparam);
      }
#line 993
      if (tmp___1 == 0) {
#line 994
        r = *(f->sub.nodep.r.av + i___0);
#line 995
        if ((unsigned int )r->type == 11U) {
#line 996
          r = r->sub.nodep.l.lptr;
        }
#line 997
        if (pname) {
#line 998
          *pname = fparam;
        }
#line 999
        goto while_break;
      }
#line 991
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1003
  return (r);
}
}
#line 1008 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static NODE *find_symbol(char const   *name , char **pname ) 
{ 
  NODE *r ;
  char *tmp___1 ;
  char *__cil_tmp5 ;

  {
#line 1011
  r = (NODE *)((void *)0);
#line 1013
  if (pname) {
#line 1014
    *pname = (char *)((void *)0);
  }
#line 1015
  if (prog_running) {
    {
#line 1016
    r = find_param(name, cur_frame, pname);
    }
  }
#line 1017
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 1018
    r = lookup(name);
    }
  }
#line 1019
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 1020
    tmp___1 = gettext("no symbol `%s\' in current context\n");
#line 1020
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
            name);
    }
  }
#line 1021
  return (r);
}
}
#line 1026 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static NODE *find_array(char const   *name ) 
{ 
  NODE *r ;
  char *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 1030
  r = find_symbol(name, (char **)((void *)0));
  }
#line 1031
  if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 1031
    if ((unsigned int )r->type != 5U) {
      {
#line 1032
      tmp___1 = gettext("`%s\' is not an array\n");
#line 1032
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
              name);
      }
#line 1033
      return ((NODE *)((void *)0));
    }
  }
#line 1035
  return (r);
}
}
#line 1040 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void print_field(long field_num ) 
{ 
  NODE **lhs ;
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1044
  lhs = get_field(field_num, (Func_ptr *)((void *)0));
  }
#line 1045
  if ((unsigned long )*lhs == (unsigned long )Null_field) {
    {
#line 1046
    tmp___1 = gettext("$%ld = uninitialized field\n");
#line 1046
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
            field_num);
    }
  } else
#line 1045
  if ((unsigned long )*lhs == (unsigned long )Nnull_string) {
    {
#line 1046
    tmp___1 = gettext("$%ld = uninitialized field\n");
#line 1046
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
            field_num);
    }
  } else {
    {
#line 1048
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"$%ld = ",
            field_num);
#line 1049
    valinfo(*lhs, (int (*)(FILE * , char const   *  , ...))(& fprintf), out_fp);
    }
  }
#line 1051
  return;
}
}
#line 1055 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int print_array(NODE volatile   *arr , char *arr_name ) 
{ 
  NODE *subs ;
  NODE **list ;
  int i___0 ;
  size_t num_elems ;
  NODE volatile   *r ;
  int volatile   ret ;
  jmp_buf volatile   pager_quit_tag_stack ;
  char *tmp___1 ;
  struct exp_node **tmp___2 ;
  struct exp_node **tmp___3 ;
  _Bool tmp___4 ;
  struct exp_node **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 1061
  num_elems = (size_t )0;
#line 1063
  ret = (int volatile   )0;
#line 1066
  tmp___2 = (*(*(((NODE *)arr)->sub.nodep.l.lp + 2)))((NODE *)arr, (struct exp_node *)((void *)0));
  }
#line 1066
  if ((*tmp___2)->sub.nodep.reflags == 0UL) {
    {
#line 1067
    tmp___1 = gettext("array `%s\' is empty\n");
#line 1067
    gprintf(out_fp, (char const   *)tmp___1, arr_name);
    }
#line 1068
    return (0);
  }
  {
#line 1071
  tmp___3 = (*(*(((NODE *)arr)->sub.nodep.l.lp + 2)))((NODE *)arr, (struct exp_node *)((void *)0));
#line 1071
  num_elems = (*tmp___3)->sub.nodep.reflags;
#line 1074
  list = assoc_list((NODE *)arr, "@ind_str_asc", (sort_context_t )1);
#line 1076
  tmp___4 = pager_quit_tag_valid;
#line 1076
  pager_quit_tag_valid = (_Bool )((int )pager_quit_tag_valid + 1);
  }
#line 1076
  if (tmp___4) {
    {
#line 1076
    memcpy((void */* __restrict  */)((char *)(pager_quit_tag_stack)), (void const   */* __restrict  */)((char const   *)(pager_quit_tag)),
           sizeof(jmp_buf ));
    }
  }
  {
#line 1077
  tmp___7 = _setjmp((struct __jmp_buf_tag *)(pager_quit_tag));
  }
#line 1077
  if (tmp___7 == 0) {
#line 1078
    i___0 = 0;
    {
#line 1078
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1078
      if (ret == (int volatile   )0) {
#line 1078
        if (! ((size_t )i___0 < num_elems)) {
#line 1078
          goto while_break;
        }
      } else {
#line 1078
        goto while_break;
      }
      {
#line 1079
      subs = *(list + i___0);
#line 1080
      tmp___5 = (*(*(((NODE *)arr)->sub.nodep.l.lp + 3)))((NODE *)arr, subs);
#line 1080
      r = (NODE volatile   *)*tmp___5;
      }
#line 1081
      if ((unsigned int volatile   )r->type == (unsigned int volatile   )5) {
        {
#line 1082
        tmp___6 = print_array(r, (char *)r->sub.nodep.name);
#line 1082
        ret = (int volatile   )tmp___6;
        }
      } else {
        {
#line 1084
        gprintf(out_fp, "%s[\"%s\"] = ", arr_name, subs->sub.val.sp);
#line 1085
        valinfo((NODE *)r, & gprintf, out_fp);
        }
      }
#line 1078
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1089
    ret = (int volatile   )1;
  }
#line 1091
  pager_quit_tag_valid = (_Bool )((int )pager_quit_tag_valid - 1);
#line 1091
  if (pager_quit_tag_valid) {
    {
#line 1091
    memcpy((void */* __restrict  */)((char *)(pager_quit_tag)), (void const   */* __restrict  */)((char const   *)(pager_quit_tag_stack)),
           sizeof(jmp_buf ));
    }
  }
#line 1093
  i___0 = 0;
  {
#line 1093
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1093
    if (! ((size_t )i___0 < num_elems)) {
#line 1093
      goto while_break___0;
    }
    {
#line 1094
    unref(*(list + i___0));
#line 1093
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1095
  free((void *)list);
  }
#line 1097
  return ((int )ret);
}
}
#line 1102 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void print_subscript(NODE *arr , char *arr_name , CMDARG *a , int count ) 
{ 
  NODE *r ;
  NODE *subs ;
  char *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1107
  subs = a->value.nodeval;
#line 1108
  r = in_array(arr, subs);
  }
#line 1109
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 1110
    tmp___1 = gettext("[\"%s\"] not in array `%s\'\n");
#line 1110
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
            subs->sub.val.sp, arr_name);
    }
  } else
#line 1111
  if ((unsigned int )r->type == 5U) {
#line 1112
    if (count > 1) {
      {
#line 1113
      print_subscript(r, r->sub.nodep.name, a->next, count - 1);
      }
    } else {
      {
#line 1116
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s = ",
              r->sub.nodep.name);
#line 1117
      print_symbol(r, (_Bool)0);
      }
    }
  } else {
    {
#line 1120
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s[\"%s\"] = ",
            arr_name, subs->sub.val.sp);
#line 1121
    valinfo(r, (int (*)(FILE * , char const   *  , ...))(& fprintf), out_fp);
    }
  }
#line 1123
  return;
}
}
#line 1127 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_print_var(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  NODE *r ;
  CMDARG *a ;
  char *name ;
  char *pname ;
  int count ;
  NODE *value ;
  NODE *subs ;
  char *tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1134
  a = arg;
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 1134
      goto while_break;
    }
    {
#line 1136
    if ((unsigned int )a->type == 45U) {
#line 1136
      goto case_45;
    }
#line 1144
    if ((unsigned int )a->type == 49U) {
#line 1144
      goto case_49;
    }
#line 1152
    if ((unsigned int )a->type == 48U) {
#line 1152
      goto case_48;
    }
#line 1181
    if ((unsigned int )a->type == 47U) {
#line 1181
      goto case_47;
    }
#line 1185
    goto switch_default;
    case_45: /* CIL Label */ 
    {
#line 1137
    name = a->value.sval;
#line 1138
    r = find_symbol((char const   *)name, & pname);
    }
#line 1138
    if ((unsigned long )r != (unsigned long )((void *)0)) {
      {
#line 1139
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s = ",
              name);
#line 1140
      print_symbol(r, (_Bool )((unsigned long )pname != (unsigned long )((void *)0)));
      }
    }
#line 1142
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 1146
    name = a->value.sval;
#line 1147
    r = find_array((char const   *)name);
    }
#line 1148
    if ((unsigned long )r != (unsigned long )((void *)0)) {
      {
#line 1149
      print_subscript(r, name, a->next, a->a_count);
      }
    }
#line 1150
    goto switch_break;
    case_48: /* CIL Label */ 
    {
#line 1153
    name = a->value.sval;
#line 1154
    r = find_array((char const   *)name);
    }
#line 1154
    if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 1155
      count = a->a_count;
      {
#line 1156
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1156
        if (! (count > 0)) {
#line 1156
          goto while_break___0;
        }
        {
#line 1158
        a = a->next;
#line 1159
        subs = a->value.nodeval;
#line 1160
        value = in_array(r, subs);
        }
#line 1161
        if ((unsigned long )value == (unsigned long )((void *)0)) {
          {
#line 1162
          tmp___1 = gettext("[\"%s\"] not in array `%s\'\n");
#line 1162
          fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
                  subs->sub.val.sp, name);
          }
#line 1164
          goto while_break___0;
        } else
#line 1165
        if ((unsigned int )value->type != 5U) {
          {
#line 1166
          tmp___2 = gettext("`%s[\"%s\"]\' is not an array\n");
#line 1166
          fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2,
                  name, subs->sub.val.sp);
          }
#line 1168
          goto while_break___0;
        } else {
#line 1170
          r = value;
#line 1171
          name = r->sub.nodep.name;
        }
#line 1156
        count --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1174
      if (count == 0) {
        {
#line 1175
        initialize_pager(out_fp);
#line 1176
        print_array((NODE volatile   *)r, name);
        }
      }
    }
#line 1179
    goto switch_break;
    case_47: /* CIL Label */ 
#line 1182
    if ((a->value.nodeval)->flags & 2048U) {
      {
#line 1182
      tmp___3 = mpfr_get_si((mpfr_srcptr )((a->value.nodeval)->sub.val.nm.mpnum),
                            ROUND_MODE);
#line 1182
      tmp___6 = tmp___3;
      }
    } else {
#line 1182
      if ((a->value.nodeval)->flags & 4096U) {
        {
#line 1182
        tmp___4 = __gmpz_get_si((mpz_srcptr )((a->value.nodeval)->sub.val.nm.mpi));
#line 1182
        tmp___5 = tmp___4;
        }
      } else {
#line 1182
        tmp___5 = (long )(a->value.nodeval)->sub.val.nm.fltnum;
      }
#line 1182
      tmp___6 = tmp___5;
    }
    {
#line 1182
    print_field(tmp___6);
    }
#line 1183
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1187
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1134
    a = a->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1190
  return (0);
}
}
#line 1195 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_set_var(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  NODE *r ;
  NODE *val ;
  NODE **lhs ;
  char *name ;
  char *pname ;
  char *tmp___1 ;
  NODE *subs ;
  NODE *value ;
  int count ;
  char *tmp___2 ;
  NODE *array ;
  char *tmp___3 ;
  long field_num ;
  void (*assign)(void) ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 1203
  if ((unsigned int )arg->type == 45U) {
#line 1203
    goto case_45;
  }
#line 1232
  if ((unsigned int )arg->type == 49U) {
#line 1232
    goto case_49;
  }
#line 1283
  if ((unsigned int )arg->type == 47U) {
#line 1283
    goto case_47;
  }
#line 1301
  goto switch_default___0;
  case_45: /* CIL Label */ 
  {
#line 1204
  name = arg->value.sval;
#line 1205
  arg = arg->next;
#line 1206
  val = arg->value.nodeval;
#line 1208
  r = find_symbol((char const   *)name, & pname);
  }
#line 1208
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1209
    goto switch_break;
  }
  {
#line 1212
  if ((unsigned int )r->type == 6U) {
#line 1212
    goto case_6;
  }
#line 1216
  if ((unsigned int )r->type == 4U) {
#line 1216
    goto case_4;
  }
#line 1226
  goto switch_default;
  case_6: /* CIL Label */ 
  {
#line 1213
  r->type = (NODETYPE )4;
#line 1214
  r->sub.nodep.l.lptr = dupnode(Nnull_string);
  }
  case_4: /* CIL Label */ 
  {
#line 1217
  lhs = & r->sub.nodep.l.lptr;
#line 1218
  unref(*lhs);
#line 1219
  *lhs = dupnode(val);
  }
#line 1220
  if ((unsigned long )pname == (unsigned long )((void *)0)) {
#line 1220
    if ((unsigned long )r->sub.nodep.x.aptr != (unsigned long )((void *)0)) {
      {
#line 1221
      (*(r->sub.nodep.x.aptr))();
      }
    }
  }
  {
#line 1222
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s = ",
          name);
#line 1223
  print_symbol(r, (_Bool )((unsigned long )pname != (unsigned long )((void *)0)));
  }
#line 1224
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 1227
  tmp___1 = gettext("`%s\' is not a scalar variable");
#line 1227
  d_error((char const   *)tmp___1, name);
  }
#line 1228
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1230
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 1235
  count = arg->a_count;
#line 1238
  name = arg->value.sval;
#line 1239
  r = find_array((char const   *)name);
  }
#line 1240
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1241
    goto switch_break;
  }
  {
#line 1242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1242
    if (! (count > 0)) {
#line 1242
      goto while_break;
    }
    {
#line 1243
    arg = arg->next;
#line 1244
    subs = arg->value.nodeval;
#line 1245
    value = in_array(r, subs);
    }
#line 1247
    if (count == 1) {
#line 1248
      if ((unsigned long )value != (unsigned long )((void *)0)) {
#line 1248
        if ((unsigned int )value->type == 5U) {
          {
#line 1249
          tmp___2 = gettext("attempt to use array `%s[\"%s\"]\' in a scalar context");
#line 1249
          d_error((char const   *)tmp___2, name, subs->sub.val.sp);
          }
        } else {
#line 1248
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1252
        arg = arg->next;
#line 1253
        val = arg->value.nodeval;
#line 1254
        lhs = (*(*(r->sub.nodep.l.lp + 3)))(r, subs);
#line 1255
        unref(*lhs);
#line 1256
        *lhs = dupnode(val);
#line 1257
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s[\"%s\"] = ",
                name, subs->sub.val.sp);
#line 1258
        valinfo(*lhs, (int (*)(FILE * , char const   *  , ...))(& fprintf), out_fp);
        }
      }
    } else
#line 1261
    if ((unsigned long )value == (unsigned long )((void *)0)) {
      {
#line 1263
      array = make_array();
#line 1264
      array->sub.nodep.name = estrdup((char const   *)subs->sub.val.sp, subs->sub.val.slen);
#line 1265
      array->sub.nodep.x.extra = r;
#line 1266
      lhs = (*(*(r->sub.nodep.l.lp + 3)))(r, subs);
#line 1267
      unref(*lhs);
#line 1268
      *lhs = array;
#line 1269
      r = array;
      }
    } else
#line 1270
    if ((unsigned int )value->type != 5U) {
      {
#line 1271
      tmp___3 = gettext("attempt to use scalar `%s[\"%s\"]\' as array");
#line 1271
      d_error((char const   *)tmp___3, name, subs->sub.val.sp);
      }
#line 1273
      goto while_break;
    } else {
#line 1275
      r = value;
#line 1276
      name = r->sub.nodep.name;
    }
#line 1242
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1281
  goto switch_break;
  case_47: /* CIL Label */ 
#line 1286
  assign = (void (*)(void))((void *)0);
#line 1288
  if ((arg->value.nodeval)->flags & 2048U) {
    {
#line 1288
    tmp___4 = mpfr_get_si((mpfr_srcptr )((arg->value.nodeval)->sub.val.nm.mpnum),
                          ROUND_MODE);
#line 1288
    field_num = tmp___4;
    }
  } else {
#line 1288
    if ((arg->value.nodeval)->flags & 4096U) {
      {
#line 1288
      tmp___5 = __gmpz_get_si((mpz_srcptr )((arg->value.nodeval)->sub.val.nm.mpi));
#line 1288
      tmp___6 = tmp___5;
      }
    } else {
#line 1288
      tmp___6 = (long )(arg->value.nodeval)->sub.val.nm.fltnum;
    }
#line 1288
    field_num = tmp___6;
  }
  {
#line 1290
  arg = arg->next;
#line 1291
  val = arg->value.nodeval;
#line 1292
  lhs = get_field(field_num, & assign);
#line 1293
  unref(*lhs);
#line 1294
  *lhs = dupnode(val);
  }
#line 1295
  if (assign) {
    {
#line 1296
    (*assign)();
    }
  }
  {
#line 1297
  print_field(field_num);
  }
#line 1299
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 1302
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1304
  return (0);
}
}
#line 1309 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct list_item *find_item(struct list_item *list , long num ) 
{ 
  struct list_item *d ;

  {
#line 1314
  if (num <= 0L) {
#line 1315
    return ((struct list_item *)((void *)0));
  }
#line 1316
  d = list->next;
  {
#line 1316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1316
    if (! ((unsigned long )d != (unsigned long )list)) {
#line 1316
      goto while_break;
    }
#line 1317
    if ((long )d->number == num) {
#line 1318
      return (d);
    }
#line 1316
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1320
  return ((struct list_item *)((void *)0));
}
}
#line 1325 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void delete_item(struct list_item *d ) 
{ 
  struct commands_item *c ;
  int i___0 ;

  {
#line 1331
  if ((d->flags & 2) != 0) {
#line 1332
    i___0 = 0;
    {
#line 1332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1332
      if (! (i___0 < d->num_subs)) {
#line 1332
        goto while_break;
      }
      {
#line 1333
      unref(*(d->subs + i___0));
#line 1332
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1334
    free((void *)d->subs);
    }
  } else
#line 1335
  if ((d->flags & 4) != 0) {
    {
#line 1336
    unref(d->symbol);
    }
  }
#line 1338
  if ((d->flags & 16) == 0) {
    {
#line 1339
    unref(d->value[0].n);
    }
  }
#line 1340
  if ((d->flags & 8) == 0) {
    {
#line 1341
    unref(d->value[1].n);
    }
  }
#line 1344
  c = d->commands.next;
  {
#line 1344
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1344
    if (! ((unsigned long )c != (unsigned long )(& d->commands))) {
#line 1344
      goto while_break___0;
    }
    {
#line 1345
    c = c->prev;
#line 1346
    delete_commands_item(c->next);
#line 1344
    c = c->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1349
  free_context(d->cndn.ctxt, (_Bool)0);
  }
#line 1350
  if ((unsigned long )d->cndn.expr != (unsigned long )((void *)0)) {
    {
#line 1351
    free((void *)d->cndn.expr);
    }
  }
  {
#line 1353
  (d->next)->prev = d->prev;
#line 1354
  (d->prev)->next = d->next;
#line 1355
  free((void *)d);
  }
#line 1356
  return;
}
}
#line 1360 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct list_item *add_item(struct list_item *list , int type , NODE *symbol ,
                                  char *pname ) 
{ 
  struct list_item *d ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  struct commands_item *tmp___6 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 1365
  tmp___1 = malloc(sizeof(struct list_item ));
#line 1365
  d = (struct list_item *)tmp___1;
  }
#line 1365
  if (d) {
#line 1365
    tmp___5 = 1;
  } else {
    {
#line 1365
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 1365);
#line 1365
    tmp___2 = __errno_location();
#line 1365
    tmp___3 = strerror(*tmp___2);
#line 1365
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1365
    r_fatal((char const   *)tmp___4, "add_item", "d", (long )sizeof(struct list_item ),
            tmp___3);
#line 1365
    tmp___5 = 0;
    }
  }
  {
#line 1366
  memset((void *)d, 0, sizeof(struct list_item ));
#line 1367
  tmp___6 = & d->commands;
#line 1367
  d->commands.prev = tmp___6;
#line 1367
  d->commands.next = tmp___6;
#line 1369
  (list->number) ++;
#line 1369
  d->number = list->number;
#line 1370
  d->sname = symbol->sub.nodep.name;
  }
#line 1371
  if ((unsigned long )pname != (unsigned long )((void *)0)) {
#line 1372
    d->sname = pname;
#line 1373
    d->flags |= 1;
#line 1374
    d->fcall_count = fcall_count - cur_frame;
  }
#line 1377
  if (type == 47) {
#line 1379
    d->symbol = symbol;
#line 1380
    d->flags |= 4;
  } else
#line 1381
  if (type == 49) {
#line 1383
    d->symbol = symbol;
#line 1384
    d->flags |= 2;
  } else {
#line 1387
    d->symbol = symbol;
  }
#line 1391
  d->next = list->next;
#line 1392
  d->prev = list;
#line 1393
  list->next = d;
#line 1394
  (d->next)->prev = d;
#line 1395
  return (d);
}
}
#line 1400 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct list_item *do_add_item(struct list_item *list , CMDARG *arg ) 
{ 
  NODE *symbol ;
  char *name ;
  char *pname ;
  struct list_item *item ;
  char *tmp___1 ;
  char *tmp___2 ;
  NODE **subs ;
  int count ;
  int i___0 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 1403
  symbol = (NODE *)((void *)0);
#line 1404
  pname = (char *)((void *)0);
#line 1405
  item = (struct list_item *)((void *)0);
  {
#line 1409
  if ((unsigned int )arg->type == 45U) {
#line 1409
    goto case_45;
  }
#line 1409
  if ((unsigned int )arg->type == 49U) {
#line 1409
    goto case_45;
  }
#line 1440
  if ((unsigned int )arg->type == 47U) {
#line 1440
    goto case_47;
  }
#line 1445
  goto switch_default;
  case_45: /* CIL Label */ 
  case_49: /* CIL Label */ 
  {
#line 1410
  name = arg->value.sval;
#line 1411
  symbol = find_symbol((char const   *)name, & pname);
  }
#line 1411
  if ((unsigned long )symbol == (unsigned long )((void *)0)) {
#line 1412
    return ((struct list_item *)((void *)0));
  }
#line 1413
  if ((unsigned int )symbol->type == 8U) {
    {
#line 1414
    tmp___1 = gettext("`%s\' is a function");
#line 1414
    d_error((char const   *)tmp___1, name);
    }
#line 1415
    return ((struct list_item *)((void *)0));
  }
#line 1417
  if ((unsigned int )arg->type == 49U) {
#line 1417
    if ((unsigned int )symbol->type != 5U) {
      {
#line 1418
      tmp___2 = gettext("`%s\' is not an array\n");
#line 1418
      d_error((char const   *)tmp___2, name);
      }
#line 1419
      return ((struct list_item *)((void *)0));
    }
  }
  {
#line 1422
  item = add_item(list, (int )arg->type, symbol, pname);
  }
#line 1423
  if ((unsigned long )item != (unsigned long )((void *)0)) {
#line 1423
    if ((unsigned int )arg->type == 49U) {
      {
#line 1425
      count = arg->a_count;
#line 1429
      tmp___3 = malloc((unsigned long )count * sizeof(NODE *));
#line 1429
      subs = (NODE **)tmp___3;
      }
#line 1429
      if (subs) {
#line 1429
        tmp___7 = 1;
      } else {
        {
#line 1429
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 1429);
#line 1429
        tmp___4 = __errno_location();
#line 1429
        tmp___5 = strerror(*tmp___4);
#line 1429
        tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1429
        r_fatal((char const   *)tmp___6, "do_add_item", "subs", (long )((unsigned long )count * sizeof(NODE *)),
                tmp___5);
#line 1429
        tmp___7 = 0;
        }
      }
#line 1430
      i___0 = 0;
      {
#line 1430
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1430
        if (! (i___0 < count)) {
#line 1430
          goto while_break;
        }
        {
#line 1431
        arg = arg->next;
#line 1432
        *(subs + i___0) = dupnode(arg->value.nodeval);
#line 1433
        *(subs + i___0) = force_string(*(subs + i___0));
#line 1430
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1435
      item->subs = subs;
#line 1436
      item->num_subs = count;
    }
  }
#line 1438
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 1441
  symbol = dupnode(arg->value.nodeval);
#line 1442
  item = add_item(list, 47, symbol, (char *)((void *)0));
  }
#line 1443
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1446
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1450
  if ((unsigned long )list == (unsigned long )(& watch_list)) {
#line 1451
    arg = arg->next;
#line 1452
    if ((unsigned long )item != (unsigned long )((void *)0)) {
#line 1452
      if ((unsigned long )arg != (unsigned long )((void *)0)) {
        {
#line 1453
        tmp___9 = parse_condition(41, item->number, arg->value.sval);
        }
#line 1453
        if (tmp___9 == 0) {
#line 1454
          arg->value.sval = (char *)((void *)0);
        } else {
          {
#line 1456
          tmp___8 = gettext("watchpoint %d is unconditional\n");
#line 1456
          fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___8,
                  item->number);
          }
        }
      }
    }
  }
#line 1459
  return (item);
}
}
#line 1464 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void do_delete_item(struct list_item *list , CMDARG *arg ) 
{ 
  struct list_item *d ;
  long i___0 ;
  long j ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1467
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 1468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1468
      if (! ((unsigned long )list->next != (unsigned long )list)) {
#line 1468
        goto while_break;
      }
      {
#line 1469
      delete_item(list->next);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1472
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1472
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 1472
      goto while_break___0;
    }
#line 1474
    if ((unsigned int )arg->type == 51U) {
#line 1477
      i___0 = arg->value.lval;
#line 1478
      arg = arg->next;
#line 1479
      j = arg->value.lval;
#line 1480
      if (j > (long )list->number) {
#line 1481
        j = (long )list->number;
      }
      {
#line 1482
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1482
        if (! (i___0 <= j)) {
#line 1482
          goto while_break___1;
        }
        {
#line 1483
        d = find_item(list, i___0);
        }
#line 1483
        if ((unsigned long )d != (unsigned long )((void *)0)) {
          {
#line 1484
          delete_item(d);
          }
        }
#line 1482
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 1487
      d = find_item(list, arg->value.lval);
      }
#line 1487
      if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 1489
        if ((unsigned long )list == (unsigned long )(& display_list)) {
          {
#line 1490
          tmp___1 = gettext("No display item numbered %ld");
#line 1490
          d_error((char const   *)tmp___1, arg->value.lval);
          }
        } else {
          {
#line 1493
          tmp___2 = gettext("No watch item numbered %ld");
#line 1493
          d_error((char const   *)tmp___2, arg->value.lval);
          }
        }
      } else {
        {
#line 1496
        delete_item(d);
        }
      }
    }
#line 1472
    arg = arg->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1499
  return;
}
}
#line 1503 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void display(struct list_item *d ) 
{ 
  NODE *symbol ;
  NODE *sub ;
  NODE *r ;
  int i___0 ;
  int count ;
  char *tmp___1 ;
  NODE *r___0 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1508
  symbol = d->symbol;
#line 1509
  if ((d->flags & 1) != 0) {
#line 1509
    if (d->fcall_count != fcall_count - cur_frame) {
#line 1510
      return;
    }
  }
#line 1512
  if ((d->flags & 2) != 0) {
#line 1514
    i___0 = 0;
#line 1514
    count = d->num_subs;
#line 1515
    i___0 = 0;
    {
#line 1515
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1515
      if (! (i___0 < count)) {
#line 1515
        goto while_break;
      }
      {
#line 1516
      sub = *(d->subs + i___0);
#line 1517
      r = in_array(symbol, sub);
      }
#line 1518
      if ((unsigned long )r == (unsigned long )((void *)0)) {
        {
#line 1519
        tmp___1 = gettext("%d: [\"%s\"] not in array `%s\'\n");
#line 1519
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
                d->number, sub->sub.val.sp, d->sname);
        }
#line 1521
        goto while_break;
      }
#line 1523
      if ((unsigned int )r->type == 5U) {
#line 1524
        symbol = r;
#line 1525
        if (i___0 == count - 1) {
#line 1526
          goto print_sym;
        }
      } else {
#line 1528
        if (i___0 != count - 1) {
#line 1529
          return;
        }
        {
#line 1530
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%d: %s[\"%s\"] = ",
                d->number, d->sname, sub->sub.val.sp);
#line 1532
        valinfo(r, (int (*)(FILE * , char const   *  , ...))(& fprintf), out_fp);
        }
      }
#line 1515
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1535
  if ((d->flags & 4) != 0) {
    {
#line 1536
    r___0 = d->symbol;
#line 1537
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%d: ",
            d->number);
    }
#line 1538
    if (r___0->flags & 2048U) {
      {
#line 1538
      tmp___2 = mpfr_get_si((mpfr_srcptr )(r___0->sub.val.nm.mpnum), ROUND_MODE);
#line 1538
      tmp___5 = tmp___2;
      }
    } else {
#line 1538
      if (r___0->flags & 4096U) {
        {
#line 1538
        tmp___3 = __gmpz_get_si((mpz_srcptr )(r___0->sub.val.nm.mpi));
#line 1538
        tmp___4 = tmp___3;
        }
      } else {
#line 1538
        tmp___4 = (long )r___0->sub.val.nm.fltnum;
      }
#line 1538
      tmp___5 = tmp___4;
    }
    {
#line 1538
    print_field(tmp___5);
    }
  } else {
    print_sym: 
    {
#line 1541
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%d: %s = ",
            d->number, d->sname);
#line 1542
    print_symbol(symbol, (_Bool )((d->flags & 1) != 0));
    }
  }
#line 1544
  return;
}
}
#line 1549 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_display(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  struct list_item *d ;

  {
#line 1554
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 1556
    d = display_list.prev;
    {
#line 1556
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1556
      if (! ((unsigned long )d != (unsigned long )(& display_list))) {
#line 1556
        goto while_break;
      }
      {
#line 1557
      display(d);
#line 1556
      d = d->prev;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1558
    return (0);
  }
  {
#line 1561
  d = do_add_item(& display_list, arg);
  }
#line 1561
  if ((unsigned long )d != (unsigned long )((void *)0)) {
    {
#line 1562
    display(d);
    }
  }
#line 1564
  return (0);
}
}
#line 1569 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_undisplay(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1572
  do_delete_item(& display_list, arg);
  }
#line 1573
  return (0);
}
}
#line 1578 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int condition_triggered(struct condition *cndn ) 
{ 
  NODE *r ;
  int di ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1585
  if ((unsigned long )cndn->code == (unsigned long )((void *)0)) {
#line 1586
    return (1);
  }
  {
#line 1588
  push_context(cndn->ctxt);
#line 1589
  r = execute_code((INSTRUCTION volatile   *)cndn->code);
#line 1590
  pop_context();
  }
#line 1591
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1592
    return (0);
  }
  {
#line 1594
  force_number(r);
  }
#line 1595
  if (r->flags & 2048U) {
#line 1595
    tmp___3 = r->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 1UL);
  } else {
#line 1595
    if (r->flags & 4096U) {
#line 1595
      if (r->sub.val.nm.mpi[0]._mp_size < 0) {
#line 1595
        tmp___1 = -1;
      } else {
#line 1595
        tmp___1 = r->sub.val.nm.mpi[0]._mp_size > 0;
      }
#line 1595
      tmp___2 = tmp___1 == 0;
    } else {
#line 1595
      tmp___2 = r->sub.val.nm.fltnum == 0.0;
    }
#line 1595
    tmp___3 = tmp___2;
  }
#line 1595
  if (tmp___3) {
#line 1595
    tmp___4 = 0;
  } else {
#line 1595
    tmp___4 = 1;
  }
  {
#line 1595
  di = tmp___4;
#line 1596
  DEREF(r);
  }
#line 1597
  return (di);
}
}
#line 1601 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int find_subscript(struct list_item *item , NODE **ptr ) 
{ 
  NODE *symbol ;
  NODE *sub ;
  NODE *r ;
  int i___0 ;
  int count ;
  NODE *tmp___1 ;

  {
#line 1604
  symbol = item->symbol;
#line 1606
  i___0 = 0;
#line 1606
  count = item->num_subs;
#line 1608
  tmp___1 = (NODE *)((void *)0);
#line 1608
  *ptr = tmp___1;
#line 1608
  r = tmp___1;
#line 1609
  i___0 = 0;
  {
#line 1609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1609
    if (! (i___0 < count)) {
#line 1609
      goto while_break;
    }
    {
#line 1610
    sub = *(item->subs + i___0);
#line 1611
    r = in_array(symbol, sub);
    }
#line 1612
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1613
      return (0);
    }
#line 1614
    if ((unsigned int )r->type == 5U) {
#line 1615
      symbol = r;
    } else
#line 1616
    if (i___0 < count - 1) {
#line 1617
      return (-1);
    }
#line 1609
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1619
  if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 1620
    *ptr = r;
  }
#line 1621
  return (0);
}
}
#line 1626 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int cmp_val(struct list_item *w___0 , NODE *old , NODE *new ) 
{ 
  long size ;
  struct exp_node **tmp___1 ;
  int tmp___2 ;

  {
#line 1643
  if ((w___0->flags & 16) != 0) {
#line 1644
    size = 0L;
#line 1645
    if (! new) {
#line 1646
      return (1);
    }
#line 1647
    if ((unsigned int )new->type == 1U) {
#line 1648
      return (1);
    }
    {
#line 1650
    tmp___1 = (*(*(new->sub.nodep.l.lp + 2)))(new, (struct exp_node *)((void *)0));
#line 1650
    size = (long )(*tmp___1)->sub.nodep.reflags;
    }
#line 1651
    if (w___0->value[0].l == size) {
#line 1652
      return (0);
    }
#line 1653
    return (1);
  }
#line 1656
  if (! old) {
#line 1656
    if (! new) {
#line 1657
      return (0);
    }
  }
#line 1658
  if (! old) {
#line 1658
    if (new) {
#line 1660
      return (1);
    } else {
#line 1658
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1658
  if (old) {
#line 1658
    if (! new) {
#line 1660
      return (1);
    }
  }
#line 1662
  if ((unsigned int )new->type == 5U) {
#line 1663
    return (1);
  }
  {
#line 1664
  tmp___2 = cmp_nodes(old, new);
  }
#line 1664
  return (tmp___2);
}
}
#line 1671 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int watchpoint_triggered(struct list_item *w___0 ) 
{ 
  NODE *symbol ;
  NODE *t1 ;
  NODE *t2 ;
  int tmp___1 ;
  long field_num ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  NODE **tmp___5 ;
  int tmp___6 ;
  struct exp_node **tmp___7 ;
  struct exp_node **tmp___8 ;
  struct exp_node **tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1677
  symbol = w___0->symbol;
#line 1678
  if ((w___0->flags & 1) != 0) {
#line 1678
    if (w___0->fcall_count != fcall_count - cur_frame) {
#line 1679
      return (0);
    }
  }
  {
#line 1680
  tmp___1 = condition_triggered(& w___0->cndn);
  }
#line 1680
  if (! tmp___1) {
#line 1681
    return (0);
  }
#line 1683
  t1 = w___0->value[0].n;
#line 1684
  t2 = (NODE *)0;
#line 1685
  if ((w___0->flags & 2) != 0) {
    {
#line 1686
    find_subscript(w___0, & t2);
    }
  } else
#line 1687
  if ((w___0->flags & 4) != 0) {
#line 1689
    if ((w___0->symbol)->flags & 2048U) {
      {
#line 1689
      tmp___2 = mpfr_get_si((mpfr_srcptr )((w___0->symbol)->sub.val.nm.mpnum), ROUND_MODE);
#line 1689
      field_num = tmp___2;
      }
    } else {
#line 1689
      if ((w___0->symbol)->flags & 4096U) {
        {
#line 1689
        tmp___3 = __gmpz_get_si((mpz_srcptr )((w___0->symbol)->sub.val.nm.mpi));
#line 1689
        tmp___4 = tmp___3;
        }
      } else {
#line 1689
        tmp___4 = (long )(w___0->symbol)->sub.val.nm.fltnum;
      }
#line 1689
      field_num = tmp___4;
    }
    {
#line 1690
    tmp___5 = get_field(field_num, (Func_ptr *)((void *)0));
#line 1690
    t2 = *tmp___5;
    }
  } else {
    {
#line 1693
    if ((unsigned int )symbol->type == 4U) {
#line 1693
      goto case_4;
    }
#line 1696
    if ((unsigned int )symbol->type == 5U) {
#line 1696
      goto case_5;
    }
#line 1699
    if ((unsigned int )symbol->type == 6U) {
#line 1699
      goto case_6;
    }
#line 1701
    goto switch_default;
    case_4: /* CIL Label */ 
#line 1694
    t2 = symbol->sub.nodep.l.lptr;
#line 1695
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1697
    t2 = symbol;
#line 1698
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1700
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1702
    r_fatal("internal error line %d, file: %s", 1702, "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1706
  tmp___6 = cmp_val(w___0, t1, t2);
  }
#line 1706
  if (! tmp___6) {
#line 1707
    return (0);
  }
#line 1711
  if ((w___0->flags & 8) == 0) {
    {
#line 1712
    unref(w___0->value[1].n);
    }
  }
#line 1713
  w___0->flags &= -9;
#line 1714
  if ((w___0->flags & 16) != 0) {
#line 1715
    w___0->value[1].l = w___0->value[0].l;
#line 1716
    w___0->flags |= 8;
#line 1717
    if (! t2) {
#line 1718
      w___0->flags &= -17;
#line 1719
      w___0->value[0].n = (NODE *)0;
    } else
#line 1720
    if ((unsigned int )t2->type == 1U) {
      {
#line 1721
      w___0->flags &= -17;
#line 1722
      w___0->value[0].n = dupnode(t2);
      }
    } else
#line 1724
    if ((unsigned int )t2->type == 5U) {
      {
#line 1724
      tmp___7 = (*(*(t2->sub.nodep.l.lp + 2)))(t2, (struct exp_node *)((void *)0));
#line 1724
      w___0->value[0].l = (long )(*tmp___7)->sub.nodep.reflags;
      }
    } else {
#line 1724
      w___0->value[0].l = 0L;
    }
  } else
#line 1725
  if (! t1) {
#line 1726
    w___0->value[1].n = (NODE *)0;
#line 1728
    if ((unsigned int )t2->type == 1U) {
      {
#line 1729
      w___0->value[0].n = dupnode(t2);
      }
    } else {
#line 1731
      w___0->flags |= 16;
#line 1732
      if ((unsigned int )t2->type == 5U) {
        {
#line 1732
        tmp___8 = (*(*(t2->sub.nodep.l.lp + 2)))(t2, (struct exp_node *)((void *)0));
#line 1732
        w___0->value[0].l = (long )(*tmp___8)->sub.nodep.reflags;
        }
      } else {
#line 1732
        w___0->value[0].l = 0L;
      }
    }
  } else {
#line 1735
    w___0->value[1].n = w___0->value[0].n;
#line 1736
    if (! t2) {
#line 1737
      w___0->value[0].n = (NODE *)0;
    } else
#line 1738
    if ((unsigned int )t2->type == 5U) {
      {
#line 1739
      w___0->flags |= 16;
#line 1740
      tmp___9 = (*(*(t2->sub.nodep.l.lp + 2)))(t2, (struct exp_node *)((void *)0));
#line 1740
      w___0->value[0].l = (long )(*tmp___9)->sub.nodep.reflags;
      }
    } else {
      {
#line 1742
      w___0->value[0].n = dupnode(t2);
      }
    }
  }
#line 1745
  return (w___0->number);
}
}
#line 1750 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int initialize_watch_item(struct list_item *w___0 ) 
{ 
  NODE *t ;
  NODE *r ;
  NODE *symbol ;
  char *tmp___1 ;
  int tmp___2 ;
  struct exp_node **tmp___3 ;
  long field_num ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  NODE **tmp___7 ;
  struct exp_node **tmp___8 ;
  char *__cil_tmp14 ;

  {
#line 1754
  symbol = w___0->symbol;
#line 1756
  if ((w___0->flags & 2) != 0) {
    {
#line 1757
    tmp___2 = find_subscript(w___0, & r);
    }
#line 1757
    if (tmp___2 == -1) {
      {
#line 1758
      tmp___1 = gettext("attempt to use scalar value as array");
#line 1758
      d_error((char const   *)tmp___1);
      }
#line 1759
      return (-1);
    }
#line 1762
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1763
      w___0->value[0].n = (NODE *)0;
    } else
#line 1764
    if ((unsigned int )r->type == 5U) {
      {
#line 1765
      w___0->flags |= 16;
#line 1766
      tmp___3 = (*(*(r->sub.nodep.l.lp + 2)))(r, (struct exp_node *)((void *)0));
#line 1766
      w___0->value[0].l = (long )(*tmp___3)->sub.nodep.reflags;
      }
    } else {
      {
#line 1768
      w___0->value[0].n = dupnode(r);
      }
    }
  } else
#line 1769
  if ((w___0->flags & 4) != 0) {
#line 1771
    t = w___0->symbol;
#line 1772
    if (t->flags & 2048U) {
      {
#line 1772
      tmp___4 = mpfr_get_si((mpfr_srcptr )(t->sub.val.nm.mpnum), ROUND_MODE);
#line 1772
      field_num = tmp___4;
      }
    } else {
#line 1772
      if (t->flags & 4096U) {
        {
#line 1772
        tmp___5 = __gmpz_get_si((mpz_srcptr )(t->sub.val.nm.mpi));
#line 1772
        tmp___6 = tmp___5;
        }
      } else {
#line 1772
        tmp___6 = (long )t->sub.val.nm.fltnum;
      }
#line 1772
      field_num = tmp___6;
    }
    {
#line 1773
    tmp___7 = get_field(field_num, (Func_ptr *)((void *)0));
#line 1773
    r = *tmp___7;
#line 1774
    w___0->value[0].n = dupnode(r);
    }
  } else
#line 1776
  if ((unsigned int )symbol->type == 6U) {
#line 1777
    w___0->value[0].n = (NODE *)0;
  } else
#line 1778
  if ((unsigned int )symbol->type == 4U) {
    {
#line 1779
    r = symbol->sub.nodep.l.lptr;
#line 1780
    w___0->value[0].n = dupnode(r);
    }
  } else
#line 1781
  if ((unsigned int )symbol->type == 5U) {
    {
#line 1782
    w___0->flags |= 16;
#line 1783
    tmp___8 = (*(*(symbol->sub.nodep.l.lp + 2)))(symbol, (struct exp_node *)((void *)0));
#line 1783
    w___0->value[0].l = (long )(*tmp___8)->sub.nodep.reflags;
    }
  }
#line 1787
  return (0);
}
}
#line 1792 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_watch(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  struct list_item *w___0 ;
  NODE *symbol ;
  NODE *sub ;
  int i___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1799
  w___0 = do_add_item(& watch_list, arg);
  }
#line 1800
  if ((unsigned long )w___0 == (unsigned long )((void *)0)) {
#line 1801
    return (0);
  }
  {
#line 1803
  tmp___1 = initialize_watch_item(w___0);
  }
#line 1803
  if (tmp___1 == -1) {
    {
#line 1804
    delete_item(w___0);
    }
#line 1805
    return (0);
  }
  {
#line 1808
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"Watchpoint %d: ",
          w___0->number);
#line 1809
  symbol = w___0->symbol;
  }
#line 1812
  if ((w___0->flags & 2) != 0) {
    {
#line 1813
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s",
            w___0->sname);
#line 1814
    i___0 = 0;
    }
    {
#line 1814
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1814
      if (! (i___0 < w___0->num_subs)) {
#line 1814
        goto while_break;
      }
      {
#line 1815
      sub = *(w___0->subs + i___0);
#line 1816
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"[\"%s\"]",
              sub->sub.val.sp);
#line 1814
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1818
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\n");
    }
  } else
#line 1819
  if ((w___0->flags & 4) != 0) {
#line 1820
    if (symbol->flags & 2048U) {
      {
#line 1820
      tmp___2 = mpfr_get_si((mpfr_srcptr )(symbol->sub.val.nm.mpnum), ROUND_MODE);
#line 1820
      tmp___5 = tmp___2;
      }
    } else {
#line 1820
      if (symbol->flags & 4096U) {
        {
#line 1820
        tmp___3 = __gmpz_get_si((mpz_srcptr )(symbol->sub.val.nm.mpi));
#line 1820
        tmp___4 = tmp___3;
        }
      } else {
#line 1820
        tmp___4 = (long )symbol->sub.val.nm.fltnum;
      }
#line 1820
      tmp___5 = tmp___4;
    }
    {
#line 1820
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"$%ld\n",
            tmp___5);
    }
  } else {
    {
#line 1822
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s\n",
            w___0->sname);
    }
  }
#line 1824
  return (0);
}
}
#line 1829 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_unwatch(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1832
  do_delete_item(& watch_list, arg);
  }
#line 1833
  return (0);
}
}
#line 1838 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
void frame_popped(void) 
{ 
  struct list_item *item ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1844
  item = watch_list.next;
  {
#line 1844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1844
    if (! ((unsigned long )item != (unsigned long )(& watch_list))) {
#line 1844
      goto while_break;
    }
#line 1845
    if ((item->flags & 1) != 0) {
#line 1845
      if (item->fcall_count > fcall_count) {
        {
#line 1846
        tmp___1 = gettext("Watchpoint %d deleted because parameter is out of scope.\n");
#line 1846
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
                item->number);
#line 1849
        item = item->prev;
#line 1850
        delete_item(item->next);
        }
      }
    }
#line 1844
    item = item->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1855
  item = display_list.next;
  {
#line 1855
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1855
    if (! ((unsigned long )item != (unsigned long )(& display_list))) {
#line 1855
      goto while_break___0;
    }
#line 1856
    if ((item->flags & 1) != 0) {
#line 1856
      if (item->fcall_count > fcall_count) {
        {
#line 1857
        tmp___2 = gettext("Display %d deleted because parameter is out of scope.\n");
#line 1857
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2,
                item->number);
#line 1860
        item = item->prev;
#line 1861
        delete_item(item->next);
        }
      }
    }
#line 1855
    item = item->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1864
  return;
}
}
#line 1870 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int print_function(INSTRUCTION *pc , void *x ) 
{ 
  NODE *func___1 ;
  int i___0 ;
  int pcount ;
  struct pf_data *data ;
  int defn ;
  int (*print_func)(FILE * , char const   *  , ...) ;
  FILE *fp___0 ;
  char *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1875
  data = (struct pf_data *)x;
#line 1876
  defn = (int )data->defn;
#line 1877
  print_func = data->print_func;
#line 1878
  fp___0 = data->fp;
#line 1880
  func___1 = pc->x.xn;
#line 1881
  pcount = (int )func___1->sub.nodep.l.ll;
#line 1883
  (*print_func)(fp___0, "%s(", func___1->sub.nodep.name);
#line 1884
  i___0 = 0;
  }
  {
#line 1884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1884
    if (! (i___0 < pcount)) {
#line 1884
      goto while_break;
    }
    {
#line 1885
    (*print_func)(fp___0, "%s", (func___1->sub.nodep.rn + i___0)->sub.nodep.name);
    }
#line 1886
    if (i___0 < pcount - 1) {
      {
#line 1887
      (*print_func)(fp___0, ", ");
      }
    }
#line 1884
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1889
  (*print_func)(fp___0, ")");
  }
#line 1890
  if (defn) {
    {
#line 1891
    tmp___1 = gettext(" in file `%s\', line %d\n");
#line 1891
    (*print_func)(fp___0, (char const   *)tmp___1, pc->d.name, (int )pc->source_line);
    }
  }
#line 1893
  return (0);
}
}
#line 1901 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void print_frame(NODE *func___1 , char *src , int srcline___0 ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1904
  if ((unsigned long )func___1 == (unsigned long )((void *)0)) {
    {
#line 1905
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"main()");
    }
  } else {
    {
#line 1907
    pf_data.print_func = (int (*)(FILE * , char const   *  , ...))(& fprintf);
#line 1908
    pf_data.fp = out_fp;
#line 1909
    pf_data.defn = (_Bool)0;
#line 1910
    print_function(func___1->sub.nodep.r.iptr, (void *)(& pf_data));
    }
  }
  {
#line 1912
  tmp___1 = gettext(" at `%s\':%d");
#line 1912
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
          src, srcline___0);
  }
#line 1913
  return;
}
}
#line 1917 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void print_numbered_frame(long num ) 
{ 
  NODE *f ;
  char *tmp___1 ;
  NODE *tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1923
  f = find_frame(num);
  }
#line 1924
  if (num == 0L) {
    {
#line 1925
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"#%ld\t ",
            num);
#line 1926
    print_frame(f->sub.nodep.x.extra, source, sourceline);
    }
  } else {
    {
#line 1928
    tmp___1 = gettext("#%ld\tin ");
#line 1928
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
            num);
#line 1929
    tmp___2 = find_frame(num - 1L);
#line 1929
    print_frame(f->sub.nodep.x.extra, f->sub.nodep.name, (int )(tmp___2->sub.nodep.l.li)->source_line);
    }
  }
  {
#line 1932
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\n");
  }
#line 1933
  return;
}
}
#line 1937 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_backtrace(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  long cur ;
  long last ;
  char *tmp___1 ;
  long count ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1940
  cur = 0L;
#line 1941
  last = fcall_count;
  {
#line 1943
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1943
    if (! prog_running) {
      {
#line 1943
      tmp___1 = gettext("program not running.");
#line 1943
      d_error((char const   *)tmp___1);
      }
#line 1943
      return (0);
    }
#line 1943
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1944
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 1944
    if ((unsigned int )arg->type == 43U) {
#line 1945
      count = arg->value.lval;
#line 1948
      if (count >= 0L) {
#line 1950
        last = count - 1L;
#line 1951
        if (last > fcall_count) {
#line 1952
          last = fcall_count;
        }
      } else {
#line 1955
        cur = (1L + fcall_count) + count;
#line 1956
        if (cur < 0L) {
#line 1957
          cur = 0L;
        }
      }
    }
  }
  {
#line 1961
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1961
    if (! (cur <= last)) {
#line 1961
      goto while_break___0;
    }
    {
#line 1962
    print_numbered_frame(cur);
#line 1961
    cur ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1964
  if (cur <= fcall_count) {
    {
#line 1965
    tmp___2 = gettext("More stack frames follow ...\n");
#line 1965
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2);
    }
  }
#line 1966
  return (0);
}
}
#line 1973 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void print_cur_frame_and_sourceline(void) 
{ 
  NODE *f ;
  int srcline___0 ;
  char *src ;
  NODE *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1981
  f = find_frame(cur_frame);
  }
#line 1982
  if (cur_frame == 0L) {
#line 1983
    src = source;
#line 1984
    srcline___0 = sourceline;
  } else {
    {
#line 1986
    f = find_frame(cur_frame);
#line 1987
    src = f->sub.nodep.name;
#line 1988
    tmp___1 = find_frame(cur_frame - 1L);
#line 1988
    srcline___0 = (int )(tmp___1->sub.nodep.l.li)->source_line;
    }
  }
#line 1991
  if (cur_frame > 0L) {
    {
#line 1991
    tmp___2 = gettext("#%ld\tin ");
#line 1991
    tmp___3 = (char const   *)tmp___2;
    }
  } else {
#line 1991
    tmp___3 = "#%ld\t ";
  }
  {
#line 1991
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___3,
          cur_frame);
#line 1992
  print_frame(f->sub.nodep.x.extra, src, srcline___0);
#line 1993
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\n");
#line 1994
  print_lines(src, srcline___0, 1);
#line 1995
  last_printed_line = srcline___0 - list_size / 2;
  }
#line 1996
  if (last_printed_line < 0) {
#line 1997
    last_printed_line = 0;
  }
#line 1998
  return;
}
}
#line 2002 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_frame(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 2005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2005
    if (! prog_running) {
      {
#line 2005
      tmp___1 = gettext("program not running.");
#line 2005
      d_error((char const   *)tmp___1);
      }
#line 2005
      return (0);
    }
#line 2005
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2006
  if (arg) {
#line 2006
    if ((unsigned int )arg->type == 43U) {
#line 2007
      if (arg->value.lval < 0L) {
        {
#line 2008
        tmp___2 = gettext("invalid frame number");
#line 2008
        d_error((char const   *)tmp___2);
        }
#line 2009
        return (0);
      } else
#line 2007
      if (arg->value.lval > fcall_count) {
        {
#line 2008
        tmp___2 = gettext("invalid frame number");
#line 2008
        d_error((char const   *)tmp___2);
        }
#line 2009
        return (0);
      }
#line 2011
      cur_frame = arg->value.lval;
    }
  }
  {
#line 2013
  print_cur_frame_and_sourceline();
  }
#line 2014
  return (0);
}
}
#line 2019 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_up(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 2022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2022
    if (! prog_running) {
      {
#line 2022
      tmp___1 = gettext("program not running.");
#line 2022
      d_error((char const   *)tmp___1);
      }
#line 2022
      return (0);
    }
#line 2022
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2023
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 2023
    if ((unsigned int )arg->type == 43U) {
#line 2024
      cur_frame += arg->value.lval;
    } else {
#line 2026
      cur_frame ++;
    }
  } else {
#line 2026
    cur_frame ++;
  }
#line 2027
  if (cur_frame < 0L) {
#line 2028
    cur_frame = 0L;
  } else
#line 2029
  if (cur_frame > fcall_count) {
#line 2030
    cur_frame = fcall_count;
  }
  {
#line 2031
  print_cur_frame_and_sourceline();
  }
#line 2032
  return (0);
}
}
#line 2037 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_down(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 2040
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2040
    if (! prog_running) {
      {
#line 2040
      tmp___1 = gettext("program not running.");
#line 2040
      d_error((char const   *)tmp___1);
      }
#line 2040
      return (0);
    }
#line 2040
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2041
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 2041
    if ((unsigned int )arg->type == 43U) {
#line 2042
      cur_frame -= arg->value.lval;
    } else {
#line 2044
      cur_frame --;
    }
  } else {
#line 2044
    cur_frame --;
  }
#line 2045
  if (cur_frame < 0L) {
#line 2046
    cur_frame = 0L;
  } else
#line 2047
  if (cur_frame > fcall_count) {
#line 2048
    cur_frame = fcall_count;
  }
  {
#line 2049
  print_cur_frame_and_sourceline();
  }
#line 2050
  return (0);
}
}
#line 2057 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static INSTRUCTION *find_rule(char *src , long lineno ) 
{ 
  INSTRUCTION *rp ;

  {
#line 2063
  rp = rule_list->nexti;
  {
#line 2063
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2063
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 2063
      goto while_break;
    }
#line 2064
    if ((unsigned long )(rp - 1)->d.name == (unsigned long )src) {
#line 2064
      if (lineno >= (long )(rp + 1)->source_line) {
#line 2064
        if (lineno <= (rp + 1)->x.xl) {
#line 2067
          return (rp - 1);
        }
      }
    }
#line 2063
    rp = rp->nexti;
  }
  while_break: /* CIL Label */ ;
  }
#line 2069
  return ((INSTRUCTION *)((void *)0));
}
}
#line 2076 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static INSTRUCTION *mk_breakpoint(char *src , int srcline___0 ) 
{ 
  INSTRUCTION *bp ;
  BREAKPOINT *b___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  struct commands_item *tmp___6 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 2082
  bp = bcalloc((OPCODE )99, 1, srcline___0);
#line 2083
  tmp___1 = malloc(sizeof(BREAKPOINT ));
#line 2083
  b___0 = (BREAKPOINT *)tmp___1;
  }
#line 2083
  if (b___0) {
#line 2083
    tmp___5 = 1;
  } else {
    {
#line 2083
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 2083);
#line 2083
    tmp___2 = __errno_location();
#line 2083
    tmp___3 = strerror(*tmp___2);
#line 2083
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2083
    r_fatal((char const   *)tmp___4, "mk_breakpoint", "b", (long )sizeof(BREAKPOINT ),
            tmp___3);
#line 2083
    tmp___5 = 0;
    }
  }
  {
#line 2084
  memset((void *)(& b___0->cndn), 0, sizeof(struct condition ));
#line 2085
  tmp___6 = & b___0->commands;
#line 2085
  b___0->commands.prev = tmp___6;
#line 2085
  b___0->commands.next = tmp___6;
#line 2086
  b___0->silent = (_Bool)0;
#line 2089
  (watch_list.number) ++;
#line 2089
  b___0->number = watch_list.number;
#line 2090
  b___0->ignore_count = 0L;
#line 2091
  b___0->hit_count = 0L;
#line 2092
  b___0->flags = (short)1;
#line 2093
  b___0->src = src;
#line 2094
  bp->x.bpt = b___0;
#line 2095
  b___0->bpi = bp;
#line 2098
  b___0->next = breakpoints.next;
#line 2099
  b___0->prev = & breakpoints;
#line 2100
  breakpoints.next = b___0;
#line 2101
  (b___0->next)->prev = b___0;
  }
#line 2102
  return (bp);
}
}
#line 2109 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void delete_breakpoint(BREAKPOINT *b___0 ) 
{ 
  INSTRUCTION *pc ;
  struct commands_item *c ;

  {
#line 2112
  pc = b___0->bpi;
#line 2120
  pc->opcode = (OPCODE )81;
#line 2121
  pc->source_line = (short)0;
#line 2122
  pc->x.bpt = (struct break_point *)((void *)0);
#line 2125
  c = b___0->commands.next;
  {
#line 2125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2125
    if (! ((unsigned long )c != (unsigned long )(& b___0->commands))) {
#line 2125
      goto while_break;
    }
    {
#line 2126
    c = c->prev;
#line 2127
    delete_commands_item(c->next);
#line 2125
    c = c->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2130
  free_context(b___0->cndn.ctxt, (_Bool)0);
  }
#line 2131
  if ((unsigned long )b___0->cndn.expr != (unsigned long )((void *)0)) {
    {
#line 2132
    free((void *)b___0->cndn.expr);
    }
  }
  {
#line 2135
  (b___0->next)->prev = b___0->prev;
#line 2136
  (b___0->prev)->next = b___0->next;
#line 2137
  free((void *)b___0);
  }
#line 2138
  return;
}
}
#line 2142 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static BREAKPOINT *find_breakpoint(long num ) 
{ 
  BREAKPOINT *b___0 ;

  {
#line 2147
  if (num <= 0L) {
#line 2148
    return ((BREAKPOINT *)((void *)0));
  }
#line 2150
  b___0 = breakpoints.next;
  {
#line 2150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2150
    if (! ((unsigned long )b___0 != (unsigned long )(& breakpoints))) {
#line 2150
      goto while_break;
    }
#line 2151
    if ((long )b___0->number == num) {
#line 2152
      return (b___0);
    }
#line 2150
    b___0 = b___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2154
  return ((BREAKPOINT *)((void *)0));
}
}
#line 2159 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static BREAKPOINT *add_breakpoint(INSTRUCTION *prevp , INSTRUCTION *ip , char *src ,
                                  _Bool silent ) 
{ 
  BREAKPOINT *b___0 ;
  INSTRUCTION *bp ;
  int lineno ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2164
  lineno = (int )ip->source_line;
  {
#line 2170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2170
    if ((unsigned int )ip->opcode == 99U) {
#line 2170
      if (! ((int )ip->source_line == lineno)) {
#line 2170
        goto while_break;
      }
    } else {
#line 2170
      goto while_break;
    }
#line 2171
    if (! silent) {
#line 2172
      b___0 = ip->x.bpt;
#line 2177
      if (((int )b___0->flags & 1) != 0) {
#line 2178
        if (((int )b___0->flags & 8) != 0) {
          {
#line 2179
          tmp___1 = gettext("Note: breakpoint %d (enabled, ignore next %ld hits), also set at %s:%d");
#line 2179
          fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
                  b___0->number, b___0->ignore_count, b___0->src, lineno);
          }
        } else {
          {
#line 2186
          tmp___2 = gettext("Note: breakpoint %d (enabled), also set at %s:%d");
#line 2186
          fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2,
                  b___0->number, b___0->src, lineno);
          }
        }
      } else
#line 2192
      if (((int )b___0->flags & 8) != 0) {
        {
#line 2193
        tmp___3 = gettext("Note: breakpoint %d (disabled, ignore next %ld hits), also set at %s:%d");
#line 2193
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___3,
                b___0->number, b___0->ignore_count, b___0->src, lineno);
        }
      } else {
        {
#line 2200
        tmp___4 = gettext("Note: breakpoint %d (disabled), also set at %s:%d");
#line 2200
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___4,
                b___0->number, b___0->src, lineno);
        }
      }
    }
#line 2207
    prevp = ip;
#line 2208
    ip = ip->nexti;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2213
  bp = mk_breakpoint(src, lineno);
#line 2214
  prevp->nexti = bp;
#line 2215
  bp->nexti = ip;
#line 2216
  b___0 = bp->x.bpt;
  }
#line 2217
  if (! silent) {
    {
#line 2218
    tmp___5 = gettext("Breakpoint %d set at file `%s\', line %d\n");
#line 2218
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___5,
            b___0->number, src, lineno);
    }
  }
#line 2220
  return (b___0);
}
}
#line 2225 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static BREAKPOINT *set_breakpoint_at(INSTRUCTION *rp , int lineno , _Bool silent ) 
{ 
  INSTRUCTION *ip ;
  INSTRUCTION *prevp ;
  INSTRUCTION *i1 ;
  INSTRUCTION *i2 ;
  BREAKPOINT *tmp___1 ;
  BREAKPOINT *tmp___2 ;

  {
#line 2230
  prevp = rp;
#line 2230
  ip = rp->nexti;
  {
#line 2230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2230
    if (! ip) {
#line 2230
      goto while_break;
    }
#line 2231
    if ((unsigned int )ip->opcode == 50U) {
#line 2239
      i2 = ip->d.di;
#line 2239
      i1 = i2->nexti;
      {
#line 2239
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2239
        if (! ((unsigned long )i2 != (unsigned long )ip->x.xi)) {
#line 2239
          goto while_break___0;
        }
#line 2241
        if ((int )i1->source_line >= lineno) {
          {
#line 2242
          tmp___1 = add_breakpoint(i2, i1, rp->d.name, silent);
          }
#line 2242
          return (tmp___1);
        }
#line 2243
        if ((unsigned long )i1 == (unsigned long )ip->x.xi) {
#line 2244
          goto while_break___0;
        }
#line 2239
        i2 = i1;
#line 2239
        i1 = i1->nexti;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2248
    if ((int )ip->source_line >= lineno) {
      {
#line 2249
      tmp___2 = add_breakpoint(prevp, ip, rp->d.name, silent);
      }
#line 2249
      return (tmp___2);
    }
#line 2250
    if ((unsigned long )ip == (unsigned long )(rp + 1)->d.di) {
#line 2251
      goto while_break;
    }
#line 2230
    prevp = ip;
#line 2230
    ip = ip->nexti;
  }
  while_break: /* CIL Label */ ;
  }
#line 2253
  return ((BREAKPOINT *)((void *)0));
}
}
#line 2258 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static BREAKPOINT *set_breakpoint_next(INSTRUCTION *rp , INSTRUCTION *ip ) 
{ 
  INSTRUCTION *prevp ;
  BREAKPOINT *tmp___1 ;

  {
#line 2263
  if ((unsigned long )ip == (unsigned long )(rp + 1)->d.di) {
#line 2264
    return ((BREAKPOINT *)((void *)0));
  }
#line 2265
  prevp = ip;
#line 2266
  if ((unsigned int )ip->opcode != 99U) {
#line 2267
    ip = ip->nexti;
  }
  {
#line 2268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2268
    if (! ip) {
#line 2268
      goto while_break;
    }
#line 2269
    if ((int )ip->source_line > 0) {
      {
#line 2270
      tmp___1 = add_breakpoint(prevp, ip, rp->d.name, (_Bool)0);
      }
#line 2270
      return (tmp___1);
    }
#line 2271
    if ((unsigned long )ip == (unsigned long )(rp + 1)->d.di) {
#line 2272
      goto while_break;
    }
#line 2268
    prevp = ip;
#line 2268
    ip = ip->nexti;
  }
  while_break: /* CIL Label */ ;
  }
#line 2274
  return ((BREAKPOINT *)((void *)0));
}
}
#line 2279 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int set_breakpoint(CMDARG *arg , _Bool temporary ) 
{ 
  int lineno ;
  BREAKPOINT *b___0 ;
  INSTRUCTION *rp ;
  INSTRUCTION *ip ;
  NODE *func___1 ;
  SRCFILE *s___0 ;
  char *src ;
  char *tmp___1 ;
  NODE *f ;
  NODE *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 2283
  b___0 = (BREAKPOINT *)((void *)0);
#line 2286
  s___0 = cur_srcfile;
#line 2287
  src = cur_srcfile->src;
#line 2289
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 2307
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2307
      if (! prog_running) {
        {
#line 2307
        tmp___1 = gettext("program not running.");
#line 2307
        d_error((char const   *)tmp___1);
        }
#line 2307
        return (0);
      }
#line 2307
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2308
    if (cur_frame == 0L) {
#line 2309
      src = source;
#line 2310
      ip = cur_pc;
    } else {
      {
#line 2313
      f = find_frame(cur_frame);
#line 2314
      src = f->sub.nodep.name;
#line 2315
      tmp___2 = find_frame(cur_frame - 1L);
#line 2315
      ip = tmp___2->sub.nodep.l.li;
      }
    }
    {
#line 2317
    rp = find_rule(src, (long )ip->source_line);
#line 2319
    b___0 = set_breakpoint_next(rp, ip);
    }
#line 2319
    if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
      {
#line 2320
      tmp___3 = gettext("Can\'t set breakpoint in file `%s\'\n");
#line 2320
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___3,
              src);
      }
    } else {
#line 2322
      if (cur_frame == 0L) {
#line 2323
        b___0->flags = (short )((int )b___0->flags | 8);
#line 2324
        b___0->ignore_count = 1L;
      }
#line 2326
      if (temporary) {
#line 2327
        b___0->flags = (short )((int )b___0->flags | 4);
      }
    }
#line 2329
    return (0);
  }
  {
#line 2335
  if ((unsigned int )arg->type == 44U) {
#line 2335
    goto case_44;
  }
#line 2346
  if ((unsigned int )arg->type == 43U) {
#line 2346
    goto case_43;
  }
#line 2362
  if ((unsigned int )arg->type == 50U) {
#line 2362
    goto func;
  }
#line 2374
  goto switch_default;
  case_44: /* CIL Label */ 
  {
#line 2336
  s___0 = source_find(arg->value.sval);
#line 2337
  arg = arg->next;
  }
#line 2338
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 2340
    return (0);
  } else
#line 2338
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 2340
    return (0);
  } else
#line 2338
  if ((unsigned int )arg->type != 43U) {
#line 2338
    if ((unsigned int )arg->type != 50U) {
#line 2340
      return (0);
    }
  }
#line 2341
  src = s___0->src;
#line 2342
  if ((unsigned int )arg->type == 50U) {
#line 2343
    goto func;
  } else {
    case_43: /* CIL Label */ 
#line 2347
    lineno = (int )arg->value.lval;
  }
#line 2348
  if (lineno <= 0) {
    {
#line 2349
    tmp___4 = gettext("line number %d in file `%s\' out of range");
#line 2349
    d_error((char const   *)tmp___4, lineno, src);
    }
  } else
#line 2348
  if (lineno > s___0->srclines) {
    {
#line 2349
    tmp___4 = gettext("line number %d in file `%s\' out of range");
#line 2349
    d_error((char const   *)tmp___4, lineno, src);
    }
  } else {
    {
#line 2351
    rp = find_rule(src, (long )lineno);
    }
#line 2352
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 2353
      tmp___5 = gettext("Can\'t find rule!!!\n");
#line 2353
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___5);
      }
    }
#line 2354
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 2355
      tmp___6 = gettext("Can\'t set breakpoint at `%s\':%d\n");
#line 2355
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___6,
              src, lineno);
      }
    } else {
      {
#line 2354
      b___0 = set_breakpoint_at(rp, lineno, (_Bool)0);
      }
#line 2354
      if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
        {
#line 2355
        tmp___6 = gettext("Can\'t set breakpoint at `%s\':%d\n");
#line 2355
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___6,
                src, lineno);
        }
      }
    }
#line 2357
    if ((unsigned long )b___0 != (unsigned long )((void *)0)) {
#line 2357
      if (temporary) {
#line 2358
        b___0->flags = (short )((int )b___0->flags | 4);
      }
    }
  }
#line 2360
  goto switch_break;
  func: 
  case_50: /* CIL Label */ 
  {
#line 2364
  func___1 = arg->value.nodeval;
#line 2365
  rp = func___1->sub.nodep.r.iptr;
#line 2366
  b___0 = set_breakpoint_at(rp, (int )rp->source_line, (_Bool)0);
  }
#line 2366
  if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
    {
#line 2367
    tmp___7 = gettext("Can\'t set breakpoint in function `%s\'\n");
#line 2367
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___7,
            func___1->sub.nodep.name);
    }
  } else
#line 2369
  if (temporary) {
#line 2370
    b___0->flags = (short )((int )b___0->flags | 4);
  }
#line 2371
  lineno = (int )(b___0->bpi)->source_line;
#line 2372
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2375
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 2378
  arg = arg->next;
#line 2379
  if ((unsigned long )b___0 != (unsigned long )((void *)0)) {
#line 2379
    if ((unsigned long )arg != (unsigned long )((void *)0)) {
      {
#line 2380
      tmp___9 = parse_condition(2, b___0->number, arg->value.sval);
      }
#line 2380
      if (tmp___9 == 0) {
#line 2381
        arg->value.sval = (char *)((void *)0);
      } else {
        {
#line 2383
        tmp___8 = gettext("breakpoint %d set at file `%s\', line %d is unconditional\n");
#line 2383
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___8,
                b___0->number, src, lineno);
        }
      }
    }
  }
#line 2386
  return (0);
}
}
#line 2392 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int breakpoint_triggered(BREAKPOINT *b___0 ) 
{ 
  int tmp___1 ;

  {
#line 2395
  if (((int )b___0->flags & 1) == 0) {
#line 2396
    return (0);
  }
#line 2397
  if (((int )b___0->flags & 8) != 0) {
#line 2398
    (b___0->ignore_count) --;
#line 2398
    if (b___0->ignore_count <= 0L) {
#line 2399
      b___0->flags = (short )((int )b___0->flags & -9);
    }
#line 2400
    return (0);
  }
  {
#line 2403
  tmp___1 = condition_triggered(& b___0->cndn);
  }
#line 2403
  if (! tmp___1) {
#line 2404
    return (0);
  }
#line 2406
  (b___0->hit_count) ++;
#line 2407
  if (((int )b___0->flags & 2) != 0) {
#line 2408
    b___0->flags = (short )((int )b___0->flags & -3);
#line 2409
    b___0->flags = (short )((int )b___0->flags & -2);
  }
#line 2411
  return (b___0->number);
}
}
#line 2416 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  int tmp___1 ;

  {
  {
#line 2419
  tmp___1 = set_breakpoint(arg, (_Bool)0);
  }
#line 2419
  return (tmp___1);
}
}
#line 2424 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_tmp_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  int tmp___1 ;

  {
  {
#line 2427
  tmp___1 = set_breakpoint(arg, (_Bool)1);
  }
#line 2427
  return (tmp___1);
}
}
#line 2432 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_clear(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  int lineno ;
  BREAKPOINT *b___0 ;
  INSTRUCTION *rp ;
  INSTRUCTION *ip ;
  NODE *func___1 ;
  SRCFILE *s___0 ;
  char *src ;
  _Bool bp_found ;
  char *tmp___1 ;
  NODE *f ;
  NODE *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 2439
  s___0 = cur_srcfile;
#line 2440
  src = cur_srcfile->src;
#line 2441
  bp_found = (_Bool)0;
#line 2443
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 2444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2444
      if (! prog_running) {
        {
#line 2444
        tmp___1 = gettext("program not running.");
#line 2444
        d_error((char const   *)tmp___1);
        }
#line 2444
        return (0);
      }
#line 2444
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2445
    if (cur_frame == 0L) {
#line 2446
      lineno = sourceline;
#line 2447
      src = source;
    } else {
      {
#line 2450
      f = find_frame(cur_frame);
#line 2451
      src = f->sub.nodep.name;
#line 2452
      tmp___2 = find_frame(cur_frame - 1L);
#line 2452
      lineno = (int )(tmp___2->sub.nodep.l.li)->source_line;
      }
    }
#line 2454
    goto delete_bp;
  }
  {
#line 2458
  if ((unsigned int )arg->type == 44U) {
#line 2458
    goto case_44;
  }
#line 2469
  if ((unsigned int )arg->type == 43U) {
#line 2469
    goto case_43;
  }
#line 2477
  if ((unsigned int )arg->type == 50U) {
#line 2477
    goto func;
  }
#line 2499
  goto switch_default;
  case_44: /* CIL Label */ 
  {
#line 2459
  s___0 = source_find(arg->value.sval);
#line 2460
  arg = arg->next;
  }
#line 2461
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 2463
    return (0);
  } else
#line 2461
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 2463
    return (0);
  } else
#line 2461
  if ((unsigned int )arg->type != 43U) {
#line 2461
    if ((unsigned int )arg->type != 50U) {
#line 2463
      return (0);
    }
  }
#line 2464
  src = s___0->src;
#line 2465
  if ((unsigned int )arg->type == 50U) {
#line 2466
    goto func;
  }
  case_43: /* CIL Label */ 
#line 2470
  lineno = (int )arg->value.lval;
#line 2471
  if (lineno <= 0) {
    {
#line 2472
    tmp___3 = gettext("line number %d in file `%s\' out of range");
#line 2472
    d_error((char const   *)tmp___3, lineno, src);
    }
#line 2473
    return (0);
  } else
#line 2471
  if (lineno > s___0->srclines) {
    {
#line 2472
    tmp___3 = gettext("line number %d in file `%s\' out of range");
#line 2472
    d_error((char const   *)tmp___3, lineno, src);
    }
#line 2473
    return (0);
  }
#line 2475
  goto switch_break;
  func: 
  case_50: /* CIL Label */ 
#line 2479
  func___1 = arg->value.nodeval;
#line 2480
  rp = func___1->sub.nodep.r.iptr;
#line 2481
  ip = rp->nexti;
  {
#line 2481
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2481
    if (! ip) {
#line 2481
      goto while_break___0;
    }
#line 2482
    if ((int )ip->source_line <= 0) {
#line 2483
      goto __Cont;
    }
#line 2484
    if ((unsigned int )ip->opcode != 99U) {
#line 2485
      goto while_break___0;
    }
#line 2486
    b___0 = ip->x.bpt;
#line 2487
    bp_found = (_Bool )((int )bp_found + 1);
#line 2487
    if ((int )bp_found == 1) {
      {
#line 2488
      tmp___4 = gettext("Deleted breakpoint %d");
#line 2488
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___4,
              b___0->number);
      }
    } else {
      {
#line 2490
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)", %d",
              b___0->number);
      }
    }
    {
#line 2491
    delete_breakpoint(b___0);
    }
    __Cont: /* CIL Label */ 
#line 2481
    ip = ip->nexti;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2493
  if (! bp_found) {
    {
#line 2494
    tmp___5 = gettext("No breakpoint(s) at entry to function `%s\'\n");
#line 2494
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___5,
            func___1->sub.nodep.name);
    }
  } else {
    {
#line 2497
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\n");
    }
  }
  switch_default: /* CIL Label */ 
#line 2500
  return (0);
  switch_break: /* CIL Label */ ;
  }
  delete_bp: 
  {
#line 2504
  rp = find_rule(src, (long )lineno);
  }
#line 2505
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 2506
    ip = rp->nexti;
    {
#line 2506
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2506
      if (! ip) {
#line 2506
        goto while_break___1;
      }
#line 2507
      if ((unsigned int )ip->opcode == 99U) {
#line 2507
        if ((int )ip->source_line == lineno) {
#line 2508
          b___0 = ip->x.bpt;
#line 2509
          bp_found = (_Bool )((int )bp_found + 1);
#line 2509
          if ((int )bp_found == 1) {
            {
#line 2510
            tmp___6 = gettext("Deleted breakpoint %d");
#line 2510
            fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___6,
                    b___0->number);
            }
          } else {
            {
#line 2512
            fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)", %d",
                    b___0->number);
            }
          }
          {
#line 2513
          delete_breakpoint(b___0);
          }
        }
      }
#line 2515
      if ((unsigned long )ip == (unsigned long )(rp + 1)->d.di) {
#line 2516
        goto while_break___1;
      }
#line 2506
      ip = ip->nexti;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2520
  if (! bp_found) {
    {
#line 2521
    tmp___7 = gettext("No breakpoint at file `%s\', line #%d\n");
#line 2521
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___7,
            src, lineno);
    }
  } else {
    {
#line 2524
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\n");
    }
  }
#line 2525
  return (0);
}
}
#line 2530 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
__inline static void enable_breakpoint(BREAKPOINT *b___0 , short disp ) 
{ 


  {
#line 2533
  b___0->flags = (short )((int )b___0->flags & -7);
#line 2534
  b___0->flags = (short )((int )b___0->flags | 1);
#line 2535
  if (disp) {
#line 2536
    b___0->flags = (short )((int )b___0->flags | (int )disp);
  }
#line 2537
  return;
}
}
#line 2541 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_enable_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  BREAKPOINT *b___0 ;
  short disp ;
  long i___0 ;
  long j ;
  char *tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 2545
  disp = (short)0;
#line 2547
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 2547
    if ((unsigned int )arg->type == 42U) {
#line 2548
      if (arg->value.lval == 3L) {
#line 2549
        disp = (short)4;
      } else {
#line 2551
        disp = (short)2;
      }
#line 2552
      arg = arg->next;
    }
  }
#line 2555
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 2556
    b___0 = breakpoints.next;
    {
#line 2556
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2556
      if (! ((unsigned long )b___0 != (unsigned long )(& breakpoints))) {
#line 2556
        goto while_break;
      }
      {
#line 2557
      enable_breakpoint(b___0, disp);
#line 2556
      b___0 = b___0->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2560
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2560
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 2560
      goto while_break___0;
    }
#line 2561
    if ((unsigned int )arg->type == 51U) {
#line 2564
      i___0 = arg->value.lval;
#line 2565
      arg = arg->next;
#line 2566
      j = arg->value.lval;
#line 2567
      if (j > (long )breakpoints.number) {
#line 2568
        j = (long )breakpoints.number;
      }
      {
#line 2569
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2569
        if (! (i___0 <= j)) {
#line 2569
          goto while_break___1;
        }
        {
#line 2570
        b___0 = find_breakpoint(i___0);
        }
#line 2570
        if ((unsigned long )b___0 != (unsigned long )((void *)0)) {
          {
#line 2571
          enable_breakpoint(b___0, disp);
          }
        }
#line 2569
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 2575
      b___0 = find_breakpoint(arg->value.lval);
      }
#line 2575
      if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
        {
#line 2576
        tmp___1 = gettext("invalid breakpoint number");
#line 2576
        d_error((char const   *)tmp___1);
        }
      } else {
        {
#line 2578
        enable_breakpoint(b___0, disp);
        }
      }
    }
#line 2560
    arg = arg->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2581
  return (0);
}
}
#line 2586 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_delete_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  _Bool delete_all ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  BREAKPOINT *b___0 ;
  long i___0 ;
  long j ;
  char *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 2589
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 2590
    delete_all = (_Bool)1;
#line 2591
    tmp___1 = gettext("y");
#line 2591
    tmp___2 = gettext("Delete all breakpoints? (y or n) ");
#line 2591
    tmp___3 = prompt_yes_no((char const   *)tmp___2, *(tmp___1 + 0), 1, out_fp);
#line 2591
    delete_all = (_Bool )tmp___3;
    }
#line 2595
    if (delete_all) {
      {
#line 2596
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2596
        if (! ((unsigned long )breakpoints.next != (unsigned long )(& breakpoints))) {
#line 2596
          goto while_break;
        }
        {
#line 2597
        delete_breakpoint(breakpoints.next);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 2601
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2601
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 2601
      goto while_break___0;
    }
#line 2603
    if ((unsigned int )arg->type == 51U) {
#line 2606
      i___0 = arg->value.lval;
#line 2607
      arg = arg->next;
#line 2608
      j = arg->value.lval;
#line 2609
      if (j > (long )breakpoints.number) {
#line 2610
        j = (long )breakpoints.number;
      }
      {
#line 2611
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2611
        if (! (i___0 <= j)) {
#line 2611
          goto while_break___1;
        }
        {
#line 2612
        b___0 = find_breakpoint(i___0);
        }
#line 2612
        if ((unsigned long )b___0 != (unsigned long )((void *)0)) {
          {
#line 2613
          delete_breakpoint(b___0);
          }
        }
#line 2611
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 2616
      b___0 = find_breakpoint(arg->value.lval);
      }
#line 2616
      if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
        {
#line 2617
        tmp___4 = gettext("invalid breakpoint number");
#line 2617
        d_error((char const   *)tmp___4);
        }
      } else {
        {
#line 2619
        delete_breakpoint(b___0);
        }
      }
    }
#line 2601
    arg = arg->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2622
  return (0);
}
}
#line 2627 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_ignore_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  BREAKPOINT *b___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 2632
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 2634
    return (0);
  } else
#line 2632
  if ((unsigned int )arg->type != 43U) {
#line 2634
    return (0);
  } else
#line 2632
  if ((unsigned long )arg->next == (unsigned long )((void *)0)) {
#line 2634
    return (0);
  } else
#line 2632
  if ((unsigned int )(arg->next)->type != 43U) {
#line 2634
    return (0);
  }
  {
#line 2636
  b___0 = find_breakpoint(arg->value.lval);
  }
#line 2636
  if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
    {
#line 2637
    tmp___1 = gettext("invalid breakpoint number");
#line 2637
    d_error((char const   *)tmp___1);
    }
  } else {
#line 2639
    b___0->ignore_count = (arg->next)->value.lval;
#line 2640
    if (b___0->ignore_count > 0L) {
      {
#line 2641
      b___0->flags = (short )((int )b___0->flags | 8);
#line 2642
      tmp___2 = gettext("Will ignore next %ld crossing(s) of breakpoint %d.\n");
#line 2642
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2,
              b___0->ignore_count, b___0->number);
      }
    } else {
      {
#line 2645
      b___0->flags = (short )((int )b___0->flags & -9);
#line 2646
      tmp___3 = gettext("Will stop next time breakpoint %d is reached.\n");
#line 2646
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___3,
              b___0->number);
      }
    }
  }
#line 2650
  return (0);
}
}
#line 2655 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_disable_breakpoint(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  BREAKPOINT *b___0 ;
  long i___0 ;
  long j ;
  char *tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 2660
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 2662
    b___0 = breakpoints.next;
    {
#line 2662
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2662
      if (! ((unsigned long )b___0 != (unsigned long )(& breakpoints))) {
#line 2662
        goto while_break;
      }
#line 2663
      b___0->flags = (short )((int )b___0->flags & -2);
#line 2662
      b___0 = b___0->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2666
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2666
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 2666
      goto while_break___0;
    }
#line 2667
    if ((unsigned int )arg->type == 51U) {
#line 2670
      i___0 = arg->value.lval;
#line 2671
      arg = arg->next;
#line 2672
      j = arg->value.lval;
#line 2673
      if (j > (long )breakpoints.number) {
#line 2674
        j = (long )breakpoints.number;
      }
      {
#line 2675
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2675
        if (! (i___0 <= j)) {
#line 2675
          goto while_break___1;
        }
        {
#line 2676
        b___0 = find_breakpoint(i___0);
        }
#line 2676
        if ((unsigned long )b___0 != (unsigned long )((void *)0)) {
#line 2677
          b___0->flags = (short )((int )b___0->flags & -2);
        }
#line 2675
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 2679
      b___0 = find_breakpoint(arg->value.lval);
      }
#line 2679
      if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
        {
#line 2680
        tmp___1 = gettext("invalid breakpoint number");
#line 2680
        d_error((char const   *)tmp___1);
        }
      } else {
#line 2682
        b___0->flags = (short )((int )b___0->flags & -2);
      }
    }
#line 2666
    arg = arg->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2685
  return (0);
}
}
#line 2692 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
NODE *get_function(void) 
{ 
  NODE *func___1 ;
  NODE *tmp___1 ;

  {
#line 2697
  if (! prog_running) {
#line 2698
    return ((NODE *)((void *)0));
  }
  {
#line 2699
  tmp___1 = find_frame(cur_frame);
#line 2699
  func___1 = tmp___1->sub.nodep.x.extra;
  }
#line 2700
  return (func___1);
}
}
#line 2705 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void initialize_readline(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 2711
  rl_outstream = out_fp;
#line 2714
  rl_readline_name = "gawk";
#line 2717
  rl_attempted_completion_function = & command_completion;
#line 2719
  read_a_line = & readline;
#line 2720
  return;
}
}
#line 2728 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
void init_debug(void) 
{ 


  {
  {
#line 2731
  register_exec_hook(& debug_pre_execute, & debug_post_execute);
  }
#line 2732
  return;
}
}
#line 2737 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int debug_prog(INSTRUCTION *pc ) 
{ 
  char *run ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int fd ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int fd___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 2742
  input_fd = fileno(stdin);
#line 2743
  out_fp = stdout;
#line 2744
  tmp___1 = os_isatty(input_fd);
  }
#line 2744
  if (tmp___1) {
#line 2745
    input_from_tty = (_Bool)1;
  }
#line 2746
  if (input_fd == 0) {
#line 2746
    if (input_from_tty) {
      {
#line 2747
      initialize_readline();
      }
    }
  }
#line 2749
  if (! read_a_line) {
#line 2750
    read_a_line = & g_readline;
  }
  {
#line 2752
  push_cmd_src(input_fd, input_from_tty, read_a_line, (int (*)(int  ))0, 0, 2);
#line 2754
  setbuf((FILE */* __restrict  */)out_fp, (char */* __restrict  */)((char *)((void *)0)));
#line 2755
  cur_srcfile = srcfiles->prev;
  }
  {
#line 2755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2755
    if (! ((unsigned long )cur_srcfile != (unsigned long )srcfiles)) {
#line 2755
      goto while_break;
    }
#line 2757
    if ((unsigned int )cur_srcfile->stype == 3U) {
#line 2759
      goto while_break;
    } else
#line 2757
    if ((unsigned int )cur_srcfile->stype == 4U) {
#line 2759
      goto while_break;
    }
#line 2755
    cur_srcfile = cur_srcfile->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 2762
  if ((unsigned long )cur_srcfile == (unsigned long )srcfiles) {
    {
#line 2763
    tmp___2 = gettext("Can only debug programs provided with the `-f\' option.\n");
#line 2763
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2);
#line 2764
    exit(1);
    }
  }
  {
#line 2767
  tmp___3 = strlen("gawk> ");
#line 2767
  dgawk_prompt = estrdup("gawk> ", tmp___3);
#line 2768
  dbg_prompt = dgawk_prompt;
#line 2770
  memset((void *)(& stop), 0, sizeof(stop));
#line 2771
  stop.command = (enum argtype )0;
#line 2773
  run = getenv("DGAWK_RESTART");
  }
#line 2773
  if ((unsigned long )run != (unsigned long )((void *)0)) {
    {
#line 2777
    unserialize(1);
#line 2778
    unserialize(2);
#line 2779
    unserialize(3);
#line 2780
    unserialize(4);
#line 2781
    unserialize(5);
#line 2782
    unsetenv("DGAWK_RESTART");
#line 2783
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"Restarting ...\n");
    }
#line 2784
    if ((int )*(run + 0) == 84) {
      {
#line 2785
      do_run((CMDARG *)((void *)0), 0);
      }
    }
  } else
#line 2787
  if ((unsigned long )command_file != (unsigned long )((void *)0)) {
    {
#line 2790
    fd = open_readfd(command_file);
    }
#line 2791
    if (fd == -1) {
      {
#line 2792
      tmp___4 = __errno_location();
#line 2792
      tmp___5 = strerror(*tmp___4);
#line 2792
      tmp___6 = gettext("can\'t open source file `%s\' for reading (%s)");
#line 2792
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              command_file, tmp___5);
#line 2794
      exit(1);
      }
    }
    {
#line 2796
    push_cmd_src(fd, (_Bool)0, & g_readline, & close, 0, 1);
#line 2797
    tmp___7 = strlen(command_file);
#line 2797
    cmd_src->str = estrdup(command_file, tmp___7);
    }
  } else {
    {
#line 2803
    read_history(history_file);
#line 2804
    sess_history_base = history_length;
#line 2808
    fd___0 = open_readfd(options_file);
    }
#line 2809
    if (fd___0 > -1) {
      {
#line 2810
      push_cmd_src(fd___0, (_Bool)0, & g_readline, & close, 0, 0);
      }
    }
  }
  {
#line 2814
  zzparse();
  }
#line 2815
  return (0);
}
}
#line 2823 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int check_watchpoint(void) 
{ 
  struct list_item *w___0 ;
  int wnum ;
  int tmp___1 ;

  {
#line 2828
  if ((unsigned int )stop.command == 27U) {
#line 2829
    return (0);
  }
#line 2830
  w___0 = watch_list.prev;
  {
#line 2830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2830
    if (! ((unsigned long )w___0 != (unsigned long )(& watch_list))) {
#line 2830
      goto while_break;
    }
    {
#line 2831
    tmp___1 = watchpoint_triggered(w___0);
#line 2831
    wnum = tmp___1;
    }
#line 2832
    if (wnum > 0) {
#line 2833
      stop.watch_point = wnum;
#line 2834
      stop.print_frame = (_Bool)1;
#line 2835
      return (1);
    }
#line 2830
    w___0 = w___0->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 2838
  return (0);
}
}
#line 2843 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int check_breakpoint(INSTRUCTION **pi ) 
{ 
  INSTRUCTION *pc ;
  int bnum ;

  {
#line 2848
  pc = *pi;
#line 2849
  if ((unsigned int )stop.command == 27U) {
#line 2850
    return (0);
  }
#line 2851
  if ((unsigned int )pc->opcode == 99U) {
    {
#line 2853
    *pi = pc->nexti;
#line 2856
    bnum = breakpoint_triggered(pc->x.bpt);
    }
#line 2857
    if (bnum > 0) {
#line 2858
      stop.break_point = bnum;
#line 2859
      stop.print_frame = (_Bool)1;
#line 2860
      return (1);
    }
  }
#line 2863
  return (0);
}
}
#line 2868
static  __attribute__((__noreturn__)) void restart(_Bool run ) ;
#line 2868 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void restart(_Bool run ) 
{ 
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 2872
  serialize(1);
#line 2873
  serialize(2);
#line 2874
  serialize(3);
#line 2875
  serialize(4);
#line 2876
  serialize(5);
  }
#line 2879
  if (run) {
#line 2879
    tmp___1 = "true";
  } else {
#line 2879
    tmp___1 = "false";
  }
  {
#line 2879
  setenv("DGAWK_RESTART", tmp___1, 1);
#line 2882
  close_all();
#line 2885
  execvp((char const   *)*(d_argv + 0), (char * const  *)d_argv);
#line 2888
  tmp___2 = gettext("Failed to restart debugger");
#line 2888
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2);
#line 2889
  exit(1);
  }
}
}
#line 2894 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_run(CMDARG *arg  __attribute__((__unused__)) , int cmd  __attribute__((__unused__)) ) 
{ 
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 2897
  if (prog_running) {
#line 2898
    if (! input_from_tty) {
#line 2899
      need_restart = (_Bool)1;
    } else {
      {
#line 2901
      tmp___1 = gettext("y");
#line 2901
      tmp___2 = gettext("Program already running. Restart from beginning (y/n)? ");
#line 2901
      tmp___3 = prompt_yes_no((char const   *)tmp___2, *(tmp___1 + 0), 0, out_fp);
#line 2901
      need_restart = (_Bool )tmp___3;
      }
#line 2905
      if (! need_restart) {
        {
#line 2906
        tmp___4 = gettext("Program not restarted\n");
#line 2906
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___4);
        }
#line 2907
        return (0);
      }
    }
  }
#line 2912
  if (need_restart) {
#line 2914
    if ((unsigned long )command_file != (unsigned long )((void *)0)) {
      {
#line 2916
      tmp___5 = gettext("error: cannot restart, operation not allowed\n");
#line 2916
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5);
#line 2917
      exit(1);
      }
    }
#line 2920
    if (cmd_src->cmd == 32) {
      {
#line 2922
      tmp___6 = gettext("error (%s): cannot restart, ignoring rest of the commands\n");
#line 2922
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___6,
              cmd_src->str);
#line 2923
      pop_cmd_src();
      }
#line 2924
      return (0);
    }
    {
#line 2927
    restart((_Bool)1);
    }
  }
  {
#line 2930
  tmp___7 = gettext("Starting program: \n");
#line 2930
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___7);
#line 2932
  prog_running = (_Bool)1;
#line 2933
  fatal_tag_valid = (_Bool)1;
#line 2934
  tmp___8 = _setjmp((struct __jmp_buf_tag *)(fatal_tag));
  }
#line 2934
  if (tmp___8 == 0) {
    {
#line 2935
    (*interpret)(code_block);
    }
  }
#line 2937
  fatal_tag_valid = (_Bool)0;
#line 2938
  prog_running = (_Bool)0;
#line 2939
  if (! exiting) {
#line 2939
    if (exit_val != 0) {
#line 2939
      tmp___9 = "abnormally";
    } else {
#line 2939
      tmp___9 = "normally";
    }
  } else {
#line 2939
    tmp___9 = "normally";
  }
  {
#line 2939
  tmp___10 = gettext("Program exited %s with exit value: %d\n");
#line 2939
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___10,
          tmp___9, exit_val);
#line 2943
  need_restart = (_Bool)1;
  }
#line 2944
  return (0);
}
}
#line 2949 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_quit(CMDARG *arg  __attribute__((__unused__)) , int cmd  __attribute__((__unused__)) ) 
{ 
  _Bool terminate ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int ret ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 2952
  terminate = (_Bool)1;
#line 2953
  if (prog_running) {
    {
#line 2954
    tmp___1 = gettext("y");
#line 2954
    tmp___2 = gettext("The program is running. Exit anyway (y/n)? ");
#line 2954
    tmp___3 = prompt_yes_no((char const   *)tmp___2, *(tmp___1 + 0), 1, out_fp);
#line 2954
    terminate = (_Bool )tmp___3;
    }
  }
#line 2957
  if (terminate) {
    {
#line 2958
    close_all();
#line 2959
    do_trace = 0;
    }
#line 2962
    if (do_save_history) {
#line 2962
      if (input_from_tty) {
        {
#line 2964
        ret = write_history(history_file);
        }
#line 2965
        if (ret == 0) {
#line 2965
          if (history_length > history_size) {
            {
#line 2966
            history_truncate_file(history_file, history_size);
            }
          }
        }
      }
    }
#line 2969
    if (do_save_options) {
#line 2969
      if (input_from_tty) {
        {
#line 2970
        save_options(options_file);
        }
      }
    }
    {
#line 2972
    exit(exit_val);
    }
  }
#line 2974
  return (0);
}
}
#line 2979 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_continue(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  BREAKPOINT *b___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 2984
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2984
    if (! prog_running) {
      {
#line 2984
      tmp___1 = gettext("program not running.");
#line 2984
      d_error((char const   *)tmp___1);
      }
#line 2984
      return (0);
    }
#line 2984
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2985
  if (! arg) {
#line 2986
    return (1);
  } else
#line 2985
  if ((unsigned int )arg->type != 43U) {
#line 2986
    return (1);
  }
#line 2989
  if (! stop.break_point) {
    {
#line 2990
    tmp___2 = gettext("Not stopped at any breakpoint; argument ignored.\n");
#line 2990
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2);
    }
#line 2991
    return (1);
  }
  {
#line 2993
  b___0 = find_breakpoint((long )stop.break_point);
  }
#line 2994
  if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
    {
#line 2995
    tmp___3 = gettext("invalid breakpoint number %d.");
#line 2995
    d_error((char const   *)tmp___3, stop.break_point);
    }
#line 2996
    return (0);
  }
  {
#line 2998
  b___0->flags = (short )((int )b___0->flags | 8);
#line 2999
  b___0->ignore_count = arg->value.lval;
#line 3000
  tmp___4 = gettext("Will ignore next %ld crossings of breakpoint %d.\n");
#line 3000
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___4,
          b___0->ignore_count, stop.break_point);
  }
#line 3002
  return (1);
}
}
#line 3007 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int next_step(CMDARG *arg , int cmd ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 3010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3010
    if (! prog_running) {
      {
#line 3010
      tmp___1 = gettext("program not running.");
#line 3010
      d_error((char const   *)tmp___1);
      }
#line 3010
      return (0);
    }
#line 3010
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3011
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 3011
    if ((unsigned int )arg->type == 43U) {
#line 3012
      stop.repeat_count = (int )arg->value.lval;
    } else {
#line 3014
      stop.repeat_count = 1;
    }
  } else {
#line 3014
    stop.repeat_count = 1;
  }
#line 3015
  stop.command = (enum argtype )cmd;
#line 3016
  return (1);
}
}
#line 3021 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int check_step(INSTRUCTION **pi ) 
{ 


  {
#line 3024
  if (fcall_count != stop.fcall_count) {
#line 3025
    stop.fcall_count = fcall_count;
#line 3026
    stop.sourceline = sourceline;
#line 3027
    stop.source = source;
#line 3028
    stop.print_frame = (_Bool)1;
#line 3029
    (stop.repeat_count) --;
#line 3029
    return (stop.repeat_count == 0);
  }
#line 3032
  if ((unsigned long )source != (unsigned long )stop.source) {
#line 3033
    stop.source = source;
#line 3034
    stop.sourceline = sourceline;
#line 3035
    (stop.repeat_count) --;
#line 3035
    return (stop.repeat_count == 0);
  }
#line 3038
  if (sourceline != stop.sourceline) {
#line 3039
    stop.sourceline = sourceline;
#line 3040
    (stop.repeat_count) --;
#line 3040
    return (stop.repeat_count == 0);
  }
#line 3042
  return (0);
}
}
#line 3047 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_step(CMDARG *arg , int cmd ) 
{ 
  int ret ;

  {
  {
#line 3051
  ret = next_step(arg, cmd);
  }
#line 3052
  if (ret) {
#line 3053
    stop.fcall_count = fcall_count;
#line 3054
    stop.source = source;
#line 3055
    stop.sourceline = sourceline;
#line 3056
    stop.check_func = & check_step;
  }
#line 3058
  return (ret);
}
}
#line 3063 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int check_stepi(INSTRUCTION **pi ) 
{ 


  {
#line 3066
  (stop.repeat_count) --;
#line 3066
  return (stop.repeat_count == 0);
}
}
#line 3071 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_stepi(CMDARG *arg , int cmd ) 
{ 
  int ret ;

  {
  {
#line 3075
  ret = next_step(arg, cmd);
  }
#line 3076
  if (ret) {
#line 3077
    stop.check_func = & check_stepi;
  }
#line 3078
  return (ret);
}
}
#line 3084 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int check_next(INSTRUCTION **pi ) 
{ 


  {
#line 3089
  if (fcall_count < stop.fcall_count) {
#line 3090
    stop.fcall_count = fcall_count;
#line 3091
    stop.sourceline = sourceline;
#line 3092
    stop.source = source;
#line 3093
    stop.print_frame = (_Bool)1;
#line 3094
    (stop.repeat_count) --;
#line 3094
    return (stop.repeat_count == 0);
  }
#line 3097
  if (fcall_count == stop.fcall_count) {
#line 3098
    if ((unsigned long )source != (unsigned long )stop.source) {
#line 3099
      stop.source = source;
#line 3100
      stop.sourceline = sourceline;
#line 3101
      (stop.repeat_count) --;
#line 3101
      return (stop.repeat_count == 0);
    }
#line 3103
    if (sourceline != stop.sourceline) {
#line 3104
      stop.sourceline = sourceline;
#line 3105
      (stop.repeat_count) --;
#line 3105
      return (stop.repeat_count == 0);
    }
  }
#line 3117
  return (0);
}
}
#line 3122 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_next(CMDARG *arg , int cmd ) 
{ 
  int ret ;

  {
  {
#line 3127
  ret = next_step(arg, cmd);
  }
#line 3128
  if (ret) {
#line 3129
    stop.source = source;
#line 3130
    stop.sourceline = sourceline;
#line 3131
    stop.fcall_count = fcall_count;
#line 3132
    stop.check_func = & check_next;
  }
#line 3134
  return (ret);
}
}
#line 3139 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int check_nexti(INSTRUCTION **pi ) 
{ 
  int tmp___1 ;

  {
#line 3144
  if (fcall_count < stop.fcall_count) {
#line 3145
    stop.print_frame = (_Bool)1;
#line 3146
    stop.fcall_count = fcall_count;
  }
#line 3148
  if (fcall_count == stop.fcall_count) {
#line 3148
    (stop.repeat_count) --;
#line 3148
    if (stop.repeat_count == 0) {
#line 3148
      tmp___1 = 1;
    } else {
#line 3148
      tmp___1 = 0;
    }
  } else {
#line 3148
    tmp___1 = 0;
  }
#line 3148
  return (tmp___1);
}
}
#line 3154 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_nexti(CMDARG *arg , int cmd ) 
{ 
  int ret ;

  {
  {
#line 3159
  ret = next_step(arg, cmd);
  }
#line 3160
  if (ret) {
#line 3161
    stop.fcall_count = fcall_count;
#line 3162
    stop.check_func = & check_nexti;
  }
#line 3164
  return (ret);
}
}
#line 3169 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int check_finish(INSTRUCTION **pi ) 
{ 


  {
#line 3172
  if (fcall_count == stop.fcall_count) {
#line 3173
    stop.print_frame = (_Bool)1;
#line 3174
    return (1);
  }
#line 3176
  return (0);
}
}
#line 3181 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_finish(CMDARG *arg  __attribute__((__unused__)) , int cmd ) 
{ 
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 3184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3184
    if (! prog_running) {
      {
#line 3184
      tmp___1 = gettext("program not running.");
#line 3184
      d_error((char const   *)tmp___1);
      }
#line 3184
      return (0);
    }
#line 3184
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3185
  if (cur_frame == fcall_count) {
    {
#line 3186
    tmp___2 = gettext("\'finish\' not meaningful in the outermost frame main()\n");
#line 3186
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___2);
    }
#line 3188
    return (0);
  }
  {
#line 3190
  stop.fcall_count = (fcall_count - cur_frame) - 1L;
#line 3192
  tmp___3 = gettext("Run till return from ");
#line 3192
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___3);
#line 3193
  print_numbered_frame(cur_frame);
#line 3194
  stop.check_func = & check_finish;
#line 3195
  stop.command = (enum argtype )cmd;
#line 3196
  stop.print_ret = (_Bool)1;
  }
#line 3197
  return (1);
}
}
#line 3202 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int check_return(INSTRUCTION **pi ) 
{ 
  NODE *func___1 ;
  NODE *tmp___1 ;

  {
#line 3207
  if (fcall_count == stop.fcall_count) {
#line 3208
    stop.print_frame = (_Bool)1;
#line 3209
    return (1);
  }
#line 3212
  if (fcall_count > stop.fcall_count) {
    {
#line 3216
    tmp___1 = find_frame(cur_frame);
#line 3216
    func___1 = tmp___1->sub.nodep.x.extra;
#line 3218
    *pi = (func___1->sub.nodep.r.iptr + 1)->d.di;
    }
  }
#line 3222
  return (0);
}
}
#line 3227 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_return(CMDARG *arg , int cmd ) 
{ 
  NODE *func___1 ;
  NODE *n ;
  char *tmp___1 ;
  NODE *tmp___2 ;
  char *tmp___3 ;
  STACK_ITEM *tmp___4 ;
  STACK_ITEM *tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 3232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3232
    if (! prog_running) {
      {
#line 3232
      tmp___1 = gettext("program not running.");
#line 3232
      d_error((char const   *)tmp___1);
      }
#line 3232
      return (0);
    }
#line 3232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3233
  tmp___2 = find_frame(cur_frame);
#line 3233
  func___1 = tmp___2->sub.nodep.x.extra;
  }
#line 3234
  if ((unsigned long )func___1 == (unsigned long )((void *)0)) {
    {
#line 3235
    tmp___3 = gettext("\'return\' not meaningful in the outermost frame main()\n");
#line 3235
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___3);
    }
#line 3236
    return (0);
  }
#line 3239
  stop.fcall_count = (fcall_count - cur_frame) - 1L;
#line 3241
  stop.pc = (func___1->sub.nodep.r.iptr + 1)->d.di;
#line 3243
  stop.command = (enum argtype )cmd;
#line 3245
  stop.check_func = & check_return;
#line 3247
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 3247
    if ((unsigned int )arg->type == 46U) {
      {
#line 3248
      n = dupnode(arg->value.nodeval);
      }
    } else {
      {
#line 3250
      n = dupnode(Nnull_string);
      }
    }
  } else {
    {
#line 3250
    n = dupnode(Nnull_string);
    }
  }
#line 3251
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 3251
    stack_ptr ++;
#line 3251
    tmp___5 = stack_ptr;
  } else {
    {
#line 3251
    tmp___4 = grow_stack();
#line 3251
    tmp___5 = tmp___4;
    }
  }
#line 3251
  tmp___5->rptr = n;
#line 3253
  return (1);
}
}
#line 3258 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int check_until(INSTRUCTION **pi ) 
{ 


  {
#line 3261
  if (fcall_count < stop.fcall_count) {
#line 3262
    stop.print_frame = (_Bool)1;
#line 3263
    return (1);
  } else
#line 3264
  if (fcall_count == stop.fcall_count) {
#line 3265
    if (stop.pc) {
#line 3265
      if ((unsigned long )*pi == (unsigned long )stop.pc) {
#line 3266
        return (1);
      }
    }
#line 3267
    if (stop.sourceline > 0) {
#line 3267
      if ((unsigned long )source == (unsigned long )stop.source) {
#line 3267
        if (sourceline > stop.sourceline) {
#line 3270
          return (1);
        }
      }
    }
  }
#line 3272
  return (0);
}
}
#line 3277 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_until(CMDARG *arg , int cmd ) 
{ 
  SRCFILE *s___0 ;
  char *src ;
  int lineno ;
  INSTRUCTION *rp ;
  INSTRUCTION *ip ;
  NODE *func___1 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 3280
  s___0 = cur_srcfile;
#line 3281
  src = cur_srcfile->src;
  {
#line 3286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3286
    if (! prog_running) {
      {
#line 3286
      tmp___1 = gettext("program not running.");
#line 3286
      d_error((char const   *)tmp___1);
      }
#line 3286
      return (0);
    }
#line 3286
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3287
  stop.pc = (INSTRUCTION *)((void *)0);
#line 3288
  stop.sourceline = 0;
#line 3290
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 3302
    stop.source = source;
#line 3303
    stop.sourceline = sourceline;
#line 3304
    stop.fcall_count = fcall_count - cur_frame;
#line 3305
    stop.check_func = & check_until;
#line 3306
    stop.command = (enum argtype )cmd;
#line 3307
    return (1);
  }
  {
#line 3316
  if ((unsigned int )arg->type == 44U) {
#line 3316
    goto case_44;
  }
#line 3327
  if ((unsigned int )arg->type == 43U) {
#line 3327
    goto case_43;
  }
#line 3336
  if ((unsigned int )arg->type == 50U) {
#line 3336
    goto func;
  }
#line 3352
  goto switch_default;
  case_44: /* CIL Label */ 
  {
#line 3317
  s___0 = source_find(arg->value.sval);
#line 3318
  arg = arg->next;
  }
#line 3319
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 3321
    return (0);
  } else
#line 3319
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 3321
    return (0);
  } else
#line 3319
  if ((unsigned int )arg->type != 43U) {
#line 3319
    if ((unsigned int )arg->type != 50U) {
#line 3321
      return (0);
    }
  }
#line 3322
  src = s___0->src;
#line 3323
  if ((unsigned int )arg->type == 50U) {
#line 3324
    goto func;
  }
  case_43: /* CIL Label */ 
#line 3328
  lineno = (int )arg->value.lval;
#line 3329
  if (lineno <= 0) {
    {
#line 3330
    tmp___2 = gettext("line number %d in file `%s\' out of range");
#line 3330
    d_error((char const   *)tmp___2, lineno, src);
    }
#line 3332
    return (0);
  } else
#line 3329
  if (lineno > s___0->srclines) {
    {
#line 3330
    tmp___2 = gettext("line number %d in file `%s\' out of range");
#line 3330
    d_error((char const   *)tmp___2, lineno, src);
    }
#line 3332
    return (0);
  }
#line 3334
  goto switch_break;
  func: 
  case_50: /* CIL Label */ 
#line 3338
  func___1 = arg->value.nodeval;
#line 3339
  rp = func___1->sub.nodep.r.iptr;
#line 3340
  ip = rp->nexti;
  {
#line 3340
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3340
    if (! ip) {
#line 3340
      goto while_break___0;
    }
#line 3341
    if ((unsigned int )ip->opcode != 99U) {
#line 3341
      if ((int )ip->source_line > 0) {
#line 3342
        stop.pc = ip;
#line 3343
        stop.fcall_count = fcall_count - cur_frame;
#line 3344
        stop.check_func = & check_until;
#line 3345
        stop.command = (enum argtype )cmd;
#line 3346
        return (1);
      }
    }
#line 3340
    ip = ip->nexti;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3349
  tmp___3 = gettext("Can\'t find specified location in function `%s\'\n");
#line 3349
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___3,
          func___1->sub.nodep.name);
  }
  switch_default: /* CIL Label */ 
#line 3353
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 3356
  rp = find_rule(src, (long )lineno);
  }
#line 3356
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 3357
    tmp___4 = gettext("invalid source line %d in file `%s\'");
#line 3357
    d_error((char const   *)tmp___4, lineno, src);
    }
#line 3358
    return (0);
  }
#line 3361
  ip = rp->nexti;
  {
#line 3361
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3361
    if (! ip) {
#line 3361
      goto while_break___1;
    }
#line 3362
    if ((unsigned int )ip->opcode != 99U) {
#line 3362
      if ((int )ip->source_line >= lineno) {
#line 3363
        stop.pc = ip;
#line 3364
        stop.fcall_count = fcall_count - cur_frame;
#line 3365
        stop.check_func = & check_until;
#line 3366
        stop.command = (enum argtype )cmd;
#line 3367
        return (1);
      }
    }
#line 3369
    if ((unsigned long )ip == (unsigned long )(rp + 1)->d.di) {
#line 3370
      goto while_break___1;
    }
#line 3361
    ip = ip->nexti;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 3372
  tmp___5 = gettext("Can\'t find specified location %d in file `%s\'\n");
#line 3372
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___5,
          lineno, src);
  }
#line 3374
  return (0);
}
}
#line 3379 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void print_watch_item(struct list_item *w___0 ) 
{ 
  NODE *symbol ;
  NODE *sub ;
  int i___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 3385
  symbol = w___0->symbol;
#line 3386
  if ((w___0->flags & 2) != 0) {
    {
#line 3387
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s",
            w___0->sname);
#line 3388
    i___0 = 0;
    }
    {
#line 3388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3388
      if (! (i___0 < w___0->num_subs)) {
#line 3388
        goto while_break;
      }
      {
#line 3389
      sub = *(w___0->subs + i___0);
#line 3390
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"[\"%s\"]",
              sub->sub.val.sp);
#line 3388
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3392
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\n");
    }
  } else
#line 3393
  if ((w___0->flags & 4) != 0) {
#line 3394
    if (symbol->flags & 2048U) {
      {
#line 3394
      tmp___1 = mpfr_get_si((mpfr_srcptr )(symbol->sub.val.nm.mpnum), ROUND_MODE);
#line 3394
      tmp___4 = tmp___1;
      }
    } else {
#line 3394
      if (symbol->flags & 4096U) {
        {
#line 3394
        tmp___2 = __gmpz_get_si((mpz_srcptr )(symbol->sub.val.nm.mpi));
#line 3394
        tmp___3 = tmp___2;
        }
      } else {
#line 3394
        tmp___3 = (long )symbol->sub.val.nm.fltnum;
      }
#line 3394
      tmp___4 = tmp___3;
    }
    {
#line 3394
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"$%ld\n",
            tmp___4);
    }
  } else {
    {
#line 3396
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s\n",
            w___0->sname);
    }
  }
  {
#line 3408
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"  Old value: ");
  }
#line 3409
  if ((w___0->flags & 8) != 0) {
    {
#line 3409
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"array, %ld elements\n",
            w___0->value[1].l);
    }
  } else
#line 3409
  if (! w___0->value[1].n) {
#line 3409
    if ((w___0->flags & 2) != 0) {
      {
#line 3409
      tmp___5 = gettext("element not in array\n");
#line 3409
      tmp___7 = tmp___5;
      }
    } else {
      {
#line 3409
      tmp___6 = gettext("untyped variable\n");
#line 3409
      tmp___7 = tmp___6;
      }
    }
    {
#line 3409
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___7);
    }
  } else {
    {
#line 3409
    valinfo(w___0->value[1].n, (int (*)(FILE * , char const   *  , ...))(& fprintf),
            out_fp);
    }
  }
  {
#line 3410
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"  New value: ");
  }
#line 3411
  if ((w___0->flags & 16) != 0) {
    {
#line 3411
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"array, %ld elements\n",
            w___0->value[0].l);
    }
  } else
#line 3411
  if (! w___0->value[0].n) {
#line 3411
    if ((w___0->flags & 2) != 0) {
      {
#line 3411
      tmp___8 = gettext("element not in array\n");
#line 3411
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 3411
      tmp___9 = gettext("untyped variable\n");
#line 3411
      tmp___10 = tmp___9;
      }
    }
    {
#line 3411
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___10);
    }
  } else {
    {
#line 3411
    valinfo(w___0->value[0].n, (int (*)(FILE * , char const   *  , ...))(& fprintf),
            out_fp);
    }
  }
#line 3414
  return;
}
}
#line 3423 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int last_rule  =    0;
#line 3420 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void next_command(void) 
{ 
  struct list_item *d ;
  struct list_item *w___0 ;
  BREAKPOINT *b___0 ;
  SRCFILE *s___0 ;
  char *tmp___1 ;
  int ret ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 3424
  d = (struct list_item *)((void *)0);
#line 3424
  w___0 = (struct list_item *)((void *)0);
#line 3425
  b___0 = (BREAKPOINT *)((void *)0);
#line 3428
  if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 3429
    stop.command = (enum argtype )0;
#line 3430
    stop.check_func = (int (*)(INSTRUCTION ** ))((void *)0);
#line 3431
    return;
  }
#line 3434
  if (stop.break_point) {
    {
#line 3435
    b___0 = find_breakpoint((long )stop.break_point);
    }
#line 3437
    if (b___0->silent) {
#line 3438
      goto no_output;
    }
  } else
#line 3439
  if (stop.watch_point) {
    {
#line 3440
    w___0 = find_item(& watch_list, (long )stop.watch_point);
    }
#line 3441
    if (w___0->silent) {
#line 3442
      goto no_output;
    }
  }
#line 3445
  if (cur_rule != last_rule) {
    {
#line 3446
    tmp___1 = gettext("Stopping in %s ...\n");
#line 3446
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1,
            ruletab[cur_rule]);
#line 3447
    last_rule = cur_rule;
    }
  }
#line 3450
  if ((unsigned long )b___0 != (unsigned long )((void *)0)) {
    {
#line 3451
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"Breakpoint %d, ",
            b___0->number);
    }
  } else
#line 3452
  if ((unsigned long )w___0 != (unsigned long )((void *)0)) {
    {
#line 3453
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"Watchpoint %d: ",
            w___0->number);
#line 3454
    print_watch_item(w___0);
    }
  }
#line 3458
  if (stop.print_frame) {
    {
#line 3459
    print_frame(frame_ptr->sub.nodep.x.extra, source, sourceline);
#line 3460
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\n");
#line 3461
    stop.print_frame = (_Bool)0;
    }
  }
  {
#line 3464
  print_lines(source, sourceline, 1);
#line 3467
  d = display_list.prev;
  }
  {
#line 3467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3467
    if (! ((unsigned long )d != (unsigned long )(& display_list))) {
#line 3467
      goto while_break;
    }
    {
#line 3468
    display(d);
#line 3467
    d = d->prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
  no_output: 
#line 3475
  last_printed_line = sourceline - list_size / 2;
#line 3476
  if (last_printed_line < 0) {
#line 3477
    last_printed_line = 0;
  }
  {
#line 3480
  s___0 = source_find(source);
  }
#line 3481
  if ((unsigned long )cur_srcfile != (unsigned long )s___0) {
#line 3482
    if (cur_srcfile->fd != -1) {
      {
#line 3483
      close(cur_srcfile->fd);
#line 3484
      cur_srcfile->fd = -1;
      }
    }
#line 3486
    cur_srcfile = s___0;
  }
#line 3489
  stop.command = (enum argtype )0;
#line 3490
  stop.check_func = (int (*)(INSTRUCTION ** ))((void *)0);
#line 3492
  if ((unsigned long )b___0 != (unsigned long )((void *)0)) {
    {
#line 3494
    ret = execute_commands(& b___0->commands);
    }
#line 3495
    if (((int )b___0->flags & 4) != 0) {
      {
#line 3496
      delete_breakpoint(b___0);
      }
    }
#line 3497
    if (ret) {
#line 3498
      return;
    }
  } else
#line 3499
  if ((unsigned long )w___0 != (unsigned long )((void *)0)) {
    {
#line 3499
    tmp___2 = execute_commands(& w___0->commands);
    }
#line 3499
    if (tmp___2) {
#line 3500
      return;
    }
  }
  {
#line 3502
  zzparse();
  }
#line 3503
  return;
}
}
#line 3507 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void debug_post_execute(INSTRUCTION *pc ) 
{ 
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  NODE *r ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 3510
  tmp___1 = in_main_context();
  }
#line 3510
  if (! tmp___1) {
#line 3511
    return;
  }
  {
#line 3516
  if ((unsigned int )pc->opcode == 58U) {
#line 3516
    goto case_58;
  }
#line 3516
  if ((unsigned int )pc->opcode == 64U) {
#line 3516
    goto case_58;
  }
#line 3516
  if ((unsigned int )pc->opcode == 57U) {
#line 3516
    goto case_58;
  }
#line 3535
  if ((unsigned int )pc->opcode == 59U) {
#line 3535
    goto case_59;
  }
#line 3550
  if ((unsigned int )pc->opcode == 86U) {
#line 3550
    goto case_86;
  }
#line 3550
  if ((unsigned int )pc->opcode == 87U) {
#line 3550
    goto case_86;
  }
#line 3553
  goto switch_default;
  case_58: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_57: /* CIL Label */ 
#line 3517
  if ((unsigned int )stop.command == 15U) {
    {
#line 3519
    stop.print_ret = (_Bool)0;
#line 3520
    stop.print_frame = (_Bool)0;
#line 3521
    stop.command = (enum argtype )0;
#line 3522
    stop.check_func = (int (*)(INSTRUCTION ** ))((void *)0);
#line 3523
    tmp___2 = op2str(pc->opcode);
#line 3523
    tmp___3 = gettext("\'finish\' not meaningful with non-local jump \'%s\'\n");
#line 3523
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___3,
            tmp___2);
    }
  } else
#line 3525
  if ((unsigned int )stop.command == 38U) {
    {
#line 3527
    stop.print_frame = (_Bool)0;
#line 3528
    stop.command = (enum argtype )0;
#line 3529
    stop.check_func = (int (*)(INSTRUCTION ** ))((void *)0);
#line 3530
    tmp___4 = op2str(pc->opcode);
#line 3530
    tmp___5 = gettext("\'until\' not meaningful with non-local jump \'%s\'\n");
#line 3530
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___5,
            tmp___4);
    }
  }
#line 3533
  goto switch_break;
  case_59: /* CIL Label */ 
#line 3536
  if ((unsigned int )stop.command == 15U) {
#line 3536
    if (fcall_count == stop.fcall_count) {
#line 3536
      if (stop.print_ret) {
        {
#line 3542
        r = stack_ptr->rptr;
#line 3543
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"Returned value = ");
#line 3544
        valinfo(r, (int (*)(FILE * , char const   *  , ...))(& fprintf), out_fp);
#line 3545
        stop.print_ret = (_Bool)0;
        }
      }
    }
  }
#line 3547
  goto switch_break;
  case_86: /* CIL Label */ 
  case_87: /* CIL Label */ 
#line 3551
  return;
  switch_default: /* CIL Label */ 
#line 3554
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3556
  return;
}
}
#line 3566 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static _Bool cant_stop  =    (_Bool)0;
#line 3563 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int debug_pre_execute(INSTRUCTION **pi ) 
{ 
  NODE *m ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 3569
  tmp___2 = in_main_context();
  }
#line 3569
  if (! tmp___2) {
    {
#line 3570
    tmp___1 = pre_execute_code(pi);
    }
#line 3570
    return (tmp___1);
  }
#line 3572
  cur_pc = *pi;
#line 3573
  stop.break_point = 0;
#line 3574
  stop.watch_point = 0;
#line 3575
  cur_frame = 0L;
#line 3577
  if (do_trace) {
#line 3577
    if ((unsigned int )cur_pc->opcode != 99U) {
#line 3577
      if ((unsigned int )stop.command != 27U) {
        {
#line 3581
        print_instruction(cur_pc, (int (*)(FILE * , char const   *  , ...))(& fprintf),
                          out_fp, 0);
        }
      }
    }
  }
  {
#line 3590
  if ((unsigned int )cur_pc->opcode == 80U) {
#line 3590
    goto case_80;
  }
#line 3594
  if ((unsigned int )cur_pc->opcode == 93U) {
#line 3594
    goto case_93;
  }
#line 3598
  if ((unsigned int )cur_pc->opcode == 78U) {
#line 3598
    goto case_78;
  }
#line 3604
  if ((unsigned int )cur_pc->opcode == 89U) {
#line 3604
    goto case_89;
  }
#line 3610
  if ((unsigned int )cur_pc->opcode == 92U) {
#line 3610
    goto case_92;
  }
#line 3614
  if ((unsigned int )cur_pc->opcode == 49U) {
#line 3614
    goto case_49;
  }
#line 3619
  if ((unsigned int )cur_pc->opcode == 91U) {
#line 3619
    goto case_91;
  }
#line 3619
  if ((unsigned int )cur_pc->opcode == 97U) {
#line 3619
    goto case_91;
  }
#line 3622
  if ((unsigned int )cur_pc->opcode == 99U) {
#line 3622
    goto case_99;
  }
#line 3625
  goto switch_default;
  case_80: /* CIL Label */ 
#line 3591
  cant_stop = (_Bool)1;
#line 3592
  goto switch_break;
  case_93: /* CIL Label */ 
#line 3595
  cant_stop = (_Bool)0;
#line 3596
  return (1);
  case_78: /* CIL Label */ 
#line 3599
  m = cur_pc->d.dn;
#line 3600
  if ((unsigned int )m->type == 4U) {
#line 3600
    if (m->sub.nodep.x.aptr) {
#line 3601
      cant_stop = (_Bool)1;
    }
  }
#line 3602
  goto switch_break;
  case_89: /* CIL Label */ 
#line 3605
  m = cur_pc->x.xn;
#line 3606
  if ((unsigned int )m->type == 4U) {
#line 3606
    if (m->sub.nodep.x.aptr) {
#line 3607
      cant_stop = (_Bool)1;
    }
  }
#line 3608
  goto switch_break;
  case_92: /* CIL Label */ 
#line 3611
  cant_stop = (_Bool)0;
#line 3612
  return (1);
  case_49: /* CIL Label */ 
#line 3615
  cur_rule = (int )cur_pc->x.xl;
#line 3616
  return (1);
  case_91: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 3620
  return (1);
  case_99: /* CIL Label */ 
#line 3623
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3626
  if ((int )cur_pc->source_line <= 0) {
#line 3627
    return (1);
  }
#line 3628
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3631
  if (cant_stop) {
#line 3632
    return (1);
  }
  {
#line 3636
  tmp___3 = check_breakpoint(pi);
  }
#line 3636
  if (tmp___3) {
#line 3636
    goto _L;
  } else {
    {
#line 3636
    tmp___4 = check_watchpoint();
    }
#line 3636
    if (tmp___4) {
#line 3636
      goto _L;
    } else
#line 3636
    if (stop.check_func) {
      {
#line 3636
      tmp___5 = (*(stop.check_func))(pi);
      }
#line 3636
      if (tmp___5) {
        _L: /* CIL Label */ 
        {
#line 3639
        next_command();
        }
#line 3640
        if ((unsigned int )stop.command == 27U) {
#line 3641
          *pi = stop.pc;
        }
      }
    }
  }
#line 3647
  return ((unsigned long )cur_pc == (unsigned long )*pi);
}
}
#line 3652 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void print_memory(NODE *m , NODE *func___1 , int (*print_func)(FILE * , char const   * 
                                                                      , ...) , FILE *fp___0 ) 
{ 
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 3656
  if ((unsigned int )m->type == 1U) {
#line 3656
    goto case_1;
  }
#line 3686
  if ((unsigned int )m->type == 2U) {
#line 3686
    goto case_2;
  }
#line 3690
  if ((unsigned int )m->type == 3U) {
#line 3690
    goto case_3;
  }
#line 3693
  if ((unsigned int )m->type == 7U) {
#line 3693
    goto case_7;
  }
#line 3700
  if ((unsigned int )m->type == 5U) {
#line 3700
    goto case_5;
  }
#line 3700
  if ((unsigned int )m->type == 6U) {
#line 3700
    goto case_5;
  }
#line 3700
  if ((unsigned int )m->type == 4U) {
#line 3700
    goto case_5;
  }
#line 3704
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3657
  if ((unsigned long )m == (unsigned long )Nnull_string) {
    {
#line 3658
    (*print_func)(fp___0, "Nnull_string");
    }
  } else
#line 3659
  if ((m->flags & 16U) != 0U) {
#line 3661
    if ((m->flags & 2048U) != 0U) {
      {
#line 3662
      tmp___1 = mpg_fmt("%R*g", (int )ROUND_MODE, m->sub.val.nm.mpnum);
#line 3662
      (*print_func)(fp___0, "%s", tmp___1);
      }
    } else
#line 3663
    if ((m->flags & 4096U) != 0U) {
      {
#line 3664
      tmp___2 = mpg_fmt("%Zd", m->sub.val.nm.mpi);
#line 3664
      (*print_func)(fp___0, "%s", tmp___2);
      }
    } else {
      {
#line 3667
      (*print_func)(fp___0, "%g", m->sub.val.nm.fltnum);
      }
    }
  } else
#line 3668
  if ((m->flags & 2U) != 0U) {
    {
#line 3669
    pp_string_fp(print_func, fp___0, (char const   *)m->sub.val.sp, m->sub.val.slen,
                 '\"', (_Bool)0);
    }
  } else
#line 3670
  if ((m->flags & 8U) != 0U) {
#line 3672
    if ((m->flags & 2048U) != 0U) {
      {
#line 3673
      tmp___3 = mpg_fmt("%R*g", (int )ROUND_MODE, m->sub.val.nm.mpnum);
#line 3673
      (*print_func)(fp___0, "%s", tmp___3);
      }
    } else
#line 3674
    if ((m->flags & 4096U) != 0U) {
      {
#line 3675
      tmp___4 = mpg_fmt("%Zd", m->sub.val.nm.mpi);
#line 3675
      (*print_func)(fp___0, "%s", tmp___4);
      }
    } else {
      {
#line 3678
      (*print_func)(fp___0, "%g", m->sub.val.nm.fltnum);
      }
    }
  } else
#line 3679
  if ((m->flags & 4U) != 0U) {
    {
#line 3680
    pp_string_fp(print_func, fp___0, (char const   *)m->sub.val.sp, m->sub.val.slen,
                 '\"', (_Bool)0);
    }
  } else {
    {
#line 3682
    (*print_func)(fp___0, "-?-");
    }
  }
  {
#line 3683
  tmp___5 = flags2str((int )m->flags);
#line 3683
  (*print_func)(fp___0, " [%s]", tmp___5);
  }
#line 3684
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3687
  pp_string_fp(print_func, fp___0, (char const   *)(m->sub.nodep.x.extra)->sub.val.sp,
               (m->sub.nodep.x.extra)->sub.val.slen, '/', (_Bool)0);
  }
#line 3688
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3691
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 3695
  (*print_func)(fp___0, "%s", (func___1->sub.nodep.rn + m->sub.nodep.l.ll)->sub.nodep.name);
  }
#line 3696
  goto switch_break;
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 3701
  (*print_func)(fp___0, "%s", m->sub.nodep.name);
  }
#line 3702
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 3705
  (*print_func)(fp___0, "?");
  }
  switch_break: /* CIL Label */ ;
  }
#line 3707
  return;
}
}
#line 3715 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static NODE *func  =    (NODE *)((void *)0);
#line 3716 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int noffset  =    0;
#line 3719 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char buf___3[50]  ;
#line 3871 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct flagtab  const  values___3[4]  = {      {1, "GSUB"}, 
        {2, "GENSUB"}, 
        {4, "LITERAL"}, 
        {0, (char const   *)((void *)0)}};
#line 3934 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char const   * const  linttypetab[3]  = {      (char const   */* const  */)"LINT_illegal",      (char const   */* const  */)"LINT_assign_in_cond",      (char const   */* const  */)"LINT_no_effect"};
#line 3711 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void print_instruction(INSTRUCTION *pc , int (*print_func)(FILE * , char const   * 
                                                                  , ...) , FILE *fp___0 ,
                              int in_dump ) 
{ 
  int pcount ;
  char const   *tmp___1 ;
  int j ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  NODE *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  char const   *fname ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;

  {
#line 3714
  pcount = 0;
#line 3718
  if (noffset == 0) {
    {
#line 3721
    tmp___1 = opcode2str(pc->opcode);
#line 3721
    noffset = sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"[      :%p] %-20.20s: ",
                      (void *)pc, tmp___1);
    }
  }
#line 3725
  if ((unsigned int )pc->opcode == 97U) {
#line 3726
    func = pc->x.xn;
#line 3727
    pcount = (int )func->sub.nodep.l.ll;
#line 3728
    if (in_dump) {
      {
#line 3730
      (*print_func)(fp___0, "\n\t# Function: %s (", func->sub.nodep.name);
#line 3731
      j = 0;
      }
      {
#line 3731
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3731
        if (! (j < pcount)) {
#line 3731
          goto while_break;
        }
        {
#line 3732
        (*print_func)(fp___0, "%s", (func->sub.nodep.rn + j)->sub.nodep.name);
        }
#line 3733
        if (j < pcount - 1) {
          {
#line 3734
          (*print_func)(fp___0, ", ");
          }
        }
#line 3731
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3736
      (*print_func)(fp___0, ")\n\n");
      }
    }
  } else
#line 3738
  if ((unsigned int )pc->opcode == 49U) {
#line 3739
    if (in_dump) {
      {
#line 3740
      (*print_func)(fp___0, "\n\t# %s\n\n", ruletab[pc->x.xl]);
      }
    }
  }
#line 3743
  if ((unsigned int )pc->opcode == 87U) {
    {
#line 3744
    (*print_func)(fp___0, "\n");
    }
  }
#line 3746
  if ((int )pc->source_line <= 0) {
    {
#line 3747
    tmp___2 = opcode2str(pc->opcode);
#line 3747
    (*print_func)(fp___0, "[      :%p] %-20.20s: ", pc, tmp___2);
    }
  } else {
    {
#line 3749
    tmp___3 = opcode2str(pc->opcode);
#line 3749
    (*print_func)(fp___0, "[%6d:%p] %-20.20s: ", (int )pc->source_line, pc, tmp___3);
    }
  }
#line 3752
  if (prog_running) {
#line 3752
    if (! in_dump) {
      {
#line 3754
      tmp___4 = find_frame(0L);
#line 3754
      func = tmp___4->sub.nodep.x.extra;
      }
    }
  }
  {
#line 3759
  if ((unsigned int )pc->opcode == 91U) {
#line 3759
    goto case_91;
  }
#line 3763
  if ((unsigned int )pc->opcode == 92U) {
#line 3763
    goto case_92;
  }
#line 3770
  if ((unsigned int )pc->opcode == 93U) {
#line 3770
    goto case_93;
  }
#line 3775
  if ((unsigned int )pc->opcode == 80U) {
#line 3775
    goto case_80;
  }
#line 3780
  if ((unsigned int )pc->opcode == 97U) {
#line 3780
    goto case_97;
  }
#line 3785
  if ((unsigned int )pc->opcode == 62U) {
#line 3785
    goto case_62;
  }
#line 3791
  if ((unsigned int )pc->opcode == 63U) {
#line 3791
    goto case_63;
  }
#line 3798
  if ((unsigned int )pc->opcode == 55U) {
#line 3798
    goto case_55;
  }
#line 3803
  if ((unsigned int )pc->opcode == 56U) {
#line 3803
    goto case_56;
  }
#line 3803
  if ((unsigned int )pc->opcode == 54U) {
#line 3803
    goto case_56;
  }
#line 3809
  if ((unsigned int )pc->opcode == 70U) {
#line 3809
    goto case_70;
  }
#line 3809
  if ((unsigned int )pc->opcode == 71U) {
#line 3809
    goto case_70;
  }
#line 3814
  if ((unsigned int )pc->opcode == 64U) {
#line 3814
    goto case_64;
  }
#line 3819
  if ((unsigned int )pc->opcode == 87U) {
#line 3819
    goto case_87;
  }
#line 3826
  if ((unsigned int )pc->opcode == 86U) {
#line 3826
    goto case_86;
  }
#line 3838
  if ((unsigned int )pc->opcode == 53U) {
#line 3838
    goto case_53;
  }
#line 3838
  if ((unsigned int )pc->opcode == 52U) {
#line 3838
    goto case_53;
  }
#line 3838
  if ((unsigned int )pc->opcode == 88U) {
#line 3838
    goto case_53;
  }
#line 3838
  if ((unsigned int )pc->opcode == 57U) {
#line 3838
    goto case_53;
  }
#line 3838
  if ((unsigned int )pc->opcode == 38U) {
#line 3838
    goto case_53;
  }
#line 3838
  if ((unsigned int )pc->opcode == 36U) {
#line 3838
    goto case_53;
  }
#line 3838
  if ((unsigned int )pc->opcode == 84U) {
#line 3838
    goto case_53;
  }
#line 3838
  if ((unsigned int )pc->opcode == 85U) {
#line 3838
    goto case_53;
  }
#line 3838
  if ((unsigned int )pc->opcode == 83U) {
#line 3838
    goto case_53;
  }
#line 3841
  if ((unsigned int )pc->opcode == 58U) {
#line 3841
    goto case_58;
  }
#line 3846
  if ((unsigned int )pc->opcode == 50U) {
#line 3846
    goto case_50;
  }
#line 3851
  if ((unsigned int )pc->opcode == 89U) {
#line 3851
    goto case_89;
  }
#line 3858
  if ((unsigned int )pc->opcode == 14U) {
#line 3858
    goto case_14;
  }
#line 3863
  if ((unsigned int )pc->opcode == 15U) {
#line 3863
    goto case_15;
  }
#line 3868
  if ((unsigned int )pc->opcode == 66U) {
#line 3868
    goto case_66;
  }
#line 3888
  if ((unsigned int )pc->opcode == 65U) {
#line 3888
    goto case_65;
  }
#line 3893
  if ((unsigned int )pc->opcode == 67U) {
#line 3893
    goto case_67;
  }
#line 3899
  if ((unsigned int )pc->opcode == 17U) {
#line 3899
    goto case_17;
  }
#line 3899
  if ((unsigned int )pc->opcode == 16U) {
#line 3899
    goto case_17;
  }
#line 3903
  if ((unsigned int )pc->opcode == 27U) {
#line 3903
    goto case_27;
  }
#line 3908
  if ((unsigned int )pc->opcode == 79U) {
#line 3908
    goto case_79;
  }
#line 3915
  if ((unsigned int )pc->opcode == 69U) {
#line 3915
    goto case_69;
  }
#line 3915
  if ((unsigned int )pc->opcode == 60U) {
#line 3915
    goto case_69;
  }
#line 3919
  if ((unsigned int )pc->opcode == 13U) {
#line 3919
    goto case_13;
  }
#line 3926
  if ((unsigned int )pc->opcode == 49U) {
#line 3926
    goto case_49;
  }
#line 3932
  if ((unsigned int )pc->opcode == 100U) {
#line 3932
    goto case_100;
  }
#line 3943
  if ((unsigned int )pc->opcode == 98U) {
#line 3943
    goto case_98;
  }
#line 3947
  if ((unsigned int )pc->opcode == 26U) {
#line 3947
    goto case_26;
  }
#line 3956
  if ((unsigned int )pc->opcode == 78U) {
#line 3956
    goto case_78;
  }
#line 3977
  if ((unsigned int )pc->opcode == 35U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 6U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 4U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 12U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 2U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 10U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 8U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 48U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 46U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 47U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 75U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 76U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 77U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 73U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 72U) {
#line 3977
    goto case_35;
  }
#line 3977
  if ((unsigned int )pc->opcode == 74U) {
#line 3977
    goto case_35;
  }
#line 3980
  goto switch_default;
  case_91: /* CIL Label */ 
  {
#line 3760
  tmp___5 = get_spec_varname(pc->x.aptr);
#line 3760
  (*print_func)(fp___0, "[update_%s()]\n", tmp___5);
  }
#line 3761
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 3764
  tmp___6 = get_spec_varname(pc->x.aptr);
#line 3764
  (*print_func)(fp___0, "[set_%s()]", tmp___6);
  }
#line 3765
  if (pc->d.dl != 0L) {
    {
#line 3766
    tmp___7 = opcode2str((OPCODE )pc->d.dl);
#line 3766
    (*print_func)(fp___0, " [assign_ctxt = %s]", tmp___7);
    }
  }
  {
#line 3767
  (*print_func)(fp___0, "\n");
  }
#line 3768
  goto switch_break;
  case_93: /* CIL Label */ 
#line 3771
  if ((unsigned long )pc->x.aptr == (unsigned long )(& reset_record)) {
#line 3771
    tmp___8 = "reset_record()";
  } else {
#line 3771
    tmp___8 = "invalidate_field0()";
  }
  {
#line 3771
  (*print_func)(fp___0, "[%s]\n", tmp___8);
  }
#line 3773
  goto switch_break;
  case_80: /* CIL Label */ 
#line 3776
  if (pc->x.xl) {
#line 3776
    tmp___9 = "true";
  } else {
#line 3776
    tmp___9 = "false";
  }
  {
#line 3776
  (*print_func)(fp___0, "[target_assign = %p] [do_reference = %s]\n", pc->d.di, tmp___9);
  }
#line 3778
  goto switch_break;
  case_97: /* CIL Label */ 
#line 3781
  if (pc->d.name) {
#line 3781
    tmp___10 = (char const   *)pc->d.name;
  } else {
#line 3781
    tmp___10 = "cmd. line";
  }
  {
#line 3781
  (*print_func)(fp___0, "[param_cnt = %d] [source_file = %s]\n", pcount, tmp___10);
  }
#line 3783
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 3786
  tmp___11 = redir2str((int )pc->d.dl);
  }
#line 3786
  if (pc->x.xl) {
#line 3786
    tmp___12 = "true";
  } else {
#line 3786
    tmp___12 = "false";
  }
  {
#line 3786
  (*print_func)(fp___0, "[into_var = %s] [redir_type = \"%s\"]\n", tmp___12, tmp___11);
  }
#line 3789
  goto switch_break;
  case_63: /* CIL Label */ 
#line 3792
  if (pc->x.xl) {
#line 3792
    tmp___13 = "true";
  } else {
#line 3792
    tmp___13 = "false";
  }
  {
#line 3792
  (*print_func)(fp___0, "[into_var = %s]\n", tmp___13);
#line 3793
  (*print_func)(fp___0, "%*s[target_beginfile = %p] [target_endfile = %p]\n", noffset,
                "", (pc + 1)->d.di, (pc + 1)->x.xi);
  }
#line 3796
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 3799
  tmp___14 = redir2str((int )pc->d.dl);
#line 3799
  (*print_func)(fp___0, "[redir_type = \"%s\"]\n", tmp___14);
  }
#line 3800
  goto switch_break;
  case_56: /* CIL Label */ 
  case_54: /* CIL Label */ 
  {
#line 3804
  tmp___15 = redir2str((int )pc->d.dl);
#line 3804
  (*print_func)(fp___0, "[expr_count = %ld] [redir_type = \"%s\"]\n", pc->x.xl, tmp___15);
  }
#line 3806
  goto switch_break;
  case_70: /* CIL Label */ 
  case_71: /* CIL Label */ 
  {
#line 3810
  (*print_func)(fp___0, "[func_name = %s] [arg_count = %ld]\n", pc->d.name, (pc + 1)->x.xl);
  }
#line 3812
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 3815
  (*print_func)(fp___0, "[target_newfile = %p] [target_endfile = %p]\n", pc->d.di,
                pc->x.xi);
  }
#line 3817
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 3820
  (*print_func)(fp___0, "[target_jmp = %p] [target_endfile = %p]\n", pc->d.di, pc->x.xi);
#line 3822
  (*print_func)(fp___0, "%*s[target_get_record = %p]\n", noffset, "", (pc + 1)->x.xi);
  }
#line 3824
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 3827
  (*print_func)(fp___0, "[target_newfile = %p]\n", pc->d.di);
  }
#line 3828
  goto switch_break;
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_83: /* CIL Label */ 
  {
#line 3839
  (*print_func)(fp___0, "[target_jmp = %p]\n", pc->d.di);
  }
#line 3840
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 3842
  (*print_func)(fp___0, "[target_end = %p] [target_atexit = %p]\n", pc->d.di, pc->x.xi);
  }
#line 3844
  goto switch_break;
  case_50: /* CIL Label */ 
#line 3847
  if ((pc + 1)->x.xl) {
#line 3847
    tmp___16 = "true";
  } else {
#line 3847
    tmp___16 = "false";
  }
  {
#line 3847
  (*print_func)(fp___0, "[target_jmp = %p] [match_exp = %s]\n", pc->d.di, tmp___16);
  }
#line 3849
  goto switch_break;
  case_89: /* CIL Label */ 
#line 3852
  if ((unsigned int )(pc->x.xn)->type == 7U) {
#line 3852
    tmp___17 = (func->sub.nodep.rn + (pc->x.xn)->sub.nodep.l.ll)->sub.nodep.name;
  } else {
#line 3852
    tmp___17 = (pc->x.xn)->sub.nodep.name;
  }
  {
#line 3852
  (*print_func)(fp___0, "[array_var = %s] [target_jmp = %p]\n", tmp___17, pc->d.di);
  }
#line 3856
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 3859
  (*print_func)(fp___0, "[triggered = %ld] [target_jmp = %p]\n", pc->x.xl, pc->d.di);
  }
#line 3861
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 3864
  (*print_func)(fp___0, "[line_range = %p] [target_jmp = %p]\n", pc->x.xi, pc->d.di);
  }
#line 3866
  goto switch_break;
  case_66: /* CIL Label */ 
#line 3870
  fname = "sub";
#line 3878
  if ((pc->d.dl & 1L) != 0L) {
#line 3879
    fname = "gsub";
  } else
#line 3880
  if ((pc->d.dl & 2L) != 0L) {
#line 3881
    fname = "gensub";
  }
  {
#line 3882
  tmp___18 = genflags2str((int )pc->d.dl, values___3);
#line 3882
  (*print_func)(fp___0, "%s [arg_count = %ld] [sub_flags = %s]\n", fname, pc->x.xl,
                tmp___18);
  }
#line 3886
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 3889
  tmp___19 = getfname(pc->d.fptr);
#line 3889
  (*print_func)(fp___0, "%s [arg_count = %ld]\n", tmp___19, pc->x.xl);
  }
#line 3891
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 3894
  (*print_func)(fp___0, "%s [arg_count = %ld]\n", (pc + 1)->d.name, pc->x.xl);
  }
#line 3896
  goto switch_break;
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  {
#line 3900
  (*print_func)(fp___0, "[sub_count = %ld]\n", pc->d.dl);
  }
#line 3901
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 3904
  print_memory(pc->d.dn, func, print_func, fp___0);
#line 3905
  (*print_func)(fp___0, " [sub_count = %ld]\n", pc->x.xl);
  }
#line 3906
  goto switch_break;
  case_79: /* CIL Label */ 
#line 3909
  if (pc->x.xl) {
#line 3909
    tmp___20 = "true";
  } else {
#line 3909
    tmp___20 = "false";
  }
  {
#line 3909
  (*print_func)(fp___0, "[sub_count = %ld] [do_reference = %s]\n", pc->d.dl, tmp___20);
  }
#line 3912
  goto switch_break;
  case_69: /* CIL Label */ 
  case_60: /* CIL Label */ 
  {
#line 3916
  (*print_func)(fp___0, "[expr_count = %ld]\n", pc->x.xl);
  }
#line 3917
  goto switch_break;
  case_13: /* CIL Label */ 
#line 3921
  if ((pc->d.dl & 1L) != 0L) {
#line 3921
    tmp___21 = "CSUBSEP";
  } else {
#line 3921
    tmp___21 = "0";
  }
  {
#line 3921
  (*print_func)(fp___0, "[expr_count = %ld] [concat_flag = %s]\n", pc->x.xl, tmp___21);
  }
#line 3924
  goto switch_break;
  case_49: /* CIL Label */ 
#line 3927
  if (pc->d.name) {
#line 3927
    tmp___22 = (char const   *)pc->d.name;
  } else {
#line 3927
    tmp___22 = "cmd. line";
  }
  {
#line 3927
  (*print_func)(fp___0, "[in_rule = %s] [source_file = %s]\n", ruletab[pc->x.xl],
                tmp___22);
  }
#line 3930
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 3939
  (*print_func)(fp___0, "[lint_type = %s]\n", linttypetab[pc->d.dl]);
  }
#line 3941
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 3944
  (*print_func)(fp___0, "[exec_count = %ld]\n", pc->d.dl);
  }
#line 3945
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 3948
  print_memory(pc->d.dn, func, print_func, fp___0);
  }
#line 3949
  if ((unsigned long )pc->x.xn != (unsigned long )((void *)0)) {
    {
#line 3950
    (*print_func)(fp___0, " = ");
#line 3951
    print_memory(pc->x.xn, func, print_func, fp___0);
    }
  }
  {
#line 3953
  (*print_func)(fp___0, "\n");
  }
#line 3954
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 3957
  print_memory(pc->d.dn, func, print_func, fp___0);
  }
#line 3958
  if (pc->x.xl) {
#line 3958
    tmp___23 = "true";
  } else {
#line 3958
    tmp___23 = "false";
  }
  {
#line 3958
  (*print_func)(fp___0, " [do_reference = %s]\n", tmp___23);
  }
#line 3960
  goto switch_break;
  case_35: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_74: /* CIL Label */ 
  {
#line 3978
  print_memory(pc->d.dn, func, print_func, fp___0);
  }
  switch_default: /* CIL Label */ 
  {
#line 3981
  (*print_func)(fp___0, "\n");
  }
#line 3982
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3984
  return;
}
}
#line 3988 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_trace_instruction(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 


  {
#line 3991
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 3991
    if ((unsigned int )arg->type == 42U) {
#line 3991
      if (arg->value.lval == 11L) {
#line 3993
        do_trace = 1;
      } else {
#line 3995
        do_trace = 0;
      }
    } else {
#line 3995
      do_trace = 0;
    }
  } else {
#line 3995
    do_trace = 0;
  }
#line 3996
  return (0);
}
}
#line 4001 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int print_code(INSTRUCTION *pc , void *x ) 
{ 
  struct pf_data *data ;

  {
#line 4004
  data = (struct pf_data *)x;
  {
#line 4005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4005
    if (! ((unsigned long )pc != (unsigned long )((void *)0))) {
#line 4005
      goto while_break;
    }
    {
#line 4006
    print_instruction(pc, data->print_func, data->fp, (int )data->defn);
#line 4005
    pc = pc->nexti;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4007
  return (0);
}
}
#line 4012 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_dump_instructions(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  FILE *fp___0 ;
  NODE **funcs ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 4018
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 4018
    if ((unsigned int )arg->type == 44U) {
      {
#line 4020
      fp___0 = fopen((char const   */* __restrict  */)arg->value.sval, (char const   */* __restrict  */)"w");
      }
#line 4020
      if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
        {
#line 4021
        tmp___1 = __errno_location();
#line 4021
        tmp___2 = strerror(*tmp___1);
#line 4021
        tmp___3 = gettext("could not open `%s\' for writing (%s)");
#line 4021
        d_error((char const   *)tmp___3, arg->value.sval, tmp___2);
        }
#line 4023
        return (0);
      }
      {
#line 4025
      pf_data.print_func = (int (*)(FILE * , char const   *  , ...))(& fprintf);
#line 4026
      pf_data.fp = fp___0;
#line 4027
      pf_data.defn = (_Bool)1;
#line 4028
      print_code(code_block, (void *)(& pf_data));
#line 4029
      funcs = function_list((_Bool)1);
#line 4030
      foreach_func(funcs, & print_code, (void *)(& pf_data));
#line 4033
      free((void *)funcs);
#line 4034
      fclose(fp___0);
      }
#line 4035
      return (0);
    }
  }
  {
#line 4038
  funcs = function_list((_Bool)1);
#line 4039
  initialize_pager(out_fp);
#line 4040
  tmp___4 = _setjmp((struct __jmp_buf_tag *)(pager_quit_tag));
  }
#line 4040
  if (tmp___4 == 0) {
    {
#line 4041
    pf_data.print_func = & gprintf;
#line 4042
    pf_data.fp = out_fp;
#line 4043
    pf_data.defn = (_Bool)1;
#line 4044
    print_code(code_block, (void *)(& pf_data));
#line 4045
    foreach_func(funcs, & print_code, (void *)(& pf_data));
    }
  }
  {
#line 4049
  free((void *)funcs);
  }
#line 4050
  return (0);
}
}
#line 4055 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_save(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  FILE *fp___0 ;
  HIST_ENTRY **hist_list ;
  int i___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *line ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 4063
  fp___0 = fopen((char const   */* __restrict  */)arg->value.sval, (char const   */* __restrict  */)"w");
  }
#line 4063
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
    {
#line 4064
    tmp___1 = __errno_location();
#line 4064
    tmp___2 = strerror(*tmp___1);
#line 4064
    tmp___3 = gettext("could not open `%s\' for writing (%s)");
#line 4064
    d_error((char const   *)tmp___3, arg->value.sval, tmp___2);
    }
#line 4066
    return (0);
  }
  {
#line 4069
  hist_list = history_list();
  }
#line 4070
  if (hist_list) {
#line 4070
    if (history_length > sess_history_base) {
#line 4071
      i___0 = sess_history_base;
      {
#line 4071
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4071
        if (! ((unsigned long )*(hist_list + i___0) != (unsigned long )((void *)0))) {
#line 4071
          goto while_break;
        }
        {
#line 4073
        line = (*(hist_list + i___0))->line;
#line 4080
        tmp___4 = strlen((char const   *)line);
        }
#line 4080
        if (tmp___4 > 1UL) {
          {
#line 4080
          tmp___5 = strncmp((char const   *)line, "sa", (size_t )2);
          }
#line 4080
          if (tmp___5 == 0) {
#line 4082
            goto __Cont;
          }
        }
        {
#line 4084
        fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%s\n",
                line);
        }
        __Cont: /* CIL Label */ 
#line 4071
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 4087
  fclose(fp___0);
  }
#line 4089
  return (0);
}
}
#line 4094 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_option(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  struct dbg_option  const  *opt ;
  char *name ;
  char *value ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 4100
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 4101
    opt = option_list;
    {
#line 4101
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4101
      if (! opt->name) {
#line 4101
        goto while_break;
      }
#line 4102
      if ((unsigned long )opt->str_val != (unsigned long )((void *)0)) {
        {
#line 4103
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s = \"%s\"\n",
                opt->name, *(opt->str_val));
        }
      } else {
        {
#line 4105
        fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s = %d\n",
                opt->name, *(opt->num_val));
        }
      }
#line 4101
      opt ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 4107
    return (0);
  }
#line 4110
  name = arg->value.sval;
#line 4111
  arg = arg->next;
#line 4112
  if (arg) {
#line 4112
    value = arg->value.sval;
  } else {
#line 4112
    value = (char *)((void *)0);
  }
#line 4114
  opt = option_list;
  {
#line 4114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4114
    if (! opt->name) {
#line 4114
      goto while_break___0;
    }
    {
#line 4115
    tmp___1 = strcmp((char const   *)name, (char const   *)opt->name);
    }
#line 4115
    if (tmp___1 == 0) {
#line 4116
      goto while_break___0;
    }
#line 4114
    opt ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4118
  if (! opt->name) {
#line 4119
    return (0);
  }
#line 4121
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 4122
    if ((unsigned long )opt->str_val != (unsigned long )((void *)0)) {
      {
#line 4123
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s = \"%s\"\n",
              opt->name, *(opt->str_val));
      }
    } else {
      {
#line 4125
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s = %d\n",
              opt->name, *(opt->num_val));
      }
    }
  } else {
    {
#line 4127
    (*(opt->assign))((char const   *)value);
    }
  }
#line 4128
  return (0);
}
}
#line 4136 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
void initialize_pager(FILE *fp___0 ) 
{ 
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 4139
  tmp___1 = fileno(fp___0);
#line 4139
  tmp___2 = os_isatty(tmp___1);
  }
#line 4139
  if (tmp___2) {
#line 4139
    if (! input_from_tty) {
#line 4140
      screen_width = 2147483647;
#line 4141
      screen_height = 2147483647;
    } else
#line 4139
    if (input_fd != 0) {
#line 4140
      screen_width = 2147483647;
#line 4141
      screen_height = 2147483647;
    } else {
      {
#line 4145
      rl_reset_terminal((char const   *)((void *)0));
#line 4148
      rl_get_screen_size(& screen_height, & screen_width);
      }
#line 4149
      if (screen_height <= 1) {
#line 4150
        screen_height = 2147483647;
      }
#line 4151
      if (screen_width <= 1) {
#line 4152
        screen_width = 2147483647;
      }
    }
  } else {
#line 4140
    screen_width = 2147483647;
#line 4141
    screen_height = 2147483647;
  }
#line 4154
  pager_lines_printed = 0;
#line 4155
  return;
}
}
#line 4158 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void prompt_continue(FILE *fp___0 ) 
{ 
  _Bool quit_pager ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 4161
  quit_pager = (_Bool)0;
#line 4163
  tmp___4 = fileno(fp___0);
#line 4163
  tmp___5 = os_isatty(tmp___4);
  }
#line 4163
  if (tmp___5) {
#line 4163
    if (input_fd == 0) {
      {
#line 4164
      tmp___1 = gettext("q");
#line 4164
      tmp___2 = gettext("\t------[Enter] to continue or q [Enter] to quit------");
#line 4164
      tmp___3 = prompt_yes_no((char const   *)tmp___2, *(tmp___1 + 0), 0, fp___0);
#line 4164
      quit_pager = (_Bool )tmp___3;
      }
    }
  }
#line 4167
  if (quit_pager) {
    {
#line 4168
    longjmp((struct __jmp_buf_tag *)(pager_quit_tag), 1);
    }
  }
#line 4169
  pager_lines_printed = 0;
#line 4170
  return;
}
}
#line 4178 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char *buf___4  =    (char *)((void *)0);
#line 4179 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static size_t buflen___0  =    (size_t )0;
#line 4180 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int bl  =    0;
#line 4174 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int gprintf(FILE *fp___0 , char const   *format  , ...) 
{ 
  va_list args ;
  char *p ;
  char *q ;
  int nchar ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int sz ;
  int cnt ;
  size_t tmp___16 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 4185
  if ((unsigned long )buf___4 == (unsigned long )((void *)0)) {
    {
#line 4186
    buflen___0 = (size_t )512;
#line 4187
    tmp___1 = malloc((buflen___0 + 2UL) * sizeof(char ));
#line 4187
    buf___4 = (char *)tmp___1;
    }
#line 4187
    if (buf___4) {
#line 4187
      tmp___5 = 1;
    } else {
      {
#line 4187
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4187);
#line 4187
      tmp___2 = __errno_location();
#line 4187
      tmp___3 = strerror(*tmp___2);
#line 4187
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4187
      r_fatal((char const   *)tmp___4, "gprintf", "buf", (long )((buflen___0 + 2UL) * sizeof(char )),
              tmp___3);
#line 4187
      tmp___5 = 0;
      }
    }
  } else
#line 4188
  if (buflen___0 - (size_t )bl < 256UL) {
    {
#line 4189
    buflen___0 += 512UL;
#line 4190
    tmp___6 = realloc((void *)buf___4, (buflen___0 + 2UL) * sizeof(char ));
#line 4190
    buf___4 = (char *)tmp___6;
    }
#line 4190
    if (buf___4) {
#line 4190
      tmp___10 = 1;
    } else {
      {
#line 4190
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4190);
#line 4190
      tmp___7 = __errno_location();
#line 4190
      tmp___8 = strerror(*tmp___7);
#line 4190
      tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4190
      r_fatal((char const   *)tmp___9, "gprintf", "buf", (long )((buflen___0 + 2UL) * sizeof(char )),
              tmp___8);
#line 4190
      tmp___10 = 0;
      }
    }
  }
  {
#line 4194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4195
    __builtin_va_start(args, format);
#line 4196
    nchar = vsnprintf((char */* __restrict  */)(buf___4 + bl), buflen___0 - (size_t )bl,
                      (char const   */* __restrict  */)format, args);
#line 4197
    __builtin_va_end(args);
    }
#line 4198
    if (nchar == 0) {
#line 4199
      return (0);
    }
#line 4200
    if (nchar > 0) {
#line 4200
      if ((size_t )nchar < buflen___0 - (size_t )bl) {
#line 4201
        bl += nchar;
#line 4202
        if ((int )*(buf___4 + (bl - 1)) != 10) {
#line 4203
          return (nchar);
        }
#line 4204
        goto while_break;
      }
    }
    {
#line 4208
    buflen___0 *= 2UL;
#line 4209
    tmp___11 = realloc((void *)buf___4, (buflen___0 + 2UL) * sizeof(char ));
#line 4209
    buf___4 = (char *)tmp___11;
    }
#line 4209
    if (buf___4) {
#line 4209
      tmp___15 = 1;
    } else {
      {
#line 4209
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4209);
#line 4209
      tmp___12 = __errno_location();
#line 4209
      tmp___13 = strerror(*tmp___12);
#line 4209
      tmp___14 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4209
      r_fatal((char const   *)tmp___14, "gprintf", "buf", (long )((buflen___0 + 2UL) * sizeof(char )),
              tmp___13);
#line 4209
      tmp___15 = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4212
  bl = 0;
#line 4213
  p = buf___4;
  {
#line 4213
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 4213
    q = strchr((char const   *)p, '\n');
    }
#line 4213
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 4213
      goto while_break___0;
    }
#line 4214
    sz = (int )(q - p);
    {
#line 4216
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4216
      if (! (sz > 0)) {
#line 4216
        goto while_break___1;
      }
#line 4218
      if (sz > screen_width) {
#line 4218
        cnt = screen_width;
      } else {
#line 4218
        cnt = sz;
      }
#line 4221
      if (cnt < sz) {
#line 4221
        if (pager_lines_printed == screen_height - 2) {
          {
#line 4222
          prompt_continue(fp___0);
          }
        }
      }
      {
#line 4224
      tmp___16 = fwrite((void const   */* __restrict  */)p, sizeof(char ), (size_t )cnt,
                        (FILE */* __restrict  */)fp___0);
      }
#line 4224
      if (tmp___16 != (size_t )cnt) {
#line 4225
        return (-1);
      }
#line 4226
      if (cnt == sz) {
#line 4227
        goto while_break___1;
      } else {
#line 4229
        pager_lines_printed ++;
#line 4229
        if (pager_lines_printed == screen_height - 1) {
          {
#line 4230
          prompt_continue(fp___0);
          }
        }
#line 4231
        sz -= screen_width;
#line 4233
        p += cnt;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 4237
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n");
#line 4238
    pager_lines_printed ++;
    }
#line 4238
    if (pager_lines_printed == screen_height - 1) {
      {
#line 4239
      prompt_continue(fp___0);
      }
    }
#line 4240
    p ++;
#line 4213
    p = q + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4242
  return (nchar);
}
}
#line 4246 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int serialize_subscript(char *buf___7 , int buflen___2 , struct list_item *item ) 
{ 
  int bl___0 ;
  int nchar ;
  int i___0 ;
  NODE *sub ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 4249
  bl___0 = 0;
#line 4252
  nchar = snprintf((char */* __restrict  */)buf___7, (size_t )buflen___2, (char const   */* __restrict  */)"%d%c%d%c%s%c%d%c",
                   item->number, (int )((char )'\037'), 49, (int )((char )'\037'),
                   item->sname, (int )((char )'\037'), item->num_subs, (int )((char )'\037'));
  }
#line 4255
  if (nchar <= 0) {
#line 4256
    return (0);
  } else
#line 4257
  if (nchar >= buflen___2) {
#line 4258
    return (nchar);
  }
#line 4259
  bl___0 += nchar;
#line 4260
  i___0 = 0;
  {
#line 4260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4260
    if (! (i___0 < item->num_subs)) {
#line 4260
      goto while_break;
    }
    {
#line 4261
    sub = *(item->subs + i___0);
#line 4262
    nchar = snprintf((char */* __restrict  */)(buf___7 + bl___0), (size_t )(buflen___2 - bl___0),
                     (char const   */* __restrict  */)"%lu%c%s%c", sub->sub.val.slen,
                     (int )((char )'\037'), sub->sub.val.sp, (int )((char )'\037'));
    }
#line 4264
    if (nchar <= 0) {
#line 4265
      return (0);
    }
#line 4266
    bl___0 += nchar;
#line 4267
    if (bl___0 >= buflen___2) {
#line 4268
      return (bl___0);
    }
#line 4260
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4270
  return (bl___0);
}
}
#line 4287 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char *buf___5  =    (char *)((void *)0);
#line 4288 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int buflen___1  =    0;
#line 4279 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void serialize(int type ) 
{ 
  int bl___0 ;
  BREAKPOINT *b___0 ;
  struct list_item *wd ;
  HIST_ENTRY **hist_list ;
  int hist_index ;
  struct dbg_option *opt ;
  struct commands_item *commands___0 ;
  struct commands_item *c ;
  int cnum ;
  struct condition *cndn ;
  void *ptr ;
  void *end_ptr___0 ;
  HIST_ENTRY *h ;
  int n ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int nchar ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  CMDARG *a ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  CMDARG *a___0 ;
  size_t tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t tmp___36 ;
  void *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;

  {
#line 4290
  b___0 = (BREAKPOINT *)((void *)0);
#line 4291
  wd = (struct list_item *)((void *)0);
#line 4292
  hist_list = (HIST_ENTRY **)((void *)0);
#line 4293
  hist_index = 0;
#line 4294
  opt = (struct dbg_option *)((void *)0);
#line 4295
  commands___0 = (struct commands_item *)((void *)0);
#line 4296
  cnum = 0;
#line 4297
  cndn = (struct condition *)((void *)0);
#line 4300
  h = (HIST_ENTRY *)((void *)0);
  {
#line 4304
  if (type == 1) {
#line 4304
    goto case_1;
  }
#line 4308
  if (type == 2) {
#line 4308
    goto case_2;
  }
#line 4312
  if (type == 3) {
#line 4312
    goto case_3;
  }
#line 4316
  if (type == 4) {
#line 4316
    goto case_4;
  }
#line 4323
  if (type == 5) {
#line 4323
    goto case_5;
  }
#line 4332
  goto switch_default;
  case_1: /* CIL Label */ 
#line 4305
  end_ptr___0 = (void *)(& breakpoints);
#line 4306
  ptr = (void *)breakpoints.prev;
#line 4307
  goto switch_break;
  case_2: /* CIL Label */ 
#line 4309
  end_ptr___0 = (void *)(& watch_list);
#line 4310
  ptr = (void *)watch_list.prev;
#line 4311
  goto switch_break;
  case_3: /* CIL Label */ 
#line 4313
  end_ptr___0 = (void *)(& display_list);
#line 4314
  ptr = (void *)display_list.prev;
#line 4315
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 4317
  hist_list = history_list();
  }
#line 4318
  if ((unsigned long )hist_list == (unsigned long )((void *)0)) {
#line 4319
    return;
  }
#line 4320
  end_ptr___0 = (void *)0;
#line 4321
  ptr = (void *)*(hist_list + 0);
#line 4322
  goto switch_break;
  case_5: /* CIL Label */ 
#line 4326
  n = (int )(sizeof(option_list) / sizeof(option_list[0]));
#line 4327
  end_ptr___0 = (void *)(& option_list[n - 1]);
#line 4328
  ptr = (void *)(option_list);
#line 4330
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4333
  return;
  switch_break: /* CIL Label */ ;
  }
#line 4336
  if (type != 4) {
#line 4336
    if ((unsigned long )ptr == (unsigned long )end_ptr___0) {
#line 4337
      return;
    }
  }
#line 4341
  if ((unsigned long )buf___5 == (unsigned long )((void *)0)) {
    {
#line 4342
    buflen___1 = 512;
#line 4343
    tmp___1 = malloc((size_t )(buflen___1 + 2));
#line 4343
    buf___5 = (char *)tmp___1;
    }
#line 4343
    if (buf___5) {
#line 4343
      tmp___5 = 1;
    } else {
      {
#line 4343
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4343);
#line 4343
      tmp___2 = __errno_location();
#line 4343
      tmp___3 = strerror(*tmp___2);
#line 4343
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4343
      r_fatal((char const   *)tmp___4, "serialize", "buf", (long )(buflen___1 + 2),
              tmp___3);
#line 4343
      tmp___5 = 0;
      }
    }
  }
#line 4345
  bl___0 = 0;
  {
#line 4347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4347
    if (! ((unsigned long )ptr != (unsigned long )end_ptr___0)) {
#line 4347
      goto while_break;
    }
#line 4348
    nchar = 0;
#line 4349
    if (buflen___1 - bl___0 < 256) {
      enlarge_buffer: 
      {
#line 4351
      buflen___1 *= 2;
#line 4352
      tmp___6 = realloc((void *)buf___5, (size_t )(buflen___1 + 2));
#line 4352
      buf___5 = (char *)tmp___6;
      }
#line 4352
      if (buf___5) {
#line 4352
        tmp___10 = 1;
      } else {
        {
#line 4352
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4352);
#line 4352
        tmp___7 = __errno_location();
#line 4352
        tmp___8 = strerror(*tmp___7);
#line 4352
        tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4352
        r_fatal((char const   *)tmp___9, "serialize", "buf", (long )(buflen___1 + 2),
                tmp___8);
#line 4352
        tmp___10 = 0;
        }
      }
    }
    {
#line 4360
    if (type == 1) {
#line 4360
      goto case_1___0;
    }
#line 4377
    if (type == 2) {
#line 4377
      goto case_2___0;
    }
#line 4377
    if (type == 3) {
#line 4377
      goto case_2___0;
    }
#line 4399
    if (type == 4) {
#line 4399
      goto case_4___0;
    }
#line 4408
    if (type == 5) {
#line 4408
      goto case_5___0;
    }
#line 4417
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 4361
    b___0 = (BREAKPOINT *)ptr;
#line 4367
    nchar = snprintf((char */* __restrict  */)(buf___5 + bl___0), (size_t )(buflen___1 - bl___0),
                     (char const   */* __restrict  */)"%s%c%d%c%d%c%d%c%d%c%d%c",
                     b___0->src, (int )((char )'\037'), (int )(b___0->bpi)->source_line,
                     (int )((char )'\037'), (int )b___0->flags, (int )((char )'\037'),
                     (int )b___0->ignore_count, (int )((char )'\037'), (int )b___0->hit_count,
                     (int )((char )'\037'), b___0->number, (int )((char )'\037'));
#line 4372
    cnum = b___0->number;
#line 4373
    commands___0 = & b___0->commands;
#line 4374
    cndn = & b___0->cndn;
    }
#line 4375
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 4378
    wd = (struct list_item *)ptr;
#line 4385
    if ((wd->flags & 1) != 0) {
#line 4386
      nchar = 0;
    } else
#line 4387
    if ((wd->flags & 2) != 0) {
      {
#line 4388
      nchar = serialize_subscript(buf___5 + bl___0, buflen___1 - bl___0, wd);
      }
    } else
#line 4389
    if ((wd->flags & 4) != 0) {
#line 4390
      if ((wd->symbol)->flags & 2048U) {
        {
#line 4390
        tmp___11 = mpfr_get_si((mpfr_srcptr )((wd->symbol)->sub.val.nm.mpnum), ROUND_MODE);
#line 4390
        tmp___14 = tmp___11;
        }
      } else {
#line 4390
        if ((wd->symbol)->flags & 4096U) {
          {
#line 4390
          tmp___12 = __gmpz_get_si((mpz_srcptr )((wd->symbol)->sub.val.nm.mpi));
#line 4390
          tmp___13 = tmp___12;
          }
        } else {
#line 4390
          tmp___13 = (long )(wd->symbol)->sub.val.nm.fltnum;
        }
#line 4390
        tmp___14 = tmp___13;
      }
      {
#line 4390
      nchar = snprintf((char */* __restrict  */)(buf___5 + bl___0), (size_t )(buflen___1 - bl___0),
                       (char const   */* __restrict  */)"%d%c%d%c%d%c", wd->number,
                       (int )((char )'\037'), 47, (int )((char )'\037'), (int )tmp___14,
                       (int )((char )'\037'));
      }
    } else {
      {
#line 4393
      nchar = snprintf((char */* __restrict  */)(buf___5 + bl___0), (size_t )(buflen___1 - bl___0),
                       (char const   */* __restrict  */)"%d%c%d%c%s%c", wd->number,
                       (int )((char )'\037'), 45, (int )((char )'\037'), wd->sname,
                       (int )((char )'\037'));
      }
    }
#line 4395
    cnum = wd->number;
#line 4396
    commands___0 = & wd->commands;
#line 4397
    cndn = & wd->cndn;
#line 4398
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 4401
    h = (HIST_ENTRY *)ptr;
#line 4402
    tmp___15 = strlen((char const   *)h->line);
#line 4402
    nchar = (int )tmp___15;
    }
#line 4403
    if (nchar >= buflen___1 - bl___0) {
#line 4404
      goto enlarge_buffer;
    }
    {
#line 4405
    strcpy((char */* __restrict  */)(buf___5 + bl___0), (char const   */* __restrict  */)h->line);
    }
#line 4407
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 4409
    opt = (struct dbg_option *)ptr;
#line 4410
    if ((unsigned long )opt->num_val != (unsigned long )((void *)0)) {
      {
#line 4411
      nchar = snprintf((char */* __restrict  */)(buf___5 + bl___0), (size_t )(buflen___1 - bl___0),
                       (char const   */* __restrict  */)"%s%c%d%c", opt->name, (int )((char )'\037'),
                       *(opt->num_val), (int )((char )'\037'));
      }
    } else {
      {
#line 4414
      nchar = snprintf((char */* __restrict  */)(buf___5 + bl___0), (size_t )(buflen___1 - bl___0),
                       (char const   */* __restrict  */)"%s%c%s%c", opt->name, (int )((char )'\037'),
                       *(opt->str_val), (int )((char )'\037'));
      }
    }
#line 4416
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 4418
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 4421
    if (! (nchar == 0)) {
#line 4423
      if (nchar > 0) {
#line 4423
        if (nchar < buflen___1 - bl___0) {
#line 4424
          bl___0 += nchar;
#line 4425
          *(buf___5 + bl___0) = (char )'\036';
#line 4426
          bl___0 ++;
#line 4426
          *(buf___5 + bl___0) = (char )'\000';
        } else {
#line 4428
          goto enlarge_buffer;
        }
      } else {
#line 4428
        goto enlarge_buffer;
      }
    }
    {
#line 4432
    if (type == 2) {
#line 4432
      goto case_2___1;
    }
#line 4432
    if (type == 1) {
#line 4432
      goto case_2___1;
    }
#line 4504
    if (type == 3) {
#line 4504
      goto case_3___1;
    }
#line 4507
    if (type == 4) {
#line 4507
      goto case_4___1;
    }
#line 4510
    if (type == 5) {
#line 4510
      goto case_5___1;
    }
#line 4513
    goto switch_default___1;
    case_2___1: /* CIL Label */ 
    case_1___1: /* CIL Label */ 
#line 4439
    bl___0 --;
#line 4442
    nchar = 0;
#line 4443
    c = commands___0->next;
    {
#line 4443
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4443
      if (! ((unsigned long )c != (unsigned long )commands___0)) {
#line 4443
        goto while_break___0;
      }
      {
#line 4444
      tmp___16 = strlen((char const   *)c->cmd_string);
#line 4444
      nchar = (int )((size_t )nchar + (tmp___16 + 1UL));
      }
#line 4445
      if (c->cmd == 14) {
        {
#line 4446
        a = c->arg;
#line 4447
        tmp___17 = strlen((char const   *)a->value.sval);
#line 4447
        nchar = (int )((size_t )nchar + (tmp___17 + 1UL));
#line 4448
        tmp___18 = strlen("end");
#line 4448
        nchar = (int )((size_t )nchar + (tmp___18 + 1UL));
        }
      }
#line 4443
      c = c->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4452
    if (nchar > 0) {
      {
#line 4453
      tmp___19 = strlen("commands ");
#line 4453
      tmp___20 = strlen("end");
#line 4453
      nchar = (int )((size_t )nchar + (((tmp___19 + 20UL) + tmp___20) + 2UL));
      }
#line 4454
      if (nchar > buflen___1 - bl___0) {
        {
#line 4455
        buflen___1 = bl___0 + nchar;
#line 4456
        tmp___21 = realloc((void *)buf___5, (size_t )(buflen___1 + 3));
#line 4456
        buf___5 = (char *)tmp___21;
        }
#line 4456
        if (buf___5) {
#line 4456
          tmp___25 = 1;
        } else {
          {
#line 4456
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4456);
#line 4456
          tmp___22 = __errno_location();
#line 4456
          tmp___23 = strerror(*tmp___22);
#line 4456
          tmp___24 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4456
          r_fatal((char const   *)tmp___24, "serialize", "buf", (long )(buflen___1 + 3),
                  tmp___23);
#line 4456
          tmp___25 = 0;
          }
        }
      }
      {
#line 4458
      nchar = sprintf((char */* __restrict  */)(buf___5 + bl___0), (char const   */* __restrict  */)"commands %d",
                      cnum);
#line 4459
      bl___0 += nchar;
#line 4460
      tmp___26 = bl___0;
#line 4460
      bl___0 ++;
#line 4460
      *(buf___5 + tmp___26) = (char )'\035';
#line 4461
      c = commands___0->next;
      }
      {
#line 4461
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4461
        if (! ((unsigned long )c != (unsigned long )commands___0)) {
#line 4461
          goto while_break___1;
        }
        {
#line 4462
        tmp___27 = strlen((char const   *)c->cmd_string);
#line 4462
        nchar = (int )tmp___27;
#line 4463
        memcpy((void */* __restrict  */)(buf___5 + bl___0), (void const   */* __restrict  */)c->cmd_string,
               (size_t )nchar);
#line 4464
        bl___0 += nchar;
#line 4465
        tmp___28 = bl___0;
#line 4465
        bl___0 ++;
#line 4465
        *(buf___5 + tmp___28) = (char )'\035';
        }
#line 4467
        if (c->cmd == 14) {
          {
#line 4468
          a___0 = c->arg;
#line 4469
          tmp___29 = strlen((char const   *)a___0->value.sval);
#line 4469
          nchar = (int )tmp___29;
#line 4470
          memcpy((void */* __restrict  */)(buf___5 + bl___0), (void const   */* __restrict  */)a___0->value.sval,
                 (size_t )nchar);
#line 4471
          bl___0 += nchar;
#line 4472
          tmp___30 = bl___0;
#line 4472
          bl___0 ++;
#line 4472
          *(buf___5 + tmp___30) = (char )'\035';
#line 4473
          tmp___31 = strlen("end");
#line 4473
          nchar = (int )tmp___31;
#line 4474
          memcpy((void */* __restrict  */)(buf___5 + bl___0), (void const   */* __restrict  */)"end",
                 (size_t )nchar);
#line 4475
          bl___0 += nchar;
#line 4476
          tmp___32 = bl___0;
#line 4476
          bl___0 ++;
#line 4476
          *(buf___5 + tmp___32) = (char )'\035';
          }
        }
#line 4461
        c = c->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 4479
      tmp___33 = strlen("end");
#line 4479
      nchar = (int )tmp___33;
#line 4480
      memcpy((void */* __restrict  */)(buf___5 + bl___0), (void const   */* __restrict  */)"end",
             (size_t )nchar);
#line 4481
      bl___0 += nchar;
      }
    }
#line 4483
    tmp___34 = bl___0;
#line 4483
    bl___0 ++;
#line 4483
    *(buf___5 + tmp___34) = (char )'\037';
#line 4484
    tmp___35 = bl___0;
#line 4484
    bl___0 ++;
#line 4484
    *(buf___5 + tmp___35) = (char )'\036';
#line 4485
    *(buf___5 + bl___0) = (char )'\000';
#line 4488
    if (cndn->expr) {
      {
#line 4489
      bl___0 --;
#line 4490
      tmp___36 = strlen((char const   *)cndn->expr);
#line 4490
      nchar = (int )tmp___36;
      }
#line 4491
      if (nchar > buflen___1 - bl___0) {
        {
#line 4492
        buflen___1 = bl___0 + nchar;
#line 4493
        tmp___37 = realloc((void *)buf___5, (size_t )(buflen___1 + 3));
#line 4493
        buf___5 = (char *)tmp___37;
        }
#line 4493
        if (buf___5) {
#line 4493
          tmp___41 = 1;
        } else {
          {
#line 4493
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4493);
#line 4493
          tmp___38 = __errno_location();
#line 4493
          tmp___39 = strerror(*tmp___38);
#line 4493
          tmp___40 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4493
          r_fatal((char const   *)tmp___40, "serialize", "buf", (long )(buflen___1 + 3),
                  tmp___39);
#line 4493
          tmp___41 = 0;
          }
        }
      }
      {
#line 4495
      memcpy((void */* __restrict  */)(buf___5 + bl___0), (void const   */* __restrict  */)cndn->expr,
             (size_t )nchar);
#line 4496
      bl___0 += nchar;
#line 4497
      tmp___42 = bl___0;
#line 4497
      bl___0 ++;
#line 4497
      *(buf___5 + tmp___42) = (char )'\037';
#line 4498
      tmp___43 = bl___0;
#line 4498
      bl___0 ++;
#line 4498
      *(buf___5 + tmp___43) = (char )'\036';
#line 4499
      *(buf___5 + bl___0) = (char )'\000';
      }
    }
#line 4502
    if (type == 1) {
#line 4502
      ptr = (void *)b___0->prev;
    } else {
#line 4502
      ptr = (void *)wd->prev;
    }
#line 4503
    goto switch_break___1;
    case_3___1: /* CIL Label */ 
#line 4505
    ptr = (void *)wd->prev;
#line 4506
    goto switch_break___1;
    case_4___1: /* CIL Label */ 
#line 4508
    hist_index ++;
#line 4508
    ptr = (void *)*(hist_list + hist_index);
#line 4509
    goto switch_break___1;
    case_5___1: /* CIL Label */ 
#line 4511
    opt ++;
#line 4511
    ptr = (void *)opt;
#line 4512
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 4514
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4518
  if (bl___0 > 0) {
    {
#line 4519
    setenv((char const   *)env_variable[type], (char const   *)buf___5, 1);
    }
  }
#line 4520
  return;
}
}
#line 4523 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void unserialize_commands(char *str , int str_len ) 
{ 


  {
#line 4526
  if (str_len <= 0) {
#line 4527
    return;
  } else
#line 4526
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 4527
    return;
  }
  {
#line 4528
  commands_string = (char const   *)str;
#line 4529
  commands_string_len = str_len;
#line 4530
  push_cmd_src(-1, (_Bool)0, & read_commands_string, (int (*)(int  ))0, 0, 2);
#line 4531
  line_sep = (char )'\035';
#line 4532
  zzparse();
#line 4533
  pop_cmd_src();
  }
#line 4534
  return;
}
}
#line 4539 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct list_item *unserialize_list_item(struct list_item *list , char **pstr___0 ,
                                               int *pstr_len___0 , int field_cnt ) 
{ 
  int num ;
  int type ;
  int i___0 ;
  struct list_item *l ;
  NODE *symbol ;
  int sub_cnt ;
  int cnt ;
  NODE **subs ;
  long tmp___1 ;
  long tmp___2 ;
  int field_num ;
  long tmp___3 ;
  char *name ;
  int sub_len ;
  long tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  char *expr ;
  int tmp___11 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 4544
  symbol = (NODE *)((void *)0);
#line 4545
  sub_cnt = 0;
#line 4546
  subs = (NODE **)((void *)0);
#line 4553
  tmp___1 = strtol((char const   */* __restrict  */)*(pstr___0 + 0), (char **/* __restrict  */)((void *)0),
                   0);
#line 4553
  num = (int )tmp___1;
#line 4554
  tmp___2 = strtol((char const   */* __restrict  */)*(pstr___0 + 1), (char **/* __restrict  */)((void *)0),
                   0);
#line 4554
  type = (int )tmp___2;
  }
#line 4556
  if (type == 47) {
    {
#line 4558
    tmp___3 = strtol((char const   */* __restrict  */)*(pstr___0 + 2), (char **/* __restrict  */)((void *)0),
                     0);
#line 4558
    field_num = (int )tmp___3;
#line 4559
    symbol = (*make_number)((double )field_num);
#line 4560
    cnt = 3;
    }
  } else {
    {
#line 4563
    name = estrdup((char const   *)*(pstr___0 + 2), (size_t )*(pstr_len___0 + 2));
#line 4564
    symbol = find_symbol((char const   *)name, (char **)((void *)0));
#line 4565
    free((void *)name);
    }
#line 4566
    if ((unsigned long )symbol == (unsigned long )((void *)0)) {
#line 4567
      return ((struct list_item *)((void *)0));
    }
#line 4568
    cnt = 3;
#line 4569
    if (type == 49) {
      {
#line 4571
      tmp___4 = strtol((char const   */* __restrict  */)*(pstr___0 + 3), (char **/* __restrict  */)((void *)0),
                       0);
#line 4571
      sub_cnt = (int )tmp___4;
#line 4572
      tmp___5 = malloc((unsigned long )sub_cnt * sizeof(NODE *));
#line 4572
      subs = (NODE **)tmp___5;
      }
#line 4572
      if (subs) {
#line 4572
        tmp___9 = 1;
      } else {
        {
#line 4572
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4572);
#line 4572
        tmp___6 = __errno_location();
#line 4572
        tmp___7 = strerror(*tmp___6);
#line 4572
        tmp___8 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4572
        r_fatal((char const   *)tmp___8, "unserialize_list_item", "subs", (long )((unsigned long )sub_cnt * sizeof(NODE *)),
                tmp___7);
#line 4572
        tmp___9 = 0;
        }
      }
#line 4573
      cnt ++;
#line 4574
      i___0 = 0;
      {
#line 4574
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4574
        if (! (i___0 < sub_cnt)) {
#line 4574
          goto while_break;
        }
        {
#line 4575
        tmp___10 = strtol((char const   */* __restrict  */)*(pstr___0 + cnt), (char **/* __restrict  */)((void *)0),
                          0);
#line 4575
        sub_len = (int )tmp___10;
#line 4576
        *(subs + i___0) = make_str_node((char const   *)*(pstr___0 + (cnt + 1)), (size_t )sub_len,
                                        0);
#line 4577
        cnt += 2;
#line 4574
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 4582
  l = add_item(list, type, symbol, (char *)((void *)0));
  }
#line 4583
  if (type == 49) {
#line 4584
    l->num_subs = sub_cnt;
#line 4585
    l->subs = subs;
  }
#line 4587
  l->number = num;
#line 4589
  if ((unsigned long )list == (unsigned long )(& watch_list)) {
    {
#line 4590
    initialize_watch_item(l);
#line 4592
    unserialize_commands(*(pstr___0 + cnt), *(pstr_len___0 + cnt));
#line 4593
    cnt ++;
    }
#line 4594
    if (field_cnt > cnt) {
      {
#line 4596
      expr = estrdup((char const   *)*(pstr___0 + cnt), (size_t )*(pstr_len___0 + cnt));
#line 4597
      tmp___11 = parse_condition(41, l->number, expr);
      }
#line 4597
      if (tmp___11 != 0) {
        {
#line 4598
        free((void *)expr);
        }
      }
    }
#line 4600
    if (num > list->number) {
#line 4601
      list->number = num;
    }
  } else {
#line 4603
    list->number = num;
  }
#line 4605
  return (l);
}
}
#line 4610 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static BREAKPOINT *unserialize_breakpoint(char **pstr___0 , int *pstr_len___0 , int field_cnt ) 
{ 
  char *src ;
  int lineno ;
  BREAKPOINT *b___0 ;
  INSTRUCTION *rp ;
  SRCFILE *s___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char *expr ;
  int tmp___4 ;

  {
  {
#line 4615
  b___0 = (BREAKPOINT *)((void *)0);
#line 4621
  src = estrdup((char const   *)*(pstr___0 + 0), (size_t )*(pstr_len___0 + 0));
#line 4622
  s___0 = source_find(src);
#line 4623
  free((void *)src);
  }
#line 4624
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 4625
    return ((BREAKPOINT *)((void *)0));
  }
  {
#line 4626
  src = s___0->src;
#line 4627
  tmp___1 = strtol((char const   */* __restrict  */)*(pstr___0 + 1), (char **/* __restrict  */)((void *)0),
                   0);
#line 4627
  lineno = (int )tmp___1;
  }
#line 4628
  if (lineno <= 0) {
#line 4629
    return ((BREAKPOINT *)((void *)0));
  } else
#line 4628
  if (lineno > s___0->srclines) {
#line 4629
    return ((BREAKPOINT *)((void *)0));
  }
  {
#line 4630
  rp = find_rule(src, (long )lineno);
  }
#line 4631
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 4634
    return ((BREAKPOINT *)((void *)0));
  } else {
    {
#line 4631
    b___0 = set_breakpoint_at(rp, lineno, (_Bool)1);
    }
#line 4631
    if ((unsigned long )b___0 == (unsigned long )((void *)0)) {
#line 4634
      return ((BREAKPOINT *)((void *)0));
    }
  }
  {
#line 4636
  tmp___2 = strtol((char const   */* __restrict  */)*(pstr___0 + 2), (char **/* __restrict  */)((void *)0),
                   0);
#line 4636
  b___0->flags = (short )tmp___2;
#line 4637
  b___0->ignore_count = strtol((char const   */* __restrict  */)*(pstr___0 + 3), (char **/* __restrict  */)((void *)0),
                               0);
#line 4638
  b___0->hit_count = strtol((char const   */* __restrict  */)*(pstr___0 + 4), (char **/* __restrict  */)((void *)0),
                            0);
#line 4639
  tmp___3 = strtol((char const   */* __restrict  */)*(pstr___0 + 5), (char **/* __restrict  */)((void *)0),
                   0);
#line 4639
  b___0->number = (int )tmp___3;
  }
#line 4641
  if (field_cnt > 6) {
    {
#line 4642
    unserialize_commands(*(pstr___0 + 6), *(pstr_len___0 + 6));
    }
  }
#line 4644
  if (field_cnt > 7) {
    {
#line 4646
    expr = estrdup((char const   *)*(pstr___0 + 7), (size_t )*(pstr_len___0 + 7));
#line 4647
    tmp___4 = parse_condition(2, b___0->number, expr);
    }
#line 4647
    if (tmp___4 != 0) {
      {
#line 4648
      free((void *)expr);
      }
    }
  }
#line 4651
  if (b___0->number > watch_list.number) {
#line 4652
    watch_list.number = b___0->number;
  }
#line 4653
  return (b___0);
}
}
#line 4658 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct dbg_option *unserialize_option(char **pstr___0 , int *pstr_len___0 ,
                                             int field_cnt  __attribute__((__unused__)) ) 
{ 
  struct dbg_option  const  *opt ;
  char *value ;
  int tmp___1 ;

  {
#line 4663
  opt = option_list;
  {
#line 4663
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4663
    if (! opt->name) {
#line 4663
      goto while_break;
    }
    {
#line 4664
    tmp___1 = strncmp((char const   *)*(pstr___0 + 0), (char const   *)opt->name,
                      (size_t )*(pstr_len___0 + 0));
    }
#line 4664
    if (tmp___1 == 0) {
      {
#line 4667
      value = estrdup((char const   *)*(pstr___0 + 1), (size_t )*(pstr_len___0 + 1));
#line 4668
      (*(opt->assign))((char const   *)value);
#line 4669
      free((void *)value);
      }
#line 4670
      return ((struct dbg_option *)opt);
    }
#line 4663
    opt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4673
  return ((struct dbg_option *)((void *)0));
}
}
#line 4686 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static char *pstr[30]  ;
#line 4687 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int pstr_len[30]  ;
#line 4680 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void unserialize(int type ) 
{ 
  char *val ;
  char *p ;
  char *q ;
  char *r ;
  char *s___0 ;
  int field_cnt ;

  {
  {
#line 4689
  val = getenv((char const   *)env_variable[type]);
  }
#line 4690
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 4691
    return;
  }
#line 4693
  p = val;
  {
#line 4693
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4693
    q = strchr((char const   *)p, (int )((char )'\036'));
    }
#line 4693
    if (! ((unsigned long )q != (unsigned long )((void *)0))) {
#line 4693
      goto while_break;
    }
#line 4694
    field_cnt = 0;
#line 4695
    if (type == 4) {
      {
#line 4696
      *q = (char )'\000';
#line 4697
      add_history((char const   *)p);
#line 4698
      *q = (char )'\036';
      }
#line 4699
      goto __Cont;
    }
#line 4702
    r = p;
    {
#line 4703
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4703
      s___0 = strchr((char const   *)r, (int )((char )'\037'));
      }
#line 4703
      if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 4703
        if (! ((unsigned long )s___0 < (unsigned long )q)) {
#line 4703
          goto while_break___0;
        }
      } else {
#line 4703
        goto while_break___0;
      }
#line 4704
      pstr[field_cnt] = r;
#line 4705
      pstr_len[field_cnt] = (int )(s___0 - r);
#line 4706
      r = s___0 + 1;
#line 4707
      field_cnt ++;
#line 4708
      if (field_cnt == 30) {
#line 4712
        return;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4717
    if (type == 1) {
#line 4717
      goto case_1;
    }
#line 4720
    if (type == 3) {
#line 4720
      goto case_3;
    }
#line 4723
    if (type == 2) {
#line 4723
      goto case_2;
    }
#line 4726
    if (type == 5) {
#line 4726
      goto case_5;
    }
#line 4729
    if (type == 4) {
#line 4729
      goto case_4;
    }
#line 4732
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 4718
    unserialize_breakpoint(pstr, pstr_len, field_cnt);
    }
#line 4719
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 4721
    unserialize_list_item(& display_list, pstr, pstr_len, field_cnt);
    }
#line 4722
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 4724
    unserialize_list_item(& watch_list, pstr, pstr_len, field_cnt);
    }
#line 4725
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 4727
    unserialize_option(pstr, pstr_len, field_cnt);
    }
#line 4728
    goto switch_break;
    case_4: /* CIL Label */ 
#line 4731
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 4733
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 4693
    p = q + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 4738
  if (type == 4) {
#line 4739
    sess_history_base = history_length;
  }
  {
#line 4742
  unsetenv((char const   *)env_variable[type]);
  }
#line 4744
  return;
}
}
#line 4746 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int prompt_yes_no(char const   *mesg , char res_true , int res_default , FILE *fp___0 ) 
{ 
  char *in_str ;
  int ret ;
  char *tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 4750
  ret = res_default;
#line 4752
  if (input_from_tty) {
    {
#line 4753
    tmp___1 = gettext(mesg);
#line 4753
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%s",
            tmp___1);
#line 4754
    in_str = (*read_a_line)((char const   *)((void *)0));
    }
#line 4755
    if ((unsigned long )in_str == (unsigned long )((void *)0)) {
      {
#line 4756
      exit(1);
      }
    }
    {
#line 4757
    ret = (int )*in_str == (int )res_true;
#line 4758
    free((void *)in_str);
    }
  }
#line 4760
  return (ret);
}
}
#line 4770 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int has_break_or_watch_point(int *pnum , _Bool any ) 
{ 
  BREAKPOINT *b___0 ;
  struct list_item *w___0 ;

  {
#line 4773
  b___0 = (BREAKPOINT *)((void *)0);
#line 4774
  w___0 = (struct list_item *)((void *)0);
#line 4776
  if (any) {
#line 4777
    if ((unsigned long )breakpoints.next != (unsigned long )(& breakpoints)) {
#line 4778
      b___0 = breakpoints.next;
    }
#line 4779
    if ((unsigned long )watch_list.next != (unsigned long )(& watch_list)) {
#line 4780
      w___0 = watch_list.next;
    }
#line 4782
    if (! b___0) {
#line 4782
      if (! w___0) {
#line 4783
        return (0);
      }
    }
#line 4784
    if (b___0) {
#line 4784
      if (! w___0) {
#line 4785
        *pnum = b___0->number;
#line 4786
        return (2);
      }
    }
#line 4788
    if (w___0) {
#line 4788
      if (! b___0) {
#line 4789
        *pnum = w___0->number;
#line 4790
        return (41);
      }
    }
#line 4792
    if (w___0->number > b___0->number) {
#line 4793
      *pnum = w___0->number;
#line 4794
      return (41);
    }
#line 4796
    *pnum = b___0->number;
#line 4797
    return (2);
  }
#line 4804
  b___0 = breakpoints.next;
  {
#line 4804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4804
    if (! ((unsigned long )b___0 != (unsigned long )(& breakpoints))) {
#line 4804
      goto while_break;
    }
#line 4805
    if (b___0->number == *pnum) {
#line 4806
      return (2);
    }
#line 4804
    b___0 = b___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4808
  w___0 = watch_list.next;
  {
#line 4808
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4808
    if (! ((unsigned long )w___0 != (unsigned long )(& watch_list))) {
#line 4808
      goto while_break___0;
    }
#line 4809
    if (w___0->number == *pnum) {
#line 4810
      return (41);
    }
#line 4808
    w___0 = w___0->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4813
  return (0);
}
}
#line 4818 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void delete_commands_item(struct commands_item *c ) 
{ 


  {
  {
#line 4821
  free((void *)c->cmd_string);
#line 4822
  free_cmdarg(c->arg);
#line 4823
  (c->next)->prev = c->prev;
#line 4824
  (c->prev)->next = c->next;
#line 4825
  free((void *)c);
  }
#line 4826
  return;
}
}
#line 4833 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static BREAKPOINT *b  ;
#line 4834 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct list_item *w  ;
#line 4835 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static struct commands_item *commands  ;
#line 4830 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_commands(CMDARG *arg , int cmd ) 
{ 
  struct commands_item *c ;
  int num ;
  int type ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 4838
  if (cmd == 4) {
#line 4840
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
#line 4841
      type = has_break_or_watch_point(& num, (_Bool)1);
      }
    } else {
      {
#line 4843
      num = (int )arg->value.lval;
#line 4844
      type = has_break_or_watch_point(& num, (_Bool)0);
      }
    }
#line 4846
    b = (BREAKPOINT *)((void *)0);
#line 4847
    w = (struct list_item *)((void *)0);
#line 4848
    if (type == 2) {
      {
#line 4849
      b = find_breakpoint((long )num);
      }
    } else
#line 4850
    if (type == 41) {
      {
#line 4851
      w = find_item(& watch_list, (long )num);
      }
    }
#line 4853
    if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 4853
      commands = & b->commands;
    } else {
#line 4853
      commands = & w->commands;
    }
#line 4856
    c = commands->next;
    {
#line 4856
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4856
      if (! ((unsigned long )c != (unsigned long )commands)) {
#line 4856
        goto while_break;
      }
      {
#line 4857
      c = c->prev;
#line 4858
      delete_commands_item(c->next);
#line 4856
      c = c->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4860
    return (0);
  } else
#line 4862
  if (cmd == 13) {
#line 4863
    commands = (struct commands_item *)((void *)0);
#line 4864
    if ((unsigned long )read_a_line == (unsigned long )(& read_commands_string)) {
#line 4865
      return (1);
    }
#line 4866
    return (0);
  } else
#line 4868
  if (cmd == 31) {
#line 4869
    if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 4870
      b->silent = (_Bool)1;
    } else
#line 4871
    if ((unsigned long )w != (unsigned long )((void *)0)) {
#line 4872
      w->silent = 1;
    }
  }
  {
#line 4881
  tmp___1 = malloc(sizeof(struct commands_item ));
#line 4881
  c = (struct commands_item *)tmp___1;
  }
#line 4881
  if (c) {
#line 4881
    tmp___5 = 1;
  } else {
    {
#line 4881
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4881);
#line 4881
    tmp___2 = __errno_location();
#line 4881
    tmp___3 = strerror(*tmp___2);
#line 4881
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4881
    r_fatal((char const   *)tmp___4, "do_commands", "c", (long )sizeof(struct commands_item ),
            tmp___3);
#line 4881
    tmp___5 = 0;
    }
  }
  {
#line 4882
  c->next = (struct commands_item *)((void *)0);
#line 4883
  c->cmd = cmd;
#line 4886
  c->cmd_string = arg->value.sval;
#line 4887
  c->arg = arg->next;
#line 4888
  free((void *)arg);
#line 4891
  c->prev = commands->prev;
#line 4892
  c->next = commands;
#line 4893
  commands->prev = c;
#line 4894
  (c->prev)->next = c;
  }
#line 4895
  return (0);
}
}
#line 4903 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int execute_commands(struct commands_item *commands___0 ) 
{ 
  struct commands_item *c ;
  int (*cmd_ptr)(CMDARG * , int  ) ;
  _Bool ret ;
  int tmp___1 ;

  {
#line 4908
  ret = (_Bool)0;
#line 4910
  c = commands___0->next;
  {
#line 4910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4910
    if (! ((unsigned long )c != (unsigned long )commands___0)) {
#line 4910
      goto while_break;
    }
#line 4911
    if (c->cmd == 31) {
#line 4912
      goto __Cont;
    }
    {
#line 4913
    cmd_ptr = get_command(c->cmd);
#line 4914
    tmp___1 = (*cmd_ptr)(c->arg, c->cmd);
#line 4914
    ret = (_Bool )tmp___1;
    }
#line 4915
    if (ret) {
#line 4916
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 4910
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4918
  return ((int )ret);
}
}
#line 4923 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_print_f(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  int count ;
  int i___0 ;
  CMDARG *a ;
  NODE **tmp___1 ;
  char *name ;
  NODE *r ;
  jmp_buf volatile   fatal_tag_stack ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  long field_num ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  NODE **tmp___11 ;
  int cnt ;
  NODE *value ;
  NODE *subs ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 4926
  count = 0;
#line 4935
  a = arg;
  {
#line 4935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4935
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 4935
      goto while_break;
    }
#line 4936
    count ++;
#line 4935
    a = a->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4937
  tmp___2 = malloc((unsigned long )count * sizeof(NODE *));
#line 4937
  tmp___1 = (NODE **)tmp___2;
  }
#line 4937
  if (tmp___1) {
#line 4937
    tmp___6 = 1;
  } else {
    {
#line 4937
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 4937);
#line 4937
    tmp___3 = __errno_location();
#line 4937
    tmp___4 = strerror(*tmp___3);
#line 4937
    tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4937
    r_fatal((char const   *)tmp___5, "do_print_f", "tmp", (long )((unsigned long )count * sizeof(NODE *)),
            tmp___4);
#line 4937
    tmp___6 = 0;
    }
  }
#line 4939
  i___0 = 0;
#line 4939
  a = arg;
  {
#line 4939
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4939
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 4939
      goto while_break___0;
    }
    {
#line 4941
    if ((unsigned int )a->type == 45U) {
#line 4941
      goto case_45;
    }
#line 4954
    if ((unsigned int )a->type == 47U) {
#line 4954
      goto case_47;
    }
#line 4962
    if ((unsigned int )a->type == 49U) {
#line 4962
      goto case_49;
    }
#line 5001
    if ((unsigned int )a->type == 46U) {
#line 5001
      goto case_46;
    }
#line 5004
    goto switch_default;
    case_45: /* CIL Label */ 
    {
#line 4942
    name = a->value.sval;
#line 4943
    r = find_symbol((char const   *)name, (char **)((void *)0));
    }
#line 4944
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 4945
      goto done;
    }
#line 4946
    if ((unsigned int )r->type == 6U) {
#line 4947
      *(tmp___1 + i___0) = Nnull_string;
    } else
#line 4948
    if ((unsigned int )r->type != 4U) {
      {
#line 4949
      tmp___7 = gettext("`%s\' is not a scalar variable");
#line 4949
      d_error((char const   *)tmp___7, name);
      }
#line 4950
      goto done;
    } else {
#line 4952
      *(tmp___1 + i___0) = r->sub.nodep.l.lptr;
    }
#line 4953
    goto switch_break;
    case_47: /* CIL Label */ 
#line 4957
    r = a->value.nodeval;
#line 4958
    if (r->flags & 2048U) {
      {
#line 4958
      tmp___8 = mpfr_get_si((mpfr_srcptr )(r->sub.val.nm.mpnum), ROUND_MODE);
#line 4958
      field_num = tmp___8;
      }
    } else {
#line 4958
      if (r->flags & 4096U) {
        {
#line 4958
        tmp___9 = __gmpz_get_si((mpz_srcptr )(r->sub.val.nm.mpi));
#line 4958
        tmp___10 = tmp___9;
        }
      } else {
#line 4958
        tmp___10 = (long )r->sub.val.nm.fltnum;
      }
#line 4958
      field_num = tmp___10;
    }
    {
#line 4959
    tmp___11 = get_field(field_num, (Func_ptr *)((void *)0));
#line 4959
    *(tmp___1 + i___0) = *tmp___11;
    }
#line 4961
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 4964
    cnt = a->a_count;
#line 4965
    name = a->value.sval;
#line 4966
    r = find_array((char const   *)name);
    }
#line 4967
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 4968
      goto done;
    }
    {
#line 4970
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4970
      if (! (cnt > 0)) {
#line 4970
        goto while_break___1;
      }
      {
#line 4972
      a = a->next;
#line 4973
      subs = a->value.nodeval;
#line 4974
      value = in_array(r, subs);
      }
#line 4975
      if (cnt == 1) {
#line 4976
        if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 4977
          *(tmp___1 + i___0) = Nnull_string;
        } else
#line 4978
        if ((unsigned int )value->type == 5U) {
          {
#line 4979
          tmp___12 = gettext("attempt to use array `%s[\"%s\"]\' in a scalar context");
#line 4979
          d_error((char const   *)tmp___12, name, subs->sub.val.sp);
          }
#line 4981
          goto done;
        } else {
#line 4983
          *(tmp___1 + i___0) = value;
        }
      } else
#line 4985
      if ((unsigned long )value == (unsigned long )((void *)0)) {
        {
#line 4986
        tmp___13 = gettext("[\"%s\"] not in array `%s\'");
#line 4986
        d_error((char const   *)tmp___13, subs->sub.val.sp, name);
        }
#line 4988
        goto done;
      } else
#line 4989
      if ((unsigned int )value->type != 5U) {
        {
#line 4990
        tmp___14 = gettext("attempt to use scalar `%s[\"%s\"]\' as array");
#line 4990
        d_error((char const   *)tmp___14, name, subs->sub.val.sp);
        }
#line 4992
        goto done;
      } else {
#line 4994
        r = value;
#line 4995
        name = r->sub.nodep.name;
      }
#line 4970
      cnt --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5000
    goto switch_break;
    case_46: /* CIL Label */ 
#line 5002
    *(tmp___1 + i___0) = a->value.nodeval;
#line 5003
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5005
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4939
    i___0 ++;
#line 4939
    a = a->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5009
  *(tmp___1 + 0) = force_string(*(tmp___1 + 0));
#line 5011
  tmp___15 = fatal_tag_valid;
#line 5011
  fatal_tag_valid = (_Bool )((int )fatal_tag_valid + 1);
  }
#line 5011
  if (tmp___15) {
    {
#line 5011
    memcpy((void */* __restrict  */)((char *)(fatal_tag_stack)), (void const   */* __restrict  */)((char const   *)(fatal_tag)),
           sizeof(jmp_buf ));
    }
  }
  {
#line 5012
  tmp___16 = _setjmp((struct __jmp_buf_tag *)(fatal_tag));
  }
#line 5012
  if (tmp___16 == 0) {
    {
#line 5013
    r = format_tree((char const   *)(*(tmp___1 + 0))->sub.val.sp, (*(tmp___1 + 0))->sub.val.slen,
                    tmp___1, (long )i___0);
    }
  } else {
#line 5016
    exit_val = 0;
#line 5017
    r = (NODE *)((void *)0);
  }
#line 5019
  fatal_tag_valid = (_Bool )((int )fatal_tag_valid - 1);
#line 5019
  if (fatal_tag_valid) {
    {
#line 5019
    memcpy((void */* __restrict  */)((char *)(fatal_tag)), (void const   */* __restrict  */)((char const   *)(fatal_tag_stack)),
           sizeof(jmp_buf ));
    }
  }
#line 5021
  if ((unsigned long )r != (unsigned long )((void *)0)) {
    {
#line 5022
    fwrite((void const   */* __restrict  */)r->sub.val.sp, sizeof(char ), r->sub.val.slen,
           (FILE */* __restrict  */)out_fp);
#line 5023
    unref(r);
    }
  }
  done: 
  {
#line 5026
  free((void *)tmp___1);
  }
#line 5027
  return (0);
}
}
#line 5032 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_source(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  int fd ;
  char *file ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *__cil_tmp9 ;

  {
  {
#line 5036
  file = arg->value.sval;
#line 5038
  fd = open_readfd((char const   *)file);
  }
#line 5039
  if (fd <= -1) {
    {
#line 5040
    tmp___1 = __errno_location();
#line 5040
    tmp___2 = strerror(*tmp___1);
#line 5040
    tmp___3 = gettext("can\'t open source file `%s\' for reading (%s)");
#line 5040
    d_error((char const   *)tmp___3, file, tmp___2);
    }
#line 5042
    return (0);
  }
  {
#line 5045
  push_cmd_src(fd, (_Bool)0, & g_readline, & close, 32, 0);
#line 5046
  tmp___4 = strlen((char const   *)file);
#line 5046
  cmd_src->str = estrdup((char const   *)file, tmp___4);
  }
#line 5047
  return (0);
}
}
#line 5052 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int open_readfd(char const   *file ) 
{ 
  int fd ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 5057
  fd = open(file, 0);
  }
#line 5058
  if (fd <= -1) {
#line 5059
    return (-1);
  } else {
    {
#line 5060
    tmp___2 = os_isdir(fd);
    }
#line 5060
    if (tmp___2) {
      {
#line 5061
      close(fd);
#line 5062
      tmp___1 = __errno_location();
#line 5062
      *tmp___1 = 21;
      }
#line 5063
      return (-1);
    }
  }
#line 5065
  return (fd);
}
}
#line 5070 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int find_option(char *name ) 
{ 
  char const   *p ;
  int idx___3 ;
  int tmp___1 ;

  {
#line 5076
  idx___3 = 0;
  {
#line 5076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5076
    p = (char const   *)option_list[idx___3].name;
#line 5076
    if (! p) {
#line 5076
      goto while_break;
    }
    {
#line 5077
    tmp___1 = strcmp(p, (char const   *)name);
    }
#line 5077
    if (tmp___1 == 0) {
#line 5078
      return (idx___3);
    }
#line 5076
    idx___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5080
  return (-1);
}
}
#line 5085 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
void option_help(void) 
{ 
  struct dbg_option  const  *opt ;
  char *tmp___1 ;
  char *__cil_tmp3 ;

  {
#line 5090
  opt = option_list;
  {
#line 5090
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5090
    if (! opt->name) {
#line 5090
      goto while_break;
    }
    {
#line 5091
    tmp___1 = gettext((char const   *)opt->help_txt);
#line 5091
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\t%-15.15s - %s\n",
            opt->name, tmp___1);
#line 5090
    opt ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5092
  return;
}
}
#line 5101 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static size_t textlen  ;
#line 5102 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int idx  ;
#line 5098 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
char *option_generator(char const   *text , int state___2 ) 
{ 
  char const   *name ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 5105
  if (! state___2) {
    {
#line 5106
    textlen = strlen(text);
#line 5107
    idx = 0;
    }
  }
  {
#line 5110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5110
    tmp___4 = idx;
#line 5110
    idx ++;
#line 5110
    name = (char const   *)option_list[tmp___4].name;
#line 5110
    if (! name) {
#line 5110
      goto while_break;
    }
    {
#line 5111
    tmp___3 = strncmp(name, text, textlen);
    }
#line 5111
    if (tmp___3 == 0) {
      {
#line 5112
      tmp___1 = strlen(name);
#line 5112
      tmp___2 = estrdup(name, tmp___1);
      }
#line 5112
      return (tmp___2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5114
  return ((char *)((void *)0));
}
}
#line 5121 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void set_gawk_output(char const   *file ) 
{ 
  int fd ;
  FILE *fp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *cp ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned long tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 5124
  fd = -1;
#line 5125
  fp___0 = (FILE *)((void *)0);
#line 5127
  if ((unsigned long )output_fp != (unsigned long )stdout) {
#line 5128
    if ((unsigned long )output_fp != (unsigned long )stderr) {
      {
#line 5129
      fclose(output_fp);
#line 5130
      free((void *)output_file);
      }
    }
    {
#line 5132
    output_fp = stdout;
#line 5133
    tmp___1 = fileno(stdout);
#line 5133
    tmp___2 = os_isatty(tmp___1);
#line 5133
    output_is_tty = (_Bool )tmp___2;
#line 5134
    output_file = (char *)"/dev/stdout";
    }
  }
#line 5137
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 5138
    return;
  } else
#line 5137
  if ((int const   )*(file + 0) == 0) {
#line 5138
    return;
  }
  {
#line 5140
  tmp___3 = __errno_location();
#line 5140
  *tmp___3 = 0;
#line 5141
  fd = os_devopen(file, 1);
  }
#line 5141
  if (fd != -1) {
    {
#line 5142
    fp___0 = fdopen(fd, "w");
    }
#line 5143
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      {
#line 5144
      close(fd);
      }
    }
  } else {
    {
#line 5146
    tmp___11 = strncmp(file, "/dev/", (size_t )5);
    }
#line 5146
    if (tmp___11 == 0) {
      {
#line 5147
      cp = (char *)file + 5;
#line 5149
      tmp___4 = strcmp((char const   *)cp, "stdout");
      }
#line 5149
      if (tmp___4 == 0) {
#line 5150
        return;
      }
      {
#line 5151
      tmp___7 = strcmp((char const   *)cp, "stderr");
      }
#line 5151
      if (tmp___7 == 0) {
        {
#line 5152
        output_fp = stderr;
#line 5153
        output_file = (char *)"/dev/stderr";
#line 5154
        tmp___5 = fileno(stderr);
#line 5154
        tmp___6 = os_isatty(tmp___5);
#line 5154
        output_is_tty = (_Bool )tmp___6;
        }
#line 5155
        return;
      }
      {
#line 5158
      tmp___10 = strncmp((char const   *)cp, "fd/", (size_t )3);
      }
#line 5158
      if (tmp___10 == 0) {
        {
#line 5159
        cp += 3;
#line 5160
        tmp___8 = strtoul((char const   */* __restrict  */)cp, (char **/* __restrict  */)((void *)0),
                          10);
#line 5160
        fd = (int )tmp___8;
#line 5161
        tmp___9 = __errno_location();
        }
#line 5161
        if (*tmp___9 == 0) {
#line 5161
          if (fd > -1) {
            {
#line 5162
            fp___0 = fdopen(fd, "w");
            }
#line 5163
            if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
#line 5164
              fd = -1;
            }
          } else {
#line 5166
            fd = -1;
          }
        } else {
#line 5166
          fd = -1;
        }
      } else {
        {
#line 5169
        fd = open(file, 1);
        }
      }
#line 5172
      if (fd > -1) {
#line 5172
        if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
          {
#line 5173
          fp___0 = fdopen(fd, "w");
          }
#line 5174
          if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
            {
#line 5175
            close(fd);
            }
          }
        }
      }
    } else {
      {
#line 5180
      fp___0 = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
      }
    }
  }
#line 5183
  if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
    {
#line 5184
    output_fp = fp___0;
#line 5185
    tmp___12 = strlen(file);
#line 5185
    output_file = estrdup(file, tmp___12);
#line 5186
    setbuf((FILE */* __restrict  */)fp___0, (char */* __restrict  */)((char *)((void *)0)));
#line 5187
    tmp___13 = fileno(fp___0);
#line 5187
    tmp___14 = os_isatty(tmp___13);
#line 5187
    output_is_tty = (_Bool )tmp___14;
    }
  } else {
    {
#line 5189
    tmp___19 = __errno_location();
    }
#line 5189
    if (*tmp___19 != 0) {
      {
#line 5189
      tmp___15 = __errno_location();
#line 5189
      tmp___16 = strerror(*tmp___15);
#line 5189
      tmp___18 = tmp___16;
      }
    } else {
      {
#line 5189
      tmp___17 = gettext("reason unknown");
#line 5189
      tmp___18 = tmp___17;
      }
    }
    {
#line 5189
    tmp___20 = gettext("could not open `%s\' for writing (%s)");
#line 5189
    d_error((char const   *)tmp___20, file, tmp___18);
#line 5192
    tmp___21 = gettext("sending output to stdout\n");
#line 5192
    fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___21);
    }
  }
#line 5194
  return;
}
}
#line 5198 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void set_prompt(char const   *value ) 
{ 
  size_t tmp___1 ;

  {
  {
#line 5201
  free((void *)dgawk_prompt);
#line 5202
  tmp___1 = strlen(value);
#line 5202
  dgawk_prompt = estrdup(value, tmp___1);
#line 5203
  dbg_prompt = dgawk_prompt;
  }
#line 5204
  return;
}
}
#line 5208 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int set_option_flag(char const   *value ) 
{ 
  long n ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 5212
  tmp___1 = strcmp(value, "on");
  }
#line 5212
  if (tmp___1 == 0) {
#line 5213
    return (1);
  }
  {
#line 5214
  tmp___2 = strcmp(value, "off");
  }
#line 5214
  if (tmp___2 == 0) {
#line 5215
    return (0);
  }
  {
#line 5216
  tmp___3 = __errno_location();
#line 5216
  *tmp___3 = 0;
#line 5217
  n = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)((void *)0),
             0);
#line 5218
  tmp___4 = __errno_location();
  }
#line 5218
  if (*tmp___4 == 0) {
#line 5218
    if (n != 0L) {
#line 5218
      tmp___5 = 1;
    } else {
#line 5218
      tmp___5 = 0;
    }
  } else {
#line 5218
    tmp___5 = 0;
  }
#line 5218
  return (tmp___5);
}
}
#line 5223 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void set_option_num(int *pnum , char const   *value ) 
{ 
  long n ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 5227
  tmp___1 = __errno_location();
#line 5227
  *tmp___1 = 0;
#line 5228
  n = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)((void *)0),
             0);
#line 5229
  tmp___3 = __errno_location();
  }
#line 5229
  if (*tmp___3 == 0) {
#line 5229
    if (n > 0L) {
#line 5230
      *pnum = (int )n;
    } else {
      {
#line 5232
      tmp___2 = gettext("invalid number");
#line 5232
      d_error((char const   *)tmp___2);
      }
    }
  } else {
    {
#line 5232
    tmp___2 = gettext("invalid number");
#line 5232
    d_error((char const   *)tmp___2);
    }
  }
#line 5233
  return;
}
}
#line 5237 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void set_listsize(char const   *value ) 
{ 


  {
  {
#line 5240
  set_option_num(& list_size, value);
  }
#line 5241
  return;
}
}
#line 5245 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void set_trace(char const   *value ) 
{ 


  {
  {
#line 5248
  do_trace = set_option_flag(value);
  }
#line 5249
  return;
}
}
#line 5253 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void set_save_history(char const   *value ) 
{ 


  {
  {
#line 5256
  do_save_history = set_option_flag(value);
  }
#line 5257
  return;
}
}
#line 5261 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void set_save_options(char const   *value ) 
{ 


  {
  {
#line 5264
  do_save_options = set_option_flag(value);
  }
#line 5265
  return;
}
}
#line 5269 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void set_history_size(char const   *value ) 
{ 


  {
  {
#line 5272
  set_option_num(& history_size, value);
  }
#line 5273
  return;
}
}
#line 5281 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
char *read_commands_string(char const   *prompt  __attribute__((__unused__)) ) 
{ 
  char *p ;
  char *end ;
  char *line ;

  {
#line 5286
  if ((unsigned long )commands_string == (unsigned long )((void *)0)) {
#line 5287
    return ((char *)((void *)0));
  }
#line 5289
  p = (char *)commands_string;
#line 5290
  end = (char *)commands_string + commands_string_len;
  {
#line 5291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5291
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 5291
      goto while_break;
    }
#line 5292
    if ((int )*p == (int )line_sep) {
      {
#line 5293
      line = estrdup(commands_string, (size_t )(p - (char *)commands_string));
#line 5294
      commands_string = (char const   *)(p + 1);
#line 5295
      commands_string_len = (int )(end - (char *)commands_string);
      }
#line 5296
      return (line);
    }
#line 5291
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5300
  line = estrdup(commands_string, (size_t )commands_string_len);
#line 5301
  commands_string = (char const   *)((void *)0);
#line 5302
  commands_string_len = 0;
  }
#line 5303
  return (line);
}
}
#line 5308 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void save_options(char const   *file ) 
{ 
  FILE *fp___0 ;
  struct dbg_option  const  *opt ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 5314
  fp___0 = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
#line 5315
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
#line 5316
    return;
  }
#line 5318
  opt = option_list;
  {
#line 5318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5318
    if (! opt->name) {
#line 5318
      goto while_break;
    }
#line 5319
    if ((unsigned long )opt->str_val != (unsigned long )((void *)0)) {
      {
#line 5320
      fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"option %s = \"%s\"\n",
              opt->name, *(opt->str_val));
      }
    } else {
      {
#line 5322
      fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"option %s = %d\n",
              opt->name, *(opt->num_val));
      }
    }
#line 5318
    opt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5324
  fclose(fp___0);
#line 5325
  chmod(file, (__mode_t )384);
  }
#line 5326
  return;
}
}
#line 5330 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void close_all(void) 
{ 
  _Bool stdio_problem ;
  struct command_source *cs ;

  {
  {
#line 5336
  nextfile(& curfile, (_Bool)1);
#line 5337
  close_io(& stdio_problem);
  }
#line 5338
  if (cur_srcfile->fd != -1) {
    {
#line 5339
    close(cur_srcfile->fd);
#line 5340
    cur_srcfile->fd = -1;
    }
  }
#line 5342
  cs = cmd_src;
  {
#line 5342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5342
    if (! ((unsigned long )cs != (unsigned long )((void *)0))) {
#line 5342
      goto while_break;
    }
#line 5343
    if (cs->close_func) {
#line 5343
      if (cs->fd != -1) {
        {
#line 5344
        (*(cs->close_func))(cs->fd);
#line 5345
        cs->fd = -1;
        }
      }
    }
#line 5342
    cs = cs->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5349
  close_extensions();
#line 5351
  set_gawk_output((char const   *)((void *)0));
  }
#line 5352
  return;
}
}
#line 5356 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int pre_execute_code(INSTRUCTION **pi ) 
{ 
  INSTRUCTION *ei ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  NODE *r ;
  char *tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 5359
  ei = *pi;
  {
#line 5365
  if ((unsigned int )ei->opcode == 63U) {
#line 5365
    goto case_63;
  }
#line 5365
  if ((unsigned int )ei->opcode == 64U) {
#line 5365
    goto case_63;
  }
#line 5365
  if ((unsigned int )ei->opcode == 57U) {
#line 5365
    goto case_63;
  }
#line 5365
  if ((unsigned int )ei->opcode == 58U) {
#line 5365
    goto case_63;
  }
#line 5371
  if ((unsigned int )ei->opcode == 59U) {
#line 5371
    goto case_59;
  }
#line 5382
  goto switch_default;
  case_63: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_58: /* CIL Label */ 
  {
#line 5366
  tmp___1 = op2str(ei->opcode);
#line 5366
  tmp___2 = gettext("`%s\' not allowed in current context; statement ignored");
#line 5366
  d_error((char const   *)tmp___2, tmp___1);
#line 5369
  *pi = ei->nexti;
  }
#line 5370
  goto switch_break;
  case_59: /* CIL Label */ 
#line 5372
  if ((unsigned long )ei->nexti != (unsigned long )((void *)0)) {
    {
#line 5374
    tmp___3 = gettext("`return\' not allowed in current context; statement ignored");
#line 5374
    d_error((char const   *)tmp___3);
#line 5377
    r = POP_SCALAR();
#line 5378
    DEREF(r);
#line 5379
    *pi = ei->nexti;
    }
  }
#line 5381
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5383
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5385
  return ((unsigned long )ei == (unsigned long )*pi);
}
}
#line 5390 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static NODE *execute_code(INSTRUCTION volatile   *code ) 
{ 
  NODE volatile   *r ;
  jmp_buf volatile   fatal_tag_stack ;
  long save_stack_size ;
  int save_flags ;
  _Bool tmp___1 ;
  NODE *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
#line 5393
  r = (NODE volatile   *)((void *)0);
#line 5396
  save_flags = do_flags;
#line 5403
  save_stack_size = (stack_ptr - stack_bottom) + 1L;
#line 5404
  do_flags = 0;
#line 5406
  tmp___1 = fatal_tag_valid;
#line 5406
  fatal_tag_valid = (_Bool )((int )fatal_tag_valid + 1);
#line 5406
  if (tmp___1) {
    {
#line 5406
    memcpy((void */* __restrict  */)((char *)(fatal_tag_stack)), (void const   */* __restrict  */)((char const   *)(fatal_tag)),
           sizeof(jmp_buf ));
    }
  }
  {
#line 5407
  tmp___3 = _setjmp((struct __jmp_buf_tag *)(fatal_tag));
  }
#line 5407
  if (tmp___3 == 0) {
    {
#line 5408
    (*interpret)((INSTRUCTION *)code);
#line 5409
    tmp___2 = POP_SCALAR();
#line 5409
    r = (NODE volatile   *)tmp___2;
    }
  } else {
    {
#line 5411
    unwind_stack(save_stack_size);
    }
  }
#line 5413
  fatal_tag_valid = (_Bool )((int )fatal_tag_valid - 1);
#line 5413
  if (fatal_tag_valid) {
    {
#line 5413
    memcpy((void */* __restrict  */)((char *)(fatal_tag)), (void const   */* __restrict  */)((char const   *)(fatal_tag_stack)),
           sizeof(jmp_buf ));
    }
  }
#line 5414
  do_flags = save_flags;
#line 5415
  if (exit_val != 0) {
#line 5416
    exit_val = 0;
#line 5417
    return ((NODE *)((void *)0));
  }
#line 5419
  return ((NODE *)r);
}
}
#line 5424 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_eval(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  NODE *r ;
  NODE *ret_val ;
  NODE *f ;
  NODE *this_frame ;
  NODE *this_func ;
  NODE **sp___0 ;
  INSTRUCTION *eval ;
  INSTRUCTION *code ;
  AWK_CONTEXT *ctxt ;
  int ecount ;
  int pcount ;
  int ret ;
  int save_flags ;
  int i___0 ;
  INSTRUCTION *t ;
  struct exp_node **tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  struct exp_node **tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  NODE *np ;
  void *tmp___13 ;
  NODE **tmp___14 ;
  int i___1 ;
  NODE **tmp___15 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 5428
  f = (NODE *)((void *)0);
#line 5429
  this_frame = (NODE *)((void *)0);
#line 5429
  this_func = (NODE *)((void *)0);
#line 5431
  code = (INSTRUCTION *)((void *)0);
#line 5433
  ecount = 0;
#line 5433
  pcount = 0;
#line 5435
  save_flags = do_flags;
#line 5437
  if (prog_running) {
    {
#line 5438
    this_frame = find_frame(0L);
#line 5439
    this_func = this_frame->sub.nodep.x.extra;
    }
  }
  {
#line 5442
  install_params(this_func);
#line 5443
  ctxt = new_context();
#line 5444
  ctxt->install_func = & append_symbol;
#line 5445
  push_context(ctxt);
#line 5446
  add_srcfile(1, arg->value.sval, srcfiles, (_Bool *)((void *)0), (int *)((void *)0));
#line 5447
  do_flags = 0;
#line 5448
  ret = parse_program(& code);
#line 5449
  do_flags = save_flags;
#line 5450
  remove_params(this_func);
  }
#line 5451
  if (ret != 0) {
    {
#line 5452
    pop_context();
#line 5453
    free_context(ctxt, (_Bool)0);
    }
#line 5454
    return (0);
  }
  {
#line 5457
  f = lookup("@eval");
  }
#line 5459
  if ((unsigned long )this_func == (unsigned long )((void *)0)) {
    {
#line 5461
    eval = bcalloc((OPCODE )70, 2, 0);
#line 5462
    eval->d.name = cur_srcfile->src;
#line 5463
    eval->x.xn = f;
#line 5464
    eval->d.name = (char *)((void *)0);
#line 5465
    (eval + 1)->x.xl = 0L;
#line 5466
    eval->nexti = bcalloc((OPCODE )102, 1, 0);
    }
  } else {
#line 5473
    eval = f->sub.nodep.r.iptr;
#line 5474
    eval->d.name = cur_srcfile->src;
#line 5476
    t = (eval + 1)->d.di;
#line 5477
    t->opcode = (OPCODE )102;
#line 5480
    ecount = (int )f->sub.nodep.l.ll;
#line 5481
    pcount = (int )this_func->sub.nodep.l.ll;
#line 5483
    if (ecount > 0) {
#line 5484
      if (pcount == 0) {
        {
#line 5485
        tmp___2 = malloc((unsigned long )ecount * sizeof(NODE *));
#line 5485
        tmp___1 = (NODE **)tmp___2;
#line 5485
        this_frame->sub.nodep.r.av = tmp___1;
        }
#line 5485
        if (tmp___1) {
#line 5485
          tmp___6 = 1;
        } else {
          {
#line 5485
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 5485);
#line 5485
          tmp___3 = __errno_location();
#line 5485
          tmp___4 = strerror(*tmp___3);
#line 5485
          tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 5485
          r_fatal((char const   *)tmp___5, "do_eval", "this_frame->stack", (long )((unsigned long )ecount * sizeof(NODE *)),
                  tmp___4);
#line 5485
          tmp___6 = 0;
          }
        }
      } else {
        {
#line 5487
        tmp___8 = realloc((void *)((char *)this_frame->sub.nodep.r.av), (unsigned long )(pcount + ecount) * sizeof(NODE *));
#line 5487
        tmp___7 = (NODE **)tmp___8;
#line 5487
        this_frame->sub.nodep.r.av = tmp___7;
        }
#line 5487
        if (tmp___7) {
#line 5487
          tmp___12 = 1;
        } else {
          {
#line 5487
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 5487);
#line 5487
          tmp___9 = __errno_location();
#line 5487
          tmp___10 = strerror(*tmp___9);
#line 5487
          tmp___11 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 5487
          r_fatal((char const   *)tmp___11, "do_eval", "this_frame->stack", (long )((unsigned long )(pcount + ecount) * sizeof(NODE *)),
                  tmp___10);
#line 5487
          tmp___12 = 0;
          }
        }
      }
#line 5489
      sp___0 = this_frame->sub.nodep.r.av + pcount;
#line 5490
      i___0 = 0;
      {
#line 5490
      while (1) {
        while_continue: /* CIL Label */ ;
#line 5490
        if (! (i___0 < ecount)) {
#line 5490
          goto while_break;
        }
#line 5493
        np = f->sub.nodep.rn + i___0;
#line 5494
        np->sub.nodep.l.ll += (long )pcount;
#line 5496
        r = (NODE *)nextfree[1].freep;
#line 5496
        if (r) {
#line 5496
          nextfree[1].freep = ((BLOCK *)r)->freep;
        } else {
          {
#line 5496
          tmp___13 = more_blocks(1);
#line 5496
          r = (NODE *)tmp___13;
          }
        }
        {
#line 5497
        memset((void *)r, 0, sizeof(NODE ));
#line 5498
        tmp___14 = sp___0;
#line 5498
        sp___0 ++;
#line 5498
        *tmp___14 = r;
#line 5500
        r->type = (NODETYPE )6;
#line 5501
        r->sub.nodep.name = np->sub.nodep.name;
#line 5490
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 5504
      this_func->sub.nodep.l.ll += (long )ecount;
    }
  }
  {
#line 5515
  ret_val = execute_code((INSTRUCTION volatile   *)eval);
  }
#line 5517
  if ((unsigned long )ret_val != (unsigned long )((void *)0)) {
    {
#line 5518
    DEREF(ret_val);
    }
  }
#line 5522
  if ((unsigned long )this_func != (unsigned long )((void *)0)) {
#line 5522
    if (ecount > 0) {
#line 5528
      sp___0 = this_frame->sub.nodep.r.av + pcount;
#line 5529
      i___1 = ecount;
      {
#line 5529
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5529
        if (! (i___1 > 0)) {
#line 5529
          goto while_break___0;
        }
#line 5530
        r = *sp___0;
#line 5531
        if ((unsigned int )r->type == 4U) {
          {
#line 5532
          DEREF(r->sub.nodep.l.lptr);
          }
        } else
#line 5533
        if ((unsigned int )r->type == 5U) {
          {
#line 5534
          (*(*(r->sub.nodep.l.lp + 5)))(r, (struct exp_node *)((void *)0));
          }
        }
#line 5535
        ((BLOCK *)r)->freep = nextfree[1].freep;
#line 5535
        nextfree[1].freep = (BLOCK *)r;
#line 5536
        tmp___15 = sp___0;
#line 5536
        sp___0 ++;
#line 5536
        *tmp___15 = (NODE *)0;
#line 5529
        i___1 --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 5538
      if (pcount == 0) {
        {
#line 5539
        free((void *)this_frame->sub.nodep.r.av);
#line 5540
        this_frame->sub.nodep.r.av = (struct exp_node **)((void *)0);
        }
      }
#line 5544
      this_func->sub.nodep.l.ll -= (long )ecount;
    }
  }
  {
#line 5551
  pop_context();
#line 5552
  free_context(ctxt, (_Bool )((unsigned long )ret_val != (unsigned long )((void *)0)));
  }
#line 5553
  if ((unsigned long )ret_val != (unsigned long )((void *)0)) {
    {
#line 5554
    destroy_symbol(f);
    }
  }
#line 5555
  return (0);
}
}
#line 5569 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int invalid_symbol  =    0;
#line 5571 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static void check_symbol(NODE *r ) 
{ 
  char *tmp___1 ;
  char *__cil_tmp3 ;

  {
  {
#line 5574
  invalid_symbol ++;
#line 5575
  tmp___1 = gettext("No symbol `%s\' in current context");
#line 5575
  d_error((char const   *)tmp___1, r->sub.nodep.name);
#line 5577
  append_symbol(r);
  }
#line 5578
  return;
}
}
#line 5582 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
static int parse_condition(int type , int num , char *expr ) 
{ 
  INSTRUCTION *code ;
  AWK_CONTEXT *ctxt ;
  int ret ;
  BREAKPOINT *b___0 ;
  struct list_item *w___0 ;
  NODE *this_func ;
  INSTRUCTION *it ;
  INSTRUCTION *stop___0 ;
  INSTRUCTION *rule___0 ;
  struct condition *cndn ;
  int save_flags ;
  INSTRUCTION *rp ;
  NODE *tmp___1 ;

  {
#line 5585
  code = (INSTRUCTION *)((void *)0);
#line 5586
  ctxt = (AWK_CONTEXT *)((void *)0);
#line 5590
  this_func = (NODE *)((void *)0);
#line 5592
  cndn = (struct condition *)((void *)0);
#line 5593
  save_flags = do_flags;
#line 5595
  if (type == 2) {
    {
#line 5595
    b___0 = find_breakpoint((long )num);
    }
#line 5595
    if ((unsigned long )b___0 != (unsigned long )((void *)0)) {
      {
#line 5597
      cndn = & b___0->cndn;
#line 5598
      rp = find_rule(b___0->src, (long )(b___0->bpi)->source_line);
      }
#line 5599
      if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 5599
        if ((unsigned int )rp->opcode == 97U) {
#line 5600
          this_func = rp->x.xn;
        }
      }
    } else {
#line 5595
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 5601
  if (type == 41) {
    {
#line 5601
    w___0 = find_item(& watch_list, (long )num);
    }
#line 5601
    if ((unsigned long )w___0 != (unsigned long )((void *)0)) {
      {
#line 5602
      cndn = & w___0->cndn;
#line 5603
      tmp___1 = find_frame(cur_frame);
#line 5603
      this_func = tmp___1->sub.nodep.x.extra;
      }
    }
  }
#line 5606
  if ((unsigned long )cndn == (unsigned long )((void *)0)) {
#line 5607
    return (-1);
  }
#line 5608
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
#line 5609
    goto out;
  }
  {
#line 5611
  install_params(this_func);
#line 5612
  ctxt = new_context();
#line 5613
  invalid_symbol = 0;
#line 5614
  ctxt->install_func = & check_symbol;
#line 5615
  push_context(ctxt);
#line 5616
  add_srcfile(1, expr, srcfiles, (_Bool *)((void *)0), (int *)((void *)0));
#line 5617
  do_flags = 0;
#line 5618
  ret = parse_program(& code);
#line 5619
  do_flags = save_flags;
#line 5620
  remove_params(this_func);
#line 5621
  pop_context();
  }
#line 5623
  if (ret != 0) {
    {
#line 5624
    free_context(ctxt, (_Bool)0);
    }
#line 5625
    return (-1);
  } else
#line 5623
  if (invalid_symbol) {
    {
#line 5624
    free_context(ctxt, (_Bool)0);
    }
#line 5625
    return (-1);
  }
  {
#line 5634
  rule___0 = ctxt->rule_list.nexti;
#line 5635
  stop___0 = bcalloc((OPCODE )102, 1, 0);
#line 5637
  it = rule___0->x.xi;
#line 5639
  it->opcode = (OPCODE )74;
#line 5640
  it->d.dn = (*make_number)(1.0);
#line 5641
  it->nexti = bcalloc((OPCODE )83, 1, 0);
#line 5642
  (it->nexti)->d.di = stop___0;
#line 5643
  (it->nexti)->nexti = rule___0->d.di;
#line 5645
  it = rule___0->d.di;
#line 5647
  it->opcode = (OPCODE )74;
#line 5648
  it->d.dn = (*make_number)(0.0);
#line 5649
  it->nexti = stop___0;
  }
  out: 
#line 5652
  if ((unsigned long )cndn->expr != (unsigned long )((void *)0)) {
    {
#line 5653
    free((void *)cndn->expr);
    }
  }
  {
#line 5654
  free_context(cndn->ctxt, (_Bool)0);
#line 5655
  cndn->code = code;
#line 5656
  cndn->expr = expr;
#line 5657
  cndn->ctxt = ctxt;
  }
#line 5659
  return (0);
}
}
#line 5664 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int do_condition(CMDARG *arg , int cmd  __attribute__((__unused__)) ) 
{ 
  int type ;
  int num ;
  char *expr ;
  int tmp___1 ;

  {
  {
#line 5668
  expr = (char *)((void *)0);
#line 5670
  num = (int )arg->value.lval;
#line 5671
  type = has_break_or_watch_point(& num, (_Bool)0);
  }
#line 5672
  if (! type) {
#line 5673
    return (0);
  }
#line 5674
  arg = arg->next;
#line 5675
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 5676
    expr = arg->value.sval;
  }
  {
#line 5677
  tmp___1 = parse_condition(type, num, expr);
  }
#line 5677
  if (tmp___1 == 0) {
#line 5677
    if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 5678
      arg->value.sval = (char *)((void *)0);
    }
  }
#line 5679
  return (0);
}
}
#line 5684 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int in_cmd_src(char const   *filename ) 
{ 
  struct command_source *cs ;
  int tmp___1 ;

  {
#line 5688
  cs = cmd_src;
  {
#line 5688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5688
    if (! ((unsigned long )cs != (unsigned long )((void *)0))) {
#line 5688
      goto while_break;
    }
#line 5689
    if ((unsigned long )cs->str != (unsigned long )((void *)0)) {
      {
#line 5689
      tmp___1 = strcmp((char const   *)cs->str, filename);
      }
#line 5689
      if (tmp___1 == 0) {
#line 5690
        return (1);
      }
    }
#line 5688
    cs = cs->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 5692
  return (0);
}
}
#line 5695 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int get_eof_status(void) 
{ 


  {
#line 5698
  if ((unsigned long )cmd_src == (unsigned long )((void *)0)) {
#line 5699
    return (2);
  }
#line 5700
  return (cmd_src->eof_status);
}
}
#line 5703 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
void push_cmd_src(int fd , _Bool istty , char *(*readfunc___0)(char const   * ) ,
                  int (*closefunc___0)(int  ) , int ctype , int eofstatus ) 
{ 
  struct command_source *cs ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 5713
  tmp___1 = malloc(sizeof(struct command_source ));
#line 5713
  cs = (struct command_source *)tmp___1;
  }
#line 5713
  if (cs) {
#line 5713
    tmp___5 = 1;
  } else {
    {
#line 5713
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c", 5713);
#line 5713
    tmp___2 = __errno_location();
#line 5713
    tmp___3 = strerror(*tmp___2);
#line 5713
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 5713
    r_fatal((char const   *)tmp___4, "push_cmd_src", "cs", (long )sizeof(struct command_source ),
            tmp___3);
#line 5713
    tmp___5 = 0;
    }
  }
#line 5714
  cs->fd = fd;
#line 5715
  cs->is_tty = (int )istty;
#line 5716
  cs->read_func = readfunc___0;
#line 5717
  cs->close_func = closefunc___0;
#line 5718
  cs->cmd = ctype;
#line 5724
  cs->eof_status = eofstatus;
#line 5725
  cs->str = (char *)((void *)0);
#line 5726
  cs->next = cmd_src;
#line 5727
  cmd_src = cs;
#line 5729
  input_fd = fd;
#line 5730
  input_from_tty = istty;
#line 5731
  read_a_line = readfunc___0;
#line 5732
  return;
}
}
#line 5734 "/home/wslee/gnu_benchmarks/gawk-4.1.0/debug.c"
int pop_cmd_src(void) 
{ 
  struct command_source *cs ;

  {
#line 5739
  if ((unsigned long )cmd_src->next == (unsigned long )((void *)0)) {
#line 5740
    return (-1);
  }
#line 5742
  cs = cmd_src;
#line 5743
  cmd_src = cs->next;
#line 5744
  if (cs->close_func) {
#line 5744
    if (cs->fd != -1) {
      {
#line 5745
      (*(cs->close_func))(cs->fd);
      }
    }
  }
#line 5746
  if ((unsigned long )cs->str != (unsigned long )((void *)0)) {
    {
#line 5747
    free((void *)cs->str);
    }
  }
  {
#line 5748
  free((void *)cs);
#line 5750
  input_fd = cmd_src->fd;
#line 5751
  input_from_tty = (_Bool )cmd_src->is_tty;
#line 5752
  read_a_line = cmd_src->read_func;
  }
#line 5753
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 1374 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
void negate_num(NODE *n ) ;
#line 449 "/usr/include/readline/readline.h"
extern char **rl_completion_matches(char const   * , rl_compentry_func_t * ) ;
#line 508
extern char *rl_line_buffer ;
#line 735
extern int rl_attempted_completion_over ;
#line 790
extern int rl_inhibit_completion ;
#line 72 "/usr/include/readline/history.h"
extern void using_history(void) ;
#line 153
extern HIST_ENTRY *previous_history(void) ;
#line 222
extern int history_expand(char * , char ** ) ;
#line 159 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cmd.h"
char const   *get_command_name(int ctype ) ;
#line 194
int do_help(CMDARG *arg , int cmd ) ;
#line 35 "command.y"
static int zzlex(void) ;
#line 36
static void zzerror(char const   *mesg  , ...) ;
#line 38
static int find_command(char const   *token , size_t toklen ) ;
#line 40 "command.y"
static _Bool want_nodeval  =    (_Bool)0;
#line 42 "command.y"
static int cmd_idx  =    -1;
#line 43 "command.y"
static int repeat_idx  =    -1;
#line 44 "command.y"
static CMDARG *arg_list  =    (CMDARG *)((void *)0);
#line 45 "command.y"
static long errcount  =    0L;
#line 46 "command.y"
static char *lexptr_begin  =    (char *)((void *)0);
#line 47 "command.y"
static _Bool in_commands  =    (_Bool)0;
#line 48 "command.y"
static int num_dim  ;
#line 50 "command.y"
static _Bool in_eval  =    (_Bool)0;
#line 51 "command.y"
static char const   start_EVAL[18]  = 
#line 51
  {      (char const   )'f',      (char const   )'u',      (char const   )'n',      (char const   )'c', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'@',      (char const   )'e',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'(',      (char const   )')', 
        (char const   )'{',      (char const   )'\000'};
#line 52 "command.y"
static char const   end_EVAL[2]  = {      (char const   )'}',      (char const   )'\000'};
#line 53
static CMDARG *append_statement(CMDARG *stmt_list , char *stmt ) ;
#line 54
static char *next_word(char *p , int len , char **endp ) ;
#line 55
static NODE *concat_args(CMDARG *arg , int count ) ;
#line 58
static void history_expand_line(char **line ) ;
#line 59
static char *command_generator(char const   *text , int state___2 ) ;
#line 60
static char *srcfile_generator(char const   *text , int state___2 ) ;
#line 61
static char *argument_generator(char const   *text , int state___2 ) ;
#line 62
static char *variable_generator(char const   *text , int state___2 ) ;
#line 64 "command.y"
static int this_cmd  =    0;
#line 84
struct argtoken zz_debug_argtab[15] ;
#line 85
struct cmdtoken zz_debug_cmdtab[42] ;
#line 87
static CMDARG *mk_cmdarg(enum argtype type ) ;
#line 88
static void append_cmdarg(CMDARG *arg ) ;
#line 89
static int find_argument(CMDARG *arg ) ;
#line 279 "command.c"
CMDARG *zzlval  ;
#line 548 "command.c"
static yytype_uint8 const   yytranslate[304]  = 
#line 548
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )58,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )54,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )51,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )49,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )56,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48};
#line 715 "command.c"
static yytype_uint8 const   yyr1[157]  = 
#line 715
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )63,      (yytype_uint8 const   )63,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )64,      (yytype_uint8 const   )64,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )69,      (yytype_uint8 const   )68,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )74,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )75,      (yytype_uint8 const   )71,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )77,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )81,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )89,      (yytype_uint8 const   )88,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )88,      (yytype_uint8 const   )88,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )92,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )94,      (yytype_uint8 const   )94,      (yytype_uint8 const   )95, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )96,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )97,      (yytype_uint8 const   )97,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )100,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )105,      (yytype_uint8 const   )105,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )106,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )108,      (yytype_uint8 const   )108,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )111,      (yytype_uint8 const   )112,      (yytype_uint8 const   )112,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )113};
#line 736 "command.c"
static yytype_uint8 const   yyr2[157]  = 
#line 736
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1};
#line 759 "command.c"
static yytype_uint8 const   yydefact[203]  = 
#line 759
  {      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )20,      (yytype_uint8 const   )83,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )14,      (yytype_uint8 const   )17,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )19,      (yytype_uint8 const   )101,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )117,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )40,      (yytype_uint8 const   )30,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )46,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )16,      (yytype_uint8 const   )83,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )53,      (yytype_uint8 const   )13,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )79,      (yytype_uint8 const   )0,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )156,      (yytype_uint8 const   )3,      (yytype_uint8 const   )147, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )149,      (yytype_uint8 const   )88,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )151,      (yytype_uint8 const   )82,      (yytype_uint8 const   )0,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )84,      (yytype_uint8 const   )129,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )131,      (yytype_uint8 const   )103,      (yytype_uint8 const   )128, 
        (yytype_uint8 const   )130,      (yytype_uint8 const   )102,      (yytype_uint8 const   )29,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )82,      (yytype_uint8 const   )118,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )42,      (yytype_uint8 const   )122,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )99,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )95,      (yytype_uint8 const   )0,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )62,      (yytype_uint8 const   )80,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )59,      (yytype_uint8 const   )67,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )0,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )55,      (yytype_uint8 const   )153,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )34,      (yytype_uint8 const   )150,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )45,      (yytype_uint8 const   )89,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )152,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )133,      (yytype_uint8 const   )132,      (yytype_uint8 const   )0,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )111,      (yytype_uint8 const   )141,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )108,      (yytype_uint8 const   )39,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )112,      (yytype_uint8 const   )114,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )144,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )100,      (yytype_uint8 const   )0,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )96,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )71,      (yytype_uint8 const   )0,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )0,      (yytype_uint8 const   )154,      (yytype_uint8 const   )155, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )87,      (yytype_uint8 const   )86,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )123,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )139,      (yytype_uint8 const   )143,      (yytype_uint8 const   )106,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )109,      (yytype_uint8 const   )0,      (yytype_uint8 const   )145, 
        (yytype_uint8 const   )146,      (yytype_uint8 const   )0,      (yytype_uint8 const   )77,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )76,      (yytype_uint8 const   )81,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )0,      (yytype_uint8 const   )64,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )136, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )134,      (yytype_uint8 const   )140,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )110,      (yytype_uint8 const   )115,      (yytype_uint8 const   )47,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )26,      (yytype_uint8 const   )138,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )137,      (yytype_uint8 const   )93,      (yytype_uint8 const   )135};
#line 785 "command.c"
static yytype_int16 const   yydefgoto[55]  = 
#line 785
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )46,      (yytype_int16 const   )47, 
        (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )98, 
        (yytype_int16 const   )51,      (yytype_int16 const   )111,      (yytype_int16 const   )186,      (yytype_int16 const   )52, 
        (yytype_int16 const   )53,      (yytype_int16 const   )80,      (yytype_int16 const   )81,      (yytype_int16 const   )83, 
        (yytype_int16 const   )82,      (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )149, 
        (yytype_int16 const   )175,      (yytype_int16 const   )93,      (yytype_int16 const   )146,      (yytype_int16 const   )147, 
        (yytype_int16 const   )176,      (yytype_int16 const   )177,      (yytype_int16 const   )91,      (yytype_int16 const   )59, 
        (yytype_int16 const   )60,      (yytype_int16 const   )109,      (yytype_int16 const   )153,      (yytype_int16 const   )196, 
        (yytype_int16 const   )139,      (yytype_int16 const   )88,      (yytype_int16 const   )136,      (yytype_int16 const   )70, 
        (yytype_int16 const   )64,      (yytype_int16 const   )125,      (yytype_int16 const   )126,      (yytype_int16 const   )130, 
        (yytype_int16 const   )131,      (yytype_int16 const   )77,      (yytype_int16 const   )65,      (yytype_int16 const   )66, 
        (yytype_int16 const   )67,      (yytype_int16 const   )188,      (yytype_int16 const   )164,      (yytype_int16 const   )165, 
        (yytype_int16 const   )127,      (yytype_int16 const   )137,      (yytype_int16 const   )94,      (yytype_int16 const   )105, 
        (yytype_int16 const   )68,      (yytype_int16 const   )106,      (yytype_int16 const   )54};
#line 798 "command.c"
static yytype_int16 const   yypact[203]  = 
#line 798
  {      (yytype_int16 const   )-151,      (yytype_int16 const   )145,      (yytype_int16 const   )-151,      (yytype_int16 const   )-34, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )50,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )10, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-10,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-9,      (yytype_int16 const   )43,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )50,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-8, 
        (yytype_int16 const   )-6,      (yytype_int16 const   )14,      (yytype_int16 const   )12,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )59,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )59, 
        (yytype_int16 const   )13,      (yytype_int16 const   )36,      (yytype_int16 const   )64,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-34,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )24,      (yytype_int16 const   )47,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )13, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )59, 
        (yytype_int16 const   )48,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )80, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )67,      (yytype_int16 const   )47,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )48, 
        (yytype_int16 const   )4,      (yytype_int16 const   )19,      (yytype_int16 const   )69,      (yytype_int16 const   )-20, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-20,      (yytype_int16 const   )-20,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )70,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )16,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )84, 
        (yytype_int16 const   )85,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )73, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )40, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )74,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )48,      (yytype_int16 const   )59,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )74,      (yytype_int16 const   )-151,      (yytype_int16 const   )71,      (yytype_int16 const   )89, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-151,      (yytype_int16 const   )42,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )81, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )92,      (yytype_int16 const   )94, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )86,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )6,      (yytype_int16 const   )96,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-34,      (yytype_int16 const   )75, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )6,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )74,      (yytype_int16 const   )6,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )48,      (yytype_int16 const   )31, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )71,      (yytype_int16 const   )71,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )52,      (yytype_int16 const   )-151,      (yytype_int16 const   )-17,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )69,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )95,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-34,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )17,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )71, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )6,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151};
#line 824 "command.c"
static yytype_int16 const   yypgoto[55]  = 
#line 824
  {      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-119,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )38,      (yytype_int16 const   )-151,      (yytype_int16 const   )-15, 
        (yytype_int16 const   )108,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-90,      (yytype_int16 const   )-151,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-14,      (yytype_int16 const   )-25, 
        (yytype_int16 const   )-151,      (yytype_int16 const   )-151,      (yytype_int16 const   )-150,      (yytype_int16 const   )-26, 
        (yytype_int16 const   )-77,      (yytype_int16 const   )-147,      (yytype_int16 const   )97,      (yytype_int16 const   )-151, 
        (yytype_int16 const   )-5,      (yytype_int16 const   )-151,      (yytype_int16 const   )-3};
#line 838 "command.c"
static yytype_int16 const   yytable[204]  = 
#line 838
  {      (yytype_int16 const   )55,      (yytype_int16 const   )61,      (yytype_int16 const   )76,      (yytype_int16 const   )78, 
        (yytype_int16 const   )132,      (yytype_int16 const   )121,      (yytype_int16 const   )138,      (yytype_int16 const   )174, 
        (yytype_int16 const   )140,      (yytype_int16 const   )141,      (yytype_int16 const   )71,      (yytype_int16 const   )62, 
        (yytype_int16 const   )79,      (yytype_int16 const   )92,      (yytype_int16 const   )62,      (yytype_int16 const   )190, 
        (yytype_int16 const   )189,      (yytype_int16 const   )143,      (yytype_int16 const   )198,      (yytype_int16 const   )122, 
        (yytype_int16 const   )128,      (yytype_int16 const   )129,      (yytype_int16 const   )122,      (yytype_int16 const   )101, 
        (yytype_int16 const   )45,      (yytype_int16 const   )61,      (yytype_int16 const   )194,      (yytype_int16 const   )69, 
        (yytype_int16 const   )72,      (yytype_int16 const   )87,      (yytype_int16 const   )182,      (yytype_int16 const   )89, 
        (yytype_int16 const   )187,      (yytype_int16 const   )95,      (yytype_int16 const   )185,      (yytype_int16 const   )108, 
        (yytype_int16 const   )169,      (yytype_int16 const   )124,      (yytype_int16 const   )115,      (yytype_int16 const   )99, 
        (yytype_int16 const   )124,      (yytype_int16 const   )190,      (yytype_int16 const   )95,      (yytype_int16 const   )122, 
        (yytype_int16 const   )144,      (yytype_int16 const   )110,      (yytype_int16 const   )56,      (yytype_int16 const   )63, 
        (yytype_int16 const   )56,      (yytype_int16 const   )56,      (yytype_int16 const   )112,      (yytype_int16 const   )90, 
        (yytype_int16 const   )202,      (yytype_int16 const   )116,      (yytype_int16 const   )144,      (yytype_int16 const   )145, 
        (yytype_int16 const   )123,      (yytype_int16 const   )129,      (yytype_int16 const   )122,      (yytype_int16 const   )96, 
        (yytype_int16 const   )97,      (yytype_int16 const   )124,      (yytype_int16 const   )117,      (yytype_int16 const   )58, 
        (yytype_int16 const   )-75,      (yytype_int16 const   )58,      (yytype_int16 const   )58,      (yytype_int16 const   )199, 
        (yytype_int16 const   )-127,      (yytype_int16 const   )133,      (yytype_int16 const   )-147,      (yytype_int16 const   )-127, 
        (yytype_int16 const   )102,      (yytype_int16 const   )200,      (yytype_int16 const   )-69,      (yytype_int16 const   )113, 
        (yytype_int16 const   )124,      (yytype_int16 const   )201,      (yytype_int16 const   )192,      (yytype_int16 const   )56, 
        (yytype_int16 const   )73,      (yytype_int16 const   )122,      (yytype_int16 const   )154,      (yytype_int16 const   )114, 
        (yytype_int16 const   )134,      (yytype_int16 const   )135,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )155,      (yytype_int16 const   )103,      (yytype_int16 const   )104,      (yytype_int16 const   )122, 
        (yytype_int16 const   )168,      (yytype_int16 const   )132,      (yytype_int16 const   )123,      (yytype_int16 const   )56, 
        (yytype_int16 const   )74,      (yytype_int16 const   )75,      (yytype_int16 const   )157,      (yytype_int16 const   )124, 
        (yytype_int16 const   )56,      (yytype_int16 const   )107,      (yytype_int16 const   )118,      (yytype_int16 const   )58, 
        (yytype_int16 const   )123,      (yytype_int16 const   )160,      (yytype_int16 const   )161,      (yytype_int16 const   )133, 
        (yytype_int16 const   )158,      (yytype_int16 const   )124,      (yytype_int16 const   )56,      (yytype_int16 const   )156, 
        (yytype_int16 const   )58,      (yytype_int16 const   )159,      (yytype_int16 const   )180,      (yytype_int16 const   )162, 
        (yytype_int16 const   )119,      (yytype_int16 const   )58,      (yytype_int16 const   )120,      (yytype_int16 const   )142, 
        (yytype_int16 const   )150,      (yytype_int16 const   )151,      (yytype_int16 const   )134,      (yytype_int16 const   )135, 
        (yytype_int16 const   )152,      (yytype_int16 const   )181,      (yytype_int16 const   )163,      (yytype_int16 const   )58, 
        (yytype_int16 const   )166,      (yytype_int16 const   )167,      (yytype_int16 const   )171,      (yytype_int16 const   )170, 
        (yytype_int16 const   )172,      (yytype_int16 const   )178,      (yytype_int16 const   )195,      (yytype_int16 const   )173, 
        (yytype_int16 const   )148,      (yytype_int16 const   )183,      (yytype_int16 const   )84,      (yytype_int16 const   )193, 
        (yytype_int16 const   )191,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )179, 
        (yytype_int16 const   )100,      (yytype_int16 const   )2,      (yytype_int16 const   )3,      (yytype_int16 const   )184, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )197, 
        (yytype_int16 const   )0,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )45};
#line 869 "command.c"
static yytype_int16 const   yycheck[204]  = 
#line 869
  {      (yytype_int16 const   )3,      (yytype_int16 const   )6,      (yytype_int16 const   )17,      (yytype_int16 const   )17, 
        (yytype_int16 const   )81,      (yytype_int16 const   )1,      (yytype_int16 const   )83,      (yytype_int16 const   )1, 
        (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )15,      (yytype_int16 const   )1, 
        (yytype_int16 const   )17,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )165, 
        (yytype_int16 const   )163,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )39, 
        (yytype_int16 const   )1,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )48, 
        (yytype_int16 const   )58,      (yytype_int16 const   )30,      (yytype_int16 const   )173,      (yytype_int16 const   )37, 
        (yytype_int16 const   )37,      (yytype_int16 const   )37,      (yytype_int16 const   )149,      (yytype_int16 const   )37, 
        (yytype_int16 const   )1,      (yytype_int16 const   )38,      (yytype_int16 const   )153,      (yytype_int16 const   )50, 
        (yytype_int16 const   )126,      (yytype_int16 const   )57,      (yytype_int16 const   )63,      (yytype_int16 const   )44, 
        (yytype_int16 const   )57,      (yytype_int16 const   )191,      (yytype_int16 const   )47,      (yytype_int16 const   )39, 
        (yytype_int16 const   )38,      (yytype_int16 const   )50,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )36,      (yytype_int16 const   )36,      (yytype_int16 const   )53,      (yytype_int16 const   )37, 
        (yytype_int16 const   )199,      (yytype_int16 const   )67,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )52,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )37, 
        (yytype_int16 const   )37,      (yytype_int16 const   )57,      (yytype_int16 const   )67,      (yytype_int16 const   )53, 
        (yytype_int16 const   )58,      (yytype_int16 const   )53,      (yytype_int16 const   )53,      (yytype_int16 const   )50, 
        (yytype_int16 const   )58,      (yytype_int16 const   )38,      (yytype_int16 const   )58,      (yytype_int16 const   )58, 
        (yytype_int16 const   )36,      (yytype_int16 const   )56,      (yytype_int16 const   )58,      (yytype_int16 const   )51, 
        (yytype_int16 const   )57,      (yytype_int16 const   )196,      (yytype_int16 const   )168,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )39,      (yytype_int16 const   )42,      (yytype_int16 const   )36, 
        (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )48,      (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )39, 
        (yytype_int16 const   )50,      (yytype_int16 const   )170,      (yytype_int16 const   )52,      (yytype_int16 const   )36, 
        (yytype_int16 const   )53,      (yytype_int16 const   )54,      (yytype_int16 const   )113,      (yytype_int16 const   )57, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )54,      (yytype_int16 const   )53, 
        (yytype_int16 const   )52,      (yytype_int16 const   )120,      (yytype_int16 const   )120,      (yytype_int16 const   )38, 
        (yytype_int16 const   )113,      (yytype_int16 const   )57,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )53,      (yytype_int16 const   )118,      (yytype_int16 const   )39,      (yytype_int16 const   )120, 
        (yytype_int16 const   )36,      (yytype_int16 const   )53,      (yytype_int16 const   )51,      (yytype_int16 const   )49, 
        (yytype_int16 const   )36,      (yytype_int16 const   )36,      (yytype_int16 const   )53,      (yytype_int16 const   )54, 
        (yytype_int16 const   )51,      (yytype_int16 const   )50,      (yytype_int16 const   )55,      (yytype_int16 const   )53, 
        (yytype_int16 const   )39,      (yytype_int16 const   )38,      (yytype_int16 const   )38,      (yytype_int16 const   )50, 
        (yytype_int16 const   )38,      (yytype_int16 const   )37,      (yytype_int16 const   )39,      (yytype_int16 const   )49, 
        (yytype_int16 const   )98,      (yytype_int16 const   )152,      (yytype_int16 const   )30,      (yytype_int16 const   )170, 
        (yytype_int16 const   )166,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )146, 
        (yytype_int16 const   )47,      (yytype_int16 const   )0,      (yytype_int16 const   )1,      (yytype_int16 const   )152, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30, 
        (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34, 
        (yytype_int16 const   )35,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )186, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42, 
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46, 
        (yytype_int16 const   )47,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )58};
#line 896 "command.c"
static yytype_uint8 const   yystos[203]  = 
#line 896
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )60,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )58,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )113,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )53,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )111,      (yytype_uint8 const   )1,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )111,      (yytype_uint8 const   )37,      (yytype_uint8 const   )94,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )100,      (yytype_uint8 const   )101,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )75,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )80,      (yytype_uint8 const   )109,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )66,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )102,      (yytype_uint8 const   )36,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )110,      (yytype_uint8 const   )112,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )88,      (yytype_uint8 const   )111,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )51,      (yytype_uint8 const   )36,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )111,      (yytype_uint8 const   )54,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )1,      (yytype_uint8 const   )39,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )96,      (yytype_uint8 const   )97,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )38,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )108,      (yytype_uint8 const   )107,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )49,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )78,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )89,      (yytype_uint8 const   )42,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )86,      (yytype_uint8 const   )111,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )101,      (yytype_uint8 const   )111,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )39,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )96,      (yytype_uint8 const   )50,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )49,      (yytype_uint8 const   )1,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )37,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )50,      (yytype_uint8 const   )79,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )111,      (yytype_uint8 const   )79,      (yytype_uint8 const   )69,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )108,      (yytype_uint8 const   )105,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )96,      (yytype_uint8 const   )98,      (yytype_uint8 const   )108,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )113,      (yytype_uint8 const   )1,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )79,      (yytype_uint8 const   )108};
#line 1410 "command.c"
static void yydestruct(char const   *yymsg , int yytype , CMDARG **yyvaluep ) 
{ 
  char *__cil_tmp4 ;

  {
#line 1422
  if (! yymsg) {
#line 1423
    yymsg = "Deleting";
  }
#line 1427
  return;
}
}
#line 1433 "command.c"
int zzchar  ;
#line 1448 "command.c"
int zznerrs  ;
#line 1468 "command.c"
int zzparse(void) 
{ 
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  CMDARG *yyvsa[200] ;
  CMDARG **yyvs ;
  CMDARG **yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  CMDARG *yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp___1 ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  int (*cmdfunc)(CMDARG * , int  ) ;
  _Bool terminate ;
  CMDARG *args ;
  int ctype ;
  int tmp___2 ;
  char *tmp___3 ;
  char *str ;
  size_t len ;
  size_t tmp___4 ;
  NODE *n ;
  CMDARG *arg ;
  char *tmp___5 ;
  int idx___3 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int type ;
  int num ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int idx___4 ;
  int tmp___19 ;
  char *tmp___20 ;
  int type___0 ;
  int num___0 ;
  char *tmp___21 ;
  CMDARG *arg___0 ;
  NODE *n___0 ;
  NODE *n___1 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  NODE *n___2 ;
  char *tmp___27 ;
  int idx___5 ;
  int tmp___28 ;
  char *tmp___29 ;
  CMDARG *a ;
  char *tmp___30 ;
  CMDARG *a___0 ;
  NODE *subs ;
  int count ;
  NODE *n___3 ;
  char *tmp___31 ;
  NODE *n___4 ;
  char *tmp___32 ;
  NODE *n___5 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  void *__cil_tmp82 ;
  void *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;

  {
#line 1503
  yytoken = 0;
#line 1519
  yylen = 0;
#line 1521
  yyss = yyssa;
#line 1521
  yyssp = yyss;
#line 1522
  yyvs = yyvsa;
#line 1522
  yyvsp = yyvs;
#line 1523
  yystacksize = 200UL;
#line 1527
  yystate = 0;
#line 1528
  yyerrstatus = 0;
#line 1529
  zznerrs = 0;
#line 1530
  zzchar = -2;
#line 1531
  goto yysetstate;
  yynewstate: 
#line 1539
  yyssp ++;
  yysetstate: 
#line 1542
  *yyssp = (yytype_int16 )yystate;
#line 1544
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1547
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1574
    if (10000UL <= yystacksize) {
#line 1575
      goto yyexhaustedlab;
    }
#line 1576
    yystacksize *= 2UL;
#line 1577
    if (10000UL < yystacksize) {
#line 1578
      yystacksize = 10000UL;
    }
    {
#line 1581
    yyss1 = yyss;
#line 1582
    tmp___1 = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(CMDARG *)) + (sizeof(union yyalloc ) - 1UL));
#line 1582
    yyptr = (union yyalloc *)tmp___1;
    }
#line 1584
    if (! yyptr) {
#line 1585
      goto yyexhaustedlab;
    }
    {
#line 1586
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1586
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1586
      yyss = & yyptr->yyss_alloc;
#line 1586
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1586
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1586
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1587
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1587
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1587
      yyvs = & yyptr->yyvs_alloc;
#line 1587
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1587
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1587
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1589
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1590
      free((void *)yyss1);
      }
    }
#line 1595
    yyssp = (yyss + yysize) - 1;
#line 1596
    yyvsp = (yyvs + yysize) - 1;
#line 1601
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1602
      goto yyabortlab;
    }
  }
#line 1607
  if (yystate == 2) {
#line 1608
    goto yyacceptlab;
  }
#line 1610
  goto yybackup;
  yybackup: 
#line 1621
  yyn = (int )yypact[yystate];
#line 1622
  if (! (! (yyn == -151))) {
#line 1623
    goto yydefault;
  }
#line 1628
  if (zzchar == -2) {
    {
#line 1631
    zzchar = zzlex();
    }
  }
#line 1634
  if (zzchar <= 0) {
#line 1636
    yytoken = 0;
#line 1636
    zzchar = yytoken;
  } else
#line 1641
  if ((unsigned int )zzchar <= 303U) {
#line 1641
    yytoken = (int )yytranslate[zzchar];
  } else {
#line 1641
    yytoken = 2;
  }
#line 1647
  yyn += yytoken;
#line 1648
  if (yyn < 0) {
#line 1649
    goto yydefault;
  } else
#line 1648
  if (203 < yyn) {
#line 1649
    goto yydefault;
  } else
#line 1648
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1649
    goto yydefault;
  }
#line 1650
  yyn = (int )yytable[yyn];
#line 1651
  if (yyn <= 0) {
#line 1655
    yyn = - yyn;
#line 1656
    goto yyreduce;
  }
#line 1661
  if (yyerrstatus) {
#line 1662
    yyerrstatus --;
  }
#line 1668
  zzchar = -2;
#line 1670
  yystate = yyn;
#line 1672
  yyvsp ++;
#line 1672
  *yyvsp = zzlval;
#line 1675
  goto yynewstate;
  yydefault: 
#line 1682
  yyn = (int )yydefact[yystate];
#line 1683
  if (yyn == 0) {
#line 1684
    goto yyerrlab;
  }
#line 1685
  goto yyreduce;
  yyreduce: 
#line 1693
  yylen = (int )yyr2[yyn];
#line 1703
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1709
  if (yyn == 3) {
#line 1709
    goto case_3;
  }
#line 125
  if (yyn == 5) {
#line 125 "command.y"
    goto case_5;
  }
#line 179
  if (yyn == 6) {
#line 179
    goto case_6;
  }
#line 183
  if (yyn == 22) {
#line 183
    goto case_22;
  }
#line 215
  if (yyn == 23) {
#line 215
    goto case_23;
  }
#line 234
  if (yyn == 24) {
#line 234
    goto case_24;
  }
#line 245
  if (yyn == 25) {
#line 245
    goto case_25;
  }
#line 246
  if (yyn == 26) {
#line 246
    goto case_26;
  }
#line 249
  if (yyn == 27) {
#line 249
    goto case_27;
  }
#line 268
  if (yyn == 28) {
#line 268
    goto case_28;
  }
#line 279
  if (yyn == 34) {
#line 279
    goto case_34;
  }
#line 293
  if (yyn == 35) {
#line 293
    goto case_35;
  }
#line 305
  if (yyn == 38) {
#line 305
    goto case_38;
  }
#line 308
  if (yyn == 40) {
#line 308
    goto case_40;
  }
#line 309
  if (yyn == 46) {
#line 309
    goto case_46;
  }
#line 314
  if (yyn == 49) {
#line 314
    goto case_49;
  }
#line 316
  if (yyn == 51) {
#line 316
    goto case_51;
  }
#line 317
  if (yyn == 53) {
#line 317
    goto case_53;
  }
#line 318
  if (yyn == 57) {
#line 318
    goto case_57;
  }
#line 325
  if (yyn == 58) {
#line 325
    goto case_58;
  }
#line 330
  if (yyn == 59) {
#line 330
    goto case_59;
  }
#line 356
  if (yyn == 60) {
#line 356
    goto case_60;
  }
#line 366
  if (yyn == 61) {
#line 366
    goto case_61;
  }
#line 371
  if (yyn == 62) {
#line 371
    goto case_62;
  }
#line 383
  if (yyn == 63) {
#line 383
    goto case_63;
  }
#line 384
  if (yyn == 64) {
#line 384
    goto case_64;
  }
#line 391
  if (yyn == 65) {
#line 391
    goto case_65;
  }
#line 402
  if (yyn == 66) {
#line 402
    goto case_66;
  }
#line 415
  if (yyn == 68) {
#line 415
    goto case_68;
  }
#line 421
  if (yyn == 69) {
#line 421
    goto case_69;
  }
#line 426
  if (yyn == 74) {
#line 426
    goto case_74;
  }
#line 435
  if (yyn == 75) {
#line 435
    goto case_75;
  }
#line 440
  if (yyn == 77) {
#line 440
    goto case_77;
  }
#line 443
  if (yyn == 78) {
#line 443
    goto case_78;
  }
#line 453
  if (yyn == 79) {
#line 453
    goto case_79;
  }
#line 458
  if (yyn == 80) {
#line 458
    goto case_80;
  }
#line 463
  if (yyn == 81) {
#line 463
    goto case_81;
  }
#line 468
  if (yyn == 82) {
#line 468
    goto case_82;
  }
#line 484
  if (yyn == 83) {
#line 484
    goto case_83;
  }
#line 489
  if (yyn == 88) {
#line 489
    goto case_88;
  }
#line 498
  if (yyn == 89) {
#line 498
    goto case_89;
  }
#line 499
  if (yyn == 92) {
#line 499
    goto case_92;
  }
#line 501
  if (yyn == 95) {
#line 501
    goto case_95;
  }
#line 507
  if (yyn == 97) {
#line 507
    goto case_97;
  }
#line 513
  if (yyn == 99) {
#line 513
    goto case_99;
  }
#line 519
  if (yyn == 104) {
#line 519
    goto case_104;
  }
#line 541
  if (yyn == 106) {
#line 541
    goto case_106;
  }
#line 550
  if (yyn == 107) {
#line 550
    goto case_107;
  }
#line 555
  if (yyn == 117) {
#line 555
    goto case_117;
  }
#line 578
  if (yyn == 118) {
#line 578
    goto case_118;
  }
#line 580
  if (yyn == 119) {
#line 580
    goto case_119;
  }
#line 587
  if (yyn == 126) {
#line 587
    goto case_126;
  }
#line 605
  if (yyn == 127) {
#line 605
    goto case_127;
  }
#line 610
  if (yyn == 134) {
#line 610
    goto case_134;
  }
#line 624
  if (yyn == 135) {
#line 624
    goto case_135;
  }
#line 626
  if (yyn == 137) {
#line 626
    goto case_137;
  }
#line 645
  if (yyn == 139) {
#line 645
    goto case_139;
  }
#line 651
  if (yyn == 140) {
#line 651
    goto case_140;
  }
#line 653
  if (yyn == 142) {
#line 653
    goto case_142;
  }
#line 666
  if (yyn == 143) {
#line 666
    goto case_143;
  }
#line 673
  if (yyn == 144) {
#line 673
    goto case_144;
  }
#line 678
  if (yyn == 145) {
#line 678
    goto case_145;
  }
#line 685
  if (yyn == 146) {
#line 685
    goto case_146;
  }
#line 694
  if (yyn == 147) {
#line 694
    goto case_147;
  }
#line 699
  if (yyn == 148) {
#line 699
    goto case_148;
  }
#line 701
  if (yyn == 149) {
#line 701
    goto case_149;
  }
#line 706
  if (yyn == 150) {
#line 706
    goto case_150;
  }
#line 708
  if (yyn == 151) {
#line 708
    goto case_151;
  }
#line 717
  if (yyn == 152) {
#line 717
    goto case_152;
  }
#line 723
  if (yyn == 153) {
#line 723
    goto case_153;
  }
#line 728
  if (yyn == 154) {
#line 728
    goto case_154;
  }
#line 730
  if (yyn == 155) {
#line 730
    goto case_155;
  }
#line 735
  if (yyn == 156) {
#line 735
    goto case_156;
  }
#line 2451 "command.c"
  goto switch_default;
  case_3: /* CIL Label */ 
#line 110 "command.y"
  cmd_idx = -1;
#line 111
  want_nodeval = (_Bool)0;
#line 112
  if ((unsigned long )lexptr_begin != (unsigned long )((void *)0)) {
#line 113
    if (input_from_tty) {
#line 113
      if ((int )*(lexptr_begin + 0) != 0) {
        {
#line 114
        add_history((char const   *)lexptr_begin);
        }
      }
    }
    {
#line 115
    free((void *)lexptr_begin);
#line 116
    lexptr_begin = (char *)((void *)0);
    }
  }
#line 118
  if ((unsigned long )arg_list != (unsigned long )((void *)0)) {
    {
#line 119
    free_cmdarg(arg_list);
#line 120
    arg_list = (CMDARG *)((void *)0);
    }
  }
#line 123
  goto switch_break;
  case_5: /* CIL Label */ 
#line 129
  if (errcount == 0L) {
#line 129
    if (cmd_idx >= 0) {
#line 131
      terminate = (_Bool)0;
#line 133
      ctype = 0;
#line 135
      ctype = (int )zz_debug_cmdtab[cmd_idx].type;
#line 141
      if (ctype == 20) {
#line 141
        goto _L;
      } else
#line 141
      if (ctype == 21) {
#line 141
        goto _L;
      } else
#line 141
      if (ctype == 33) {
#line 141
        goto _L;
      } else
#line 141
      if (ctype == 22) {
#line 141
        goto _L;
      } else
#line 141
      if (ctype == 34) {
#line 141
        goto _L;
      } else
#line 141
      if (ctype == 6) {
        _L: /* CIL Label */ 
#line 141
        if ((unsigned long )arg_list == (unsigned long )((void *)0)) {
#line 141
          if (! in_commands) {
#line 141
            if (input_from_tty) {
#line 151
              repeat_idx = cmd_idx;
            } else {
#line 153
              repeat_idx = -1;
            }
          } else {
#line 153
            repeat_idx = -1;
          }
        } else {
#line 153
          repeat_idx = -1;
        }
      } else {
#line 153
        repeat_idx = -1;
      }
#line 161
      cmdfunc = zz_debug_cmdtab[cmd_idx].cf_ptr;
#line 162
      if (in_commands) {
#line 163
        cmdfunc = & do_commands;
      }
      {
#line 164
      cmd_idx = -1;
#line 165
      want_nodeval = (_Bool)0;
#line 167
      args = arg_list;
#line 168
      arg_list = (CMDARG *)((void *)0);
#line 170
      tmp___2 = (*cmdfunc)(args, ctype);
#line 170
      terminate = (_Bool )tmp___2;
      }
#line 171
      if (! in_commands) {
        {
#line 172
        free_cmdarg(args);
        }
      } else
#line 171
      if (ctype == 4) {
        {
#line 172
        free_cmdarg(args);
        }
      }
#line 173
      if (terminate) {
#line 174
        goto yyacceptlab;
      }
    }
  }
#line 177
  goto switch_break;
  case_6: /* CIL Label */ 
#line 179
  yyerrstatus = 0;
#line 181
  goto switch_break;
  case_22: /* CIL Label */ 
#line 212
  want_nodeval = (_Bool)1;
#line 213
  goto switch_break;
  case_23: /* CIL Label */ 
#line 218
  if (errcount == 0L) {
#line 222
    if (input_from_tty) {
      {
#line 223
      dbg_prompt = eval_prompt;
#line 224
      tmp___3 = gettext("Type (g)awk statement(s). End with the command \"end\"\n");
#line 224
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___3);
#line 226
      rl_inhibit_completion = 1;
      }
    }
#line 228
    cmd_idx = -1;
#line 229
    in_eval = (_Bool)1;
  }
#line 232
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 237
  yyval = append_statement(arg_list, (char *)(start_EVAL));
  }
#line 238
  if ((unsigned long )read_a_line == (unsigned long )(& read_commands_string)) {
#line 239
    *(yyval->value.sval + 0) = (char )'\000';
  }
  {
#line 240
  free_cmdarg(arg_list);
#line 241
  arg_list = (CMDARG *)((void *)0);
  }
#line 243
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 243
  yyval = append_statement(*(yyvsp + -1), lexptr_begin);
  }
#line 244
  goto switch_break;
  case_26: /* CIL Label */ 
#line 245
  yyval = *(yyvsp + -1);
#line 247
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 252
  arg_list = append_statement(*(yyvsp + -1), (char *)(end_EVAL));
  }
#line 253
  if ((unsigned long )read_a_line == (unsigned long )(& read_commands_string)) {
    {
#line 254
    str = arg_list->value.sval;
#line 255
    tmp___4 = strlen((char const   *)str);
#line 255
    len = tmp___4;
#line 257
    *(str + (len - 2UL)) = (char )'\000';
    }
  }
#line 259
  if (input_from_tty) {
#line 260
    if (in_commands) {
#line 260
      dbg_prompt = commands_prompt;
    } else {
#line 260
      dbg_prompt = dgawk_prompt;
    }
#line 261
    rl_inhibit_completion = 0;
  }
  {
#line 263
  cmd_idx = find_command("eval", (size_t )4);
#line 264
  in_eval = (_Bool)0;
  }
#line 266
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 270
  n = (*(yyvsp + 0))->value.nodeval;
#line 271
  arg = append_statement((CMDARG *)((void *)0), (char *)(start_EVAL));
#line 272
  append_statement(arg, n->sub.val.sp);
#line 273
  append_statement(arg, (char *)(end_EVAL));
#line 274
  free_cmdarg(arg_list);
#line 275
  arg_list = arg;
  }
#line 277
  goto switch_break;
  case_34: /* CIL Label */ 
#line 287
  if (zz_debug_cmdtab[cmd_idx].class == 267) {
#line 287
    if ((unsigned long )*(yyvsp + 0) != (unsigned long )((void *)0)) {
#line 287
      if ((*(yyvsp + 0))->value.lval < 0L) {
        {
#line 289
        tmp___5 = gettext("invalid frame number: %d");
#line 289
        zzerror((char const   *)tmp___5, (*(yyvsp + 0))->value.lval);
        }
      }
    }
  }
#line 291
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 293
  tmp___6 = find_argument(*(yyvsp + 0));
#line 293
  idx___3 = tmp___6;
  }
#line 294
  if (idx___3 < 0) {
    {
#line 295
    tmp___7 = gettext("info: invalid option - \"%s\"");
#line 295
    zzerror((char const   *)tmp___7, (*(yyvsp + 0))->value.sval);
    }
  } else {
    {
#line 297
    free((void *)(*(yyvsp + 0))->value.sval);
#line 298
    (*(yyvsp + 0))->value.sval = (char *)((void *)0);
#line 299
    (*(yyvsp + 0))->type = (enum argtype )42;
#line 300
    (*(yyvsp + 0))->value.lval = (long )zz_debug_argtab[idx___3].value;
    }
  }
#line 303
  goto switch_break;
  case_38: /* CIL Label */ 
#line 305
  want_nodeval = (_Bool)1;
#line 306
  goto switch_break;
  case_40: /* CIL Label */ 
#line 306
  want_nodeval = (_Bool)1;
#line 307
  goto switch_break;
  case_46: /* CIL Label */ 
#line 311
  want_nodeval = (_Bool)1;
#line 312
  goto switch_break;
  case_49: /* CIL Label */ 
#line 313
  want_nodeval = (_Bool)1;
#line 314
  goto switch_break;
  case_51: /* CIL Label */ 
#line 314
  want_nodeval = (_Bool)1;
#line 315
  goto switch_break;
  case_53: /* CIL Label */ 
#line 315
  want_nodeval = (_Bool)1;
#line 316
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 320
  tmp___9 = in_cmd_src((char const   *)(*(yyvsp + 0))->value.sval);
  }
#line 320
  if (tmp___9) {
    {
#line 321
    tmp___8 = gettext("source \"%s\": already sourced.");
#line 321
    zzerror((char const   *)tmp___8, (*(yyvsp + 0))->value.sval);
    }
  }
#line 323
  goto switch_break;
  case_58: /* CIL Label */ 
#line 325
  if (! input_from_tty) {
    {
#line 326
    tmp___10 = gettext("save \"%s\": command not permitted.");
#line 326
    zzerror((char const   *)tmp___10, (*(yyvsp + 0))->value.sval);
    }
  }
#line 328
  goto switch_break;
  case_59: /* CIL Label */ 
#line 330
  type = 0;
#line 333
  if ((unsigned long )*(yyvsp + 0) != (unsigned long )((void *)0)) {
#line 334
    num = (int )(*(yyvsp + 0))->value.lval;
  }
#line 336
  if (! (errcount != 0L)) {
#line 338
    if (in_commands) {
      {
#line 339
      tmp___11 = gettext("Can\'t use command `commands\' for breakpoint/watchpoint commands");
#line 339
      zzerror((char const   *)tmp___11);
      }
    } else
#line 340
    if ((unsigned long )*(yyvsp + 0) == (unsigned long )((void *)0)) {
      {
#line 340
      type = has_break_or_watch_point(& num, (_Bool)1);
      }
#line 340
      if (type) {
#line 340
        goto _L___0;
      } else {
        {
#line 341
        tmp___12 = gettext("no breakpoint/watchpoint has been set yet");
#line 341
        zzerror((char const   *)tmp___12);
        }
      }
    } else
    _L___0: /* CIL Label */ 
#line 342
    if ((unsigned long )*(yyvsp + 0) != (unsigned long )((void *)0)) {
      {
#line 342
      type = has_break_or_watch_point(& num, (_Bool)0);
      }
#line 342
      if (! type) {
        {
#line 343
        tmp___13 = gettext("invalid breakpoint/watchpoint number");
#line 343
        zzerror((char const   *)tmp___13);
        }
      }
    }
  }
#line 344
  if (type) {
#line 345
    in_commands = (_Bool)1;
#line 346
    if (input_from_tty) {
#line 347
      dbg_prompt = commands_prompt;
#line 348
      if (type == 2) {
#line 348
        tmp___14 = "breakpoint";
      } else {
#line 348
        tmp___14 = "watchpoint";
      }
      {
#line 348
      tmp___15 = gettext("Type commands for when %s %d is hit, one per line.\n");
#line 348
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___15,
              tmp___14, num);
#line 350
      tmp___16 = gettext("End with the command \"end\"\n");
#line 350
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___16);
      }
    }
  }
#line 354
  goto switch_break;
  case_60: /* CIL Label */ 
#line 356
  if (! in_commands) {
    {
#line 357
    tmp___17 = gettext("`end\' valid only in command `commands\' or `eval\'");
#line 357
    zzerror((char const   *)tmp___17);
    }
  } else {
#line 359
    if (input_from_tty) {
#line 360
      dbg_prompt = dgawk_prompt;
    }
#line 361
    in_commands = (_Bool)0;
  }
#line 364
  goto switch_break;
  case_61: /* CIL Label */ 
#line 366
  if (! in_commands) {
    {
#line 367
    tmp___18 = gettext("`silent\' valid only in command `commands\'");
#line 367
    zzerror((char const   *)tmp___18);
    }
  }
#line 369
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 371
  tmp___19 = find_argument(*(yyvsp + 0));
#line 371
  idx___4 = tmp___19;
  }
#line 372
  if (idx___4 < 0) {
    {
#line 373
    tmp___20 = gettext("trace: invalid option - \"%s\"");
#line 373
    zzerror((char const   *)tmp___20, (*(yyvsp + 0))->value.sval);
    }
  } else {
    {
#line 375
    free((void *)(*(yyvsp + 0))->value.sval);
#line 376
    (*(yyvsp + 0))->value.sval = (char *)((void *)0);
#line 377
    (*(yyvsp + 0))->type = (enum argtype )42;
#line 378
    (*(yyvsp + 0))->value.lval = (long )zz_debug_argtab[idx___4].value;
    }
  }
#line 381
  goto switch_break;
  case_63: /* CIL Label */ 
#line 381
  want_nodeval = (_Bool)1;
#line 382
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 384
  num___0 = (int )(*(yyvsp + -2))->value.lval;
#line 385
  type___0 = has_break_or_watch_point(& num___0, (_Bool)0);
  }
#line 386
  if (! type___0) {
    {
#line 387
    tmp___21 = gettext("condition: invalid breakpoint/watchpoint number");
#line 387
    zzerror((char const   *)tmp___21);
    }
  }
#line 389
  goto switch_break;
  case_65: /* CIL Label */ 
#line 391
  if (in_commands) {
    {
#line 394
    arg___0 = mk_cmdarg((enum argtype )44);
#line 395
    arg___0->value.sval = estrdup("eval", (size_t )4);
#line 396
    arg___0->next = arg_list;
#line 397
    arg_list = arg___0;
    }
  }
#line 400
  goto switch_break;
  case_66: /* CIL Label */ 
#line 405
  if ((unsigned long )*(yyvsp + 0) != (unsigned long )((void *)0)) {
#line 406
    n___0 = (*(yyvsp + 0))->value.nodeval;
#line 407
    (*(yyvsp + 0))->type = (enum argtype )44;
#line 408
    (*(yyvsp + 0))->value.sval = n___0->sub.val.sp;
#line 409
    ((BLOCK *)n___0)->freep = nextfree[1].freep;
#line 409
    nextfree[1].freep = (BLOCK *)n___0;
  }
#line 411
  yyval = *(yyvsp + 0);
#line 413
  goto switch_break;
  case_68: /* CIL Label */ 
#line 418
  yyval = (CMDARG *)((void *)0);
#line 419
  goto switch_break;
  case_69: /* CIL Label */ 
#line 423
  yyval = (CMDARG *)((void *)0);
#line 424
  goto switch_break;
  case_74: /* CIL Label */ 
#line 432
  yyval = (CMDARG *)((void *)0);
#line 433
  goto switch_break;
  case_75: /* CIL Label */ 
#line 437
  yyval = (CMDARG *)((void *)0);
#line 438
  goto switch_break;
  case_77: /* CIL Label */ 
#line 440
  yyval = (CMDARG *)((void *)0);
#line 441
  goto switch_break;
  case_78: /* CIL Label */ 
#line 447
  n___1 = (*(yyvsp + 0))->value.nodeval;
#line 448
  if ((n___1->flags & 2U) == 0U) {
    {
#line 449
    tmp___22 = gettext("argument not a string");
#line 449
    zzerror((char const   *)tmp___22);
    }
  }
#line 451
  goto switch_break;
  case_79: /* CIL Label */ 
#line 455
  yyval = (CMDARG *)((void *)0);
#line 456
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 458
  tmp___24 = find_option((*(yyvsp + 0))->value.sval);
  }
#line 458
  if (tmp___24 < 0) {
    {
#line 459
    tmp___23 = gettext("option: invalid parameter - \"%s\"");
#line 459
    zzerror((char const   *)tmp___23, (*(yyvsp + 0))->value.sval);
    }
  }
#line 461
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 463
  tmp___26 = find_option((*(yyvsp + -2))->value.sval);
  }
#line 463
  if (tmp___26 < 0) {
    {
#line 464
    tmp___25 = gettext("option: invalid parameter - \"%s\"");
#line 464
    zzerror((char const   *)tmp___25, (*(yyvsp + -2))->value.sval);
    }
  }
#line 466
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 472
  n___2 = lookup((char const   *)(*(yyvsp + 0))->value.sval);
  }
#line 473
  if ((unsigned long )n___2 == (unsigned long )((void *)0)) {
    {
#line 474
    tmp___27 = gettext("no such function - \"%s\"");
#line 474
    zzerror((char const   *)tmp___27, (*(yyvsp + 0))->value.sval);
    }
  } else
#line 473
  if ((unsigned int )n___2->type != 8U) {
    {
#line 474
    tmp___27 = gettext("no such function - \"%s\"");
#line 474
    zzerror((char const   *)tmp___27, (*(yyvsp + 0))->value.sval);
    }
  } else {
    {
#line 476
    (*(yyvsp + 0))->type = (enum argtype )50;
#line 477
    free((void *)(*(yyvsp + 0))->value.sval);
#line 478
    (*(yyvsp + 0))->value.sval = (char *)((void *)0);
#line 479
    (*(yyvsp + 0))->value.nodeval = n___2;
    }
  }
#line 482
  goto switch_break;
  case_83: /* CIL Label */ 
#line 486
  yyval = (CMDARG *)((void *)0);
#line 487
  goto switch_break;
  case_88: /* CIL Label */ 
#line 495
  yyval = (CMDARG *)((void *)0);
#line 496
  goto switch_break;
  case_89: /* CIL Label */ 
#line 496
  want_nodeval = (_Bool)1;
#line 497
  goto switch_break;
  case_92: /* CIL Label */ 
#line 498
  want_nodeval = (_Bool)1;
#line 499
  goto switch_break;
  case_95: /* CIL Label */ 
#line 504
  yyval = (CMDARG *)((void *)0);
#line 505
  goto switch_break;
  case_97: /* CIL Label */ 
#line 510
  yyval = (CMDARG *)((void *)0);
#line 511
  goto switch_break;
  case_99: /* CIL Label */ 
#line 516
  yyval = (CMDARG *)((void *)0);
#line 517
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 529
  tmp___28 = find_argument(*(yyvsp + -1));
#line 529
  idx___5 = tmp___28;
  }
#line 530
  if (idx___5 < 0) {
    {
#line 531
    tmp___29 = gettext("enable: invalid option - \"%s\"");
#line 531
    zzerror((char const   *)tmp___29, (*(yyvsp + -1))->value.sval);
    }
  } else {
    {
#line 533
    free((void *)(*(yyvsp + -1))->value.sval);
#line 534
    (*(yyvsp + -1))->value.sval = (char *)((void *)0);
#line 535
    (*(yyvsp + -1))->type = (enum argtype )42;
#line 536
    (*(yyvsp + -1))->value.lval = (long )zz_debug_argtab[idx___5].value;
    }
  }
#line 539
  goto switch_break;
  case_106: /* CIL Label */ 
#line 545
  (*(yyvsp + 0))->type = (enum argtype )48;
#line 546
  (*(yyvsp + 0))->a_count = 0;
#line 548
  goto switch_break;
  case_107: /* CIL Label */ 
#line 550
  (*(yyvsp + -1))->type = (enum argtype )48;
#line 551
  (*(yyvsp + -1))->a_count = num_dim;
#line 553
  goto switch_break;
  case_117: /* CIL Label */ 
#line 575
  yyval = (CMDARG *)((void *)0);
#line 576
  goto switch_break;
  case_118: /* CIL Label */ 
#line 577
  yyval = (CMDARG *)((void *)0);
#line 578
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 581
  a = mk_cmdarg((enum argtype )43);
#line 582
  a->value.lval = -1L;
#line 583
  append_cmdarg(a);
  }
#line 585
  goto switch_break;
  case_126: /* CIL Label */ 
#line 596
  if ((*(yyvsp + -2))->value.lval > (*(yyvsp + 0))->value.lval) {
    {
#line 597
    tmp___30 = gettext("invalid range specification: %d - %d");
#line 597
    zzerror((char const   *)tmp___30, (*(yyvsp + -2))->value.lval, (*(yyvsp + 0))->value.lval);
    }
  } else {
#line 600
    (*(yyvsp + -2))->type = (enum argtype )51;
  }
#line 601
  yyval = *(yyvsp + -2);
#line 603
  goto switch_break;
  case_127: /* CIL Label */ 
#line 607
  yyval = (CMDARG *)((void *)0);
#line 608
  goto switch_break;
  case_134: /* CIL Label */ 
#line 621
  yyval = *(yyvsp + 0);
#line 622
  goto switch_break;
  case_135: /* CIL Label */ 
#line 623
  yyval = *(yyvsp + -2);
#line 624
  goto switch_break;
  case_137: /* CIL Label */ 
#line 632
  count = 0;
#line 634
  a___0 = *(yyvsp + -1);
  {
#line 634
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 634
    if (! ((unsigned long )a___0 != (unsigned long )((void *)0))) {
#line 634
      goto while_break___1;
    }
#line 635
    count ++;
#line 634
    a___0 = a___0->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 636
  subs = concat_args(*(yyvsp + -1), count);
#line 637
  free_cmdarg((*(yyvsp + -1))->next);
#line 638
  (*(yyvsp + -1))->next = (struct cmd_argument *)((void *)0);
#line 639
  (*(yyvsp + -1))->type = (enum argtype )46;
#line 640
  (*(yyvsp + -1))->value.nodeval = subs;
#line 641
  yyval = *(yyvsp + -1);
  }
#line 643
  goto switch_break;
  case_139: /* CIL Label */ 
#line 648
  yyval = *(yyvsp + 0);
#line 648
  num_dim = 1;
#line 649
  goto switch_break;
  case_140: /* CIL Label */ 
#line 650
  yyval = *(yyvsp + -1);
#line 650
  num_dim ++;
#line 651
  goto switch_break;
  case_142: /* CIL Label */ 
#line 657
  n___3 = (*(yyvsp + 0))->value.nodeval;
#line 658
  if ((n___3->flags & 16U) == 0U) {
    {
#line 659
    tmp___31 = gettext("non-numeric value for field number");
#line 659
    zzerror((char const   *)tmp___31);
    }
  } else {
#line 661
    (*(yyvsp + 0))->type = (enum argtype )47;
  }
#line 662
  yyval = *(yyvsp + 0);
#line 664
  goto switch_break;
  case_143: /* CIL Label */ 
#line 667
  (*(yyvsp + -1))->type = (enum argtype )49;
#line 668
  (*(yyvsp + -1))->a_count = num_dim;
#line 669
  yyval = *(yyvsp + -1);
#line 671
  goto switch_break;
  case_144: /* CIL Label */ 
#line 675
  yyval = *(yyvsp + 0);
#line 676
  goto switch_break;
  case_145: /* CIL Label */ 
#line 678
  n___4 = (*(yyvsp + 0))->value.nodeval;
#line 679
  if ((n___4->flags & 16U) == 0U) {
    {
#line 680
    tmp___32 = gettext("non-numeric value found, numeric expected");
#line 680
    zzerror((char const   *)tmp___32);
    }
  }
#line 681
  yyval = *(yyvsp + 0);
#line 683
  goto switch_break;
  case_146: /* CIL Label */ 
#line 685
  n___5 = (*(yyvsp + 0))->value.nodeval;
#line 686
  if ((n___5->flags & 16U) == 0U) {
    {
#line 687
    tmp___33 = gettext("non-numeric value found, numeric expected");
#line 687
    zzerror((char const   *)tmp___33);
    }
  } else {
    {
#line 689
    negate_num(n___5);
    }
  }
#line 690
  yyval = *(yyvsp + 0);
#line 692
  goto switch_break;
  case_147: /* CIL Label */ 
#line 696
  yyval = (CMDARG *)((void *)0);
#line 697
  goto switch_break;
  case_148: /* CIL Label */ 
#line 698
  yyval = *(yyvsp + 0);
#line 699
  goto switch_break;
  case_149: /* CIL Label */ 
#line 703
  yyval = (CMDARG *)((void *)0);
#line 704
  goto switch_break;
  case_150: /* CIL Label */ 
#line 705
  yyval = *(yyvsp + 0);
#line 706
  goto switch_break;
  case_151: /* CIL Label */ 
#line 711
  if ((*(yyvsp + 0))->value.lval == 0L) {
    {
#line 712
    tmp___34 = gettext("non-zero integer value");
#line 712
    zzerror((char const   *)tmp___34);
    }
  }
#line 713
  yyval = *(yyvsp + 0);
#line 715
  goto switch_break;
  case_152: /* CIL Label */ 
#line 717
  if ((*(yyvsp + 0))->value.lval == 0L) {
    {
#line 718
    tmp___35 = gettext("non-zero integer value");
#line 718
    zzerror((char const   *)tmp___35);
    }
  }
#line 719
  yyval = *(yyvsp + 0);
#line 721
  goto switch_break;
  case_153: /* CIL Label */ 
#line 725
  yyval = *(yyvsp + 0);
#line 726
  goto switch_break;
  case_154: /* CIL Label */ 
#line 727
  yyval = *(yyvsp + 0);
#line 728
  goto switch_break;
  case_155: /* CIL Label */ 
#line 730
  (*(yyvsp + 0))->value.lval = - (*(yyvsp + 0))->value.lval;
#line 731
  yyval = *(yyvsp + 0);
#line 733
  goto switch_break;
  case_156: /* CIL Label */ 
#line 738
  if ((unsigned long )lexptr_begin != (unsigned long )((void *)0)) {
#line 739
    if (input_from_tty) {
#line 739
      if ((int )*(lexptr_begin + 0) != 0) {
        {
#line 740
        add_history((char const   *)lexptr_begin);
        }
      }
    }
    {
#line 741
    free((void *)lexptr_begin);
#line 742
    lexptr_begin = (char *)((void *)0);
    }
  }
#line 745
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2451 "command.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2466
  yyvsp -= yylen;
#line 2466
  yyssp -= yylen;
#line 2467
  yylen = 0;
#line 2470
  yyvsp ++;
#line 2470
  *yyvsp = yyval;
#line 2476
  yyn = (int )yyr1[yyn];
#line 2478
  yystate = (int )((int const   )yypgoto[yyn - 59] + (int const   )*yyssp);
#line 2479
  if (0 <= yystate) {
#line 2479
    if (yystate <= 203) {
#line 2479
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2480
        yystate = (int )yytable[yystate];
      } else {
#line 2482
        yystate = (int )yydefgoto[yyn - 59];
      }
    } else {
#line 2482
      yystate = (int )yydefgoto[yyn - 59];
    }
  } else {
#line 2482
    yystate = (int )yydefgoto[yyn - 59];
  }
#line 2484
  goto yynewstate;
  yyerrlab: 
#line 2493
  if (zzchar == -2) {
#line 2493
    yytoken = -2;
  } else {
#line 2493
    if ((unsigned int )zzchar <= 303U) {
#line 2493
      tmp___36 = (int const   )yytranslate[zzchar];
    } else {
#line 2493
      tmp___36 = (int const   )2;
    }
#line 2493
    yytoken = (int )tmp___36;
  }
#line 2496
  if (! yyerrstatus) {
    {
#line 2498
    zznerrs ++;
#line 2500
    zzerror("syntax error");
    }
  }
#line 2537
  if (yyerrstatus == 3) {
#line 2542
    if (zzchar <= 0) {
#line 2545
      if (zzchar == 0) {
#line 2546
        goto yyabortlab;
      }
    } else {
      {
#line 2550
      yydestruct("Error: discarding", yytoken, & zzlval);
#line 2552
      zzchar = -2;
      }
    }
  }
#line 2558
  goto yyerrlab1;
#line 2574
  yyvsp -= yylen;
#line 2574
  yyssp -= yylen;
#line 2575
  yylen = 0;
#line 2577
  yystate = (int )*yyssp;
#line 2578
  goto yyerrlab1;
  yyerrlab1: 
#line 2585
  yyerrstatus = 3;
  {
#line 2587
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2589
    yyn = (int )yypact[yystate];
#line 2590
    if (! (! (! (yyn == -151)))) {
#line 2592
      yyn ++;
#line 2593
      if (0 <= yyn) {
#line 2593
        if (yyn <= 203) {
#line 2593
          if ((int const   )yycheck[yyn] == 1) {
#line 2595
            yyn = (int )yytable[yyn];
#line 2596
            if (0 < yyn) {
#line 2597
              goto while_break___2;
            }
          }
        }
      }
    }
#line 2602
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2603
      goto yyabortlab;
    }
    {
#line 2606
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 2608
    yyvsp --;
#line 2608
    yyssp --;
#line 2609
    yystate = (int )*yyssp;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2614
  yyvsp ++;
#line 2614
  *yyvsp = zzlval;
#line 2621
  yystate = yyn;
#line 2622
  goto yynewstate;
  yyacceptlab: 
#line 2629
  yyresult = 0;
#line 2630
  goto yyreturn;
  yyabortlab: 
#line 2636
  yyresult = 1;
#line 2637
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2644
  zzerror("memory exhausted");
#line 2645
  yyresult = 2;
  }
  yyreturn: 
#line 2650
  if (zzchar != -2) {
#line 2654
    if ((unsigned int )zzchar <= 303U) {
#line 2654
      yytoken = (int )yytranslate[zzchar];
    } else {
#line 2654
      yytoken = 2;
    }
    {
#line 2655
    yydestruct("Cleanup: discarding lookahead", yytoken, & zzlval);
    }
  }
#line 2660
  yyvsp -= yylen;
#line 2660
  yyssp -= yylen;
  {
#line 2662
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2662
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2662
      goto while_break___3;
    }
    {
#line 2664
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 2666
    yyvsp --;
#line 2666
    yyssp --;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2669
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2670
    free((void *)yyss);
    }
  }
#line 2677
  return (yyresult);
}
}
#line 752 "command.y"
static CMDARG *append_statement(CMDARG *stmt_list , char *stmt ) 
{ 
  CMDARG *a ;
  CMDARG *arg ;
  char *s___0 ;
  int len ;
  int slen ;
  int ssize ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  void *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 761
  if ((unsigned long )stmt == (unsigned long )(start_EVAL)) {
#line 762
    len = (int )sizeof(start_EVAL);
#line 763
    a = stmt_list;
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
#line 763
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 763
        goto while_break;
      }
      {
#line 764
      tmp___1 = strlen((char const   *)a->value.sval);
#line 764
      len = (int )((size_t )len + (tmp___1 + 1UL));
#line 763
      a = a->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 765
    len += 512;
#line 767
    tmp___2 = malloc((unsigned long )(len + 2) * sizeof(char ));
#line 767
    s___0 = (char *)tmp___2;
    }
#line 767
    if (s___0) {
#line 767
      tmp___6 = 1;
    } else {
      {
#line 767
      set_loc("command.y", 767);
#line 767
      tmp___3 = __errno_location();
#line 767
      tmp___4 = strerror(*tmp___3);
#line 767
      tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 767
      r_fatal((char const   *)tmp___5, "append_statement", "s", (long )((unsigned long )(len + 2) * sizeof(char )),
              tmp___4);
#line 767
      tmp___6 = 0;
      }
    }
    {
#line 768
    arg = mk_cmdarg((enum argtype )44);
#line 769
    arg->value.sval = s___0;
#line 770
    arg->a_count = len;
#line 772
    slen = (int )(sizeof("function @eval(") - 1UL);
#line 773
    memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)(start_EVAL),
           (size_t )slen);
#line 775
    a = stmt_list;
    }
    {
#line 775
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 775
      if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 775
        goto while_break___0;
      }
      {
#line 776
      tmp___7 = strlen((char const   *)a->value.sval);
#line 776
      len = (int )tmp___7;
#line 777
      memcpy((void */* __restrict  */)(s___0 + slen), (void const   */* __restrict  */)a->value.sval,
             (size_t )len);
#line 778
      slen += len;
      }
#line 779
      if ((unsigned long )a->next != (unsigned long )((void *)0)) {
#line 780
        tmp___8 = slen;
#line 780
        slen ++;
#line 780
        *(s___0 + tmp___8) = (char )',';
      }
#line 775
      a = a->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 782
    tmp___9 = slen;
#line 782
    slen ++;
#line 782
    *(s___0 + tmp___9) = (char )')';
#line 783
    tmp___10 = slen;
#line 783
    slen ++;
#line 783
    *(s___0 + tmp___10) = (char )'{';
#line 784
    *(s___0 + slen) = (char )'\000';
#line 785
    return (arg);
  }
  {
#line 788
  tmp___11 = strlen((char const   *)stmt);
#line 788
  len = (int )(tmp___11 + 1UL);
#line 789
  s___0 = stmt_list->value.sval;
#line 790
  tmp___12 = strlen((char const   *)s___0);
#line 790
  slen = (int )tmp___12;
#line 791
  ssize = stmt_list->a_count;
  }
#line 792
  if (len > ssize - slen) {
    {
#line 793
    ssize = (slen + len) + 512;
#line 794
    tmp___13 = realloc((void *)s___0, (unsigned long )(ssize + 2) * sizeof(char ));
#line 794
    s___0 = (char *)tmp___13;
    }
#line 794
    if (s___0) {
#line 794
      tmp___17 = 1;
    } else {
      {
#line 794
      set_loc("command.y", 794);
#line 794
      tmp___14 = __errno_location();
#line 794
      tmp___15 = strerror(*tmp___14);
#line 794
      tmp___16 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 794
      r_fatal((char const   *)tmp___16, "append_statement", "s", (long )((unsigned long )(ssize + 2) * sizeof(char )),
              tmp___15);
#line 794
      tmp___17 = 0;
      }
    }
#line 795
    stmt_list->value.sval = s___0;
#line 796
    stmt_list->a_count = ssize;
  }
  {
#line 798
  memcpy((void */* __restrict  */)(s___0 + slen), (void const   */* __restrict  */)stmt,
         (size_t )len);
#line 799
  slen += len;
  }
#line 800
  if (slen >= 2) {
#line 800
    if ((int )*(s___0 + (slen - 2)) != 10) {
#line 801
      *(s___0 + (slen - 1)) = (char )'\n';
#line 802
      *(s___0 + slen) = (char )'\000';
    }
  }
#line 805
  if ((unsigned long )stmt == (unsigned long )(end_EVAL)) {
    {
#line 806
    tmp___19 = realloc((void *)stmt_list->value.sval, (size_t )(slen + 2));
#line 806
    tmp___18 = (char *)tmp___19;
#line 806
    stmt_list->value.sval = tmp___18;
    }
#line 806
    if (tmp___18) {
#line 806
      tmp___23 = 1;
    } else {
      {
#line 806
      set_loc("command.y", 806);
#line 806
      tmp___20 = __errno_location();
#line 806
      tmp___21 = strerror(*tmp___20);
#line 806
      tmp___22 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 806
      r_fatal((char const   *)tmp___22, "append_statement", "stmt_list->a_string",
              (long )(slen + 2), tmp___21);
#line 806
      tmp___23 = 0;
      }
    }
  }
#line 807
  return (stmt_list);
}
}
#line 815 "command.y"
struct cmdtoken zz_debug_cmdtab[42]  = 
#line 815
  {      {"backtrace", (char *)"bt", (enum argtype )1, 258, & do_backtrace, "backtrace [N] - print trace of all or N innermost (outermost if N < 0) frames."}, 
        {"break",
      (char *)"b", (enum argtype )2, 259, & do_breakpoint, "break [[filename:]N|function] - set breakpoint at the specified location."}, 
        {"clear",
      (char *)"", (enum argtype )3, 260, & do_clear, "clear [[filename:]N|function] - delete breakpoints previously set."}, 
        {"commands",
      (char *)"", (enum argtype )4, 296, & do_commands, "commands [num] - starts a list of commands to be executed at a breakpoint(watchpoint) hit."}, 
        {"condition",
      (char *)"", (enum argtype )5, 302, & do_condition, "condition num [expr] - set or clear breakpoint or watchpoint condition."}, 
        {"continue",
      (char *)"c", (enum argtype )6, 261, & do_continue, "continue [COUNT] - continue program being debugged."}, 
        {"delete",
      (char *)"d", (enum argtype )7, 262, & do_delete_breakpoint, "delete [breakpoints] [range] - delete specified breakpoints."}, 
        {"disable",
      (char *)"", (enum argtype )8, 263, & do_disable_breakpoint, "disable [breakpoints] [range] - disable specified breakpoints."}, 
        {"display",
      (char *)"", (enum argtype )9, 285, & do_display, "display [var] - print value of variable each time the program stops."}, 
        {"down",
      (char *)"", (enum argtype )10, 264, & do_down, "down [N] - move N frames down the stack."}, 
        {"dump",
      (char *)"", (enum argtype )11, 289, & do_dump_instructions, "dump [filename] - dump instructions to file or stdout."}, 
        {"enable",
      (char *)"e", (enum argtype )12, 265, & do_enable_breakpoint, "enable [once|del] [breakpoints] [range] - enable specified breakpoints."}, 
        {"end",
      (char *)"", (enum argtype )13, 297, & do_commands, "end - end a list of commands or awk statements."}, 
        {"eval",
      (char *)"", (enum argtype )14, 301, & do_eval, "eval stmt|[p1, p2, ...] - evaluate awk statement(s)."}, 
        {"finish",
      (char *)"", (enum argtype )15, 266, & do_finish, "finish - execute until selected stack frame returns."}, 
        {"frame",
      (char *)"f", (enum argtype )16, 267, & do_frame, "frame [N] - select and print stack frame number N."}, 
        {"help",
      (char *)"h", (enum argtype )17, 268, & do_help, "help [command] - print list of commands or explanation of command."}, 
        {"ignore",
      (char *)"", (enum argtype )18, 269, & do_ignore_breakpoint, "ignore N COUNT - set ignore-count of breakpoint number N to COUNT."}, 
        {"info",
      (char *)"i", (enum argtype )19, 270, & do_info, "info topic - source|sources|variables|functions|break|frame|args|locals|display|watch."}, 
        {"list",
      (char *)"l", (enum argtype )20, 271, & do_list, "list [-|+|[filename:]lineno|function|range] - list specified line(s)."}, 
        {"next",
      (char *)"n", (enum argtype )21, 272, & do_next, "next [COUNT] - step program, proceeding through subroutine calls."}, 
        {"nexti",
      (char *)"ni", (enum argtype )22, 273, & do_nexti, "nexti [COUNT] - step one instruction, but proceed through subroutine calls."}, 
        {"option",
      (char *)"o", (enum argtype )23, 295, & do_option, "option [name[=value]] - set or display debugger option(s)."}, 
        {"print",
      (char *)"p", (enum argtype )24, 274, & do_print_var, "print var [var] - print value of a variable or array."}, 
        {"printf",
      (char *)"", (enum argtype )25, 275, & do_print_f, "printf format, [arg], ... - formatted output."}, 
        {"quit",
      (char *)"q", (enum argtype )26, 276, & do_quit, "quit - exit debugger."}, 
        {"return", (char *)"", (enum argtype )27, 277, & do_return, "return [value] - make selected stack frame return to its caller."}, 
        {"run",
      (char *)"r", (enum argtype )28, 278, & do_run, "run - start or restart executing program."}, 
        {"save",
      (char *)"", (enum argtype )29, 300, & do_save, "save filename - save commands from the session to file."}, 
        {"set",
      (char *)"", (enum argtype )30, 279, & do_set_var, "set var = value - assign value to a scalar variable."}, 
        {"silent",
      (char *)"", (enum argtype )31, 298, & do_commands, "silent - suspends usual message when stopped at a breakpoint/watchpoint."}, 
        {"source",
      (char *)"", (enum argtype )32, 299, & do_source, "source file - execute commands from file."}, 
        {"step",
      (char *)"s", (enum argtype )33, 280, & do_step, "step [COUNT] - step program until it reaches a different source line."}, 
        {"stepi",
      (char *)"si", (enum argtype )34, 281, & do_stepi, "stepi [COUNT] - step one instruction exactly."}, 
        {"tbreak",
      (char *)"t", (enum argtype )35, 282, & do_tmp_breakpoint, "tbreak [[filename:]N|function] - set a temporary breakpoint."}, 
        {"trace",
      (char *)"", (enum argtype )36, 290, & do_trace_instruction, "trace on|off - print instruction before executing."}, 
        {"undisplay",
      (char *)"", (enum argtype )37, 286, & do_undisplay, "undisplay [N] - remove variable(s) from automatic display list."}, 
        {"until",
      (char *)"u", (enum argtype )38, 284, & do_until, "until [[filename:]N|function] - execute until program reaches a different line or line N within current frame."}, 
        {"unwatch",
      (char *)"", (enum argtype )39, 288, & do_unwatch, "unwatch [N] - remove variable(s) from watch list."}, 
        {"up",
      (char *)"", (enum argtype )40, 283, & do_up, "up [N] - move N frames up the stack."}, 
        {"watch",
      (char *)"w", (enum argtype )41, 287, & do_watch, "watch var - set a watchpoint for a variable."}, 
        {(char const   *)((void *)0),
      (char *)((void *)0), (enum argtype )0, 0, (int (*)(CMDARG * , int  ))0, (char const   *)((void *)0)}};
#line 904 "command.y"
struct argtoken zz_debug_argtab[15]  = 
#line 904
  {      {"args", (enum argtype )19, (enum nametypeval )1}, 
        {"break", (enum argtype )19, (enum nametypeval )2}, 
        {"del", (enum argtype )12, (enum nametypeval )3}, 
        {"display", (enum argtype )19, (enum nametypeval )4}, 
        {"frame", (enum argtype )19, (enum nametypeval )5}, 
        {"functions", (enum argtype )19, (enum nametypeval )6}, 
        {"locals", (enum argtype )19, (enum nametypeval )7}, 
        {"off", (enum argtype )36, (enum nametypeval )12}, 
        {"on", (enum argtype )36, (enum nametypeval )11}, 
        {"once", (enum argtype )12, (enum nametypeval )8}, 
        {"source", (enum argtype )19, (enum nametypeval )9}, 
        {"sources", (enum argtype )19, (enum nametypeval )10}, 
        {"variables", (enum argtype )19, (enum nametypeval )13}, 
        {"watch", (enum argtype )19, (enum nametypeval )14}, 
        {(char const   *)((void *)0), (enum argtype )0, (enum nametypeval )0}};
#line 925 "command.y"
Func_cmd get_command(int ctype ) 
{ 
  int i___0 ;

  {
#line 929
  i___0 = 0;
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 929
    if (! ((unsigned long )zz_debug_cmdtab[i___0].name != (unsigned long )((void *)0))) {
#line 929
      goto while_break;
    }
#line 930
    if ((unsigned int )zz_debug_cmdtab[i___0].type == (unsigned int )ctype) {
#line 931
      return (zz_debug_cmdtab[i___0].cf_ptr);
    }
#line 929
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 933
  return ((int (*)(CMDARG * , int  ))0);
}
}
#line 938 "command.y"
char const   *get_command_name(int ctype ) 
{ 
  int i___0 ;

  {
#line 942
  i___0 = 0;
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 942
    if (! ((unsigned long )zz_debug_cmdtab[i___0].name != (unsigned long )((void *)0))) {
#line 942
      goto while_break;
    }
#line 943
    if ((unsigned int )zz_debug_cmdtab[i___0].type == (unsigned int )ctype) {
#line 944
      return (zz_debug_cmdtab[i___0].name);
    }
#line 942
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 946
  return ((char const   *)((void *)0));
}
}
#line 951 "command.y"
static CMDARG *mk_cmdarg(enum argtype type ) 
{ 
  CMDARG *arg ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 955
  tmp___1 = malloc(sizeof(CMDARG ));
#line 955
  arg = (CMDARG *)tmp___1;
  }
#line 955
  if (arg) {
#line 955
    tmp___5 = 1;
  } else {
    {
#line 955
    set_loc("command.y", 955);
#line 955
    tmp___2 = __errno_location();
#line 955
    tmp___3 = strerror(*tmp___2);
#line 955
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 955
    r_fatal((char const   *)tmp___4, "mk_cmdarg", "arg", (long )sizeof(CMDARG ), tmp___3);
#line 955
    tmp___5 = 0;
    }
  }
  {
#line 956
  memset((void *)arg, 0, sizeof(CMDARG ));
#line 957
  arg->type = type;
  }
#line 958
  return (arg);
}
}
#line 966 "command.y"
static CMDARG *savetail  ;
#line 963 "command.y"
static void append_cmdarg(CMDARG *arg ) 
{ 


  {
#line 968
  if ((unsigned long )arg_list == (unsigned long )((void *)0)) {
#line 969
    arg_list = arg;
  } else {
#line 971
    savetail->next = arg;
  }
#line 972
  savetail = arg;
#line 973
  return;
}
}
#line 977 "command.y"
void free_cmdarg(CMDARG *list ) 
{ 
  CMDARG *arg ;
  CMDARG *nexta ;

  {
#line 982
  arg = list;
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
#line 982
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 982
      goto while_break;
    }
#line 983
    nexta = arg->next;
    {
#line 989
    if ((unsigned int )arg->type == 44U) {
#line 989
      goto case_44;
    }
#line 989
    if ((unsigned int )arg->type == 48U) {
#line 989
      goto case_44;
    }
#line 989
    if ((unsigned int )arg->type == 49U) {
#line 989
      goto case_44;
    }
#line 989
    if ((unsigned int )arg->type == 45U) {
#line 989
      goto case_44;
    }
#line 994
    if ((unsigned int )arg->type == 47U) {
#line 994
      goto case_47;
    }
#line 994
    if ((unsigned int )arg->type == 46U) {
#line 994
      goto case_47;
    }
#line 997
    goto switch_default;
    case_44: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 990
    if ((unsigned long )arg->value.sval != (unsigned long )((void *)0)) {
      {
#line 991
      free((void *)arg->value.sval);
      }
    }
#line 992
    goto switch_break;
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    {
#line 995
    unref(arg->value.nodeval);
    }
#line 996
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 998
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1000
    free((void *)arg);
#line 982
    arg = nexta;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1002
  return;
}
}
#line 1006 "command.y"
static void zzerror(char const   *mesg  , ...) 
{ 
  va_list args ;
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1010
  __builtin_va_start(args, mesg);
#line 1011
  tmp___1 = gettext("error: ");
#line 1011
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___1);
#line 1012
  vfprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)mesg,
           args);
#line 1013
  fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"\n");
#line 1014
  __builtin_va_end(args);
#line 1015
  errcount ++;
#line 1016
  repeat_idx = -1;
  }
#line 1017
  return;
}
}
#line 1025 "command.y"
static char *lexptr___0  =    (char *)((void *)0);
#line 1026 "command.y"
static char *lexend  ;
#line 1046 "command.y"
static int seen_eof  =    0;
#line 1022 "command.y"
static int zzlex(void) 
{ 
  int c ;
  char *tokstart___0 ;
  size_t toklen ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  HIST_ENTRY *h ;
  char *tmp___14 ;
  unsigned short const   **tmp___15 ;
  CMDARG *arg ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *str ;
  char *p ;
  int flags___0 ;
  _Bool esc_seen ;
  void *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *end ;
  long l ;
  int *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int *tmp___31 ;
  int *tmp___32 ;
  unsigned short const   **tmp___33 ;
  NODE *r ;
  int *tmp___34 ;
  int tval ;
  int tmp___35 ;
  int tmp___36 ;
  NODE *tmp___37 ;
  int tmp___38 ;
  double tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int *tmp___42 ;
  int *tmp___43 ;
  unsigned short const   **tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  unsigned short const   **tmp___47 ;
  unsigned short const   **tmp___48 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;

  {
#line 1031
  zzlval = (CMDARG *)((void *)0);
#line 1033
  if (errcount > 0L) {
#line 1033
    if ((unsigned long )lexptr_begin == (unsigned long )((void *)0)) {
#line 1035
      errcount = 0L;
#line 1036
      return ('\n');
    }
  }
#line 1039
  if ((unsigned long )lexptr_begin == (unsigned long )((void *)0)) {
    again: 
    {
#line 1041
    lexptr_begin = (*read_a_line)((char const   *)dbg_prompt);
    }
#line 1042
    if ((unsigned long )lexptr_begin == (unsigned long )((void *)0)) {
      {
#line 1043
      tmp___1 = get_eof_status();
      }
#line 1043
      if (tmp___1 == 2) {
        {
#line 1044
        exit(2);
        }
      }
      {
#line 1045
      tmp___7 = get_eof_status();
      }
#line 1045
      if (tmp___7 == 1) {
#line 1049
        if (! seen_eof) {
          {
#line 1050
          tmp___5 = __errno_location();
          }
#line 1050
          if (*tmp___5 != 0) {
            {
#line 1051
            tmp___2 = __errno_location();
#line 1051
            tmp___3 = strerror(*tmp___2);
#line 1051
            tmp___4 = gettext("can\'t read command (%s)\n");
#line 1051
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
                    tmp___3);
#line 1052
            exit_val = 1;
            }
          }
#line 1056
          seen_eof = 1;
#line 1057
          return ('\n');
        } else {
#line 1058
          tmp___6 = seen_eof;
#line 1058
          seen_eof ++;
#line 1058
          if (tmp___6 == 1) {
            {
#line 1059
            cmd_idx = find_command("quit", (size_t )4);
            }
#line 1060
            return (276);
          } else {
#line 1062
            return ('\n');
          }
        }
      }
      {
#line 1064
      tmp___11 = __errno_location();
      }
#line 1064
      if (*tmp___11 != 0) {
        {
#line 1065
        tmp___8 = __errno_location();
#line 1065
        tmp___9 = strerror(*tmp___8);
#line 1065
        tmp___10 = gettext("can\'t read command (%s)");
#line 1065
        d_error((char const   *)tmp___10, tmp___9);
        }
      }
      {
#line 1066
      tmp___12 = pop_cmd_src();
      }
#line 1066
      if (tmp___12 == 0) {
#line 1067
        goto again;
      }
      {
#line 1068
      exit(2);
      }
    }
#line 1071
    if (! in_commands) {
#line 1071
      if (! in_eval) {
#line 1071
        if (input_from_tty) {
          {
#line 1074
          history_expand_line(& lexptr_begin);
          }
        }
      }
    }
    {
#line 1076
    lexptr___0 = lexptr_begin;
#line 1077
    tmp___13 = strlen((char const   *)lexptr___0);
#line 1077
    lexend = lexptr___0 + tmp___13;
    }
#line 1078
    if ((int )*lexptr___0 == 0) {
#line 1078
      if (repeat_idx >= 0) {
#line 1078
        if (input_from_tty) {
#line 1078
          if (! in_eval) {
            {
#line 1085
            h = previous_history();
            }
#line 1086
            if ((unsigned long )h != (unsigned long )((void *)0)) {
              {
#line 1087
              add_history((char const   *)h->line);
              }
            }
#line 1089
            cmd_idx = repeat_idx;
#line 1090
            return (zz_debug_cmdtab[cmd_idx].class);
          }
        }
      }
    }
#line 1092
    repeat_idx = -1;
  }
#line 1095
  c = (int )*lexptr___0;
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1097
    if (! (c == 32)) {
#line 1097
      if (! (c == 9)) {
#line 1097
        goto while_break;
      }
    }
#line 1098
    lexptr___0 ++;
#line 1098
    c = (int )*lexptr___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1100
  if (! input_from_tty) {
#line 1100
    if (c == 35) {
#line 1101
      return ('\n');
    }
  }
#line 1103
  tokstart___0 = lexptr___0;
#line 1104
  if ((unsigned long )lexptr___0 >= (unsigned long )lexend) {
#line 1105
    return ('\n');
  }
#line 1107
  if (cmd_idx < 0) {
#line 1108
    if (c == 63) {
#line 1108
      if ((int )*(tokstart___0 + 1) == 0) {
#line 1108
        if (! in_eval) {
          {
#line 1109
          lexptr___0 ++;
#line 1110
          cmd_idx = find_command("help", (size_t )4);
          }
#line 1111
          return (268);
        }
      }
    }
    {
#line 1114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1114
      if (c != 0) {
#line 1114
        if (c != 32) {
#line 1114
          if (! (c != 9)) {
#line 1114
            goto while_break___0;
          }
        } else {
#line 1114
          goto while_break___0;
        }
      } else {
#line 1114
        goto while_break___0;
      }
      {
#line 1115
      tmp___15 = __ctype_b_loc();
      }
#line 1115
      if (! ((int const   )*(*tmp___15 + c) & 1024)) {
#line 1115
        if (! in_eval) {
          {
#line 1116
          tmp___14 = gettext("invalid character in command");
#line 1116
          zzerror((char const   *)tmp___14);
          }
#line 1117
          return ('\n');
        }
      }
#line 1119
      lexptr___0 ++;
#line 1119
      c = (int )*lexptr___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1122
    toklen = (size_t )(lexptr___0 - tokstart___0);
#line 1124
    if (in_eval) {
#line 1125
      if (toklen == 3UL) {
#line 1125
        if ((int )*(tokstart___0 + 3) == 0) {
#line 1125
          if ((int )*(tokstart___0 + 0) == 101) {
#line 1125
            if ((int )*(tokstart___0 + 1) == 110) {
#line 1125
              if ((int )*(tokstart___0 + 2) == 100) {
                {
#line 1131
                cmd_idx = find_command((char const   *)tokstart___0, toklen);
                }
#line 1132
                return (297);
              }
            }
          }
        }
      }
#line 1134
      lexptr___0 = lexend;
#line 1135
      return (303);
    }
    {
#line 1138
    cmd_idx = find_command((char const   *)tokstart___0, toklen);
    }
#line 1139
    if (cmd_idx >= 0) {
#line 1140
      if (in_commands) {
#line 1140
        if ((unsigned int )zz_debug_cmdtab[cmd_idx].type != 14U) {
          {
#line 1146
          arg = mk_cmdarg((enum argtype )44);
#line 1147
          arg->value.sval = estrdup((char const   *)lexptr_begin, (size_t )(lexend - lexptr_begin));
#line 1148
          append_cmdarg(arg);
          }
        }
      }
#line 1150
      return (zz_debug_cmdtab[cmd_idx].class);
    } else {
      {
#line 1152
      tmp___16 = gettext("unknown command - \"%.*s\", try help");
#line 1152
      zzerror((char const   *)tmp___16, toklen, tokstart___0);
      }
#line 1153
      return ('\n');
    }
  }
#line 1157
  c = (int )*lexptr___0;
#line 1159
  if ((unsigned int )zz_debug_cmdtab[cmd_idx].type == 23U) {
#line 1160
    if (c == 61) {
#line 1161
      tmp___17 = lexptr___0;
#line 1161
      lexptr___0 ++;
#line 1161
      return ((int )*tmp___17);
    }
  } else
#line 1162
  if (c == 45) {
#line 1163
    tmp___18 = lexptr___0;
#line 1163
    lexptr___0 ++;
#line 1163
    return ((int )*tmp___18);
  } else
#line 1162
  if (c == 43) {
#line 1163
    tmp___18 = lexptr___0;
#line 1163
    lexptr___0 ++;
#line 1163
    return ((int )*tmp___18);
  } else
#line 1162
  if (c == 58) {
#line 1163
    tmp___18 = lexptr___0;
#line 1163
    lexptr___0 ++;
#line 1163
    return ((int )*tmp___18);
  } else
#line 1162
  if (c == 124) {
#line 1163
    tmp___18 = lexptr___0;
#line 1163
    lexptr___0 ++;
#line 1163
    return ((int )*tmp___18);
  }
#line 1165
  if (c == 34) {
    {
#line 1167
    flags___0 = 2;
#line 1168
    esc_seen = (_Bool)0;
#line 1170
    toklen = (size_t )(lexend - lexptr___0);
#line 1171
    tmp___19 = malloc(toklen + 2UL);
#line 1171
    str = (char *)tmp___19;
    }
#line 1171
    if (str) {
#line 1171
      tmp___23 = 1;
    } else {
      {
#line 1171
      set_loc("command.y", 1171);
#line 1171
      tmp___20 = __errno_location();
#line 1171
      tmp___21 = strerror(*tmp___20);
#line 1171
      tmp___22 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1171
      r_fatal((char const   *)tmp___22, "yylex", "str", (long )(toklen + 2UL), tmp___21);
#line 1171
      tmp___23 = 0;
      }
    }
#line 1172
    p = str;
    {
#line 1174
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1174
      lexptr___0 ++;
#line 1174
      c = (int )*lexptr___0;
#line 1174
      if (! (c != 34)) {
#line 1174
        goto while_break___1;
      }
#line 1175
      if ((unsigned long )lexptr___0 == (unsigned long )lexend) {
        err: 
        {
#line 1177
        free((void *)str);
#line 1178
        tmp___24 = gettext("unterminated string");
#line 1178
        zzerror((char const   *)tmp___24);
        }
#line 1179
        return ('\n');
      }
#line 1181
      if (c == 92) {
#line 1182
        lexptr___0 ++;
#line 1182
        c = (int )*lexptr___0;
#line 1183
        esc_seen = (_Bool)1;
#line 1184
        if (want_nodeval) {
#line 1185
          tmp___25 = p;
#line 1185
          p ++;
#line 1185
          *tmp___25 = (char )'\\';
        } else
#line 1184
        if (c != 34) {
#line 1185
          tmp___25 = p;
#line 1185
          p ++;
#line 1185
          *tmp___25 = (char )'\\';
        }
      }
#line 1187
      if ((unsigned long )lexptr___0 == (unsigned long )lexend) {
#line 1188
        goto err;
      }
#line 1189
      tmp___26 = p;
#line 1189
      p ++;
#line 1189
      *tmp___26 = (char )c;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1191
    lexptr___0 ++;
#line 1192
    *p = (char )'\000';
#line 1194
    if (! want_nodeval) {
      {
#line 1195
      zzlval = mk_cmdarg((enum argtype )44);
#line 1196
      zzlval->value.sval = str;
#line 1197
      append_cmdarg(zzlval);
      }
#line 1198
      return (292);
    } else {
#line 1200
      if (esc_seen) {
#line 1201
        flags___0 |= 1;
      }
      {
#line 1202
      zzlval = mk_cmdarg((enum argtype )46);
#line 1203
      zzlval->value.nodeval = make_str_node((char const   *)str, (size_t )(p - str),
                                            flags___0);
#line 1204
      append_cmdarg(zzlval);
      }
#line 1205
      return (293);
    }
  }
#line 1209
  if (! want_nodeval) {
    {
#line 1210
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1210
      lexptr___0 ++;
#line 1210
      c = (int )*lexptr___0;
#line 1210
      if (c != 0) {
#line 1210
        if (c != 58) {
#line 1210
          if (c != 45) {
#line 1210
            if (c != 32) {
#line 1210
              if (c != 9) {
#line 1210
                if (! (c != 61)) {
#line 1210
                  goto while_break___2;
                }
              } else {
#line 1210
                goto while_break___2;
              }
            } else {
#line 1210
              goto while_break___2;
            }
          } else {
#line 1210
            goto while_break___2;
          }
        } else {
#line 1210
          goto while_break___2;
        }
      } else {
#line 1210
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1215
    tmp___33 = __ctype_b_loc();
    }
#line 1215
    if ((int const   )*(*tmp___33 + (int )((unsigned char )*(tokstart___0 + 0))) & 2048) {
#line 1215
      if ((unsigned int )zz_debug_cmdtab[cmd_idx].type != 23U) {
        {
#line 1219
        tmp___27 = __errno_location();
#line 1219
        *tmp___27 = 0;
#line 1220
        l = strtol((char const   */* __restrict  */)tokstart___0, (char **/* __restrict  */)(& end),
                   0);
#line 1221
        tmp___32 = __errno_location();
        }
#line 1221
        if (*tmp___32 != 0) {
          {
#line 1222
          tmp___28 = __errno_location();
#line 1222
          tmp___29 = strerror(*tmp___28);
#line 1222
          tmp___30 = gettext("%s");
#line 1222
          zzerror((char const   *)tmp___30, tmp___29);
#line 1223
          tmp___31 = __errno_location();
#line 1223
          *tmp___31 = 0;
          }
#line 1224
          return ('\n');
        }
#line 1227
        if ((unsigned long )lexptr___0 == (unsigned long )end) {
          {
#line 1228
          zzlval = mk_cmdarg((enum argtype )43);
#line 1229
          zzlval->value.lval = l;
#line 1230
          append_cmdarg(zzlval);
          }
#line 1231
          return (291);
        }
      }
    }
    {
#line 1236
    zzlval = mk_cmdarg((enum argtype )44);
#line 1237
    zzlval->value.sval = estrdup((char const   *)tokstart___0, (size_t )(lexptr___0 - tokstart___0));
#line 1238
    append_cmdarg(zzlval);
    }
#line 1239
    return (292);
  }
  {
#line 1244
  tmp___44 = __ctype_b_loc();
  }
#line 1244
  if ((int const   )*(*tmp___44 + (int )((unsigned char )*(tokstart___0 + 0))) & 2048) {
    {
#line 1245
    r = (NODE *)((void *)0);
#line 1247
    tmp___34 = __errno_location();
#line 1247
    *tmp___34 = 0;
    }
#line 1249
    if (do_flags & 16384) {
      {
#line 1251
      r = mpg_node(2048U);
#line 1252
      tval = mpfr_strtofr(r->sub.val.nm.mpnum, (char const   *)tokstart___0, & lexptr___0,
                          0, ROUND_MODE);
      }
#line 1253
      if (do_ieee_fmt) {
        {
#line 1253
        tmp___35 = format_ieee(r->sub.val.nm.mpnum, tval);
        }
#line 1253
        if (tmp___35) {
#line 1253
          tmp___36 = 1;
        } else {
#line 1253
          tmp___36 = 0;
        }
      } else {
#line 1253
        tmp___36 = 0;
      }
      {
#line 1254
      tmp___38 = mpfr_integer_p((mpfr_srcptr )(r->sub.val.nm.mpnum));
      }
#line 1254
      if (tmp___38) {
        {
#line 1256
        tmp___37 = r;
#line 1257
        r = mpg_node(4096U);
#line 1258
        mpfr_get_z(r->sub.val.nm.mpi, (mpfr_srcptr )(tmp___37->sub.val.nm.mpnum),
                   (mpfr_rnd_t )1);
#line 1259
        unref(tmp___37);
        }
      }
    } else {
      {
#line 1263
      tmp___39 = strtod((char const   */* __restrict  */)tokstart___0, (char **/* __restrict  */)(& lexptr___0));
#line 1263
      r = (*make_number)(tmp___39);
      }
    }
    {
#line 1265
    tmp___43 = __errno_location();
    }
#line 1265
    if (*tmp___43 != 0) {
      {
#line 1266
      tmp___40 = __errno_location();
#line 1266
      tmp___41 = strerror(*tmp___40);
#line 1266
      zzerror((char const   *)tmp___41);
#line 1267
      unref(r);
#line 1268
      tmp___42 = __errno_location();
#line 1268
      *tmp___42 = 0;
      }
#line 1269
      return ('\n');
    }
    {
#line 1271
    zzlval = mk_cmdarg((enum argtype )46);
#line 1272
    zzlval->value.nodeval = r;
#line 1273
    append_cmdarg(zzlval);
    }
#line 1274
    return (293);
  }
#line 1277
  c = (int )*lexptr___0;
#line 1278
  if (c == 36) {
#line 1281
    tmp___45 = lexptr___0;
#line 1281
    lexptr___0 ++;
#line 1281
    return ((int )*tmp___45);
  } else
#line 1278
  if (c == 64) {
#line 1281
    tmp___45 = lexptr___0;
#line 1281
    lexptr___0 ++;
#line 1281
    return ((int )*tmp___45);
  } else
#line 1278
  if (c == 91) {
#line 1281
    tmp___45 = lexptr___0;
#line 1281
    lexptr___0 ++;
#line 1281
    return ((int )*tmp___45);
  } else
#line 1278
  if (c == 93) {
#line 1281
    tmp___45 = lexptr___0;
#line 1281
    lexptr___0 ++;
#line 1281
    return ((int )*tmp___45);
  } else
#line 1278
  if (c == 44) {
#line 1281
    tmp___45 = lexptr___0;
#line 1281
    lexptr___0 ++;
#line 1281
    return ((int )*tmp___45);
  } else
#line 1278
  if (c == 61) {
#line 1281
    tmp___45 = lexptr___0;
#line 1281
    lexptr___0 ++;
#line 1281
    return ((int )*tmp___45);
  }
#line 1283
  if (c != 95) {
    {
#line 1283
    tmp___47 = __ctype_b_loc();
    }
#line 1283
    if (! ((int const   )*(*tmp___47 + c) & 1024)) {
      {
#line 1284
      tmp___46 = gettext("invalid character");
#line 1284
      zzerror((char const   *)tmp___46);
      }
#line 1285
      return ('\n');
    }
  }
  {
#line 1288
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1288
    tmp___48 = __ctype_b_loc();
    }
#line 1288
    if (! ((int const   )*(*tmp___48 + c) & 8)) {
#line 1288
      if (! (c == 95)) {
#line 1288
        goto while_break___3;
      }
    }
#line 1289
    lexptr___0 ++;
#line 1289
    c = (int )*lexptr___0;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1290
  toklen = (size_t )(lexptr___0 - tokstart___0);
#line 1293
  zzlval = mk_cmdarg((enum argtype )45);
#line 1294
  zzlval->value.sval = estrdup((char const   *)tokstart___0, toklen);
#line 1295
  append_cmdarg(zzlval);
  }
#line 1296
  return (294);
}
}
#line 1301 "command.y"
static int find_argument(CMDARG *arg ) 
{ 
  int idx___3 ;
  char *name ;
  char *p ;
  size_t len ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1309
  name = arg->value.sval;
#line 1310
  len = strlen((char const   *)name);
#line 1311
  idx___3 = 0;
  }
  {
#line 1311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1311
    p = (char *)zz_debug_argtab[idx___3].name;
#line 1311
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1311
      goto while_break;
    }
#line 1312
    if ((unsigned int )zz_debug_cmdtab[cmd_idx].type == (unsigned int )zz_debug_argtab[idx___3].cmd) {
#line 1312
      if ((int )*p == (int )*name) {
        {
#line 1312
        tmp___1 = strlen((char const   *)p);
        }
#line 1312
        if (tmp___1 == len) {
          {
#line 1312
          tmp___2 = strncmp((char const   *)p, (char const   *)name, len);
          }
#line 1312
          if (tmp___2 == 0) {
#line 1317
            return (idx___3);
          }
        }
      }
    }
#line 1311
    idx___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1319
  return (-1);
}
}
#line 1324 "command.y"
static NODE *concat_args(CMDARG *arg , int count ) 
{ 
  NODE *n ;
  NODE **tmp___1 ;
  char *str ;
  char *subsep ;
  char *p ;
  long len ;
  long subseplen ;
  int i___0 ;
  NODE *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  NODE *tmp___14 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 1333
  if (count == 1) {
    {
#line 1334
    n = force_string(arg->value.nodeval);
#line 1335
    tmp___2 = dupnode(n);
    }
#line 1335
    return (tmp___2);
  }
  {
#line 1338
  tmp___3 = malloc((unsigned long )count * sizeof(NODE *));
#line 1338
  tmp___1 = (NODE **)tmp___3;
  }
#line 1338
  if (tmp___1) {
#line 1338
    tmp___7 = 1;
  } else {
    {
#line 1338
    set_loc("command.y", 1338);
#line 1338
    tmp___4 = __errno_location();
#line 1338
    tmp___5 = strerror(*tmp___4);
#line 1338
    tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1338
    r_fatal((char const   *)tmp___6, "concat_args", "tmp", (long )((unsigned long )count * sizeof(NODE *)),
            tmp___5);
#line 1338
    tmp___7 = 0;
    }
  }
#line 1339
  subseplen = (long )(SUBSEP_node->sub.nodep.l.lptr)->sub.val.slen;
#line 1340
  subsep = (SUBSEP_node->sub.nodep.l.lptr)->sub.val.sp;
#line 1341
  len = - subseplen;
#line 1343
  i___0 = 0;
  {
#line 1343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1343
    if (! (i___0 < count)) {
#line 1343
      goto while_break;
    }
    {
#line 1344
    n = force_string(arg->value.nodeval);
#line 1345
    len = (long )((size_t )len + (n->sub.val.slen + (size_t )subseplen));
#line 1346
    *(tmp___1 + i___0) = n;
#line 1347
    arg = arg->next;
#line 1343
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1350
  tmp___8 = malloc((size_t )(len + 2L));
#line 1350
  str = (char *)tmp___8;
  }
#line 1350
  if (str) {
#line 1350
    tmp___12 = 1;
  } else {
    {
#line 1350
    set_loc("command.y", 1350);
#line 1350
    tmp___9 = __errno_location();
#line 1350
    tmp___10 = strerror(*tmp___9);
#line 1350
    tmp___11 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1350
    r_fatal((char const   *)tmp___11, "concat_args", "str", len + 2L, tmp___10);
#line 1350
    tmp___12 = 0;
    }
  }
  {
#line 1351
  n = *(tmp___1 + 0);
#line 1352
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)n->sub.val.sp,
         n->sub.val.slen);
#line 1353
  p = str + n->sub.val.slen;
#line 1354
  i___0 = 1;
  }
  {
#line 1354
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1354
    if (! (i___0 < count)) {
#line 1354
      goto while_break___0;
    }
#line 1355
    if (subseplen == 1L) {
#line 1356
      tmp___13 = p;
#line 1356
      p ++;
#line 1356
      *tmp___13 = *subsep;
    } else
#line 1357
    if (subseplen > 0L) {
      {
#line 1358
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)subsep,
             (size_t )subseplen);
#line 1359
      p += subseplen;
      }
    }
    {
#line 1362
    n = *(tmp___1 + i___0);
#line 1363
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)n->sub.val.sp,
           n->sub.val.slen);
#line 1364
    p += n->sub.val.slen;
#line 1354
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1366
  *(str + len) = (char )'\000';
#line 1367
  free((void *)tmp___1);
#line 1368
  tmp___14 = make_str_node((char const   *)str, (size_t )len, 2);
  }
#line 1368
  return (tmp___14);
}
}
#line 1375 "command.y"
static int find_command(char const   *token , size_t toklen ) 
{ 
  char *name ;
  char *abrv ;
  int i___0 ;
  int k ;
  _Bool try_exact ;
  int abrv_match ;
  int partial_match ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 1380
  try_exact = (_Bool)1;
#line 1381
  abrv_match = -1;
#line 1382
  partial_match = -1;
#line 1394
  k = (int )(sizeof(zz_debug_cmdtab) / sizeof(zz_debug_cmdtab[0]) - 1UL);
#line 1395
  i___0 = 0;
  {
#line 1395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1395
    if (! (i___0 < k)) {
#line 1395
      goto while_break;
    }
#line 1396
    name = (char *)zz_debug_cmdtab[i___0].name;
#line 1397
    if (try_exact) {
#line 1397
      if ((int const   )*token == (int const   )*name) {
        {
#line 1397
        tmp___1 = strlen((char const   *)name);
        }
#line 1397
        if (toklen == tmp___1) {
          {
#line 1397
          tmp___2 = strncmp((char const   *)name, token, toklen);
          }
#line 1397
          if (tmp___2 == 0) {
#line 1401
            return (i___0);
          }
        }
      }
    }
#line 1403
    if ((int )*name > (int )*token) {
#line 1404
      try_exact = (_Bool)0;
    } else
#line 1403
    if (i___0 == k - 1) {
#line 1404
      try_exact = (_Bool)0;
    }
#line 1406
    if (abrv_match < 0) {
#line 1407
      abrv = zz_debug_cmdtab[i___0].abbrvn;
#line 1408
      if ((int )*(abrv + 0) == (int )*(token + 0)) {
#line 1409
        if (toklen == 1UL) {
#line 1409
          if (! *(abrv + 1)) {
#line 1410
            abrv_match = i___0;
          } else {
#line 1409
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1411
        if (toklen == 2UL) {
#line 1411
          if ((int )*(abrv + 1) == (int )*(token + 1)) {
#line 1412
            abrv_match = i___0;
          }
        }
      }
    }
#line 1415
    if (! try_exact) {
#line 1415
      if (abrv_match >= 0) {
#line 1416
        return (abrv_match);
      }
    }
#line 1417
    if (partial_match < 0) {
#line 1418
      if ((int const   )*token == (int const   )*name) {
        {
#line 1418
        tmp___5 = strlen((char const   *)name);
        }
#line 1418
        if (toklen < tmp___5) {
          {
#line 1418
          tmp___6 = strncmp((char const   *)name, token, toklen);
          }
#line 1418
          if (tmp___6 == 0) {
#line 1422
            if (i___0 == k - 1) {
#line 1422
              goto _L___0;
            } else {
              {
#line 1422
              tmp___3 = strncmp(zz_debug_cmdtab[i___0 + 1].name, token, toklen);
              }
#line 1422
              if (tmp___3 != 0) {
                _L___0: /* CIL Label */ 
#line 1422
                if (i___0 == 0) {
#line 1425
                  partial_match = i___0;
                } else {
                  {
#line 1422
                  tmp___4 = strncmp(zz_debug_cmdtab[i___0 - 1].name, token, toklen);
                  }
#line 1422
                  if (tmp___4 != 0) {
#line 1425
                    partial_match = i___0;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1395
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1429
  return (partial_match);
}
}
#line 1434 "command.y"
int do_help(CMDARG *arg , int cmd ) 
{ 
  int i___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *name ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1438
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 1439
    initialize_pager(out_fp);
#line 1440
    tmp___2 = _setjmp((struct __jmp_buf_tag *)(pager_quit_tag));
    }
#line 1440
    if (tmp___2 == 0) {
#line 1441
      i___0 = 0;
      {
#line 1441
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1441
        if (! ((unsigned long )zz_debug_cmdtab[i___0].name != (unsigned long )((void *)0))) {
#line 1441
          goto while_break;
        }
        {
#line 1442
        gprintf(out_fp, "%s:\n", zz_debug_cmdtab[i___0].name);
#line 1443
        tmp___1 = gettext(zz_debug_cmdtab[i___0].help_txt);
#line 1443
        gprintf(out_fp, "\t%s\n", tmp___1);
#line 1441
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else
#line 1446
  if ((unsigned int )arg->type == 44U) {
    {
#line 1448
    name = arg->value.sval;
#line 1449
    tmp___3 = strlen((char const   *)name);
#line 1449
    i___0 = find_command((char const   *)name, tmp___3);
    }
#line 1450
    if (i___0 >= 0) {
      {
#line 1451
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)"%s\n",
              zz_debug_cmdtab[i___0].help_txt);
#line 1452
      tmp___4 = strcmp(zz_debug_cmdtab[i___0].name, "option");
      }
#line 1452
      if (tmp___4 == 0) {
        {
#line 1453
        option_help();
        }
      }
    } else {
      {
#line 1455
      tmp___5 = gettext("undefined command: %s\n");
#line 1455
      fprintf((FILE */* __restrict  */)out_fp, (char const   */* __restrict  */)tmp___5,
              name);
      }
    }
  }
#line 1458
  return (0);
}
}
#line 1466 "command.y"
static char *next_word(char *p , int len , char **endp ) 
{ 
  char *q ;
  int i___0 ;

  {
#line 1472
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1473
    return ((char *)((void *)0));
  } else
#line 1472
  if (len <= 0) {
#line 1473
    return ((char *)((void *)0));
  }
#line 1474
  i___0 = 0;
  {
#line 1474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1474
    if (! (i___0 < len)) {
#line 1474
      goto while_break;
    }
#line 1475
    if ((int )*p != 32) {
#line 1475
      if ((int )*p != 9) {
#line 1476
        goto while_break;
      }
    }
#line 1474
    i___0 ++;
#line 1474
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1477
  if (i___0 == len) {
#line 1478
    return ((char *)((void *)0));
  }
#line 1479
  if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 1480
    i___0 ++;
#line 1480
    q = p + 1;
    {
#line 1480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1480
      if (! (i___0 < len)) {
#line 1480
        goto while_break___0;
      }
#line 1481
      if ((int )*q == 32) {
#line 1482
        goto while_break___0;
      } else
#line 1481
      if ((int )*q == 9) {
#line 1482
        goto while_break___0;
      }
#line 1480
      i___0 ++;
#line 1480
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1483
    *endp = q;
  }
#line 1485
  return (p);
}
}
#line 1500 "command.y"
char **command_completion(char const   *text , int start , int end ) 
{ 
  char *cmdtok ;
  char *e ;
  int idx___3 ;
  int len ;
  char **tmp___1 ;
  char **tmp___2 ;
  char **tmp___3 ;
  char **tmp___4 ;
  char **tmp___5 ;
  char *tmp___6 ;
  char **tmp___7 ;

  {
  {
#line 1507
  rl_attempted_completion_over = 1;
#line 1509
  this_cmd = 0;
#line 1510
  len = start;
#line 1511
  cmdtok = next_word(rl_line_buffer, len, & e);
  }
#line 1511
  if ((unsigned long )cmdtok == (unsigned long )((void *)0)) {
    {
#line 1512
    tmp___1 = rl_completion_matches(text, & command_generator);
    }
#line 1512
    return (tmp___1);
  }
  {
#line 1513
  len = (int )((long )len - (e - rl_line_buffer));
#line 1515
  idx___3 = find_command((char const   *)cmdtok, (size_t )(e - cmdtok));
  }
#line 1516
  if (idx___3 < 0) {
#line 1517
    return ((char **)((void *)0));
  }
  {
#line 1518
  this_cmd = (int )zz_debug_cmdtab[idx___3].type;
#line 1520
  tmp___6 = next_word(e, len, (char **)((void *)0));
  }
#line 1520
  if (! tmp___6) {
    {
#line 1526
    if (this_cmd == 3) {
#line 1526
      goto case_3;
    }
#line 1526
    if (this_cmd == 35) {
#line 1526
      goto case_3;
    }
#line 1526
    if (this_cmd == 38) {
#line 1526
      goto case_3;
    }
#line 1526
    if (this_cmd == 20) {
#line 1526
      goto case_3;
    }
#line 1526
    if (this_cmd == 2) {
#line 1526
      goto case_3;
    }
#line 1531
    if (this_cmd == 17) {
#line 1531
      goto case_17;
    }
#line 1531
    if (this_cmd == 36) {
#line 1531
      goto case_17;
    }
#line 1531
    if (this_cmd == 12) {
#line 1531
      goto case_17;
    }
#line 1531
    if (this_cmd == 19) {
#line 1531
      goto case_17;
    }
#line 1533
    if (this_cmd == 23) {
#line 1533
      goto case_23;
    }
#line 1539
    if (this_cmd == 41) {
#line 1539
      goto case_41;
    }
#line 1539
    if (this_cmd == 9) {
#line 1539
      goto case_41;
    }
#line 1539
    if (this_cmd == 30) {
#line 1539
      goto case_41;
    }
#line 1539
    if (this_cmd == 25) {
#line 1539
      goto case_41;
    }
#line 1539
    if (this_cmd == 24) {
#line 1539
      goto case_41;
    }
#line 1541
    goto switch_default;
    case_3: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 1527
    tmp___2 = rl_completion_matches(text, & srcfile_generator);
    }
#line 1527
    return (tmp___2);
    case_17: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_19: /* CIL Label */ 
    {
#line 1532
    tmp___3 = rl_completion_matches(text, & argument_generator);
    }
#line 1532
    return (tmp___3);
    case_23: /* CIL Label */ 
    {
#line 1534
    tmp___4 = rl_completion_matches(text, & option_generator);
    }
#line 1534
    return (tmp___4);
    case_41: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    {
#line 1540
    tmp___5 = rl_completion_matches(text, & variable_generator);
    }
#line 1540
    return (tmp___5);
    switch_default: /* CIL Label */ 
#line 1542
    return ((char **)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 1546
  if (this_cmd == 24) {
    {
#line 1547
    tmp___7 = rl_completion_matches(text, & variable_generator);
    }
#line 1547
    return (tmp___7);
  } else
#line 1546
  if (this_cmd == 25) {
    {
#line 1547
    tmp___7 = rl_completion_matches(text, & variable_generator);
    }
#line 1547
    return (tmp___7);
  }
#line 1548
  return ((char **)((void *)0));
}
}
#line 1556 "command.y"
static size_t textlen___0  ;
#line 1557 "command.y"
static int idx___0  =    0;
#line 1553 "command.y"
static char *command_generator(char const   *text , int state___2 ) 
{ 
  char *name ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1560
  if (! state___2) {
    {
#line 1561
    textlen___0 = strlen(text);
#line 1562
    idx___0 = 0;
    }
  }
  {
#line 1564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1564
    name = (char *)zz_debug_cmdtab[idx___0].name;
#line 1564
    if (! ((unsigned long )name != (unsigned long )((void *)0))) {
#line 1564
      goto while_break;
    }
    {
#line 1565
    idx___0 ++;
#line 1566
    tmp___3 = strncmp((char const   *)name, text, textlen___0);
    }
#line 1566
    if (tmp___3 == 0) {
      {
#line 1567
      tmp___1 = strlen((char const   *)name);
#line 1567
      tmp___2 = estrdup((char const   *)name, tmp___1);
      }
#line 1567
      return (tmp___2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1569
  return ((char *)((void *)0));
}
}
#line 1577 "command.y"
static size_t textlen___1  ;
#line 1578 "command.y"
static SRCFILE *s  ;
#line 1574 "command.y"
static char *srcfile_generator(char const   *text , int state___2 ) 
{ 
  char *name ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1582
  if (! state___2) {
    {
#line 1583
    textlen___1 = strlen(text);
#line 1584
    s = srcfiles->next;
    }
  }
  {
#line 1586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1586
    if (! ((unsigned long )s != (unsigned long )srcfiles)) {
#line 1586
      goto while_break;
    }
#line 1587
    if ((unsigned int )s->stype != 3U) {
#line 1587
      if ((unsigned int )s->stype != 4U) {
#line 1588
        s = s->next;
#line 1589
        goto while_continue;
      }
    }
    {
#line 1591
    name = s->src;
#line 1592
    s = s->next;
#line 1593
    tmp___3 = strncmp((char const   *)name, text, textlen___1);
    }
#line 1593
    if (tmp___3 == 0) {
      {
#line 1594
      tmp___1 = strlen((char const   *)name);
#line 1594
      tmp___2 = estrdup((char const   *)name, tmp___1);
      }
#line 1594
      return (tmp___2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1596
  return ((char *)((void *)0));
}
}
#line 1604 "command.y"
static size_t textlen___2  ;
#line 1605 "command.y"
static int idx___1  ;
#line 1601 "command.y"
static char *argument_generator(char const   *text , int state___2 ) 
{ 
  char const   *name ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 1608
  if (! state___2) {
    {
#line 1609
    textlen___2 = strlen(text);
#line 1610
    idx___1 = 0;
    }
  }
#line 1613
  if (this_cmd == 17) {
    {
#line 1614
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1614
      tmp___4 = idx___1;
#line 1614
      idx___1 ++;
#line 1614
      name = zz_debug_cmdtab[tmp___4].name;
#line 1614
      if (! ((unsigned long )name != (unsigned long )((void *)0))) {
#line 1614
        goto while_break;
      }
      {
#line 1615
      tmp___3 = strncmp(name, text, textlen___2);
      }
#line 1615
      if (tmp___3 == 0) {
        {
#line 1616
        tmp___1 = strlen(name);
#line 1616
        tmp___2 = estrdup(name, tmp___1);
        }
#line 1616
        return (tmp___2);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1619
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1619
      name = zz_debug_argtab[idx___1].name;
#line 1619
      if (! ((unsigned long )name != (unsigned long )((void *)0))) {
#line 1619
        goto while_break___0;
      }
#line 1620
      tmp___5 = idx___1;
#line 1620
      idx___1 ++;
#line 1620
      if ((unsigned int )this_cmd != (unsigned int )zz_debug_argtab[tmp___5].cmd) {
#line 1621
        goto while_continue___0;
      }
      {
#line 1622
      tmp___8 = strncmp(name, text, textlen___2);
      }
#line 1622
      if (tmp___8 == 0) {
        {
#line 1623
        tmp___6 = strlen(name);
#line 1623
        tmp___7 = estrdup(name, tmp___6);
        }
#line 1623
        return (tmp___7);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1626
  return ((char *)((void *)0));
}
}
#line 1634 "command.y"
static size_t textlen___3  ;
#line 1635 "command.y"
static int idx___2  =    0;
#line 1636 "command.y"
static NODE *func___0  =    (NODE *)((void *)0);
#line 1637 "command.y"
static NODE **vars  =    (NODE **)((void *)0);
#line 1631 "command.y"
static char *variable_generator(char const   *text , int state___2 ) 
{ 
  char const   *name ;
  NODE *r ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1641
  if (! state___2) {
    {
#line 1642
    textlen___3 = strlen(text);
    }
#line 1643
    if ((unsigned long )vars != (unsigned long )((void *)0)) {
      {
#line 1644
      free((void *)vars);
      }
    }
    {
#line 1645
    vars = variable_list();
#line 1646
    idx___2 = 0;
#line 1647
    func___0 = get_function();
    }
  }
  {
#line 1651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1651
    if (! ((unsigned long )func___0 != (unsigned long )((void *)0))) {
#line 1651
      goto while_break;
    }
#line 1652
    if ((long )idx___2 >= func___0->sub.nodep.l.ll) {
#line 1653
      func___0 = (NODE *)((void *)0);
#line 1654
      idx___2 = 0;
#line 1655
      goto while_break;
    }
    {
#line 1657
    tmp___1 = idx___2;
#line 1657
    idx___2 ++;
#line 1657
    name = (char const   *)(func___0->sub.nodep.rn + tmp___1)->sub.nodep.name;
#line 1658
    tmp___4 = strncmp(name, text, textlen___3);
    }
#line 1658
    if (tmp___4 == 0) {
      {
#line 1659
      tmp___2 = strlen(name);
#line 1659
      tmp___3 = estrdup(name, tmp___2);
      }
#line 1659
      return (tmp___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1663
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1663
    tmp___8 = idx___2;
#line 1663
    idx___2 ++;
#line 1663
    r = *(vars + tmp___8);
#line 1663
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 1663
      goto while_break___0;
    }
    {
#line 1664
    name = (char const   *)r->sub.nodep.name;
#line 1665
    tmp___7 = strncmp(name, text, textlen___3);
    }
#line 1665
    if (tmp___7 == 0) {
      {
#line 1666
      tmp___5 = strlen(name);
#line 1666
      tmp___6 = estrdup(name, tmp___5);
      }
#line 1666
      return (tmp___6);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1669
  return ((char *)((void *)0));
}
}
#line 1674 "command.y"
static void history_expand_line(char **line ) 
{ 
  int ret ;
  char *expansion ;

  {
#line 1680
  if (! *line) {
#line 1681
    return;
  } else
#line 1680
  if (input_fd != 0) {
#line 1681
    return;
  } else
#line 1680
  if (! input_from_tty) {
#line 1681
    return;
  }
  {
#line 1682
  using_history();
#line 1683
  ret = history_expand(*line, & expansion);
  }
#line 1684
  if (ret < 0) {
    {
#line 1685
    free((void *)expansion);
    }
  } else
#line 1684
  if (ret == 2) {
    {
#line 1685
    free((void *)expansion);
    }
  } else {
    {
#line 1687
    free((void *)*line);
#line 1688
    *line = expansion;
    }
  }
#line 1690
  return;
}
}
#line 1060 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
afunc_t cint_array_func[11] ;
#line 39 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static int NHAT  =    10;
#line 40 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static long THRESHOLD  ;
#line 48
static NODE **cint_array_init(NODE *symbol  __attribute__((__unused__)) , NODE *subs  __attribute__((__unused__)) ) ;
#line 49
static NODE **is_uinteger(NODE *symbol , NODE *subs ) ;
#line 50
static NODE **cint_lookup(NODE *symbol , NODE *subs ) ;
#line 51
static NODE **cint_exists(NODE *symbol , NODE *subs ) ;
#line 52
static NODE **cint_clear(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) ;
#line 53
static NODE **cint_remove(NODE *symbol , NODE *subs ) ;
#line 54
static NODE **cint_list(NODE *symbol , NODE *t ) ;
#line 55
static NODE **cint_copy(NODE *symbol , NODE *newsymb ) ;
#line 56
static NODE **cint_dump(NODE *symbol , NODE *ndump___0 ) ;
#line 61 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
afunc_t cint_array_func[11]  = 
#line 61
  {      & cint_array_init,      & is_uinteger,      & null_length,      & cint_lookup, 
        & cint_exists,      & cint_clear,      & cint_remove,      & cint_list, 
        & cint_copy,      & cint_dump,      (struct exp_node **(*)(struct exp_node * , struct exp_node * ))0};
#line 75
__inline static int cint_hash(long k ) ;
#line 76
__inline static NODE **cint_find(NODE *symbol , long k , int h1 ) ;
#line 78
__inline static NODE *make_node(NODETYPE type ) ;
#line 80
static NODE **tree_lookup(NODE *symbol , NODE *tree , long k , int m , long base ) ;
#line 81
static NODE **tree_exists(NODE *tree , long k ) ;
#line 82
static void tree_clear(NODE *tree ) ;
#line 83
static int tree_remove(NODE *symbol , NODE *tree , long k ) ;
#line 84
static void tree_copy(NODE *newsymb , NODE *tree , NODE *newtree ) ;
#line 85
static long tree_list(NODE *tree , NODE **list , assoc_kind_t assoc_kind ) ;
#line 86
__inline static NODE **tree_find(NODE *tree , long k , int i___0 ) ;
#line 87
static void tree_info(NODE *tree , NODE *ndump___0 , char const   *aname___0 ) ;
#line 88
static size_t tree_kilobytes(NODE *tree ) ;
#line 93
__inline static NODE **leaf_lookup(NODE *symbol , NODE *array , long k , long size ,
                                   long base ) ;
#line 94
__inline static NODE **leaf_exists(NODE *array , long k ) ;
#line 95
static void leaf_clear(NODE *array ) ;
#line 96
static int leaf_remove(NODE *symbol , NODE *array , long k ) ;
#line 97
static void leaf_copy(NODE *newsymb , NODE *array , NODE *newarray ) ;
#line 98
static long leaf_list(NODE *array , NODE **list , assoc_kind_t assoc_kind ) ;
#line 99
static void leaf_info(NODE *array , NODE *ndump___0 , char const   *aname___0 ) ;
#line 105 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static long const   power_two_table[31]  = 
#line 105
  {      (long const   )1,      (long const   )2,      (long const   )4,      (long const   )8, 
        (long const   )16,      (long const   )32,      (long const   )64,      (long const   )128, 
        (long const   )256,      (long const   )512,      (long const   )1024,      (long const   )2048, 
        (long const   )4096,      (long const   )8192,      (long const   )16384,      (long const   )32768, 
        (long const   )65536,      (long const   )131072,      (long const   )262144,      (long const   )524288, 
        (long const   )1048576,      (long const   )2097152,      (long const   )4194304,      (long const   )8388608, 
        (long const   )16777216,      (long const   )33554432,      (long const   )67108864,      (long const   )134217728, 
        (long const   )268435456,      (long const   )536870912,      (long const   )1073741824};
#line 148 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **cint_array_init(NODE *symbol  __attribute__((__unused__)) , NODE *subs  __attribute__((__unused__)) ) 
{ 
  long newval ;
  char *__cil_tmp4 ;

  {
#line 151
  if ((unsigned long )symbol == (unsigned long )((void *)0)) {
    {
#line 155
    newval = getenv_long("NHAT");
    }
#line 155
    if (newval > 1L) {
#line 155
      if (newval < 32L) {
#line 156
        NHAT = (int )newval;
      }
    }
#line 157
    THRESHOLD = (long )power_two_table[NHAT + 1];
  } else {
    {
#line 159
    null_array(symbol);
    }
  }
#line 161
  return ((NODE **)(! ((void *)0)));
}
}
#line 167 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **is_uinteger(NODE *symbol , NODE *subs ) 
{ 
  NODE **tmp___1 ;

  {
  {
#line 170
  tmp___1 = is_integer(symbol, subs);
  }
#line 170
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 170
    if (subs->sub.val.nm.fltnum >= (double )0) {
#line 171
      return ((NODE **)(! ((void *)0)));
    }
  }
#line 172
  return ((NODE **)((void *)0));
}
}
#line 178 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **cint_lookup(NODE *symbol , NODE *subs ) 
{ 
  NODE **lhs ;
  long k ;
  int h1 ;
  int m ;
  int li ;
  NODE *tn ;
  NODE *xn ;
  long cint_size ;
  long capacity ;
  NODE **tmp___1 ;
  struct exp_node **tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  NODE **tmp___8 ;
  NODE **tmp___9 ;
  struct exp_node *tmp___10 ;
  NODE **tmp___11 ;
  struct exp_node **tmp___12 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 183
  h1 = -1;
#line 187
  k = -1L;
#line 188
  if ((subs->flags & 256U) != 0U) {
#line 188
    goto _L;
  } else {
    {
#line 188
    tmp___1 = is_integer(symbol, subs);
    }
#line 188
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 188
      if (subs->sub.val.nm.fltnum >= (double )0) {
        {
#line 189
        k = (long )subs->sub.val.nm.fltnum;
#line 190
        h1 = cint_hash(k);
#line 191
        lhs = cint_find(symbol, k, h1);
        }
#line 191
        if ((unsigned long )lhs != (unsigned long )((void *)0)) {
#line 192
          return (lhs);
        }
      }
    }
  }
#line 194
  xn = symbol->sub.nodep.rn;
#line 195
  if ((unsigned long )xn != (unsigned long )((void *)0)) {
    {
#line 195
    lhs = (*(*(xn->sub.nodep.l.lp + 4)))(xn, subs);
    }
#line 195
    if ((unsigned long )lhs != (unsigned long )((void *)0)) {
#line 196
      return (lhs);
    }
  }
#line 200
  if (k < 0L) {
#line 201
    goto xinstall;
  }
#line 203
  m = h1 - 1;
#line 208
  if (m > NHAT) {
#line 208
    li = m;
  } else {
#line 208
    li = NHAT;
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (li >= NHAT)) {
#line 209
      goto while_break;
    }
#line 211
    li = (li + 1) / 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  capacity = (long )(symbol->sub.nodep.reserved + (size_t )power_two_table[li]);
#line 215
  if ((unsigned long )xn == (unsigned long )((void *)0)) {
#line 215
    cint_size = (long )symbol->sub.nodep.reflags;
  } else {
#line 215
    cint_size = (long )(symbol->sub.nodep.reflags - xn->sub.nodep.reflags);
  }
#line 218
  if (capacity - cint_size > THRESHOLD) {
#line 219
    goto xinstall;
  }
#line 221
  if ((unsigned long )symbol->sub.nodep.r.av == (unsigned long )((void *)0)) {
    {
#line 222
    symbol->sub.nodep.reserved = (size_t )0;
#line 226
    tmp___3 = malloc(32UL * sizeof(NODE *));
#line 226
    tmp___2 = (NODE **)tmp___3;
#line 226
    symbol->sub.nodep.r.av = tmp___2;
    }
#line 226
    if (tmp___2) {
#line 226
      tmp___7 = 1;
    } else {
      {
#line 226
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c", 226);
#line 226
      tmp___4 = __errno_location();
#line 226
      tmp___5 = strerror(*tmp___4);
#line 226
      tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 226
      r_fatal((char const   *)tmp___6, "cint_lookup", "symbol->nodes", (long )(32UL * sizeof(NODE *)),
              tmp___5);
#line 226
      tmp___7 = 0;
      }
    }
    {
#line 227
    memset((void *)symbol->sub.nodep.r.av, '\000', 32UL * sizeof(NODE *));
    }
  }
#line 230
  (symbol->sub.nodep.reflags) ++;
#line 232
  tn = *(symbol->sub.nodep.r.av + h1);
#line 233
  if ((unsigned long )tn == (unsigned long )((void *)0)) {
    {
#line 234
    tn = make_node((NODETYPE )12);
#line 235
    *(symbol->sub.nodep.r.av + h1) = tn;
    }
  }
#line 238
  if (m < NHAT) {
    {
#line 239
    tmp___8 = tree_lookup(symbol, tn, k, NHAT, 0L);
    }
#line 239
    return (tmp___8);
  }
  {
#line 240
  tmp___9 = tree_lookup(symbol, tn, k, m, (long )power_two_table[m]);
  }
#line 240
  return (tmp___9);
  xinstall: 
#line 244
  (symbol->sub.nodep.reflags) ++;
#line 245
  if ((unsigned long )xn == (unsigned long )((void *)0)) {
    {
#line 246
    tmp___10 = make_array();
#line 246
    symbol->sub.nodep.rn = tmp___10;
#line 246
    xn = tmp___10;
#line 247
    xn->sub.nodep.name = symbol->sub.nodep.name;
#line 254
    tmp___11 = is_integer(xn, subs);
    }
#line 254
    if (tmp___11) {
#line 255
      xn->sub.nodep.l.lp = int_array_func;
    } else {
#line 257
      xn->sub.nodep.l.lp = str_array_func;
    }
#line 258
    xn->flags |= 65536U;
  }
  {
#line 260
  tmp___12 = (*(*(xn->sub.nodep.l.lp + 3)))(xn, subs);
  }
#line 260
  return (tmp___12);
}
}
#line 266 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **cint_exists(NODE *symbol , NODE *subs ) 
{ 
  NODE *xn ;
  long k ;
  NODE **lhs ;
  int tmp___1 ;
  NODE **tmp___2 ;
  struct exp_node **tmp___3 ;

  {
#line 271
  if ((subs->flags & 256U) != 0U) {
#line 271
    goto _L;
  } else {
    {
#line 271
    tmp___2 = is_integer(symbol, subs);
    }
#line 271
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 271
      if (subs->sub.val.nm.fltnum >= (double )0) {
        {
#line 272
        k = (long )subs->sub.val.nm.fltnum;
#line 274
        tmp___1 = cint_hash(k);
#line 274
        lhs = cint_find(symbol, k, tmp___1);
        }
#line 274
        if ((unsigned long )lhs != (unsigned long )((void *)0)) {
#line 275
          return (lhs);
        }
      }
    }
  }
#line 277
  xn = symbol->sub.nodep.rn;
#line 277
  if ((unsigned long )xn == (unsigned long )((void *)0)) {
#line 278
    return ((NODE **)((void *)0));
  }
  {
#line 279
  tmp___3 = (*(*(xn->sub.nodep.l.lp + 4)))(xn, subs);
  }
#line 279
  return (tmp___3);
}
}
#line 285 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **cint_clear(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) 
{ 
  size_t i___0 ;
  NODE *tn ;
  NODE *xn ;

  {
#line 293
  if ((unsigned long )symbol->sub.nodep.rn != (unsigned long )((void *)0)) {
    {
#line 294
    xn = symbol->sub.nodep.rn;
#line 295
    (*(*(xn->sub.nodep.l.lp + 5)))(xn, (struct exp_node *)((void *)0));
#line 296
    ((BLOCK *)xn)->freep = nextfree[1].freep;
#line 296
    nextfree[1].freep = (BLOCK *)xn;
#line 297
    symbol->sub.nodep.rn = (struct exp_node *)((void *)0);
    }
  }
#line 300
  i___0 = (size_t )NHAT;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (i___0 < 32UL)) {
#line 300
      goto while_break;
    }
#line 301
    tn = *(symbol->sub.nodep.r.av + i___0);
#line 302
    if ((unsigned long )tn != (unsigned long )((void *)0)) {
      {
#line 303
      tree_clear(tn);
#line 304
      ((BLOCK *)tn)->freep = nextfree[1].freep;
#line 304
      nextfree[1].freep = (BLOCK *)tn;
      }
    }
#line 300
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  free((void *)symbol->sub.nodep.r.av);
#line 309
  (*(*(symbol->sub.nodep.l.lp + 0)))(symbol, (struct exp_node *)((void *)0));
  }
#line 310
  return ((NODE **)((void *)0));
}
}
#line 316 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **cint_remove(NODE *symbol , NODE *subs ) 
{ 
  long k ;
  int h1 ;
  NODE *tn ;
  NODE *xn ;
  NODE **tmp___1 ;
  int tmp___2 ;
  struct exp_node **tmp___3 ;

  {
#line 321
  xn = symbol->sub.nodep.rn;
#line 323
  if (symbol->sub.nodep.reflags == 0UL) {
#line 324
    return ((NODE **)((void *)0));
  }
#line 326
  if ((subs->flags & 256U) != 0U) {
#line 326
    goto _L;
  } else {
    {
#line 326
    tmp___1 = is_integer(symbol, subs);
    }
#line 326
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 326
      if (! (subs->sub.val.nm.fltnum >= (double )0)) {
#line 327
        goto xremove;
      }
    } else {
#line 327
      goto xremove;
    }
  }
  {
#line 331
  k = (long )subs->sub.val.nm.fltnum;
#line 332
  h1 = cint_hash(k);
#line 333
  tn = *(symbol->sub.nodep.r.av + h1);
  }
#line 334
  if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 335
    goto xremove;
  } else {
    {
#line 334
    tmp___2 = tree_remove(symbol, tn, k);
    }
#line 334
    if (! tmp___2) {
#line 335
      goto xremove;
    }
  }
#line 337
  if (tn->sub.nodep.reflags == 0UL) {
#line 338
    ((BLOCK *)tn)->freep = nextfree[1].freep;
#line 338
    nextfree[1].freep = (BLOCK *)tn;
#line 339
    *(symbol->sub.nodep.r.av + h1) = (struct exp_node *)((void *)0);
  }
#line 342
  (symbol->sub.nodep.reflags) --;
#line 344
  if ((unsigned long )xn == (unsigned long )((void *)0)) {
#line 344
    if (symbol->sub.nodep.reflags == 0UL) {
      {
#line 345
      free((void *)symbol->sub.nodep.r.av);
#line 346
      (*(*(symbol->sub.nodep.l.lp + 0)))(symbol, (struct exp_node *)((void *)0));
      }
    } else {
#line 344
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 347
  if ((unsigned long )xn != (unsigned long )((void *)0)) {
#line 347
    if (symbol->sub.nodep.reflags == xn->sub.nodep.reflags) {
      {
#line 350
      xn->flags &= 4294901759U;
#line 351
      xn->sub.nodep.x.extra = symbol->sub.nodep.x.extra;
#line 352
      free((void *)symbol->sub.nodep.r.av);
#line 353
      *symbol = *xn;
#line 354
      ((BLOCK *)xn)->freep = nextfree[1].freep;
#line 354
      nextfree[1].freep = (BLOCK *)xn;
      }
    }
  }
#line 357
  return ((NODE **)(! ((void *)0)));
  xremove: 
#line 360
  xn = symbol->sub.nodep.rn;
#line 361
  if ((unsigned long )xn == (unsigned long )((void *)0)) {
#line 362
    return ((NODE **)((void *)0));
  } else {
    {
#line 361
    tmp___3 = (*(*(xn->sub.nodep.l.lp + 6)))(xn, subs);
    }
#line 361
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 362
      return ((NODE **)((void *)0));
    }
  }
#line 363
  if (xn->sub.nodep.reflags == 0UL) {
#line 364
    ((BLOCK *)xn)->freep = nextfree[1].freep;
#line 364
    nextfree[1].freep = (BLOCK *)xn;
#line 365
    symbol->sub.nodep.rn = (struct exp_node *)((void *)0);
  }
#line 367
  (symbol->sub.nodep.reflags) --;
#line 370
  return ((NODE **)(! ((void *)0)));
}
}
#line 376 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **cint_copy(NODE *symbol , NODE *newsymb ) 
{ 
  NODE **old ;
  NODE **new ;
  size_t i___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  NODE *xn ;
  NODE *n ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 385
  tmp___1 = malloc(32UL * sizeof(NODE *));
#line 385
  new = (NODE **)tmp___1;
  }
#line 385
  if (new) {
#line 385
    tmp___5 = 1;
  } else {
    {
#line 385
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c", 385);
#line 385
    tmp___2 = __errno_location();
#line 385
    tmp___3 = strerror(*tmp___2);
#line 385
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 385
    r_fatal((char const   *)tmp___4, "cint_copy", "new", (long )(32UL * sizeof(NODE *)),
            tmp___3);
#line 385
    tmp___5 = 0;
    }
  }
  {
#line 386
  memset((void *)new, '\000', 32UL * sizeof(NODE *));
#line 388
  old = symbol->sub.nodep.r.av;
#line 389
  i___0 = (size_t )NHAT;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (i___0 < 32UL)) {
#line 389
      goto while_break;
    }
#line 390
    if ((unsigned long )*(old + i___0) == (unsigned long )((void *)0)) {
#line 391
      goto __Cont;
    }
    {
#line 392
    *(new + i___0) = make_node((NODETYPE )12);
#line 393
    tree_copy(newsymb, *(old + i___0), *(new + i___0));
    }
    __Cont: /* CIL Label */ 
#line 389
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  if ((unsigned long )symbol->sub.nodep.rn != (unsigned long )((void *)0)) {
    {
#line 398
    xn = symbol->sub.nodep.rn;
#line 399
    n = make_array();
#line 400
    n->sub.nodep.name = newsymb->sub.nodep.name;
#line 401
    (*(*(xn->sub.nodep.l.lp + 8)))(xn, n);
#line 402
    newsymb->sub.nodep.rn = n;
    }
  } else {
#line 404
    newsymb->sub.nodep.rn = (struct exp_node *)((void *)0);
  }
#line 406
  newsymb->sub.nodep.r.av = new;
#line 407
  newsymb->sub.nodep.reflags = symbol->sub.nodep.reflags;
#line 408
  newsymb->sub.nodep.reserved = symbol->sub.nodep.reserved;
#line 409
  newsymb->flags = symbol->flags;
#line 411
  return ((NODE **)((void *)0));
}
}
#line 417 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **cint_list(NODE *symbol , NODE *t ) 
{ 
  NODE **list ;
  NODE *tn ;
  NODE *xn ;
  unsigned long k ;
  unsigned long num_elems ;
  unsigned long list_size___0 ;
  size_t j ;
  size_t ja ;
  size_t jd ;
  int elem_size ;
  assoc_kind_t assoc_kind ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  long tmp___13 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 420
  list = (NODE **)((void *)0);
#line 422
  k = 0UL;
#line 424
  elem_size = 1;
#line 427
  num_elems = symbol->sub.nodep.reflags;
#line 428
  if (num_elems == 0UL) {
#line 429
    return ((NODE **)((void *)0));
  }
#line 430
  assoc_kind = (assoc_kind_t )t->flags;
#line 431
  if (((unsigned int )assoc_kind & 259U) == 257U) {
#line 432
    num_elems = 1UL;
  }
#line 434
  if (((unsigned int )assoc_kind & 3U) == 3U) {
#line 435
    elem_size = 2;
  }
#line 436
  list_size___0 = num_elems * (unsigned long )elem_size;
#line 438
  if ((unsigned long )symbol->sub.nodep.rn != (unsigned long )((void *)0)) {
    {
#line 439
    xn = symbol->sub.nodep.rn;
#line 440
    list = (*(*(xn->sub.nodep.l.lp + 7)))(xn, t);
#line 442
    assoc_kind = (assoc_kind_t )((unsigned int )assoc_kind & 4294967103U);
#line 443
    t->flags = (unsigned int )assoc_kind;
    }
#line 444
    if (num_elems == 1UL) {
#line 445
      return (list);
    } else
#line 444
    if (num_elems == xn->sub.nodep.reflags) {
#line 445
      return (list);
    }
    {
#line 446
    tmp___1 = realloc((void *)((char *)list), list_size___0 * sizeof(NODE *));
#line 446
    list = (NODE **)tmp___1;
    }
#line 446
    if (list) {
#line 446
      tmp___5 = 1;
    } else {
      {
#line 446
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c", 446);
#line 446
      tmp___2 = __errno_location();
#line 446
      tmp___3 = strerror(*tmp___2);
#line 446
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 446
      r_fatal((char const   *)tmp___4, "cint_list", "list", (long )(list_size___0 * sizeof(NODE *)),
              tmp___3);
#line 446
      tmp___5 = 0;
      }
    }
#line 447
    k = (unsigned long )elem_size * xn->sub.nodep.reflags;
  } else {
    {
#line 449
    tmp___6 = malloc(list_size___0 * sizeof(NODE *));
#line 449
    list = (NODE **)tmp___6;
    }
#line 449
    if (list) {
#line 449
      tmp___10 = 1;
    } else {
      {
#line 449
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c", 449);
#line 449
      tmp___7 = __errno_location();
#line 449
      tmp___8 = strerror(*tmp___7);
#line 449
      tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 449
      r_fatal((char const   *)tmp___9, "cint_list", "list", (long )(list_size___0 * sizeof(NODE *)),
              tmp___8);
#line 449
      tmp___10 = 0;
      }
    }
  }
#line 451
  if (((unsigned int )assoc_kind & 4U) == 0U) {
#line 453
    assoc_kind = (assoc_kind_t )((unsigned int )assoc_kind & 4294967103U);
#line 454
    t->flags = (unsigned int )assoc_kind;
  }
#line 459
  ja = (size_t )NHAT;
#line 459
  jd = (size_t )31;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (ja < 32UL) {
#line 459
      if (! (jd >= (size_t )NHAT)) {
#line 459
        goto while_break;
      }
    } else {
#line 459
      goto while_break;
    }
#line 460
    if (((unsigned int )assoc_kind & 128U) != 0U) {
#line 460
      tmp___11 = jd;
#line 460
      jd --;
#line 460
      j = tmp___11;
    } else {
#line 460
      tmp___12 = ja;
#line 460
      ja ++;
#line 460
      j = tmp___12;
    }
#line 461
    tn = *(symbol->sub.nodep.r.av + j);
#line 462
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 463
      goto __Cont;
    }
    {
#line 464
    tmp___13 = tree_list(tn, list + k, assoc_kind);
#line 464
    k += (unsigned long )tmp___13;
    }
#line 465
    if (k >= list_size___0) {
#line 466
      return (list);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return (list);
}
}
#line 474 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **cint_dump(NODE *symbol , NODE *ndump___0 ) 
{ 
  NODE *tn ;
  NODE *xn ;
  int indent_level___0 ;
  size_t i___0 ;
  long cint_size ;
  long xsize ;
  double kb ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  char const   *aname___0 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 477
  xn = (NODE *)((void *)0);
#line 480
  cint_size = 0L;
#line 480
  xsize = 0L;
#line 481
  kb = (double )0;
#line 485
  indent_level___0 = (int )ndump___0->sub.nodep.x.xl;
#line 487
  if ((unsigned long )symbol->sub.nodep.rn != (unsigned long )((void *)0)) {
#line 488
    xn = symbol->sub.nodep.rn;
#line 489
    xsize = (long )xn->sub.nodep.reflags;
  }
#line 491
  cint_size = (long )(symbol->sub.nodep.reflags - (unsigned long )xsize);
#line 493
  if ((symbol->flags & 65536U) == 0U) {
    {
#line 494
    tmp___1 = array_vname((NODE const   *)symbol);
    }
#line 494
    if ((unsigned long )symbol->sub.nodep.x.extra == (unsigned long )((void *)0)) {
#line 494
      tmp___2 = "array";
    } else {
#line 494
      tmp___2 = "sub-array";
    }
    {
#line 494
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"%s `%s\'\n",
            tmp___2, tmp___1);
    }
  }
  {
#line 497
  indent_level___0 ++;
#line 498
  indent(indent_level___0);
#line 499
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"array_func: cint_array_func\n");
  }
#line 500
  if (symbol->flags != 0U) {
    {
#line 501
    indent(indent_level___0);
#line 502
    tmp___3 = flags2str((int )symbol->flags);
#line 502
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"flags: %s\n",
            tmp___3);
    }
  }
  {
#line 504
  indent(indent_level___0);
#line 505
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"NHAT: %d\n",
          NHAT);
#line 506
  indent(indent_level___0);
#line 507
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"THRESHOLD: %ld\n",
          THRESHOLD);
#line 508
  indent(indent_level___0);
#line 509
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"table_size: %ld (total), %ld (cint), %ld (int + str)\n",
          symbol->sub.nodep.reflags, cint_size, xsize);
#line 511
  indent(indent_level___0);
#line 512
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"array_capacity: %lu\n",
          symbol->sub.nodep.reserved);
#line 513
  indent(indent_level___0);
#line 514
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"Load Factor: %.2g\n",
          (double )cint_size / (double )symbol->sub.nodep.reserved);
#line 516
  i___0 = (size_t )NHAT;
  }
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (i___0 < 32UL)) {
#line 516
      goto while_break;
    }
#line 517
    tn = *(symbol->sub.nodep.r.av + i___0);
#line 518
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 519
      goto __Cont;
    }
    {
#line 521
    tmp___4 = tree_kilobytes(tn);
#line 521
    kb += (double )(sizeof(NODE ) + tmp___4) / 1024.0;
    }
    __Cont: /* CIL Label */ 
#line 516
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  kb += (double )(32UL * sizeof(NODE *)) / 1024.0;
#line 524
  kb += (double )(symbol->sub.nodep.reserved * sizeof(NODE *)) / 1024.0;
#line 525
  if ((unsigned long )xn != (unsigned long )((void *)0)) {
#line 526
    if ((unsigned long )xn->sub.nodep.l.lp == (unsigned long )(int_array_func)) {
      {
#line 527
      tmp___5 = int_kilobytes(xn);
#line 527
      kb += tmp___5;
      }
    } else {
      {
#line 529
      tmp___6 = str_kilobytes(xn);
#line 529
      kb += tmp___6;
      }
    }
  }
  {
#line 532
  indent(indent_level___0);
#line 533
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"memory: %.2g kB (total)\n",
          kb);
  }
#line 537
  if (ndump___0->sub.nodep.l.ll >= 0L) {
    {
#line 540
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"\n");
#line 541
    aname___0 = make_aname((NODE const   *)symbol);
#line 542
    i___0 = (size_t )NHAT;
    }
    {
#line 542
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 542
      if (! (i___0 < 32UL)) {
#line 542
        goto while_break___0;
      }
#line 543
      tn = *(symbol->sub.nodep.r.av + i___0);
#line 544
      if ((unsigned long )tn != (unsigned long )((void *)0)) {
        {
#line 545
        tree_info(tn, ndump___0, aname___0);
        }
      }
#line 542
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 549
  if ((unsigned long )xn != (unsigned long )((void *)0)) {
    {
#line 550
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"\n");
#line 551
    (*(*(xn->sub.nodep.l.lp + 9)))(xn, ndump___0);
    }
  }
#line 559
  return ((NODE **)((void *)0));
}
}
#line 565 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
__inline static int cint_hash(long k ) 
{ 
  uint32_t num ;
  uint32_t r ;
  uint32_t shift ;

  {
#line 571
  if (k == 0L) {
#line 572
    return (NHAT);
  }
#line 573
  num = (uint32_t )k;
#line 607
  r = (uint32_t )((num > 65535U) << 4);
#line 607
  num >>= r;
#line 608
  shift = (uint32_t )((num > 255U) << 3);
#line 608
  num >>= shift;
#line 608
  r |= shift;
#line 609
  shift = (uint32_t )((num > 15U) << 2);
#line 609
  num >>= shift;
#line 609
  r |= shift;
#line 610
  shift = (uint32_t )((num > 3U) << 1);
#line 610
  num >>= shift;
#line 610
  r |= shift;
#line 611
  r |= num >> 1;
#line 614
  if (r < (uint32_t )NHAT) {
#line 615
    return (NHAT);
  }
#line 617
  return ((int )(1U + r));
}
}
#line 623 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
__inline static NODE **cint_find(NODE *symbol , long k , int h1 ) 
{ 
  NODE *tn ;
  NODE **tmp___1 ;

  {
#line 628
  if ((unsigned long )symbol->sub.nodep.r.av == (unsigned long )((void *)0)) {
#line 629
    return ((NODE **)((void *)0));
  } else {
#line 628
    tn = *(symbol->sub.nodep.r.av + h1);
#line 628
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 629
      return ((NODE **)((void *)0));
    }
  }
  {
#line 630
  tmp___1 = tree_exists(tn, k);
  }
#line 630
  return (tmp___1);
}
}
#line 706 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
__inline static NODE *make_node(NODETYPE type ) 
{ 
  NODE *n ;
  void *tmp___1 ;

  {
#line 710
  n = (NODE *)nextfree[1].freep;
#line 710
  if (n) {
#line 710
    nextfree[1].freep = ((BLOCK *)n)->freep;
  } else {
    {
#line 710
    tmp___1 = more_blocks(1);
#line 710
    n = (NODE *)tmp___1;
    }
  }
  {
#line 711
  memset((void *)n, '\000', sizeof(NODE ));
#line 712
  n->type = type;
  }
#line 713
  return (n);
}
}
#line 719 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **tree_lookup(NODE *symbol , NODE *tree , long k , int m , long base ) 
{ 
  NODE **lhs ;
  NODE *tn ;
  int i___0 ;
  int n ;
  size_t size ;
  long num ;
  size_t actual_size ;
  NODE **table ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  struct exp_node *tmp___6 ;
  NODE **tmp___7 ;
  struct exp_node *tmp___8 ;
  NODE **tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 726
  num = k;
#line 734
  n = (m + 1) / 2;
#line 736
  if (tree->sub.nodep.reflags == 0UL) {
#line 743
    actual_size = (size_t )power_two_table[n];
#line 743
    size = actual_size;
#line 744
    tree->sub.nodep.l.ll = base;
#line 745
    tree->sub.nodep.cnt = size;
#line 746
    tree->sub.nodep.reflags = 0UL;
#line 747
    if (n > m / 2) {
#line 749
      actual_size /= 2UL;
#line 750
      tree->flags |= 32768U;
    }
    {
#line 752
    tmp___1 = malloc(actual_size * sizeof(NODE *));
#line 752
    table = (NODE **)tmp___1;
    }
#line 752
    if (table) {
#line 752
      tmp___5 = 1;
    } else {
      {
#line 752
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c", 752);
#line 752
      tmp___2 = __errno_location();
#line 752
      tmp___3 = strerror(*tmp___2);
#line 752
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 752
      r_fatal((char const   *)tmp___4, "tree_lookup", "table", (long )(actual_size * sizeof(NODE *)),
              tmp___3);
#line 752
      tmp___5 = 0;
      }
    }
    {
#line 753
    memset((void *)table, '\000', actual_size * sizeof(NODE *));
#line 754
    tree->sub.nodep.r.av = table;
    }
  } else {
#line 756
    size = tree->sub.nodep.cnt;
  }
  {
#line 758
  num -= tree->sub.nodep.l.ll;
#line 759
  i___0 = (int )((size_t )num / size);
#line 762
  lhs = tree_find(tree, k, i___0);
  }
#line 762
  if ((unsigned long )lhs != (unsigned long )((void *)0)) {
#line 763
    return (lhs);
  }
#line 767
  (tree->sub.nodep.reflags) ++;
#line 768
  base = (long )((size_t )base + size * (size_t )i___0);
#line 769
  tn = *(tree->sub.nodep.r.av + i___0);
#line 770
  if (n > NHAT) {
#line 771
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
      {
#line 772
      tmp___6 = make_node((NODETYPE )12);
#line 772
      *(tree->sub.nodep.r.av + i___0) = tmp___6;
#line 772
      tn = tmp___6;
      }
    }
    {
#line 773
    tmp___7 = tree_lookup(symbol, tn, k, n, base);
    }
#line 773
    return (tmp___7);
  } else {
#line 775
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
      {
#line 776
      tmp___8 = make_node((NODETYPE )13);
#line 776
      *(tree->sub.nodep.r.av + i___0) = tmp___8;
#line 776
      tn = tmp___8;
      }
    }
    {
#line 777
    tmp___9 = leaf_lookup(symbol, tn, k, (long )size, base);
    }
#line 777
    return (tmp___9);
  }
}
}
#line 784 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static NODE **tree_exists(NODE *tree , long k ) 
{ 
  int i___0 ;
  NODE *tn ;
  NODE **tmp___1 ;
  NODE **tmp___2 ;

  {
#line 790
  i___0 = (int )((unsigned long )(k - tree->sub.nodep.l.ll) / tree->sub.nodep.cnt);
#line 792
  tn = *(tree->sub.nodep.r.av + i___0);
#line 793
  if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 794
    return ((NODE **)((void *)0));
  }
#line 795
  if ((unsigned int )tn->type == 12U) {
    {
#line 796
    tmp___1 = tree_exists(tn, k);
    }
#line 796
    return (tmp___1);
  }
  {
#line 797
  tmp___2 = leaf_exists(tn, k);
  }
#line 797
  return (tmp___2);
}
}
#line 802 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static void tree_clear(NODE *tree ) 
{ 
  NODE *tn ;
  size_t j ;
  size_t hsize ;

  {
#line 808
  hsize = tree->sub.nodep.cnt;
#line 809
  if ((tree->flags & 32768U) != 0U) {
#line 810
    hsize /= 2UL;
  }
#line 812
  j = (size_t )0;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 812
    if (! (j < hsize)) {
#line 812
      goto while_break;
    }
#line 813
    tn = *(tree->sub.nodep.r.av + j);
#line 814
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 815
      goto __Cont;
    }
#line 816
    if ((unsigned int )tn->type == 12U) {
      {
#line 817
      tree_clear(tn);
      }
    } else {
      {
#line 819
      leaf_clear(tn);
      }
    }
#line 820
    ((BLOCK *)tn)->freep = nextfree[1].freep;
#line 820
    nextfree[1].freep = (BLOCK *)tn;
    __Cont: /* CIL Label */ 
#line 812
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 823
  free((void *)tree->sub.nodep.r.av);
#line 824
  memset((void *)tree, '\000', sizeof(NODE ));
#line 825
  tree->type = (NODETYPE )12;
  }
#line 826
  return;
}
}
#line 831 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static int tree_remove(NODE *symbol , NODE *tree , long k ) 
{ 
  int i___0 ;
  NODE *tn ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 837
  i___0 = (int )((unsigned long )(k - tree->sub.nodep.l.ll) / tree->sub.nodep.cnt);
#line 839
  tn = *(tree->sub.nodep.r.av + i___0);
#line 840
  if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 841
    return (0);
  }
#line 843
  if ((unsigned int )tn->type == 12U) {
    {
#line 843
    tmp___2 = tree_remove(symbol, tn, k);
    }
#line 843
    if (tmp___2) {
#line 843
      goto _L;
    } else {
#line 845
      return (0);
    }
  } else
  _L: /* CIL Label */ 
#line 846
  if ((unsigned int )tn->type == 13U) {
    {
#line 846
    tmp___1 = leaf_remove(symbol, tn, k);
    }
#line 846
    if (! tmp___1) {
#line 848
      return (0);
    }
  }
#line 850
  if (tn->sub.nodep.reflags == 0UL) {
#line 851
    ((BLOCK *)tn)->freep = nextfree[1].freep;
#line 851
    nextfree[1].freep = (BLOCK *)tn;
#line 852
    *(tree->sub.nodep.r.av + i___0) = (struct exp_node *)((void *)0);
  }
#line 856
  (tree->sub.nodep.reflags) --;
#line 856
  if (tree->sub.nodep.reflags == 0UL) {
    {
#line 857
    free((void *)tree->sub.nodep.r.av);
#line 858
    memset((void *)tree, '\000', sizeof(NODE ));
#line 859
    tree->type = (NODETYPE )12;
    }
  }
#line 861
  return (1);
}
}
#line 867 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
__inline static NODE **tree_find(NODE *tree , long k , int i___0 ) 
{ 
  NODE *tn ;
  NODE **tmp___1 ;
  NODE **tmp___2 ;

  {
#line 873
  tn = *(tree->sub.nodep.r.av + i___0);
#line 874
  if ((unsigned long )tn != (unsigned long )((void *)0)) {
#line 875
    if ((unsigned int )tn->type == 12U) {
      {
#line 876
      tmp___1 = tree_exists(tn, k);
      }
#line 876
      return (tmp___1);
    }
    {
#line 877
    tmp___2 = leaf_exists(tn, k);
    }
#line 877
    return (tmp___2);
  }
#line 879
  return ((NODE **)((void *)0));
}
}
#line 885 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static long tree_list(NODE *tree , NODE **list , assoc_kind_t assoc_kind ) 
{ 
  NODE *tn ;
  size_t j ;
  size_t cj ;
  size_t hsize ;
  long k ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 890
  k = 0L;
#line 894
  hsize = tree->sub.nodep.cnt;
#line 895
  if ((tree->flags & 32768U) != 0U) {
#line 896
    hsize /= 2UL;
  }
#line 898
  j = (size_t )0;
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! (j < hsize)) {
#line 898
      goto while_break;
    }
#line 899
    if (((unsigned int )assoc_kind & 128U) != 0U) {
#line 899
      cj = (hsize - 1UL) - j;
    } else {
#line 899
      cj = j;
    }
#line 900
    tn = *(tree->sub.nodep.r.av + cj);
#line 901
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 902
      goto __Cont;
    }
#line 903
    if ((unsigned int )tn->type == 12U) {
      {
#line 904
      tmp___1 = tree_list(tn, list + k, assoc_kind);
#line 904
      k += tmp___1;
      }
    } else {
      {
#line 906
      tmp___2 = leaf_list(tn, list + k, assoc_kind);
#line 906
      k += tmp___2;
      }
    }
#line 907
    if (((unsigned int )assoc_kind & 256U) != 0U) {
#line 907
      if (k >= 1L) {
#line 908
        return (k);
      }
    }
    __Cont: /* CIL Label */ 
#line 898
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 910
  return (k);
}
}
#line 916 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static void tree_copy(NODE *newsymb , NODE *tree , NODE *newtree ) 
{ 
  NODE **old ;
  NODE **new ;
  size_t j ;
  size_t hsize ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 922
  hsize = tree->sub.nodep.cnt;
#line 923
  if ((tree->flags & 32768U) != 0U) {
#line 924
    hsize /= 2UL;
  }
  {
#line 926
  tmp___1 = malloc(hsize * sizeof(NODE *));
#line 926
  new = (NODE **)tmp___1;
  }
#line 926
  if (new) {
#line 926
    tmp___5 = 1;
  } else {
    {
#line 926
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c", 926);
#line 926
    tmp___2 = __errno_location();
#line 926
    tmp___3 = strerror(*tmp___2);
#line 926
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 926
    r_fatal((char const   *)tmp___4, "tree_copy", "new", (long )(hsize * sizeof(NODE *)),
            tmp___3);
#line 926
    tmp___5 = 0;
    }
  }
  {
#line 927
  memset((void *)new, '\000', hsize * sizeof(NODE *));
#line 928
  newtree->sub.nodep.r.av = new;
#line 929
  newtree->sub.nodep.l.ll = tree->sub.nodep.l.ll;
#line 930
  newtree->sub.nodep.cnt = tree->sub.nodep.cnt;
#line 931
  newtree->sub.nodep.reflags = tree->sub.nodep.reflags;
#line 932
  newtree->flags = tree->flags;
#line 934
  old = tree->sub.nodep.r.av;
#line 935
  j = (size_t )0;
  }
  {
#line 935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 935
    if (! (j < hsize)) {
#line 935
      goto while_break;
    }
#line 936
    if ((unsigned long )*(old + j) == (unsigned long )((void *)0)) {
#line 937
      goto __Cont;
    }
#line 938
    if ((unsigned int )(*(old + j))->type == 12U) {
      {
#line 939
      *(new + j) = make_node((NODETYPE )12);
#line 940
      tree_copy(newsymb, *(old + j), *(new + j));
      }
    } else {
      {
#line 942
      *(new + j) = make_node((NODETYPE )13);
#line 943
      leaf_copy(newsymb, *(old + j), *(new + j));
      }
    }
    __Cont: /* CIL Label */ 
#line 935
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 946
  return;
}
}
#line 951 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static void tree_info(NODE *tree , NODE *ndump___0 , char const   *aname___0 ) 
{ 
  NODE *tn ;
  size_t j ;
  size_t hsize ;

  {
#line 957
  hsize = tree->sub.nodep.cnt;
#line 958
  if ((tree->flags & 32768U) != 0U) {
#line 959
    hsize /= 2UL;
  }
#line 961
  j = (size_t )0;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! (j < hsize)) {
#line 961
      goto while_break;
    }
#line 962
    tn = *(tree->sub.nodep.r.av + j);
#line 963
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 964
      goto __Cont;
    }
#line 965
    if ((unsigned int )tn->type == 12U) {
      {
#line 966
      tree_info(tn, ndump___0, aname___0);
      }
    } else {
      {
#line 968
      leaf_info(tn, ndump___0, aname___0);
      }
    }
    __Cont: /* CIL Label */ 
#line 961
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 970
  return;
}
}
#line 975 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static size_t tree_kilobytes(NODE *tree ) 
{ 
  NODE *tn ;
  size_t j ;
  size_t hsize ;
  size_t sz ;
  size_t tmp___1 ;

  {
#line 980
  sz = (size_t )0;
#line 982
  hsize = tree->sub.nodep.cnt;
#line 983
  if ((tree->flags & 32768U) != 0U) {
#line 984
    hsize /= 2UL;
  }
#line 985
  j = (size_t )0;
  {
#line 985
  while (1) {
    while_continue: /* CIL Label */ ;
#line 985
    if (! (j < hsize)) {
#line 985
      goto while_break;
    }
#line 986
    tn = *(tree->sub.nodep.r.av + j);
#line 987
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
#line 988
      goto __Cont;
    }
#line 989
    sz += sizeof(NODE );
#line 990
    if ((unsigned int )tn->type == 12U) {
      {
#line 991
      tmp___1 = tree_kilobytes(tn);
#line 991
      sz += tmp___1;
      }
    }
    __Cont: /* CIL Label */ 
#line 985
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 993
  sz += hsize * sizeof(NODE *);
#line 994
  return (sz);
}
}
#line 1036 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
__inline static NODE **leaf_lookup(NODE *symbol , NODE *array , long k , long size ,
                                   long base ) 
{ 
  NODE **lhs ;
  struct exp_node **tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1041
  if ((unsigned long )array->sub.nodep.r.av == (unsigned long )((void *)0)) {
    {
#line 1042
    array->sub.nodep.reflags = 0UL;
#line 1043
    array->sub.nodep.cnt = (unsigned long )size;
#line 1044
    array->sub.nodep.l.ll = base;
#line 1045
    tmp___2 = malloc((unsigned long )size * sizeof(NODE *));
#line 1045
    tmp___1 = (NODE **)tmp___2;
#line 1045
    array->sub.nodep.r.av = tmp___1;
    }
#line 1045
    if (tmp___1) {
#line 1045
      tmp___6 = 1;
    } else {
      {
#line 1045
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c", 1045);
#line 1045
      tmp___3 = __errno_location();
#line 1045
      tmp___4 = strerror(*tmp___3);
#line 1045
      tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1045
      r_fatal((char const   *)tmp___5, "leaf_lookup", "array->nodes", (long )((unsigned long )size * sizeof(NODE *)),
              tmp___4);
#line 1045
      tmp___6 = 0;
      }
    }
    {
#line 1046
    memset((void *)array->sub.nodep.r.av, '\000', (unsigned long )size * sizeof(NODE *));
#line 1047
    symbol->sub.nodep.reserved += (size_t )size;
    }
  }
#line 1050
  lhs = array->sub.nodep.r.av + (k - base);
#line 1051
  if ((unsigned long )*lhs == (unsigned long )((void *)0)) {
    {
#line 1052
    (array->sub.nodep.reflags) ++;
#line 1053
    *lhs = dupnode(Nnull_string);
    }
  }
#line 1055
  return (lhs);
}
}
#line 1061 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
__inline static NODE **leaf_exists(NODE *array , long k ) 
{ 
  NODE **lhs ;
  NODE **tmp___1 ;

  {
#line 1065
  lhs = array->sub.nodep.r.av + (k - array->sub.nodep.l.ll);
#line 1066
  if ((unsigned long )*lhs != (unsigned long )((void *)0)) {
#line 1066
    tmp___1 = lhs;
  } else {
#line 1066
    tmp___1 = (NODE **)((void *)0);
  }
#line 1066
  return (tmp___1);
}
}
#line 1072 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static void leaf_clear(NODE *array ) 
{ 
  long i___0 ;
  long size ;
  NODE *r ;
  unsigned long tmp___1 ;

  {
#line 1075
  size = (long )array->sub.nodep.cnt;
#line 1078
  i___0 = 0L;
  {
#line 1078
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1078
    if (! (i___0 < size)) {
#line 1078
      goto while_break;
    }
#line 1079
    r = *(array->sub.nodep.r.av + i___0);
#line 1080
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1081
      goto __Cont;
    }
#line 1082
    if ((unsigned int )r->type == 5U) {
      {
#line 1083
      (*(*(r->sub.nodep.l.lp + 5)))(r, (struct exp_node *)((void *)0));
#line 1084
      free((void *)r->sub.nodep.name);
#line 1085
      ((BLOCK *)r)->freep = nextfree[1].freep;
#line 1085
      nextfree[1].freep = (BLOCK *)r;
      }
    } else {
      {
#line 1087
      unref(r);
      }
    }
    __Cont: /* CIL Label */ 
#line 1078
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1089
  free((void *)array->sub.nodep.r.av);
#line 1090
  array->sub.nodep.r.av = (struct exp_node **)((void *)0);
#line 1091
  tmp___1 = 0UL;
#line 1091
  array->sub.nodep.reflags = tmp___1;
#line 1091
  array->sub.nodep.cnt = tmp___1;
  }
#line 1092
  return;
}
}
#line 1097 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static int leaf_remove(NODE *symbol , NODE *array , long k ) 
{ 
  NODE **lhs ;

  {
#line 1102
  lhs = array->sub.nodep.r.av + (k - array->sub.nodep.l.ll);
#line 1103
  if ((unsigned long )*lhs == (unsigned long )((void *)0)) {
#line 1104
    return (0);
  }
#line 1105
  *lhs = (NODE *)((void *)0);
#line 1106
  (array->sub.nodep.reflags) --;
#line 1106
  if (array->sub.nodep.reflags == 0UL) {
    {
#line 1107
    free((void *)array->sub.nodep.r.av);
#line 1108
    array->sub.nodep.r.av = (struct exp_node **)((void *)0);
#line 1109
    symbol->sub.nodep.reserved -= array->sub.nodep.cnt;
#line 1110
    array->sub.nodep.cnt = 0UL;
    }
  }
#line 1112
  return (1);
}
}
#line 1118 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static void leaf_copy(NODE *newsymb , NODE *array , NODE *newarray ) 
{ 
  NODE **old ;
  NODE **new ;
  long size ;
  long i___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  NODE *r ;
  size_t tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 1124
  size = (long )array->sub.nodep.cnt;
#line 1125
  tmp___1 = malloc((unsigned long )size * sizeof(NODE *));
#line 1125
  new = (NODE **)tmp___1;
  }
#line 1125
  if (new) {
#line 1125
    tmp___5 = 1;
  } else {
    {
#line 1125
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c", 1125);
#line 1125
    tmp___2 = __errno_location();
#line 1125
    tmp___3 = strerror(*tmp___2);
#line 1125
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1125
    r_fatal((char const   *)tmp___4, "leaf_copy", "new", (long )((unsigned long )size * sizeof(NODE *)),
            tmp___3);
#line 1125
    tmp___5 = 0;
    }
  }
  {
#line 1126
  memset((void *)new, '\000', (unsigned long )size * sizeof(NODE *));
#line 1127
  newarray->sub.nodep.r.av = new;
#line 1128
  newarray->sub.nodep.cnt = (unsigned long )size;
#line 1129
  newarray->sub.nodep.l.ll = array->sub.nodep.l.ll;
#line 1130
  newarray->flags = array->flags;
#line 1131
  newarray->sub.nodep.reflags = array->sub.nodep.reflags;
#line 1133
  old = array->sub.nodep.r.av;
#line 1134
  i___0 = 0L;
  }
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    if (! (i___0 < size)) {
#line 1134
      goto while_break;
    }
#line 1135
    if ((unsigned long )*(old + i___0) == (unsigned long )((void *)0)) {
#line 1136
      goto __Cont;
    }
#line 1137
    if ((unsigned int )(*(old + i___0))->type == 1U) {
      {
#line 1138
      *(new + i___0) = dupnode(*(old + i___0));
      }
    } else {
      {
#line 1141
      r = make_array();
#line 1142
      tmp___6 = strlen((char const   *)(*(old + i___0))->sub.nodep.name);
#line 1142
      r->sub.nodep.name = estrdup((char const   *)(*(old + i___0))->sub.nodep.name,
                                  tmp___6);
#line 1143
      r->sub.nodep.x.extra = newsymb;
#line 1144
      *(new + i___0) = assoc_copy(*(old + i___0), r);
      }
    }
    __Cont: /* CIL Label */ 
#line 1134
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1147
  return;
}
}
#line 1158 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static char buf___6[100]  ;
#line 1152 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static long leaf_list(NODE *array , NODE **list , assoc_kind_t assoc_kind ) 
{ 
  NODE *r ;
  NODE *subs ;
  long num ;
  long i___0 ;
  long ci ;
  long k ;
  long size ;
  size_t tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char *__cil_tmp14 ;

  {
#line 1156
  k = 0L;
#line 1157
  size = (long )array->sub.nodep.cnt;
#line 1160
  i___0 = 0L;
  {
#line 1160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1160
    if (! (i___0 < size)) {
#line 1160
      goto while_break;
    }
#line 1161
    if (((unsigned int )assoc_kind & 128U) != 0U) {
#line 1161
      ci = (size - 1L) - i___0;
    } else {
#line 1161
      ci = i___0;
    }
#line 1162
    r = *(array->sub.nodep.r.av + ci);
#line 1163
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1164
      goto __Cont;
    }
#line 1167
    num = array->sub.nodep.l.ll + ci;
#line 1168
    if (((unsigned int )assoc_kind & 8U) != 0U) {
      {
#line 1169
      sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%ld",
              num);
#line 1170
      tmp___1 = strlen((char const   *)(buf___6));
#line 1170
      subs = make_str_node((char const   *)(buf___6), tmp___1, 0);
#line 1171
      subs->sub.val.nm.fltnum = (double )num;
#line 1172
      subs->flags |= 264U;
      }
    } else {
      {
#line 1174
      subs = (*make_number)((double )num);
#line 1175
      subs->flags |= 768U;
      }
    }
#line 1177
    tmp___2 = k;
#line 1177
    k ++;
#line 1177
    *(list + tmp___2) = subs;
#line 1180
    if (((unsigned int )assoc_kind & 2U) != 0U) {
#line 1181
      if ((unsigned int )r->type == 1U) {
#line 1182
        if (((unsigned int )assoc_kind & 16U) != 0U) {
          {
#line 1183
          force_number(r);
          }
        } else
#line 1184
        if (((unsigned int )assoc_kind & 32U) != 0U) {
          {
#line 1185
          r = force_string(r);
          }
        }
      }
#line 1187
      tmp___3 = k;
#line 1187
      k ++;
#line 1187
      *(list + tmp___3) = r;
    }
#line 1189
    if (((unsigned int )assoc_kind & 256U) != 0U) {
#line 1189
      if (k >= 1L) {
#line 1190
        return (k);
      }
    }
    __Cont: /* CIL Label */ 
#line 1160
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1193
  return (k);
}
}
#line 1199 "/home/wslee/gnu_benchmarks/gawk-4.1.0/cint_array.c"
static void leaf_info(NODE *array , NODE *ndump___0 , char const   *aname___0 ) 
{ 
  NODE *subs ;
  NODE *val ;
  size_t i___0 ;
  size_t size ;

  {
  {
#line 1205
  size = array->sub.nodep.cnt;
#line 1207
  subs = (*make_number)(0.0);
#line 1208
  subs->flags |= 768U;
#line 1209
  i___0 = (size_t )0;
  }
  {
#line 1209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1209
    if (! (i___0 < size)) {
#line 1209
      goto while_break;
    }
#line 1210
    val = *(array->sub.nodep.r.av + i___0);
#line 1211
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1212
      goto __Cont;
    }
    {
#line 1213
    subs->sub.val.nm.fltnum = (double )((size_t )array->sub.nodep.l.ll + i___0);
#line 1214
    assoc_info(subs, val, ndump___0, aname___0);
    }
    __Cont: /* CIL Label */ 
#line 1209
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1216
  unref(subs);
  }
#line 1217
  return;
}
}
#line 415 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 52 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category )  __attribute__((__format_arg__(2))) ;
#line 74
extern  __attribute__((__nothrow__)) char *dcngettext(char const   *__domainname ,
                                                      char const   *__msgid1 , char const   *__msgid2 ,
                                                      unsigned long __n , int __category )  __attribute__((__format_arg__(3),
__format_arg__(2))) ;
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 193 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 199
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 233
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 237
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 712 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 323 "/usr/include/mpfr.h"
extern intmax_t __gmpfr_mpfr_get_sj(mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 324
extern uintmax_t __gmpfr_mpfr_get_uj(mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 375
extern int mpfr_snprintf(char * , size_t  , char const   *  , ...) ;
#line 551
extern int mpfr_fits_intmax_p(mpfr_srcptr  , mpfr_rnd_t  ) ;
#line 1377 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *do_exp(int nargs ) ;
#line 1378
NODE *do_fflush(int nargs ) ;
#line 1379
NODE *do_index(int nargs ) ;
#line 1380
NODE *do_int(int nargs ) ;
#line 1381
NODE *do_isarray(int nargs ) ;
#line 1382
NODE *do_length(int nargs ) ;
#line 1383
NODE *do_log(int nargs ) ;
#line 1384
NODE *do_mktime(int nargs ) ;
#line 1385
NODE *do_sprintf(int nargs ) ;
#line 1388
NODE *do_sqrt(int nargs ) ;
#line 1389
NODE *do_substr(int nargs ) ;
#line 1390
NODE *do_strftime(int nargs ) ;
#line 1391
NODE *do_systime(int nargs  __attribute__((__unused__)) ) ;
#line 1392
NODE *do_system(int nargs ) ;
#line 1395
NODE *do_tolower(int nargs ) ;
#line 1396
NODE *do_toupper(int nargs ) ;
#line 1397
NODE *do_atan2(int nargs ) ;
#line 1398
NODE *do_sin(int nargs ) ;
#line 1399
NODE *do_cos(int nargs ) ;
#line 1400
NODE *do_rand(int nargs  __attribute__((__unused__)) ) ;
#line 1401
NODE *do_srand(int nargs ) ;
#line 1402
NODE *do_match(int nargs ) ;
#line 1405
NODE *do_lshift(int nargs ) ;
#line 1406
NODE *do_rshift(int nargs ) ;
#line 1407
NODE *do_and(int nargs ) ;
#line 1408
NODE *do_or(int nargs ) ;
#line 1409
NODE *do_xor(int nargs ) ;
#line 1410
NODE *do_compl(int nargs ) ;
#line 1411
NODE *do_strtonum(int nargs ) ;
#line 1413
NODE *do_dcgettext(int nargs ) ;
#line 1414
NODE *do_dcngettext(int nargs ) ;
#line 1415
NODE *do_bindtextdomain(int nargs ) ;
#line 61 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 101
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 193
extern  __attribute__((__nothrow__)) int __isinf(double __value )  __attribute__((__const__)) ;
#line 193
extern  __attribute__((__nothrow__)) int __isinff(float __value )  __attribute__((__const__)) ;
#line 193
extern  __attribute__((__nothrow__)) int __isinfl(long double __value )  __attribute__((__const__)) ;
#line 64 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static size_t mbc_byte_count(char const   *ptr , size_t numchars ) ;
#line 65
static size_t mbc_char_count(char const   *ptr , size_t numbytes ) ;
#line 97 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static void efwrite(void const   *ptr , size_t size , size_t count , FILE *fp___0 ,
                    char const   *from , struct redirect *rp , _Bool flush ) 
{ 
  int *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 106
  tmp___1 = __errno_location();
#line 106
  *tmp___1 = 0;
  }
#line 107
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
    {
#line 108
    tmp___2 = (*(rp->output.gawk_fwrite))(ptr, size, count, fp___0, rp->output.opaque);
    }
#line 108
    if (tmp___2 != count) {
#line 109
      goto wrerror;
    }
  } else {
    {
#line 110
    tmp___3 = fwrite((void const   */* __restrict  */)ptr, size, count, (FILE */* __restrict  */)fp___0);
    }
#line 110
    if (tmp___3 != count) {
#line 111
      goto wrerror;
    }
  }
#line 112
  if (flush) {
#line 112
    if ((unsigned long )fp___0 == (unsigned long )stdout) {
#line 112
      if (output_is_tty) {
#line 112
        goto _L;
      } else {
#line 112
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 112
    if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 112
      if ((rp->flag & 32U) != 0U) {
        _L: /* CIL Label */ 
#line 115
        if ((unsigned long )rp != (unsigned long )((void *)0)) {
          {
#line 116
          (*(rp->output.gawk_fflush))(fp___0, rp->output.opaque);
#line 117
          tmp___4 = (*(rp->output.gawk_ferror))(fp___0, rp->output.opaque);
          }
#line 117
          if (tmp___4) {
#line 118
            goto wrerror;
          }
        } else {
          {
#line 120
          fflush(fp___0);
#line 121
          tmp___5 = ferror(fp___0);
          }
#line 121
          if (tmp___5) {
#line 122
            goto wrerror;
          }
        }
      }
    }
  }
#line 125
  return;
  wrerror: 
  {
#line 128
  set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 128);
#line 128
  tmp___10 = __errno_location();
  }
#line 128
  if (*tmp___10) {
    {
#line 128
    tmp___6 = __errno_location();
#line 128
    tmp___7 = strerror(*tmp___6);
#line 128
    tmp___9 = tmp___7;
    }
  } else {
    {
#line 128
    tmp___8 = gettext("reason unknown");
#line 128
    tmp___9 = tmp___8;
    }
  }
#line 128
  if (rp) {
#line 128
    tmp___12 = rp->value;
  } else {
    {
#line 128
    tmp___11 = gettext("standard output");
#line 128
    tmp___12 = tmp___11;
    }
  }
  {
#line 128
  tmp___13 = gettext("%s to \"%s\" failed (%s)");
#line 128
  r_fatal((char const   *)tmp___13, from, tmp___12, tmp___9);
  }
#line 131
  return;
}
}
#line 135 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_exp(int nargs ) 
{ 
  NODE *tmp___1 ;
  double d ;
  double res ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  NODE *tmp___7 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 141
  tmp___1 = POP_SCALAR();
  }
#line 142
  if (do_flags & 3) {
#line 142
    if ((tmp___1->flags & 24U) == 0U) {
      {
#line 143
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 143);
#line 143
      tmp___2 = gettext("exp: received non-numeric argument");
#line 143
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 144
  tmp___3 = force_number(tmp___1);
#line 144
  d = tmp___3->sub.val.nm.fltnum;
#line 145
  DEREF(tmp___1);
#line 146
  tmp___4 = __errno_location();
#line 146
  *tmp___4 = 0;
#line 147
  res = exp(d);
#line 148
  tmp___6 = __errno_location();
  }
#line 148
  if (*tmp___6 == 34) {
    {
#line 149
    tmp___5 = gettext("exp: argument %g is out of range");
#line 149
    warning((char const   *)tmp___5, d);
    }
  }
  {
#line 150
  tmp___7 = (*make_number)(res);
  }
#line 150
  return (tmp___7);
}
}
#line 161 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static FILE *stdfile(char const   *name , size_t len ) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 164
  if (len == 11UL) {
    {
#line 165
    tmp___2 = strncmp(name, "/dev/stderr", (size_t )11);
    }
#line 165
    if (tmp___2 == 0) {
#line 166
      return (stderr);
    } else {
      {
#line 167
      tmp___1 = strncmp(name, "/dev/stdout", (size_t )11);
      }
#line 167
      if (tmp___1 == 0) {
#line 168
        return (stdout);
      }
    }
  }
#line 171
  return ((FILE *)((void *)0));
}
}
#line 176 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_fflush(int nargs ) 
{ 
  struct redirect *rp ;
  NODE *tmp___1 ;
  FILE *fp___0 ;
  int status ;
  char const   *file ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  NODE *tmp___7 ;
  char *tmp___8 ;
  NODE *tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 182
  status = 0;
#line 203
  if (nargs == 0) {
    {
#line 204
    status = flush_io();
#line 205
    tmp___2 = (*make_number)((double )status);
    }
#line 205
    return (tmp___2);
  }
  {
#line 208
  tmp___3 = POP_SCALAR();
#line 208
  tmp___1 = force_string(tmp___3);
#line 209
  file = (char const   *)tmp___1->sub.val.sp;
  }
#line 212
  if (tmp___1->sub.val.slen == 0UL) {
    {
#line 213
    status = flush_io();
#line 214
    DEREF(tmp___1);
#line 215
    tmp___4 = (*make_number)((double )status);
    }
#line 215
    return (tmp___4);
  }
  {
#line 219
  rp = getredirect((char const   *)tmp___1->sub.val.sp, (int )tmp___1->sub.val.slen);
#line 220
  status = -1;
  }
#line 221
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 222
    if ((rp->flag & 24U) == 0U) {
#line 223
      if ((rp->flag & 2U) != 0U) {
        {
#line 224
        tmp___5 = gettext("fflush: cannot flush: pipe `%s\' opened for reading, not writing");
#line 224
        warning((char const   *)tmp___5, file);
        }
      } else {
        {
#line 227
        tmp___6 = gettext("fflush: cannot flush: file `%s\' opened for reading, not writing");
#line 227
        warning((char const   *)tmp___6, file);
        }
      }
      {
#line 229
      DEREF(tmp___1);
#line 230
      tmp___7 = (*make_number)((double )status);
      }
#line 230
      return (tmp___7);
    }
#line 232
    fp___0 = rp->output.fp;
#line 233
    if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
      {
#line 234
      status = (*(rp->output.gawk_fflush))(fp___0, rp->output.opaque);
      }
    }
  } else {
    {
#line 235
    fp___0 = stdfile((char const   *)tmp___1->sub.val.sp, tmp___1->sub.val.slen);
    }
#line 235
    if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
      {
#line 236
      status = fflush(fp___0);
      }
    } else {
      {
#line 238
      status = -1;
#line 239
      tmp___8 = gettext("fflush: `%s\' is not an open file, pipe or co-process");
#line 239
      warning((char const   *)tmp___8, file);
      }
    }
  }
  {
#line 241
  DEREF(tmp___1);
#line 242
  tmp___9 = (*make_number)((double )status);
  }
#line 242
  return (tmp___9);
}
}
#line 248 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
int strncasecmpmbs(unsigned char const   *s1 , unsigned char const   *s2 , size_t n ) 
{ 
  size_t i1 ;
  size_t i2 ;
  size_t mbclen1 ;
  size_t mbclen2 ;
  size_t gap ;
  wchar_t wc1 ;
  wchar_t wc2 ;
  mbstate_t mbs1 ;
  mbstate_t mbs2 ;
  wint_t tmp___1 ;
  wint_t tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 255
  memset((void *)(& mbs1), 0, sizeof(mbs1));
#line 256
  memset((void *)(& mbs2), 0, sizeof(mbs2));
#line 258
  i2 = (size_t )0;
#line 258
  i1 = i2;
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (i1 < n) {
#line 258
      if (! (i2 < n)) {
#line 258
        goto while_break;
      }
    } else {
#line 258
      goto while_break;
    }
#line 259
    if (btowc_cache[(int const   )*(s1 + i1) & 255] != 4294967295U) {
#line 260
      mbclen1 = (size_t )1;
#line 261
      wc1 = (wchar_t )btowc_cache[(int const   )*(s1 + i1) & 255];
    } else {
      {
#line 263
      mbclen1 = mbrtowc((wchar_t */* __restrict  */)(& wc1), (char const   */* __restrict  */)((char const   *)s1 + i1),
                        n - i1, & mbs1);
      }
#line 265
      if (mbclen1 == 0xffffffffffffffffUL) {
#line 267
        mbclen1 = (size_t )1;
#line 268
        wc1 = (wchar_t )btowc_cache[(int const   )*(s1 + i1) & 255];
      } else
#line 265
      if (mbclen1 == 0xfffffffffffffffeUL) {
#line 267
        mbclen1 = (size_t )1;
#line 268
        wc1 = (wchar_t )btowc_cache[(int const   )*(s1 + i1) & 255];
      } else
#line 265
      if (mbclen1 == 0UL) {
#line 267
        mbclen1 = (size_t )1;
#line 268
        wc1 = (wchar_t )btowc_cache[(int const   )*(s1 + i1) & 255];
      }
    }
#line 271
    if (btowc_cache[(int const   )*(s2 + i2) & 255] != 4294967295U) {
#line 272
      mbclen2 = (size_t )1;
#line 273
      wc2 = (wchar_t )btowc_cache[(int const   )*(s2 + i2) & 255];
    } else {
      {
#line 275
      mbclen2 = mbrtowc((wchar_t */* __restrict  */)(& wc2), (char const   */* __restrict  */)((char const   *)s2 + i2),
                        n - i2, & mbs2);
      }
#line 277
      if (mbclen2 == 0xffffffffffffffffUL) {
#line 279
        mbclen2 = (size_t )1;
#line 280
        wc2 = (wchar_t )btowc_cache[(int const   )*(s2 + i2) & 255];
      } else
#line 277
      if (mbclen2 == 0xfffffffffffffffeUL) {
#line 279
        mbclen2 = (size_t )1;
#line 280
        wc2 = (wchar_t )btowc_cache[(int const   )*(s2 + i2) & 255];
      } else
#line 277
      if (mbclen2 == 0UL) {
#line 279
        mbclen2 = (size_t )1;
#line 280
        wc2 = (wchar_t )btowc_cache[(int const   )*(s2 + i2) & 255];
      }
    }
    {
#line 283
    tmp___1 = towlower((wint_t )wc1);
#line 283
    tmp___2 = towlower((wint_t )wc2);
#line 283
    gap = (size_t )(tmp___1 - tmp___2);
    }
#line 283
    if (gap != 0UL) {
#line 285
      return ((int )gap);
    }
#line 258
    i1 += mbclen1;
#line 258
    i2 += mbclen2;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return (0);
}
}
#line 297 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static void index_multibyte_buffer(char *src , char *dest , int len ) 
{ 
  int idx___3 ;
  int prev_idx ;
  mbstate_t mbs___0 ;
  mbstate_t prevs ;
  size_t mbclen ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  {
#line 303
  memset((void *)(& prevs), 0, sizeof(mbstate_t ));
#line 304
  prev_idx = 0;
#line 304
  idx___3 = prev_idx;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (idx___3 < len)) {
#line 304
      goto while_break;
    }
    {
#line 306
    mbs___0 = prevs;
#line 307
    mbclen = mbrlen((char const   */* __restrict  */)(src + prev_idx), (size_t )((idx___3 - prev_idx) + 1),
                    (mbstate_t */* __restrict  */)(& mbs___0));
    }
#line 308
    if (mbclen == 0xffffffffffffffffUL) {
#line 310
      mbclen = (size_t )1;
#line 311
      prev_idx = idx___3 + 1;
    } else
#line 308
    if (mbclen == 1UL) {
#line 310
      mbclen = (size_t )1;
#line 311
      prev_idx = idx___3 + 1;
    } else
#line 308
    if (mbclen == 0UL) {
#line 310
      mbclen = (size_t )1;
#line 311
      prev_idx = idx___3 + 1;
    } else
#line 312
    if (mbclen == 0xfffffffffffffffeUL) {
#line 314
      mbclen = (size_t )((idx___3 - prev_idx) + 1);
    } else
#line 315
    if (mbclen > 1UL) {
#line 317
      prev_idx = idx___3 + 1;
#line 318
      prevs = mbs___0;
    }
#line 322
    *(dest + idx___3) = (char )mbclen;
#line 304
    idx___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return;
}
}
#line 336 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_index(int nargs ) 
{ 
  NODE *s1 ;
  NODE *s2 ;
  char const   *p1 ;
  char const   *p2 ;
  size_t l1 ;
  size_t l2 ;
  long ret ;
  _Bool do_single_byte ;
  mbstate_t mbs1 ;
  mbstate_t mbs2 ;
  STACK_ITEM *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  wchar_t const   *pos ;
  int tmp___7 ;
  int tmp___8 ;
  wchar_t const   *pos___0 ;
  NODE *tmp___9 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 344
  do_single_byte = (_Bool)0;
#line 347
  if (gawk_mb_cur_max > 1) {
    {
#line 348
    memset((void *)(& mbs1), 0, sizeof(mbstate_t ));
#line 349
    memset((void *)(& mbs2), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 353
  s2 = POP_SCALAR();
#line 353
  tmp___1 = stack_ptr;
#line 353
  stack_ptr --;
#line 353
  s1 = tmp___1->rptr;
  }
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if ((unsigned int )s1->type == 5U) {
      {
#line 353
      DEREF(s2);
#line 353
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 353);
#line 353
      tmp___2 = array_vname((NODE const   *)s1);
#line 353
      tmp___3 = gettext("attempt to use array `%s\' in a scalar context");
#line 353
      r_fatal((char const   *)tmp___3, tmp___2);
      }
    }
#line 353
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  if (do_flags & 3) {
#line 356
    if ((s1->flags & 6U) == 0U) {
      {
#line 357
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 357);
#line 357
      tmp___4 = gettext("index: received non-string first argument");
#line 357
      (*lintfunc)((char const   *)tmp___4);
      }
    }
#line 358
    if ((s2->flags & 6U) == 0U) {
      {
#line 359
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 359);
#line 359
      tmp___5 = gettext("index: received non-string second argument");
#line 359
      (*lintfunc)((char const   *)tmp___5);
      }
    }
  }
  {
#line 362
  s1 = force_string(s1);
#line 363
  s2 = force_string(s2);
#line 365
  p1 = (char const   *)s1->sub.val.sp;
#line 366
  p2 = (char const   *)s2->sub.val.sp;
#line 367
  l1 = s1->sub.val.slen;
#line 368
  l2 = s2->sub.val.slen;
#line 369
  ret = 0L;
  }
#line 376
  if (l2 == 0UL) {
#line 377
    ret = 1L;
#line 378
    goto out;
  }
#line 382
  if (gawk_mb_cur_max > 1) {
    {
#line 383
    s1 = str2wstr(s1, (size_t **)((void *)0));
#line 384
    s2 = str2wstr(s2, (size_t **)((void *)0));
    }
#line 389
    if (s1->sub.val.wslen == 0UL) {
#line 389
      if (s1->sub.val.slen > 0UL) {
#line 389
        tmp___6 = 1;
      } else {
#line 389
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 389
    if (s2->sub.val.wslen == 0UL) {
#line 389
      if (s2->sub.val.slen > 0UL) {
#line 389
        tmp___6 = 1;
      } else {
#line 389
        tmp___6 = 0;
      }
    } else {
#line 389
      tmp___6 = 0;
    }
#line 389
    do_single_byte = (_Bool )tmp___6;
  }
#line 395
  if (IGNORECASE) {
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 396
      if (! (l1 > 0UL)) {
#line 396
        goto while_break___0;
      }
#line 397
      if (l2 > l1) {
#line 398
        goto while_break___0;
      }
#line 400
      if (! do_single_byte) {
#line 400
        if (gawk_mb_cur_max > 1) {
          {
#line 403
          pos = wcasestrstr((wchar_t const   *)s1->sub.val.wsp, s1->sub.val.wslen,
                            (wchar_t const   *)s2->sub.val.wsp, s2->sub.val.wslen);
          }
#line 404
          if ((unsigned long )pos == (unsigned long )((void *)0)) {
#line 405
            ret = 0L;
          } else {
#line 407
            ret = (pos - (wchar_t const   *)s1->sub.val.wsp) + 1L;
          }
#line 408
          goto out;
        } else {
#line 400
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 415
        if ((int )casetable[(unsigned char )*p1] == (int )casetable[(unsigned char )*p2]) {
#line 415
          if (l2 == 1UL) {
#line 417
            ret = (long )((1UL + s1->sub.val.slen) - l1);
#line 418
            goto while_break___0;
          } else {
            {
#line 415
            tmp___7 = strncasecmp(p1, p2, l2);
            }
#line 415
            if (tmp___7 == 0) {
#line 417
              ret = (long )((1UL + s1->sub.val.slen) - l1);
#line 418
              goto while_break___0;
            }
          }
        }
#line 420
        l1 --;
#line 421
        p1 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 427
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 427
      if (! (l1 > 0UL)) {
#line 427
        goto while_break___1;
      }
#line 428
      if (l2 > l1) {
#line 429
        goto while_break___1;
      }
#line 430
      if ((int const   )*p1 == (int const   )*p2) {
#line 430
        if (l2 == 1UL) {
#line 432
          ret = (long )((1UL + s1->sub.val.slen) - l1);
#line 433
          goto while_break___1;
        } else
#line 430
        if (l2 > 0UL) {
          {
#line 430
          tmp___8 = memcmp((void const   *)p1, (void const   *)p2, l2);
          }
#line 430
          if (tmp___8 == 0) {
#line 432
            ret = (long )((1UL + s1->sub.val.slen) - l1);
#line 433
            goto while_break___1;
          }
        }
      }
#line 436
      if (! do_single_byte) {
#line 436
        if (gawk_mb_cur_max > 1) {
          {
#line 439
          pos___0 = wstrstr((wchar_t const   *)s1->sub.val.wsp, s1->sub.val.wslen,
                            (wchar_t const   *)s2->sub.val.wsp, s2->sub.val.wslen);
          }
#line 440
          if ((unsigned long )pos___0 == (unsigned long )((void *)0)) {
#line 441
            ret = 0L;
          } else {
#line 443
            ret = (pos___0 - (wchar_t const   *)s1->sub.val.wsp) + 1L;
          }
#line 444
          goto out;
        } else {
#line 446
          l1 --;
#line 447
          p1 ++;
        }
      } else {
#line 446
        l1 --;
#line 447
        p1 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  out: 
  {
#line 456
  DEREF(s1);
#line 457
  DEREF(s2);
#line 458
  tmp___9 = (*make_number)((double )ret);
  }
#line 458
  return (tmp___9);
}
}
#line 463 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
double double_to_int(double d ) 
{ 


  {
#line 466
  if (d >= (double )0) {
    {
#line 467
    d = Floor(d);
    }
  } else {
    {
#line 469
    d = Ceil(d);
    }
  }
#line 470
  return (d);
}
}
#line 475 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_int(int nargs ) 
{ 
  NODE *tmp___1 ;
  double d ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 481
  tmp___1 = POP_SCALAR();
  }
#line 482
  if (do_flags & 3) {
#line 482
    if ((tmp___1->flags & 24U) == 0U) {
      {
#line 483
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 483);
#line 483
      tmp___2 = gettext("int: received non-numeric argument");
#line 483
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 484
  tmp___3 = force_number(tmp___1);
#line 484
  d = tmp___3->sub.val.nm.fltnum;
#line 485
  d = double_to_int(d);
#line 486
  DEREF(tmp___1);
#line 487
  tmp___4 = (*make_number)(d);
  }
#line 487
  return (tmp___4);
}
}
#line 492 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_isarray(int nargs ) 
{ 
  NODE *tmp___1 ;
  int ret ;
  STACK_ITEM *tmp___2 ;
  NODE *tmp___3 ;

  {
#line 496
  ret = 1;
#line 498
  tmp___2 = stack_ptr;
#line 498
  stack_ptr --;
#line 498
  tmp___1 = tmp___2->rptr;
#line 499
  if ((unsigned int )tmp___1->type != 5U) {
    {
#line 500
    ret = 0;
#line 501
    DEREF(tmp___1);
    }
  }
  {
#line 503
  tmp___3 = (*make_number)((double )ret);
  }
#line 503
  return (tmp___3);
}
}
#line 516 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static _Bool warned___14  =    (_Bool)0;
#line 508 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_length(int nargs ) 
{ 
  NODE *tmp___1 ;
  size_t len ;
  STACK_ITEM *tmp___2 ;
  unsigned long size ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct exp_node **tmp___5 ;
  NODE *tmp___6 ;
  char *tmp___7 ;
  NODE *tmp___8 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 514
  tmp___2 = stack_ptr;
#line 514
  stack_ptr --;
#line 514
  tmp___1 = tmp___2->rptr;
#line 515
  if ((unsigned int )tmp___1->type == 5U) {
#line 519
    if (do_flags & 16) {
      {
#line 520
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 520);
#line 520
      tmp___3 = gettext("length: received array argument");
#line 520
      r_fatal((char const   *)tmp___3);
      }
    }
#line 521
    if (do_flags & 3) {
#line 521
      if (! warned___14) {
        {
#line 522
        warned___14 = (_Bool)1;
#line 523
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 523);
#line 523
        tmp___4 = gettext("`length(array)\' is a gawk extension");
#line 523
        (*lintfunc)((char const   *)tmp___4);
        }
      }
    }
    {
#line 532
    tmp___5 = (*(*(tmp___1->sub.nodep.l.lp + 2)))(tmp___1, (struct exp_node *)((void *)0));
#line 532
    size = (*tmp___5)->sub.nodep.reflags;
#line 533
    tmp___6 = (*make_number)((double )size);
    }
#line 533
    return (tmp___6);
  }
#line 538
  if (do_flags & 3) {
#line 538
    if ((tmp___1->flags & 6U) == 0U) {
      {
#line 539
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 539);
#line 539
      tmp___7 = gettext("length: received non-string argument");
#line 539
      (*lintfunc)((char const   *)tmp___7);
      }
    }
  }
  {
#line 540
  tmp___1 = force_string(tmp___1);
  }
#line 543
  if (gawk_mb_cur_max > 1) {
    {
#line 544
    tmp___1 = str2wstr(tmp___1, (size_t **)((void *)0));
#line 545
    len = tmp___1->sub.val.wslen;
    }
#line 550
    if (len == 0UL) {
#line 550
      if (tmp___1->sub.val.slen > 0UL) {
#line 551
        len = tmp___1->sub.val.slen;
      }
    }
  } else {
#line 554
    len = tmp___1->sub.val.slen;
  }
  {
#line 556
  DEREF(tmp___1);
#line 557
  tmp___8 = (*make_number)((double )len);
  }
#line 557
  return (tmp___8);
}
}
#line 562 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_log(int nargs ) 
{ 
  NODE *tmp___1 ;
  double d ;
  double arg ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  char *tmp___4 ;
  NODE *tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 568
  tmp___1 = POP_SCALAR();
  }
#line 569
  if (do_flags & 3) {
#line 569
    if ((tmp___1->flags & 24U) == 0U) {
      {
#line 570
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 570);
#line 570
      tmp___2 = gettext("log: received non-numeric argument");
#line 570
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 571
  tmp___3 = force_number(tmp___1);
#line 571
  arg = tmp___3->sub.val.nm.fltnum;
  }
#line 572
  if (arg < 0.0) {
    {
#line 573
    tmp___4 = gettext("log: received negative argument %g");
#line 573
    warning((char const   *)tmp___4, arg);
    }
  }
  {
#line 574
  d = log(arg);
#line 575
  DEREF(tmp___1);
#line 576
  tmp___5 = (*make_number)(d);
  }
#line 576
  return (tmp___5);
}
}
#line 593 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static mpfr_t mpfrval  ;
#line 594
static mpfr_ptr mpz2mpfr(mpz_ptr zi ) ;
#line 594 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static _Bool inited  =    (_Bool)0;
#line 589 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static mpfr_ptr mpz2mpfr(mpz_ptr zi ) 
{ 
  size_t prec ;
  int tval ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 598
  prec = __gmpz_sizeinbase((mpz_srcptr )zi, 2);
#line 599
  tmp___1 = __gmpz_scan1((mpz_srcptr )zi, 0UL);
#line 599
  prec -= tmp___1;
  }
#line 600
  if (prec < 2UL) {
#line 601
    prec = (size_t )2;
  } else
#line 602
  if (prec > 0xffffffffffffffffUL >> 1) {
#line 603
    prec = 0xffffffffffffffffUL >> 1;
  }
#line 605
  if (! inited) {
    {
#line 606
    mpfr_init2(mpfrval, prec);
#line 607
    inited = (_Bool)1;
    }
  } else {
    {
#line 609
    mpfr_set_prec(mpfrval, prec);
    }
  }
  {
#line 610
  tval = mpfr_set_z(mpfrval, (mpz_srcptr )zi, ROUND_MODE);
  }
#line 611
  if (do_ieee_fmt) {
    {
#line 611
    tmp___2 = format_ieee(mpfrval, tval);
    }
#line 611
    if (tmp___2) {
#line 611
      tmp___3 = 1;
    } else {
#line 611
      tmp___3 = 0;
    }
  } else {
#line 611
    tmp___3 = 0;
  }
#line 612
  return (mpfrval);
}
}
#line 719 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static char const   sp[2]  = {      (char const   )' ',      (char const   )'\000'};
#line 720 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static char const   zero_string[2]  = {      (char const   )'0',      (char const   )'\000'};
#line 721 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static char const   lchbuf[17]  = 
#line 721
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 722 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static char const   Uchbuf[17]  = 
#line 722
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
#line 1003 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static _Bool warned___15  =    (_Bool)0;
#line 1020 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static _Bool warned___16  =    (_Bool)0;
#line 1037 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static _Bool warned___17  =    (_Bool)0;
#line 626 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *format_tree(char const   *fmt_string , size_t n0 , NODE **the_args , long num_args ) 
{ 
  size_t cur_arg ;
  NODE *r ;
  int i___0 ;
  int nc ;
  _Bool toofew ;
  char *obuf ;
  char *obufout ;
  size_t osiz ;
  size_t ofre ;
  char const   *chbuf ;
  char const   *s0 ;
  char const   *s1 ;
  int cs1 ;
  NODE *arg ;
  long fw ;
  long prec ;
  long argnum ;
  _Bool used_dollar ;
  _Bool lj ;
  _Bool alt ;
  _Bool big_flag ;
  _Bool bigbig_flag ;
  _Bool small_flag ;
  _Bool have_prec ;
  _Bool need_format ;
  long *cur ;
  uintmax_t uval ;
  _Bool sgn ;
  int base ;
  struct __anonstruct_cpbufs_88 cpbufs[2] ;
  char *cend ;
  char *cp ;
  char const   *fill ;
  double tmpval ;
  char signchar ;
  size_t len ;
  _Bool zero_flag ;
  _Bool quote_flag ;
  int ii ;
  int jj ;
  char *chp ;
  size_t copy_count ;
  size_t char_count ;
  mpz_ptr zi ;
  mpfr_ptr mf ;
  enum __anonenum_fmt_type_89 fmt_type ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t k ;
  size_t olen ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  char const   *tmp___12 ;
  char const   *msg___0 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  size_t olen___0 ;
  void *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int val ;
  unsigned short const   **tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  unsigned short const   **tmp___31 ;
  long tmp___32 ;
  long tmp___33 ;
  long tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  uintmax_t tmp___43 ;
  double tmp___44 ;
  uintmax_t tmp___45 ;
  char buf___7[100] ;
  wchar_t wc ;
  mbstate_t mbs___0 ;
  size_t count ;
  mbstate_t state___2 ;
  size_t count___0 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  size_t tmp___60 ;
  void *tmp___61 ;
  int *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  char *prev ;
  void *tmp___66 ;
  int *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  int tmp___70 ;
  char *prev___0 ;
  void *tmp___71 ;
  int *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  int tmp___75 ;
  char *prev___1 ;
  void *tmp___76 ;
  int *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  int tmp___80 ;
  char *prev___2 ;
  void *tmp___81 ;
  int *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  int tmp___85 ;
  char *prev___3 ;
  void *tmp___86 ;
  int *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  int tmp___90 ;
  size_t olen___1 ;
  void *tmp___91 ;
  int *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  int tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  intmax_t tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  double tmp___106 ;
  double tmp___107 ;
  char *prev___4 ;
  void *tmp___108 ;
  int *tmp___109 ;
  char *tmp___110 ;
  char *tmp___111 ;
  int tmp___112 ;
  char *prev___5 ;
  void *tmp___113 ;
  int *tmp___114 ;
  char *tmp___115 ;
  char *tmp___116 ;
  int tmp___117 ;
  char *prev___6 ;
  void *tmp___118 ;
  int *tmp___119 ;
  char *tmp___120 ;
  char *tmp___121 ;
  int tmp___122 ;
  char *prev___7 ;
  void *tmp___123 ;
  int *tmp___124 ;
  char *tmp___125 ;
  char *tmp___126 ;
  int tmp___127 ;
  char *prev___8 ;
  void *tmp___128 ;
  int *tmp___129 ;
  char *tmp___130 ;
  char *tmp___131 ;
  int tmp___132 ;
  size_t olen___2 ;
  void *tmp___133 ;
  int *tmp___134 ;
  char *tmp___135 ;
  char *tmp___136 ;
  int tmp___137 ;
  char *prev___9 ;
  void *tmp___138 ;
  int *tmp___139 ;
  char *tmp___140 ;
  char *tmp___141 ;
  int tmp___142 ;
  size_t olen___3 ;
  void *tmp___143 ;
  int *tmp___144 ;
  char *tmp___145 ;
  char *tmp___146 ;
  int tmp___147 ;
  char *tmp___148 ;
  size_t olen___4 ;
  void *tmp___149 ;
  int *tmp___150 ;
  char *tmp___151 ;
  char *tmp___152 ;
  int tmp___153 ;
  size_t olen___5 ;
  void *tmp___154 ;
  int *tmp___155 ;
  char *tmp___156 ;
  char *tmp___157 ;
  int tmp___158 ;
  char *tmp___159 ;
  char *tmp___160 ;
  char *tmp___161 ;
  char *tmp___162 ;
  size_t olen___6 ;
  size_t delta ;
  void *tmp___163 ;
  int *tmp___164 ;
  char *tmp___165 ;
  char *tmp___166 ;
  int tmp___167 ;
  char *tmp___168 ;
  char *tmp___169 ;
  char *tmp___170 ;
  char *tmp___171 ;
  char *tmp___172 ;
  char *tmp___173 ;
  size_t olen___7 ;
  size_t delta___0 ;
  void *tmp___174 ;
  int *tmp___175 ;
  char *tmp___176 ;
  char *tmp___177 ;
  int tmp___178 ;
  size_t olen___8 ;
  size_t delta___1 ;
  void *tmp___179 ;
  int *tmp___180 ;
  char *tmp___181 ;
  char *tmp___182 ;
  int tmp___183 ;
  size_t olen___9 ;
  size_t delta___2 ;
  void *tmp___184 ;
  int *tmp___185 ;
  char *tmp___186 ;
  char *tmp___187 ;
  int tmp___188 ;
  size_t olen___10 ;
  size_t delta___3 ;
  void *tmp___189 ;
  int *tmp___190 ;
  char *tmp___191 ;
  char *tmp___192 ;
  int tmp___193 ;
  char *tmp___194 ;
  unsigned short const   **tmp___195 ;
  char *tmp___196 ;
  char *tmp___197 ;
  size_t tmp___198 ;
  char *tmp___199 ;
  char *tmp___200 ;
  size_t olen___11 ;
  void *tmp___201 ;
  int *tmp___202 ;
  char *tmp___203 ;
  char *tmp___204 ;
  int tmp___205 ;
  size_t k___0 ;
  size_t count___1 ;
  void *__cil_tmp296 ;
  int __cil_tmp297 ;
  void *__cil_tmp298 ;
  void *__cil_tmp299 ;
  void *__cil_tmp300 ;
  void *__cil_tmp301 ;
  void *__cil_tmp302 ;
  void *__cil_tmp303 ;
  void *__cil_tmp304 ;
  void *__cil_tmp305 ;
  void *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;
  char *__cil_tmp402 ;
  char *__cil_tmp403 ;
  char *__cil_tmp404 ;
  char *__cil_tmp405 ;
  char *__cil_tmp406 ;
  char *__cil_tmp407 ;
  char *__cil_tmp408 ;
  char *__cil_tmp409 ;
  char *__cil_tmp410 ;
  char *__cil_tmp411 ;
  char *__cil_tmp412 ;
  char *__cil_tmp413 ;
  char *__cil_tmp414 ;
  char *__cil_tmp415 ;
  char *__cil_tmp416 ;
  char *__cil_tmp417 ;
  char *__cil_tmp418 ;
  char *__cil_tmp419 ;
  char *__cil_tmp420 ;
  char *__cil_tmp421 ;
  char *__cil_tmp422 ;
  char *__cil_tmp423 ;
  char *__cil_tmp424 ;
  char *__cil_tmp425 ;
  char *__cil_tmp426 ;
  char *__cil_tmp427 ;
  char *__cil_tmp428 ;
  char *__cil_tmp429 ;
  char *__cil_tmp430 ;
  char *__cil_tmp431 ;
  char *__cil_tmp432 ;
  char *__cil_tmp433 ;
  char *__cil_tmp434 ;
  char *__cil_tmp435 ;
  char *__cil_tmp436 ;
  char *__cil_tmp437 ;
  char *__cil_tmp438 ;
  char *__cil_tmp439 ;
  char *__cil_tmp440 ;
  char *__cil_tmp441 ;
  char *__cil_tmp442 ;
  char *__cil_tmp443 ;
  char *__cil_tmp444 ;
  char *__cil_tmp445 ;
  char *__cil_tmp446 ;
  char *__cil_tmp447 ;
  char *__cil_tmp448 ;
  char *__cil_tmp449 ;
  char *__cil_tmp450 ;
  char *__cil_tmp451 ;
  char *__cil_tmp452 ;
  char *__cil_tmp453 ;
  char *__cil_tmp454 ;
  char *__cil_tmp455 ;
  char *__cil_tmp456 ;
  char *__cil_tmp457 ;
  char *__cil_tmp458 ;
  char *__cil_tmp459 ;
  char *__cil_tmp460 ;
  char *__cil_tmp461 ;
  char *__cil_tmp462 ;
  char *__cil_tmp463 ;

  {
  {
#line 671
  cur_arg = (size_t )0;
#line 672
  r = (NODE *)((void *)0);
#line 674
  toofew = (_Bool)0;
#line 684
  cur = (long *)((void *)0);
#line 702
  cend = & cpbufs[0].stackbuf[sizeof(cpbufs[0].stackbuf)];
#line 705
  tmpval = 0.0;
#line 706
  signchar = (char )'\000';
#line 708
  zero_flag = (_Bool)0;
#line 709
  quote_flag = (_Bool)0;
#line 725
  tmp___1 = malloc((size_t )512);
#line 725
  obuf = (char *)tmp___1;
  }
#line 725
  if (obuf) {
#line 725
    tmp___5 = 1;
  } else {
    {
#line 725
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 725);
#line 725
    tmp___2 = __errno_location();
#line 725
    tmp___3 = strerror(*tmp___2);
#line 725
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 725
    r_fatal((char const   *)tmp___4, "format_tree", "obuf", 512L, tmp___3);
#line 725
    tmp___5 = 0;
    }
  }
#line 726
  obufout = obuf;
#line 727
  osiz = (size_t )512;
#line 728
  ofre = osiz - 2UL;
#line 730
  cur_arg = (size_t )1;
#line 734
  k = (size_t )0;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if (! (k < sizeof(cpbufs) / sizeof(cpbufs[0]))) {
#line 734
      goto while_break;
    }
#line 735
    cpbufs[k].bufsize = sizeof(cpbufs[k].stackbuf);
#line 736
    cpbufs[k].buf = cpbufs[k].stackbuf;
#line 734
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 789
  need_format = (_Bool)0;
#line 790
  used_dollar = (_Bool)0;
#line 792
  s1 = fmt_string;
#line 792
  s0 = s1;
  {
#line 793
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 793
    tmp___198 = n0;
#line 793
    n0 --;
#line 793
    if (! (tmp___198 > 0UL)) {
#line 793
      goto while_break___0;
    }
#line 794
    if ((int const   )*s1 != 37) {
#line 795
      s1 ++;
#line 796
      goto while_continue___0;
    }
#line 798
    need_format = (_Bool)1;
#line 799
    if (s1 - s0) {
      {
#line 799
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 799
        if (! ((size_t )(s1 - s0) > ofre)) {
#line 799
          goto while_break___1;
        }
        {
#line 799
        olen = (size_t )(obufout - obuf);
#line 799
        tmp___6 = realloc((void *)obuf, osiz * 2UL);
#line 799
        obuf = (char *)tmp___6;
        }
#line 799
        if (obuf) {
#line 799
          tmp___10 = 1;
        } else {
          {
#line 799
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 799);
#line 799
          tmp___7 = __errno_location();
#line 799
          tmp___8 = strerror(*tmp___7);
#line 799
          tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 799
          r_fatal((char const   *)tmp___9, "format_tree", "obuf", (long )(osiz * 2UL),
                  tmp___8);
#line 799
          tmp___10 = 0;
          }
        }
#line 799
        ofre += osiz;
#line 799
        osiz *= 2UL;
#line 799
        obufout = obuf + olen;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 799
      memcpy((void */* __restrict  */)obufout, (void const   */* __restrict  */)s0,
             (size_t )(s1 - s0));
#line 799
      obufout += s1 - s0;
#line 799
      ofre -= (size_t )(s1 - s0);
      }
    }
#line 800
    s0 = s1;
#line 801
    cur = & fw;
#line 802
    fw = 0L;
#line 803
    prec = 0L;
#line 804
    base = 0;
#line 805
    argnum = 0L;
#line 806
    base = 0;
#line 807
    have_prec = (_Bool)0;
#line 808
    signchar = (char )'\000';
#line 809
    zero_flag = (_Bool)0;
#line 810
    quote_flag = (_Bool)0;
#line 812
    mf = (mpfr_ptr )((void *)0);
#line 813
    zi = (mpz_ptr )((void *)0);
#line 815
    fmt_type = (enum __anonenum_fmt_type_89 )0;
#line 817
    small_flag = (_Bool)0;
#line 817
    bigbig_flag = small_flag;
#line 817
    big_flag = bigbig_flag;
#line 817
    alt = big_flag;
#line 817
    lj = alt;
#line 818
    fill = sp;
#line 819
    cp = cend;
#line 820
    chbuf = lchbuf;
#line 821
    s1 ++;
    retry: 
#line 824
    tmp___11 = n0;
#line 824
    n0 --;
#line 824
    if (tmp___11 == 0UL) {
#line 825
      goto while_break___0;
    }
#line 827
    tmp___12 = s1;
#line 827
    s1 ++;
#line 827
    cs1 = (int )*tmp___12;
    {
#line 828
    if (cs1 == -1) {
#line 828
      goto check_pos;
    }
#line 833
    if (cs1 == 37) {
#line 833
      goto case_37;
    }
#line 859
    if (cs1 == 48) {
#line 859
      goto case_48;
    }
#line 878
    if (cs1 == 57) {
#line 878
      goto case_57;
    }
#line 878
    if (cs1 == 56) {
#line 878
      goto case_57;
    }
#line 878
    if (cs1 == 55) {
#line 878
      goto case_57;
    }
#line 878
    if (cs1 == 54) {
#line 878
      goto case_57;
    }
#line 878
    if (cs1 == 53) {
#line 878
      goto case_57;
    }
#line 878
    if (cs1 == 52) {
#line 878
      goto case_57;
    }
#line 878
    if (cs1 == 51) {
#line 878
      goto case_57;
    }
#line 878
    if (cs1 == 50) {
#line 878
      goto case_57;
    }
#line 878
    if (cs1 == 49) {
#line 878
      goto case_57;
    }
#line 899
    if (cs1 == 36) {
#line 899
      goto case_36;
    }
#line 923
    if (cs1 == 42) {
#line 923
      goto case_42;
    }
#line 962
    if (cs1 == 32) {
#line 962
      goto case_32;
    }
#line 968
    if (cs1 == 43) {
#line 968
      goto case_43;
    }
#line 971
    if (cs1 == 45) {
#line 971
      goto case_45;
    }
#line 981
    if (cs1 == 46) {
#line 981
      goto case_46;
    }
#line 987
    if (cs1 == 35) {
#line 987
      goto case_35;
    }
#line 990
    if (cs1 == 39) {
#line 990
      goto case_39;
    }
#line 999
    if (cs1 == 108) {
#line 999
      goto case_108;
    }
#line 1016
    if (cs1 == 76) {
#line 1016
      goto case_76;
    }
#line 1033
    if (cs1 == 104) {
#line 1033
      goto case_104;
    }
#line 1050
    if (cs1 == 99) {
#line 1050
      goto case_99;
    }
#line 1123
    if (cs1 == 115) {
#line 1123
      goto case_115;
    }
#line 1137
    if (cs1 == 105) {
#line 1137
      goto case_105;
    }
#line 1137
    if (cs1 == 100) {
#line 1137
      goto case_105;
    }
#line 1250
    if (cs1 == 88) {
#line 1250
      goto case_88;
    }
#line 1252
    if (cs1 == 120) {
#line 1252
      goto case_120;
    }
#line 1254
    if (cs1 == 117) {
#line 1254
      goto case_117;
    }
#line 1256
    if (cs1 == 111) {
#line 1256
      goto case_111;
    }
#line 1453
    if (cs1 == 69) {
#line 1453
      goto case_69;
    }
#line 1453
    if (cs1 == 102) {
#line 1453
      goto case_69;
    }
#line 1453
    if (cs1 == 101) {
#line 1453
      goto case_69;
    }
#line 1453
    if (cs1 == 71) {
#line 1453
      goto case_69;
    }
#line 1453
    if (cs1 == 103) {
#line 1453
      goto case_69;
    }
#line 1453
    if (cs1 == 70) {
#line 1453
      goto case_69;
    }
#line 1535
    goto switch_default___0;
    check_pos: 
    case_neg_1: /* CIL Label */ 
#line 830
    if ((unsigned long )cur != (unsigned long )(& fw)) {
#line 831
      goto switch_break;
    }
#line 832
    goto retry;
    case_37: /* CIL Label */ 
#line 834
    need_format = (_Bool)0;
#line 842
    if (do_flags & 3) {
#line 843
      msg___0 = (char const   *)((void *)0);
#line 845
      if (fw) {
#line 845
        if (! have_prec) {
          {
#line 846
          tmp___13 = gettext("field width is ignored for `%%\' specifier");
#line 846
          msg___0 = (char const   *)tmp___13;
          }
        } else {
#line 845
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 847
      if (fw == 0L) {
#line 847
        if (have_prec) {
          {
#line 848
          tmp___14 = gettext("precision is ignored for `%%\' specifier");
#line 848
          msg___0 = (char const   *)tmp___14;
          }
        } else {
#line 847
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 849
      if (fw) {
#line 849
        if (have_prec) {
          {
#line 850
          tmp___15 = gettext("field width and precision are ignored for `%%\' specifier");
#line 850
          msg___0 = (char const   *)tmp___15;
          }
        }
      }
#line 852
      if ((unsigned long )msg___0 != (unsigned long )((void *)0)) {
        {
#line 853
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 853);
#line 853
        (*lintfunc)("%s", msg___0);
        }
      }
    }
#line 855
    if (ofre < 1UL) {
      {
#line 855
      olen___0 = (size_t )(obufout - obuf);
#line 855
      tmp___16 = realloc((void *)obuf, osiz * 2UL);
#line 855
      obuf = (char *)tmp___16;
      }
#line 855
      if (obuf) {
#line 855
        tmp___20 = 1;
      } else {
        {
#line 855
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 855);
#line 855
        tmp___17 = __errno_location();
#line 855
        tmp___18 = strerror(*tmp___17);
#line 855
        tmp___19 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 855
        r_fatal((char const   *)tmp___19, "format_tree", "obuf", (long )(osiz * 2UL),
                tmp___18);
#line 855
        tmp___20 = 0;
        }
      }
#line 855
      ofre += osiz;
#line 855
      osiz *= 2UL;
#line 855
      obufout = obuf + olen___0;
    }
#line 855
    tmp___21 = obufout;
#line 855
    obufout ++;
#line 855
    *tmp___21 = (char )*"%";
#line 855
    ofre --;
#line 856
    s0 = s1;
#line 857
    goto switch_break;
    case_48: /* CIL Label */ 
#line 865
    if ((unsigned long )cur == (unsigned long )(& fw)) {
#line 866
      zero_flag = (_Bool)1;
    }
#line 867
    if (lj) {
#line 868
      goto retry;
    }
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 879
    if ((unsigned long )cur == (unsigned long )((void *)0)) {
#line 880
      goto switch_break;
    }
#line 881
    if (prec >= 0L) {
#line 882
      *cur = (long )(cs1 - 48);
    }
    {
#line 888
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 888
      if (n0 > 0UL) {
#line 888
        if ((int const   )*s1 >= 48) {
#line 888
          if (! ((int const   )*s1 <= 57)) {
#line 888
            goto while_break___2;
          }
        } else {
#line 888
          goto while_break___2;
        }
      } else {
#line 888
        goto while_break___2;
      }
#line 889
      n0 --;
#line 890
      tmp___22 = s1;
#line 890
      s1 ++;
#line 890
      *cur = (*cur * 10L + (long )*tmp___22) - 48L;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 892
    if (prec < 0L) {
#line 893
      have_prec = (_Bool)0;
    }
#line 894
    if ((unsigned long )cur == (unsigned long )(& prec)) {
#line 895
      cur = (long *)((void *)0);
    }
#line 896
    if (n0 == 0UL) {
#line 897
      goto while_continue___0;
    }
#line 898
    goto retry;
    case_36: /* CIL Label */ 
#line 900
    if (do_flags & 8) {
      {
#line 901
      tmp___23 = gettext("fatal: `$\' is not permitted in awk formats");
#line 901
      msg((char const   *)tmp___23);
      }
#line 902
      goto out;
    }
#line 905
    if ((unsigned long )cur == (unsigned long )(& fw)) {
#line 906
      argnum = fw;
#line 907
      fw = 0L;
#line 908
      used_dollar = (_Bool)1;
#line 909
      if (argnum <= 0L) {
        {
#line 910
        tmp___24 = gettext("fatal: arg count with `$\' must be > 0");
#line 910
        msg((char const   *)tmp___24);
        }
#line 911
        goto out;
      }
#line 913
      if (argnum >= num_args) {
        {
#line 914
        tmp___25 = gettext("fatal: arg count %ld greater than total number of supplied arguments");
#line 914
        msg((char const   *)tmp___25, argnum);
        }
#line 915
        goto out;
      }
    } else {
      {
#line 918
      tmp___26 = gettext("fatal: `$\' not permitted after period in format");
#line 918
      msg((char const   *)tmp___26);
      }
#line 919
      goto out;
    }
#line 922
    goto retry;
    case_42: /* CIL Label */ 
#line 924
    if ((unsigned long )cur == (unsigned long )((void *)0)) {
#line 925
      goto switch_break;
    }
#line 926
    if (! (do_flags & 8)) {
      {
#line 926
      tmp___31 = __ctype_b_loc();
      }
#line 926
      if ((int const   )*(*tmp___31 + (int )((unsigned char )*s1)) & 2048) {
#line 927
        val = 0;
        {
#line 929
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 929
          if (n0 > 0UL) {
#line 929
            if (*s1) {
              {
#line 929
              tmp___27 = __ctype_b_loc();
              }
#line 929
              if (! ((int const   )*(*tmp___27 + (int )((unsigned char )*s1)) & 2048)) {
#line 929
                goto while_break___3;
              }
            } else {
#line 929
              goto while_break___3;
            }
          } else {
#line 929
            goto while_break___3;
          }
#line 930
          val *= 10;
#line 931
          val += (int )((int const   )*s1 - 48);
#line 929
          s1 ++;
#line 929
          n0 --;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 933
        if ((int const   )*s1 != 36) {
          {
#line 934
          tmp___28 = gettext("fatal: no `$\' supplied for positional field width or precision");
#line 934
          msg((char const   *)tmp___28);
          }
#line 935
          goto out;
        } else {
#line 937
          s1 ++;
#line 938
          n0 --;
        }
#line 940
        if ((long )val >= num_args) {
#line 941
          toofew = (_Bool)1;
#line 942
          goto switch_break;
        }
#line 944
        arg = *(the_args + val);
      } else {
#line 926
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 946
    if (argnum > 0L) {
#line 946
      if (cur_arg > 1UL) {
        {
#line 946
        tmp___29 = gettext("fatal: must use `count$\' on all formats or none");
#line 946
        msg((char const   *)tmp___29);
        }
#line 946
        goto out;
      }
#line 946
      arg = *(the_args + argnum);
    } else
#line 946
    if (used_dollar) {
      {
#line 946
      tmp___30 = gettext("fatal: must use `count$\' on all formats or none");
#line 946
      msg((char const   *)tmp___30);
#line 946
      arg = (NODE *)0;
      }
#line 946
      goto out;
    } else
#line 946
    if (cur_arg >= (size_t )num_args) {
#line 946
      arg = (NODE *)0;
#line 946
      toofew = (_Bool)1;
#line 946
      goto switch_break;
    } else {
#line 946
      arg = *(the_args + cur_arg);
#line 946
      cur_arg ++;
    }
    {
#line 948
    force_number(arg);
    }
#line 949
    if (arg->flags & 2048U) {
      {
#line 949
      tmp___32 = mpfr_get_si((mpfr_srcptr )(arg->sub.val.nm.mpnum), ROUND_MODE);
#line 949
      *cur = tmp___32;
      }
    } else {
#line 949
      if (arg->flags & 4096U) {
        {
#line 949
        tmp___33 = __gmpz_get_si((mpz_srcptr )(arg->sub.val.nm.mpi));
#line 949
        tmp___34 = tmp___33;
        }
      } else {
#line 949
        tmp___34 = (long )arg->sub.val.nm.fltnum;
      }
#line 949
      *cur = tmp___34;
    }
#line 950
    if (*cur < 0L) {
#line 950
      if ((unsigned long )cur == (unsigned long )(& fw)) {
#line 951
        *cur = - *cur;
#line 952
        lj = (_Bool )((int )lj + 1);
      }
    }
#line 954
    if ((unsigned long )cur == (unsigned long )(& prec)) {
#line 955
      if (*cur >= 0L) {
#line 956
        have_prec = (_Bool)1;
      } else {
#line 958
        have_prec = (_Bool)0;
      }
#line 959
      cur = (long *)((void *)0);
    }
#line 961
    goto retry;
    case_32: /* CIL Label */ 
#line 965
    if ((int )signchar != 0) {
#line 966
      goto check_pos;
    }
    case_43: /* CIL Label */ 
#line 969
    signchar = (char )cs1;
#line 970
    goto check_pos;
    case_45: /* CIL Label */ 
#line 972
    if (prec < 0L) {
#line 973
      goto switch_break;
    }
#line 974
    if ((unsigned long )cur == (unsigned long )(& prec)) {
#line 975
      prec = -1L;
#line 976
      goto retry;
    }
#line 978
    fill = sp;
#line 979
    lj = (_Bool )((int )lj + 1);
#line 980
    goto check_pos;
    case_46: /* CIL Label */ 
#line 982
    if ((unsigned long )cur != (unsigned long )(& fw)) {
#line 983
      goto switch_break;
    }
#line 984
    cur = & prec;
#line 985
    have_prec = (_Bool)1;
#line 986
    goto retry;
    case_35: /* CIL Label */ 
#line 988
    alt = (_Bool)1;
#line 989
    goto check_pos;
    case_39: /* CIL Label */ 
#line 993
    if ((int )*(loc.thousands_sep + 0) != 0) {
#line 994
      quote_flag = (_Bool)1;
    }
#line 995
    goto check_pos;
    case_108: /* CIL Label */ 
#line 1000
    if (big_flag) {
#line 1001
      goto switch_break;
    } else {
#line 1005
      if (do_flags & 3) {
#line 1005
        if (! warned___15) {
          {
#line 1006
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1006);
#line 1006
          tmp___35 = gettext("`l\' is meaningless in awk formats; ignored");
#line 1006
          (*lintfunc)((char const   *)tmp___35);
#line 1007
          warned___15 = (_Bool)1;
          }
        }
      }
#line 1009
      if (do_flags & 16) {
        {
#line 1010
        tmp___36 = gettext("fatal: `l\' is not permitted in POSIX awk formats");
#line 1010
        msg((char const   *)tmp___36);
        }
#line 1011
        goto out;
      }
    }
#line 1014
    big_flag = (_Bool)1;
#line 1015
    goto retry;
    case_76: /* CIL Label */ 
#line 1017
    if (bigbig_flag) {
#line 1018
      goto switch_break;
    } else {
#line 1022
      if (do_flags & 3) {
#line 1022
        if (! warned___16) {
          {
#line 1023
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1023);
#line 1023
          tmp___37 = gettext("`L\' is meaningless in awk formats; ignored");
#line 1023
          (*lintfunc)((char const   *)tmp___37);
#line 1024
          warned___16 = (_Bool)1;
          }
        }
      }
#line 1026
      if (do_flags & 16) {
        {
#line 1027
        tmp___38 = gettext("fatal: `L\' is not permitted in POSIX awk formats");
#line 1027
        msg((char const   *)tmp___38);
        }
#line 1028
        goto out;
      }
    }
#line 1031
    bigbig_flag = (_Bool)1;
#line 1032
    goto retry;
    case_104: /* CIL Label */ 
#line 1034
    if (small_flag) {
#line 1035
      goto switch_break;
    } else {
#line 1039
      if (do_flags & 3) {
#line 1039
        if (! warned___17) {
          {
#line 1040
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1040);
#line 1040
          tmp___39 = gettext("`h\' is meaningless in awk formats; ignored");
#line 1040
          (*lintfunc)((char const   *)tmp___39);
#line 1041
          warned___17 = (_Bool)1;
          }
        }
      }
#line 1043
      if (do_flags & 16) {
        {
#line 1044
        tmp___40 = gettext("fatal: `h\' is not permitted in POSIX awk formats");
#line 1044
        msg((char const   *)tmp___40);
        }
#line 1045
        goto out;
      }
    }
#line 1048
    small_flag = (_Bool)1;
#line 1049
    goto retry;
    case_99: /* CIL Label */ 
#line 1051
    need_format = (_Bool)0;
#line 1052
    if (argnum > 0L) {
#line 1052
      if (cur_arg > 1UL) {
        {
#line 1052
        tmp___41 = gettext("fatal: must use `count$\' on all formats or none");
#line 1052
        msg((char const   *)tmp___41);
        }
#line 1052
        goto out;
      }
#line 1052
      arg = *(the_args + argnum);
    } else
#line 1052
    if (used_dollar) {
      {
#line 1052
      tmp___42 = gettext("fatal: must use `count$\' on all formats or none");
#line 1052
      msg((char const   *)tmp___42);
#line 1052
      arg = (NODE *)0;
      }
#line 1052
      goto out;
    } else
#line 1052
    if (cur_arg >= (size_t )num_args) {
#line 1052
      arg = (NODE *)0;
#line 1052
      toofew = (_Bool)1;
#line 1052
      goto switch_break;
    } else {
#line 1052
      arg = *(the_args + cur_arg);
#line 1052
      cur_arg ++;
    }
#line 1054
    if ((arg->flags & 48U) == 32U) {
      {
#line 1055
      force_number(arg);
      }
    }
#line 1056
    if ((arg->flags & 16U) != 0U) {
#line 1057
      if (arg->flags & 2048U) {
        {
#line 1057
        tmp___43 = __gmpfr_mpfr_get_uj((mpfr_srcptr )(arg->sub.val.nm.mpnum), ROUND_MODE);
#line 1057
        uval = tmp___43;
        }
      } else {
#line 1057
        if (arg->flags & 4096U) {
          {
#line 1057
          tmp___44 = __gmpz_get_d((mpz_srcptr )(arg->sub.val.nm.mpi));
#line 1057
          tmp___45 = (uintmax_t )tmp___44;
          }
        } else {
#line 1057
          tmp___45 = (uintmax_t )arg->sub.val.nm.fltnum;
        }
#line 1057
        uval = tmp___45;
      }
#line 1059
      if (gawk_mb_cur_max > 1) {
        {
#line 1065
        memset((void *)(& mbs___0), 0, sizeof(mbs___0));
#line 1066
        wc = (wchar_t )uval;
#line 1068
        count = wcrtomb((char */* __restrict  */)(buf___7), wc, (mbstate_t */* __restrict  */)(& mbs___0));
        }
#line 1069
        if (count == 0UL) {
#line 1072
          goto out0;
        } else
#line 1069
        if (count == 0xffffffffffffffffUL) {
#line 1072
          goto out0;
        } else
#line 1069
        if (count == 0xfffffffffffffffeUL) {
#line 1072
          goto out0;
        }
        {
#line 1074
        memcpy((void */* __restrict  */)cpbufs[0].buf, (void const   */* __restrict  */)(buf___7),
               count);
#line 1075
        prec = (long )count;
#line 1076
        cp = cpbufs[0].buf;
        }
#line 1077
        goto pr_tail;
      }
      out0: ;
#line 1084
      if (do_flags & 3) {
#line 1084
        if (uval > 255UL) {
          {
#line 1085
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1085);
#line 1085
          (*lintfunc)("[s]printf: value %g is too big for %%c format", arg->sub.val.nm.fltnum);
          }
        }
      }
#line 1088
      *(cpbufs[0].buf + 0) = (char )uval;
#line 1089
      prec = 1L;
#line 1090
      cp = cpbufs[0].buf;
#line 1091
      goto pr_tail;
    }
#line 1099
    cp = arg->sub.val.sp;
#line 1105
    if (gawk_mb_cur_max > 1) {
      {
#line 1109
      memset((void *)(& state___2), 0, sizeof(state___2));
#line 1110
      count___0 = mbrlen((char const   */* __restrict  */)cp, arg->sub.val.slen, (mbstate_t */* __restrict  */)(& state___2));
      }
#line 1111
      if (count___0 == 0UL) {
#line 1114
        goto out2;
      } else
#line 1111
      if (count___0 == 0xffffffffffffffffUL) {
#line 1114
        goto out2;
      } else
#line 1111
      if (count___0 == 0xfffffffffffffffeUL) {
#line 1114
        goto out2;
      }
#line 1115
      prec = (long )count___0;
#line 1116
      goto pr_tail;
    }
    out2: 
#line 1121
    prec = 1L;
#line 1122
    goto pr_tail;
    case_115: /* CIL Label */ 
#line 1124
    need_format = (_Bool)0;
#line 1125
    if (argnum > 0L) {
#line 1125
      if (cur_arg > 1UL) {
        {
#line 1125
        tmp___46 = gettext("fatal: must use `count$\' on all formats or none");
#line 1125
        msg((char const   *)tmp___46);
        }
#line 1125
        goto out;
      }
#line 1125
      arg = *(the_args + argnum);
    } else
#line 1125
    if (used_dollar) {
      {
#line 1125
      tmp___47 = gettext("fatal: must use `count$\' on all formats or none");
#line 1125
      msg((char const   *)tmp___47);
#line 1125
      arg = (NODE *)0;
      }
#line 1125
      goto out;
    } else
#line 1125
    if (cur_arg >= (size_t )num_args) {
#line 1125
      arg = (NODE *)0;
#line 1125
      toofew = (_Bool)1;
#line 1125
      goto switch_break;
    } else {
#line 1125
      arg = *(the_args + cur_arg);
#line 1125
      cur_arg ++;
    }
    {
#line 1126
    arg = force_string(arg);
    }
#line 1127
    if (fw == 0L) {
#line 1127
      if (! have_prec) {
#line 1128
        prec = (long )arg->sub.val.slen;
      } else {
#line 1127
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 1130
      char_count = mbc_char_count((char const   *)arg->sub.val.sp, arg->sub.val.slen);
      }
#line 1131
      if (! have_prec) {
#line 1132
        prec = (long )char_count;
      } else
#line 1131
      if ((size_t )prec > char_count) {
#line 1132
        prec = (long )char_count;
      }
    }
#line 1134
    cp = arg->sub.val.sp;
#line 1135
    goto pr_tail;
    case_105: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 1138
    need_format = (_Bool)0;
#line 1139
    if (argnum > 0L) {
#line 1139
      if (cur_arg > 1UL) {
        {
#line 1139
        tmp___48 = gettext("fatal: must use `count$\' on all formats or none");
#line 1139
        msg((char const   *)tmp___48);
        }
#line 1139
        goto out;
      }
#line 1139
      arg = *(the_args + argnum);
    } else
#line 1139
    if (used_dollar) {
      {
#line 1139
      tmp___49 = gettext("fatal: must use `count$\' on all formats or none");
#line 1139
      msg((char const   *)tmp___49);
#line 1139
      arg = (NODE *)0;
      }
#line 1139
      goto out;
    } else
#line 1139
    if (cur_arg >= (size_t )num_args) {
#line 1139
      arg = (NODE *)0;
#line 1139
      toofew = (_Bool)1;
#line 1139
      goto switch_break;
    } else {
#line 1139
      arg = *(the_args + cur_arg);
#line 1139
      cur_arg ++;
    }
    {
#line 1140
    force_number(arg);
    }
#line 1142
    if ((arg->flags & 2048U) != 0U) {
#line 1143
      goto mpf0;
    } else
#line 1144
    if ((arg->flags & 4096U) != 0U) {
#line 1145
      goto mpz0;
    } else {
#line 1148
      tmpval = arg->sub.val.nm.fltnum;
    }
#line 1153
    if (sizeof(tmpval) == sizeof(float )) {
      {
#line 1153
      tmp___50 = __isnanf((float )tmpval);
#line 1153
      tmp___54 = tmp___50;
      }
    } else {
#line 1153
      if (sizeof(tmpval) == sizeof(double )) {
        {
#line 1153
        tmp___51 = __isnan(tmpval);
#line 1153
        tmp___53 = tmp___51;
        }
      } else {
        {
#line 1153
        tmp___52 = __isnanl((long double )tmpval);
#line 1153
        tmp___53 = tmp___52;
        }
      }
#line 1153
      tmp___54 = tmp___53;
    }
#line 1153
    if (tmp___54) {
#line 1154
      goto out_of_range;
    } else {
#line 1153
      if (sizeof(tmpval) == sizeof(float )) {
        {
#line 1153
        tmp___55 = __isinff((float )tmpval);
#line 1153
        tmp___59 = tmp___55;
        }
      } else {
#line 1153
        if (sizeof(tmpval) == sizeof(double )) {
          {
#line 1153
          tmp___56 = __isinf(tmpval);
#line 1153
          tmp___58 = tmp___56;
          }
        } else {
          {
#line 1153
          tmp___57 = __isinfl((long double )tmpval);
#line 1153
          tmp___58 = tmp___57;
          }
        }
#line 1153
        tmp___59 = tmp___58;
      }
#line 1153
      if (tmp___59) {
#line 1154
        goto out_of_range;
      } else {
        {
#line 1156
        tmpval = double_to_int(tmpval);
        }
      }
    }
#line 1162
    if (have_prec) {
#line 1162
      if (prec == 0L) {
#line 1162
        if (tmpval == (double )0) {
#line 1163
          goto pr_tail;
        }
      }
    }
#line 1165
    if (tmpval < (double )0) {
#line 1166
      tmpval = - tmpval;
#line 1167
      sgn = (_Bool)1;
    } else {
#line 1169
      if (tmpval == - 0.0) {
#line 1171
        tmpval = 0.0;
      }
#line 1172
      sgn = (_Bool)0;
    }
    {
#line 1178
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1178
      i___0 = snprintf((char */* __restrict  */)cpbufs[1].buf, cpbufs[1].bufsize,
                       (char const   */* __restrict  */)"%.0f", tmpval);
      }
#line 1178
      if (! ((size_t )i___0 >= cpbufs[1].bufsize)) {
#line 1178
        goto while_break___4;
      }
#line 1182
      if ((unsigned long )cpbufs[1].buf == (unsigned long )(cpbufs[1].stackbuf)) {
#line 1183
        cpbufs[1].buf = (char *)((void *)0);
      }
#line 1184
      if (i___0 > 0) {
#line 1185
        if ((size_t )i___0 > cpbufs[1].bufsize) {
#line 1185
          tmp___60 = (size_t )i___0;
        } else {
#line 1185
          tmp___60 = cpbufs[1].bufsize;
        }
#line 1185
        cpbufs[1].bufsize += tmp___60;
      } else {
#line 1189
        cpbufs[1].bufsize *= 2UL;
      }
      {
#line 1191
      tmp___61 = realloc((void *)cpbufs[1].buf, cpbufs[1].bufsize);
#line 1191
      cpbufs[1].buf = (char *)tmp___61;
      }
#line 1191
      if (cpbufs[1].buf) {
#line 1191
        tmp___65 = 1;
      } else {
        {
#line 1191
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1192);
#line 1191
        tmp___62 = __errno_location();
#line 1191
        tmp___63 = strerror(*tmp___62);
#line 1191
        tmp___64 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1191
        r_fatal((char const   *)tmp___64, "format_tree", "cpbufs[1].buf", (long )cpbufs[1].bufsize,
                tmp___63);
#line 1191
        tmp___65 = 0;
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1194
    if (i___0 < 1) {
#line 1195
      goto out_of_range;
    }
#line 1196
    chp = cpbufs[1].buf + (i___0 - 1);
#line 1197
    jj = 0;
#line 1197
    ii = jj;
    {
#line 1198
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1199
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1199
        if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
          {
#line 1199
          prev = cpbufs[0].buf;
#line 1199
          tmp___66 = malloc(2UL * cpbufs[0].bufsize);
#line 1199
          cpbufs[0].buf = (char *)tmp___66;
          }
#line 1199
          if (cpbufs[0].buf) {
#line 1199
            tmp___70 = 1;
          } else {
            {
#line 1199
            set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1199);
#line 1199
            tmp___67 = __errno_location();
#line 1199
            tmp___68 = strerror(*tmp___67);
#line 1199
            tmp___69 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1199
            r_fatal((char const   *)tmp___69, "format_tree", "cpbufs[0].buf", (long )(2UL * cpbufs[0].bufsize),
                    tmp___68);
#line 1199
            tmp___70 = 0;
            }
          }
          {
#line 1199
          cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1199
          memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev,
                 cpbufs[0].bufsize);
#line 1199
          cpbufs[0].bufsize *= 2UL;
          }
#line 1199
          if ((unsigned long )prev != (unsigned long )(cpbufs[0].stackbuf)) {
            {
#line 1199
            free((void *)prev);
            }
          }
#line 1199
          cend = cpbufs[0].buf + cpbufs[0].bufsize;
        }
#line 1199
        cp --;
#line 1199
        *cp = *chp;
#line 1199
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1200
      chp --;
#line 1200
      i___0 --;
#line 1202
      if (quote_flag) {
#line 1202
        if (*(loc.grouping + ii)) {
#line 1202
          jj ++;
#line 1202
          if (jj == (int )*(loc.grouping + ii)) {
#line 1203
            if (i___0) {
              {
#line 1204
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 1204
                if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
                  {
#line 1204
                  prev___0 = cpbufs[0].buf;
#line 1204
                  tmp___71 = malloc(2UL * cpbufs[0].bufsize);
#line 1204
                  cpbufs[0].buf = (char *)tmp___71;
                  }
#line 1204
                  if (cpbufs[0].buf) {
#line 1204
                    tmp___75 = 1;
                  } else {
                    {
#line 1204
                    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1204);
#line 1204
                    tmp___72 = __errno_location();
#line 1204
                    tmp___73 = strerror(*tmp___72);
#line 1204
                    tmp___74 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1204
                    r_fatal((char const   *)tmp___74, "format_tree", "cpbufs[0].buf",
                            (long )(2UL * cpbufs[0].bufsize), tmp___73);
#line 1204
                    tmp___75 = 0;
                    }
                  }
                  {
#line 1204
                  cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1204
                  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___0,
                         cpbufs[0].bufsize);
#line 1204
                  cpbufs[0].bufsize *= 2UL;
                  }
#line 1204
                  if ((unsigned long )prev___0 != (unsigned long )(cpbufs[0].stackbuf)) {
                    {
#line 1204
                    free((void *)prev___0);
                    }
                  }
#line 1204
                  cend = cpbufs[0].buf + cpbufs[0].bufsize;
                }
#line 1204
                cp --;
#line 1204
                *cp = *(loc.thousands_sep + 0);
#line 1204
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
            }
#line 1205
            if ((int )*(loc.grouping + (ii + 1)) == 0) {
#line 1206
              jj = 0;
            } else
#line 1207
            if ((int )*(loc.grouping + (ii + 1)) == 127) {
#line 1208
              quote_flag = (_Bool)0;
            } else {
#line 1210
              ii ++;
#line 1211
              jj = 0;
            }
          }
        }
      }
#line 1198
      if (! (i___0 > 0)) {
#line 1198
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1218
    if (have_prec) {
      {
#line 1219
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1219
        if (! (cend - cp < prec)) {
#line 1219
          goto while_break___8;
        }
        {
#line 1220
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1220
          if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
            {
#line 1220
            prev___1 = cpbufs[0].buf;
#line 1220
            tmp___76 = malloc(2UL * cpbufs[0].bufsize);
#line 1220
            cpbufs[0].buf = (char *)tmp___76;
            }
#line 1220
            if (cpbufs[0].buf) {
#line 1220
              tmp___80 = 1;
            } else {
              {
#line 1220
              set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1220);
#line 1220
              tmp___77 = __errno_location();
#line 1220
              tmp___78 = strerror(*tmp___77);
#line 1220
              tmp___79 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1220
              r_fatal((char const   *)tmp___79, "format_tree", "cpbufs[0].buf", (long )(2UL * cpbufs[0].bufsize),
                      tmp___78);
#line 1220
              tmp___80 = 0;
              }
            }
            {
#line 1220
            cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1220
            memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___1,
                   cpbufs[0].bufsize);
#line 1220
            cpbufs[0].bufsize *= 2UL;
            }
#line 1220
            if ((unsigned long )prev___1 != (unsigned long )(cpbufs[0].stackbuf)) {
              {
#line 1220
              free((void *)prev___1);
              }
            }
#line 1220
            cend = cpbufs[0].buf + cpbufs[0].bufsize;
          }
#line 1220
          cp --;
#line 1220
          *cp = (char )'0';
#line 1220
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 1223
    if (sgn) {
      {
#line 1224
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1224
        if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
          {
#line 1224
          prev___2 = cpbufs[0].buf;
#line 1224
          tmp___81 = malloc(2UL * cpbufs[0].bufsize);
#line 1224
          cpbufs[0].buf = (char *)tmp___81;
          }
#line 1224
          if (cpbufs[0].buf) {
#line 1224
            tmp___85 = 1;
          } else {
            {
#line 1224
            set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1224);
#line 1224
            tmp___82 = __errno_location();
#line 1224
            tmp___83 = strerror(*tmp___82);
#line 1224
            tmp___84 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1224
            r_fatal((char const   *)tmp___84, "format_tree", "cpbufs[0].buf", (long )(2UL * cpbufs[0].bufsize),
                    tmp___83);
#line 1224
            tmp___85 = 0;
            }
          }
          {
#line 1224
          cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1224
          memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___2,
                 cpbufs[0].bufsize);
#line 1224
          cpbufs[0].bufsize *= 2UL;
          }
#line 1224
          if ((unsigned long )prev___2 != (unsigned long )(cpbufs[0].stackbuf)) {
            {
#line 1224
            free((void *)prev___2);
            }
          }
#line 1224
          cend = cpbufs[0].buf + cpbufs[0].bufsize;
        }
#line 1224
        cp --;
#line 1224
        *cp = (char )'-';
#line 1224
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    } else
#line 1225
    if (signchar) {
      {
#line 1226
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1226
        if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
          {
#line 1226
          prev___3 = cpbufs[0].buf;
#line 1226
          tmp___86 = malloc(2UL * cpbufs[0].bufsize);
#line 1226
          cpbufs[0].buf = (char *)tmp___86;
          }
#line 1226
          if (cpbufs[0].buf) {
#line 1226
            tmp___90 = 1;
          } else {
            {
#line 1226
            set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1226);
#line 1226
            tmp___87 = __errno_location();
#line 1226
            tmp___88 = strerror(*tmp___87);
#line 1226
            tmp___89 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1226
            r_fatal((char const   *)tmp___89, "format_tree", "cpbufs[0].buf", (long )(2UL * cpbufs[0].bufsize),
                    tmp___88);
#line 1226
            tmp___90 = 0;
            }
          }
          {
#line 1226
          cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1226
          memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___3,
                 cpbufs[0].bufsize);
#line 1226
          cpbufs[0].bufsize *= 2UL;
          }
#line 1226
          if ((unsigned long )prev___3 != (unsigned long )(cpbufs[0].stackbuf)) {
            {
#line 1226
            free((void *)prev___3);
            }
          }
#line 1226
          cend = cpbufs[0].buf + cpbufs[0].bufsize;
        }
#line 1226
        cp --;
#line 1226
        *cp = signchar;
#line 1226
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 1235
    if (! lj) {
#line 1235
      if (zero_flag) {
#line 1235
        if (! have_prec) {
#line 1238
          fill = zero_string;
        } else {
#line 1235
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1235
      if (fw == 0L) {
#line 1235
        if (have_prec) {
#line 1238
          fill = zero_string;
        }
      }
    }
#line 1239
    if (prec > fw) {
#line 1240
      fw = prec;
    }
#line 1241
    prec = cend - cp;
#line 1242
    if (fw > prec) {
#line 1242
      if (! lj) {
#line 1242
        if ((unsigned long )fill != (unsigned long )(sp)) {
#line 1242
          if ((int )*cp == 45) {
#line 1242
            goto _L___4;
          } else
#line 1242
          if (signchar) {
            _L___4: /* CIL Label */ 
#line 1244
            if (ofre < 1UL) {
              {
#line 1244
              olen___1 = (size_t )(obufout - obuf);
#line 1244
              tmp___91 = realloc((void *)obuf, osiz * 2UL);
#line 1244
              obuf = (char *)tmp___91;
              }
#line 1244
              if (obuf) {
#line 1244
                tmp___95 = 1;
              } else {
                {
#line 1244
                set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1244);
#line 1244
                tmp___92 = __errno_location();
#line 1244
                tmp___93 = strerror(*tmp___92);
#line 1244
                tmp___94 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1244
                r_fatal((char const   *)tmp___94, "format_tree", "obuf", (long )(osiz * 2UL),
                        tmp___93);
#line 1244
                tmp___95 = 0;
                }
              }
#line 1244
              ofre += osiz;
#line 1244
              osiz *= 2UL;
#line 1244
              obufout = obuf + olen___1;
            }
#line 1244
            tmp___96 = obufout;
#line 1244
            obufout ++;
#line 1244
            *tmp___96 = *cp;
#line 1244
            ofre --;
#line 1245
            cp ++;
#line 1246
            prec --;
#line 1247
            fw --;
          }
        }
      }
    }
#line 1249
    goto pr_tail;
    case_88: /* CIL Label */ 
#line 1251
    chbuf = Uchbuf;
    case_120: /* CIL Label */ 
#line 1253
    base += 6;
    case_117: /* CIL Label */ 
#line 1255
    base += 2;
    case_111: /* CIL Label */ 
#line 1257
    base += 8;
#line 1258
    need_format = (_Bool)0;
#line 1259
    if (argnum > 0L) {
#line 1259
      if (cur_arg > 1UL) {
        {
#line 1259
        tmp___97 = gettext("fatal: must use `count$\' on all formats or none");
#line 1259
        msg((char const   *)tmp___97);
        }
#line 1259
        goto out;
      }
#line 1259
      arg = *(the_args + argnum);
    } else
#line 1259
    if (used_dollar) {
      {
#line 1259
      tmp___98 = gettext("fatal: must use `count$\' on all formats or none");
#line 1259
      msg((char const   *)tmp___98);
#line 1259
      arg = (NODE *)0;
      }
#line 1259
      goto out;
    } else
#line 1259
    if (cur_arg >= (size_t )num_args) {
#line 1259
      arg = (NODE *)0;
#line 1259
      toofew = (_Bool)1;
#line 1259
      goto switch_break;
    } else {
#line 1259
      arg = *(the_args + cur_arg);
#line 1259
      cur_arg ++;
    }
    {
#line 1260
    force_number(arg);
    }
#line 1262
    if ((arg->flags & 4096U) != 0U) {
      mpz0: 
#line 1264
      zi = arg->sub.val.nm.mpi;
#line 1266
      if (cs1 != 100) {
#line 1266
        if (cs1 != 105) {
#line 1267
          if (zi->_mp_size < 0) {
#line 1267
            tmp___99 = -1;
          } else {
#line 1267
            tmp___99 = zi->_mp_size > 0;
          }
#line 1267
          if (tmp___99 <= 0) {
            {
#line 1274
            mf = mpz2mpfr(zi);
            }
#line 1275
            goto mpf1;
          }
#line 1277
          signchar = (char )'\000';
        }
      }
#line 1281
      if (! lj) {
#line 1281
        if (zero_flag) {
#line 1281
          if (! have_prec) {
#line 1281
            tmp___100 = 1;
          } else {
#line 1281
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 1281
        if (fw == 0L) {
#line 1281
          if (have_prec) {
#line 1281
            tmp___100 = 1;
          } else {
#line 1281
            tmp___100 = 0;
          }
        } else {
#line 1281
          tmp___100 = 0;
        }
      } else {
#line 1281
        tmp___100 = 0;
      }
#line 1281
      zero_flag = (_Bool )tmp___100;
#line 1285
      if (have_prec) {
#line 1285
        fmt_type = (enum __anonenum_fmt_type_89 )1;
      } else {
#line 1285
        fmt_type = (enum __anonenum_fmt_type_89 )2;
      }
#line 1286
      goto fmt0;
    } else
#line 1288
    if ((arg->flags & 2048U) != 0U) {
      mpf0: 
      {
#line 1290
      mf = arg->sub.val.nm.mpnum;
#line 1291
      tmp___101 = mpfr_number_p((mpfr_srcptr )mf);
      }
#line 1291
      if (! tmp___101) {
#line 1293
        cs1 = 'g';
#line 1294
        fmt_type = (enum __anonenum_fmt_type_89 )3;
#line 1295
        goto fmt1;
      }
#line 1298
      if (cs1 != 100) {
#line 1298
        if (cs1 != 105) {
          mpf1: 
#line 1304
          if (mf->_mpfr_exp < (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 3UL)) {
#line 1304
            if (mf->_mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 2UL)) {
              {
#line 1304
              mpfr_set_erangeflag();
              }
            }
#line 1304
            tmp___104 = 0;
          } else {
#line 1304
            tmp___104 = mf->_mpfr_sign;
          }
#line 1304
          if (tmp___104 <= 0) {
            {
#line 1305
            tmp___102 = mpfr_fits_intmax_p((mpfr_srcptr )mf, ROUND_MODE);
            }
#line 1305
            if (! tmp___102) {
#line 1307
              cs1 = 'g';
#line 1308
              fmt_type = (enum __anonenum_fmt_type_89 )3;
#line 1309
              goto fmt1;
            }
            {
#line 1312
            tmp___103 = __gmpfr_mpfr_get_sj((mpfr_srcptr )mf, ROUND_MODE);
#line 1312
            uval = (uintmax_t )tmp___103;
#line 1312
            tmpval = (double )uval;
            }
#line 1313
            if (! alt) {
#line 1313
              if (have_prec) {
#line 1313
                if (prec == 0L) {
#line 1313
                  if (tmpval == (double )0) {
#line 1314
                    goto pr_tail;
                  }
                }
              }
            }
#line 1315
            goto int0;
          }
#line 1317
          signchar = (char )'\000';
        }
      }
#line 1321
      if (! lj) {
#line 1321
        if (zero_flag) {
#line 1321
          if (! have_prec) {
#line 1321
            tmp___105 = 1;
          } else {
#line 1321
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 1321
        if (fw == 0L) {
#line 1321
          if (have_prec) {
#line 1321
            tmp___105 = 1;
          } else {
#line 1321
            tmp___105 = 0;
          }
        } else {
#line 1321
          tmp___105 = 0;
        }
      } else {
#line 1321
        tmp___105 = 0;
      }
      {
#line 1321
      zero_flag = (_Bool )tmp___105;
#line 1325
      mpfr_get_z(mpzval, (mpfr_srcptr )mf, (mpfr_rnd_t )1);
      }
#line 1326
      if (have_prec) {
#line 1326
        fmt_type = (enum __anonenum_fmt_type_89 )1;
      } else {
#line 1326
        fmt_type = (enum __anonenum_fmt_type_89 )2;
      }
#line 1327
      zi = mpzval;
#line 1328
      goto fmt0;
    } else {
#line 1331
      tmpval = arg->sub.val.nm.fltnum;
    }
#line 1345
    if (! alt) {
#line 1345
      if (have_prec) {
#line 1345
        if (prec == 0L) {
#line 1345
          if (tmpval == (double )0) {
#line 1346
            goto pr_tail;
          }
        }
      }
    }
#line 1348
    if (tmpval < (double )0) {
      {
#line 1349
      uval = (uintmax_t )((intmax_t )tmpval);
#line 1350
      tmp___106 = double_to_int(tmpval);
      }
#line 1350
      if ((double )((intmax_t )uval) != tmp___106) {
#line 1351
        goto out_of_range;
      }
    } else {
      {
#line 1353
      uval = (uintmax_t )tmpval;
#line 1354
      tmp___107 = double_to_int(tmpval);
      }
#line 1354
      if ((double )uval != tmp___107) {
#line 1355
        goto out_of_range;
      }
    }
    int0: 
#line 1368
    if (! lj) {
#line 1368
      if (zero_flag) {
#line 1368
        if (! have_prec) {
#line 1371
          fill = zero_string;
        } else {
#line 1368
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 1368
      if (fw == 0L) {
#line 1368
        if (have_prec) {
#line 1371
          fill = zero_string;
        }
      }
    }
#line 1372
    jj = 0;
#line 1372
    ii = jj;
    {
#line 1373
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 1374
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1374
        if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
          {
#line 1374
          prev___4 = cpbufs[0].buf;
#line 1374
          tmp___108 = malloc(2UL * cpbufs[0].bufsize);
#line 1374
          cpbufs[0].buf = (char *)tmp___108;
          }
#line 1374
          if (cpbufs[0].buf) {
#line 1374
            tmp___112 = 1;
          } else {
            {
#line 1374
            set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1374);
#line 1374
            tmp___109 = __errno_location();
#line 1374
            tmp___110 = strerror(*tmp___109);
#line 1374
            tmp___111 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1374
            r_fatal((char const   *)tmp___111, "format_tree", "cpbufs[0].buf", (long )(2UL * cpbufs[0].bufsize),
                    tmp___110);
#line 1374
            tmp___112 = 0;
            }
          }
          {
#line 1374
          cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1374
          memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___4,
                 cpbufs[0].bufsize);
#line 1374
          cpbufs[0].bufsize *= 2UL;
          }
#line 1374
          if ((unsigned long )prev___4 != (unsigned long )(cpbufs[0].stackbuf)) {
            {
#line 1374
            free((void *)prev___4);
            }
          }
#line 1374
          cend = cpbufs[0].buf + cpbufs[0].bufsize;
        }
#line 1374
        cp --;
#line 1374
        *cp = (char )*(chbuf + uval % (unsigned long )base);
#line 1374
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1375
      uval /= (uintmax_t )base;
#line 1377
      if (base == 10) {
#line 1377
        if (quote_flag) {
#line 1377
          if (*(loc.grouping + ii)) {
#line 1377
            jj ++;
#line 1377
            if (jj == (int )*(loc.grouping + ii)) {
#line 1378
              if (uval) {
                {
#line 1379
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 1379
                  if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
                    {
#line 1379
                    prev___5 = cpbufs[0].buf;
#line 1379
                    tmp___113 = malloc(2UL * cpbufs[0].bufsize);
#line 1379
                    cpbufs[0].buf = (char *)tmp___113;
                    }
#line 1379
                    if (cpbufs[0].buf) {
#line 1379
                      tmp___117 = 1;
                    } else {
                      {
#line 1379
                      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1379);
#line 1379
                      tmp___114 = __errno_location();
#line 1379
                      tmp___115 = strerror(*tmp___114);
#line 1379
                      tmp___116 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1379
                      r_fatal((char const   *)tmp___116, "format_tree", "cpbufs[0].buf",
                              (long )(2UL * cpbufs[0].bufsize), tmp___115);
#line 1379
                      tmp___117 = 0;
                      }
                    }
                    {
#line 1379
                    cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1379
                    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___5,
                           cpbufs[0].bufsize);
#line 1379
                    cpbufs[0].bufsize *= 2UL;
                    }
#line 1379
                    if ((unsigned long )prev___5 != (unsigned long )(cpbufs[0].stackbuf)) {
                      {
#line 1379
                      free((void *)prev___5);
                      }
                    }
#line 1379
                    cend = cpbufs[0].buf + cpbufs[0].bufsize;
                  }
#line 1379
                  cp --;
#line 1379
                  *cp = *(loc.thousands_sep + 0);
#line 1379
                  goto while_break___14;
                }
                while_break___14: /* CIL Label */ ;
                }
              }
#line 1380
              if ((int )*(loc.grouping + (ii + 1)) == 0) {
#line 1381
                jj = 0;
              } else
#line 1382
              if ((int )*(loc.grouping + (ii + 1)) == 127) {
#line 1383
                quote_flag = (_Bool)0;
              } else {
#line 1385
                ii ++;
#line 1386
                jj = 0;
              }
            }
          }
        }
      }
#line 1373
      if (! (uval > 0UL)) {
#line 1373
        goto while_break___12;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1393
    if (have_prec) {
      {
#line 1394
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1394
        if (! (cend - cp < prec)) {
#line 1394
          goto while_break___15;
        }
        {
#line 1395
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 1395
          if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
            {
#line 1395
            prev___6 = cpbufs[0].buf;
#line 1395
            tmp___118 = malloc(2UL * cpbufs[0].bufsize);
#line 1395
            cpbufs[0].buf = (char *)tmp___118;
            }
#line 1395
            if (cpbufs[0].buf) {
#line 1395
              tmp___122 = 1;
            } else {
              {
#line 1395
              set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1395);
#line 1395
              tmp___119 = __errno_location();
#line 1395
              tmp___120 = strerror(*tmp___119);
#line 1395
              tmp___121 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1395
              r_fatal((char const   *)tmp___121, "format_tree", "cpbufs[0].buf", (long )(2UL * cpbufs[0].bufsize),
                      tmp___120);
#line 1395
              tmp___122 = 0;
              }
            }
            {
#line 1395
            cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1395
            memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___6,
                   cpbufs[0].bufsize);
#line 1395
            cpbufs[0].bufsize *= 2UL;
            }
#line 1395
            if ((unsigned long )prev___6 != (unsigned long )(cpbufs[0].stackbuf)) {
              {
#line 1395
              free((void *)prev___6);
              }
            }
#line 1395
            cend = cpbufs[0].buf + cpbufs[0].bufsize;
          }
#line 1395
          cp --;
#line 1395
          *cp = (char )'0';
#line 1395
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 1398
    if (alt) {
#line 1398
      if (tmpval != (double )0) {
#line 1399
        if (base == 16) {
          {
#line 1400
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 1400
            if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
              {
#line 1400
              prev___7 = cpbufs[0].buf;
#line 1400
              tmp___123 = malloc(2UL * cpbufs[0].bufsize);
#line 1400
              cpbufs[0].buf = (char *)tmp___123;
              }
#line 1400
              if (cpbufs[0].buf) {
#line 1400
                tmp___127 = 1;
              } else {
                {
#line 1400
                set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1400);
#line 1400
                tmp___124 = __errno_location();
#line 1400
                tmp___125 = strerror(*tmp___124);
#line 1400
                tmp___126 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1400
                r_fatal((char const   *)tmp___126, "format_tree", "cpbufs[0].buf",
                        (long )(2UL * cpbufs[0].bufsize), tmp___125);
#line 1400
                tmp___127 = 0;
                }
              }
              {
#line 1400
              cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1400
              memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___7,
                     cpbufs[0].bufsize);
#line 1400
              cpbufs[0].bufsize *= 2UL;
              }
#line 1400
              if ((unsigned long )prev___7 != (unsigned long )(cpbufs[0].stackbuf)) {
                {
#line 1400
                free((void *)prev___7);
                }
              }
#line 1400
              cend = cpbufs[0].buf + cpbufs[0].bufsize;
            }
#line 1400
            cp --;
#line 1400
            *cp = (char )cs1;
#line 1400
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
          {
#line 1401
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 1401
            if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
              {
#line 1401
              prev___8 = cpbufs[0].buf;
#line 1401
              tmp___128 = malloc(2UL * cpbufs[0].bufsize);
#line 1401
              cpbufs[0].buf = (char *)tmp___128;
              }
#line 1401
              if (cpbufs[0].buf) {
#line 1401
                tmp___132 = 1;
              } else {
                {
#line 1401
                set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1401);
#line 1401
                tmp___129 = __errno_location();
#line 1401
                tmp___130 = strerror(*tmp___129);
#line 1401
                tmp___131 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1401
                r_fatal((char const   *)tmp___131, "format_tree", "cpbufs[0].buf",
                        (long )(2UL * cpbufs[0].bufsize), tmp___130);
#line 1401
                tmp___132 = 0;
                }
              }
              {
#line 1401
              cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1401
              memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___8,
                     cpbufs[0].bufsize);
#line 1401
              cpbufs[0].bufsize *= 2UL;
              }
#line 1401
              if ((unsigned long )prev___8 != (unsigned long )(cpbufs[0].stackbuf)) {
                {
#line 1401
                free((void *)prev___8);
                }
              }
#line 1401
              cend = cpbufs[0].buf + cpbufs[0].bufsize;
            }
#line 1401
            cp --;
#line 1401
            *cp = (char )'0';
#line 1401
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
#line 1402
          if ((unsigned long )fill != (unsigned long )(sp)) {
            {
#line 1403
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 1403
              if (! (2UL > ofre)) {
#line 1403
                goto while_break___19;
              }
              {
#line 1403
              olen___2 = (size_t )(obufout - obuf);
#line 1403
              tmp___133 = realloc((void *)obuf, osiz * 2UL);
#line 1403
              obuf = (char *)tmp___133;
              }
#line 1403
              if (obuf) {
#line 1403
                tmp___137 = 1;
              } else {
                {
#line 1403
                set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1403);
#line 1403
                tmp___134 = __errno_location();
#line 1403
                tmp___135 = strerror(*tmp___134);
#line 1403
                tmp___136 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1403
                r_fatal((char const   *)tmp___136, "format_tree", "obuf", (long )(osiz * 2UL),
                        tmp___135);
#line 1403
                tmp___137 = 0;
                }
              }
#line 1403
              ofre += osiz;
#line 1403
              osiz *= 2UL;
#line 1403
              obufout = obuf + olen___2;
            }
            while_break___19: /* CIL Label */ ;
            }
            {
#line 1403
            memcpy((void */* __restrict  */)obufout, (void const   */* __restrict  */)cp,
                   (size_t )2);
#line 1403
            obufout += 2;
#line 1403
            ofre -= 2UL;
#line 1404
            cp += 2;
#line 1405
            fw -= 2L;
            }
          }
        } else
#line 1407
        if (base == 8) {
          {
#line 1408
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 1408
            if ((unsigned long )cp == (unsigned long )cpbufs[0].buf) {
              {
#line 1408
              prev___9 = cpbufs[0].buf;
#line 1408
              tmp___138 = malloc(2UL * cpbufs[0].bufsize);
#line 1408
              cpbufs[0].buf = (char *)tmp___138;
              }
#line 1408
              if (cpbufs[0].buf) {
#line 1408
                tmp___142 = 1;
              } else {
                {
#line 1408
                set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1408);
#line 1408
                tmp___139 = __errno_location();
#line 1408
                tmp___140 = strerror(*tmp___139);
#line 1408
                tmp___141 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1408
                r_fatal((char const   *)tmp___141, "format_tree", "cpbufs[0].buf",
                        (long )(2UL * cpbufs[0].bufsize), tmp___140);
#line 1408
                tmp___142 = 0;
                }
              }
              {
#line 1408
              cp = cpbufs[0].buf + cpbufs[0].bufsize;
#line 1408
              memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)prev___9,
                     cpbufs[0].bufsize);
#line 1408
              cpbufs[0].bufsize *= 2UL;
              }
#line 1408
              if ((unsigned long )prev___9 != (unsigned long )(cpbufs[0].stackbuf)) {
                {
#line 1408
                free((void *)prev___9);
                }
              }
#line 1408
              cend = cpbufs[0].buf + cpbufs[0].bufsize;
            }
#line 1408
            cp --;
#line 1408
            *cp = (char )'0';
#line 1408
            goto while_break___20;
          }
          while_break___20: /* CIL Label */ ;
          }
        }
      }
    }
#line 1410
    base = 0;
#line 1411
    if (prec > fw) {
#line 1412
      fw = prec;
    }
#line 1413
    prec = cend - cp;
    pr_tail: 
#line 1415
    if (! lj) {
      {
#line 1416
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 1416
        if (! (fw > prec)) {
#line 1416
          goto while_break___21;
        }
#line 1417
        if (ofre < 1UL) {
          {
#line 1417
          olen___3 = (size_t )(obufout - obuf);
#line 1417
          tmp___143 = realloc((void *)obuf, osiz * 2UL);
#line 1417
          obuf = (char *)tmp___143;
          }
#line 1417
          if (obuf) {
#line 1417
            tmp___147 = 1;
          } else {
            {
#line 1417
            set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1417);
#line 1417
            tmp___144 = __errno_location();
#line 1417
            tmp___145 = strerror(*tmp___144);
#line 1417
            tmp___146 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1417
            r_fatal((char const   *)tmp___146, "format_tree", "obuf", (long )(osiz * 2UL),
                    tmp___145);
#line 1417
            tmp___147 = 0;
            }
          }
#line 1417
          ofre += osiz;
#line 1417
          osiz *= 2UL;
#line 1417
          obufout = obuf + olen___3;
        }
#line 1417
        tmp___148 = obufout;
#line 1417
        obufout ++;
#line 1417
        *tmp___148 = (char )*fill;
#line 1417
        ofre --;
#line 1418
        fw --;
      }
      while_break___21: /* CIL Label */ ;
      }
    }
#line 1421
    copy_count = (size_t )prec;
#line 1422
    if (fw == 0L) {
#line 1422
      if (! (! have_prec)) {
#line 1422
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 1424
    if (gawk_mb_cur_max > 1) {
#line 1424
      if (cs1 == 115) {
        {
#line 1426
        copy_count = mbc_byte_count((char const   *)arg->sub.val.sp, (size_t )prec);
        }
      } else
#line 1424
      if (cs1 == 99) {
        {
#line 1426
        copy_count = mbc_byte_count((char const   *)arg->sub.val.sp, (size_t )prec);
        }
      }
    }
#line 1428
    if (copy_count) {
      {
#line 1428
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 1428
        if (! (copy_count > ofre)) {
#line 1428
          goto while_break___22;
        }
        {
#line 1428
        olen___4 = (size_t )(obufout - obuf);
#line 1428
        tmp___149 = realloc((void *)obuf, osiz * 2UL);
#line 1428
        obuf = (char *)tmp___149;
        }
#line 1428
        if (obuf) {
#line 1428
          tmp___153 = 1;
        } else {
          {
#line 1428
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1428);
#line 1428
          tmp___150 = __errno_location();
#line 1428
          tmp___151 = strerror(*tmp___150);
#line 1428
          tmp___152 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1428
          r_fatal((char const   *)tmp___152, "format_tree", "obuf", (long )(osiz * 2UL),
                  tmp___151);
#line 1428
          tmp___153 = 0;
          }
        }
#line 1428
        ofre += osiz;
#line 1428
        osiz *= 2UL;
#line 1428
        obufout = obuf + olen___4;
      }
      while_break___22: /* CIL Label */ ;
      }
      {
#line 1428
      memcpy((void */* __restrict  */)obufout, (void const   */* __restrict  */)cp,
             copy_count);
#line 1428
      obufout += copy_count;
#line 1428
      ofre -= copy_count;
      }
    }
    {
#line 1429
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 1429
      if (! (fw > prec)) {
#line 1429
        goto while_break___23;
      }
#line 1430
      if (ofre < 1UL) {
        {
#line 1430
        olen___5 = (size_t )(obufout - obuf);
#line 1430
        tmp___154 = realloc((void *)obuf, osiz * 2UL);
#line 1430
        obuf = (char *)tmp___154;
        }
#line 1430
        if (obuf) {
#line 1430
          tmp___158 = 1;
        } else {
          {
#line 1430
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1430);
#line 1430
          tmp___155 = __errno_location();
#line 1430
          tmp___156 = strerror(*tmp___155);
#line 1430
          tmp___157 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1430
          r_fatal((char const   *)tmp___157, "format_tree", "obuf", (long )(osiz * 2UL),
                  tmp___156);
#line 1430
          tmp___158 = 0;
          }
        }
#line 1430
        ofre += osiz;
#line 1430
        osiz *= 2UL;
#line 1430
        obufout = obuf + olen___5;
      }
#line 1430
      tmp___159 = obufout;
#line 1430
      obufout ++;
#line 1430
      *tmp___159 = (char )*fill;
#line 1430
      ofre --;
#line 1431
      fw --;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 1433
    s0 = s1;
#line 1434
    goto switch_break;
    out_of_range: 
#line 1438
    if (do_flags & 3) {
      {
#line 1439
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1439);
#line 1439
      tmp___160 = gettext("[s]printf: value %g is out of range for `%%%c\' format");
#line 1439
      (*lintfunc)((char const   *)tmp___160, tmpval, cs1);
      }
    }
#line 1441
    cs1 = 'g';
#line 1442
    goto fmt1;
    case_69: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_70: /* CIL Label */ 
#line 1454
    need_format = (_Bool)0;
#line 1455
    if (argnum > 0L) {
#line 1455
      if (cur_arg > 1UL) {
        {
#line 1455
        tmp___161 = gettext("fatal: must use `count$\' on all formats or none");
#line 1455
        msg((char const   *)tmp___161);
        }
#line 1455
        goto out;
      }
#line 1455
      arg = *(the_args + argnum);
    } else
#line 1455
    if (used_dollar) {
      {
#line 1455
      tmp___162 = gettext("fatal: must use `count$\' on all formats or none");
#line 1455
      msg((char const   *)tmp___162);
#line 1455
      arg = (NODE *)0;
      }
#line 1455
      goto out;
    } else
#line 1455
    if (cur_arg >= (size_t )num_args) {
#line 1455
      arg = (NODE *)0;
#line 1455
      toofew = (_Bool)1;
#line 1455
      goto switch_break;
    } else {
#line 1455
      arg = *(the_args + cur_arg);
#line 1455
      cur_arg ++;
    }
    {
#line 1456
    force_number(arg);
    }
#line 1458
    if (! ((arg->flags & 6144U) != 0U)) {
#line 1459
      tmpval = arg->sub.val.nm.fltnum;
    } else
#line 1461
    if ((arg->flags & 2048U) != 0U) {
#line 1462
      mf = arg->sub.val.nm.mpnum;
#line 1463
      fmt_type = (enum __anonenum_fmt_type_89 )3;
    } else {
      {
#line 1467
      mf = mpz2mpfr(arg->sub.val.nm.mpi);
#line 1468
      fmt_type = (enum __anonenum_fmt_type_89 )3;
      }
    }
    fmt1: 
#line 1472
    if (! have_prec) {
#line 1473
      prec = 6L;
    }
    fmt0: 
#line 1477
    if ((size_t )((fw + prec) + 11L) >= ofre) {
      {
#line 1477
      olen___6 = (size_t )(obufout - obuf);
#line 1477
      delta = (((osiz + (size_t )fw) + (size_t )prec) + 11UL) - ofre;
#line 1477
      tmp___163 = realloc((void *)obuf, osiz + delta);
#line 1477
      obuf = (char *)tmp___163;
      }
#line 1477
      if (obuf) {
#line 1477
        tmp___167 = 1;
      } else {
        {
#line 1477
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1477);
#line 1477
        tmp___164 = __errno_location();
#line 1477
        tmp___165 = strerror(*tmp___164);
#line 1477
        tmp___166 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1477
        r_fatal((char const   *)tmp___166, "format_tree", "obuf", (long )(osiz + delta),
                tmp___165);
#line 1477
        tmp___167 = 0;
        }
      }
#line 1477
      obufout = obuf + olen___6;
#line 1477
      ofre += delta;
#line 1477
      osiz += delta;
    }
#line 1478
    cp = cpbufs[0].buf;
#line 1479
    tmp___168 = cp;
#line 1479
    cp ++;
#line 1479
    *tmp___168 = (char )'%';
#line 1480
    if (lj) {
#line 1481
      tmp___169 = cp;
#line 1481
      cp ++;
#line 1481
      *tmp___169 = (char )'-';
    }
#line 1482
    if (signchar) {
#line 1483
      tmp___170 = cp;
#line 1483
      cp ++;
#line 1483
      *tmp___170 = signchar;
    }
#line 1484
    if (alt) {
#line 1485
      tmp___171 = cp;
#line 1485
      cp ++;
#line 1485
      *tmp___171 = (char )'#';
    }
#line 1486
    if (zero_flag) {
#line 1487
      tmp___172 = cp;
#line 1487
      cp ++;
#line 1487
      *tmp___172 = (char )'0';
    }
#line 1488
    if (quote_flag) {
#line 1489
      tmp___173 = cp;
#line 1489
      cp ++;
#line 1489
      *tmp___173 = (char )'\'';
    }
#line 1492
    if (quote_flag) {
#line 1492
      if (! use_lc_numeric) {
        {
#line 1493
        setlocale(1, "");
        }
      }
    }
    {
#line 1498
    if ((unsigned int )fmt_type == 1U) {
#line 1498
      goto case_1;
    }
#line 1504
    if ((unsigned int )fmt_type == 2U) {
#line 1504
      goto case_2;
    }
#line 1510
    if ((unsigned int )fmt_type == 3U) {
#line 1510
      goto case_3;
    }
#line 1517
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1499
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"*.*Z%c",
            cs1);
    }
    {
#line 1500
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 1500
      nc = mpfr_snprintf(obufout, ofre, (char const   *)cpbufs[0].buf, (int )fw, (int )prec,
                         zi);
      }
#line 1500
      if (! ((size_t )nc >= ofre)) {
#line 1500
        goto while_break___24;
      }
#line 1502
      if ((size_t )nc >= ofre) {
        {
#line 1502
        olen___7 = (size_t )(obufout - obuf);
#line 1502
        delta___0 = (osiz + (size_t )nc) - ofre;
#line 1502
        tmp___174 = realloc((void *)obuf, osiz + delta___0);
#line 1502
        obuf = (char *)tmp___174;
        }
#line 1502
        if (obuf) {
#line 1502
          tmp___178 = 1;
        } else {
          {
#line 1502
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1502);
#line 1502
          tmp___175 = __errno_location();
#line 1502
          tmp___176 = strerror(*tmp___175);
#line 1502
          tmp___177 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1502
          r_fatal((char const   *)tmp___177, "format_tree", "obuf", (long )(osiz + delta___0),
                  tmp___176);
#line 1502
          tmp___178 = 0;
          }
        }
#line 1502
        obufout = obuf + olen___7;
#line 1502
        ofre += delta___0;
#line 1502
        osiz += delta___0;
      }
    }
    while_break___24: /* CIL Label */ ;
    }
#line 1503
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 1505
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"*Z%c",
            cs1);
    }
    {
#line 1506
    while (1) {
      while_continue___25: /* CIL Label */ ;
      {
#line 1506
      nc = mpfr_snprintf(obufout, ofre, (char const   *)cpbufs[0].buf, (int )fw, zi);
      }
#line 1506
      if (! ((size_t )nc >= ofre)) {
#line 1506
        goto while_break___25;
      }
#line 1508
      if ((size_t )nc >= ofre) {
        {
#line 1508
        olen___8 = (size_t )(obufout - obuf);
#line 1508
        delta___1 = (osiz + (size_t )nc) - ofre;
#line 1508
        tmp___179 = realloc((void *)obuf, osiz + delta___1);
#line 1508
        obuf = (char *)tmp___179;
        }
#line 1508
        if (obuf) {
#line 1508
          tmp___183 = 1;
        } else {
          {
#line 1508
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1508);
#line 1508
          tmp___180 = __errno_location();
#line 1508
          tmp___181 = strerror(*tmp___180);
#line 1508
          tmp___182 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1508
          r_fatal((char const   *)tmp___182, "format_tree", "obuf", (long )(osiz + delta___1),
                  tmp___181);
#line 1508
          tmp___183 = 0;
          }
        }
#line 1508
        obufout = obuf + olen___8;
#line 1508
        ofre += delta___1;
#line 1508
        osiz += delta___1;
      }
    }
    while_break___25: /* CIL Label */ ;
    }
#line 1509
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 1511
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"*.*R*%c",
            cs1);
    }
    {
#line 1512
    while (1) {
      while_continue___26: /* CIL Label */ ;
      {
#line 1512
      nc = mpfr_snprintf(obufout, ofre, (char const   *)cpbufs[0].buf, (int )fw, (int )prec,
                         (int )ROUND_MODE, mf);
      }
#line 1512
      if (! ((size_t )nc >= ofre)) {
#line 1512
        goto while_break___26;
      }
#line 1514
      if ((size_t )nc >= ofre) {
        {
#line 1514
        olen___9 = (size_t )(obufout - obuf);
#line 1514
        delta___2 = (osiz + (size_t )nc) - ofre;
#line 1514
        tmp___184 = realloc((void *)obuf, osiz + delta___2);
#line 1514
        obuf = (char *)tmp___184;
        }
#line 1514
        if (obuf) {
#line 1514
          tmp___188 = 1;
        } else {
          {
#line 1514
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1514);
#line 1514
          tmp___185 = __errno_location();
#line 1514
          tmp___186 = strerror(*tmp___185);
#line 1514
          tmp___187 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1514
          r_fatal((char const   *)tmp___187, "format_tree", "obuf", (long )(osiz + delta___2),
                  tmp___186);
#line 1514
          tmp___188 = 0;
          }
        }
#line 1514
        obufout = obuf + olen___9;
#line 1514
        ofre += delta___2;
#line 1514
        osiz += delta___2;
      }
    }
    while_break___26: /* CIL Label */ ;
    }
#line 1515
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1518
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"*.*%c",
            cs1);
    }
    {
#line 1519
    while (1) {
      while_continue___27: /* CIL Label */ ;
      {
#line 1519
      nc = snprintf((char */* __restrict  */)obufout, ofre, (char const   */* __restrict  */)cpbufs[0].buf,
                    (int )fw, (int )prec, tmpval);
      }
#line 1519
      if (! ((size_t )nc >= ofre)) {
#line 1519
        goto while_break___27;
      }
#line 1522
      if ((size_t )nc >= ofre) {
        {
#line 1522
        olen___10 = (size_t )(obufout - obuf);
#line 1522
        delta___3 = (osiz + (size_t )nc) - ofre;
#line 1522
        tmp___189 = realloc((void *)obuf, osiz + delta___3);
#line 1522
        obuf = (char *)tmp___189;
        }
#line 1522
        if (obuf) {
#line 1522
          tmp___193 = 1;
        } else {
          {
#line 1522
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1522);
#line 1522
          tmp___190 = __errno_location();
#line 1522
          tmp___191 = strerror(*tmp___190);
#line 1522
          tmp___192 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1522
          r_fatal((char const   *)tmp___192, "format_tree", "obuf", (long )(osiz + delta___3),
                  tmp___191);
#line 1522
          tmp___193 = 0;
          }
        }
#line 1522
        obufout = obuf + olen___10;
#line 1522
        ofre += delta___3;
#line 1522
        osiz += delta___3;
      }
    }
    while_break___27: /* CIL Label */ ;
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1526
    if (quote_flag) {
#line 1526
      if (! use_lc_numeric) {
        {
#line 1527
        setlocale(1, "C");
        }
      }
    }
    {
#line 1530
    len = strlen((char const   *)obufout);
#line 1531
    ofre -= len;
#line 1532
    obufout += len;
#line 1533
    s0 = s1;
    }
#line 1534
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 1536
    if (do_flags & 3) {
      {
#line 1536
      tmp___195 = __ctype_b_loc();
      }
#line 1536
      if ((int const   )*(*tmp___195 + cs1) & 1024) {
        {
#line 1537
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1537);
#line 1537
        tmp___194 = gettext("ignoring unknown format specifier character `%c\': no argument converted");
#line 1537
        (*lintfunc)((char const   *)tmp___194, cs1);
        }
      }
    }
#line 1538
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1540
    if (toofew) {
      {
#line 1541
      tmp___196 = gettext("^ ran out for this one");
#line 1541
      tmp___197 = gettext("fatal: not enough arguments to satisfy format string");
#line 1541
      msg("%s\n\t`%s\'\n\t%*s%s", tmp___197, fmt_string, (int )((s1 - fmt_string) - 1L),
          "", tmp___196);
      }
#line 1545
      goto out;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1548
  if (do_flags & 3) {
#line 1549
    if (need_format) {
      {
#line 1550
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1550);
#line 1550
      tmp___199 = gettext("[s]printf: format specifier does not have control letter");
#line 1550
      (*lintfunc)((char const   *)tmp___199);
      }
    }
#line 1552
    if (cur_arg < (size_t )num_args) {
      {
#line 1553
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1553);
#line 1553
      tmp___200 = gettext("too many arguments supplied for format string");
#line 1553
      (*lintfunc)((char const   *)tmp___200);
      }
    }
  }
#line 1556
  if (s1 - s0) {
    {
#line 1556
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1556
      if (! ((size_t )(s1 - s0) > ofre)) {
#line 1556
        goto while_break___28;
      }
      {
#line 1556
      olen___11 = (size_t )(obufout - obuf);
#line 1556
      tmp___201 = realloc((void *)obuf, osiz * 2UL);
#line 1556
      obuf = (char *)tmp___201;
      }
#line 1556
      if (obuf) {
#line 1556
        tmp___205 = 1;
      } else {
        {
#line 1556
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1556);
#line 1556
        tmp___202 = __errno_location();
#line 1556
        tmp___203 = strerror(*tmp___202);
#line 1556
        tmp___204 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1556
        r_fatal((char const   *)tmp___204, "format_tree", "obuf", (long )(osiz * 2UL),
                tmp___203);
#line 1556
        tmp___205 = 0;
        }
      }
#line 1556
      ofre += osiz;
#line 1556
      osiz *= 2UL;
#line 1556
      obufout = obuf + olen___11;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 1556
    memcpy((void */* __restrict  */)obufout, (void const   */* __restrict  */)s0,
           (size_t )(s1 - s0));
#line 1556
    obufout += s1 - s0;
#line 1556
    ofre -= (size_t )(s1 - s0);
    }
  }
  {
#line 1557
  r = make_str_node((char const   *)obuf, (size_t )(obufout - obuf), 2);
#line 1558
  obuf = (char *)((void *)0);
  }
  out: 
#line 1562
  count___1 = sizeof(cpbufs) / sizeof(cpbufs[0]);
#line 1563
  k___0 = (size_t )0;
  {
#line 1563
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 1563
    if (! (k___0 < count___1)) {
#line 1563
      goto while_break___29;
    }
#line 1564
    if ((unsigned long )cpbufs[k___0].buf != (unsigned long )(cpbufs[k___0].stackbuf)) {
      {
#line 1565
      free((void *)cpbufs[k___0].buf);
      }
    }
#line 1563
    k___0 ++;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 1567
  if ((unsigned long )obuf != (unsigned long )((void *)0)) {
    {
#line 1568
    free((void *)obuf);
    }
  }
#line 1571
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 1572
    gawk_exit(2);
    }
  }
#line 1573
  return (r);
}
}
#line 1579 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static NODE *printf_common(int nargs ) 
{ 
  int i___0 ;
  NODE *r ;
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  STACK_ITEM *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1586
  i___0 = 1;
  {
#line 1586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1586
    if (! (i___0 <= nargs)) {
#line 1586
      goto while_break;
    }
#line 1587
    tmp___3 = stack_ptr;
#line 1587
    stack_ptr --;
#line 1587
    tmp___2 = tmp___3->rptr;
#line 1587
    *(args_array + (nargs - i___0)) = tmp___2;
#line 1587
    tmp___1 = tmp___2;
#line 1588
    if ((unsigned int )tmp___1->type == 5U) {
      {
#line 1589
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1589
        i___0 --;
#line 1589
        if (! (i___0 > 0)) {
#line 1589
          goto while_break___0;
        }
        {
#line 1590
        DEREF(*(args_array + (nargs - i___0)));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1591
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1591);
#line 1591
      tmp___4 = array_vname((NODE const   *)tmp___1);
#line 1591
      tmp___5 = gettext("attempt to use array `%s\' in a scalar context");
#line 1591
      r_fatal((char const   *)tmp___5, tmp___4);
      }
    }
#line 1586
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1595
  *(args_array + 0) = force_string(*(args_array + 0));
#line 1596
  r = format_tree((char const   *)(*(args_array + 0))->sub.val.sp, (*(args_array + 0))->sub.val.slen,
                  args_array, (long )nargs);
#line 1597
  i___0 = 0;
  }
  {
#line 1597
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1597
    if (! (i___0 < nargs)) {
#line 1597
      goto while_break___1;
    }
    {
#line 1598
    DEREF(*(args_array + i___0));
#line 1597
    i___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1599
  return (r);
}
}
#line 1604 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_sprintf(int nargs ) 
{ 
  NODE *r ;
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1609
  if (nargs == 0) {
    {
#line 1610
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1610);
#line 1610
    tmp___1 = gettext("sprintf: no arguments");
#line 1610
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 1612
  r = printf_common(nargs);
  }
#line 1613
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 1614
    gawk_exit(2);
    }
  }
#line 1615
  return (r);
}
}
#line 1621 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
void do_printf(int nargs , int redirtype ) 
{ 
  FILE *fp___0 ;
  NODE *tmp___1 ;
  struct redirect *rp ;
  int errflg ;
  NODE *redir_exp ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 1624
  fp___0 = (FILE *)((void *)0);
#line 1626
  rp = (struct redirect *)((void *)0);
#line 1628
  redir_exp = (NODE *)((void *)0);
#line 1630
  if (nargs == 0) {
#line 1631
    if (do_flags & 8) {
#line 1632
      if (do_flags & 3) {
        {
#line 1633
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1633);
#line 1633
        tmp___2 = gettext("printf: no arguments");
#line 1633
        (*lintfunc)((char const   *)tmp___2);
        }
      }
#line 1634
      if (redirtype != 0) {
#line 1635
        redir_exp = stack_ptr->rptr;
#line 1636
        if ((unsigned int )redir_exp->type != 1U) {
          {
#line 1637
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1637);
#line 1637
          tmp___3 = array_vname((NODE const   *)redir_exp);
#line 1637
          tmp___4 = gettext("attempt to use array `%s\' in a scalar context");
#line 1637
          r_fatal((char const   *)tmp___4, tmp___3);
          }
        }
        {
#line 1638
        rp = redirect(redir_exp, redirtype, & errflg);
#line 1639
        DEREF(redir_exp);
#line 1640
        stack_ptr --;
        }
      }
#line 1642
      return;
    }
    {
#line 1644
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1644);
#line 1644
    tmp___5 = gettext("printf: no arguments");
#line 1644
    r_fatal((char const   *)tmp___5);
    }
  }
#line 1647
  if (redirtype != 0) {
#line 1648
    redir_exp = (stack_ptr - nargs)->rptr;
#line 1649
    if ((unsigned int )redir_exp->type != 1U) {
      {
#line 1650
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1650);
#line 1650
      tmp___6 = array_vname((NODE const   *)redir_exp);
#line 1650
      tmp___7 = gettext("attempt to use array `%s\' in a scalar context");
#line 1650
      r_fatal((char const   *)tmp___7, tmp___6);
      }
    }
    {
#line 1651
    rp = redirect(redir_exp, redirtype, & errflg);
    }
#line 1652
    if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 1653
      fp___0 = rp->output.fp;
    }
  } else
#line 1654
  if (do_flags & 8192) {
#line 1655
    fp___0 = output_fp;
  } else {
#line 1657
    fp___0 = stdout;
  }
  {
#line 1659
  tmp___1 = printf_common(nargs);
  }
#line 1660
  if ((unsigned long )redir_exp != (unsigned long )((void *)0)) {
    {
#line 1661
    DEREF(redir_exp);
#line 1662
    stack_ptr --;
    }
  }
#line 1664
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1665
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      {
#line 1666
      DEREF(tmp___1);
      }
#line 1667
      return;
    }
    {
#line 1669
    efwrite((void const   *)tmp___1->sub.val.sp, sizeof(char ), tmp___1->sub.val.slen,
            fp___0, "printf", rp, (_Bool)1);
    }
#line 1670
    if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 1670
      if ((rp->flag & 256U) != 0U) {
        {
#line 1671
        (*(rp->output.gawk_fflush))(rp->output.fp, rp->output.opaque);
        }
      }
    }
    {
#line 1672
    DEREF(tmp___1);
    }
  } else {
    {
#line 1674
    gawk_exit(2);
    }
  }
#line 1675
  return;
}
}
#line 1679 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_sqrt(int nargs ) 
{ 
  NODE *tmp___1 ;
  double arg ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  char *tmp___4 ;
  double tmp___5 ;
  NODE *tmp___6 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1685
  tmp___1 = POP_SCALAR();
  }
#line 1686
  if (do_flags & 3) {
#line 1686
    if ((tmp___1->flags & 24U) == 0U) {
      {
#line 1687
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1687);
#line 1687
      tmp___2 = gettext("sqrt: received non-numeric argument");
#line 1687
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 1688
  tmp___3 = force_number(tmp___1);
#line 1688
  arg = tmp___3->sub.val.nm.fltnum;
#line 1689
  DEREF(tmp___1);
  }
#line 1690
  if (arg < 0.0) {
    {
#line 1691
    tmp___4 = gettext("sqrt: called with negative argument %g");
#line 1691
    warning((char const   *)tmp___4, arg);
    }
  }
  {
#line 1692
  tmp___5 = sqrt(arg);
#line 1692
  tmp___6 = (*make_number)(tmp___5);
  }
#line 1692
  return (tmp___6);
}
}
#line 1697 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_substr(int nargs ) 
{ 
  NODE *t1 ;
  NODE *r ;
  size_t indx ;
  size_t length ;
  double d_index ;
  double d_length ;
  size_t src_len ;
  NODE *tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  NODE *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  NODE *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  NODE *tmp___12 ;
  char *tmp___13 ;
  double tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  double tmp___18 ;
  char *tmp___19 ;
  NODE *tmp___20 ;
  char *tmp___21 ;
  NODE *tmp___22 ;
  char *tmp___23 ;
  size_t result ;
  wchar_t *wp ;
  mbstate_t mbs___0 ;
  char *substr ;
  char *cp ;
  void *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;

  {
#line 1703
  length = (size_t )0;
#line 1704
  d_index = (double )0;
#line 1704
  d_length = (double )0;
#line 1707
  if (nargs == 3) {
    {
#line 1708
    tmp___1 = POP_SCALAR();
#line 1708
    t1 = force_number(tmp___1);
    }
#line 1709
    if (t1->flags & 2048U) {
      {
#line 1709
      tmp___2 = mpfr_get_d((mpfr_srcptr )(t1->sub.val.nm.mpnum), ROUND_MODE);
#line 1709
      d_length = tmp___2;
      }
    } else {
#line 1709
      if (t1->flags & 4096U) {
        {
#line 1709
        tmp___3 = __gmpz_get_d((mpz_srcptr )(t1->sub.val.nm.mpi));
#line 1709
        tmp___4 = tmp___3;
        }
      } else {
#line 1709
        tmp___4 = t1->sub.val.nm.fltnum;
      }
#line 1709
      d_length = tmp___4;
    }
    {
#line 1710
    DEREF(t1);
    }
  }
  {
#line 1713
  tmp___5 = POP_SCALAR();
#line 1713
  t1 = force_number(tmp___5);
  }
#line 1714
  if (t1->flags & 2048U) {
    {
#line 1714
    tmp___6 = mpfr_get_d((mpfr_srcptr )(t1->sub.val.nm.mpnum), ROUND_MODE);
#line 1714
    d_index = tmp___6;
    }
  } else {
#line 1714
    if (t1->flags & 4096U) {
      {
#line 1714
      tmp___7 = __gmpz_get_d((mpz_srcptr )(t1->sub.val.nm.mpi));
#line 1714
      tmp___8 = tmp___7;
      }
    } else {
#line 1714
      tmp___8 = t1->sub.val.nm.fltnum;
    }
#line 1714
    d_index = tmp___8;
  }
  {
#line 1715
  DEREF(t1);
#line 1717
  tmp___9 = POP_SCALAR();
#line 1717
  t1 = force_string(tmp___9);
  }
#line 1719
  if (nargs == 3) {
#line 1720
    if (! (d_length >= (double )1)) {
#line 1721
      if ((do_flags & 3) == 2) {
        {
#line 1722
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1722);
#line 1722
        tmp___10 = gettext("substr: length %g is not >= 1");
#line 1722
        (*lintfunc)((char const   *)tmp___10, d_length);
        }
      } else
#line 1723
      if ((do_flags & 3) == 1) {
#line 1723
        if (! (d_length >= (double )0)) {
          {
#line 1724
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1724);
#line 1724
          tmp___11 = gettext("substr: length %g is not >= 0");
#line 1724
          (*lintfunc)((char const   *)tmp___11, d_length);
          }
        }
      }
      {
#line 1725
      DEREF(t1);
#line 1726
      tmp___12 = dupnode(Nnull_string);
      }
#line 1726
      return (tmp___12);
    }
#line 1728
    if (do_flags & 3) {
      {
#line 1729
      tmp___14 = double_to_int(d_length);
      }
#line 1729
      if (tmp___14 != d_length) {
        {
#line 1730
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1730);
#line 1730
        tmp___13 = gettext("substr: non-integer length %g will be truncated");
#line 1730
        (*lintfunc)((char const   *)tmp___13, d_length);
        }
      }
#line 1734
      if (d_length > (double )0xffffffffffffffffUL) {
        {
#line 1735
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1735);
#line 1735
        tmp___15 = gettext("substr: length %g too big for string indexing, truncating to %g");
#line 1735
        (*lintfunc)((char const   *)tmp___15, d_length, (double )0xffffffffffffffffUL);
        }
      }
    }
#line 1739
    if (d_length < (double )0xffffffffffffffffUL) {
#line 1740
      length = (size_t )d_length;
    } else {
#line 1742
      length = 0xffffffffffffffffUL;
    }
  }
#line 1746
  if (! (d_index >= (double )1)) {
#line 1747
    if (do_flags & 3) {
      {
#line 1748
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1748);
#line 1748
      tmp___16 = gettext("substr: start index %g is invalid, using 1");
#line 1748
      (*lintfunc)((char const   *)tmp___16, d_index);
      }
    }
#line 1750
    d_index = (double )1;
  }
#line 1752
  if (do_flags & 3) {
    {
#line 1752
    tmp___18 = double_to_int(d_index);
    }
#line 1752
    if (tmp___18 != d_index) {
      {
#line 1753
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1753);
#line 1753
      tmp___17 = gettext("substr: non-integer start index %g will be truncated");
#line 1753
      (*lintfunc)((char const   *)tmp___17, d_index);
      }
    }
  }
#line 1757
  if (d_index <= (double )0xffffffffffffffffUL) {
#line 1758
    indx = (size_t )(d_index - (double )1);
  } else {
#line 1760
    indx = 0xffffffffffffffffUL;
  }
#line 1762
  if (nargs == 2) {
#line 1764
    length = t1->sub.val.slen - indx;
#line 1766
    if (gawk_mb_cur_max > 1) {
      {
#line 1767
      t1 = str2wstr(t1, (size_t **)((void *)0));
      }
#line 1768
      if (t1->sub.val.wslen > 0UL) {
#line 1769
        length = t1->sub.val.wslen - indx;
      }
    }
#line 1772
    d_length = (double )length;
  }
#line 1775
  if (t1->sub.val.slen == 0UL) {
#line 1777
    if (do_flags & 3) {
#line 1777
      if ((do_flags & 3) == 2) {
        {
#line 1778
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1778);
#line 1778
        tmp___19 = gettext("substr: source string is zero length");
#line 1778
        (*lintfunc)((char const   *)tmp___19);
        }
      } else
#line 1777
      if ((indx | length) != 0UL) {
        {
#line 1778
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1778);
#line 1778
        tmp___19 = gettext("substr: source string is zero length");
#line 1778
        (*lintfunc)((char const   *)tmp___19);
        }
      }
    }
    {
#line 1779
    DEREF(t1);
#line 1780
    tmp___20 = dupnode(Nnull_string);
    }
#line 1780
    return (tmp___20);
  }
#line 1785
  if (gawk_mb_cur_max > 1) {
    {
#line 1786
    t1 = str2wstr(t1, (size_t **)((void *)0));
#line 1787
    src_len = t1->sub.val.wslen;
    }
  } else {
#line 1790
    src_len = t1->sub.val.slen;
  }
#line 1792
  if (indx >= src_len) {
#line 1793
    if (do_flags & 3) {
      {
#line 1794
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1794);
#line 1794
      tmp___21 = gettext("substr: start index %g is past end of string");
#line 1794
      (*lintfunc)((char const   *)tmp___21, d_index);
      }
    }
    {
#line 1796
    DEREF(t1);
#line 1797
    tmp___22 = dupnode(Nnull_string);
    }
#line 1797
    return (tmp___22);
  }
#line 1799
  if (length > src_len - indx) {
#line 1800
    if (do_flags & 3) {
      {
#line 1801
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1801);
#line 1801
      tmp___23 = gettext("substr: length %g at start index %g exceeds length of first argument (%lu)");
#line 1801
      (*lintfunc)((char const   *)tmp___23, d_length, d_index, src_len);
      }
    }
#line 1804
    length = src_len - indx;
  }
#line 1809
  if (gawk_mb_cur_max == 1) {
    {
#line 1811
    r = make_str_node((char const   *)(t1->sub.val.sp + indx), length, 0);
    }
  } else
#line 1809
  if (t1->sub.val.wslen == t1->sub.val.slen) {
    {
#line 1811
    r = make_str_node((char const   *)(t1->sub.val.sp + indx), length, 0);
    }
  } else {
    {
#line 1824
    memset((void *)(& mbs___0), 0, sizeof(mbs___0));
#line 1825
    tmp___24 = malloc(length * (size_t )gawk_mb_cur_max + 2UL);
#line 1825
    substr = (char *)tmp___24;
    }
#line 1825
    if (substr) {
#line 1825
      tmp___28 = 1;
    } else {
      {
#line 1825
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1825);
#line 1825
      tmp___25 = __errno_location();
#line 1825
      tmp___26 = strerror(*tmp___25);
#line 1825
      tmp___27 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1825
      r_fatal((char const   *)tmp___27, "do_substr", "substr", (long )(length * (size_t )gawk_mb_cur_max + 2UL),
              tmp___26);
#line 1825
      tmp___28 = 0;
      }
    }
#line 1826
    wp = t1->sub.val.wsp + indx;
#line 1827
    cp = substr;
    {
#line 1827
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1827
      if (! (length > 0UL)) {
#line 1827
        goto while_break;
      }
      {
#line 1828
      result = wcrtomb((char */* __restrict  */)cp, *wp, (mbstate_t */* __restrict  */)(& mbs___0));
      }
#line 1829
      if (result == 0xffffffffffffffffUL) {
#line 1830
        goto while_break;
      }
#line 1831
      cp += result;
#line 1832
      wp ++;
#line 1827
      length --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1834
    *cp = (char )'\000';
#line 1835
    r = make_str_node((char const   *)substr, (size_t )(cp - substr), 2);
    }
  }
  {
#line 1841
  DEREF(t1);
  }
#line 1842
  return (r);
}
}
#line 1847 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_strftime(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  NODE *t3 ;
  NODE *ret ;
  struct tm *tm ;
  time_t fclock ;
  long clock_val ;
  char *bufp ;
  size_t buflen___2 ;
  size_t bufsize ;
  char buf___7[8192] ;
  char const   *format ;
  int formatlen ;
  int do_gmt ;
  NODE *val ;
  NODE *sub ;
  size_t tmp___1 ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  char *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  NODE *tmp___11 ;
  void *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
  {
#line 1860
  val = (NODE *)((void *)0);
#line 1861
  sub = (NODE *)((void *)0);
#line 1864
  format = def_strftime_format;
#line 1865
  tmp___1 = strlen(format);
#line 1865
  formatlen = (int )tmp___1;
#line 1866
  time(& fclock);
#line 1867
  do_gmt = 0;
  }
#line 1869
  if ((unsigned long )PROCINFO_node != (unsigned long )((void *)0)) {
    {
#line 1870
    sub = make_str_node("strftime", (size_t )8, 0);
#line 1871
    val = in_array(PROCINFO_node, sub);
#line 1872
    unref(sub);
    }
#line 1874
    if ((unsigned long )val != (unsigned long )((void *)0)) {
#line 1875
      if (do_flags & 3) {
#line 1875
        if ((val->flags & 2U) == 0U) {
          {
#line 1876
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1876);
#line 1876
          tmp___2 = gettext("strftime: format value in PROCINFO[\"strftime\"] has numeric type");
#line 1876
          (*lintfunc)((char const   *)tmp___2);
          }
        }
      }
      {
#line 1877
      val = force_string(val);
#line 1878
      format = (char const   *)val->sub.val.sp;
#line 1879
      formatlen = (int )val->sub.val.slen;
      }
    }
  }
#line 1883
  t3 = (NODE *)((void *)0);
#line 1883
  t2 = t3;
#line 1883
  t1 = t2;
#line 1884
  if (nargs > 0) {
#line 1887
    if (nargs == 3) {
      {
#line 1888
      t3 = POP_SCALAR();
      }
#line 1889
      if ((t3->flags & 24U) != 0U) {
#line 1890
        do_gmt = t3->sub.val.nm.fltnum != (double )0;
      } else {
#line 1892
        do_gmt = t3->sub.val.slen > 0UL;
      }
      {
#line 1893
      DEREF(t3);
      }
    }
#line 1896
    if (nargs >= 2) {
      {
#line 1897
      t2 = POP_SCALAR();
      }
#line 1898
      if (do_flags & 3) {
#line 1898
        if ((t2->flags & 24U) == 0U) {
          {
#line 1899
          set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1899);
#line 1899
          tmp___4 = gettext("strftime: received non-numeric second argument");
#line 1899
          (*lintfunc)((char const   *)tmp___4);
          }
        }
      }
      {
#line 1900
      force_number(t2);
      }
#line 1901
      if (t2->flags & 2048U) {
        {
#line 1901
        tmp___5 = mpfr_get_si((mpfr_srcptr )(t2->sub.val.nm.mpnum), ROUND_MODE);
#line 1901
        clock_val = tmp___5;
        }
      } else {
#line 1901
        if (t2->flags & 4096U) {
          {
#line 1901
          tmp___6 = __gmpz_get_si((mpz_srcptr )(t2->sub.val.nm.mpi));
#line 1901
          tmp___7 = tmp___6;
          }
        } else {
#line 1901
          tmp___7 = (long )t2->sub.val.nm.fltnum;
        }
#line 1901
        clock_val = tmp___7;
      }
#line 1902
      if (clock_val < 0L) {
        {
#line 1903
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1903);
#line 1903
        tmp___8 = gettext("strftime: second argument less than 0 or too big for time_t");
#line 1903
        r_fatal((char const   *)tmp___8);
        }
      }
      {
#line 1904
      fclock = clock_val;
#line 1905
      DEREF(t2);
      }
    }
    {
#line 1908
    tmp___3 = POP_SCALAR();
    }
#line 1909
    if (do_flags & 3) {
#line 1909
      if ((tmp___3->flags & 6U) == 0U) {
        {
#line 1910
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1910);
#line 1910
        tmp___9 = gettext("strftime: received non-string first argument");
#line 1910
        (*lintfunc)((char const   *)tmp___9);
        }
      }
    }
    {
#line 1912
    t1 = force_string(tmp___3);
#line 1913
    format = (char const   *)t1->sub.val.sp;
#line 1914
    formatlen = (int )t1->sub.val.slen;
    }
#line 1915
    if (formatlen == 0) {
#line 1916
      if (do_flags & 3) {
        {
#line 1917
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1917);
#line 1917
        tmp___10 = gettext("strftime: received empty format string");
#line 1917
        (*lintfunc)((char const   *)tmp___10);
        }
      }
      {
#line 1918
      DEREF(t1);
#line 1919
      tmp___11 = make_str_node("", (size_t )0, 0);
      }
#line 1919
      return (tmp___11);
    }
  }
#line 1923
  if (do_gmt) {
    {
#line 1924
    tm = gmtime((time_t const   *)(& fclock));
    }
  } else {
    {
#line 1926
    tm = localtime((time_t const   *)(& fclock));
    }
  }
#line 1928
  bufp = buf___7;
#line 1929
  bufsize = sizeof(buf___7);
  {
#line 1930
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1931
    *bufp = (char )'\000';
#line 1932
    buflen___2 = strftime((char */* __restrict  */)bufp, bufsize, (char const   */* __restrict  */)format,
                          (struct tm  const  */* __restrict  */)tm);
    }
#line 1941
    if (buflen___2 > 0UL) {
#line 1942
      goto while_break;
    } else
#line 1941
    if (bufsize >= (size_t )(1024 * formatlen)) {
#line 1942
      goto while_break;
    }
#line 1943
    bufsize *= 2UL;
#line 1944
    if ((unsigned long )bufp == (unsigned long )(buf___7)) {
      {
#line 1945
      tmp___12 = malloc(bufsize);
#line 1945
      bufp = (char *)tmp___12;
      }
#line 1945
      if (bufp) {
#line 1945
        tmp___16 = 1;
      } else {
        {
#line 1945
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1945);
#line 1945
        tmp___13 = __errno_location();
#line 1945
        tmp___14 = strerror(*tmp___13);
#line 1945
        tmp___15 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1945
        r_fatal((char const   *)tmp___15, "do_strftime", "bufp", (long )bufsize, tmp___14);
#line 1945
        tmp___16 = 0;
        }
      }
    } else {
      {
#line 1947
      tmp___17 = realloc((void *)bufp, bufsize);
#line 1947
      bufp = (char *)tmp___17;
      }
#line 1947
      if (bufp) {
#line 1947
        tmp___21 = 1;
      } else {
        {
#line 1947
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1947);
#line 1947
        tmp___18 = __errno_location();
#line 1947
        tmp___19 = strerror(*tmp___18);
#line 1947
        tmp___20 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1947
        r_fatal((char const   *)tmp___20, "do_strftime", "bufp", (long )bufsize, tmp___19);
#line 1947
        tmp___21 = 0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1949
  ret = make_str_node((char const   *)bufp, buflen___2, 0);
  }
#line 1950
  if ((unsigned long )bufp != (unsigned long )(buf___7)) {
    {
#line 1951
    free((void *)bufp);
    }
  }
#line 1952
  if (t1) {
    {
#line 1953
    DEREF(t1);
    }
  }
#line 1954
  return (ret);
}
}
#line 1959 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_systime(int nargs  __attribute__((__unused__)) ) 
{ 
  time_t lclock ;
  NODE *tmp___1 ;

  {
  {
#line 1964
  time(& lclock);
#line 1965
  tmp___1 = (*make_number)((double )lclock);
  }
#line 1965
  return (tmp___1);
}
}
#line 1970 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_mktime(int nargs ) 
{ 
  NODE *t1 ;
  struct tm then ;
  long year ;
  int month ;
  int day ;
  int hour ;
  int minute ;
  int second ;
  int count ;
  int dst ;
  time_t then_stamp ;
  char save ;
  char *tmp___1 ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 1977
  dst = -1;
#line 1981
  t1 = POP_SCALAR();
  }
#line 1982
  if (do_flags & 3) {
#line 1982
    if ((t1->flags & 6U) == 0U) {
      {
#line 1983
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 1983);
#line 1983
      tmp___1 = gettext("mktime: received non-string argument");
#line 1983
      (*lintfunc)((char const   *)tmp___1);
      }
    }
  }
  {
#line 1984
  t1 = force_string(t1);
#line 1986
  save = *(t1->sub.val.sp + t1->sub.val.slen);
#line 1987
  *(t1->sub.val.sp + t1->sub.val.slen) = (char )'\000';
#line 1989
  count = sscanf((char const   */* __restrict  */)t1->sub.val.sp, (char const   */* __restrict  */)"%ld %d %d %d %d %d %d",
                 & year, & month, & day, & hour, & minute, & second, & dst);
  }
#line 1994
  if (do_flags & 3) {
#line 1994
    if (second < 0) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    } else
#line 1994
    if (second > 60) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    } else
#line 1994
    if (minute < 0) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    } else
#line 1994
    if (minute > 60) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    } else
#line 1994
    if (hour < 0) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    } else
#line 1994
    if (hour > 23) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    } else
#line 1994
    if (day < 1) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    } else
#line 1994
    if (day > 31) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    } else
#line 1994
    if (month < 1) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    } else
#line 1994
    if (month > 12) {
      {
#line 2000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2000);
#line 2000
      tmp___2 = gettext("mktime: at least one of the values is out of the default range");
#line 2000
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 2002
  *(t1->sub.val.sp + t1->sub.val.slen) = save;
#line 2003
  DEREF(t1);
  }
#line 2005
  if (count < 6) {
    {
#line 2009
    tmp___3 = (*make_number)((double )-1);
    }
#line 2009
    return (tmp___3);
  } else
#line 2005
  if (month == (-0x7FFFFFFF-1)) {
    {
#line 2009
    tmp___3 = (*make_number)((double )-1);
    }
#line 2009
    return (tmp___3);
  } else
#line 2005
  if (year < -2147481748L) {
    {
#line 2009
    tmp___3 = (*make_number)((double )-1);
    }
#line 2009
    return (tmp___3);
  } else
#line 2005
  if (year - 1900L > 2147483647L) {
    {
#line 2009
    tmp___3 = (*make_number)((double )-1);
    }
#line 2009
    return (tmp___3);
  }
  {
#line 2011
  memset((void *)(& then), '\000', sizeof(then));
#line 2012
  then.tm_sec = second;
#line 2013
  then.tm_min = minute;
#line 2014
  then.tm_hour = hour;
#line 2015
  then.tm_mday = day;
#line 2016
  then.tm_mon = month - 1;
#line 2017
  then.tm_year = (int )(year - 1900L);
#line 2018
  then.tm_isdst = dst;
#line 2020
  then_stamp = mktime(& then);
#line 2021
  tmp___4 = (*make_number)((double )then_stamp);
  }
#line 2021
  return (tmp___4);
}
}
#line 2026 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_system(int nargs ) 
{ 
  NODE *tmp___1 ;
  int ret ;
  char *cmd ;
  char save ;
  char *tmp___2 ;
  char *tmp___3 ;
  NODE *tmp___4 ;
  int tmp___5 ;
  union __anonunion_90 __constr_expr_0 ;
  int tmp___6 ;
  NODE *tmp___7 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2030
  ret = 0;
#line 2034
  if (do_flags & 2048) {
    {
#line 2035
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2035);
#line 2035
    tmp___2 = gettext("\'system\' function not allowed in sandbox mode");
#line 2035
    r_fatal((char const   *)tmp___2);
    }
  }
  {
#line 2037
  flush_io();
#line 2038
  tmp___1 = POP_SCALAR();
  }
#line 2039
  if (do_flags & 3) {
#line 2039
    if ((tmp___1->flags & 6U) == 0U) {
      {
#line 2040
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2040);
#line 2040
      tmp___3 = gettext("system: received non-string argument");
#line 2040
      (*lintfunc)((char const   *)tmp___3);
      }
    }
  }
  {
#line 2041
  tmp___4 = force_string(tmp___1);
#line 2041
  cmd = tmp___4->sub.val.sp;
  }
#line 2043
  if (cmd) {
#line 2043
    if (*cmd) {
      {
#line 2045
      save = *(cmd + tmp___1->sub.val.slen);
#line 2046
      *(cmd + tmp___1->sub.val.slen) = (char )'\000';
#line 2048
      tmp___5 = fileno(stdin);
#line 2048
      os_restore_mode(tmp___5);
#line 2049
      ret = system((char const   *)cmd);
      }
#line 2050
      if (ret != -1) {
#line 2051
        __constr_expr_0.__in = ret;
#line 2051
        ret = (__constr_expr_0.__i & 65280) >> 8;
      }
#line 2052
      if ((BINMODE & 1) != 0) {
        {
#line 2053
        tmp___6 = fileno(stdin);
#line 2053
        os_setbinmode(tmp___6, 0);
        }
      }
#line 2055
      *(cmd + tmp___1->sub.val.slen) = save;
    }
  }
  {
#line 2057
  DEREF(tmp___1);
#line 2058
  tmp___7 = (*make_number)((double )ret);
  }
#line 2058
  return (tmp___7);
}
}
#line 2063 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
void do_print(int nargs , int redirtype ) 
{ 
  struct redirect *rp ;
  int errflg ;
  FILE *fp___0 ;
  int i___0 ;
  NODE *redir_exp ;
  NODE *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  NODE *tmp___4 ;
  STACK_ITEM *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 2066
  rp = (struct redirect *)((void *)0);
#line 2068
  fp___0 = (FILE *)((void *)0);
#line 2070
  redir_exp = (NODE *)((void *)0);
#line 2071
  tmp___1 = (NODE *)((void *)0);
#line 2075
  if (redirtype != 0) {
#line 2076
    redir_exp = (stack_ptr - nargs)->rptr;
#line 2077
    if ((unsigned int )redir_exp->type != 1U) {
      {
#line 2078
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2078);
#line 2078
      tmp___2 = array_vname((NODE const   *)redir_exp);
#line 2078
      tmp___3 = gettext("attempt to use array `%s\' in a scalar context");
#line 2078
      r_fatal((char const   *)tmp___3, tmp___2);
      }
    }
    {
#line 2079
    rp = redirect(redir_exp, redirtype, & errflg);
    }
#line 2080
    if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 2081
      fp___0 = rp->output.fp;
    }
  } else
#line 2082
  if (do_flags & 8192) {
#line 2083
    fp___0 = output_fp;
  } else {
#line 2085
    fp___0 = stdout;
  }
#line 2087
  i___0 = 1;
  {
#line 2087
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2087
    if (! (i___0 <= nargs)) {
#line 2087
      goto while_break;
    }
#line 2088
    tmp___5 = stack_ptr;
#line 2088
    stack_ptr --;
#line 2088
    tmp___4 = tmp___5->rptr;
#line 2088
    *(args_array + i___0) = tmp___4;
#line 2088
    tmp___1 = tmp___4;
#line 2089
    if ((unsigned int )tmp___1->type == 5U) {
      {
#line 2090
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2090
        i___0 --;
#line 2090
        if (! (i___0 > 0)) {
#line 2090
          goto while_break___0;
        }
        {
#line 2091
        DEREF(*(args_array + i___0));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2092
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2092);
#line 2092
      tmp___6 = array_vname((NODE const   *)tmp___1);
#line 2092
      tmp___7 = gettext("attempt to use array `%s\' in a scalar context");
#line 2092
      r_fatal((char const   *)tmp___7, tmp___6);
      }
    }
#line 2095
    if ((tmp___1->flags & 18U) == 16U) {
#line 2096
      if (OFMTidx == CONVFMTidx) {
        {
#line 2097
        *(args_array + i___0) = force_string(tmp___1);
        }
      } else {
        {
#line 2099
        *(args_array + i___0) = (*format_val)((char const   *)OFMT, OFMTidx, tmp___1);
        }
      }
    }
#line 2087
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2103
  if ((unsigned long )redir_exp != (unsigned long )((void *)0)) {
    {
#line 2104
    DEREF(redir_exp);
#line 2105
    stack_ptr --;
    }
  }
#line 2108
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
#line 2109
    i___0 = nargs;
    {
#line 2109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2109
      if (! (i___0 > 0)) {
#line 2109
        goto while_break___1;
      }
      {
#line 2110
      DEREF(*(args_array + i___0));
#line 2109
      i___0 --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2111
    return;
  }
#line 2114
  i___0 = nargs;
  {
#line 2114
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2114
    if (! (i___0 > 0)) {
#line 2114
      goto while_break___2;
    }
    {
#line 2115
    efwrite((void const   *)(*(args_array + i___0))->sub.val.sp, sizeof(char ), (*(args_array + i___0))->sub.val.slen,
            fp___0, "print", rp, (_Bool)0);
#line 2116
    DEREF(*(args_array + i___0));
    }
#line 2117
    if (i___0 != 1) {
#line 2117
      if (OFSlen > 0) {
        {
#line 2118
        efwrite((void const   *)OFS, sizeof(char ), (size_t )OFSlen, fp___0, "print",
                rp, (_Bool)0);
        }
      }
    }
#line 2114
    i___0 --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2122
  if (ORSlen > 0) {
    {
#line 2123
    efwrite((void const   *)ORS, sizeof(char ), (size_t )ORSlen, fp___0, "print",
            rp, (_Bool)1);
    }
  }
#line 2125
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 2125
    if ((rp->flag & 256U) != 0U) {
      {
#line 2126
      (*(rp->output.gawk_fflush))(rp->output.fp, rp->output.opaque);
      }
    }
  }
#line 2127
  return;
}
}
#line 2131 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
void do_print_rec(int nargs , int redirtype ) 
{ 
  FILE *fp___0 ;
  NODE *f0 ;
  struct redirect *rp ;
  int errflg ;
  NODE *redir_exp ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 2134
  fp___0 = (FILE *)((void *)0);
#line 2136
  rp = (struct redirect *)((void *)0);
#line 2138
  redir_exp = (NODE *)((void *)0);
#line 2141
  if (redirtype != 0) {
    {
#line 2142
    redir_exp = stack_ptr->rptr;
#line 2143
    rp = redirect(redir_exp, redirtype, & errflg);
    }
#line 2144
    if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 2145
      fp___0 = rp->output.fp;
    }
    {
#line 2146
    DEREF(redir_exp);
#line 2147
    stack_ptr --;
    }
  } else {
#line 2149
    fp___0 = output_fp;
  }
#line 2151
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
#line 2152
    return;
  }
#line 2154
  if (! field0_valid) {
    {
#line 2155
    get_field(0L, (Func_ptr *)((void *)0));
    }
  }
#line 2157
  f0 = *(fields_arr + 0);
#line 2159
  if (do_flags & 3) {
#line 2159
    if ((unsigned long )f0 == (unsigned long )Nnull_string) {
      {
#line 2160
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2160);
#line 2160
      tmp___1 = gettext("reference to uninitialized field `$%d\'");
#line 2160
      (*lintfunc)((char const   *)tmp___1, 0);
      }
    }
  }
  {
#line 2162
  efwrite((void const   *)f0->sub.val.sp, sizeof(char ), f0->sub.val.slen, fp___0,
          "print", rp, (_Bool)0);
  }
#line 2164
  if (ORSlen > 0) {
    {
#line 2165
    efwrite((void const   *)ORS, sizeof(char ), (size_t )ORSlen, fp___0, "print",
            rp, (_Bool)1);
    }
  }
#line 2167
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 2167
    if ((rp->flag & 256U) != 0U) {
      {
#line 2168
      (*(rp->output.gawk_fflush))(rp->output.fp, rp->output.opaque);
      }
    }
  }
#line 2169
  return;
}
}
#line 2175 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static int is_wupper(wchar_t c ) 
{ 
  int tmp___1 ;

  {
  {
#line 2178
  tmp___1 = iswupper((wint_t )c);
  }
#line 2178
  return (tmp___1);
}
}
#line 2183 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static int is_wlower(wchar_t c ) 
{ 
  int tmp___1 ;

  {
  {
#line 2186
  tmp___1 = iswlower((wint_t )c);
  }
#line 2186
  return (tmp___1);
}
}
#line 2191 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static int to_wlower(wchar_t c ) 
{ 
  wint_t tmp___1 ;

  {
  {
#line 2194
  tmp___1 = towlower((wint_t )c);
  }
#line 2194
  return ((int )tmp___1);
}
}
#line 2199 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static int to_wupper(wchar_t c ) 
{ 
  wint_t tmp___1 ;

  {
  {
#line 2202
  tmp___1 = towupper((wint_t )c);
  }
#line 2202
  return ((int )tmp___1);
}
}
#line 2207 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static void wide_change_case(wchar_t *wstr , size_t wlen , int (*is_x)(wchar_t c ) ,
                             int (*to_y)(wchar_t c ) ) 
{ 
  size_t i___0 ;
  wchar_t *wcp ;
  int tmp___1 ;

  {
#line 2216
  i___0 = (size_t )0;
#line 2216
  wcp = wstr;
  {
#line 2216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2216
    if (! (i___0 < wlen)) {
#line 2216
      goto while_break;
    }
    {
#line 2217
    tmp___1 = (*is_x)(*wcp);
    }
#line 2217
    if (tmp___1) {
      {
#line 2218
      *wcp = (*to_y)(*wcp);
      }
    }
#line 2216
    i___0 ++;
#line 2216
    wcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2219
  return;
}
}
#line 2223 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static void wide_toupper(wchar_t *wstr , size_t wlen ) 
{ 


  {
  {
#line 2226
  wide_change_case(wstr, wlen, & is_wlower, & to_wupper);
  }
#line 2227
  return;
}
}
#line 2231 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static void wide_tolower(wchar_t *wstr , size_t wlen ) 
{ 


  {
  {
#line 2234
  wide_change_case(wstr, wlen, & is_wupper, & to_wlower);
  }
#line 2235
  return;
}
}
#line 2240 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_tolower(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  char *tmp___1 ;
  unsigned char *cp ;
  unsigned char *cp2 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2245
  t1 = POP_SCALAR();
  }
#line 2246
  if (do_flags & 3) {
#line 2246
    if ((t1->flags & 6U) == 0U) {
      {
#line 2247
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2247);
#line 2247
      tmp___1 = gettext("tolower: received non-string argument");
#line 2247
      (*lintfunc)((char const   *)tmp___1);
      }
    }
  }
  {
#line 2248
  t1 = force_string(t1);
#line 2249
  t2 = make_str_node((char const   *)t1->sub.val.sp, t1->sub.val.slen, 0);
  }
#line 2251
  if (gawk_mb_cur_max == 1) {
#line 2254
    cp = (unsigned char *)t2->sub.val.sp;
#line 2254
    cp2 = (unsigned char *)(t2->sub.val.sp + t2->sub.val.slen);
    {
#line 2254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2254
      if (! ((unsigned long )cp < (unsigned long )cp2)) {
#line 2254
        goto while_break;
      }
      {
#line 2257
      tmp___3 = __ctype_b_loc();
      }
#line 2257
      if ((int const   )*(*tmp___3 + (int )*cp) & 256) {
        {
#line 2258
        tmp___2 = tolower((int )*cp);
#line 2258
        *cp = (unsigned char )tmp___2;
        }
      }
#line 2254
      cp ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2262
    str2wstr(t2, (size_t **)((void *)0));
#line 2263
    wide_tolower(t2->sub.val.wsp, t2->sub.val.wslen);
#line 2264
    wstr2str(t2);
    }
  }
  {
#line 2268
  DEREF(t1);
  }
#line 2269
  return (t2);
}
}
#line 2274 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_toupper(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  char *tmp___1 ;
  unsigned char *cp ;
  unsigned char *cp2 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2279
  t1 = POP_SCALAR();
  }
#line 2280
  if (do_flags & 3) {
#line 2280
    if ((t1->flags & 6U) == 0U) {
      {
#line 2281
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2281);
#line 2281
      tmp___1 = gettext("toupper: received non-string argument");
#line 2281
      (*lintfunc)((char const   *)tmp___1);
      }
    }
  }
  {
#line 2282
  t1 = force_string(t1);
#line 2283
  t2 = make_str_node((char const   *)t1->sub.val.sp, t1->sub.val.slen, 0);
  }
#line 2285
  if (gawk_mb_cur_max == 1) {
#line 2288
    cp = (unsigned char *)t2->sub.val.sp;
#line 2288
    cp2 = (unsigned char *)(t2->sub.val.sp + t2->sub.val.slen);
    {
#line 2288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2288
      if (! ((unsigned long )cp < (unsigned long )cp2)) {
#line 2288
        goto while_break;
      }
      {
#line 2291
      tmp___3 = __ctype_b_loc();
      }
#line 2291
      if ((int const   )*(*tmp___3 + (int )*cp) & 512) {
        {
#line 2292
        tmp___2 = toupper((int )*cp);
#line 2292
        *cp = (unsigned char )tmp___2;
        }
      }
#line 2288
      cp ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2296
    str2wstr(t2, (size_t **)((void *)0));
#line 2297
    wide_toupper(t2->sub.val.wsp, t2->sub.val.wslen);
#line 2298
    wstr2str(t2);
    }
  }
  {
#line 2302
  DEREF(t1);
  }
#line 2303
  return (t2);
}
}
#line 2308 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_atan2(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  double d1 ;
  double d2 ;
  STACK_ITEM *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  NODE *tmp___6 ;
  NODE *tmp___7 ;
  double tmp___8 ;
  NODE *tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 2314
  t2 = POP_SCALAR();
#line 2314
  tmp___1 = stack_ptr;
#line 2314
  stack_ptr --;
#line 2314
  t1 = tmp___1->rptr;
  }
  {
#line 2314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2314
    if ((unsigned int )t1->type == 5U) {
      {
#line 2314
      DEREF(t2);
#line 2314
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2314);
#line 2314
      tmp___2 = array_vname((NODE const   *)t1);
#line 2314
      tmp___3 = gettext("attempt to use array `%s\' in a scalar context");
#line 2314
      r_fatal((char const   *)tmp___3, tmp___2);
      }
    }
#line 2314
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2315
  if (do_flags & 3) {
#line 2316
    if ((t1->flags & 24U) == 0U) {
      {
#line 2317
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2317);
#line 2317
      tmp___4 = gettext("atan2: received non-numeric first argument");
#line 2317
      (*lintfunc)((char const   *)tmp___4);
      }
    }
#line 2318
    if ((t2->flags & 24U) == 0U) {
      {
#line 2319
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2319);
#line 2319
      tmp___5 = gettext("atan2: received non-numeric second argument");
#line 2319
      (*lintfunc)((char const   *)tmp___5);
      }
    }
  }
  {
#line 2321
  tmp___6 = force_number(t1);
#line 2321
  d1 = tmp___6->sub.val.nm.fltnum;
#line 2322
  tmp___7 = force_number(t2);
#line 2322
  d2 = tmp___7->sub.val.nm.fltnum;
#line 2323
  DEREF(t1);
#line 2324
  DEREF(t2);
#line 2325
  tmp___8 = atan2(d1, d2);
#line 2325
  tmp___9 = (*make_number)(tmp___8);
  }
#line 2325
  return (tmp___9);
}
}
#line 2330 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_sin(int nargs ) 
{ 
  NODE *tmp___1 ;
  double d ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2336
  tmp___1 = POP_SCALAR();
  }
#line 2337
  if (do_flags & 3) {
#line 2337
    if ((tmp___1->flags & 24U) == 0U) {
      {
#line 2338
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2338);
#line 2338
      tmp___2 = gettext("sin: received non-numeric argument");
#line 2338
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 2339
  tmp___3 = force_number(tmp___1);
#line 2339
  d = sin(tmp___3->sub.val.nm.fltnum);
#line 2340
  DEREF(tmp___1);
#line 2341
  tmp___4 = (*make_number)(d);
  }
#line 2341
  return (tmp___4);
}
}
#line 2346 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_cos(int nargs ) 
{ 
  NODE *tmp___1 ;
  double d ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2352
  tmp___1 = POP_SCALAR();
  }
#line 2353
  if (do_flags & 3) {
#line 2353
    if ((tmp___1->flags & 24U) == 0U) {
      {
#line 2354
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2354);
#line 2354
      tmp___2 = gettext("cos: received non-numeric argument");
#line 2354
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 2355
  tmp___3 = force_number(tmp___1);
#line 2355
  d = cos(tmp___3->sub.val.nm.fltnum);
#line 2356
  DEREF(tmp___1);
#line 2357
  tmp___4 = (*make_number)(d);
  }
#line 2357
  return (tmp___4);
}
}
#line 2362 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static _Bool firstrand___0  =    (_Bool)1;
#line 2365 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static gawk_uint32_t istate[256UL / sizeof(gawk_uint32_t )]  ;
#line 2366 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static char * const  state___1  =    (char */* const  */)(istate);
#line 2369 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_rand(int nargs  __attribute__((__unused__)) ) 
{ 
  long tmp___1 ;
  NODE *tmp___2 ;

  {
#line 2372
  if (firstrand___0) {
    {
#line 2373
    gawk_initstate(1UL, (char *)state___1, 256L);
#line 2375
    firstrand___0 = (_Bool)0;
#line 2376
    gawk_setstate((char *)state___1);
    }
  }
  {
#line 2383
  tmp___1 = gawk_random();
#line 2383
  tmp___2 = (*make_number)((double )(tmp___1 % 2147483647L) / (double )2147483647L);
  }
#line 2383
  return (tmp___2);
}
}
#line 2392 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static long save_seed  =    1L;
#line 2388 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_srand(int nargs ) 
{ 
  NODE *tmp___1 ;
  long ret ;
  time_t tmp___2 ;
  char *tmp___3 ;
  NODE *tmp___4 ;
  NODE *tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 2393
  ret = save_seed;
#line 2395
  if (firstrand___0) {
    {
#line 2396
    gawk_initstate(1UL, (char *)state___1, 256L);
#line 2398
    firstrand___0 = (_Bool)0;
#line 2399
    gawk_setstate((char *)state___1);
    }
  }
#line 2402
  if (nargs == 0) {
    {
#line 2403
    tmp___2 = time((time_t *)0);
#line 2403
    save_seed = tmp___2;
#line 2403
    gawk_srandom((unsigned long )((unsigned int )save_seed));
    }
  } else {
    {
#line 2405
    tmp___1 = POP_SCALAR();
    }
#line 2406
    if (do_flags & 3) {
#line 2406
      if ((tmp___1->flags & 24U) == 0U) {
        {
#line 2407
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2407);
#line 2407
        tmp___3 = gettext("srand: received non-numeric argument");
#line 2407
        (*lintfunc)((char const   *)tmp___3);
        }
      }
    }
    {
#line 2408
    tmp___4 = force_number(tmp___1);
#line 2408
    save_seed = (long )tmp___4->sub.val.nm.fltnum;
#line 2408
    gawk_srandom((unsigned long )((unsigned int )save_seed));
#line 2409
    DEREF(tmp___1);
    }
  }
  {
#line 2411
  tmp___5 = (*make_number)((double )ret);
  }
#line 2411
  return (tmp___5);
}
}
#line 2419 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_match(int nargs ) 
{ 
  NODE *tre ;
  NODE *t1 ;
  NODE *dest ;
  NODE *it ;
  int rstart ;
  int len ;
  int ii ;
  int rlength ;
  Regexp *rp ;
  regoff_t s___0 ;
  char *start ;
  char *buf___7 ;
  char buff[100] ;
  size_t amt ;
  size_t oldamt ;
  size_t ilen ;
  size_t slen ;
  char *subsepstr ;
  size_t subseplen ;
  char *tmp___1 ;
  STACK_ITEM *tmp___2 ;
  NODE *tmp___3 ;
  size_t *wc_indices ;
  size_t subpat_start ;
  size_t subpat_len ;
  NODE **lhs ;
  NODE *sub ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  NODE *tmp___15 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
#line 2428
  buf___7 = (char *)((void *)0);
#line 2430
  oldamt = (size_t )0;
#line 2434
  dest = (NODE *)((void *)0);
#line 2435
  if (nargs == 3) {
    {
#line 2436
    dest = POP_PARAM();
    }
#line 2437
    if ((unsigned int )dest->type != 5U) {
      {
#line 2438
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2438);
#line 2438
      tmp___1 = gettext("match: third argument is not an array");
#line 2438
      r_fatal((char const   *)tmp___1);
      }
    }
    {
#line 2439
    (*(*(dest->sub.nodep.l.lp + 5)))(dest, (struct exp_node *)((void *)0));
    }
  }
  {
#line 2441
  tmp___2 = stack_ptr;
#line 2441
  stack_ptr --;
#line 2441
  tre = tmp___2->rptr;
#line 2442
  rp = re_update(tre);
#line 2443
  tmp___3 = POP_SCALAR();
#line 2443
  t1 = force_string(tmp___3);
#line 2445
  rstart = research(rp, t1->sub.val.sp, 0, t1->sub.val.slen, 1);
  }
#line 2446
  if (rstart >= 0) {
#line 2447
    wc_indices = (size_t *)((void *)0);
#line 2449
    rlength = *(rp->regs.end + 0) - *(rp->regs.start + 0);
#line 2451
    if (rlength > 0) {
#line 2451
      if (gawk_mb_cur_max > 1) {
        {
#line 2452
        t1 = str2wstr(t1, & wc_indices);
#line 2453
        rlength = (int )((*(wc_indices + ((rstart + rlength) - 1)) - *(wc_indices + rstart)) + 1UL);
#line 2454
        rstart = (int )*(wc_indices + rstart);
        }
      }
    }
#line 2457
    rstart ++;
#line 2460
    if ((unsigned long )dest != (unsigned long )((void *)0)) {
#line 2461
      subsepstr = (SUBSEP_node->sub.nodep.l.lptr)->sub.val.sp;
#line 2462
      subseplen = (SUBSEP_node->sub.nodep.l.lptr)->sub.val.slen;
#line 2464
      ii = 0;
      {
#line 2464
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2464
        if (! ((unsigned int )ii < rp->regs.num_regs)) {
#line 2464
          goto while_break;
        }
#line 2469
        s___0 = *(rp->regs.start + ii);
#line 2469
        if (s___0 != -1) {
#line 2475
          start = t1->sub.val.sp + s___0;
#line 2476
          subpat_start = (size_t )s___0;
#line 2477
          len = *(rp->regs.end + ii) - s___0;
#line 2477
          subpat_len = (size_t )len;
#line 2479
          if (len > 0) {
#line 2479
            if (gawk_mb_cur_max > 1) {
#line 2480
              subpat_start = *(wc_indices + s___0);
#line 2481
              subpat_len = (*(wc_indices + ((s___0 + len) - 1)) - subpat_start) + 1UL;
            }
          }
          {
#line 2485
          it = make_str_node((char const   *)start, (size_t )len, 0);
#line 2486
          it->flags |= 32U;
#line 2488
          sub = (*make_number)((double )ii);
#line 2489
          lhs = (*(*(dest->sub.nodep.l.lp + 3)))(dest, sub);
#line 2490
          unref(*lhs);
#line 2491
          *lhs = it;
          }
#line 2493
          if ((unsigned long )*(dest->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
            {
#line 2494
            (*(*(dest->sub.nodep.l.lp + 10)))(dest, sub);
            }
          }
          {
#line 2495
          unref(sub);
#line 2497
          sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"%d",
                  ii);
#line 2498
          ilen = strlen((char const   *)(buff));
#line 2499
          tmp___4 = strlen("length");
#line 2499
          amt = ((ilen + subseplen) + tmp___4) + 2UL;
          }
#line 2501
          if (oldamt == 0UL) {
            {
#line 2502
            tmp___5 = malloc(amt);
#line 2502
            buf___7 = (char *)tmp___5;
            }
#line 2502
            if (buf___7) {
#line 2502
              tmp___9 = 1;
            } else {
              {
#line 2502
              set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2502);
#line 2502
              tmp___6 = __errno_location();
#line 2502
              tmp___7 = strerror(*tmp___6);
#line 2502
              tmp___8 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2502
              r_fatal((char const   *)tmp___8, "do_match", "buf", (long )amt, tmp___7);
#line 2502
              tmp___9 = 0;
              }
            }
          } else
#line 2503
          if (amt > oldamt) {
            {
#line 2504
            tmp___10 = realloc((void *)buf___7, amt);
#line 2504
            buf___7 = (char *)tmp___10;
            }
#line 2504
            if (buf___7) {
#line 2504
              tmp___14 = 1;
            } else {
              {
#line 2504
              set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2504);
#line 2504
              tmp___11 = __errno_location();
#line 2504
              tmp___12 = strerror(*tmp___11);
#line 2504
              tmp___13 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2504
              r_fatal((char const   *)tmp___13, "do_match", "buf", (long )amt, tmp___12);
#line 2504
              tmp___14 = 0;
              }
            }
          }
          {
#line 2506
          oldamt = amt;
#line 2507
          memcpy((void */* __restrict  */)buf___7, (void const   */* __restrict  */)(buff),
                 ilen);
#line 2508
          memcpy((void */* __restrict  */)(buf___7 + ilen), (void const   */* __restrict  */)subsepstr,
                 subseplen);
#line 2509
          memcpy((void */* __restrict  */)((buf___7 + ilen) + subseplen), (void const   */* __restrict  */)"start",
                 (size_t )6);
#line 2511
          slen = (ilen + subseplen) + 5UL;
#line 2513
          it = (*make_number)((double )subpat_start + (double )1);
#line 2514
          sub = make_str_node((char const   *)buf___7, slen, 0);
#line 2515
          lhs = (*(*(dest->sub.nodep.l.lp + 3)))(dest, sub);
#line 2516
          unref(*lhs);
#line 2517
          *lhs = it;
          }
#line 2518
          if ((unsigned long )*(dest->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
            {
#line 2519
            (*(*(dest->sub.nodep.l.lp + 10)))(dest, sub);
            }
          }
          {
#line 2520
          unref(sub);
#line 2522
          memcpy((void */* __restrict  */)buf___7, (void const   */* __restrict  */)(buff),
                 ilen);
#line 2523
          memcpy((void */* __restrict  */)(buf___7 + ilen), (void const   */* __restrict  */)subsepstr,
                 subseplen);
#line 2524
          memcpy((void */* __restrict  */)((buf___7 + ilen) + subseplen), (void const   */* __restrict  */)"length",
                 (size_t )7);
#line 2526
          slen = (ilen + subseplen) + 6UL;
#line 2528
          it = (*make_number)((double )subpat_len);
#line 2529
          sub = make_str_node((char const   *)buf___7, slen, 0);
#line 2530
          lhs = (*(*(dest->sub.nodep.l.lp + 3)))(dest, sub);
#line 2531
          unref(*lhs);
#line 2532
          *lhs = it;
          }
#line 2533
          if ((unsigned long )*(dest->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
            {
#line 2534
            (*(*(dest->sub.nodep.l.lp + 10)))(dest, sub);
            }
          }
          {
#line 2535
          unref(sub);
          }
        }
#line 2464
        ii ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2539
      free((void *)buf___7);
      }
    }
#line 2541
    if ((unsigned long )wc_indices != (unsigned long )((void *)0)) {
      {
#line 2542
      free((void *)wc_indices);
      }
    }
  } else {
#line 2544
    rstart = 0;
#line 2545
    rlength = -1;
  }
  {
#line 2548
  DEREF(t1);
#line 2549
  unref(RSTART_node->sub.nodep.l.lptr);
#line 2550
  RSTART_node->sub.nodep.l.lptr = (*make_number)((double )rstart);
#line 2551
  unref(RLENGTH_node->sub.nodep.l.lptr);
#line 2552
  RLENGTH_node->sub.nodep.l.lptr = (*make_number)((double )rlength);
#line 2553
  tmp___15 = (*make_number)((double )rstart);
  }
#line 2553
  return (tmp___15);
}
}
#line 2649 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_sub(int nargs , unsigned int flags___0 ) 
{ 
  char *scan ;
  char *bp ;
  char *cp ;
  char *buf___7 ;
  size_t buflen___2 ;
  char *matchend ;
  size_t len ;
  char *matchstart ;
  char *text ;
  size_t textlen___4 ;
  char *repl ;
  char *replend ;
  size_t repllen ;
  int sofar ;
  int ampersands ;
  int matches ;
  Regexp *rp ;
  NODE *s___0 ;
  NODE *t ;
  NODE *tmp___1 ;
  NODE **lhs ;
  long how_many ;
  int global ;
  long current ;
  _Bool lastmatchnonzero ;
  char *mb_indices ;
  double d ;
  NODE *t1 ;
  NODE *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  char *tmp___9 ;
  NODE *tmp___10 ;
  STACK_ITEM *tmp___11 ;
  NODE *tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  unsigned short const   **tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int dig ;
  char *start ;
  char *end ;
  char *tmp___34 ;
  char *tmp___35 ;
  unsigned short const   **tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  void *tmp___50 ;
  int *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *tmp___55 ;
  NODE *tmp___56 ;
  NODE *tmp___57 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;

  {
#line 2654
  buf___7 = (char *)((void *)0);
#line 2660
  textlen___4 = (size_t )0;
#line 2666
  matches = 0;
#line 2671
  lhs = (NODE **)((void *)0);
#line 2672
  how_many = 1L;
#line 2676
  mb_indices = (char *)((void *)0);
#line 2678
  if ((flags___0 & 2U) != 0U) {
    {
#line 2682
    tmp___1 = (stack_ptr - 3)->rptr;
#line 2683
    rp = re_update(tmp___1);
#line 2685
    tmp___2 = POP_SCALAR();
#line 2685
    t = force_string(tmp___2);
#line 2687
    t1 = POP_SCALAR();
    }
#line 2688
    if ((t1->flags & 6U) != 0U) {
#line 2689
      if (t1->sub.val.slen > 0UL) {
#line 2689
        if ((int )*(t1->sub.val.sp + 0) == 103) {
#line 2690
          how_many = -1L;
        } else
#line 2689
        if ((int )*(t1->sub.val.sp + 0) == 71) {
#line 2690
          how_many = -1L;
        } else {
#line 2689
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 2692
        force_number(t1);
        }
#line 2693
        if (t1->flags & 2048U) {
          {
#line 2693
          tmp___3 = mpfr_get_d((mpfr_srcptr )(t1->sub.val.nm.mpnum), ROUND_MODE);
#line 2693
          d = tmp___3;
          }
        } else {
#line 2693
          if (t1->flags & 4096U) {
            {
#line 2693
            tmp___4 = __gmpz_get_d((mpz_srcptr )(t1->sub.val.nm.mpi));
#line 2693
            tmp___5 = tmp___4;
            }
          } else {
#line 2693
            tmp___5 = t1->sub.val.nm.fltnum;
          }
#line 2693
          d = tmp___5;
        }
#line 2694
        if ((t1->flags & 8U) != 0U) {
#line 2695
          goto set_how_many;
        }
#line 2697
        how_many = 1L;
      }
    } else {
      {
#line 2700
      force_number(t1);
      }
#line 2701
      if (t1->flags & 2048U) {
        {
#line 2701
        tmp___6 = mpfr_get_d((mpfr_srcptr )(t1->sub.val.nm.mpnum), ROUND_MODE);
#line 2701
        d = tmp___6;
        }
      } else {
#line 2701
        if (t1->flags & 4096U) {
          {
#line 2701
          tmp___7 = __gmpz_get_d((mpz_srcptr )(t1->sub.val.nm.mpi));
#line 2701
          tmp___8 = tmp___7;
          }
        } else {
#line 2701
          tmp___8 = t1->sub.val.nm.fltnum;
        }
#line 2701
        d = tmp___8;
      }
      set_how_many: 
#line 2703
      if (d < (double )1) {
#line 2704
        how_many = 1L;
      } else
#line 2705
      if (d < (double )9223372036854775807L) {
#line 2706
        how_many = (long )d;
      } else {
#line 2708
        how_many = 9223372036854775807L;
      }
#line 2709
      if (d == (double )0) {
        {
#line 2710
        tmp___9 = gettext("gensub: third argument of 0 treated as 1");
#line 2710
        warning((char const   *)tmp___9);
        }
      }
    }
    {
#line 2712
    DEREF(t1);
    }
  } else {
    {
#line 2718
    tmp___1 = (stack_ptr - 2)->rptr;
#line 2719
    rp = re_update(tmp___1);
    }
#line 2721
    if ((flags___0 & 1U) != 0U) {
#line 2722
      how_many = -1L;
    }
#line 2726
    if ((flags___0 & 4U) != 0U) {
      {
#line 2727
      tmp___10 = POP_SCALAR();
#line 2727
      t = force_string(tmp___10);
      }
    } else {
      {
#line 2729
      tmp___11 = stack_ptr;
#line 2729
      stack_ptr --;
#line 2729
      lhs = tmp___11->lptr;
#line 2730
      t = force_string(*lhs);
      }
    }
  }
  {
#line 2734
  global = how_many == -1L;
#line 2736
  tmp___12 = POP_SCALAR();
#line 2736
  s___0 = force_string(tmp___12);
#line 2737
  stack_ptr --;
#line 2740
  tmp___13 = research(rp, t->sub.val.sp, 0, t->sub.val.slen, 1);
  }
#line 2740
  if (tmp___13 == -1) {
#line 2742
    goto done;
  } else
#line 2740
  if ((size_t )*(rp->regs.start + 0) > t->sub.val.slen) {
#line 2742
    goto done;
  }
  {
#line 2744
  t->flags |= 2U;
#line 2746
  text = t->sub.val.sp;
#line 2747
  textlen___4 = t->sub.val.slen;
#line 2748
  buflen___2 = textlen___4 + 2UL;
#line 2750
  repl = s___0->sub.val.sp;
#line 2751
  replend = repl + s___0->sub.val.slen;
#line 2752
  repllen = (size_t )(replend - repl);
#line 2753
  tmp___14 = malloc(buflen___2 + 2UL);
#line 2753
  buf___7 = (char *)tmp___14;
  }
#line 2753
  if (buf___7) {
#line 2753
    tmp___18 = 1;
  } else {
    {
#line 2753
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2753);
#line 2753
    tmp___15 = __errno_location();
#line 2753
    tmp___16 = strerror(*tmp___15);
#line 2753
    tmp___17 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2753
    r_fatal((char const   *)tmp___17, "do_sub", "buf", (long )(buflen___2 + 2UL),
            tmp___16);
#line 2753
    tmp___18 = 0;
    }
  }
#line 2754
  *(buf___7 + buflen___2) = (char )'\000';
#line 2755
  *(buf___7 + (buflen___2 + 1UL)) = (char )'\000';
#line 2756
  ampersands = 0;
#line 2766
  if (gawk_mb_cur_max > 1) {
#line 2766
    if (repllen > 0UL) {
      {
#line 2767
      tmp___19 = malloc(repllen * sizeof(char ));
#line 2767
      mb_indices = (char *)tmp___19;
      }
#line 2767
      if (mb_indices) {
#line 2767
        tmp___23 = 1;
      } else {
        {
#line 2767
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2767);
#line 2767
        tmp___20 = __errno_location();
#line 2767
        tmp___21 = strerror(*tmp___20);
#line 2767
        tmp___22 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2767
        r_fatal((char const   *)tmp___22, "do_sub", "mb_indices", (long )(repllen * sizeof(char )),
                tmp___21);
#line 2767
        tmp___23 = 0;
        }
      }
      {
#line 2768
      index_multibyte_buffer(repl, mb_indices, (int )repllen);
      }
    }
  }
#line 2771
  scan = repl;
  {
#line 2771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2771
    if (! ((unsigned long )scan < (unsigned long )replend)) {
#line 2771
      goto while_break;
    }
#line 2772
    if (gawk_mb_cur_max == 1) {
#line 2772
      goto _L___1;
    } else
#line 2772
    if (repllen > 0UL) {
#line 2772
      if ((int )*(mb_indices + (scan - repl)) == 1) {
        _L___1: /* CIL Label */ 
#line 2772
        if ((int )*scan == 38) {
#line 2774
          repllen --;
#line 2775
          ampersands ++;
        } else {
#line 2772
          goto _L___2;
        }
      } else {
#line 2772
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2776
    if ((int )*scan == 92) {
#line 2777
      if ((flags___0 & 2U) != 0U) {
        {
#line 2778
        tmp___24 = __ctype_b_loc();
        }
#line 2778
        if ((int const   )*(*tmp___24 + (int )((unsigned char )*(scan + 1))) & 2048) {
#line 2779
          ampersands ++;
#line 2780
          scan ++;
        } else {
#line 2782
          repllen --;
#line 2783
          scan ++;
        }
      } else
#line 2785
      if (do_flags & 16) {
#line 2787
        if ((int )*(scan + 1) == 38) {
#line 2788
          repllen --;
#line 2789
          scan ++;
        } else
#line 2787
        if ((int )*(scan + 1) == 92) {
#line 2788
          repllen --;
#line 2789
          scan ++;
        }
      } else {
        {
#line 2794
        tmp___26 = strncmp((char const   *)scan, "\\\\\\&", (size_t )4);
        }
#line 2794
        if (tmp___26 == 0) {
#line 2796
          repllen -= 2UL;
#line 2797
          scan += 3;
        } else {
          {
#line 2798
          tmp___25 = strncmp((char const   *)scan, "\\\\&", (size_t )3);
          }
#line 2798
          if (tmp___25 == 0) {
#line 2800
            ampersands ++;
#line 2801
            repllen --;
#line 2802
            scan += 2;
          } else
#line 2803
          if ((int )*(scan + 1) == 38) {
#line 2805
            repllen --;
#line 2806
            scan ++;
          }
        }
      }
    }
#line 2771
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2813
  lastmatchnonzero = (_Bool)0;
#line 2814
  bp = buf___7;
#line 2815
  current = 1L;
  {
#line 2815
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2816
    matches ++;
#line 2817
    matchstart = t->sub.val.sp + *(rp->regs.start + 0);
#line 2818
    matchend = t->sub.val.sp + *(rp->regs.end + 0);
#line 2824
    len = ((size_t )(matchstart - text) + repllen) + (size_t )((long )ampersands * (matchend - matchstart));
#line 2826
    sofar = (int )(bp - buf___7);
    {
#line 2827
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2827
      if (! (buflen___2 < ((size_t )sofar + len) + 1UL)) {
#line 2827
        goto while_break___1;
      }
      {
#line 2828
      buflen___2 *= 2UL;
#line 2829
      tmp___27 = realloc((void *)buf___7, buflen___2);
#line 2829
      buf___7 = (char *)tmp___27;
      }
#line 2829
      if (buf___7) {
#line 2829
        tmp___31 = 1;
      } else {
        {
#line 2829
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2829);
#line 2829
        tmp___28 = __errno_location();
#line 2829
        tmp___29 = strerror(*tmp___28);
#line 2829
        tmp___30 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2829
        r_fatal((char const   *)tmp___30, "sub_common", "buf", (long )buflen___2,
                tmp___29);
#line 2829
        tmp___31 = 0;
        }
      }
#line 2830
      bp = buf___7 + sofar;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2832
    scan = text;
    {
#line 2832
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2832
      if (! ((unsigned long )scan < (unsigned long )matchstart)) {
#line 2832
        goto while_break___2;
      }
#line 2833
      tmp___32 = bp;
#line 2833
      bp ++;
#line 2833
      *tmp___32 = *scan;
#line 2832
      scan ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2834
    if (global) {
#line 2834
      goto _L___6;
    } else
#line 2834
    if (current == how_many) {
      _L___6: /* CIL Label */ 
#line 2842
      if ((unsigned long )matchstart == (unsigned long )matchend) {
#line 2842
        if (lastmatchnonzero) {
#line 2842
          if ((unsigned long )matchstart == (unsigned long )text) {
#line 2845
            lastmatchnonzero = (_Bool)0;
#line 2846
            matches --;
#line 2847
            goto empty;
          }
        }
      }
#line 2854
      scan = repl;
      {
#line 2854
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2854
        if (! ((unsigned long )scan < (unsigned long )replend)) {
#line 2854
          goto while_break___3;
        }
#line 2855
        if ((int )*scan == 38) {
#line 2855
          if (gawk_mb_cur_max == 1) {
#line 2855
            goto _L___5;
          } else
#line 2855
          if ((int )*(mb_indices + (scan - repl)) == 1) {
            _L___5: /* CIL Label */ 
#line 2863
            cp = matchstart;
            {
#line 2863
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2863
              if (! ((unsigned long )cp < (unsigned long )matchend)) {
#line 2863
                goto while_break___4;
              }
#line 2864
              tmp___33 = bp;
#line 2864
              bp ++;
#line 2864
              *tmp___33 = *cp;
#line 2863
              cp ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          } else {
#line 2855
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 2865
        if ((int )*scan == 92) {
#line 2865
          if (gawk_mb_cur_max == 1) {
#line 2865
            goto _L___3;
          } else
#line 2865
          if (repllen > 0UL) {
#line 2865
            if ((int )*(mb_indices + (scan - repl)) == 1) {
              _L___3: /* CIL Label */ 
#line 2869
              if (flags___0 & 2U) {
                {
#line 2870
                tmp___36 = __ctype_b_loc();
                }
#line 2870
                if ((int const   )*(*tmp___36 + (int )((unsigned char )*(scan + 1))) & 2048) {
#line 2871
                  dig = (int )*(scan + 1) - 48;
#line 2872
                  if ((unsigned int )dig < rp->regs.num_regs) {
#line 2872
                    if (*(rp->regs.start + dig) != -1) {
#line 2875
                      start = t->sub.val.sp + *(rp->regs.start + dig);
#line 2877
                      end = t->sub.val.sp + *(rp->regs.end + dig);
#line 2880
                      cp = start;
                      {
#line 2880
                      while (1) {
                        while_continue___5: /* CIL Label */ ;
#line 2880
                        if (! ((unsigned long )cp < (unsigned long )end)) {
#line 2880
                          goto while_break___5;
                        }
#line 2881
                        tmp___34 = bp;
#line 2881
                        bp ++;
#line 2881
                        *tmp___34 = *cp;
#line 2880
                        cp ++;
                      }
                      while_break___5: /* CIL Label */ ;
                      }
                    }
                  }
#line 2883
                  scan ++;
                } else {
#line 2885
                  tmp___35 = bp;
#line 2885
                  bp ++;
#line 2885
                  scan ++;
#line 2885
                  *tmp___35 = *scan;
                }
              } else
#line 2886
              if (do_flags & 16) {
#line 2888
                if ((int )*(scan + 1) == 38) {
#line 2889
                  scan ++;
                } else
#line 2888
                if ((int )*(scan + 1) == 92) {
#line 2889
                  scan ++;
                }
#line 2890
                tmp___37 = bp;
#line 2890
                bp ++;
#line 2890
                *tmp___37 = *scan;
              } else {
                {
#line 2893
                tmp___45 = strncmp((char const   *)scan, "\\\\\\&", (size_t )4);
                }
#line 2893
                if (tmp___45 == 0) {
#line 2895
                  tmp___38 = bp;
#line 2895
                  bp ++;
#line 2895
                  *tmp___38 = (char )'\\';
#line 2896
                  tmp___39 = bp;
#line 2896
                  bp ++;
#line 2896
                  *tmp___39 = (char )'&';
#line 2897
                  scan += 3;
                } else {
                  {
#line 2898
                  tmp___44 = strncmp((char const   *)scan, "\\\\&", (size_t )3);
                  }
#line 2898
                  if (tmp___44 == 0) {
#line 2900
                    tmp___40 = bp;
#line 2900
                    bp ++;
#line 2900
                    *tmp___40 = (char )'\\';
#line 2901
                    cp = matchstart;
                    {
#line 2901
                    while (1) {
                      while_continue___6: /* CIL Label */ ;
#line 2901
                      if (! ((unsigned long )cp < (unsigned long )matchend)) {
#line 2901
                        goto while_break___6;
                      }
#line 2902
                      tmp___41 = bp;
#line 2902
                      bp ++;
#line 2902
                      *tmp___41 = *cp;
#line 2901
                      cp ++;
                    }
                    while_break___6: /* CIL Label */ ;
                    }
#line 2903
                    scan += 2;
                  } else
#line 2904
                  if ((int )*(scan + 1) == 38) {
#line 2906
                    tmp___42 = bp;
#line 2906
                    bp ++;
#line 2906
                    *tmp___42 = (char )'&';
#line 2907
                    scan ++;
                  } else {
#line 2909
                    tmp___43 = bp;
#line 2909
                    bp ++;
#line 2909
                    *tmp___43 = *scan;
                  }
                }
              }
            } else {
#line 2912
              tmp___46 = bp;
#line 2912
              bp ++;
#line 2912
              *tmp___46 = *scan;
            }
          } else {
#line 2912
            tmp___46 = bp;
#line 2912
            bp ++;
#line 2912
            *tmp___46 = *scan;
          }
        } else {
#line 2912
          tmp___46 = bp;
#line 2912
          bp ++;
#line 2912
          *tmp___46 = *scan;
        }
#line 2854
        scan ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2913
      if ((unsigned long )matchstart != (unsigned long )matchend) {
#line 2914
        lastmatchnonzero = (_Bool)1;
      }
    } else {
#line 2920
      cp = matchstart;
      {
#line 2920
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2920
        if (! ((unsigned long )cp < (unsigned long )matchend)) {
#line 2920
          goto while_break___7;
        }
#line 2921
        tmp___47 = bp;
#line 2921
        bp ++;
#line 2921
        *tmp___47 = *cp;
#line 2920
        cp ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    empty: 
#line 2925
    if ((unsigned long )matchstart == (unsigned long )matchend) {
#line 2925
      if ((unsigned long )matchend < (unsigned long )(text + textlen___4)) {
#line 2926
        tmp___48 = bp;
#line 2926
        bp ++;
#line 2926
        *tmp___48 = *matchend;
#line 2927
        matchend ++;
      }
    }
#line 2929
    textlen___4 = (size_t )((text + textlen___4) - matchend);
#line 2930
    text = matchend;
#line 2932
    if (current >= how_many) {
#line 2932
      if (! global) {
#line 2935
        goto while_break___0;
      } else {
#line 2932
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 2932
    if ((long )textlen___4 <= 0L) {
#line 2932
      if ((unsigned long )matchstart == (unsigned long )matchend) {
#line 2935
        goto while_break___0;
      } else {
#line 2932
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
      {
#line 2932
      tmp___49 = research(rp, t->sub.val.sp, (int )(text - t->sub.val.sp), textlen___4,
                          1);
      }
#line 2932
      if (tmp___49 == -1) {
#line 2935
        goto while_break___0;
      }
    }
#line 2815
    current ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2938
  sofar = (int )(bp - buf___7);
#line 2939
  if (((buflen___2 - (size_t )sofar) - textlen___4) - 1UL) {
    {
#line 2940
    buflen___2 = ((size_t )sofar + textlen___4) + 2UL;
#line 2941
    tmp___50 = realloc((void *)buf___7, buflen___2);
#line 2941
    buf___7 = (char *)tmp___50;
    }
#line 2941
    if (buf___7) {
#line 2941
      tmp___54 = 1;
    } else {
      {
#line 2941
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 2941);
#line 2941
      tmp___51 = __errno_location();
#line 2941
      tmp___52 = strerror(*tmp___51);
#line 2941
      tmp___53 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2941
      r_fatal((char const   *)tmp___53, "do_sub", "buf", (long )buflen___2, tmp___52);
#line 2941
      tmp___54 = 0;
      }
    }
#line 2942
    bp = buf___7 + sofar;
  }
#line 2944
  scan = matchend;
  {
#line 2944
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2944
    if (! ((unsigned long )scan < (unsigned long )(text + textlen___4))) {
#line 2944
      goto while_break___8;
    }
#line 2945
    tmp___55 = bp;
#line 2945
    bp ++;
#line 2945
    *tmp___55 = *scan;
#line 2944
    scan ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 2946
  *bp = (char )'\000';
#line 2947
  textlen___4 = (size_t )(bp - buf___7);
#line 2949
  if ((unsigned long )mb_indices != (unsigned long )((void *)0)) {
    {
#line 2950
    free((void *)mb_indices);
    }
  }
  done: 
  {
#line 2953
  DEREF(s___0);
  }
#line 2955
  if (matches == 0) {
#line 2955
    goto _L___9;
  } else
#line 2955
  if ((flags___0 & 4U) != 0U) {
    _L___9: /* CIL Label */ 
#line 2955
    if ((unsigned long )buf___7 != (unsigned long )((void *)0)) {
      {
#line 2956
      free((void *)buf___7);
      }
    }
  }
#line 2958
  if (flags___0 & 2U) {
#line 2959
    if (matches > 0) {
      {
#line 2961
      DEREF(t);
#line 2962
      tmp___56 = make_str_node((char const   *)buf___7, textlen___4, 2);
      }
#line 2962
      return (tmp___56);
    }
#line 2966
    return (t);
  }
#line 2970
  if ((flags___0 & 4U) != 0U) {
    {
#line 2971
    DEREF(t);
    }
  } else
#line 2972
  if (matches > 0) {
    {
#line 2973
    unref(*lhs);
#line 2974
    *lhs = make_str_node((char const   *)buf___7, textlen___4, 2);
    }
  }
  {
#line 2977
  tmp___57 = (*make_number)((double )matches);
  }
#line 2977
  return (tmp___57);
}
}
#line 2983 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static NODE *make_integer(uintmax_t n ) 
{ 
  NODE *tmp___1 ;

  {
  {
#line 2986
  n = adjust_uint(n);
#line 2988
  tmp___1 = (*make_number)((double )n);
  }
#line 2988
  return (tmp___1);
}
}
#line 2993 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_lshift(int nargs ) 
{ 
  NODE *s1 ;
  NODE *s2 ;
  uintmax_t uval ;
  uintmax_t ushift ;
  uintmax_t res ;
  double val ;
  double shift ;
  STACK_ITEM *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  NODE *tmp___6 ;
  NODE *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  char *tmp___12 ;
  NODE *tmp___13 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 3000
  s2 = POP_SCALAR();
#line 3000
  tmp___1 = stack_ptr;
#line 3000
  stack_ptr --;
#line 3000
  s1 = tmp___1->rptr;
  }
  {
#line 3000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3000
    if ((unsigned int )s1->type == 5U) {
      {
#line 3000
      DEREF(s2);
#line 3000
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3000);
#line 3000
      tmp___2 = array_vname((NODE const   *)s1);
#line 3000
      tmp___3 = gettext("attempt to use array `%s\' in a scalar context");
#line 3000
      r_fatal((char const   *)tmp___3, tmp___2);
      }
    }
#line 3000
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3001
  if (do_flags & 3) {
#line 3002
    if ((s1->flags & 24U) == 0U) {
      {
#line 3003
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3003);
#line 3003
      tmp___4 = gettext("lshift: received non-numeric first argument");
#line 3003
      (*lintfunc)((char const   *)tmp___4);
      }
    }
#line 3004
    if ((s2->flags & 24U) == 0U) {
      {
#line 3005
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3005);
#line 3005
      tmp___5 = gettext("lshift: received non-numeric second argument");
#line 3005
      (*lintfunc)((char const   *)tmp___5);
      }
    }
  }
  {
#line 3007
  tmp___6 = force_number(s1);
#line 3007
  val = tmp___6->sub.val.nm.fltnum;
#line 3008
  tmp___7 = force_number(s2);
#line 3008
  shift = tmp___7->sub.val.nm.fltnum;
  }
#line 3009
  if (do_flags & 3) {
#line 3010
    if (val < (double )0) {
      {
#line 3011
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3011);
#line 3011
      tmp___8 = gettext("lshift(%f, %f): negative values will give strange results");
#line 3011
      (*lintfunc)((char const   *)tmp___8, val, shift);
      }
    } else
#line 3010
    if (shift < (double )0) {
      {
#line 3011
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3011);
#line 3011
      tmp___8 = gettext("lshift(%f, %f): negative values will give strange results");
#line 3011
      (*lintfunc)((char const   *)tmp___8, val, shift);
      }
    }
    {
#line 3012
    tmp___10 = double_to_int(val);
    }
#line 3012
    if (tmp___10 != val) {
      {
#line 3013
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3013);
#line 3013
      tmp___9 = gettext("lshift(%f, %f): fractional values will be truncated");
#line 3013
      (*lintfunc)((char const   *)tmp___9, val, shift);
      }
    } else {
      {
#line 3012
      tmp___11 = double_to_int(shift);
      }
#line 3012
      if (tmp___11 != shift) {
        {
#line 3013
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3013);
#line 3013
        tmp___9 = gettext("lshift(%f, %f): fractional values will be truncated");
#line 3013
        (*lintfunc)((char const   *)tmp___9, val, shift);
        }
      }
    }
#line 3014
    if (shift >= (double )(sizeof(uintmax_t ) * 8UL)) {
      {
#line 3015
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3015);
#line 3015
      tmp___12 = gettext("lshift(%f, %f): too large shift value will give strange results");
#line 3015
      (*lintfunc)((char const   *)tmp___12, val, shift);
      }
    }
  }
  {
#line 3018
  DEREF(s1);
#line 3019
  DEREF(s2);
#line 3021
  uval = (uintmax_t )val;
#line 3022
  ushift = (uintmax_t )shift;
#line 3024
  res = uval << ushift;
#line 3025
  tmp___13 = make_integer(res);
  }
#line 3025
  return (tmp___13);
}
}
#line 3030 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_rshift(int nargs ) 
{ 
  NODE *s1 ;
  NODE *s2 ;
  uintmax_t uval ;
  uintmax_t ushift ;
  uintmax_t res ;
  double val ;
  double shift ;
  STACK_ITEM *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  NODE *tmp___6 ;
  NODE *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  char *tmp___12 ;
  NODE *tmp___13 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 3037
  s2 = POP_SCALAR();
#line 3037
  tmp___1 = stack_ptr;
#line 3037
  stack_ptr --;
#line 3037
  s1 = tmp___1->rptr;
  }
  {
#line 3037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3037
    if ((unsigned int )s1->type == 5U) {
      {
#line 3037
      DEREF(s2);
#line 3037
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3037);
#line 3037
      tmp___2 = array_vname((NODE const   *)s1);
#line 3037
      tmp___3 = gettext("attempt to use array `%s\' in a scalar context");
#line 3037
      r_fatal((char const   *)tmp___3, tmp___2);
      }
    }
#line 3037
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3038
  if (do_flags & 3) {
#line 3039
    if ((s1->flags & 24U) == 0U) {
      {
#line 3040
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3040);
#line 3040
      tmp___4 = gettext("rshift: received non-numeric first argument");
#line 3040
      (*lintfunc)((char const   *)tmp___4);
      }
    }
#line 3041
    if ((s2->flags & 24U) == 0U) {
      {
#line 3042
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3042);
#line 3042
      tmp___5 = gettext("rshift: received non-numeric second argument");
#line 3042
      (*lintfunc)((char const   *)tmp___5);
      }
    }
  }
  {
#line 3044
  tmp___6 = force_number(s1);
#line 3044
  val = tmp___6->sub.val.nm.fltnum;
#line 3045
  tmp___7 = force_number(s2);
#line 3045
  shift = tmp___7->sub.val.nm.fltnum;
  }
#line 3046
  if (do_flags & 3) {
#line 3047
    if (val < (double )0) {
      {
#line 3048
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3048);
#line 3048
      tmp___8 = gettext("rshift(%f, %f): negative values will give strange results");
#line 3048
      (*lintfunc)((char const   *)tmp___8, val, shift);
      }
    } else
#line 3047
    if (shift < (double )0) {
      {
#line 3048
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3048);
#line 3048
      tmp___8 = gettext("rshift(%f, %f): negative values will give strange results");
#line 3048
      (*lintfunc)((char const   *)tmp___8, val, shift);
      }
    }
    {
#line 3049
    tmp___10 = double_to_int(val);
    }
#line 3049
    if (tmp___10 != val) {
      {
#line 3050
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3050);
#line 3050
      tmp___9 = gettext("rshift(%f, %f): fractional values will be truncated");
#line 3050
      (*lintfunc)((char const   *)tmp___9, val, shift);
      }
    } else {
      {
#line 3049
      tmp___11 = double_to_int(shift);
      }
#line 3049
      if (tmp___11 != shift) {
        {
#line 3050
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3050);
#line 3050
        tmp___9 = gettext("rshift(%f, %f): fractional values will be truncated");
#line 3050
        (*lintfunc)((char const   *)tmp___9, val, shift);
        }
      }
    }
#line 3051
    if (shift >= (double )(sizeof(uintmax_t ) * 8UL)) {
      {
#line 3052
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3052);
#line 3052
      tmp___12 = gettext("rshift(%f, %f): too large shift value will give strange results");
#line 3052
      (*lintfunc)((char const   *)tmp___12, val, shift);
      }
    }
  }
  {
#line 3055
  DEREF(s1);
#line 3056
  DEREF(s2);
#line 3058
  uval = (uintmax_t )val;
#line 3059
  ushift = (uintmax_t )shift;
#line 3061
  res = uval >> ushift;
#line 3062
  tmp___13 = make_integer(res);
  }
#line 3062
  return (tmp___13);
}
}
#line 3067 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_and(int nargs ) 
{ 
  NODE *s1 ;
  uintmax_t res ;
  uintmax_t uval ;
  double val ;
  int i___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  char *tmp___4 ;
  NODE *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 3075
  res = (uintmax_t )(~ 0);
#line 3076
  if (nargs < 2) {
    {
#line 3077
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3077);
#line 3077
    tmp___1 = gettext("and: called with less than two arguments");
#line 3077
    r_fatal((char const   *)tmp___1);
    }
  }
#line 3079
  i___0 = 1;
  {
#line 3079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3079
    if (! (nargs > 0)) {
#line 3079
      goto while_break;
    }
    {
#line 3080
    s1 = POP_SCALAR();
    }
#line 3081
    if (do_flags & 3) {
#line 3081
      if ((s1->flags & 24U) == 0U) {
        {
#line 3082
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3082);
#line 3082
        tmp___2 = gettext("and: argument %d is non-numeric");
#line 3082
        (*lintfunc)((char const   *)tmp___2, i___0);
        }
      }
    }
    {
#line 3084
    tmp___3 = force_number(s1);
#line 3084
    val = tmp___3->sub.val.nm.fltnum;
    }
#line 3085
    if (do_flags & 3) {
#line 3085
      if (val < (double )0) {
        {
#line 3086
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3086);
#line 3086
        tmp___4 = gettext("and: argument %d negative value %g will give strange results");
#line 3086
        (*lintfunc)((char const   *)tmp___4, i___0, val);
        }
      }
    }
    {
#line 3088
    uval = (uintmax_t )val;
#line 3089
    res &= uval;
#line 3091
    DEREF(s1);
#line 3079
    nargs --;
#line 3079
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3094
  tmp___5 = make_integer(res);
  }
#line 3094
  return (tmp___5);
}
}
#line 3099 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_or(int nargs ) 
{ 
  NODE *s1 ;
  uintmax_t res ;
  uintmax_t uval ;
  double val ;
  int i___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  char *tmp___4 ;
  NODE *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 3107
  res = (uintmax_t )0;
#line 3108
  if (nargs < 2) {
    {
#line 3109
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3109);
#line 3109
    tmp___1 = gettext("or: called with less than two arguments");
#line 3109
    r_fatal((char const   *)tmp___1);
    }
  }
#line 3111
  i___0 = 1;
  {
#line 3111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3111
    if (! (nargs > 0)) {
#line 3111
      goto while_break;
    }
    {
#line 3112
    s1 = POP_SCALAR();
    }
#line 3113
    if (do_flags & 3) {
#line 3113
      if ((s1->flags & 24U) == 0U) {
        {
#line 3114
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3114);
#line 3114
        tmp___2 = gettext("or: argument %d is non-numeric");
#line 3114
        (*lintfunc)((char const   *)tmp___2, i___0);
        }
      }
    }
    {
#line 3116
    tmp___3 = force_number(s1);
#line 3116
    val = tmp___3->sub.val.nm.fltnum;
    }
#line 3117
    if (do_flags & 3) {
#line 3117
      if (val < (double )0) {
        {
#line 3118
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3118);
#line 3118
        tmp___4 = gettext("or: argument %d negative value %g will give strange results");
#line 3118
        (*lintfunc)((char const   *)tmp___4, i___0, val);
        }
      }
    }
    {
#line 3120
    uval = (uintmax_t )val;
#line 3121
    res |= uval;
#line 3123
    DEREF(s1);
#line 3111
    nargs --;
#line 3111
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3126
  tmp___5 = make_integer(res);
  }
#line 3126
  return (tmp___5);
}
}
#line 3131 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_xor(int nargs ) 
{ 
  NODE *s1 ;
  uintmax_t res ;
  uintmax_t uval ;
  double val ;
  int i___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  char *tmp___4 ;
  NODE *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 3139
  if (nargs < 2) {
    {
#line 3140
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3140);
#line 3140
    tmp___1 = gettext("xor: called with less than two arguments");
#line 3140
    r_fatal((char const   *)tmp___1);
    }
  }
#line 3142
  res = (uintmax_t )0;
#line 3143
  i___0 = 1;
  {
#line 3143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3143
    if (! (nargs > 0)) {
#line 3143
      goto while_break;
    }
    {
#line 3144
    s1 = POP_SCALAR();
    }
#line 3145
    if (do_flags & 3) {
#line 3145
      if ((s1->flags & 24U) == 0U) {
        {
#line 3146
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3146);
#line 3146
        tmp___2 = gettext("xor: argument %d is non-numeric");
#line 3146
        (*lintfunc)((char const   *)tmp___2, i___0);
        }
      }
    }
    {
#line 3148
    tmp___3 = force_number(s1);
#line 3148
    val = tmp___3->sub.val.nm.fltnum;
    }
#line 3149
    if (do_flags & 3) {
#line 3149
      if (val < (double )0) {
        {
#line 3150
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3150);
#line 3150
        tmp___4 = gettext("xor: argument %d negative value %g will give strange results");
#line 3150
        (*lintfunc)((char const   *)tmp___4, i___0, val);
        }
      }
    }
#line 3152
    uval = (uintmax_t )val;
#line 3153
    if (i___0 == 1) {
#line 3154
      res = uval;
    } else {
#line 3156
      res ^= uval;
    }
    {
#line 3158
    DEREF(s1);
#line 3143
    nargs --;
#line 3143
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3161
  tmp___5 = make_integer(res);
  }
#line 3161
  return (tmp___5);
}
}
#line 3166 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_compl(int nargs ) 
{ 
  NODE *tmp___1 ;
  double d ;
  uintmax_t uval ;
  char *tmp___2 ;
  NODE *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  double tmp___6 ;
  NODE *tmp___7 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 3173
  tmp___1 = POP_SCALAR();
  }
#line 3174
  if (do_flags & 3) {
#line 3174
    if ((tmp___1->flags & 24U) == 0U) {
      {
#line 3175
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3175);
#line 3175
      tmp___2 = gettext("compl: received non-numeric argument");
#line 3175
      (*lintfunc)((char const   *)tmp___2);
      }
    }
  }
  {
#line 3176
  tmp___3 = force_number(tmp___1);
#line 3176
  d = tmp___3->sub.val.nm.fltnum;
#line 3177
  DEREF(tmp___1);
  }
#line 3179
  if (do_flags & 3) {
#line 3180
    if (d < (double )0) {
      {
#line 3181
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3181);
#line 3181
      tmp___4 = gettext("compl(%f): negative value will give strange results");
#line 3181
      (*lintfunc)((char const   *)tmp___4, d);
      }
    }
    {
#line 3182
    tmp___6 = double_to_int(d);
    }
#line 3182
    if (tmp___6 != d) {
      {
#line 3183
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3183);
#line 3183
      tmp___5 = gettext("compl(%f): fractional value will be truncated");
#line 3183
      (*lintfunc)((char const   *)tmp___5, d);
      }
    }
  }
  {
#line 3186
  uval = (uintmax_t )d;
#line 3187
  uval = ~ uval;
#line 3188
  tmp___7 = make_integer(uval);
  }
#line 3188
  return (tmp___7);
}
}
#line 3193 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_strtonum(int nargs ) 
{ 
  NODE *tmp___1 ;
  double d ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  int tmp___4 ;
  NODE *tmp___5 ;

  {
  {
#line 3199
  tmp___1 = POP_SCALAR();
  }
#line 3200
  if ((tmp___1->flags & 24U) != 0U) {
    {
#line 3201
    tmp___2 = force_number(tmp___1);
#line 3201
    d = tmp___2->sub.val.nm.fltnum;
    }
  } else {
    {
#line 3202
    tmp___4 = get_numbase((char const   *)tmp___1->sub.val.sp, (_Bool )use_lc_numeric);
    }
#line 3202
    if (tmp___4 != 10) {
      {
#line 3203
      d = nondec2awknum(tmp___1->sub.val.sp, tmp___1->sub.val.slen);
      }
    } else {
      {
#line 3205
      tmp___3 = force_number(tmp___1);
#line 3205
      d = tmp___3->sub.val.nm.fltnum;
      }
    }
  }
  {
#line 3207
  DEREF(tmp___1);
#line 3208
  tmp___5 = (*make_number)(d);
  }
#line 3208
  return (tmp___5);
}
}
#line 3219 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
double nondec2awknum(char *str , size_t len ) 
{ 
  double retval ;
  char save ;
  short val ;
  char *start ;
  unsigned short const   **tmp___1 ;

  {
#line 3222
  retval = 0.0;
#line 3225
  start = str;
#line 3227
  if ((int )*str == 48) {
#line 3227
    if ((int )*(str + 1) == 120) {
#line 3227
      goto _L___0;
    } else
#line 3227
    if ((int )*(str + 1) == 88) {
      _L___0: /* CIL Label */ 
#line 3232
      if (len <= 2UL) {
#line 3233
        return (0.0);
      }
#line 3235
      str += 2;
#line 3235
      len -= 2UL;
      {
#line 3235
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3235
        if (! (len > 0UL)) {
#line 3235
          goto while_break;
        }
        {
#line 3246
        if ((int )*str == 57) {
#line 3246
          goto case_57;
        }
#line 3246
        if ((int )*str == 56) {
#line 3246
          goto case_57;
        }
#line 3246
        if ((int )*str == 55) {
#line 3246
          goto case_57;
        }
#line 3246
        if ((int )*str == 54) {
#line 3246
          goto case_57;
        }
#line 3246
        if ((int )*str == 53) {
#line 3246
          goto case_57;
        }
#line 3246
        if ((int )*str == 52) {
#line 3246
          goto case_57;
        }
#line 3246
        if ((int )*str == 51) {
#line 3246
          goto case_57;
        }
#line 3246
        if ((int )*str == 50) {
#line 3246
          goto case_57;
        }
#line 3246
        if ((int )*str == 49) {
#line 3246
          goto case_57;
        }
#line 3246
        if ((int )*str == 48) {
#line 3246
          goto case_57;
        }
#line 3254
        if ((int )*str == 102) {
#line 3254
          goto case_102;
        }
#line 3254
        if ((int )*str == 101) {
#line 3254
          goto case_102;
        }
#line 3254
        if ((int )*str == 100) {
#line 3254
          goto case_102;
        }
#line 3254
        if ((int )*str == 99) {
#line 3254
          goto case_102;
        }
#line 3254
        if ((int )*str == 98) {
#line 3254
          goto case_102;
        }
#line 3254
        if ((int )*str == 97) {
#line 3254
          goto case_102;
        }
#line 3262
        if ((int )*str == 70) {
#line 3262
          goto case_70;
        }
#line 3262
        if ((int )*str == 69) {
#line 3262
          goto case_70;
        }
#line 3262
        if ((int )*str == 68) {
#line 3262
          goto case_70;
        }
#line 3262
        if ((int )*str == 67) {
#line 3262
          goto case_70;
        }
#line 3262
        if ((int )*str == 66) {
#line 3262
          goto case_70;
        }
#line 3262
        if ((int )*str == 65) {
#line 3262
          goto case_70;
        }
#line 3265
        goto switch_default;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 3247
        val = (short )((int )*str - 48);
#line 3248
        goto switch_break;
        case_102: /* CIL Label */ 
        case_101: /* CIL Label */ 
        case_100: /* CIL Label */ 
        case_99: /* CIL Label */ 
        case_98: /* CIL Label */ 
        case_97: /* CIL Label */ 
#line 3255
        val = (short )(((int )*str - 97) + 10);
#line 3256
        goto switch_break;
        case_70: /* CIL Label */ 
        case_69: /* CIL Label */ 
        case_68: /* CIL Label */ 
        case_67: /* CIL Label */ 
        case_66: /* CIL Label */ 
        case_65: /* CIL Label */ 
#line 3263
        val = (short )(((int )*str - 65) + 10);
#line 3264
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 3266
        goto done;
        switch_break: /* CIL Label */ ;
        }
#line 3268
        retval = retval * (double )16 + (double )val;
#line 3235
        len --;
#line 3235
        str ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 3227
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3270
  if ((int )*str == 48) {
    {
#line 3271
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3271
      if (! (len > 0UL)) {
#line 3271
        goto while_break___0;
      }
      {
#line 3272
      tmp___1 = __ctype_b_loc();
      }
#line 3272
      if ((int const   )*(*tmp___1 + (int )((unsigned char )*str)) & 2048) {
#line 3274
        if ((int )*str == 56) {
#line 3275
          str = start;
#line 3276
          goto decimal;
        } else
#line 3274
        if ((int )*str == 57) {
#line 3275
          str = start;
#line 3276
          goto decimal;
        }
      } else {
#line 3273
        goto done;
      }
#line 3278
      retval = retval * (double )8 + (double )((int )*str - 48);
#line 3279
      str ++;
#line 3271
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    decimal: 
    {
#line 3283
    save = *(str + len);
#line 3284
    retval = strtod((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0));
#line 3285
    *(str + len) = save;
    }
  }
  done: 
#line 3288
  return (retval);
}
}
#line 3298
static int localecategory_from_argument(NODE *t ) ;
#line 3298 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static struct category_table  const  cat_tab[7]  = {      {6, "LC_ALL"}, 
        {3, "LC_COLLATE"}, 
        {0, "LC_CTYPE"}, 
        {5, "LC_MESSAGES"}, 
        {4, "LC_MONETARY"}, 
        {1, "LC_NUMERIC"}, 
        {2, "LC_TIME"}};
#line 3295 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static int localecategory_from_argument(NODE *t ) 
{ 
  int low ;
  int high ;
  int i___0 ;
  int mid ;
  char *category ;
  int lc_cat ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 3328
  if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 3331
    lc_cat = -1;
#line 3333
    category = t->sub.val.sp;
#line 3336
    low = 0;
#line 3337
    high = (int )(sizeof(cat_tab) / sizeof(cat_tab[0]) - 1UL);
    {
#line 3338
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3338
      if (! (low <= high)) {
#line 3338
        goto while_break;
      }
      {
#line 3339
      mid = (low + high) / 2;
#line 3340
      i___0 = strcmp((char const   *)category, (char const   *)cat_tab[mid].name);
      }
#line 3342
      if (i___0 < 0) {
#line 3343
        high = mid - 1;
      } else
#line 3344
      if (i___0 > 0) {
#line 3345
        low = mid + 1;
      } else {
#line 3347
        lc_cat = (int )cat_tab[mid].val;
#line 3348
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3351
    if (lc_cat == -1) {
      {
#line 3352
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c", 3352);
#line 3352
      tmp___1 = gettext("dcgettext: `%s\' is not a valid locale category");
#line 3352
      r_fatal((char const   *)tmp___1, category);
      }
    }
#line 3354
    return (lc_cat);
  } else {
#line 3356
    return (5);
  }
}
}
#line 3370 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_dcgettext(int nargs ) 
{ 
  NODE *tmp___1 ;
  NODE *t1 ;
  NODE *t2 ;
  char *string ;
  char *the_result ;
  int lc_cat ;
  char *domain ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  size_t tmp___5 ;
  NODE *tmp___6 ;

  {
#line 3373
  t2 = (NODE *)((void *)0);
#line 3380
  if (nargs == 3) {
    {
#line 3381
    tmp___2 = POP_SCALAR();
#line 3381
    tmp___1 = force_string(tmp___2);
#line 3382
    lc_cat = localecategory_from_argument(tmp___1);
#line 3383
    DEREF(tmp___1);
    }
  } else {
#line 3385
    lc_cat = 5;
  }
#line 3387
  if (nargs >= 2) {
    {
#line 3388
    tmp___3 = POP_SCALAR();
#line 3388
    t2 = force_string(tmp___3);
#line 3389
    domain = t2->sub.val.sp;
    }
  } else {
#line 3391
    domain = TEXTDOMAIN;
  }
  {
#line 3403
  tmp___4 = POP_SCALAR();
#line 3403
  t1 = force_string(tmp___4);
#line 3404
  string = t1->sub.val.sp;
#line 3407
  the_result = dcgettext((char const   *)domain, (char const   *)string, lc_cat);
  }
#line 3408
  if ((unsigned long )t2 != (unsigned long )((void *)0)) {
    {
#line 3409
    DEREF(t2);
    }
  }
  {
#line 3413
  DEREF(t1);
#line 3414
  tmp___5 = strlen((char const   *)the_result);
#line 3414
  tmp___6 = make_str_node((char const   *)the_result, tmp___5, 0);
  }
#line 3414
  return (tmp___6);
}
}
#line 3418 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_dcngettext(int nargs ) 
{ 
  NODE *tmp___1 ;
  NODE *t1 ;
  NODE *t2 ;
  NODE *t3 ;
  char *string1 ;
  char *string2 ;
  unsigned long number ;
  double d ;
  char *the_result ;
  int lc_cat ;
  char *domain ;
  NODE *tmp___2 ;
  NODE *tmp___3 ;
  NODE *tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  NODE *tmp___9 ;
  NODE *tmp___10 ;
  size_t tmp___11 ;
  NODE *tmp___12 ;

  {
#line 3431
  if (nargs == 5) {
    {
#line 3432
    tmp___2 = POP_SCALAR();
#line 3432
    tmp___1 = force_string(tmp___2);
#line 3433
    lc_cat = localecategory_from_argument(tmp___1);
#line 3434
    DEREF(tmp___1);
    }
  } else {
#line 3436
    lc_cat = 5;
  }
#line 3438
  t3 = (NODE *)((void *)0);
#line 3439
  if (nargs >= 4) {
    {
#line 3440
    tmp___3 = POP_SCALAR();
#line 3440
    t3 = force_string(tmp___3);
#line 3441
    domain = t3->sub.val.sp;
    }
  } else {
#line 3443
    domain = TEXTDOMAIN;
  }
  {
#line 3455
  tmp___4 = POP_SCALAR();
#line 3455
  t2 = force_number(tmp___4);
  }
#line 3456
  if (t2->flags & 2048U) {
    {
#line 3456
    tmp___5 = mpfr_get_d((mpfr_srcptr )(t2->sub.val.nm.mpnum), ROUND_MODE);
#line 3456
    d = tmp___5;
    }
  } else {
#line 3456
    if (t2->flags & 4096U) {
      {
#line 3456
      tmp___6 = __gmpz_get_d((mpz_srcptr )(t2->sub.val.nm.mpi));
#line 3456
      tmp___7 = tmp___6;
      }
    } else {
#line 3456
      tmp___7 = t2->sub.val.nm.fltnum;
    }
#line 3456
    d = tmp___7;
  }
  {
#line 3457
  DEREF(t2);
#line 3459
  tmp___8 = double_to_int(d);
#line 3459
  number = (unsigned long )tmp___8;
#line 3460
  tmp___9 = POP_SCALAR();
#line 3460
  t2 = force_string(tmp___9);
#line 3461
  string2 = t2->sub.val.sp;
#line 3462
  tmp___10 = POP_SCALAR();
#line 3462
  t1 = force_string(tmp___10);
#line 3463
  string1 = t1->sub.val.sp;
#line 3467
  the_result = dcngettext((char const   *)domain, (char const   *)string1, (char const   *)string2,
                          number, lc_cat);
  }
#line 3468
  if ((unsigned long )t3 != (unsigned long )((void *)0)) {
    {
#line 3469
    DEREF(t3);
    }
  }
  {
#line 3473
  DEREF(t1);
#line 3474
  DEREF(t2);
#line 3475
  tmp___11 = strlen((char const   *)the_result);
#line 3475
  tmp___12 = make_str_node((char const   *)the_result, tmp___11, 0);
  }
#line 3475
  return (tmp___12);
}
}
#line 3489 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
NODE *do_bindtextdomain(int nargs ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  char const   *directory ;
  char const   *domain ;
  char const   *the_result ;
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  NODE *tmp___5 ;

  {
#line 3496
  t2 = (NODE *)((void *)0);
#line 3496
  t1 = t2;
#line 3498
  directory = (char const   *)((void *)0);
#line 3499
  domain = (char const   *)TEXTDOMAIN;
#line 3501
  if (nargs == 2) {
    {
#line 3502
    tmp___1 = POP_SCALAR();
#line 3502
    t2 = force_string(tmp___1);
#line 3503
    domain = (char const   *)t2->sub.val.sp;
    }
  }
  {
#line 3507
  tmp___2 = POP_SCALAR();
#line 3507
  t1 = force_string(tmp___2);
  }
#line 3508
  if (t1->sub.val.slen > 0UL) {
#line 3509
    directory = (char const   *)t1->sub.val.sp;
  }
  {
#line 3511
  tmp___3 = bindtextdomain(domain, directory);
#line 3511
  the_result = (char const   *)tmp___3;
#line 3513
  DEREF(t1);
  }
#line 3514
  if ((unsigned long )t2 != (unsigned long )((void *)0)) {
    {
#line 3515
    DEREF(t2);
    }
  }
  {
#line 3517
  tmp___4 = strlen(the_result);
#line 3517
  tmp___5 = make_str_node(the_result, tmp___4, 0);
  }
#line 3517
  return (tmp___5);
}
}
#line 3523 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static size_t mbc_byte_count(char const   *ptr , size_t numchars ) 
{ 
  mbstate_t cur_state ;
  size_t sum ;
  int mb_len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 3528
  sum = (size_t )0;
#line 3531
  memset((void *)(& cur_state), 0, sizeof(cur_state));
#line 3534
  tmp___1 = mbrlen((char const   */* __restrict  */)ptr, numchars * (size_t )gawk_mb_cur_max,
                   (mbstate_t */* __restrict  */)(& cur_state));
#line 3534
  mb_len = (int )tmp___1;
  }
#line 3535
  if (mb_len <= 0) {
#line 3536
    return (numchars);
  }
  {
#line 3538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3538
    if (! (numchars > 0UL)) {
#line 3538
      goto while_break;
    }
    {
#line 3539
    tmp___2 = mbrlen((char const   */* __restrict  */)ptr, numchars * (size_t )gawk_mb_cur_max,
                     (mbstate_t */* __restrict  */)(& cur_state));
#line 3539
    mb_len = (int )tmp___2;
    }
#line 3540
    if (mb_len <= 0) {
#line 3541
      goto while_break;
    }
#line 3542
    sum += (size_t )mb_len;
#line 3543
    ptr += mb_len;
#line 3538
    numchars --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3546
  return (sum);
}
}
#line 3554 "/home/wslee/gnu_benchmarks/gawk-4.1.0/builtin.c"
static size_t mbc_char_count(char const   *ptr , size_t numbytes ) 
{ 
  mbstate_t cur_state ;
  size_t sum ;
  int mb_len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
#line 3559
  sum = (size_t )0;
#line 3562
  if (gawk_mb_cur_max == 1) {
#line 3563
    return (numbytes);
  }
  {
#line 3565
  memset((void *)(& cur_state), 0, sizeof(cur_state));
#line 3567
  tmp___1 = mbrlen((char const   */* __restrict  */)ptr, numbytes * (size_t )gawk_mb_cur_max,
                   (mbstate_t */* __restrict  */)(& cur_state));
#line 3567
  mb_len = (int )tmp___1;
  }
#line 3568
  if (mb_len <= 0) {
#line 3569
    return (numbytes);
  }
  {
#line 3571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3571
    if (! (numbytes > 0UL)) {
#line 3571
      goto while_break;
    }
    {
#line 3572
    tmp___2 = mbrlen((char const   */* __restrict  */)ptr, numbytes * (size_t )gawk_mb_cur_max,
                     (mbstate_t */* __restrict  */)(& cur_state));
#line 3572
    mb_len = (int )tmp___2;
    }
#line 3573
    if (mb_len <= 0) {
#line 3574
      goto while_break;
    }
#line 3575
    sum ++;
#line 3576
    ptr += mb_len;
#line 3571
    numbytes --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3579
  return (sum);
}
}
#line 562 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 145 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 1357 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
NODE *do_asort(int nargs ) ;
#line 1358
NODE *do_asorti(int nargs ) ;
#line 1367
NODE *stopme(int nargs  __attribute__((__unused__)) ) ;
#line 37 "awkgram.y"
static void ( /* format attribute */  yyerror)(char const   *m  , ...) ;
#line 38
static void ( /* format attribute */  error_ln)(int line , char const   *m  , ...) ;
#line 39
static void ( /* format attribute */  lintwarn_ln)(int line , char const   *mesg 
                                                   , ...) ;
#line 40
static void ( /* format attribute */  warning_ln)(int line , char const   *mesg  , ...) ;
#line 41
static char *get_src_buf(void) ;
#line 42
static int yylex(void) ;
#line 43
int yyparse(void) ;
#line 44
static INSTRUCTION *snode(INSTRUCTION *subn , INSTRUCTION *r ) ;
#line 45
static char **check_params(char *fname , int pcount , INSTRUCTION *list ) ;
#line 46
static int install_function(char *fname , INSTRUCTION *fi , INSTRUCTION *plist ) ;
#line 47
static NODE *mk_rexp(INSTRUCTION *list ) ;
#line 48
static void param_sanity(INSTRUCTION *arglist ) ;
#line 49
static int parms_shadow(INSTRUCTION *pc , _Bool *shadow ) ;
#line 51
static int isnoeffect(OPCODE type ) ;
#line 53
static INSTRUCTION *make_assignable(INSTRUCTION *ip ) ;
#line 54
static void dumpintlstr(char const   *str , size_t len ) ;
#line 55
static void dumpintlstr2(char const   *str1 , size_t len1 , char const   *str2 , size_t len2 ) ;
#line 56
static int include_source(INSTRUCTION *file ) ;
#line 57
static int load_library(INSTRUCTION *file ) ;
#line 58
static void next_sourcefile(void) ;
#line 59
static char *tokexpand(void) ;
#line 60
static _Bool is_deferred_variable(char const   *name ) ;
#line 64
static INSTRUCTION *mk_program(void) ;
#line 65
static INSTRUCTION *append_rule(INSTRUCTION *pattern , INSTRUCTION *action ) ;
#line 66
static INSTRUCTION *mk_function(INSTRUCTION *fi , INSTRUCTION *def ) ;
#line 67
static INSTRUCTION *mk_condition(INSTRUCTION *cond , INSTRUCTION *ifp , INSTRUCTION *true_branch ,
                                 INSTRUCTION *elsep , INSTRUCTION *false_branch ) ;
#line 69
static INSTRUCTION *mk_expression_list(INSTRUCTION *list , INSTRUCTION *s1 ) ;
#line 70
static INSTRUCTION *mk_for_loop(INSTRUCTION *forp , INSTRUCTION *init , INSTRUCTION *cond ,
                                INSTRUCTION *incr , INSTRUCTION *body ) ;
#line 72
static void fix_break_continue(INSTRUCTION *list , INSTRUCTION *b_target , INSTRUCTION *c_target ) ;
#line 73
static INSTRUCTION *mk_binary(INSTRUCTION *s1 , INSTRUCTION *s2 , INSTRUCTION *op ) ;
#line 74
static INSTRUCTION *mk_boolean(INSTRUCTION *left , INSTRUCTION *right , INSTRUCTION *op ) ;
#line 75
static INSTRUCTION *mk_assignment(INSTRUCTION *lhs , INSTRUCTION *rhs , INSTRUCTION *op ) ;
#line 76
static INSTRUCTION *mk_getline(INSTRUCTION *op , INSTRUCTION *var , INSTRUCTION *redir ,
                               int redirtype ) ;
#line 77
static NODE *make_regnode(int type , NODE *exp___0 ) ;
#line 78
static int count_expressions(INSTRUCTION **list , _Bool isarg ) ;
#line 79
static INSTRUCTION *optimize_assignment(INSTRUCTION *exp___0 ) ;
#line 80
static void add_lint(INSTRUCTION *list , LINTTYPE linttype ) ;
#line 82
static void process_deferred(void) ;
#line 85
static void func_use(char const   *name , enum defref how ) ;
#line 86
static void check_funcs(void) ;
#line 88
static ssize_t read_one_line(int fd , void *buffer___0 , size_t count ) ;
#line 89
static int one_line_close(int fd ) ;
#line 91 "awkgram.y"
static _Bool want_source  =    (_Bool)0;
#line 92 "awkgram.y"
static _Bool want_regexp  =    (_Bool)0;
#line 93 "awkgram.y"
static char *in_function  ;
#line 94 "awkgram.y"
static _Bool symtab_used  =    (_Bool)0;
#line 95 "awkgram.y"
static int rule  =    0;
#line 97 "awkgram.y"
char const   * const  ruletab[6]  = {      (char const   */* const  */)"?",      (char const   */* const  */)"BEGIN",      (char const   */* const  */)"Rule",      (char const   */* const  */)"END", 
        (char const   */* const  */)"BEGINFILE",      (char const   */* const  */)"ENDFILE"};
#line 106 "awkgram.y"
static _Bool in_print  =    (_Bool)0;
#line 107 "awkgram.y"
static int in_parens  =    0;
#line 108 "awkgram.y"
static int sub_counter  =    0;
#line 109 "awkgram.y"
static char *lexptr___1  =    (char *)((void *)0);
#line 110 "awkgram.y"
static char *lexend___0  ;
#line 111 "awkgram.y"
static char *lexptr_begin___0  ;
#line 112 "awkgram.y"
static char *lexeme  ;
#line 113 "awkgram.y"
static _Bool lexeof  ;
#line 114 "awkgram.y"
static char *thisline  =    (char *)((void *)0);
#line 115 "awkgram.y"
static int in_braces  =    0;
#line 116 "awkgram.y"
static int lastline  =    0;
#line 117 "awkgram.y"
static int firstline  =    0;
#line 118 "awkgram.y"
static SRCFILE *sourcefile  =    (SRCFILE *)((void *)0);
#line 119 "awkgram.y"
static int lasttok___0  =    0;
#line 120 "awkgram.y"
static _Bool eof_warned  =    (_Bool)0;
#line 121 "awkgram.y"
static int break_allowed  ;
#line 122 "awkgram.y"
static int continue_allowed  ;
#line 128 "awkgram.y"
static char *tokstart  =    (char *)((void *)0);
#line 129 "awkgram.y"
static char *tok___0  =    (char *)((void *)0);
#line 130 "awkgram.y"
static char *tokend  ;
#line 131 "awkgram.y"
static int errcount___0  =    0;
#line 140 "awkgram.y"
static INSTRUCTION *rule_block[sizeof(ruletab)]  ;
#line 142 "awkgram.y"
static INSTRUCTION *ip_rec  ;
#line 143 "awkgram.y"
static INSTRUCTION *ip_newfile  ;
#line 144 "awkgram.y"
static INSTRUCTION *ip_atexit  =    (INSTRUCTION *)((void *)0);
#line 145 "awkgram.y"
static INSTRUCTION *ip_end  ;
#line 146 "awkgram.y"
static INSTRUCTION *ip_endfile  ;
#line 147 "awkgram.y"
static INSTRUCTION *ip_beginfile  ;
#line 149
__inline static INSTRUCTION *list_create(INSTRUCTION *x ) ;
#line 150
__inline static INSTRUCTION *list_append(INSTRUCTION *l , INSTRUCTION *x ) ;
#line 151
__inline static INSTRUCTION *list_prepend(INSTRUCTION *l , INSTRUCTION *x ) ;
#line 152
__inline static INSTRUCTION *list_merge(INSTRUCTION *l1 , INSTRUCTION *l2 ) ;
#line 350 "awkgram.c"
INSTRUCTION *yylval  ;
#line 619 "awkgram.c"
static yytype_uint8 const   yytranslate___0[309]  = 
#line 619
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )63,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )62,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )60,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )59,      (yytype_uint8 const   )2,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )54,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )2,      (yytype_uint8 const   )57,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )71,      (yytype_uint8 const   )65,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )73,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )64};
#line 819 "awkgram.c"
static yytype_uint8 const   yyr1___0[189]  = 
#line 819
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )76,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )86,      (yytype_uint8 const   )85,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )88,      (yytype_uint8 const   )88,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )93,      (yytype_uint8 const   )95,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )93,      (yytype_uint8 const   )96,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )97,      (yytype_uint8 const   )97,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )99,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )104,      (yytype_uint8 const   )104,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )108,      (yytype_uint8 const   )108,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )109,      (yytype_uint8 const   )109,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )110,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )112,      (yytype_uint8 const   )112,      (yytype_uint8 const   )112,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )112,      (yytype_uint8 const   )112,      (yytype_uint8 const   )113,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )113,      (yytype_uint8 const   )113,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )113,      (yytype_uint8 const   )114,      (yytype_uint8 const   )114, 
        (yytype_uint8 const   )114,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )116, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )117,      (yytype_uint8 const   )117, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )119,      (yytype_uint8 const   )119,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )119,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )121,      (yytype_uint8 const   )122,      (yytype_uint8 const   )123, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125, 
        (yytype_uint8 const   )125,      (yytype_uint8 const   )126,      (yytype_uint8 const   )127,      (yytype_uint8 const   )128, 
        (yytype_uint8 const   )128,      (yytype_uint8 const   )129,      (yytype_uint8 const   )130,      (yytype_uint8 const   )130, 
        (yytype_uint8 const   )131,      (yytype_uint8 const   )131,      (yytype_uint8 const   )132,      (yytype_uint8 const   )132, 
        (yytype_uint8 const   )132,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )136,      (yytype_uint8 const   )136,      (yytype_uint8 const   )137,      (yytype_uint8 const   )138, 
        (yytype_uint8 const   )139};
#line 843 "awkgram.c"
static yytype_uint8 const   yyr2___0[189]  = 
#line 843
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )9,      (yytype_uint8 const   )6,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )12,      (yytype_uint8 const   )11,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )6,      (yytype_uint8 const   )9,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2};
#line 869 "awkgram.c"
static yytype_uint8 const   yydefact___0[335]  = 
#line 869
  {      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )174,      (yytype_uint8 const   )156,      (yytype_uint8 const   )157, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )163,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )151,      (yytype_uint8 const   )5,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )146, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )117, 
        (yytype_uint8 const   )125,      (yytype_uint8 const   )126,      (yytype_uint8 const   )128,      (yytype_uint8 const   )152, 
        (yytype_uint8 const   )160,      (yytype_uint8 const   )176,      (yytype_uint8 const   )153,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )171,      (yytype_uint8 const   )0,      (yytype_uint8 const   )175, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )26,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )28,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )164,      (yytype_uint8 const   )154,      (yytype_uint8 const   )155,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )159,      (yytype_uint8 const   )153, 
        (yytype_uint8 const   )158,      (yytype_uint8 const   )147,      (yytype_uint8 const   )0,      (yytype_uint8 const   )180, 
        (yytype_uint8 const   )153,      (yytype_uint8 const   )106,      (yytype_uint8 const   )0,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )161,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )186,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )89,      (yytype_uint8 const   )9,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )121,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )122,      (yytype_uint8 const   )124,      (yytype_uint8 const   )123,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )127,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )119,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )136,      (yytype_uint8 const   )137,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )104,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )173,      (yytype_uint8 const   )172,      (yytype_uint8 const   )29,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )135,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )178,      (yytype_uint8 const   )179,      (yytype_uint8 const   )177, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )89,      (yytype_uint8 const   )183,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )148,      (yytype_uint8 const   )14,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )181,      (yytype_uint8 const   )0,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )113,      (yytype_uint8 const   )114,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )112,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )163,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134,      (yytype_uint8 const   )130, 
        (yytype_uint8 const   )131,      (yytype_uint8 const   )132,      (yytype_uint8 const   )129,      (yytype_uint8 const   )144, 
        (yytype_uint8 const   )145,      (yytype_uint8 const   )141,      (yytype_uint8 const   )142,      (yytype_uint8 const   )143, 
        (yytype_uint8 const   )140,      (yytype_uint8 const   )120,      (yytype_uint8 const   )110,      (yytype_uint8 const   )162, 
        (yytype_uint8 const   )170,      (yytype_uint8 const   )97,      (yytype_uint8 const   )95,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )92,      (yytype_uint8 const   )149,      (yytype_uint8 const   )150, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )188,      (yytype_uint8 const   )0,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )13,      (yytype_uint8 const   )10,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )39,      (yytype_uint8 const   )0,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )0,      (yytype_uint8 const   )100,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )38,      (yytype_uint8 const   )51,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )44,      (yytype_uint8 const   )65,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )184,      (yytype_uint8 const   )89,      (yytype_uint8 const   )0,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )139,      (yytype_uint8 const   )89,      (yytype_uint8 const   )98,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )138,      (yytype_uint8 const   )0,      (yytype_uint8 const   )100,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )101,      (yytype_uint8 const   )55,      (yytype_uint8 const   )182, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )185,      (yytype_uint8 const   )42,      (yytype_uint8 const   )116,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )96,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )165,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )174,      (yytype_uint8 const   )67,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )0,      (yytype_uint8 const   )82,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )25,      (yytype_uint8 const   )89,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )0,      (yytype_uint8 const   )167,      (yytype_uint8 const   )169, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )89,      (yytype_uint8 const   )89,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )89,      (yytype_uint8 const   )0,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )0,      (yytype_uint8 const   )166,      (yytype_uint8 const   )168, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )81,      (yytype_uint8 const   )0,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )46,      (yytype_uint8 const   )0,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )89,      (yytype_uint8 const   )84,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )89,      (yytype_uint8 const   )0,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )0,      (yytype_uint8 const   )70,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )69,      (yytype_uint8 const   )0,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )66,      (yytype_uint8 const   )0,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )76,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )0,      (yytype_uint8 const   )187,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )0,      (yytype_uint8 const   )89,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )89,      (yytype_uint8 const   )37,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )0,      (yytype_uint8 const   )49};
#line 908 "awkgram.c"
static yytype_int16 const   yydefgoto___0[65]  = 
#line 908
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )28,      (yytype_int16 const   )140, 
        (yytype_int16 const   )143,      (yytype_int16 const   )29,      (yytype_int16 const   )77,      (yytype_int16 const   )53, 
        (yytype_int16 const   )54,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )83, 
        (yytype_int16 const   )32,      (yytype_int16 const   )146,      (yytype_int16 const   )78,      (yytype_int16 const   )205, 
        (yytype_int16 const   )206,      (yytype_int16 const   )222,      (yytype_int16 const   )207,      (yytype_int16 const   )237, 
        (yytype_int16 const   )248,      (yytype_int16 const   )255,      (yytype_int16 const   )296,      (yytype_int16 const   )305, 
        (yytype_int16 const   )317,      (yytype_int16 const   )208,      (yytype_int16 const   )258,      (yytype_int16 const   )276, 
        (yytype_int16 const   )286,      (yytype_int16 const   )209,      (yytype_int16 const   )144,      (yytype_int16 const   )145, 
        (yytype_int16 const   )125,      (yytype_int16 const   )175,      (yytype_int16 const   )176,      (yytype_int16 const   )232, 
        (yytype_int16 const   )116,      (yytype_int16 const   )117,      (yytype_int16 const   )210,      (yytype_int16 const   )115, 
        (yytype_int16 const   )94,      (yytype_int16 const   )95,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )40, 
        (yytype_int16 const   )55,      (yytype_int16 const   )264,      (yytype_int16 const   )265,      (yytype_int16 const   )266, 
        (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )41, 
        (yytype_int16 const   )42,      (yytype_int16 const   )131,      (yytype_int16 const   )211,      (yytype_int16 const   )212, 
        (yytype_int16 const   )137,      (yytype_int16 const   )239,      (yytype_int16 const   )213,      (yytype_int16 const   )319, 
        (yytype_int16 const   )136};
#line 922 "awkgram.c"
static yytype_int16 const   yypact___0[335]  = 
#line 922
  {      (yytype_int16 const   )-273,      (yytype_int16 const   )376,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-27,      (yytype_int16 const   )-21,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )157,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )11,      (yytype_int16 const   )11,      (yytype_int16 const   )11, 
        (yytype_int16 const   )-5,      (yytype_int16 const   )-3,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )1019,      (yytype_int16 const   )1065,      (yytype_int16 const   )821,      (yytype_int16 const   )116, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-20,      (yytype_int16 const   )1,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )35,      (yytype_int16 const   )758,      (yytype_int16 const   )992, 
        (yytype_int16 const   )252,      (yytype_int16 const   )296,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )233,      (yytype_int16 const   )789, 
        (yytype_int16 const   )821,      (yytype_int16 const   )-273,      (yytype_int16 const   )2,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )63,      (yytype_int16 const   )54,      (yytype_int16 const   )-273,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )789, 
        (yytype_int16 const   )789,      (yytype_int16 const   )127,      (yytype_int16 const   )87,      (yytype_int16 const   )115, 
        (yytype_int16 const   )87,      (yytype_int16 const   )87,      (yytype_int16 const   )1019,      (yytype_int16 const   )131, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )55,      (yytype_int16 const   )295, 
        (yytype_int16 const   )40,      (yytype_int16 const   )47,      (yytype_int16 const   )-273,      (yytype_int16 const   )83, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )35, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )83,      (yytype_int16 const   )-273,      (yytype_int16 const   )151, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )1019,      (yytype_int16 const   )132, 
        (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )83, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )1019, 
        (yytype_int16 const   )124,      (yytype_int16 const   )252,      (yytype_int16 const   )1019,      (yytype_int16 const   )1019, 
        (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )1019, 
        (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )1019, 
        (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )152,      (yytype_int16 const   )1019, 
        (yytype_int16 const   )100,      (yytype_int16 const   )16,      (yytype_int16 const   )1034,      (yytype_int16 const   )37, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )43, 
        (yytype_int16 const   )1019,      (yytype_int16 const   )-273,      (yytype_int16 const   )100,      (yytype_int16 const   )100, 
        (yytype_int16 const   )295,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )1019,      (yytype_int16 const   )83,      (yytype_int16 const   )-273,      (yytype_int16 const   )137, 
        (yytype_int16 const   )867,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )75, 
        (yytype_int16 const   )-19,      (yytype_int16 const   )-273,      (yytype_int16 const   )77,      (yytype_int16 const   )-19, 
        (yytype_int16 const   )35,      (yytype_int16 const   )-273,      (yytype_int16 const   )596,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )123,      (yytype_int16 const   )-273,      (yytype_int16 const   )141, 
        (yytype_int16 const   )175,      (yytype_int16 const   )1098,      (yytype_int16 const   )1019,      (yytype_int16 const   )161, 
        (yytype_int16 const   )11,      (yytype_int16 const   )-26,      (yytype_int16 const   )-26,      (yytype_int16 const   )87, 
        (yytype_int16 const   )87,      (yytype_int16 const   )87,      (yytype_int16 const   )87,      (yytype_int16 const   )-26, 
        (yytype_int16 const   )-26,      (yytype_int16 const   )87,      (yytype_int16 const   )87,      (yytype_int16 const   )87, 
        (yytype_int16 const   )87,      (yytype_int16 const   )-273,      (yytype_int16 const   )1034,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )100, 
        (yytype_int16 const   )65,      (yytype_int16 const   )252,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )1034,      (yytype_int16 const   )-273,      (yytype_int16 const   )132,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )1034,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )104,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )26,      (yytype_int16 const   )118,      (yytype_int16 const   )119,      (yytype_int16 const   )83, 
        (yytype_int16 const   )121,      (yytype_int16 const   )-19,      (yytype_int16 const   )-19,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-19,      (yytype_int16 const   )1019,      (yytype_int16 const   )-19, 
        (yytype_int16 const   )83,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-19, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )1034,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )117,      (yytype_int16 const   )83,      (yytype_int16 const   )1019,      (yytype_int16 const   )1034, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )83,      (yytype_int16 const   )-273,      (yytype_int16 const   )112, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )188,      (yytype_int16 const   )1019,      (yytype_int16 const   )1019,      (yytype_int16 const   )710, 
        (yytype_int16 const   )900,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-19,      (yytype_int16 const   )1034,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )642,      (yytype_int16 const   )596,      (yytype_int16 const   )83, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )1034,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )295,      (yytype_int16 const   )-19, 
        (yytype_int16 const   )-21,      (yytype_int16 const   )126,      (yytype_int16 const   )295,      (yytype_int16 const   )295, 
        (yytype_int16 const   )169,      (yytype_int16 const   )-13,      (yytype_int16 const   )-273,      (yytype_int16 const   )117, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )821,      (yytype_int16 const   )186,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )83,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )13,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )83,      (yytype_int16 const   )83,      (yytype_int16 const   )139, 
        (yytype_int16 const   )132,      (yytype_int16 const   )83,      (yytype_int16 const   )55,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )710,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )1,      (yytype_int16 const   )710,      (yytype_int16 const   )1019,      (yytype_int16 const   )100, 
        (yytype_int16 const   )743,      (yytype_int16 const   )137,      (yytype_int16 const   )1019,      (yytype_int16 const   )192, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )295,      (yytype_int16 const   )83, 
        (yytype_int16 const   )286,      (yytype_int16 const   )83,      (yytype_int16 const   )992,      (yytype_int16 const   )83, 
        (yytype_int16 const   )44,      (yytype_int16 const   )83,      (yytype_int16 const   )710,      (yytype_int16 const   )83, 
        (yytype_int16 const   )946,      (yytype_int16 const   )710,      (yytype_int16 const   )-273,      (yytype_int16 const   )247, 
        (yytype_int16 const   )154,      (yytype_int16 const   )-273,      (yytype_int16 const   )156,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )946,      (yytype_int16 const   )100,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )226,      (yytype_int16 const   )228, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )154,      (yytype_int16 const   )-273,      (yytype_int16 const   )83, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )100,      (yytype_int16 const   )83,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )83,      (yytype_int16 const   )-273,      (yytype_int16 const   )83, 
        (yytype_int16 const   )710,      (yytype_int16 const   )-273,      (yytype_int16 const   )448,      (yytype_int16 const   )710, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )522,      (yytype_int16 const   )-273};
#line 961 "awkgram.c"
static yytype_int16 const   yypgoto___0[65]  = 
#line 961
  {      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )208,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-64,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-202,      (yytype_int16 const   )71,      (yytype_int16 const   )-58, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-218,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-272,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )50,      (yytype_int16 const   )76, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )19, 
        (yytype_int16 const   )-54,      (yytype_int16 const   )-23,      (yytype_int16 const   )-1,      (yytype_int16 const   )-273, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-44,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-273,      (yytype_int16 const   )224,      (yytype_int16 const   )-273,      (yytype_int16 const   )-11, 
        (yytype_int16 const   )94,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-7, 
        (yytype_int16 const   )-38,      (yytype_int16 const   )-273,      (yytype_int16 const   )-273,      (yytype_int16 const   )-73, 
        (yytype_int16 const   )-2,      (yytype_int16 const   )-273,      (yytype_int16 const   )-28,      (yytype_int16 const   )-231, 
        (yytype_int16 const   )-46,      (yytype_int16 const   )-273,      (yytype_int16 const   )-25,      (yytype_int16 const   )-57, 
        (yytype_int16 const   )85};
#line 976 "awkgram.c"
static yytype_int16 const   yytable___0[1156]  = 
#line 976
  {      (yytype_int16 const   )34,      (yytype_int16 const   )80,      (yytype_int16 const   )80,      (yytype_int16 const   )70, 
        (yytype_int16 const   )81,      (yytype_int16 const   )126,      (yytype_int16 const   )127,      (yytype_int16 const   )260, 
        (yytype_int16 const   )121,      (yytype_int16 const   )238,      (yytype_int16 const   )254,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )150,      (yytype_int16 const   )5, 
        (yytype_int16 const   )74,      (yytype_int16 const   )132,      (yytype_int16 const   )120,      (yytype_int16 const   )63, 
        (yytype_int16 const   )63,      (yytype_int16 const   )119,      (yytype_int16 const   )63,      (yytype_int16 const   )68, 
        (yytype_int16 const   )135,      (yytype_int16 const   )71,      (yytype_int16 const   )-103,      (yytype_int16 const   )272, 
        (yytype_int16 const   )310,      (yytype_int16 const   )278,      (yytype_int16 const   )223,      (yytype_int16 const   )19, 
        (yytype_int16 const   )19,      (yytype_int16 const   )63,      (yytype_int16 const   )100,      (yytype_int16 const   )101, 
        (yytype_int16 const   )102,      (yytype_int16 const   )321,      (yytype_int16 const   )132,      (yytype_int16 const   )103, 
        (yytype_int16 const   )43,      (yytype_int16 const   )138,      (yytype_int16 const   )118,      (yytype_int16 const   )118, 
        (yytype_int16 const   )173,      (yytype_int16 const   )302,      (yytype_int16 const   )139,      (yytype_int16 const   )174, 
        (yytype_int16 const   )141,      (yytype_int16 const   )44,      (yytype_int16 const   )74,      (yytype_int16 const   )33, 
        (yytype_int16 const   )75,      (yytype_int16 const   )142,      (yytype_int16 const   )76,      (yytype_int16 const   )76, 
        (yytype_int16 const   )132,      (yytype_int16 const   )44,      (yytype_int16 const   )118,      (yytype_int16 const   )118, 
        (yytype_int16 const   )62,      (yytype_int16 const   )64,      (yytype_int16 const   )59,      (yytype_int16 const   )65, 
        (yytype_int16 const   )60,      (yytype_int16 const   )128,      (yytype_int16 const   )218,      (yytype_int16 const   )-103, 
        (yytype_int16 const   )303,      (yytype_int16 const   )304,      (yytype_int16 const   )171,      (yytype_int16 const   )133, 
        (yytype_int16 const   )44,      (yytype_int16 const   )75,      (yytype_int16 const   )97,      (yytype_int16 const   )320, 
        (yytype_int16 const   )185,      (yytype_int16 const   )25,      (yytype_int16 const   )187,      (yytype_int16 const   )79, 
        (yytype_int16 const   )178,      (yytype_int16 const   )179,      (yytype_int16 const   )254,      (yytype_int16 const   )44, 
        (yytype_int16 const   )-103,      (yytype_int16 const   )149,      (yytype_int16 const   )84,      (yytype_int16 const   )151, 
        (yytype_int16 const   )152,      (yytype_int16 const   )153,      (yytype_int16 const   )-103,      (yytype_int16 const   )254, 
        (yytype_int16 const   )133,      (yytype_int16 const   )224,      (yytype_int16 const   )155,      (yytype_int16 const   )19, 
        (yytype_int16 const   )63,      (yytype_int16 const   )63,      (yytype_int16 const   )63,      (yytype_int16 const   )63, 
        (yytype_int16 const   )63,      (yytype_int16 const   )63,      (yytype_int16 const   )63,      (yytype_int16 const   )63, 
        (yytype_int16 const   )63,      (yytype_int16 const   )63,      (yytype_int16 const   )63,      (yytype_int16 const   )63, 
        (yytype_int16 const   )172,      (yytype_int16 const   )220,      (yytype_int16 const   )133,      (yytype_int16 const   )-93, 
        (yytype_int16 const   )122,      (yytype_int16 const   )244,      (yytype_int16 const   )170,      (yytype_int16 const   )81, 
        (yytype_int16 const   )245,      (yytype_int16 const   )-89,      (yytype_int16 const   )81,      (yytype_int16 const   )4, 
        (yytype_int16 const   )133,      (yytype_int16 const   )123,      (yytype_int16 const   )63,      (yytype_int16 const   )134, 
        (yytype_int16 const   )330,      (yytype_int16 const   )124,      (yytype_int16 const   )-12,      (yytype_int16 const   )333, 
        (yytype_int16 const   )-15,      (yytype_int16 const   )217,      (yytype_int16 const   )4,      (yytype_int16 const   )180, 
        (yytype_int16 const   )85,      (yytype_int16 const   )-94,      (yytype_int16 const   )19,      (yytype_int16 const   )184, 
        (yytype_int16 const   )5,      (yytype_int16 const   )157,      (yytype_int16 const   )158,      (yytype_int16 const   )159, 
        (yytype_int16 const   )160,      (yytype_int16 const   )161,      (yytype_int16 const   )162,      (yytype_int16 const   )163, 
        (yytype_int16 const   )164,      (yytype_int16 const   )165,      (yytype_int16 const   )166,      (yytype_int16 const   )167, 
        (yytype_int16 const   )168,      (yytype_int16 const   )-12,      (yytype_int16 const   )85,      (yytype_int16 const   )-15, 
        (yytype_int16 const   )103,      (yytype_int16 const   )215,      (yytype_int16 const   )56,      (yytype_int16 const   )86, 
        (yytype_int16 const   )148,      (yytype_int16 const   )147,      (yytype_int16 const   )112,      (yytype_int16 const   )113, 
        (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )156,      (yytype_int16 const   )177, 
        (yytype_int16 const   )72,      (yytype_int16 const   )169,      (yytype_int16 const   )73,      (yytype_int16 const   )154, 
        (yytype_int16 const   )134,      (yytype_int16 const   )252,      (yytype_int16 const   )-104,      (yytype_int16 const   )221, 
        (yytype_int16 const   )81,      (yytype_int16 const   )81,      (yytype_int16 const   )129,      (yytype_int16 const   )130, 
        (yytype_int16 const   )81,      (yytype_int16 const   )182,      (yytype_int16 const   )81,      (yytype_int16 const   )92, 
        (yytype_int16 const   )93,      (yytype_int16 const   )87,      (yytype_int16 const   )81,      (yytype_int16 const   )259, 
        (yytype_int16 const   )85,      (yytype_int16 const   )225,      (yytype_int16 const   )226,      (yytype_int16 const   )240, 
        (yytype_int16 const   )228,      (yytype_int16 const   )86,      (yytype_int16 const   )79,      (yytype_int16 const   )76, 
        (yytype_int16 const   )249,      (yytype_int16 const   )79,      (yytype_int16 const   )268,      (yytype_int16 const   )271, 
        (yytype_int16 const   )275,      (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )283, 
        (yytype_int16 const   )262,      (yytype_int16 const   )233,      (yytype_int16 const   )50,      (yytype_int16 const   )51, 
        (yytype_int16 const   )269,      (yytype_int16 const   )270,      (yytype_int16 const   )282,      (yytype_int16 const   )81, 
        (yytype_int16 const   )318,      (yytype_int16 const   )181,      (yytype_int16 const   )267,      (yytype_int16 const   )186, 
        (yytype_int16 const   )295,      (yytype_int16 const   )242,      (yytype_int16 const   )188,      (yytype_int16 const   )87, 
        (yytype_int16 const   )88,      (yytype_int16 const   )-104,      (yytype_int16 const   )-104,      (yytype_int16 const   )287, 
        (yytype_int16 const   )246,      (yytype_int16 const   )233,      (yytype_int16 const   )81,      (yytype_int16 const   )289, 
        (yytype_int16 const   )250,      (yytype_int16 const   )251,      (yytype_int16 const   )52,      (yytype_int16 const   )267, 
        (yytype_int16 const   )285,      (yytype_int16 const   )204,      (yytype_int16 const   )273,      (yytype_int16 const   )92, 
        (yytype_int16 const   )93,      (yytype_int16 const   )323,      (yytype_int16 const   )274,      (yytype_int16 const   )324, 
        (yytype_int16 const   )118,      (yytype_int16 const   )291,      (yytype_int16 const   )82,      (yytype_int16 const   )316, 
        (yytype_int16 const   )308,      (yytype_int16 const   )247,      (yytype_int16 const   )294,      (yytype_int16 const   )311, 
        (yytype_int16 const   )297,      (yytype_int16 const   )110,      (yytype_int16 const   )111,      (yytype_int16 const   )79, 
        (yytype_int16 const   )79,      (yytype_int16 const   )67,      (yytype_int16 const   )216,      (yytype_int16 const   )79, 
        (yytype_int16 const   )288,      (yytype_int16 const   )79,      (yytype_int16 const   )312,      (yytype_int16 const   )313, 
        (yytype_int16 const   )71,      (yytype_int16 const   )79,      (yytype_int16 const   )279,      (yytype_int16 const   )293, 
        (yytype_int16 const   )325,      (yytype_int16 const   )219,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )322,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )299, 
        (yytype_int16 const   )229,      (yytype_int16 const   )230,      (yytype_int16 const   )332,      (yytype_int16 const   )227, 
        (yytype_int16 const   )231,      (yytype_int16 const   )334,      (yytype_int16 const   )234,      (yytype_int16 const   )327, 
        (yytype_int16 const   )112,      (yytype_int16 const   )113,      (yytype_int16 const   )236,      (yytype_int16 const   )0, 
        (yytype_int16 const   )235,      (yytype_int16 const   )290,      (yytype_int16 const   )79,      (yytype_int16 const   )292, 
        (yytype_int16 const   )63,      (yytype_int16 const   )114,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )241,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )63,      (yytype_int16 const   )243,      (yytype_int16 const   )0,      (yytype_int16 const   )85, 
        (yytype_int16 const   )0,      (yytype_int16 const   )79,      (yytype_int16 const   )0,      (yytype_int16 const   )20, 
        (yytype_int16 const   )86,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )256, 
        (yytype_int16 const   )85,      (yytype_int16 const   )314,      (yytype_int16 const   )315,      (yytype_int16 const   )0, 
        (yytype_int16 const   )23,      (yytype_int16 const   )86,      (yytype_int16 const   )98,      (yytype_int16 const   )99, 
        (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )261, 
        (yytype_int16 const   )0,      (yytype_int16 const   )103,      (yytype_int16 const   )263,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )87,      (yytype_int16 const   )88, 
        (yytype_int16 const   )89,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )97,      (yytype_int16 const   )0,      (yytype_int16 const   )87, 
        (yytype_int16 const   )88,      (yytype_int16 const   )89,      (yytype_int16 const   )277,      (yytype_int16 const   )90, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )92,      (yytype_int16 const   )93, 
        (yytype_int16 const   )0,      (yytype_int16 const   )280,      (yytype_int16 const   )281,      (yytype_int16 const   )0, 
        (yytype_int16 const   )90,      (yytype_int16 const   )284,      (yytype_int16 const   )0,      (yytype_int16 const   )92, 
        (yytype_int16 const   )93,      (yytype_int16 const   )0,      (yytype_int16 const   )104,      (yytype_int16 const   )105, 
        (yytype_int16 const   )106,      (yytype_int16 const   )107,      (yytype_int16 const   )108,      (yytype_int16 const   )0, 
        (yytype_int16 const   )76,      (yytype_int16 const   )109,      (yytype_int16 const   )0,      (yytype_int16 const   )134, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )298, 
        (yytype_int16 const   )0,      (yytype_int16 const   )300,      (yytype_int16 const   )0,      (yytype_int16 const   )301, 
        (yytype_int16 const   )306,      (yytype_int16 const   )307,      (yytype_int16 const   )0,      (yytype_int16 const   )309, 
        (yytype_int16 const   )2,      (yytype_int16 const   )3,      (yytype_int16 const   )0,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )326, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )328,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )329,      (yytype_int16 const   )0,      (yytype_int16 const   )331, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )19, 
        (yytype_int16 const   )20,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )0,      (yytype_int16 const   )27,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-18,      (yytype_int16 const   )189,      (yytype_int16 const   )-18,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )190, 
        (yytype_int16 const   )0,      (yytype_int16 const   )191,      (yytype_int16 const   )192,      (yytype_int16 const   )193, 
        (yytype_int16 const   )-72,      (yytype_int16 const   )-72,      (yytype_int16 const   )194,      (yytype_int16 const   )195, 
        (yytype_int16 const   )196,      (yytype_int16 const   )197,      (yytype_int16 const   )198,      (yytype_int16 const   )199, 
        (yytype_int16 const   )200,      (yytype_int16 const   )201,      (yytype_int16 const   )202,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )13,      (yytype_int16 const   )203, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )-72, 
        (yytype_int16 const   )20,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )0,      (yytype_int16 const   )61,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )75,      (yytype_int16 const   )-72,      (yytype_int16 const   )76,      (yytype_int16 const   )189, 
        (yytype_int16 const   )0,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )190,      (yytype_int16 const   )0,      (yytype_int16 const   )191, 
        (yytype_int16 const   )192,      (yytype_int16 const   )193,      (yytype_int16 const   )-71,      (yytype_int16 const   )-71, 
        (yytype_int16 const   )194,      (yytype_int16 const   )195,      (yytype_int16 const   )196,      (yytype_int16 const   )197, 
        (yytype_int16 const   )198,      (yytype_int16 const   )199,      (yytype_int16 const   )200,      (yytype_int16 const   )201, 
        (yytype_int16 const   )202,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )13,      (yytype_int16 const   )203,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-71,      (yytype_int16 const   )20,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )23, 
        (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )61, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )75,      (yytype_int16 const   )-71, 
        (yytype_int16 const   )76,      (yytype_int16 const   )189,      (yytype_int16 const   )0,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )190, 
        (yytype_int16 const   )0,      (yytype_int16 const   )191,      (yytype_int16 const   )192,      (yytype_int16 const   )193, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )194,      (yytype_int16 const   )195, 
        (yytype_int16 const   )196,      (yytype_int16 const   )197,      (yytype_int16 const   )198,      (yytype_int16 const   )199, 
        (yytype_int16 const   )200,      (yytype_int16 const   )201,      (yytype_int16 const   )202,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )13,      (yytype_int16 const   )203, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )69, 
        (yytype_int16 const   )0,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )0, 
        (yytype_int16 const   )20,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-102,      (yytype_int16 const   )0,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )0,      (yytype_int16 const   )61,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )75,      (yytype_int16 const   )204,      (yytype_int16 const   )76,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )13,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )-102,      (yytype_int16 const   )20,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )23, 
        (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )25,      (yytype_int16 const   )257,      (yytype_int16 const   )-102,      (yytype_int16 const   )61, 
        (yytype_int16 const   )0,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )0, 
        (yytype_int16 const   )-102,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )190,      (yytype_int16 const   )0,      (yytype_int16 const   )191, 
        (yytype_int16 const   )192,      (yytype_int16 const   )193,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )194,      (yytype_int16 const   )195,      (yytype_int16 const   )196,      (yytype_int16 const   )197, 
        (yytype_int16 const   )198,      (yytype_int16 const   )199,      (yytype_int16 const   )200,      (yytype_int16 const   )201, 
        (yytype_int16 const   )202,      (yytype_int16 const   )0,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )13,      (yytype_int16 const   )203,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )20,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )85, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )23, 
        (yytype_int16 const   )86,      (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )61, 
        (yytype_int16 const   )0,      (yytype_int16 const   )13,      (yytype_int16 const   )75,      (yytype_int16 const   )0, 
        (yytype_int16 const   )76,      (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )69,      (yytype_int16 const   )0, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )0,      (yytype_int16 const   )20, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )87,      (yytype_int16 const   )88, 
        (yytype_int16 const   )89,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )0, 
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )90, 
        (yytype_int16 const   )61,      (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93, 
        (yytype_int16 const   )0,      (yytype_int16 const   )76,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )69,      (yytype_int16 const   )0, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )0,      (yytype_int16 const   )13, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )20,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0, 
        (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )-102,      (yytype_int16 const   )61,      (yytype_int16 const   )13, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )183,      (yytype_int16 const   )0,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )0,      (yytype_int16 const   )20,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0, 
        (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )61,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )4, 
        (yytype_int16 const   )253,      (yytype_int16 const   )13,      (yytype_int16 const   )0,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )20, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )192,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )0, 
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )199, 
        (yytype_int16 const   )200,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0, 
        (yytype_int16 const   )61,      (yytype_int16 const   )0,      (yytype_int16 const   )13,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )0, 
        (yytype_int16 const   )20,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )192,      (yytype_int16 const   )61,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )199,      (yytype_int16 const   )200,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )13,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )0,      (yytype_int16 const   )20,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )96, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )23, 
        (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )61, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )13,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )85, 
        (yytype_int16 const   )20,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )86,      (yytype_int16 const   )0,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )13,      (yytype_int16 const   )25,      (yytype_int16 const   )26, 
        (yytype_int16 const   )0,      (yytype_int16 const   )61,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )0,      (yytype_int16 const   )20, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )87,      (yytype_int16 const   )88, 
        (yytype_int16 const   )89,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )0, 
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )90, 
        (yytype_int16 const   )61,      (yytype_int16 const   )0,      (yytype_int16 const   )92,      (yytype_int16 const   )93, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )85, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )86,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )20,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )0,      (yytype_int16 const   )23,      (yytype_int16 const   )0, 
        (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )25, 
        (yytype_int16 const   )66,      (yytype_int16 const   )0,      (yytype_int16 const   )61,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )87,      (yytype_int16 const   )88, 
        (yytype_int16 const   )89,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )90, 
        (yytype_int16 const   )214,      (yytype_int16 const   )0,      (yytype_int16 const   )92,      (yytype_int16 const   )93};
#line 1102 "awkgram.c"
static yytype_int16 const   yycheck___0[1156]  = 
#line 1102
  {      (yytype_int16 const   )1,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )26, 
        (yytype_int16 const   )29,      (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )238, 
        (yytype_int16 const   )46,      (yytype_int16 const   )211,      (yytype_int16 const   )228,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )87,      (yytype_int16 const   )4, 
        (yytype_int16 const   )27,      (yytype_int16 const   )1,      (yytype_int16 const   )16,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )44,      (yytype_int16 const   )24,      (yytype_int16 const   )25, 
        (yytype_int16 const   )70,      (yytype_int16 const   )26,      (yytype_int16 const   )10,      (yytype_int16 const   )40, 
        (yytype_int16 const   )300,      (yytype_int16 const   )16,      (yytype_int16 const   )4,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )35,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )62,      (yytype_int16 const   )309,      (yytype_int16 const   )1,      (yytype_int16 const   )65, 
        (yytype_int16 const   )67,      (yytype_int16 const   )1,      (yytype_int16 const   )43,      (yytype_int16 const   )44, 
        (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )6,      (yytype_int16 const   )4, 
        (yytype_int16 const   )1,      (yytype_int16 const   )70,      (yytype_int16 const   )61,      (yytype_int16 const   )1, 
        (yytype_int16 const   )72,      (yytype_int16 const   )6,      (yytype_int16 const   )74,      (yytype_int16 const   )74, 
        (yytype_int16 const   )1,      (yytype_int16 const   )70,      (yytype_int16 const   )59,      (yytype_int16 const   )60, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )67,      (yytype_int16 const   )24, 
        (yytype_int16 const   )67,      (yytype_int16 const   )66,      (yytype_int16 const   )1,      (yytype_int16 const   )51, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )116,      (yytype_int16 const   )55, 
        (yytype_int16 const   )70,      (yytype_int16 const   )72,      (yytype_int16 const   )35,      (yytype_int16 const   )306, 
        (yytype_int16 const   )1,      (yytype_int16 const   )66,      (yytype_int16 const   )1,      (yytype_int16 const   )29, 
        (yytype_int16 const   )126,      (yytype_int16 const   )127,      (yytype_int16 const   )300,      (yytype_int16 const   )70, 
        (yytype_int16 const   )68,      (yytype_int16 const   )86,      (yytype_int16 const   )51,      (yytype_int16 const   )88, 
        (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )74,      (yytype_int16 const   )309, 
        (yytype_int16 const   )55,      (yytype_int16 const   )67,      (yytype_int16 const   )95,      (yytype_int16 const   )51, 
        (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )100,      (yytype_int16 const   )101, 
        (yytype_int16 const   )102,      (yytype_int16 const   )103,      (yytype_int16 const   )104,      (yytype_int16 const   )105, 
        (yytype_int16 const   )106,      (yytype_int16 const   )107,      (yytype_int16 const   )108,      (yytype_int16 const   )109, 
        (yytype_int16 const   )71,      (yytype_int16 const   )182,      (yytype_int16 const   )55,      (yytype_int16 const   )68, 
        (yytype_int16 const   )49,      (yytype_int16 const   )1,      (yytype_int16 const   )115,      (yytype_int16 const   )140, 
        (yytype_int16 const   )4,      (yytype_int16 const   )73,      (yytype_int16 const   )143,      (yytype_int16 const   )3, 
        (yytype_int16 const   )55,      (yytype_int16 const   )67,      (yytype_int16 const   )124,      (yytype_int16 const   )68, 
        (yytype_int16 const   )326,      (yytype_int16 const   )56,      (yytype_int16 const   )51,      (yytype_int16 const   )329, 
        (yytype_int16 const   )51,      (yytype_int16 const   )175,      (yytype_int16 const   )3,      (yytype_int16 const   )132, 
        (yytype_int16 const   )9,      (yytype_int16 const   )68,      (yytype_int16 const   )51,      (yytype_int16 const   )136, 
        (yytype_int16 const   )4,      (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )103,      (yytype_int16 const   )104, 
        (yytype_int16 const   )105,      (yytype_int16 const   )106,      (yytype_int16 const   )107,      (yytype_int16 const   )108, 
        (yytype_int16 const   )109,      (yytype_int16 const   )74,      (yytype_int16 const   )9,      (yytype_int16 const   )74, 
        (yytype_int16 const   )65,      (yytype_int16 const   )154,      (yytype_int16 const   )156,      (yytype_int16 const   )14, 
        (yytype_int16 const   )5,      (yytype_int16 const   )81,      (yytype_int16 const   )43,      (yytype_int16 const   )44, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )38,      (yytype_int16 const   )124, 
        (yytype_int16 const   )48,      (yytype_int16 const   )13,      (yytype_int16 const   )50,      (yytype_int16 const   )91, 
        (yytype_int16 const   )68,      (yytype_int16 const   )227,      (yytype_int16 const   )9,      (yytype_int16 const   )67, 
        (yytype_int16 const   )197,      (yytype_int16 const   )198,      (yytype_int16 const   )43,      (yytype_int16 const   )44, 
        (yytype_int16 const   )201,      (yytype_int16 const   )40,      (yytype_int16 const   )203,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )40,      (yytype_int16 const   )207,      (yytype_int16 const   )237, 
        (yytype_int16 const   )9,      (yytype_int16 const   )67,      (yytype_int16 const   )67,      (yytype_int16 const   )212, 
        (yytype_int16 const   )67,      (yytype_int16 const   )14,      (yytype_int16 const   )140,      (yytype_int16 const   )74, 
        (yytype_int16 const   )4,      (yytype_int16 const   )143,      (yytype_int16 const   )68,      (yytype_int16 const   )26, 
        (yytype_int16 const   )10,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )272, 
        (yytype_int16 const   )246,      (yytype_int16 const   )202,      (yytype_int16 const   )45,      (yytype_int16 const   )46, 
        (yytype_int16 const   )250,      (yytype_int16 const   )251,      (yytype_int16 const   )67,      (yytype_int16 const   )232, 
        (yytype_int16 const   )54,      (yytype_int16 const   )133,      (yytype_int16 const   )248,      (yytype_int16 const   )140, 
        (yytype_int16 const   )20,      (yytype_int16 const   )214,      (yytype_int16 const   )143,      (yytype_int16 const   )40, 
        (yytype_int16 const   )41,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )277, 
        (yytype_int16 const   )221,      (yytype_int16 const   )222,      (yytype_int16 const   )247,      (yytype_int16 const   )281, 
        (yytype_int16 const   )225,      (yytype_int16 const   )226,      (yytype_int16 const   )69,      (yytype_int16 const   )265, 
        (yytype_int16 const   )274,      (yytype_int16 const   )73,      (yytype_int16 const   )255,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )7,      (yytype_int16 const   )257,      (yytype_int16 const   )7, 
        (yytype_int16 const   )237,      (yytype_int16 const   )283,      (yytype_int16 const   )30,      (yytype_int16 const   )303, 
        (yytype_int16 const   )298,      (yytype_int16 const   )222,      (yytype_int16 const   )286,      (yytype_int16 const   )301, 
        (yytype_int16 const   )290,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )197, 
        (yytype_int16 const   )198,      (yytype_int16 const   )25,      (yytype_int16 const   )156,      (yytype_int16 const   )201, 
        (yytype_int16 const   )280,      (yytype_int16 const   )203,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )257,      (yytype_int16 const   )207,      (yytype_int16 const   )265,      (yytype_int16 const   )284, 
        (yytype_int16 const   )317,      (yytype_int16 const   )176,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )310,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )292, 
        (yytype_int16 const   )197,      (yytype_int16 const   )198,      (yytype_int16 const   )328,      (yytype_int16 const   )195, 
        (yytype_int16 const   )201,      (yytype_int16 const   )331,      (yytype_int16 const   )203,      (yytype_int16 const   )321, 
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )207,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )204,      (yytype_int16 const   )282,      (yytype_int16 const   )232,      (yytype_int16 const   )284, 
        (yytype_int16 const   )286,      (yytype_int16 const   )52,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )213,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )294,      (yytype_int16 const   )217,      (yytype_int16 const   )-1,      (yytype_int16 const   )9, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )247,      (yytype_int16 const   )-1,      (yytype_int16 const   )52, 
        (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )232, 
        (yytype_int16 const   )9,      (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )61,      (yytype_int16 const   )14,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62,      (yytype_int16 const   )239, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )65,      (yytype_int16 const   )247,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )40,      (yytype_int16 const   )41, 
        (yytype_int16 const   )42,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )294,      (yytype_int16 const   )-1,      (yytype_int16 const   )40, 
        (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )262,      (yytype_int16 const   )53, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )269,      (yytype_int16 const   )270,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )53,      (yytype_int16 const   )273,      (yytype_int16 const   )-1,      (yytype_int16 const   )56, 
        (yytype_int16 const   )57,      (yytype_int16 const   )-1,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )74,      (yytype_int16 const   )65,      (yytype_int16 const   )-1,      (yytype_int16 const   )68, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )291, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )293,      (yytype_int16 const   )-1,      (yytype_int16 const   )295, 
        (yytype_int16 const   )296,      (yytype_int16 const   )297,      (yytype_int16 const   )-1,      (yytype_int16 const   )299, 
        (yytype_int16 const   )0,      (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )319, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )322,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )325,      (yytype_int16 const   )-1,      (yytype_int16 const   )327, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )47, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )51, 
        (yytype_int16 const   )52,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )72,      (yytype_int16 const   )1,      (yytype_int16 const   )74,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )19, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )51, 
        (yytype_int16 const   )52,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )74,      (yytype_int16 const   )1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )19,      (yytype_int16 const   )-1,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45, 
        (yytype_int16 const   )46,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )72,      (yytype_int16 const   )73, 
        (yytype_int16 const   )74,      (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )19, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )38,      (yytype_int16 const   )39, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )52,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )-1,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )74,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )38,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45, 
        (yytype_int16 const   )46,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )74,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )19,      (yytype_int16 const   )-1,      (yytype_int16 const   )21, 
        (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33, 
        (yytype_int16 const   )34,      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )38,      (yytype_int16 const   )39,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45, 
        (yytype_int16 const   )46,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )52,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )9, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1,      (yytype_int16 const   )61, 
        (yytype_int16 const   )14,      (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )38,      (yytype_int16 const   )72,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )74,      (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )44, 
        (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )52, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )40,      (yytype_int16 const   )41, 
        (yytype_int16 const   )42,      (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )53, 
        (yytype_int16 const   )69,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )74,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )38, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )52,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )-1,      (yytype_int16 const   )61,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66, 
        (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69,      (yytype_int16 const   )38, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46, 
        (yytype_int16 const   )1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )52,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )-1,      (yytype_int16 const   )61,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66, 
        (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )38,      (yytype_int16 const   )-1,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )44, 
        (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )52, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )22,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )38,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )52,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )22,      (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )38,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45, 
        (yytype_int16 const   )46,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3, 
        (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )52,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )11, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )38,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )9, 
        (yytype_int16 const   )52,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )58,      (yytype_int16 const   )59, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )38,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )69,      (yytype_int16 const   )43,      (yytype_int16 const   )44, 
        (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )-1,      (yytype_int16 const   )52, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )40,      (yytype_int16 const   )41, 
        (yytype_int16 const   )42,      (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )61,      (yytype_int16 const   )-1,      (yytype_int16 const   )63,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )66,      (yytype_int16 const   )67,      (yytype_int16 const   )53, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-1,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )9, 
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46, 
        (yytype_int16 const   )14,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )52,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )-1,      (yytype_int16 const   )61,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )63,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )66, 
        (yytype_int16 const   )67,      (yytype_int16 const   )-1,      (yytype_int16 const   )69,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )40,      (yytype_int16 const   )41, 
        (yytype_int16 const   )42,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )53, 
        (yytype_int16 const   )54,      (yytype_int16 const   )-1,      (yytype_int16 const   )56,      (yytype_int16 const   )57};
#line 1224 "awkgram.c"
static yytype_uint8 const   yystos___0[335]  = 
#line 1224
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )76,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )80,      (yytype_uint8 const   )84,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )105,      (yytype_uint8 const   )113,      (yytype_uint8 const   )117, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )119,      (yytype_uint8 const   )120,      (yytype_uint8 const   )121, 
        (yytype_uint8 const   )122,      (yytype_uint8 const   )130,      (yytype_uint8 const   )131,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )127,      (yytype_uint8 const   )128,      (yytype_uint8 const   )129, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )123, 
        (yytype_uint8 const   )131,      (yytype_uint8 const   )131,      (yytype_uint8 const   )131,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )69,      (yytype_uint8 const   )118,      (yytype_uint8 const   )131, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )67,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )131,      (yytype_uint8 const   )1,      (yytype_uint8 const   )112,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )50,      (yytype_uint8 const   )122,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )81,      (yytype_uint8 const   )89,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )133,      (yytype_uint8 const   )137,      (yytype_uint8 const   )81,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )9,      (yytype_uint8 const   )14,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )53,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )115,      (yytype_uint8 const   )116, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )118,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )65,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )52,      (yytype_uint8 const   )114, 
        (yytype_uint8 const   )111,      (yytype_uint8 const   )112,      (yytype_uint8 const   )113,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )127,      (yytype_uint8 const   )49,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )107,      (yytype_uint8 const   )111,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )132, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )55,      (yytype_uint8 const   )68,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )139,      (yytype_uint8 const   )135,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )88,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )113,      (yytype_uint8 const   )130,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )113,      (yytype_uint8 const   )106,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )13,      (yytype_uint8 const   )113,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )118,      (yytype_uint8 const   )135,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )106,      (yytype_uint8 const   )40,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )1,      (yytype_uint8 const   )89,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )1,      (yytype_uint8 const   )19,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )104,      (yytype_uint8 const   )113,      (yytype_uint8 const   )133, 
        (yytype_uint8 const   )134,      (yytype_uint8 const   )137,      (yytype_uint8 const   )54,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )135,      (yytype_uint8 const   )1,      (yytype_uint8 const   )139, 
        (yytype_uint8 const   )130,      (yytype_uint8 const   )67,      (yytype_uint8 const   )92,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )89,      (yytype_uint8 const   )89,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )110,      (yytype_uint8 const   )113,      (yytype_uint8 const   )89,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )94,      (yytype_uint8 const   )88,      (yytype_uint8 const   )136, 
        (yytype_uint8 const   )137,      (yytype_uint8 const   )106,      (yytype_uint8 const   )113,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )113,      (yytype_uint8 const   )110, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )4,      (yytype_uint8 const   )113,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )4,      (yytype_uint8 const   )93,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )67,      (yytype_uint8 const   )101,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )134,      (yytype_uint8 const   )106,      (yytype_uint8 const   )135,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )126,      (yytype_uint8 const   )127, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )135,      (yytype_uint8 const   )135,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )137,      (yytype_uint8 const   )112,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )106,      (yytype_uint8 const   )16,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )106,      (yytype_uint8 const   )106,      (yytype_uint8 const   )67,      (yytype_uint8 const   )130, 
        (yytype_uint8 const   )106,      (yytype_uint8 const   )135,      (yytype_uint8 const   )103,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )133,      (yytype_uint8 const   )90,      (yytype_uint8 const   )113,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )137,      (yytype_uint8 const   )117,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )135,      (yytype_uint8 const   )106,      (yytype_uint8 const   )137, 
        (yytype_uint8 const   )106,      (yytype_uint8 const   )106,      (yytype_uint8 const   )1,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )98,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )106,      (yytype_uint8 const   )96,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )99,      (yytype_uint8 const   )54,      (yytype_uint8 const   )138, 
        (yytype_uint8 const   )134,      (yytype_uint8 const   )96,      (yytype_uint8 const   )135,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )138,      (yytype_uint8 const   )106,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )106,      (yytype_uint8 const   )106,      (yytype_uint8 const   )88,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )88,      (yytype_uint8 const   )90};
#line 1751 "awkgram.c"
static void yydestruct___0(char const   *yymsg , int yytype , INSTRUCTION **yyvaluep ) 
{ 
  char *__cil_tmp4 ;

  {
#line 1763
  if (! yymsg) {
#line 1764
    yymsg = "Deleting";
  }
#line 1768
  return;
}
}
#line 1774 "awkgram.c"
int yychar  ;
#line 1789 "awkgram.c"
int yynerrs  ;
#line 322 "awkgram.y"
static int begin_seen  =    0;
#line 333 "awkgram.y"
static int end_seen  =    0;
#line 897 "awkgram.y"
static _Bool warned___18  =    (_Bool)0;
#line 1018 "awkgram.y"
static _Bool warned___19  =    (_Bool)0;
#line 1536 "awkgram.y"
static _Bool warned___20  =    (_Bool)0;
#line 1606 "awkgram.y"
static _Bool warned___21  =    (_Bool)0;
#line 1809 "awkgram.c"
int yyparse(void) 
{ 
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  INSTRUCTION *yyvsa[200] ;
  INSTRUCTION **yyvs ;
  INSTRUCTION **yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  INSTRUCTION *yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc___0 *yyptr ;
  void *tmp___1 ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  INSTRUCTION *tp ;
  INSTRUCTION *tmp___6 ;
  INSTRUCTION *tmp___7 ;
  INSTRUCTION *tmp___8 ;
  INSTRUCTION *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  INSTRUCTION *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  NODE *n ;
  NODE *exp___0 ;
  char *re ;
  size_t len ;
  char *tmp___15 ;
  char *tmp___16 ;
  INSTRUCTION *tmp___17 ;
  INSTRUCTION *dflt ;
  INSTRUCTION *curr ;
  INSTRUCTION *cexp ;
  INSTRUCTION *cstmt ;
  INSTRUCTION *ip ;
  INSTRUCTION *nextc___0 ;
  INSTRUCTION *tbreak ;
  char const   **case_values ;
  int maxcount ;
  int case_count ;
  int i___0 ;
  INSTRUCTION *tmp___18 ;
  INSTRUCTION *caseexp ;
  INSTRUCTION *casestmt ;
  char *caseval ;
  NODE *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  void *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  INSTRUCTION *tmp___34 ;
  INSTRUCTION *ip___0 ;
  INSTRUCTION *tbreak___0 ;
  INSTRUCTION *tcont ;
  INSTRUCTION *tmp___35 ;
  INSTRUCTION *tmp___36 ;
  INSTRUCTION *tmp___37 ;
  INSTRUCTION *ip___1 ;
  INSTRUCTION *tbreak___1 ;
  INSTRUCTION *tcont___0 ;
  INSTRUCTION *tmp___38 ;
  INSTRUCTION *tmp___39 ;
  INSTRUCTION *tmp___40 ;
  INSTRUCTION *ip___2 ;
  char *var_name ;
  NODE *arr ;
  int tmp___41 ;
  INSTRUCTION *tbreak___2 ;
  INSTRUCTION *tcont___1 ;
  INSTRUCTION *tmp___42 ;
  INSTRUCTION *tmp___43 ;
  INSTRUCTION *tmp___44 ;
  INSTRUCTION *tmp___45 ;
  int tmp___46 ;
  INSTRUCTION *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  INSTRUCTION *tmp___52 ;
  char *tmp___53 ;
  INSTRUCTION *tmp___54 ;
  int tmp___55 ;
  NODE *n___0 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  char *tmp___59 ;
  INSTRUCTION *ip___3 ;
  INSTRUCTION *t ;
  int tmp___60 ;
  INSTRUCTION *ip___4 ;
  INSTRUCTION *t___0 ;
  int tmp___61 ;
  INSTRUCTION *tmp___62 ;
  char *arr___0 ;
  char *tmp___63 ;
  char *tmp___64 ;
  INSTRUCTION *tmp___65 ;
  INSTRUCTION *tmp___66 ;
  char *arr___1 ;
  char *tmp___67 ;
  char *tmp___68 ;
  INSTRUCTION *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  INSTRUCTION *casestmt___0 ;
  INSTRUCTION *tmp___72 ;
  INSTRUCTION *tmp___73 ;
  INSTRUCTION *casestmt___1 ;
  INSTRUCTION *tmp___74 ;
  INSTRUCTION *tmp___75 ;
  NODE *n___1 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  INSTRUCTION *tmp___79 ;
  char *tmp___80 ;
  INSTRUCTION *tmp___81 ;
  char *tmp___82 ;
  INSTRUCTION *tmp___83 ;
  int count ;
  _Bool is_simple_var ;
  int tmp___84 ;
  NODE *n1 ;
  NODE *n2 ;
  size_t nlen ;
  char *tmp___85 ;
  void *tmp___86 ;
  int *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  int tmp___90 ;
  INSTRUCTION *tmp___91 ;
  INSTRUCTION *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  INSTRUCTION *t___1 ;
  int tmp___98 ;
  INSTRUCTION *tmp___99 ;
  INSTRUCTION *tmp___100 ;
  INSTRUCTION *tmp___101 ;
  INSTRUCTION *tmp___102 ;
  NODE *n___2 ;
  char *tmp___103 ;
  NODE *n___3 ;
  INSTRUCTION *f ;
  INSTRUCTION *t___2 ;
  char *name ;
  NODE *indirect_var ;
  char const   *msg___0 ;
  char *tmp___104 ;
  size_t tmp___105 ;
  char *tmp___106 ;
  int tmp___107 ;
  INSTRUCTION *t___3 ;
  int tmp___108 ;
  INSTRUCTION *ip___5 ;
  int count___0 ;
  INSTRUCTION *t___4 ;
  char *tmp___109 ;
  INSTRUCTION *tmp___110 ;
  int tmp___111 ;
  char *var_name___0 ;
  char *arr___2 ;
  INSTRUCTION *ip___6 ;
  INSTRUCTION *tmp___112 ;
  int tmp___113 ;
  void *__cil_tmp193 ;
  void *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;

  {
#line 1844
  yytoken = 0;
#line 1860
  yylen = 0;
#line 1862
  yyss = yyssa;
#line 1862
  yyssp = yyss;
#line 1863
  yyvs = yyvsa;
#line 1863
  yyvsp = yyvs;
#line 1864
  yystacksize = 200UL;
#line 1868
  yystate = 0;
#line 1869
  yyerrstatus = 0;
#line 1870
  yynerrs = 0;
#line 1871
  yychar = -2;
#line 1872
  goto yysetstate;
  yynewstate: 
#line 1880
  yyssp ++;
  yysetstate: 
#line 1883
  *yyssp = (yytype_int16 )yystate;
#line 1885
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1888
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1915
    if (10000UL <= yystacksize) {
#line 1916
      goto yyexhaustedlab;
    }
#line 1917
    yystacksize *= 2UL;
#line 1918
    if (10000UL < yystacksize) {
#line 1919
      yystacksize = 10000UL;
    }
    {
#line 1922
    yyss1 = yyss;
#line 1923
    tmp___1 = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(INSTRUCTION *)) + (sizeof(union yyalloc___0 ) - 1UL));
#line 1923
    yyptr = (union yyalloc___0 *)tmp___1;
    }
#line 1925
    if (! yyptr) {
#line 1926
      goto yyexhaustedlab;
    }
    {
#line 1927
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1927
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1927
      yyss = & yyptr->yyss_alloc;
#line 1927
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1927
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1927
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1928
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1928
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1928
      yyvs = & yyptr->yyvs_alloc;
#line 1928
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1928
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1928
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1930
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1931
      free((void *)yyss1);
      }
    }
#line 1936
    yyssp = (yyss + yysize) - 1;
#line 1937
    yyvsp = (yyvs + yysize) - 1;
#line 1942
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1943
      goto yyabortlab;
    }
  }
#line 1948
  if (yystate == 2) {
#line 1949
    goto yyacceptlab;
  }
#line 1951
  goto yybackup;
  yybackup: 
#line 1962
  yyn = (int )yypact___0[yystate];
#line 1963
  if (! (! (yyn == -273))) {
#line 1964
    goto yydefault;
  }
#line 1969
  if (yychar == -2) {
    {
#line 1972
    yychar = yylex();
    }
  }
#line 1975
  if (yychar <= 0) {
#line 1977
    yytoken = 0;
#line 1977
    yychar = yytoken;
  } else
#line 1982
  if ((unsigned int )yychar <= 308U) {
#line 1982
    yytoken = (int )yytranslate___0[yychar];
  } else {
#line 1982
    yytoken = 2;
  }
#line 1988
  yyn += yytoken;
#line 1989
  if (yyn < 0) {
#line 1990
    goto yydefault;
  } else
#line 1989
  if (1155 < yyn) {
#line 1990
    goto yydefault;
  } else
#line 1989
  if ((int const   )yycheck___0[yyn] != (int const   )yytoken) {
#line 1990
    goto yydefault;
  }
#line 1991
  yyn = (int )yytable___0[yyn];
#line 1992
  if (yyn <= 0) {
#line 1994
    if (! (! (yyn == -104))) {
#line 1995
      goto yyerrlab;
    }
#line 1996
    yyn = - yyn;
#line 1997
    goto yyreduce;
  }
#line 2002
  if (yyerrstatus) {
#line 2003
    yyerrstatus --;
  }
#line 2009
  yychar = -2;
#line 2011
  yystate = yyn;
#line 2013
  yyvsp ++;
#line 2013
  *yyvsp = yylval;
#line 2016
  goto yynewstate;
  yydefault: 
#line 2023
  yyn = (int )yydefact___0[yystate];
#line 2024
  if (yyn == 0) {
#line 2025
    goto yyerrlab;
  }
#line 2026
  goto yyreduce;
  yyreduce: 
#line 2034
  yylen = (int )yyr2___0[yyn];
#line 2044
  yyval = *(yyvsp + (1 - yylen));
  {
#line 2050
  if (yyn == 3) {
#line 2050
    goto case_3;
  }
#line 209
  if (yyn == 5) {
#line 209 "awkgram.y"
    goto case_5;
  }
#line 216
  if (yyn == 6) {
#line 216
    goto case_6;
  }
#line 225
  if (yyn == 7) {
#line 225
    goto case_7;
  }
#line 232
  if (yyn == 8) {
#line 232
    goto case_8;
  }
#line 243
  if (yyn == 9) {
#line 243
    goto case_9;
  }
#line 249
  if (yyn == 10) {
#line 249
    goto case_10;
  }
#line 254
  if (yyn == 11) {
#line 254
    goto case_11;
  }
#line 259
  if (yyn == 12) {
#line 259
    goto case_12;
  }
#line 270
  if (yyn == 13) {
#line 270
    goto case_13;
  }
#line 272
  if (yyn == 14) {
#line 272
    goto case_14;
  }
#line 274
  if (yyn == 15) {
#line 274
    goto case_15;
  }
#line 285
  if (yyn == 16) {
#line 285
    goto case_16;
  }
#line 287
  if (yyn == 17) {
#line 287
    goto case_17;
  }
#line 289
  if (yyn == 18) {
#line 289
    goto case_18;
  }
#line 294
  if (yyn == 19) {
#line 294
    goto case_19;
  }
#line 296
  if (yyn == 20) {
#line 296
    goto case_20;
  }
#line 322
  if (yyn == 21) {
#line 322
    goto case_21;
  }
#line 333
  if (yyn == 22) {
#line 333
    goto case_22;
  }
#line 344
  if (yyn == 23) {
#line 344
    goto case_23;
  }
#line 350
  if (yyn == 24) {
#line 350
    goto case_24;
  }
#line 356
  if (yyn == 25) {
#line 356
    goto case_25;
  }
#line 366
  if (yyn == 26) {
#line 366
    goto case_26;
  }
#line 371
  if (yyn == 27) {
#line 371
    goto case_27;
  }
#line 373
  if (yyn == 28) {
#line 373
    goto case_28;
  }
#line 379
  if (yyn == 29) {
#line 379
    goto case_29;
  }
#line 381
  if (yyn == 32) {
#line 381
    goto case_32;
  }
#line 400
  if (yyn == 33) {
#line 400
    goto case_33;
  }
#line 409
  if (yyn == 34) {
#line 409
    goto case_34;
  }
#line 438
  if (yyn == 35) {
#line 438
    goto case_35;
  }
#line 443
  if (yyn == 37) {
#line 443
    goto case_37;
  }
#line 449
  if (yyn == 38) {
#line 449
    goto case_38;
  }
#line 462
  if (yyn == 39) {
#line 462
    goto case_39;
  }
#line 464
  if (yyn == 42) {
#line 464
    goto case_42;
  }
#line 474
  if (yyn == 43) {
#line 474
    goto case_43;
  }
#line 476
  if (yyn == 44) {
#line 476
    goto case_44;
  }
#line 483
  if (yyn == 45) {
#line 483
    goto case_45;
  }
#line 573
  if (yyn == 46) {
#line 573
    goto case_46;
  }
#line 615
  if (yyn == 47) {
#line 615
    goto case_47;
  }
#line 657
  if (yyn == 48) {
#line 657
    goto case_48;
  }
#line 770
  if (yyn == 49) {
#line 770
    goto case_49;
  }
#line 777
  if (yyn == 50) {
#line 777
    goto case_50;
  }
#line 784
  if (yyn == 51) {
#line 784
    goto case_51;
  }
#line 791
  if (yyn == 52) {
#line 791
    goto case_52;
  }
#line 803
  if (yyn == 53) {
#line 803
    goto case_53;
  }
#line 812
  if (yyn == 54) {
#line 812
    goto case_54;
  }
#line 821
  if (yyn == 55) {
#line 821
    goto case_55;
  }
#line 832
  if (yyn == 56) {
#line 832
    goto case_56;
  }
#line 847
  if (yyn == 57) {
#line 847
    goto case_57;
  }
#line 852
  if (yyn == 58) {
#line 852
    goto case_58;
  }
#line 871
  if (yyn == 60) {
#line 871
    goto case_60;
  }
#line 884
  if (yyn == 61) {
#line 884
    goto case_61;
  }
#line 980
  if (yyn == 62) {
#line 980
    goto case_62;
  }
#line 982
  if (yyn == 63) {
#line 982
    goto case_63;
  }
#line 1014
  if (yyn == 64) {
#line 1014
    goto case_64;
  }
#line 1044
  if (yyn == 65) {
#line 1044
    goto case_65;
  }
#line 1046
  if (yyn == 66) {
#line 1046
    goto case_66;
  }
#line 1051
  if (yyn == 67) {
#line 1051
    goto case_67;
  }
#line 1053
  if (yyn == 68) {
#line 1053
    goto case_68;
  }
#line 1058
  if (yyn == 69) {
#line 1058
    goto case_69;
  }
#line 1065
  if (yyn == 70) {
#line 1065
    goto case_70;
  }
#line 1067
  if (yyn == 71) {
#line 1067
    goto case_71;
  }
#line 1082
  if (yyn == 72) {
#line 1082
    goto case_72;
  }
#line 1093
  if (yyn == 73) {
#line 1093
    goto case_73;
  }
#line 1098
  if (yyn == 74) {
#line 1098
    goto case_74;
  }
#line 1106
  if (yyn == 75) {
#line 1106
    goto case_75;
  }
#line 1111
  if (yyn == 76) {
#line 1111
    goto case_76;
  }
#line 1113
  if (yyn == 77) {
#line 1113
    goto case_77;
  }
#line 1118
  if (yyn == 78) {
#line 1118
    goto case_78;
  }
#line 1123
  if (yyn == 79) {
#line 1123
    goto case_79;
  }
#line 1125
  if (yyn == 81) {
#line 1125
    goto case_81;
  }
#line 1137
  if (yyn == 82) {
#line 1137
    goto case_82;
  }
#line 1146
  if (yyn == 83) {
#line 1146
    goto case_83;
  }
#line 1147
  if (yyn == 84) {
#line 1147
    goto case_84;
  }
#line 1154
  if (yyn == 85) {
#line 1154
    goto case_85;
  }
#line 1161
  if (yyn == 86) {
#line 1161
    goto case_86;
  }
#line 1166
  if (yyn == 91) {
#line 1166
    goto case_91;
  }
#line 1181
  if (yyn == 92) {
#line 1181
    goto case_92;
  }
#line 1186
  if (yyn == 93) {
#line 1186
    goto case_93;
  }
#line 1191
  if (yyn == 94) {
#line 1191
    goto case_94;
  }
#line 1193
  if (yyn == 95) {
#line 1193
    goto case_95;
  }
#line 1201
  if (yyn == 96) {
#line 1201
    goto case_96;
  }
#line 1207
  if (yyn == 97) {
#line 1207
    goto case_97;
  }
#line 1209
  if (yyn == 98) {
#line 1209
    goto case_98;
  }
#line 1211
  if (yyn == 99) {
#line 1211
    goto case_99;
  }
#line 1213
  if (yyn == 100) {
#line 1213
    goto case_100;
  }
#line 1219
  if (yyn == 101) {
#line 1219
    goto case_101;
  }
#line 1221
  if (yyn == 102) {
#line 1221
    goto case_102;
  }
#line 1226
  if (yyn == 103) {
#line 1226
    goto case_103;
  }
#line 1228
  if (yyn == 104) {
#line 1228
    goto case_104;
  }
#line 1233
  if (yyn == 105) {
#line 1233
    goto case_105;
  }
#line 1238
  if (yyn == 106) {
#line 1238
    goto case_106;
  }
#line 1240
  if (yyn == 107) {
#line 1240
    goto case_107;
  }
#line 1248
  if (yyn == 108) {
#line 1248
    goto case_108;
  }
#line 1253
  if (yyn == 109) {
#line 1253
    goto case_109;
  }
#line 1258
  if (yyn == 110) {
#line 1258
    goto case_110;
  }
#line 1269
  if (yyn == 111) {
#line 1269
    goto case_111;
  }
#line 1271
  if (yyn == 112) {
#line 1271
    goto case_112;
  }
#line 1273
  if (yyn == 113) {
#line 1273
    goto case_113;
  }
#line 1289
  if (yyn == 114) {
#line 1289
    goto case_114;
  }
#line 1299
  if (yyn == 115) {
#line 1299
    goto case_115;
  }
#line 1306
  if (yyn == 116) {
#line 1306
    goto case_116;
  }
#line 1308
  if (yyn == 117) {
#line 1308
    goto case_117;
  }
#line 1310
  if (yyn == 118) {
#line 1310
    goto case_118;
  }
#line 1315
  if (yyn == 119) {
#line 1315
    goto case_119;
  }
#line 1317
  if (yyn == 120) {
#line 1317
    goto case_120;
  }
#line 1322
  if (yyn == 121) {
#line 1322
    goto case_121;
  }
#line 1327
  if (yyn == 122) {
#line 1327
    goto case_122;
  }
#line 1329
  if (yyn == 123) {
#line 1329
    goto case_123;
  }
#line 1334
  if (yyn == 124) {
#line 1334
    goto case_124;
  }
#line 1336
  if (yyn == 125) {
#line 1336
    goto case_125;
  }
#line 1341
  if (yyn == 126) {
#line 1341
    goto case_126;
  }
#line 1343
  if (yyn == 127) {
#line 1343
    goto case_127;
  }
#line 1390
  if (yyn == 129) {
#line 1390
    goto case_129;
  }
#line 1397
  if (yyn == 130) {
#line 1397
    goto case_130;
  }
#line 1399
  if (yyn == 131) {
#line 1399
    goto case_131;
  }
#line 1401
  if (yyn == 132) {
#line 1401
    goto case_132;
  }
#line 1403
  if (yyn == 133) {
#line 1403
    goto case_133;
  }
#line 1405
  if (yyn == 134) {
#line 1405
    goto case_134;
  }
#line 1407
  if (yyn == 135) {
#line 1407
    goto case_135;
  }
#line 1430
  if (yyn == 136) {
#line 1430
    goto case_136;
  }
#line 1435
  if (yyn == 137) {
#line 1435
    goto case_137;
  }
#line 1440
  if (yyn == 138) {
#line 1440
    goto case_138;
  }
#line 1460
  if (yyn == 139) {
#line 1460
    goto case_139;
  }
#line 1470
  if (yyn == 140) {
#line 1470
    goto case_140;
  }
#line 1473
  if (yyn == 141) {
#line 1473
    goto case_141;
  }
#line 1475
  if (yyn == 142) {
#line 1475
    goto case_142;
  }
#line 1477
  if (yyn == 143) {
#line 1477
    goto case_143;
  }
#line 1479
  if (yyn == 144) {
#line 1479
    goto case_144;
  }
#line 1481
  if (yyn == 145) {
#line 1481
    goto case_145;
  }
#line 1483
  if (yyn == 146) {
#line 1483
    goto case_146;
  }
#line 1490
  if (yyn == 147) {
#line 1490
    goto case_147;
  }
#line 1522
  if (yyn == 148) {
#line 1522
    goto case_148;
  }
#line 1524
  if (yyn == 149) {
#line 1524
    goto case_149;
  }
#line 1530
  if (yyn == 150) {
#line 1530
    goto case_150;
  }
#line 1536
  if (yyn == 151) {
#line 1536
    goto case_151;
  }
#line 1549
  if (yyn == 154) {
#line 1549
    goto case_154;
  }
#line 1556
  if (yyn == 155) {
#line 1556
    goto case_155;
  }
#line 1561
  if (yyn == 156) {
#line 1561
    goto case_156;
  }
#line 1565
  if (yyn == 157) {
#line 1565
    goto case_157;
  }
#line 1569
  if (yyn == 158) {
#line 1569
    goto case_158;
  }
#line 1584
  if (yyn == 159) {
#line 1584
    goto case_159;
  }
#line 1594
  if (yyn == 160) {
#line 1594
    goto case_160;
  }
#line 1602
  if (yyn == 161) {
#line 1602
    goto case_161;
  }
#line 1635
  if (yyn == 162) {
#line 1635
    goto case_162;
  }
#line 1652
  if (yyn == 163) {
#line 1652
    goto case_163;
  }
#line 1657
  if (yyn == 164) {
#line 1657
    goto case_164;
  }
#line 1659
  if (yyn == 165) {
#line 1659
    goto case_165;
  }
#line 1664
  if (yyn == 166) {
#line 1664
    goto case_166;
  }
#line 1666
  if (yyn == 167) {
#line 1666
    goto case_167;
  }
#line 1671
  if (yyn == 168) {
#line 1671
    goto case_168;
  }
#line 1675
  if (yyn == 169) {
#line 1675
    goto case_169;
  }
#line 1692
  if (yyn == 170) {
#line 1692
    goto case_170;
  }
#line 1709
  if (yyn == 171) {
#line 1709
    goto case_171;
  }
#line 1714
  if (yyn == 172) {
#line 1714
    goto case_172;
  }
#line 1718
  if (yyn == 173) {
#line 1718
    goto case_173;
  }
#line 1723
  if (yyn == 174) {
#line 1723
    goto case_174;
  }
#line 1734
  if (yyn == 175) {
#line 1734
    goto case_175;
  }
#line 1741
  if (yyn == 176) {
#line 1741
    goto case_176;
  }
#line 1756
  if (yyn == 177) {
#line 1756
    goto case_177;
  }
#line 1762
  if (yyn == 178) {
#line 1762
    goto case_178;
  }
#line 1769
  if (yyn == 179) {
#line 1769
    goto case_179;
  }
#line 1773
  if (yyn == 180) {
#line 1773
    goto case_180;
  }
#line 1774
  if (yyn == 182) {
#line 1774
    goto case_182;
  }
#line 1782
  if (yyn == 183) {
#line 1782
    goto case_183;
  }
#line 1786
  if (yyn == 186) {
#line 1786
    goto case_186;
  }
#line 1795
  if (yyn == 187) {
#line 1795
    goto case_187;
  }
#line 1799
  if (yyn == 188) {
#line 1799
    goto case_188;
  }
#line 4118 "awkgram.c"
  goto switch_default;
  case_3: /* CIL Label */ 
#line 204 "awkgram.y"
  rule = 0;
#line 205
  yyerrstatus = 0;
#line 207
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 210
  next_sourcefile();
  }
#line 211
  if ((unsigned long )sourcefile == (unsigned long )srcfiles) {
    {
#line 212
    process_deferred();
    }
  }
#line 214
  goto switch_break;
  case_6: /* CIL Label */ 
#line 216
  rule = 0;
#line 223
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 228
  append_rule(*(yyvsp + -1), *(yyvsp + 0));
  }
#line 230
  goto switch_break;
  case_8: /* CIL Label */ 
#line 232
  if (rule != 2) {
    {
#line 233
    tmp___2 = gettext("%s blocks must have an action part");
#line 233
    msg((char const   *)tmp___2, ruletab[rule]);
#line 234
    errcount___0 ++;
    }
  } else
#line 235
  if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
    {
#line 236
    tmp___3 = gettext("each rule must have a pattern or an action part");
#line 236
    msg((char const   *)tmp___3);
#line 237
    errcount___0 ++;
    }
  } else {
    {
#line 239
    append_rule(*(yyvsp + -1), (INSTRUCTION *)((void *)0));
    }
  }
#line 241
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 243
  in_function = (char *)((void *)0);
#line 244
  mk_function(*(yyvsp + -1), *(yyvsp + 0));
#line 245
  yyerrstatus = 0;
  }
#line 247
  goto switch_break;
  case_10: /* CIL Label */ 
#line 249
  want_source = (_Bool)0;
#line 250
  yyerrstatus = 0;
#line 252
  goto switch_break;
  case_11: /* CIL Label */ 
#line 254
  want_source = (_Bool)0;
#line 255
  yyerrstatus = 0;
#line 257
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 262
  tmp___4 = include_source(*(yyvsp + 0));
  }
#line 262
  if (tmp___4 < 0) {
#line 263
    goto yyabortlab;
  }
  {
#line 264
  free((void *)(*(yyvsp + 0))->d.name);
#line 265
  bcfree(*(yyvsp + 0));
#line 266
  yyval = (INSTRUCTION *)((void *)0);
  }
#line 268
  goto switch_break;
  case_13: /* CIL Label */ 
#line 269
  yyval = (INSTRUCTION *)((void *)0);
#line 270
  goto switch_break;
  case_14: /* CIL Label */ 
#line 271
  yyval = (INSTRUCTION *)((void *)0);
#line 272
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 277
  tmp___5 = load_library(*(yyvsp + 0));
  }
#line 277
  if (tmp___5 < 0) {
#line 278
    goto yyabortlab;
  }
  {
#line 279
  free((void *)(*(yyvsp + 0))->d.name);
#line 280
  bcfree(*(yyvsp + 0));
#line 281
  yyval = (INSTRUCTION *)((void *)0);
  }
#line 283
  goto switch_break;
  case_16: /* CIL Label */ 
#line 284
  yyval = (INSTRUCTION *)((void *)0);
#line 285
  goto switch_break;
  case_17: /* CIL Label */ 
#line 286
  yyval = (INSTRUCTION *)((void *)0);
#line 287
  goto switch_break;
  case_18: /* CIL Label */ 
#line 291
  yyval = (INSTRUCTION *)((void *)0);
#line 291
  rule = 2;
#line 292
  goto switch_break;
  case_19: /* CIL Label */ 
#line 293
  yyval = *(yyvsp + 0);
#line 293
  rule = 2;
#line 294
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 298
  add_lint(*(yyvsp + -3), (LINTTYPE )1);
#line 299
  add_lint(*(yyvsp + 0), (LINTTYPE )1);
#line 301
  tp = bcalloc((OPCODE )81, 1, 0);
#line 302
  tmp___6 = bcalloc((OPCODE )14, ! (! (do_flags & 256)) + 1, 0);
#line 302
  list_prepend(*(yyvsp + -3), tmp___6);
#line 303
  ((*(yyvsp + -3))->nexti)->x.xl = 0L;
#line 304
  ((*(yyvsp + -3))->nexti)->d.di = (*(yyvsp + 0))->nexti;
#line 306
  tmp___7 = bcalloc((OPCODE )15, 1, 0);
#line 306
  list_append(*(yyvsp + -3), tmp___7);
#line 307
  ((*(yyvsp + -3))->d.di)->x.xi = (*(yyvsp + -3))->nexti;
#line 308
  ((*(yyvsp + -3))->d.di)->d.di = tp;
#line 310
  tmp___8 = bcalloc((OPCODE )15, 1, 0);
#line 310
  list_append(*(yyvsp + 0), tmp___8);
#line 311
  ((*(yyvsp + 0))->d.di)->x.xi = (*(yyvsp + -3))->nexti;
#line 312
  ((*(yyvsp + 0))->d.di)->d.di = tp;
  }
#line 313
  if (do_flags & 256) {
#line 314
    ((*(yyvsp + -3))->nexti + 1)->d.di = (*(yyvsp + -3))->d.di;
#line 315
    ((*(yyvsp + -3))->nexti + 1)->x.xi = (*(yyvsp + 0))->d.di;
  }
  {
#line 317
  tmp___9 = list_merge(*(yyvsp + -3), *(yyvsp + 0));
#line 317
  yyval = list_append(tmp___9, tp);
#line 318
  rule = 2;
  }
#line 320
  goto switch_break;
  case_21: /* CIL Label */ 
#line 323
  if (do_flags & 4) {
#line 323
    begin_seen ++;
#line 323
    if (begin_seen == 2) {
      {
#line 324
      tmp___10 = gettext("old awk does not support multiple `BEGIN\' or `END\' rules");
#line 324
      warning_ln((int )(*(yyvsp + 0))->source_line, (char const   *)tmp___10);
      }
    }
  }
#line 327
  rule = 1;
#line 327
  (*(yyvsp + 0))->x.xl = (long )rule;
#line 328
  (*(yyvsp + 0))->d.name = source;
#line 329
  yyval = *(yyvsp + 0);
#line 331
  goto switch_break;
  case_22: /* CIL Label */ 
#line 334
  if (do_flags & 4) {
#line 334
    end_seen ++;
#line 334
    if (end_seen == 2) {
      {
#line 335
      tmp___11 = gettext("old awk does not support multiple `BEGIN\' or `END\' rules");
#line 335
      warning_ln((int )(*(yyvsp + 0))->source_line, (char const   *)tmp___11);
      }
    }
  }
#line 338
  rule = 3;
#line 338
  (*(yyvsp + 0))->x.xl = (long )rule;
#line 339
  (*(yyvsp + 0))->d.name = source;
#line 340
  yyval = *(yyvsp + 0);
#line 342
  goto switch_break;
  case_23: /* CIL Label */ 
#line 344
  rule = 4;
#line 344
  (*(yyvsp + 0))->x.xl = (long )rule;
#line 345
  (*(yyvsp + 0))->d.name = source;
#line 346
  yyval = *(yyvsp + 0);
#line 348
  goto switch_break;
  case_24: /* CIL Label */ 
#line 350
  rule = 5;
#line 350
  (*(yyvsp + 0))->x.xl = (long )rule;
#line 351
  (*(yyvsp + 0))->d.name = source;
#line 352
  yyval = *(yyvsp + 0);
#line 354
  goto switch_break;
  case_25: /* CIL Label */ 
#line 359
  if ((unsigned long )*(yyvsp + -3) == (unsigned long )((void *)0)) {
    {
#line 360
    tmp___12 = bcalloc((OPCODE )81, 1, 0);
#line 360
    yyval = list_create(tmp___12);
    }
  } else {
#line 362
    yyval = *(yyvsp + -3);
  }
#line 364
  goto switch_break;
  case_26: /* CIL Label */ 
#line 368
  yyval = *(yyvsp + 0);
#line 369
  goto switch_break;
  case_27: /* CIL Label */ 
#line 370
  yyval = *(yyvsp + 0);
#line 371
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 373
  tmp___13 = gettext("`%s\' is a built-in function, it cannot be redefined");
#line 373
  yyerror((char const   *)tmp___13, tokstart);
  }
#line 375
  goto yyabortlab;
#line 377
  goto switch_break;
  case_29: /* CIL Label */ 
#line 378
  yyval = *(yyvsp + 0);
#line 379
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 389
  (*(yyvsp + -5))->d.name = source;
#line 390
  tmp___14 = install_function((*(yyvsp + -4))->d.name, *(yyvsp + -5), *(yyvsp + -2));
  }
#line 390
  if (tmp___14 < 0) {
#line 391
    goto yyabortlab;
  }
  {
#line 392
  in_function = (*(yyvsp + -4))->d.name;
#line 393
  (*(yyvsp + -4))->d.name = (char *)((void *)0);
#line 394
  bcfree(*(yyvsp + -4));
#line 396
  yyval = *(yyvsp + -5);
  }
#line 398
  goto switch_break;
  case_33: /* CIL Label */ 
#line 406
  want_regexp = (_Bool)1;
#line 407
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 413
  re = (*(yyvsp + 0))->d.name;
#line 414
  (*(yyvsp + 0))->d.name = (char *)((void *)0);
#line 415
  len = strlen((char const   *)re);
  }
#line 416
  if (do_flags & 3) {
#line 417
    if (len == 0UL) {
      {
#line 418
      tmp___15 = gettext("regexp constant `//\' looks like a C++ comment, but is not");
#line 418
      lintwarn_ln((int )(*(yyvsp + 0))->source_line, (char const   *)tmp___15);
      }
    } else
#line 420
    if ((int )*(re + 0) == 42) {
#line 420
      if ((int )*(re + (len - 1UL)) == 42) {
        {
#line 422
        tmp___16 = gettext("regexp constant `/%s/\' looks like a C comment, but is not");
#line 422
        lintwarn_ln((int )(*(yyvsp + 0))->source_line, (char const   *)tmp___16, re);
        }
      }
    }
  }
  {
#line 426
  exp___0 = make_str_node((char const   *)re, len, 2);
#line 427
  n = make_regnode(2, exp___0);
  }
#line 428
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    {
#line 429
    unref(exp___0);
    }
#line 430
    goto yyabortlab;
  }
#line 432
  yyval = *(yyvsp + 0);
#line 433
  yyval->opcode = (OPCODE )47;
#line 434
  yyval->d.dn = n;
#line 436
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 440
  bcfree(*(yyvsp + 0));
  }
#line 441
  goto switch_break;
  case_37: /* CIL Label */ 
#line 446
  yyval = (INSTRUCTION *)((void *)0);
#line 447
  goto switch_break;
  case_38: /* CIL Label */ 
#line 449
  if ((unsigned long )*(yyvsp + 0) == (unsigned long )((void *)0)) {
#line 450
    yyval = *(yyvsp + -1);
  } else {
    {
#line 452
    add_lint(*(yyvsp + 0), (LINTTYPE )2);
    }
#line 453
    if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
#line 454
      yyval = *(yyvsp + 0);
    } else {
      {
#line 456
      yyval = list_merge(*(yyvsp + -1), *(yyvsp + 0));
      }
    }
  }
#line 458
  yyerrstatus = 0;
#line 460
  goto switch_break;
  case_39: /* CIL Label */ 
#line 461
  yyval = (INSTRUCTION *)((void *)0);
#line 462
  goto switch_break;
  case_42: /* CIL Label */ 
#line 471
  yyval = (INSTRUCTION *)((void *)0);
#line 472
  goto switch_break;
  case_43: /* CIL Label */ 
#line 473
  yyval = *(yyvsp + -1);
#line 474
  goto switch_break;
  case_44: /* CIL Label */ 
#line 476
  if (do_flags & 256) {
    {
#line 477
    tmp___17 = bcalloc((OPCODE )98, 1, 0);
#line 477
    yyval = list_prepend(*(yyvsp + 0), tmp___17);
    }
  } else {
#line 479
    yyval = *(yyvsp + 0);
  }
#line 481
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 483
  curr = (INSTRUCTION *)((void *)0);
#line 485
  case_values = (char const   **)((void *)0);
#line 486
  maxcount = 128;
#line 487
  case_count = 0;
#line 490
  tbreak = bcalloc((OPCODE )81, 1, 0);
#line 491
  cstmt = list_create(tbreak);
#line 492
  tmp___18 = bcalloc((OPCODE )82, 1, 0);
#line 492
  cexp = list_create(tmp___18);
#line 493
  dflt = bcalloc((OPCODE )83, 1, 0);
#line 494
  dflt->d.di = tbreak;
  }
#line 496
  if ((unsigned long )*(yyvsp + -2) != (unsigned long )((void *)0)) {
    {
#line 497
    curr = (*(yyvsp + -2))->nexti;
#line 498
    bcfree(*(yyvsp + -2));
    }
  }
  {
#line 502
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 502
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 502
      goto while_break___1;
    }
#line 503
    caseexp = curr->d.di;
#line 504
    casestmt = curr->x.xi;
#line 506
    nextc___0 = curr->nexti;
#line 507
    if ((unsigned int )curr->opcode == 50U) {
#line 508
      if ((unsigned int )caseexp->opcode == 74U) {
        {
#line 511
        tmp___19 = force_string(caseexp->d.dn);
#line 511
        caseval = tmp___19->sub.val.sp;
#line 512
        i___0 = 0;
        }
        {
#line 512
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 512
          if (! (i___0 < case_count)) {
#line 512
            goto while_break___2;
          }
          {
#line 513
          tmp___21 = strcmp((char const   *)caseval, *(case_values + i___0));
          }
#line 513
          if (tmp___21 == 0) {
            {
#line 514
            tmp___20 = gettext("duplicate case values in switch body: %s");
#line 514
            error_ln((int )curr->source_line, (char const   *)tmp___20, caseval);
            }
          }
#line 512
          i___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 518
        if ((unsigned long )case_values == (unsigned long )((void *)0)) {
          {
#line 519
          tmp___22 = malloc(sizeof(char *) * (unsigned long )maxcount);
#line 519
          case_values = (char const   **)tmp___22;
          }
#line 519
          if (case_values) {
#line 519
            tmp___26 = 1;
          } else {
            {
#line 519
            set_loc("awkgram.y", 519);
#line 519
            tmp___23 = __errno_location();
#line 519
            tmp___24 = strerror(*tmp___23);
#line 519
            tmp___25 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 519
            r_fatal((char const   *)tmp___25, "statement", "case_values", (long )(sizeof(char *) * (unsigned long )maxcount),
                    tmp___24);
#line 519
            tmp___26 = 0;
            }
          }
        } else
#line 520
        if (case_count >= maxcount) {
          {
#line 521
          maxcount += 128;
#line 522
          tmp___27 = realloc((void *)((char *)case_values), sizeof(char *) * (unsigned long )maxcount);
#line 522
          case_values = (char const   **)tmp___27;
          }
#line 522
          if (case_values) {
#line 522
            tmp___31 = 1;
          } else {
            {
#line 522
            set_loc("awkgram.y", 522);
#line 522
            tmp___28 = __errno_location();
#line 522
            tmp___29 = strerror(*tmp___28);
#line 522
            tmp___30 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 522
            r_fatal((char const   *)tmp___30, "statement", "case_values", (long )(sizeof(char *) * (unsigned long )maxcount),
                    tmp___29);
#line 522
            tmp___31 = 0;
            }
          }
        }
#line 524
        tmp___32 = case_count;
#line 524
        case_count ++;
#line 524
        *(case_values + tmp___32) = (char const   *)caseval;
      } else {
#line 527
        (curr + 1)->x.xl = 1L;
      }
      {
#line 529
      curr->d.di = casestmt->nexti;
#line 530
      curr->x.xi = casestmt->d.di;
#line 531
      list_prepend(cexp, curr);
#line 532
      list_prepend(cexp, caseexp);
      }
    } else {
#line 534
      if ((unsigned long )dflt->d.di != (unsigned long )tbreak) {
        {
#line 535
        tmp___33 = gettext("duplicate `default\' detected in switch body");
#line 535
        error_ln((int )curr->source_line, (char const   *)tmp___33);
        }
      } else {
#line 538
        dflt->d.di = casestmt->nexti;
      }
#line 540
      if (do_flags & 256) {
        {
#line 541
        curr->d.di = casestmt->nexti;
#line 542
        curr->x.xi = casestmt->d.di;
#line 543
        list_prepend(cexp, curr);
        }
      } else {
        {
#line 545
        bcfree(curr);
        }
      }
    }
    {
#line 548
    cstmt = list_merge(casestmt, cstmt);
#line 502
    curr = nextc___0;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 551
  if ((unsigned long )case_values != (unsigned long )((void *)0)) {
    {
#line 552
    free((void *)case_values);
    }
  }
#line 554
  ip = *(yyvsp + -6);
#line 555
  if (do_flags & 256) {
    {
#line 556
    list_prepend(ip, *(yyvsp + -8));
#line 557
    tmp___34 = bcalloc((OPCODE )98, 1, 0);
#line 557
    list_prepend(ip, tmp___34);
#line 558
    (*(yyvsp + -8))->x.xi = tbreak;
#line 559
    (*(yyvsp + -8) + 1)->d.di = cexp->nexti;
#line 560
    (*(yyvsp + -8) + 1)->x.xi = cexp->d.di;
    }
  }
  {
#line 564
  list_append(cexp, dflt);
#line 565
  list_merge(ip, cexp);
#line 566
  yyval = list_merge(ip, cstmt);
#line 568
  break_allowed --;
#line 569
  fix_break_continue(ip, tbreak, (INSTRUCTION *)((void *)0));
  }
#line 571
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 588
  tbreak___0 = bcalloc((OPCODE )81, 1, 0);
#line 589
  add_lint(*(yyvsp + -3), (LINTTYPE )1);
#line 590
  tcont = (*(yyvsp + -3))->nexti;
#line 591
  tmp___35 = bcalloc((OPCODE )85, 1, 0);
#line 591
  ip___0 = list_append(*(yyvsp + -3), tmp___35);
#line 592
  (ip___0->d.di)->d.di = tbreak___0;
  }
#line 594
  if (do_flags & 256) {
    {
#line 595
    tmp___36 = bcalloc((OPCODE )98, 1, 0);
#line 595
    list_append(ip___0, tmp___36);
#line 596
    (*(yyvsp + -5))->x.xi = tbreak___0;
#line 597
    (*(yyvsp + -5))->d.di = tcont;
#line 598
    (*(yyvsp + -5) + 1)->d.di = ip___0->d.di;
#line 599
    list_prepend(ip___0, *(yyvsp + -5));
    }
  }
#line 603
  if ((unsigned long )*(yyvsp + 0) != (unsigned long )((void *)0)) {
    {
#line 604
    list_merge(ip___0, *(yyvsp + 0));
    }
  }
  {
#line 605
  tmp___37 = bcalloc((OPCODE )83, 1, 0);
#line 605
  list_append(ip___0, tmp___37);
#line 606
  (ip___0->d.di)->d.di = tcont;
#line 607
  yyval = list_append(ip___0, tbreak___0);
#line 609
  break_allowed --;
#line 610
  continue_allowed --;
#line 611
  fix_break_continue(ip___0, tbreak___0, tcont);
  }
#line 613
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 629
  tbreak___1 = bcalloc((OPCODE )81, 1, 0);
#line 630
  tcont___0 = (*(yyvsp + -2))->nexti;
#line 631
  add_lint(*(yyvsp + -2), (LINTTYPE )1);
  }
#line 632
  if ((unsigned long )*(yyvsp + -5) != (unsigned long )((void *)0)) {
    {
#line 633
    ip___1 = list_merge(*(yyvsp + -5), *(yyvsp + -2));
    }
  } else {
    {
#line 635
    tmp___38 = bcalloc((OPCODE )81, 1, 0);
#line 635
    ip___1 = list_prepend(*(yyvsp + -2), tmp___38);
    }
  }
#line 636
  if (do_flags & 256) {
    {
#line 637
    tmp___39 = bcalloc((OPCODE )98, 1, 0);
#line 637
    list_prepend(ip___1, tmp___39);
    }
  }
  {
#line 638
  tmp___40 = bcalloc((OPCODE )84, 1, 0);
#line 638
  list_append(ip___1, tmp___40);
#line 639
  (ip___1->d.di)->d.di = ip___1->nexti;
#line 640
  yyval = list_append(ip___1, tbreak___1);
#line 642
  break_allowed --;
#line 643
  continue_allowed --;
#line 644
  fix_break_continue(ip___1, tbreak___1, tcont___0);
  }
#line 646
  if (do_flags & 256) {
    {
#line 647
    (*(yyvsp + -7))->x.xi = tbreak___1;
#line 648
    (*(yyvsp + -7))->d.di = tcont___0;
#line 649
    (*(yyvsp + -7) + 1)->d.di = tcont___0;
#line 650
    yyval = list_prepend(ip___1, *(yyvsp + -7));
#line 651
    bcfree(*(yyvsp + -4));
    }
  }
#line 655
  goto switch_break;
  case_48: /* CIL Label */ 
#line 658
  var_name = (*(yyvsp + -5))->d.name;
#line 660
  if ((unsigned long )*(yyvsp + 0) != (unsigned long )((void *)0)) {
#line 660
    if ((unsigned int )((*(yyvsp + 0))->d.di)->opcode == 60U) {
#line 660
      if (((*(yyvsp + 0))->d.di)->x.xl == 1L) {
#line 660
        if ((unsigned int )((*(yyvsp + 0))->nexti)->opcode == 72U) {
#line 660
          if ((unsigned int )(((*(yyvsp + 0))->nexti)->d.dn)->type != 4U) {
#line 660
            goto _L___1;
          } else
#line 660
          if (! (((*(yyvsp + 0))->nexti)->d.dn)->sub.nodep.r.uptr) {
            _L___1: /* CIL Label */ 
            {
#line 660
            tmp___46 = strcmp((char const   *)(((*(yyvsp + 0))->nexti)->d.dn)->sub.nodep.name,
                              (char const   *)var_name);
            }
#line 660
            if (tmp___46 == 0) {
#line 680
              arr = (NODE *)((void *)0);
#line 682
              ip___2 = ((*(yyvsp + 0))->nexti)->nexti;
#line 683
              if ((unsigned int )((*(yyvsp + -3))->nexti)->opcode == 72U) {
#line 683
                if ((unsigned long )(*(yyvsp + -3))->d.di == (unsigned long )(*(yyvsp + -3))->nexti) {
#line 684
                  arr = ((*(yyvsp + -3))->nexti)->d.dn;
                }
              }
#line 685
              if ((unsigned long )arr != (unsigned long )((void *)0)) {
#line 685
                if ((unsigned int )ip___2->opcode == 81U) {
#line 685
                  if ((unsigned int )(ip___2->nexti)->opcode == 76U) {
                    {
#line 685
                    tmp___41 = strcmp((char const   *)((ip___2->nexti)->d.dn)->sub.nodep.name,
                                      (char const   *)arr->sub.nodep.name);
                    }
#line 685
                    if (tmp___41 == 0) {
#line 685
                      if ((unsigned long )(ip___2->nexti)->nexti == (unsigned long )(*(yyvsp + 0))->d.di) {
                        {
#line 691
                        make_assignable((*(yyvsp + 0))->nexti);
#line 692
                        ((*(yyvsp + 0))->d.di)->opcode = (OPCODE )61;
#line 693
                        ((*(yyvsp + 0))->d.di)->x.xl = 0L;
                        }
#line 694
                        if ((unsigned long )*(yyvsp + -7) != (unsigned long )((void *)0)) {
                          {
#line 695
                          bcfree(*(yyvsp + -7));
                          }
                        }
                        {
#line 696
                        free((void *)var_name);
#line 697
                        bcfree(*(yyvsp + -5));
#line 698
                        bcfree(*(yyvsp + -4));
#line 699
                        bcfree(*(yyvsp + -3));
#line 700
                        yyval = *(yyvsp + 0);
                        }
                      } else {
#line 702
                        goto regular_loop;
                      }
                    } else {
#line 702
                      goto regular_loop;
                    }
                  } else {
#line 702
                    goto regular_loop;
                  }
                } else {
#line 702
                  goto regular_loop;
                }
              } else {
#line 702
                goto regular_loop;
              }
            } else {
#line 660
              goto regular_loop;
            }
          } else {
#line 660
            goto regular_loop;
          }
        } else {
#line 660
          goto regular_loop;
        }
      } else {
#line 660
        goto regular_loop;
      }
    } else {
#line 660
      goto regular_loop;
    }
  } else {
    regular_loop: 
    {
#line 717
    ip___2 = *(yyvsp + -3);
#line 718
    (ip___2->nexti)->opcode = (OPCODE )76;
#line 720
    tbreak___2 = bcalloc((OPCODE )90, 1, 0);
#line 721
    (*(yyvsp + -4))->opcode = (OPCODE )89;
#line 722
    (*(yyvsp + -4))->x.xn = variable((int )(*(yyvsp + -5))->source_line, var_name,
                                     (NODETYPE )4);
#line 723
    (*(yyvsp + -4))->d.di = tbreak___2;
#line 724
    tcont___1 = *(yyvsp + -4);
#line 725
    (*(yyvsp + -5))->opcode = (OPCODE )88;
#line 726
    (*(yyvsp + -5))->d.di = tbreak___2;
#line 727
    list_append(ip___2, *(yyvsp + -5));
    }
#line 729
    if (do_flags & 256) {
      {
#line 730
      (*(yyvsp + -7))->opcode = (OPCODE )108;
#line 731
      (*(yyvsp + -7))->d.di = tcont___1;
#line 732
      (*(yyvsp + -7))->x.xi = tbreak___2;
#line 733
      list_append(ip___2, *(yyvsp + -7));
      }
    }
#line 738
    if ((unsigned int )((*(yyvsp + -4))->x.xn)->type == 4U) {
#line 738
      if (((*(yyvsp + -4))->x.xn)->sub.nodep.r.uptr) {
        {
#line 739
        tmp___42 = bcalloc((OPCODE )91, 1, 0);
#line 739
        list_append(ip___2, tmp___42);
#line 740
        (ip___2->d.di)->x.aptr = ((*(yyvsp + -4))->x.xn)->sub.nodep.r.uptr;
        }
      }
    }
    {
#line 742
    list_append(ip___2, *(yyvsp + -4));
    }
#line 745
    if ((unsigned int )((*(yyvsp + -4))->x.xn)->type == 4U) {
#line 745
      if (((*(yyvsp + -4))->x.xn)->sub.nodep.x.aptr) {
        {
#line 746
        tmp___43 = bcalloc((OPCODE )92, 1, 0);
#line 746
        list_append(ip___2, tmp___43);
#line 747
        (ip___2->d.di)->x.aptr = ((*(yyvsp + -4))->x.xn)->sub.nodep.x.aptr;
        }
      }
    }
#line 750
    if (do_flags & 256) {
      {
#line 751
      tmp___44 = bcalloc((OPCODE )98, 1, 0);
#line 751
      list_append(ip___2, tmp___44);
#line 752
      (*(yyvsp + -7) + 1)->d.di = *(yyvsp + -4);
#line 753
      (*(yyvsp + -7) + 1)->x.xi = ip___2->d.di;
      }
    }
#line 756
    if ((unsigned long )*(yyvsp + 0) != (unsigned long )((void *)0)) {
      {
#line 757
      list_merge(ip___2, *(yyvsp + 0));
      }
    }
    {
#line 759
    tmp___45 = bcalloc((OPCODE )83, 1, 0);
#line 759
    list_append(ip___2, tmp___45);
#line 760
    (ip___2->d.di)->d.di = *(yyvsp + -4);
#line 761
    yyval = list_append(ip___2, tbreak___2);
#line 762
    fix_break_continue(ip___2, tbreak___2, tcont___1);
    }
  }
#line 765
  break_allowed --;
#line 766
  continue_allowed --;
#line 768
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 770
  yyval = mk_for_loop(*(yyvsp + -11), *(yyvsp + -9), *(yyvsp + -6), *(yyvsp + -3),
                      *(yyvsp + 0));
#line 772
  break_allowed --;
#line 773
  continue_allowed --;
  }
#line 775
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 777
  yyval = mk_for_loop(*(yyvsp + -10), *(yyvsp + -8), (INSTRUCTION *)((void *)0), *(yyvsp + -3),
                      *(yyvsp + 0));
#line 779
  break_allowed --;
#line 780
  continue_allowed --;
  }
#line 782
  goto switch_break;
  case_51: /* CIL Label */ 
#line 784
  if (do_flags & 256) {
    {
#line 785
    tmp___47 = bcalloc((OPCODE )98, 1, 0);
#line 785
    yyval = list_prepend(*(yyvsp + 0), tmp___47);
    }
  } else {
#line 787
    yyval = *(yyvsp + 0);
  }
#line 789
  goto switch_break;
  case_52: /* CIL Label */ 
#line 794
  if (! break_allowed) {
    {
#line 795
    tmp___48 = gettext("`break\' is not allowed outside a loop or switch");
#line 795
    error_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___48);
    }
  }
  {
#line 797
  (*(yyvsp + -1))->d.di = (struct exp_instruction *)((void *)0);
#line 798
  yyval = list_create(*(yyvsp + -1));
  }
#line 801
  goto switch_break;
  case_53: /* CIL Label */ 
#line 803
  if (! continue_allowed) {
    {
#line 804
    tmp___49 = gettext("`continue\' is not allowed outside a loop");
#line 804
    error_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___49);
    }
  }
  {
#line 806
  (*(yyvsp + -1))->d.di = (struct exp_instruction *)((void *)0);
#line 807
  yyval = list_create(*(yyvsp + -1));
  }
#line 810
  goto switch_break;
  case_54: /* CIL Label */ 
#line 813
  if (rule) {
#line 813
    if (rule != 2) {
      {
#line 814
      tmp___50 = gettext("`next\' used in %s action");
#line 814
      error_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___50, ruletab[rule]);
      }
    }
  }
  {
#line 816
  (*(yyvsp + -1))->d.di = ip_rec;
#line 817
  yyval = list_create(*(yyvsp + -1));
  }
#line 819
  goto switch_break;
  case_55: /* CIL Label */ 
#line 822
  if (rule == 1) {
    {
#line 823
    tmp___51 = gettext("`nextfile\' used in %s action");
#line 823
    error_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___51, ruletab[rule]);
    }
  } else
#line 822
  if (rule == 3) {
    {
#line 823
    tmp___51 = gettext("`nextfile\' used in %s action");
#line 823
    error_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___51, ruletab[rule]);
    }
  } else
#line 822
  if (rule == 5) {
    {
#line 823
    tmp___51 = gettext("`nextfile\' used in %s action");
#line 823
    error_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___51, ruletab[rule]);
    }
  }
  {
#line 826
  (*(yyvsp + -1))->d.di = ip_newfile;
#line 827
  (*(yyvsp + -1))->x.xi = ip_endfile;
#line 828
  yyval = list_create(*(yyvsp + -1));
  }
#line 830
  goto switch_break;
  case_56: /* CIL Label */ 
#line 835
  (*(yyvsp + -2))->d.di = ip_end;
#line 836
  (*(yyvsp + -2))->x.xi = ip_atexit;
#line 838
  if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
    {
#line 839
    yyval = list_create(*(yyvsp + -2));
#line 840
    tmp___52 = bcalloc((OPCODE )74, 1, 0);
#line 840
    list_prepend(yyval, tmp___52);
#line 841
    (yyval->nexti)->d.dn = dupnode(Nnull_string);
    }
  } else {
    {
#line 843
    yyval = list_append(*(yyvsp + -1), *(yyvsp + -2));
    }
  }
#line 845
  goto switch_break;
  case_57: /* CIL Label */ 
#line 847
  if (! in_function) {
    {
#line 848
    tmp___53 = gettext("`return\' used outside function context");
#line 848
    yyerror((char const   *)tmp___53);
    }
  }
#line 850
  goto switch_break;
  case_58: /* CIL Label */ 
#line 850
  if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
    {
#line 851
    yyval = list_create(*(yyvsp + -3));
#line 852
    tmp___54 = bcalloc((OPCODE )74, 1, 0);
#line 852
    list_prepend(yyval, tmp___54);
#line 853
    (yyval->nexti)->d.dn = dupnode(Nnull_string);
    }
  } else {
#line 855
    if ((int )do_optimize > 1) {
#line 855
      if ((unsigned int )((*(yyvsp + -1))->d.di)->opcode == 70U) {
        {
#line 855
        tmp___55 = strcmp((char const   *)((*(yyvsp + -1))->d.di)->d.name, (char const   *)in_function);
        }
#line 855
        if (tmp___55 == 0) {
#line 863
          ((*(yyvsp + -1))->d.di + 1)->d.dl = 1L;
        }
      }
    }
    {
#line 866
    yyval = list_append(*(yyvsp + -1), *(yyvsp + -3));
    }
  }
#line 869
  goto switch_break;
  case_60: /* CIL Label */ 
#line 881
  in_print = (_Bool)1;
#line 881
  in_parens = 0;
#line 882
  goto switch_break;
  case_61: /* CIL Label */ 
#line 889
  if ((unsigned int )(*(yyvsp + -3))->opcode == 54U) {
#line 889
    if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
#line 889
      goto _L___7;
    } else
#line 889
    if ((unsigned int )((*(yyvsp + -1))->d.di)->opcode == 23U) {
#line 889
      if ((unsigned long )(((*(yyvsp + -1))->nexti)->nexti)->nexti == (unsigned long )(*(yyvsp + -1))->d.di) {
#line 889
        if ((unsigned int )(((*(yyvsp + -1))->nexti)->nexti)->opcode == 74U) {
#line 889
          if ((unsigned int )((((*(yyvsp + -1))->nexti)->nexti)->d.dn)->type == 1U) {
            _L___7: /* CIL Label */ 
#line 907
            if ((unsigned long )*(yyvsp + -1) != (unsigned long )((void *)0)) {
#line 908
              n___0 = (((*(yyvsp + -1))->nexti)->nexti)->d.dn;
#line 910
              if (n___0->flags & 2048U) {
#line 910
                tmp___58 = n___0->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 1UL);
              } else {
#line 910
                if (n___0->flags & 4096U) {
#line 910
                  if (n___0->sub.val.nm.mpi[0]._mp_size < 0) {
#line 910
                    tmp___56 = -1;
                  } else {
#line 910
                    tmp___56 = n___0->sub.val.nm.mpi[0]._mp_size > 0;
                  }
#line 910
                  tmp___57 = tmp___56 == 0;
                } else {
#line 910
                  tmp___57 = n___0->sub.val.nm.fltnum == 0.0;
                }
#line 910
                tmp___58 = tmp___57;
              }
#line 910
              if (! tmp___58) {
#line 911
                goto regular_print;
              }
              {
#line 913
              bcfree((*(yyvsp + -1))->d.di);
#line 914
              unref(n___0);
#line 915
              bcfree(((*(yyvsp + -1))->nexti)->nexti);
#line 916
              bcfree((*(yyvsp + -1))->nexti);
#line 917
              bcfree(*(yyvsp + -1));
              }
            } else
#line 919
            if (do_flags & 3) {
#line 919
              if (rule == 1) {
#line 919
                goto _L___5;
              } else
#line 919
              if (rule == 3) {
                _L___5: /* CIL Label */ 
#line 919
                if (! warned___18) {
                  {
#line 920
                  warned___18 = (_Bool)1;
#line 921
                  tmp___59 = gettext("plain `print\' in BEGIN or END rule should probably be `print \"\"\'");
#line 921
                  lintwarn_ln((int )(*(yyvsp + -3))->source_line, (char const   *)tmp___59);
                  }
                }
              }
            }
#line 926
            (*(yyvsp + -3))->x.xl = 0L;
#line 927
            (*(yyvsp + -3))->opcode = (OPCODE )55;
#line 928
            if ((unsigned long )*(yyvsp + 0) == (unsigned long )((void *)0)) {
              {
#line 929
              (*(yyvsp + -3))->d.dl = 0L;
#line 930
              yyval = list_create(*(yyvsp + -3));
              }
            } else {
              {
#line 933
              ip___3 = (*(yyvsp + 0))->nexti;
#line 934
              (*(yyvsp + -3))->d.dl = ip___3->d.dl;
#line 935
              (*(yyvsp + 0))->nexti = ip___3->nexti;
#line 936
              bcfree(ip___3);
#line 937
              yyval = list_append(*(yyvsp + 0), *(yyvsp + -3));
              }
            }
          } else {
#line 889
            goto regular_print;
          }
        } else {
#line 889
          goto regular_print;
        }
      } else {
#line 889
        goto regular_print;
      }
    } else {
#line 889
      goto regular_print;
    }
  } else
  regular_print: 
#line 950
  if ((unsigned long )*(yyvsp + 0) == (unsigned long )((void *)0)) {
#line 951
    if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
      {
#line 952
      (*(yyvsp + -3))->x.xl = 0L;
#line 953
      (*(yyvsp + -3))->d.dl = 0L;
#line 954
      yyval = list_create(*(yyvsp + -3));
      }
    } else {
      {
#line 956
      t = *(yyvsp + -1);
#line 957
      tmp___60 = count_expressions(& t, (_Bool)0);
#line 957
      (*(yyvsp + -3))->x.xl = (long )tmp___60;
#line 958
      (*(yyvsp + -3))->d.dl = 0L;
#line 959
      yyval = list_append(t, *(yyvsp + -3));
      }
    }
  } else {
    {
#line 963
    ip___4 = (*(yyvsp + 0))->nexti;
#line 964
    (*(yyvsp + -3))->d.dl = ip___4->d.dl;
#line 965
    (*(yyvsp + 0))->nexti = ip___4->nexti;
#line 966
    bcfree(ip___4);
    }
#line 967
    if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
      {
#line 968
      (*(yyvsp + -3))->x.xl = 0L;
#line 969
      yyval = list_append(*(yyvsp + 0), *(yyvsp + -3));
      }
    } else {
      {
#line 971
      t___0 = *(yyvsp + -1);
#line 972
      tmp___61 = count_expressions(& t___0, (_Bool)0);
#line 972
      (*(yyvsp + -3))->x.xl = (long )tmp___61;
#line 973
      tmp___62 = list_merge(*(yyvsp + 0), t___0);
#line 973
      yyval = list_append(tmp___62, *(yyvsp + -3));
      }
    }
  }
#line 978
  goto switch_break;
  case_62: /* CIL Label */ 
#line 979
  sub_counter = 0;
#line 980
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 981
  arr___0 = (*(yyvsp + -2))->d.name;
#line 983
  (*(yyvsp + -2))->opcode = (OPCODE )76;
#line 984
  (*(yyvsp + -2))->d.dn = variable((int )(*(yyvsp + -2))->source_line, arr___0, (NODETYPE )6);
  }
#line 986
  if (! (do_flags & 16)) {
#line 986
    if (! (do_flags & 8)) {
#line 987
      if ((unsigned long )(*(yyvsp + -2))->d.dn == (unsigned long )symbol_table) {
        {
#line 988
        set_loc("awkgram.y", 988);
#line 988
        tmp___63 = gettext("`delete\' is not allowed with SYMTAB");
#line 988
        r_fatal((char const   *)tmp___63);
        }
      } else
#line 989
      if ((unsigned long )(*(yyvsp + -2))->d.dn == (unsigned long )func_table) {
        {
#line 990
        set_loc("awkgram.y", 990);
#line 990
        tmp___64 = gettext("`delete\' is not allowed with FUNCTAB");
#line 990
        r_fatal((char const   *)tmp___64);
        }
      }
    }
  }
#line 993
  if ((unsigned long )*(yyvsp + 0) == (unsigned long )((void *)0)) {
    {
#line 1005
    (*(yyvsp + -3))->x.xl = 0L;
#line 1006
    tmp___65 = list_create(*(yyvsp + -2));
#line 1006
    yyval = list_append(tmp___65, *(yyvsp + -3));
    }
  } else {
    {
#line 1008
    (*(yyvsp + -3))->x.xl = (long )sub_counter;
#line 1009
    tmp___66 = list_append(*(yyvsp + 0), *(yyvsp + -2));
#line 1009
    yyval = list_append(tmp___66, *(yyvsp + -3));
    }
  }
#line 1012
  goto switch_break;
  case_64: /* CIL Label */ 
#line 1019
  arr___1 = (*(yyvsp + -1))->d.name;
#line 1021
  if (do_flags & 3) {
#line 1021
    if (! warned___19) {
      {
#line 1022
      warned___19 = (_Bool)1;
#line 1023
      tmp___67 = gettext("`delete(array)\' is a non-portable tawk extension");
#line 1023
      lintwarn_ln((int )(*(yyvsp + -3))->source_line, (char const   *)tmp___67);
      }
    }
  }
#line 1026
  if (do_flags & 8) {
    {
#line 1027
    tmp___68 = gettext("`delete(array)\' is a non-portable tawk extension");
#line 1027
    error_ln((int )(*(yyvsp + -3))->source_line, (char const   *)tmp___68);
    }
  }
  {
#line 1030
  (*(yyvsp + -1))->d.dn = variable((int )(*(yyvsp + -1))->source_line, arr___1, (NODETYPE )6);
#line 1031
  (*(yyvsp + -1))->opcode = (OPCODE )76;
#line 1032
  (*(yyvsp + -3))->x.xl = 0L;
#line 1033
  tmp___69 = list_create(*(yyvsp + -1));
#line 1033
  yyval = list_append(tmp___69, *(yyvsp + -3));
  }
#line 1035
  if (! (do_flags & 16)) {
#line 1035
    if (! (do_flags & 8)) {
#line 1036
      if ((unsigned long )(*(yyvsp + -1))->d.dn == (unsigned long )symbol_table) {
        {
#line 1037
        set_loc("awkgram.y", 1037);
#line 1037
        tmp___70 = gettext("`delete\' is not allowed with SYMTAB");
#line 1037
        r_fatal((char const   *)tmp___70);
        }
      } else
#line 1038
      if ((unsigned long )(*(yyvsp + -1))->d.dn == (unsigned long )func_table) {
        {
#line 1039
        set_loc("awkgram.y", 1039);
#line 1039
        tmp___71 = gettext("`delete\' is not allowed with FUNCTAB");
#line 1039
        r_fatal((char const   *)tmp___71);
        }
      }
    }
  }
#line 1042
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 1043
  yyval = optimize_assignment(*(yyvsp + 0));
  }
#line 1044
  goto switch_break;
  case_66: /* CIL Label */ 
#line 1048
  yyval = (INSTRUCTION *)((void *)0);
#line 1049
  goto switch_break;
  case_67: /* CIL Label */ 
#line 1050
  yyval = *(yyvsp + 0);
#line 1051
  goto switch_break;
  case_68: /* CIL Label */ 
#line 1055
  yyval = (INSTRUCTION *)((void *)0);
#line 1056
  goto switch_break;
  case_69: /* CIL Label */ 
#line 1058
  if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
    {
#line 1059
    yyval = list_create(*(yyvsp + 0));
    }
  } else {
    {
#line 1061
    yyval = list_prepend(*(yyvsp + -1), *(yyvsp + 0));
    }
  }
#line 1063
  goto switch_break;
  case_70: /* CIL Label */ 
#line 1064
  yyval = (INSTRUCTION *)((void *)0);
#line 1065
  goto switch_break;
  case_71: /* CIL Label */ 
#line 1070
  casestmt___0 = *(yyvsp + 0);
#line 1071
  if ((unsigned long )*(yyvsp + 0) == (unsigned long )((void *)0)) {
    {
#line 1072
    tmp___72 = bcalloc((OPCODE )81, 1, 0);
#line 1072
    casestmt___0 = list_create(tmp___72);
    }
  }
#line 1073
  if (do_flags & 256) {
    {
#line 1074
    tmp___73 = bcalloc((OPCODE )98, 1, 0);
#line 1074
    list_prepend(casestmt___0, tmp___73);
    }
  }
  {
#line 1075
  (*(yyvsp + -4))->d.di = *(yyvsp + -3);
#line 1076
  (*(yyvsp + -4))->x.xi = casestmt___0;
#line 1077
  bcfree(*(yyvsp + -2));
#line 1078
  yyval = *(yyvsp + -4);
  }
#line 1080
  goto switch_break;
  case_72: /* CIL Label */ 
#line 1082
  casestmt___1 = *(yyvsp + 0);
#line 1083
  if ((unsigned long )*(yyvsp + 0) == (unsigned long )((void *)0)) {
    {
#line 1084
    tmp___74 = bcalloc((OPCODE )81, 1, 0);
#line 1084
    casestmt___1 = list_create(tmp___74);
    }
  }
#line 1085
  if (do_flags & 256) {
    {
#line 1086
    tmp___75 = bcalloc((OPCODE )98, 1, 0);
#line 1086
    list_prepend(casestmt___1, tmp___75);
    }
  }
  {
#line 1087
  bcfree(*(yyvsp + -2));
#line 1088
  (*(yyvsp + -3))->x.xi = casestmt___1;
#line 1089
  yyval = *(yyvsp + -3);
  }
#line 1091
  goto switch_break;
  case_73: /* CIL Label */ 
#line 1095
  yyval = *(yyvsp + 0);
#line 1096
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 1098
  n___1 = (*(yyvsp + 0))->d.dn;
#line 1099
  force_number(n___1);
#line 1100
  negate_num(n___1);
#line 1101
  bcfree(*(yyvsp + -1));
#line 1102
  yyval = *(yyvsp + 0);
  }
#line 1104
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 1106
  bcfree(*(yyvsp + -1));
#line 1107
  yyval = *(yyvsp + 0);
  }
#line 1109
  goto switch_break;
  case_76: /* CIL Label */ 
#line 1110
  yyval = *(yyvsp + 0);
#line 1111
  goto switch_break;
  case_77: /* CIL Label */ 
#line 1113
  (*(yyvsp + 0))->opcode = (OPCODE )75;
#line 1114
  yyval = *(yyvsp + 0);
#line 1116
  goto switch_break;
  case_78: /* CIL Label */ 
#line 1120
  yyval = *(yyvsp + 0);
#line 1121
  goto switch_break;
  case_79: /* CIL Label */ 
#line 1122
  yyval = *(yyvsp + 0);
#line 1123
  goto switch_break;
  case_81: /* CIL Label */ 
#line 1133
  yyval = *(yyvsp + -1);
#line 1135
  goto switch_break;
  case_82: /* CIL Label */ 
#line 1140
  in_print = (_Bool)0;
#line 1141
  in_parens = 0;
#line 1142
  yyval = (INSTRUCTION *)((void *)0);
#line 1144
  goto switch_break;
  case_83: /* CIL Label */ 
#line 1144
  in_print = (_Bool)0;
#line 1144
  in_parens = 0;
#line 1145
  goto switch_break;
  case_84: /* CIL Label */ 
#line 1146
  if ((*(yyvsp + -2))->d.dl == 6L) {
#line 1146
    if ((unsigned int )((*(yyvsp + 0))->d.di)->opcode == 62U) {
#line 1146
      if (((*(yyvsp + 0))->d.di)->d.dl == 6L) {
        {
#line 1149
        tmp___76 = gettext("multistage two-way pipelines don\'t work");
#line 1149
        yyerror((char const   *)tmp___76);
        }
      }
    }
  }
  {
#line 1150
  yyval = list_prepend(*(yyvsp + 0), *(yyvsp + -2));
  }
#line 1152
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 1157
  yyval = mk_condition(*(yyvsp + -3), *(yyvsp + -5), *(yyvsp + 0), (INSTRUCTION *)((void *)0),
                       (INSTRUCTION *)((void *)0));
  }
#line 1159
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 1162
  yyval = mk_condition(*(yyvsp + -6), *(yyvsp + -8), *(yyvsp + -3), *(yyvsp + -2),
                       *(yyvsp + 0));
  }
#line 1164
  goto switch_break;
  case_91: /* CIL Label */ 
#line 1178
  yyval = (INSTRUCTION *)((void *)0);
#line 1179
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 1181
  bcfree(*(yyvsp + -1));
#line 1182
  yyval = *(yyvsp + 0);
  }
#line 1184
  goto switch_break;
  case_93: /* CIL Label */ 
#line 1188
  yyval = (INSTRUCTION *)((void *)0);
#line 1189
  goto switch_break;
  case_94: /* CIL Label */ 
#line 1190
  yyval = *(yyvsp + 0);
#line 1191
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 1196
  (*(yyvsp + 0))->x.xl = 0L;
#line 1197
  yyval = list_create(*(yyvsp + 0));
  }
#line 1199
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 1201
  (*(yyvsp + 0))->x.xl = ((*(yyvsp + -2))->d.di)->x.xl + 1L;
#line 1202
  yyval = list_append(*(yyvsp + -2), *(yyvsp + 0));
#line 1203
  yyerrstatus = 0;
  }
#line 1205
  goto switch_break;
  case_97: /* CIL Label */ 
#line 1206
  yyval = (INSTRUCTION *)((void *)0);
#line 1207
  goto switch_break;
  case_98: /* CIL Label */ 
#line 1208
  yyval = *(yyvsp + -1);
#line 1209
  goto switch_break;
  case_99: /* CIL Label */ 
#line 1210
  yyval = *(yyvsp + -2);
#line 1211
  goto switch_break;
  case_100: /* CIL Label */ 
#line 1216
  yyval = (INSTRUCTION *)((void *)0);
#line 1217
  goto switch_break;
  case_101: /* CIL Label */ 
#line 1218
  yyval = *(yyvsp + 0);
#line 1219
  goto switch_break;
  case_102: /* CIL Label */ 
#line 1223
  yyval = (INSTRUCTION *)((void *)0);
#line 1224
  goto switch_break;
  case_103: /* CIL Label */ 
#line 1225
  yyval = *(yyvsp + 0);
#line 1226
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 1230
  yyval = mk_expression_list((INSTRUCTION *)((void *)0), *(yyvsp + 0));
  }
#line 1231
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 1233
  yyval = mk_expression_list(*(yyvsp + -2), *(yyvsp + 0));
#line 1234
  yyerrstatus = 0;
  }
#line 1236
  goto switch_break;
  case_106: /* CIL Label */ 
#line 1237
  yyval = (INSTRUCTION *)((void *)0);
#line 1238
  goto switch_break;
  case_107: /* CIL Label */ 
#line 1244
  yyval = *(yyvsp + -1);
#line 1246
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 1249
  yyval = mk_expression_list(*(yyvsp + -2), *(yyvsp + 0));
  }
#line 1251
  goto switch_break;
  case_109: /* CIL Label */ 
#line 1254
  yyval = *(yyvsp + -2);
#line 1256
  goto switch_break;
  case_110: /* CIL Label */ 
#line 1262
  if (do_flags & 3) {
#line 1262
    if ((unsigned int )((*(yyvsp + 0))->d.di)->opcode == 47U) {
      {
#line 1263
      tmp___77 = gettext("regular expression on right of assignment");
#line 1263
      lintwarn_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___77);
      }
    }
  }
  {
#line 1265
  yyval = mk_assignment(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1267
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 1268
  yyval = mk_boolean(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1269
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 1270
  yyval = mk_boolean(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1271
  goto switch_break;
  case_113: /* CIL Label */ 
#line 1273
  if ((unsigned int )((*(yyvsp + -2))->d.di)->opcode == 47U) {
    {
#line 1274
    tmp___78 = gettext("regular expression on left of `~\' or `!~\' operator");
#line 1274
    warning_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___78);
    }
  }
#line 1277
  if ((unsigned long )(*(yyvsp + 0))->d.di == (unsigned long )(*(yyvsp + 0))->nexti) {
#line 1277
    if ((unsigned int )((*(yyvsp + 0))->nexti)->opcode == 47U) {
      {
#line 1278
      (*(yyvsp + -1))->d.dn = ((*(yyvsp + 0))->nexti)->d.dn;
#line 1279
      bcfree((*(yyvsp + 0))->nexti);
#line 1280
      bcfree(*(yyvsp + 0));
#line 1281
      yyval = list_append(*(yyvsp + -2), *(yyvsp + -1));
      }
    } else {
      {
#line 1283
      (*(yyvsp + -1))->d.dn = make_regnode(3, (NODE *)((void *)0));
#line 1284
      tmp___79 = list_merge(*(yyvsp + -2), *(yyvsp + 0));
#line 1284
      yyval = list_append(tmp___79, *(yyvsp + -1));
      }
    }
  } else {
    {
#line 1283
    (*(yyvsp + -1))->d.dn = make_regnode(3, (NODE *)((void *)0));
#line 1284
    tmp___79 = list_merge(*(yyvsp + -2), *(yyvsp + 0));
#line 1284
    yyval = list_append(tmp___79, *(yyvsp + -1));
    }
  }
#line 1287
  goto switch_break;
  case_114: /* CIL Label */ 
#line 1289
  if (do_flags & 4) {
    {
#line 1290
    tmp___80 = gettext("old awk does not support the keyword `in\' except after `for\'");
#line 1290
    warning_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___80);
    }
  }
  {
#line 1292
  ((*(yyvsp + 0))->nexti)->opcode = (OPCODE )76;
#line 1293
  (*(yyvsp + -1))->opcode = (OPCODE )69;
#line 1294
  (*(yyvsp + -1))->x.xl = 1L;
#line 1295
  tmp___81 = list_merge(*(yyvsp + -2), *(yyvsp + 0));
#line 1295
  yyval = list_append(tmp___81, *(yyvsp + -1));
  }
#line 1297
  goto switch_break;
  case_115: /* CIL Label */ 
#line 1299
  if (do_flags & 3) {
#line 1299
    if ((unsigned int )((*(yyvsp + 0))->d.di)->opcode == 47U) {
      {
#line 1300
      tmp___82 = gettext("regular expression on right of comparison");
#line 1300
      lintwarn_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___82);
      }
    }
  }
  {
#line 1302
  tmp___83 = list_merge(*(yyvsp + -2), *(yyvsp + 0));
#line 1302
  yyval = list_append(tmp___83, *(yyvsp + -1));
  }
#line 1304
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 1305
  yyval = mk_condition(*(yyvsp + -4), *(yyvsp + -3), *(yyvsp + -2), *(yyvsp + -1),
                       *(yyvsp + 0));
  }
#line 1306
  goto switch_break;
  case_117: /* CIL Label */ 
#line 1307
  yyval = *(yyvsp + 0);
#line 1308
  goto switch_break;
  case_118: /* CIL Label */ 
#line 1312
  yyval = *(yyvsp + 0);
#line 1313
  goto switch_break;
  case_119: /* CIL Label */ 
#line 1314
  yyval = *(yyvsp + 0);
#line 1315
  goto switch_break;
  case_120: /* CIL Label */ 
#line 1317
  (*(yyvsp + 0))->opcode = (OPCODE )30;
#line 1318
  yyval = *(yyvsp + 0);
#line 1320
  goto switch_break;
  case_121: /* CIL Label */ 
#line 1324
  yyval = *(yyvsp + 0);
#line 1325
  goto switch_break;
  case_122: /* CIL Label */ 
#line 1326
  yyval = *(yyvsp + 0);
#line 1327
  goto switch_break;
  case_123: /* CIL Label */ 
#line 1331
  yyval = *(yyvsp + 0);
#line 1332
  goto switch_break;
  case_124: /* CIL Label */ 
#line 1333
  yyval = *(yyvsp + 0);
#line 1334
  goto switch_break;
  case_125: /* CIL Label */ 
#line 1338
  yyval = *(yyvsp + 0);
#line 1339
  goto switch_break;
  case_126: /* CIL Label */ 
#line 1340
  yyval = *(yyvsp + 0);
#line 1341
  goto switch_break;
  case_127: /* CIL Label */ 
#line 1343
  count = 2;
#line 1344
  is_simple_var = (_Bool)0;
#line 1346
  if ((unsigned int )((*(yyvsp + -1))->d.di)->opcode == 13U) {
#line 1348
    is_simple_var = (_Bool )(((*(yyvsp + -1))->d.di)->d.dl & 2L);
#line 1349
    count = (int )(((*(yyvsp + -1))->d.di)->x.xl + 1L);
#line 1350
    ((*(yyvsp + -1))->d.di)->opcode = (OPCODE )81;
  } else {
#line 1352
    if ((unsigned int )((*(yyvsp + -1))->nexti)->opcode == 72U) {
#line 1352
      if ((unsigned long )(*(yyvsp + -1))->d.di == (unsigned long )(*(yyvsp + -1))->nexti) {
#line 1352
        tmp___84 = 1;
      } else {
#line 1352
        tmp___84 = 0;
      }
    } else {
#line 1352
      tmp___84 = 0;
    }
#line 1352
    is_simple_var = (_Bool )tmp___84;
  }
#line 1359
  if ((int )do_optimize > 1) {
#line 1359
    if ((unsigned long )(*(yyvsp + -1))->nexti == (unsigned long )(*(yyvsp + -1))->d.di) {
#line 1359
      if ((unsigned int )((*(yyvsp + -1))->nexti)->opcode == 74U) {
#line 1359
        if ((unsigned long )(*(yyvsp + 0))->nexti == (unsigned long )(*(yyvsp + 0))->d.di) {
#line 1359
          if ((unsigned int )((*(yyvsp + 0))->nexti)->opcode == 74U) {
            {
#line 1363
            n1 = ((*(yyvsp + -1))->nexti)->d.dn;
#line 1364
            n2 = ((*(yyvsp + 0))->nexti)->d.dn;
#line 1367
            n1 = force_string(n1);
#line 1368
            n2 = force_string(n2);
#line 1369
            nlen = n1->sub.val.slen + n2->sub.val.slen;
#line 1370
            tmp___86 = realloc((void *)n1->sub.val.sp, nlen + 2UL);
#line 1370
            tmp___85 = (char *)tmp___86;
#line 1370
            n1->sub.val.sp = tmp___85;
            }
#line 1370
            if (tmp___85) {
#line 1370
              tmp___90 = 1;
            } else {
              {
#line 1370
              set_loc("awkgram.y", 1370);
#line 1370
              tmp___87 = __errno_location();
#line 1370
              tmp___88 = strerror(*tmp___87);
#line 1370
              tmp___89 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1370
              r_fatal((char const   *)tmp___89, "constant fold", "n1->stptr", (long )(nlen + 2UL),
                      tmp___88);
#line 1370
              tmp___90 = 0;
              }
            }
            {
#line 1371
            memcpy((void */* __restrict  */)(n1->sub.val.sp + n1->sub.val.slen), (void const   */* __restrict  */)n2->sub.val.sp,
                   n2->sub.val.slen);
#line 1372
            n1->sub.val.slen = nlen;
#line 1373
            *(n1->sub.val.sp + nlen) = (char )'\000';
#line 1374
            n1->flags &= 4294967015U;
#line 1375
            n1->flags |= 6U;
#line 1376
            unref(n2);
#line 1377
            bcfree((*(yyvsp + 0))->nexti);
#line 1378
            bcfree(*(yyvsp + 0));
#line 1379
            yyval = *(yyvsp + -1);
            }
          } else {
#line 1359
            goto _L___11;
          }
        } else {
#line 1359
          goto _L___11;
        }
      } else {
#line 1359
        goto _L___11;
      }
    } else {
#line 1359
      goto _L___11;
    }
  } else {
    _L___11: /* CIL Label */ 
    {
#line 1381
    tmp___91 = bcalloc((OPCODE )13, 1, 0);
#line 1381
    tmp___92 = list_merge(*(yyvsp + -1), *(yyvsp + 0));
#line 1381
    yyval = list_append(tmp___92, tmp___91);
    }
#line 1382
    if (is_simple_var) {
#line 1382
      (yyval->d.di)->d.dl = 2L;
    } else {
#line 1382
      (yyval->d.di)->d.dl = 0L;
    }
#line 1383
    (yyval->d.di)->x.xl = (long )count;
#line 1384
    if (count > max_args) {
#line 1385
      max_args = count;
    }
  }
#line 1388
  goto switch_break;
  case_129: /* CIL Label */ 
  {
#line 1394
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1395
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 1396
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1397
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 1398
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1399
  goto switch_break;
  case_132: /* CIL Label */ 
  {
#line 1400
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1401
  goto switch_break;
  case_133: /* CIL Label */ 
  {
#line 1402
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1403
  goto switch_break;
  case_134: /* CIL Label */ 
  {
#line 1404
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1405
  goto switch_break;
  case_135: /* CIL Label */ 
#line 1411
  if (rule == 4) {
#line 1411
    goto _L___13;
  } else
#line 1411
  if (rule == 5) {
    _L___13: /* CIL Label */ 
#line 1412
    if ((unsigned long )*(yyvsp + -1) != (unsigned long )((void *)0)) {
#line 1412
      if (! ((unsigned long )*(yyvsp + 0) != (unsigned long )((void *)0))) {
#line 1412
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 1415
    if ((unsigned long )*(yyvsp + -1) != (unsigned long )((void *)0)) {
      {
#line 1416
      tmp___93 = gettext("`getline var\' invalid inside `%s\' rule");
#line 1416
      error_ln((int )(*(yyvsp + -2))->source_line, (char const   *)tmp___93, ruletab[rule]);
      }
    } else {
      {
#line 1419
      tmp___94 = gettext("`getline\' invalid inside `%s\' rule");
#line 1419
      error_ln((int )(*(yyvsp + -2))->source_line, (char const   *)tmp___94, ruletab[rule]);
      }
    }
  }
#line 1423
  if (do_flags & 3) {
#line 1423
    if (rule == 3) {
#line 1423
      if ((unsigned long )*(yyvsp + 0) == (unsigned long )((void *)0)) {
        {
#line 1424
        tmp___95 = gettext("non-redirected `getline\' undefined inside END action");
#line 1424
        lintwarn_ln((int )(*(yyvsp + -2))->source_line, (char const   *)tmp___95);
        }
      }
    }
  }
  {
#line 1426
  yyval = mk_getline(*(yyvsp + -2), *(yyvsp + -1), *(yyvsp + 0), 5);
  }
#line 1428
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 1430
  (*(yyvsp + 0))->opcode = (OPCODE )20;
#line 1431
  yyval = mk_assignment(*(yyvsp + -1), (INSTRUCTION *)((void *)0), *(yyvsp + 0));
  }
#line 1433
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 1435
  (*(yyvsp + 0))->opcode = (OPCODE )21;
#line 1436
  yyval = mk_assignment(*(yyvsp + -1), (INSTRUCTION *)((void *)0), *(yyvsp + 0));
  }
#line 1438
  goto switch_break;
  case_138: /* CIL Label */ 
#line 1440
  if (do_flags & 4) {
    {
#line 1441
    tmp___96 = gettext("old awk does not support the keyword `in\' except after `for\'");
#line 1441
    warning_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___96);
#line 1443
    tmp___97 = gettext("old awk does not support multidimensional arrays");
#line 1443
    warning_ln((int )(*(yyvsp + -1))->source_line, (char const   *)tmp___97);
    }
  }
#line 1446
  ((*(yyvsp + 0))->nexti)->opcode = (OPCODE )76;
#line 1447
  (*(yyvsp + -1))->opcode = (OPCODE )69;
#line 1448
  if ((unsigned long )*(yyvsp + -3) == (unsigned long )((void *)0)) {
    {
#line 1449
    errcount___0 ++;
#line 1450
    (*(yyvsp + -1))->x.xl = 0L;
#line 1451
    yyval = list_merge(*(yyvsp + 0), *(yyvsp + -1));
    }
  } else {
    {
#line 1453
    t___1 = *(yyvsp + -3);
#line 1454
    tmp___98 = count_expressions(& t___1, (_Bool)0);
#line 1454
    (*(yyvsp + -1))->x.xl = (long )tmp___98;
#line 1455
    tmp___99 = list_merge(t___1, *(yyvsp + 0));
#line 1455
    yyval = list_append(tmp___99, *(yyvsp + -1));
    }
  }
#line 1458
  goto switch_break;
  case_139: /* CIL Label */ 
  {
#line 1465
  yyval = mk_getline(*(yyvsp + -1), *(yyvsp + 0), *(yyvsp + -3), (int )(*(yyvsp + -2))->d.dl);
#line 1466
  bcfree(*(yyvsp + -2));
  }
#line 1468
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 1470
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1471
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 1472
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1473
  goto switch_break;
  case_142: /* CIL Label */ 
  {
#line 1474
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1475
  goto switch_break;
  case_143: /* CIL Label */ 
  {
#line 1476
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1477
  goto switch_break;
  case_144: /* CIL Label */ 
  {
#line 1478
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1479
  goto switch_break;
  case_145: /* CIL Label */ 
  {
#line 1480
  yyval = mk_binary(*(yyvsp + -2), *(yyvsp + 0), *(yyvsp + -1));
  }
#line 1481
  goto switch_break;
  case_146: /* CIL Label */ 
  {
#line 1486
  yyval = list_create(*(yyvsp + 0));
  }
#line 1488
  goto switch_break;
  case_147: /* CIL Label */ 
#line 1490
  if ((unsigned int )(*(yyvsp + 0))->opcode == 47U) {
    {
#line 1491
    (*(yyvsp + 0))->opcode = (OPCODE )48;
#line 1492
    (*(yyvsp + -1))->opcode = (OPCODE )74;
#line 1493
    (*(yyvsp + -1))->d.dn = (*make_number)(0.0);
#line 1494
    tmp___100 = bcalloc((OPCODE )23, 1, 0);
#line 1494
    tmp___101 = list_create(*(yyvsp + -1));
#line 1494
    tmp___102 = list_append(tmp___101, tmp___100);
#line 1494
    yyval = list_append(tmp___102, *(yyvsp + 0));
    }
  } else
#line 1497
  if ((int )do_optimize > 1) {
#line 1497
    if ((unsigned long )(*(yyvsp + 0))->nexti == (unsigned long )(*(yyvsp + 0))->d.di) {
#line 1497
      if ((unsigned int )((*(yyvsp + 0))->nexti)->opcode == 74U) {
#line 1497
        if (((((*(yyvsp + 0))->nexti)->d.dn)->flags & 6144U) == 0U) {
#line 1501
          n___2 = ((*(yyvsp + 0))->nexti)->d.dn;
#line 1502
          if ((n___2->flags & 6U) != 0U) {
            {
#line 1503
            n___2->sub.val.nm.fltnum = (double )(n___2->sub.val.slen == 0UL);
#line 1504
            n___2->flags &= 4294967289U;
#line 1505
            n___2->flags |= 24U;
#line 1506
            free((void *)n___2->sub.val.sp);
#line 1507
            n___2->sub.val.sp = (char *)((void *)0);
#line 1508
            n___2->sub.val.slen = (size_t )0;
            }
          } else {
#line 1510
            n___2->sub.val.nm.fltnum = (double )(n___2->sub.val.nm.fltnum == 0.0);
          }
          {
#line 1511
          bcfree(*(yyvsp + -1));
#line 1512
          yyval = *(yyvsp + 0);
          }
        } else {
          {
#line 1514
          (*(yyvsp + -1))->opcode = (OPCODE )24;
#line 1515
          add_lint(*(yyvsp + 0), (LINTTYPE )1);
#line 1516
          yyval = list_append(*(yyvsp + 0), *(yyvsp + -1));
          }
        }
      } else {
        {
#line 1514
        (*(yyvsp + -1))->opcode = (OPCODE )24;
#line 1515
        add_lint(*(yyvsp + 0), (LINTTYPE )1);
#line 1516
        yyval = list_append(*(yyvsp + 0), *(yyvsp + -1));
        }
      }
    } else {
      {
#line 1514
      (*(yyvsp + -1))->opcode = (OPCODE )24;
#line 1515
      add_lint(*(yyvsp + 0), (LINTTYPE )1);
#line 1516
      yyval = list_append(*(yyvsp + 0), *(yyvsp + -1));
      }
    }
  } else {
    {
#line 1514
    (*(yyvsp + -1))->opcode = (OPCODE )24;
#line 1515
    add_lint(*(yyvsp + 0), (LINTTYPE )1);
#line 1516
    yyval = list_append(*(yyvsp + 0), *(yyvsp + -1));
    }
  }
#line 1520
  goto switch_break;
  case_148: /* CIL Label */ 
#line 1521
  yyval = *(yyvsp + -1);
#line 1522
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 1524
  yyval = snode(*(yyvsp + -1), *(yyvsp + -3));
  }
#line 1525
  if ((unsigned long )yyval == (unsigned long )((void *)0)) {
#line 1526
    goto yyabortlab;
  }
#line 1528
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 1530
  yyval = snode(*(yyvsp + -1), *(yyvsp + -3));
  }
#line 1531
  if ((unsigned long )yyval == (unsigned long )((void *)0)) {
#line 1532
    goto yyabortlab;
  }
#line 1534
  goto switch_break;
  case_151: /* CIL Label */ 
#line 1538
  if (do_flags & 3) {
#line 1538
    if (! warned___20) {
      {
#line 1539
      warned___20 = (_Bool)1;
#line 1540
      tmp___103 = gettext("call of `length\' without parentheses is not portable");
#line 1540
      lintwarn_ln((int )(*(yyvsp + 0))->source_line, (char const   *)tmp___103);
      }
    }
  }
  {
#line 1543
  yyval = snode((INSTRUCTION *)((void *)0), *(yyvsp + 0));
  }
#line 1544
  if ((unsigned long )yyval == (unsigned long )((void *)0)) {
#line 1545
    goto yyabortlab;
  }
#line 1547
  goto switch_break;
  case_154: /* CIL Label */ 
  {
#line 1551
  (*(yyvsp + -1))->opcode = (OPCODE )18;
#line 1552
  yyval = mk_assignment(*(yyvsp + 0), (INSTRUCTION *)((void *)0), *(yyvsp + -1));
  }
#line 1554
  goto switch_break;
  case_155: /* CIL Label */ 
  {
#line 1556
  (*(yyvsp + -1))->opcode = (OPCODE )19;
#line 1557
  yyval = mk_assignment(*(yyvsp + 0), (INSTRUCTION *)((void *)0), *(yyvsp + -1));
  }
#line 1559
  goto switch_break;
  case_156: /* CIL Label */ 
  {
#line 1561
  yyval = list_create(*(yyvsp + 0));
  }
#line 1563
  goto switch_break;
  case_157: /* CIL Label */ 
  {
#line 1565
  yyval = list_create(*(yyvsp + 0));
  }
#line 1567
  goto switch_break;
  case_158: /* CIL Label */ 
#line 1569
  if ((unsigned int )((*(yyvsp + 0))->d.di)->opcode == 74U) {
#line 1569
    if (((((*(yyvsp + 0))->d.di)->d.dn)->flags & 6U) == 0U) {
      {
#line 1572
      n___3 = ((*(yyvsp + 0))->d.di)->d.dn;
#line 1573
      force_number(n___3);
#line 1574
      negate_num(n___3);
#line 1575
      yyval = *(yyvsp + 0);
#line 1576
      bcfree(*(yyvsp + -1));
      }
    } else {
      {
#line 1578
      (*(yyvsp + -1))->opcode = (OPCODE )22;
#line 1579
      yyval = list_append(*(yyvsp + 0), *(yyvsp + -1));
      }
    }
  } else {
    {
#line 1578
    (*(yyvsp + -1))->opcode = (OPCODE )22;
#line 1579
    yyval = list_append(*(yyvsp + 0), *(yyvsp + -1));
    }
  }
#line 1582
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 1588
  (*(yyvsp + -1))->opcode = (OPCODE )8;
#line 1589
  (*(yyvsp + -1))->d.dn = (*make_number)(0.0);
#line 1590
  yyval = list_append(*(yyvsp + 0), *(yyvsp + -1));
  }
#line 1592
  goto switch_break;
  case_160: /* CIL Label */ 
  {
#line 1597
  func_use((char const   *)((*(yyvsp + 0))->d.di)->d.name, (enum defref )1);
#line 1598
  yyval = *(yyvsp + 0);
  }
#line 1600
  goto switch_break;
  case_161: /* CIL Label */ 
  {
#line 1607
  tmp___104 = gettext("indirect function calls are a gawk extension");
#line 1607
  msg___0 = (char const   *)tmp___104;
  }
#line 1609
  if (do_flags & 8) {
    {
#line 1610
    yyerror("%s", msg___0);
    }
  } else
#line 1609
  if (do_flags & 16) {
    {
#line 1610
    yyerror("%s", msg___0);
    }
  } else
#line 1611
  if (do_flags & 3) {
#line 1611
    if (! warned___21) {
      {
#line 1612
      warned___21 = (_Bool)1;
#line 1613
      set_loc("awkgram.y", 1613);
#line 1613
      (*lintfunc)("%s", msg___0);
      }
    }
  }
  {
#line 1616
  f = (*(yyvsp + 0))->d.di;
#line 1617
  f->opcode = (OPCODE )71;
#line 1618
  tmp___105 = strlen((char const   *)f->d.name);
#line 1618
  name = estrdup((char const   *)f->d.name, tmp___105);
#line 1619
  tmp___107 = is_std_var((char const   *)name);
  }
#line 1619
  if (tmp___107) {
    {
#line 1620
    tmp___106 = gettext("can not use special variable `%s\' for indirect function call");
#line 1620
    yyerror((char const   *)tmp___106, name);
    }
  }
  {
#line 1621
  indirect_var = variable((int )f->source_line, name, (NODETYPE )6);
#line 1622
  t___2 = bcalloc((OPCODE )72, 1, 0);
#line 1623
  t___2->d.dn = indirect_var;
#line 1631
  yyval = list_prepend(*(yyvsp + 0), t___2);
  }
#line 1633
  goto switch_break;
  case_162: /* CIL Label */ 
  {
#line 1638
  param_sanity(*(yyvsp + -1));
#line 1639
  (*(yyvsp + -3))->opcode = (OPCODE )70;
#line 1640
  (*(yyvsp + -3))->x.xn = (NODE *)((void *)0);
  }
#line 1641
  if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
    {
#line 1642
    (*(yyvsp + -3) + 1)->x.xl = 0L;
#line 1643
    yyval = list_create(*(yyvsp + -3));
    }
  } else {
    {
#line 1645
    t___3 = *(yyvsp + -1);
#line 1646
    tmp___108 = count_expressions(& t___3, (_Bool)1);
#line 1646
    (*(yyvsp + -3) + 1)->x.xl = (long )tmp___108;
#line 1647
    yyval = list_append(t___3, *(yyvsp + -3));
    }
  }
#line 1650
  goto switch_break;
  case_163: /* CIL Label */ 
#line 1654
  yyval = (INSTRUCTION *)((void *)0);
#line 1655
  goto switch_break;
  case_164: /* CIL Label */ 
#line 1656
  yyval = *(yyvsp + 0);
#line 1657
  goto switch_break;
  case_165: /* CIL Label */ 
#line 1661
  yyval = (INSTRUCTION *)((void *)0);
#line 1662
  goto switch_break;
  case_166: /* CIL Label */ 
#line 1663
  yyval = *(yyvsp + -1);
#line 1664
  goto switch_break;
  case_167: /* CIL Label */ 
#line 1668
  yyval = *(yyvsp + 0);
#line 1669
  goto switch_break;
  case_168: /* CIL Label */ 
  {
#line 1671
  yyval = list_merge(*(yyvsp + -1), *(yyvsp + 0));
  }
#line 1673
  goto switch_break;
  case_169: /* CIL Label */ 
#line 1678
  ip___5 = (*(yyvsp + 0))->d.di;
#line 1679
  count___0 = (int )ip___5->d.dl;
#line 1680
  if (count___0 > 1) {
#line 1682
    ip___5->opcode = (OPCODE )13;
#line 1683
    ip___5->d.dl = 1L;
#line 1684
    ip___5->x.xl = (long )count___0;
  } else {
#line 1686
    ip___5->opcode = (OPCODE )81;
  }
#line 1687
  sub_counter ++;
#line 1688
  yyval = *(yyvsp + 0);
#line 1690
  goto switch_break;
  case_170: /* CIL Label */ 
#line 1695
  t___4 = *(yyvsp + -1);
#line 1696
  if ((unsigned long )*(yyvsp + -1) == (unsigned long )((void *)0)) {
    {
#line 1697
    tmp___109 = gettext("invalid subscript expression");
#line 1697
    error_ln((int )(*(yyvsp + 0))->source_line, (char const   *)tmp___109);
#line 1700
    tmp___110 = bcalloc((OPCODE )74, 1, 0);
#line 1700
    t___4 = list_create(tmp___110);
#line 1701
    (t___4->nexti)->d.dn = dupnode(Nnull_string);
#line 1702
    (*(yyvsp + 0))->d.dl = 1L;
    }
  } else {
    {
#line 1704
    tmp___111 = count_expressions(& t___4, (_Bool)0);
#line 1704
    (*(yyvsp + 0))->d.dl = (long )tmp___111;
    }
  }
  {
#line 1705
  yyval = list_append(t___4, *(yyvsp + 0));
  }
#line 1707
  goto switch_break;
  case_171: /* CIL Label */ 
#line 1711
  yyval = *(yyvsp + 0);
#line 1712
  goto switch_break;
  case_172: /* CIL Label */ 
  {
#line 1714
  yyval = list_merge(*(yyvsp + -1), *(yyvsp + 0));
  }
#line 1716
  goto switch_break;
  case_173: /* CIL Label */ 
#line 1720
  yyval = *(yyvsp + -1);
#line 1721
  goto switch_break;
  case_174: /* CIL Label */ 
  {
#line 1726
  var_name___0 = (*(yyvsp + 0))->d.name;
#line 1728
  (*(yyvsp + 0))->opcode = (OPCODE )72;
#line 1729
  (*(yyvsp + 0))->d.dn = variable((int )(*(yyvsp + 0))->source_line, var_name___0,
                                  (NODETYPE )6);
#line 1730
  yyval = list_create(*(yyvsp + 0));
  }
#line 1732
  goto switch_break;
  case_175: /* CIL Label */ 
  {
#line 1734
  arr___2 = (*(yyvsp + -1))->d.name;
#line 1735
  (*(yyvsp + -1))->d.dn = variable((int )(*(yyvsp + -1))->source_line, arr___2, (NODETYPE )6);
#line 1736
  (*(yyvsp + -1))->opcode = (OPCODE )76;
#line 1737
  yyval = list_prepend(*(yyvsp + 0), *(yyvsp + -1));
  }
#line 1739
  goto switch_break;
  case_176: /* CIL Label */ 
#line 1744
  ip___6 = (*(yyvsp + 0))->nexti;
#line 1745
  if ((unsigned int )ip___6->opcode == 72U) {
#line 1745
    if ((unsigned int )(ip___6->d.dn)->type == 4U) {
#line 1745
      if ((ip___6->d.dn)->sub.nodep.r.uptr) {
        {
#line 1749
        tmp___112 = bcalloc((OPCODE )91, 1, 0);
#line 1749
        yyval = list_prepend(*(yyvsp + 0), tmp___112);
#line 1750
        (yyval->nexti)->x.aptr = (ip___6->d.dn)->sub.nodep.r.uptr;
        }
      } else {
#line 1752
        yyval = *(yyvsp + 0);
      }
    } else {
#line 1752
      yyval = *(yyvsp + 0);
    }
  } else {
#line 1752
    yyval = *(yyvsp + 0);
  }
#line 1754
  goto switch_break;
  case_177: /* CIL Label */ 
  {
#line 1756
  yyval = list_append(*(yyvsp + -1), *(yyvsp + -2));
  }
#line 1757
  if ((unsigned long )*(yyvsp + 0) != (unsigned long )((void *)0)) {
    {
#line 1758
    mk_assignment(*(yyvsp + -1), (INSTRUCTION *)((void *)0), *(yyvsp + 0));
    }
  }
#line 1760
  goto switch_break;
  case_178: /* CIL Label */ 
#line 1765
  (*(yyvsp + 0))->opcode = (OPCODE )20;
#line 1767
  goto switch_break;
  case_179: /* CIL Label */ 
#line 1769
  (*(yyvsp + 0))->opcode = (OPCODE )21;
#line 1771
  goto switch_break;
  case_180: /* CIL Label */ 
#line 1771
  yyval = (INSTRUCTION *)((void *)0);
#line 1772
  goto switch_break;
  case_182: /* CIL Label */ 
#line 1779
  yyerrstatus = 0;
#line 1780
  goto switch_break;
  case_183: /* CIL Label */ 
#line 1783
  yyerrstatus = 0;
#line 1784
  goto switch_break;
  case_186: /* CIL Label */ 
#line 1792
  yyerrstatus = 0;
#line 1793
  goto switch_break;
  case_187: /* CIL Label */ 
#line 1796
  yyval = *(yyvsp + 0);
#line 1796
  yyerrstatus = 0;
#line 1797
  goto switch_break;
  case_188: /* CIL Label */ 
#line 1800
  yyerrstatus = 0;
#line 1801
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4118 "awkgram.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4133
  yyvsp -= yylen;
#line 4133
  yyssp -= yylen;
#line 4134
  yylen = 0;
#line 4137
  yyvsp ++;
#line 4137
  *yyvsp = yyval;
#line 4143
  yyn = (int )yyr1___0[yyn];
#line 4145
  yystate = (int )((int const   )yypgoto___0[yyn - 75] + (int const   )*yyssp);
#line 4146
  if (0 <= yystate) {
#line 4146
    if (yystate <= 1155) {
#line 4146
      if ((int const   )yycheck___0[yystate] == (int const   )*yyssp) {
#line 4147
        yystate = (int )yytable___0[yystate];
      } else {
#line 4149
        yystate = (int )yydefgoto___0[yyn - 75];
      }
    } else {
#line 4149
      yystate = (int )yydefgoto___0[yyn - 75];
    }
  } else {
#line 4149
    yystate = (int )yydefgoto___0[yyn - 75];
  }
#line 4151
  goto yynewstate;
  yyerrlab: 
#line 4160
  if (yychar == -2) {
#line 4160
    yytoken = -2;
  } else {
#line 4160
    if ((unsigned int )yychar <= 308U) {
#line 4160
      tmp___113 = (int const   )yytranslate___0[yychar];
    } else {
#line 4160
      tmp___113 = (int const   )2;
    }
#line 4160
    yytoken = (int )tmp___113;
  }
#line 4163
  if (! yyerrstatus) {
    {
#line 4165
    yynerrs ++;
#line 4167
    yyerror("syntax error");
    }
  }
#line 4204
  if (yyerrstatus == 3) {
#line 4209
    if (yychar <= 0) {
#line 4212
      if (yychar == 0) {
#line 4213
        goto yyabortlab;
      }
    } else {
      {
#line 4217
      yydestruct___0("Error: discarding", yytoken, & yylval);
#line 4219
      yychar = -2;
      }
    }
  }
#line 4225
  goto yyerrlab1;
#line 4241
  yyvsp -= yylen;
#line 4241
  yyssp -= yylen;
#line 4242
  yylen = 0;
#line 4244
  yystate = (int )*yyssp;
#line 4245
  goto yyerrlab1;
  yyerrlab1: 
#line 4252
  yyerrstatus = 3;
  {
#line 4254
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 4256
    yyn = (int )yypact___0[yystate];
#line 4257
    if (! (! (! (yyn == -273)))) {
#line 4259
      yyn ++;
#line 4260
      if (0 <= yyn) {
#line 4260
        if (yyn <= 1155) {
#line 4260
          if ((int const   )yycheck___0[yyn] == 1) {
#line 4262
            yyn = (int )yytable___0[yyn];
#line 4263
            if (0 < yyn) {
#line 4264
              goto while_break___3;
            }
          }
        }
      }
    }
#line 4269
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 4270
      goto yyabortlab;
    }
    {
#line 4273
    yydestruct___0("Error: popping", (int )yystos___0[yystate], yyvsp);
#line 4275
    yyvsp --;
#line 4275
    yyssp --;
#line 4276
    yystate = (int )*yyssp;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 4281
  yyvsp ++;
#line 4281
  *yyvsp = yylval;
#line 4288
  yystate = yyn;
#line 4289
  goto yynewstate;
  yyacceptlab: 
#line 4296
  yyresult = 0;
#line 4297
  goto yyreturn;
  yyabortlab: 
#line 4303
  yyresult = 1;
#line 4304
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 4311
  yyerror("memory exhausted");
#line 4312
  yyresult = 2;
  }
  yyreturn: 
#line 4317
  if (yychar != -2) {
#line 4321
    if ((unsigned int )yychar <= 308U) {
#line 4321
      yytoken = (int )yytranslate___0[yychar];
    } else {
#line 4321
      yytoken = 2;
    }
    {
#line 4322
    yydestruct___0("Cleanup: discarding lookahead", yytoken, & yylval);
    }
  }
#line 4327
  yyvsp -= yylen;
#line 4327
  yyssp -= yylen;
  {
#line 4329
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 4329
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 4329
      goto while_break___4;
    }
    {
#line 4331
    yydestruct___0("Cleanup: popping", (int )yystos___0[*yyssp], yyvsp);
#line 4333
    yyvsp --;
#line 4333
    yyssp --;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 4336
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 4337
    free((void *)yyss);
    }
  }
#line 4344
  return (yyresult);
}
}
#line 1849 "awkgram.y"
static struct token  const  tokentab[69]  = 
#line 1849 "awkgram.y"
  {      {"BEGIN", (OPCODE )49, 272, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"BEGINFILE", (OPCODE )49, 291, 1024U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"END",
      (OPCODE )49, 273, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"ENDFILE", (OPCODE )49, 292, 1024U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"and",
      (OPCODE )65, 300, 1024U, & do_and, & do_mpfr_and}, 
        {"asort", (OPCODE )65, 300, (unsigned int )(((1024 | (1 << 1)) | (1 << 2)) | (1 << 3)),
      & do_asort, (NODE *(*)(int  ))0}, 
        {"asorti", (OPCODE )65, 300, (unsigned int )(((1024 | (1 << 1)) | (1 << 2)) | (1 << 3)),
      & do_asorti, (NODE *(*)(int  ))0}, 
        {"atan2", (OPCODE )65, 300, (unsigned int )(256 | (1 << 2)), & do_atan2, & do_mpfr_atan2}, 
        {"bindtextdomain",
      (OPCODE )65, 300, (unsigned int )((1024 | (1 << 1)) | (1 << 2)), & do_bindtextdomain,
      (NODE *(*)(int  ))0}, 
        {"break", (OPCODE )52, 284, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"case", (OPCODE )50, 279, 1024U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"close", (OPCODE )65, 300, (unsigned int )((256 | (1 << 1)) | (1 << 2)), & do_close,
      (NODE *(*)(int  ))0}, 
        {"compl", (OPCODE )65, 300, (unsigned int )(1024 | (1 << 1)), & do_compl, & do_mpfr_compl}, 
        {"continue",
      (OPCODE )53, 285, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"cos", (OPCODE )65, 300, (unsigned int )(256 | (1 << 1)), & do_cos, & do_mpfr_cos}, 
        {"dcgettext",
      (OPCODE )65, 300, (unsigned int )(((1024 | (1 << 1)) | (1 << 2)) | (1 << 3)),
      & do_dcgettext, (NODE *(*)(int  ))0}, 
        {"dcngettext", (OPCODE )65, 300, (unsigned int )(((((1024 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)),
      & do_dcngettext, (NODE *(*)(int  ))0}, 
        {"default", (OPCODE )51, 280, 1024U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"delete",
      (OPCODE )60, 277, 256U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"do", (OPCODE )106, 282, 6400U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"else", (OPCODE )112, 275, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"eval", (OPCODE )104, 304, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"exit", (OPCODE )58, 289, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"exp", (OPCODE )65, 300, (unsigned int )(1 << 1), & do_exp, & do_mpfr_exp}, 
        {"extension", (OPCODE )65, 300, (unsigned int )(((1024 | (1 << 1)) | (1 << 2)) | (1 << 3)),
      & do_ext, (NODE *(*)(int  ))0}, 
        {"fflush", (OPCODE )65, 300, (unsigned int )(1 | (1 << 1)), & do_fflush, (NODE *(*)(int  ))0}, 
        {"for",
      (OPCODE )107, 283, 6144U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"func", (OPCODE )97, 290, 768U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"function", (OPCODE )97, 290, 256U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"gensub",
      (OPCODE )66, 300, (unsigned int )((1024 | (1 << 3)) | (1 << 4)), (NODE *(*)(int  ))0,
      (NODE *(*)(int  ))0}, 
        {"getline", (OPCODE )62, 293, 256U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"gsub",
      (OPCODE )66, 300, (unsigned int )((256 | (1 << 2)) | (1 << 3)), (NODE *(*)(int  ))0,
      (NODE *(*)(int  ))0}, 
        {"if", (OPCODE )111, 274, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"in", (OPCODE )104, 295, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"include", (OPCODE )104, 303, 1024U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"index",
      (OPCODE )65, 300, (unsigned int )(1 << 2), & do_index, (NODE *(*)(int  ))0}, 
        {"int",
      (OPCODE )65, 300, (unsigned int )(1 << 1), & do_int, & do_mpfr_int}, 
        {"isarray", (OPCODE )65, 300, (unsigned int )(1024 | (1 << 1)), & do_isarray,
      (NODE *(*)(int  ))0}, 
        {"length", (OPCODE )65, 301, (unsigned int )(1 | (1 << 1)), & do_length, (NODE *(*)(int  ))0}, 
        {"load",
      (OPCODE )104, 305, 1024U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"log", (OPCODE )65, 300, (unsigned int )(1 << 1), & do_log, & do_mpfr_log}, 
        {"lshift", (OPCODE )65, 300, (unsigned int )(1024 | (1 << 2)), & do_lshift, & do_mpfr_lshift}, 
        {"match",
      (OPCODE )65, 300, (unsigned int )((256 | (1 << 2)) | (1 << 3)), & do_match,
      (NODE *(*)(int  ))0}, 
        {"mktime", (OPCODE )65, 300, (unsigned int )(1024 | (1 << 1)), & do_mktime, (NODE *(*)(int  ))0}, 
        {"next",
      (OPCODE )57, 288, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"nextfile", (OPCODE )64, 294, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"or",
      (OPCODE )65, 300, 1024U, & do_or, & do_mpfr_or}, 
        {"patsplit", (OPCODE )65, 300, (unsigned int )(((1024 | (1 << 2)) | (1 << 3)) | (1 << 4)),
      & do_patsplit, (NODE *(*)(int  ))0}, 
        {"print", (OPCODE )54, 286, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"printf", (OPCODE )56, 287, 0U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"rand", (OPCODE )65, 300, 257U, & do_rand, & do_mpfr_rand}, 
        {"return", (OPCODE )59, 276, 256U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"rshift",
      (OPCODE )65, 300, (unsigned int )(1024 | (1 << 2)), & do_rshift, & do_mpfr_rshift}, 
        {"sin",
      (OPCODE )65, 300, (unsigned int )(256 | (1 << 1)), & do_sin, & do_mpfr_sin}, 
        {"split",
      (OPCODE )65, 300, (unsigned int )(((1 << 2) | (1 << 3)) | (1 << 4)), & do_split,
      (NODE *(*)(int  ))0}, 
        {"sprintf", (OPCODE )65, 300, 0U, & do_sprintf, (NODE *(*)(int  ))0}, 
        {"sqrt", (OPCODE )65, 300, (unsigned int )(1 << 1), & do_sqrt, & do_mpfr_sqrt}, 
        {"srand",
      (OPCODE )65, 300, (unsigned int )(257 | (1 << 1)), & do_srand, & do_mpfr_srand}, 
        {"strftime",
      (OPCODE )65, 300, (unsigned int )(((1025 | (1 << 1)) | (1 << 2)) | (1 << 3)),
      & do_strftime, (NODE *(*)(int  ))0}, 
        {"strtonum", (OPCODE )65, 300, (unsigned int )(1024 | (1 << 1)), & do_strtonum,
      & do_mpfr_strtonum}, 
        {"sub", (OPCODE )66, 300, (unsigned int )((256 | (1 << 2)) | (1 << 3)), (NODE *(*)(int  ))0,
      (NODE *(*)(int  ))0}, 
        {"substr", (OPCODE )65, 300, (unsigned int )((1 << 2) | (1 << 3)), & do_substr,
      (NODE *(*)(int  ))0}, 
        {"switch", (OPCODE )110, 278, 3072U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"system",
      (OPCODE )65, 300, (unsigned int )(256 | (1 << 1)), & do_system, (NODE *(*)(int  ))0}, 
        {"systime",
      (OPCODE )65, 300, 1025U, & do_systime, (NODE *(*)(int  ))0}, 
        {"tolower", (OPCODE )65, 300, (unsigned int )(256 | (1 << 1)), & do_tolower,
      (NODE *(*)(int  ))0}, 
        {"toupper", (OPCODE )65, 300, (unsigned int )(256 | (1 << 1)), & do_toupper,
      (NODE *(*)(int  ))0}, 
        {"while", (OPCODE )109, 281, 6144U, (NODE *(*)(int  ))0, (NODE *(*)(int  ))0}, 
        {"xor",
      (OPCODE )65, 300, 1024U, & do_xor, & do_mpfr_xor}};
#line 1931 "awkgram.y"
static mbstate_t cur_mbstate  ;
#line 1935 "awkgram.y"
static char cur_char_ring[128]  ;
#line 1937 "awkgram.y"
static int cur_ring_idx  ;
#line 1948 "awkgram.y"
char const   *getfname(NODE *(*fptr___0)(int  ) ) 
{ 
  int i___0 ;
  int j ;

  {
#line 1953
  j = (int )(sizeof(tokentab) / sizeof(tokentab[0]));
#line 1955
  i___0 = 0;
  {
#line 1955
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1955
    if (! (i___0 < j)) {
#line 1955
      goto while_break;
    }
#line 1956
    if ((unsigned long )tokentab[i___0].ptr == (unsigned long )fptr___0) {
#line 1957
      return ((char const   *)tokentab[i___0].operator);
    }
#line 1955
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1959
  return ((char const   *)((void *)0));
}
}
#line 1964 "awkgram.y"
void negate_num(NODE *n ) 
{ 
  int tval ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1968
  if ((n->flags & 2048U) != 0U) {
    {
#line 1970
    tval = mpfr_neg(n->sub.val.nm.mpnum, (mpfr_srcptr )(n->sub.val.nm.mpnum), ROUND_MODE);
    }
#line 1971
    if (do_ieee_fmt) {
      {
#line 1971
      tmp___1 = format_ieee(n->sub.val.nm.mpnum, tval);
      }
#line 1971
      if (tmp___1) {
#line 1971
        tmp___2 = 1;
      } else {
#line 1971
        tmp___2 = 0;
      }
    } else {
#line 1971
      tmp___2 = 0;
    }
  } else
#line 1972
  if ((n->flags & 4096U) != 0U) {
    {
#line 1973
    __gmpz_neg(n->sub.val.nm.mpi, (mpz_srcptr )(n->sub.val.nm.mpi));
    }
  } else {
#line 1976
    n->sub.val.nm.fltnum = - n->sub.val.nm.fltnum;
  }
#line 1977
  return;
}
}
#line 1981 "awkgram.y"
static void print_included_from(void) 
{ 
  int saveline ;
  int line ;
  SRCFILE *s___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1988
  saveline = sourceline;
#line 1989
  sourceline = 0;
#line 1991
  s___0 = sourcefile;
  {
#line 1991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1991
    if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 1991
      if (! ((unsigned int )s___0->stype == 4U)) {
#line 1991
        goto while_break;
      }
    } else {
#line 1991
      goto while_break;
    }
#line 1992
    s___0 = s___0->next;
#line 1993
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1994
      goto __Cont;
    } else
#line 1993
    if (s___0->fd <= -1) {
#line 1994
      goto __Cont;
    }
#line 1995
    line = s___0->srclines;
#line 1998
    if (s___0->lasttok == 306) {
#line 1999
      line --;
    }
#line 2000
    if ((unsigned int )s___0->stype == 4U) {
#line 2000
      tmp___1 = ',';
    } else {
#line 2000
      tmp___1 = ':';
    }
#line 2000
    if ((unsigned int )s___0->stype == 4U) {
#line 2000
      tmp___2 = (char const   *)s___0->src;
    } else
#line 2000
    if ((unsigned int )s___0->stype == 3U) {
#line 2000
      tmp___2 = (char const   *)s___0->src;
    } else {
#line 2000
      tmp___2 = "cmd. line";
    }
#line 2000
    if ((unsigned long )s___0->prev == (unsigned long )sourcefile) {
#line 2000
      tmp___3 = "In file included from";
    } else {
#line 2000
      tmp___3 = "                 from";
    }
    {
#line 2000
    msg("%s %s:%d%c", tmp___3, tmp___2, line, tmp___1);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2009
  sourceline = saveline;
#line 2010
  return;
}
}
#line 2014 "awkgram.y"
static void ( /* format attribute */  warning_ln)(int line , char const   *mesg  , ...) 
{ 
  va_list args ;
  int saveline ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 2020
  saveline = sourceline;
#line 2021
  sourceline = line;
#line 2022
  print_included_from();
#line 2023
  __builtin_va_start(args, mesg);
#line 2024
  tmp___1 = gettext("warning: ");
#line 2024
  err((_Bool)0, (char const   *)tmp___1, mesg, args);
#line 2025
  __builtin_va_end(args);
#line 2026
  sourceline = saveline;
  }
#line 2027
  return;
}
}
#line 2031 "awkgram.y"
static void ( /* format attribute */  lintwarn_ln)(int line , char const   *mesg 
                                                   , ...) 
{ 
  va_list args ;
  int saveline ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2037
  saveline = sourceline;
#line 2038
  sourceline = line;
#line 2039
  print_included_from();
#line 2040
  __builtin_va_start(args, mesg);
  }
#line 2041
  if ((unsigned long )lintfunc == (unsigned long )(& r_fatal)) {
    {
#line 2042
    tmp___1 = gettext("fatal: ");
#line 2042
    err((_Bool)1, (char const   *)tmp___1, mesg, args);
    }
  } else {
    {
#line 2044
    tmp___2 = gettext("warning: ");
#line 2044
    err((_Bool)0, (char const   *)tmp___2, mesg, args);
    }
  }
  {
#line 2045
  __builtin_va_end(args);
#line 2046
  sourceline = saveline;
  }
#line 2047
  if ((unsigned long )lintfunc == (unsigned long )(& r_fatal)) {
    {
#line 2048
    gawk_exit(2);
    }
  }
#line 2049
  return;
}
}
#line 2053 "awkgram.y"
static void ( /* format attribute */  error_ln)(int line , char const   *m  , ...) 
{ 
  va_list args ;
  int saveline ;
  char *__cil_tmp5 ;

  {
  {
#line 2059
  saveline = sourceline;
#line 2060
  sourceline = line;
#line 2061
  print_included_from();
#line 2062
  errcount___0 ++;
#line 2063
  __builtin_va_start(args, m);
#line 2064
  err((_Bool)0, "error: ", m, args);
#line 2065
  __builtin_va_end(args);
#line 2066
  sourceline = saveline;
  }
#line 2067
  return;
}
}
#line 2080 "awkgram.y"
static char end_of_file_line[14]  = 
#line 2080
  {      (char )'(',      (char )'E',      (char )'N',      (char )'D', 
        (char )' ',      (char )'O',      (char )'F',      (char )' ', 
        (char )'F',      (char )'I',      (char )'L',      (char )'E', 
        (char )')',      (char )'\000'};
#line 2071 "awkgram.y"
static void ( /* format attribute */  yyerror)(char const   *m  , ...) 
{ 
  va_list args ;
  char const   *mesg ;
  char *bp ;
  char *cp ;
  char *scan ;
  char *buf___7 ;
  int count ;
  char save ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 2075
  mesg = (char const   *)((void *)0);
#line 2083
  print_included_from();
#line 2085
  errcount___0 ++;
  }
#line 2087
  if (lexptr___1) {
#line 2087
    if (lexeme) {
#line 2088
      if ((unsigned long )thisline == (unsigned long )((void *)0)) {
#line 2089
        cp = lexeme;
#line 2090
        if ((int )*cp == 10) {
          {
#line 2091
          cp --;
#line 2092
          tmp___1 = gettext("unexpected newline or end of string");
#line 2092
          mesg = (char const   *)tmp___1;
          }
        }
        {
#line 2094
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2094
          if ((unsigned long )cp != (unsigned long )lexptr_begin___0) {
#line 2094
            if (! ((int )*cp != 10)) {
#line 2094
              goto while_break;
            }
          } else {
#line 2094
            goto while_break;
          }
#line 2095
          goto __Cont;
          __Cont: /* CIL Label */ 
#line 2094
          cp --;
        }
        while_break: /* CIL Label */ ;
        }
#line 2096
        if ((int )*cp == 10) {
#line 2097
          cp ++;
        }
#line 2098
        thisline = cp;
      }
#line 2101
      bp = lexeme;
      {
#line 2102
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2102
        if ((unsigned long )bp < (unsigned long )lexend___0) {
#line 2102
          if (*bp) {
#line 2102
            if (! ((int )*bp != 10)) {
#line 2102
              goto while_break___0;
            }
          } else {
#line 2102
            goto while_break___0;
          }
        } else {
#line 2102
          goto while_break___0;
        }
#line 2103
        bp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 2105
      thisline = end_of_file_line;
#line 2106
      tmp___2 = strlen((char const   *)thisline);
#line 2106
      bp = thisline + tmp___2;
      }
    }
  } else {
    {
#line 2105
    thisline = end_of_file_line;
#line 2106
    tmp___2 = strlen((char const   *)thisline);
#line 2106
    bp = thisline + tmp___2;
    }
  }
  {
#line 2116
  save = *bp;
#line 2117
  *bp = (char )'\000';
#line 2119
  msg("%.*s", (int )(bp - thisline), thisline);
#line 2121
  *bp = save;
#line 2122
  __builtin_va_start(args, m);
  }
#line 2123
  if ((unsigned long )mesg == (unsigned long )((void *)0)) {
#line 2124
    mesg = m;
  }
  {
#line 2126
  tmp___3 = strlen(mesg);
#line 2126
  count = (int )((((size_t )(bp - thisline) + tmp___3) + 2UL) + 1UL);
#line 2127
  tmp___4 = malloc((size_t )count);
#line 2127
  buf___7 = (char *)tmp___4;
  }
#line 2127
  if (buf___7) {
#line 2127
    tmp___8 = 1;
  } else {
    {
#line 2127
    set_loc("awkgram.y", 2127);
#line 2127
    tmp___5 = __errno_location();
#line 2127
    tmp___6 = strerror(*tmp___5);
#line 2127
    tmp___7 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2127
    r_fatal((char const   *)tmp___7, "yyerror", "buf", (long )count, tmp___6);
#line 2127
    tmp___8 = 0;
    }
  }
#line 2129
  bp = buf___7;
#line 2131
  if ((unsigned long )lexptr___1 != (unsigned long )((void *)0)) {
#line 2132
    scan = thisline;
    {
#line 2133
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2133
      if (! ((unsigned long )scan < (unsigned long )lexeme)) {
#line 2133
        goto while_break___1;
      }
#line 2134
      tmp___11 = scan;
#line 2134
      scan ++;
#line 2134
      if ((int )*tmp___11 == 9) {
#line 2135
        tmp___9 = bp;
#line 2135
        bp ++;
#line 2135
        *tmp___9 = (char )'\t';
      } else {
#line 2137
        tmp___10 = bp;
#line 2137
        bp ++;
#line 2137
        *tmp___10 = (char )' ';
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2138
    tmp___12 = bp;
#line 2138
    bp ++;
#line 2138
    *tmp___12 = (char )'^';
#line 2139
    tmp___13 = bp;
#line 2139
    bp ++;
#line 2139
    *tmp___13 = (char )' ';
  }
  {
#line 2141
  strcpy((char */* __restrict  */)bp, (char const   */* __restrict  */)mesg);
#line 2142
  err((_Bool)0, "", (char const   *)buf___7, args);
#line 2143
  __builtin_va_end(args);
#line 2144
  free((void *)buf___7);
  }
#line 2145
  return;
}
}
#line 2149 "awkgram.y"
static INSTRUCTION *mk_program(void) 
{ 
  INSTRUCTION *cp ;
  INSTRUCTION *tmp___1 ;
  INSTRUCTION *tmp___2 ;
  int tmp___3 ;
  INSTRUCTION *tmp___4 ;
  INSTRUCTION *tmp___5 ;
  INSTRUCTION *tmp___6 ;
  INSTRUCTION *tmp___7 ;
  INSTRUCTION *tmp___8 ;
  INSTRUCTION *tmp___9 ;
  INSTRUCTION *tmp___10 ;
  INSTRUCTION *tmp___11 ;

  {
#line 2160
  if ((unsigned long )rule_block[3] == (unsigned long )((void *)0)) {
    {
#line 2161
    rule_block[3] = list_create(ip_end);
    }
  } else {
    {
#line 2163
    list_prepend(rule_block[3], ip_end);
    }
  }
  {
#line 2165
  tmp___3 = in_main_context();
  }
#line 2165
  if (! tmp___3) {
#line 2166
    if ((unsigned long )rule_block[1] != (unsigned long )((void *)0)) {
#line 2166
      if ((unsigned long )rule_block[2] != (unsigned long )((void *)0)) {
        {
#line 2167
        cp = list_merge(rule_block[1], rule_block[2]);
        }
      } else {
#line 2166
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2169
    if ((unsigned long )rule_block[1] != (unsigned long )((void *)0)) {
#line 2169
      cp = rule_block[1];
    } else {
#line 2169
      cp = rule_block[2];
    }
#line 2171
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 2172
      list_merge(cp, rule_block[3]);
      }
    } else {
#line 2174
      cp = rule_block[3];
    }
    {
#line 2176
    tmp___2 = bcalloc((OPCODE )102, 1, 0);
#line 2176
    list_append(cp, tmp___2);
    }
#line 2177
    goto out;
  }
#line 2180
  if ((unsigned long )rule_block[5] == (unsigned long )((void *)0)) {
    {
#line 2181
    rule_block[5] = list_create(ip_endfile);
    }
  } else {
    {
#line 2183
    ip_rec->x.xl = 1L;
#line 2184
    list_prepend(rule_block[5], ip_endfile);
    }
  }
#line 2187
  if ((unsigned long )rule_block[4] == (unsigned long )((void *)0)) {
    {
#line 2188
    rule_block[4] = list_create(ip_beginfile);
    }
  } else {
    {
#line 2190
    list_prepend(rule_block[4], ip_beginfile);
    }
  }
#line 2192
  if ((unsigned long )rule_block[2] == (unsigned long )((void *)0)) {
#line 2193
    if ((unsigned long )(rule_block[3])->nexti == (unsigned long )(rule_block[3])->d.di) {
#line 2193
      if ((unsigned long )(rule_block[4])->nexti == (unsigned long )(rule_block[4])->d.di) {
#line 2193
        if ((unsigned long )(rule_block[5])->nexti == (unsigned long )(rule_block[5])->d.di) {
          {
#line 2198
          bcfree(ip_rec);
#line 2199
          bcfree(ip_newfile);
#line 2200
          ip_newfile = (INSTRUCTION *)((void *)0);
#line 2200
          ip_rec = ip_newfile;
#line 2202
          tmp___4 = bcalloc((OPCODE )95, 1, 0);
#line 2202
          list_append(rule_block[4], tmp___4);
#line 2203
          tmp___5 = bcalloc((OPCODE )96, 1, 0);
#line 2203
          list_append(rule_block[5], tmp___5);
          }
#line 2205
          if ((unsigned long )rule_block[1] == (unsigned long )((void *)0)) {
#line 2206
            cp = rule_block[3];
          } else {
            {
#line 2208
            cp = list_merge(rule_block[1], rule_block[3]);
            }
          }
          {
#line 2209
          list_append(cp, ip_atexit);
#line 2210
          tmp___6 = bcalloc((OPCODE )102, 1, 0);
#line 2210
          list_append(cp, tmp___6);
#line 2216
          list_merge(cp, rule_block[4]);
#line 2217
          list_merge(cp, rule_block[5]);
          }
#line 2219
          goto out;
        } else {
          {
#line 2223
          tmp___7 = bcalloc((OPCODE )81, 1, 0);
#line 2223
          rule_block[2] = list_create(tmp___7);
          }
        }
      } else {
        {
#line 2223
        tmp___7 = bcalloc((OPCODE )81, 1, 0);
#line 2223
        rule_block[2] = list_create(tmp___7);
        }
      }
    } else {
      {
#line 2223
      tmp___7 = bcalloc((OPCODE )81, 1, 0);
#line 2223
      rule_block[2] = list_create(tmp___7);
      }
    }
  }
  {
#line 2227
  tmp___8 = bcalloc((OPCODE )96, 1, 0);
#line 2227
  list_append(rule_block[5], tmp___8);
#line 2228
  list_prepend(rule_block[2], ip_rec);
#line 2229
  tmp___9 = bcalloc((OPCODE )83, 1, 0);
#line 2229
  list_append(rule_block[2], tmp___9);
#line 2230
  ((rule_block[2])->d.di)->d.di = ip_rec;
#line 2232
  tmp___10 = bcalloc((OPCODE )95, 1, 0);
#line 2232
  list_append(rule_block[4], tmp___10);
#line 2234
  cp = list_merge(rule_block[4], rule_block[2]);
#line 2235
  list_prepend(cp, ip_newfile);
#line 2236
  list_merge(cp, rule_block[5]);
#line 2237
  list_merge(cp, rule_block[3]);
  }
#line 2238
  if ((unsigned long )rule_block[1] != (unsigned long )((void *)0)) {
    {
#line 2239
    cp = list_merge(rule_block[1], cp);
    }
  }
  {
#line 2241
  list_append(cp, ip_atexit);
#line 2242
  tmp___11 = bcalloc((OPCODE )102, 1, 0);
#line 2242
  list_append(cp, tmp___11);
  }
  out: 
  {
#line 2246
  tmp___1 = cp->nexti;
#line 2247
  bcfree(cp);
  }
#line 2248
  return (tmp___1);
}
}
#line 2259 "awkgram.y"
int parse_program(INSTRUCTION **pcode ) 
{ 
  int ret ;
  int tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 2268
  ip_end = bcalloc((OPCODE )81, 1, 0);
#line 2270
  tmp___1 = in_main_context();
  }
#line 2270
  if (tmp___1) {
    {
#line 2273
    ip_endfile = bcalloc((OPCODE )81, 1, 0);
#line 2274
    ip_beginfile = bcalloc((OPCODE )81, 1, 0);
#line 2275
    ip_rec = bcalloc((OPCODE )86, 1, 0);
#line 2276
    ip_newfile = bcalloc((OPCODE )87, 2, 0);
#line 2277
    ip_newfile->d.di = ip_end;
#line 2278
    ip_newfile->x.xi = ip_endfile;
#line 2279
    (ip_newfile + 1)->x.xi = ip_rec;
#line 2280
    ip_rec->d.di = ip_newfile;
#line 2281
    ip_atexit = bcalloc((OPCODE )101, 1, 0);
    }
  } else {
#line 2271
    ip_endfile = (INSTRUCTION *)((void *)0);
#line 2271
    ip_beginfile = ip_endfile;
#line 2271
    ip_atexit = ip_beginfile;
#line 2271
    ip_rec = ip_atexit;
#line 2271
    ip_newfile = ip_rec;
  }
#line 2284
  sourcefile = srcfiles->next;
  {
#line 2284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2284
    if (! ((unsigned int )sourcefile->stype == 5U)) {
#line 2284
      goto while_break;
    }
#line 2284
    sourcefile = sourcefile->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2288
  lexeof = (_Bool)0;
#line 2289
  lexptr___1 = (char *)((void *)0);
#line 2290
  lasttok___0 = 0;
#line 2291
  memset((void *)(rule_block), 0, sizeof(ruletab) * sizeof(INSTRUCTION *));
#line 2292
  errcount___0 = 0;
  }
#line 2293
  if ((unsigned long )tokstart != (unsigned long )((void *)0)) {
#line 2293
    tok___0 = tokstart;
  } else {
    {
#line 2293
    tmp___2 = tokexpand();
#line 2293
    tok___0 = tmp___2;
    }
  }
  {
#line 2295
  ret = yyparse();
#line 2296
  *pcode = mk_program();
#line 2299
  source = (char *)((void *)0);
#line 2300
  sourceline = 0;
  }
#line 2301
  if (ret == 0) {
    {
#line 2302
    check_funcs();
    }
  }
#line 2304
  if ((unsigned long )args_array == (unsigned long )((void *)0)) {
    {
#line 2305
    tmp___3 = malloc((unsigned long )(max_args + 2) * sizeof(NODE *));
#line 2305
    args_array = (NODE **)tmp___3;
    }
#line 2305
    if (args_array) {
#line 2305
      tmp___7 = 1;
    } else {
      {
#line 2305
      set_loc("awkgram.y", 2305);
#line 2305
      tmp___4 = __errno_location();
#line 2305
      tmp___5 = strerror(*tmp___4);
#line 2305
      tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2305
      r_fatal((char const   *)tmp___6, "parse_program", "args_array", (long )((unsigned long )(max_args + 2) * sizeof(NODE *)),
              tmp___5);
#line 2305
      tmp___7 = 0;
      }
    }
  } else {
    {
#line 2307
    tmp___8 = realloc((void *)((char *)args_array), (unsigned long )(max_args + 2) * sizeof(NODE *));
#line 2307
    args_array = (NODE **)tmp___8;
    }
#line 2307
    if (args_array) {
#line 2307
      tmp___12 = 1;
    } else {
      {
#line 2307
      set_loc("awkgram.y", 2307);
#line 2307
      tmp___9 = __errno_location();
#line 2307
      tmp___10 = strerror(*tmp___9);
#line 2307
      tmp___11 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2307
      r_fatal((char const   *)tmp___11, "parse_program", "args_array", (long )((unsigned long )(max_args + 2) * sizeof(NODE *)),
              tmp___10);
#line 2307
      tmp___12 = 0;
      }
    }
  }
#line 2309
  if (ret) {
#line 2309
    tmp___13 = 1;
  } else
#line 2309
  if (errcount___0) {
#line 2309
    tmp___13 = 1;
  } else {
#line 2309
    tmp___13 = 0;
  }
#line 2309
  return (tmp___13);
}
}
#line 2314 "awkgram.y"
static SRCFILE *do_add_srcfile(int stype , char *src , char *path , SRCFILE *thisfile ) 
{ 
  SRCFILE *s___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 2319
  tmp___1 = malloc(sizeof(SRCFILE ));
#line 2319
  s___0 = (SRCFILE *)tmp___1;
  }
#line 2319
  if (s___0) {
#line 2319
    tmp___5 = 1;
  } else {
    {
#line 2319
    set_loc("awkgram.y", 2319);
#line 2319
    tmp___2 = __errno_location();
#line 2319
    tmp___3 = strerror(*tmp___2);
#line 2319
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2319
    r_fatal((char const   *)tmp___4, "do_add_srcfile", "s", (long )sizeof(SRCFILE ),
            tmp___3);
#line 2319
    tmp___5 = 0;
    }
  }
  {
#line 2320
  memset((void *)s___0, 0, sizeof(SRCFILE ));
#line 2321
  tmp___6 = strlen((char const   *)src);
#line 2321
  s___0->src = estrdup((char const   *)src, tmp___6);
#line 2322
  s___0->fullpath = path;
#line 2323
  s___0->stype = (enum srctype )stype;
#line 2324
  s___0->fd = -1;
#line 2325
  s___0->next = thisfile;
#line 2326
  s___0->prev = thisfile->prev;
#line 2327
  (thisfile->prev)->next = s___0;
#line 2328
  thisfile->prev = s___0;
  }
#line 2329
  return (s___0);
}
}
#line 2336 "awkgram.y"
SRCFILE *add_srcfile(int stype , char *src , SRCFILE *thisfile , _Bool *already_included ,
                     int *errcode ) 
{ 
  SRCFILE *s___0 ;
  struct stat sbuf ;
  char *path ;
  int errno_val ;
  SRCFILE *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int line ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 2342
  errno_val = 0;
#line 2344
  if (already_included) {
#line 2345
    *already_included = (_Bool)0;
  }
#line 2346
  if (errcode) {
#line 2347
    *errcode = 0;
  }
#line 2348
  if (stype == 1) {
    {
#line 2349
    tmp___1 = do_add_srcfile(stype, src, (char *)((void *)0), thisfile);
    }
#line 2349
    return (tmp___1);
  } else
#line 2348
  if (stype == 2) {
    {
#line 2349
    tmp___1 = do_add_srcfile(stype, src, (char *)((void *)0), thisfile);
    }
#line 2349
    return (tmp___1);
  }
  {
#line 2351
  path = find_source((char const   *)src, & sbuf, & errno_val, stype == 5);
  }
#line 2352
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 2353
    if (errcode) {
#line 2354
      *errcode = errno_val;
#line 2355
      return ((SRCFILE *)((void *)0));
    }
    {
#line 2358
    set_loc("awkgram.y", 2358);
    }
#line 2358
    if (errno_val) {
      {
#line 2358
      tmp___2 = strerror(errno_val);
#line 2358
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 2358
      tmp___3 = gettext("reason unknown");
#line 2358
      tmp___4 = tmp___3;
      }
    }
#line 2358
    if (stype != 5) {
      {
#line 2358
      tmp___5 = gettext("can\'t open source file `%s\' for reading (%s)");
#line 2358
      tmp___7 = tmp___5;
      }
    } else {
      {
#line 2358
      tmp___6 = gettext("can\'t open shared library `%s\' for reading (%s)");
#line 2358
      tmp___7 = tmp___6;
      }
    }
    {
#line 2358
    r_fatal((char const   *)tmp___7, src, tmp___4);
    }
  }
#line 2366
  s___0 = srcfiles->next;
  {
#line 2366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2366
    if (! ((unsigned long )s___0 != (unsigned long )srcfiles)) {
#line 2366
      goto while_break;
    }
#line 2367
    if ((unsigned int )s___0->stype == 3U) {
#line 2367
      goto _L___0;
    } else
#line 2367
    if ((unsigned int )s___0->stype == 4U) {
#line 2367
      goto _L___0;
    } else
#line 2367
    if ((unsigned int )s___0->stype == 5U) {
      _L___0: /* CIL Label */ 
      {
#line 2367
      tmp___13 = files_are_same(path, s___0);
      }
#line 2367
      if (tmp___13) {
#line 2368
        if (stype == 4) {
#line 2368
          goto _L;
        } else
#line 2368
        if (stype == 5) {
          _L: /* CIL Label */ 
#line 2370
          if (stype == 4) {
#line 2370
            if ((unsigned int )s___0->stype == 3U) {
              {
#line 2371
              set_loc("awkgram.y", 2371);
#line 2371
              tmp___8 = gettext("can\'t include `%s\' and use it as a program file");
#line 2371
              r_fatal((char const   *)tmp___8, src);
              }
            }
          }
#line 2373
          if (do_flags & 3) {
#line 2374
            line = sourceline;
#line 2380
            if (sourceline > 1) {
#line 2380
              if (lasttok___0 == 306) {
#line 2381
                line --;
              }
            }
#line 2382
            if (stype != 5) {
              {
#line 2382
              tmp___9 = gettext("already included source file `%s\'");
#line 2382
              tmp___11 = tmp___9;
              }
            } else {
              {
#line 2382
              tmp___10 = gettext("already loaded shared library `%s\'");
#line 2382
              tmp___11 = tmp___10;
              }
            }
            {
#line 2382
            lintwarn_ln(line, (char const   *)tmp___11, src);
            }
          }
          {
#line 2388
          free((void *)path);
          }
#line 2389
          if (already_included) {
#line 2390
            *already_included = (_Bool)1;
          }
#line 2391
          return ((SRCFILE *)((void *)0));
        } else {
#line 2394
          if ((unsigned int )s___0->stype == 4U) {
            {
#line 2395
            set_loc("awkgram.y", 2395);
#line 2395
            tmp___12 = gettext("can\'t include `%s\' and use it as a program file");
#line 2395
            r_fatal((char const   *)tmp___12, src);
            }
          }
#line 2398
          goto while_break;
        }
      }
    }
#line 2366
    s___0 = s___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2403
  s___0 = do_add_srcfile(stype, src, path, thisfile);
#line 2404
  s___0->sbuf = sbuf;
#line 2405
  s___0->mtime = sbuf.st_mtim.tv_sec;
  }
#line 2406
  return (s___0);
}
}
#line 2411 "awkgram.y"
static int include_source(INSTRUCTION *file ) 
{ 
  SRCFILE *s___0 ;
  char *src ;
  int errcode ;
  _Bool already_included ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2415
  src = file->d.name;
#line 2419
  if (do_flags & 8) {
    {
#line 2420
    tmp___1 = gettext("@include is a gawk extension");
#line 2420
    error_ln((int )file->source_line, (char const   *)tmp___1);
    }
#line 2421
    return (-1);
  } else
#line 2419
  if (do_flags & 16) {
    {
#line 2420
    tmp___1 = gettext("@include is a gawk extension");
#line 2420
    error_ln((int )file->source_line, (char const   *)tmp___1);
    }
#line 2421
    return (-1);
  }
  {
#line 2424
  tmp___3 = strlen((char const   *)src);
  }
#line 2424
  if (tmp___3 == 0UL) {
#line 2425
    if (do_flags & 3) {
      {
#line 2426
      tmp___2 = gettext("empty filename after @include");
#line 2426
      lintwarn_ln((int )file->source_line, (char const   *)tmp___2);
      }
    }
#line 2427
    return (0);
  }
  {
#line 2430
  s___0 = add_srcfile(4, src, sourcefile, & already_included, & errcode);
  }
#line 2431
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 2432
    if (already_included) {
#line 2433
      return (0);
    }
#line 2434
    if (errcode) {
      {
#line 2434
      tmp___4 = strerror(errcode);
#line 2434
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 2434
      tmp___5 = gettext("reason unknown");
#line 2434
      tmp___6 = tmp___5;
      }
    }
    {
#line 2434
    tmp___7 = gettext("can\'t open source file `%s\' for reading (%s)");
#line 2434
    error_ln((int )file->source_line, (char const   *)tmp___7, src, tmp___6);
    }
#line 2437
    return (-1);
  }
#line 2441
  sourcefile->srclines = sourceline;
#line 2442
  sourcefile->lexptr = lexptr___1;
#line 2443
  sourcefile->lexend = lexend___0;
#line 2444
  sourcefile->lexptr_begin = lexptr_begin___0;
#line 2445
  sourcefile->lexeme = lexeme;
#line 2446
  sourcefile->lasttok = lasttok___0;
#line 2449
  sourcefile = s___0;
#line 2450
  lexptr___1 = (char *)((void *)0);
#line 2451
  sourceline = 0;
#line 2452
  source = (char *)((void *)0);
#line 2453
  lasttok___0 = 0;
#line 2454
  lexeof = (_Bool)0;
#line 2455
  eof_warned = (_Bool)0;
#line 2456
  return (0);
}
}
#line 2461 "awkgram.y"
static int load_library(INSTRUCTION *file ) 
{ 
  SRCFILE *s___0 ;
  char *src ;
  int errcode ;
  _Bool already_included ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2465
  src = file->d.name;
#line 2469
  if (do_flags & 8) {
    {
#line 2470
    tmp___1 = gettext("@load is a gawk extension");
#line 2470
    error_ln((int )file->source_line, (char const   *)tmp___1);
    }
#line 2471
    return (-1);
  } else
#line 2469
  if (do_flags & 16) {
    {
#line 2470
    tmp___1 = gettext("@load is a gawk extension");
#line 2470
    error_ln((int )file->source_line, (char const   *)tmp___1);
    }
#line 2471
    return (-1);
  }
  {
#line 2474
  tmp___3 = strlen((char const   *)src);
  }
#line 2474
  if (tmp___3 == 0UL) {
#line 2475
    if (do_flags & 3) {
      {
#line 2476
      tmp___2 = gettext("empty filename after @load");
#line 2476
      lintwarn_ln((int )file->source_line, (char const   *)tmp___2);
      }
    }
#line 2477
    return (0);
  }
  {
#line 2480
  s___0 = add_srcfile(5, src, sourcefile, & already_included, & errcode);
  }
#line 2481
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 2482
    if (already_included) {
#line 2483
      return (0);
    }
#line 2484
    if (errcode) {
      {
#line 2484
      tmp___4 = strerror(errcode);
#line 2484
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 2484
      tmp___5 = gettext("reason unknown");
#line 2484
      tmp___6 = tmp___5;
      }
    }
    {
#line 2484
    tmp___7 = gettext("can\'t open shared library `%s\' for reading (%s)");
#line 2484
    error_ln((int )file->source_line, (char const   *)tmp___7, src, tmp___6);
    }
#line 2487
    return (-1);
  }
  {
#line 2490
  load_ext((char const   *)s___0->fullpath);
  }
#line 2491
  return (0);
}
}
#line 2499 "awkgram.y"
static int (*closefunc)(int fd )  =    (int (*)(int fd ))((void *)0);
#line 2496 "awkgram.y"
static void next_sourcefile(void) 
{ 
  char *cp ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp4 ;

  {
#line 2501
  if ((unsigned long )closefunc == (unsigned long )((void *)0)) {
    {
#line 2502
    tmp___1 = getenv("AWKREADFUNC");
#line 2502
    cp = tmp___1;
    }
#line 2505
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 2506
      closefunc = & close;
    } else {
#line 2508
      closefunc = & one_line_close;
    }
  }
#line 2520
  lexeof = (_Bool)0;
#line 2521
  eof_warned = (_Bool)0;
#line 2522
  sourcefile->srclines = sourceline;
#line 2523
  if (sourcefile->fd > -1) {
    {
#line 2524
    tmp___2 = fileno(stdin);
    }
#line 2524
    if (sourcefile->fd != tmp___2) {
      {
#line 2525
      (*closefunc)(sourcefile->fd);
      }
    }
#line 2526
    sourcefile->fd = -1;
  }
#line 2528
  if ((unsigned long )sourcefile->buf != (unsigned long )((void *)0)) {
    {
#line 2529
    free((void *)sourcefile->buf);
#line 2530
    sourcefile->buf = (char *)((void *)0);
#line 2531
    sourcefile->lexptr_begin = (char *)((void *)0);
    }
  }
  {
#line 2534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2534
    sourcefile = sourcefile->next;
#line 2534
    if (! ((unsigned long )sourcefile != (unsigned long )((void *)0))) {
#line 2534
      goto while_break;
    }
#line 2535
    if ((unsigned long )sourcefile == (unsigned long )srcfiles) {
#line 2536
      return;
    }
#line 2537
    if ((unsigned int )sourcefile->stype != 5U) {
#line 2538
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2541
  if ((unsigned long )sourcefile->lexptr_begin != (unsigned long )((void *)0)) {
#line 2543
    lexptr___1 = sourcefile->lexptr;
#line 2544
    lexend___0 = sourcefile->lexend;
#line 2545
    lasttok___0 = sourcefile->lasttok;
#line 2546
    lexptr_begin___0 = sourcefile->lexptr_begin;
#line 2547
    lexeme = sourcefile->lexeme;
#line 2548
    sourceline = sourcefile->srclines;
#line 2549
    source = sourcefile->src;
  } else {
#line 2551
    lexptr___1 = (char *)((void *)0);
#line 2552
    sourceline = 0;
#line 2553
    source = (char *)((void *)0);
#line 2554
    lasttok___0 = 0;
  }
#line 2556
  return;
}
}
#line 2574 "awkgram.y"
static ssize_t (*readfunc)()  =    (ssize_t (*)())0;
#line 2606 "awkgram.y"
static _Bool warned___22  =    (_Bool)0;
#line 2732 "awkgram.y"
static _Bool warned___23  =    (_Bool)0;
#line 2560 "awkgram.y"
static char *get_src_buf(void) 
{ 
  int n ;
  char *scan ;
  _Bool newfile ;
  int savelen ;
  struct stat sbuf ;
  char *cp ;
  char *tmp___1 ;
  char *tmp___2 ;
  int offset ;
  char *buf___7 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int fd ;
  int l ;
  char *in ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  void *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int offset___0 ;
  char *tmp___18 ;
  void *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  ssize_t tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 2576
  if ((unsigned long )readfunc == (unsigned long )((void *)0)) {
    {
#line 2577
    tmp___1 = getenv("AWKREADFUNC");
#line 2577
    cp = tmp___1;
    }
#line 2580
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 2585
      readfunc = (ssize_t (*)())(& read);
    } else {
#line 2587
      readfunc = (ssize_t (*)())(& read_one_line);
    }
  }
#line 2590
  newfile = (_Bool)0;
#line 2591
  if ((unsigned long )sourcefile == (unsigned long )srcfiles) {
#line 2592
    return ((char *)((void *)0));
  }
#line 2594
  if ((unsigned int )sourcefile->stype == 1U) {
#line 2595
    if (sourcefile->bufsize == 0UL) {
      {
#line 2596
      sourcefile->bufsize = strlen((char const   *)sourcefile->src);
#line 2597
      lexeme = sourcefile->src;
#line 2597
      lexptr_begin___0 = lexeme;
#line 2597
      lexptr___1 = lexptr_begin___0;
#line 2598
      lexend___0 = lexptr___1 + sourcefile->bufsize;
#line 2599
      sourceline = 1;
      }
#line 2600
      if (sourcefile->bufsize == 0UL) {
#line 2608
        if (do_flags & 3) {
#line 2608
          if (! warned___22) {
            {
#line 2609
            warned___22 = (_Bool)1;
#line 2610
            set_loc("awkgram.y", 2610);
#line 2610
            tmp___2 = gettext("empty program text on command line");
#line 2610
            (*lintfunc)((char const   *)tmp___2);
            }
          }
        }
#line 2612
        lexeof = (_Bool)1;
      }
    } else
#line 2614
    if ((unsigned long )sourcefile->buf == (unsigned long )((void *)0)) {
#line 2614
      if ((int )*(lexptr___1 - 1) != 10) {
#line 2623
        offset = (int )(lexptr___1 - lexeme);
#line 2624
        scan = lexeme;
        {
#line 2624
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2624
          if (! ((unsigned long )scan > (unsigned long )lexptr_begin___0)) {
#line 2624
            goto while_break;
          }
#line 2625
          if ((int )*scan == 10) {
#line 2626
            scan ++;
#line 2627
            goto while_break;
          }
#line 2624
          scan --;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 2629
        savelen = (int )(lexptr___1 - scan);
#line 2630
        tmp___3 = malloc((size_t )(savelen + 1));
#line 2630
        buf___7 = (char *)tmp___3;
        }
#line 2630
        if (buf___7) {
#line 2630
          tmp___7 = 1;
        } else {
          {
#line 2630
          set_loc("awkgram.y", 2630);
#line 2630
          tmp___4 = __errno_location();
#line 2630
          tmp___5 = strerror(*tmp___4);
#line 2630
          tmp___6 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2630
          r_fatal((char const   *)tmp___6, "get_src_buf", "buf", (long )(savelen + 1),
                  tmp___5);
#line 2630
          tmp___7 = 0;
          }
        }
        {
#line 2631
        memcpy((void */* __restrict  */)buf___7, (void const   */* __restrict  */)scan,
               (size_t )savelen);
#line 2632
        thisline = buf___7;
#line 2633
        lexptr___1 = buf___7 + savelen;
#line 2634
        *lexptr___1 = (char )'\n';
#line 2635
        lexeme = lexptr___1 - offset;
#line 2636
        lexptr_begin___0 = buf___7;
#line 2637
        lexend___0 = lexptr___1 + 1;
#line 2638
        sourcefile->buf = buf___7;
        }
      } else {
#line 2640
        lexeof = (_Bool)1;
      }
    } else {
#line 2640
      lexeof = (_Bool)1;
    }
#line 2641
    return (lexptr___1);
  }
#line 2644
  if (sourcefile->fd <= -1) {
#line 2648
    source = sourcefile->src;
#line 2649
    if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 2650
      return ((char *)((void *)0));
    }
    {
#line 2651
    fd = srcopen(sourcefile);
    }
#line 2652
    if (fd <= -1) {
      {
#line 2656
      in = source;
#line 2657
      source = (char *)((void *)0);
#line 2658
      tmp___8 = __errno_location();
#line 2658
      tmp___9 = strerror(*tmp___8);
#line 2658
      tmp___10 = gettext("can\'t open source file `%s\' for reading (%s)");
#line 2658
      error((char const   *)tmp___10, in, tmp___9);
#line 2660
      errcount___0 ++;
#line 2661
      lexeof = (_Bool)1;
      }
#line 2662
      return (sourcefile->src);
    }
    {
#line 2665
    sourcefile->fd = fd;
#line 2666
    tmp___11 = optimal_bufsize(fd, & sbuf);
#line 2666
    l = (int )tmp___11;
    }
#line 2673
    if (l < 128) {
#line 2674
      l = 128;
    }
    {
#line 2676
    sourcefile->bufsize = (size_t )l;
#line 2677
    newfile = (_Bool)1;
#line 2678
    tmp___13 = malloc(sourcefile->bufsize);
#line 2678
    tmp___12 = (char *)tmp___13;
#line 2678
    sourcefile->buf = tmp___12;
    }
#line 2678
    if (tmp___12) {
#line 2678
      tmp___17 = 1;
    } else {
      {
#line 2678
      set_loc("awkgram.y", 2678);
#line 2678
      tmp___14 = __errno_location();
#line 2678
      tmp___15 = strerror(*tmp___14);
#line 2678
      tmp___16 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2678
      r_fatal((char const   *)tmp___16, "get_src_buf", "sourcefile->buf", (long )sourcefile->bufsize,
              tmp___15);
#line 2678
      tmp___17 = 0;
      }
    }
#line 2679
    lexeme = sourcefile->buf;
#line 2679
    lexptr_begin___0 = lexeme;
#line 2679
    lexptr___1 = lexptr_begin___0;
#line 2680
    savelen = 0;
#line 2681
    sourceline = 1;
#line 2682
    thisline = (char *)((void *)0);
  } else {
#line 2688
    scan = lexeme;
    {
#line 2688
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2688
      if (! ((unsigned long )scan > (unsigned long )lexptr_begin___0)) {
#line 2688
        goto while_break___0;
      }
#line 2689
      if ((int )*scan == 10) {
#line 2690
        scan ++;
#line 2691
        goto while_break___0;
      }
#line 2688
      scan --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2694
    savelen = (int )(lexptr___1 - scan);
#line 2695
    offset___0 = (int )(lexptr___1 - lexeme);
#line 2697
    if (savelen > 0) {
#line 2705
      if ((size_t )savelen > sourcefile->bufsize / 2UL) {
        {
#line 2706
        sourcefile->bufsize *= 2UL;
#line 2707
        tmp___19 = realloc((void *)sourcefile->buf, sourcefile->bufsize);
#line 2707
        tmp___18 = (char *)tmp___19;
#line 2707
        sourcefile->buf = tmp___18;
        }
#line 2707
        if (tmp___18) {
#line 2707
          tmp___23 = 1;
        } else {
          {
#line 2707
          set_loc("awkgram.y", 2707);
#line 2707
          tmp___20 = __errno_location();
#line 2707
          tmp___21 = strerror(*tmp___20);
#line 2707
          tmp___22 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2707
          r_fatal((char const   *)tmp___22, "get_src_buf", "sourcefile->buf", (long )sourcefile->bufsize,
                  tmp___21);
#line 2707
          tmp___23 = 0;
          }
        }
#line 2708
        scan = sourcefile->buf + (scan - lexptr_begin___0);
#line 2709
        lexptr_begin___0 = sourcefile->buf;
      }
      {
#line 2712
      thisline = lexptr_begin___0;
#line 2713
      memmove((void *)thisline, (void const   *)scan, (size_t )savelen);
#line 2714
      lexptr___1 = thisline + savelen;
#line 2715
      lexeme = lexptr___1 - offset___0;
      }
    } else {
#line 2717
      savelen = 0;
#line 2718
      lexeme = lexptr_begin___0;
#line 2718
      lexptr___1 = lexeme;
#line 2719
      thisline = (char *)((void *)0);
    }
  }
  {
#line 2723
  tmp___24 = (*readfunc)(sourcefile->fd, lexptr___1, sourcefile->bufsize - (size_t )savelen);
#line 2723
  n = (int )tmp___24;
  }
#line 2724
  if (n == -1) {
    {
#line 2725
    tmp___25 = __errno_location();
#line 2725
    tmp___26 = strerror(*tmp___25);
#line 2725
    tmp___27 = gettext("can\'t read sourcefile `%s\' (%s)");
#line 2725
    error((char const   *)tmp___27, source, tmp___26);
#line 2727
    errcount___0 ++;
#line 2728
    lexeof = (_Bool)1;
    }
  } else {
#line 2730
    lexend___0 = lexptr___1 + n;
#line 2731
    if (n == 0) {
#line 2733
      if (do_flags & 3) {
#line 2733
        if (newfile) {
#line 2733
          if (! warned___23) {
            {
#line 2734
            warned___23 = (_Bool)1;
#line 2735
            sourceline = 0;
#line 2736
            set_loc("awkgram.y", 2736);
#line 2736
            tmp___28 = gettext("source file `%s\' is empty");
#line 2736
            (*lintfunc)((char const   *)tmp___28, source);
            }
          }
        }
      }
#line 2738
      lexeof = (_Bool)1;
    }
  }
#line 2741
  return (sourcefile->buf);
}
}
#line 2753 "awkgram.y"
static int toksize  ;
#line 2750 "awkgram.y"
static char *tokexpand(void) 
{ 
  int tokoffset ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 2756
  if ((unsigned long )tokstart != (unsigned long )((void *)0)) {
    {
#line 2757
    tokoffset = (int )(tok___0 - tokstart);
#line 2758
    toksize *= 2;
#line 2759
    tmp___1 = realloc((void *)tokstart, (size_t )toksize);
#line 2759
    tokstart = (char *)tmp___1;
    }
#line 2759
    if (tokstart) {
#line 2759
      tmp___5 = 1;
    } else {
      {
#line 2759
      set_loc("awkgram.y", 2759);
#line 2759
      tmp___2 = __errno_location();
#line 2759
      tmp___3 = strerror(*tmp___2);
#line 2759
      tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2759
      r_fatal((char const   *)tmp___4, "tokexpand", "tokstart", (long )toksize, tmp___3);
#line 2759
      tmp___5 = 0;
      }
    }
#line 2760
    tok___0 = tokstart + tokoffset;
  } else {
    {
#line 2762
    toksize = 60;
#line 2763
    tmp___6 = malloc((size_t )toksize);
#line 2763
    tokstart = (char *)tmp___6;
    }
#line 2763
    if (tokstart) {
#line 2763
      tmp___10 = 1;
    } else {
      {
#line 2763
      set_loc("awkgram.y", 2763);
#line 2763
      tmp___7 = __errno_location();
#line 2763
      tmp___8 = strerror(*tmp___7);
#line 2763
      tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 2763
      r_fatal((char const   *)tmp___9, "tokexpand", "tokstart", (long )toksize, tmp___8);
#line 2763
      tmp___10 = 0;
      }
    }
#line 2764
    tok___0 = tokstart;
  }
#line 2766
  tokend = tokstart + toksize;
#line 2767
  return (tok___0);
}
}
#line 2774 "awkgram.y"
static int nextc(void) 
{ 
  char *tmp___1 ;
  int idx___3 ;
  int work_ring_idx ;
  mbstate_t tmp_state ;
  size_t mbclen ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 2777
  if (gawk_mb_cur_max > 1) {
    again: 
#line 2779
    if (lexeof) {
#line 2780
      return (-1000);
    }
#line 2781
    if ((unsigned long )lexptr___1 == (unsigned long )((void *)0)) {
#line 2781
      goto _L;
    } else
#line 2781
    if ((unsigned long )lexptr___1 >= (unsigned long )lexend___0) {
      _L: /* CIL Label */ 
      {
#line 2782
      tmp___1 = get_src_buf();
      }
#line 2782
      if (tmp___1) {
#line 2783
        goto again;
      }
#line 2784
      return (-2000);
    }
#line 2788
    if (cur_ring_idx == 127) {
#line 2788
      cur_ring_idx = 0;
    } else {
#line 2788
      cur_ring_idx ++;
    }
#line 2792
    if ((int )cur_char_ring[cur_ring_idx] == 0) {
#line 2794
      work_ring_idx = cur_ring_idx;
#line 2798
      idx___3 = 0;
      {
#line 2798
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2798
        if (! ((unsigned long )(lexptr___1 + idx___3) < (unsigned long )lexend___0)) {
#line 2798
          goto while_break;
        }
        {
#line 2799
        tmp_state = cur_mbstate;
#line 2800
        mbclen = mbrlen((char const   */* __restrict  */)lexptr___1, (size_t )(idx___3 + 1),
                        (mbstate_t */* __restrict  */)(& tmp_state));
        }
#line 2802
        if (mbclen == 1UL) {
#line 2806
          cur_char_ring[work_ring_idx] = (char)1;
#line 2807
          goto while_break;
        } else
#line 2802
        if (mbclen == 0xffffffffffffffffUL) {
#line 2806
          cur_char_ring[work_ring_idx] = (char)1;
#line 2807
          goto while_break;
        } else
#line 2802
        if (mbclen == 0UL) {
#line 2806
          cur_char_ring[work_ring_idx] = (char)1;
#line 2807
          goto while_break;
        } else
#line 2808
        if (mbclen == 0xfffffffffffffffeUL) {
#line 2810
          cur_char_ring[work_ring_idx] = (char )(idx___3 + 1);
        } else {
#line 2813
          cur_char_ring[work_ring_idx] = (char )mbclen;
#line 2814
          goto while_break;
        }
#line 2816
        if (work_ring_idx == 127) {
#line 2816
          work_ring_idx = 0;
        } else {
#line 2816
          work_ring_idx ++;
        }
#line 2798
        idx___3 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2819
      cur_mbstate = tmp_state;
#line 2822
      if (work_ring_idx == 127) {
#line 2822
        work_ring_idx = 0;
      } else {
#line 2822
        work_ring_idx ++;
      }
#line 2824
      cur_char_ring[work_ring_idx] = (char)0;
    }
#line 2827
    tmp___2 = lexptr___1;
#line 2827
    lexptr___1 ++;
#line 2827
    return ((int )((unsigned char )*tmp___2));
  } else {
    {
#line 2829
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2830
      if (lexeof) {
#line 2831
        return (-1000);
      }
#line 2832
      if (lexptr___1) {
#line 2832
        if ((unsigned long )lexptr___1 < (unsigned long )lexend___0) {
#line 2833
          tmp___3 = lexptr___1;
#line 2833
          lexptr___1 ++;
#line 2833
          return ((int )((unsigned char )*tmp___3));
        }
      }
      {
#line 2829
      tmp___4 = get_src_buf();
      }
#line 2829
      if (! tmp___4) {
#line 2829
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2835
    return (-2000);
  }
}
}
#line 2857 "awkgram.y"
__inline static void pushback(void) 
{ 


  {
#line 2861
  if (gawk_mb_cur_max > 1) {
#line 2862
    if (cur_ring_idx == 0) {
#line 2862
      cur_ring_idx = 127;
    } else {
#line 2862
      cur_ring_idx --;
    }
  }
#line 2865
  if (! lexeof) {
#line 2865
    if (lexptr___1) {
#line 2865
      if ((unsigned long )lexptr___1 > (unsigned long )lexptr_begin___0) {
#line 2865
        lexptr___1 --;
      }
    }
  }
#line 2866
  return;
}
}
#line 2871 "awkgram.y"
static void allow_newline(void) 
{ 
  int c ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 2876
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2877
    c = nextc();
    }
#line 2878
    if (c == -1000) {
      {
#line 2879
      pushback();
      }
#line 2880
      goto while_break;
    }
#line 2882
    if (c == 35) {
      {
#line 2883
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2883
        c = nextc();
        }
#line 2883
        if (c != 10) {
#line 2883
          if (! (c != -1000)) {
#line 2883
            goto while_break___0;
          }
        } else {
#line 2883
          goto while_break___0;
        }
#line 2884
        goto while_continue___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2885
      if (c == -1000) {
        {
#line 2886
        pushback();
        }
#line 2887
        goto while_break;
      }
    }
#line 2890
    if (c == 10) {
#line 2891
      sourceline ++;
    }
    {
#line 2892
    tmp___1 = __ctype_b_loc();
    }
#line 2892
    if (! ((int const   )*(*tmp___1 + c) & 8192)) {
      {
#line 2893
      pushback();
      }
#line 2894
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2897
  return;
}
}
#line 2907 "awkgram.y"
static int newline_eof(void) 
{ 
  char *tmp___1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 2910
  if (lasttok___0 != 306) {
    {
#line 2911
    pushback();
    }
#line 2912
    if (do_flags & 3) {
#line 2912
      if (! eof_warned) {
        {
#line 2913
        set_loc("awkgram.y", 2913);
#line 2913
        tmp___1 = gettext("source file does not end in newline");
#line 2913
        (*lintfunc)((char const   *)tmp___1);
#line 2914
        eof_warned = (_Bool)1;
        }
      }
    }
#line 2916
    sourceline ++;
#line 2917
    return (306);
  }
#line 2920
  sourceline --;
#line 2921
  eof_warned = (_Bool)0;
#line 2922
  return (302);
}
}
#line 2936 "awkgram.y"
static _Bool did_newline  =    (_Bool)0;
#line 3187 "awkgram.y"
static _Bool did_warn_op  =    (_Bool)0;
#line 3187 "awkgram.y"
static _Bool did_warn_assgn  =    (_Bool)0;
#line 3236 "awkgram.y"
static _Bool did_warn_op___0  =    (_Bool)0;
#line 3236 "awkgram.y"
static _Bool did_warn_assgn___0  =    (_Bool)0;
#line 3617 "awkgram.y"
static int warntab[69UL]  ;
#line 3720 "awkgram.y"
static _Bool goto_warned  =    (_Bool)0;
#line 2927 "awkgram.y"
static int yylex(void) 
{ 
  int c ;
  _Bool seen_e ;
  _Bool seen_point ;
  _Bool esc_seen ;
  int mid ;
  int base ;
  char *tokkey ;
  _Bool inhex ;
  _Bool intlstr ;
  double d ;
  int in_brack ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int peek ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  unsigned short const   **tmp___29 ;
  _Bool gotnumber ;
  char *tmp___30 ;
  int peek___0 ;
  int tmp___31 ;
  unsigned short const   **tmp___32 ;
  int c2 ;
  int tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  unsigned short const   **tmp___36 ;
  unsigned short const   **tmp___37 ;
  char *tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  NODE *r ;
  size_t tmp___41 ;
  int *tmp___42 ;
  int tval ;
  int *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  size_t tmp___46 ;
  char *tmp___47 ;
  unsigned short const   **tmp___48 ;
  char *tmp___49 ;
  unsigned short const   **tmp___50 ;
  char *tmp___51 ;
  int class ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;
  void *tmp___56 ;
  int *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  int tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  int tmp___64 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;

  {
#line 2931
  seen_e = (_Bool)0;
#line 2932
  seen_point = (_Bool)0;
#line 2938
  inhex = (_Bool)0;
#line 2939
  intlstr = (_Bool)0;
#line 2946
  yylval = (INSTRUCTION *)((void *)0);
#line 2947
  if (lasttok___0 == 271) {
#line 2948
    lasttok___0 = 0;
#line 2949
    return (271);
  }
#line 2952
  if (lasttok___0 == 302) {
#line 2953
    return (0);
  }
  {
#line 2955
  c = nextc();
  }
#line 2956
  if (c == -2000) {
#line 2957
    return (0);
  }
#line 2958
  if (c == -1000) {
    {
#line 2959
    lasttok___0 = newline_eof();
    }
#line 2959
    return (lasttok___0);
  }
  {
#line 2960
  pushback();
#line 2973
  lexeme = lexptr___1;
#line 2974
  thisline = (char *)((void *)0);
  }
#line 2975
  if (want_regexp) {
#line 2976
    in_brack = 0;
#line 2994
    want_regexp = (_Bool)0;
#line 2995
    tok___0 = tokstart;
    {
#line 2996
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2997
      c = nextc();
      }
#line 2999
      if (gawk_mb_cur_max == 1) {
#line 2999
        goto _L___0;
      } else
#line 2999
      if ((int )cur_char_ring[cur_ring_idx] == 1) {
        _L___0: /* CIL Label */ 
        {
#line 3000
        if (c == 91) {
#line 3000
          goto case_91;
        }
#line 3006
        if (c == 93) {
#line 3006
          goto case_93;
        }
#line 3015
        if (c == 92) {
#line 3015
          goto case_92;
        }
#line 3029
        if (c == 47) {
#line 3029
          goto case_47;
        }
#line 3051
        if (c == 10) {
#line 3051
          goto case_10;
        }
#line 3055
        if (c == -1000) {
#line 3055
          goto case_neg_1000;
        }
#line 2999
        goto switch_break;
        case_91: /* CIL Label */ 
        {
#line 3002
        tmp___1 = nextc();
        }
#line 3002
        if (tmp___1 == 58) {
#line 3003
          in_brack ++;
        } else
#line 3002
        if (in_brack == 0) {
#line 3003
          in_brack ++;
        }
        {
#line 3004
        pushback();
        }
#line 3005
        goto switch_break;
        case_93: /* CIL Label */ 
#line 3007
        if ((int )*(tokstart + 0) == 91) {
#line 3007
          if (! ((unsigned long )tok___0 == (unsigned long )(tokstart + 1))) {
#line 3007
            if ((unsigned long )tok___0 == (unsigned long )(tokstart + 2)) {
#line 3007
              if (! ((int )*(tokstart + 1) == 94)) {
#line 3013
                in_brack --;
              }
            } else {
#line 3013
              in_brack --;
            }
          }
        } else {
#line 3013
          in_brack --;
        }
#line 3014
        goto switch_break;
        case_92: /* CIL Label */ 
        {
#line 3016
        c = nextc();
        }
#line 3016
        if (c == -1000) {
          {
#line 3017
          pushback();
#line 3018
          tmp___2 = gettext("unterminated regexp ends with `\\\' at end of file");
#line 3018
          yyerror((char const   *)tmp___2);
          }
#line 3019
          goto end_regexp;
        } else
#line 3020
        if (c == 10) {
#line 3021
          sourceline ++;
#line 3022
          goto __Cont;
        } else {
#line 3024
          tmp___3 = tok___0;
#line 3024
          tok___0 ++;
#line 3024
          *tmp___3 = (char )'\\';
#line 3024
          if ((unsigned long )tok___0 == (unsigned long )tokend) {
            {
#line 3024
            tokexpand();
            }
          }
#line 3025
          tmp___4 = tok___0;
#line 3025
          tok___0 ++;
#line 3025
          *tmp___4 = (char )c;
#line 3025
          if ((unsigned long )tok___0 == (unsigned long )tokend) {
            {
#line 3025
            tokexpand();
            }
          }
#line 3026
          goto __Cont;
        }
#line 3028
        goto switch_break;
        case_47: /* CIL Label */ 
#line 3030
        if (in_brack > 0) {
#line 3031
          goto switch_break;
        }
        end_regexp: 
        {
#line 3033
        yylval = bcalloc((OPCODE )103, 1, sourceline);
#line 3034
        yylval->d.name = estrdup((char const   *)tokstart, (size_t )(tok___0 - tokstart));
        }
#line 3035
        if (do_flags & 3) {
          {
#line 3036
          tmp___5 = nextc();
#line 3036
          peek = tmp___5;
#line 3038
          pushback();
          }
#line 3039
          if (peek == 105) {
#line 3039
            goto _L;
          } else
#line 3039
          if (peek == 115) {
            _L: /* CIL Label */ 
#line 3040
            if (source) {
              {
#line 3041
              set_loc("awkgram.y", 3041);
#line 3041
              tmp___6 = gettext("%s: %d: tawk regex modifier `/.../%c\' doesn\'t work in gawk");
#line 3041
              (*lintfunc)((char const   *)tmp___6, source, sourceline, peek);
              }
            } else {
              {
#line 3045
              set_loc("awkgram.y", 3045);
#line 3045
              tmp___7 = gettext("tawk regex modifier `/.../%c\' doesn\'t work in gawk");
#line 3045
              (*lintfunc)((char const   *)tmp___7, peek);
              }
            }
          }
        }
#line 3050
        lasttok___0 = 260;
#line 3050
        return (lasttok___0);
        case_10: /* CIL Label */ 
        {
#line 3052
        pushback();
#line 3053
        tmp___8 = gettext("unterminated regexp");
#line 3053
        yyerror((char const   *)tmp___8);
        }
#line 3054
        goto end_regexp;
        case_neg_1000: /* CIL Label */ 
        {
#line 3056
        pushback();
#line 3057
        tmp___9 = gettext("unterminated regexp at end of file");
#line 3057
        yyerror((char const   *)tmp___9);
        }
#line 3058
        goto end_regexp;
        switch_break: /* CIL Label */ ;
        }
      }
#line 3060
      tmp___10 = tok___0;
#line 3060
      tok___0 ++;
#line 3060
      *tmp___10 = (char )c;
#line 3060
      if ((unsigned long )tok___0 == (unsigned long )tokend) {
        {
#line 3060
        tokexpand();
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  retry: 
  {
#line 3066
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3066
    c = nextc();
    }
#line 3066
    if (! (c == 32)) {
#line 3066
      if (! (c == 9)) {
#line 3066
        if (! (c == 13)) {
#line 3066
          goto while_break___0;
        }
      }
    }
#line 3067
    goto while_continue___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3069
  if (lexptr___1) {
#line 3069
    lexeme = lexptr___1 - 1;
  } else {
#line 3069
    lexeme = lexptr___1;
  }
#line 3070
  thisline = (char *)((void *)0);
#line 3071
  tok___0 = tokstart;
#line 3074
  if (gawk_mb_cur_max == 1) {
#line 3074
    goto _L___5;
  } else
#line 3074
  if ((int )cur_char_ring[cur_ring_idx] == 1) {
    _L___5: /* CIL Label */ 
    {
#line 3077
    if (c == -2000) {
#line 3077
      goto case_neg_2000;
    }
#line 3080
    if (c == -1000) {
#line 3080
      goto case_neg_1000___0;
    }
#line 3083
    if (c == 10) {
#line 3083
      goto case_10___0;
    }
#line 3087
    if (c == 35) {
#line 3087
      goto case_35;
    }
#line 3095
    if (c == 64) {
#line 3095
      goto case_64;
    }
#line 3098
    if (c == 92) {
#line 3098
      goto case_92___0;
    }
#line 3138
    if (c == 63) {
#line 3138
      goto case_63;
    }
#line 3138
    if (c == 58) {
#line 3138
      goto case_63;
    }
#line 3148
    if (c == 41) {
#line 3148
      goto case_41;
    }
#line 3152
    if (c == 40) {
#line 3152
      goto case_40;
    }
#line 3155
    if (c == 36) {
#line 3155
      goto case_36;
    }
#line 3158
    if (c == 123) {
#line 3158
      goto case_123;
    }
#line 3163
    if (c == 91) {
#line 3163
      goto case_91___0;
    }
#line 3163
    if (c == 44) {
#line 3163
      goto case_91___0;
    }
#line 3163
    if (c == 59) {
#line 3163
      goto case_91___0;
    }
#line 3165
    if (c == 93) {
#line 3165
      goto case_93___0;
    }
#line 3177
    if (c == 42) {
#line 3177
      goto case_42;
    }
#line 3216
    if (c == 47) {
#line 3216
      goto case_47___0;
    }
#line 3225
    if (c == 37) {
#line 3225
      goto case_37;
    }
#line 3234
    if (c == 94) {
#line 3234
      goto case_94;
    }
#line 3255
    if (c == 43) {
#line 3255
      goto case_43;
    }
#line 3268
    if (c == 33) {
#line 3268
      goto case_33;
    }
#line 3281
    if (c == 60) {
#line 3281
      goto case_60;
    }
#line 3290
    if (c == 61) {
#line 3290
      goto case_61;
    }
#line 3299
    if (c == 62) {
#line 3299
      goto case_62;
    }
#line 3317
    if (c == 126) {
#line 3317
      goto case_126;
    }
#line 3321
    if (c == 125) {
#line 3321
      goto case_125;
    }
#line 3336
    if (c == 34) {
#line 3336
      goto string;
    }
#line 3380
    if (c == 45) {
#line 3380
      goto case_45;
    }
#line 3393
    if (c == 46) {
#line 3393
      goto case_46;
    }
#line 3410
    if (c == 57) {
#line 3410
      goto case_57;
    }
#line 3410
    if (c == 56) {
#line 3410
      goto case_57;
    }
#line 3410
    if (c == 55) {
#line 3410
      goto case_57;
    }
#line 3410
    if (c == 54) {
#line 3410
      goto case_57;
    }
#line 3410
    if (c == 53) {
#line 3410
      goto case_57;
    }
#line 3410
    if (c == 52) {
#line 3410
      goto case_57;
    }
#line 3410
    if (c == 51) {
#line 3410
      goto case_57;
    }
#line 3410
    if (c == 50) {
#line 3410
      goto case_57;
    }
#line 3410
    if (c == 49) {
#line 3410
      goto case_57;
    }
#line 3410
    if (c == 48) {
#line 3410
      goto case_57;
    }
#line 3546
    if (c == 38) {
#line 3546
      goto case_38;
    }
#line 3556
    if (c == 124) {
#line 3556
      goto case_124;
    }
#line 3076
    goto switch_break___0;
    case_neg_2000: /* CIL Label */ 
#line 3078
    return (0);
    case_neg_1000___0: /* CIL Label */ 
    {
#line 3081
    lasttok___0 = newline_eof();
    }
#line 3081
    return (lasttok___0);
    case_10___0: /* CIL Label */ 
#line 3084
    sourceline ++;
#line 3085
    lasttok___0 = 306;
#line 3085
    return (lasttok___0);
    case_35: /* CIL Label */ 
    {
#line 3088
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 3088
      c = nextc();
      }
#line 3088
      if (! (c != 10)) {
#line 3088
        goto while_break___1;
      }
#line 3089
      if (c == -1000) {
        {
#line 3090
        lasttok___0 = newline_eof();
        }
#line 3090
        return (lasttok___0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3092
    sourceline ++;
#line 3093
    lasttok___0 = 306;
#line 3093
    return (lasttok___0);
    case_64: /* CIL Label */ 
#line 3096
    lasttok___0 = '@';
#line 3096
    return (lasttok___0);
    case_92___0: /* CIL Label */ 
    {
#line 3125
    c = nextc();
    }
#line 3126
    if (c == 13) {
      {
#line 3127
      c = nextc();
      }
    }
#line 3128
    if (c == 10) {
#line 3129
      sourceline ++;
#line 3130
      goto retry;
    } else {
      {
#line 3132
      tmp___11 = gettext("backslash not last character on line");
#line 3132
      yyerror((char const   *)tmp___11);
#line 3133
      lasttok___0 = 302;
      }
#line 3133
      return (lasttok___0);
    }
#line 3135
    goto switch_break___0;
    case_63: /* CIL Label */ 
    case_58: /* CIL Label */ 
    {
#line 3139
    yylval = bcalloc((OPCODE )114, 1, sourceline);
    }
#line 3140
    if (! (do_flags & 16)) {
      {
#line 3141
      allow_newline();
      }
    }
#line 3142
    lasttok___0 = c;
#line 3142
    return (lasttok___0);
    case_41: /* CIL Label */ 
#line 3149
    in_parens --;
#line 3150
    lasttok___0 = c;
#line 3150
    return (lasttok___0);
    case_40: /* CIL Label */ 
#line 3153
    in_parens ++;
#line 3154
    lasttok___0 = c;
#line 3154
    return (lasttok___0);
    case_36: /* CIL Label */ 
    {
#line 3156
    yylval = bcalloc((OPCODE )23, 1, sourceline);
#line 3157
    lasttok___0 = c;
    }
#line 3157
    return (lasttok___0);
    case_123: /* CIL Label */ 
#line 3159
    in_braces ++;
#line 3159
    if (in_braces == 1) {
#line 3160
      firstline = sourceline;
    }
    case_91___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_59: /* CIL Label */ 
#line 3164
    lasttok___0 = c;
#line 3164
    return (lasttok___0);
    case_93___0: /* CIL Label */ 
    {
#line 3166
    c = nextc();
#line 3167
    pushback();
    }
#line 3168
    if (c == 91) {
      {
#line 3169
      yylval = bcalloc((OPCODE )17, 1, sourceline);
#line 3170
      lasttok___0 = ']';
      }
    } else {
      {
#line 3172
      yylval = bcalloc((OPCODE )16, 1, sourceline);
#line 3173
      lasttok___0 = 271;
      }
    }
#line 3175
    return (']');
    case_42: /* CIL Label */ 
    {
#line 3178
    c = nextc();
    }
#line 3178
    if (c == 61) {
      {
#line 3179
      yylval = bcalloc((OPCODE )29, 1, sourceline);
#line 3180
      lasttok___0 = 267;
      }
#line 3180
      return (lasttok___0);
    } else
#line 3181
    if (do_flags & 16) {
      {
#line 3182
      pushback();
#line 3183
      yylval = bcalloc((OPCODE )1, 1, sourceline);
#line 3184
      lasttok___0 = '*';
      }
#line 3184
      return (lasttok___0);
    } else
#line 3185
    if (c == 42) {
      {
#line 3189
      tmp___16 = nextc();
      }
#line 3189
      if (tmp___16 == 61) {
#line 3190
        if (! did_warn_assgn) {
#line 3191
          did_warn_assgn = (_Bool)1;
#line 3192
          if (do_flags & 3) {
            {
#line 3193
            set_loc("awkgram.y", 3193);
#line 3193
            tmp___12 = gettext("POSIX does not allow operator `**=\'");
#line 3193
            (*lintfunc)((char const   *)tmp___12);
            }
          }
#line 3194
          if (do_flags & 4) {
            {
#line 3195
            tmp___13 = gettext("old awk does not support operator `**=\'");
#line 3195
            warning((char const   *)tmp___13);
            }
          }
        }
        {
#line 3197
        yylval = bcalloc((OPCODE )34, 1, sourceline);
        }
#line 3198
        return (267);
      } else {
        {
#line 3200
        pushback();
        }
#line 3201
        if (! did_warn_op) {
#line 3202
          did_warn_op = (_Bool)1;
#line 3203
          if (do_flags & 3) {
            {
#line 3204
            set_loc("awkgram.y", 3204);
#line 3204
            tmp___14 = gettext("POSIX does not allow operator `**\'");
#line 3204
            (*lintfunc)((char const   *)tmp___14);
            }
          }
#line 3205
          if (do_flags & 4) {
            {
#line 3206
            tmp___15 = gettext("old awk does not support operator `**\'");
#line 3206
            warning((char const   *)tmp___15);
            }
          }
        }
        {
#line 3208
        yylval = bcalloc((OPCODE )11, 1, sourceline);
#line 3209
        lasttok___0 = '^';
        }
#line 3209
        return (lasttok___0);
      }
    }
    {
#line 3212
    pushback();
#line 3213
    yylval = bcalloc((OPCODE )1, 1, sourceline);
#line 3214
    lasttok___0 = '*';
    }
#line 3214
    return (lasttok___0);
    case_47___0: /* CIL Label */ 
    {
#line 3217
    tmp___17 = nextc();
    }
#line 3217
    if (tmp___17 == 61) {
      {
#line 3218
      pushback();
#line 3219
      lasttok___0 = 307;
      }
#line 3219
      return (lasttok___0);
    }
    {
#line 3221
    pushback();
#line 3222
    yylval = bcalloc((OPCODE )3, 1, sourceline);
#line 3223
    lasttok___0 = '/';
    }
#line 3223
    return (lasttok___0);
    case_37: /* CIL Label */ 
    {
#line 3226
    tmp___18 = nextc();
    }
#line 3226
    if (tmp___18 == 61) {
      {
#line 3227
      yylval = bcalloc((OPCODE )31, 1, sourceline);
#line 3228
      lasttok___0 = 267;
      }
#line 3228
      return (lasttok___0);
    }
    {
#line 3230
    pushback();
#line 3231
    yylval = bcalloc((OPCODE )5, 1, sourceline);
#line 3232
    lasttok___0 = '%';
    }
#line 3232
    return (lasttok___0);
    case_94: /* CIL Label */ 
    {
#line 3238
    tmp___20 = nextc();
    }
#line 3238
    if (tmp___20 == 61) {
#line 3239
      if (do_flags & 4) {
#line 3239
        if (! did_warn_assgn___0) {
          {
#line 3240
          did_warn_assgn___0 = (_Bool)1;
#line 3241
          tmp___19 = gettext("operator `^=\' is not supported in old awk");
#line 3241
          warning((char const   *)tmp___19);
          }
        }
      }
      {
#line 3243
      yylval = bcalloc((OPCODE )34, 1, sourceline);
#line 3244
      lasttok___0 = 267;
      }
#line 3244
      return (lasttok___0);
    }
    {
#line 3246
    pushback();
    }
#line 3247
    if (do_flags & 4) {
#line 3247
      if (! did_warn_op___0) {
        {
#line 3248
        did_warn_op___0 = (_Bool)1;
#line 3249
        tmp___21 = gettext("operator `^\' is not supported in old awk");
#line 3249
        warning((char const   *)tmp___21);
        }
      }
    }
    {
#line 3251
    yylval = bcalloc((OPCODE )11, 1, sourceline);
#line 3252
    lasttok___0 = '^';
    }
#line 3252
    return (lasttok___0);
    case_43: /* CIL Label */ 
    {
#line 3256
    c = nextc();
    }
#line 3256
    if (c == 61) {
      {
#line 3257
      yylval = bcalloc((OPCODE )32, 1, sourceline);
#line 3258
      lasttok___0 = 267;
      }
#line 3258
      return (lasttok___0);
    }
#line 3260
    if (c == 43) {
      {
#line 3261
      yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3262
      lasttok___0 = 298;
      }
#line 3262
      return (lasttok___0);
    }
    {
#line 3264
    pushback();
#line 3265
    yylval = bcalloc((OPCODE )7, 1, sourceline);
#line 3266
    lasttok___0 = '+';
    }
#line 3266
    return (lasttok___0);
    case_33: /* CIL Label */ 
    {
#line 3269
    c = nextc();
    }
#line 3269
    if (c == 61) {
      {
#line 3270
      yylval = bcalloc((OPCODE )41, 1, sourceline);
#line 3271
      lasttok___0 = 264;
      }
#line 3271
      return (lasttok___0);
    }
#line 3273
    if (c == 126) {
      {
#line 3274
      yylval = bcalloc((OPCODE )48, 1, sourceline);
#line 3275
      lasttok___0 = 269;
      }
#line 3275
      return (lasttok___0);
    }
    {
#line 3277
    pushback();
#line 3278
    yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3279
    lasttok___0 = '!';
    }
#line 3279
    return (lasttok___0);
    case_60: /* CIL Label */ 
    {
#line 3282
    tmp___22 = nextc();
    }
#line 3282
    if (tmp___22 == 61) {
      {
#line 3283
      yylval = bcalloc((OPCODE )44, 1, sourceline);
#line 3284
      lasttok___0 = 264;
      }
#line 3284
      return (lasttok___0);
    }
    {
#line 3286
    yylval = bcalloc((OPCODE )42, 1, sourceline);
#line 3287
    pushback();
#line 3288
    lasttok___0 = '<';
    }
#line 3288
    return (lasttok___0);
    case_61: /* CIL Label */ 
    {
#line 3291
    tmp___23 = nextc();
    }
#line 3291
    if (tmp___23 == 61) {
      {
#line 3292
      yylval = bcalloc((OPCODE )40, 1, sourceline);
#line 3293
      lasttok___0 = 264;
      }
#line 3293
      return (lasttok___0);
    }
    {
#line 3295
    yylval = bcalloc((OPCODE )25, 1, sourceline);
#line 3296
    pushback();
#line 3297
    lasttok___0 = 268;
    }
#line 3297
    return (lasttok___0);
    case_62: /* CIL Label */ 
    {
#line 3300
    c = nextc();
    }
#line 3300
    if (c == 61) {
      {
#line 3301
      yylval = bcalloc((OPCODE )45, 1, sourceline);
#line 3302
      lasttok___0 = 264;
      }
#line 3302
      return (lasttok___0);
    } else
#line 3303
    if (c == 62) {
      {
#line 3304
      yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3305
      yylval->d.dl = 2L;
#line 3306
      lasttok___0 = 265;
      }
#line 3306
      return (lasttok___0);
    }
    {
#line 3308
    pushback();
    }
#line 3309
    if (in_print) {
#line 3309
      if (in_parens == 0) {
        {
#line 3310
        yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3311
        yylval->d.dl = 1L;
#line 3312
        lasttok___0 = 265;
        }
#line 3312
        return (lasttok___0);
      }
    }
    {
#line 3314
    yylval = bcalloc((OPCODE )43, 1, sourceline);
#line 3315
    lasttok___0 = '>';
    }
#line 3315
    return (lasttok___0);
    case_126: /* CIL Label */ 
    {
#line 3318
    yylval = bcalloc((OPCODE )46, 1, sourceline);
#line 3319
    lasttok___0 = 269;
    }
#line 3319
    return (lasttok___0);
    case_125: /* CIL Label */ 
#line 3326
    if (did_newline) {
#line 3327
      did_newline = (_Bool)0;
#line 3328
      in_braces --;
#line 3328
      if (in_braces == 0) {
#line 3329
        lastline = sourceline;
      }
#line 3330
      lasttok___0 = c;
#line 3330
      return (lasttok___0);
    }
#line 3332
    did_newline = (_Bool )((int )did_newline + 1);
#line 3333
    lexptr___1 --;
#line 3334
    lasttok___0 = 306;
#line 3334
    return (lasttok___0);
    string: 
    case_34: /* CIL Label */ 
#line 3338
    esc_seen = (_Bool)0;
    {
#line 3339
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 3339
      c = nextc();
      }
#line 3339
      if (! (c != 34)) {
#line 3339
        goto while_break___2;
      }
#line 3340
      if (c == 10) {
        {
#line 3341
        pushback();
#line 3342
        tmp___24 = gettext("unterminated string");
#line 3342
        yyerror((char const   *)tmp___24);
#line 3343
        lasttok___0 = 302;
        }
#line 3343
        return (lasttok___0);
      }
#line 3345
      if (gawk_mb_cur_max == 1) {
#line 3345
        goto _L___2;
      } else
#line 3345
      if ((int )cur_char_ring[cur_ring_idx] == 1) {
        _L___2: /* CIL Label */ 
#line 3345
        if (c == 92) {
          {
#line 3347
          c = nextc();
          }
#line 3348
          if (c == 10) {
#line 3349
            sourceline ++;
#line 3350
            goto while_continue___2;
          }
#line 3352
          esc_seen = (_Bool)1;
#line 3353
          if (! want_source) {
#line 3353
            goto _L___1;
          } else
#line 3353
          if (c != 34) {
            _L___1: /* CIL Label */ 
#line 3354
            tmp___25 = tok___0;
#line 3354
            tok___0 ++;
#line 3354
            *tmp___25 = (char )'\\';
#line 3354
            if ((unsigned long )tok___0 == (unsigned long )tokend) {
              {
#line 3354
              tokexpand();
              }
            }
          }
        }
      }
#line 3356
      if (c == -1000) {
        {
#line 3357
        pushback();
#line 3358
        tmp___26 = gettext("unterminated string");
#line 3358
        yyerror((char const   *)tmp___26);
#line 3359
        lasttok___0 = 302;
        }
#line 3359
        return (lasttok___0);
      }
#line 3361
      tmp___27 = tok___0;
#line 3361
      tok___0 ++;
#line 3361
      *tmp___27 = (char )c;
#line 3361
      if ((unsigned long )tok___0 == (unsigned long )tokend) {
        {
#line 3361
        tokexpand();
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3363
    yylval = bcalloc((OPCODE )103, 1, sourceline);
    }
#line 3364
    if (want_source) {
      {
#line 3365
      yylval->d.name = estrdup((char const   *)tokstart, (size_t )(tok___0 - tokstart));
#line 3366
      lasttok___0 = 261;
      }
#line 3366
      return (lasttok___0);
    }
#line 3369
    yylval->opcode = (OPCODE )74;
#line 3370
    if (esc_seen) {
#line 3370
      tmp___28 = 1;
    } else {
#line 3370
      tmp___28 = 0;
    }
    {
#line 3370
    yylval->d.dn = make_str_node((char const   *)tokstart, (size_t )(tok___0 - tokstart),
                                 tmp___28);
    }
#line 3372
    if (intlstr) {
#line 3373
      (yylval->d.dn)->flags |= 128U;
#line 3374
      intlstr = (_Bool)0;
#line 3375
      if (do_flags & 32) {
        {
#line 3376
        dumpintlstr((char const   *)(yylval->d.dn)->sub.val.sp, (yylval->d.dn)->sub.val.slen);
        }
      }
    }
#line 3378
    lasttok___0 = 263;
#line 3378
    return (lasttok___0);
    case_45: /* CIL Label */ 
    {
#line 3381
    c = nextc();
    }
#line 3381
    if (c == 61) {
      {
#line 3382
      yylval = bcalloc((OPCODE )33, 1, sourceline);
#line 3383
      lasttok___0 = 267;
      }
#line 3383
      return (lasttok___0);
    }
#line 3385
    if (c == 45) {
      {
#line 3386
      yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3387
      lasttok___0 = 299;
      }
#line 3387
      return (lasttok___0);
    }
    {
#line 3389
    pushback();
#line 3390
    yylval = bcalloc((OPCODE )9, 1, sourceline);
#line 3391
    lasttok___0 = '-';
    }
#line 3391
    return (lasttok___0);
    case_46: /* CIL Label */ 
    {
#line 3394
    c = nextc();
#line 3395
    pushback();
#line 3396
    tmp___29 = __ctype_b_loc();
    }
#line 3396
    if ((int const   )*(*tmp___29 + c) & 2048) {
#line 3399
      c = '.';
    } else {
#line 3397
      lasttok___0 = '.';
#line 3397
      return (lasttok___0);
    }
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    {
#line 3412
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3413
      gotnumber = (_Bool)0;
#line 3415
      tmp___30 = tok___0;
#line 3415
      tok___0 ++;
#line 3415
      *tmp___30 = (char )c;
#line 3415
      if ((unsigned long )tok___0 == (unsigned long )tokend) {
        {
#line 3415
        tokexpand();
        }
      }
      {
#line 3418
      if (c == 88) {
#line 3418
        goto case_88;
      }
#line 3418
      if (c == 120) {
#line 3418
        goto case_88;
      }
#line 3433
      if (c == 46) {
#line 3433
        goto case_46___0;
      }
#line 3442
      if (c == 69) {
#line 3442
        goto case_69;
      }
#line 3442
      if (c == 101) {
#line 3442
        goto case_69;
      }
#line 3477
      if (c == 70) {
#line 3477
        goto case_70;
      }
#line 3477
      if (c == 102) {
#line 3477
        goto case_70;
      }
#line 3477
      if (c == 100) {
#line 3477
        goto case_70;
      }
#line 3477
      if (c == 68) {
#line 3477
        goto case_70;
      }
#line 3477
      if (c == 67) {
#line 3477
        goto case_70;
      }
#line 3477
      if (c == 99) {
#line 3477
        goto case_70;
      }
#line 3477
      if (c == 66) {
#line 3477
        goto case_70;
      }
#line 3477
      if (c == 98) {
#line 3477
        goto case_70;
      }
#line 3477
      if (c == 65) {
#line 3477
        goto case_70;
      }
#line 3477
      if (c == 97) {
#line 3477
        goto case_70;
      }
#line 3490
      if (c == 57) {
#line 3490
        goto case_57___0;
      }
#line 3490
      if (c == 56) {
#line 3490
        goto case_57___0;
      }
#line 3490
      if (c == 55) {
#line 3490
        goto case_57___0;
      }
#line 3490
      if (c == 54) {
#line 3490
        goto case_57___0;
      }
#line 3490
      if (c == 53) {
#line 3490
        goto case_57___0;
      }
#line 3490
      if (c == 52) {
#line 3490
        goto case_57___0;
      }
#line 3490
      if (c == 51) {
#line 3490
        goto case_57___0;
      }
#line 3490
      if (c == 50) {
#line 3490
        goto case_57___0;
      }
#line 3490
      if (c == 49) {
#line 3490
        goto case_57___0;
      }
#line 3490
      if (c == 48) {
#line 3490
        goto case_57___0;
      }
#line 3492
      goto done;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
#line 3419
      if (do_flags & 8) {
#line 3420
        goto done;
      }
#line 3421
      if ((unsigned long )tok___0 == (unsigned long )(tokstart + 2)) {
        {
#line 3422
        tmp___31 = nextc();
#line 3422
        peek___0 = tmp___31;
#line 3424
        tmp___32 = __ctype_b_loc();
        }
#line 3424
        if ((int const   )*(*tmp___32 + peek___0) & 4096) {
          {
#line 3425
          inhex = (_Bool)1;
#line 3426
          pushback();
          }
        } else {
          {
#line 3428
          pushback();
          }
#line 3429
          goto done;
        }
      }
#line 3432
      goto switch_break___1;
      case_46___0: /* CIL Label */ 
#line 3435
      if (seen_point) {
#line 3436
        gotnumber = (_Bool)1;
#line 3437
        goto switch_break___1;
      } else
#line 3435
      if (seen_e) {
#line 3436
        gotnumber = (_Bool)1;
#line 3437
        goto switch_break___1;
      }
#line 3439
      seen_point = (_Bool)1;
#line 3440
      goto switch_break___1;
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
#line 3443
      if (inhex) {
#line 3444
        goto switch_break___1;
      }
#line 3445
      if (seen_e) {
#line 3446
        gotnumber = (_Bool)1;
#line 3447
        goto switch_break___1;
      }
      {
#line 3449
      seen_e = (_Bool)1;
#line 3450
      c = nextc();
      }
#line 3450
      if (c == 45) {
#line 3450
        goto _L___3;
      } else
#line 3450
      if (c == 43) {
        _L___3: /* CIL Label */ 
        {
#line 3451
        tmp___33 = nextc();
#line 3451
        c2 = tmp___33;
#line 3453
        tmp___36 = __ctype_b_loc();
        }
#line 3453
        if ((int const   )*(*tmp___36 + c2) & 2048) {
#line 3454
          tmp___34 = tok___0;
#line 3454
          tok___0 ++;
#line 3454
          *tmp___34 = (char )c;
#line 3454
          if ((unsigned long )tok___0 == (unsigned long )tokend) {
            {
#line 3454
            tokexpand();
            }
          }
#line 3455
          tmp___35 = tok___0;
#line 3455
          tok___0 ++;
#line 3455
          *tmp___35 = (char )c2;
#line 3455
          if ((unsigned long )tok___0 == (unsigned long )tokend) {
            {
#line 3455
            tokexpand();
            }
          }
        } else {
          {
#line 3457
          pushback();
#line 3458
          pushback();
#line 3459
          pushback();
          }
        }
      } else {
        {
#line 3461
        tmp___37 = __ctype_b_loc();
        }
#line 3461
        if ((int const   )*(*tmp___37 + c) & 2048) {
          {
#line 3465
          pushback();
          }
        } else {
          {
#line 3462
          pushback();
#line 3463
          pushback();
          }
        }
      }
#line 3467
      goto switch_break___1;
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_68: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_99: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 3478
      if (do_flags & 8) {
#line 3479
        goto done;
      } else
#line 3478
      if (! inhex) {
#line 3479
        goto done;
      }
      case_57___0: /* CIL Label */ 
      case_56___0: /* CIL Label */ 
      case_55___0: /* CIL Label */ 
      case_54___0: /* CIL Label */ 
      case_53___0: /* CIL Label */ 
      case_52___0: /* CIL Label */ 
      case_51___0: /* CIL Label */ 
      case_50___0: /* CIL Label */ 
      case_49___0: /* CIL Label */ 
      case_48___0: /* CIL Label */ 
#line 3491
      goto switch_break___1;
      done: 
      switch_default: /* CIL Label */ 
#line 3494
      gotnumber = (_Bool)1;
      switch_break___1: /* CIL Label */ ;
      }
#line 3496
      if (gotnumber) {
#line 3497
        goto while_break___3;
      }
      {
#line 3498
      c = nextc();
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3500
    pushback();
#line 3502
    tmp___38 = tok___0;
#line 3502
    tok___0 ++;
#line 3502
    *tmp___38 = (char )'\000';
    }
#line 3502
    if ((unsigned long )tok___0 == (unsigned long )tokend) {
      {
#line 3502
      tokexpand();
      }
    }
    {
#line 3503
    yylval = bcalloc((OPCODE )74, 1, sourceline);
#line 3505
    base = 10;
    }
#line 3506
    if (! (do_flags & 8)) {
      {
#line 3507
      base = get_numbase((char const   *)tokstart, (_Bool)0);
      }
#line 3508
      if (do_flags & 3) {
#line 3509
        if (base == 8) {
          {
#line 3510
          set_loc("awkgram.y", 3510);
#line 3510
          tmp___39 = strlen((char const   *)tokstart);
#line 3510
          (*lintfunc)("numeric constant `%.*s\' treated as octal", (int )tmp___39 - 1,
                      tokstart);
          }
        } else
#line 3512
        if (base == 16) {
          {
#line 3513
          set_loc("awkgram.y", 3513);
#line 3513
          tmp___40 = strlen((char const   *)tokstart);
#line 3513
          (*lintfunc)("numeric constant `%.*s\' treated as hexadecimal", (int )tmp___40 - 1,
                      tokstart);
          }
        }
      }
    }
#line 3519
    if (do_flags & 16384) {
#line 3522
      if (! seen_point) {
#line 3522
        if (! seen_e) {
          {
#line 3523
          r = mpg_node(4096U);
#line 3524
          tmp___41 = strlen((char const   *)tokstart);
#line 3524
          mpg_strtoui(r->sub.val.nm.mpi, tokstart, tmp___41, (char **)((void *)0),
                      base);
#line 3525
          tmp___42 = __errno_location();
#line 3525
          *tmp___42 = 0;
          }
        } else {
#line 3522
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        {
#line 3528
        r = mpg_node(2048U);
#line 3529
        tval = mpfr_strtofr(r->sub.val.nm.mpnum, (char const   *)tokstart, (char **)((void *)0),
                            base, ROUND_MODE);
#line 3530
        tmp___43 = __errno_location();
#line 3530
        *tmp___43 = 0;
        }
#line 3531
        if (do_ieee_fmt) {
          {
#line 3531
          tmp___44 = format_ieee(r->sub.val.nm.mpnum, tval);
          }
#line 3531
          if (tmp___44) {
#line 3531
            tmp___45 = 1;
          } else {
#line 3531
            tmp___45 = 0;
          }
        } else {
#line 3531
          tmp___45 = 0;
        }
      }
#line 3533
      yylval->d.dn = r;
#line 3534
      lasttok___0 = 262;
#line 3534
      return (lasttok___0);
    }
#line 3537
    if (base != 10) {
      {
#line 3538
      tmp___46 = strlen((char const   *)tokstart);
#line 3538
      d = nondec2awknum(tokstart, tmp___46);
      }
    } else {
      {
#line 3540
      d = atof((char const   *)tokstart);
      }
    }
    {
#line 3541
    yylval->d.dn = (*make_number)(d);
    }
#line 3542
    if (d <= (double )2147483647) {
#line 3542
      if (d >= (double )(-0x7FFFFFFF-1)) {
#line 3542
        if (d == (double )((int32_t )d)) {
#line 3543
          (yylval->d.dn)->flags |= 256U;
        }
      }
    }
#line 3544
    lasttok___0 = 262;
#line 3544
    return (lasttok___0);
    case_38: /* CIL Label */ 
    {
#line 3547
    c = nextc();
    }
#line 3547
    if (c == 38) {
      {
#line 3548
      yylval = bcalloc((OPCODE )36, 1, sourceline);
#line 3549
      allow_newline();
#line 3550
      lasttok___0 = 296;
      }
#line 3550
      return (lasttok___0);
    }
    {
#line 3552
    pushback();
#line 3553
    yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3554
    lasttok___0 = '&';
    }
#line 3554
    return (lasttok___0);
    case_124: /* CIL Label */ 
    {
#line 3557
    c = nextc();
    }
#line 3557
    if (c == 124) {
      {
#line 3558
      yylval = bcalloc((OPCODE )38, 1, sourceline);
#line 3559
      allow_newline();
#line 3560
      lasttok___0 = 297;
      }
#line 3560
      return (lasttok___0);
    } else
#line 3561
    if (! (do_flags & 8)) {
#line 3561
      if (c == 38) {
        {
#line 3562
        yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3563
        yylval->d.dl = 6L;
        }
#line 3564
        if (in_print) {
#line 3564
          if (in_parens == 0) {
#line 3564
            lasttok___0 = 265;
          } else {
#line 3564
            lasttok___0 = 266;
          }
        } else {
#line 3564
          lasttok___0 = 266;
        }
#line 3564
        return (lasttok___0);
      }
    }
    {
#line 3566
    pushback();
    }
#line 3567
    if (in_print) {
#line 3567
      if (in_parens == 0) {
        {
#line 3568
        yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3569
        yylval->d.dl = 3L;
#line 3570
        lasttok___0 = 265;
        }
#line 3570
        return (lasttok___0);
      } else {
        {
#line 3572
        yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3573
        yylval->d.dl = 4L;
#line 3574
        lasttok___0 = 266;
        }
#line 3574
        return (lasttok___0);
      }
    } else {
      {
#line 3572
      yylval = bcalloc((OPCODE )104, 1, sourceline);
#line 3573
      yylval->d.dl = 4L;
#line 3574
      lasttok___0 = 266;
      }
#line 3574
      return (lasttok___0);
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 3578
  if (c != 95) {
    {
#line 3578
    tmp___48 = __ctype_b_loc();
    }
#line 3578
    if (! ((int const   )*(*tmp___48 + c) & 1024)) {
      {
#line 3579
      tmp___47 = gettext("invalid char \'%c\' in expression");
#line 3579
      yyerror((char const   *)tmp___47, c);
#line 3580
      lasttok___0 = 302;
      }
#line 3580
      return (lasttok___0);
    }
  }
#line 3597
  if (! (do_flags & 8)) {
#line 3597
    if (c == 95) {
#line 3597
      if (lasttok___0 != 36) {
        {
#line 3598
        c = nextc();
        }
#line 3598
        if (c == 34) {
#line 3599
          intlstr = (_Bool)1;
#line 3600
          goto string;
        }
        {
#line 3602
        pushback();
#line 3603
        c = '_';
        }
      }
    }
  }
#line 3607
  tok___0 = tokstart;
  {
#line 3608
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3608
    if (c != -1000) {
      {
#line 3608
      tmp___50 = __ctype_b_loc();
      }
#line 3608
      if (! ((int const   )*(*tmp___50 + c) & 8)) {
#line 3608
        if (! (c == 95)) {
#line 3608
          goto while_break___4;
        }
      }
    } else {
#line 3608
      goto while_break___4;
    }
#line 3609
    tmp___49 = tok___0;
#line 3609
    tok___0 ++;
#line 3609
    *tmp___49 = (char )c;
#line 3609
    if ((unsigned long )tok___0 == (unsigned long )tokend) {
      {
#line 3609
      tokexpand();
      }
    }
    {
#line 3610
    c = nextc();
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3612
  tmp___51 = tok___0;
#line 3612
  tok___0 ++;
#line 3612
  *tmp___51 = (char )'\000';
#line 3612
  if ((unsigned long )tok___0 == (unsigned long )tokend) {
    {
#line 3612
    tokexpand();
    }
  }
  {
#line 3613
  pushback();
#line 3616
  mid = check_special((char const   *)tokstart);
  }
#line 3616
  if (mid >= 0) {
#line 3618
    class = (int )tokentab[mid].class;
#line 3620
    if (class == 303) {
#line 3620
      goto _L___6;
    } else
#line 3620
    if (class == 305) {
#line 3620
      goto _L___6;
    } else
#line 3620
    if (class == 304) {
      _L___6: /* CIL Label */ 
#line 3620
      if (lasttok___0 != 64) {
#line 3622
        goto out;
      }
    }
#line 3624
    if (do_flags & 3) {
#line 3625
      if ((tokentab[mid].flags & 1024U) != 0U) {
#line 3625
        if ((warntab[mid] & 1024) == 0) {
          {
#line 3626
          set_loc("awkgram.y", 3626);
#line 3626
          tmp___52 = gettext("`%s\' is a gawk extension");
#line 3626
          (*lintfunc)((char const   *)tmp___52, tokentab[mid].operator);
#line 3628
          warntab[mid] |= 1024;
          }
        }
      }
#line 3630
      if ((tokentab[mid].flags & 512U) != 0U) {
#line 3630
        if ((warntab[mid] & 512) == 0) {
          {
#line 3631
          set_loc("awkgram.y", 3631);
#line 3631
          tmp___53 = gettext("POSIX does not allow `%s\'");
#line 3631
          (*lintfunc)((char const   *)tmp___53, tokentab[mid].operator);
#line 3633
          warntab[mid] |= 512;
          }
        }
      }
    }
#line 3636
    if (do_flags & 4) {
#line 3636
      if ((tokentab[mid].flags & 256U) != 0U) {
#line 3636
        if ((warntab[mid] & 256) == 0) {
          {
#line 3639
          tmp___54 = gettext("`%s\' is not supported in old awk");
#line 3639
          warning((char const   *)tmp___54, tokentab[mid].operator);
#line 3641
          warntab[mid] |= 256;
          }
        }
      }
    }
#line 3644
    if ((tokentab[mid].flags & 2048U) != 0U) {
#line 3645
      break_allowed ++;
    }
#line 3646
    if ((tokentab[mid].flags & 4096U) != 0U) {
#line 3647
      continue_allowed ++;
    }
    {
#line 3651
    if (class == 305) {
#line 3651
      goto case_305;
    }
#line 3651
    if (class == 303) {
#line 3651
      goto case_305;
    }
#line 3654
    if (class == 304) {
#line 3654
      goto case_304;
    }
#line 3668
    if (class == 292) {
#line 3668
      goto case_292;
    }
#line 3668
    if (class == 291) {
#line 3668
      goto case_292;
    }
#line 3668
    if (class == 273) {
#line 3668
      goto case_292;
    }
#line 3668
    if (class == 272) {
#line 3668
      goto case_292;
    }
#line 3668
    if (class == 290) {
#line 3668
      goto case_292;
    }
#line 3675
    if (class == 278) {
#line 3675
      goto case_278;
    }
#line 3675
    if (class == 282) {
#line 3675
      goto case_278;
    }
#line 3675
    if (class == 281) {
#line 3675
      goto case_278;
    }
#line 3675
    if (class == 283) {
#line 3675
      goto case_278;
    }
#line 3679
    if (class == 279) {
#line 3679
      goto case_279;
    }
#line 3688
    if (class == 285) {
#line 3688
      goto case_285;
    }
#line 3696
    if (class == 284) {
#line 3696
      goto case_284;
    }
#line 3704
    goto make_instruction;
    case_305: /* CIL Label */ 
    case_303: /* CIL Label */ 
#line 3652
    want_source = (_Bool)1;
#line 3653
    goto switch_break___2;
    case_304: /* CIL Label */ 
    {
#line 3655
    tmp___55 = in_main_context();
    }
#line 3655
    if (tmp___55) {
#line 3656
      goto out;
    }
    {
#line 3657
    tmp___56 = malloc((size_t )((tok___0 - tokstart) + 1L));
#line 3657
    tokkey = (char *)tmp___56;
    }
#line 3657
    if (tokkey) {
#line 3657
      tmp___60 = 1;
    } else {
      {
#line 3657
      set_loc("awkgram.y", 3657);
#line 3657
      tmp___57 = __errno_location();
#line 3657
      tmp___58 = strerror(*tmp___57);
#line 3657
      tmp___59 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 3657
      r_fatal((char const   *)tmp___59, "yylex", "tokkey", (tok___0 - tokstart) + 1L,
              tmp___58);
#line 3657
      tmp___60 = 0;
      }
    }
    {
#line 3658
    *(tokkey + 0) = (char )'@';
#line 3659
    memcpy((void */* __restrict  */)(tokkey + 1), (void const   */* __restrict  */)tokstart,
           (size_t )(tok___0 - tokstart));
#line 3660
    yylval = bcalloc((OPCODE )103, 1, sourceline);
#line 3661
    yylval->d.name = tokkey;
    }
#line 3662
    goto switch_break___2;
    case_292: /* CIL Label */ 
    case_291: /* CIL Label */ 
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    case_290: /* CIL Label */ 
    {
#line 3669
    yylval = bcalloc((OPCODE )tokentab[mid].value, 3, sourceline);
    }
#line 3670
    goto switch_break___2;
    case_278: /* CIL Label */ 
    case_282: /* CIL Label */ 
    case_281: /* CIL Label */ 
    case_283: /* CIL Label */ 
#line 3676
    if (! (do_flags & 256)) {
#line 3677
      lasttok___0 = class;
#line 3677
      return (lasttok___0);
    }
    case_279: /* CIL Label */ 
    {
#line 3680
    yylval = bcalloc((OPCODE )tokentab[mid].value, 2, sourceline);
    }
#line 3681
    goto switch_break___2;
    case_285: /* CIL Label */ 
#line 3689
    if (! continue_allowed) {
      {
#line 3690
      tmp___61 = gettext("`continue\' is not allowed outside a loop");
#line 3690
      error_ln(sourceline, (char const   *)tmp___61);
#line 3692
      errcount___0 ++;
      }
    }
#line 3694
    goto make_instruction;
    case_284: /* CIL Label */ 
#line 3697
    if (! break_allowed) {
      {
#line 3698
      tmp___62 = gettext("`break\' is not allowed outside a loop or switch");
#line 3698
      error_ln(sourceline, (char const   *)tmp___62);
#line 3700
      errcount___0 ++;
      }
    }
#line 3702
    goto make_instruction;
    make_instruction: 
    switch_default___0: /* CIL Label */ 
    {
#line 3706
    yylval = bcalloc((OPCODE )tokentab[mid].value, 1, sourceline);
    }
#line 3707
    if (class == 300) {
#line 3708
      yylval->d.dl = (long )mid;
    } else
#line 3707
    if (class == 301) {
#line 3708
      yylval->d.dl = (long )mid;
    }
#line 3709
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 3711
    lasttok___0 = class;
#line 3711
    return (lasttok___0);
  }
  out: 
  {
#line 3714
  tokkey = estrdup((char const   *)tokstart, (size_t )(tok___0 - tokstart));
  }
#line 3715
  if ((int )*lexptr___1 == 40) {
    {
#line 3716
    yylval = bcalloc((OPCODE )103, 2, sourceline);
#line 3717
    yylval->d.name = tokkey;
#line 3718
    lasttok___0 = 258;
    }
#line 3718
    return (lasttok___0);
  } else {
    {
#line 3722
    yylval = bcalloc((OPCODE )103, 1, sourceline);
#line 3723
    yylval->d.name = tokkey;
    }
#line 3726
    if (do_flags & 3) {
#line 3726
      if (! goto_warned) {
        {
#line 3726
        tmp___64 = strcasecmp((char const   *)tokkey, "goto");
        }
#line 3726
        if (tmp___64 == 0) {
          {
#line 3728
          goto_warned = (_Bool)1;
#line 3729
          set_loc("awkgram.y", 3729);
#line 3729
          tmp___63 = gettext("`goto\' considered harmful!\n");
#line 3729
          (*lintfunc)((char const   *)tmp___63);
          }
        }
      }
    }
#line 3731
    lasttok___0 = 259;
#line 3731
    return (lasttok___0);
  }
}
}
#line 3878 "awkgram.y"
static _Bool warned___24  =    (_Bool)0;
#line 3939 "awkgram.y"
static _Bool warned___25  =    (_Bool)0;
#line 3741 "awkgram.y"
static INSTRUCTION *snode(INSTRUCTION *subn , INSTRUCTION *r ) 
{ 
  INSTRUCTION *arg ;
  INSTRUCTION *ip ;
  NODE *n ;
  int nexp ;
  int args_allowed ;
  int idx___3 ;
  INSTRUCTION *tp ;
  char *tmp___1 ;
  char const   *operator ;
  int tmp___2 ;
  INSTRUCTION *expr ;
  INSTRUCTION *tmp___3 ;
  INSTRUCTION *tmp___4 ;
  INSTRUCTION *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  INSTRUCTION *tmp___8 ;
  int tmp___9 ;
  INSTRUCTION *tmp___10 ;
  INSTRUCTION *tmp___11 ;
  INSTRUCTION *tmp___12 ;
  INSTRUCTION *tmp___13 ;
  INSTRUCTION *tmp___14 ;
  INSTRUCTION *tmp___15 ;
  int tmp___16 ;
  INSTRUCTION *tmp___17 ;
  int tmp___18 ;
  INSTRUCTION *list ;
  INSTRUCTION *tmp___19 ;
  INSTRUCTION *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  INSTRUCTION *expr___0 ;
  INSTRUCTION *tmp___23 ;
  INSTRUCTION *expr___1 ;
  INSTRUCTION *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  NODE *str ;
  char *tmp___27 ;
  NODE *str1 ;
  NODE *str2 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  INSTRUCTION *tmp___31 ;
  INSTRUCTION *tmp___32 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 3747
  nexp = 0;
#line 3749
  idx___3 = (int )r->d.dl;
#line 3751
  if ((unsigned long )subn != (unsigned long )((void *)0)) {
#line 3753
    tp = subn->nexti;
    {
#line 3753
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3753
      if (! tp) {
#line 3753
        goto while_break;
      }
#line 3754
      tp = tp->d.di;
#line 3755
      nexp ++;
#line 3753
      tp = tp->nexti;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3761
  args_allowed = (int )(tokentab[idx___3].flags & 255U);
#line 3762
  if (args_allowed) {
#line 3762
    if ((args_allowed & (1 << nexp)) == 0) {
      {
#line 3763
      tmp___1 = gettext("%d is invalid as number of arguments for %s");
#line 3763
      yyerror((char const   *)tmp___1, nexp, tokentab[idx___3].operator);
      }
#line 3765
      return ((INSTRUCTION *)((void *)0));
    }
  }
#line 3770
  if ((unsigned int const   )tokentab[idx___3].value == 66U) {
    {
#line 3771
    operator = (char const   *)tokentab[idx___3].operator;
#line 3773
    r->d.dl = 0L;
#line 3775
    arg = subn->nexti;
#line 3776
    mk_rexp(arg);
#line 3778
    tmp___18 = strcmp(operator, "gensub");
    }
#line 3778
    if (tmp___18 != 0) {
      {
#line 3781
      tmp___2 = strcmp(operator, "gsub");
      }
#line 3781
      if (tmp___2 == 0) {
#line 3782
        r->d.dl |= 1L;
      }
#line 3784
      arg = (arg->d.di)->nexti;
#line 3785
      if (nexp == 2) {
        {
#line 3788
        tmp___3 = bcalloc((OPCODE )74, 1, 0);
#line 3788
        expr = list_create(tmp___3);
#line 3789
        (expr->nexti)->d.dn = (*make_number)(0.0);
#line 3790
        tmp___4 = bcalloc((OPCODE )23, 1, 0);
#line 3790
        tmp___5 = list_append(expr, tmp___4);
#line 3790
        mk_expression_list(subn, tmp___5);
        }
      }
#line 3794
      arg = (arg->d.di)->nexti;
#line 3795
      ip = arg->d.di;
#line 3796
      if ((unsigned int )ip->opcode == 74U) {
#line 3797
        if (do_flags & 3) {
          {
#line 3798
          set_loc("awkgram.y", 3798);
#line 3798
          tmp___6 = gettext("%s: string literal as last arg of substitute has no effect");
#line 3798
          (*lintfunc)((char const   *)tmp___6, operator);
          }
        }
#line 3800
        r->d.dl |= 4L;
      } else {
        {
#line 3802
        tmp___8 = make_assignable(ip);
        }
#line 3802
        if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
          {
#line 3803
          tmp___7 = gettext("%s third parameter is not a changeable object");
#line 3803
          yyerror((char const   *)tmp___7, operator);
          }
        } else {
#line 3806
          ip->x.xl = 1L;
        }
      }
      {
#line 3809
      tmp___9 = count_expressions(& subn, (_Bool)0);
#line 3809
      r->x.xl = (long )tmp___9;
#line 3810
      ip = subn->d.di;
#line 3812
      list_append(subn, r);
      }
#line 3815
      if ((unsigned int )ip->opcode == 78U) {
#line 3815
        if ((unsigned int )(ip->d.dn)->type == 4U) {
#line 3815
          if ((ip->d.dn)->sub.nodep.x.aptr) {
            {
#line 3816
            tmp___10 = bcalloc((OPCODE )92, 1, 0);
#line 3816
            list_append(subn, tmp___10);
#line 3817
            (subn->d.di)->d.dl = 66L;
#line 3818
            (subn->d.di)->x.aptr = (ip->d.dn)->sub.nodep.x.aptr;
            }
          } else {
#line 3815
            goto _L___0;
          }
        } else {
#line 3815
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 3819
      if ((unsigned int )ip->opcode == 80U) {
        {
#line 3820
        tmp___11 = bcalloc((OPCODE )93, 1, 0);
#line 3820
        list_append(subn, tmp___11);
#line 3821
        (subn->d.di)->d.dl = 66L;
#line 3822
        (subn->d.di)->x.aptr = (void (*)(void))0;
#line 3823
        ip->d.di = subn->d.di;
        }
      } else
#line 3824
      if ((unsigned int )ip->opcode == 79U) {
        {
#line 3825
        tmp___12 = bcalloc((OPCODE )94, 1, 0);
#line 3825
        list_append(subn, tmp___12);
#line 3826
        (subn->d.di)->d.dl = 66L;
        }
      }
#line 3829
      return (subn);
    } else {
#line 3834
      r->d.dl |= 2L;
#line 3835
      if (nexp == 3) {
        {
#line 3836
        ip = bcalloc((OPCODE )74, 1, 0);
#line 3837
        ip->d.dn = (*make_number)(0.0);
#line 3838
        tmp___13 = bcalloc((OPCODE )23, 1, 0);
#line 3838
        tmp___14 = list_create(ip);
#line 3838
        tmp___15 = list_append(tmp___14, tmp___13);
#line 3838
        mk_expression_list(subn, tmp___15);
        }
      }
      {
#line 3842
      tmp___16 = count_expressions(& subn, (_Bool)0);
#line 3842
      r->x.xl = (long )tmp___16;
#line 3843
      tmp___17 = list_append(subn, r);
      }
#line 3843
      return (tmp___17);
    }
  }
#line 3849
  if (do_flags & 16384) {
#line 3849
    if (tokentab[idx___3].ptr2) {
#line 3850
      r->d.fptr = (NODE *(*)(int  ))tokentab[idx___3].ptr2;
    } else {
#line 3853
      r->d.fptr = (NODE *(*)(int  ))tokentab[idx___3].ptr;
    }
  } else {
#line 3853
    r->d.fptr = (NODE *(*)(int  ))tokentab[idx___3].ptr;
  }
#line 3857
  if ((unsigned long )r->d.fptr == (unsigned long )(& do_length)) {
#line 3858
    if (nexp == 0) {
      {
#line 3862
      r->x.xl = 1L;
#line 3863
      list = list_create(r);
#line 3864
      tmp___19 = bcalloc((OPCODE )23, 1, 0);
#line 3864
      list_prepend(list, tmp___19);
#line 3865
      tmp___20 = bcalloc((OPCODE )74, 1, 0);
#line 3865
      list_prepend(list, tmp___20);
#line 3866
      (list->nexti)->d.dn = (*make_number)(0.0);
      }
#line 3867
      return (list);
    } else {
#line 3869
      arg = subn->nexti;
#line 3870
      if ((unsigned long )arg->nexti == (unsigned long )arg->d.di) {
#line 3870
        if ((unsigned int )(arg->nexti)->opcode == 72U) {
#line 3871
          (arg->nexti)->opcode = (OPCODE )73;
        }
      }
    }
  } else
#line 3873
  if ((unsigned long )r->d.fptr == (unsigned long )(& do_isarray)) {
#line 3874
    arg = subn->nexti;
#line 3875
    if ((unsigned long )arg->nexti == (unsigned long )arg->d.di) {
#line 3875
      if ((unsigned int )(arg->nexti)->opcode == 72U) {
#line 3876
        (arg->nexti)->opcode = (OPCODE )73;
      }
    }
  } else
#line 3877
  if ((unsigned long )r->d.fptr == (unsigned long )(& do_match)) {
    {
#line 3880
    arg = ((subn->nexti)->d.di)->nexti;
#line 3881
    mk_rexp(arg);
    }
#line 3883
    if (nexp == 3) {
#line 3884
      if (do_flags & 3) {
#line 3884
        if (! warned___24) {
          {
#line 3885
          warned___24 = (_Bool)1;
#line 3886
          set_loc("awkgram.y", 3886);
#line 3886
          tmp___21 = gettext("match: third argument is a gawk extension");
#line 3886
          (*lintfunc)((char const   *)tmp___21);
          }
        }
      }
#line 3888
      if (do_flags & 8) {
        {
#line 3889
        tmp___22 = gettext("match: third argument is a gawk extension");
#line 3889
        yyerror((char const   *)tmp___22);
        }
#line 3890
        return ((INSTRUCTION *)((void *)0));
      }
#line 3893
      arg = (arg->d.di)->nexti;
#line 3894
      ip = arg->d.di;
#line 3895
      if ((unsigned int )ip->opcode == 72U) {
#line 3896
        ip->opcode = (OPCODE )76;
      }
    }
  } else
#line 3898
  if ((unsigned long )r->d.fptr == (unsigned long )(& do_split)) {
#line 3899
    arg = ((subn->nexti)->d.di)->nexti;
#line 3900
    ip = arg->d.di;
#line 3901
    if ((unsigned int )ip->opcode == 72U) {
#line 3902
      ip->opcode = (OPCODE )76;
    }
#line 3903
    if (nexp == 2) {
      {
#line 3905
      tmp___23 = bcalloc((OPCODE )72, 1, 0);
#line 3905
      expr___0 = list_create(tmp___23);
#line 3906
      (expr___0->nexti)->d.dn = FS_node;
#line 3907
      mk_expression_list(subn, expr___0);
      }
    }
    {
#line 3909
    arg = (arg->d.di)->nexti;
#line 3910
    n = mk_rexp(arg);
    }
#line 3911
    if (nexp == 2) {
#line 3912
      n->sub.nodep.reflags |= 4UL;
    }
#line 3913
    if (nexp == 4) {
#line 3914
      arg = (arg->d.di)->nexti;
#line 3915
      ip = arg->d.di;
#line 3916
      if ((unsigned int )ip->opcode == 72U) {
#line 3917
        ip->opcode = (OPCODE )76;
      }
    }
  } else
#line 3919
  if ((unsigned long )r->d.fptr == (unsigned long )(& do_patsplit)) {
#line 3920
    arg = ((subn->nexti)->d.di)->nexti;
#line 3921
    ip = arg->d.di;
#line 3922
    if ((unsigned int )ip->opcode == 72U) {
#line 3923
      ip->opcode = (OPCODE )76;
    }
#line 3924
    if (nexp == 2) {
      {
#line 3926
      tmp___24 = bcalloc((OPCODE )72, 1, 0);
#line 3926
      expr___1 = list_create(tmp___24);
#line 3927
      (expr___1->nexti)->d.dn = FPAT_node;
#line 3928
      mk_expression_list(subn, expr___1);
      }
    }
    {
#line 3930
    arg = (arg->d.di)->nexti;
#line 3931
    n = mk_rexp(arg);
    }
#line 3932
    if (nexp == 4) {
#line 3933
      arg = (arg->d.di)->nexti;
#line 3934
      ip = arg->d.di;
#line 3935
      if ((unsigned int )ip->opcode == 72U) {
#line 3936
        ip->opcode = (OPCODE )76;
      }
    }
  } else
#line 3938
  if ((unsigned long )r->d.fptr == (unsigned long )(& do_close)) {
#line 3940
    if (nexp == 2) {
#line 3941
      if (do_flags & 3) {
#line 3941
        if (! warned___25) {
          {
#line 3942
          warned___25 = (_Bool)1;
#line 3943
          set_loc("awkgram.y", 3943);
#line 3943
          tmp___25 = gettext("close: second argument is a gawk extension");
#line 3943
          (*lintfunc)((char const   *)tmp___25);
          }
        }
      }
#line 3945
      if (do_flags & 8) {
        {
#line 3946
        tmp___26 = gettext("close: second argument is a gawk extension");
#line 3946
        yyerror((char const   *)tmp___26);
        }
#line 3947
        return ((INSTRUCTION *)((void *)0));
      }
    }
  } else
#line 3950
  if (do_flags & 32) {
#line 3950
    if ((unsigned long )r->d.fptr == (unsigned long )(& do_dcgettext)) {
#line 3950
      if ((unsigned int )((subn->nexti)->d.di)->opcode == 74U) {
#line 3950
        if (((((subn->nexti)->d.di)->d.dn)->flags & 4U) != 0U) {
#line 3955
          str = ((subn->nexti)->d.di)->d.dn;
#line 3957
          if ((str->flags & 128U) != 0U) {
            {
#line 3958
            tmp___27 = gettext("use of dcgettext(_\"...\") is incorrect: remove leading underscore");
#line 3958
            warning((char const   *)tmp___27);
            }
          } else {
            {
#line 3961
            dumpintlstr((char const   *)str->sub.val.sp, str->sub.val.slen);
            }
          }
        } else {
#line 3950
          goto _L___9;
        }
      } else {
#line 3950
        goto _L___9;
      }
    } else {
#line 3950
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 3962
  if (do_flags & 32) {
#line 3962
    if ((unsigned long )r->d.fptr == (unsigned long )(& do_dcngettext)) {
#line 3962
      if ((unsigned int )((subn->nexti)->d.di)->opcode == 74U) {
#line 3962
        if (((((subn->nexti)->d.di)->d.dn)->flags & 4U) != 0U) {
#line 3962
          if ((unsigned int )((((subn->nexti)->d.di)->nexti)->d.di)->opcode == 74U) {
#line 3962
            if (((((((subn->nexti)->d.di)->nexti)->d.di)->d.dn)->flags & 4U) != 0U) {
#line 3969
              str1 = ((subn->nexti)->d.di)->d.dn;
#line 3970
              str2 = ((((subn->nexti)->d.di)->nexti)->d.di)->d.dn;
#line 3972
              if (((str1->flags | str2->flags) & 128U) != 0U) {
                {
#line 3973
                tmp___28 = gettext("use of dcngettext(_\"...\") is incorrect: remove leading underscore");
#line 3973
                warning((char const   *)tmp___28);
                }
              } else {
                {
#line 3975
                dumpintlstr2((char const   *)str1->sub.val.sp, str1->sub.val.slen,
                             (char const   *)str2->sub.val.sp, str2->sub.val.slen);
                }
              }
            } else {
#line 3962
              goto _L___6;
            }
          } else {
#line 3962
            goto _L___6;
          }
        } else {
#line 3962
          goto _L___6;
        }
      } else {
#line 3962
        goto _L___6;
      }
    } else {
#line 3962
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 3976
  if ((unsigned long )r->d.fptr == (unsigned long )(& do_asort)) {
#line 3976
    goto _L___1;
  } else
#line 3976
  if ((unsigned long )r->d.fptr == (unsigned long )(& do_asorti)) {
    _L___1: /* CIL Label */ 
#line 3977
    arg = subn->nexti;
#line 3978
    ip = arg->d.di;
#line 3979
    if ((unsigned int )ip->opcode == 72U) {
#line 3980
      ip->opcode = (OPCODE )76;
    }
#line 3981
    if (nexp >= 2) {
#line 3982
      arg = ip->nexti;
#line 3983
      ip = arg->d.di;
#line 3984
      if ((unsigned int )ip->opcode == 72U) {
#line 3985
        ip->opcode = (OPCODE )76;
      }
    }
  } else
#line 3988
  if ((unsigned long )r->d.fptr == (unsigned long )(& do_index)) {
#line 3989
    arg = ((subn->nexti)->d.di)->nexti;
#line 3990
    ip = arg->d.di;
#line 3991
    if ((unsigned int )ip->opcode == 47U) {
      {
#line 3992
      set_loc("awkgram.y", 3992);
#line 3992
      tmp___29 = gettext("index: regexp constant as second argument is not allowed");
#line 3992
      r_fatal((char const   *)tmp___29);
      }
    }
  }
#line 4002
  if ((unsigned long )subn != (unsigned long )((void *)0)) {
    {
#line 4003
    tmp___30 = count_expressions(& subn, (_Bool)0);
#line 4003
    r->x.xl = (long )tmp___30;
#line 4004
    tmp___31 = list_append(subn, r);
    }
#line 4004
    return (tmp___31);
  }
  {
#line 4007
  r->x.xl = 0L;
#line 4008
  tmp___32 = list_create(r);
  }
#line 4008
  return (tmp___32);
}
}
#line 4014 "awkgram.y"
static int parms_shadow(INSTRUCTION *pc , _Bool *shadow ) 
{ 
  int pcount ;
  int i___0 ;
  _Bool ret ;
  NODE *func___1 ;
  NODE *fp___0 ;
  char *fname ;
  char *tmp___1 ;
  NODE *tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 4018
  ret = (_Bool)0;
#line 4022
  func___1 = pc->x.xn;
#line 4023
  fname = func___1->sub.nodep.name;
#line 4024
  fp___0 = func___1->sub.nodep.rn;
#line 4031
  pcount = (int )func___1->sub.nodep.l.ll;
#line 4033
  if (pcount == 0) {
#line 4034
    return (0);
  }
#line 4036
  source = pc->d.name;
#line 4037
  sourceline = (int )pc->source_line;
#line 4042
  i___0 = 0;
  {
#line 4042
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4042
    if (! (i___0 < pcount)) {
#line 4042
      goto while_break;
    }
    {
#line 4043
    tmp___2 = lookup((char const   *)(fp___0 + i___0)->sub.nodep.name);
    }
#line 4043
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {
#line 4044
      tmp___1 = gettext("function `%s\': parameter `%s\' shadows global variable");
#line 4044
      warning((char const   *)tmp___1, fname, (fp___0 + i___0)->sub.nodep.name);
#line 4047
      ret = (_Bool)1;
      }
    }
#line 4042
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4051
  *shadow = (_Bool )((int )*shadow | (int )ret);
#line 4052
  return (0);
}
}
#line 4057 "awkgram.y"
void valinfo(NODE *n , int (*print_func)(FILE * , char const   *  , ...) , FILE *fp___0 ) 
{ 
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 4060
  if ((unsigned long )n == (unsigned long )Nnull_string) {
    {
#line 4061
    (*print_func)(fp___0, "uninitialized scalar\n");
    }
  } else
#line 4062
  if (n->flags & 2U) {
    {
#line 4063
    pp_string_fp(print_func, fp___0, (char const   *)n->sub.val.sp, n->sub.val.slen,
                 '\"', (_Bool)0);
#line 4064
    (*print_func)(fp___0, "\n");
    }
  } else
#line 4065
  if (n->flags & 16U) {
#line 4067
    if ((n->flags & 2048U) != 0U) {
      {
#line 4068
      tmp___1 = mpg_fmt("%.17R*g", (int )ROUND_MODE, n->sub.val.nm.mpnum);
#line 4068
      (*print_func)(fp___0, "%s\n", tmp___1);
      }
    } else
#line 4069
    if ((n->flags & 4096U) != 0U) {
      {
#line 4070
      tmp___2 = mpg_fmt("%Zd", n->sub.val.nm.mpi);
#line 4070
      (*print_func)(fp___0, "%s\n", tmp___2);
      }
    } else {
      {
#line 4073
      (*print_func)(fp___0, "%.17g\n", n->sub.val.nm.fltnum);
      }
    }
  } else
#line 4074
  if (n->flags & 4U) {
    {
#line 4075
    pp_string_fp(print_func, fp___0, (char const   *)n->sub.val.sp, n->sub.val.slen,
                 '\"', (_Bool)0);
#line 4076
    (*print_func)(fp___0, "\n");
    }
  } else
#line 4077
  if (n->flags & 8U) {
#line 4079
    if ((n->flags & 2048U) != 0U) {
      {
#line 4080
      tmp___3 = mpg_fmt("%.17R*g", (int )ROUND_MODE, n->sub.val.nm.mpnum);
#line 4080
      (*print_func)(fp___0, "%s\n", tmp___3);
      }
    } else
#line 4081
    if ((n->flags & 4096U) != 0U) {
      {
#line 4082
      tmp___4 = mpg_fmt("%Zd", n->sub.val.nm.mpi);
#line 4082
      (*print_func)(fp___0, "%s\n", tmp___4);
      }
    } else {
      {
#line 4085
      (*print_func)(fp___0, "%.17g\n", n->sub.val.nm.fltnum);
      }
    }
  } else {
    {
#line 4087
    tmp___5 = flags2str((int )n->flags);
#line 4087
    (*print_func)(fp___0, "?? flags %s\n", tmp___5);
    }
  }
#line 4088
  return;
}
}
#line 4093 "awkgram.y"
void dump_vars(char const   *fname ) 
{ 
  FILE *fp___0 ;
  NODE **vars___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 4099
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 4100
    fp___0 = stderr;
  } else {
    {
#line 4101
    fp___0 = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
    }
#line 4101
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      {
#line 4102
      tmp___1 = __errno_location();
#line 4102
      tmp___2 = strerror(*tmp___1);
#line 4102
      tmp___3 = gettext("could not open `%s\' for writing (%s)");
#line 4102
      warning((char const   *)tmp___3, fname, tmp___2);
#line 4103
      tmp___4 = gettext("sending variable list to standard error");
#line 4103
      warning((char const   *)tmp___4);
#line 4104
      fp___0 = stderr;
      }
    }
  }
  {
#line 4107
  vars___0 = variable_list();
#line 4108
  print_vars(vars___0, (int (*)(FILE * , char const   *  , ...))(& fprintf), fp___0);
#line 4109
  free((void *)vars___0);
  }
#line 4110
  if ((unsigned long )fp___0 != (unsigned long )stderr) {
    {
#line 4110
    tmp___8 = fclose(fp___0);
    }
#line 4110
    if (tmp___8 != 0) {
      {
#line 4111
      tmp___5 = __errno_location();
#line 4111
      tmp___6 = strerror(*tmp___5);
#line 4111
      tmp___7 = gettext("%s: close failed (%s)");
#line 4111
      warning((char const   *)tmp___7, fname, tmp___6);
      }
    }
  }
#line 4112
  return;
}
}
#line 4116 "awkgram.y"
void dump_funcs(void) 
{ 
  NODE **funcs ;

  {
  {
#line 4120
  funcs = function_list((_Bool)1);
#line 4121
  foreach_func(funcs, & pp_func, (void *)0);
#line 4122
  free((void *)funcs);
  }
#line 4123
  return;
}
}
#line 4131 "awkgram.y"
static int calls  =    0;
#line 4128 "awkgram.y"
void shadow_funcs(void) 
{ 
  _Bool shadow ;
  NODE **funcs ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 4132
  shadow = (_Bool)0;
#line 4135
  tmp___2 = calls;
#line 4135
  calls ++;
#line 4135
  if (tmp___2 != 0) {
    {
#line 4136
    set_loc("awkgram.y", 4136);
#line 4136
    tmp___1 = gettext("shadow_funcs() called twice!");
#line 4136
    r_fatal((char const   *)tmp___1);
    }
  }
  {
#line 4138
  funcs = function_list((_Bool)1);
#line 4139
  foreach_func(funcs, (int (*)(INSTRUCTION * , void * ))(& parms_shadow), (void *)(& shadow));
#line 4140
  free((void *)funcs);
  }
#line 4143
  if (shadow) {
#line 4143
    if ((unsigned long )lintfunc != (unsigned long )(& warning)) {
      {
#line 4144
      set_loc("awkgram.y", 4144);
#line 4144
      tmp___3 = gettext("there were shadowed variables.");
#line 4144
      (*lintfunc)((char const   *)tmp___3);
      }
    }
  }
#line 4145
  return;
}
}
#line 4152 "awkgram.y"
static INSTRUCTION *mk_function(INSTRUCTION *fi , INSTRUCTION *def ) 
{ 
  NODE *thisfunc ;
  INSTRUCTION *t ;
  int tmp___1 ;
  INSTRUCTION *tmp___2 ;
  INSTRUCTION *tmp___3 ;
  INSTRUCTION *tmp___4 ;

  {
#line 4157
  thisfunc = fi->x.xn;
#line 4160
  if ((int )do_optimize > 1) {
#line 4160
    if ((unsigned int )(def->d.di)->opcode == 82U) {
#line 4165
      t = def->nexti;
      {
#line 4165
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4165
        if (! ((unsigned long )t->nexti != (unsigned long )def->d.di)) {
#line 4165
          goto while_break;
        }
#line 4165
        t = t->nexti;
      }
      while_break: /* CIL Label */ ;
      }
#line 4167
      if ((unsigned int )t->opcode == 70U) {
        {
#line 4167
        tmp___1 = strcmp((char const   *)t->d.name, (char const   *)thisfunc->sub.nodep.name);
        }
#line 4167
        if (tmp___1 == 0) {
#line 4169
          (t + 1)->d.dl = 1L;
        }
      }
    }
  }
  {
#line 4176
  tmp___2 = bcalloc((OPCODE )74, 1, 0);
#line 4176
  list_append(def, tmp___2);
#line 4177
  (def->d.di)->d.dn = dupnode(Nnull_string);
#line 4178
  tmp___3 = bcalloc((OPCODE )59, 1, 0);
#line 4178
  list_append(def, tmp___3);
  }
#line 4180
  if (do_flags & 256) {
    {
#line 4181
    tmp___4 = bcalloc((OPCODE )98, 1, 0);
#line 4181
    list_prepend(def, tmp___4);
    }
  }
  {
#line 4184
  (fi + 1)->x.xi = def->nexti;
#line 4185
  (fi + 1)->d.di = def->d.di;
#line 4186
  (fi + 2)->source_line = fi->source_line;
#line 4187
  (fi + 2)->x.xl = (long )lastline;
#line 4188
  fi->nexti = def->nexti;
#line 4189
  bcfree(def);
#line 4191
  list_append(rule_list, fi + 1);
#line 4194
  func_use((char const   *)thisfunc->sub.nodep.name, (enum defref )0);
#line 4197
  remove_params(thisfunc);
  }
#line 4198
  return (fi);
}
}
#line 4207 "awkgram.y"
static int install_function(char *fname , INSTRUCTION *fi , INSTRUCTION *plist ) 
{ 
  NODE *r ;
  NODE *f ;
  int pcount ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  char **pnames ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 4211
  pcount = 0;
#line 4213
  r = lookup((char const   *)fname);
  }
#line 4214
  if ((unsigned long )r != (unsigned long )((void *)0)) {
    {
#line 4215
    tmp___1 = gettext("function name `%s\' previously defined");
#line 4215
    error_ln((int )fi->source_line, (char const   *)tmp___1, fname);
    }
#line 4216
    return (-1);
  } else {
    {
#line 4214
    tmp___2 = is_deferred_variable((char const   *)fname);
    }
#line 4214
    if (tmp___2) {
      {
#line 4215
      tmp___1 = gettext("function name `%s\' previously defined");
#line 4215
      error_ln((int )fi->source_line, (char const   *)tmp___1, fname);
      }
#line 4216
      return (-1);
    }
  }
#line 4219
  if ((unsigned long )plist != (unsigned long )((void *)0)) {
#line 4220
    pcount = (int )((plist->d.di)->x.xl + 1L);
  }
  {
#line 4221
  f = install_symbol(fname, (NODETYPE )8);
#line 4222
  fi->x.xn = f;
#line 4223
  f->sub.nodep.l.ll = (long )pcount;
#line 4224
  f->sub.nodep.r.iptr = fi;
#line 4225
  f->sub.nodep.rn = (struct exp_node *)((void *)0);
  }
#line 4226
  if (pcount > 0) {
    {
#line 4228
    pnames = check_params(fname, pcount, plist);
#line 4229
    f->sub.nodep.rn = make_params(pnames, pcount);
#line 4230
    free((void *)pnames);
#line 4231
    install_params(f);
    }
  }
#line 4233
  return (0);
}
}
#line 4241 "awkgram.y"
static char **check_params(char *fname , int pcount , INSTRUCTION *list ) 
{ 
  INSTRUCTION *p ;
  INSTRUCTION *np ;
  int i___0 ;
  int j ;
  char *name ;
  char **pnames ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 4251
  tmp___1 = malloc((unsigned long )pcount * sizeof(char *));
#line 4251
  pnames = (char **)tmp___1;
  }
#line 4251
  if (pnames) {
#line 4251
    tmp___5 = 1;
  } else {
    {
#line 4251
    set_loc("awkgram.y", 4251);
#line 4251
    tmp___2 = __errno_location();
#line 4251
    tmp___3 = strerror(*tmp___2);
#line 4251
    tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4251
    r_fatal((char const   *)tmp___4, "check_params", "pnames", (long )((unsigned long )pcount * sizeof(char *)),
            tmp___3);
#line 4251
    tmp___5 = 0;
    }
  }
#line 4253
  i___0 = 0;
#line 4253
  p = list->nexti;
  {
#line 4253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4253
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 4253
      goto while_break;
    }
    {
#line 4254
    np = p->nexti;
#line 4255
    name = p->d.name;
#line 4256
    p->d.name = (char *)((void *)0);
#line 4258
    tmp___9 = strcmp((char const   *)name, (char const   *)fname);
    }
#line 4258
    if (tmp___9 == 0) {
      {
#line 4260
      tmp___6 = gettext("function `%s\': can\'t use function name as parameter name");
#line 4260
      error_ln((int )p->source_line, (char const   *)tmp___6, fname);
      }
    } else {
      {
#line 4262
      tmp___8 = is_std_var((char const   *)name);
      }
#line 4262
      if (tmp___8) {
        {
#line 4263
        tmp___7 = gettext("function `%s\': can\'t use special variable `%s\' as a function parameter");
#line 4263
        error_ln((int )p->source_line, (char const   *)tmp___7, fname, name);
        }
      }
    }
#line 4269
    j = 0;
    {
#line 4269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4269
      if (! (j < i___0)) {
#line 4269
        goto while_break___0;
      }
      {
#line 4270
      tmp___11 = strcmp((char const   *)name, (char const   *)*(pnames + j));
      }
#line 4270
      if (tmp___11 == 0) {
        {
#line 4271
        tmp___10 = gettext("function `%s\': parameter #%d, `%s\', duplicates parameter #%d");
#line 4271
        error_ln((int )p->source_line, (char const   *)tmp___10, fname, i___0 + 1,
                 name, j + 1);
        }
      }
#line 4269
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4277
    *(pnames + i___0) = name;
#line 4278
    bcfree(p);
#line 4253
    i___0 ++;
#line 4253
    p = np;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4280
  bcfree(list);
  }
#line 4282
  return (pnames);
}
}
#line 4291 "awkgram.y"
static struct fdesc *ftable[1021]  ;
#line 4301 "awkgram.y"
static void func_use(char const   *name , enum defref how ) 
{ 
  struct fdesc *fp___0 ;
  int len ;
  int ind ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 4308
  tmp___1 = strlen(name);
#line 4308
  len = (int )tmp___1;
#line 4309
  tmp___2 = (*hash)(name, (size_t )len, 1021UL, (size_t *)((void *)0));
#line 4309
  ind = (int )tmp___2;
#line 4311
  fp___0 = ftable[ind];
  }
  {
#line 4311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4311
    if (! ((unsigned long )fp___0 != (unsigned long )((void *)0))) {
#line 4311
      goto while_break;
    }
    {
#line 4312
    tmp___3 = strcmp((char const   *)fp___0->name, name);
    }
#line 4312
    if (tmp___3 == 0) {
#line 4313
      if ((unsigned int )how == 0U) {
#line 4314
        fp___0->defined = (short )((int )fp___0->defined + 1);
      } else
#line 4315
      if ((unsigned int )how == 2U) {
#line 4316
        fp___0->defined = (short )((int )fp___0->defined + 1);
#line 4317
        fp___0->extension = (short )((int )fp___0->extension + 1);
      } else {
#line 4319
        fp___0->used = (short )((int )fp___0->used + 1);
      }
#line 4320
      return;
    }
#line 4311
    fp___0 = fp___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4326
  tmp___4 = malloc(sizeof(struct fdesc ));
#line 4326
  fp___0 = (struct fdesc *)tmp___4;
  }
#line 4326
  if (fp___0) {
#line 4326
    tmp___8 = 1;
  } else {
    {
#line 4326
    set_loc("awkgram.y", 4326);
#line 4326
    tmp___5 = __errno_location();
#line 4326
    tmp___6 = strerror(*tmp___5);
#line 4326
    tmp___7 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4326
    r_fatal((char const   *)tmp___7, "func_use", "fp", (long )sizeof(struct fdesc ),
            tmp___6);
#line 4326
    tmp___8 = 0;
    }
  }
  {
#line 4327
  memset((void *)fp___0, '\000', sizeof(struct fdesc ));
#line 4328
  tmp___10 = malloc((size_t )(len + 1));
#line 4328
  tmp___9 = (char *)tmp___10;
#line 4328
  fp___0->name = tmp___9;
  }
#line 4328
  if (tmp___9) {
#line 4328
    tmp___14 = 1;
  } else {
    {
#line 4328
    set_loc("awkgram.y", 4328);
#line 4328
    tmp___11 = __errno_location();
#line 4328
    tmp___12 = strerror(*tmp___11);
#line 4328
    tmp___13 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4328
    r_fatal((char const   *)tmp___13, "func_use", "fp->name", (long )(len + 1), tmp___12);
#line 4328
    tmp___14 = 0;
    }
  }
  {
#line 4329
  strcpy((char */* __restrict  */)fp___0->name, (char const   */* __restrict  */)name);
  }
#line 4330
  if ((unsigned int )how == 0U) {
#line 4331
    fp___0->defined = (short )((int )fp___0->defined + 1);
  } else
#line 4332
  if ((unsigned int )how == 2U) {
#line 4333
    fp___0->defined = (short )((int )fp___0->defined + 1);
#line 4334
    fp___0->extension = (short )((int )fp___0->extension + 1);
  } else {
#line 4336
    fp___0->used = (short )((int )fp___0->used + 1);
  }
#line 4337
  fp___0->next = ftable[ind];
#line 4338
  ftable[ind] = fp___0;
#line 4339
  return;
}
}
#line 4343 "awkgram.y"
void track_ext_func(char const   *name ) 
{ 


  {
  {
#line 4346
  func_use(name, (enum defref )2);
  }
#line 4347
  return;
}
}
#line 4351 "awkgram.y"
static void check_funcs(void) 
{ 
  struct fdesc *fp___0 ;
  struct fdesc *next ;
  int i___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 4357
  tmp___1 = in_main_context();
  }
#line 4357
  if (! tmp___1) {
#line 4358
    goto free_mem;
  }
#line 4360
  i___0 = 0;
  {
#line 4360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4360
    if (! (i___0 < 1021)) {
#line 4360
      goto while_break;
    }
#line 4361
    fp___0 = ftable[i___0];
    {
#line 4361
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4361
      if (! ((unsigned long )fp___0 != (unsigned long )((void *)0))) {
#line 4361
        goto while_break___0;
      }
#line 4370
      if (do_flags & 3) {
#line 4370
        if ((int )fp___0->defined == 0) {
#line 4370
          if (! fp___0->extension) {
            {
#line 4371
            set_loc("awkgram.y", 4371);
#line 4371
            tmp___2 = gettext("function `%s\' called but never defined");
#line 4371
            (*lintfunc)((char const   *)tmp___2, fp___0->name);
            }
          }
        }
      }
#line 4375
      if (do_flags & 3) {
#line 4375
        if ((int )fp___0->used == 0) {
#line 4375
          if (! fp___0->extension) {
            {
#line 4376
            set_loc("awkgram.y", 4376);
#line 4376
            tmp___3 = gettext("function `%s\' defined but never called directly");
#line 4376
            (*lintfunc)((char const   *)tmp___3, fp___0->name);
            }
          }
        }
      }
#line 4361
      fp___0 = fp___0->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4360
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  free_mem: 
#line 4384
  i___0 = 0;
  {
#line 4384
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4384
    if (! (i___0 < 1021)) {
#line 4384
      goto while_break___1;
    }
#line 4385
    fp___0 = ftable[i___0];
    {
#line 4385
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4385
      if (! ((unsigned long )fp___0 != (unsigned long )((void *)0))) {
#line 4385
        goto while_break___2;
      }
      {
#line 4386
      next = fp___0->next;
#line 4387
      free((void *)fp___0->name);
#line 4388
      free((void *)fp___0);
#line 4385
      fp___0 = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4390
    ftable[i___0] = (struct fdesc *)((void *)0);
#line 4384
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4392
  return;
}
}
#line 4396 "awkgram.y"
static void param_sanity(INSTRUCTION *arglist ) 
{ 
  INSTRUCTION *argl ;
  INSTRUCTION *arg ;
  int i___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 4400
  i___0 = 1;
#line 4402
  if ((unsigned long )arglist == (unsigned long )((void *)0)) {
#line 4403
    return;
  }
#line 4404
  argl = arglist->nexti;
  {
#line 4404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4404
    if (! argl) {
#line 4404
      goto while_break;
    }
#line 4405
    arg = argl->d.di;
#line 4406
    if ((unsigned int )arg->opcode == 47U) {
      {
#line 4407
      tmp___1 = gettext("regexp constant for parameter #%d yields boolean value");
#line 4407
      warning_ln((int )arg->source_line, (char const   *)tmp___1, i___0);
      }
    }
#line 4409
    argl = arg->nexti;
#line 4410
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4412
  return;
}
}
#line 4423 "awkgram.y"
static struct deferred_variable *deferred_variables  ;
#line 4431 "awkgram.y"
void register_deferred_variable(char const   *name , NODE *(*load_func)(void) ) 
{ 
  struct deferred_variable *dv ;
  size_t sl ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 4435
  tmp___1 = strlen(name);
#line 4435
  sl = tmp___1;
#line 4437
  tmp___2 = malloc(sizeof(*dv) + sl);
#line 4437
  dv = (struct deferred_variable *)tmp___2;
  }
#line 4437
  if (dv) {
#line 4437
    tmp___6 = 1;
  } else {
    {
#line 4437
    set_loc("awkgram.y", 4438);
#line 4437
    tmp___3 = __errno_location();
#line 4437
    tmp___4 = strerror(*tmp___3);
#line 4437
    tmp___5 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 4437
    r_fatal((char const   *)tmp___5, "register_deferred_variable", "dv", (long )(sizeof(*dv) + sl),
            tmp___4);
#line 4437
    tmp___6 = 0;
    }
  }
  {
#line 4439
  dv->load_func = load_func;
#line 4440
  dv->next = deferred_variables;
#line 4441
  memcpy((void */* __restrict  */)(dv->name), (void const   */* __restrict  */)name,
         sl + 1UL);
#line 4442
  deferred_variables = dv;
  }
#line 4443
  return;
}
}
#line 4447 "awkgram.y"
static _Bool is_deferred_variable(char const   *name ) 
{ 
  struct deferred_variable *dv ;
  int tmp___1 ;

  {
#line 4451
  dv = deferred_variables;
  {
#line 4451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4451
    if (! ((unsigned long )dv != (unsigned long )((void *)0))) {
#line 4451
      goto while_break;
    }
    {
#line 4452
    tmp___1 = strcmp(name, (char const   *)(dv->name));
    }
#line 4452
    if (tmp___1 == 0) {
#line 4453
      return ((_Bool)1);
    }
#line 4451
    dv = dv->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 4454
  return ((_Bool)0);
}
}
#line 4460 "awkgram.y"
NODE *variable(int location , char *name , NODETYPE type ) 
{ 
  NODE *r ;
  char *tmp___1 ;
  struct deferred_variable *dv ;
  NODE *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 4465
  r = lookup((char const   *)name);
  }
#line 4465
  if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 4466
    if ((unsigned int )r->type == 8U) {
      {
#line 4467
      tmp___1 = gettext("function `%s\' called with space between name and `(\',\nor used as a variable or an array");
#line 4467
      error_ln(location, (char const   *)tmp___1, r->sub.nodep.name);
      }
    } else
#line 4466
    if ((unsigned int )r->type == 9U) {
      {
#line 4467
      tmp___1 = gettext("function `%s\' called with space between name and `(\',\nor used as a variable or an array");
#line 4467
      error_ln(location, (char const   *)tmp___1, r->sub.nodep.name);
      }
    }
#line 4469
    if ((unsigned long )r == (unsigned long )symbol_table) {
#line 4470
      symtab_used = (_Bool)1;
    }
  } else {
#line 4475
    dv = deferred_variables;
    {
#line 4475
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4476
      if ((unsigned long )dv == (unsigned long )((void *)0)) {
        {
#line 4480
        tmp___2 = install_symbol(name, type);
        }
#line 4480
        return (tmp___2);
      }
      {
#line 4482
      tmp___3 = strcmp((char const   *)name, (char const   *)(dv->name));
      }
#line 4482
      if (tmp___3 == 0) {
        {
#line 4483
        r = (*(dv->load_func))();
        }
#line 4484
        goto while_break;
      }
#line 4475
      dv = dv->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 4488
  free((void *)name);
  }
#line 4489
  return (r);
}
}
#line 4494 "awkgram.y"
static void process_deferred(void) 
{ 
  struct deferred_variable *dv ;

  {
#line 4499
  if (! symtab_used) {
#line 4500
    return;
  }
#line 4502
  dv = deferred_variables;
  {
#line 4502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4502
    if (! ((unsigned long )dv != (unsigned long )((void *)0))) {
#line 4502
      goto while_break;
    }
    {
#line 4503
    (*(dv->load_func))();
#line 4502
    dv = dv->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4505
  return;
}
}
#line 4509 "awkgram.y"
static NODE *make_regnode(int type , NODE *exp___0 ) 
{ 
  NODE *n ;
  void *tmp___1 ;

  {
#line 4514
  n = (NODE *)nextfree[1].freep;
#line 4514
  if (n) {
#line 4514
    nextfree[1].freep = ((BLOCK *)n)->freep;
  } else {
    {
#line 4514
    tmp___1 = more_blocks(1);
#line 4514
    n = (NODE *)tmp___1;
    }
  }
  {
#line 4515
  memset((void *)n, 0, sizeof(NODE ));
#line 4516
  n->type = (NODETYPE )type;
#line 4517
  n->flags = 1U;
  }
#line 4519
  if (type == 2) {
    {
#line 4520
    n->sub.nodep.r.preg = make_regexp((char const   *)exp___0->sub.val.sp, exp___0->sub.val.slen,
                                      (_Bool)0, (_Bool)1, (_Bool)0);
    }
#line 4521
    if ((unsigned long )n->sub.nodep.r.preg == (unsigned long )((void *)0)) {
#line 4522
      ((BLOCK *)n)->freep = nextfree[1].freep;
#line 4522
      nextfree[1].freep = (BLOCK *)n;
#line 4523
      return ((NODE *)((void *)0));
    }
#line 4525
    n->sub.nodep.x.extra = exp___0;
#line 4526
    n->sub.nodep.reflags = 2UL;
  }
#line 4528
  return (n);
}
}
#line 4534 "awkgram.y"
static NODE *mk_rexp(INSTRUCTION *list ) 
{ 
  INSTRUCTION *ip ;

  {
#line 4539
  ip = list->nexti;
#line 4540
  if ((unsigned long )ip == (unsigned long )list->d.di) {
#line 4540
    if ((unsigned int )ip->opcode == 47U) {
#line 4541
      ip->opcode = (OPCODE )75;
    } else {
      {
#line 4543
      ip = bcalloc((OPCODE )75, 1, 0);
#line 4544
      ip->d.dn = make_regnode(3, (NODE *)((void *)0));
#line 4545
      ip->nexti = (list->d.di)->nexti;
#line 4546
      (list->d.di)->nexti = ip;
#line 4547
      list->d.di = ip;
      }
    }
  } else {
    {
#line 4543
    ip = bcalloc((OPCODE )75, 1, 0);
#line 4544
    ip->d.dn = make_regnode(3, (NODE *)((void *)0));
#line 4545
    ip->nexti = (list->d.di)->nexti;
#line 4546
    (list->d.di)->nexti = ip;
#line 4547
    list->d.di = ip;
    }
  }
#line 4549
  return (ip->d.dn);
}
}
#line 4555 "awkgram.y"
static int isnoeffect(OPCODE type ) 
{ 


  {
  {
#line 4587
  if ((unsigned int )type == 69U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 24U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 47U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 48U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 46U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 45U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 44U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 43U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 42U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 41U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 40U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 39U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 37U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 23U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 22U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 12U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 11U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 13U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 16U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 10U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 9U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 8U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 7U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 6U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 5U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 4U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 3U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 2U) {
#line 4587
    goto case_69;
  }
#line 4587
  if ((unsigned int )type == 1U) {
#line 4587
    goto case_69;
  }
#line 4589
  goto switch_default;
  case_69: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 4588
  return (1);
  switch_default: /* CIL Label */ 
#line 4590
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4593
  return (0);
}
}
#line 4600 "awkgram.y"
static INSTRUCTION *make_assignable(INSTRUCTION *ip ) 
{ 


  {
  {
#line 4604
  if ((unsigned int )ip->opcode == 72U) {
#line 4604
    goto case_72;
  }
#line 4607
  if ((unsigned int )ip->opcode == 23U) {
#line 4607
    goto case_23;
  }
#line 4610
  if ((unsigned int )ip->opcode == 16U) {
#line 4610
    goto case_16;
  }
#line 4613
  goto switch_default;
  case_72: /* CIL Label */ 
#line 4605
  ip->opcode = (OPCODE )78;
#line 4606
  return (ip);
  case_23: /* CIL Label */ 
#line 4608
  ip->opcode = (OPCODE )80;
#line 4609
  return (ip);
  case_16: /* CIL Label */ 
#line 4611
  ip->opcode = (OPCODE )79;
#line 4612
  return (ip);
  switch_default: /* CIL Label */ 
#line 4614
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4616
  return ((INSTRUCTION *)((void *)0));
}
}
#line 4621 "awkgram.y"
NODE *stopme(int nargs  __attribute__((__unused__)) ) 
{ 
  NODE *tmp___1 ;

  {
  {
#line 4624
  tmp___1 = (*make_number)(0.0);
  }
#line 4624
  return (tmp___1);
}
}
#line 4629 "awkgram.y"
static void dumpintlstr(char const   *str , size_t len ) 
{ 
  char *cp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 4636
  if ((unsigned long )source != (unsigned long )((void *)0)) {
#line 4638
    cp = source;
    {
#line 4638
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4638
      if ((int )*(cp + 0) == 46) {
#line 4638
        if (! ((int )*(cp + 1) == 47)) {
#line 4638
          goto while_break;
        }
      } else {
#line 4638
        goto while_break;
      }
#line 4639
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 4638
      cp += 2;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4640
    printf((char const   */* __restrict  */)"#: %s:%d\n", cp, sourceline);
    }
  }
  {
#line 4643
  printf((char const   */* __restrict  */)"msgid ");
#line 4644
  pp_string_fp((int (*)(FILE * , char const   *  , ...))(& fprintf), stdout, str,
               len, '\"', (_Bool)1);
#line 4645
  putchar('\n');
#line 4646
  printf((char const   */* __restrict  */)"msgstr \"\"\n\n");
#line 4647
  fflush(stdout);
  }
#line 4648
  return;
}
}
#line 4652 "awkgram.y"
static void dumpintlstr2(char const   *str1 , size_t len1 , char const   *str2 , size_t len2 ) 
{ 
  char *cp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 4659
  if ((unsigned long )source != (unsigned long )((void *)0)) {
#line 4661
    cp = source;
    {
#line 4661
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4661
      if ((int )*(cp + 0) == 46) {
#line 4661
        if (! ((int )*(cp + 1) == 47)) {
#line 4661
          goto while_break;
        }
      } else {
#line 4661
        goto while_break;
      }
#line 4662
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 4661
      cp += 2;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4663
    printf((char const   */* __restrict  */)"#: %s:%d\n", cp, sourceline);
    }
  }
  {
#line 4666
  printf((char const   */* __restrict  */)"msgid ");
#line 4667
  pp_string_fp((int (*)(FILE * , char const   *  , ...))(& fprintf), stdout, str1,
               len1, '\"', (_Bool)1);
#line 4668
  putchar('\n');
#line 4669
  printf((char const   */* __restrict  */)"msgid_plural ");
#line 4670
  pp_string_fp((int (*)(FILE * , char const   *  , ...))(& fprintf), stdout, str2,
               len2, '\"', (_Bool)1);
#line 4671
  putchar('\n');
#line 4672
  printf((char const   */* __restrict  */)"msgstr[0] \"\"\nmsgstr[1] \"\"\n\n");
#line 4673
  fflush(stdout);
  }
#line 4674
  return;
}
}
#line 4678 "awkgram.y"
static INSTRUCTION *mk_binary(INSTRUCTION *s1 , INSTRUCTION *s2 , INSTRUCTION *op ) 
{ 
  INSTRUCTION *ip1 ;
  INSTRUCTION *ip2 ;
  double res ;
  NODE *n1 ;
  NODE *n2 ;
  NODE *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  INSTRUCTION *tmp___4 ;
  INSTRUCTION *tmp___5 ;
  INSTRUCTION *tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 4684
  ip2 = s2->nexti;
#line 4685
  if ((unsigned long )s2->d.di == (unsigned long )ip2) {
#line 4685
    if ((unsigned int )ip2->opcode == 74U) {
#line 4687
      ip1 = s1->nexti;
#line 4688
      if ((int )do_optimize > 1) {
#line 4688
        if ((unsigned long )ip1 == (unsigned long )s1->d.di) {
#line 4688
          if ((unsigned int )ip1->opcode == 74U) {
#line 4688
            if (((ip1->d.dn)->flags & 6150U) == 0U) {
#line 4688
              if (((ip2->d.dn)->flags & 6150U) == 0U) {
                {
#line 4693
                n1 = ip1->d.dn;
#line 4693
                n2 = ip2->d.dn;
#line 4694
                tmp___1 = force_number(n1);
#line 4694
                res = tmp___1->sub.val.nm.fltnum;
#line 4695
                force_number(n2);
                }
                {
#line 4697
                if ((unsigned int )op->opcode == 1U) {
#line 4697
                  goto case_1;
                }
#line 4700
                if ((unsigned int )op->opcode == 3U) {
#line 4700
                  goto case_3;
                }
#line 4709
                if ((unsigned int )op->opcode == 5U) {
#line 4709
                  goto case_5;
                }
#line 4722
                if ((unsigned int )op->opcode == 7U) {
#line 4722
                  goto case_7;
                }
#line 4725
                if ((unsigned int )op->opcode == 9U) {
#line 4725
                  goto case_9;
                }
#line 4728
                if ((unsigned int )op->opcode == 11U) {
#line 4728
                  goto case_11;
                }
#line 4731
                goto switch_default;
                case_1: /* CIL Label */ 
#line 4698
                res *= n2->sub.val.nm.fltnum;
#line 4699
                goto switch_break;
                case_3: /* CIL Label */ 
#line 4701
                if (n2->sub.val.nm.fltnum == 0.0) {
                  {
#line 4703
                  tmp___2 = gettext("division by zero attempted");
#line 4703
                  error_ln((int )op->source_line, (char const   *)tmp___2);
                  }
#line 4704
                  goto regular;
                }
#line 4707
                res /= n2->sub.val.nm.fltnum;
#line 4708
                goto switch_break;
                case_5: /* CIL Label */ 
#line 4710
                if (n2->sub.val.nm.fltnum == 0.0) {
                  {
#line 4712
                  tmp___3 = gettext("division by zero attempted in `%%\'");
#line 4712
                  error_ln((int )op->source_line, (char const   *)tmp___3);
                  }
#line 4713
                  goto regular;
                }
                {
#line 4716
                res = fmod(res, n2->sub.val.nm.fltnum);
                }
#line 4721
                goto switch_break;
                case_7: /* CIL Label */ 
#line 4723
                res += n2->sub.val.nm.fltnum;
#line 4724
                goto switch_break;
                case_9: /* CIL Label */ 
#line 4726
                res -= n2->sub.val.nm.fltnum;
#line 4727
                goto switch_break;
                case_11: /* CIL Label */ 
                {
#line 4729
                res = calc_exp(res, n2->sub.val.nm.fltnum);
                }
#line 4730
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 4732
                goto regular;
                switch_break: /* CIL Label */ ;
                }
                {
#line 4735
                op->opcode = (OPCODE )74;
#line 4736
                op->d.dn = (*make_number)(res);
#line 4737
                unref(n1);
#line 4738
                unref(n2);
#line 4739
                bcfree(ip1);
#line 4740
                bcfree(ip2);
#line 4741
                bcfree(s1);
#line 4742
                bcfree(s2);
#line 4743
                tmp___4 = list_create(op);
                }
#line 4743
                return (tmp___4);
              } else {
#line 4688
                goto _L___2;
              }
            } else {
#line 4688
              goto _L___2;
            }
          } else {
#line 4688
            goto _L___2;
          }
        } else {
#line 4688
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        {
#line 4748
        if ((unsigned int )op->opcode == 1U) {
#line 4748
          goto case_1___0;
        }
#line 4751
        if ((unsigned int )op->opcode == 3U) {
#line 4751
          goto case_3___0;
        }
#line 4754
        if ((unsigned int )op->opcode == 5U) {
#line 4754
          goto case_5___0;
        }
#line 4757
        if ((unsigned int )op->opcode == 7U) {
#line 4757
          goto case_7___0;
        }
#line 4760
        if ((unsigned int )op->opcode == 9U) {
#line 4760
          goto case_9___0;
        }
#line 4763
        if ((unsigned int )op->opcode == 11U) {
#line 4763
          goto case_11___0;
        }
#line 4766
        goto switch_default___0;
        case_1___0: /* CIL Label */ 
#line 4749
        op->opcode = (OPCODE )2;
#line 4750
        goto switch_break___0;
        case_3___0: /* CIL Label */ 
#line 4752
        op->opcode = (OPCODE )4;
#line 4753
        goto switch_break___0;
        case_5___0: /* CIL Label */ 
#line 4755
        op->opcode = (OPCODE )6;
#line 4756
        goto switch_break___0;
        case_7___0: /* CIL Label */ 
#line 4758
        op->opcode = (OPCODE )8;
#line 4759
        goto switch_break___0;
        case_9___0: /* CIL Label */ 
#line 4761
        op->opcode = (OPCODE )10;
#line 4762
        goto switch_break___0;
        case_11___0: /* CIL Label */ 
#line 4764
        op->opcode = (OPCODE )12;
#line 4765
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4767
        goto regular;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 4770
        op->d.dn = ip2->d.dn;
#line 4771
        bcfree(ip2);
#line 4772
        bcfree(s2);
#line 4773
        tmp___5 = list_append(s1, op);
        }
#line 4773
        return (tmp___5);
      }
    }
  }
  regular: 
  {
#line 4779
  list_merge(s1, s2);
#line 4780
  tmp___6 = list_append(s1, op);
  }
#line 4780
  return (tmp___6);
}
}
#line 4785 "awkgram.y"
static INSTRUCTION *mk_boolean(INSTRUCTION *left , INSTRUCTION *right , INSTRUCTION *op ) 
{ 
  INSTRUCTION *tp ;
  OPCODE opc ;
  OPCODE final_opc ;
  INSTRUCTION *tmp___1 ;
  INSTRUCTION *ip ;
  INSTRUCTION *tmp___2 ;

  {
#line 4791
  opc = op->opcode;
#line 4792
  if ((unsigned int )opc == 38U) {
#line 4792
    final_opc = (OPCODE )39;
  } else {
#line 4792
    final_opc = (OPCODE )37;
  }
  {
#line 4794
  add_lint(right, (LINTTYPE )1);
#line 4796
  tp = left->d.di;
  }
#line 4798
  if ((unsigned int )tp->opcode != (unsigned int )final_opc) {
    {
#line 4799
    tmp___1 = bcalloc(final_opc, 1, 0);
#line 4799
    list_append(right, tmp___1);
#line 4800
    add_lint(left, (LINTTYPE )1);
#line 4801
    list_append(left, op);
#line 4802
    (left->d.di)->d.di = right->d.di;
#line 4808
    (left->d.di)->x.xi = left->d.di;
#line 4809
    (right->d.di)->x.xi = left->d.di;
    }
  } else {
    {
#line 4813
    op->opcode = final_opc;
#line 4814
    list_append(right, op);
#line 4815
    op->x.xi = tp;
#line 4816
    tp->opcode = opc;
#line 4817
    tp->d.di = op;
#line 4820
    ip = tp->x.xi;
    }
    {
#line 4820
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4824
      ip->d.di = op;
#line 4825
      if ((unsigned long )ip->x.xi == (unsigned long )ip) {
#line 4826
        goto while_break;
      }
#line 4820
      ip = ip->x.xi;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 4830
  tmp___2 = list_merge(left, right);
  }
#line 4830
  return (tmp___2);
}
}
#line 4835 "awkgram.y"
static INSTRUCTION *mk_condition(INSTRUCTION *cond , INSTRUCTION *ifp , INSTRUCTION *true_branch ,
                                 INSTRUCTION *elsep , INSTRUCTION *false_branch ) 
{ 
  INSTRUCTION *ip ;
  INSTRUCTION *tmp___1 ;
  INSTRUCTION *tmp___2 ;
  INSTRUCTION *tmp___3 ;
  INSTRUCTION *tmp___4 ;
  INSTRUCTION *tmp___5 ;
  INSTRUCTION *tmp___6 ;
  INSTRUCTION *tmp___7 ;

  {
#line 4859
  if ((unsigned long )false_branch == (unsigned long )((void *)0)) {
    {
#line 4860
    tmp___1 = bcalloc((OPCODE )81, 1, 0);
#line 4860
    false_branch = list_create(tmp___1);
    }
#line 4861
    if ((unsigned long )elsep != (unsigned long )((void *)0)) {
#line 4862
      if (do_flags & 256) {
        {
#line 4863
        list_prepend(false_branch, elsep);
        }
      } else {
        {
#line 4865
        bcfree(elsep);
        }
      }
    }
  } else {
#line 4871
    if ((unsigned int )(false_branch->d.di)->opcode != 81U) {
      {
#line 4872
      tmp___2 = bcalloc((OPCODE )81, 1, 0);
#line 4872
      list_append(false_branch, tmp___2);
      }
    }
#line 4873
    if (do_flags & 256) {
      {
#line 4874
      list_prepend(false_branch, elsep);
#line 4875
      (false_branch->nexti)->x.xi = false_branch->d.di;
#line 4876
      tmp___3 = bcalloc((OPCODE )98, 1, 0);
#line 4876
      list_prepend(false_branch, tmp___3);
      }
    } else {
      {
#line 4878
      bcfree(elsep);
      }
    }
  }
  {
#line 4881
  tmp___4 = bcalloc((OPCODE )83, 1, 0);
#line 4881
  list_prepend(false_branch, tmp___4);
#line 4882
  (false_branch->nexti)->d.di = false_branch->d.di;
#line 4884
  add_lint(cond, (LINTTYPE )1);
#line 4885
  tmp___5 = bcalloc((OPCODE )85, 1, 0);
#line 4885
  ip = list_append(cond, tmp___5);
#line 4886
  (ip->d.di)->d.di = (false_branch->nexti)->nexti;
  }
#line 4888
  if (do_flags & 256) {
    {
#line 4889
    list_prepend(ip, ifp);
#line 4890
    tmp___6 = bcalloc((OPCODE )98, 1, 0);
#line 4890
    list_append(ip, tmp___6);
#line 4891
    (ip->nexti)->d.di = ip->d.di;
#line 4892
    (ip->nexti)->x.xi = false_branch->nexti;
    }
  } else {
    {
#line 4894
    bcfree(ifp);
    }
  }
#line 4896
  if ((unsigned long )true_branch != (unsigned long )((void *)0)) {
    {
#line 4897
    list_merge(ip, true_branch);
    }
  }
  {
#line 4898
  tmp___7 = list_merge(ip, false_branch);
  }
#line 4898
  return (tmp___7);
}
}
#line 4905 "awkgram.y"
static int find_line(INSTRUCTION *pattern , enum defline what ) 
{ 
  INSTRUCTION *ip ;
  int lineno ;

  {
#line 4909
  lineno = 0;
#line 4911
  ip = pattern->nexti;
  {
#line 4911
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4911
    if (! ip) {
#line 4911
      goto while_break;
    }
#line 4912
    if ((unsigned int )what == 1U) {
#line 4913
      if ((int )ip->source_line > lineno) {
#line 4914
        lineno = (int )ip->source_line;
      }
    } else
#line 4916
    if ((int )ip->source_line > 0) {
#line 4916
      if (lineno == 0) {
#line 4918
        lineno = (int )ip->source_line;
      } else
#line 4916
      if ((int )ip->source_line < lineno) {
#line 4918
        lineno = (int )ip->source_line;
      }
    }
#line 4920
    if ((unsigned long )ip == (unsigned long )pattern->d.di) {
#line 4921
      goto while_break;
    }
#line 4911
    ip = ip->nexti;
  }
  while_break: /* CIL Label */ ;
  }
#line 4924
  return (lineno);
}
}
#line 4929 "awkgram.y"
static INSTRUCTION *append_rule(INSTRUCTION *pattern , INSTRUCTION *action ) 
{ 
  INSTRUCTION *rp ;
  INSTRUCTION *tp ;
  INSTRUCTION *ip ;
  INSTRUCTION *tmp___1 ;
  INSTRUCTION *tmp___2 ;
  INSTRUCTION *tmp___3 ;
  INSTRUCTION *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  INSTRUCTION *tmp___7 ;
  INSTRUCTION *tmp___8 ;
  INSTRUCTION *tmp___9 ;
  INSTRUCTION *tmp___10 ;
  INSTRUCTION *tmp___11 ;
  INSTRUCTION *tmp___12 ;

  {
#line 4948
  if (rule != 2) {
#line 4949
    rp = pattern;
#line 4950
    if (do_flags & 256) {
      {
#line 4951
      tmp___1 = bcalloc((OPCODE )81, 1, 0);
#line 4951
      list_append(action, tmp___1);
      }
    }
    {
#line 4952
    (rp + 1)->x.xi = action->nexti;
#line 4953
    (rp + 1)->d.di = action->d.di;
#line 4954
    (rp + 2)->source_line = pattern->source_line;
#line 4955
    (rp + 2)->x.xl = (long )lastline;
#line 4956
    ip = list_prepend(action, rp);
    }
  } else {
    {
#line 4959
    rp = bcalloc((OPCODE )49, 3, 0);
#line 4960
    rp->x.xl = 2L;
#line 4961
    rp->d.name = source;
#line 4962
    tp = bcalloc((OPCODE )81, 1, 0);
    }
#line 4964
    if ((unsigned long )pattern == (unsigned long )((void *)0)) {
#line 4966
      if (do_flags & 256) {
        {
#line 4967
        tmp___2 = bcalloc((OPCODE )98, 1, 0);
#line 4967
        list_prepend(action, tmp___2);
        }
      }
      {
#line 4968
      (rp + 1)->x.xi = action->nexti;
#line 4969
      (rp + 1)->d.di = tp;
#line 4970
      (rp + 2)->source_line = (short )firstline;
#line 4971
      (rp + 2)->x.xl = (long )lastline;
#line 4972
      rp->source_line = (short )firstline;
#line 4973
      tmp___3 = list_append(action, tp);
#line 4973
      ip = list_prepend(tmp___3, rp);
      }
    } else {
      {
#line 4975
      tmp___4 = bcalloc((OPCODE )85, 1, 0);
#line 4975
      list_append(pattern, tmp___4);
#line 4976
      (pattern->d.di)->d.di = tp;
#line 4977
      tmp___5 = find_line(pattern, (enum defline )0);
#line 4977
      (rp + 2)->source_line = (short )tmp___5;
#line 4978
      rp->source_line = (rp + 2)->source_line;
      }
#line 4979
      if ((unsigned long )action == (unsigned long )((void *)0)) {
        {
#line 4980
        tmp___6 = find_line(pattern, (enum defline )1);
#line 4980
        (rp + 2)->x.xl = (long )tmp___6;
#line 4981
        tmp___7 = bcalloc((OPCODE )55, 1, 0);
#line 4981
        action = list_create(tmp___7);
        }
#line 4982
        if (do_flags & 256) {
          {
#line 4983
          tmp___8 = bcalloc((OPCODE )98, 1, 0);
#line 4983
          list_prepend(action, tmp___8);
          }
        }
      } else {
#line 4985
        (rp + 2)->x.xl = (long )lastline;
      }
#line 4987
      if (do_flags & 256) {
        {
#line 4988
        tmp___9 = bcalloc((OPCODE )98, 1, 0);
#line 4988
        list_prepend(pattern, tmp___9);
#line 4989
        tmp___10 = bcalloc((OPCODE )98, 1, 0);
#line 4989
        list_prepend(action, tmp___10);
        }
      }
      {
#line 4991
      (rp + 1)->x.xi = action->nexti;
#line 4992
      (rp + 1)->d.di = tp;
#line 4993
      tmp___11 = list_prepend(pattern, rp);
#line 4993
      tmp___12 = list_merge(tmp___11, action);
#line 4993
      ip = list_append(tmp___12, tp);
      }
    }
  }
  {
#line 5001
  list_append(rule_list, rp + 1);
  }
#line 5003
  if ((unsigned long )rule_block[rule] == (unsigned long )((void *)0)) {
#line 5004
    rule_block[rule] = ip;
  } else {
    {
#line 5006
    list_merge(rule_block[rule], ip);
    }
  }
#line 5008
  return (rule_block[rule]);
}
}
#line 5013 "awkgram.y"
static INSTRUCTION *mk_assignment(INSTRUCTION *lhs , INSTRUCTION *rhs , INSTRUCTION *op ) 
{ 
  INSTRUCTION *tp ;
  INSTRUCTION *ip ;
  INSTRUCTION *tmp___1 ;
  INSTRUCTION *tmp___2 ;
  INSTRUCTION *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 5019
  tp = lhs->d.di;
  {
#line 5021
  if ((unsigned int )tp->opcode == 23U) {
#line 5021
    goto case_23;
  }
#line 5024
  if ((unsigned int )tp->opcode == 16U) {
#line 5024
    goto case_16;
  }
#line 5028
  if ((unsigned int )tp->opcode == 76U) {
#line 5028
    goto case_76;
  }
#line 5028
  if ((unsigned int )tp->opcode == 72U) {
#line 5028
    goto case_76;
  }
#line 5031
  goto switch_default;
  case_23: /* CIL Label */ 
#line 5022
  tp->opcode = (OPCODE )80;
#line 5023
  goto switch_break;
  case_16: /* CIL Label */ 
#line 5025
  tp->opcode = (OPCODE )79;
#line 5026
  goto switch_break;
  case_76: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 5029
  tp->opcode = (OPCODE )78;
#line 5030
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 5032
  r_fatal("internal error line %d, file: %s", 5032, "awkgram.y");
  }
  switch_break: /* CIL Label */ ;
  }
#line 5035
  tp->x.xl = (long )((unsigned int )op->opcode != 25U);
#line 5037
  if ((unsigned long )rhs != (unsigned long )((void *)0)) {
    {
#line 5038
    ip = list_merge(rhs, lhs);
    }
  } else {
#line 5040
    ip = lhs;
  }
  {
#line 5042
  list_append(ip, op);
  }
#line 5044
  if ((unsigned int )tp->opcode == 78U) {
#line 5044
    if ((unsigned int )(tp->d.dn)->type == 4U) {
#line 5044
      if ((tp->d.dn)->sub.nodep.x.aptr) {
        {
#line 5048
        tp->x.xl = 0L;
#line 5051
        tmp___1 = bcalloc((OPCODE )92, 1, 0);
#line 5051
        list_append(ip, tmp___1);
#line 5052
        (ip->d.di)->x.aptr = (tp->d.dn)->sub.nodep.x.aptr;
        }
      } else {
#line 5044
        goto _L___0;
      }
    } else {
#line 5044
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 5053
  if ((unsigned int )tp->opcode == 80U) {
    {
#line 5054
    tmp___2 = bcalloc((OPCODE )93, 1, 0);
#line 5054
    list_append(ip, tmp___2);
#line 5055
    (ip->d.di)->x.aptr = (void (*)(void))0;
#line 5056
    tp->d.di = ip->d.di;
    }
  } else
#line 5057
  if ((unsigned int )tp->opcode == 79U) {
    {
#line 5058
    tmp___3 = bcalloc((OPCODE )94, 1, 0);
#line 5058
    list_append(ip, tmp___3);
    }
  }
#line 5061
  return (ip);
}
}
#line 5066 "awkgram.y"
static INSTRUCTION *optimize_assignment(INSTRUCTION *exp___0 ) 
{ 
  INSTRUCTION *i1 ;
  INSTRUCTION *i2 ;
  INSTRUCTION *i3 ;
  INSTRUCTION *tmp___1 ;
  INSTRUCTION *tmp___2 ;
  INSTRUCTION *tmp___3 ;
  INSTRUCTION *tmp___4 ;
  INSTRUCTION *tmp___5 ;
  INSTRUCTION *tmp___6 ;

  {
#line 5099
  i2 = (INSTRUCTION *)((void *)0);
#line 5100
  i1 = exp___0->d.di;
#line 5102
  if (! do_optimize) {
    {
#line 5106
    tmp___1 = bcalloc((OPCODE )82, 1, 0);
#line 5106
    tmp___2 = list_append(exp___0, tmp___1);
    }
#line 5106
    return (tmp___2);
  } else
#line 5102
  if ((unsigned int )i1->opcode != 25U) {
#line 5102
    if ((unsigned int )i1->opcode != 93U) {
      {
#line 5106
      tmp___1 = bcalloc((OPCODE )82, 1, 0);
#line 5106
      tmp___2 = list_append(exp___0, tmp___1);
      }
#line 5106
      return (tmp___2);
    }
  }
#line 5108
  i2 = exp___0->nexti;
  {
#line 5108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5108
    if (! ((unsigned long )i2 != (unsigned long )i1)) {
#line 5108
      goto while_break;
    }
    {
#line 5110
    if ((unsigned int )i2->opcode == 13U) {
#line 5110
      goto case_13;
    }
#line 5151
    if ((unsigned int )i2->opcode == 80U) {
#line 5151
      goto case_80;
    }
#line 5166
    if ((unsigned int )i2->opcode == 76U) {
#line 5166
      goto case_76;
    }
#line 5188
    if ((unsigned int )i2->opcode == 78U) {
#line 5188
      goto case_78;
    }
#line 5214
    goto switch_default;
    case_13: /* CIL Label */ 
#line 5111
    if ((unsigned int )(i2->nexti)->opcode == 78U) {
#line 5111
      if (i2->d.dl & 2L) {
#line 5111
        if ((unsigned long )(i2->nexti)->d.dn == (unsigned long )(exp___0->nexti)->d.dn) {
#line 5111
          if ((unsigned long )(i2->nexti)->nexti == (unsigned long )i1) {
#line 5111
            if ((unsigned int )i1->opcode == 25U) {
#line 5127
              i3 = (exp___0->nexti)->nexti;
              {
#line 5127
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 5127
                if (! ((unsigned long )i3 != (unsigned long )i2)) {
#line 5127
                  goto while_break___0;
                }
#line 5128
                if ((unsigned int )i3->opcode == 78U) {
#line 5128
                  if ((unsigned long )i3->d.dn == (unsigned long )(i2->nexti)->d.dn) {
                    {
#line 5130
                    tmp___3 = bcalloc((OPCODE )82, 1, 0);
#line 5130
                    tmp___4 = list_append(exp___0, tmp___3);
                    }
#line 5130
                    return (tmp___4);
                  } else {
#line 5128
                    goto _L;
                  }
                } else
                _L: /* CIL Label */ 
#line 5128
                if ((unsigned int )i3->opcode == 70U) {
                  {
#line 5130
                  tmp___3 = bcalloc((OPCODE )82, 1, 0);
#line 5130
                  tmp___4 = list_append(exp___0, tmp___3);
                  }
#line 5130
                  return (tmp___4);
                }
#line 5127
                i3 = i3->nexti;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 5134
              i3 = exp___0->nexti;
#line 5135
              exp___0->nexti = i3->nexti;
#line 5136
              bcfree(i3);
#line 5138
              (i2->x.xl) --;
              }
#line 5138
              if (i2->x.xl == 1L) {
#line 5139
                i2->opcode = (OPCODE )81;
              }
              {
#line 5141
              i3 = i2->nexti;
#line 5143
              i3->opcode = (OPCODE )35;
#line 5144
              i3->nexti = (struct exp_instruction *)((void *)0);
#line 5145
              bcfree(i1);
#line 5146
              exp___0->d.di = i3;
              }
#line 5147
              return (exp___0);
            }
          }
        }
      }
    }
#line 5149
    goto switch_break;
    case_80: /* CIL Label */ 
#line 5152
    if ((unsigned int )(i2->nexti)->opcode == 25U) {
#line 5152
      if ((unsigned long )(i2->nexti)->nexti == (unsigned long )i1) {
#line 5152
        if ((unsigned int )i1->opcode == 93U) {
          {
#line 5157
          i2->opcode = (OPCODE )28;
#line 5158
          bcfree(i2->nexti);
#line 5159
          i2->nexti = (struct exp_instruction *)((void *)0);
#line 5160
          bcfree(i1);
#line 5161
          exp___0->d.di = i2;
          }
#line 5162
          return (exp___0);
        }
      }
    }
#line 5164
    goto switch_break;
    case_76: /* CIL Label */ 
#line 5167
    if ((unsigned int )((i2->nexti)->nexti)->opcode == 79U) {
#line 5168
      i3 = (i2->nexti)->nexti;
#line 5169
      if (i3->d.dl == 1L) {
#line 5169
        if ((unsigned long )i3->nexti == (unsigned long )i1) {
#line 5169
          if ((unsigned int )i1->opcode == 25U) {
            {
#line 5174
            i3->opcode = (OPCODE )27;
#line 5175
            i3->d.dn = i2->d.dn;
#line 5176
            i3->x.xl = 1L;
#line 5179
            i3->nexti = (struct exp_instruction *)((void *)0);
#line 5180
            i2->opcode = (OPCODE )81;
#line 5181
            bcfree(i1);
#line 5182
            exp___0->d.di = i3;
            }
#line 5183
            return (exp___0);
          }
        }
      }
    }
#line 5186
    goto switch_break;
    case_78: /* CIL Label */ 
#line 5189
    if ((unsigned long )i2->nexti == (unsigned long )i1) {
#line 5189
      if ((unsigned int )i1->opcode == 25U) {
        {
#line 5193
        i2->opcode = (OPCODE )26;
#line 5194
        i2->nexti = (struct exp_instruction *)((void *)0);
#line 5195
        bcfree(i1);
#line 5196
        exp___0->d.di = i2;
#line 5198
        i3 = exp___0->nexti;
        }
#line 5199
        if ((unsigned int )i3->opcode == 74U) {
#line 5199
          if (((i3->d.dn)->flags & 128U) == 0U) {
#line 5199
            if ((unsigned long )i3->nexti == (unsigned long )i2) {
              {
#line 5204
              i2->x.xn = i3->d.dn;
#line 5205
              bcfree(i3);
#line 5206
              exp___0->nexti = i2;
              }
            } else {
#line 5208
              i2->x.xn = (NODE *)((void *)0);
            }
          } else {
#line 5208
            i2->x.xn = (NODE *)((void *)0);
          }
        } else {
#line 5208
          i2->x.xn = (NODE *)((void *)0);
        }
#line 5210
        return (exp___0);
      }
    }
#line 5212
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5215
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5108
    i2 = i2->nexti;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5220
  tmp___5 = bcalloc((OPCODE )82, 1, 0);
#line 5220
  tmp___6 = list_append(exp___0, tmp___5);
  }
#line 5220
  return (tmp___6);
}
}
#line 5226 "awkgram.y"
static INSTRUCTION *mk_getline(INSTRUCTION *op , INSTRUCTION *var , INSTRUCTION *redir ,
                               int redirtype ) 
{ 
  INSTRUCTION *ip ;
  INSTRUCTION *tp ;
  INSTRUCTION *asgn ;
  int sline ;
  INSTRUCTION *tmp___1 ;
  INSTRUCTION *tmp___2 ;

  {
#line 5231
  asgn = (INSTRUCTION *)((void *)0);
#line 5243
  if ((unsigned long )redir == (unsigned long )((void *)0)) {
    {
#line 5244
    sline = (int )op->source_line;
#line 5245
    bcfree(op);
#line 5246
    op = bcalloc((OPCODE )63, 2, sline);
#line 5247
    (op + 1)->x.xi = ip_endfile;
#line 5248
    (op + 1)->d.di = ip_beginfile;
    }
  }
#line 5251
  if ((unsigned long )var != (unsigned long )((void *)0)) {
    {
#line 5252
    tp = make_assignable(var->d.di);
    }
#line 5256
    if ((unsigned int )tp->opcode == 78U) {
#line 5256
      if ((unsigned int )(tp->d.dn)->type == 4U) {
#line 5256
        if ((tp->d.dn)->sub.nodep.x.aptr) {
          {
#line 5260
          asgn = bcalloc((OPCODE )92, 1, 0);
#line 5261
          asgn->d.dl = (long )op->opcode;
#line 5262
          asgn->x.aptr = (tp->d.dn)->sub.nodep.x.aptr;
          }
        } else {
#line 5256
          goto _L___0;
        }
      } else {
#line 5256
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 5263
    if ((unsigned int )tp->opcode == 80U) {
      {
#line 5264
      asgn = bcalloc((OPCODE )93, 1, 0);
#line 5265
      asgn->d.dl = (long )op->opcode;
#line 5266
      asgn->x.aptr = (void (*)(void))0;
#line 5267
      tp->d.di = asgn;
      }
    } else
#line 5268
    if ((unsigned int )tp->opcode == 79U) {
      {
#line 5269
      asgn = bcalloc((OPCODE )94, 1, 0);
#line 5270
      asgn->d.dl = (long )op->opcode;
      }
    }
#line 5273
    if ((unsigned long )redir != (unsigned long )((void *)0)) {
      {
#line 5274
      ip = list_merge(redir, var);
#line 5275
      list_append(ip, op);
      }
    } else {
      {
#line 5277
      ip = list_append(var, op);
      }
    }
  } else
#line 5278
  if ((unsigned long )redir != (unsigned long )((void *)0)) {
    {
#line 5279
    ip = list_append(redir, op);
    }
  } else {
    {
#line 5281
    ip = list_create(op);
    }
  }
#line 5282
  op->x.xl = (long )((unsigned long )var != (unsigned long )((void *)0));
#line 5283
  if ((unsigned long )redir != (unsigned long )((void *)0)) {
#line 5283
    op->d.dl = (long )redirtype;
  } else {
#line 5283
    op->d.dl = 0L;
  }
#line 5285
  if ((unsigned long )asgn == (unsigned long )((void *)0)) {
#line 5285
    tmp___2 = ip;
  } else {
    {
#line 5285
    tmp___1 = list_append(ip, asgn);
#line 5285
    tmp___2 = tmp___1;
    }
  }
#line 5285
  return (tmp___2);
}
}
#line 5291 "awkgram.y"
static INSTRUCTION *mk_for_loop(INSTRUCTION *forp , INSTRUCTION *init , INSTRUCTION *cond ,
                                INSTRUCTION *incr , INSTRUCTION *body ) 
{ 
  INSTRUCTION *ip ;
  INSTRUCTION *tbreak ;
  INSTRUCTION *tcont ;
  INSTRUCTION *jmp ;
  INSTRUCTION *pp_cond ;
  INSTRUCTION *ret ;
  INSTRUCTION *tmp___1 ;
  INSTRUCTION *tmp___2 ;

  {
  {
#line 5318
  tbreak = bcalloc((OPCODE )81, 1, 0);
  }
#line 5320
  if ((unsigned long )cond != (unsigned long )((void *)0)) {
    {
#line 5321
    add_lint(cond, (LINTTYPE )1);
#line 5322
    pp_cond = cond->nexti;
#line 5323
    ip = cond;
#line 5324
    tmp___1 = bcalloc((OPCODE )85, 1, 0);
#line 5324
    list_append(ip, tmp___1);
#line 5325
    (ip->d.di)->d.di = tbreak;
    }
  } else {
    {
#line 5327
    pp_cond = bcalloc((OPCODE )81, 1, 0);
#line 5328
    ip = list_create(pp_cond);
    }
  }
#line 5331
  if ((unsigned long )init != (unsigned long )((void *)0)) {
    {
#line 5332
    ip = list_merge(init, ip);
    }
  }
#line 5334
  if (do_flags & 256) {
    {
#line 5335
    tmp___2 = bcalloc((OPCODE )98, 1, 0);
#line 5335
    list_append(ip, tmp___2);
#line 5336
    (forp + 1)->d.di = pp_cond;
#line 5337
    (forp + 1)->x.xi = ip->d.di;
    }
  }
#line 5340
  if ((unsigned long )body != (unsigned long )((void *)0)) {
    {
#line 5341
    list_merge(ip, body);
    }
  }
  {
#line 5343
  jmp = bcalloc((OPCODE )83, 1, 0);
#line 5344
  jmp->d.di = pp_cond;
  }
#line 5345
  if ((unsigned long )incr == (unsigned long )((void *)0)) {
#line 5346
    tcont = jmp;
  } else {
    {
#line 5348
    tcont = incr->nexti;
#line 5349
    list_merge(ip, incr);
    }
  }
  {
#line 5352
  list_append(ip, jmp);
#line 5353
  ret = list_append(ip, tbreak);
#line 5354
  fix_break_continue(ret, tbreak, tcont);
  }
#line 5356
  if (do_flags & 256) {
    {
#line 5357
    forp->x.xi = tbreak;
#line 5358
    forp->d.di = tcont;
#line 5359
    ret = list_prepend(ret, forp);
    }
  }
#line 5363
  return (ret);
}
}
#line 5368 "awkgram.y"
static void add_lint(INSTRUCTION *list , LINTTYPE linttype ) 
{ 
  INSTRUCTION *ip ;
  INSTRUCTION *tmp___1 ;
  int tmp___2 ;
  INSTRUCTION *tmp___3 ;
  char *__cil_tmp7 ;

  {
  {
#line 5375
  if ((unsigned int )linttype == 1U) {
#line 5375
    goto case_1;
  }
#line 5389
  if ((unsigned int )linttype == 2U) {
#line 5389
    goto case_2;
  }
#line 5408
  goto switch_default;
  case_1: /* CIL Label */ 
#line 5376
  ip = list->d.di;
#line 5377
  if ((unsigned int )ip->opcode == 92U) {
#line 5377
    goto _L;
  } else
#line 5377
  if ((unsigned int )ip->opcode == 93U) {
    _L: /* CIL Label */ 
#line 5379
    ip = list->nexti;
    {
#line 5379
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5379
      if (! ((unsigned long )ip->nexti != (unsigned long )list->d.di)) {
#line 5379
        goto while_break;
      }
#line 5379
      ip = ip->nexti;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 5383
  if ((unsigned int )ip->opcode == 25U) {
    {
#line 5384
    tmp___1 = bcalloc((OPCODE )100, 1, 0);
#line 5384
    list_append(list, tmp___1);
#line 5385
    (list->d.di)->d.dl = (long )linttype;
    }
  } else
#line 5383
  if ((unsigned int )ip->opcode == 35U) {
    {
#line 5384
    tmp___1 = bcalloc((OPCODE )100, 1, 0);
#line 5384
    list_append(list, tmp___1);
#line 5385
    (list->d.di)->d.dl = (long )linttype;
    }
  }
#line 5387
  goto switch_break;
  case_2: /* CIL Label */ 
#line 5390
  if ((unsigned int )(list->d.di)->opcode == 82U) {
#line 5390
    if ((unsigned long )list->nexti != (unsigned long )list->d.di) {
#line 5391
      ip = list->nexti;
      {
#line 5391
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5391
        if (! ((unsigned long )ip->nexti != (unsigned long )list->d.di)) {
#line 5391
          goto while_break___0;
        }
#line 5391
        ip = ip->nexti;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 5394
      if (do_flags & 3) {
        {
#line 5396
        tmp___2 = isnoeffect(ip->opcode);
        }
#line 5396
        if (tmp___2) {
          {
#line 5397
          lintwarn_ln((int )ip->source_line, "statement may have no effect");
          }
        }
      }
#line 5401
      if ((unsigned int )ip->opcode == 72U) {
        {
#line 5402
        tmp___3 = bcalloc((OPCODE )100, 1, 0);
#line 5402
        list_append(list, tmp___3);
#line 5403
        (list->d.di)->d.dl = (long )linttype;
        }
      }
    }
  }
#line 5406
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5409
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5412
  return;
}
}
#line 5416 "awkgram.y"
static INSTRUCTION *mk_expression_list(INSTRUCTION *list , INSTRUCTION *s1 ) 
{ 
  INSTRUCTION *r ;

  {
#line 5438
  if ((unsigned long )list == (unsigned long )((void *)0)) {
    {
#line 5439
    list = bcalloc((OPCODE )105, 1, 0);
#line 5440
    list->nexti = s1;
#line 5441
    list->d.di = s1->d.di;
    }
#line 5442
    return (list);
  }
#line 5447
  r = list->d.di;
#line 5448
  r->nexti = s1;
#line 5449
  list->d.di = s1->d.di;
#line 5450
  return (list);
}
}
#line 5458 "awkgram.y"
static int count_expressions(INSTRUCTION **list , _Bool isarg ) 
{ 
  INSTRUCTION *expr ;
  INSTRUCTION *r ;
  int count ;
  INSTRUCTION *t1 ;
  INSTRUCTION *t2 ;

  {
#line 5462
  r = (INSTRUCTION *)((void *)0);
#line 5463
  count = 0;
#line 5465
  if ((unsigned long )*list == (unsigned long )((void *)0)) {
#line 5466
    return (0);
  }
#line 5468
  expr = (*list)->nexti;
  {
#line 5468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5468
    if (! expr) {
#line 5468
      goto while_break;
    }
#line 5470
    t1 = expr->nexti;
#line 5471
    t2 = expr->d.di;
#line 5472
    if (isarg) {
#line 5472
      if ((unsigned long )t1 == (unsigned long )t2) {
#line 5472
        if ((unsigned int )t1->opcode == 72U) {
#line 5473
          t1->opcode = (OPCODE )77;
        }
      }
    }
#line 5474
    count ++;
#line 5474
    if (count == 1) {
#line 5475
      r = expr;
    } else {
      {
#line 5477
      list_merge(r, expr);
      }
    }
#line 5478
    expr = t2->nexti;
  }
  while_break: /* CIL Label */ ;
  }
#line 5482
  if (! isarg) {
#line 5482
    if (count > max_args) {
#line 5483
      max_args = count;
    }
  }
  {
#line 5484
  bcfree(*list);
#line 5485
  *list = r;
  }
#line 5486
  return (count);
}
}
#line 5491 "awkgram.y"
static void fix_break_continue(INSTRUCTION *list , INSTRUCTION *b_target , INSTRUCTION *c_target ) 
{ 
  INSTRUCTION *ip ;

  {
#line 5496
  (list->d.di)->nexti = (struct exp_instruction *)((void *)0);
#line 5498
  ip = list->nexti;
  {
#line 5498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5498
    if (! ((unsigned long )ip != (unsigned long )((void *)0))) {
#line 5498
      goto while_break;
    }
    {
#line 5500
    if ((unsigned int )ip->opcode == 52U) {
#line 5500
      goto case_52;
    }
#line 5505
    if ((unsigned int )ip->opcode == 53U) {
#line 5505
      goto case_53;
    }
#line 5510
    goto switch_default;
    case_52: /* CIL Label */ 
#line 5501
    if ((unsigned long )ip->d.di == (unsigned long )((void *)0)) {
#line 5502
      ip->d.di = b_target;
    }
#line 5503
    goto switch_break;
    case_53: /* CIL Label */ 
#line 5506
    if ((unsigned long )ip->d.di == (unsigned long )((void *)0)) {
#line 5507
      ip->d.di = c_target;
    }
#line 5508
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5512
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5498
    ip = ip->nexti;
  }
  while_break: /* CIL Label */ ;
  }
#line 5515
  return;
}
}
#line 5517 "awkgram.y"
__inline static INSTRUCTION *list_create(INSTRUCTION *x ) 
{ 
  INSTRUCTION *l ;

  {
  {
#line 5522
  l = bcalloc((OPCODE )105, 1, 0);
#line 5523
  l->nexti = x;
#line 5524
  l->d.di = x;
  }
#line 5525
  return (l);
}
}
#line 5528 "awkgram.y"
__inline static INSTRUCTION *list_append(INSTRUCTION *l , INSTRUCTION *x ) 
{ 


  {
#line 5535
  (l->d.di)->nexti = x;
#line 5536
  l->d.di = x;
#line 5537
  return (l);
}
}
#line 5540 "awkgram.y"
__inline static INSTRUCTION *list_prepend(INSTRUCTION *l , INSTRUCTION *x ) 
{ 


  {
#line 5547
  x->nexti = l->nexti;
#line 5548
  l->nexti = x;
#line 5549
  return (l);
}
}
#line 5552 "awkgram.y"
__inline static INSTRUCTION *list_merge(INSTRUCTION *l1 , INSTRUCTION *l2 ) 
{ 


  {
  {
#line 5561
  (l1->d.di)->nexti = l2->nexti;
#line 5562
  l1->d.di = l2->d.di;
#line 5563
  bcfree(l2);
  }
#line 5564
  return (l1);
}
}
#line 5569 "awkgram.y"
int check_special(char const   *name ) 
{ 
  int low ;
  int high ;
  int mid ;
  int i___0 ;

  {
#line 5585
  low = 0;
#line 5586
  high = (int )(sizeof(tokentab) / sizeof(tokentab[0]) - 1UL);
  {
#line 5587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5587
    if (! (low <= high)) {
#line 5587
      goto while_break;
    }
#line 5588
    mid = (low + high) / 2;
#line 5589
    i___0 = (int )((int const   )*name - (int const   )*(tokentab[mid].operator + 0));
#line 5590
    if (i___0 == 0) {
      {
#line 5591
      i___0 = strcmp(name, (char const   *)tokentab[mid].operator);
      }
    }
#line 5593
    if (i___0 < 0) {
#line 5594
      high = mid - 1;
    } else
#line 5595
    if (i___0 > 0) {
#line 5596
      low = mid + 1;
    } else {
#line 5598
      if (do_flags & 8) {
#line 5598
        if (tokentab[mid].flags & 1024U) {
#line 5600
          return (-1);
        } else {
#line 5598
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 5598
      if (do_flags & 16) {
#line 5598
        if (tokentab[mid].flags & 512U) {
#line 5600
          return (-1);
        }
      }
#line 5601
      return (mid);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5604
  return (-1);
}
}
#line 5613 "awkgram.y"
static FILE *fp  =    (FILE *)((void *)0);
#line 5617 "awkgram.y"
static ssize_t read_one_line(int fd , void *buffer___0 , size_t count ) 
{ 
  char buf___7[8192] ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 5623
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 5624
    fp = fdopen(fd, "r");
    }
#line 5625
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 5626
      tmp___1 = __errno_location();
#line 5626
      tmp___2 = strerror(*tmp___1);
#line 5626
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ugh. fdopen: %s\n",
              tmp___2);
#line 5627
      gawk_exit(1);
      }
    }
  }
  {
#line 5631
  tmp___3 = fgets((char */* __restrict  */)(buf___7), (int )sizeof(buf___7), (FILE */* __restrict  */)fp);
  }
#line 5631
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 5632
    return ((ssize_t )0);
  }
  {
#line 5634
  tmp___4 = strlen((char const   *)(buf___7));
#line 5634
  memcpy((void */* __restrict  */)buffer___0, (void const   */* __restrict  */)(buf___7),
         tmp___4);
#line 5635
  tmp___5 = strlen((char const   *)(buf___7));
  }
#line 5635
  return ((ssize_t )tmp___5);
}
}
#line 5640 "awkgram.y"
static int one_line_close(int fd ) 
{ 
  int ret ;
  int tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 5645
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 5646
    set_loc("awkgram.y", 5646);
#line 5646
    r_fatal("debugging read/close screwed up!");
    }
  } else {
    {
#line 5645
    tmp___1 = fileno(fp);
    }
#line 5645
    if (fd != tmp___1) {
      {
#line 5646
      set_loc("awkgram.y", 5646);
#line 5646
      r_fatal("debugging read/close screwed up!");
      }
    }
  }
  {
#line 5648
  ret = fclose(fp);
#line 5649
  fp = (FILE *)((void *)0);
  }
#line 5650
  return (ret);
}
}
#line 1344 "/home/wslee/gnu_benchmarks/gawk-4.1.0/awk.h"
int register_array_func(afunc_t *afunc ) ;
#line 1346
NODE **null_afunc(NODE *symbol  __attribute__((__unused__)) , NODE *subs  __attribute__((__unused__)) ) ;
#line 1350
void assoc_dump(NODE *symbol , NODE *ndump___0 ) ;
#line 1355
NODE *do_adump(int nargs ) ;
#line 31 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static size_t SUBSEPlen  ;
#line 32 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static char *SUBSEP  ;
#line 33 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static char indent_char[5]  = {      (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'\000'};
#line 35
static NODE **null_lookup(NODE *symbol , NODE *subs ) ;
#line 36
static NODE **null_dump(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) ;
#line 37 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static afunc_t null_array_func[11]  = 
#line 37
  {      (struct exp_node **(*)(struct exp_node * , struct exp_node * ))0,      (struct exp_node **(*)(struct exp_node * , struct exp_node * ))0,      & null_length,      & null_lookup, 
        & null_afunc,      & null_afunc,      & null_afunc,      & null_afunc, 
        & null_afunc,      & null_dump,      (struct exp_node **(*)(struct exp_node * , struct exp_node * ))0};
#line 53 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static afunc_t *array_types[10]  ;
#line 54 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int num_array_types  =    0;
#line 61 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
int register_array_func(afunc_t *afunc ) 
{ 
  int tmp___1 ;

  {
#line 64
  if (afunc) {
#line 64
    if (num_array_types < 10) {
#line 65
      if ((unsigned long )afunc != (unsigned long )(str_array_func)) {
#line 65
        if (! *(afunc + 1)) {
#line 66
          return (0);
        }
      }
#line 67
      tmp___1 = num_array_types;
#line 67
      num_array_types ++;
#line 67
      array_types[tmp___1] = afunc;
#line 68
      if (*(afunc + 0)) {
        {
#line 69
        (*(*(afunc + 0)))((struct exp_node *)((void *)0), (struct exp_node *)((void *)0));
        }
      }
#line 70
      return (1);
    }
  }
#line 72
  return (0);
}
}
#line 78 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
void array_init(void) 
{ 


  {
  {
#line 81
  register_array_func(str_array_func);
  }
#line 82
  if (! (do_flags & 16384)) {
    {
#line 83
    register_array_func(int_array_func);
#line 84
    register_array_func(cint_array_func);
    }
  }
#line 86
  return;
}
}
#line 91 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE *make_array(void) 
{ 
  NODE *array ;
  void *tmp___1 ;

  {
#line 95
  array = (NODE *)nextfree[1].freep;
#line 95
  if (array) {
#line 95
    nextfree[1].freep = ((BLOCK *)array)->freep;
  } else {
    {
#line 95
    tmp___1 = more_blocks(1);
#line 95
    array = (NODE *)tmp___1;
    }
  }
  {
#line 96
  memset((void *)array, '\000', sizeof(NODE ));
#line 97
  array->type = (NODETYPE )5;
#line 98
  array->sub.nodep.l.lp = null_array_func;
  }
#line 101
  return (array);
}
}
#line 107 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
void null_array(NODE *symbol ) 
{ 
  unsigned long tmp___1 ;

  {
#line 110
  symbol->type = (NODETYPE )5;
#line 111
  symbol->sub.nodep.l.lp = null_array_func;
#line 112
  symbol->sub.nodep.r.bv = (BUCKET **)((void *)0);
#line 113
  tmp___1 = 0UL;
#line 113
  symbol->sub.nodep.cnt = tmp___1;
#line 113
  symbol->sub.nodep.reflags = tmp___1;
#line 114
  symbol->sub.nodep.reserved = (size_t )0;
#line 115
  symbol->flags = 0U;
#line 118
  return;
}
}
#line 123 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static NODE **null_lookup(NODE *symbol , NODE *subs ) 
{ 
  int i___0 ;
  afunc_t *afunc ;
  struct exp_node **tmp___1 ;
  struct exp_node **tmp___2 ;

  {
#line 127
  afunc = (afunc_t *)((void *)0);
#line 135
  i___0 = num_array_types - 1;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i___0 >= 1)) {
#line 135
      goto while_break;
    }
    {
#line 136
    afunc = array_types[i___0];
#line 137
    tmp___1 = (*(*(afunc + 1)))(symbol, subs);
    }
#line 137
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 138
      goto while_break;
    }
#line 135
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (i___0 == 0) {
#line 141
    afunc = array_types[0];
  } else
#line 140
  if ((unsigned long )afunc == (unsigned long )((void *)0)) {
#line 141
    afunc = array_types[0];
  }
  {
#line 142
  symbol->sub.nodep.l.lp = afunc;
#line 145
  tmp___2 = (*(*(symbol->sub.nodep.l.lp + 3)))(symbol, subs);
  }
#line 145
  return (tmp___2);
}
}
#line 153 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static NODE *tmp___0  ;
#line 150 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE **null_length(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) 
{ 


  {
#line 154
  tmp___0 = symbol;
#line 155
  return (& tmp___0);
}
}
#line 160 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE **null_afunc(NODE *symbol  __attribute__((__unused__)) , NODE *subs  __attribute__((__unused__)) ) 
{ 


  {
#line 163
  return ((NODE **)((void *)0));
}
}
#line 168 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static NODE **null_dump(NODE *symbol , NODE *subs  __attribute__((__unused__)) ) 
{ 
  char const   *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 171
  tmp___1 = array_vname((NODE const   *)symbol);
#line 171
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"array `%s\' is empty\n",
          tmp___1);
  }
#line 172
  return ((NODE **)((void *)0));
}
}
#line 178 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE *assoc_copy(NODE *symbol , NODE *newsymb ) 
{ 


  {
  {
#line 183
  (*(*(newsymb->sub.nodep.l.lp + 5)))(newsymb, (struct exp_node *)((void *)0));
#line 184
  (*(*(symbol->sub.nodep.l.lp + 8)))(symbol, newsymb);
#line 185
  newsymb->sub.nodep.l.lp = symbol->sub.nodep.l.lp;
#line 186
  newsymb->flags = symbol->flags;
  }
#line 187
  return (newsymb);
}
}
#line 193 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
void assoc_dump(NODE *symbol , NODE *ndump___0 ) 
{ 


  {
#line 196
  if (*(symbol->sub.nodep.l.lp + 9)) {
    {
#line 197
    (*(*(symbol->sub.nodep.l.lp + 9)))(symbol, ndump___0);
    }
  }
#line 198
  return;
}
}
#line 206 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static char *aname  =    (char *)((void *)0);
#line 207 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static size_t alen  ;
#line 208 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static size_t max_alen  ;
#line 203 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
char const   *make_aname(NODE const   *symbol ) 
{ 
  size_t slen ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 211
  if ((unsigned long )symbol->sub.nodep.x.extra != (unsigned long )((void *)0)) {
    {
#line 214
    make_aname((NODE const   *)symbol->sub.nodep.x.extra);
#line 215
    slen = strlen((char const   *)symbol->sub.nodep.name);
    }
#line 216
    if ((alen + slen) + 4UL > max_alen) {
      {
#line 217
      max_alen = ((alen + slen) + 4UL) + 256UL;
#line 218
      tmp___1 = realloc((void *)aname, (max_alen + 1UL) * sizeof(char *));
#line 218
      aname = (char *)tmp___1;
      }
#line 218
      if (aname) {
#line 218
        tmp___5 = 1;
      } else {
        {
#line 218
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 218);
#line 218
        tmp___2 = __errno_location();
#line 218
        tmp___3 = strerror(*tmp___2);
#line 218
        tmp___4 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 218
        r_fatal((char const   *)tmp___4, "make_aname", "aname", (long )((max_alen + 1UL) * sizeof(char *)),
                tmp___3);
#line 218
        tmp___5 = 0;
        }
      }
    }
    {
#line 220
    tmp___6 = sprintf((char */* __restrict  */)(aname + alen), (char const   */* __restrict  */)"[\"%s\"]",
                      symbol->sub.nodep.name);
#line 220
    alen += (size_t )tmp___6;
    }
  } else {
    {
#line 222
    alen = strlen((char const   *)symbol->sub.nodep.name);
    }
#line 223
    if ((unsigned long )aname == (unsigned long )((void *)0)) {
      {
#line 224
      max_alen = alen + 256UL;
#line 225
      tmp___7 = malloc((max_alen + 1UL) * sizeof(char *));
#line 225
      aname = (char *)tmp___7;
      }
#line 225
      if (aname) {
#line 225
        tmp___11 = 1;
      } else {
        {
#line 225
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 225);
#line 225
        tmp___8 = __errno_location();
#line 225
        tmp___9 = strerror(*tmp___8);
#line 225
        tmp___10 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 225
        r_fatal((char const   *)tmp___10, "make_aname", "aname", (long )((max_alen + 1UL) * sizeof(char *)),
                tmp___9);
#line 225
        tmp___11 = 0;
        }
      }
    } else
#line 226
    if (alen > max_alen) {
      {
#line 227
      max_alen = alen + 256UL;
#line 228
      tmp___12 = realloc((void *)aname, (max_alen + 1UL) * sizeof(char *));
#line 228
      aname = (char *)tmp___12;
      }
#line 228
      if (aname) {
#line 228
        tmp___16 = 1;
      } else {
        {
#line 228
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 228);
#line 228
        tmp___13 = __errno_location();
#line 228
        tmp___14 = strerror(*tmp___13);
#line 228
        tmp___15 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 228
        r_fatal((char const   *)tmp___15, "make_aname", "aname", (long )((max_alen + 1UL) * sizeof(char *)),
                tmp___14);
#line 228
        tmp___16 = 0;
        }
      }
    }
    {
#line 230
    memcpy((void */* __restrict  */)aname, (void const   */* __restrict  */)symbol->sub.nodep.name,
           alen + 1UL);
    }
  }
#line 232
  return ((char const   *)aname);
}
}
#line 248 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static char *message  =    (char *)((void *)0);
#line 249 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static size_t msglen  =    (size_t )0;
#line 245 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
char const   *array_vname(NODE const   *symbol ) 
{ 
  char *s___0 ;
  size_t len ;
  int n ;
  NODE const   *save_symbol ;
  char const   *from ;
  char *tmp___1 ;
  char const   *aname___0 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 253
  save_symbol = symbol;
#line 254
  tmp___1 = gettext("from %s");
#line 254
  from = (char const   *)tmp___1;
  }
#line 257
  if ((unsigned int const   )symbol->type != 11U) {
#line 257
    goto _L;
  } else
#line 257
  if ((unsigned int )(symbol->sub.nodep.l.lptr)->type != 5U) {
    _L: /* CIL Label */ 
#line 260
    if ((unsigned int const   )symbol->type != 5U) {
#line 261
      return ((char const   *)symbol->sub.nodep.name);
    } else
#line 260
    if ((unsigned long )symbol->sub.nodep.x.extra == (unsigned long )((void *)0)) {
#line 261
      return ((char const   *)symbol->sub.nodep.name);
    }
    {
#line 262
    tmp___2 = make_aname(symbol);
    }
#line 262
    return (tmp___2);
  }
#line 267
  len = (size_t )2;
#line 268
  n = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! ((unsigned int const   )symbol->type == 11U)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp___3 = strlen((char const   *)symbol->sub.nodep.name);
#line 270
    len += tmp___3;
#line 271
    n ++;
#line 272
    symbol = (NODE const   *)symbol->sub.nodep.r.rptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if ((unsigned long )symbol->sub.nodep.x.extra == (unsigned long )((void *)0)) {
#line 277
    aname___0 = (char const   *)symbol->sub.nodep.name;
  } else {
    {
#line 279
    aname___0 = make_aname(symbol);
    }
  }
  {
#line 280
  tmp___4 = strlen(aname___0);
#line 280
  len += tmp___4;
#line 286
  tmp___5 = strlen(from);
#line 286
  len += (size_t )n * tmp___5;
  }
#line 289
  if ((unsigned long )message == (unsigned long )((void *)0)) {
    {
#line 290
    tmp___6 = malloc(len);
#line 290
    message = (char *)tmp___6;
    }
#line 290
    if (message) {
#line 290
      tmp___10 = 1;
    } else {
      {
#line 290
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 290);
#line 290
      tmp___7 = __errno_location();
#line 290
      tmp___8 = strerror(*tmp___7);
#line 290
      tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 290
      r_fatal((char const   *)tmp___9, "array_vname", "message", (long )len, tmp___8);
#line 290
      tmp___10 = 0;
      }
    }
#line 291
    msglen = len;
  } else
#line 292
  if (len > msglen) {
    {
#line 293
    tmp___11 = realloc((void *)message, len);
#line 293
    message = (char *)tmp___11;
    }
#line 293
    if (message) {
#line 293
      tmp___15 = 1;
    } else {
      {
#line 293
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 293);
#line 293
      tmp___12 = __errno_location();
#line 293
      tmp___13 = strerror(*tmp___12);
#line 293
      tmp___14 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 293
      r_fatal((char const   *)tmp___14, "array_vname", "message", (long )len, tmp___13);
#line 293
      tmp___15 = 0;
      }
    }
#line 294
    msglen = len;
  }
  {
#line 299
  symbol = save_symbol;
#line 300
  s___0 = message;
#line 306
  tmp___16 = sprintf((char */* __restrict  */)s___0, (char const   */* __restrict  */)"%s (",
                     symbol->sub.nodep.name);
#line 306
  s___0 += tmp___16;
  }
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 308
    symbol = (NODE const   *)symbol->sub.nodep.r.rptr;
#line 309
    if ((unsigned int const   )symbol->type != 11U) {
#line 310
      goto while_break___0;
    }
    {
#line 311
    tmp___17 = sprintf((char */* __restrict  */)s___0, (char const   */* __restrict  */)from,
                       symbol->sub.nodep.name);
#line 311
    s___0 += tmp___17;
#line 312
    tmp___18 = sprintf((char */* __restrict  */)s___0, (char const   */* __restrict  */)", ");
#line 312
    s___0 += tmp___18;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 314
  tmp___19 = sprintf((char */* __restrict  */)s___0, (char const   */* __restrict  */)from,
                     aname___0);
#line 314
  s___0 += tmp___19;
#line 315
  strcpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)")");
  }
#line 317
  return ((char const   *)message);
}
}
#line 328 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE *force_array(NODE *symbol , _Bool canfatal ) 
{ 
  NODE *save_symbol ;
  _Bool isparam ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 331
  save_symbol = symbol;
#line 332
  isparam = (_Bool)0;
#line 334
  if ((unsigned int )symbol->type == 7U) {
#line 335
    symbol = *(frame_ptr->sub.nodep.r.av + symbol->sub.nodep.l.ll);
#line 335
    save_symbol = symbol;
#line 336
    isparam = (_Bool)1;
#line 337
    if ((unsigned int )symbol->type == 11U) {
#line 338
      symbol = symbol->sub.nodep.l.lptr;
    }
  }
  {
#line 342
  if ((unsigned int )symbol->type == 6U) {
#line 342
    goto case_6;
  }
#line 346
  if ((unsigned int )symbol->type == 5U) {
#line 346
    goto case_5;
  }
#line 350
  goto switch_default;
  case_6: /* CIL Label */ 
  {
#line 343
  null_array(symbol);
#line 344
  symbol->sub.nodep.x.extra = (struct exp_node *)((void *)0);
  }
  case_5: /* CIL Label */ 
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 352
  if (canfatal) {
#line 353
    if ((unsigned int )symbol->type == 1U) {
      {
#line 354
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 354);
#line 354
      tmp___1 = gettext("attempt to use a scalar value as array");
#line 354
      r_fatal((char const   *)tmp___1);
      }
    }
#line 355
    if (isparam) {
      {
#line 356
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 356);
#line 356
      tmp___2 = gettext("attempt to use scalar parameter `%s\' as an array");
#line 356
      r_fatal((char const   *)tmp___2, save_symbol->sub.nodep.name);
      }
    } else {
      {
#line 359
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 359);
#line 359
      tmp___3 = gettext("attempt to use scalar `%s\' as an array");
#line 359
      r_fatal((char const   *)tmp___3, save_symbol->sub.nodep.name);
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 365
  return (symbol);
}
}
#line 371 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
void set_SUBSEP(void) 
{ 


  {
  {
#line 374
  SUBSEP_node->sub.nodep.l.lptr = force_string(SUBSEP_node->sub.nodep.l.lptr);
#line 375
  SUBSEP = (SUBSEP_node->sub.nodep.l.lptr)->sub.val.sp;
#line 376
  SUBSEPlen = (SUBSEP_node->sub.nodep.l.lptr)->sub.val.slen;
  }
#line 377
  return;
}
}
#line 382 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE *concat_exp(int nargs , _Bool do_subsep ) 
{ 
  NODE *r ;
  char *str ;
  char *s___0 ;
  size_t len ;
  size_t subseplen ;
  int i___0 ;
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  NODE *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  NODE *tmp___12 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 390
  subseplen = (size_t )0;
#line 394
  if (nargs == 1) {
    {
#line 395
    tmp___1 = POP_SCALAR();
#line 395
    tmp___2 = force_string(tmp___1);
    }
#line 395
    return (tmp___2);
  }
#line 397
  if (do_subsep) {
#line 398
    subseplen = SUBSEPlen;
  }
#line 400
  len = (size_t )0;
#line 401
  i___0 = 1;
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! (i___0 <= nargs)) {
#line 401
      goto while_break;
    }
#line 402
    r = stack_ptr->rptr;
#line 403
    if ((unsigned int )r->type == 5U) {
      {
#line 404
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 404
        i___0 --;
#line 404
        if (! (i___0 > 0)) {
#line 404
          goto while_break___0;
        }
        {
#line 405
        DEREF(*(args_array + i___0));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 406
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 406);
#line 406
      tmp___3 = array_vname((NODE const   *)r);
#line 406
      tmp___4 = gettext("attempt to use array `%s\' in a scalar context");
#line 406
      r_fatal((char const   *)tmp___4, tmp___3);
      }
    }
    {
#line 408
    tmp___5 = POP_SCALAR();
#line 408
    r = force_string(tmp___5);
#line 409
    *(args_array + i___0) = r;
#line 410
    len += r->sub.val.slen;
#line 401
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 412
  len += (size_t )(nargs - 1) * subseplen;
#line 414
  tmp___6 = malloc(len + 2UL);
#line 414
  str = (char *)tmp___6;
  }
#line 414
  if (str) {
#line 414
    tmp___10 = 1;
  } else {
    {
#line 414
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 414);
#line 414
    tmp___7 = __errno_location();
#line 414
    tmp___8 = strerror(*tmp___7);
#line 414
    tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 414
    r_fatal((char const   *)tmp___9, "concat_exp", "str", (long )(len + 2UL), tmp___8);
#line 414
    tmp___10 = 0;
    }
  }
  {
#line 416
  r = *(args_array + nargs);
#line 417
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)r->sub.val.sp,
         r->sub.val.slen);
#line 418
  s___0 = str + r->sub.val.slen;
#line 419
  DEREF(r);
#line 420
  i___0 = nargs - 1;
  }
  {
#line 420
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 420
    if (! (i___0 > 0)) {
#line 420
      goto while_break___1;
    }
#line 421
    if (subseplen == 1UL) {
#line 422
      tmp___11 = s___0;
#line 422
      s___0 ++;
#line 422
      *tmp___11 = *SUBSEP;
    } else
#line 423
    if (subseplen > 0UL) {
      {
#line 424
      memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)SUBSEP,
             subseplen);
#line 425
      s___0 += subseplen;
      }
    }
    {
#line 427
    r = *(args_array + i___0);
#line 428
    memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)r->sub.val.sp,
           r->sub.val.slen);
#line 429
    s___0 += r->sub.val.slen;
#line 430
    DEREF(r);
#line 420
    i___0 --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 433
  tmp___12 = make_str_node((char const   *)str, len, 2);
  }
#line 433
  return (tmp___12);
}
}
#line 442 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static void adjust_fcall_stack(NODE *symbol , int nsubs ) 
{ 
  NODE *func___1 ;
  NODE *r ;
  NODE *n ;
  NODE **sp___0 ;
  int pcount ;
  NODE **tmp___1 ;

  {
#line 468
  func___1 = frame_ptr->sub.nodep.x.extra;
#line 469
  if ((unsigned long )func___1 == (unsigned long )((void *)0)) {
#line 470
    return;
  }
#line 471
  pcount = (int )func___1->sub.nodep.l.ll;
#line 472
  sp___0 = frame_ptr->sub.nodep.r.av;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! (pcount > 0)) {
#line 474
      goto while_break;
    }
#line 475
    tmp___1 = sp___0;
#line 475
    sp___0 ++;
#line 475
    r = *tmp___1;
#line 476
    if ((unsigned int )r->type != 11U) {
#line 478
      goto __Cont;
    } else
#line 476
    if ((unsigned int )(r->sub.nodep.l.lptr)->type != 5U) {
#line 478
      goto __Cont;
    }
#line 479
    n = r->sub.nodep.l.lptr;
#line 482
    if ((unsigned long )n == (unsigned long )symbol) {
#line 482
      if ((unsigned long )symbol->sub.nodep.x.extra != (unsigned long )((void *)0)) {
#line 482
        if (nsubs > 0) {
          {
#line 498
          null_array(r);
#line 499
          r->sub.nodep.x.extra = (struct exp_node *)((void *)0);
          }
#line 500
          goto __Cont;
        }
      }
    }
#line 504
    n = n->sub.nodep.x.extra;
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 504
      if (! ((unsigned long )n != (unsigned long )((void *)0))) {
#line 504
        goto while_break___0;
      }
#line 506
      if ((unsigned long )n == (unsigned long )symbol) {
        {
#line 516
        null_array(r);
#line 517
        r->sub.nodep.x.extra = (struct exp_node *)((void *)0);
        }
#line 518
        goto while_break___0;
      }
#line 504
      n = n->sub.nodep.x.extra;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 474
    pcount --;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return;
}
}
#line 532 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
void do_delete(NODE *symbol , int nsubs ) 
{ 
  NODE *val ;
  NODE *subs ;
  int i___0 ;
  NODE *s___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  NODE *s___1 ;
  NODE *s___2 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  struct exp_node **tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 539
  val = (NODE *)((void *)0);
#line 539
  subs = val;
#line 559
  if (nsubs == 0) {
    {
#line 562
    adjust_fcall_stack(symbol, 0);
#line 563
    (*(*(symbol->sub.nodep.l.lp + 5)))(symbol, (struct exp_node *)((void *)0));
    }
#line 564
    return;
  }
#line 569
  i___0 = nsubs;
  {
#line 569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 569
    if (! (i___0 > 0)) {
#line 569
      goto while_break;
    }
#line 570
    subs = (stack_ptr - (i___0 - 1))->rptr;
#line 571
    if ((unsigned int )subs->type != 1U) {
      {
#line 572
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 572
        s___0 = (stack_ptr - (i___0 - 1))->rptr;
#line 572
        if ((unsigned int )s___0->type == 1U) {
          {
#line 572
          force_string(s___0);
#line 572
          DEREF(s___0);
          }
        }
#line 572
        i___0 --;
#line 572
        if (! (i___0 > 0)) {
#line 572
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 573
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 573);
#line 573
      tmp___1 = array_vname((NODE const   *)subs);
#line 573
      tmp___2 = gettext("attempt to use array `%s\' in a scalar context");
#line 573
      r_fatal((char const   *)tmp___2, tmp___1);
      }
    }
    {
#line 576
    val = in_array(symbol, subs);
    }
#line 577
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 578
      if (do_flags & 3) {
        {
#line 579
        subs = force_string(subs);
#line 580
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 580);
#line 580
        tmp___3 = array_vname((NODE const   *)symbol);
#line 580
        tmp___4 = gettext("delete: index `%s\' not in array `%s\'");
#line 580
        (*lintfunc)((char const   *)tmp___4, subs->sub.val.sp, tmp___3);
        }
      }
      {
#line 584
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 584
        s___1 = (stack_ptr - (i___0 - 1))->rptr;
#line 584
        if ((unsigned int )s___1->type == 1U) {
          {
#line 584
          force_string(s___1);
#line 584
          DEREF(s___1);
          }
        }
#line 584
        i___0 --;
#line 584
        if (! (i___0 > 0)) {
#line 584
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 585
      return;
    }
#line 588
    if (i___0 > 1) {
#line 589
      if ((unsigned int )val->type != 5U) {
        {
#line 592
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 592
          s___2 = (stack_ptr - (i___0 - 1))->rptr;
#line 592
          if ((unsigned int )s___2->type == 1U) {
            {
#line 592
            force_string(s___2);
#line 592
            DEREF(s___2);
            }
          }
#line 592
          i___0 --;
#line 592
          if (! (i___0 > 0)) {
#line 592
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 593
        subs = force_string(subs);
#line 594
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 594);
#line 594
        tmp___5 = array_vname((NODE const   *)symbol);
#line 594
        tmp___6 = gettext("attempt to use scalar `%s[\"%.*s\"]\' as an array");
#line 594
        r_fatal((char const   *)tmp___6, tmp___5, (int )subs->sub.val.slen, subs->sub.val.sp);
        }
      }
      {
#line 599
      symbol = val;
#line 600
      DEREF(subs);
      }
    }
#line 569
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  if ((unsigned int )val->type == 5U) {
    {
#line 605
    adjust_fcall_stack(val, nsubs);
#line 606
    (*(*(val->sub.nodep.l.lp + 5)))(val, (struct exp_node *)((void *)0));
#line 608
    free((void *)val->sub.nodep.name);
#line 609
    ((BLOCK *)val)->freep = nextfree[1].freep;
#line 609
    nextfree[1].freep = (BLOCK *)val;
    }
  } else {
    {
#line 611
    unref(val);
    }
  }
  {
#line 613
  tmp___7 = (*(*(symbol->sub.nodep.l.lp + 6)))(symbol, subs);
#line 614
  DEREF(subs);
  }
#line 617
  return;
}
}
#line 628 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
void do_delete_loop(NODE *symbol , NODE **lhs ) 
{ 
  NODE **list ;
  NODE akind ;
  struct exp_node **tmp___1 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 634
  akind.flags = 257U;
#line 635
  list = (*(*(symbol->sub.nodep.l.lp + 7)))(symbol, & akind);
#line 637
  tmp___1 = (*(*(symbol->sub.nodep.l.lp + 2)))(symbol, (struct exp_node *)((void *)0));
  }
#line 637
  if ((*tmp___1)->sub.nodep.reflags == 0UL) {
#line 638
    return;
  }
  {
#line 640
  unref(*lhs);
#line 641
  *lhs = *(list + 0);
#line 642
  free((void *)list);
#line 645
  adjust_fcall_stack(symbol, 0);
#line 646
  (*(*(symbol->sub.nodep.l.lp + 5)))(symbol, (struct exp_node *)((void *)0));
  }
#line 647
  return;
}
}
#line 652 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static void value_info(NODE *n ) 
{ 
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 659
  if ((unsigned long )n == (unsigned long )Nnull_string) {
    {
#line 660
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"<(null)>");
    }
#line 661
    return;
  } else
#line 659
  if ((unsigned long )n == (unsigned long )Null_field) {
    {
#line 660
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"<(null)>");
    }
#line 661
    return;
  }
#line 664
  if ((n->flags & 6U) != 0U) {
    {
#line 665
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"<");
#line 666
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"\"%.*s\"",
            -1, n->sub.val.sp);
    }
#line 667
    if ((n->flags & 24U) != 0U) {
#line 669
      if ((n->flags & 2048U) != 0U) {
        {
#line 670
        tmp___1 = mpg_fmt("%.*R*g", -1, (int )ROUND_MODE, n->sub.val.nm.mpnum);
#line 670
        fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)":%s",
                tmp___1);
        }
      } else
#line 672
      if ((n->flags & 4096U) != 0U) {
        {
#line 673
        tmp___2 = mpg_fmt("%Zd", n->sub.val.nm.mpi);
#line 673
        fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)":%s",
                tmp___2);
        }
      } else {
        {
#line 676
        fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)":%.*g",
                -1, n->sub.val.nm.fltnum);
        }
      }
    }
    {
#line 678
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)">");
    }
  } else
#line 681
  if ((n->flags & 2048U) != 0U) {
    {
#line 682
    tmp___3 = mpg_fmt("%.*R*g", -1, (int )ROUND_MODE, n->sub.val.nm.mpnum);
#line 682
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"<%s>",
            tmp___3);
    }
  } else
#line 684
  if ((n->flags & 4096U) != 0U) {
    {
#line 685
    tmp___4 = mpg_fmt("%Zd", n->sub.val.nm.mpi);
#line 685
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"<%s>",
            tmp___4);
    }
  } else {
    {
#line 688
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"<%.*g>",
            -1, n->sub.val.nm.fltnum);
    }
  }
  {
#line 691
  tmp___5 = flags2str((int )n->flags);
#line 691
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)":%s",
          tmp___5);
  }
#line 693
  if ((n->flags & 64U) == 0U) {
    {
#line 694
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)":%ld",
            n->sub.val.sref);
    }
  } else {
    {
#line 696
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)":");
    }
  }
#line 698
  if ((n->flags & 6U) == 4U) {
    {
#line 699
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"][");
#line 700
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"stfmt=%d, ",
            n->sub.val.idx);
    }
#line 701
    if (n->sub.val.idx <= -1) {
#line 701
      tmp___6 = "%ld";
    } else {
#line 701
      tmp___6 = (char const   *)(*(fmt_list + n->sub.val.idx))->sub.val.sp;
    }
    {
#line 701
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"CONVFMT=\"%s\"",
            tmp___6);
    }
  }
#line 707
  return;
}
}
#line 710 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
void indent(int indent_level___0 ) 
{ 
  int i___0 ;
  char *__cil_tmp3 ;

  {
#line 714
  i___0 = 0;
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (i___0 < indent_level___0)) {
#line 714
      goto while_break;
    }
    {
#line 715
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"%s",
            indent_char);
#line 714
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 716
  return;
}
}
#line 720 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
void assoc_info(NODE *subs , NODE *val , NODE *ndump___0 , char const   *aname___0 ) 
{ 
  int indent_level___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 723
  indent_level___0 = (int )ndump___0->sub.nodep.x.xl;
#line 725
  indent_level___0 ++;
#line 726
  indent(indent_level___0);
#line 727
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"I: [%s:",
          aname___0);
  }
#line 728
  if ((subs->flags & 6656U) == 512U) {
    {
#line 729
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"<%ld>",
            (long )subs->sub.val.nm.fltnum);
    }
  } else {
    {
#line 731
    value_info(subs);
    }
  }
  {
#line 732
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"]\n");
#line 734
  indent(indent_level___0);
  }
#line 735
  if ((unsigned int )val->type == 1U) {
    {
#line 736
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"V: [scalar: ");
#line 737
    value_info(val);
    }
  } else {
    {
#line 739
    fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"V: [");
#line 740
    (ndump___0->sub.nodep.x.xl) ++;
#line 741
    (ndump___0->sub.nodep.l.ll) --;
#line 742
    assoc_dump(val, ndump___0);
#line 743
    (ndump___0->sub.nodep.l.ll) ++;
#line 744
    (ndump___0->sub.nodep.x.xl) --;
#line 745
    indent(indent_level___0);
    }
  }
  {
#line 747
  fprintf((FILE */* __restrict  */)output_fp, (char const   */* __restrict  */)"]\n");
  }
#line 748
  return;
}
}
#line 757 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static NODE ndump  ;
#line 753 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE *do_adump(int nargs ) 
{ 
  NODE *symbol ;
  NODE *tmp___1 ;
  long depth___0 ;
  NODE *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  char *tmp___6 ;
  NODE *tmp___7 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 758
  depth___0 = 0L;
#line 766
  if (nargs == 2) {
    {
#line 767
    tmp___2 = POP_SCALAR();
#line 767
    tmp___1 = force_number(tmp___2);
    }
#line 768
    if (tmp___1->flags & 2048U) {
      {
#line 768
      tmp___3 = mpfr_get_si((mpfr_srcptr )(tmp___1->sub.val.nm.mpnum), ROUND_MODE);
#line 768
      depth___0 = tmp___3;
      }
    } else {
#line 768
      if (tmp___1->flags & 4096U) {
        {
#line 768
        tmp___4 = __gmpz_get_si((mpz_srcptr )(tmp___1->sub.val.nm.mpi));
#line 768
        tmp___5 = tmp___4;
        }
      } else {
#line 768
        tmp___5 = (long )tmp___1->sub.val.nm.fltnum;
      }
#line 768
      depth___0 = tmp___5;
    }
    {
#line 769
    DEREF(tmp___1);
    }
  }
  {
#line 771
  symbol = POP_PARAM();
  }
#line 772
  if ((unsigned int )symbol->type != 5U) {
    {
#line 773
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 773);
#line 773
    tmp___6 = gettext("adump: first argument not an array");
#line 773
    r_fatal((char const   *)tmp___6);
    }
  }
  {
#line 775
  ndump.type = (NODETYPE )14;
#line 776
  ndump.sub.nodep.l.ll = depth___0;
#line 777
  ndump.sub.nodep.x.xl = 0L;
#line 778
  assoc_dump(symbol, & ndump);
#line 779
  tmp___7 = (*make_number)((double )0);
  }
#line 779
  return (tmp___7);
}
}
#line 785 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static NODE *asort_actual(int nargs , sort_context_t ctxt ) 
{ 
  NODE *array ;
  NODE *dest ;
  NODE *result ;
  NODE *r ;
  NODE *subs ;
  NODE *s___0 ;
  NODE **list ;
  NODE **ptr ;
  NODE **lhs ;
  unsigned long num_elems ;
  unsigned long i___0 ;
  char const   *sort_str ;
  NODE *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  struct exp_node **tmp___14 ;
  NODE *tmp___15 ;
  NODE **tmp___16 ;
  NODE **tmp___17 ;
  NODE *arr ;
  NODE *tmp___18 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 788
  dest = (NODE *)((void *)0);
#line 790
  list = (NODE **)((void *)0);
#line 794
  if (nargs == 3) {
    {
#line 795
    tmp___1 = POP_SCALAR();
#line 795
    s___0 = force_string(tmp___1);
    }
  } else {
    {
#line 797
    s___0 = dupnode(Nnull_string);
    }
  }
  {
#line 799
  s___0 = force_string(s___0);
#line 800
  sort_str = (char const   *)s___0->sub.val.sp;
  }
#line 801
  if (s___0->sub.val.slen == 0UL) {
#line 802
    if ((unsigned int )ctxt == 2U) {
#line 803
      sort_str = "@val_type_asc";
    } else {
#line 805
      sort_str = "@ind_str_asc";
    }
  }
#line 808
  if (nargs >= 2) {
    {
#line 809
    dest = POP_PARAM();
    }
#line 810
    if ((unsigned int )dest->type != 5U) {
      {
#line 811
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 811);
      }
#line 811
      if ((unsigned int )ctxt == 2U) {
        {
#line 811
        tmp___2 = gettext("asort: second argument not an array");
#line 811
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 811
        tmp___3 = gettext("asorti: second argument not an array");
#line 811
        tmp___4 = tmp___3;
        }
      }
      {
#line 811
      r_fatal((char const   *)tmp___4);
      }
    }
  }
  {
#line 817
  array = POP_PARAM();
  }
#line 818
  if ((unsigned int )array->type != 5U) {
    {
#line 819
    set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 819);
    }
#line 819
    if ((unsigned int )ctxt == 2U) {
      {
#line 819
      tmp___5 = gettext("asort: first argument not an array");
#line 819
      tmp___7 = tmp___5;
      }
    } else {
      {
#line 819
      tmp___6 = gettext("asorti: first argument not an array");
#line 819
      tmp___7 = tmp___6;
      }
    }
    {
#line 819
    r_fatal((char const   *)tmp___7);
    }
  }
#line 824
  if ((unsigned long )dest != (unsigned long )((void *)0)) {
#line 825
    r = dest->sub.nodep.x.extra;
    {
#line 825
    while (1) {
      while_continue: /* CIL Label */ ;
#line 825
      if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 825
        goto while_break;
      }
#line 826
      if ((unsigned long )r == (unsigned long )array) {
        {
#line 827
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 827);
        }
#line 827
        if ((unsigned int )ctxt == 2U) {
          {
#line 827
          tmp___8 = gettext("asort: cannot use a subarray of first arg for second arg");
#line 827
          tmp___10 = tmp___8;
          }
        } else {
          {
#line 827
          tmp___9 = gettext("asorti: cannot use a subarray of first arg for second arg");
#line 827
          tmp___10 = tmp___9;
          }
        }
        {
#line 827
        r_fatal((char const   *)tmp___10);
        }
      }
#line 825
      r = r->sub.nodep.x.extra;
    }
    while_break: /* CIL Label */ ;
    }
#line 831
    r = array->sub.nodep.x.extra;
    {
#line 831
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 831
      if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 831
        goto while_break___0;
      }
#line 832
      if ((unsigned long )r == (unsigned long )dest) {
        {
#line 833
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 833);
        }
#line 833
        if ((unsigned int )ctxt == 2U) {
          {
#line 833
          tmp___11 = gettext("asort: cannot use a subarray of second arg for first arg");
#line 833
          tmp___13 = tmp___11;
          }
        } else {
          {
#line 833
          tmp___12 = gettext("asorti: cannot use a subarray of second arg for first arg");
#line 833
          tmp___13 = tmp___12;
          }
        }
        {
#line 833
        r_fatal((char const   *)tmp___13);
        }
      }
#line 831
      r = r->sub.nodep.x.extra;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 840
  list = assoc_list(array, sort_str, ctxt);
#line 841
  DEREF(s___0);
#line 843
  tmp___14 = (*(*(array->sub.nodep.l.lp + 2)))(array, (struct exp_node *)((void *)0));
#line 843
  num_elems = (*tmp___14)->sub.nodep.reflags;
  }
#line 844
  if (num_elems == 0UL) {
#line 844
    goto _L;
  } else
#line 844
  if ((unsigned long )list == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 846
    if ((unsigned long )dest != (unsigned long )((void *)0)) {
#line 846
      if ((unsigned long )dest != (unsigned long )array) {
        {
#line 847
        (*(*(dest->sub.nodep.l.lp + 5)))(dest, (struct exp_node *)((void *)0));
        }
      }
    }
    {
#line 848
    tmp___15 = (*make_number)((double )0);
    }
#line 848
    return (tmp___15);
  }
#line 857
  if ((unsigned long )dest != (unsigned long )((void *)0)) {
#line 857
    if ((unsigned long )dest != (unsigned long )array) {
      {
#line 858
      (*(*(dest->sub.nodep.l.lp + 5)))(dest, (struct exp_node *)((void *)0));
#line 859
      result = dest;
      }
    } else {
      {
#line 862
      result = make_array();
#line 863
      result->sub.nodep.name = array->sub.nodep.name;
#line 864
      result->sub.nodep.x.extra = array->sub.nodep.x.extra;
      }
    }
  } else {
    {
#line 862
    result = make_array();
#line 863
    result->sub.nodep.name = array->sub.nodep.name;
#line 864
    result->sub.nodep.x.extra = array->sub.nodep.x.extra;
    }
  }
#line 867
  if ((unsigned int )ctxt == 3U) {
#line 870
    i___0 = 1UL;
#line 870
    ptr = list;
    {
#line 870
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 870
      if (! (i___0 <= num_elems)) {
#line 870
        goto while_break___1;
      }
      {
#line 871
      subs = (*make_number)((double )i___0);
#line 872
      lhs = (*(*(result->sub.nodep.l.lp + 3)))(result, subs);
#line 873
      unref(*lhs);
#line 874
      *lhs = *ptr;
      }
#line 875
      if ((unsigned long )*(result->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
        {
#line 876
        (*(*(result->sub.nodep.l.lp + 10)))(result, subs);
        }
      }
      {
#line 877
      unref(subs);
#line 870
      i___0 ++;
#line 870
      ptr += 2;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 882
    i___0 = 1UL;
#line 882
    ptr = list;
    {
#line 882
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 882
      if (! (i___0 <= num_elems)) {
#line 882
        goto while_break___2;
      }
      {
#line 883
      subs = (*make_number)((double )i___0);
#line 886
      tmp___16 = ptr;
#line 886
      ptr ++;
#line 886
      r = *tmp___16;
#line 887
      unref(r);
#line 890
      tmp___17 = ptr;
#line 890
      ptr ++;
#line 890
      r = *tmp___17;
      }
#line 892
      if ((unsigned int )r->type == 1U) {
        {
#line 893
        lhs = (*(*(result->sub.nodep.l.lp + 3)))(result, subs);
#line 894
        unref(*lhs);
#line 895
        *lhs = dupnode(r);
        }
      } else {
        {
#line 898
        arr = make_array();
#line 899
        subs = force_string(subs);
#line 900
        arr->sub.nodep.name = subs->sub.val.sp;
#line 901
        subs->sub.val.sp = (char *)((void *)0);
#line 902
        subs->flags &= 4294967291U;
#line 903
        arr->sub.nodep.x.extra = array;
#line 904
        lhs = (*(*(result->sub.nodep.l.lp + 3)))(result, subs);
#line 905
        unref(*lhs);
#line 906
        *lhs = assoc_copy(r, arr);
        }
      }
#line 908
      if ((unsigned long )*(result->sub.nodep.l.lp + 10) != (unsigned long )((void *)0)) {
        {
#line 909
        (*(*(result->sub.nodep.l.lp + 10)))(result, subs);
        }
      }
      {
#line 910
      unref(subs);
#line 882
      i___0 ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 914
  free((void *)list);
  }
#line 916
  if ((unsigned long )result != (unsigned long )dest) {
    {
#line 918
    (*(*(array->sub.nodep.l.lp + 5)))(array, (struct exp_node *)((void *)0));
#line 919
    *array = *result;
#line 920
    ((BLOCK *)result)->freep = nextfree[1].freep;
#line 920
    nextfree[1].freep = (BLOCK *)result;
    }
  }
  {
#line 925
  tmp___18 = (*make_number)((double )num_elems);
  }
#line 925
  return (tmp___18);
}
}
#line 930 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE *do_asort(int nargs ) 
{ 
  NODE *tmp___1 ;

  {
  {
#line 933
  tmp___1 = asort_actual(nargs, (sort_context_t )2);
  }
#line 933
  return (tmp___1);
}
}
#line 938 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE *do_asorti(int nargs ) 
{ 
  NODE *tmp___1 ;

  {
  {
#line 941
  tmp___1 = asort_actual(nargs, (sort_context_t )3);
  }
#line 941
  return (tmp___1);
}
}
#line 951 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int cmp_strings(NODE const   *n1 , NODE const   *n2 ) 
{ 
  char *s1 ;
  char *s2 ;
  size_t len1 ;
  size_t len2 ;
  int ret ;
  size_t lmin ;
  int tmp___1 ;
  unsigned char const   *cp1 ;
  unsigned char const   *cp2 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 959
  s1 = (char *)n1->sub.val.sp;
#line 960
  len1 = (size_t )n1->sub.val.slen;
#line 961
  s2 = (char *)n2->sub.val.sp;
#line 962
  len2 = (size_t )n2->sub.val.slen;
#line 964
  if (len1 == 0UL) {
#line 965
    if (len2 == 0UL) {
#line 965
      tmp___1 = 0;
    } else {
#line 965
      tmp___1 = -1;
    }
#line 965
    return (tmp___1);
  }
#line 966
  if (len2 == 0UL) {
#line 967
    return (1);
  }
#line 970
  if (len1 < len2) {
#line 970
    lmin = len1;
  } else {
#line 970
    lmin = len2;
  }
#line 972
  if (IGNORECASE) {
#line 973
    cp1 = (unsigned char const   *)s1;
#line 974
    cp2 = (unsigned char const   *)s2;
#line 977
    if (gawk_mb_cur_max > 1) {
      {
#line 978
      ret = strncasecmpmbs(cp1, cp2, lmin);
      }
    } else {
#line 982
      ret = 0;
      {
#line 982
      while (1) {
        while_continue: /* CIL Label */ ;
#line 982
        tmp___2 = lmin;
#line 982
        lmin --;
#line 982
        if (tmp___2 > 0UL) {
#line 982
          if (! (ret == 0)) {
#line 982
            goto while_break;
          }
        } else {
#line 982
          goto while_break;
        }
#line 983
        ret = (int )casetable[*cp1] - (int )casetable[*cp2];
#line 982
        cp1 ++;
#line 982
        cp2 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 984
    if (ret != 0) {
#line 985
      return (ret);
    }
  }
  {
#line 992
  ret = memcmp((void const   *)s1, (void const   *)s2, lmin);
  }
#line 993
  if (ret != 0) {
#line 994
    return (ret);
  } else
#line 993
  if (len1 == len2) {
#line 994
    return (ret);
  }
#line 995
  if (len1 < len2) {
#line 995
    tmp___3 = -1;
  } else {
#line 995
    tmp___3 = 1;
  }
#line 995
  return (tmp___3);
}
}
#line 1000 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_up_index_string(void const   *p1 , void const   *p2 ) 
{ 
  NODE const   *t1 ;
  NODE const   *t2 ;
  int tmp___1 ;

  {
  {
#line 1006
  t1 = (NODE const   *)*((NODE const   * const  *)p1);
#line 1007
  t2 = (NODE const   *)*((NODE const   * const  *)p2);
#line 1008
  tmp___1 = cmp_strings(t1, t2);
  }
#line 1008
  return (tmp___1);
}
}
#line 1014 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_down_index_string(void const   *p1 , void const   *p2 ) 
{ 
  int tmp___1 ;

  {
  {
#line 1026
  tmp___1 = sort_up_index_string(p1, p2);
  }
#line 1026
  return (- tmp___1);
}
}
#line 1032 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_up_index_number(void const   *p1 , void const   *p2 ) 
{ 
  NODE const   *t1 ;
  NODE const   *t2 ;
  int ret ;
  NODE *tmp___1 ;
  NODE *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1038
  t1 = (NODE const   *)*((NODE const   * const  *)p1);
#line 1039
  t2 = (NODE const   *)*((NODE const   * const  *)p2);
#line 1041
  ret = (*cmp_numbers)(t1, t2);
  }
#line 1042
  if (ret != 0) {
#line 1043
    return (ret);
  }
  {
#line 1046
  tmp___1 = force_string((NODE *)t1);
#line 1046
  t1 = (NODE const   *)tmp___1;
#line 1047
  tmp___2 = force_string((NODE *)t2);
#line 1047
  t2 = (NODE const   *)tmp___2;
#line 1048
  tmp___3 = cmp_strings(t1, t2);
  }
#line 1048
  return (tmp___3);
}
}
#line 1053 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_down_index_number(void const   *p1 , void const   *p2 ) 
{ 
  int tmp___1 ;

  {
  {
#line 1056
  tmp___1 = sort_up_index_number(p1, p2);
  }
#line 1056
  return (- tmp___1);
}
}
#line 1062 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_up_value_string(void const   *p1 , void const   *p2 ) 
{ 
  NODE const   *t1 ;
  NODE const   *t2 ;
  int tmp___1 ;

  {
#line 1067
  t1 = (NODE const   *)*((NODE const   * const  *)p1 + 1);
#line 1068
  t2 = (NODE const   *)*((NODE const   * const  *)p2 + 1);
#line 1070
  if ((unsigned int const   )t1->type == 5U) {
#line 1072
    return ((unsigned int const   )t2->type != 5U);
  }
#line 1074
  if ((unsigned int const   )t2->type == 5U) {
#line 1075
    return (-1);
  }
  {
#line 1078
  tmp___1 = cmp_strings(t1, t2);
  }
#line 1078
  return (tmp___1);
}
}
#line 1084 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_down_value_string(void const   *p1 , void const   *p2 ) 
{ 
  int tmp___1 ;

  {
  {
#line 1087
  tmp___1 = sort_up_value_string(p1, p2);
  }
#line 1087
  return (- tmp___1);
}
}
#line 1093 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_up_value_number(void const   *p1 , void const   *p2 ) 
{ 
  NODE *t1 ;
  NODE *t2 ;
  int ret ;
  int tmp___1 ;

  {
#line 1099
  t1 = (NODE *)*((NODE * const  *)p1 + 1);
#line 1100
  t2 = (NODE *)*((NODE * const  *)p2 + 1);
#line 1102
  if ((unsigned int )t1->type == 5U) {
#line 1104
    return ((unsigned int )t2->type != 5U);
  }
#line 1106
  if ((unsigned int )t2->type == 5U) {
#line 1107
    return (-1);
  }
  {
#line 1109
  ret = (*cmp_numbers)((NODE const   *)t1, (NODE const   *)t2);
  }
#line 1110
  if (ret != 0) {
#line 1111
    return (ret);
  }
  {
#line 1117
  t1 = force_string(t1);
#line 1118
  t2 = force_string(t2);
#line 1119
  tmp___1 = cmp_strings((NODE const   *)t1, (NODE const   *)t2);
  }
#line 1119
  return (tmp___1);
}
}
#line 1125 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_down_value_number(void const   *p1 , void const   *p2 ) 
{ 
  int tmp___1 ;

  {
  {
#line 1128
  tmp___1 = sort_up_value_number(p1, p2);
  }
#line 1128
  return (- tmp___1);
}
}
#line 1134 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_up_value_type(void const   *p1 , void const   *p2 ) 
{ 
  NODE *n1 ;
  NODE *n2 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1140
  n1 = (NODE *)*((NODE * const  *)p1 + 1);
#line 1141
  n2 = (NODE *)*((NODE * const  *)p2 + 1);
#line 1144
  if ((unsigned int )n1->type == 5U) {
#line 1146
    return ((unsigned int )n2->type != 5U);
  }
#line 1148
  if ((unsigned int )n2->type == 5U) {
#line 1149
    return (-1);
  }
#line 1154
  if ((n1->flags & 32U) != 0U) {
    {
#line 1155
    force_number(n1);
    }
  }
#line 1156
  if ((n2->flags & 32U) != 0U) {
    {
#line 1157
    force_number(n2);
    }
  }
#line 1160
  if ((n1->flags & 512U) != 0U) {
    {
#line 1161
    force_string(n1);
    }
  }
#line 1162
  if ((n2->flags & 512U) != 0U) {
    {
#line 1163
    force_string(n2);
    }
  }
#line 1165
  if ((n1->flags & 16U) != 0U) {
#line 1165
    if ((n2->flags & 16U) != 0U) {
      {
#line 1166
      tmp___1 = (*cmp_numbers)((NODE const   *)n1, (NODE const   *)n2);
      }
#line 1166
      return (tmp___1);
    }
  }
#line 1170
  if ((n1->flags & 16U) != 0U) {
#line 1170
    if ((n2->flags & 2U) != 0U) {
#line 1171
      return (-1);
    } else {
#line 1170
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1172
  if ((n1->flags & 2U) != 0U) {
#line 1172
    if ((n2->flags & 16U) != 0U) {
#line 1173
      return (1);
    }
  }
  {
#line 1177
  tmp___2 = cmp_strings((NODE const   *)n1, (NODE const   *)n2);
  }
#line 1177
  return (tmp___2);
}
}
#line 1182 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_down_value_type(void const   *p1 , void const   *p2 ) 
{ 
  int tmp___1 ;

  {
  {
#line 1185
  tmp___1 = sort_up_value_type(p1, p2);
  }
#line 1185
  return (- tmp___1);
}
}
#line 1190 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static int sort_user_func(void const   *p1 , void const   *p2 ) 
{ 
  NODE *idx1 ;
  NODE *idx2 ;
  NODE *val1 ;
  NODE *val2 ;
  NODE *r ;
  int ret ;
  INSTRUCTION *code ;
  STACK_ITEM *tmp___1 ;
  STACK_ITEM *tmp___2 ;
  STACK_ITEM *tmp___3 ;
  STACK_ITEM *tmp___4 ;
  STACK_ITEM *tmp___5 ;
  STACK_ITEM *tmp___6 ;
  STACK_ITEM *tmp___7 ;
  STACK_ITEM *tmp___8 ;
  NODE *tmp___9 ;

  {
#line 1197
  idx1 = (NODE *)*((NODE * const  *)p1);
#line 1198
  idx2 = (NODE *)*((NODE * const  *)p2);
#line 1199
  val1 = (NODE *)*((NODE * const  *)p1 + 1);
#line 1200
  val2 = (NODE *)*((NODE * const  *)p2 + 1);
#line 1202
  code = (stack_ptr->rptr)->sub.nodep.r.iptr;
#line 1205
  (idx1->sub.val.sref) ++;
#line 1206
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1206
    stack_ptr ++;
#line 1206
    tmp___2 = stack_ptr;
  } else {
    {
#line 1206
    tmp___1 = grow_stack();
#line 1206
    tmp___2 = tmp___1;
    }
  }
#line 1206
  tmp___2->rptr = idx1;
#line 1207
  if ((unsigned int )val1->type == 1U) {
#line 1208
    (val1->sub.val.sref) ++;
  }
#line 1209
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1209
    stack_ptr ++;
#line 1209
    tmp___4 = stack_ptr;
  } else {
    {
#line 1209
    tmp___3 = grow_stack();
#line 1209
    tmp___4 = tmp___3;
    }
  }
#line 1209
  tmp___4->rptr = val1;
#line 1211
  (idx2->sub.val.sref) ++;
#line 1212
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1212
    stack_ptr ++;
#line 1212
    tmp___6 = stack_ptr;
  } else {
    {
#line 1212
    tmp___5 = grow_stack();
#line 1212
    tmp___6 = tmp___5;
    }
  }
#line 1212
  tmp___6->rptr = idx2;
#line 1213
  if ((unsigned int )val2->type == 1U) {
#line 1214
    (val2->sub.val.sref) ++;
  }
#line 1215
  if ((unsigned long )stack_ptr < (unsigned long )stack_top) {
#line 1215
    stack_ptr ++;
#line 1215
    tmp___8 = stack_ptr;
  } else {
    {
#line 1215
    tmp___7 = grow_stack();
#line 1215
    tmp___8 = tmp___7;
    }
  }
  {
#line 1215
  tmp___8->rptr = val2;
#line 1218
  (*interpret)(code);
#line 1221
  tmp___9 = POP_SCALAR();
#line 1221
  r = force_number(tmp___9);
  }
#line 1227
  if ((r->flags & 2048U) != 0U) {
#line 1228
    if (r->sub.val.nm.mpnum[0]._mpfr_exp < (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 3UL)) {
#line 1228
      if (r->sub.val.nm.mpnum[0]._mpfr_exp == (mp_exp_t )(~ (0xffffffffffffffffUL >> 1) + 2UL)) {
        {
#line 1228
        mpfr_set_erangeflag();
        }
      }
#line 1228
      ret = 0;
    } else {
#line 1228
      ret = r->sub.val.nm.mpnum[0]._mpfr_sign;
    }
  } else
#line 1229
  if ((r->flags & 4096U) != 0U) {
#line 1230
    if (r->sub.val.nm.mpi[0]._mp_size < 0) {
#line 1230
      ret = -1;
    } else {
#line 1230
      ret = r->sub.val.nm.mpi[0]._mp_size > 0;
    }
  } else
#line 1233
  if (r->sub.val.nm.fltnum < 0.0) {
#line 1233
    ret = -1;
  } else {
#line 1233
    ret = r->sub.val.nm.fltnum > 0.0;
  }
  {
#line 1234
  DEREF(r);
  }
#line 1235
  return (ret);
}
}
#line 1246 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
static struct qsort_funcs  const  sort_funcs[11]  = 
#line 1246
  {      {"@ind_str_asc", & sort_up_index_string, (assoc_kind_t )73}, 
        {"@ind_num_asc", & sort_up_index_number, (assoc_kind_t )69}, 
        {"@val_str_asc", & sort_up_value_string, (assoc_kind_t )98}, 
        {"@val_num_asc", & sort_up_value_number, (assoc_kind_t )82}, 
        {"@ind_str_desc", & sort_down_index_string, (assoc_kind_t )137}, 
        {"@ind_num_desc", & sort_down_index_number, (assoc_kind_t )133}, 
        {"@val_str_desc", & sort_down_value_string, (assoc_kind_t )162}, 
        {"@val_num_desc", & sort_down_value_number, (assoc_kind_t )146}, 
        {"@val_type_asc", & sort_up_value_type, (assoc_kind_t )66}, 
        {"@val_type_desc", & sort_down_value_type, (assoc_kind_t )130}, 
        {"@unsorted", (int (*)(void const   * , void const   * ))0, (assoc_kind_t )1}};
#line 1241 "/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c"
NODE **assoc_list(NODE *symbol , char const   *sort_str , sort_context_t sort_ctxt ) 
{ 
  NODE **list ;
  NODE akind ;
  unsigned long num_elems ;
  unsigned long j ;
  int elem_size ;
  int qi ;
  int (*cmp_func)(void const   * , void const   * ) ;
  INSTRUCTION *code ;
  int save_rule ;
  assoc_kind_t assoc_kind ;
  int tmp___1 ;
  NODE *f ;
  char const   *sp___0 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct exp_node **tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 1273
  cmp_func = (int (*)(void const   * , void const   * ))0;
#line 1274
  code = (INSTRUCTION *)((void *)0);
#line 1276
  save_rule = 0;
#line 1277
  assoc_kind = (assoc_kind_t )0;
#line 1279
  elem_size = 1;
#line 1281
  qi = 0;
#line 1281
  j = sizeof(sort_funcs) / sizeof(sort_funcs[0]);
  {
#line 1281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1281
    if (! ((unsigned long )qi < j)) {
#line 1281
      goto while_break;
    }
    {
#line 1282
    tmp___1 = strcmp((char const   *)sort_funcs[qi].name, sort_str);
    }
#line 1282
    if (tmp___1 == 0) {
#line 1283
      goto while_break;
    }
#line 1281
    qi ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1286
  if ((unsigned long )qi < j) {
#line 1287
    cmp_func = (int (*)(void const   * , void const   * ))sort_funcs[qi].comp_func;
#line 1288
    assoc_kind = (assoc_kind_t )sort_funcs[qi].kind;
#line 1290
    if ((unsigned long )symbol->sub.nodep.l.lp != (unsigned long )(cint_array_func)) {
#line 1291
      assoc_kind = (assoc_kind_t )((unsigned int )assoc_kind & 4294967103U);
    }
#line 1293
    if ((unsigned int )sort_ctxt != 1U) {
#line 1296
      assoc_kind = (assoc_kind_t )((unsigned int )assoc_kind | 3U);
#line 1297
      elem_size = 2;
    } else
#line 1293
    if (((unsigned int )assoc_kind & 2U) != 0U) {
#line 1296
      assoc_kind = (assoc_kind_t )((unsigned int )assoc_kind | 3U);
#line 1297
      elem_size = 2;
    }
  } else {
#line 1304
    sp___0 = sort_str;
    {
#line 1304
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1304
      if ((int const   )*sp___0 != 0) {
        {
#line 1304
        tmp___2 = __ctype_b_loc();
        }
#line 1304
        if ((int const   )*(*tmp___2 + (int )((unsigned char )*sp___0)) & 8192) {
#line 1304
          goto while_break___0;
        }
      } else {
#line 1304
        goto while_break___0;
      }
#line 1305
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 1304
      sp___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1308
    if ((unsigned long )sp___0 == (unsigned long )sort_str) {
      {
#line 1309
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 1309);
#line 1309
      tmp___3 = gettext("`%s\' is invalid as a function name");
#line 1309
      r_fatal((char const   *)tmp___3, sort_str);
      }
    } else
#line 1308
    if ((int const   )*sp___0 != 0) {
      {
#line 1309
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 1309);
#line 1309
      tmp___3 = gettext("`%s\' is invalid as a function name");
#line 1309
      r_fatal((char const   *)tmp___3, sort_str);
      }
    }
    {
#line 1311
    f = lookup(sort_str);
    }
#line 1312
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 1313
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 1313);
#line 1313
      tmp___4 = gettext("sort comparison function `%s\' is not defined");
#line 1313
      r_fatal((char const   *)tmp___4, sort_str);
      }
    } else
#line 1312
    if ((unsigned int )f->type != 8U) {
      {
#line 1313
      set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 1313);
#line 1313
      tmp___4 = gettext("sort comparison function `%s\' is not defined");
#line 1313
      r_fatal((char const   *)tmp___4, sort_str);
      }
    }
    {
#line 1315
    cmp_func = & sort_user_func;
#line 1318
    assoc_kind = (assoc_kind_t )((unsigned int )assoc_kind | 3U);
#line 1319
    elem_size = 2;
#line 1322
    code = bcalloc((OPCODE )70, 2, 0);
#line 1323
    code->x.xn = f;
#line 1324
    code->d.name = (char *)((void *)0);
#line 1325
    (code + 1)->x.xl = 4L;
#line 1326
    code->nexti = bcalloc((OPCODE )102, 1, 0);
#line 1334
    save_rule = currule;
#line 1335
    currule = 0;
#line 1337
    PUSH_CODE(code);
    }
  }
  {
#line 1340
  akind.flags = (unsigned int )assoc_kind;
#line 1341
  list = (*(*(symbol->sub.nodep.l.lp + 7)))(symbol, & akind);
#line 1342
  assoc_kind = (assoc_kind_t )akind.flags;
  }
#line 1344
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 1345
    return (list);
  } else
#line 1344
  if (! cmp_func) {
#line 1345
    return (list);
  } else
#line 1344
  if (((unsigned int )assoc_kind & 192U) != 0U) {
#line 1345
    return (list);
  }
  {
#line 1347
  tmp___5 = (*(*(symbol->sub.nodep.l.lp + 2)))(symbol, (struct exp_node *)((void *)0));
#line 1347
  num_elems = (*tmp___5)->sub.nodep.reflags;
#line 1349
  qsort((void *)list, num_elems, (unsigned long )elem_size * sizeof(NODE *), cmp_func);
  }
#line 1351
  if ((unsigned long )cmp_func == (unsigned long )(& sort_user_func)) {
    {
#line 1352
    code = POP_CODE();
#line 1353
    currule = save_rule;
#line 1354
    bcfree(code->nexti);
#line 1355
    bcfree(code);
    }
  }
#line 1358
  if ((unsigned int )sort_ctxt == 1U) {
#line 1358
    if (((unsigned int )assoc_kind & 3U) == 3U) {
#line 1360
      j = 1UL;
      {
#line 1360
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1360
        if (! (j < num_elems)) {
#line 1360
          goto while_break___1;
        }
#line 1361
        *(list + j) = *(list + 2UL * j);
#line 1360
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1365
      tmp___6 = realloc((void *)((char *)list), num_elems * sizeof(NODE *));
#line 1365
      list = (NODE **)tmp___6;
      }
#line 1365
      if (list) {
#line 1365
        tmp___10 = 1;
      } else {
        {
#line 1365
        set_loc("/home/wslee/gnu_benchmarks/gawk-4.1.0/array.c", 1365);
#line 1365
        tmp___7 = __errno_location();
#line 1365
        tmp___8 = strerror(*tmp___7);
#line 1365
        tmp___9 = gettext("%s: %s: can\'t allocate %ld bytes of memory (%s)");
#line 1365
        r_fatal((char const   *)tmp___9, "assoc_list", "list", (long )(num_elems * sizeof(NODE *)),
                tmp___8);
#line 1365
        tmp___10 = 0;
        }
      }
    }
  }
#line 1368
  return (list);
}
}
