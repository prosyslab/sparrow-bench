/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_16 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_16 fd_set;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 118
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isspace)(int  ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 332
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 58 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memccpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  int __c ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static char *host  =    (char *)"irc.oftc.net";
#line 12 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static char *port  =    (char *)"ircd";
#line 13 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static char *password  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static char nick[32]  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static char bufin[4096]  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static char bufout[4096]  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static char channel[256]  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static time_t trespond  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static FILE *srv  ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/sic-1.1/util.c"
static void eprint(char const   *fmt  , ...) 
{ 
  va_list ap ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 10
  __builtin_va_start(ap, fmt);
#line 11
  vsnprintf((char */* __restrict  */)(bufout), sizeof(bufout), (char const   */* __restrict  */)fmt,
            ap);
#line 12
  __builtin_va_end(ap);
#line 13
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          bufout);
  }
#line 14
  if (*(fmt + 0)) {
    {
#line 14
    tmp___1 = strlen(fmt);
    }
#line 14
    if ((int const   )*(fmt + (tmp___1 - 1UL)) == 58) {
      {
#line 15
      tmp = __errno_location();
#line 15
      tmp___0 = strerror(*tmp);
#line 15
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s\n",
              tmp___0);
      }
    }
  }
  {
#line 16
  exit(1);
  }
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/sic-1.1/util.c"
static struct addrinfo hints  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/sic-1.1/util.c"
static int dial(char *host___0 , char *port___0 ) 
{ 
  int srv___0 ;
  struct addrinfo *res ;
  struct addrinfo *r ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 25
  memset((void *)(& hints), 0, sizeof(hints));
#line 26
  hints.ai_family = 0;
#line 27
  hints.ai_socktype = 1;
#line 28
  tmp = getaddrinfo((char const   */* __restrict  */)host___0, (char const   */* __restrict  */)port___0,
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 28
  if (tmp != 0) {
    {
#line 29
    eprint("error: cannot resolve hostname \'%s\':", host___0);
    }
  }
#line 30
  r = res;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! r) {
#line 30
      goto while_break;
    }
    {
#line 31
    srv___0 = socket(r->ai_family, r->ai_socktype, r->ai_protocol);
    }
#line 31
    if (srv___0 == -1) {
#line 32
      goto __Cont;
    }
    {
#line 33
    tmp___0 = connect(srv___0, (struct sockaddr  const  */* __restrict  */)r->ai_addr,
                      r->ai_addrlen);
    }
#line 33
    if (tmp___0 == 0) {
#line 34
      goto while_break;
    }
    {
#line 35
    close(srv___0);
    }
    __Cont: /* CIL Label */ 
#line 30
    r = r->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 37
  freeaddrinfo(res);
  }
#line 38
  if (! r) {
    {
#line 39
    eprint("error: cannot connect to host \'%s\'\n", host___0);
    }
  }
#line 40
  return (srv___0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/sic-1.1/util.c"
static void _strlcpy(char *to , char const   *from , int l ) 
{ 


  {
  {
#line 46
  memccpy((void */* __restrict  */)to, (void const   */* __restrict  */)from, '\000',
          (size_t )l);
#line 47
  *(to + (l - 1)) = (char )'\000';
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/sic-1.1/util.c"
static char *eat(char *s , int (*p)(int  ) , int r ) 
{ 
  int tmp ;

  {
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if ((unsigned long )s != (unsigned long )((char *)0)) {
      {
#line 52
      tmp = (*p)((int )*s);
      }
#line 52
      if (! (tmp == r)) {
#line 52
        goto while_break;
      }
    } else {
#line 52
      goto while_break;
    }
#line 53
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return (s);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/sic-1.1/util.c"
static char *skip(char *s , char c ) 
{ 
  char *tmp ;

  {
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if ((int )*s != (int )c) {
#line 59
      if (! ((int )*s != 0)) {
#line 59
        goto while_break;
      }
    } else {
#line 59
      goto while_break;
    }
#line 60
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  if ((int )*s != 0) {
#line 62
    tmp = s;
#line 62
    s ++;
#line 62
    *tmp = (char )'\000';
  }
#line 63
  return (s);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/sic-1.1/util.c"
static void trim(char *s ) 
{ 
  char *e ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 70
  tmp = strlen((char const   *)s);
#line 70
  e = (s + tmp) - 1;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    tmp___0 = __ctype_b_loc();
    }
#line 71
    if ((int const   )*(*tmp___0 + (int )*e) & 8192) {
#line 71
      if (! ((unsigned long )e > (unsigned long )s)) {
#line 71
        goto while_break;
      }
    } else {
#line 71
      goto while_break;
    }
#line 72
    e --;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  *(e + 1) = (char )'\000';
#line 74
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static char timestr[18]  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static void pout(char *channel___0 , char *fmt  , ...) 
{ 
  time_t t ;
  va_list ap ;
  struct tm *tmp ;

  {
  {
#line 29
  __builtin_va_start(ap, fmt);
#line 30
  vsnprintf((char */* __restrict  */)(bufout), sizeof(bufout), (char const   */* __restrict  */)fmt,
            ap);
#line 31
  __builtin_va_end(ap);
#line 32
  t = time((time_t *)((void *)0));
#line 33
  tmp = localtime((time_t const   *)(& t));
#line 33
  strftime((char */* __restrict  */)(timestr), sizeof(timestr), (char const   */* __restrict  */)"%D %R",
           (struct tm  const  */* __restrict  */)tmp);
#line 34
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%-12s: %s %s\n",
          channel___0, timestr, bufout);
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static void sout(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 41
  __builtin_va_start(ap, fmt);
#line 42
  vsnprintf((char */* __restrict  */)(bufout), sizeof(bufout), (char const   */* __restrict  */)fmt,
            ap);
#line 43
  __builtin_va_end(ap);
#line 44
  fprintf((FILE */* __restrict  */)srv, (char const   */* __restrict  */)"%s\r\n",
          bufout);
  }
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static void privmsg(char *channel___0 , char *msg ) 
{ 


  {
#line 49
  if ((int )*(channel___0 + 0) == 0) {
    {
#line 50
    pout((char *)"", (char *)"No channel to send to");
    }
#line 51
    return;
  }
  {
#line 53
  pout(channel___0, (char *)"<%s> %s", nick, msg);
#line 54
  sout((char *)"PRIVMSG %s :%s", channel___0, msg);
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static void parsein(char *s ) 
{ 
  char c ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 61
  if ((int )*(s + 0) == 0) {
#line 62
    return;
  }
  {
#line 63
  skip(s, (char )'\n');
  }
#line 64
  if ((int )*(s + 0) != 58) {
    {
#line 65
    privmsg(channel, s);
    }
#line 66
    return;
  }
#line 68
  s ++;
#line 68
  c = *s;
#line 69
  if ((int )c != 0) {
    {
#line 69
    tmp___1 = __ctype_b_loc();
    }
#line 69
    if ((int const   )*(*tmp___1 + (int )*(s + 1)) & 8192) {
#line 70
      p = s + 2;
      {
#line 72
      if ((int )c == 106) {
#line 72
        goto case_106;
      }
#line 77
      if ((int )c == 108) {
#line 77
        goto case_108;
      }
#line 88
      if ((int )c == 109) {
#line 88
        goto case_109;
      }
#line 95
      if ((int )c == 115) {
#line 95
        goto case_115;
      }
#line 71
      goto switch_break;
      case_106: /* CIL Label */ 
      {
#line 73
      sout((char *)"JOIN %s", p);
      }
#line 74
      if ((int )channel[0] == 0) {
        {
#line 75
        _strlcpy(channel, (char const   *)p, (int )sizeof(channel));
        }
      }
#line 76
      return;
      case_108: /* CIL Label */ 
      {
#line 78
      s = eat(p, (int (*)(int  ))(& isspace), 1);
#line 79
      p = eat(s, (int (*)(int  ))(& isspace), 0);
      }
#line 80
      if (! *s) {
#line 81
        s = channel;
      }
#line 82
      if (*p) {
#line 83
        tmp = p;
#line 83
        p ++;
#line 83
        *tmp = (char )'\000';
      }
#line 84
      if (! *p) {
#line 85
        p = (char *)"sic - 250 LOC are too much!";
      }
      {
#line 86
      sout((char *)"PART %s :%s", s, p);
      }
#line 87
      return;
      case_109: /* CIL Label */ 
      {
#line 89
      s = eat(p, (int (*)(int  ))(& isspace), 1);
#line 90
      p = eat(s, (int (*)(int  ))(& isspace), 0);
      }
#line 91
      if (*p) {
#line 92
        tmp___0 = p;
#line 92
        p ++;
#line 92
        *tmp___0 = (char )'\000';
      }
      {
#line 93
      privmsg(s, p);
      }
#line 94
      return;
      case_115: /* CIL Label */ 
      {
#line 96
      _strlcpy(channel, (char const   *)p, (int )sizeof(channel));
      }
#line 97
      return;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 100
  sout((char *)"%s", s);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
static void parsesrv(char *cmd ) 
{ 
  char *usr ;
  char *par ;
  char *txt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 107
  usr = host;
#line 108
  if (! cmd) {
#line 109
    return;
  } else
#line 108
  if (! *cmd) {
#line 109
    return;
  }
#line 110
  if ((int )*(cmd + 0) == 58) {
    {
#line 111
    usr = cmd + 1;
#line 112
    cmd = skip(usr, (char )' ');
    }
#line 113
    if ((int )*(cmd + 0) == 0) {
#line 114
      return;
    }
    {
#line 115
    skip(usr, (char )'!');
    }
  }
  {
#line 117
  skip(cmd, (char )'\r');
#line 118
  par = skip(cmd, (char )' ');
#line 119
  txt = skip(par, (char )':');
#line 120
  trim(par);
#line 121
  tmp = strcmp("PONG", (char const   *)cmd);
  }
#line 121
  if (! tmp) {
#line 122
    return;
  }
  {
#line 123
  tmp___3 = strcmp("PRIVMSG", (char const   *)cmd);
  }
#line 123
  if (tmp___3) {
    {
#line 125
    tmp___2 = strcmp("PING", (char const   *)cmd);
    }
#line 125
    if (tmp___2) {
      {
#line 128
      pout(usr, (char *)">< %s (%s): %s", cmd, par, txt);
#line 129
      tmp___0 = strcmp("NICK", (char const   *)cmd);
      }
#line 129
      if (! tmp___0) {
        {
#line 129
        tmp___1 = strcmp((char const   *)usr, (char const   *)(nick));
        }
#line 129
        if (! tmp___1) {
          {
#line 130
          _strlcpy(nick, (char const   *)txt, (int )sizeof(nick));
          }
        }
      }
    } else {
      {
#line 126
      sout((char *)"PONG %s", txt);
      }
    }
  } else {
    {
#line 124
    pout(par, (char *)"<%s> %s", usr, txt);
    }
  }
#line 132
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/sic-1.1/sic.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int c ;
  struct timeval tv ;
  char const   *user ;
  char *tmp ;
  fd_set rd ;
  char const   *tmp___0 ;
  int __d0 ;
  int __d1 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  time_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 138
  tmp = getenv("USER");
#line 138
  user = (char const   *)tmp;
  }
#line 141
  if (user) {
#line 141
    tmp___0 = user;
  } else {
#line 141
    tmp___0 = "unknown";
  }
  {
#line 141
  _strlcpy(nick, tmp___0, (int )sizeof(nick));
#line 142
  i = 1;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < argc)) {
#line 142
      goto while_break;
    }
#line 143
    c = (int )*(*(argv + i) + 1);
#line 144
    if ((int )*(*(argv + i) + 0) != 45) {
#line 145
      c = -1;
    } else
#line 144
    if (*(*(argv + i) + 2)) {
#line 145
      c = -1;
    }
    {
#line 147
    if (c == 104) {
#line 147
      goto case_104;
    }
#line 150
    if (c == 112) {
#line 150
      goto case_112;
    }
#line 153
    if (c == 110) {
#line 153
      goto case_110;
    }
#line 156
    if (c == 107) {
#line 156
      goto case_107;
    }
#line 159
    if (c == 118) {
#line 159
      goto case_118;
    }
#line 161
    goto switch_default;
    case_104: /* CIL Label */ 
#line 148
    i ++;
#line 148
    if (i < argc) {
#line 148
      host = *(argv + i);
    }
#line 149
    goto switch_break;
    case_112: /* CIL Label */ 
#line 151
    i ++;
#line 151
    if (i < argc) {
#line 151
      port = *(argv + i);
    }
#line 152
    goto switch_break;
    case_110: /* CIL Label */ 
#line 154
    i ++;
#line 154
    if (i < argc) {
      {
#line 154
      _strlcpy(nick, (char const   *)*(argv + i), (int )sizeof(nick));
      }
    }
#line 155
    goto switch_break;
    case_107: /* CIL Label */ 
#line 157
    i ++;
#line 157
    if (i < argc) {
#line 157
      password = *(argv + i);
    }
#line 158
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 160
    eprint("sic-1.1, \302\251 2005-2009 Kris Maglione, Anselm R. Garbe, Nico Golde\n");
    }
    switch_default: /* CIL Label */ 
    {
#line 162
    eprint("usage: sic [-h host] [-p port] [-n nick] [-k keyword] [-v]\n");
    }
    switch_break: /* CIL Label */ ;
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  i = dial(host, port);
#line 167
  srv = fdopen(i, "r+");
  }
#line 169
  if (password) {
    {
#line 170
    sout((char *)"PASS %s", password);
    }
  }
  {
#line 171
  sout((char *)"NICK %s", nick);
#line 172
  sout((char *)"USER %s localhost %s :%s", nick, host, nick);
#line 173
  fflush(srv);
#line 174
  setbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((void *)0));
#line 175
  setbuf((FILE */* __restrict  */)srv, (char */* __restrict  */)((void *)0));
  }
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 177
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 177
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rd.fds_bits[0]): "memory");
#line 177
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 178
    rd.fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 179
    tmp___1 = fileno(srv);
#line 179
    tmp___2 = fileno(srv);
#line 179
    rd.fds_bits[tmp___1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << tmp___2 % (8 * (int )sizeof(__fd_mask ));
#line 180
    tv.tv_sec = (__time_t )120;
#line 181
    tv.tv_usec = (__suseconds_t )0;
#line 182
    tmp___3 = fileno(srv);
#line 182
    i = select(tmp___3 + 1, (fd_set */* __restrict  */)(& rd), (fd_set */* __restrict  */)0,
               (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
    }
#line 183
    if (i < 0) {
      {
#line 184
      tmp___4 = __errno_location();
      }
#line 184
      if (*tmp___4 == 4) {
#line 185
        goto __Cont;
      }
      {
#line 186
      eprint("sic: error on select():");
      }
    } else
#line 188
    if (i == 0) {
      {
#line 189
      tmp___5 = time((time_t *)((void *)0));
      }
#line 189
      if (tmp___5 - trespond >= 300L) {
        {
#line 190
        eprint("sic shutting down: parse timeout\n");
        }
      }
      {
#line 191
      sout((char *)"PING %s", host);
      }
#line 192
      goto __Cont;
    }
    {
#line 194
    tmp___7 = fileno(srv);
#line 194
    tmp___8 = fileno(srv);
    }
#line 194
    if ((rd.fds_bits[tmp___7 / (8 * (int )sizeof(__fd_mask ))] & (1L << tmp___8 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 195
      tmp___6 = fgets((char */* __restrict  */)(bufin), (int )sizeof(bufin), (FILE */* __restrict  */)srv);
      }
#line 195
      if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
        {
#line 196
        eprint("sic: remote host closed connection\n");
        }
      }
      {
#line 197
      parsesrv(bufin);
#line 198
      trespond = time((time_t *)((void *)0));
      }
    }
#line 200
    if ((rd.fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 201
      tmp___9 = fgets((char */* __restrict  */)(bufin), (int )sizeof(bufin), (FILE */* __restrict  */)stdin);
      }
#line 201
      if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
        {
#line 202
        eprint("sic: broken pipe\n");
        }
      }
      {
#line 203
      parsein(bufin);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 206
  return (0);
}
}
