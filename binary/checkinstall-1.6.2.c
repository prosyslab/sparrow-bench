/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 186 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent64 {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 196 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
struct string_t;
#line 196 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
typedef struct string_t string_t;
#line 197 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
struct string_t {
   char *string ;
   string_t *next ;
};
#line 203 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
struct instw_t {
   int gstatus ;
   int dbglvl ;
   pid_t pid ;
   char *root ;
   char *backup ;
   char *transl ;
   char *meta ;
   char *mtransl ;
   char *mdirls ;
   string_t *exclude ;
   int error ;
   int status ;
   char path[4097] ;
   char reslvpath[4097] ;
   char truepath[4097] ;
   char translpath[4097] ;
   string_t *equivpaths ;
   char mtranslpath[4097] ;
   char mdirlspath[4097] ;
};
#line 203 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
typedef struct instw_t instw_t;
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *path ,
                                                                                     __mode_t mode ) ;
#line 297
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int filedes ,
                                                                      __mode_t mode ) ;
#line 303
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fchmodat)(int dirfd___0 ,
                                                                                        char const   *path ,
                                                                                        __mode_t mode ,
                                                                                        int flag ) ;
#line 321
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *pathname ,
                                                                                     __mode_t mode ) ;
#line 328
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) mkdirat)(int dirfd___0 ,
                                                                                       char const   *path ,
                                                                                       __mode_t mode ) ;
#line 401
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int version ,
                                                                                         char const   *pathname ,
                                                                                         struct stat *info ) ;
#line 403
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int version ,
                                                                                          char const   *pathname ,
                                                                                          struct stat *info ) ;
#line 405
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat)(int version ,
                                                                                            int dirfd___0 ,
                                                                                            char const   *path ,
                                                                                            struct stat *s ,
                                                                                            int flags ) ;
#line 434
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat64)(int version ,
                                                                                           char const   *pathname ,
                                                                                           struct stat64 *info ) ;
#line 436
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat64)(int version ,
                                                                                            char const   *pathname ,
                                                                                            struct stat64 *info ) ;
#line 438
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat64)(int version ,
                                                                                              int dirfd___0 ,
                                                                                              char const   *path ,
                                                                                              struct stat64 *s ,
                                                                                              int flags ) ;
#line 442
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) __xmknod)(int version ,
                                                                                          char const   *pathname ,
                                                                                          __mode_t mode ,
                                                                                          __dev_t *dev ) ;
#line 445
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5), __leaf__)) __xmknodat)(int version ,
                                                                                            int dirfd___0 ,
                                                                                            char const   *path ,
                                                                                            __mode_t mode ,
                                                                                            __dev_t *dev ) ;
#line 146 "/usr/include/fcntl.h"
int ( __attribute__((__nonnull__(1))) open)(char const   *pathname , int flags  , ...) ;
#line 156
int ( __attribute__((__nonnull__(1))) open64)(char const   *pathname , int flags 
                                              , ...) ;
#line 170
int ( __attribute__((__nonnull__(2))) openat)(int dirfd___0 , char const   *path ,
                                              int flags  , ...) ;
#line 192
int ( __attribute__((__nonnull__(1))) creat)(char const   *pathname , mode_t mode ) ;
#line 202
int ( __attribute__((__nonnull__(1))) creat64)(char const   *pathname , unsigned int mode ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 180
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *oldpath ,
                                                                      char const   *newpath ) ;
#line 185
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) renameat)(int olddirfd ,
                                                                        char const   *oldpath ,
                                                                        int newdirfd ,
                                                                        char const   *newpath ) ;
#line 272
FILE *fopen(char const   * __restrict  pathname , char const   * __restrict  mode ) ;
#line 297
FILE *fopen64(char const   * __restrict  pathname , char const   * __restrict  mode ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 734
 __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  file_name ,
                                                                          char * __restrict  resolved_name ) ;
#line 64 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 287 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *pathname ,
                                                                                      int type ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 473
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *path ,
                                                                                     __uid_t owner ,
                                                                                     __gid_t group ) ;
#line 478
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int fd , __uid_t owner ,
                                                                      __gid_t group ) ;
#line 483
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) lchown)(char const   *path ,
                                                                                      __uid_t owner ,
                                                                                      __gid_t group ) ;
#line 491
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fchownat)(int dirfd___0 ,
                                                                                        char const   *path ,
                                                                                        __uid_t owner ,
                                                                                        __gid_t group ,
                                                                                        int flags ) ;
#line 497
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *pathname ) ;
#line 511
 __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *buffer ,
                                                                        size_t size ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 790
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *oldpath ,
                                                                                      char const   *newpath ) ;
#line 796
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) linkat)(int olddirfd ,
                                                                                        char const   *oldpath ,
                                                                                        int newdirfd ,
                                                                                        char const   *newpath ,
                                                                                        int flags ) ;
#line 803
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *pathname ,
                                                                                         char const   *slink ) ;
#line 809
 __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  path ,
                                                                                              char * __restrict  buf ,
                                                                                              size_t bufsiz ) ;
#line 816
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3), __leaf__)) symlinkat)(char const   *oldpath ,
                                                                                           int dirfd___0 ,
                                                                                           char const   *newpath ) ;
#line 820
 __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(2,3), __leaf__)) readlinkat)(int dirfd___0 ,
                                                                                                char const   * __restrict  path ,
                                                                                                char * __restrict  buf ,
                                                                                                size_t bufsiz ) ;
#line 826
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *pathname ) ;
#line 830
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int dirfd___0 ,
                                                                                        char const   *path ,
                                                                                        int flags ) ;
#line 835
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *pathname ) ;
#line 944
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *path ) ;
#line 993
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) truncate)(char const   *path ,
                                                                                        __off_t length ) ;
#line 1005
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) truncate64)(char const   *path ,
                                                                                          __off64_t length ) ;
#line 1016
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int fd ,
                                                                         __off_t length ) ;
#line 1026
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate64)(int fd ,
                                                                           __off64_t length ) ;
#line 26 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dirname)(char *__path ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 604
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const   *__filename ) ;
#line 192 "/usr/include/time.h"
 __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *timer ) ;
#line 45 "/usr/include/utime.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *pathname ,
                                                                                     struct utimbuf  const  *newtimes ) ;
#line 134 "/usr/include/dirent.h"
DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *dirname___0 ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *dir ) ;
#line 173
struct dirent64 *( __attribute__((__nonnull__(1))) readdir64)(DIR *dir ) ;
#line 254
int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  dir ,
                                                 struct dirent *** __restrict  namelist ,
                                                 int (*select___0)(struct dirent  const  * ) ,
                                                 int (*compar)(struct dirent  const  ** ,
                                                               struct dirent  const  ** ) ) ;
#line 277
int ( __attribute__((__nonnull__(1,2))) scandir64)(char const   * __restrict  dir ,
                                                   struct dirent64 *** __restrict  namelist ,
                                                   int (*select___0)(struct dirent64  const  * ) ,
                                                   int (*compar)(struct dirent64  const  ** ,
                                                                 struct dirent64  const  ** ) ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int __installwatch_refcount  =    0;
#line 68 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int __installwatch_timecount  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static time_t (*true_time)(time_t * )  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_chdir)(char const   * )  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_chmod)(char const   * , mode_t  )  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_chown)(char const   * , uid_t  , gid_t  )  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_chroot)(char const   * )  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_creat)(char const   * , mode_t  )  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_fchmod)(int  , mode_t  )  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_fchown)(int  , uid_t  , gid_t  )  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static FILE *(*true_fopen)(char const   * , char const   * )  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_ftruncate)(int  , off_t  )  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static char *(*true_getcwd)(char * , size_t  )  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_lchown)(char const   * , uid_t  , gid_t  )  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_link)(char const   * , char const   * )  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_mkdir)(char const   * , mode_t  )  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_xmknod)(int ver , char const   * , mode_t  , dev_t * )  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_open)(char const   * , int   , ...)  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static DIR *(*true_opendir)(char const   * )  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static struct dirent *(*true_readdir)(DIR *dir )  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static ssize_t (*true_readlink)(char const   * , char * , size_t  )  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static char *(*true_realpath)(char const   * , char * )  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_rename)(char const   * , char const   * )  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_rmdir)(char const   * )  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_xstat)(int  , char const   * , struct stat * )  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_lxstat)(int  , char const   * , struct stat * )  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_scandir)(char const   * , struct dirent *** , int (*)(struct dirent  const  * ) ,
                           int (*)(struct dirent  const  ** , struct dirent  const  ** ) )  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_symlink)(char const   * , char const   * )  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_truncate)(char const   * , off_t  )  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_unlink)(char const   * )  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_utime)(char const   * , struct utimbuf  const  * )  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_utimes)(char const   * , struct timeval  const  * )  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_access)(char const   * , int  )  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_setxattr)(char const   * , char const   * , void const   * , size_t  ,
                            int  )  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_removexattr)(char const   * , char const   * )  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_creat64)(char const   * , __mode_t  )  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static FILE *(*true_fopen64)(char const   * , char const   * )  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_ftruncate64)(int  , __off64_t  )  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_open64)(char const   * , int   , ...)  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static struct dirent64 *(*true_readdir64)(DIR *dir )  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_scandir64)(char const   * , struct dirent64 *** , int (*)(struct dirent64  const  * ) ,
                             int (*)(struct dirent64  const  ** , struct dirent64  const  ** ) )  ;
#line 118 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_xstat64)(int  , char const   * , struct stat64 * )  ;
#line 119 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_lxstat64)(int  , char const   * , struct stat64 * )  ;
#line 120 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_truncate64)(char const   * , __off64_t  )  ;
#line 123 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_openat)(int  , char const   * , int   , ...)  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_fchmodat)(int  , char const   * , mode_t  , int  )  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_fchownat)(int  , char const   * , uid_t  , gid_t  , int  )  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_fxstatat)(int  , int  , char const   * , struct stat * , int  )  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_fxstatat64)(int  , int  , char const   * , struct stat64 * , int  )  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_linkat)(int  , char const   * , int  , char const   * , int  )  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_mkdirat)(int  , char const   * , mode_t  )  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_readlinkat)(int  , char const   * , char * , size_t  )  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_xmknodat)(int  , int  , char const   * , mode_t  , dev_t * )  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_renameat)(int  , char const   * , int  , char const   * )  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_symlinkat)(char const   * , int  , char const   * )  ;
#line 134 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int (*true_unlinkat)(int  , char const   * , int  )  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
__inline static int true_stat(char const   *pathname , struct stat *info ) 
{ 
  int tmp ;

  {
  {
#line 143
  tmp = (*true_xstat)(1, pathname, info);
  }
#line 143
  return (tmp);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
__inline static int true_mknod(char const   *pathname , mode_t mode , dev_t dev ) 
{ 
  int tmp ;

  {
  {
#line 147
  tmp = (*true_xmknod)(0, pathname, mode, & dev);
  }
#line 147
  return (tmp);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
__inline static int true_lstat(char const   *pathname , struct stat *info ) 
{ 
  int tmp ;

  {
  {
#line 151
  tmp = (*true_lxstat)(1, pathname, info);
  }
#line 151
  return (tmp);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static instw_t __instw  ;
#line 242
static int canonicalize(char const   *path , char *resolved_path ) ;
#line 243
static int reduce(char *path ) ;
#line 244
static int make_path(char const   *path ) ;
#line 245
static int copy_path(char const   *truepath , char const   *translroot ) ;
#line 246
__inline static int path_excluded(char const   *truepath ) ;
#line 247
static int unlink_recursive(char const   *truepath ) ;
#line 249
int expand_path(string_t **list , char const   *prefix , char const   *suffix ) ;
#line 250
int parse_suffix(char *pnp , char *pns , char const   *suffix ) ;
#line 258
static int __instw_printdirent(struct dirent *entry ) ;
#line 259
static int __instw_printdirent64(struct dirent64 *entry ) ;
#line 263
static int instw_print(instw_t *instw ) ;
#line 265
static int instw_init(void) ;
#line 266
static int instw_fini(void) ;
#line 268
static int instw_new(instw_t *instw ) ;
#line 269
static int instw_delete(instw_t *instw ) ;
#line 272
static int instw_setmetatransl(instw_t *instw ) ;
#line 274
static int instw_setpath(instw_t *instw , char const   *path ) ;
#line 275
static int instw_setpathrel(instw_t *instw , int dirfd___0 , char const   *relpath ) ;
#line 276
static int instw_getstatus(instw_t *instw , int *status ) ;
#line 277
static int instw_apply(instw_t *instw ) ;
#line 278
static int instw_filldirls(instw_t *instw ) ;
#line 279
static int instw_makedirls(instw_t *instw ) ;
#line 281
static int backup(char const   *path ) ;
#line 283
static int vlambda_log(char const   *logname , char const   *format , va_list ap ) ;
#line 293
__inline static int ( /* format attribute */  logg)(char const   *format  , ...) ;
#line 301
__inline static int ( /* format attribute */  debug)(int dbglvl , char const   *format 
                                                     , ...) ;
#line 314 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static void *libc_handle  =    (void *)0;
#line 315 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static void initialize(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  void *tmp___37 ;
  void *tmp___38 ;
  void *tmp___39 ;
  void *tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  void *tmp___43 ;
  void *tmp___44 ;
  void *tmp___45 ;
  void *tmp___46 ;
  void *tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  void *tmp___50 ;
  void *tmp___51 ;
  void *tmp___52 ;
  int tmp___53 ;

  {
#line 316
  if (libc_handle) {
#line 317
    return;
  }
  {
#line 324
  libc_handle = (void *)-1L;
#line 327
  tmp = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"time");
#line 327
  true_time = (time_t (*)(time_t * ))tmp;
#line 328
  tmp___0 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"chdir");
#line 328
  true_chdir = (int (*)(char const   * ))tmp___0;
#line 329
  tmp___1 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"chmod");
#line 329
  true_chmod = (int (*)(char const   * , mode_t  ))tmp___1;
#line 330
  tmp___2 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"chown");
#line 330
  true_chown = (int (*)(char const   * , uid_t  , gid_t  ))tmp___2;
#line 331
  tmp___3 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"chroot");
#line 331
  true_chroot = (int (*)(char const   * ))tmp___3;
#line 332
  tmp___4 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"creat");
#line 332
  true_creat = (int (*)(char const   * , mode_t  ))tmp___4;
#line 333
  tmp___5 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"fchmod");
#line 333
  true_fchmod = (int (*)(int  , mode_t  ))tmp___5;
#line 334
  tmp___6 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"fchown");
#line 334
  true_fchown = (int (*)(int  , uid_t  , gid_t  ))tmp___6;
#line 335
  tmp___7 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"fopen");
#line 335
  true_fopen = (FILE *(*)(char const   * , char const   * ))tmp___7;
#line 336
  tmp___8 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"ftruncate");
#line 336
  true_ftruncate = (int (*)(int  , off_t  ))tmp___8;
#line 337
  tmp___9 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"getcwd");
#line 337
  true_getcwd = (char *(*)(char * , size_t  ))tmp___9;
#line 338
  tmp___10 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"lchown");
#line 338
  true_lchown = (int (*)(char const   * , uid_t  , gid_t  ))tmp___10;
#line 339
  tmp___11 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"link");
#line 339
  true_link = (int (*)(char const   * , char const   * ))tmp___11;
#line 340
  tmp___12 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"mkdir");
#line 340
  true_mkdir = (int (*)(char const   * , mode_t  ))tmp___12;
#line 341
  tmp___13 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"__xmknod");
#line 341
  true_xmknod = (int (*)(int ver , char const   * , mode_t  , dev_t * ))tmp___13;
#line 342
  tmp___14 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"open");
#line 342
  true_open = (int (*)(char const   * , int   , ...))tmp___14;
#line 343
  tmp___15 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"opendir");
#line 343
  true_opendir = (DIR *(*)(char const   * ))tmp___15;
#line 344
  tmp___16 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"readdir");
#line 344
  true_readdir = (struct dirent *(*)(DIR *dir ))tmp___16;
#line 345
  tmp___17 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"readlink");
#line 345
  true_readlink = (ssize_t (*)(char const   * , char * , size_t  ))tmp___17;
#line 346
  tmp___18 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"realpath");
#line 346
  true_realpath = (char *(*)(char const   * , char * ))tmp___18;
#line 347
  tmp___19 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"rename");
#line 347
  true_rename = (int (*)(char const   * , char const   * ))tmp___19;
#line 348
  tmp___20 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"rmdir");
#line 348
  true_rmdir = (int (*)(char const   * ))tmp___20;
#line 349
  tmp___21 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"scandir");
#line 349
  true_scandir = (int (*)(char const   * , struct dirent *** , int (*)(struct dirent  const  * ) ,
                          int (*)(struct dirent  const  ** , struct dirent  const  ** ) ))tmp___21;
#line 350
  tmp___22 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"__xstat");
#line 350
  true_xstat = (int (*)(int  , char const   * , struct stat * ))tmp___22;
#line 351
  tmp___23 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"__lxstat");
#line 351
  true_lxstat = (int (*)(int  , char const   * , struct stat * ))tmp___23;
#line 352
  tmp___24 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"symlink");
#line 352
  true_symlink = (int (*)(char const   * , char const   * ))tmp___24;
#line 353
  tmp___25 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"truncate");
#line 353
  true_truncate = (int (*)(char const   * , off_t  ))tmp___25;
#line 354
  tmp___26 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"unlink");
#line 354
  true_unlink = (int (*)(char const   * ))tmp___26;
#line 355
  tmp___27 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"utime");
#line 355
  true_utime = (int (*)(char const   * , struct utimbuf  const  * ))tmp___27;
#line 356
  tmp___28 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"setxattr");
#line 356
  true_setxattr = (int (*)(char const   * , char const   * , void const   * , size_t  ,
                           int  ))tmp___28;
#line 357
  tmp___29 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"utimes");
#line 357
  true_utimes = (int (*)(char const   * , struct timeval  const  * ))tmp___29;
#line 358
  tmp___30 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"access");
#line 358
  true_access = (int (*)(char const   * , int  ))tmp___30;
#line 362
  tmp___31 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"creat64");
#line 362
  true_creat64 = (int (*)(char const   * , __mode_t  ))tmp___31;
#line 363
  tmp___32 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"fopen64");
#line 363
  true_fopen64 = (FILE *(*)(char const   * , char const   * ))tmp___32;
#line 364
  tmp___33 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"ftruncate64");
#line 364
  true_ftruncate64 = (int (*)(int  , __off64_t  ))tmp___33;
#line 365
  tmp___34 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"open64");
#line 365
  true_open64 = (int (*)(char const   * , int   , ...))tmp___34;
#line 366
  tmp___35 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"readdir64");
#line 366
  true_readdir64 = (struct dirent64 *(*)(DIR *dir ))tmp___35;
#line 367
  tmp___36 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"scandir64");
#line 367
  true_scandir64 = (int (*)(char const   * , struct dirent64 *** , int (*)(struct dirent64  const  * ) ,
                            int (*)(struct dirent64  const  ** , struct dirent64  const  ** ) ))tmp___36;
#line 368
  tmp___37 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"__xstat64");
#line 368
  true_xstat64 = (int (*)(int  , char const   * , struct stat64 * ))tmp___37;
#line 369
  tmp___38 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"__lxstat64");
#line 369
  true_lxstat64 = (int (*)(int  , char const   * , struct stat64 * ))tmp___38;
#line 370
  tmp___39 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"truncate64");
#line 370
  true_truncate64 = (int (*)(char const   * , __off64_t  ))tmp___39;
#line 371
  tmp___40 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"removexattr");
#line 371
  true_removexattr = (int (*)(char const   * , char const   * ))tmp___40;
#line 374
  tmp___41 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"openat");
#line 374
  true_openat = (int (*)(int  , char const   * , int   , ...))tmp___41;
#line 375
  tmp___42 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"fchmodat");
#line 375
  true_fchmodat = (int (*)(int  , char const   * , mode_t  , int  ))tmp___42;
#line 376
  tmp___43 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"fchownat");
#line 376
  true_fchownat = (int (*)(int  , char const   * , uid_t  , gid_t  , int  ))tmp___43;
#line 377
  tmp___44 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"__fxstatat");
#line 377
  true_fxstatat = (int (*)(int  , int  , char const   * , struct stat * , int  ))tmp___44;
#line 378
  tmp___45 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"__fxstatat64");
#line 378
  true_fxstatat64 = (int (*)(int  , int  , char const   * , struct stat64 * , int  ))tmp___45;
#line 379
  tmp___46 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"linkat");
#line 379
  true_linkat = (int (*)(int  , char const   * , int  , char const   * , int  ))tmp___46;
#line 380
  tmp___47 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"mkdirat");
#line 380
  true_mkdirat = (int (*)(int  , char const   * , mode_t  ))tmp___47;
#line 381
  tmp___48 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"readlinkat");
#line 381
  true_readlinkat = (int (*)(int  , char const   * , char * , size_t  ))tmp___48;
#line 382
  tmp___49 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"__xmknodat");
#line 382
  true_xmknodat = (int (*)(int  , int  , char const   * , mode_t  , dev_t * ))tmp___49;
#line 383
  tmp___50 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"renameat");
#line 383
  true_renameat = (int (*)(int  , char const   * , int  , char const   * ))tmp___50;
#line 384
  tmp___51 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"symlinkat");
#line 384
  true_symlinkat = (int (*)(char const   * , int  , char const   * ))tmp___51;
#line 385
  tmp___52 = dlsym((void */* __restrict  */)libc_handle, (char const   */* __restrict  */)"unlinkat");
#line 385
  true_unlinkat = (int (*)(int  , char const   * , int  ))tmp___52;
#line 388
  tmp___53 = instw_init();
  }
#line 388
  if (tmp___53) {
    {
#line 388
    exit(-1);
    }
  }
#line 389
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
void _init(void) 
{ 


  {
  {
#line 392
  initialize();
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
void _fini(void) 
{ 


  {
  {
#line 396
  instw_fini();
  }
#line 397
  return;
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int vlambda_log(char const   *logname , char const   *format , va_list ap ) 
{ 
  char buffer[1024] ;
  int count ;
  int logfd ;
  int rcod ;
  int s_errno ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 412
  rcod = 0;
#line 416
  tmp = __errno_location();
#line 416
  s_errno = *tmp;
#line 418
  buffer[1022] = (char )'\n';
#line 419
  buffer[1023] = (char )'\000';
#line 421
  count = vsnprintf((char */* __restrict  */)(buffer), (size_t )1024, (char const   */* __restrict  */)format,
                    ap);
  }
#line 422
  if (count == -1) {
    {
#line 424
    strcpy((char */* __restrict  */)(& buffer[1019]), (char const   */* __restrict  */)"...\n");
#line 425
    count = 1023;
    }
  } else {
    {
#line 429
    tmp___0 = strlen((char const   *)(buffer));
#line 429
    count = (int )tmp___0;
    }
  }
#line 432
  if ((unsigned long )logname != (unsigned long )((void *)0)) {
    {
#line 433
    logfd = (*true_open)(logname, 1089, 438);
    }
#line 434
    if (logfd >= 0) {
      {
#line 435
      tmp___3 = write(logfd, (void const   *)(buffer), (size_t )count);
      }
#line 435
      if (tmp___3 != (ssize_t )count) {
        {
#line 436
        tmp___1 = __errno_location();
#line 436
        tmp___2 = strerror(*tmp___1);
#line 436
        syslog(((1 << 3) | 6) | 1, "Count not write `%s\' in `%s\': %s\n", buffer,
               logname, tmp___2);
        }
      }
      {
#line 439
      tmp___6 = close(logfd);
      }
#line 439
      if (tmp___6 < 0) {
        {
#line 440
        tmp___4 = __errno_location();
#line 440
        tmp___5 = strerror(*tmp___4);
#line 440
        syslog(((1 << 3) | 6) | 1, "Could not close `%s\': %s\n", logname, tmp___5);
        }
      }
    } else {
      {
#line 444
      tmp___7 = __errno_location();
#line 444
      tmp___8 = strerror(*tmp___7);
#line 444
      syslog(((1 << 3) | 6) | 1, "Could not open `%s\' to write `%s\': %s\n", logname,
             buffer, tmp___8);
      }
    }
  } else {
    {
#line 449
    syslog(((1 << 3) | 6) | 1, "%s", buffer);
    }
  }
  {
#line 453
  tmp___9 = __errno_location();
#line 453
  *tmp___9 = s_errno;
  }
#line 455
  return (rcod);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
__inline static int ( /* format attribute */  logg)(char const   *format  , ...) 
{ 
  char *logname ;
  va_list ap ;
  int rcod ;

  {
  {
#line 492
  logname = getenv("INSTW_LOGFILE");
#line 493
  __builtin_va_start(ap, format);
#line 494
  rcod = vlambda_log((char const   *)logname, format, ap);
#line 495
  __builtin_va_end(ap);
  }
#line 497
  return (rcod);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
__inline static int ( /* format attribute */  debug)(int dbglvl , char const   *format 
                                                     , ...) 
{ 
  int rcod ;
  char *logname ;
  va_list ap ;

  {
#line 501
  rcod = 0;
#line 506
  if (__instw.dbglvl == 0) {
#line 508
    return (rcod);
  } else
#line 506
  if (dbglvl > __instw.dbglvl) {
#line 508
    return (rcod);
  } else
#line 506
  if (dbglvl < 0) {
#line 508
    return (rcod);
  }
  {
#line 510
  logname = getenv("INSTW_DBGFILE");
#line 511
  __builtin_va_start(ap, format);
#line 512
  rcod = vlambda_log((char const   *)logname, format, ap);
#line 513
  __builtin_va_end(ap);
  }
#line 516
  return (rcod);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int canonicalize(char const   *path , char *resolved_path ) 
{ 
  int s_errno ;
  int *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 533
  tmp = __errno_location();
#line 533
  s_errno = *tmp;
#line 535
  __instw.gstatus &= ~ (1 << 1);
#line 537
  tmp___1 = realpath((char const   */* __restrict  */)path, (char */* __restrict  */)resolved_path);
  }
#line 537
  if (! tmp___1) {
#line 538
    if ((int const   )*(path + 0) != 47) {
      {
#line 542
      (*true_getcwd)(resolved_path, (size_t )4094);
#line 543
      *(resolved_path + 4094) = (char )'\000';
#line 544
      strcat((char */* __restrict  */)resolved_path, (char const   */* __restrict  */)"/");
#line 545
      tmp___0 = strlen((char const   *)resolved_path);
#line 545
      strncat((char */* __restrict  */)resolved_path, (char const   */* __restrict  */)path,
              4095UL - tmp___0);
      }
    } else {
      {
#line 547
      strcpy((char */* __restrict  */)resolved_path, (char const   */* __restrict  */)path);
      }
    }
  }
  {
#line 551
  __instw.gstatus |= 1 << 1;
#line 554
  debug(4, "canonicalize(%s,%s)\n", path, resolved_path);
#line 557
  tmp___2 = __errno_location();
#line 557
  *tmp___2 = s_errno;
  }
#line 559
  return (0);
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int reduce(char *path ) 
{ 
  int len ;
  char *off ;
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *off2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 586
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 587
    tmp = __errno_location();
#line 587
    *tmp = 22;
    }
#line 588
    return (-1);
  } else
#line 586
  if ((int )*path != 47) {
    {
#line 587
    tmp = __errno_location();
#line 587
    *tmp = 22;
    }
#line 588
    return (-1);
  }
  {
#line 591
  tmp___0 = strlen((char const   *)path);
#line 591
  len = (int )tmp___0;
#line 594
  off = strstr((char const   *)path, "//");
  }
#line 594
  if (off) {
    {
#line 595
    memmove((void *)off, (void const   *)(off + 1), (size_t )((long )len - (off - path)));
#line 596
    tmp___1 = reduce(path);
    }
#line 596
    return (tmp___1);
  }
  {
#line 600
  off = strstr((char const   *)path, "/./");
  }
#line 600
  if (off) {
    {
#line 601
    memmove((void *)off, (void const   *)(off + 2), (size_t )((long )(len - 1) - (off - path)));
#line 602
    tmp___2 = reduce(path);
    }
#line 602
    return (tmp___2);
  }
  {
#line 606
  off = strstr((char const   *)path, "/../");
  }
#line 606
  if (off) {
#line 607
    off2 = off;
#line 608
    tmp___3 = off2;
#line 608
    off2 ++;
#line 608
    if ((unsigned long )tmp___3 != (unsigned long )path) {
      {
#line 609
      while (1) {
        while_continue: /* CIL Label */ ;
#line 609
        off2 --;
#line 609
        if (! ((int )*(off2 + -1) != 47)) {
#line 609
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 610
    memmove((void *)off2, (void const   *)(off + 4), (size_t )((long )(len - 3) - (off - path)));
#line 611
    tmp___4 = reduce(path);
    }
#line 611
    return (tmp___4);
  }
  {
#line 616
  if ((int )*(path + (len - 1)) == 46) {
#line 616
    goto case_46;
  }
#line 631
  if ((int )*(path + (len - 1)) == 47) {
#line 631
    goto case_47___0;
  }
#line 636
  goto switch_default___0;
  case_46: /* CIL Label */ 
  {
#line 620
  if ((int )*(path + (len - 2)) == 46) {
#line 620
    goto case_46___0;
  }
#line 629
  if ((int )*(path + (len - 2)) == 47) {
#line 629
    goto case_47;
  }
#line 618
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 619
  return (0);
  case_46___0: /* CIL Label */ 
#line 621
  if (len != 3) {
#line 622
    off = (path + len) - 3;
#line 623
    tmp___5 = off;
#line 623
    off --;
#line 623
    if ((int )*tmp___5 != 47) {
#line 624
      return (0);
    }
    {
#line 625
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 625
      off --;
#line 625
      if (! ((int )*off != 47)) {
#line 625
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 626
    *(off + 1) = (char)0;
#line 627
    tmp___6 = reduce(path);
    }
#line 627
    return (tmp___6);
  }
  case_47: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
  case_47___0: /* CIL Label */ 
#line 632
  if (len != 1) {
    {
#line 633
    *(path + (len - 1)) = (char)0;
#line 634
    tmp___7 = reduce(path);
    }
#line 634
    return (tmp___7);
  }
  switch_default___0: /* CIL Label */ 
#line 637
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int make_path(char const   *path ) 
{ 
  char checkdir[8192] ;
  struct stat inode ;
  int s_errno ;
  int i ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 645
  i = 0;
#line 647
  tmp = __errno_location();
#line 647
  s_errno = *tmp;
#line 650
  debug(2, "===== make_path: %s\n", path);
  }
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (! ((int const   )*(path + i) != 0)) {
#line 653
      goto while_break;
    }
#line 654
    checkdir[i] = (char )*(path + i);
#line 655
    if ((int )checkdir[i] == 47) {
      {
#line 656
      checkdir[i + 1] = (char )'\000';
#line 657
      tmp___0 = true_stat((char const   *)(checkdir), & inode);
      }
#line 657
      if (tmp___0 < 0) {
        {
#line 658
        (*true_mkdir)((char const   *)(checkdir), (mode_t )448);
        }
      }
    }
#line 660
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 664
  tmp___1 = __errno_location();
#line 664
  *tmp___1 = s_errno;
  }
#line 666
  return (0);
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int copy_path(char const   *truepath , char const   *translroot ) 
{ 
  int rcod ;
  char buffer[8192] ;
  int bytes ;
  char translpath[4097] ;
  struct stat trueinfo ;
  struct stat translinfo ;
  int truefd ;
  int translfd ;
  struct utimbuf timbuf ;
  size_t truesz ;
  char linkpath[4097] ;
  ssize_t linksz ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 703
  debug(2, "copy_path(%s,%s)\n", truepath, translroot);
#line 706
  rcod = true_lstat(truepath, & trueinfo);
  }
#line 707
  if (rcod < 0) {
    {
#line 707
    tmp = __errno_location();
    }
#line 707
    if (*tmp != 2) {
#line 707
      return (-1);
    }
  }
#line 708
  if (! rcod) {
    {
#line 709
    tmp___1 = strlen(truepath);
#line 709
    tmp___2 = strlen((char const   *)(translpath));
#line 709
    truesz = tmp___1 + tmp___2;
    }
#line 709
    if (truesz > 4096UL) {
      {
#line 710
      tmp___0 = __errno_location();
#line 710
      *tmp___0 = 36;
      }
#line 711
      return (-1);
    }
    {
#line 714
    strncpy((char */* __restrict  */)(translpath), (char const   */* __restrict  */)translroot,
            (size_t )4096);
#line 715
    strncat((char */* __restrict  */)(translpath), (char const   */* __restrict  */)truepath,
            4096UL - truesz);
#line 717
    tmp___3 = true_lstat((char const   *)(translpath), & translinfo);
    }
#line 717
    if (! tmp___3) {
#line 717
      return (0);
    }
#line 720
    if ((trueinfo.st_mode & 61440U) == 40960U) {
      {
#line 721
      linksz = (*true_readlink)(truepath, linkpath, (size_t )4096);
      }
#line 721
      if (linksz < 0L) {
#line 721
        return (-1);
      }
      {
#line 722
      linkpath[linksz] = (char )'\000';
#line 723
      tmp___4 = (*true_symlink)((char const   *)(linkpath), (char const   *)(translpath));
      }
#line 723
      if (tmp___4 != 0) {
#line 723
        return (-1);
      }
    }
#line 727
    if ((trueinfo.st_mode & 61440U) == 32768U) {
      {
#line 728
      truefd = (*true_open)(truepath, 0);
      }
#line 728
      if (truefd < 0) {
#line 728
        return (-1);
      }
      {
#line 729
      translfd = (*true_open)((char const   *)(translpath), 577, trueinfo.st_mode);
      }
#line 729
      if (translfd < 0) {
        {
#line 732
        close(truefd);
        }
#line 733
        return (-1);
      }
      {
#line 736
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 736
        tmp___5 = read(truefd, (void *)(buffer), (size_t )8192);
#line 736
        bytes = (int )tmp___5;
        }
#line 736
        if (! (bytes > 0)) {
#line 736
          goto while_break;
        }
        {
#line 737
        write(translfd, (void const   *)(buffer), (size_t )bytes);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 739
      close(truefd);
#line 740
      close(translfd);
      }
    }
#line 744
    if ((trueinfo.st_mode & 61440U) == 16384U) {
      {
#line 745
      tmp___6 = (*true_mkdir)((char const   *)(translpath), trueinfo.st_mode);
      }
#line 745
      if (tmp___6) {
#line 745
        return (-1);
      }
    }
#line 749
    if ((trueinfo.st_mode & 61440U) == 24576U) {
      {
#line 750
      tmp___7 = true_mknod((char const   *)(translpath), trueinfo.st_mode | 24576U,
                           trueinfo.st_rdev);
      }
#line 750
      if (tmp___7) {
#line 751
        return (-1);
      }
    }
#line 755
    if ((trueinfo.st_mode & 61440U) == 8192U) {
      {
#line 756
      tmp___8 = true_mknod((char const   *)(translpath), trueinfo.st_mode | 8192U,
                           trueinfo.st_rdev);
      }
#line 756
      if (tmp___8) {
#line 757
        return (-1);
      }
    }
#line 761
    if ((trueinfo.st_mode & 61440U) == 4096U) {
      {
#line 762
      tmp___9 = true_mknod((char const   *)(translpath), trueinfo.st_mode | 4096U,
                           (dev_t )0);
      }
#line 762
      if (tmp___9) {
#line 763
        return (-1);
      }
    }
    {
#line 766
    timbuf.actime = trueinfo.st_atim.tv_sec;
#line 767
    timbuf.modtime = trueinfo.st_mtim.tv_sec;
#line 768
    (*true_utime)((char const   *)(translpath), (struct utimbuf  const  *)(& timbuf));
    }
#line 770
    if (! ((trueinfo.st_mode & 61440U) == 40960U)) {
      {
#line 771
      (*true_chown)((char const   *)(translpath), trueinfo.st_uid, trueinfo.st_gid);
#line 772
      (*true_chmod)((char const   *)(translpath), trueinfo.st_mode);
      }
    }
  }
#line 776
  return (0);
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
__inline static int path_excluded(char const   *truepath ) 
{ 
  string_t *pnext ;
  int result ;
  char *tmp ;

  {
#line 795
  result = 0;
#line 796
  pnext = __instw.exclude;
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if (! ((unsigned long )pnext != (unsigned long )((void *)0))) {
#line 798
      goto while_break;
    }
    {
#line 799
    tmp = strstr(truepath, (char const   *)pnext->string);
    }
#line 799
    if ((unsigned long )tmp == (unsigned long )truepath) {
#line 800
      result = 1;
#line 801
      goto while_break;
    }
#line 803
    pnext = pnext->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 806
  return (result);
}
}
#line 828 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int unlink_recursive(char const   *truepath ) 
{ 
  int rcod ;
  struct stat trueinfo ;
  DIR *wdir ;
  struct dirent *went ;
  char wpath[4097] ;
  struct stat winfo ;
  int *tmp ;

  {
  {
#line 837
  debug(2, "unlink_recursive(%s)\n", truepath);
#line 840
  rcod = true_lstat(truepath, & trueinfo);
  }
#line 841
  if (rcod < 0) {
    {
#line 841
    tmp = __errno_location();
    }
#line 841
    if (*tmp != 2) {
#line 841
      return (-1);
    }
  }
#line 842
  if (rcod != 0) {
#line 842
    return (0);
  }
#line 844
  if ((trueinfo.st_mode & 61440U) == 16384U) {
    {
#line 845
    wdir = (*true_opendir)(truepath);
    }
#line 846
    if ((unsigned long )wdir == (unsigned long )((void *)0)) {
#line 846
      return (-1);
    }
    {
#line 847
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 847
      went = (*true_readdir)(wdir);
      }
#line 847
      if (! ((unsigned long )went != (unsigned long )((void *)0))) {
#line 847
        goto while_break;
      }
#line 849
      if ((int )went->d_name[0] == 46) {
#line 849
        if ((int )went->d_name[1] == 0) {
#line 853
          goto while_continue;
        } else
#line 849
        if ((int )went->d_name[1] == 46) {
#line 849
          if ((int )went->d_name[2] == 0) {
#line 853
            goto while_continue;
          }
        }
      }
      {
#line 856
      strcpy((char */* __restrict  */)(wpath), (char const   */* __restrict  */)truepath);
#line 857
      strcat((char */* __restrict  */)(wpath), (char const   */* __restrict  */)"/");
#line 858
      strcat((char */* __restrict  */)(wpath), (char const   */* __restrict  */)(went->d_name));
#line 859
      rcod = true_lstat((char const   *)(wpath), & winfo);
      }
#line 860
      if (rcod != 0) {
        {
#line 861
        closedir(wdir);
        }
#line 862
        return (-1);
      }
#line 865
      if ((winfo.st_mode & 61440U) == 16384U) {
        {
#line 866
        unlink_recursive((char const   *)(wpath));
#line 867
        (*true_rmdir)((char const   *)(wpath));
        }
      } else {
        {
#line 869
        (*true_unlink)((char const   *)(wpath));
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 872
    closedir(wdir);
#line 873
    (*true_rmdir)(truepath);
    }
  } else {
    {
#line 875
    (*true_unlink)(truepath);
    }
  }
#line 878
  return (rcod);
}
}
#line 894 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int expand_path(string_t **list , char const   *prefix , char const   *suffix ) 
{ 
  char nprefix[4097] ;
  char nwork[4097] ;
  char nsuffix[4097] ;
  char lnkpath[4097] ;
  size_t lnksz ;
  string_t *pthis ;
  string_t *list1 ;
  string_t *list2 ;
  struct stat ninfo ;
  int rcod ;
  char pnp[4097] ;
  char pns[4097] ;
  size_t len ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 899
  lnksz = (size_t )0;
#line 900
  pthis = (string_t *)((void *)0);
#line 901
  list1 = (string_t *)((void *)0);
#line 902
  list2 = (string_t *)((void *)0);
#line 904
  rcod = 0;
#line 910
  debug(4, "expand_path(%p,%s,%s)\n", list, prefix, suffix);
  }
#line 914
  if ((int const   )*(suffix + 0) == 0) {
    {
#line 915
    tmp = malloc(sizeof(string_t ));
#line 915
    *list = (string_t *)tmp;
#line 916
    tmp___0 = strlen(prefix);
#line 916
    tmp___1 = malloc(tmp___0 + 1UL);
#line 916
    (*list)->string = (char *)tmp___1;
#line 917
    strcpy((char */* __restrict  */)(*list)->string, (char const   */* __restrict  */)prefix);
#line 918
    (*list)->next = (string_t *)((void *)0);
#line 919
    rcod = 0;
    }
#line 919
    goto finalize;
  }
  {
#line 923
  parse_suffix(pnp, pns, suffix);
#line 924
  strcpy((char */* __restrict  */)(nprefix), (char const   */* __restrict  */)prefix);
#line 925
  strcat((char */* __restrict  */)(nprefix), (char const   */* __restrict  */)(pnp));
#line 926
  strcpy((char */* __restrict  */)(nsuffix), (char const   */* __restrict  */)(pns));
#line 928
  rcod = true_lstat((char const   *)(nprefix), & ninfo);
  }
#line 929
  if (rcod != 0) {
    {
#line 931
    expand_path(list, (char const   *)(nprefix), (char const   *)(nsuffix));
    }
  } else
#line 929
  if (rcod == 0) {
#line 929
    if (! ((ninfo.st_mode & 61440U) == 40960U)) {
      {
#line 931
      expand_path(list, (char const   *)(nprefix), (char const   *)(nsuffix));
      }
    } else {
#line 929
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 933
    expand_path(& list1, (char const   *)(nprefix), (char const   *)(nsuffix));
#line 935
    tmp___2 = (*true_readlink)((char const   *)(nprefix), lnkpath, (size_t )4096);
#line 935
    lnksz = (size_t )tmp___2;
#line 936
    lnkpath[lnksz] = (char )'\000';
    }
#line 937
    if ((int )lnkpath[0] != 47) {
      {
#line 938
      strcpy((char */* __restrict  */)(nprefix), (char const   */* __restrict  */)prefix);
#line 939
      len = strlen((char const   *)(lnkpath));
      }
#line 940
      if ((int )lnkpath[len - 1UL] == 47) {
#line 940
        lnkpath[len - 1UL] = (char )'\000';
      }
      {
#line 941
      strcpy((char */* __restrict  */)(nwork), (char const   */* __restrict  */)"/");
#line 942
      strcat((char */* __restrict  */)(nwork), (char const   */* __restrict  */)(lnkpath));
#line 943
      strcat((char */* __restrict  */)(nwork), (char const   */* __restrict  */)(nsuffix));
#line 944
      strcpy((char */* __restrict  */)(nsuffix), (char const   */* __restrict  */)(nwork));
#line 945
      expand_path(& list2, (char const   *)(nprefix), (char const   *)(nsuffix));
      }
    } else {
      {
#line 947
      len = strlen((char const   *)(lnkpath));
      }
#line 948
      if ((int )lnkpath[len - 1UL] == 47) {
#line 948
        lnkpath[len - 1UL] = (char )'\000';
      }
      {
#line 949
      strcpy((char */* __restrict  */)(nprefix), (char const   */* __restrict  */)"");
#line 950
      strcpy((char */* __restrict  */)(nwork), (char const   */* __restrict  */)(lnkpath));
#line 951
      strcat((char */* __restrict  */)(nwork), (char const   */* __restrict  */)(nsuffix));
#line 952
      strcpy((char */* __restrict  */)(nsuffix), (char const   */* __restrict  */)(nwork));
#line 953
      expand_path(& list2, (char const   *)(nprefix), (char const   *)(nsuffix));
      }
    }
#line 956
    *list = list1;
#line 957
    pthis = *list;
    {
#line 958
    while (1) {
      while_continue: /* CIL Label */ ;
#line 958
      if (! ((unsigned long )pthis->next != (unsigned long )((void *)0))) {
#line 958
        goto while_break;
      }
#line 958
      pthis = pthis->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 959
    pthis->next = list2;
  }
  finalize: 
#line 964
  return (rcod);
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int parse_suffix(char *pnp , char *pns , char const   *suffix ) 
{ 
  int rcod ;
  char *p ;

  {
  {
#line 968
  rcod = 0;
#line 971
  strcpy((char */* __restrict  */)pnp, (char const   */* __restrict  */)suffix);
#line 972
  strcpy((char */* __restrict  */)pns, (char const   */* __restrict  */)"");
#line 974
  p = pnp;
  }
#line 976
  if ((int )*p == 0) {
    {
#line 977
    strcpy((char */* __restrict  */)pns, (char const   */* __restrict  */)"");
    }
  } else {
#line 979
    p ++;
    {
#line 980
    while (1) {
      while_continue: /* CIL Label */ ;
#line 980
      if (! ((int )*p != 0)) {
#line 980
        goto while_break;
      }
#line 981
      if ((int )*p == 47) {
        {
#line 982
        strcpy((char */* __restrict  */)pns, (char const   */* __restrict  */)p);
#line 983
        *p = (char )'\000';
        }
#line 984
        goto while_break;
      }
#line 986
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 990
  return (rcod);
}
}
#line 997 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int __instw_printdirent(struct dirent *entry ) 
{ 


  {
#line 999
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    {
#line 1000
    debug(4, "entry(%p) {\n\td_ino     : %ld\n\td_off     : %ld\n\td_reclen  : %d\n\td_type    : %d\n\td_name    : \"%.*s\"\n",
          entry, (int64_t )entry->d_ino, entry->d_off, (int )entry->d_reclen, (int )entry->d_type,
          (int )entry->d_reclen, entry->d_name);
    }
  } else {
    {
#line 1015
    debug(4, "entry(null) \n");
    }
  }
#line 1018
  return (0);
}
}
#line 1021 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int __instw_printdirent64(struct dirent64 *entry ) 
{ 


  {
#line 1023
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    {
#line 1024
    debug(4, "entry(%p) {\n\td_ino     : %ld\n\td_off     : %ldd\n\td_reclen  : %d\n\td_type    : %d\n\td_name    : \"%.*s\"\n",
          entry, entry->d_ino, entry->d_off, (int )entry->d_reclen, (int )entry->d_type,
          (int )entry->d_reclen, entry->d_name);
    }
  } else {
    {
#line 1039
    debug(4, "entry(null) \n");
    }
  }
#line 1042
  return (0);
}
}
#line 1050 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_print(instw_t *instw ) 
{ 
  string_t *pnext ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 1054
  tmp = (char const   *)instw->mdirls;
#line 1054
  if (! tmp) {
#line 1054
    tmp = "(null)";
  }
#line 1054
  tmp___0 = (char const   *)instw->mtransl;
#line 1054
  if (! tmp___0) {
#line 1054
    tmp___0 = "(null)";
  }
#line 1054
  tmp___1 = (char const   *)instw->meta;
#line 1054
  if (! tmp___1) {
#line 1054
    tmp___1 = "(null)";
  }
#line 1054
  tmp___2 = (char const   *)instw->transl;
#line 1054
  if (! tmp___2) {
#line 1054
    tmp___2 = "(null)";
  }
#line 1054
  tmp___3 = (char const   *)instw->backup;
#line 1054
  if (! tmp___3) {
#line 1054
    tmp___3 = "(null)";
  }
#line 1054
  tmp___4 = (char const   *)instw->root;
#line 1054
  if (! tmp___4) {
#line 1054
    tmp___4 = "(null)";
  }
  {
#line 1054
  debug(4, "instw(%p) {\n\tgstatus     : %d\n\terror       : %d\n\tstatus      : %d\n\tdbglvl      : %d\n\tpid         : %d\n\troot        : \"%.*s\"\n\tbackup      : \"%.*s\"\n\ttransl      : \"%.*s\"\n\tmeta        : \"%.*s\"\n\tmtransl     : \"%.*s\"\n\tmdirls      : \"%.*s\"\n",
        instw, instw->gstatus, instw->error, instw->status, instw->dbglvl, instw->pid,
        4096, (char *)tmp___4, 4096, (char *)tmp___3, 4096, (char *)tmp___2, 4096,
        (char *)tmp___1, 4096, (char *)tmp___0, 4096, (char *)tmp);
#line 1081
  pnext = instw->exclude;
#line 1082
  i = 0;
  }
  {
#line 1083
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1083
    if (! ((unsigned long )pnext != (unsigned long )((void *)0))) {
#line 1083
      goto while_break;
    }
    {
#line 1084
    i ++;
#line 1084
    debug(4, "\texclude     : (%02d) \"%.*s\"\n", i, 4096, pnext->string);
#line 1087
    pnext = pnext->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1090
  debug(4, "\tpath        : \"%.*s\"\n\treslvpath   : \"%.*s\"\n\ttruepath    : \"%.*s\"\n\ttranslpath  : \"%.*s\"\n",
        4096, instw->path, 4096, instw->reslvpath, 4096, instw->truepath, 4096, instw->translpath);
#line 1101
  pnext = instw->equivpaths;
#line 1102
  i = 0;
  }
  {
#line 1103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1103
    if (! ((unsigned long )pnext != (unsigned long )((void *)0))) {
#line 1103
      goto while_break___0;
    }
    {
#line 1104
    i ++;
#line 1104
    debug(4, "\tequivpaths  : (%02d) \"%.*s\"\n", i, 4096, pnext->string);
#line 1107
    pnext = pnext->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1110
  debug(4, "\tmtranslpath : \"%.*s\"\n\tmdirlspath  : \"%.*s\"\n}\n", 4096, instw->mtranslpath,
        4096, instw->mdirlspath);
  }
#line 1118
  return (0);
}
}
#line 1133 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_init(void) 
{ 
  char *proot ;
  char *pbackup ;
  char *ptransl ;
  char *pdbglvl ;
  struct stat info ;
  char wrkpath[4097] ;
  char *pexclude ;
  char *exclude ;
  string_t **ppnext ;
  int okinit ;
  int okbackup ;
  int oktransl ;
  int okwrap ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  void *tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  void *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  void *tmp___37 ;
  size_t tmp___38 ;
  void *tmp___39 ;
  size_t tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  void *tmp___45 ;

  {
  {
#line 1152
  __instw.dbglvl = 0;
#line 1153
  pdbglvl = getenv("INSTW_DBGLVL");
  }
#line 1153
  if (pdbglvl) {
    {
#line 1154
    __instw.dbglvl = atoi((char const   *)pdbglvl);
    }
#line 1155
    if (__instw.dbglvl > 4) {
#line 1155
      __instw.dbglvl = 4;
    }
#line 1156
    if (__instw.dbglvl < 0) {
#line 1156
      __instw.dbglvl = 0;
    }
  }
  {
#line 1159
  debug(2, "instw_init()\n");
#line 1162
  okinit = 0;
#line 1163
  okbackup = 0;
#line 1164
  oktransl = 0;
#line 1165
  okwrap = 0;
#line 1167
  __instw.gstatus = 0;
#line 1168
  __instw.error = 0;
#line 1169
  __instw.status = 0;
#line 1170
  __instw.pid = getpid();
#line 1171
  __instw.root = (char *)((void *)0);
#line 1172
  __instw.backup = (char *)((void *)0);
#line 1173
  __instw.transl = (char *)((void *)0);
#line 1174
  __instw.meta = (char *)((void *)0);
#line 1175
  __instw.mtransl = (char *)((void *)0);
#line 1176
  __instw.mdirls = (char *)((void *)0);
#line 1177
  __instw.exclude = (string_t *)((void *)0);
#line 1179
  __instw.path[0] = (char )'\000';
#line 1180
  __instw.reslvpath[0] = (char )'\000';
#line 1181
  __instw.truepath[0] = (char )'\000';
#line 1182
  __instw.translpath[0] = (char )'\000';
#line 1184
  __instw.equivpaths = (string_t *)((void *)0);
#line 1186
  __instw.mtranslpath[0] = (char )'\000';
#line 1187
  __instw.mdirlspath[0] = (char )'\000';
#line 1190
  proot = getenv("INSTW_ROOTPATH");
  }
#line 1190
  if (proot) {
    {
#line 1191
    realpath((char const   */* __restrict  */)proot, (char */* __restrict  */)(wrkpath));
#line 1192
    tmp___0 = strlen((char const   *)(wrkpath));
    }
#line 1192
    if ((int )wrkpath[tmp___0 - 1UL] == 47) {
      {
#line 1193
      tmp = strlen((char const   *)(wrkpath));
#line 1193
      wrkpath[tmp - 1UL] = (char )'\000';
      }
    }
    {
#line 1194
    tmp___1 = strlen((char const   *)(wrkpath));
#line 1194
    tmp___2 = malloc(tmp___1 + 1UL);
#line 1194
    __instw.root = (char *)tmp___2;
    }
#line 1195
    if ((unsigned long )((void *)0) == (unsigned long )__instw.root) {
#line 1195
      return (-1);
    }
    {
#line 1196
    strcpy((char */* __restrict  */)__instw.root, (char const   */* __restrict  */)(wrkpath));
    }
#line 1199
    if ((int )*(__instw.root + 0) == 0) {
      {
#line 1200
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please check the INSTW_ROOTPATH and be sure that it does exist please !\ngiven value : %s\n",
              __instw.root);
      }
#line 1204
      return (-1);
    } else {
      {
#line 1199
      tmp___3 = true_stat((char const   *)__instw.root, & info);
      }
#line 1199
      if (tmp___3) {
        {
#line 1200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please check the INSTW_ROOTPATH and be sure that it does exist please !\ngiven value : %s\n",
                __instw.root);
        }
#line 1204
        return (-1);
      }
    }
    {
#line 1207
    pbackup = getenv("INSTW_BACKUP");
    }
#line 1207
    if (pbackup) {
      {
#line 1208
      tmp___12 = strcmp((char const   *)pbackup, "1");
      }
#line 1208
      if (tmp___12) {
        {
#line 1208
        tmp___13 = strcmp((char const   *)pbackup, "yes");
        }
#line 1208
        if (tmp___13) {
          {
#line 1208
          tmp___14 = strcmp((char const   *)pbackup, "true");
          }
#line 1208
          if (tmp___14) {
            {
#line 1227
            tmp___9 = strcmp((char const   *)pbackup, "0");
            }
#line 1227
            if (tmp___9) {
              {
#line 1227
              tmp___10 = strcmp((char const   *)pbackup, "no");
              }
#line 1227
              if (tmp___10) {
                {
#line 1227
                tmp___11 = strcmp((char const   *)pbackup, "false");
                }
#line 1227
                if (tmp___11) {
                  {
#line 1230
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please check the INSTW_BACKUP value please !\nRecognized values are : 1/0,yes/no,true/false.\n");
                  }
#line 1233
                  return (-1);
                }
              }
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 1212
            tmp___4 = strlen((char const   *)__instw.root);
#line 1212
            tmp___5 = strlen("/BACKUP");
            }
#line 1212
            if (tmp___4 + tmp___5 > 4096UL) {
              {
#line 1213
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Backup path would exceed PATH_MAX. Aborting.\n");
              }
#line 1215
              return (-1);
            }
            {
#line 1217
            tmp___6 = strlen((char const   *)__instw.root);
#line 1217
            tmp___7 = strlen("/BACKUP");
#line 1217
            tmp___8 = malloc((tmp___6 + tmp___7) + 1UL);
#line 1217
            __instw.backup = (char *)tmp___8;
            }
#line 1218
            if ((unsigned long )((void *)0) == (unsigned long )__instw.backup) {
#line 1218
              return (-1);
            }
            {
#line 1219
            strcpy((char */* __restrict  */)__instw.backup, (char const   */* __restrict  */)__instw.root);
#line 1220
            strcat((char */* __restrict  */)__instw.backup, (char const   */* __restrict  */)"/BACKUP");
#line 1223
            (*true_mkdir)((char const   *)__instw.backup, (mode_t )448);
#line 1225
            okbackup = 1;
            }
          }
        } else {
#line 1208
          goto _L;
        }
      } else {
#line 1208
        goto _L;
      }
    }
    {
#line 1237
    ptransl = getenv("INSTW_TRANSL");
    }
#line 1237
    if (ptransl) {
      {
#line 1238
      tmp___34 = strcmp((char const   *)ptransl, "1");
      }
#line 1238
      if (tmp___34) {
        {
#line 1238
        tmp___35 = strcmp((char const   *)ptransl, "yes");
        }
#line 1238
        if (tmp___35) {
          {
#line 1238
          tmp___36 = strcmp((char const   *)ptransl, "true");
          }
#line 1238
          if (tmp___36) {
            {
#line 1287
            tmp___31 = strcmp((char const   *)ptransl, "0");
            }
#line 1287
            if (tmp___31) {
              {
#line 1287
              tmp___32 = strcmp((char const   *)ptransl, "no");
              }
#line 1287
              if (tmp___32) {
                {
#line 1287
                tmp___33 = strcmp((char const   *)ptransl, "false");
                }
#line 1287
                if (tmp___33) {
                  {
#line 1290
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please check the INSTW_TRANSL value please !\nRecognized values are : 1/0,yes/no,true/false.\n");
                  }
#line 1293
                  return (-1);
                }
              }
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 1242
            tmp___15 = strlen((char const   *)__instw.root);
#line 1242
            tmp___16 = strlen("/TRANSL");
            }
#line 1242
            if (tmp___15 + tmp___16 > 4096UL) {
              {
#line 1243
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Transl path would exceed PATH_MAX. Aborting.\n");
              }
#line 1245
              return (-1);
            }
            {
#line 1247
            tmp___17 = strlen((char const   *)__instw.root);
#line 1247
            tmp___18 = strlen("/TRANSL");
#line 1247
            tmp___19 = malloc((tmp___17 + tmp___18) + 1UL);
#line 1247
            __instw.transl = (char *)tmp___19;
            }
#line 1248
            if ((unsigned long )((void *)0) == (unsigned long )__instw.transl) {
#line 1248
              return (-1);
            }
            {
#line 1249
            strcpy((char */* __restrict  */)__instw.transl, (char const   */* __restrict  */)__instw.root);
#line 1250
            strcat((char */* __restrict  */)__instw.transl, (char const   */* __restrict  */)"/TRANSL");
#line 1253
            (*true_mkdir)((char const   *)__instw.transl, (mode_t )448);
#line 1255
            tmp___20 = strlen((char const   *)__instw.root);
#line 1255
            tmp___21 = strlen("/META");
            }
#line 1255
            if (tmp___20 + tmp___21 > 4096UL) {
              {
#line 1256
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Meta path would exceed PATH_MAX. Aborting.\n");
              }
#line 1258
              return (-1);
            }
            {
#line 1261
            tmp___22 = strlen((char const   *)__instw.root);
#line 1261
            tmp___23 = strlen("/META");
#line 1261
            tmp___24 = malloc((tmp___22 + tmp___23) + 1UL);
#line 1261
            __instw.meta = (char *)tmp___24;
            }
#line 1262
            if ((unsigned long )((void *)0) == (unsigned long )__instw.meta) {
#line 1262
              return (-1);
            }
            {
#line 1263
            strcpy((char */* __restrict  */)__instw.meta, (char const   */* __restrict  */)__instw.root);
#line 1264
            strcat((char */* __restrict  */)__instw.meta, (char const   */* __restrict  */)"/META");
#line 1267
            (*true_mkdir)((char const   *)__instw.meta, (mode_t )448);
#line 1269
            tmp___25 = strlen((char const   *)__instw.meta);
#line 1269
            tmp___26 = strlen("/TRANSL");
#line 1269
            tmp___27 = malloc((tmp___25 + tmp___26) + 1UL);
#line 1269
            __instw.mtransl = (char *)tmp___27;
            }
#line 1270
            if ((unsigned long )((void *)0) == (unsigned long )__instw.mtransl) {
#line 1270
              return (-1);
            }
            {
#line 1271
            strcpy((char */* __restrict  */)__instw.mtransl, (char const   */* __restrict  */)__instw.meta);
#line 1272
            strcat((char */* __restrict  */)__instw.mtransl, (char const   */* __restrict  */)"/TRANSL");
#line 1275
            (*true_mkdir)((char const   *)__instw.mtransl, (mode_t )448);
#line 1277
            tmp___28 = strlen((char const   *)__instw.meta);
#line 1277
            tmp___29 = strlen("/DIRLS");
#line 1277
            tmp___30 = malloc((tmp___28 + tmp___29) + 1UL);
#line 1277
            __instw.mdirls = (char *)tmp___30;
            }
#line 1278
            if ((unsigned long )((void *)0) == (unsigned long )__instw.mdirls) {
#line 1278
              return (-1);
            }
            {
#line 1279
            strcpy((char */* __restrict  */)__instw.mdirls, (char const   */* __restrict  */)__instw.meta);
#line 1280
            strcat((char */* __restrict  */)__instw.mdirls, (char const   */* __restrict  */)"/DIRLS");
#line 1283
            (*true_mkdir)((char const   *)__instw.mdirls, (mode_t )448);
#line 1285
            oktransl = 1;
            }
          }
        } else {
#line 1238
          goto _L___0;
        }
      } else {
#line 1238
        goto _L___0;
      }
    }
  }
#line 1302
  ppnext = & __instw.exclude;
#line 1305
  if (__instw.gstatus & (1 << 3)) {
    {
#line 1306
    tmp___37 = malloc(sizeof(string_t ));
#line 1306
    *ppnext = (string_t *)tmp___37;
    }
#line 1307
    if ((unsigned long )*ppnext == (unsigned long )((void *)0)) {
#line 1307
      return (-1);
    }
    {
#line 1308
    (*ppnext)->string = (char *)((void *)0);
#line 1309
    (*ppnext)->next = (string_t *)((void *)0);
#line 1310
    realpath((char const   */* __restrict  */)__instw.root, (char */* __restrict  */)(wrkpath));
#line 1311
    tmp___38 = strlen((char const   *)(wrkpath));
#line 1311
    tmp___39 = malloc(tmp___38 + 1UL);
#line 1311
    (*ppnext)->string = (char *)tmp___39;
#line 1312
    strcpy((char */* __restrict  */)(*ppnext)->string, (char const   */* __restrict  */)(wrkpath));
#line 1313
    ppnext = & (*ppnext)->next;
    }
  }
  {
#line 1316
  pexclude = getenv("INSTW_EXCLUDE");
  }
#line 1316
  if (pexclude) {
    {
#line 1317
    tmp___40 = strlen((char const   *)pexclude);
#line 1317
    tmp___41 = malloc(tmp___40 + 1UL);
#line 1317
    exclude = (char *)tmp___41;
#line 1318
    strcpy((char */* __restrict  */)exclude, (char const   */* __restrict  */)pexclude);
#line 1319
    pexclude = strtok((char */* __restrict  */)exclude, (char const   */* __restrict  */)",");
    }
    {
#line 1321
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1321
      if (! ((unsigned long )pexclude != (unsigned long )((void *)0))) {
#line 1321
        goto while_break;
      }
      {
#line 1322
      tmp___42 = malloc(sizeof(string_t ));
#line 1322
      *ppnext = (string_t *)tmp___42;
      }
#line 1323
      if ((unsigned long )*ppnext == (unsigned long )((void *)0)) {
#line 1323
        return (-1);
      }
      {
#line 1324
      (*ppnext)->string = (char *)((void *)0);
#line 1325
      (*ppnext)->next = (string_t *)((void *)0);
#line 1327
      tmp___43 = strlen((char const   *)pexclude);
      }
#line 1327
      if (tmp___43 > 4096UL) {
#line 1327
        return (-1);
      }
      {
#line 1328
      realpath((char const   */* __restrict  */)pexclude, (char */* __restrict  */)(wrkpath));
#line 1329
      tmp___44 = strlen((char const   *)(wrkpath));
#line 1329
      tmp___45 = malloc(tmp___44 + 1UL);
#line 1329
      (*ppnext)->string = (char *)tmp___45;
#line 1330
      strcpy((char */* __restrict  */)(*ppnext)->string, (char const   */* __restrict  */)(wrkpath));
#line 1331
      ppnext = & (*ppnext)->next;
#line 1332
      pexclude = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1338
  okinit = 1;
#line 1339
  okwrap = 1;
#line 1341
  if (okinit) {
#line 1341
    __instw.gstatus |= 1;
  }
#line 1342
  if (okwrap) {
#line 1342
    __instw.gstatus |= 1 << 1;
  }
#line 1343
  if (okbackup) {
#line 1343
    __instw.gstatus |= 1 << 2;
  }
#line 1344
  if (oktransl) {
#line 1344
    __instw.gstatus |= 1 << 3;
  }
  {
#line 1347
  debug(4, "__instw(%p)\n", & __instw);
#line 1348
  instw_print(& __instw);
  }
#line 1351
  return (0);
}
}
#line 1362 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_fini(void) 
{ 
  int rcod ;
  string_t *pnext ;
  string_t *pthis ;

  {
  {
#line 1363
  rcod = 0;
#line 1368
  debug(2, "instw_fini()\n");
  }
#line 1371
  if (! (__instw.gstatus & 1)) {
#line 1371
    rcod = 0;
#line 1371
    goto finalize;
  }
#line 1373
  __instw.gstatus &= -2;
#line 1375
  if ((unsigned long )__instw.root != (unsigned long )((void *)0)) {
    {
#line 1375
    free((void *)__instw.root);
#line 1375
    __instw.root = (char *)((void *)0);
    }
  }
#line 1376
  if ((unsigned long )__instw.backup != (unsigned long )((void *)0)) {
    {
#line 1376
    free((void *)__instw.backup);
#line 1376
    __instw.backup = (char *)((void *)0);
    }
  }
#line 1377
  if ((unsigned long )__instw.transl != (unsigned long )((void *)0)) {
    {
#line 1377
    free((void *)__instw.transl);
#line 1377
    __instw.transl = (char *)((void *)0);
    }
  }
#line 1378
  if ((unsigned long )__instw.meta != (unsigned long )((void *)0)) {
    {
#line 1378
    free((void *)__instw.meta);
#line 1378
    __instw.meta = (char *)((void *)0);
    }
  }
#line 1379
  if ((unsigned long )__instw.mtransl != (unsigned long )((void *)0)) {
    {
#line 1379
    free((void *)__instw.mtransl);
#line 1379
    __instw.mtransl = (char *)((void *)0);
    }
  }
#line 1380
  if ((unsigned long )__instw.mdirls != (unsigned long )((void *)0)) {
    {
#line 1380
    free((void *)__instw.mdirls);
#line 1380
    __instw.mdirls = (char *)((void *)0);
    }
  }
#line 1382
  pthis = __instw.exclude;
  {
#line 1383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1383
    if (! ((unsigned long )pthis != (unsigned long )((void *)0))) {
#line 1383
      goto while_break;
    }
    {
#line 1384
    free((void *)pthis->string);
#line 1385
    pnext = pthis->next;
#line 1386
    free((void *)pthis);
#line 1387
    pthis = pnext;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1389
  __instw.exclude = (string_t *)((void *)0);
  finalize: 
#line 1393
  return (rcod);
}
}
#line 1404 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_new(instw_t *instw ) 
{ 
  int rcod ;

  {
#line 1405
  rcod = 0;
#line 1407
  *instw = __instw;
#line 1409
  instw->error = 0;
#line 1410
  instw->status = 0;
#line 1411
  instw->path[0] = (char )'\000';
#line 1412
  instw->reslvpath[0] = (char )'\000';
#line 1413
  instw->truepath[0] = (char )'\000';
#line 1414
  instw->translpath[0] = (char )'\000';
#line 1415
  instw->equivpaths = (string_t *)((void *)0);
#line 1416
  instw->mtranslpath[0] = (char )'\000';
#line 1417
  instw->mdirlspath[0] = (char )'\000';
#line 1419
  return (rcod);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_delete(instw_t *instw ) 
{ 
  int rcod ;
  string_t *pnext ;
  string_t *pthis ;

  {
#line 1431
  rcod = 0;
#line 1435
  pthis = instw->equivpaths;
  {
#line 1436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1436
    if (! ((unsigned long )pthis != (unsigned long )((void *)0))) {
#line 1436
      goto while_break;
    }
    {
#line 1437
    free((void *)pthis->string);
#line 1438
    pnext = pthis->next;
#line 1439
    free((void *)pthis);
#line 1440
    pthis = pnext;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1443
  instw->status = 0;
#line 1445
  return (rcod);
}
}
#line 1470 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_setmetatransl(instw_t *instw ) 
{ 
  int rcod ;
  struct stat info ;
  char mtransldir[4097] ;
  char mtranslpath[4097] ;
  char reslvpath[4097] ;
  size_t mesz ;
  int i ;
  string_t *pthis ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1471
  rcod = 0;
#line 1476
  mesz = (size_t )0;
#line 1477
  i = 0;
#line 1481
  debug(3, "instw_setmetatransl(%p)\n", instw);
#line 1482
  instw_print(instw);
  }
#line 1485
  if (! (instw->gstatus & 1)) {
#line 1486
    rcod = 0;
#line 1486
    goto finalize;
  } else
#line 1485
  if (! (instw->gstatus & (1 << 3))) {
#line 1486
    rcod = 0;
#line 1486
    goto finalize;
  }
#line 1488
  if (! (instw->status & 1)) {
#line 1488
    rcod = 0;
#line 1488
    goto finalize;
  }
#line 1490
  if ((unsigned long )instw->equivpaths == (unsigned long )((void *)0)) {
    {
#line 1491
    expand_path(& instw->equivpaths, "", (char const   *)(instw->reslvpath));
    }
  }
  {
#line 1495
  instw_print(instw);
#line 1498
  pthis = instw->equivpaths;
  }
  {
#line 1499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1499
    if (! ((unsigned long )pthis != (unsigned long )((void *)0))) {
#line 1499
      goto while_break;
    }
    {
#line 1500
    strcpy((char */* __restrict  */)(mtranslpath), (char const   */* __restrict  */)instw->mtransl);
#line 1501
    strcat((char */* __restrict  */)(mtranslpath), (char const   */* __restrict  */)pthis->string);
#line 1502
    strcpy((char */* __restrict  */)(reslvpath), (char const   */* __restrict  */)pthis->string);
#line 1504
    tmp = true_stat((char const   *)(mtranslpath), & info);
    }
#line 1504
    if (tmp) {
      {
#line 1504
      tmp___0 = (*true_mkdir)((char const   *)(mtranslpath), (mode_t )448);
      }
#line 1504
      if (tmp___0) {
        {
#line 1506
        strcpy((char */* __restrict  */)(mtransldir), (char const   */* __restrict  */)(mtranslpath));
#line 1507
        mesz = strlen((char const   *)instw->mtransl);
#line 1509
        i = 0;
        }
        {
#line 1509
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1509
          if (! ((int )reslvpath[i] != 0)) {
#line 1509
            goto while_break___0;
          }
#line 1510
          mtransldir[mesz + (size_t )i] = reslvpath[i];
#line 1511
          if ((int )reslvpath[i] == 47) {
            {
#line 1512
            mtransldir[(mesz + (size_t )i) + 1UL] = (char )'\000';
#line 1513
            (*true_mkdir)((char const   *)(mtransldir), (mode_t )448);
            }
          }
#line 1509
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1517
        (*true_mkdir)((char const   *)(mtranslpath), (mode_t )448);
        }
      }
    }
#line 1520
    pthis = pthis->next;
  }
  while_break: /* CIL Label */ ;
  }
  finalize: 
#line 1525
  return (rcod);
}
}
#line 1543 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_setpath(instw_t *instw , char const   *path ) 
{ 
  size_t relen ;
  size_t trlen ;
  size_t melen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1545
  trlen = (size_t )0;
#line 1549
  debug(2, "instw_setpath(%p,%s)\n", instw, path);
#line 1552
  instw->status = 0;
#line 1554
  strncpy((char */* __restrict  */)(instw->path), (char const   */* __restrict  */)path,
          (size_t )4096);
#line 1555
  instw->truepath[0] = (char )'\000';
  }
#line 1557
  if ((int )instw->path[0] != 47) {
    {
#line 1558
    (*true_getcwd)(instw->truepath, (size_t )4097);
#line 1559
    tmp = strlen((char const   *)(instw->truepath));
    }
#line 1559
    if ((int )instw->truepath[tmp - 1UL] != 47) {
      {
#line 1560
      strcat((char */* __restrict  */)(instw->truepath), (char const   */* __restrict  */)"/");
      }
    }
    {
#line 1562
    strcat((char */* __restrict  */)(instw->truepath), (char const   */* __restrict  */)(instw->path));
    }
  } else {
    {
#line 1564
    reduce(instw->path);
#line 1565
    strcpy((char */* __restrict  */)(instw->truepath), (char const   */* __restrict  */)(instw->path));
    }
  }
  {
#line 1567
  relen = strlen((char const   *)(instw->truepath));
#line 1570
  reduce(instw->truepath);
  }
#line 1577
  if (! (instw->gstatus & 1)) {
    {
#line 1579
    strncpy((char */* __restrict  */)(instw->reslvpath), (char const   */* __restrict  */)(instw->truepath),
            (size_t )4096);
#line 1580
    strncpy((char */* __restrict  */)(instw->translpath), (char const   */* __restrict  */)(instw->truepath),
            (size_t )4096);
    }
#line 1581
    return (0);
  } else
#line 1577
  if (! (instw->gstatus & (1 << 3))) {
    {
#line 1579
    strncpy((char */* __restrict  */)(instw->reslvpath), (char const   */* __restrict  */)(instw->truepath),
            (size_t )4096);
#line 1580
    strncpy((char */* __restrict  */)(instw->translpath), (char const   */* __restrict  */)(instw->truepath),
            (size_t )4096);
    }
#line 1581
    return (0);
  }
  {
#line 1588
  tmp___1 = strstr((char const   *)(instw->truepath), (char const   *)instw->transl);
  }
#line 1588
  if ((unsigned long )tmp___1 == (unsigned long )(instw->truepath)) {
    {
#line 1589
    tmp___0 = strlen((char const   *)instw->transl);
#line 1589
    strcpy((char */* __restrict  */)(instw->reslvpath), (char const   */* __restrict  */)(instw->truepath + tmp___0));
    }
  } else {
    {
#line 1591
    strcpy((char */* __restrict  */)(instw->reslvpath), (char const   */* __restrict  */)(instw->truepath));
    }
  }
#line 1599
  if ((int )instw->path[0] == 47) {
    {
#line 1599
    tmp___2 = strstr((char const   *)(instw->path), (char const   *)instw->transl);
    }
#line 1599
    if ((unsigned long )tmp___2 == (unsigned long )(instw->path)) {
      {
#line 1601
      strcpy((char */* __restrict  */)(instw->path), (char const   */* __restrict  */)(instw->reslvpath));
      }
    }
  }
  {
#line 1607
  tmp___5 = path_excluded((char const   *)(instw->truepath));
  }
#line 1607
  if (tmp___5) {
    {
#line 1608
    strncpy((char */* __restrict  */)(instw->translpath), (char const   */* __restrict  */)(instw->truepath),
            (size_t )4096);
#line 1609
    instw->status |= 1 | (1 << 1);
    }
  } else {
    {
#line 1612
    strncpy((char */* __restrict  */)(instw->translpath), (char const   */* __restrict  */)instw->transl,
            (size_t )4096);
#line 1613
    trlen = strlen((char const   *)(instw->translpath));
    }
#line 1614
    if (trlen + relen > 4096UL) {
      {
#line 1615
      tmp___3 = __errno_location();
#line 1615
      tmp___4 = 36;
#line 1615
      *tmp___3 = tmp___4;
#line 1615
      instw->error = tmp___4;
      }
#line 1616
      return (-1);
    }
    {
#line 1618
    strncat((char */* __restrict  */)(instw->translpath), (char const   */* __restrict  */)(instw->reslvpath),
            4096UL - trlen);
#line 1619
    instw->translpath[4096] = (char )'\000';
    }
  }
  {
#line 1623
  strncpy((char */* __restrict  */)(instw->mtranslpath), (char const   */* __restrict  */)instw->mtransl,
          (size_t )4096);
#line 1624
  instw->mtranslpath[4096] = (char )'\000';
#line 1625
  melen = strlen((char const   *)(instw->mtranslpath));
  }
#line 1626
  if (melen + relen > 4096UL) {
    {
#line 1627
    tmp___6 = __errno_location();
#line 1627
    tmp___7 = 36;
#line 1627
    *tmp___6 = tmp___7;
#line 1627
    instw->error = tmp___7;
    }
#line 1628
    return (-1);
  }
  {
#line 1630
  strncat((char */* __restrict  */)(instw->mtranslpath), (char const   */* __restrict  */)(instw->reslvpath),
          4096UL - trlen);
#line 1631
  instw->mtranslpath[4096] = (char )'\000';
  }
#line 1633
  return (0);
}
}
#line 1653 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_setpathrel(instw_t *instw , int dirfd___0 , char const   *relpath ) 
{ 
  int retval ;
  int l ;
  char *newpath ;
  char proc_path[20] ;
  struct stat s ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 1661
  debug(2, "instw_setpathrel(%p,%d,%s)\n", instw, dirfd___0, relpath);
#line 1662
  retval = -1;
  }
#line 1671
  if (dirfd___0 == -100) {
    {
#line 1671
    tmp = instw_setpath(instw, relpath);
    }
#line 1671
    return (tmp);
  }
  {
#line 1673
  snprintf((char */* __restrict  */)(proc_path), (size_t )20, (char const   */* __restrict  */)"/proc/self/fd/%d",
           dirfd___0);
#line 1674
  tmp___0 = true_stat((char const   *)(proc_path), & s);
  }
#line 1674
  if (tmp___0 == -1) {
#line 1675
    goto out;
  }
  {
#line 1676
  tmp___1 = strlen(relpath);
#line 1676
  tmp___2 = malloc(((size_t )s.st_size + tmp___1) + 2UL);
#line 1676
  newpath = (char *)tmp___2;
  }
#line 1676
  if (! newpath) {
#line 1677
    goto out;
  }
  {
#line 1678
  tmp___3 = (*true_readlink)((char const   *)(proc_path), newpath, (size_t )s.st_size);
#line 1678
  l = (int )tmp___3;
  }
#line 1678
  if (l == -1) {
#line 1679
    goto free_out;
  }
  {
#line 1680
  *(newpath + l) = (char )'/';
#line 1681
  strcpy((char */* __restrict  */)((newpath + l) + 1), (char const   */* __restrict  */)relpath);
#line 1683
  retval = instw_setpath(instw, (char const   *)newpath);
  }
  free_out: 
  {
#line 1686
  free((void *)newpath);
  }
  out: 
#line 1688
  return (retval);
}
}
#line 1704 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_getstatus(instw_t *instw , int *status ) 
{ 
  struct stat inode ;
  struct stat rinode ;
  struct stat tinode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1710
  debug(2, "instw_getstatus(%p,%p)\n", instw, status);
  }
#line 1716
  if (instw->gstatus & 1) {
#line 1716
    if (instw->gstatus & (1 << 3)) {
#line 1716
      if (! (instw->status & 1)) {
        {
#line 1716
        tmp = true_stat((char const   *)(instw->mtranslpath), & inode);
        }
#line 1716
        if (! tmp) {
#line 1720
          instw->status |= 1;
        }
      }
    }
  }
#line 1726
  if (instw->gstatus & 1) {
#line 1726
    if (instw->gstatus & (1 << 3)) {
      {
#line 1726
      tmp___0 = true_stat((char const   *)(instw->translpath), & tinode);
      }
#line 1726
      if (! tmp___0) {
#line 1729
        instw->status |= 1 << 7;
      }
    }
  }
#line 1735
  if (instw->gstatus & 1) {
    {
#line 1735
    tmp___1 = true_stat((char const   *)(instw->reslvpath), & rinode);
    }
#line 1735
    if (! tmp___1) {
#line 1737
      instw->status |= 1 << 6;
    }
  }
#line 1746
  if (instw->gstatus & 1) {
#line 1746
    if (instw->gstatus & (1 << 3)) {
#line 1746
      if (instw->status & (1 << 7)) {
#line 1746
        if (! (instw->status & 1)) {
          {
#line 1750
          instw->status |= 1;
#line 1751
          instw_setmetatransl(instw);
          }
        }
      }
    }
  }
#line 1758
  if (instw->gstatus & 1) {
#line 1758
    if (instw->gstatus & (1 << 3)) {
#line 1758
      if (instw->status & 1) {
        {
#line 1758
        tmp___2 = strcmp((char const   *)(instw->truepath), (char const   *)(instw->translpath));
        }
#line 1758
        if (0 == tmp___2) {
#line 1762
          instw->status |= 1 << 1;
        }
      }
    }
  }
#line 1765
  *status = instw->status;
#line 1767
  return (0);
}
}
#line 1786 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_apply(instw_t *instw ) 
{ 
  int rcod ;
  int status ;
  char dirpart[4097] ;
  char basepart[4097] ;
  char *pdir ;
  char *pbase ;
  struct stat reslvinfo ;
  instw_t iw ;
  char wpath[4097] ;
  size_t wsz ;
  char linkpath[4097] ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1787
  rcod = 0;
#line 1788
  status = 0;
#line 1797
  wsz = (size_t )0;
#line 1802
  debug(2, "instw_apply(%p)\n", instw);
#line 1803
  instw_print(instw);
  }
#line 1810
  if (! (instw->gstatus & 1)) {
#line 1811
    rcod = 0;
#line 1811
    goto finalize;
  } else
#line 1810
  if (! (instw->gstatus & (1 << 3))) {
#line 1811
    rcod = 0;
#line 1811
    goto finalize;
  }
  {
#line 1814
  tmp = instw_getstatus(instw, & status);
  }
#line 1814
  if (tmp) {
#line 1814
    rcod = -1;
#line 1814
    goto finalize;
  }
#line 1817
  if (status & 1) {
#line 1817
    return (0);
  }
  {
#line 1819
  strcpy((char */* __restrict  */)(basepart), (char const   */* __restrict  */)(instw->reslvpath));
#line 1820
  strcpy((char */* __restrict  */)(dirpart), (char const   */* __restrict  */)(instw->reslvpath));
#line 1822
  pbase = basename((char const   *)(basepart));
#line 1823
  pdir = dirname(dirpart);
  }
#line 1826
  if ((int )*(pdir + 0) == 47) {
#line 1826
    if ((int )*(pdir + 1) == 0) {
#line 1826
      if ((int )*(pbase + 0) == 0) {
#line 1827
        instw->status |= 1;
#line 1828
        rcod = 0;
#line 1828
        goto finalize;
      }
    }
  }
  {
#line 1831
  instw_new(& iw);
#line 1832
  instw_setpath(& iw, (char const   *)pdir);
#line 1833
  instw_apply(& iw);
#line 1834
  instw_delete(& iw);
#line 1837
  tmp___1 = true_lstat((char const   *)(instw->reslvpath), & reslvinfo);
  }
#line 1837
  if (! tmp___1) {
    {
#line 1838
    copy_path((char const   *)(instw->reslvpath), (char const   *)instw->transl);
    }
#line 1841
    if ((reslvinfo.st_mode & 61440U) == 40960U) {
      {
#line 1842
      tmp___0 = (*true_readlink)((char const   *)(instw->reslvpath), wpath, (size_t )4096);
#line 1842
      wsz = (size_t )tmp___0;
#line 1843
      wpath[wsz] = (char )'\000';
#line 1845
      instw_new(& iw);
      }
#line 1846
      if ((int )wpath[0] != 47) {
        {
#line 1847
        strcpy((char */* __restrict  */)(linkpath), (char const   */* __restrict  */)pdir);
#line 1848
        strcat((char */* __restrict  */)(linkpath), (char const   */* __restrict  */)"/");
#line 1849
        strcat((char */* __restrict  */)(linkpath), (char const   */* __restrict  */)(wpath));
        }
      } else {
        {
#line 1851
        strcpy((char */* __restrict  */)(linkpath), (char const   */* __restrict  */)(wpath));
        }
      }
      {
#line 1854
      instw_setpath(& iw, (char const   *)(linkpath));
#line 1855
      instw_apply(& iw);
#line 1856
      instw_delete(& iw);
      }
    }
  }
  {
#line 1861
  instw->status |= 1;
#line 1862
  instw_setmetatransl(instw);
  }
  finalize: 
#line 1866
  return (rcod);
}
}
#line 1883 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_filldirls(instw_t *instw ) 
{ 
  int rcod ;
  DIR *wdir ;
  struct dirent *went ;
  char spath[4097] ;
  char dpath[4097] ;
  char lpath[4097] ;
  struct stat sinfo ;
  struct stat dinfo ;
  int wfd ;
  size_t wsz ;
  instw_t iw_entry ;
  int status ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 1884
  rcod = 0;
#line 1895
  status = 0;
#line 1898
  debug(2, "instw_filldirls(%p)\n", instw);
#line 1901
  wdir = (*true_opendir)((char const   *)(instw->translpath));
  }
#line 1901
  if ((unsigned long )wdir == (unsigned long )((void *)0)) {
#line 1901
    return (-1);
  }
  {
#line 1902
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1902
    went = (*true_readdir)(wdir);
    }
#line 1902
    if (! ((unsigned long )went != (unsigned long )((void *)0))) {
#line 1902
      goto while_break;
    }
#line 1903
    if ((int )went->d_name[0] == 46) {
#line 1903
      if ((int )went->d_name[1] == 0) {
#line 1907
        goto while_continue;
      } else
#line 1903
      if ((int )went->d_name[1] == 46) {
#line 1903
        if ((int )went->d_name[2] == 0) {
#line 1907
          goto while_continue;
        }
      }
    }
    {
#line 1909
    strcpy((char */* __restrict  */)(spath), (char const   */* __restrict  */)(instw->translpath));
#line 1910
    strcat((char */* __restrict  */)(spath), (char const   */* __restrict  */)"/");
#line 1911
    strcat((char */* __restrict  */)(spath), (char const   */* __restrict  */)(went->d_name));
#line 1913
    tmp = true_lstat((char const   *)(spath), & sinfo);
    }
#line 1913
    if (tmp) {
#line 1913
      goto while_continue;
    }
    {
#line 1915
    strcpy((char */* __restrict  */)(dpath), (char const   */* __restrict  */)(instw->mdirlspath));
#line 1916
    strcat((char */* __restrict  */)(dpath), (char const   */* __restrict  */)"/");
#line 1917
    strcat((char */* __restrict  */)(dpath), (char const   */* __restrict  */)(went->d_name));
    }
#line 1920
    if ((sinfo.st_mode & 61440U) == 40960U) {
      {
#line 1921
      tmp___0 = (*true_readlink)((char const   *)(spath), lpath, (size_t )4096);
#line 1921
      wsz = (size_t )tmp___0;
      }
#line 1921
      if (wsz >= 0UL) {
        {
#line 1922
        lpath[wsz] = (char )'\000';
#line 1923
        (*true_symlink)((char const   *)(lpath), (char const   *)(dpath));
#line 1925
        debug(4, "\tfilled symlink       : %s\n", dpath);
        }
      }
    }
#line 1932
    if ((sinfo.st_mode & 61440U) == 32768U) {
      {
#line 1933
      wfd = (*true_creat)((char const   *)(dpath), sinfo.st_mode);
      }
#line 1933
      if (wfd >= 0) {
        {
#line 1934
        close(wfd);
#line 1936
        debug(4, "\tfilled regular file  : %s\n", dpath);
        }
      }
    }
#line 1942
    if ((sinfo.st_mode & 61440U) == 16384U) {
      {
#line 1943
      (*true_mkdir)((char const   *)(dpath), sinfo.st_mode);
#line 1945
      debug(4, "\tfilled directory     : %s\n", dpath);
      }
    }
#line 1951
    if ((sinfo.st_mode & 61440U) == 24576U) {
      {
#line 1952
      true_mknod((char const   *)(dpath), sinfo.st_mode | 24576U, sinfo.st_rdev);
#line 1954
      debug(4, "\tfilled special block : %s\n", dpath);
      }
    }
#line 1960
    if ((sinfo.st_mode & 61440U) == 8192U) {
      {
#line 1961
      true_mknod((char const   *)(dpath), sinfo.st_mode | 8192U, sinfo.st_rdev);
#line 1963
      debug(4, "\tfilled special char  : %s\n", dpath);
      }
    }
#line 1968
    if ((sinfo.st_mode & 61440U) == 4096U) {
      {
#line 1969
      true_mknod((char const   *)(dpath), sinfo.st_mode | 4096U, (dev_t )0);
#line 1971
      debug(4, "\tfilled special fifo  : %s\n", dpath);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1976
  closedir(wdir);
#line 1978
  wdir = (*true_opendir)((char const   *)(instw->reslvpath));
  }
#line 1978
  if ((unsigned long )wdir == (unsigned long )((void *)0)) {
#line 1978
    return (-1);
  }
  {
#line 1979
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1979
    went = (*true_readdir)(wdir);
    }
#line 1979
    if (! ((unsigned long )went != (unsigned long )((void *)0))) {
#line 1979
      goto while_break___0;
    }
#line 1980
    if ((int )went->d_name[0] == 46) {
#line 1980
      if ((int )went->d_name[1] == 0) {
#line 1984
        goto while_continue___0;
      } else
#line 1980
      if ((int )went->d_name[1] == 46) {
#line 1980
        if ((int )went->d_name[2] == 0) {
#line 1984
          goto while_continue___0;
        }
      }
    }
    {
#line 1986
    strcpy((char */* __restrict  */)(spath), (char const   */* __restrict  */)(instw->reslvpath));
#line 1987
    strcat((char */* __restrict  */)(spath), (char const   */* __restrict  */)"/");
#line 1988
    strcat((char */* __restrict  */)(spath), (char const   */* __restrict  */)(went->d_name));
#line 1989
    tmp___1 = true_lstat((char const   *)(spath), & sinfo);
    }
#line 1989
    if (tmp___1) {
#line 1989
      goto while_continue___0;
    }
    {
#line 1991
    instw_new(& iw_entry);
#line 1992
    instw_setpath(& iw_entry, (char const   *)(spath));
#line 1993
    instw_getstatus(& iw_entry, & status);
    }
#line 2000
    if (status & 1) {
#line 2000
      if (! (status & (1 << 7))) {
#line 2001
        goto while_continue___0;
      }
    }
    {
#line 2003
    strcpy((char */* __restrict  */)(dpath), (char const   */* __restrict  */)(instw->mdirlspath));
#line 2004
    strcat((char */* __restrict  */)(dpath), (char const   */* __restrict  */)"/");
#line 2005
    strcat((char */* __restrict  */)(dpath), (char const   */* __restrict  */)(went->d_name));
#line 2008
    tmp___2 = true_lstat((char const   *)(dpath), & dinfo);
    }
#line 2008
    if (! tmp___2) {
#line 2008
      goto while_continue___0;
    }
#line 2011
    if ((sinfo.st_mode & 61440U) == 40960U) {
      {
#line 2012
      tmp___3 = (*true_readlink)((char const   *)(spath), lpath, (size_t )4096);
#line 2012
      wsz = (size_t )tmp___3;
      }
#line 2012
      if (wsz >= 0UL) {
        {
#line 2013
        lpath[wsz] = (char )'\000';
#line 2014
        (*true_symlink)((char const   *)(lpath), (char const   *)(dpath));
#line 2016
        debug(4, "\tfilled symlink       : %s\n", dpath);
        }
      }
    }
#line 2022
    if ((sinfo.st_mode & 61440U) == 32768U) {
      {
#line 2023
      wfd = (*true_creat)((char const   *)(dpath), sinfo.st_mode);
      }
#line 2023
      if (wfd >= 0) {
        {
#line 2024
        close(wfd);
#line 2026
        debug(4, "\tfilled regular file  : %s\n", dpath);
        }
      }
    }
#line 2032
    if ((sinfo.st_mode & 61440U) == 16384U) {
      {
#line 2033
      (*true_mkdir)((char const   *)(dpath), sinfo.st_mode);
#line 2035
      debug(4, "\tfilled directory     : %s\n", dpath);
      }
    }
#line 2040
    if ((sinfo.st_mode & 61440U) == 24576U) {
      {
#line 2041
      true_mknod((char const   *)(dpath), sinfo.st_mode | 24576U, sinfo.st_rdev);
#line 2043
      debug(4, "\tfilled special block : %s\n", dpath);
      }
    }
#line 2048
    if ((sinfo.st_mode & 61440U) == 8192U) {
      {
#line 2049
      true_mknod((char const   *)(dpath), sinfo.st_mode | 8192U, sinfo.st_rdev);
#line 2051
      debug(4, "\tfilled special char  : %s\n", dpath);
      }
    }
#line 2056
    if ((sinfo.st_mode & 61440U) == 4096U) {
      {
#line 2057
      true_mknod((char const   *)(dpath), sinfo.st_mode | 4096U, (dev_t )0);
#line 2059
      debug(4, "\tfilled special fifo  : %s\n", dpath);
      }
    }
    {
#line 2063
    instw_delete(& iw_entry);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2065
  closedir(wdir);
  }
#line 2067
  return (rcod);
}
}
#line 2087 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int instw_makedirls(instw_t *instw ) 
{ 
  int rcod ;
  int status ;
  struct stat translinfo ;
  struct stat dirlsinfo ;
  char wdirname[256] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2088
  rcod = 0;
#line 2089
  status = 0;
#line 2095
  debug(2, "instw_makedirls(%p)\n", instw);
  }
#line 2102
  if (! (instw->gstatus & 1)) {
    {
#line 2104
    strcpy((char */* __restrict  */)(instw->mdirlspath), (char const   */* __restrict  */)(instw->path));
    }
#line 2105
    return (0);
  } else
#line 2102
  if (! (instw->gstatus & (1 << 3))) {
    {
#line 2104
    strcpy((char */* __restrict  */)(instw->mdirlspath), (char const   */* __restrict  */)(instw->path));
    }
#line 2105
    return (0);
  }
  {
#line 2109
  tmp = instw_getstatus(instw, & status);
  }
#line 2109
  if (tmp) {
#line 2109
    return (-1);
  }
#line 2111
  if (! (status & 1)) {
    {
#line 2113
    strcpy((char */* __restrict  */)(instw->mdirlspath), (char const   */* __restrict  */)(instw->path));
    }
  } else
#line 2111
  if (status & 1) {
#line 2111
    if (status & (1 << 1)) {
      {
#line 2113
      strcpy((char */* __restrict  */)(instw->mdirlspath), (char const   */* __restrict  */)(instw->path));
      }
    } else {
#line 2111
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2120
  if (! (status & (1 << 6))) {
    {
#line 2121
    strcpy((char */* __restrict  */)(instw->mdirlspath), (char const   */* __restrict  */)(instw->translpath));
    }
  } else {
    {
#line 2123
    rcod = true_stat((char const   *)(instw->translpath), & translinfo);
#line 2125
    sprintf((char */* __restrict  */)(wdirname), (char const   */* __restrict  */)"/%d_%lld_%lld",
            instw->pid, (long long )translinfo.st_dev, (long long )translinfo.st_ino);
#line 2130
    strcpy((char */* __restrict  */)(instw->mdirlspath), (char const   */* __restrict  */)instw->mdirls);
#line 2131
    strcat((char */* __restrict  */)(instw->mdirlspath), (char const   */* __restrict  */)(wdirname));
#line 2134
    tmp___0 = true_stat((char const   *)(instw->mdirlspath), & dirlsinfo);
    }
#line 2134
    if (! tmp___0) {
      {
#line 2135
      unlink_recursive((char const   *)(instw->mdirlspath));
      }
    }
    {
#line 2137
    (*true_mkdir)((char const   *)(instw->mdirlspath), (mode_t )448);
#line 2140
    instw_filldirls(instw);
    }
  }
  {
#line 2145
  instw_print(instw);
  }
#line 2148
  return (rcod);
}
}
#line 2154 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
static int backup(char const   *path ) 
{ 
  char checkdir[8192] ;
  char backup_path[8192] ;
  int placeholder ;
  int i ;
  int blen ;
  struct stat inode ;
  struct stat backup_inode ;
  struct utimbuf timbuf ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char tmp___6 ;
  int tmp___7 ;

  {
  {
#line 2164
  debug(2, "========= backup () =========  path: %s\n", path);
  }
#line 2168
  if (! (__instw.gstatus & (1 << 2))) {
    {
#line 2170
    debug(3, "Backup not enabled, path: %s\n", path);
    }
#line 2172
    return (0);
  }
  {
#line 2176
  tmp = strstr(path, "/dev");
  }
#line 2176
  if ((unsigned long )tmp == (unsigned long )path) {
    {
#line 2178
    debug(3, "%s is inside /dev. Ignoring.\n", path);
    }
#line 2180
    return (0);
  }
  {
#line 2184
  tmp___0 = strstr(path, "/tmp");
  }
#line 2184
  if ((unsigned long )tmp___0 == (unsigned long )path) {
    {
#line 2186
    debug(3, "%s is inside /tmp. Ignoring.\n", path);
    }
#line 2188
    return (0);
  }
  {
#line 2192
  tmp___1 = strstr(path, (char const   *)__instw.backup);
  }
#line 2192
  if ((unsigned long )tmp___1 == (unsigned long )path) {
    {
#line 2194
    debug(3, "%s is inside the backup path. Ignoring.\n", path);
    }
#line 2196
    return (0);
  }
  {
#line 2201
  debug(3, "Exists %s?\n", path);
#line 2203
  tmp___2 = true_stat(path, & inode);
  }
#line 2203
  if (tmp___2 < 0) {
    {
#line 2208
    strcpy((char */* __restrict  */)(backup_path), (char const   */* __restrict  */)__instw.backup);
#line 2209
    strncat((char */* __restrict  */)(backup_path), (char const   */* __restrict  */)"/no-backup",
            (size_t )11);
#line 2210
    strcat((char */* __restrict  */)(backup_path), (char const   */* __restrict  */)path);
#line 2211
    make_path((char const   *)(backup_path));
#line 2214
    placeholder = (*true_creat)((char const   *)(backup_path), (mode_t )256);
    }
#line 2215
    if (! (placeholder < 0)) {
      {
#line 2215
      close(placeholder);
      }
    }
    {
#line 2218
    debug(3, "does not exist\n");
    }
#line 2220
    return (0);
  }
  {
#line 2225
  strcpy((char */* __restrict  */)(backup_path), (char const   */* __restrict  */)__instw.backup);
#line 2226
  strncat((char */* __restrict  */)(backup_path), (char const   */* __restrict  */)"/no-backup",
          (size_t )11);
#line 2227
  strcat((char */* __restrict  */)(backup_path), (char const   */* __restrict  */)path);
#line 2229
  tmp___3 = true_stat((char const   *)(backup_path), & backup_inode);
  }
#line 2229
  if (tmp___3 >= 0) {
    {
#line 2231
    debug(3, "%s should not be backed up\n", backup_path);
    }
#line 2233
    return (0);
  }
  {
#line 2238
  debug(3, "Exists in real path. Lets see what it is.\n");
#line 2242
  strcpy((char */* __restrict  */)(backup_path), (char const   */* __restrict  */)__instw.backup);
#line 2243
  strcat((char */* __restrict  */)(backup_path), (char const   */* __restrict  */)path);
#line 2246
  make_path((char const   *)(backup_path));
#line 2249
  tmp___4 = copy_path(path, (char const   *)__instw.backup);
  }
#line 2249
  if (tmp___4) {
#line 2250
    return (-1);
  }
  {
#line 2253
  i = 0;
#line 2254
  tmp___5 = strlen((char const   *)__instw.backup);
#line 2254
  blen = (int )tmp___5;
  }
  {
#line 2255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2255
    if (! ((int const   )*(path + i) != 0)) {
#line 2255
      goto while_break;
    }
#line 2256
    tmp___6 = (char )*(path + i);
#line 2256
    backup_path[blen + i] = tmp___6;
#line 2256
    checkdir[i] = tmp___6;
#line 2257
    if ((int )checkdir[i] == 47) {
      {
#line 2258
      checkdir[i + 1] = (char )'\000';
#line 2259
      tmp___7 = true_stat((char const   *)(checkdir), & inode);
      }
#line 2259
      if (! tmp___7) {
        {
#line 2260
        backup_path[(blen + i) + 1] = (char )'\000';
#line 2261
        timbuf.actime = inode.st_atim.tv_sec;
#line 2262
        timbuf.modtime = inode.st_mtim.tv_sec;
#line 2263
        (*true_utime)((char const   *)(backup_path), (struct utimbuf  const  *)(& timbuf));
#line 2264
        (*true_chmod)((char const   *)(backup_path), inode.st_mode);
#line 2265
        (*true_chown)((char const   *)(backup_path), inode.st_uid, inode.st_gid);
        }
      }
    }
#line 2268
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2271
  return (0);
}
}
#line 2274
 __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *timer ) ;
#line 2274 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
time_t ( __attribute__((__leaf__)) time)(time_t *timer ) 
{ 
  time_t tmp ;

  {
#line 2275
  __installwatch_timecount ++;
#line 2277
  if (! libc_handle) {
    {
#line 2278
    initialize();
    }
  }
  {
#line 2281
  debug(2, "time\n");
#line 2284
  tmp = (*true_time)(timer);
  }
#line 2284
  return (tmp);
}
}
#line 2291
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *pathname ) ;
#line 2291 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *pathname ) 
{ 
  int result ;
  instw_t instw ;
  int status ;

  {
#line 2296
  if (! libc_handle) {
    {
#line 2297
    initialize();
    }
  }
  {
#line 2300
  debug(2, "chdir(%s)\n", pathname);
  }
#line 2304
  if (! (__instw.gstatus & 1)) {
    {
#line 2306
    result = (*true_chdir)(pathname);
    }
#line 2307
    return (result);
  } else
#line 2304
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2306
    result = (*true_chdir)(pathname);
    }
#line 2307
    return (result);
  }
  {
#line 2310
  instw_new(& instw);
#line 2311
  instw_setpath(& instw, pathname);
#line 2312
  instw_getstatus(& instw, & status);
  }
#line 2314
  if (status & 1) {
#line 2314
    if (! (status & (1 << 6))) {
      {
#line 2315
      result = (*true_chdir)((char const   *)(instw.translpath));
#line 2316
      debug(3, "\teffective chdir(%s)\n", instw.translpath);
      }
    } else {
      {
#line 2318
      result = (*true_chdir)(pathname);
#line 2319
      debug(3, "\teffective chdir(%s)\n", pathname);
      }
    }
  } else {
    {
#line 2318
    result = (*true_chdir)(pathname);
#line 2319
    debug(3, "\teffective chdir(%s)\n", pathname);
    }
  }
  {
#line 2322
  instw_delete(& instw);
  }
#line 2324
  return (result);
}
}
#line 2327
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *path ,
                                                                                     __mode_t mode ) ;
#line 2327 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *path , __mode_t mode ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2331
  __installwatch_refcount ++;
#line 2333
  if (! libc_handle) {
    {
#line 2334
    initialize();
    }
  }
  {
#line 2337
  debug(2, "chmod(%s,mode)\n", path);
  }
#line 2341
  if (! (__instw.gstatus & 1)) {
    {
#line 2343
    result = (*true_chmod)(path, mode);
    }
#line 2344
    return (result);
  } else
#line 2341
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2343
    result = (*true_chmod)(path, mode);
    }
#line 2344
    return (result);
  }
  {
#line 2347
  instw_new(& instw);
#line 2348
  instw_setpath(& instw, path);
#line 2351
  instw_print(& instw);
#line 2354
  backup((char const   *)(instw.truepath));
#line 2355
  instw_apply(& instw);
#line 2357
  result = (*true_chmod)((char const   *)(instw.translpath), mode);
  }
#line 2358
  if (result < 0) {
    {
#line 2358
    tmp = __errno_location();
#line 2358
    tmp___0 = strerror(*tmp);
#line 2358
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2358
    tmp___1 = "success";
  }
  {
#line 2358
  logg("%d\tchmod\t%s\t0%04o\t#%s\n", result, instw.reslvpath, mode, tmp___1);
#line 2361
  instw_delete(& instw);
  }
#line 2363
  return (result);
}
}
#line 2366
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *path ,
                                                                                     __uid_t owner ,
                                                                                     __gid_t group ) ;
#line 2366 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *path , __uid_t owner ,
                                                       __gid_t group ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2370
  __installwatch_refcount ++;
#line 2372
  if (! libc_handle) {
    {
#line 2373
    initialize();
    }
  }
  {
#line 2376
  debug(2, "chown(%s,owner,group)\n", path);
  }
#line 2380
  if (! (__instw.gstatus & 1)) {
    {
#line 2382
    result = (*true_chown)(path, owner, group);
    }
#line 2383
    return (result);
  } else
#line 2380
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2382
    result = (*true_chown)(path, owner, group);
    }
#line 2383
    return (result);
  }
  {
#line 2386
  instw_new(& instw);
#line 2387
  instw_setpath(& instw, path);
#line 2390
  instw_print(& instw);
#line 2393
  backup((char const   *)(instw.truepath));
#line 2394
  instw_apply(& instw);
#line 2396
  result = (*true_chown)((char const   *)(instw.translpath), owner, group);
  }
#line 2397
  if (result < 0) {
    {
#line 2397
    tmp = __errno_location();
#line 2397
    tmp___0 = strerror(*tmp);
#line 2397
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2397
    tmp___1 = "success";
  }
  {
#line 2397
  logg("%d\tchown\t%s\t%d\t%d\t#%s\n", result, instw.reslvpath, owner, group, tmp___1);
#line 2400
  instw_delete(& instw);
  }
#line 2402
  return (result);
}
}
#line 2406 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int chown32(char const   *path , uid_t owner , gid_t group ) 
{ 
  int tmp ;

  {
  {
#line 2408
  tmp = chown(path, owner, group);
  }
#line 2408
  return (tmp);
}
}
#line 2412
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *path ) ;
#line 2412 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *path ) 
{ 
  int result ;
  char canonic[4096] ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2416
  __installwatch_refcount ++;
#line 2418
  if (! libc_handle) {
    {
#line 2419
    initialize();
    }
  }
  {
#line 2422
  debug(2, "chroot(%s)\n", path);
#line 2425
  canonicalize(path, canonic);
#line 2426
  result = (*true_chroot)(path);
  }
#line 2431
  if (result < 0) {
    {
#line 2431
    tmp = __errno_location();
#line 2431
    tmp___0 = strerror(*tmp);
#line 2431
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2431
    tmp___1 = "success";
  }
  {
#line 2431
  logg("%d\tchroot\t%s\t#%s\n", result, canonic, tmp___1);
  }
#line 2432
  return (result);
}
}
#line 2435 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1))) creat)(char const   *pathname , mode_t mode ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2440
  __installwatch_refcount ++;
#line 2442
  if (! libc_handle) {
    {
#line 2443
    initialize();
    }
  }
  {
#line 2446
  debug(2, "creat(%s,mode)\n", pathname);
  }
#line 2450
  if (! (__instw.gstatus & 1)) {
    {
#line 2452
    result = (*true_creat)(pathname, mode);
    }
#line 2453
    return (result);
  } else
#line 2450
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2452
    result = (*true_creat)(pathname, mode);
    }
#line 2453
    return (result);
  }
  {
#line 2456
  instw_new(& instw);
#line 2457
  instw_setpath(& instw, pathname);
#line 2460
  instw_print(& instw);
#line 2463
  backup((char const   *)(instw.truepath));
#line 2464
  instw_apply(& instw);
#line 2466
  result = (*true_open)((char const   *)(instw.translpath), 577, mode);
  }
#line 2467
  if (result < 0) {
    {
#line 2467
    tmp = __errno_location();
#line 2467
    tmp___0 = strerror(*tmp);
#line 2467
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2467
    tmp___1 = "success";
  }
  {
#line 2467
  logg("%d\tcreat\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 2469
  instw_delete(& instw);
  }
#line 2471
  return (result);
}
}
#line 2474
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int filedes ,
                                                                      __mode_t mode ) ;
#line 2474 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__leaf__)) fchmod)(int filedes , __mode_t mode ) 
{ 
  int result ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2477
  __installwatch_refcount ++;
#line 2479
  if (! libc_handle) {
    {
#line 2480
    initialize();
    }
  }
  {
#line 2483
  debug(2, "fchmod\n");
#line 2486
  result = (*true_fchmod)(filedes, mode);
  }
#line 2487
  if (result < 0) {
    {
#line 2487
    tmp = __errno_location();
#line 2487
    tmp___0 = strerror(*tmp);
#line 2487
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2487
    tmp___1 = "success";
  }
  {
#line 2487
  logg("%d\tfchmod\t%d\t0%04o\t#%s\n", result, filedes, mode, tmp___1);
  }
#line 2488
  return (result);
}
}
#line 2491
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int fd , __uid_t owner ,
                                                                      __gid_t group ) ;
#line 2491 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__leaf__)) fchown)(int fd , __uid_t owner , __gid_t group ) 
{ 
  int result ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2494
  __installwatch_refcount ++;
#line 2496
  if (! libc_handle) {
    {
#line 2497
    initialize();
    }
  }
  {
#line 2500
  debug(2, "fchown\n");
#line 2503
  result = (*true_fchown)(fd, owner, group);
  }
#line 2504
  if (result < 0) {
    {
#line 2504
    tmp = __errno_location();
#line 2504
    tmp___0 = strerror(*tmp);
#line 2504
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2504
    tmp___1 = "success";
  }
  {
#line 2504
  logg("%d\tfchown\t%d\t%d\t%d\t#%s\n", result, fd, owner, group, tmp___1);
  }
#line 2505
  return (result);
}
}
#line 2508 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
FILE *fopen(char const   * __restrict  pathname , char const   * __restrict  mode ) 
{ 
  FILE *result ;
  instw_t instw ;
  int status ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 2511
  status = 0;
#line 2513
  __installwatch_refcount ++;
#line 2515
  if (! libc_handle) {
    {
#line 2516
    initialize();
    }
  }
  {
#line 2519
  debug(2, "fopen(%s,%s)\n", pathname, mode);
  }
#line 2523
  if (! (__instw.gstatus & 1)) {
    {
#line 2525
    result = (*true_fopen)((char const   *)pathname, (char const   *)mode);
    }
#line 2526
    return (result);
  } else
#line 2523
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2525
    result = (*true_fopen)((char const   *)pathname, (char const   *)mode);
    }
#line 2526
    return (result);
  }
  {
#line 2529
  instw_new(& instw);
#line 2530
  instw_setpath(& instw, (char const   *)pathname);
#line 2533
  instw_print(& instw);
  }
#line 2536
  if ((int const   )*(mode + 0) == 119) {
#line 2536
    goto _L;
  } else
#line 2536
  if ((int const   )*(mode + 0) == 97) {
#line 2536
    goto _L;
  } else
#line 2536
  if ((int const   )*(mode + 1) == 43) {
    _L: /* CIL Label */ 
    {
#line 2537
    backup((char const   *)(instw.truepath));
#line 2538
    instw_apply(& instw);
    }
#line 2539
    if ((unsigned long )result < 0UL) {
      {
#line 2539
      tmp = __errno_location();
#line 2539
      tmp___0 = strerror(*tmp);
#line 2539
      tmp___1 = (char const   *)tmp___0;
      }
    } else {
#line 2539
      tmp___1 = "success";
    }
    {
#line 2539
    logg("%ld\tfopen\t%s\t#%s\n", (intptr_t )result, instw.reslvpath, tmp___1);
    }
  }
  {
#line 2543
  instw_getstatus(& instw, & status);
  }
#line 2545
  if (status & 1) {
    {
#line 2546
    debug(4, "\teffective fopen(%s)\n", instw.translpath);
#line 2547
    result = (*true_fopen)((char const   *)(instw.translpath), (char const   *)mode);
    }
  } else {
    {
#line 2549
    debug(4, "\teffective fopen(%s)\n", instw.path);
#line 2550
    result = (*true_fopen)((char const   *)(instw.path), (char const   *)mode);
    }
  }
#line 2553
  if ((int const   )*(mode + 0) == 119) {
#line 2553
    goto _L___0;
  } else
#line 2553
  if ((int const   )*(mode + 0) == 97) {
#line 2553
    goto _L___0;
  } else
#line 2553
  if ((int const   )*(mode + 1) == 43) {
    _L___0: /* CIL Label */ 
#line 2554
    if ((unsigned long )result < 0UL) {
      {
#line 2554
      tmp___2 = __errno_location();
#line 2554
      tmp___3 = strerror(*tmp___2);
#line 2554
      tmp___4 = (char const   *)tmp___3;
      }
    } else {
#line 2554
      tmp___4 = "success";
    }
    {
#line 2554
    logg("%ld\tfopen\t%s\t#%s\n", (intptr_t )result, instw.reslvpath, tmp___4);
    }
  }
  {
#line 2557
  instw_delete(& instw);
  }
#line 2559
  return (result);
}
}
#line 2562
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int fd ,
                                                                         __off_t length ) ;
#line 2562 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__leaf__)) ftruncate)(int fd , __off_t length ) 
{ 
  int result ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2565
  __installwatch_refcount ++;
#line 2567
  if (! libc_handle) {
    {
#line 2568
    initialize();
    }
  }
  {
#line 2571
  debug(2, "ftruncate\n");
#line 2574
  result = (*true_ftruncate)(fd, length);
  }
#line 2575
  if (result < 0) {
    {
#line 2575
    tmp = __errno_location();
#line 2575
    tmp___0 = strerror(*tmp);
#line 2575
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2575
    tmp___1 = "success";
  }
  {
#line 2575
  logg("%d\tftruncate\t%d\t%d\t#%s\n", result, fd, (int )length, tmp___1);
  }
#line 2576
  return (result);
}
}
#line 2579
 __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *buffer ,
                                                                        size_t size ) ;
#line 2579 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
char *( __attribute__((__leaf__)) getcwd)(char *buffer , size_t size ) 
{ 
  char wpath[4097] ;
  char *result ;
  char *wptr ;
  size_t wsize ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 2585
  if (! libc_handle) {
    {
#line 2586
    initialize();
    }
  }
  {
#line 2589
  debug(2, "getcwd(%p,%ld)\n", buffer, (long )size);
  }
#line 2593
  if (! (__instw.gstatus & 1)) {
    {
#line 2595
    result = (*true_getcwd)(buffer, size);
    }
#line 2596
    return (result);
  } else
#line 2593
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2595
    result = (*true_getcwd)(buffer, size);
    }
#line 2596
    return (result);
  }
#line 2599
  if (__instw.gstatus & 1) {
#line 2599
    if (__instw.gstatus & (1 << 3)) {
      {
#line 2599
      result = (*true_getcwd)(wpath, sizeof(wpath));
      }
#line 2599
      if ((unsigned long )((void *)0) != (unsigned long )result) {
        {
#line 2603
        tmp___2 = strstr((char const   *)(wpath), (char const   *)__instw.transl);
        }
#line 2603
        if ((unsigned long )tmp___2 == (unsigned long )(wpath)) {
          {
#line 2604
          tmp = strlen((char const   *)__instw.transl);
#line 2604
          wptr = wpath + tmp;
#line 2605
          tmp___0 = strlen((char const   *)wptr);
#line 2605
          wsize = tmp___0 + 1UL;
          }
        } else {
          {
#line 2607
          wptr = wpath;
#line 2608
          tmp___1 = strlen((char const   *)wptr);
#line 2608
          wsize = tmp___1 + 1UL;
          }
        }
#line 2611
        if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 2612
          if (size != 0UL) {
#line 2612
            if (size < wsize) {
              {
#line 2613
              result = (char *)((void *)0);
#line 2614
              tmp___3 = __errno_location();
              }
#line 2614
              if (size <= 0UL) {
#line 2614
                *tmp___3 = 22;
              } else {
#line 2614
                *tmp___3 = 34;
              }
            } else {
#line 2612
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 2616
            tmp___4 = malloc(wsize);
#line 2616
            result = (char *)tmp___4;
            }
#line 2617
            if ((unsigned long )result == (unsigned long )((void *)0)) {
              {
#line 2618
              tmp___5 = __errno_location();
#line 2618
              *tmp___5 = 12;
              }
            } else {
              {
#line 2620
              strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)wptr);
              }
            }
          }
        } else
#line 2624
        if (size >= wsize) {
          {
#line 2625
          strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)wptr);
          }
        } else {
          {
#line 2627
          result = (char *)((void *)0);
#line 2628
          tmp___6 = __errno_location();
          }
#line 2628
          if (size <= 0UL) {
#line 2628
            *tmp___6 = 22;
          } else {
#line 2628
            *tmp___6 = 34;
          }
        }
      } else {
        {
#line 2632
        result = (*true_getcwd)(buffer, size);
        }
      }
    } else {
      {
#line 2632
      result = (*true_getcwd)(buffer, size);
      }
    }
  } else {
    {
#line 2632
    result = (*true_getcwd)(buffer, size);
    }
  }
#line 2636
  if (result) {
#line 2636
    tmp___7 = (char const   *)buffer;
  } else {
#line 2636
    tmp___7 = "(null)";
  }
  {
#line 2636
  debug(3, "\teffective getcwd(%s,%ld)\n", tmp___7, (long )size);
  }
#line 2640
  return (result);
}
}
#line 2643
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) lchown)(char const   *path ,
                                                                                      __uid_t owner ,
                                                                                      __gid_t group ) ;
#line 2643 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) lchown)(char const   *path , __uid_t owner ,
                                                        __gid_t group ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2648
  __installwatch_refcount ++;
#line 2650
  if (! libc_handle) {
    {
#line 2651
    initialize();
    }
  }
  {
#line 2654
  debug(2, "lchown(%s,owner,group)\n", path);
  }
#line 2658
  if (! (__instw.gstatus & 1)) {
    {
#line 2660
    result = (*true_lchown)(path, owner, group);
    }
#line 2661
    return (result);
  } else
#line 2658
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2660
    result = (*true_lchown)(path, owner, group);
    }
#line 2661
    return (result);
  }
  {
#line 2664
  instw_new(& instw);
#line 2665
  instw_setpath(& instw, path);
#line 2668
  instw_print(& instw);
#line 2671
  backup((char const   *)(instw.truepath));
#line 2672
  instw_apply(& instw);
#line 2674
  result = (*true_lchown)((char const   *)(instw.translpath), owner, group);
  }
#line 2675
  if (result < 0) {
    {
#line 2675
    tmp = __errno_location();
#line 2675
    tmp___0 = strerror(*tmp);
#line 2675
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2675
    tmp___1 = "success";
  }
  {
#line 2675
  logg("%d\tlchown\t%s\t%d\t%d\t#%s\n", result, instw.reslvpath, owner, group, tmp___1);
#line 2678
  instw_delete(& instw);
  }
#line 2680
  return (result);
}
}
#line 2683
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *oldpath ,
                                                                                      char const   *newpath ) ;
#line 2683 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *oldpath , char const   *newpath ) 
{ 
  int result ;
  instw_t instw_o ;
  instw_t instw_n ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2688
  __installwatch_refcount ++;
#line 2690
  if (! libc_handle) {
    {
#line 2691
    initialize();
    }
  }
  {
#line 2694
  debug(2, "link(%s,%s)\n", oldpath, newpath);
  }
#line 2698
  if (! (__instw.gstatus & 1)) {
    {
#line 2700
    result = (*true_link)(oldpath, newpath);
    }
#line 2701
    return (result);
  } else
#line 2698
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2700
    result = (*true_link)(oldpath, newpath);
    }
#line 2701
    return (result);
  }
  {
#line 2704
  instw_new(& instw_o);
#line 2705
  instw_new(& instw_n);
#line 2706
  instw_setpath(& instw_o, oldpath);
#line 2707
  instw_setpath(& instw_n, newpath);
#line 2710
  instw_print(& instw_o);
#line 2711
  instw_print(& instw_n);
#line 2714
  backup((char const   *)(instw_o.truepath));
#line 2715
  instw_apply(& instw_o);
#line 2716
  instw_apply(& instw_n);
#line 2718
  result = (*true_link)((char const   *)(instw_o.translpath), (char const   *)(instw_n.translpath));
  }
#line 2719
  if (result < 0) {
    {
#line 2719
    tmp = __errno_location();
#line 2719
    tmp___0 = strerror(*tmp);
#line 2719
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2719
    tmp___1 = "success";
  }
  {
#line 2719
  logg("%d\tlink\t%s\t%s\t#%s\n", result, instw_o.reslvpath, instw_n.reslvpath, tmp___1);
#line 2722
  instw_delete(& instw_o);
#line 2723
  instw_delete(& instw_n);
  }
#line 2725
  return (result);
}
}
#line 2728
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *pathname ,
                                                                                     __mode_t mode ) ;
#line 2728 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *pathname , __mode_t mode ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2732
  __installwatch_refcount ++;
#line 2734
  if (! libc_handle) {
    {
#line 2735
    initialize();
    }
  }
  {
#line 2738
  debug(2, "mkdir(%s,mode)\n", pathname);
  }
#line 2742
  if (! (__instw.gstatus & 1)) {
    {
#line 2744
    result = (*true_mkdir)(pathname, mode);
    }
#line 2745
    return (result);
  } else
#line 2742
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2744
    result = (*true_mkdir)(pathname, mode);
    }
#line 2745
    return (result);
  }
  {
#line 2748
  instw_new(& instw);
#line 2749
  instw_setpath(& instw, pathname);
#line 2752
  instw_print(& instw);
#line 2755
  instw_apply(& instw);
#line 2757
  result = (*true_mkdir)((char const   *)(instw.translpath), mode);
  }
#line 2758
  if (result < 0) {
    {
#line 2758
    tmp = __errno_location();
#line 2758
    tmp___0 = strerror(*tmp);
#line 2758
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2758
    tmp___1 = "success";
  }
  {
#line 2758
  logg("%d\tmkdir\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 2760
  instw_delete(& instw);
  }
#line 2762
  return (result);
}
}
#line 2765
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) __xmknod)(int version ,
                                                                                          char const   *pathname ,
                                                                                          __mode_t mode ,
                                                                                          __dev_t *dev ) ;
#line 2765 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2,4), __leaf__)) __xmknod)(int version , char const   *pathname ,
                                                            __mode_t mode , __dev_t *dev ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2769
  __installwatch_refcount ++;
#line 2771
  if (! libc_handle) {
    {
#line 2772
    initialize();
    }
  }
  {
#line 2775
  debug(2, "mknod(%s,mode,dev)\n", pathname);
  }
#line 2779
  if (! (__instw.gstatus & 1)) {
    {
#line 2781
    result = (*true_xmknod)(version, pathname, mode, dev);
    }
#line 2782
    return (result);
  } else
#line 2779
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2781
    result = (*true_xmknod)(version, pathname, mode, dev);
    }
#line 2782
    return (result);
  }
  {
#line 2785
  instw_new(& instw);
#line 2786
  instw_setpath(& instw, pathname);
#line 2789
  instw_print(& instw);
#line 2792
  instw_apply(& instw);
#line 2793
  backup((char const   *)(instw.truepath));
#line 2795
  result = (*true_xmknod)(version, (char const   *)(instw.translpath), mode, dev);
  }
#line 2796
  if (result < 0) {
    {
#line 2796
    tmp = __errno_location();
#line 2796
    tmp___0 = strerror(*tmp);
#line 2796
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 2796
    tmp___1 = "success";
  }
  {
#line 2796
  logg("%d\tmknod\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 2798
  instw_delete(& instw);
  }
#line 2800
  return (result);
}
}
#line 2803 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1))) open)(char const   *pathname , int flags  , ...) 
{ 
  va_list ap ;
  mode_t mode ;
  int result ;
  instw_t instw ;
  int status ;
  mode_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 2811
  __installwatch_refcount ++;
#line 2813
  if (! libc_handle) {
    {
#line 2814
    initialize();
    }
  }
  {
#line 2817
  debug(2, "open(%s,%d,mode)\n", pathname, flags);
#line 2820
  __builtin_va_start(ap, flags);
#line 2821
  tmp = __builtin_va_arg(ap, int );
#line 2821
  mode = tmp;
#line 2822
  __builtin_va_end(ap);
  }
#line 2825
  if (! (__instw.gstatus & 1)) {
    {
#line 2827
    result = (*true_open)(pathname, flags, mode);
    }
#line 2828
    return (result);
  } else
#line 2825
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2827
    result = (*true_open)(pathname, flags, mode);
    }
#line 2828
    return (result);
  }
  {
#line 2831
  instw_new(& instw);
#line 2832
  instw_setpath(& instw, pathname);
#line 2835
  instw_print(& instw);
  }
#line 2838
  if (flags & 3) {
    {
#line 2839
    backup((char const   *)(instw.truepath));
#line 2840
    instw_apply(& instw);
    }
  }
  {
#line 2843
  instw_getstatus(& instw, & status);
  }
#line 2845
  if (status & 1) {
    {
#line 2846
    result = (*true_open)((char const   *)(instw.translpath), flags, mode);
    }
  } else {
    {
#line 2848
    result = (*true_open)((char const   *)(instw.path), flags, mode);
    }
  }
#line 2850
  if (flags & 3) {
#line 2851
    if (result < 0) {
      {
#line 2851
      tmp___0 = __errno_location();
#line 2851
      tmp___1 = strerror(*tmp___0);
#line 2851
      tmp___2 = (char const   *)tmp___1;
      }
    } else {
#line 2851
      tmp___2 = "success";
    }
    {
#line 2851
    logg("%d\topen\t%s\t#%s\n", result, instw.reslvpath, tmp___2);
    }
  }
  {
#line 2853
  instw_delete(& instw);
  }
#line 2855
  return (result);
}
}
#line 2861 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *dirname___0 ) 
{ 
  DIR *result ;
  instw_t instw ;

  {
#line 2865
  if (! libc_handle) {
    {
#line 2866
    initialize();
    }
  }
  {
#line 2869
  debug(2, "opendir(%s)\n", dirname___0);
  }
#line 2873
  if (! (__instw.gstatus & 1)) {
    {
#line 2875
    result = (*true_opendir)(dirname___0);
    }
#line 2876
    return (result);
  } else
#line 2873
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2875
    result = (*true_opendir)(dirname___0);
    }
#line 2876
    return (result);
  }
  {
#line 2879
  instw_new(& instw);
#line 2880
  instw_setpath(& instw, dirname___0);
#line 2881
  instw_makedirls(& instw);
#line 2884
  instw_print(& instw);
#line 2887
  result = (*true_opendir)((char const   *)(instw.mdirlspath));
#line 2889
  instw_delete(& instw);
  }
#line 2891
  return (result);
}
}
#line 2894 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *dir ) 
{ 
  struct dirent *result ;

  {
#line 2897
  if (! libc_handle) {
    {
#line 2898
    initialize();
    }
  }
  {
#line 2901
  debug(3, "readdir(%p)\n", dir);
  }
#line 2905
  if (! (__instw.gstatus & 1)) {
    {
#line 2907
    result = (*true_readdir)(dir);
    }
#line 2908
    return (result);
  } else
#line 2905
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2907
    result = (*true_readdir)(dir);
    }
#line 2908
    return (result);
  }
  {
#line 2911
  result = (*true_readdir)(dir);
#line 2914
  __instw_printdirent(result);
  }
#line 2917
  return (result);
}
}
#line 2920
 __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  path ,
                                                                                              char * __restrict  buf ,
                                                                                              size_t bufsiz ) ;
#line 2920 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  path ,
                                                                char * __restrict  buf ,
                                                                size_t bufsiz ) 
{ 
  ssize_t result ;
  instw_t instw ;
  int status ;

  {
#line 2925
  if (! libc_handle) {
    {
#line 2926
    initialize();
    }
  }
  {
#line 2929
  debug(2, "readlink(\"%s\",%p,%ld)\n", path, buf, (long )bufsiz);
  }
#line 2933
  if (! (__instw.gstatus & 1)) {
    {
#line 2935
    result = (*true_readlink)((char const   *)path, (char *)buf, bufsiz);
    }
#line 2936
    return (result);
  } else
#line 2933
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2935
    result = (*true_readlink)((char const   *)path, (char *)buf, bufsiz);
    }
#line 2936
    return (result);
  }
  {
#line 2939
  instw_new(& instw);
#line 2940
  instw_setpath(& instw, (char const   *)path);
#line 2941
  instw_getstatus(& instw, & status);
#line 2944
  instw_print(& instw);
  }
#line 2947
  if (status & 1) {
    {
#line 2948
    result = (*true_readlink)((char const   *)(instw.translpath), (char *)buf, bufsiz);
    }
  } else {
    {
#line 2950
    result = (*true_readlink)((char const   *)(instw.path), (char *)buf, bufsiz);
    }
  }
  {
#line 2952
  instw_delete(& instw);
  }
#line 2954
  return (result);
}
}
#line 2957
 __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  file_name ,
                                                                          char * __restrict  resolved_name ) ;
#line 2957 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  file_name ,
                                            char * __restrict  resolved_name ) 
{ 
  char *result ;

  {
#line 2960
  if (! libc_handle) {
    {
#line 2961
    initialize();
    }
  }
#line 2964
  if (! (__instw.gstatus & 1)) {
    {
#line 2966
    result = (*true_realpath)((char const   *)file_name, (char *)resolved_name);
    }
#line 2967
    return (result);
  } else
#line 2964
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2966
    result = (*true_realpath)((char const   *)file_name, (char *)resolved_name);
    }
#line 2967
    return (result);
  }
  {
#line 2970
  result = (*true_realpath)((char const   *)file_name, (char *)resolved_name);
  }
#line 2972
  return (result);
}
}
#line 2975
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *oldpath ,
                                                                      char const   *newpath ) ;
#line 2975 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__leaf__)) rename)(char const   *oldpath , char const   *newpath ) 
{ 
  int result ;
  instw_t oldinstw ;
  instw_t newinstw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2980
  __installwatch_refcount ++;
#line 2982
  if (! libc_handle) {
    {
#line 2983
    initialize();
    }
  }
  {
#line 2986
  debug(2, "rename(\"%s\",\"%s\")\n", oldpath, newpath);
  }
#line 2990
  if (! (__instw.gstatus & 1)) {
    {
#line 2992
    result = (*true_rename)(oldpath, newpath);
    }
#line 2993
    return (result);
  } else
#line 2990
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 2992
    result = (*true_rename)(oldpath, newpath);
    }
#line 2993
    return (result);
  }
  {
#line 2996
  instw_new(& oldinstw);
#line 2997
  instw_new(& newinstw);
#line 2998
  instw_setpath(& oldinstw, oldpath);
#line 2999
  instw_setpath(& newinstw, newpath);
#line 3002
  instw_print(& oldinstw);
#line 3003
  instw_print(& newinstw);
#line 3006
  backup((char const   *)(oldinstw.truepath));
#line 3007
  instw_apply(& oldinstw);
#line 3008
  instw_apply(& newinstw);
#line 3010
  result = (*true_rename)((char const   *)(oldinstw.translpath), (char const   *)(newinstw.translpath));
  }
#line 3011
  if (result < 0) {
    {
#line 3011
    tmp = __errno_location();
#line 3011
    tmp___0 = strerror(*tmp);
#line 3011
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3011
    tmp___1 = "success";
  }
  {
#line 3011
  logg("%d\trename\t%s\t%s\t#%s\n", result, oldinstw.reslvpath, newinstw.reslvpath,
       tmp___1);
#line 3014
  instw_delete(& oldinstw);
#line 3015
  instw_delete(& newinstw);
  }
#line 3017
  return (result);
}
}
#line 3020
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *pathname ) ;
#line 3020 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *pathname ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3024
  __installwatch_refcount ++;
#line 3026
  if (! libc_handle) {
    {
#line 3027
    initialize();
    }
  }
  {
#line 3030
  debug(2, "rmdir(%s)\n", pathname);
  }
#line 3034
  if (! (__instw.gstatus & 1)) {
    {
#line 3036
    result = (*true_rmdir)(pathname);
    }
#line 3037
    return (result);
  } else
#line 3034
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3036
    result = (*true_rmdir)(pathname);
    }
#line 3037
    return (result);
  }
  {
#line 3040
  instw_new(& instw);
#line 3041
  instw_setpath(& instw, pathname);
#line 3043
  backup((char const   *)(instw.truepath));
#line 3044
  instw_apply(& instw);
#line 3046
  result = (*true_rmdir)((char const   *)(instw.translpath));
  }
#line 3047
  if (result < 0) {
    {
#line 3047
    tmp = __errno_location();
#line 3047
    tmp___0 = strerror(*tmp);
#line 3047
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3047
    tmp___1 = "success";
  }
  {
#line 3047
  logg("%d\trmdir\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 3049
  instw_delete(& instw);
  }
#line 3051
  return (result);
}
}
#line 3054 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  dir ,
                                                 struct dirent *** __restrict  namelist ,
                                                 int (*select___0)(struct dirent  const  * ) ,
                                                 int (*compar)(struct dirent  const  ** ,
                                                               struct dirent  const  ** ) ) 
{ 
  int result ;

  {
#line 3059
  if (! libc_handle) {
    {
#line 3060
    initialize();
    }
  }
  {
#line 3063
  debug(2, "scandir(%s,%p,%p,%p)\n", dir, namelist, select___0, compar);
  }
#line 3067
  if (! (__instw.gstatus & 1)) {
    {
#line 3069
    result = (*true_scandir)((char const   *)dir, (struct dirent ***)namelist, select___0,
                             compar);
    }
#line 3070
    return (result);
  } else
#line 3067
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3069
    result = (*true_scandir)((char const   *)dir, (struct dirent ***)namelist, select___0,
                             compar);
    }
#line 3070
    return (result);
  }
  {
#line 3073
  result = (*true_scandir)((char const   *)dir, (struct dirent ***)namelist, select___0,
                           compar);
  }
#line 3075
  return (result);
}
}
#line 3078
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int version ,
                                                                                         char const   *pathname ,
                                                                                         struct stat *info ) ;
#line 3078 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int version , char const   *pathname ,
                                                           struct stat *info ) 
{ 
  int result ;
  instw_t instw ;
  int status ;

  {
#line 3083
  if (! libc_handle) {
    {
#line 3084
    initialize();
    }
  }
  {
#line 3087
  debug(2, "stat(%s,%p)\n", pathname, info);
  }
#line 3091
  if (! (__instw.gstatus & 1)) {
    {
#line 3093
    result = (*true_xstat)(version, pathname, info);
    }
#line 3094
    return (result);
  } else
#line 3091
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3093
    result = (*true_xstat)(version, pathname, info);
    }
#line 3094
    return (result);
  }
  {
#line 3097
  instw_new(& instw);
#line 3098
  instw_setpath(& instw, pathname);
#line 3099
  instw_getstatus(& instw, & status);
#line 3102
  instw_print(& instw);
  }
#line 3105
  if (status & 1) {
    {
#line 3106
    debug(4, "\teffective stat(%s,%p)\n", instw.translpath, info);
#line 3108
    result = (*true_xstat)(version, (char const   *)(instw.translpath), info);
    }
  } else {
    {
#line 3110
    debug(4, "\teffective stat(%s,%p)\n", instw.path, info);
#line 3112
    result = (*true_xstat)(version, (char const   *)(instw.path), info);
    }
  }
  {
#line 3115
  instw_delete(& instw);
  }
#line 3117
  return (result);
}
}
#line 3120
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int version ,
                                                                                          char const   *pathname ,
                                                                                          struct stat *info ) ;
#line 3120 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int version , char const   *pathname ,
                                                            struct stat *info ) 
{ 
  int result ;
  instw_t instw ;
  int status ;

  {
#line 3125
  if (! libc_handle) {
    {
#line 3126
    initialize();
    }
  }
  {
#line 3129
  debug(2, "lstat(%s,%p)\n", pathname, info);
  }
#line 3133
  if (! (__instw.gstatus & 1)) {
    {
#line 3135
    result = (*true_lxstat)(version, pathname, info);
    }
#line 3136
    return (result);
  } else
#line 3133
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3135
    result = (*true_lxstat)(version, pathname, info);
    }
#line 3136
    return (result);
  }
  {
#line 3139
  instw_new(& instw);
#line 3140
  instw_setpath(& instw, pathname);
#line 3141
  instw_getstatus(& instw, & status);
#line 3144
  instw_print(& instw);
  }
#line 3147
  if (status & 1) {
    {
#line 3148
    debug(4, "\teffective lstat(%s,%p)\n", instw.translpath, info);
#line 3150
    result = (*true_lxstat)(version, (char const   *)(instw.translpath), info);
    }
  } else {
    {
#line 3152
    debug(4, "\teffective lstat(%s,%p)\n", instw.path, info);
#line 3154
    result = (*true_lxstat)(version, (char const   *)(instw.path), info);
    }
  }
  {
#line 3157
  instw_delete(& instw);
  }
#line 3159
  return (result);
}
}
#line 3162
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *pathname ,
                                                                                         char const   *slink ) ;
#line 3162 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *pathname ,
                                                           char const   *slink ) 
{ 
  int result ;
  instw_t instw ;
  instw_t instw_slink ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3167
  __installwatch_refcount ++;
#line 3169
  if (! libc_handle) {
    {
#line 3170
    initialize();
    }
  }
  {
#line 3173
  debug(2, "symlink(%s,%s)\n", pathname, slink);
  }
#line 3177
  if (! (__instw.gstatus & 1)) {
    {
#line 3179
    result = (*true_symlink)(pathname, slink);
    }
#line 3180
    return (result);
  } else
#line 3177
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3179
    result = (*true_symlink)(pathname, slink);
    }
#line 3180
    return (result);
  }
  {
#line 3183
  instw_new(& instw);
#line 3184
  instw_new(& instw_slink);
#line 3185
  instw_setpath(& instw, pathname);
#line 3186
  instw_setpath(& instw_slink, slink);
#line 3189
  instw_print(& instw_slink);
#line 3192
  backup((char const   *)(instw_slink.truepath));
#line 3193
  instw_apply(& instw_slink);
#line 3195
  result = (*true_symlink)(pathname, (char const   *)(instw_slink.translpath));
  }
#line 3196
  if (result < 0) {
    {
#line 3196
    tmp = __errno_location();
#line 3196
    tmp___0 = strerror(*tmp);
#line 3196
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3196
    tmp___1 = "success";
  }
  {
#line 3196
  logg("%d\tsymlink\t%s\t%s\t#%s\n", result, instw.path, instw_slink.reslvpath, tmp___1);
#line 3200
  instw_delete(& instw);
#line 3201
  instw_delete(& instw_slink);
  }
#line 3203
  return (result);
}
}
#line 3206
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) truncate)(char const   *path ,
                                                                                        __off_t length ) ;
#line 3206 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) truncate)(char const   *path , __off_t length ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3210
  __installwatch_refcount ++;
#line 3212
  if (! libc_handle) {
    {
#line 3213
    initialize();
    }
  }
  {
#line 3216
  debug(2, "truncate(%s,length)\n", path);
  }
#line 3220
  if (! (__instw.gstatus & 1)) {
    {
#line 3222
    result = (*true_truncate)(path, length);
    }
#line 3223
    return (result);
  } else
#line 3220
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3222
    result = (*true_truncate)(path, length);
    }
#line 3223
    return (result);
  }
  {
#line 3226
  instw_new(& instw);
#line 3227
  instw_setpath(& instw, path);
#line 3230
  instw_print(& instw);
#line 3233
  backup((char const   *)(instw.truepath));
#line 3234
  instw_apply(& instw);
#line 3236
  result = (*true_truncate)((char const   *)(instw.translpath), length);
  }
#line 3237
  if (result < 0) {
    {
#line 3237
    tmp = __errno_location();
#line 3237
    tmp___0 = strerror(*tmp);
#line 3237
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3237
    tmp___1 = "success";
  }
  {
#line 3237
  logg("%d\ttruncate\t%s\t%d\t#%s\n", result, instw.reslvpath, (int )length, tmp___1);
#line 3240
  instw_delete(& instw);
  }
#line 3242
  return (result);
}
}
#line 3245
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *pathname ) ;
#line 3245 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *pathname ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3249
  __installwatch_refcount ++;
#line 3251
  if (! libc_handle) {
    {
#line 3252
    initialize();
    }
  }
  {
#line 3255
  debug(2, "unlink(%s)\n", pathname);
  }
#line 3259
  if (! (__instw.gstatus & 1)) {
    {
#line 3261
    result = (*true_unlink)(pathname);
    }
#line 3262
    return (result);
  } else
#line 3259
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3261
    result = (*true_unlink)(pathname);
    }
#line 3262
    return (result);
  }
  {
#line 3265
  instw_new(& instw);
#line 3266
  instw_setpath(& instw, pathname);
#line 3269
  instw_print(& instw);
#line 3272
  backup((char const   *)(instw.truepath));
#line 3273
  instw_apply(& instw);
#line 3275
  result = (*true_unlink)((char const   *)(instw.translpath));
  }
#line 3276
  if (result < 0) {
    {
#line 3276
    tmp = __errno_location();
#line 3276
    tmp___0 = strerror(*tmp);
#line 3276
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3276
    tmp___1 = "success";
  }
  {
#line 3276
  logg("%d\tunlink\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 3278
  instw_delete(& instw);
  }
#line 3280
  return (result);
}
}
#line 3283
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *pathname ,
                                                                                     struct utimbuf  const  *newtimes ) ;
#line 3283 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *pathname , struct utimbuf  const  *newtimes ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3287
  if (! libc_handle) {
    {
#line 3288
    initialize();
    }
  }
  {
#line 3291
  debug(2, "utime(%s,newtimes)\n", pathname);
  }
#line 3295
  if (! (__instw.gstatus & 1)) {
    {
#line 3297
    result = (*true_utime)(pathname, newtimes);
    }
#line 3298
    return (result);
  } else
#line 3295
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3297
    result = (*true_utime)(pathname, newtimes);
    }
#line 3298
    return (result);
  }
  {
#line 3301
  instw_new(& instw);
#line 3302
  instw_setpath(& instw, pathname);
#line 3305
  instw_print(& instw);
#line 3308
  backup((char const   *)(instw.truepath));
#line 3309
  instw_apply(& instw);
#line 3311
  result = (*true_utime)((char const   *)(instw.translpath), newtimes);
  }
#line 3312
  if (result < 0) {
    {
#line 3312
    tmp = __errno_location();
#line 3312
    tmp___0 = strerror(*tmp);
#line 3312
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3312
    tmp___1 = "success";
  }
  {
#line 3312
  logg("%d\tutime\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 3314
  instw_delete(& instw);
  }
#line 3316
  return (result);
}
}
#line 3319 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int utimes(char const   *pathname , struct timeval  const  *newtimes ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3323
  if (! libc_handle) {
    {
#line 3324
    initialize();
    }
  }
  {
#line 3327
  debug(2, "utimes(%s,newtimes)\n", pathname);
  }
#line 3331
  if (! (__instw.gstatus & 1)) {
    {
#line 3333
    result = (*true_utimes)(pathname, newtimes);
    }
#line 3334
    return (result);
  } else
#line 3331
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3333
    result = (*true_utimes)(pathname, newtimes);
    }
#line 3334
    return (result);
  }
  {
#line 3337
  instw_new(& instw);
#line 3338
  instw_setpath(& instw, pathname);
#line 3341
  instw_print(& instw);
#line 3344
  backup((char const   *)(instw.truepath));
#line 3345
  instw_apply(& instw);
#line 3347
  result = (*true_utimes)((char const   *)(instw.translpath), newtimes);
  }
#line 3348
  if (result < 0) {
    {
#line 3348
    tmp = __errno_location();
#line 3348
    tmp___0 = strerror(*tmp);
#line 3348
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3348
    tmp___1 = "success";
  }
  {
#line 3348
  logg("%d\tutimes\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 3350
  instw_delete(& instw);
  }
#line 3352
  return (result);
}
}
#line 3355
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *pathname ,
                                                                                      int type ) ;
#line 3355 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *pathname , int type ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3359
  if (! libc_handle) {
    {
#line 3360
    initialize();
    }
  }
  {
#line 3363
  debug(2, "access(%s,%d)\n", pathname, type);
  }
#line 3367
  if (! (__instw.gstatus & 1)) {
    {
#line 3369
    result = (*true_access)(pathname, type);
    }
#line 3370
    return (result);
  } else
#line 3367
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3369
    result = (*true_access)(pathname, type);
    }
#line 3370
    return (result);
  }
  {
#line 3373
  instw_new(& instw);
#line 3374
  instw_setpath(& instw, pathname);
#line 3377
  instw_print(& instw);
#line 3380
  backup((char const   *)(instw.truepath));
#line 3381
  instw_apply(& instw);
#line 3383
  result = (*true_access)((char const   *)(instw.translpath), type);
  }
#line 3384
  if (result < 0) {
    {
#line 3384
    tmp = __errno_location();
#line 3384
    tmp___0 = strerror(*tmp);
#line 3384
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3384
    tmp___1 = "success";
  }
  {
#line 3384
  logg("%d\taccess\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 3386
  instw_delete(& instw);
  }
#line 3388
  return (result);
}
}
#line 3391 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int setxattr(char const   *pathname , char const   *name , void const   *value , size_t size ,
             int flags ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3397
  __installwatch_refcount ++;
#line 3399
  if (! libc_handle) {
    {
#line 3400
    initialize();
    }
  }
  {
#line 3403
  debug(2, "setxattr(%s,%s)\n", pathname, name);
  }
#line 3407
  if (! (__instw.gstatus & 1)) {
    {
#line 3409
    result = (*true_setxattr)(pathname, name, value, size, flags);
    }
#line 3411
    return (result);
  } else
#line 3407
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3409
    result = (*true_setxattr)(pathname, name, value, size, flags);
    }
#line 3411
    return (result);
  }
  {
#line 3414
  instw_new(& instw);
#line 3415
  instw_setpath(& instw, pathname);
#line 3418
  instw_print(& instw);
#line 3421
  backup((char const   *)(instw.truepath));
#line 3422
  instw_apply(& instw);
#line 3424
  result = (*true_setxattr)((char const   *)(instw.translpath), name, value, size,
                            flags);
  }
#line 3425
  if (result < 0) {
    {
#line 3425
    tmp = __errno_location();
#line 3425
    tmp___0 = strerror(*tmp);
#line 3425
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3425
    tmp___1 = "success";
  }
  {
#line 3425
  logg("%d\tsetxattr\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 3427
  instw_delete(& instw);
  }
#line 3429
  return (result);
}
}
#line 3432 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int removexattr(char const   *pathname , char const   *name ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3437
  __installwatch_refcount ++;
#line 3439
  if (! libc_handle) {
    {
#line 3440
    initialize();
    }
  }
  {
#line 3443
  debug(2, "removexattr(%s,%s)\n", pathname, name);
  }
#line 3447
  if (! (__instw.gstatus & 1)) {
    {
#line 3449
    result = (*true_removexattr)(pathname, name);
    }
#line 3450
    return (result);
  } else
#line 3447
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3449
    result = (*true_removexattr)(pathname, name);
    }
#line 3450
    return (result);
  }
  {
#line 3453
  instw_new(& instw);
#line 3454
  instw_setpath(& instw, pathname);
#line 3457
  instw_print(& instw);
#line 3460
  backup((char const   *)(instw.truepath));
#line 3461
  instw_apply(& instw);
#line 3463
  result = (*true_removexattr)((char const   *)(instw.translpath), name);
  }
#line 3464
  if (result < 0) {
    {
#line 3464
    tmp = __errno_location();
#line 3464
    tmp___0 = strerror(*tmp);
#line 3464
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3464
    tmp___1 = "success";
  }
  {
#line 3464
  logg("%d\tremovexattr\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 3466
  instw_delete(& instw);
  }
#line 3468
  return (result);
}
}
#line 3472 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1))) creat64)(char const   *pathname , unsigned int mode ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3477
  __installwatch_refcount ++;
#line 3479
  if (! libc_handle) {
    {
#line 3480
    initialize();
    }
  }
  {
#line 3483
  debug(2, "creat64(%s,mode)\n", pathname);
  }
#line 3487
  if (! (__instw.gstatus & 1)) {
    {
#line 3489
    result = (*true_creat64)(pathname, mode);
    }
#line 3490
    return (result);
  } else
#line 3487
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3489
    result = (*true_creat64)(pathname, mode);
    }
#line 3490
    return (result);
  }
  {
#line 3493
  instw_new(& instw);
#line 3494
  instw_setpath(& instw, pathname);
#line 3497
  instw_print(& instw);
#line 3500
  backup((char const   *)(instw.truepath));
#line 3501
  instw_apply(& instw);
#line 3503
  result = (*true_open64)((char const   *)(instw.translpath), 577, mode);
  }
#line 3504
  if (result < 0) {
    {
#line 3504
    tmp = __errno_location();
#line 3504
    tmp___0 = strerror(*tmp);
#line 3504
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3504
    tmp___1 = "success";
  }
  {
#line 3504
  logg("%d\tcreat\t%s\t#%s\n", result, instw.reslvpath, tmp___1);
#line 3506
  instw_delete(& instw);
  }
#line 3508
  return (result);
}
}
#line 3511
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate64)(int fd ,
                                                                           __off64_t length ) ;
#line 3511 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__leaf__)) ftruncate64)(int fd , __off64_t length ) 
{ 
  int result ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3514
  __installwatch_refcount ++;
#line 3516
  if (! libc_handle) {
    {
#line 3517
    initialize();
    }
  }
  {
#line 3520
  debug(2, "ftruncate64\n");
#line 3523
  result = (*true_ftruncate64)(fd, length);
  }
#line 3524
  if (result < 0) {
    {
#line 3524
    tmp = __errno_location();
#line 3524
    tmp___0 = strerror(*tmp);
#line 3524
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3524
    tmp___1 = "success";
  }
  {
#line 3524
  logg("%d\tftruncate\t%d\t%d\t#%s\n", result, fd, (int )length, tmp___1);
  }
#line 3525
  return (result);
}
}
#line 3528 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
FILE *fopen64(char const   * __restrict  pathname , char const   * __restrict  mode ) 
{ 
  FILE *result ;
  instw_t instw ;
  int status ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3533
  __installwatch_refcount ++;
#line 3535
  if (! libc_handle) {
    {
#line 3536
    initialize();
    }
  }
  {
#line 3539
  debug(2, "fopen64(%s,%s)\n", pathname, mode);
  }
#line 3543
  if (! (__instw.gstatus & 1)) {
    {
#line 3545
    result = (*true_fopen64)((char const   *)pathname, (char const   *)mode);
    }
#line 3546
    return (result);
  } else
#line 3543
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3545
    result = (*true_fopen64)((char const   *)pathname, (char const   *)mode);
    }
#line 3546
    return (result);
  }
  {
#line 3549
  instw_new(& instw);
#line 3550
  instw_setpath(& instw, (char const   *)pathname);
#line 3553
  instw_print(& instw);
  }
#line 3556
  if ((int const   )*(mode + 0) == 119) {
    {
#line 3557
    backup((char const   *)(instw.truepath));
#line 3558
    instw_apply(& instw);
    }
  } else
#line 3556
  if ((int const   )*(mode + 0) == 97) {
    {
#line 3557
    backup((char const   *)(instw.truepath));
#line 3558
    instw_apply(& instw);
    }
  } else
#line 3556
  if ((int const   )*(mode + 1) == 43) {
    {
#line 3557
    backup((char const   *)(instw.truepath));
#line 3558
    instw_apply(& instw);
    }
  }
  {
#line 3561
  instw_getstatus(& instw, & status);
  }
#line 3563
  if (status & 1) {
    {
#line 3564
    debug(4, "\teffective fopen64(%s)\n", instw.translpath);
#line 3565
    result = (*true_fopen64)((char const   *)(instw.translpath), (char const   *)mode);
    }
  } else {
    {
#line 3567
    debug(4, "\teffective fopen64(%s)\n", instw.path);
#line 3568
    result = (*true_fopen64)((char const   *)(instw.path), (char const   *)mode);
    }
  }
#line 3571
  if ((int const   )*(mode + 0) == 119) {
#line 3571
    goto _L;
  } else
#line 3571
  if ((int const   )*(mode + 0) == 97) {
#line 3571
    goto _L;
  } else
#line 3571
  if ((int const   )*(mode + 1) == 43) {
    _L: /* CIL Label */ 
#line 3572
    if ((unsigned long )result < 0UL) {
      {
#line 3572
      tmp = __errno_location();
#line 3572
      tmp___0 = strerror(*tmp);
#line 3572
      tmp___1 = (char const   *)tmp___0;
      }
    } else {
#line 3572
      tmp___1 = "success";
    }
    {
#line 3572
    logg("%ld\tfopen64\t%s\t#%s\n", (intptr_t )result, instw.reslvpath, tmp___1);
    }
  }
  {
#line 3575
  instw_delete(& instw);
  }
#line 3577
  return (result);
}
}
#line 3580 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1))) open64)(char const   *pathname , int flags 
                                              , ...) 
{ 
  va_list ap ;
  mode_t mode ;
  int result ;
  instw_t instw ;
  int status ;
  mode_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 3588
  __installwatch_refcount ++;
#line 3590
  if (! libc_handle) {
    {
#line 3591
    initialize();
    }
  }
  {
#line 3594
  debug(2, "open64(%s,%d,mode)\n", pathname, flags);
#line 3597
  __builtin_va_start(ap, flags);
#line 3598
  tmp = __builtin_va_arg(ap, int );
#line 3598
  mode = tmp;
#line 3599
  __builtin_va_end(ap);
  }
#line 3602
  if (! (__instw.gstatus & 1)) {
    {
#line 3604
    result = (*true_open64)(pathname, flags, mode);
    }
#line 3605
    return (result);
  } else
#line 3602
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3604
    result = (*true_open64)(pathname, flags, mode);
    }
#line 3605
    return (result);
  }
  {
#line 3608
  instw_new(& instw);
#line 3609
  instw_setpath(& instw, pathname);
#line 3612
  instw_print(& instw);
  }
#line 3615
  if (flags & 3) {
    {
#line 3616
    backup((char const   *)(instw.truepath));
#line 3617
    instw_apply(& instw);
    }
  }
  {
#line 3620
  instw_getstatus(& instw, & status);
  }
#line 3622
  if (status & 1) {
    {
#line 3623
    debug(4, "\teffective open64(%s)\n", instw.translpath);
#line 3624
    result = (*true_open64)((char const   *)(instw.translpath), flags, mode);
    }
  } else {
    {
#line 3626
    debug(4, "\teffective open64(%s)\n", instw.path);
#line 3627
    result = (*true_open64)((char const   *)(instw.path), flags, mode);
    }
  }
#line 3630
  if (flags & 3) {
#line 3631
    if (result < 0) {
      {
#line 3631
      tmp___0 = __errno_location();
#line 3631
      tmp___1 = strerror(*tmp___0);
#line 3631
      tmp___2 = (char const   *)tmp___1;
      }
    } else {
#line 3631
      tmp___2 = "success";
    }
    {
#line 3631
    logg("%d\topen\t%s\t#%s\n", result, instw.reslvpath, tmp___2);
    }
  }
  {
#line 3634
  instw_delete(& instw);
  }
#line 3636
  return (result);
}
}
#line 3639 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
struct dirent64 *( __attribute__((__nonnull__(1))) readdir64)(DIR *dir ) 
{ 
  struct dirent64 *result ;

  {
#line 3642
  if (! libc_handle) {
    {
#line 3643
    initialize();
    }
  }
  {
#line 3646
  debug(3, "readdir64(%p)\n", dir);
  }
#line 3650
  if (! (__instw.gstatus & 1)) {
    {
#line 3652
    result = (*true_readdir64)(dir);
    }
#line 3653
    return (result);
  } else
#line 3650
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3652
    result = (*true_readdir64)(dir);
    }
#line 3653
    return (result);
  }
  {
#line 3656
  result = (*true_readdir64)(dir);
#line 3659
  __instw_printdirent64(result);
  }
#line 3662
  return (result);
}
}
#line 3665 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1,2))) scandir64)(char const   * __restrict  dir ,
                                                   struct dirent64 *** __restrict  namelist ,
                                                   int (*select___0)(struct dirent64  const  * ) ,
                                                   int (*compar)(struct dirent64  const  ** ,
                                                                 struct dirent64  const  ** ) ) 
{ 
  int result ;

  {
#line 3670
  if (! libc_handle) {
    {
#line 3671
    initialize();
    }
  }
  {
#line 3674
  debug(2, "scandir64(%s,%p,%p,%p)\n", dir, namelist, select___0, compar);
  }
#line 3678
  if (! (__instw.gstatus & 1)) {
    {
#line 3680
    result = (*true_scandir64)((char const   *)dir, (struct dirent64 ***)namelist,
                               select___0, compar);
    }
#line 3681
    return (result);
  } else
#line 3678
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3680
    result = (*true_scandir64)((char const   *)dir, (struct dirent64 ***)namelist,
                               select___0, compar);
    }
#line 3681
    return (result);
  }
  {
#line 3684
  result = (*true_scandir64)((char const   *)dir, (struct dirent64 ***)namelist, select___0,
                             compar);
  }
#line 3686
  return (result);
}
}
#line 3689
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat64)(int version ,
                                                                                           char const   *pathname ,
                                                                                           struct stat64 *info ) ;
#line 3689 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat64)(int version , char const   *pathname ,
                                                             struct stat64 *info ) 
{ 
  int result ;
  instw_t instw ;
  int status ;

  {
  {
#line 3695
  debug(2, "stat64(%s,%p)\n", pathname, info);
  }
#line 3699
  if (! (__instw.gstatus & 1)) {
    {
#line 3701
    result = (*true_xstat64)(version, pathname, info);
    }
#line 3702
    return (result);
  } else
#line 3699
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3701
    result = (*true_xstat64)(version, pathname, info);
    }
#line 3702
    return (result);
  }
  {
#line 3705
  instw_new(& instw);
#line 3706
  instw_setpath(& instw, pathname);
#line 3707
  instw_getstatus(& instw, & status);
#line 3710
  instw_print(& instw);
  }
#line 3713
  if (status & 1) {
    {
#line 3714
    debug(4, "\teffective stat64(%s,%p)\n", instw.translpath, info);
#line 3716
    result = (*true_xstat64)(version, (char const   *)(instw.translpath), info);
    }
  } else {
    {
#line 3718
    debug(4, "\teffective stat64(%s,%p)\n", instw.path, info);
#line 3720
    result = (*true_xstat64)(version, (char const   *)(instw.path), info);
    }
  }
  {
#line 3723
  instw_delete(& instw);
  }
#line 3725
  return (result);
}
}
#line 3728
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat64)(int version ,
                                                                                            char const   *pathname ,
                                                                                            struct stat64 *info ) ;
#line 3728 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat64)(int version , char const   *pathname ,
                                                              struct stat64 *info ) 
{ 
  int result ;
  instw_t instw ;
  int status ;

  {
  {
#line 3734
  debug(2, "lstat64(%s,%p)\n", pathname, info);
  }
#line 3738
  if (! (__instw.gstatus & 1)) {
    {
#line 3740
    result = (*true_lxstat64)(version, pathname, info);
    }
#line 3741
    return (result);
  } else
#line 3738
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3740
    result = (*true_lxstat64)(version, pathname, info);
    }
#line 3741
    return (result);
  }
  {
#line 3744
  instw_new(& instw);
#line 3745
  instw_setpath(& instw, pathname);
#line 3746
  instw_getstatus(& instw, & status);
#line 3749
  instw_print(& instw);
  }
#line 3752
  if (status & 1) {
    {
#line 3753
    debug(4, "\teffective lstat64(%s,%p)\n", instw.translpath, info);
#line 3755
    result = (*true_lxstat64)(version, (char const   *)(instw.translpath), info);
    }
  } else {
    {
#line 3757
    debug(4, "\teffective lstat64(%s,%p)\n", instw.path, info);
#line 3759
    result = (*true_lxstat64)(version, (char const   *)(instw.path), info);
    }
  }
  {
#line 3762
  instw_delete(& instw);
  }
#line 3764
  return (result);
}
}
#line 3767
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) truncate64)(char const   *path ,
                                                                                          __off64_t length ) ;
#line 3767 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1), __leaf__)) truncate64)(char const   *path , __off64_t length ) 
{ 
  int result ;
  instw_t instw ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 3771
  if (! libc_handle) {
    {
#line 3772
    initialize();
    }
  }
#line 3774
  __installwatch_refcount ++;
#line 3776
  if (! libc_handle) {
    {
#line 3777
    initialize();
    }
  }
  {
#line 3780
  debug(2, "truncate64(%s,length)\n", path);
  }
#line 3784
  if (! (__instw.gstatus & 1)) {
    {
#line 3786
    result = (*true_truncate64)(path, length);
    }
#line 3787
    return (result);
  } else
#line 3784
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3786
    result = (*true_truncate64)(path, length);
    }
#line 3787
    return (result);
  }
  {
#line 3790
  instw_new(& instw);
#line 3791
  instw_setpath(& instw, path);
#line 3794
  instw_print(& instw);
#line 3797
  backup((char const   *)(instw.truepath));
#line 3798
  instw_apply(& instw);
#line 3800
  result = (*true_truncate64)((char const   *)(instw.translpath), length);
  }
#line 3802
  if (result < 0) {
    {
#line 3802
    tmp = __errno_location();
#line 3802
    tmp___0 = strerror(*tmp);
#line 3802
    tmp___1 = (char const   *)tmp___0;
    }
  } else {
#line 3802
    tmp___1 = "success";
  }
  {
#line 3802
  logg("%d\ttruncate\t%s\t%d\t#%s\n", result, instw.reslvpath, (int )length, tmp___1);
#line 3805
  instw_delete(& instw);
  }
#line 3807
  return (result);
}
}
#line 3830 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2))) openat)(int dirfd___0 , char const   *path ,
                                              int flags  , ...) 
{ 
  mode_t mode ;
  va_list arg ;
  mode_t tmp ;
  int result ;
  instw_t instw ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3831
  mode = (mode_t )0;
#line 3833
  if (flags & 64) {
    {
#line 3834
    __builtin_va_start(arg, flags);
#line 3835
    tmp = __builtin_va_arg(arg, int );
#line 3835
    mode = tmp;
#line 3836
    __builtin_va_end(arg);
    }
  }
#line 3843
  if (dirfd___0 == -100) {
    {
#line 3844
    tmp___0 = open(path, flags, mode);
    }
#line 3844
    return (tmp___0);
  } else
#line 3843
  if ((int const   )*path == 47) {
    {
#line 3844
    tmp___0 = open(path, flags, mode);
    }
#line 3844
    return (tmp___0);
  }
#line 3846
  __installwatch_refcount ++;
#line 3848
  if (! libc_handle) {
    {
#line 3849
    initialize();
    }
  }
  {
#line 3852
  debug(2, "openat(%d, %s, 0x%x, 0%o)\n", dirfd___0, path, flags, mode);
  }
#line 3856
  if (! (__instw.gstatus & 1)) {
    {
#line 3858
    tmp___1 = (*true_open)(path, flags, mode);
    }
#line 3858
    return (tmp___1);
  } else
#line 3856
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3858
    tmp___1 = (*true_open)(path, flags, mode);
    }
#line 3858
    return (tmp___1);
  }
  {
#line 3860
  instw_new(& instw);
#line 3861
  instw_setpathrel(& instw, dirfd___0, path);
#line 3864
  instw_print(& instw);
#line 3867
  result = open((char const   *)(instw.path), flags, mode);
#line 3869
  instw_delete(& instw);
  }
#line 3871
  return (result);
}
}
#line 3874
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fchmodat)(int dirfd___0 ,
                                                                                        char const   *path ,
                                                                                        __mode_t mode ,
                                                                                        int flag ) ;
#line 3874 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2), __leaf__)) fchmodat)(int dirfd___0 , char const   *path ,
                                                          __mode_t mode , int flag ) 
{ 
  int result ;
  instw_t instw ;
  int tmp ;
  int tmp___0 ;

  {
#line 3880
  if (dirfd___0 == -100) {
    {
#line 3883
    debug(2, "fchmodat(%d,%s,0%o)\n", dirfd___0, path, mode);
#line 3885
    tmp = chmod(path, mode);
    }
#line 3885
    return (tmp);
  } else
#line 3880
  if ((int const   )*path == 47) {
    {
#line 3883
    debug(2, "fchmodat(%d,%s,0%o)\n", dirfd___0, path, mode);
#line 3885
    tmp = chmod(path, mode);
    }
#line 3885
    return (tmp);
  }
#line 3888
  __installwatch_refcount ++;
#line 3890
  if (! libc_handle) {
    {
#line 3891
    initialize();
    }
  }
  {
#line 3894
  debug(2, "fchmodat(%d,%s,0%o)\n", dirfd___0, path, mode);
  }
#line 3898
  if (! (__instw.gstatus & 1)) {
    {
#line 3900
    tmp___0 = (*true_chmod)(path, mode);
    }
#line 3900
    return (tmp___0);
  } else
#line 3898
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 3900
    tmp___0 = (*true_chmod)(path, mode);
    }
#line 3900
    return (tmp___0);
  }
  {
#line 3902
  instw_new(& instw);
#line 3903
  instw_setpathrel(& instw, dirfd___0, path);
#line 3906
  instw_print(& instw);
#line 3909
  result = chmod((char const   *)(instw.path), mode);
#line 3911
  instw_delete(& instw);
  }
#line 3913
  return (result);
}
}
#line 3916
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fchownat)(int dirfd___0 ,
                                                                                        char const   *path ,
                                                                                        __uid_t owner ,
                                                                                        __gid_t group ,
                                                                                        int flags ) ;
#line 3916 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2), __leaf__)) fchownat)(int dirfd___0 , char const   *path ,
                                                          __uid_t owner , __gid_t group ,
                                                          int flags ) 
{ 
  int result ;
  instw_t instw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3922
  if (dirfd___0 == -100) {
#line 3922
    goto _L;
  } else
#line 3922
  if ((int const   )*path == 47) {
    _L: /* CIL Label */ 
    {
#line 3925
    debug(2, "fchownat(%d,%s,%d,%d,0%o)\n", dirfd___0, path, owner, group, flags);
    }
#line 3931
    if (flags & 256) {
      {
#line 3932
      tmp = lchown(path, owner, group);
      }
#line 3932
      return (tmp);
    } else {
      {
#line 3935
      tmp___0 = chown(path, owner, group);
      }
#line 3935
      return (tmp___0);
    }
  }
#line 3940
  __installwatch_refcount ++;
#line 3942
  if (! libc_handle) {
    {
#line 3943
    initialize();
    }
  }
  {
#line 3946
  debug(2, "fchownat(%d,%s,%d,%d,0%o)\n", dirfd___0, path, owner, group, flags);
  }
#line 3950
  if (! (__instw.gstatus & 1)) {
#line 3950
    goto _L___0;
  } else
#line 3950
  if (! (__instw.gstatus & (1 << 1))) {
    _L___0: /* CIL Label */ 
#line 3956
    if (flags & 256) {
      {
#line 3957
      tmp___1 = (*true_lchown)(path, owner, group);
      }
#line 3957
      return (tmp___1);
    } else {
      {
#line 3960
      tmp___2 = (*true_chown)(path, owner, group);
      }
#line 3960
      return (tmp___2);
    }
  }
  {
#line 3964
  instw_new(& instw);
#line 3965
  instw_setpathrel(& instw, dirfd___0, path);
#line 3968
  instw_print(& instw);
  }
#line 3973
  if (flags & 256) {
    {
#line 3974
    result = lchown((char const   *)(instw.path), owner, group);
    }
  } else {
    {
#line 3977
    result = chown((char const   *)(instw.path), owner, group);
    }
  }
  {
#line 3982
  instw_delete(& instw);
  }
#line 3984
  return (result);
}
}
#line 3988
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat)(int version ,
                                                                                            int dirfd___0 ,
                                                                                            char const   *path ,
                                                                                            struct stat *s ,
                                                                                            int flags ) ;
#line 3988 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat)(int version , int dirfd___0 ,
                                                              char const   *path ,
                                                              struct stat *s , int flags ) 
{ 
  int result ;
  instw_t instw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3994
  if (dirfd___0 == -100) {
#line 3994
    goto _L;
  } else
#line 3994
  if ((int const   )*path == 47) {
    _L: /* CIL Label */ 
    {
#line 3997
    debug(2, "__fxstatat(%d,%s,%p,0%o)\n", dirfd___0, path, s, flags);
    }
#line 4003
    if (flags & 256) {
      {
#line 4004
      tmp = __lxstat(version, path, s);
      }
#line 4004
      return (tmp);
    } else {
      {
#line 4007
      tmp___0 = __xstat(version, path, s);
      }
#line 4007
      return (tmp___0);
    }
  }
#line 4012
  __installwatch_refcount ++;
#line 4014
  if (! libc_handle) {
    {
#line 4015
    initialize();
    }
  }
  {
#line 4018
  debug(2, "__fxstatat(%d,%s,%p,0%o)\n", dirfd___0, path, s, flags);
  }
#line 4022
  if (! (__instw.gstatus & 1)) {
#line 4022
    goto _L___0;
  } else
#line 4022
  if (! (__instw.gstatus & (1 << 1))) {
    _L___0: /* CIL Label */ 
#line 4029
    if (flags & 256) {
      {
#line 4030
      tmp___1 = (*true_lxstat)(version, path, s);
      }
#line 4030
      return (tmp___1);
    } else {
      {
#line 4033
      tmp___2 = (*true_xstat)(version, path, s);
      }
#line 4033
      return (tmp___2);
    }
  }
  {
#line 4038
  instw_new(& instw);
#line 4039
  instw_setpathrel(& instw, dirfd___0, path);
#line 4042
  instw_print(& instw);
  }
#line 4048
  if (flags & 256) {
    {
#line 4049
    result = __lxstat(version, (char const   *)(instw.path), s);
    }
  } else {
    {
#line 4052
    result = __xstat(version, (char const   *)(instw.path), s);
    }
  }
  {
#line 4056
  instw_delete(& instw);
  }
#line 4058
  return (result);
}
}
#line 4061
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat64)(int version ,
                                                                                              int dirfd___0 ,
                                                                                              char const   *path ,
                                                                                              struct stat64 *s ,
                                                                                              int flags ) ;
#line 4061 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat64)(int version , int dirfd___0 ,
                                                                char const   *path ,
                                                                struct stat64 *s ,
                                                                int flags ) 
{ 
  int result ;
  instw_t instw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4067
  if (dirfd___0 == -100) {
#line 4067
    goto _L;
  } else
#line 4067
  if ((int const   )*path == 47) {
    _L: /* CIL Label */ 
    {
#line 4070
    debug(2, "__fxstatat(%d,%s,%p,0%o)\n", dirfd___0, path, s, flags);
    }
#line 4076
    if (flags & 256) {
      {
#line 4077
      tmp = __lxstat64(version, path, s);
      }
#line 4077
      return (tmp);
    } else {
      {
#line 4080
      tmp___0 = __xstat64(version, path, s);
      }
#line 4080
      return (tmp___0);
    }
  }
#line 4085
  __installwatch_refcount ++;
#line 4087
  if (! libc_handle) {
    {
#line 4088
    initialize();
    }
  }
  {
#line 4091
  debug(2, "__fxstatat(%d,%s,%p,0%o)\n", dirfd___0, path, s, flags);
  }
#line 4095
  if (! (__instw.gstatus & 1)) {
#line 4095
    goto _L___0;
  } else
#line 4095
  if (! (__instw.gstatus & (1 << 1))) {
    _L___0: /* CIL Label */ 
#line 4101
    if (flags & 256) {
      {
#line 4102
      tmp___1 = (*true_lxstat64)(version, path, s);
      }
#line 4102
      return (tmp___1);
    } else {
      {
#line 4105
      tmp___2 = (*true_xstat64)(version, path, s);
      }
#line 4105
      return (tmp___2);
    }
  }
  {
#line 4110
  instw_new(& instw);
#line 4111
  instw_setpathrel(& instw, dirfd___0, path);
#line 4114
  instw_print(& instw);
  }
#line 4120
  if (flags & 256) {
    {
#line 4121
    result = __lxstat64(version, (char const   *)(instw.path), s);
    }
  } else {
    {
#line 4124
    result = __xstat64(version, (char const   *)(instw.path), s);
    }
  }
  {
#line 4127
  instw_delete(& instw);
  }
#line 4129
  return (result);
}
}
#line 4134
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) linkat)(int olddirfd ,
                                                                                        char const   *oldpath ,
                                                                                        int newdirfd ,
                                                                                        char const   *newpath ,
                                                                                        int flags ) ;
#line 4134 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2,4), __leaf__)) linkat)(int olddirfd , char const   *oldpath ,
                                                          int newdirfd , char const   *newpath ,
                                                          int flags ) 
{ 
  int result ;
  instw_t instwold ;
  instw_t instwnew ;
  int tmp ;
  int tmp___0 ;

  {
#line 4142
  if (olddirfd == -100) {
#line 4142
    goto _L;
  } else
#line 4142
  if ((int const   )*oldpath == 47) {
    _L: /* CIL Label */ 
#line 4142
    if (newdirfd == -100) {
      {
#line 4146
      debug(2, "linkat(%d, %s, %d, %s, 0%o)\n", olddirfd, oldpath, newdirfd, newpath,
            flags);
#line 4149
      tmp = link(oldpath, newpath);
      }
#line 4149
      return (tmp);
    } else
#line 4142
    if ((int const   )*newpath == 47) {
      {
#line 4146
      debug(2, "linkat(%d, %s, %d, %s, 0%o)\n", olddirfd, oldpath, newdirfd, newpath,
            flags);
#line 4149
      tmp = link(oldpath, newpath);
      }
#line 4149
      return (tmp);
    }
  }
#line 4163
  __installwatch_refcount ++;
#line 4165
  if (! libc_handle) {
    {
#line 4166
    initialize();
    }
  }
  {
#line 4169
  debug(2, "linkat(%d, %s, %d, %s, 0%o)\n", olddirfd, oldpath, newdirfd, newpath,
        flags);
  }
#line 4173
  if (! (__instw.gstatus & 1)) {
    {
#line 4175
    tmp___0 = (*true_link)(oldpath, newpath);
    }
#line 4175
    return (tmp___0);
  } else
#line 4173
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 4175
    tmp___0 = (*true_link)(oldpath, newpath);
    }
#line 4175
    return (tmp___0);
  }
  {
#line 4177
  instw_new(& instwold);
#line 4178
  instw_new(& instwnew);
#line 4179
  instw_setpathrel(& instwold, olddirfd, oldpath);
#line 4180
  instw_setpathrel(& instwnew, newdirfd, newpath);
#line 4183
  instw_print(& instwold);
#line 4184
  instw_print(& instwnew);
#line 4187
  result = link((char const   *)(instwold.path), (char const   *)(instwnew.path));
#line 4189
  instw_delete(& instwold);
#line 4190
  instw_delete(& instwnew);
  }
#line 4192
  return (result);
}
}
#line 4196
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) mkdirat)(int dirfd___0 ,
                                                                                       char const   *path ,
                                                                                       __mode_t mode ) ;
#line 4196 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2), __leaf__)) mkdirat)(int dirfd___0 , char const   *path ,
                                                         __mode_t mode ) 
{ 
  int result ;
  instw_t instw ;
  int tmp ;
  int tmp___0 ;

  {
#line 4202
  if (dirfd___0 == -100) {
    {
#line 4205
    debug(2, "mkdirat(%d,%s,0%o)\n", dirfd___0, path, mode);
#line 4207
    tmp = mkdir(path, mode);
    }
#line 4207
    return (tmp);
  } else
#line 4202
  if ((int const   )*path == 47) {
    {
#line 4205
    debug(2, "mkdirat(%d,%s,0%o)\n", dirfd___0, path, mode);
#line 4207
    tmp = mkdir(path, mode);
    }
#line 4207
    return (tmp);
  }
#line 4210
  __installwatch_refcount ++;
#line 4212
  if (! libc_handle) {
    {
#line 4213
    initialize();
    }
  }
  {
#line 4216
  debug(2, "mkdirat(%d,%s,0%o)\n", dirfd___0, path, mode);
  }
#line 4220
  if (! (__instw.gstatus & 1)) {
    {
#line 4222
    tmp___0 = (*true_mkdir)(path, mode);
    }
#line 4222
    return (tmp___0);
  } else
#line 4220
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 4222
    tmp___0 = (*true_mkdir)(path, mode);
    }
#line 4222
    return (tmp___0);
  }
  {
#line 4224
  instw_new(& instw);
#line 4225
  instw_setpathrel(& instw, dirfd___0, path);
#line 4228
  instw_print(& instw);
#line 4231
  result = mkdir((char const   *)(instw.path), mode);
#line 4233
  instw_delete(& instw);
  }
#line 4235
  return (result);
}
}
#line 4239
 __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(2,3), __leaf__)) readlinkat)(int dirfd___0 ,
                                                                                                char const   * __restrict  path ,
                                                                                                char * __restrict  buf ,
                                                                                                size_t bufsiz ) ;
#line 4239 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
ssize_t ( __attribute__((__nonnull__(2,3), __leaf__)) readlinkat)(int dirfd___0 ,
                                                                  char const   * __restrict  path ,
                                                                  char * __restrict  buf ,
                                                                  size_t bufsiz ) 
{ 
  int result ;
  instw_t instw ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 4246
  if (dirfd___0 == -100) {
    {
#line 4249
    debug(2, "readlinkat(%d,%s, %s, %ld)\n", dirfd___0, path, buf, (long )bufsiz);
#line 4251
    tmp = readlink(path, buf, bufsiz);
    }
#line 4251
    return (tmp);
  } else
#line 4246
  if ((int const   )*path == 47) {
    {
#line 4249
    debug(2, "readlinkat(%d,%s, %s, %ld)\n", dirfd___0, path, buf, (long )bufsiz);
#line 4251
    tmp = readlink(path, buf, bufsiz);
    }
#line 4251
    return (tmp);
  }
#line 4254
  __installwatch_refcount ++;
#line 4256
  if (! libc_handle) {
    {
#line 4257
    initialize();
    }
  }
  {
#line 4260
  debug(2, "readlinkat(%d,%s, %s, %ld)\n", dirfd___0, path, buf, (long )bufsiz);
  }
#line 4264
  if (! (__instw.gstatus & 1)) {
    {
#line 4266
    tmp___0 = (*true_readlink)((char const   *)path, (char *)buf, bufsiz);
    }
#line 4266
    return (tmp___0);
  } else
#line 4264
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 4266
    tmp___0 = (*true_readlink)((char const   *)path, (char *)buf, bufsiz);
    }
#line 4266
    return (tmp___0);
  }
  {
#line 4268
  instw_new(& instw);
#line 4269
  instw_setpathrel(& instw, dirfd___0, (char const   *)path);
#line 4272
  instw_print(& instw);
#line 4275
  tmp___1 = readlink((char const   */* __restrict  */)(instw.path), buf, bufsiz);
#line 4275
  result = (int )tmp___1;
#line 4277
  instw_delete(& instw);
  }
#line 4279
  return ((ssize_t )result);
}
}
#line 4283
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5), __leaf__)) __xmknodat)(int version ,
                                                                                            int dirfd___0 ,
                                                                                            char const   *path ,
                                                                                            __mode_t mode ,
                                                                                            __dev_t *dev ) ;
#line 4283 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(3,5), __leaf__)) __xmknodat)(int version , int dirfd___0 ,
                                                              char const   *path ,
                                                              __mode_t mode , __dev_t *dev ) 
{ 
  int result ;
  instw_t instw ;
  int tmp ;
  int tmp___0 ;

  {
#line 4289
  if (dirfd___0 == -100) {
    {
#line 4292
    debug(2, "__xmknod(%d, %s, 0%o, %p)\n", version, path, mode, dev);
#line 4294
    tmp = __xmknod(version, path, mode, dev);
    }
#line 4294
    return (tmp);
  } else
#line 4289
  if ((int const   )*path == 47) {
    {
#line 4292
    debug(2, "__xmknod(%d, %s, 0%o, %p)\n", version, path, mode, dev);
#line 4294
    tmp = __xmknod(version, path, mode, dev);
    }
#line 4294
    return (tmp);
  }
#line 4297
  __installwatch_refcount ++;
#line 4299
  if (! libc_handle) {
    {
#line 4300
    initialize();
    }
  }
  {
#line 4303
  debug(2, "__xmknod(%d, %s, 0%o, %p)\n", version, path, mode, dev);
  }
#line 4307
  if (! (__instw.gstatus & 1)) {
    {
#line 4309
    tmp___0 = (*true_xmknod)(version, path, mode, dev);
    }
#line 4309
    return (tmp___0);
  } else
#line 4307
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 4309
    tmp___0 = (*true_xmknod)(version, path, mode, dev);
    }
#line 4309
    return (tmp___0);
  }
  {
#line 4311
  instw_new(& instw);
#line 4312
  instw_setpathrel(& instw, dirfd___0, path);
#line 4315
  instw_print(& instw);
#line 4318
  result = __xmknod(version, (char const   *)(instw.path), mode, dev);
#line 4320
  instw_delete(& instw);
  }
#line 4322
  return (result);
}
}
#line 4326
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) renameat)(int olddirfd ,
                                                                        char const   *oldpath ,
                                                                        int newdirfd ,
                                                                        char const   *newpath ) ;
#line 4326 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__leaf__)) renameat)(int olddirfd , char const   *oldpath , int newdirfd ,
                                          char const   *newpath ) 
{ 
  int result ;
  instw_t instwold ;
  instw_t instwnew ;
  int tmp ;
  int tmp___0 ;

  {
#line 4334
  if (olddirfd == -100) {
#line 4334
    goto _L;
  } else
#line 4334
  if ((int const   )*oldpath == 47) {
    _L: /* CIL Label */ 
#line 4334
    if (newdirfd == -100) {
      {
#line 4338
      debug(2, "renameat(%d, %s, %d, %s)\n", olddirfd, oldpath, newdirfd, newpath);
#line 4341
      tmp = rename(oldpath, newpath);
      }
#line 4341
      return (tmp);
    } else
#line 4334
    if ((int const   )*newpath == 47) {
      {
#line 4338
      debug(2, "renameat(%d, %s, %d, %s)\n", olddirfd, oldpath, newdirfd, newpath);
#line 4341
      tmp = rename(oldpath, newpath);
      }
#line 4341
      return (tmp);
    }
  }
#line 4346
  __installwatch_refcount ++;
#line 4348
  if (! libc_handle) {
    {
#line 4349
    initialize();
    }
  }
  {
#line 4352
  debug(2, "renameat(%d, %s, %d, %s)\n", olddirfd, oldpath, newdirfd, newpath);
  }
#line 4356
  if (! (__instw.gstatus & 1)) {
    {
#line 4358
    tmp___0 = (*true_rename)(oldpath, newpath);
    }
#line 4358
    return (tmp___0);
  } else
#line 4356
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 4358
    tmp___0 = (*true_rename)(oldpath, newpath);
    }
#line 4358
    return (tmp___0);
  }
  {
#line 4360
  instw_new(& instwold);
#line 4361
  instw_new(& instwnew);
#line 4362
  instw_setpathrel(& instwold, olddirfd, oldpath);
#line 4363
  instw_setpathrel(& instwnew, newdirfd, newpath);
#line 4366
  instw_print(& instwold);
#line 4367
  instw_print(& instwnew);
#line 4370
  result = rename((char const   *)(instwold.path), (char const   *)(instwnew.path));
#line 4372
  instw_delete(& instwold);
#line 4373
  instw_delete(& instwnew);
  }
#line 4375
  return (result);
}
}
#line 4379
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3), __leaf__)) symlinkat)(char const   *oldpath ,
                                                                                           int dirfd___0 ,
                                                                                           char const   *newpath ) ;
#line 4379 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(1,3), __leaf__)) symlinkat)(char const   *oldpath ,
                                                             int dirfd___0 , char const   *newpath ) 
{ 
  int result ;
  instw_t instw ;
  int tmp ;
  int tmp___0 ;

  {
#line 4385
  if (dirfd___0 == -100) {
    {
#line 4388
    debug(2, "symlinkat(%s, %d, %s)\n", oldpath, dirfd___0, newpath);
#line 4390
    tmp = symlink(oldpath, newpath);
    }
#line 4390
    return (tmp);
  } else
#line 4385
  if ((int const   )*newpath == 47) {
    {
#line 4388
    debug(2, "symlinkat(%s, %d, %s)\n", oldpath, dirfd___0, newpath);
#line 4390
    tmp = symlink(oldpath, newpath);
    }
#line 4390
    return (tmp);
  }
#line 4393
  __installwatch_refcount ++;
#line 4395
  if (! libc_handle) {
    {
#line 4396
    initialize();
    }
  }
  {
#line 4399
  debug(2, "symlinkat(%s, %d, %s)\n", oldpath, dirfd___0, newpath);
  }
#line 4403
  if (! (__instw.gstatus & 1)) {
    {
#line 4405
    tmp___0 = (*true_symlink)(oldpath, newpath);
    }
#line 4405
    return (tmp___0);
  } else
#line 4403
  if (! (__instw.gstatus & (1 << 1))) {
    {
#line 4405
    tmp___0 = (*true_symlink)(oldpath, newpath);
    }
#line 4405
    return (tmp___0);
  }
  {
#line 4407
  instw_new(& instw);
#line 4408
  instw_setpathrel(& instw, dirfd___0, newpath);
#line 4411
  instw_print(& instw);
#line 4414
  result = symlink(oldpath, (char const   *)(instw.path));
#line 4416
  instw_delete(& instw);
  }
#line 4418
  return (result);
}
}
#line 4422
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int dirfd___0 ,
                                                                                        char const   *path ,
                                                                                        int flags ) ;
#line 4422 "/home/june/repo/benchmarks/collector/temp/checkinstall-1.6.2/installwatch/installwatch.c"
int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int dirfd___0 , char const   *path ,
                                                          int flags ) 
{ 
  int result ;
  instw_t instw ;
  int tmp ;
  int tmp___0 ;

  {
#line 4428
  if (dirfd___0 == -100) {
#line 4428
    goto _L;
  } else
#line 4428
  if ((int const   )*path == 47) {
    _L: /* CIL Label */ 
    {
#line 4431
    debug(2, "unlinkat(%d,%s,0%o)\n", dirfd___0, path, flags);
    }
#line 4437
    if (flags & 512) {
      {
#line 4438
      tmp = rmdir(path);
      }
#line 4438
      return (tmp);
    } else {
      {
#line 4441
      tmp___0 = unlink(path);
      }
#line 4441
      return (tmp___0);
    }
  }
#line 4446
  __installwatch_refcount ++;
#line 4448
  if (! libc_handle) {
    {
#line 4449
    initialize();
    }
  }
  {
#line 4452
  debug(2, "unlinkat(%d,%s,0%o)\n", dirfd___0, path, flags);
  }
#line 4456
  if (! (__instw.gstatus & 1)) {
#line 4456
    goto _L___0;
  } else
#line 4456
  if (! (__instw.gstatus & (1 << 1))) {
    _L___0: /* CIL Label */ 
#line 4461
    if (flags & 512) {
      {
#line 4462
      result = (*true_rmdir)(path);
      }
    } else {
      {
#line 4465
      result = (*true_unlink)(path);
      }
    }
  }
  {
#line 4470
  instw_new(& instw);
#line 4471
  instw_setpathrel(& instw, dirfd___0, path);
#line 4474
  instw_print(& instw);
  }
#line 4480
  if (flags & 512) {
    {
#line 4481
    result = rmdir((char const   *)(instw.path));
    }
  } else {
    {
#line 4484
    result = unlink((char const   *)(instw.path));
    }
  }
  {
#line 4487
  instw_delete(& instw);
  }
#line 4489
  return (result);
}
}
