/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_7 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_7 __sigset_t;
#line 37 "/usr/include/bits/ioctl-types.h"
struct termio {
   unsigned short c_iflag ;
   unsigned short c_oflag ;
   unsigned short c_cflag ;
   unsigned short c_lflag ;
   unsigned char c_line ;
   unsigned char c_cc[8] ;
};
#line 34 "/usr/include/bits/setjmp.h"
typedef int __jmp_buf[6];
#line 35 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 49 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 21 "/home/wslee/benchmarks/clif-0.93/pso.c"
struct var_s {
   char *adr ;
   int offset ;
   char *name ;
};
#line 81 "/home/wslee/benchmarks/clif-0.93/global.h"
struct internal_type;
#line 32 "/home/wslee/benchmarks/clif-0.93/type.h"
enum intern_arit_class {
    UNUSED_AC = 0,
    VID = 1,
    CHR = 2,
    SHORT_AC = 4,
    INTEGER = 8,
    LONG_AC = 16,
    FLT = 32,
    DOUB = 64,
    SIGNED_AC = 128,
    UNSIGNED_AC = 256,
    LAST_AND_UNUSED_ARIT_CLASS = 257
} ;
#line 50
enum intern_func_class {
    SIMPLE = 1024,
    ARRAY = 1025,
    LIB = 1026,
    TYPE = 1027,
    POINTER = 1028,
    STRUCT_FC = 1029,
    UNION_FC = 1030,
    ENUM_FC = 1031,
    LOCAL = 2048,
    REMOTE_F = 2049,
    LAST_AND_UNUSED_FUNC_CLASS = 2050
} ;
#line 95
enum type_qual {
    CONST_TQ = 4096,
    VOLATILE_TQ = 4097,
    UNDEF_TQ = 4098,
    LAST_AND_UNUSED_TYPE_QUAL = 4099
} ;
#line 106
enum storage_class_specifier {
    TYPEDEF_SC = 8192,
    EXTERN_SC = 8193,
    EXPORT_SC = 8194,
    STATIC_SC = 8195,
    AUTO_SC = 8196,
    REGISTER_SC = 8197,
    UNSPEC_SC = 8198,
    LAST_AND_UNUSED_SC_SPEC = 8199
} ;
#line 62 "/home/wslee/benchmarks/clif-0.93/tables.h"
struct ident_tab;
#line 65
struct ident_tab_loc;
#line 59 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct FIX {
   char *address ;
   struct FIX *next ;
};
#line 71 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct attr {
   enum intern_func_class function_class ;
   int export_type ;
   enum type_qual type_qualifier ;
   enum storage_class_specifier storage_class_specifier ;
   enum intern_arit_class arit_class ;
   int memory_size ;
   char *domain ;
};
#line 86 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct internal_type {
   struct internal_type *input ;
   struct internal_type *arity ;
   char *field_name ;
   int offset ;
   struct attr attribute ;
   struct internal_type *output ;
};
#line 98 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct ident_list_str {
   char *ident ;
   struct ident_list_str *next ;
};
#line 107 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct ident_tab {
   struct internal_type *type ;
   int body ;
   struct ident_list_str *list_formal_param ;
   struct FIX *next ;
   char *adr ;
};
#line 132 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct ident_tab_loc {
   struct internal_type *type ;
   int body ;
   int offset ;
   char *adr ;
   struct ident_list_str *list_formal_param ;
   struct ident_tab_loc *previous ;
};
#line 61 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_mi {
   int major ;
   int minor ;
   char *adr ;
};
#line 71 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_i {
   int major ;
   int minor ;
   int num ;
};
#line 149 "/home/wslee/benchmarks/clif-0.93/global.h"
struct fileattr;
#line 149 "/home/wslee/benchmarks/clif-0.93/global.h"
typedef struct fileattr FILEATTR;
#line 151 "/home/wslee/benchmarks/clif-0.93/global.h"
struct fileattr {
   FILE *fp ;
   char *name ;
   int line_counter ;
};
#line 29 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
struct dbg_list;
#line 29 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
typedef struct dbg_list DBGLIST;
#line 31 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
struct dbg_list {
   int line_counter ;
   char *codp ;
   DBGLIST *next ;
};
#line 38
struct dbg_files;
#line 38 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
typedef struct dbg_files DBGFILES;
#line 40 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
struct dbg_files {
   char *filename ;
   DBGLIST *info ;
   DBGFILES *next ;
};
#line 15 "/home/wslee/benchmarks/clif-0.93/s-conv.h"
typedef struct internal_type *FORMAT_ARGS;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 87 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 159 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 159 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 192 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_18 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 192 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_18 XGCValues;
#line 225
struct _XGC;
#line 225 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 238 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_19 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 238 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_19 Visual;
#line 254 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_20 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 254 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_20 Depth;
#line 266
struct _XDisplay;
#line 268 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_21 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 268 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_21 Screen;
#line 301 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_23 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 301 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_23 XSetWindowAttributes;
#line 319 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_24 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 319 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_24 XWindowAttributes;
#line 498 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 568 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_38 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 568 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_38 XKeyEvent;
#line 586 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_39 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 586 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_39 XButtonEvent;
#line 604 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_40 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 604 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_40 XMotionEvent;
#line 621 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_41 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 621 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_41 XCrossingEvent;
#line 645 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_42 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 645 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_42 XFocusChangeEvent;
#line 664 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_43 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 664 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_43 XKeymapEvent;
#line 673 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_44 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 673 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_44 XExposeEvent;
#line 684 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_45 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 684 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_45 XGraphicsExposeEvent;
#line 697 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_46 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 697 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_46 XNoExposeEvent;
#line 707 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_47 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 707 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_47 XVisibilityEvent;
#line 716 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_48 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 716 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_48 XCreateWindowEvent;
#line 729 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_49 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 729 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_49 XDestroyWindowEvent;
#line 738 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_50 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 738 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_50 XUnmapEvent;
#line 748 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_51 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 748 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_51 XMapEvent;
#line 758 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 758 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_52 XMapRequestEvent;
#line 767 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 767 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_53 XReparentEvent;
#line 779 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 779 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_54 XConfigureEvent;
#line 793 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 793 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_55 XGravityEvent;
#line 803 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 803 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_56 XResizeRequestEvent;
#line 812 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 812 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_57 XConfigureRequestEvent;
#line 827 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 827 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_58 XCirculateEvent;
#line 837 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 837 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_59 XCirculateRequestEvent;
#line 847 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 847 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_60 XPropertyEvent;
#line 858 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 858 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_61 XSelectionClearEvent;
#line 868 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 868 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_62 XSelectionRequestEvent;
#line 881 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 881 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_63 XSelectionEvent;
#line 893 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_64 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 893 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_64 XColormapEvent;
#line 908 "/usr/include/X11/Xlib.h"
union __anonunion_data_66 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 908 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_66 data ;
};
#line 908 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_65 XClientMessageEvent;
#line 923 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_67 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 923 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_67 XMappingEvent;
#line 935 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_68 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 935 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_68 XErrorEvent;
#line 945 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_69 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 945 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_69 XAnyEvent;
#line 959 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_70 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 959 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_70 XGenericEvent;
#line 969 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_71 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 969 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_71 XGenericEventCookie;
#line 984 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 984 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1028 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_72 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1028 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_72 XCharStruct;
#line 1041 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_73 {
   Atom name ;
   unsigned long card32 ;
};
#line 1041 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_73 XFontProp;
#line 1046 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_74 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1046 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_74 XFontStruct;
#line 1068 "/usr/include/X11/Xlib.h"
struct __anonstruct_XTextItem_75 {
   char *chars ;
   int nchars ;
   int delta ;
   Font font ;
};
#line 1068 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XTextItem_75 XTextItem;
#line 49 "/home/wslee/benchmarks/clif-0.93/channel_maint.h"
struct RECORD {
   double x ;
   struct RECORD *next ;
};
#line 55 "/home/wslee/benchmarks/clif-0.93/channel_maint.h"
struct LIST {
   struct RECORD *head ;
   struct RECORD *tail ;
};
#line 61 "/home/wslee/benchmarks/clif-0.93/channel_maint.h"
struct FIELD {
   double lower ;
   double upper ;
   double ax ;
   double ay ;
   double x_cur ;
   double y_cur ;
   unsigned long style ;
   GC set_gc ;
};
#line 78 "/home/wslee/benchmarks/clif-0.93/channel_maint.h"
struct CHANNEL {
   int fields ;
   int cnt ;
   double global_cnt ;
   char *type ;
   char *print_format ;
   int direction ;
   double start_time ;
   int s_time ;
   double duration_time ;
   double d_time ;
   int w_resolution[2] ;
   char *on_leave_w ;
   struct LIST *list ;
   struct LIST *list_tmp ;
   struct FIELD *member ;
   Window mywin ;
   Window mywin_write ;
   XTextItem item ;
   XFontStruct *myfont ;
   int ch_pid ;
   int ch_pid_write ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 72 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
struct yy_channelwork;
#line 72 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
struct yy_channelsvf {
   struct yy_channelwork *yy_channelstoff ;
   struct yy_channelsvf *yy_channelother ;
   int *yy_channelstops ;
};
#line 1 "/home/wslee/benchmarks/clif-0.93/ch-parser.h"
union __anonunion_YY_channelSTYPE_6 {
   int myint ;
   double mydouble ;
   char *mystring ;
};
#line 1 "/home/wslee/benchmarks/clif-0.93/ch-parser.h"
typedef union __anonunion_YY_channelSTYPE_6 YY_channelSTYPE;
#line 490 "channel.l"
struct yy_channelwork {
   unsigned char verify ;
   unsigned char advance ;
};
#line 85 "/home/wslee/benchmarks/clif-0.93/global.h"
struct remote_has_tab;
#line 102
struct remote_tab;
#line 71 "/home/wslee/benchmarks/clif-0.93/type.h"
enum global_type {
    INTEGERS = 1280,
    UINTEGERS = 1281,
    LINTEGERS = 1282,
    LUINTEGERS = 1283,
    SINTEGERS = 1284,
    SUINTEGERS = 1285,
    DOUBS = 1286,
    LDOUBS = 1287,
    FLTS = 1288,
    CHRS = 1289,
    SCHRS = 1290,
    UCHRS = 1291,
    INTEGERAR = 1536,
    DOUBAR = 1537,
    FLTAR = 1538,
    CHRAR = 1539,
    LAST_AND_UNUSED_GLOBAL_TYPE = 1540
} ;
#line 158 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct remote_tab {
   char *name ;
   void (*adr)(char ** ) ;
   struct remote_tab *next ;
};
#line 171 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct remote_has_tab {
   char *name ;
   int offset ;
   struct remote_has_tab *next ;
};
#line 41 "/home/wslee/benchmarks/clif-0.93/intrinsic.h"
struct INTR {
   char *name ;
   void (*adr)(char ** ) ;
};
#line 44 "/home/wslee/benchmarks/clif-0.93/symbols.c"
struct string {
   char *str ;
   int len ;
   struct string *next ;
};
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 46 "/home/wslee/benchmarks/clif-0.93/allocx.c"
union align {
   long l ;
   char *p ;
   double d ;
   int (*f)(void) ;
};
#line 54 "/home/wslee/benchmarks/clif-0.93/allocx.c"
struct pool_chunk {
   struct pool_chunk *next ;
   char *position ;
   char *limit ;
};
#line 61 "/home/wslee/benchmarks/clif-0.93/allocx.c"
union header {
   struct pool_chunk p ;
   union align a ;
};
#line 107 "/home/wslee/benchmarks/clif-0.93/global.h"
struct return1;
#line 131
union fix;
#line 12 "/home/wslee/benchmarks/clif-0.93/control.h"
struct cont1;
#line 12
struct break1;
#line 12 "/home/wslee/benchmarks/clif-0.93/control.h"
struct __anonstruct_WHILE1_23 {
   int major ;
   char *jmp ;
   char *jz ;
   struct cont1 *cnext ;
   struct break1 *bnext ;
};
#line 12 "/home/wslee/benchmarks/clif-0.93/control.h"
typedef struct __anonstruct_WHILE1_23 WHILE1;
#line 21 "/home/wslee/benchmarks/clif-0.93/control.h"
struct __anonstruct_FOR1_24 {
   int major ;
   char *jn ;
   char *jmp2 ;
   char *jmp3 ;
   struct break1 *bnext ;
   struct cont1 *cnext ;
};
#line 21 "/home/wslee/benchmarks/clif-0.93/control.h"
typedef struct __anonstruct_FOR1_24 FOR1;
#line 35 "/home/wslee/benchmarks/clif-0.93/control.h"
struct break1 {
   char *adr ;
   struct break1 *next ;
};
#line 41 "/home/wslee/benchmarks/clif-0.93/control.h"
struct cont1 {
   char *adr ;
   struct cont1 *next ;
};
#line 47 "/home/wslee/benchmarks/clif-0.93/control.h"
struct __anonstruct_IF1_25 {
   int major ;
   char *jz ;
   char *jmp ;
};
#line 47 "/home/wslee/benchmarks/clif-0.93/control.h"
typedef struct __anonstruct_IF1_25 IF1;
#line 54 "/home/wslee/benchmarks/clif-0.93/control.h"
struct default_usage {
   int line_number ;
   int def_flag ;
   char *adr ;
};
#line 65
struct list_const1;
#line 65 "/home/wslee/benchmarks/clif-0.93/control.h"
struct __anonstruct_SWITCH1_26 {
   int major ;
   char *jz ;
   char *jmp ;
   struct default_usage def_use ;
   struct break1 *bnext ;
   struct list_const1 *next ;
};
#line 65 "/home/wslee/benchmarks/clif-0.93/control.h"
typedef struct __anonstruct_SWITCH1_26 SWITCH1;
#line 75 "/home/wslee/benchmarks/clif-0.93/control.h"
struct list_const1 {
   int line_number ;
   int constant ;
   struct list_const1 *next ;
};
#line 88 "/home/wslee/benchmarks/clif-0.93/control.h"
union fix {
   WHILE1 while1 ;
   FOR1 for1 ;
   IF1 if1 ;
   SWITCH1 switch1 ;
};
#line 48 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct range {
   int lower ;
   int upper ;
};
#line 146 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct return1 {
   char *adr ;
   struct return1 *next ;
};
#line 35 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_0_ma {
   int major ;
};
#line 43 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_0_mi {
   int major ;
   int minor ;
};
#line 52 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_ma {
   int major ;
   char *adr ;
};
#line 68 "/home/wslee/benchmarks/clif-0.93/config.h"
union __anonunion_pointer_size_23 {
   int *a ;
   long *b ;
   unsigned long *c ;
   short *d ;
   unsigned short *e ;
   char *f ;
   signed char *g ;
   unsigned char *h ;
   double *i ;
   long double *j ;
   float *k ;
   void (*l)() ;
};
#line 68 "/home/wslee/benchmarks/clif-0.93/config.h"
typedef union __anonunion_pointer_size_23 pointer_size;
#line 81 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_ui {
   int major ;
   int minor ;
   unsigned int num ;
};
#line 91 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_li {
   int major ;
   int minor ;
   long num ;
};
#line 101 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_lui {
   int major ;
   int minor ;
   unsigned long num ;
};
#line 111 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_si {
   int major ;
   int minor ;
   short num ;
};
#line 121 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_sui {
   int major ;
   int minor ;
   unsigned short num ;
};
#line 161 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_ic {
   int major ;
   int minor ;
   char num ;
};
#line 171 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_isc {
   int major ;
   int minor ;
   signed char num ;
};
#line 181 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_iuc {
   int major ;
   int minor ;
   unsigned char num ;
};
#line 73 "/home/wslee/benchmarks/clif-0.93/global.h"
struct CONTEXT;
#line 30 "/home/wslee/benchmarks/clif-0.93/store_cont.h"
struct CONTEXT {
   char *bp ;
   char *frame ;
   char *kodp ;
   char *kodp1 ;
   char *kodp2 ;
   char *kodp3 ;
   char *kodp4 ;
   char *pc ;
   char *stack ;
   char *tmp ;
   char *tmph ;
   void *state ;
   struct CONTEXT *previous ;
};
#line 32 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct tab {
   char *name ;
   int def ;
   int count ;
   int use_line_number ;
   int l_value_flag ;
   int declaration_line ;
   struct tab *next ;
};
#line 120 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct ident_tab_header {
   int scope_level ;
   int pi_loc ;
   int offset ;
   char *file_scope ;
   struct ident_tab_header *previous_level ;
   struct ident_tab_loc *all ;
   struct tab *hastab_loc ;
   struct ident_tab_loc *table ;
};
#line 183 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct goto_adr {
   char *adr ;
   int line_number ;
   struct goto_adr *gnext ;
};
#line 192 "/home/wslee/benchmarks/clif-0.93/struct.h"
struct goto_tab {
   char *name ;
   char *label_adr ;
   int line_number ;
   struct goto_adr *gnext ;
   struct goto_tab *next ;
};
#line 99 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
struct yy_rs__buffer_state;
#line 99 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
typedef struct yy_rs__buffer_state *YY_rs__BUFFER_STATE;
#line 141 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
typedef unsigned int yy_rs__size_t;
#line 144 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
struct yy_rs__buffer_state {
   FILE *yy_rs__input_rs__file ;
   char *yy_rs__ch_buf ;
   char *yy_rs__buf_pos ;
   yy_rs__size_t yy_rs__buf_size ;
   int yy_rs__n_chars ;
   int yy_rs__is_our_buffer ;
   int yy_rs__is_interactive ;
   int yy_rs__at_bol ;
   int yy_rs__fill_buffer ;
   int yy_rs__buffer_status ;
};
#line 264 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
typedef unsigned char YY_rs__CHAR;
#line 266 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
typedef int yy_rs__state_type;
#line 1 "/home/wslee/benchmarks/clif-0.93/rs-parser.h"
union __anonunion_YY_rs_STYPE_6 {
   int myy_rs_int ;
   char *myy_rs_string ;
};
#line 1 "/home/wslee/benchmarks/clif-0.93/rs-parser.h"
typedef union __anonunion_YY_rs_STYPE_6 YY_rs_STYPE;
#line 10 "/home/wslee/benchmarks/clif-0.93/keyword.c"
struct el_mc {
   char *name ;
   int kval ;
};
#line 323 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef int wchar_t;
#line 43 "lex.yy.c"
typedef short flex_int16_t;
#line 44 "lex.yy.c"
typedef int flex_int32_t;
#line 139
struct yy_buffer_state;
#line 139 "lex.yy.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 175 "lex.yy.c"
typedef unsigned int yy_size_t;
#line 180 "lex.yy.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 326 "lex.yy.c"
typedef unsigned char YY_CHAR;
#line 330 "lex.yy.c"
typedef int yy_state_type;
#line 1 "/home/wslee/benchmarks/clif-0.93/token.h"
union __anonunion_YYSTYPE_24 {
   int myint ;
   unsigned int myuint ;
   long mylint ;
   unsigned long myluint ;
   double mydouble ;
   long double myldouble ;
   float myfloat ;
   char *mystring ;
   wchar_t *mywstring ;
   char mychar ;
};
#line 1 "/home/wslee/benchmarks/clif-0.93/token.h"
typedef union __anonunion_YYSTYPE_24 YYSTYPE;
#line 131 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_id {
   int major ;
   int minor ;
   double num ;
};
#line 141 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_ild {
   int major ;
   int minor ;
   long double num ;
};
#line 151 "/home/wslee/benchmarks/clif-0.93/instr.h"
struct OPERAND_1_if {
   int major ;
   int minor ;
   float num ;
};
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 125 "/home/wslee/benchmarks/clif-0.93/global.h"
int handler ;
#line 126
int virtual_machine_suspended ;
#line 127
int clif_interrupt_level ;
#line 139
extern void error_message(int   , ...) ;
#line 142
void interrupt_service_sync(void) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 82 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 43 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
int handler  =    0;
#line 44 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
int handle_fd  ;
#line 45 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
struct termio term  ;
#line 45 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
struct termio term_initial  ;
#line 47 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
void (*interrupt_handler)(int  )  ;
#line 48
void interrupt_service(int signo ) ;
#line 49
void interrupt_register(void) ;
#line 50
void term_restore(void) ;
#line 52
void fatal_handler(int signo ) ;
#line 53
void fatal_handler_register(void) ;
#line 54
jmp_buf jmpbuf ;
#line 55
int error_count ;
#line 60 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
void interrupt_service(int signo ) 
{ 


  {
#line 67
  if (clif_interrupt_level > 0) {
#line 78
    handler = 1;
  } else
#line 67
  if (! virtual_machine_suspended) {
#line 78
    handler = 1;
  }
#line 80
  return;
}
}
#line 97
extern int ( /* missing proto */  sigset)() ;
#line 87 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
void interrupt_register(void) 
{ 


  {
  {
#line 90
  interrupt_handler = & interrupt_service;
#line 91
  handle_fd = fileno(stdin);
#line 92
  ioctl(handle_fd, 21509UL, & term);
#line 93
  term_initial = term;
#line 94
  term.c_cc[0] = (unsigned char)20;
#line 95
  term.c_cc[5] = (unsigned char)18;
#line 96
  ioctl(handle_fd, 21510UL, & term);
#line 97
  sigset(2, interrupt_handler);
  }
#line 98
  return;
}
}
#line 103 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
void interrupt_service_sync(void) 
{ 


  {
#line 106
  handler = 1;
#line 107
  return;
}
}
#line 112 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
void term_restore(void) 
{ 


  {
  {
#line 115
  ioctl(handle_fd, 21510UL, & term_initial);
  }
#line 116
  return;
}
}
#line 118 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
void fatal_handler(int signo ) 
{ 


  {
#line 122
  if (signo != 8) {
#line 122
    if (signo != 11) {
#line 123
      return;
    }
  }
#line 124
  if (error_count) {
    {
#line 125
    longjmp((struct __jmp_buf_tag *)(jmpbuf), 1);
    }
  }
  {
#line 126
  sigset(signo, (void (*)(int  ))0);
  }
#line 127
  return;
}
}
#line 129 "/home/wslee/benchmarks/clif-0.93/sig-svr4.c"
void fatal_handler_register(void) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 132
  tmp___0 = sigset(8, & fatal_handler);
  }
#line 132
  if (tmp___0 < 0) {
    {
#line 133
    error_message(4004);
    }
  }
  {
#line 134
  tmp___1 = sigset(11, & fatal_handler);
  }
#line 134
  if (tmp___1 < 0) {
    {
#line 135
    error_message(4004);
    }
  }
#line 136
  return;
}
}
#line 39 "/home/wslee/benchmarks/clif-0.93/allocx.h"
char *allocate(unsigned int n , unsigned int a ) ;
#line 42
void init_zero(char *p , unsigned int n ) ;
#line 65 "/home/wslee/benchmarks/clif-0.93/flags.h"
int no_compile_only ;
#line 72
int call_by_value ;
#line 75
int call_by_reference ;
#line 70 "/home/wslee/benchmarks/clif-0.93/global.h"
char *proc_name_text[256] ;
#line 74
int proc ;
#line 81
struct internal_type *type_com[256] ;
#line 99
struct internal_type *typeh[256] ;
#line 100
int type_spec_count ;
#line 110
char *kodp ;
#line 118
char *kodp4 ;
#line 122
char *last_instr ;
#line 122
char *current_instr ;
#line 130
int set ;
#line 137
char *text ;
#line 49 "/home/wslee/benchmarks/clif-0.93/tables.h"
enum intern_arit_class type_ac[256] ;
#line 62
struct ident_tab *point(char *var_name ) ;
#line 65
struct ident_tab_loc *point_loc(char *var_name ) ;
#line 65 "/home/wslee/benchmarks/clif-0.93/comp_maint.h"
int add_to_ident_list(void) ;
#line 75
int scope_level ;
#line 81
void array_subscript(struct internal_type *pom ) ;
#line 21 "/home/wslee/benchmarks/clif-0.93/pso.h"
void lookup_tables(char *var_name , struct var_s *variable___0 ) ;
#line 22
void typedef_copy(struct internal_type *type ) ;
#line 23
int set_memory_size(enum intern_arit_class arit_class ) ;
#line 44 "/home/wslee/benchmarks/clif-0.93/pso.c"
void lookup_tables(char *var_name , struct var_s *variable___0 ) 
{ 
  struct ident_tab_loc *loc_var ;
  struct ident_tab *var ;
  int tmp___0 ;

  {
  {
#line 50
  loc_var = point_loc(var_name);
  }
#line 50
  if ((unsigned long )((void *)0) == (unsigned long )loc_var) {
    {
#line 53
    var = point(var_name);
    }
#line 54
    if ((unsigned long )((void *)0) == (unsigned long )var) {
#line 55
      no_compile_only = 0;
    }
#line 56
    if (1029U == (unsigned int )(var->type)->attribute.function_class) {
#line 56
      goto _L;
    } else
#line 56
    if (1030U == (unsigned int )(var->type)->attribute.function_class) {
      _L: /* CIL Label */ 
      {
#line 56
      tmp___0 = add_to_ident_list();
      }
#line 56
      if (-1 == tmp___0) {
#line 59
        no_compile_only = 0;
      }
    }
#line 60
    set ++;
#line 60
    (variable___0 + set)->adr = var->adr;
#line 61
    (variable___0 + set)->name = var_name;
#line 62
    (variable___0 + set)->offset = 0;
#line 63
    type_com[set] = var->type;
  } else {
#line 69
    if ((unsigned long )((void *)0) != (unsigned long )loc_var->adr) {
#line 71
      (variable___0 + set)->offset = 0;
#line 72
      (variable___0 + set)->adr = loc_var->adr;
#line 73
      (variable___0 + set)->name = var_name;
    } else {
#line 79
      (variable___0 + set)->offset += loc_var->offset;
#line 80
      (variable___0 + set)->adr = (char *)((void *)0);
#line 81
      (variable___0 + set)->name = var_name;
    }
#line 83
    type_com[set] = loc_var->type;
  }
#line 85
  if ((unsigned long )((void *)0) == (unsigned long )(type_com[set])->output) {
#line 86
    type_ac[set] = (type_com[set])->attribute.arit_class;
  } else
#line 87
  if (2048U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 90
    type_ac[set] = ((type_com[set])->output)->attribute.arit_class;
#line 92
    proc ++;
#line 92
    proc_name_text[proc] = text;
  } else
#line 87
  if (2049U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 90
    type_ac[set] = ((type_com[set])->output)->attribute.arit_class;
#line 92
    proc ++;
#line 92
    proc_name_text[proc] = text;
  } else
#line 94
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 96
    type_ac[set] = ((type_com[set])->output)->attribute.arit_class;
#line 98
    array_subscript((type_com[set])->input);
    }
  } else
#line 100
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 101
    type_ac[set] = (enum intern_arit_class )24;
  }
#line 102
  kodp4 = kodp;
#line 103
  if (0 < (variable___0 + set)->offset) {
#line 105
    if (call_by_value) {
#line 107
      if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 109
        ((struct OPERAND_1_i *)kodp)->major = 33;
#line 109
        ((struct OPERAND_1_i *)kodp)->num = (variable___0 + set)->offset;
#line 109
        ((struct OPERAND_1_i *)kodp)->minor = 2;
#line 109
        kodp += sizeof(struct OPERAND_1_i );
      } else {
#line 113
        ((struct OPERAND_1_i *)kodp)->major = 33;
#line 113
        ((struct OPERAND_1_i *)kodp)->num = (variable___0 + set)->offset;
#line 113
        ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 113
        kodp += sizeof(struct OPERAND_1_i );
      }
    } else
#line 116
    if (call_by_reference) {
#line 118
      ((struct OPERAND_1_i *)kodp)->major = 33;
#line 118
      ((struct OPERAND_1_i *)kodp)->num = (variable___0 + set)->offset;
#line 118
      ((struct OPERAND_1_i *)kodp)->minor = 2;
#line 118
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 120
    last_instr = current_instr;
#line 120
    current_instr = kodp;
  } else
#line 122
  if (0 > (variable___0 + set)->offset) {
#line 124
    ((struct OPERAND_1_i *)kodp)->major = 33;
#line 124
    ((struct OPERAND_1_i *)kodp)->num = (variable___0 + set)->offset;
#line 124
    ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 124
    kodp += sizeof(struct OPERAND_1_i );
#line 124
    last_instr = current_instr;
#line 124
    current_instr = kodp;
  } else
#line 126
  if (! (2048U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 126
    if (! (2049U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 129
      ((struct OPERAND_1_mi *)kodp)->major = 33;
#line 129
      ((struct OPERAND_1_mi *)kodp)->adr = (variable___0 + set)->adr;
#line 129
      ((struct OPERAND_1_mi *)kodp)->minor = 0;
#line 129
      kodp += sizeof(struct OPERAND_1_mi );
#line 129
      last_instr = current_instr;
#line 129
      current_instr = kodp;
    }
  }
#line 131
  return;
}
}
#line 137 "/home/wslee/benchmarks/clif-0.93/pso.c"
void typedef_copy(struct internal_type *type ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 141
  if (scope_level > 0) {
#line 141
    tmp___0 = 1;
  } else {
#line 141
    tmp___0 = 0;
  }
  {
#line 141
  tmp___1 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___0);
#line 141
  typeh[type_spec_count] = (struct internal_type *)tmp___1;
#line 144
  init_zero((char *)typeh[type_spec_count], (unsigned int )sizeof(struct internal_type ));
#line 146
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1024;
#line 148
  (typeh[type_spec_count])->attribute.type_qualifier = (enum type_qual )4098;
#line 150
  (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )0;
#line 152
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8192;
#line 154
  (typeh[type_spec_count])->output = type;
  }
#line 155
  return;
}
}
#line 159 "/home/wslee/benchmarks/clif-0.93/pso.c"
int set_memory_size(enum intern_arit_class arit_class ) 
{ 


  {
  {
#line 166
  if ((unsigned int )arit_class == 136U) {
#line 166
    goto case_136;
  }
#line 166
  if ((unsigned int )arit_class == 8U) {
#line 166
    goto case_136;
  }
#line 168
  if ((unsigned int )arit_class == 264U) {
#line 168
    goto case_264;
  }
#line 171
  if ((unsigned int )arit_class == 152U) {
#line 171
    goto case_152;
  }
#line 171
  if ((unsigned int )arit_class == 24U) {
#line 171
    goto case_152;
  }
#line 174
  if ((unsigned int )arit_class == 140U) {
#line 174
    goto case_140;
  }
#line 174
  if ((unsigned int )arit_class == 12U) {
#line 174
    goto case_140;
  }
#line 176
  if ((unsigned int )arit_class == 280U) {
#line 176
    goto case_280;
  }
#line 178
  if ((unsigned int )arit_class == 268U) {
#line 178
    goto case_268;
  }
#line 180
  if ((unsigned int )arit_class == 64U) {
#line 180
    goto case_64;
  }
#line 182
  if ((unsigned int )arit_class == 80U) {
#line 182
    goto case_80;
  }
#line 184
  if ((unsigned int )arit_class == 32U) {
#line 184
    goto case_32;
  }
#line 186
  if ((unsigned int )arit_class == 2U) {
#line 186
    goto case_2;
  }
#line 189
  if ((unsigned int )arit_class == 130U) {
#line 189
    goto case_130;
  }
#line 191
  if ((unsigned int )arit_class == 258U) {
#line 191
    goto case_258;
  }
#line 194
  goto switch_default;
  case_136: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 167
  return ((int )sizeof(int ));
  case_264: /* CIL Label */ 
#line 169
  return ((int )sizeof(unsigned int ));
  case_152: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 172
  return ((int )sizeof(long ));
  case_140: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 175
  return ((int )sizeof(short ));
  case_280: /* CIL Label */ 
#line 177
  return ((int )sizeof(unsigned long ));
  case_268: /* CIL Label */ 
#line 179
  return ((int )sizeof(unsigned short ));
  case_64: /* CIL Label */ 
#line 181
  return ((int )sizeof(double ));
  case_80: /* CIL Label */ 
#line 183
  return ((int )sizeof(long double ));
  case_32: /* CIL Label */ 
#line 185
  return ((int )sizeof(float ));
  case_2: /* CIL Label */ 
#line 188
  return ((int )sizeof(char ));
  case_130: /* CIL Label */ 
#line 190
  return ((int )sizeof(signed char ));
  case_258: /* CIL Label */ 
#line 192
  return ((int )sizeof(unsigned char ));
  switch_default: /* CIL Label */ 
#line 195
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 197
  return (0);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 40 "/home/wslee/benchmarks/clif-0.93/global.h"
int s ;
#line 44 "/home/wslee/benchmarks/clif-0.93/allocx.h"
void *mallocx(unsigned int size ) ;
#line 37 "/home/wslee/benchmarks/clif-0.93/printfx.h"
int fprintfx(FILE *stream  , ...) ;
#line 23 "/home/wslee/benchmarks/clif-0.93/dbg-out.h"
void dbg_create(void) ;
#line 24
void dbg_print(char *pc___0 ) ;
#line 26 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
FILEATTR spf[100] ;
#line 27
int getcx(FILE *input___1 ) ;
#line 40 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
struct dbg_files *dbg_info  ;
#line 47
static void store_pos(DBGLIST **pos ) ;
#line 49 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
static void store_pos(DBGLIST **pos ) 
{ 
  register DBGLIST *walk ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 55
  if ((unsigned long )*pos == (unsigned long )((void *)0)) {
    {
#line 59
    tmp___0 = mallocx((unsigned int )sizeof(DBGLIST ));
#line 59
    *pos = (DBGLIST *)tmp___0;
#line 60
    (*pos)->line_counter = spf[s].line_counter;
#line 61
    (*pos)->codp = kodp;
#line 62
    (*pos)->next = (DBGLIST *)((void *)0);
    }
#line 63
    return;
  }
#line 68
  walk = *pos;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )walk->next != (unsigned long )((void *)0))) {
#line 69
      goto while_break;
    }
#line 70
    walk = walk->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  tmp___1 = mallocx((unsigned int )sizeof(DBGLIST ));
#line 71
  walk->next = (DBGLIST *)tmp___1;
#line 72
  walk = walk->next;
#line 73
  walk->line_counter = spf[s].line_counter;
#line 74
  walk->codp = kodp;
#line 75
  walk->next = (DBGLIST *)((void *)0);
  }
#line 76
  return;
}
}
#line 79 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
void dbg_create(void) 
{ 
  DBGFILES *walk ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 84
  if ((unsigned long )dbg_info == (unsigned long )((void *)0)) {
    {
#line 88
    tmp___0 = mallocx((unsigned int )sizeof(DBGFILES ));
#line 88
    dbg_info = (struct dbg_files *)tmp___0;
#line 89
    dbg_info->filename = spf[s].name;
#line 90
    dbg_info->info = (DBGLIST *)((void *)0);
#line 91
    dbg_info->next = (DBGFILES *)((void *)0);
#line 92
    store_pos(& dbg_info->info);
    }
#line 93
    return;
  }
#line 97
  walk = dbg_info;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((unsigned long )walk->filename != (unsigned long )spf[s].name)) {
#line 98
      goto while_break;
    }
#line 100
    if ((unsigned long )walk->next == (unsigned long )((void *)0)) {
      {
#line 102
      tmp___1 = mallocx((unsigned int )sizeof(DBGFILES ));
#line 102
      walk->next = (DBGFILES *)tmp___1;
#line 103
      walk = walk->next;
#line 104
      walk->filename = spf[s].name;
#line 105
      walk->info = (DBGLIST *)((void *)0);
#line 106
      walk->next = (DBGFILES *)((void *)0);
      }
    } else {
#line 109
      walk = walk->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 111
  store_pos(& walk->info);
  }
#line 112
  return;
}
}
#line 118 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
static DBGLIST *get_pos(DBGLIST *info___0 , char *pc___0 ) 
{ 


  {
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! ((unsigned long )info___0->next != (unsigned long )((void *)0))) {
#line 123
      goto while_break;
    }
#line 125
    if ((unsigned long )info___0->codp <= (unsigned long )pc___0) {
#line 125
      if ((unsigned long )(info___0->next)->codp > (unsigned long )pc___0) {
#line 125
        if ((unsigned long )info___0->codp != (unsigned long )(info___0->next)->codp) {
#line 127
          return (info___0);
        }
      }
    }
#line 128
    info___0 = info___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return ((DBGLIST *)((void *)0));
}
}
#line 144 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
static int line_printed  ;
#line 134 "/home/wslee/benchmarks/clif-0.93/dbg-out.c"
void dbg_print(char *pc___0 ) 
{ 
  DBGFILES *walk ;
  DBGLIST *info___0 ;
  FILE *fp ;
  char buf[1024] ;
  int i ;
  int line_counter___0 ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 138
  walk = dbg_info;
#line 139
  info___0 = (DBGLIST *)((void *)0);
#line 142
  line_counter___0 = 1;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! ((unsigned long )walk != (unsigned long )((void *)0))) {
#line 148
      goto while_break;
    }
    {
#line 150
    info___0 = get_pos(walk->info, pc___0);
    }
#line 151
    if ((unsigned long )info___0 != (unsigned long )((void *)0)) {
#line 152
      goto while_break;
    }
#line 148
    walk = walk->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  if ((unsigned long )walk == (unsigned long )((void *)0)) {
#line 156
    return;
  }
#line 158
  if (info___0->line_counter == line_printed) {
#line 159
    return;
  }
  {
#line 160
  fp = fopen((char const   */* __restrict  */)walk->filename, (char const   */* __restrict  */)"r");
  }
#line 161
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 162
    return;
  }
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! (line_counter___0 < info___0->line_counter)) {
#line 164
      goto while_break___0;
    }
    {
#line 166
    tmp___0 = getcx(fp);
    }
#line 166
    if (tmp___0 == 10) {
#line 167
      line_counter___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 170
  i = 0;
  {
#line 170
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 170
    if (! (i < 1024)) {
#line 170
      goto while_break___1;
    }
    {
#line 172
    tmp___1 = getcx(fp);
#line 172
    buf[i] = (char )tmp___1;
    }
#line 173
    if ((int )buf[i] == 10) {
#line 175
      buf[i] = (char )'\000';
#line 176
      goto while_break___1;
    }
#line 170
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 180
  if (i == 1024) {
#line 181
    return;
  }
  {
#line 183
  fprintfx(stderr, "%d: %s\n", info___0->line_counter, buf);
#line 184
  line_printed = info___0->line_counter;
#line 185
  fclose(fp);
  }
#line 186
  return;
}
}
#line 38 "/home/wslee/benchmarks/clif-0.93/s-conv.c"
int yyleng ;
#line 415 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 146 "/home/wslee/benchmarks/clif-0.93/comp_maint.h"
void gen_cast_needed(void) ;
#line 10 "/home/wslee/benchmarks/clif-0.93/s-conv.h"
int num_args[256]  ;
#line 12 "/home/wslee/benchmarks/clif-0.93/s-conv.h"
int args[256]  ;
#line 17 "/home/wslee/benchmarks/clif-0.93/s-conv.h"
FORMAT_ARGS format_args[256][256]  ;
#line 19
void compare_format_args(struct internal_type *type1 , struct internal_type *type2 ,
                         enum intern_arit_class type ) ;
#line 26 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_yes ;
#line 29
int warning_comment ;
#line 58 "/home/wslee/benchmarks/clif-0.93/s-conv.c"
static void alloc_type(struct internal_type **type ) ;
#line 59
static void store_arg_type(int proc___0 , int num ) ;
#line 231
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 61 "/home/wslee/benchmarks/clif-0.93/s-conv.c"
void s_conv(char *yytext___0 ) 
{ 
  int i ;
  int j ;
  int help___0 ;
  int wide_string ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  struct internal_type *array ;
  struct internal_type *error_type ;
  struct internal_type *pointer ;
  struct internal_type *pointer___0 ;
  struct internal_type *array___0 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  register int k ;
  char *buf ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 65
  wide_string = 0;
#line 67
  if ((int )*(yytext___0 + 0) == 76) {
#line 69
    yytext___0 ++;
#line 70
    wide_string = 1;
  }
#line 73
  if (proc) {
#line 74
    num_args[proc] = args[proc] + 1;
  }
#line 76
  i = 1;
#line 76
  j = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < yyleng - 1)) {
#line 76
      goto while_break;
    }
#line 78
    if (92 == (int )*(yytext___0 + i)) {
      {
#line 82
      if ((int )*(yytext___0 + (i + 1)) == 97) {
#line 82
        goto case_97;
      }
#line 84
      if ((int )*(yytext___0 + (i + 1)) == 98) {
#line 84
        goto case_98;
      }
#line 86
      if ((int )*(yytext___0 + (i + 1)) == 102) {
#line 86
        goto case_102;
      }
#line 88
      if ((int )*(yytext___0 + (i + 1)) == 110) {
#line 88
        goto case_110;
      }
#line 90
      if ((int )*(yytext___0 + (i + 1)) == 114) {
#line 90
        goto case_114;
      }
#line 92
      if ((int )*(yytext___0 + (i + 1)) == 116) {
#line 92
        goto case_116;
      }
#line 94
      if ((int )*(yytext___0 + (i + 1)) == 118) {
#line 94
        goto case_118;
      }
#line 99
      if ((int )*(yytext___0 + (i + 1)) == 92) {
#line 99
        goto case_92;
      }
#line 101
      if ((int )*(yytext___0 + (i + 1)) == 10) {
#line 101
        goto case_10;
      }
#line 109
      if ((int )*(yytext___0 + (i + 1)) == 120) {
#line 109
        goto case_120;
      }
#line 112
      if ((int )*(yytext___0 + (i + 1)) == 39) {
#line 112
        goto case_39;
      }
#line 116
      if ((int )*(yytext___0 + (i + 1)) == 34) {
#line 116
        goto case_34;
      }
#line 80
      goto switch_break;
      case_97: /* CIL Label */ 
#line 82
      *(yytext___0 + j) = (char )'\a';
#line 82
      i ++;
#line 83
      goto switch_break;
      case_98: /* CIL Label */ 
#line 84
      *(yytext___0 + j) = (char )'\b';
#line 84
      i ++;
#line 85
      goto switch_break;
      case_102: /* CIL Label */ 
#line 86
      *(yytext___0 + j) = (char )'\f';
#line 86
      i ++;
#line 87
      goto switch_break;
      case_110: /* CIL Label */ 
#line 88
      *(yytext___0 + j) = (char )'\n';
#line 88
      i ++;
#line 89
      goto switch_break;
      case_114: /* CIL Label */ 
#line 90
      *(yytext___0 + j) = (char )'\r';
#line 90
      i ++;
#line 91
      goto switch_break;
      case_116: /* CIL Label */ 
#line 92
      *(yytext___0 + j) = (char )'\t';
#line 92
      i ++;
#line 93
      goto switch_break;
      case_118: /* CIL Label */ 
#line 94
      *(yytext___0 + j) = (char )'\v';
#line 94
      i ++;
#line 95
      goto switch_break;
      case_92: /* CIL Label */ 
#line 99
      *(yytext___0 + j) = (char )'\\';
#line 99
      i ++;
#line 100
      goto switch_break;
      case_10: /* CIL Label */ 
#line 102
      (spf[s].line_counter) ++;
#line 103
      *(yytext___0 + j) = (char )' ';
#line 103
      i ++;
#line 108
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 109
      sscanf((char const   */* __restrict  */)(yytext___0 + (i + 2)), (char const   */* __restrict  */)"%2x",
             & help___0);
#line 109
      i += 3;
#line 110
      *(yytext___0 + j) = (char )help___0;
      }
#line 111
      goto switch_break;
      case_39: /* CIL Label */ 
#line 113
      *(yytext___0 + j) = (char )'\'';
#line 114
      i ++;
#line 115
      goto switch_break;
      case_34: /* CIL Label */ 
#line 117
      *(yytext___0 + j) = (char )'\"';
#line 118
      i ++;
#line 119
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 122
    if (37 == (int )*(yytext___0 + i)) {
#line 122
      if (37 != (int )*(yytext___0 + (i + 1))) {
#line 124
        (num_args[proc]) ++;
#line 125
        if (! warning_yes) {
#line 125
          if (! warning_comment) {
#line 127
            *(yytext___0 + j) = *(yytext___0 + i);
#line 128
            goto __Cont;
          }
        }
#line 130
        tmp___0 = j;
#line 130
        j ++;
#line 130
        tmp___1 = i;
#line 130
        i ++;
#line 130
        *(yytext___0 + tmp___0) = *(yytext___0 + tmp___1);
#line 132
        if (wide_string == 1) {
          {
#line 134
          error_message(6018);
#line 135
          wide_string ++;
          }
        }
        {
#line 138
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 140
          if (45 == (int )*(yytext___0 + i)) {
#line 140
            goto _L___8;
          } else
#line 140
          if (43 == (int )*(yytext___0 + i)) {
#line 140
            goto _L___8;
          } else
#line 140
          if (35 == (int )*(yytext___0 + i)) {
            _L___8: /* CIL Label */ 
#line 143
            tmp___2 = j;
#line 143
            j ++;
#line 143
            tmp___3 = i;
#line 143
            i ++;
#line 143
            *(yytext___0 + tmp___2) = *(yytext___0 + tmp___3);
#line 144
            goto while_continue___0;
          } else
#line 146
          if (32 == (int )*(yytext___0 + i)) {
#line 148
            if (32 == (int )*(yytext___0 + (j - 1))) {
              {
#line 149
              error_message(6020);
              }
            } else {
#line 151
              tmp___4 = j;
#line 151
              j ++;
#line 151
              tmp___5 = i;
#line 151
              i ++;
#line 151
              *(yytext___0 + tmp___4) = *(yytext___0 + tmp___5);
            }
#line 152
            goto while_continue___0;
          } else
#line 154
          if (48 <= (int )*(yytext___0 + i)) {
#line 154
            if (57 >= (int )*(yytext___0 + i)) {
#line 156
              tmp___6 = j;
#line 156
              j ++;
#line 156
              tmp___7 = i;
#line 156
              i ++;
#line 156
              *(yytext___0 + tmp___6) = *(yytext___0 + tmp___7);
#line 157
              goto while_continue___0;
            } else {
#line 154
              goto _L___7;
            }
          } else
          _L___7: /* CIL Label */ 
#line 159
          if (46 == (int )*(yytext___0 + i)) {
#line 161
            tmp___8 = j;
#line 161
            j ++;
#line 161
            tmp___9 = i;
#line 161
            i ++;
#line 161
            *(yytext___0 + tmp___8) = *(yytext___0 + tmp___9);
#line 162
            goto while_continue___0;
          } else
#line 164
          if (42 == (int )*(yytext___0 + i)) {
#line 166
            tmp___10 = j;
#line 166
            j ++;
#line 166
            tmp___11 = i;
#line 166
            i ++;
#line 166
            *(yytext___0 + tmp___10) = *(yytext___0 + tmp___11);
#line 167
            goto while_continue___0;
          } else
#line 169
          if (104 == (int )*(yytext___0 + i)) {
#line 171
            tmp___12 = j;
#line 171
            j ++;
#line 171
            tmp___13 = i;
#line 171
            i ++;
#line 171
            *(yytext___0 + tmp___12) = *(yytext___0 + tmp___13);
#line 172
            goto while_continue___0;
          } else
#line 174
          if (108 == (int )*(yytext___0 + i)) {
#line 174
            goto _L___6;
          } else
#line 174
          if (76 == (int )*(yytext___0 + i)) {
            _L___6: /* CIL Label */ 
#line 176
            tmp___14 = j;
#line 176
            j ++;
#line 176
            tmp___15 = i;
#line 176
            i ++;
#line 176
            *(yytext___0 + tmp___14) = *(yytext___0 + tmp___15);
#line 177
            goto while_continue___0;
          } else
#line 179
          if (0 == (int )*(yytext___0 + i)) {
#line 181
            if (37 == (int )*(yytext___0 + (j - 1))) {
              {
#line 182
              error_message(6018);
              }
            } else {
              {
#line 184
              error_message(6021);
              }
            }
#line 185
            goto while_break___0;
          } else
#line 187
          if (100 == (int )*(yytext___0 + i)) {
#line 187
            goto _L___5;
          } else
#line 187
          if (105 == (int )*(yytext___0 + i)) {
            _L___5: /* CIL Label */ 
            {
#line 189
            type_spec_count ++;
#line 189
            alloc_type(& typeh[type_spec_count]);
#line 190
            (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
            }
#line 192
            if (108 == (int )*(yytext___0 + (j - 1))) {
#line 193
              (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 16U);
            } else
#line 195
            if (76 == (int )*(yytext___0 + (j - 1))) {
              {
#line 196
              error_message(6015, num_args[proc]);
              }
            } else
#line 197
            if (104 == (int )*(yytext___0 + (j - 1))) {
#line 198
              (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 4U);
            }
            {
#line 200
            store_arg_type(proc, num_args[proc]);
#line 201
            *(yytext___0 + j) = *(yytext___0 + i);
            }
#line 202
            goto while_break___0;
          } else
#line 204
          if (111 == (int )*(yytext___0 + i)) {
#line 204
            goto _L___4;
          } else
#line 204
          if (117 == (int )*(yytext___0 + i)) {
#line 204
            goto _L___4;
          } else
#line 204
          if (120 == (int )*(yytext___0 + i)) {
#line 204
            goto _L___4;
          } else
#line 204
          if (88 == (int )*(yytext___0 + i)) {
            _L___4: /* CIL Label */ 
            {
#line 207
            type_spec_count ++;
#line 207
            alloc_type(& typeh[type_spec_count]);
#line 208
            (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
#line 210
            (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 256U);
            }
#line 212
            if (108 == (int )*(yytext___0 + (j - 1))) {
#line 213
              (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 16U);
            } else
#line 215
            if (76 == (int )*(yytext___0 + (j - 1))) {
              {
#line 216
              error_message(6016, num_args[proc]);
              }
            } else
#line 217
            if (104 == (int )*(yytext___0 + (j - 1))) {
#line 218
              (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 4U);
            }
            {
#line 220
            store_arg_type(proc, num_args[proc]);
#line 221
            *(yytext___0 + j) = *(yytext___0 + i);
            }
#line 222
            goto while_break___0;
          } else
#line 224
          if (102 == (int )*(yytext___0 + i)) {
            {
#line 226
            type_spec_count ++;
#line 226
            alloc_type(& typeh[type_spec_count]);
#line 227
            (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )32;
            }
#line 228
            if (108 == (int )*(yytext___0 + (j - 1))) {
#line 228
              goto _L___1;
            } else
#line 228
            if (104 == (int )*(yytext___0 + (j - 1))) {
              _L___1: /* CIL Label */ 
              {
#line 228
              tmp___18 = strcmp(proc_name_text[proc], "printf");
              }
#line 228
              if (tmp___18) {
                {
#line 228
                tmp___19 = strcmp(proc_name_text[proc], "fprintf");
                }
#line 228
                if (tmp___19) {
#line 228
                  goto _L___0;
                } else {
                  {
#line 230
                  error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
                  }
                }
              } else {
                {
#line 230
                error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
                }
              }
            } else
            _L___0: /* CIL Label */ 
#line 231
            if (108 == (int )*(yytext___0 + (j - 1))) {
              {
#line 231
              tmp___16 = strcmp(proc_name_text[proc], "scanf");
              }
#line 231
              if (tmp___16) {
                {
#line 231
                tmp___17 = strcmp(proc_name_text[proc], "fscanf");
                }
#line 231
                if (tmp___17) {
#line 231
                  goto _L;
                } else {
#line 233
                  (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )64;
                }
              } else {
#line 233
                (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )64;
              }
            } else
            _L: /* CIL Label */ 
#line 235
            if (76 == (int )*(yytext___0 + (j - 1))) {
#line 236
              (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 16U);
            }
            {
#line 238
            store_arg_type(proc, num_args[proc]);
#line 239
            *(yytext___0 + j) = *(yytext___0 + i);
            }
#line 240
            goto while_break___0;
          } else
#line 242
          if (101 == (int )*(yytext___0 + i)) {
#line 242
            goto _L___3;
          } else
#line 242
          if (69 == (int )*(yytext___0 + i)) {
#line 242
            goto _L___3;
          } else
#line 242
          if (103 == (int )*(yytext___0 + i)) {
#line 242
            goto _L___3;
          } else
#line 242
          if (71 == (int )*(yytext___0 + i)) {
            _L___3: /* CIL Label */ 
            {
#line 245
            type_spec_count ++;
#line 245
            alloc_type(& typeh[type_spec_count]);
#line 246
            (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )64;
            }
#line 247
            if (108 == (int )*(yytext___0 + (j - 1))) {
              {
#line 248
              error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
              }
            } else
#line 247
            if (104 == (int )*(yytext___0 + (j - 1))) {
              {
#line 248
              error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
              }
            } else
#line 249
            if (76 == (int )*(yytext___0 + (j - 1))) {
#line 250
              (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 16U);
            }
            {
#line 252
            store_arg_type(proc, num_args[proc]);
#line 253
            *(yytext___0 + j) = *(yytext___0 + i);
            }
#line 254
            goto while_break___0;
          } else
#line 256
          if (99 == (int )*(yytext___0 + i)) {
            {
#line 258
            type_spec_count ++;
#line 258
            alloc_type(& typeh[type_spec_count]);
#line 259
            (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )2;
#line 261
            (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 256U);
            }
#line 263
            if (108 == (int )*(yytext___0 + (j - 1))) {
              {
#line 264
              error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
              }
            } else
#line 263
            if (76 == (int )*(yytext___0 + (j - 1))) {
              {
#line 264
              error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
              }
            } else
#line 265
            if (104 == (int )*(yytext___0 + (j - 1))) {
#line 266
              (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 4U);
            }
            {
#line 268
            store_arg_type(proc, num_args[proc]);
#line 269
            *(yytext___0 + j) = *(yytext___0 + i);
            }
#line 270
            goto while_break___0;
          } else
#line 272
          if (115 == (int )*(yytext___0 + i)) {
            {
#line 275
            alloc_type(& array);
#line 276
            array->attribute.arit_class = (enum intern_arit_class )2;
#line 277
            array->attribute.arit_class = (enum intern_arit_class )((unsigned int )array->attribute.arit_class + 256U);
            }
#line 278
            if (108 == (int )*(yytext___0 + (j - 1))) {
              {
#line 281
              alloc_type(& error_type);
#line 282
              error_type->attribute.arit_class = (enum intern_arit_class )8;
#line 283
              error_message(6017, error_type, num_args[proc]);
              }
            } else
#line 286
            if (76 == (int )*(yytext___0 + (j - 1))) {
              {
#line 287
              error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
              }
            } else
#line 288
            if (104 == (int )*(yytext___0 + (j - 1))) {
#line 289
              array->attribute.arit_class = (enum intern_arit_class )((unsigned int )array->attribute.arit_class + 4U);
            }
            {
#line 290
            type_spec_count ++;
#line 290
            alloc_type(& typeh[type_spec_count]);
#line 291
            (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1025;
#line 293
            (typeh[type_spec_count])->output = array;
#line 294
            store_arg_type(proc, num_args[proc]);
#line 295
            *(yytext___0 + j) = *(yytext___0 + i);
            }
#line 296
            goto while_break___0;
          } else
#line 298
          if (112 == (int )*(yytext___0 + i)) {
            {
#line 301
            alloc_type(& pointer);
#line 302
            pointer->attribute.arit_class = (enum intern_arit_class )1;
            }
#line 303
            if (108 == (int )*(yytext___0 + (j - 1))) {
              {
#line 305
              error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
              }
            } else
#line 303
            if (76 == (int )*(yytext___0 + (j - 1))) {
              {
#line 305
              error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
              }
            } else
#line 303
            if (104 == (int )*(yytext___0 + (j - 1))) {
              {
#line 305
              error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
              }
            }
            {
#line 306
            type_spec_count ++;
#line 306
            alloc_type(& typeh[type_spec_count]);
#line 307
            (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1028;
#line 309
            (typeh[type_spec_count])->output = pointer;
#line 310
            store_arg_type(proc, num_args[proc]);
#line 311
            *(yytext___0 + j) = *(yytext___0 + i);
            }
#line 312
            goto while_break___0;
          } else
#line 314
          if (110 == (int )*(yytext___0 + i)) {
            {
#line 317
            alloc_type(& pointer___0);
#line 318
            pointer___0->attribute.arit_class = (enum intern_arit_class )8;
            }
#line 319
            if (108 == (int )*(yytext___0 + (j - 1))) {
#line 320
              pointer___0->attribute.arit_class = (enum intern_arit_class )((unsigned int )pointer___0->attribute.arit_class + 16U);
            } else
#line 321
            if (76 == (int )*(yytext___0 + (j - 1))) {
              {
#line 322
              error_message(6014, (int )*(yytext___0 + (j - 1)), (int )*(yytext___0 + i));
              }
            } else
#line 323
            if (104 == (int )*(yytext___0 + (j - 1))) {
#line 324
              pointer___0->attribute.arit_class = (enum intern_arit_class )((unsigned int )pointer___0->attribute.arit_class + 4U);
            }
            {
#line 325
            type_spec_count ++;
#line 325
            alloc_type(& typeh[type_spec_count]);
#line 326
            (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1028;
#line 328
            (typeh[type_spec_count])->output = pointer___0;
#line 329
            store_arg_type(proc, num_args[proc]);
#line 330
            *(yytext___0 + j) = *(yytext___0 + i);
            }
#line 331
            goto while_break___0;
          } else
#line 333
          if (91 == (int )*(yytext___0 + i)) {
            {
#line 333
            tmp___30 = strcmp(proc_name_text[proc], "scanf");
            }
#line 333
            if (tmp___30) {
              {
#line 333
              tmp___31 = strcmp(proc_name_text[proc], "fscanf");
              }
#line 333
              if (tmp___31) {
                {
#line 360
                error_message(6019);
                }
#line 361
                goto while_break___0;
              } else {
                _L___2: /* CIL Label */ 
                {
#line 336
                alloc_type(& array___0);
#line 337
                array___0->attribute.arit_class = (enum intern_arit_class )2;
#line 338
                array___0->attribute.arit_class = (enum intern_arit_class )((unsigned int )array___0->attribute.arit_class + 256U);
#line 339
                tmp___20 = j;
#line 339
                j ++;
#line 339
                tmp___21 = i;
#line 339
                i ++;
#line 339
                *(yytext___0 + tmp___20) = *(yytext___0 + tmp___21);
                }
#line 340
                if (93 == (int )*(yytext___0 + i)) {
#line 341
                  tmp___22 = j;
#line 341
                  j ++;
#line 341
                  tmp___23 = i;
#line 341
                  i ++;
#line 341
                  *(yytext___0 + tmp___22) = *(yytext___0 + tmp___23);
                } else
#line 342
                if (94 == (int )*(yytext___0 + i)) {
#line 342
                  if (93 == (int )*(yytext___0 + (i + 1))) {
#line 345
                    tmp___24 = j;
#line 345
                    j ++;
#line 345
                    tmp___25 = i;
#line 345
                    i ++;
#line 345
                    *(yytext___0 + tmp___24) = *(yytext___0 + tmp___25);
#line 346
                    tmp___26 = j;
#line 346
                    j ++;
#line 346
                    tmp___27 = i;
#line 346
                    i ++;
#line 346
                    *(yytext___0 + tmp___26) = *(yytext___0 + tmp___27);
                  }
                }
                {
#line 348
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 348
                  if (93 != (int )*(yytext___0 + i)) {
#line 348
                    if (! (0 != (int )*(yytext___0 + i))) {
#line 348
                      goto while_break___1;
                    }
                  } else {
#line 348
                    goto while_break___1;
                  }
#line 349
                  tmp___28 = j;
#line 349
                  j ++;
#line 349
                  tmp___29 = i;
#line 349
                  i ++;
#line 349
                  *(yytext___0 + tmp___28) = *(yytext___0 + tmp___29);
                }
                while_break___1: /* CIL Label */ ;
                }
                {
#line 350
                type_spec_count ++;
#line 350
                alloc_type(& typeh[type_spec_count]);
#line 351
                (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1025;
#line 353
                (typeh[type_spec_count])->output = array___0;
#line 354
                store_arg_type(proc, num_args[proc]);
#line 355
                *(yytext___0 + j) = *(yytext___0 + i);
                }
#line 356
                goto while_break___0;
              }
            } else {
#line 333
              goto _L___2;
            }
          } else {
            {
#line 360
            error_message(6019);
            }
#line 361
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 122
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 365
    if (37 == (int )*(yytext___0 + i)) {
#line 365
      if (37 == (int )*(yytext___0 + (i + 1))) {
#line 367
        tmp___32 = j;
#line 367
        j ++;
#line 367
        tmp___33 = i;
#line 367
        i ++;
#line 367
        *(yytext___0 + tmp___32) = *(yytext___0 + tmp___33);
#line 368
        *(yytext___0 + j) = *(yytext___0 + i);
      } else {
#line 365
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 370
    if (63 == (int )*(yytext___0 + i)) {
#line 370
      if (63 == (int )*(yytext___0 + (i + 1))) {
        {
#line 372
        error_message(6032);
        }
        {
#line 376
        if ((int )*(yytext___0 + (i + 2)) == 61) {
#line 376
          goto case_61;
        }
#line 380
        if ((int )*(yytext___0 + (i + 2)) == 40) {
#line 380
          goto case_40;
        }
#line 384
        if ((int )*(yytext___0 + (i + 2)) == 47) {
#line 384
          goto case_47;
        }
#line 407
        if ((int )*(yytext___0 + (i + 2)) == 41) {
#line 407
          goto case_41;
        }
#line 411
        if ((int )*(yytext___0 + (i + 2)) == 39) {
#line 411
          goto case_39___0;
        }
#line 415
        if ((int )*(yytext___0 + (i + 2)) == 60) {
#line 415
          goto case_60;
        }
#line 419
        if ((int )*(yytext___0 + (i + 2)) == 33) {
#line 419
          goto case_33;
        }
#line 423
        if ((int )*(yytext___0 + (i + 2)) == 62) {
#line 423
          goto case_62;
        }
#line 427
        if ((int )*(yytext___0 + (i + 2)) == 45) {
#line 427
          goto case_45;
        }
#line 431
        goto switch_default;
        case_61: /* CIL Label */ 
#line 377
        *(yytext___0 + j) = (char )'#';
#line 378
        i += 2;
#line 379
        goto switch_break___0;
        case_40: /* CIL Label */ 
#line 381
        *(yytext___0 + j) = (char )'[';
#line 382
        i += 2;
#line 383
        goto switch_break___0;
        case_47: /* CIL Label */ 
#line 385
        *(yytext___0 + j) = (char )'\\';
#line 386
        i += 2;
#line 387
        if (0 != (int )*(yytext___0 + (i + 1))) {
#line 395
          i ++;
#line 395
          *(yytext___0 + (j + 1)) = *(yytext___0 + i);
#line 396
          k = j + 2;
#line 396
          i ++;
          {
#line 396
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 396
            if (! (0 != (int )*(yytext___0 + i))) {
#line 396
              goto while_break___2;
            }
#line 397
            *(yytext___0 + k) = *(yytext___0 + i);
#line 396
            k ++;
#line 396
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 399
          *(yytext___0 + k) = *(yytext___0 + i);
#line 402
          yyleng = k;
#line 403
          j --;
#line 404
          i = j;
        }
#line 406
        goto switch_break___0;
        case_41: /* CIL Label */ 
#line 408
        *(yytext___0 + j) = (char )']';
#line 409
        i += 2;
#line 410
        goto switch_break___0;
        case_39___0: /* CIL Label */ 
#line 412
        *(yytext___0 + j) = (char )'^';
#line 413
        i += 2;
#line 414
        goto switch_break___0;
        case_60: /* CIL Label */ 
#line 416
        *(yytext___0 + j) = (char )'{';
#line 417
        i += 2;
#line 418
        goto switch_break___0;
        case_33: /* CIL Label */ 
#line 420
        *(yytext___0 + j) = (char )'|';
#line 421
        i += 2;
#line 422
        goto switch_break___0;
        case_62: /* CIL Label */ 
#line 424
        *(yytext___0 + j) = (char )'}';
#line 425
        i += 2;
#line 426
        goto switch_break___0;
        case_45: /* CIL Label */ 
#line 428
        *(yytext___0 + j) = (char )'~';
#line 429
        i += 2;
#line 430
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 432
        *(yytext___0 + j) = *(yytext___0 + i);
        switch_break___0: /* CIL Label */ ;
        }
      } else {
#line 370
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 435
    if (34 == (int )*(yytext___0 + i)) {
#line 437
      buf = (char *)((void *)0);
      {
#line 439
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 439
        i ++;
#line 439
        if (! (34 != (int )*(yytext___0 + i))) {
#line 439
          goto while_break___3;
        }
#line 440
        if (76 == (int )*(yytext___0 + i)) {
#line 440
          if (34 == (int )*(yytext___0 + (i + 1))) {
#line 441
            wide_string ++;
          } else {
#line 440
            goto _L___9;
          }
        } else
        _L___9: /* CIL Label */ 
#line 442
        if (! (32 == (int )*(yytext___0 + i))) {
#line 442
          if (! (9 == (int )*(yytext___0 + i))) {
#line 442
            if (! (11 == (int )*(yytext___0 + i))) {
#line 442
              if (! (8 == (int )*(yytext___0 + i))) {
#line 442
                if (! (12 == (int )*(yytext___0 + i))) {
#line 446
                  if (10 == (int )*(yytext___0 + i)) {
#line 450
                    (spf[s].line_counter) ++;
                  } else
#line 446
                  if (13 == (int )*(yytext___0 + i)) {
#line 450
                    (spf[s].line_counter) ++;
                  } else
#line 452
                  if (0 == (int )*(yytext___0 + i)) {
#line 453
                    goto while_break___3;
                  } else {
#line 456
                    buf = yytext___0 + i;
#line 457
                    goto while_break___3;
                  }
                }
              }
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 460
      if (buf) {
        {
#line 462
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 462
          if (32 != (int )*(yytext___0 + i)) {
#line 462
            if (9 != (int )*(yytext___0 + i)) {
#line 462
              if (10 != (int )*(yytext___0 + i)) {
#line 462
                if (13 != (int )*(yytext___0 + i)) {
#line 462
                  if (12 != (int )*(yytext___0 + i)) {
#line 462
                    if (11 != (int )*(yytext___0 + i)) {
#line 462
                      if (0 != (int )*(yytext___0 + i)) {
#line 462
                        if (! (34 != (int )*(yytext___0 + i))) {
#line 462
                          goto while_break___4;
                        }
                      } else {
#line 462
                        goto while_break___4;
                      }
                    } else {
#line 462
                      goto while_break___4;
                    }
                  } else {
#line 462
                    goto while_break___4;
                  }
                } else {
#line 462
                  goto while_break___4;
                }
              } else {
#line 462
                goto while_break___4;
              }
            } else {
#line 462
              goto while_break___4;
            }
          } else {
#line 462
            goto while_break___4;
          }
#line 466
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 467
        *(yytext___0 + i) = (char )'\000';
#line 468
        error_message(1004, buf);
        }
      }
#line 470
      j --;
    } else {
#line 473
      *(yytext___0 + j) = *(yytext___0 + i);
    }
    __Cont: /* CIL Label */ 
#line 76
    i ++;
#line 76
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  if (proc) {
#line 476
    if (wide_string) {
      {
#line 477
      error_message(6023);
      }
    }
  }
#line 478
  *(yytext___0 + j) = (char )'\000';
#line 479
  return;
}
}
#line 482 "/home/wslee/benchmarks/clif-0.93/s-conv.c"
static void alloc_type(struct internal_type **type ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 486
  if (scope_level > 0) {
#line 486
    tmp___0 = 1;
  } else {
#line 486
    tmp___0 = 0;
  }
  {
#line 486
  tmp___1 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___0);
#line 486
  *type = (struct internal_type *)tmp___1;
#line 489
  init_zero((char *)*type, (unsigned int )sizeof(struct internal_type ));
#line 490
  (*type)->attribute.function_class = (enum intern_func_class )1024;
#line 491
  (*type)->attribute.type_qualifier = (enum type_qual )4098;
  }
#line 492
  return;
}
}
#line 496 "/home/wslee/benchmarks/clif-0.93/s-conv.c"
static void store_arg_type(int proc___0 , int num ) 
{ 
  int tmp___0 ;

  {
#line 500
  format_args[proc___0][num] = typeh[type_spec_count];
#line 501
  tmp___0 = type_spec_count;
#line 501
  type_spec_count --;
#line 501
  typeh[tmp___0] = (struct internal_type *)((void *)0);
#line 502
  return;
}
}
#line 506 "/home/wslee/benchmarks/clif-0.93/s-conv.c"
void compare_format_args(struct internal_type *type1 , struct internal_type *type2 ,
                         enum intern_arit_class type ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 511
  if ((unsigned long )((void *)0) == (unsigned long )type1) {
#line 511
    if ((unsigned long )((void *)0) == (unsigned long )type2) {
#line 512
      return;
    } else {
#line 511
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 513
  if ((unsigned long )((void *)0) == (unsigned long )type1) {
#line 513
    if ((unsigned long )((void *)0) != (unsigned long )type2) {
#line 515
      if (! (1025U == (unsigned int )type2->attribute.function_class)) {
        {
#line 516
        error_message(6022);
        }
      } else
#line 515
      if (! (2U & (unsigned int )(type2->output)->attribute.arit_class)) {
        {
#line 516
        error_message(6022);
        }
      }
#line 517
      return;
    } else {
#line 513
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 519
  if ((unsigned long )((void *)0) != (unsigned long )type1) {
#line 519
    if ((unsigned long )((void *)0) == (unsigned long )type2) {
      {
#line 521
      error_message(6021);
      }
#line 522
      return;
    }
  }
#line 525
  if (call_by_value) {
    {
#line 525
    tmp___0 = strcmp(proc_name_text[proc], "scanf");
    }
#line 525
    if (tmp___0) {
      {
#line 525
      tmp___1 = strcmp(proc_name_text[proc], "fscanf");
      }
#line 525
      if (! tmp___1) {
        _L___1: /* CIL Label */ 
#line 525
        if (1028U == (unsigned int )type2->attribute.function_class) {
#line 527
          type2 = type2->output;
#line 528
          type = type2->attribute.arit_class;
        }
      }
    } else {
#line 525
      goto _L___1;
    }
  }
#line 531
  if (1028U == (unsigned int )type1->attribute.function_class) {
#line 531
    if (1028U == (unsigned int )type2->attribute.function_class) {
#line 531
      goto _L___4;
    } else {
#line 531
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 531
  if (1028U == (unsigned int )type1->attribute.function_class) {
#line 531
    if (1025U == (unsigned int )type2->attribute.function_class) {
#line 531
      goto _L___4;
    } else {
#line 531
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 531
  if (1025U == (unsigned int )type1->attribute.function_class) {
#line 531
    if (1028U == (unsigned int )type2->attribute.function_class) {
#line 531
      goto _L___4;
    } else {
#line 531
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 531
  if (1025U == (unsigned int )type1->attribute.function_class) {
#line 531
    if (1025U == (unsigned int )type2->attribute.function_class) {
      _L___4: /* CIL Label */ 
#line 536
      if (! (1U & (unsigned int )(type1->output)->attribute.arit_class)) {
#line 536
        if (! ((unsigned int )(type1->output)->attribute.arit_class & (unsigned int )(type2->output)->attribute.arit_class)) {
#line 536
          if (2U & (unsigned int )(type1->output)->attribute.arit_class) {
#line 536
            if (8U & (unsigned int )(type2->output)->attribute.arit_class) {
#line 536
              if (8U & (unsigned int )(type1->output)->attribute.arit_class) {
#line 536
                if (2U & (unsigned int )(type2->output)->attribute.arit_class) {
                  {
#line 540
                  error_message(6017, type1, args[proc]);
                  }
                }
              }
            } else {
              {
#line 540
              error_message(6017, type1, args[proc]);
              }
            }
          } else {
            {
#line 540
            error_message(6017, type1, args[proc]);
            }
          }
        }
      }
    } else {
#line 531
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 542
  if (64U & (unsigned int )type1->attribute.arit_class) {
#line 542
    if ((unsigned int )type & 32U) {
      {
#line 544
      gen_cast_needed();
      }
    } else {
#line 542
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 546
  if (! ((unsigned int )type1->attribute.arit_class & (unsigned int )type)) {
#line 546
    if (8U & (unsigned int )type1->attribute.arit_class) {
#line 546
      if ((unsigned int )type & 2U) {
#line 546
        goto _L___2;
      } else {
        {
#line 548
        error_message(6017, type1, args[proc]);
        }
      }
    } else {
      {
#line 548
      error_message(6017, type1, args[proc]);
      }
    }
  } else
  _L___2: /* CIL Label */ 
#line 549
  if (! (1025U == (unsigned int )type1->attribute.function_class)) {
#line 549
    if (! (1028U == (unsigned int )type1->attribute.function_class)) {
#line 549
      if (1025U == (unsigned int )type2->attribute.function_class) {
        {
#line 551
        error_message(6031, type1, args[proc]);
        }
      } else
#line 549
      if (1028U == (unsigned int )type2->attribute.function_class) {
        {
#line 551
        error_message(6031, type1, args[proc]);
        }
      }
    }
  }
#line 552
  return;
}
}
#line 1410 "/usr/include/X11/Xlib.h"
extern XFontStruct *XQueryFont(Display * , XID  ) ;
#line 1494
extern Display *XOpenDisplay(char const   * ) ;
#line 1591
extern Font XLoadFont(Display * , char const   * ) ;
#line 1595
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1647
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1666
extern char **XListFonts(Display * , char const   * , int  , int * ) ;
#line 1779
extern Window XDefaultRootWindow(Display * ) ;
#line 1792
extern GC XDefaultGC(Display * , int  ) ;
#line 2165
extern int XClearWindow(Display * , Window  ) ;
#line 2237
extern int XDefaultScreen(Display * ) ;
#line 2253
extern int XDestroyWindow(Display * , Window  ) ;
#line 2281
extern int XDisplayHeight(Display * , int  ) ;
#line 2302
extern int XDisplayWidth(Display * , int  ) ;
#line 2352
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2371
extern int XDrawPoint(Display * , Drawable  , GC  , int  , int  ) ;
#line 2434
extern int XDrawText(Display * , Drawable  , GC  , int  , int  , XTextItem * , int  ) ;
#line 2816
extern int XMapWindow(Display * , Window  ) ;
#line 3139
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3231
extern int XSetFontPath(Display * , char ** , int  ) ;
#line 3309
extern int XSetState(Display * , GC  , unsigned long  , unsigned long  , int  , unsigned long  ) ;
#line 3405
extern int XStoreName(Display * , Window  , char const   * ) ;
#line 3419
extern int XSync(Display * , int  ) ;
#line 3544
extern int XWindowEvent(Display * , Window  , long  , XEvent * ) ;
#line 111 "/home/wslee/benchmarks/clif-0.93/channel_maint.h"
int channel_handle ;
#line 112
char window_name_init[30] ;
#line 113
char window_name_cur[30] ;
#line 114
char window_name_wr_init[30] ;
#line 115
char window_name_wr_cur[30] ;
#line 116 "/home/wslee/benchmarks/clif-0.93/channel_maint.h"
char window_name_tmp[5]  ;
#line 117 "/home/wslee/benchmarks/clif-0.93/channel_maint.h"
struct CHANNEL channel[100]  ;
#line 40 "/home/wslee/benchmarks/clif-0.93/allocx.h"
char *callocx(unsigned int n , unsigned int size ) ;
#line 154 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 182
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 40 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
int yy_channelparse(void) ;
#line 41
void init_ch(char *input_buffer ) ;
#line 44 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
int channel_handle  =    0;
#line 45 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
char window_name_init[30]  = 
#line 45
  {      (char )'c',      (char )'l',      (char )'i',      (char )'f', 
        (char )'_',      (char )'c',      (char )'h',      (char )'a', 
        (char )'n',      (char )'n',      (char )'e',      (char )'l', 
        (char )'_',      (char )'h',      (char )'a',      (char )'n', 
        (char )'d',      (char )'l',      (char )'e',      (char )'_', 
        (char )'\000'};
#line 46 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
char window_name_cur[30]  = 
#line 46
  {      (char )'c',      (char )'l',      (char )'i',      (char )'f', 
        (char )'_',      (char )'c',      (char )'h',      (char )'a', 
        (char )'n',      (char )'n',      (char )'e',      (char )'l', 
        (char )'_',      (char )'h',      (char )'a',      (char )'n', 
        (char )'d',      (char )'l',      (char )'e',      (char )'_', 
        (char )'\000'};
#line 47 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
char window_name_wr_init[30]  = 
#line 47
  {      (char )'c',      (char )'l',      (char )'i',      (char )'f', 
        (char )'_',      (char )'a',      (char )'l',      (char )'p', 
        (char )'h',      (char )'a',      (char )'_',      (char )'c', 
        (char )'h',      (char )'a',      (char )'n',      (char )'n', 
        (char )'e',      (char )'l',      (char )'_',      (char )'h', 
        (char )'a',      (char )'n',      (char )'d',      (char )'l', 
        (char )'e',      (char )'_',      (char )'\000'};
#line 48 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
char window_name_wr_cur[30]  = 
#line 48
  {      (char )'c',      (char )'l',      (char )'i',      (char )'f', 
        (char )'_',      (char )'a',      (char )'l',      (char )'p', 
        (char )'h',      (char )'a',      (char )'_',      (char )'c', 
        (char )'h',      (char )'a',      (char )'n',      (char )'n', 
        (char )'e',      (char )'l',      (char )'_',      (char )'h', 
        (char )'a',      (char )'n',      (char )'d',      (char )'l', 
        (char )'e',      (char )'_',      (char )'\000'};
#line 53 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
XEvent event  ;
#line 54 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
GC default_gc  ;
#line 54 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
GC set_gc_write  ;
#line 55 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
Display *disp  ;
#line 37 "/home/wslee/benchmarks/clif-0.93/graph.c"
static void d_move(int d_x , int d_y ) ;
#line 38
static void d_draw(int d_handle , int d_n , int d_x , int d_y ) ;
#line 39
static void d_point(int d_handle , int d_n , int d_x , int d_y ) ;
#line 41
static void window(int handle , int n , double x_left , double y_down , double x_right ,
                   double y_up ) ;
#line 42
static void move(int handle , int n , double x___0 , double y___0 ) ;
#line 43
static void draw(int handle , int n , double x___0 , double y___0 ) ;
#line 44
static void draw_point(int handle , int n , double x___0 , double y___0 ) ;
#line 56 "/home/wslee/benchmarks/clif-0.93/graph.c"
static void window(int handle , int n , double x_left , double y_down , double x_right ,
                   double y_up ) 
{ 
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 61
  tmp___0 = fabs(x_left - x_right);
#line 61
  (channel[handle].member + n)->ax = (double )(channel[handle].w_resolution[0] - 1) / tmp___0;
#line 63
  tmp___1 = fabs(y_down - y_up);
#line 63
  (channel[handle].member + n)->ay = (double )(channel[handle].w_resolution[1] - 1) / tmp___1;
  }
#line 65
  return;
}
}
#line 77 "/home/wslee/benchmarks/clif-0.93/graph.c"
static void move(int handle , int n , double x___0 , double y___0 ) 
{ 
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 82
  tmp___0 = floor((y___0 - (channel[handle].member + n)->lower) * (channel[handle].member + n)->ay);
#line 82
  tmp___1 = floor((x___0 - channel[handle].start_time) * (channel[handle].member + n)->ax);
#line 82
  d_move((int )tmp___1, (channel[handle].w_resolution[1] - 1) - (int )tmp___0);
  }
#line 87
  return;
}
}
#line 99 "/home/wslee/benchmarks/clif-0.93/graph.c"
static void draw(int handle , int n , double x___0 , double y___0 ) 
{ 
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 104
  tmp___0 = floor((y___0 - (channel[handle].member + n)->lower) * (channel[handle].member + n)->ay);
#line 104
  tmp___1 = floor((x___0 - channel[handle].start_time) * (channel[handle].member + n)->ax);
#line 104
  d_draw(handle, n, (int )tmp___1, (channel[handle].w_resolution[1] - 1) - (int )tmp___0);
  }
#line 110
  return;
}
}
#line 122 "/home/wslee/benchmarks/clif-0.93/graph.c"
static void draw_point(int handle , int n , double x___0 , double y___0 ) 
{ 
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 127
  tmp___0 = floor((y___0 - (channel[handle].member + n)->lower) * (channel[handle].member + n)->ay);
#line 127
  tmp___1 = floor((x___0 - channel[handle].start_time) * (channel[handle].member + n)->ax);
#line 127
  d_point(handle, n, (int )tmp___1, (channel[handle].w_resolution[1] - 1) - (int )tmp___0);
  }
#line 133
  return;
}
}
#line 28 "/home/wslee/benchmarks/clif-0.93/xwin.c"
int cur_x  ;
#line 28 "/home/wslee/benchmarks/clif-0.93/xwin.c"
int cur_y  ;
#line 30
static void d_flush(void) ;
#line 31
static void d_clear(int d_handle ) ;
#line 32
static void d_clear_text(int d_handle ) ;
#line 33
static void d_destroy_window(int d_handle ) ;
#line 34
static void d_destroy_window_write(int d_handle ) ;
#line 35
static void d_draw_text(int d_handle , int d_x , int d_y ) ;
#line 36
static void d_pause(int d_handle ) ;
#line 42 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_move(int d_x , int d_y ) 
{ 


  {
#line 46
  cur_x = d_x;
#line 47
  cur_y = d_y;
#line 48
  return;
}
}
#line 53 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_draw(int d_handle , int d_n , int d_x , int d_y ) 
{ 


  {
  {
#line 62
  XDrawLine(disp, channel[d_handle].mywin, (channel[d_handle].member + d_n)->set_gc,
            cur_x, cur_y, d_x, d_y);
  }
#line 65
  return;
}
}
#line 70 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_point(int d_handle , int d_n , int d_x , int d_y ) 
{ 


  {
  {
#line 78
  XDrawPoint(disp, channel[d_handle].mywin, (channel[d_handle].member + d_n)->set_gc,
             d_x, d_y);
  }
#line 80
  return;
}
}
#line 82 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_flush(void) 
{ 


  {
  {
#line 85
  XSync(disp, 1);
  }
#line 86
  return;
}
}
#line 91 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_clear(int d_handle ) 
{ 


  {
  {
#line 95
  XClearWindow(disp, channel[d_handle].mywin);
  }
#line 101
  return;
}
}
#line 106 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_clear_text(int d_handle ) 
{ 


  {
  {
#line 110
  XClearWindow(disp, channel[d_handle].mywin_write);
  }
#line 116
  return;
}
}
#line 121 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_destroy_window(int d_handle ) 
{ 


  {
  {
#line 125
  XDestroyWindow(disp, channel[d_handle].mywin);
#line 129
  XSync(disp, 1);
  }
#line 130
  return;
}
}
#line 135 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_destroy_window_write(int d_handle ) 
{ 


  {
  {
#line 139
  XDestroyWindow(disp, channel[d_handle].mywin_write);
#line 143
  XSync(disp, 1);
  }
#line 144
  return;
}
}
#line 149 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_draw_text(int d_handle , int d_x , int d_y ) 
{ 


  {
  {
#line 153
  XDrawText(disp, channel[d_handle].mywin_write, set_gc_write, d_x, d_y, & channel[d_handle].item,
            1);
  }
#line 159
  return;
}
}
#line 164 "/home/wslee/benchmarks/clif-0.93/xwin.c"
static void d_pause(int d_handle ) 
{ 


  {
  {
#line 171
  XSelectInput(disp, channel[d_handle].mywin, 1L);
#line 172
  XWindowEvent(disp, channel[d_handle].mywin, 1L, & event);
  }
#line 176
  return;
}
}
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 29 "/home/wslee/benchmarks/clif-0.93/wind.c"
XGCValues value  ;
#line 33 "/home/wslee/benchmarks/clif-0.93/wind.c"
Window root  ;
#line 35 "/home/wslee/benchmarks/clif-0.93/wind.c"
XWindowAttributes root_window_att  ;
#line 36 "/home/wslee/benchmarks/clif-0.93/wind.c"
XSetWindowAttributes mywin_att  ;
#line 40 "/home/wslee/benchmarks/clif-0.93/wind.c"
int screen  ;
#line 41 "/home/wslee/benchmarks/clif-0.93/wind.c"
int width  ;
#line 41 "/home/wslee/benchmarks/clif-0.93/wind.c"
int height  ;
#line 42 "/home/wslee/benchmarks/clif-0.93/wind.c"
int x  =    0;
#line 42 "/home/wslee/benchmarks/clif-0.93/wind.c"
int y  =    0;
#line 43 "/home/wslee/benchmarks/clif-0.93/wind.c"
unsigned int width_w  ;
#line 43 "/home/wslee/benchmarks/clif-0.93/wind.c"
unsigned int height_w  ;
#line 43 "/home/wslee/benchmarks/clif-0.93/wind.c"
unsigned int border  =    3U;
#line 44 "/home/wslee/benchmarks/clif-0.93/wind.c"
unsigned long bord  =    1UL;
#line 44 "/home/wslee/benchmarks/clif-0.93/wind.c"
unsigned long back  =    0UL;
#line 46
int wind(void) ;
#line 48 "/home/wslee/benchmarks/clif-0.93/wind.c"
int wind(void) 
{ 
  int cnt ;
  double tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 58
  disp = XOpenDisplay((char const   *)((void *)0));
  }
#line 58
  if ((unsigned long )disp == (unsigned long )((void *)0)) {
    {
#line 60
    printf((char const   */* __restrict  */)" XOpen fails \n");
    }
#line 61
    return (-1);
  }
  {
#line 68
  root = XDefaultRootWindow(disp);
#line 69
  screen = XDefaultScreen(disp);
#line 80
  width = XDisplayWidth(disp, screen);
#line 84
  height = XDisplayHeight(disp, screen);
#line 90
  default_gc = XDefaultGC(disp, screen);
#line 95
  XSetState(disp, default_gc, 0UL, 0UL, 3, 4294967295UL);
#line 102
  width_w = (unsigned int )channel[channel_handle].w_resolution[0];
#line 103
  height_w = (unsigned int )channel[channel_handle].w_resolution[1];
#line 110
  mywin_att.background_pixmap = (Pixmap )0L;
#line 111
  mywin_att.background_pixel = 0UL;
#line 112
  mywin_att.border_pixmap = (Pixmap )0L;
#line 113
  mywin_att.border_pixel = 1UL;
#line 114
  mywin_att.bit_gravity = 0;
#line 115
  mywin_att.win_gravity = 1;
#line 116
  mywin_att.backing_store = 2;
#line 117
  mywin_att.backing_planes = 4294967295UL;
#line 118
  mywin_att.backing_pixel = 0UL;
#line 119
  mywin_att.save_under = 1;
#line 120
  mywin_att.event_mask = ((((1L | (1L << 15)) | (1L << 2)) | (1L << 16)) | (1L << 19)) | (1L << 17);
#line 121
  mywin_att.do_not_propagate_mask = 0L;
#line 122
  mywin_att.override_redirect = 0;
#line 123
  mywin_att.colormap = (Colormap )0L;
#line 124
  mywin_att.cursor = (Cursor )0L;
#line 129
  channel[channel_handle].mywin = XCreateWindow(disp, root, x, y, width_w, height_w,
                                                border, 0, 1U, (Visual *)0L, (unsigned long )((((((1L << 1) | (1L << 10)) | (1L << 6)) | (1L << 11)) | (1L << 7)) | (1L << 12)),
                                                & mywin_att);
#line 149
  value.background = 0UL;
#line 150
  value.graphics_exposures = 1;
#line 155
  cnt = 0;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (cnt < channel[channel_handle].fields)) {
#line 155
      goto while_break;
    }
    {
#line 157
    value.foreground = (channel[channel_handle].member + cnt)->style;
#line 159
    (channel[channel_handle].member + cnt)->set_gc = XCreateGC(disp, channel[channel_handle].mywin,
                                                               (unsigned long )(((1L << 2) | (1L << 3)) | (1L << 16)),
                                                               & value);
    }
#line 163
    if (channel[channel_handle].d_time == (double )0) {
      {
#line 164
      window(channel_handle, cnt, channel[channel_handle].start_time, (channel[channel_handle].member + cnt)->lower,
             channel[channel_handle].start_time + channel[channel_handle].duration_time,
             (channel[channel_handle].member + cnt)->upper);
      }
    } else {
      {
#line 171
      tmp___0 = pow(channel[channel_handle].duration_time, 2.);
#line 171
      window(channel_handle, cnt, channel[channel_handle].start_time, (channel[channel_handle].member + cnt)->lower,
             2. * (channel[channel_handle].start_time + tmp___0), (channel[channel_handle].member + cnt)->upper);
      }
    }
#line 155
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  XClearWindow(disp, channel[channel_handle].mywin);
#line 198
  sprintf((char */* __restrict  */)(window_name_tmp), (char const   */* __restrict  */)"%d",
          channel_handle);
#line 199
  strcat((char */* __restrict  */)(window_name_cur), (char const   */* __restrict  */)(window_name_tmp));
#line 200
  XStoreName(disp, channel[channel_handle].mywin, (char const   *)(window_name_cur));
#line 201
  strcpy((char */* __restrict  */)(window_name_cur), (char const   */* __restrict  */)(window_name_init));
#line 208
  XMapWindow(disp, channel[channel_handle].mywin);
#line 216
  XWindowEvent(disp, channel[channel_handle].mywin, 1L << 15, & event);
  }
#line 245
  return (channel_handle);
}
}
#line 45 "/home/wslee/benchmarks/clif-0.93/wind_w.c"
char **list  ;
#line 46 "/home/wslee/benchmarks/clif-0.93/wind_w.c"
char *path  ;
#line 47 "/home/wslee/benchmarks/clif-0.93/wind_w.c"
int *act_cnt  ;
#line 49
int wind_w(void) ;
#line 51 "/home/wslee/benchmarks/clif-0.93/wind_w.c"
int wind_w(void) 
{ 
  char *tmp___0 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 58
  disp = XOpenDisplay((char const   *)((void *)0));
  }
#line 58
  if ((unsigned long )disp == (unsigned long )((void *)0)) {
    {
#line 60
    printf((char const   */* __restrict  */)" XOpen fails write\n");
    }
#line 61
    return (-1);
  }
  {
#line 68
  root = XDefaultRootWindow(disp);
#line 69
  screen = XDefaultScreen(disp);
#line 81
  width = XDisplayWidth(disp, screen);
#line 85
  height = XDisplayHeight(disp, screen);
#line 100
  width_w = 400U;
#line 101
  height_w = (unsigned int )((channel[channel_handle].fields / 5 + 1) * 15);
#line 108
  mywin_att.background_pixmap = (Pixmap )0L;
#line 109
  mywin_att.background_pixel = 0UL;
#line 110
  mywin_att.border_pixmap = (Pixmap )0L;
#line 111
  mywin_att.border_pixel = 1UL;
#line 112
  mywin_att.bit_gravity = 0;
#line 113
  mywin_att.win_gravity = 1;
#line 114
  mywin_att.backing_store = 2;
#line 115
  mywin_att.backing_planes = 4294967295UL;
#line 116
  mywin_att.backing_pixel = 0UL;
#line 117
  mywin_att.save_under = 1;
#line 118
  mywin_att.event_mask = ((((1L | (1L << 15)) | (1L << 2)) | (1L << 16)) | (1L << 19)) | (1L << 17);
#line 119
  mywin_att.do_not_propagate_mask = 0L;
#line 120
  mywin_att.override_redirect = 0;
#line 121
  mywin_att.colormap = (Colormap )0L;
#line 122
  mywin_att.cursor = (Cursor )0L;
#line 129
  channel[channel_handle].mywin_write = XCreateWindow(disp, root, x, y, width_w, height_w,
                                                      border, 0, 1U, (Visual *)0L,
                                                      (unsigned long )((((((1L << 1) | (1L << 10)) | (1L << 6)) | (1L << 11)) | (1L << 7)) | (1L << 12)),
                                                      & mywin_att);
#line 150
  value.background = 0UL;
#line 151
  value.graphics_exposures = 1;
#line 152
  value.foreground = 16777215UL;
#line 154
  set_gc_write = XCreateGC(disp, channel[channel_handle].mywin_write, (unsigned long )(((1L << 2) | (1L << 3)) | (1L << 16)),
                           & value);
#line 160
  XClearWindow(disp, channel[channel_handle].mywin_write);
#line 174
  sprintf((char */* __restrict  */)(window_name_tmp), (char const   */* __restrict  */)"%d",
          channel_handle);
#line 175
  strcat((char */* __restrict  */)(window_name_wr_cur), (char const   */* __restrict  */)(window_name_tmp));
#line 176
  XStoreName(disp, channel[channel_handle].mywin_write, (char const   *)(window_name_wr_cur));
#line 178
  strcpy((char */* __restrict  */)(window_name_wr_cur), (char const   */* __restrict  */)(window_name_wr_init));
#line 184
  XMapWindow(disp, channel[channel_handle].mywin_write);
#line 198
  channel[channel_handle].item.delta = 1;
#line 199
  channel[channel_handle].item.font = (Font )0L;
#line 208
  XSetFontPath(disp, & path, 0);
#line 213
  tmp___0 = callocx(1U, (unsigned int )sizeof(int ));
#line 213
  act_cnt = (int *)tmp___0;
  }
#line 213
  if ((unsigned long )act_cnt == (unsigned long )((void *)0)) {
    {
#line 215
    error_message(4002);
    }
#line 216
    return (-3);
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (*act_cnt == 0)) {
#line 218
      goto while_break;
    }
    {
#line 219
    list = XListFonts(disp, "*", 10, act_cnt);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  channel[channel_handle].item.font = XLoadFont(disp, (char const   *)*(list + 0));
#line 229
  channel[channel_handle].myfont = XQueryFont(disp, channel[channel_handle].item.font);
  }
#line 255
  return (0);
}
}
#line 67 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
void chwrite(char **a ) ;
#line 68
void chclose(char **a ) ;
#line 69
void chflush(void) ;
#line 70
static void append(struct LIST **z1 , struct LIST **z2 ) ;
#line 71
static int append_record(struct LIST **z2 , double x___0 ) ;
#line 72
static void redraw_dur_aut(int handle ) ;
#line 73
static void reset_start_aut(int handle , double x___0 ) ;
#line 74
static void free_list(struct RECORD **z3 ) ;
#line 75
static int fill_write(int handle ) ;
#line 76
int chopen(char **input_buffer ) ;
#line 82 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
void chwrite(char **a ) 
{ 
  int *handle ;
  double *x___0 ;
  int n ;
  int tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 90
  handle = (int *)*(a + 0);
#line 91
  x___0 = (double *)*(a + 1);
#line 93
  append_record(& channel[*handle].list_tmp, *x___0);
#line 98
  (channel[*handle].cnt) ++;
  }
#line 99
  if (channel[*handle].fields == channel[*handle].cnt) {
    {
#line 104
    channel[*handle].global_cnt += (double )1;
#line 105
    tmp___1 = pow(channel[*handle].duration_time + channel[*handle].d_time, 2.);
    }
#line 105
    if (channel[*handle].global_cnt > 2. * (channel[*handle].start_time + tmp___1)) {
#line 105
      if (channel[*handle].d_time > (double )0) {
        {
#line 116
        d_flush();
#line 117
        tmp___0 = strcmp((char const   *)channel[*handle].on_leave_w, "suspend");
        }
#line 117
        if (! tmp___0) {
          {
#line 118
          d_pause(*handle);
          }
        }
        {
#line 119
        d_clear(*handle);
#line 120
        redraw_dur_aut(*handle);
        }
      }
    }
#line 122
    if (channel[*handle].global_cnt > channel[*handle].start_time + channel[*handle].duration_time) {
#line 122
      if (channel[*handle].s_time > 0) {
        {
#line 131
        reset_start_aut(*handle, *x___0);
#line 132
        d_flush();
#line 133
        tmp___2 = strcmp((char const   *)channel[*handle].on_leave_w, "suspend");
        }
#line 133
        if (! tmp___2) {
          {
#line 134
          d_pause(*handle);
          }
        }
        {
#line 135
        d_clear(*handle);
        }
      }
    }
    {
#line 137
    tmp___3 = strcmp((char const   *)channel[*handle].type, "alpha");
    }
#line 137
    if (! tmp___3) {
      {
#line 142
      fill_write(*handle);
      }
    }
#line 143
    n = 0;
    {
#line 143
    while (1) {
      while_continue: /* CIL Label */ ;
#line 143
      if (! (n < channel[*handle].fields)) {
#line 143
        goto while_break;
      }
      {
#line 145
      tmp___4 = strcmp((char const   *)channel[*handle].print_format, "line");
      }
#line 145
      if (tmp___4) {
        {
#line 169
        draw_point(*handle, n, channel[*handle].global_cnt, *x___0);
        }
      } else
#line 150
      if (channel[*handle].global_cnt == (double )1) {
#line 152
        (channel[*handle].member + n)->x_cur = channel[*handle].global_cnt;
#line 154
        (channel[*handle].member + n)->y_cur = *x___0;
      } else {
        {
#line 158
        move(*handle, n, (channel[*handle].member + n)->x_cur, (channel[*handle].member + n)->y_cur);
#line 160
        draw(*handle, n, channel[*handle].global_cnt, *x___0);
#line 161
        (channel[*handle].member + n)->x_cur = channel[*handle].global_cnt;
#line 163
        (channel[*handle].member + n)->y_cur = *x___0;
        }
      }
#line 143
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 171
    append(& channel[*handle].list, & channel[*handle].list_tmp);
#line 179
    channel[*handle].cnt = 0;
    }
  }
#line 182
  return;
}
}
#line 187 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
void chclose(char **a ) 
{ 
  int *handle ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 193
  handle = (int *)*(a + 0);
#line 195
  d_destroy_window(*handle);
#line 196
  tmp___0 = strcmp((char const   *)channel[*handle].type, "alpha");
  }
#line 196
  if (! tmp___0) {
    {
#line 198
    d_destroy_window_write(*handle);
    }
  }
#line 199
  return;
}
}
#line 204 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
void chflush(void) 
{ 


  {
  {
#line 207
  d_flush();
  }
#line 208
  return;
}
}
#line 213 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
static void append(struct LIST **z1 , struct LIST **z2 ) 
{ 


  {
#line 217
  if ((unsigned long )(*z1)->tail == (unsigned long )((void *)0)) {
#line 219
    (*z1)->head = (*z2)->head;
#line 220
    (*z2)->head = (struct RECORD *)((void *)0);
#line 221
    (*z1)->tail = (*z2)->tail;
#line 222
    (*z2)->tail = (struct RECORD *)((void *)0);
  } else {
#line 226
    ((*z1)->tail)->next = (*z2)->head;
#line 227
    (*z2)->head = (struct RECORD *)((void *)0);
#line 228
    (*z1)->tail = (*z2)->tail;
#line 229
    (*z2)->tail = (struct RECORD *)((void *)0);
  }
#line 231
  return;
}
}
#line 236 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
static int append_record(struct LIST **z2 , double x___0 ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 241
  if ((unsigned long )(*z2)->tail == (unsigned long )((void *)0)) {
    {
#line 243
    tmp___0 = allocate((unsigned int )sizeof(struct RECORD ), 0U);
#line 243
    (*z2)->head = (struct RECORD *)tmp___0;
#line 245
    ((*z2)->head)->x = x___0;
#line 246
    ((*z2)->head)->next = (struct RECORD *)((void *)0);
#line 247
    (*z2)->tail = (*z2)->head;
    }
  } else {
    {
#line 251
    tmp___1 = allocate((unsigned int )sizeof(struct RECORD ), 0U);
#line 251
    ((*z2)->tail)->next = (struct RECORD *)tmp___1;
#line 253
    (((*z2)->tail)->next)->x = x___0;
#line 254
    (((*z2)->tail)->next)->next = (struct RECORD *)((void *)0);
#line 255
    (*z2)->tail = ((*z2)->tail)->next;
    }
  }
#line 257
  return (0);
}
}
#line 263 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
static void redraw_dur_aut(int handle ) 
{ 
  struct RECORD *scan ;
  double global_cnt ;
  int n ;
  double tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 271
  channel[handle].d_time += (double )1;
#line 272
  n = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (n < channel[handle].fields)) {
#line 272
      goto while_break;
    }
    {
#line 273
    tmp___0 = pow(channel[handle].duration_time + channel[handle].d_time, 2.);
#line 273
    window(handle, n, channel[handle].start_time, (channel[handle].member + n)->lower,
           2. * (channel[handle].start_time + tmp___0), (channel[handle].member + n)->upper);
#line 272
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  scan = (channel[handle].list)->head;
#line 285
  global_cnt = (double )0;
  {
#line 286
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 286
    if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 286
      goto while_break___0;
    }
#line 288
    global_cnt += (double )1;
#line 289
    n = 0;
    {
#line 289
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 289
      if (! (n < channel[handle].fields)) {
#line 289
        goto while_break___1;
      }
      {
#line 291
      tmp___1 = strcmp((char const   *)channel[handle].print_format, "line");
      }
#line 291
      if (tmp___1) {
        {
#line 308
        draw_point(handle, n, global_cnt, scan->x);
        }
      } else
#line 293
      if ((unsigned long )scan == (unsigned long )(channel[handle].list)->head) {
#line 295
        (channel[handle].member + n)->x_cur = global_cnt;
#line 296
        (channel[handle].member + n)->y_cur = scan->x;
      } else {
        {
#line 300
        move(handle, n, (channel[handle].member + n)->x_cur, (channel[handle].member + n)->y_cur);
#line 302
        draw(handle, n, global_cnt, scan->x);
#line 303
        (channel[handle].member + n)->x_cur = global_cnt;
#line 304
        (channel[handle].member + n)->y_cur = scan->x;
        }
      }
#line 310
      scan = scan->next;
#line 289
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 313
  return;
}
}
#line 318 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
static void reset_start_aut(int handle , double x___0 ) 
{ 
  struct RECORD *scan ;
  int n ;

  {
#line 326
  scan = (channel[handle].list)->head;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! ((unsigned long )((void *)0) != (unsigned long )scan->next)) {
#line 327
      goto while_break;
    }
    {
#line 329
    (channel[handle].list)->head = scan->next;
#line 330
    free_list(& scan);
#line 331
    scan = (channel[handle].list)->head;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  channel[handle].start_time += channel[handle].duration_time;
#line 336
  n = 0;
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 336
    if (! (n < channel[handle].fields)) {
#line 336
      goto while_break___0;
    }
    {
#line 337
    window(handle, n, channel[handle].start_time, (channel[handle].member + n)->lower,
           channel[handle].start_time + channel[handle].duration_time, (channel[handle].member + n)->upper);
#line 336
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 342
  n = 0;
  {
#line 342
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 342
    if (! (n < channel[handle].fields)) {
#line 342
      goto while_break___1;
    }
#line 344
    (channel[handle].member + n)->x_cur = channel[handle].global_cnt;
#line 345
    (channel[handle].member + n)->y_cur = scan->x;
#line 342
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 347
  return;
}
}
#line 349 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
static void free_list(struct RECORD **z3 ) 
{ 


  {
#line 356
  return;
}
}
#line 361 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
static int fill_write(int handle ) 
{ 
  int cnt ;
  char str___0[100] ;
  char str_tmp[100] ;
  struct RECORD *z3 ;
  int y___0 ;
  size_t tmp___0 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 369
  y___0 = 9;
#line 371
  z3 = (channel[handle].list_tmp)->head;
#line 372
  d_clear_text(handle);
  }
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! ((unsigned long )((void *)0) != (unsigned long )z3)) {
#line 373
      goto while_break;
    }
#line 375
    str___0[0] = (char )'\000';
#line 376
    cnt = 0;
    {
#line 376
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 376
      if (! (cnt < 5)) {
#line 376
        goto while_break___0;
      }
      {
#line 378
      sprintf((char */* __restrict  */)(str_tmp), (char const   */* __restrict  */)"%g",
              z3->x);
#line 379
      strcat((char */* __restrict  */)(str___0), (char const   */* __restrict  */)(str_tmp));
#line 380
      strcat((char */* __restrict  */)(str___0), (char const   */* __restrict  */)" ");
#line 381
      z3 = z3->next;
      }
#line 382
      if ((unsigned long )z3 == (unsigned long )((void *)0)) {
#line 383
        goto while_break___0;
      }
#line 376
      cnt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 386
    channel[handle].item.chars = str___0;
#line 387
    tmp___0 = strlen((char const   *)channel[handle].item.chars);
#line 387
    channel[handle].item.nchars = (int )tmp___0;
#line 390
    d_draw_text(handle, 0, y___0);
#line 391
    y___0 += 15;
#line 392
    channel[handle].item.chars = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return (0);
}
}
#line 412 "/home/wslee/benchmarks/clif-0.93/channel_maint.c"
int chopen(char **input_buffer ) 
{ 
  int handle ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 416
  handle = 0;
#line 417
  init_ch(*input_buffer);
#line 421
  tmp___0 = yy_channelparse();
  }
#line 421
  if (tmp___0 == -2) {
#line 422
    return (-2);
  }
  {
#line 424
  handle = wind();
#line 425
  tmp___1 = strcmp((char const   *)channel[channel_handle].type, "alpha");
  }
#line 425
  if (! tmp___1) {
    {
#line 425
    tmp___2 = wind_w();
    }
#line 425
    if (tmp___2 == -1) {
#line 430
      return (-1);
    }
  }
#line 432
  channel_handle ++;
#line 433
  return (handle);
}
}
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 21 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
int yy_channelback(int *p , int m ) ;
#line 22
int yy_channelinput_channel(void) ;
#line 23
int yy_channellook(void) ;
#line 24
void yy_channeloutput_channel(int c ) ;
#line 27
void yy_channelunput_channel(int c ) ;
#line 28
int yy_channellex(void) ;
#line 37
int yy_channelwrap(void) ;
#line 50
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 65 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
int yy_channelleng  ;
#line 66 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
char yy_channeltext[8192]  ;
#line 67 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
int yy_channelmorfg  ;
#line 68
char *yy_channelsptr ;
#line 68 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
char yy_channelsbuf[8192]  ;
#line 69 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
int yy_channeltchar  ;
#line 70 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
FILE *yy_channelin  ;
#line 70 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
FILE *yy_channelout  ;
#line 71
int yy_channellineno ;
#line 76 "/home/wslee/benchmarks/clif-0.93/ch-lex.c"
struct yy_channelsvf *yy_channelestate  ;
#line 77
struct yy_channelsvf yy_channelsvec[127] ;
#line 77
struct yy_channelsvf *yy_channelbgin ;
#line 23 "/home/wslee/benchmarks/clif-0.93/ch-parser.h"
YY_channelSTYPE yy_channellval ;
#line 37 "/home/wslee/benchmarks/clif-0.93/init_ch.c"
int input_channel(void) ;
#line 40 "/home/wslee/benchmarks/clif-0.93/init_ch.c"
int buf_cnt  ;
#line 41 "/home/wslee/benchmarks/clif-0.93/init_ch.c"
char *inp_buf  ;
#line 46 "/home/wslee/benchmarks/clif-0.93/init_ch.c"
int input_channel(void) 
{ 
  int tmp___0 ;

  {
#line 49
  if ((unsigned long )yy_channelsptr > (unsigned long )(yy_channelsbuf)) {
#line 49
    yy_channelsptr --;
#line 49
    yy_channeltchar = (int )*yy_channelsptr;
  } else {
#line 49
    tmp___0 = buf_cnt;
#line 49
    buf_cnt ++;
#line 49
    yy_channeltchar = (int )*(inp_buf + tmp___0);
  }
#line 50
  if (yy_channeltchar == 10) {
#line 51
    yy_channellineno ++;
  }
#line 52
  if (yy_channeltchar == 0) {
#line 53
    return (0);
  }
#line 54
  return (yy_channeltchar);
}
}
#line 60 "/home/wslee/benchmarks/clif-0.93/init_ch.c"
void init_ch(char *input_buffer ) 
{ 


  {
#line 64
  buf_cnt = 0;
#line 65
  inp_buf = input_buffer;
#line 66
  return;
}
}
#line 71 "/home/wslee/benchmarks/clif-0.93/init_ch.c"
int yy_channelwrap(void) 
{ 


  {
#line 74
  return (1);
}
}
#line 32 "channel.l"
char *string(char *s___0 ) ;
#line 36
int yy_channelprevious ;
#line 35 "channel.l"
int yy_channellex(void) 
{ 
  int nstr_channel ;
  int tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 42
  yy_channelout = stdout;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 43
    nstr_channel = yy_channellook();
    }
#line 43
    if (! (nstr_channel >= 0)) {
#line 43
      goto while_break;
    }
    {
#line 45
    if (nstr_channel == 0) {
#line 45
      goto case_0;
    }
#line 47
    if (nstr_channel == 1) {
#line 47
      goto case_1;
    }
#line 45
    if (nstr_channel == 2) {
#line 45
      goto case_2;
    }
#line 46
    if (nstr_channel == 3) {
#line 46
      goto case_3;
    }
#line 50
    if (nstr_channel == 4) {
#line 50
      goto case_4;
    }
#line 55
    if (nstr_channel == 5) {
#line 55
      goto case_5;
    }
#line 60
    if (nstr_channel == 6) {
#line 60
      goto case_6;
    }
#line 65
    if (nstr_channel == 7) {
#line 65
      goto case_7;
    }
#line 66
    if (nstr_channel == 8) {
#line 66
      goto case_8;
    }
#line 70
    if (nstr_channel == 9) {
#line 70
      goto case_9;
    }
#line 74
    if (nstr_channel == 10) {
#line 74
      goto case_10;
    }
#line 78
    if (nstr_channel == 11) {
#line 78
      goto case_11;
    }
#line 82
    if (nstr_channel == 12) {
#line 82
      goto case_12;
    }
#line 87
    if (nstr_channel == 13) {
#line 87
      goto case_13;
    }
#line 92
    if (nstr_channel == 14) {
#line 92
      goto case_14;
    }
#line 96
    if (nstr_channel == 15) {
#line 96
      goto case_15;
    }
#line 100
    if (nstr_channel == 16) {
#line 100
      goto case_16;
    }
#line 104
    if (nstr_channel == 17) {
#line 104
      goto case_17;
    }
#line 109
    if (nstr_channel == 18) {
#line 109
      goto case_18;
    }
#line 110
    if (nstr_channel == -1) {
#line 110
      goto case_neg_1;
    }
#line 112
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 46
    tmp___0 = yy_channelwrap();
    }
#line 46
    if (tmp___0) {
#line 46
      return (0);
    }
#line 46
    goto switch_break;
    case_1: /* CIL Label */ ;
#line 44
    goto switch_break;
    case_2: /* CIL Label */ ;
#line 45
    goto switch_break;
    case_3: /* CIL Label */ 
#line 45
    return (261);
#line 49
    goto switch_break;
    case_4: /* CIL Label */ 
#line 49
    return (262);
#line 54
    goto switch_break;
    case_5: /* CIL Label */ 
#line 54
    return (263);
#line 59
    goto switch_break;
    case_6: /* CIL Label */ 
#line 59
    return (264);
#line 64
    goto switch_break;
    case_7: /* CIL Label */ 
#line 64
    return (265);
#line 65
    goto switch_break;
    case_8: /* CIL Label */ 
#line 65
    return (266);
#line 69
    goto switch_break;
    case_9: /* CIL Label */ 
#line 69
    return (267);
#line 73
    goto switch_break;
    case_10: /* CIL Label */ 
#line 73
    return (268);
#line 77
    goto switch_break;
    case_11: /* CIL Label */ 
#line 77
    return (269);
#line 81
    goto switch_break;
    case_12: /* CIL Label */ 
#line 81
    return (270);
#line 86
    goto switch_break;
    case_13: /* CIL Label */ 
#line 86
    return (272);
#line 91
    goto switch_break;
    case_14: /* CIL Label */ 
#line 91
    return (271);
#line 95
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 95
    sscanf((char const   */* __restrict  */)(yy_channeltext), (char const   */* __restrict  */)"%d",
           & yy_channellval.myint);
    }
#line 95
    return (258);
#line 99
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 99
    sscanf((char const   */* __restrict  */)(yy_channeltext), (char const   */* __restrict  */)"%lf",
           & yy_channellval.mydouble);
    }
#line 99
    return (259);
#line 103
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 103
    yy_channellval.mystring = string(yy_channeltext);
    }
#line 104
    return (260);
#line 108
    goto switch_break;
    case_18: /* CIL Label */ 
#line 108
    return ((int )yy_channeltext[0]);
#line 109
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 111
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 113
    fprintf((FILE */* __restrict  */)yy_channelout, (char const   */* __restrict  */)"bad switch yy_channellook %d",
            nstr_channel);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return (0);
}
}
#line 116 "channel.l"
int yy_channelvstop[258]  = 
#line 116
  {      0,      18,      0,      1, 
        18,      0,      2,      0, 
        18,      0,      18,      0, 
        15,      17,      18,      0, 
        17,      18,      0,      17, 
        18,      0,      17,      18, 
        0,      17,      18,      0, 
        17,      18,      0,      17, 
        18,      0,      17,      18, 
        0,      17,      18,      0, 
        17,      18,      0,      17, 
        18,      0,      17,      18, 
        0,      15,      0,      16, 
        0,      16,      0,      15, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        16,      0,      16,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      16,      0,      16, 
        0,      16,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      4,      17,      0, 
        17,      0,      17,      0, 
        16,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        10,      17,      0,      17, 
        0,      17,      0,      12, 
        17,      0,      11,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      3, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      13,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      14,      17,      0, 
        6,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      17, 
        0,      17,      0,      7, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        17,      0,      17,      0, 
        5,      17,      0,      9, 
        17,      0,      8,      17, 
        0,      0};
#line 490 "channel.l"
struct yy_channelwork yy_channelcrank[461]  = 
#line 490
  {      {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)3}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)4}, 
        {(unsigned char)1, (unsigned char)5}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)6}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)7}, 
        {(unsigned char)6, (unsigned char)20}, 
        {(unsigned char)1, (unsigned char)8}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)6, (unsigned char)21}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)9}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)9}, 
        {(unsigned char)2, (unsigned char)7}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)21, (unsigned char)23}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)22, (unsigned char)39}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)10}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)7, (unsigned char)22}, 
        {(unsigned char)27, (unsigned char)44}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)11}, 
        {(unsigned char)21, (unsigned char)38}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)12}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)1, (unsigned char)13}, 
        {(unsigned char)2, (unsigned char)10}, 
        {(unsigned char)19, (unsigned char)37}, 
        {(unsigned char)47, (unsigned char)65}, 
        {(unsigned char)62, (unsigned char)76}, 
        {(unsigned char)64, (unsigned char)78}, 
        {(unsigned char)1, (unsigned char)14}, 
        {(unsigned char)22, (unsigned char)39}, 
        {(unsigned char)31, (unsigned char)48}, 
        {(unsigned char)44, (unsigned char)62}, 
        {(unsigned char)1, (unsigned char)15}, 
        {(unsigned char)13, (unsigned char)31}, 
        {(unsigned char)33, (unsigned char)50}, 
        {(unsigned char)1, (unsigned char)16}, 
        {(unsigned char)1, (unsigned char)17}, 
        {(unsigned char)1, (unsigned char)18}, 
        {(unsigned char)10, (unsigned char)27}, 
        {(unsigned char)1, (unsigned char)19}, 
        {(unsigned char)14, (unsigned char)32}, 
        {(unsigned char)2, (unsigned char)11}, 
        {(unsigned char)12, (unsigned char)29}, 
        {(unsigned char)15, (unsigned char)33}, 
        {(unsigned char)2, (unsigned char)12}, 
        {(unsigned char)11, (unsigned char)28}, 
        {(unsigned char)2, (unsigned char)13}, 
        {(unsigned char)16, (unsigned char)34}, 
        {(unsigned char)17, (unsigned char)35}, 
        {(unsigned char)18, (unsigned char)36}, 
        {(unsigned char)21, (unsigned char)38}, 
        {(unsigned char)28, (unsigned char)45}, 
        {(unsigned char)2, (unsigned char)14}, 
        {(unsigned char)29, (unsigned char)46}, 
        {(unsigned char)12, (unsigned char)30}, 
        {(unsigned char)30, (unsigned char)47}, 
        {(unsigned char)2, (unsigned char)15}, 
        {(unsigned char)32, (unsigned char)49}, 
        {(unsigned char)35, (unsigned char)53}, 
        {(unsigned char)2, (unsigned char)16}, 
        {(unsigned char)2, (unsigned char)17}, 
        {(unsigned char)2, (unsigned char)18}, 
        {(unsigned char)8, (unsigned char)23}, 
        {(unsigned char)2, (unsigned char)19}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)8, (unsigned char)24}, 
        {(unsigned char)36, (unsigned char)54}, 
        {(unsigned char)37, (unsigned char)55}, 
        {(unsigned char)40, (unsigned char)59}, 
        {(unsigned char)45, (unsigned char)63}, 
        {(unsigned char)46, (unsigned char)64}, 
        {(unsigned char)48, (unsigned char)66}, 
        {(unsigned char)49, (unsigned char)67}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)26}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)50, (unsigned char)68}, 
        {(unsigned char)40, (unsigned char)59}, 
        {(unsigned char)51, (unsigned char)69}, 
        {(unsigned char)52, (unsigned char)70}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)53, (unsigned char)71}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)26}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)8, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)54, (unsigned char)72}, 
        {(unsigned char)55, (unsigned char)73}, 
        {(unsigned char)63, (unsigned char)77}, 
        {(unsigned char)65, (unsigned char)79}, 
        {(unsigned char)66, (unsigned char)80}, 
        {(unsigned char)67, (unsigned char)81}, 
        {(unsigned char)68, (unsigned char)82}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)69, (unsigned char)83}, 
        {(unsigned char)70, (unsigned char)84}, 
        {(unsigned char)72, (unsigned char)85}, 
        {(unsigned char)73, (unsigned char)86}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)76, (unsigned char)87}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)9, (unsigned char)25}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)23, (unsigned char)40}, 
        {(unsigned char)34, (unsigned char)51}, 
        {(unsigned char)77, (unsigned char)88}, 
        {(unsigned char)78, (unsigned char)89}, 
        {(unsigned char)79, (unsigned char)90}, 
        {(unsigned char)80, (unsigned char)91}, 
        {(unsigned char)82, (unsigned char)92}, 
        {(unsigned char)83, (unsigned char)93}, 
        {(unsigned char)26, (unsigned char)42}, 
        {(unsigned char)86, (unsigned char)94}, 
        {(unsigned char)26, (unsigned char)42}, 
        {(unsigned char)87, (unsigned char)95}, 
        {(unsigned char)23, (unsigned char)41}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)26, (unsigned char)43}, 
        {(unsigned char)88, (unsigned char)96}, 
        {(unsigned char)38, (unsigned char)42}, 
        {(unsigned char)34, (unsigned char)52}, 
        {(unsigned char)38, (unsigned char)42}, 
        {(unsigned char)89, (unsigned char)97}, 
        {(unsigned char)90, (unsigned char)98}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)38, (unsigned char)56}, 
        {(unsigned char)92, (unsigned char)99}, 
        {(unsigned char)39, (unsigned char)57}, 
        {(unsigned char)93, (unsigned char)100}, 
        {(unsigned char)39, (unsigned char)57}, 
        {(unsigned char)94, (unsigned char)101}, 
        {(unsigned char)23, (unsigned char)41}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)39, (unsigned char)58}, 
        {(unsigned char)41, (unsigned char)60}, 
        {(unsigned char)95, (unsigned char)102}, 
        {(unsigned char)41, (unsigned char)60}, 
        {(unsigned char)96, (unsigned char)103}, 
        {(unsigned char)97, (unsigned char)104}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)41, (unsigned char)61}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)42, (unsigned char)56}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)43, (unsigned char)43}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)57, (unsigned char)58}, 
        {(unsigned char)59, (unsigned char)74}, 
        {(unsigned char)98, (unsigned char)105}, 
        {(unsigned char)59, (unsigned char)74}, 
        {(unsigned char)99, (unsigned char)106}, 
        {(unsigned char)100, (unsigned char)107}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)59, (unsigned char)75}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)60, (unsigned char)61}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)74, (unsigned char)75}, 
        {(unsigned char)101, (unsigned char)108}, 
        {(unsigned char)103, (unsigned char)109}, 
        {(unsigned char)104, (unsigned char)110}, 
        {(unsigned char)105, (unsigned char)111}, 
        {(unsigned char)106, (unsigned char)112}, 
        {(unsigned char)107, (unsigned char)113}, 
        {(unsigned char)108, (unsigned char)114}, 
        {(unsigned char)111, (unsigned char)115}, 
        {(unsigned char)112, (unsigned char)116}, 
        {(unsigned char)113, (unsigned char)117}, 
        {(unsigned char)114, (unsigned char)118}, 
        {(unsigned char)115, (unsigned char)119}, 
        {(unsigned char)116, (unsigned char)120}, 
        {(unsigned char)118, (unsigned char)121}, 
        {(unsigned char)119, (unsigned char)122}, 
        {(unsigned char)120, (unsigned char)123}, 
        {(unsigned char)121, (unsigned char)124}, 
        {(unsigned char)122, (unsigned char)125}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}, 
        {(unsigned char)0, (unsigned char)0}};
#line 607 "channel.l"
struct yy_channelsvf yy_channelsvec[127]  = 
#line 607
  {      {(struct yy_channelwork *)0, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + -1, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + -25, yy_channelsvec + 1, (int *)0}, 
        {yy_channelcrank + 0, (struct yy_channelsvf *)0, yy_channelvstop + 1}, 
        {yy_channelcrank + 0, (struct yy_channelsvf *)0, yy_channelvstop + 3}, 
        {yy_channelcrank + 0, (struct yy_channelsvf *)0, yy_channelvstop + 6}, 
        {yy_channelcrank + 2, (struct yy_channelsvf *)0, yy_channelvstop + 8}, 
        {yy_channelcrank + 33, (struct yy_channelsvf *)0, yy_channelvstop + 10}, 
        {yy_channelcrank + 97, (struct yy_channelsvf *)0, yy_channelvstop + 12}, 
        {yy_channelcrank + 172, (struct yy_channelsvf *)0, yy_channelvstop + 16}, 
        {yy_channelcrank + 9, yy_channelsvec + 9, yy_channelvstop + 19}, 
        {yy_channelcrank + 9, yy_channelsvec + 9, yy_channelvstop + 22}, 
        {yy_channelcrank + 18, yy_channelsvec + 9, yy_channelvstop + 25}, 
        {yy_channelcrank + 9, yy_channelsvec + 9, yy_channelvstop + 28}, 
        {yy_channelcrank + 10, yy_channelsvec + 9, yy_channelvstop + 31}, 
        {yy_channelcrank + 10, yy_channelsvec + 9, yy_channelvstop + 34}, 
        {yy_channelcrank + 12, yy_channelsvec + 9, yy_channelvstop + 37}, 
        {yy_channelcrank + 8, yy_channelsvec + 9, yy_channelvstop + 40}, 
        {yy_channelcrank + 18, yy_channelsvec + 9, yy_channelvstop + 43}, 
        {yy_channelcrank + 10, yy_channelsvec + 9, yy_channelvstop + 46}, 
        {yy_channelcrank + 0, yy_channelsvec + 7, (int *)0}, 
        {yy_channelcrank + 30, yy_channelsvec + 6, yy_channelvstop + 49}, 
        {yy_channelcrank + 9, yy_channelsvec + 7, yy_channelvstop + 51}, 
        {yy_channelcrank + 247, (struct yy_channelsvf *)0, yy_channelvstop + 53}, 
        {yy_channelcrank + 0, yy_channelsvec + 8, yy_channelvstop + 55}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 58}, 
        {yy_channelcrank + 269, yy_channelsvec + 9, yy_channelvstop + 60}, 
        {yy_channelcrank + 15, yy_channelsvec + 9, yy_channelvstop + 62}, 
        {yy_channelcrank + 16, yy_channelsvec + 9, yy_channelvstop + 64}, 
        {yy_channelcrank + 20, yy_channelsvec + 9, yy_channelvstop + 66}, 
        {yy_channelcrank + 22, yy_channelsvec + 9, yy_channelvstop + 68}, 
        {yy_channelcrank + 10, yy_channelsvec + 9, yy_channelvstop + 70}, 
        {yy_channelcrank + 19, yy_channelsvec + 9, yy_channelvstop + 72}, 
        {yy_channelcrank + 10, yy_channelsvec + 9, yy_channelvstop + 74}, 
        {yy_channelcrank + 208, yy_channelsvec + 9, yy_channelvstop + 76}, 
        {yy_channelcrank + 27, yy_channelsvec + 9, yy_channelvstop + 78}, 
        {yy_channelcrank + 43, yy_channelsvec + 9, yy_channelvstop + 80}, 
        {yy_channelcrank + 42, yy_channelsvec + 9, yy_channelvstop + 82}, 
        {yy_channelcrank + 285, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + 301, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + 88, yy_channelsvec + 23, yy_channelvstop + 84}, 
        {yy_channelcrank + 316, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + 326, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + 336, yy_channelsvec + 9, yy_channelvstop + 86}, 
        {yy_channelcrank + 11, yy_channelsvec + 9, yy_channelvstop + 89}, 
        {yy_channelcrank + 47, yy_channelsvec + 9, yy_channelvstop + 91}, 
        {yy_channelcrank + 58, yy_channelsvec + 9, yy_channelvstop + 93}, 
        {yy_channelcrank + 9, yy_channelsvec + 9, yy_channelvstop + 95}, 
        {yy_channelcrank + 52, yy_channelsvec + 9, yy_channelvstop + 97}, 
        {yy_channelcrank + 60, yy_channelsvec + 9, yy_channelvstop + 99}, 
        {yy_channelcrank + 78, yy_channelsvec + 9, yy_channelvstop + 101}, 
        {yy_channelcrank + 76, yy_channelsvec + 9, yy_channelvstop + 103}, 
        {yy_channelcrank + 83, yy_channelsvec + 9, yy_channelvstop + 105}, 
        {yy_channelcrank + 92, yy_channelsvec + 9, yy_channelvstop + 107}, 
        {yy_channelcrank + 129, yy_channelsvec + 9, yy_channelvstop + 109}, 
        {yy_channelcrank + 130, yy_channelsvec + 9, yy_channelvstop + 111}, 
        {yy_channelcrank + 0, yy_channelsvec + 42, yy_channelvstop + 113}, 
        {yy_channelcrank + 346, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + 0, yy_channelsvec + 57, yy_channelvstop + 115}, 
        {yy_channelcrank + 361, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + 371, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + 0, yy_channelsvec + 60, yy_channelvstop + 117}, 
        {yy_channelcrank + 10, yy_channelsvec + 9, yy_channelvstop + 119}, 
        {yy_channelcrank + 123, yy_channelsvec + 9, yy_channelvstop + 121}, 
        {yy_channelcrank + 9, yy_channelsvec + 9, yy_channelvstop + 123}, 
        {yy_channelcrank + 117, yy_channelsvec + 9, yy_channelvstop + 125}, 
        {yy_channelcrank + 134, yy_channelsvec + 9, yy_channelvstop + 127}, 
        {yy_channelcrank + 121, yy_channelsvec + 9, yy_channelvstop + 129}, 
        {yy_channelcrank + 120, yy_channelsvec + 9, yy_channelvstop + 131}, 
        {yy_channelcrank + 147, yy_channelsvec + 9, yy_channelvstop + 133}, 
        {yy_channelcrank + 163, yy_channelsvec + 9, yy_channelvstop + 135}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 137}, 
        {yy_channelcrank + 151, yy_channelsvec + 9, yy_channelvstop + 140}, 
        {yy_channelcrank + 151, yy_channelsvec + 9, yy_channelvstop + 142}, 
        {yy_channelcrank + 381, (struct yy_channelsvf *)0, (int *)0}, 
        {yy_channelcrank + 0, yy_channelsvec + 74, yy_channelvstop + 144}, 
        {yy_channelcrank + 150, yy_channelsvec + 9, yy_channelvstop + 146}, 
        {yy_channelcrank + 209, yy_channelsvec + 9, yy_channelvstop + 148}, 
        {yy_channelcrank + 191, yy_channelsvec + 9, yy_channelvstop + 150}, 
        {yy_channelcrank + 203, yy_channelsvec + 9, yy_channelvstop + 152}, 
        {yy_channelcrank + 194, yy_channelsvec + 9, yy_channelvstop + 154}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 156}, 
        {yy_channelcrank + 215, yy_channelsvec + 9, yy_channelvstop + 159}, 
        {yy_channelcrank + 216, yy_channelsvec + 9, yy_channelvstop + 161}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 163}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 166}, 
        {yy_channelcrank + 202, yy_channelsvec + 9, yy_channelvstop + 169}, 
        {yy_channelcrank + 214, yy_channelsvec + 9, yy_channelvstop + 171}, 
        {yy_channelcrank + 211, yy_channelsvec + 9, yy_channelvstop + 173}, 
        {yy_channelcrank + 226, yy_channelsvec + 9, yy_channelvstop + 175}, 
        {yy_channelcrank + 221, yy_channelsvec + 9, yy_channelvstop + 177}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 179}, 
        {yy_channelcrank + 241, yy_channelsvec + 9, yy_channelvstop + 182}, 
        {yy_channelcrank + 229, yy_channelsvec + 9, yy_channelvstop + 184}, 
        {yy_channelcrank + 239, yy_channelsvec + 9, yy_channelvstop + 186}, 
        {yy_channelcrank + 273, yy_channelsvec + 9, yy_channelvstop + 188}, 
        {yy_channelcrank + 257, yy_channelsvec + 9, yy_channelvstop + 190}, 
        {yy_channelcrank + 252, yy_channelsvec + 9, yy_channelvstop + 192}, 
        {yy_channelcrank + 295, yy_channelsvec + 9, yy_channelvstop + 194}, 
        {yy_channelcrank + 296, yy_channelsvec + 9, yy_channelvstop + 196}, 
        {yy_channelcrank + 303, yy_channelsvec + 9, yy_channelvstop + 198}, 
        {yy_channelcrank + 322, yy_channelsvec + 9, yy_channelvstop + 200}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 202}, 
        {yy_channelcrank + 341, yy_channelsvec + 9, yy_channelvstop + 205}, 
        {yy_channelcrank + 331, yy_channelsvec + 9, yy_channelvstop + 207}, 
        {yy_channelcrank + 347, yy_channelsvec + 9, yy_channelvstop + 209}, 
        {yy_channelcrank + 329, yy_channelsvec + 9, yy_channelvstop + 211}, 
        {yy_channelcrank + 335, yy_channelsvec + 9, yy_channelvstop + 213}, 
        {yy_channelcrank + 329, yy_channelsvec + 9, yy_channelvstop + 215}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 217}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 220}, 
        {yy_channelcrank + 330, yy_channelsvec + 9, yy_channelvstop + 223}, 
        {yy_channelcrank + 338, yy_channelsvec + 9, yy_channelvstop + 225}, 
        {yy_channelcrank + 347, yy_channelsvec + 9, yy_channelvstop + 227}, 
        {yy_channelcrank + 344, yy_channelsvec + 9, yy_channelvstop + 229}, 
        {yy_channelcrank + 345, yy_channelsvec + 9, yy_channelvstop + 231}, 
        {yy_channelcrank + 354, yy_channelsvec + 9, yy_channelvstop + 233}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 235}, 
        {yy_channelcrank + 341, yy_channelsvec + 9, yy_channelvstop + 238}, 
        {yy_channelcrank + 344, yy_channelsvec + 9, yy_channelvstop + 240}, 
        {yy_channelcrank + 338, yy_channelsvec + 9, yy_channelvstop + 242}, 
        {yy_channelcrank + 345, yy_channelsvec + 9, yy_channelvstop + 244}, 
        {yy_channelcrank + 355, yy_channelsvec + 9, yy_channelvstop + 246}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 248}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 251}, 
        {yy_channelcrank + 0, yy_channelsvec + 9, yy_channelvstop + 254}, 
        {(struct yy_channelwork *)0, (struct yy_channelsvf *)0, (int *)0}};
#line 735 "channel.l"
struct yy_channelwork *yy_channeltop  =    yy_channelcrank + 456;
#line 736 "channel.l"
struct yy_channelsvf *yy_channelbgin  =    yy_channelsvec + 1;
#line 737 "channel.l"
char yy_channelmatch[257]  = 
#line 737
  {      (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)9,      (char)10,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)9,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)43, 
        (char)1,      (char)43,      (char)1,      (char)1, 
        (char)48,      (char)48,      (char)48,      (char)48, 
        (char)48,      (char)48,      (char)48,      (char)48, 
        (char)48,      (char)48,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)69,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)65, 
        (char)1,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)69,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)65, 
        (char)65,      (char)65,      (char)65,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)0};
#line 771 "channel.l"
char yy_channelextra[25]  = 
#line 771
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0};
#line 783
#pragma ident "@(#)ncform	6.8	95/02/11 SMI"
#line 785 "channel.l"
int yy_channellineno  =    1;
#line 788 "channel.l"
struct yy_channelsvf *yy_channellstate[8192]  ;
#line 788 "channel.l"
struct yy_channelsvf **yy_channellsp  ;
#line 788 "channel.l"
struct yy_channelsvf **yy_channelolsp  ;
#line 790 "channel.l"
char *yy_channelsptr  =    yy_channelsbuf;
#line 791 "channel.l"
int *yy_channelfnd  ;
#line 793 "channel.l"
int yy_channelprevious  =    10;
#line 795 "channel.l"
int yy_channellook(void) 
{ 
  register struct yy_channelsvf *yy_channelstate ;
  register struct yy_channelsvf **lsp ;
  register struct yy_channelwork *yy_channelt ;
  struct yy_channelsvf *yy_channelz ;
  int yy_channelch ;
  int yy_channelfirst ;
  struct yy_channelwork *yy_channelr ;
  char *yy_channellastch ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct yy_channelsvf **tmp___2 ;
  char *tmp___3 ;
  struct yy_channelsvf **tmp___4 ;
  char *tmp___5 ;
  struct yy_channelsvf **tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  struct yy_channelsvf **tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 813
  yy_channelfirst = 1;
#line 814
  if (! yy_channelmorfg) {
#line 815
    yy_channellastch = yy_channeltext;
  } else {
#line 817
    yy_channelmorfg = 0;
#line 818
    yy_channellastch = yy_channeltext + yy_channelleng;
  }
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    lsp = yy_channellstate;
#line 822
    yy_channelstate = yy_channelbgin;
#line 822
    yy_channelestate = yy_channelstate;
#line 823
    if (yy_channelprevious == 10) {
#line 823
      yy_channelstate ++;
    }
    {
#line 824
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 828
      yy_channelt = yy_channelstate->yy_channelstoff;
#line 829
      if ((unsigned long )yy_channelt == (unsigned long )(yy_channelcrank)) {
#line 829
        if (! yy_channelfirst) {
#line 830
          yy_channelz = yy_channelstate->yy_channelother;
#line 831
          if ((unsigned long )yy_channelz == (unsigned long )((struct yy_channelsvf *)0)) {
#line 831
            goto while_break___0;
          }
#line 832
          if ((unsigned long )yy_channelz->yy_channelstoff == (unsigned long )(yy_channelcrank)) {
#line 832
            goto while_break___0;
          }
        }
      }
      {
#line 835
      tmp___0 = yy_channellastch;
#line 835
      yy_channellastch ++;
#line 835
      yy_channelch = input_channel();
#line 835
      *tmp___0 = (char )yy_channelch;
      }
#line 839
      if ((unsigned long )yy_channellastch > (unsigned long )(& yy_channeltext[8192])) {
        {
#line 840
        fprintf((FILE */* __restrict  */)yy_channelout, (char const   */* __restrict  */)"Input string too long, limit %d\n",
                8192);
#line 841
        exit(1);
        }
      }
#line 843
      yy_channelfirst = 0;
      tryagain: 
#line 852
      yy_channelr = yy_channelt;
#line 853
      if ((int )yy_channelt > (int )(yy_channelcrank)) {
#line 854
        yy_channelt = yy_channelr + yy_channelch;
#line 855
        if ((unsigned long )yy_channelt <= (unsigned long )yy_channeltop) {
#line 855
          if ((unsigned long )(yy_channelsvec + (int )yy_channelt->verify) == (unsigned long )yy_channelstate) {
#line 856
            if ((unsigned long )(yy_channelsvec + (int )yy_channelt->advance) == (unsigned long )(yy_channelsvec)) {
#line 857
              yy_channellastch --;
#line 857
              yy_channeltchar = (int )*yy_channellastch;
#line 857
              if (yy_channeltchar == 10) {
#line 857
                yy_channellineno --;
              }
#line 857
              tmp___1 = yy_channelsptr;
#line 857
              yy_channelsptr ++;
#line 857
              *tmp___1 = (char )yy_channeltchar;
#line 857
              goto while_break___0;
            }
#line 858
            tmp___2 = lsp;
#line 858
            lsp ++;
#line 858
            yy_channelstate = yy_channelsvec + (int )yy_channelt->advance;
#line 858
            *tmp___2 = yy_channelstate;
#line 859
            if ((unsigned long )lsp > (unsigned long )(& yy_channellstate[8192])) {
              {
#line 860
              fprintf((FILE */* __restrict  */)yy_channelout, (char const   */* __restrict  */)"Input string too long, limit %d\n",
                      8192);
#line 861
              exit(1);
              }
            }
#line 863
            goto contin;
          }
        }
      } else
#line 867
      if ((int )yy_channelt < (int )(yy_channelcrank)) {
#line 868
        yy_channelr = yy_channelcrank + (yy_channelcrank - yy_channelt);
#line 868
        yy_channelt = yy_channelr;
#line 872
        yy_channelt += yy_channelch;
#line 873
        if ((unsigned long )yy_channelt <= (unsigned long )yy_channeltop) {
#line 873
          if ((unsigned long )(yy_channelsvec + (int )yy_channelt->verify) == (unsigned long )yy_channelstate) {
#line 874
            if ((unsigned long )(yy_channelsvec + (int )yy_channelt->advance) == (unsigned long )(yy_channelsvec)) {
#line 875
              yy_channellastch --;
#line 875
              yy_channeltchar = (int )*yy_channellastch;
#line 875
              if (yy_channeltchar == 10) {
#line 875
                yy_channellineno --;
              }
#line 875
              tmp___3 = yy_channelsptr;
#line 875
              yy_channelsptr ++;
#line 875
              *tmp___3 = (char )yy_channeltchar;
#line 875
              goto while_break___0;
            }
#line 876
            tmp___4 = lsp;
#line 876
            lsp ++;
#line 876
            yy_channelstate = yy_channelsvec + (int )yy_channelt->advance;
#line 876
            *tmp___4 = yy_channelstate;
#line 877
            if ((unsigned long )lsp > (unsigned long )(& yy_channellstate[8192])) {
              {
#line 878
              fprintf((FILE */* __restrict  */)yy_channelout, (char const   */* __restrict  */)"Input string too long, limit %d\n",
                      8192);
#line 879
              exit(1);
              }
            }
#line 881
            goto contin;
          }
        }
#line 883
        yy_channelt = yy_channelr + (int )yy_channelmatch[yy_channelch];
#line 891
        if ((unsigned long )yy_channelt <= (unsigned long )yy_channeltop) {
#line 891
          if ((unsigned long )(yy_channelsvec + (int )yy_channelt->verify) == (unsigned long )yy_channelstate) {
#line 892
            if ((unsigned long )(yy_channelsvec + (int )yy_channelt->advance) == (unsigned long )(yy_channelsvec)) {
#line 893
              yy_channellastch --;
#line 893
              yy_channeltchar = (int )*yy_channellastch;
#line 893
              if (yy_channeltchar == 10) {
#line 893
                yy_channellineno --;
              }
#line 893
              tmp___5 = yy_channelsptr;
#line 893
              yy_channelsptr ++;
#line 893
              *tmp___5 = (char )yy_channeltchar;
#line 893
              goto while_break___0;
            }
#line 894
            tmp___6 = lsp;
#line 894
            lsp ++;
#line 894
            yy_channelstate = yy_channelsvec + (int )yy_channelt->advance;
#line 894
            *tmp___6 = yy_channelstate;
#line 895
            if ((unsigned long )lsp > (unsigned long )(& yy_channellstate[8192])) {
              {
#line 896
              fprintf((FILE */* __restrict  */)yy_channelout, (char const   */* __restrict  */)"Input string too long, limit %d\n",
                      8192);
#line 897
              exit(1);
              }
            }
#line 899
            goto contin;
          }
        }
      }
#line 902
      yy_channelstate = yy_channelstate->yy_channelother;
#line 902
      if (yy_channelstate) {
#line 902
        yy_channelt = yy_channelstate->yy_channelstoff;
#line 902
        if ((unsigned long )yy_channelt != (unsigned long )(yy_channelcrank)) {
#line 906
          goto tryagain;
        } else {
#line 902
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 910
        yy_channellastch --;
#line 910
        yy_channeltchar = (int )*yy_channellastch;
#line 910
        if (yy_channeltchar == 10) {
#line 910
          yy_channellineno --;
        }
#line 910
        tmp___7 = yy_channelsptr;
#line 910
        yy_channelsptr ++;
#line 910
        *tmp___7 = (char )yy_channeltchar;
#line 910
        goto while_break___0;
      }
      contin: ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 928
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 928
      tmp___14 = lsp;
#line 928
      lsp --;
#line 928
      if (! ((unsigned long )tmp___14 > (unsigned long )(yy_channellstate))) {
#line 928
        goto while_break___1;
      }
#line 929
      tmp___8 = yy_channellastch;
#line 929
      yy_channellastch --;
#line 929
      *tmp___8 = (char)0;
#line 930
      if ((unsigned long )*lsp != (unsigned long )((struct yy_channelsvf *)0)) {
#line 930
        yy_channelfnd = (*lsp)->yy_channelstops;
#line 930
        if (yy_channelfnd) {
#line 930
          if (*yy_channelfnd > 0) {
#line 931
            yy_channelolsp = lsp;
#line 932
            if (yy_channelextra[*yy_channelfnd]) {
              {
#line 933
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 933
                tmp___11 = yy_channelback((*lsp)->yy_channelstops, - *yy_channelfnd);
                }
#line 933
                if (tmp___11 != 1) {
#line 933
                  if (! ((unsigned long )lsp > (unsigned long )(yy_channellstate))) {
#line 933
                    goto while_break___2;
                  }
                } else {
#line 933
                  goto while_break___2;
                }
#line 934
                lsp --;
#line 935
                tmp___9 = yy_channellastch;
#line 935
                yy_channellastch --;
#line 935
                yy_channeltchar = (int )*tmp___9;
#line 935
                if (yy_channeltchar == 10) {
#line 935
                  yy_channellineno --;
                }
#line 935
                tmp___10 = yy_channelsptr;
#line 935
                yy_channelsptr ++;
#line 935
                *tmp___10 = (char )yy_channeltchar;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
#line 938
            yy_channelprevious = (int )*yy_channellastch;
#line 939
            yy_channellsp = lsp;
#line 940
            yy_channelleng = (int )((yy_channellastch - yy_channeltext) + 1L);
#line 941
            yy_channeltext[yy_channelleng] = (char)0;
#line 949
            tmp___12 = yy_channelfnd;
#line 949
            yy_channelfnd ++;
#line 949
            return (*tmp___12);
          }
        }
      }
#line 951
      yy_channeltchar = (int )*yy_channellastch;
#line 951
      if (yy_channeltchar == 10) {
#line 951
        yy_channellineno --;
      }
#line 951
      tmp___13 = yy_channelsptr;
#line 951
      yy_channelsptr ++;
#line 951
      *tmp___13 = (char )yy_channeltchar;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 953
    if ((int )yy_channeltext[0] == 0) {
#line 955
      yy_channelsptr = yy_channelsbuf;
#line 956
      return (0);
    }
    {
#line 959
    tmp___15 = input_channel();
#line 959
    yy_channeltext[0] = (char )tmp___15;
#line 959
    yy_channelprevious = (int )yy_channeltext[0];
    }
#line 960
    if (yy_channelprevious > 0) {
      {
#line 961
      _IO_putc(yy_channelprevious, yy_channelout);
      }
    }
#line 967
    yy_channellastch = yy_channeltext;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 974 "channel.l"
int yy_channelback(int *p , int m ) 
{ 
  int *tmp___0 ;

  {
#line 980
  if ((unsigned long )p == (unsigned long )((int *)0)) {
#line 980
    return (0);
  }
  {
#line 981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 981
    if (! *p) {
#line 981
      goto while_break;
    }
#line 982
    tmp___0 = p;
#line 982
    p ++;
#line 982
    if (*tmp___0 == m) {
#line 983
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 985
  return (0);
}
}
#line 989 "channel.l"
int yy_channelinput_channel(void) 
{ 
  int tmp___0 ;

  {
  {
#line 994
  yy_channelin = stdin;
#line 996
  tmp___0 = input_channel();
  }
#line 996
  return (tmp___0);
}
}
#line 1002 "channel.l"
void yy_channeloutput_channel(int c ) 
{ 


  {
  {
#line 1008
  yy_channelout = stdout;
#line 1010
  _IO_putc(c, yy_channelout);
  }
#line 1014
  return;
}
}
#line 1016 "channel.l"
void yy_channelunput_channel(int c ) 
{ 
  char *tmp___0 ;

  {
#line 1022
  yy_channeltchar = c;
#line 1022
  if (yy_channeltchar == 10) {
#line 1022
    yy_channellineno --;
  }
#line 1022
  tmp___0 = yy_channelsptr;
#line 1022
  yy_channelsptr ++;
#line 1022
  *tmp___0 = (char )yy_channeltchar;
#line 1023
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 49 "channel.y"
int yy_channelerror(char *s___0 ) ;
#line 51 "channel.y"
int yy_channelerror(char *s___0 ) 
{ 


  {
#line 54
  return (0);
}
}
#line 89 "channel.y"
static char const   yy_channeltranslate[273]  = 
#line 89
  {      (char const   )0,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )19,      (char const   )20,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )18,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )1,      (char const   )2,      (char const   )3,      (char const   )4, 
        (char const   )5,      (char const   )6,      (char const   )7,      (char const   )8, 
        (char const   )9,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )13,      (char const   )14,      (char const   )15,      (char const   )16, 
        (char const   )17};
#line 151 "channel.y"
static short const   yy_channelr1[19]  = 
#line 151
  {      (short const   )0,      (short const   )21,      (short const   )21,      (short const   )22, 
        (short const   )22,      (short const   )22,      (short const   )22,      (short const   )22, 
        (short const   )22,      (short const   )22,      (short const   )22,      (short const   )22, 
        (short const   )22,      (short const   )22,      (short const   )22,      (short const   )23, 
        (short const   )23,      (short const   )24,      (short const   )24};
#line 156 "channel.y"
static short const   yy_channelr2[19]  = 
#line 156
  {      (short const   )0,      (short const   )2,      (short const   )0,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )4,      (short const   )6, 
        (short const   )6,      (short const   )6,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1};
#line 161 "channel.y"
static short const   yy_channeldefact[53]  = 
#line 161
  {      (short const   )2,      (short const   )0,      (short const   )14,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )1,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )7,      (short const   )17,      (short const   )18, 
        (short const   )8,      (short const   )15,      (short const   )16,      (short const   )9, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )6,      (short const   )10,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )11,      (short const   )12,      (short const   )13,      (short const   )0, 
        (short const   )0};
#line 170 "channel.y"
static short const   yy_channeldefgoto[4]  = {      (short const   )1,      (short const   )14,      (short const   )35,      (short const   )32};
#line 174 "channel.y"
static short const   yy_channelpact[53]  = 
#line 174
  {      (short const   )-32768,      (short const   )0,      (short const   )-32768,      (short const   )-16, 
        (short const   )-15,      (short const   )-14,      (short const   )-13,      (short const   )1, 
        (short const   )2,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )8,      (short const   )-32768,      (short const   )19, 
        (short const   )22,      (short const   )24,      (short const   )26,      (short const   )12, 
        (short const   )14,      (short const   )29,      (short const   )30,      (short const   )31, 
        (short const   )32,      (short const   )33,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )34,      (short const   )16,      (short const   )20,      (short const   )21, 
        (short const   )-32768,      (short const   )-32768,      (short const   )25,      (short const   )27, 
        (short const   )28,      (short const   )35,      (short const   )38,      (short const   )41, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )47, 
        (short const   )-32768};
#line 183 "channel.y"
static short const   yy_channelpgoto[4]  = {      (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768};
#line 191 "channel.y"
static short const   yy_channeltable[48]  = 
#line 191
  {      (short const   )51,      (short const   )2,      (short const   )15,      (short const   )16, 
        (short const   )17,      (short const   )18,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )30,      (short const   )13,      (short const   )33,      (short const   )19, 
        (short const   )20,      (short const   )21,      (short const   )26,      (short const   )22, 
        (short const   )23,      (short const   )24,      (short const   )25,      (short const   )27, 
        (short const   )31,      (short const   )28,      (short const   )34,      (short const   )29, 
        (short const   )36,      (short const   )37,      (short const   )38,      (short const   )39, 
        (short const   )42,      (short const   )41,      (short const   )40,      (short const   )48, 
        (short const   )43,      (short const   )44,      (short const   )49,      (short const   )45, 
        (short const   )50,      (short const   )46,      (short const   )47,      (short const   )52};
#line 199 "channel.y"
static short const   yy_channelcheck[48]  = 
#line 199
  {      (short const   )0,      (short const   )1,      (short const   )18,      (short const   )18, 
        (short const   )18,      (short const   )18,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )4,      (short const   )17,      (short const   )4,      (short const   )18, 
        (short const   )18,      (short const   )18,      (short const   )3,      (short const   )19, 
        (short const   )19,      (short const   )19,      (short const   )18,      (short const   )5, 
        (short const   )16,      (short const   )5,      (short const   )16,      (short const   )5, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )20,      (short const   )3,      (short const   )5,      (short const   )4, 
        (short const   )20,      (short const   )20,      (short const   )4,      (short const   )18, 
        (short const   )3,      (short const   )18,      (short const   )18,      (short const   )0};
#line 104 "/usr/local/gnu/lib/bison.simple"
int yy_channelchar  ;
#line 105 "/usr/local/gnu/lib/bison.simple"
YY_channelSTYPE yy_channellval  ;
#line 113 "/usr/local/gnu/lib/bison.simple"
int yy_channelnerrs  ;
#line 184 "/usr/local/gnu/lib/bison.simple"
int yy_channelparse(void) 
{ 
  register int yy_channelstate ;
  register int yy_channeln ;
  register short *yy_channelssp ;
  register YY_channelSTYPE *yy_channelvsp ;
  int yy_channelerrstatus ;
  int yy_channelchar1 ;
  short yy_channelssa[200] ;
  YY_channelSTYPE yy_channelvsa[200] ;
  short *yy_channelss ;
  YY_channelSTYPE *yy_channelvs ;
  int yy_channelstacksize ;
  YY_channelSTYPE yy_channelval ;
  int yy_channellen ;
  YY_channelSTYPE *yy_channelvs1 ;
  short *yy_channelss1 ;
  int size ;
  void *tmp___0 ;
  void *tmp___1 ;
  int cnt ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 192
  yy_channelchar1 = 0;
#line 197
  yy_channelss = yy_channelssa;
#line 198
  yy_channelvs = yy_channelvsa;
#line 210
  yy_channelstacksize = 200;
#line 232
  yy_channelstate = 0;
#line 233
  yy_channelerrstatus = 0;
#line 234
  yy_channelnerrs = 0;
#line 235
  yy_channelchar = -2;
#line 242
  yy_channelssp = yy_channelss - 1;
#line 243
  yy_channelvsp = yy_channelvs;
  yy_channelnewstate: 
#line 253
  yy_channelssp ++;
#line 253
  *yy_channelssp = (short )yy_channelstate;
#line 255
  if ((unsigned long )yy_channelssp >= (unsigned long )((yy_channelss + yy_channelstacksize) - 1)) {
#line 259
    yy_channelvs1 = yy_channelvs;
#line 260
    yy_channelss1 = yy_channelss;
#line 266
    size = (int )((yy_channelssp - yy_channelss) + 1L);
#line 292
    if (yy_channelstacksize >= 10000) {
      {
#line 294
      yy_channelerror((char *)"parser stack overflow");
      }
#line 295
      return (2);
    }
#line 297
    yy_channelstacksize *= 2;
#line 298
    if (yy_channelstacksize > 10000) {
#line 299
      yy_channelstacksize = 10000;
    }
    {
#line 300
    tmp___0 = __builtin_alloca((unsigned long )yy_channelstacksize * sizeof(*yy_channelssp));
#line 300
    yy_channelss = (short *)tmp___0;
#line 301
    __builtin_memcpy((void *)((char *)yy_channelss), (void const   *)((char *)yy_channelss1),
                     (unsigned long )size * sizeof(*yy_channelssp));
#line 302
    tmp___1 = __builtin_alloca((unsigned long )yy_channelstacksize * sizeof(*yy_channelvsp));
#line 302
    yy_channelvs = (YY_channelSTYPE *)tmp___1;
#line 303
    __builtin_memcpy((void *)((char *)yy_channelvs), (void const   *)((char *)yy_channelvs1),
                     (unsigned long )size * sizeof(*yy_channelvsp));
#line 310
    yy_channelssp = (yy_channelss + size) - 1;
#line 311
    yy_channelvsp = (yy_channelvs + size) - 1;
    }
#line 321
    if ((unsigned long )yy_channelssp >= (unsigned long )((yy_channelss + yy_channelstacksize) - 1)) {
#line 322
      return (1);
    }
  }
#line 330
  goto yy_channelbackup;
  yy_channelbackup: 
#line 339
  yy_channeln = (int )yy_channelpact[yy_channelstate];
#line 340
  if (yy_channeln == -32768) {
#line 341
    goto yy_channeldefault;
  }
#line 348
  if (yy_channelchar == -2) {
    {
#line 354
    yy_channelchar = yy_channellex();
    }
  }
#line 359
  if (yy_channelchar <= 0) {
#line 361
    yy_channelchar1 = 0;
#line 362
    yy_channelchar = 0;
  } else
#line 371
  if ((unsigned int )yy_channelchar <= 272U) {
#line 371
    yy_channelchar1 = (int )yy_channeltranslate[yy_channelchar];
  } else {
#line 371
    yy_channelchar1 = 25;
  }
#line 387
  yy_channeln += yy_channelchar1;
#line 388
  if (yy_channeln < 0) {
#line 389
    goto yy_channeldefault;
  } else
#line 388
  if (yy_channeln > 47) {
#line 389
    goto yy_channeldefault;
  } else
#line 388
  if ((int const   )yy_channelcheck[yy_channeln] != (int const   )yy_channelchar1) {
#line 389
    goto yy_channeldefault;
  }
#line 391
  yy_channeln = (int )yy_channeltable[yy_channeln];
#line 400
  if (yy_channeln < 0) {
#line 402
    if (yy_channeln == -32768) {
#line 403
      goto yy_channelerrlab;
    }
#line 404
    yy_channeln = - yy_channeln;
#line 405
    goto yy_channelreduce;
  } else
#line 407
  if (yy_channeln == 0) {
#line 408
    goto yy_channelerrlab;
  }
#line 410
  if (yy_channeln == 52) {
#line 411
    return (0);
  }
#line 421
  if (yy_channelchar != 0) {
#line 422
    yy_channelchar = -2;
  }
#line 424
  yy_channelvsp ++;
#line 424
  *yy_channelvsp = yy_channellval;
#line 430
  if (yy_channelerrstatus) {
#line 430
    yy_channelerrstatus --;
  }
#line 432
  yy_channelstate = yy_channeln;
#line 433
  goto yy_channelnewstate;
  yy_channeldefault: 
#line 438
  yy_channeln = (int )yy_channeldefact[yy_channelstate];
#line 439
  if (yy_channeln == 0) {
#line 440
    goto yy_channelerrlab;
  }
  yy_channelreduce: 
#line 444
  yy_channellen = (int )yy_channelr2[yy_channeln];
#line 445
  if (yy_channellen > 0) {
#line 446
    yy_channelval = *(yy_channelvsp + (1 - yy_channellen));
  }
  {
#line 466
  if (yy_channeln == 3) {
#line 466
    goto case_3;
  }
#line 98
  if (yy_channeln == 4) {
#line 98 "channel.y"
    goto case_4;
  }
#line 105
  if (yy_channeln == 5) {
#line 105
    goto case_5;
  }
#line 112
  if (yy_channeln == 6) {
#line 112
    goto case_6;
  }
#line 119
  if (yy_channeln == 7) {
#line 119
    goto case_7;
  }
#line 133
  if (yy_channeln == 10) {
#line 133
    goto case_10;
  }
#line 140
  if (yy_channeln == 11) {
#line 140
    goto case_11;
  }
#line 149
  if (yy_channeln == 12) {
#line 149
    goto case_12;
  }
#line 158
  if (yy_channeln == 13) {
#line 158
    goto case_13;
  }
#line 167
  if (yy_channeln == 14) {
#line 167
    goto case_14;
  }
#line 170
  if (yy_channeln == 15) {
#line 170
    goto case_15;
  }
#line 175
  if (yy_channeln == 16) {
#line 175
    goto case_16;
  }
#line 178
  if (yy_channeln == 17) {
#line 178
    goto case_17;
  }
#line 183
  if (yy_channeln == 18) {
#line 183
    goto case_18;
  }
#line 464 "/usr/local/gnu/lib/bison.simple"
  goto switch_break;
  case_3: /* CIL Label */ 
#line 70 "channel.y"
  channel[channel_handle].fields = (yy_channelvsp + 0)->myint;
#line 71
  if (channel[channel_handle].fields > 0) {
    {
#line 73
    channel[channel_handle].cnt = 0;
#line 74
    channel[channel_handle].global_cnt = (double )0;
#line 75
    channel[channel_handle].w_resolution[0] = 256;
#line 76
    channel[channel_handle].w_resolution[1] = 256;
#line 77
    channel[channel_handle].start_time = 0.;
#line 78
    channel[channel_handle].s_time = 0;
#line 79
    channel[channel_handle].duration_time = 1000.;
#line 80
    channel[channel_handle].d_time = 0.;
#line 81
    channel[channel_handle].print_format = string((char *)"line");
#line 82
    channel[channel_handle].type = string((char *)"graphic");
#line 83
    channel[channel_handle].on_leave_w = string((char *)"noevent");
#line 84
    tmp___2 = allocate((unsigned int )sizeof(struct LIST ), 0U);
#line 84
    channel[channel_handle].list = (struct LIST *)tmp___2;
#line 86
    tmp___3 = allocate((unsigned int )sizeof(struct LIST ), 0U);
#line 86
    channel[channel_handle].list_tmp = (struct LIST *)tmp___3;
#line 88
    tmp___4 = allocate((unsigned int )((unsigned long )channel[channel_handle].fields * sizeof(struct FIELD )),
                       0U);
#line 88
    channel[channel_handle].member = (struct FIELD *)tmp___4;
#line 91
    cnt = 0;
    }
    {
#line 91
    while (1) {
      while_continue: /* CIL Label */ ;
#line 91
      if (! (cnt < channel[channel_handle].fields)) {
#line 91
        goto while_break;
      }
#line 93
      (channel[channel_handle].member + cnt)->style = 16777215UL;
#line 94
      (channel[channel_handle].member + cnt)->upper = (double )1;
#line 95
      (channel[channel_handle].member + cnt)->lower = (double )-1;
#line 91
      cnt ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 97
  goto switch_break;
  case_4: /* CIL Label */ 
#line 103
  channel[channel_handle].type = (yy_channelvsp + 0)->mystring;
#line 104
  goto switch_break;
  case_5: /* CIL Label */ 
#line 110
  channel[channel_handle].print_format = (yy_channelvsp + 0)->mystring;
#line 111
  goto switch_break;
  case_6: /* CIL Label */ 
#line 117
  channel[channel_handle].on_leave_w = (yy_channelvsp + 0)->mystring;
#line 118
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 120
  tmp___6 = strcmp((yy_channelvsp + 0)->mystring, "input_channel");
  }
#line 120
  if (0 == tmp___6) {
#line 121
    channel[channel_handle].direction = 0;
  } else {
    {
#line 124
    tmp___5 = strcmp((yy_channelvsp + 0)->mystring, "output_channel");
    }
#line 124
    if (0 == tmp___5) {
#line 125
      channel[channel_handle].direction = 1;
    } else {
      {
#line 128
      fprintfx(stderr, "bad direction\n");
#line 129
      exit(0);
      }
    }
  }
#line 132
  goto switch_break;
  case_10: /* CIL Label */ 
#line 138
  channel[channel_handle].w_resolution[0] = (yy_channelvsp + -1)->myint;
#line 138
  channel[channel_handle].w_resolution[1] = (yy_channelvsp + 0)->myint;
#line 139
  goto switch_break;
  case_11: /* CIL Label */ 
#line 141
  if (channel[channel_handle].fields > (yy_channelvsp + -3)->myint) {
#line 142
    (channel[channel_handle].member + (yy_channelvsp + -3)->myint)->lower = (yy_channelvsp + 0)->mydouble;
  } else {
    {
#line 145
    fprintfx(stderr, "invalid subscript\n");
#line 146
    exit(0);
    }
  }
#line 148
  goto switch_break;
  case_12: /* CIL Label */ 
#line 150
  if (channel[channel_handle].fields > (yy_channelvsp + -3)->myint) {
#line 151
    (channel[channel_handle].member + (yy_channelvsp + -3)->myint)->upper = (yy_channelvsp + 0)->mydouble;
  } else {
    {
#line 154
    fprintfx(stderr, "invalid subscript\n");
#line 155
    exit(0);
    }
  }
#line 157
  goto switch_break;
  case_13: /* CIL Label */ 
#line 159
  if (channel[channel_handle].fields > (yy_channelvsp + -3)->myint) {
#line 160
    (channel[channel_handle].member + (yy_channelvsp + -3)->myint)->style = (unsigned long )(yy_channelvsp + 0)->myint;
  } else {
    {
#line 163
    fprintfx(stderr, "invalid subscript\n");
#line 164
    exit(0);
    }
  }
#line 166
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 168
  fprintfx(stderr, "error in opening channel\n");
  }
#line 168
  return (-2);
#line 169
  goto switch_break;
  case_15: /* CIL Label */ 
#line 173
  channel[channel_handle].duration_time = (yy_channelvsp + 0)->mydouble;
#line 173
  channel[channel_handle].d_time = 0.;
#line 174
  goto switch_break;
  case_16: /* CIL Label */ 
#line 176
  channel[channel_handle].duration_time = 16.;
#line 176
  channel[channel_handle].d_time = 1.;
#line 177
  goto switch_break;
  case_17: /* CIL Label */ 
#line 181
  channel[channel_handle].start_time = (yy_channelvsp + 0)->mydouble;
#line 181
  channel[channel_handle].s_time = 0;
#line 182
  goto switch_break;
  case_18: /* CIL Label */ 
#line 184
  channel[channel_handle].s_time = 1;
#line 185
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 466 "/usr/local/gnu/lib/bison.simple"
  yy_channelvsp -= yy_channellen;
#line 467
  yy_channelssp -= yy_channellen;
#line 483
  yy_channelvsp ++;
#line 483
  *yy_channelvsp = yy_channelval;
#line 507
  yy_channeln = (int )yy_channelr1[yy_channeln];
#line 509
  yy_channelstate = (int )((int const   )yy_channelpgoto[yy_channeln - 21] + (int const   )*yy_channelssp);
#line 510
  if (yy_channelstate >= 0) {
#line 510
    if (yy_channelstate <= 47) {
#line 510
      if ((int const   )yy_channelcheck[yy_channelstate] == (int const   )*yy_channelssp) {
#line 511
        yy_channelstate = (int )yy_channeltable[yy_channelstate];
      } else {
#line 513
        yy_channelstate = (int )yy_channeldefgoto[yy_channeln - 21];
      }
    } else {
#line 513
      yy_channelstate = (int )yy_channeldefgoto[yy_channeln - 21];
    }
  } else {
#line 513
    yy_channelstate = (int )yy_channeldefgoto[yy_channeln - 21];
  }
#line 515
  goto yy_channelnewstate;
  yy_channelerrlab: 
#line 519
  if (! yy_channelerrstatus) {
    {
#line 522
    yy_channelnerrs ++;
#line 565
    yy_channelerror((char *)"parse error");
    }
  }
#line 568
  goto yy_channelerrlab1;
  yy_channelerrlab1: 
#line 571
  if (yy_channelerrstatus == 3) {
#line 576
    if (yy_channelchar == 0) {
#line 577
      return (1);
    }
#line 584
    yy_channelchar = -2;
  }
#line 590
  yy_channelerrstatus = 3;
#line 592
  goto yy_channelerrhandle;
  yy_channelerrdefault: 
#line 605
  if ((unsigned long )yy_channelssp == (unsigned long )yy_channelss) {
#line 605
    return (1);
  }
#line 606
  yy_channelvsp --;
#line 607
  yy_channelssp --;
#line 607
  yy_channelstate = (int )*yy_channelssp;
  yy_channelerrhandle: 
#line 625
  yy_channeln = (int )yy_channelpact[yy_channelstate];
#line 626
  if (yy_channeln == -32768) {
#line 627
    goto yy_channelerrdefault;
  }
#line 629
  yy_channeln ++;
#line 630
  if (yy_channeln < 0) {
#line 631
    goto yy_channelerrdefault;
  } else
#line 630
  if (yy_channeln > 47) {
#line 631
    goto yy_channelerrdefault;
  } else
#line 630
  if ((int const   )yy_channelcheck[yy_channeln] != 1) {
#line 631
    goto yy_channelerrdefault;
  }
#line 633
  yy_channeln = (int )yy_channeltable[yy_channeln];
#line 634
  if (yy_channeln < 0) {
#line 636
    if (yy_channeln == -32768) {
#line 637
      goto yy_channelerrdefault;
    }
#line 638
    yy_channeln = - yy_channeln;
#line 639
    goto yy_channelreduce;
  } else
#line 641
  if (yy_channeln == 0) {
#line 642
    goto yy_channelerrdefault;
  }
#line 644
  if (yy_channeln == 52) {
#line 645
    return (0);
  }
#line 652
  yy_channelvsp ++;
#line 652
  *yy_channelvsp = yy_channellval;
#line 657
  yy_channelstate = yy_channeln;
#line 658
  goto yy_channelnewstate;
}
}
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 219 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 85 "/home/wslee/benchmarks/clif-0.93/global.h"
struct remote_has_tab *hastab_remote  ;
#line 66 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 101
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 62 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
double sin_(char **a ) ;
#line 63
double exp_(char **x___0 ) ;
#line 64
int cprintf(char **a ) ;
#line 65
int cscanf(char **a ) ;
#line 66
int copen(char **a ) ;
#line 67
int cclose(char **a ) ;
#line 68
int cputc(char **a ) ;
#line 69
int cgetc(char **a ) ;
#line 77
static int do_fprintf(FILE *stream , char **a ) ;
#line 78
static int do_fscanf(FILE *stream , char **a ) ;
#line 81
int transform_to_simple_type(enum global_type type ) ;
#line 84 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
FILE *str[100]  ;
#line 92 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int handle_pointer  =    2;
#line 102 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
double sin_(char **a ) 
{ 
  double tmp___0 ;

  {
  {
#line 102
  tmp___0 = sin(*((double *)*(a + 0)));
  }
#line 102
  return (tmp___0);
}
}
#line 106 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
double exp_(char **x___0 ) 
{ 
  double tmp___0 ;

  {
  {
#line 106
  tmp___0 = exp(*((double *)*(x___0 + 0)));
  }
#line 106
  return (tmp___0);
}
}
#line 108 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
static int do_fprintf(FILE *stream , char **a ) 
{ 
  char *form ;
  char c ;
  char buf[8192] ;
  int n ;
  int result ;
  int part_res ;
  int i ;
  int res ;
  int res___0 ;
  int res___1 ;
  char *tmp___0 ;
  void *__cil_tmp14 ;

  {
#line 118
  n = 2;
#line 118
  result = 0;
#line 119
  if (call_by_value) {
#line 120
    form = *((char **)*(a + 0));
  } else
#line 121
  if (call_by_reference) {
#line 122
    form = *(a + 0);
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    tmp___0 = form;
#line 124
    form ++;
#line 124
    c = *tmp___0;
#line 124
    if (! c) {
#line 124
      goto while_break;
    }
#line 126
    if (37 != (int )c) {
      {
#line 128
      part_res = fputc((int )c, stream);
      }
#line 129
      if (-1 == part_res) {
#line 131
        result = part_res;
#line 132
        goto while_break;
      } else {
#line 135
        part_res = 1;
      }
    } else {
#line 140
      buf[0] = c;
#line 141
      i = 1;
      {
#line 141
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 141
        if (! *form) {
#line 141
          goto while_break___0;
        }
#line 143
        c = *form;
#line 143
        buf[i] = c;
#line 144
        if (99 == (int )c) {
          {
#line 146
          buf[i + 1] = (char )'\000';
#line 147
          part_res = fprintfx(stream, buf, (int )*(*(a + n)));
#line 148
          form ++;
#line 149
          n += 2;
          }
#line 150
          goto while_break___0;
        } else
#line 152
        if (100 == (int )c) {
#line 152
          goto _L___0;
        } else
#line 152
        if (105 == (int )c) {
#line 152
          goto _L___0;
        } else
#line 152
        if (111 == (int )c) {
#line 152
          goto _L___0;
        } else
#line 152
        if (117 == (int )c) {
#line 152
          goto _L___0;
        } else
#line 152
        if (120 == (int )c) {
#line 152
          goto _L___0;
        } else
#line 152
        if (88 == (int )c) {
          _L___0: /* CIL Label */ 
          {
#line 156
          buf[i + 1] = (char )'\000';
#line 157
          res = transform_to_simple_type((enum global_type )*((int *)*(a + (n + 1))));
          }
#line 158
          if (res == 130) {
            {
#line 159
            part_res = fprintfx(stream, buf, (int )*((signed char *)*(a + n)));
            }
          } else
#line 161
          if (res == 258) {
            {
#line 162
            part_res = fprintfx(stream, buf, (int )*((unsigned char *)*(a + n)));
            }
          } else
#line 164
          if (res == 2) {
            {
#line 165
            part_res = fprintfx(stream, buf, (int )*(*(a + n)));
            }
          } else
#line 166
          if (res == 264) {
            {
#line 167
            part_res = fprintfx(stream, buf, *((unsigned int *)*(a + n)));
            }
          } else
#line 169
          if (res == 24) {
            {
#line 170
            part_res = fprintfx(stream, buf, *((long *)*(a + n)));
            }
          } else
#line 172
          if (res == 280) {
            {
#line 173
            part_res = fprintfx(stream, buf, *((unsigned long *)*(a + n)));
            }
          } else
#line 175
          if (res == 12) {
            {
#line 176
            part_res = fprintfx(stream, buf, (int )*((short *)*(a + n)));
            }
          } else
#line 178
          if (res == 268) {
            {
#line 179
            part_res = fprintfx(stream, buf, (int )*((unsigned short *)*(a + n)));
            }
          } else {
            {
#line 182
            part_res = fprintfx(stream, buf, *((int *)*(a + n)));
            }
          }
#line 183
          form ++;
#line 184
          n += 2;
#line 185
          goto while_break___0;
        } else
#line 187
        if (102 == (int )c) {
#line 190
          buf[i + 1] = (char )'\000';
#line 191
          if (call_by_value) {
            {
#line 192
            res___0 = transform_to_simple_type((enum global_type )*((int *)*(a + (n + 2))));
            }
          } else
#line 193
          if (call_by_reference) {
            {
#line 194
            res___0 = transform_to_simple_type((enum global_type )*((int *)*(a + (n + 1))));
            }
          }
#line 195
          if (res___0 == 32) {
            {
#line 196
            part_res = fprintfx(stream, buf, (double )*((float *)*(a + n)));
            }
          } else
#line 197
          if (res___0 == 64) {
            {
#line 198
            part_res = fprintfx(stream, buf, *((double *)*(a + n)));
            }
          } else {
            {
#line 201
            part_res = fprintfx(stream, buf, *((long double *)*(a + n)));
            }
          }
#line 203
          form ++;
#line 204
          if (call_by_value) {
#line 205
            n ++;
          }
#line 206
          n += 2;
#line 207
          goto while_break___0;
        } else
#line 209
        if (103 == (int )c) {
#line 209
          goto _L;
        } else
#line 209
        if (71 == (int )c) {
#line 209
          goto _L;
        } else
#line 209
        if (101 == (int )c) {
#line 209
          goto _L;
        } else
#line 209
        if (69 == (int )c) {
          _L: /* CIL Label */ 
#line 212
          buf[i + 1] = (char )'\000';
#line 213
          if (call_by_value) {
            {
#line 214
            res___1 = transform_to_simple_type((enum global_type )*((int *)*(a + (n + 2))));
            }
          } else
#line 215
          if (call_by_reference) {
            {
#line 216
            res___1 = transform_to_simple_type((enum global_type )*((int *)*(a + (n + 1))));
            }
          }
#line 217
          if (res___1 == 32) {
            {
#line 218
            part_res = fprintfx(stream, buf, (double )*((float *)*(a + n)));
            }
          } else
#line 219
          if (res___1 == 64) {
            {
#line 220
            part_res = fprintfx(stream, buf, *((double *)*(a + n)));
            }
          } else {
            {
#line 223
            part_res = fprintfx(stream, buf, *((long double *)*(a + n)));
            }
          }
#line 225
          form ++;
#line 226
          if (call_by_value) {
#line 227
            n ++;
          }
#line 228
          n += 2;
#line 229
          goto while_break___0;
        } else
#line 231
        if (115 == (int )c) {
#line 233
          buf[i + 1] = (char )'\000';
#line 234
          if (call_by_value) {
            {
#line 235
            part_res = fprintfx(stream, buf, *((char **)*(a + n)));
            }
          } else {
            {
#line 237
            part_res = fprintfx(stream, buf, *(a + n));
            }
          }
#line 238
          form ++;
#line 239
          n += 2;
#line 240
          goto while_break___0;
        } else
#line 242
        if (112 == (int )c) {
          {
#line 244
          buf[i + 1] = (char )'\000';
#line 245
          part_res = fprintfx(stream, buf, *((int *)*(a + n)));
#line 246
          form ++;
#line 247
          n += 2;
          }
#line 248
          goto while_break___0;
        } else
#line 250
        if (110 == (int )c) {
          {
#line 252
          buf[i + 1] = (char )'\000';
#line 253
          part_res = fprintfx(stream, buf, *((int *)*(a + n)));
#line 254
          form ++;
#line 255
          n += 2;
          }
#line 256
          goto while_break___0;
        }
#line 141
        form ++;
#line 141
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 260
    if (-1 == part_res) {
#line 262
      result = part_res;
#line 263
      goto while_break;
    } else {
#line 266
      result += part_res;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return (result);
}
}
#line 277 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int cfprintf(char **a ) 
{ 
  int tmp___0 ;

  {
  {
#line 281
  str[0] = stdin;
#line 282
  str[1] = stdout;
#line 283
  str[2] = stderr;
#line 284
  tmp___0 = do_fprintf(str[*((int *)*(a + 0))], a + 2);
  }
#line 284
  return (tmp___0);
}
}
#line 288 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int cprintf(char **a ) 
{ 
  int tmp___0 ;

  {
  {
#line 292
  str[0] = stdin;
#line 293
  str[1] = stdout;
#line 294
  str[2] = stderr;
#line 295
  tmp___0 = do_fprintf(str[1], a);
  }
#line 295
  return (tmp___0);
}
}
#line 299 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
static int do_fscanf(FILE *stream , char **a ) 
{ 
  char *form ;
  char buf[8192] ;
  int c ;
  int n ;
  int result ;
  int part_res ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int i ;
  char *tmp___2 ;
  void *__cil_tmp13 ;

  {
#line 307
  n = 1;
#line 307
  result = 0;
#line 311
  if (call_by_value) {
#line 312
    form = *((char **)*(a + 0));
  } else
#line 313
  if (call_by_reference) {
#line 314
    form = *(a + 0);
  }
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    tmp___2 = form;
#line 317
    form ++;
#line 317
    c = (int )*tmp___2;
#line 317
    if (! c) {
#line 317
      goto while_break;
    }
#line 319
    if (37 != c) {
      {
#line 321
      part_res = _IO_getc(stream);
      }
#line 322
      if (-1 == part_res) {
#line 324
        result = part_res;
#line 325
        goto while_break;
      } else {
        {
#line 327
        tmp___0 = __ctype_b_loc();
        }
#line 327
        if ((int const   )*(*tmp___0 + c) & 8192) {
          {
#line 327
          tmp___1 = __ctype_b_loc();
          }
#line 327
          if ((int const   )*(*tmp___1 + part_res) & 8192) {
#line 328
            part_res = 0;
          } else {
#line 327
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 329
        if (c != part_res) {
#line 331
          part_res = -1;
#line 331
          result = part_res;
#line 332
          goto while_break;
        } else {
#line 335
          part_res = 0;
        }
      }
    } else {
#line 340
      buf[0] = (char )c;
#line 341
      i = 1;
      {
#line 341
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 341
        if (! *form) {
#line 341
          goto while_break___0;
        }
#line 343
        c = (int )*form;
#line 343
        buf[i] = (char )c;
#line 344
        if (99 == c) {
#line 346
          buf[i + 1] = (char )'\000';
#line 347
          if (call_by_value) {
            {
#line 348
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              (int )*(*(a + n)));
            }
          } else
#line 349
          if (call_by_reference) {
            {
#line 350
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              *(a + n));
            }
          }
#line 351
          form ++;
#line 352
          n ++;
#line 353
          goto while_break___0;
        } else
#line 355
        if (100 == c) {
#line 355
          goto _L___1;
        } else
#line 355
        if (105 == c) {
#line 355
          goto _L___1;
        } else
#line 355
        if (111 == c) {
#line 355
          goto _L___1;
        } else
#line 355
        if (117 == c) {
#line 355
          goto _L___1;
        } else
#line 355
        if (120 == c) {
#line 355
          goto _L___1;
        } else
#line 355
        if (88 == c) {
          _L___1: /* CIL Label */ 
#line 358
          buf[i + 1] = (char )'\000';
#line 359
          if (call_by_value) {
            {
#line 360
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              *((int *)*(a + n)));
            }
          } else
#line 361
          if (call_by_reference) {
            {
#line 362
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              *(a + n));
            }
          }
#line 363
          form ++;
#line 364
          n ++;
#line 365
          goto while_break___0;
        } else
#line 367
        if (102 == c) {
#line 367
          goto _L___0;
        } else
#line 367
        if (103 == c) {
#line 367
          goto _L___0;
        } else
#line 367
        if (71 == c) {
#line 367
          goto _L___0;
        } else
#line 367
        if (101 == c) {
#line 367
          goto _L___0;
        } else
#line 367
        if (69 == c) {
          _L___0: /* CIL Label */ 
#line 370
          buf[i + 1] = (char )'\000';
#line 371
          if (call_by_value) {
#line 373
            if ((int )buf[i - 1] == 108) {
              {
#line 374
              part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                                *((double *)*(a + n)));
              }
            } else
#line 376
            if ((int )buf[i - 1] == 76) {
              {
#line 377
              part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                                *((long double *)*(a + n)));
              }
            } else {
              {
#line 380
              part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                                (double )*((float *)*(a + n)));
              }
            }
          } else
#line 383
          if (call_by_reference) {
            {
#line 384
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              *(a + n));
            }
          }
#line 385
          form ++;
#line 386
          n ++;
#line 387
          goto while_break___0;
        } else
#line 389
        if (115 == c) {
#line 391
          buf[i + 1] = (char )'\000';
#line 392
          if (call_by_value) {
            {
#line 393
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              (int )*(*(a + n)));
            }
          } else
#line 394
          if (call_by_reference) {
            {
#line 395
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              *(a + n));
            }
          }
#line 396
          form ++;
#line 397
          n ++;
#line 398
          goto while_break___0;
        } else
#line 400
        if (112 == c) {
#line 402
          buf[i + 1] = (char )'\000';
#line 403
          if (call_by_value) {
            {
#line 404
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              (int )*(*(a + n)));
            }
          } else
#line 405
          if (call_by_reference) {
            {
#line 406
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              *(a + n));
            }
          }
#line 407
          form ++;
#line 408
          n ++;
#line 409
          goto while_break___0;
        } else
#line 411
        if (110 == c) {
#line 413
          buf[i + 1] = (char )'\000';
#line 414
          if (call_by_value) {
            {
#line 415
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              (int )*(*(a + n)));
            }
          } else
#line 416
          if (call_by_reference) {
            {
#line 417
            part_res = fscanf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(buf),
                              *(a + n));
            }
          }
#line 418
          form ++;
#line 419
          n ++;
#line 420
          goto while_break___0;
        }
#line 341
        form ++;
#line 341
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 424
    if (-1 == part_res) {
#line 426
      result = part_res;
#line 427
      goto while_break;
    } else {
#line 430
      result += part_res;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  return (result);
}
}
#line 440 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int cfscanf(char **a ) 
{ 
  int tmp___0 ;

  {
  {
#line 444
  str[0] = stdin;
#line 445
  str[1] = stdout;
#line 446
  str[2] = stderr;
#line 447
  tmp___0 = do_fscanf(str[*((int *)*(a + 0))], a + 1);
  }
#line 447
  return (tmp___0);
}
}
#line 451 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int cscanf(char **a ) 
{ 
  int tmp___0 ;

  {
  {
#line 455
  str[0] = stdin;
#line 456
  str[1] = stdout;
#line 457
  str[2] = stderr;
#line 458
  tmp___0 = do_fscanf(str[0], a);
  }
#line 458
  return (tmp___0);
}
}
#line 465 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int copen(char **a ) 
{ 
  char *fn ;
  char *type ;
  FILE *tmp___0 ;

  {
  {
#line 471
  str[0] = stdin;
#line 472
  str[1] = stdout;
#line 473
  str[2] = stderr;
#line 474
  fn = *(a + 0);
#line 475
  type = *(a + 1);
#line 477
  handle_pointer ++;
#line 477
  tmp___0 = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)type);
#line 477
  str[handle_pointer] = tmp___0;
  }
#line 477
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 478
    return (-1);
  } else {
#line 480
    return (handle_pointer);
  }
}
}
#line 486 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int cclose(char **a ) 
{ 
  int *handle ;
  int tmp___0 ;

  {
  {
#line 492
  str[0] = stdin;
#line 493
  str[1] = stdout;
#line 494
  str[2] = stderr;
#line 495
  handle = (int *)*(a + 0);
#line 497
  handle_pointer --;
#line 498
  tmp___0 = fclose(str[*handle]);
  }
#line 498
  return (tmp___0);
}
}
#line 504 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int cputc(char **a ) 
{ 
  char *c ;
  int *handle ;
  int tmp___0 ;

  {
  {
#line 511
  str[0] = stdin;
#line 512
  str[1] = stdout;
#line 513
  str[2] = stderr;
#line 514
  c = *(a + 0);
#line 515
  handle = (int *)*(a + 1);
#line 517
  tmp___0 = fputc((int )*c, str[*handle]);
  }
#line 517
  return (tmp___0);
}
}
#line 522 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int cgetc(char **a ) 
{ 
  int *handle ;
  int tmp___0 ;

  {
  {
#line 528
  str[0] = stdin;
#line 529
  str[1] = stdout;
#line 530
  str[2] = stderr;
#line 531
  handle = (int *)*(a + 0);
#line 533
  tmp___0 = fgetc(str[*handle]);
  }
#line 533
  return (tmp___0);
}
}
#line 537 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int cfflush(char **a ) 
{ 
  int tmp___0 ;

  {
  {
#line 541
  str[0] = stdin;
#line 542
  str[1] = stdout;
#line 543
  str[2] = stderr;
#line 544
  tmp___0 = fflush(str[*((int *)*(a + 0))]);
  }
#line 544
  return (tmp___0);
}
}
#line 592
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 555 "/home/wslee/benchmarks/clif-0.93/myintrinsic.c"
int transform_to_simple_type(enum global_type type ) 
{ 


  {
  {
#line 561
  if ((unsigned int )type == 1536U) {
#line 561
    goto case_1536;
  }
#line 563
  if ((unsigned int )type == 1538U) {
#line 563
    goto case_1538;
  }
#line 565
  if ((unsigned int )type == 1537U) {
#line 565
    goto case_1537;
  }
#line 567
  if ((unsigned int )type == 1539U) {
#line 567
    goto case_1539;
  }
#line 569
  if ((unsigned int )type == 1280U) {
#line 569
    goto case_1280;
  }
#line 571
  if ((unsigned int )type == 1281U) {
#line 571
    goto case_1281;
  }
#line 573
  if ((unsigned int )type == 1282U) {
#line 573
    goto case_1282;
  }
#line 575
  if ((unsigned int )type == 1283U) {
#line 575
    goto case_1283;
  }
#line 577
  if ((unsigned int )type == 1284U) {
#line 577
    goto case_1284;
  }
#line 579
  if ((unsigned int )type == 1285U) {
#line 579
    goto case_1285;
  }
#line 581
  if ((unsigned int )type == 1288U) {
#line 581
    goto case_1288;
  }
#line 583
  if ((unsigned int )type == 1286U) {
#line 583
    goto case_1286;
  }
#line 585
  if ((unsigned int )type == 1287U) {
#line 585
    goto case_1287;
  }
#line 589
  if ((unsigned int )type == 1291U) {
#line 589
    goto case_1291;
  }
#line 589
  if ((unsigned int )type == 1290U) {
#line 589
    goto case_1291;
  }
#line 589
  if ((unsigned int )type == 1289U) {
#line 589
    goto case_1291;
  }
#line 591
  goto switch_default;
  case_1536: /* CIL Label */ 
#line 562
  return (8);
  case_1538: /* CIL Label */ 
#line 564
  return (32);
  case_1537: /* CIL Label */ 
#line 566
  return (64);
  case_1539: /* CIL Label */ 
#line 568
  return (1539);
  case_1280: /* CIL Label */ 
#line 570
  return (8);
  case_1281: /* CIL Label */ 
#line 572
  return (264);
  case_1282: /* CIL Label */ 
#line 574
  return (24);
  case_1283: /* CIL Label */ 
#line 576
  return (280);
  case_1284: /* CIL Label */ 
#line 578
  return (12);
  case_1285: /* CIL Label */ 
#line 580
  return (268);
  case_1288: /* CIL Label */ 
#line 582
  return (32);
  case_1286: /* CIL Label */ 
#line 584
  return (64);
  case_1287: /* CIL Label */ 
#line 586
  return (80);
  case_1291: /* CIL Label */ 
  case_1290: /* CIL Label */ 
  case_1289: /* CIL Label */ 
#line 590
  return (2);
  switch_default: /* CIL Label */ 
  {
#line 592
  abort();
  }
#line 593
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 595
  return (-1);
}
}
#line 41 "/home/wslee/benchmarks/clif-0.93/intrinsic.h"
struct INTR intr_name[15]  = 
#line 41 "/home/wslee/benchmarks/clif-0.93/intrinsic.h"
  {      {(char *)"cclose", (void (*)(char ** ))(& cclose)}, 
        {(char *)"cgetc", (void (*)(char ** ))(& cgetc)}, 
        {(char *)"chclose", & chclose}, 
        {(char *)"chflush", (void (*)(char ** ))(& chflush)}, 
        {(char *)"chopen", (void (*)(char ** ))(& chopen)}, 
        {(char *)"chwrite", & chwrite}, 
        {(char *)"copen", (void (*)(char ** ))(& copen)}, 
        {(char *)"cputc", (void (*)(char ** ))(& cputc)}, 
        {(char *)"exp", (void (*)(char ** ))(& exp_)}, 
        {(char *)"fflush", (void (*)(char ** ))(& cfflush)}, 
        {(char *)"fprintf", (void (*)(char ** ))(& cfprintf)}, 
        {(char *)"fscanf", (void (*)(char ** ))(& cfscanf)}, 
        {(char *)"printf", (void (*)(char ** ))(& cprintf)}, 
        {(char *)"scanf", (void (*)(char ** ))(& cscanf)}, 
        {(char *)"sin", (void (*)(char ** ))(& sin_)}};
#line 85 "/home/wslee/benchmarks/clif-0.93/intrinsic.h"
void (*f[sizeof(intr_name) / sizeof(intr_name[0])])(char ** )  ;
#line 37 "/home/wslee/benchmarks/clif-0.93/load.h"
int load(struct remote_tab **x___0 ) ;
#line 40
int load_new(void) ;
#line 43
int unload(void) ;
#line 38 "/home/wslee/benchmarks/clif-0.93/load.c"
void link_function(int i ) ;
#line 41 "/home/wslee/benchmarks/clif-0.93/load.c"
static int load_flag  =    0;
#line 46 "/home/wslee/benchmarks/clif-0.93/load.c"
int load(struct remote_tab **x___0 ) 
{ 
  int i ;
  struct remote_tab *arch ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 50
  i = 0;
#line 51
  arch = (struct remote_tab *)((void *)0);
#line 52
  if (! load_flag) {
#line 54
    if (sizeof(intr_name) / sizeof(intr_name[0]) > 0UL) {
      {
#line 56
      tmp___0 = allocate((unsigned int )sizeof(struct remote_tab ), 0U);
#line 56
      *x___0 = (struct remote_tab *)tmp___0;
#line 58
      (*x___0)->name = intr_name[i].name;
#line 59
      (*x___0)->adr = intr_name[i].adr;
#line 60
      (*x___0)->next = (struct remote_tab *)((void *)0);
#line 61
      arch = *x___0;
#line 62
      i = 1;
      }
      {
#line 62
      while (1) {
        while_continue: /* CIL Label */ ;
#line 62
        if (! ((unsigned long )i < sizeof(intr_name) / sizeof(intr_name[0]))) {
#line 62
          goto while_break;
        }
        {
#line 64
        tmp___1 = allocate((unsigned int )sizeof(struct remote_tab ), 0U);
#line 64
        arch->next = (struct remote_tab *)tmp___1;
#line 66
        arch = arch->next;
#line 67
        arch->name = intr_name[i].name;
#line 68
        arch->adr = intr_name[i].adr;
#line 69
        arch->next = (struct remote_tab *)((void *)0);
#line 62
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 71
      load_flag = 1;
#line 72
      return (0);
    } else {
      {
#line 76
      error_message(1008);
      }
#line 77
      return (-1);
    }
  } else {
#line 82
    return (1);
  }
}
}
#line 87 "/home/wslee/benchmarks/clif-0.93/load.c"
static int load_flag_new  =    0;
#line 89 "/home/wslee/benchmarks/clif-0.93/load.c"
int load_new(void) 
{ 
  int i ;

  {
#line 94
  if (! load_flag_new) {
#line 96
    i = 0;
    {
#line 96
    while (1) {
      while_continue: /* CIL Label */ ;
#line 96
      if (! ((unsigned long )i < sizeof(intr_name) / sizeof(intr_name[0]))) {
#line 96
        goto while_break;
      }
      {
#line 98
      text = string(intr_name[i].name);
#line 99
      link_function(i);
#line 96
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 101
    load_flag_new = 1;
#line 102
    return (0);
  } else {
#line 105
    return (load_flag_new);
  }
}
}
#line 108 "/home/wslee/benchmarks/clif-0.93/load.c"
int unload(void) 
{ 


  {
#line 111
  load_flag_new = 0;
#line 112
  return (0);
}
}
#line 38 "/home/wslee/benchmarks/clif-0.93/remote_call.h"
void has_remote(struct remote_tab *x___0 ) ;
#line 36 "/home/wslee/benchmarks/clif-0.93/remote_call.c"
static int hash_code_remote(char *s___0 ) ;
#line 37
static void putstruct_remote(struct remote_has_tab *np , char *name___0 , int i ) ;
#line 39
static struct remote_has_tab *lookup_remote(char *s___0 ) ;
#line 48 "/home/wslee/benchmarks/clif-0.93/remote_call.c"
static int remote_offset_counter  =    0;
#line 55 "/home/wslee/benchmarks/clif-0.93/remote_call.c"
void has_remote(struct remote_tab *x___0 ) 
{ 
  struct remote_has_tab *np ;
  struct remote_has_tab *arch ;
  int tmp___0 ;
  char *tmp___1 ;
  struct remote_has_tab *tmp___2 ;

  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! ((unsigned long )x___0 != (unsigned long )((void *)0))) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___2 = lookup_remote(x___0->name);
    }
#line 62
    if ((unsigned long )((void *)0) == (unsigned long )tmp___2) {
      {
#line 69
      f[remote_offset_counter] = x___0->adr;
#line 70
      tmp___0 = hash_code_remote(x___0->name);
#line 70
      np = hastab_remote + tmp___0;
      }
#line 71
      if ((unsigned long )np->name == (unsigned long )((void *)0)) {
        {
#line 73
        putstruct_remote(np, x___0->name, remote_offset_counter);
#line 74
        x___0 = x___0->next;
#line 75
        remote_offset_counter ++;
        }
      } else {
        {
#line 79
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 81
          arch = np;
#line 82
          np = np->next;
#line 79
          if (! ((unsigned long )np != (unsigned long )((void *)0))) {
#line 79
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 85
        tmp___1 = allocate((unsigned int )sizeof(struct remote_has_tab ), 0U);
#line 85
        np = (struct remote_has_tab *)tmp___1;
#line 87
        arch->next = np;
#line 88
        putstruct_remote(np, x___0->name, remote_offset_counter);
#line 89
        x___0 = x___0->next;
#line 90
        remote_offset_counter ++;
        }
      }
#line 92
      arch = (struct remote_has_tab *)((void *)0);
    } else {
      {
#line 96
      error_message(1006);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 106 "/home/wslee/benchmarks/clif-0.93/remote_call.c"
static void putstruct_remote(struct remote_has_tab *np , char *name___0 , int i ) 
{ 


  {
#line 112
  np->name = name___0;
#line 116
  np->offset = i;
#line 120
  return;
}
}
#line 125 "/home/wslee/benchmarks/clif-0.93/remote_call.c"
static struct remote_has_tab *lookup_remote(char *s___0 ) 
{ 
  struct remote_has_tab *ps ;
  int tmp___0 ;

  {
  {
#line 131
  tmp___0 = hash_code_remote(s___0);
#line 131
  ps = hastab_remote + tmp___0;
  }
#line 132
  if (*((int *)ps) == 0) {
#line 133
    return ((struct remote_has_tab *)((void *)0));
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 135
      if (! ((unsigned long )ps->next != (unsigned long )((void *)0))) {
#line 135
        goto while_break;
      }
    } else {
#line 135
      goto while_break;
    }
#line 136
    ps = ps->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if ((unsigned long )ps->next == (unsigned long )((void *)0)) {
#line 137
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 138
      return ((struct remote_has_tab *)((void *)0));
    } else {
#line 140
      return (ps);
    }
  } else {
#line 140
    return (ps);
  }
}
}
#line 146 "/home/wslee/benchmarks/clif-0.93/remote_call.c"
static int hash_code_remote(char *s___0 ) 
{ 
  int c ;

  {
#line 150
  c = 0;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! *s___0) {
#line 151
      goto while_break;
    }
#line 153
    c = (c << 1) ^ (int )*s___0;
#line 154
    s___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  if (c < 0) {
#line 157
    c = - c;
  }
#line 158
  return (c % 1999);
}
}
#line 41 "/home/wslee/benchmarks/clif-0.93/symbols.c"
static unsigned int hash(char *s___0 ) ;
#line 44 "/home/wslee/benchmarks/clif-0.93/symbols.c"
static struct string *buckets[2000]  ;
#line 51 "/home/wslee/benchmarks/clif-0.93/symbols.c"
static unsigned int hash(char *s___0 ) 
{ 
  int c ;

  {
#line 55
  c = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! *s___0) {
#line 57
      goto while_break;
    }
#line 59
    c = (c << 1) ^ (int )*s___0;
#line 60
    s___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if (0 > c) {
#line 63
    c = - c;
  }
#line 64
  return ((unsigned int )(c % 1999));
}
}
#line 89 "/home/wslee/benchmarks/clif-0.93/symbols.c"
static char *next  ;
#line 89 "/home/wslee/benchmarks/clif-0.93/symbols.c"
static char *limit  ;
#line 67 "/home/wslee/benchmarks/clif-0.93/symbols.c"
char *string(char *s___0 ) 
{ 
  int len ;
  size_t tmp___0 ;
  unsigned int h ;
  struct string *p ;
  char *end ;
  char *s1 ;
  char *s2 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int n ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 71
  tmp___0 = strlen((char const   *)s___0);
#line 71
  len = (int )tmp___0;
#line 74
  end = s___0 + len;
#line 76
  h = hash(s___0);
#line 77
  p = buckets[h];
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! p) {
#line 77
      goto while_break;
    }
#line 78
    if (p->len == len) {
#line 80
      s1 = s___0;
#line 80
      s2 = p->str;
      {
#line 82
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 84
        if ((unsigned long )s1 == (unsigned long )end) {
#line 85
          return (p->str);
        }
#line 82
        tmp___1 = s1;
#line 82
        s1 ++;
#line 82
        tmp___2 = s2;
#line 82
        s2 ++;
#line 82
        if (! ((int )*tmp___1 == (int )*tmp___2)) {
#line 82
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 77
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  if ((unsigned long )((next + len) + 1) >= (unsigned long )limit) {
    {
#line 93
    n = len + 4096;
#line 95
    next = allocate((unsigned int )n, 0U);
#line 96
    limit = next + n;
    }
  }
  {
#line 98
  tmp___3 = allocate((unsigned int )sizeof(*p), 0U);
#line 98
  p = (struct string *)tmp___3;
#line 99
  p->len = len;
#line 100
  p->str = next;
  }
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 100
    if (! ((unsigned long )s___0 < (unsigned long )end)) {
#line 100
      goto while_break___1;
    }
#line 101
    tmp___4 = next;
#line 101
    next ++;
#line 101
    tmp___5 = s___0;
#line 101
    s___0 ++;
#line 101
    *tmp___4 = *tmp___5;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 102
  tmp___6 = next;
#line 102
  next ++;
#line 102
  *tmp___6 = (char )'\000';
#line 103
  p->next = buckets[h];
#line 104
  buckets[h] = p;
#line 105
  return (p->str);
}
}
#line 36 "/home/wslee/benchmarks/clif-0.93/memmove.h"
void *memmovex(void *s1 , void *s2 , unsigned int n ) ;
#line 31 "/home/wslee/benchmarks/clif-0.93/memmove.c"
void *memmovex(void *s1 , void *s2 , unsigned int n ) 
{ 
  int i ;

  {
#line 37
  i = (int )((unsigned long )n / sizeof(int ) - 1UL);
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i >= 0)) {
#line 37
      goto while_break;
    }
#line 38
    *((char **)((int *)s1 + i)) = *((char **)((int *)s2 + i));
#line 37
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return (s1);
}
}
#line 44 "/home/wslee/benchmarks/clif-0.93/input.h"
int terminate_buffer(void) ;
#line 48
int init_input(int argc1 , char **argv1 ) ;
#line 49 "/home/wslee/benchmarks/clif-0.93/input.c"
FILE *yyin ;
#line 54 "/home/wslee/benchmarks/clif-0.93/input.c"
int (*input)(void)  ;
#line 56 "/home/wslee/benchmarks/clif-0.93/input.c"
char string_resume[8]  = 
#line 56
  {      (char )'r',      (char )'e',      (char )'s',      (char )'u', 
        (char )'m',      (char )'e',      (char )';',      (char )'\000'};
#line 61
int handle_main ;
#line 62
int source_line_number ;
#line 66
void exit_file_scope(void) ;
#line 178 "/home/wslee/benchmarks/clif-0.93/input.c"
int terminate_buffer(void) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 181
  fclose(spf[s].fp);
#line 182
  spf[s].fp = (FILE *)((void *)0);
#line 183
  spf[s].name = (char *)((void *)0);
#line 184
  tmp___0 = s;
#line 184
  s --;
#line 184
  spf[tmp___0].line_counter = 1;
#line 185
  source_line_number = 0;
#line 186
  exit_file_scope();
  }
#line 190
  if (! s) {
#line 190
    if (handle_main) {
#line 191
      return (1);
    }
  }
#line 193
  if (! s) {
#line 193
    if (! no_compile_only) {
#line 193
      tmp___1 = 1;
    } else {
#line 193
      tmp___1 = 0;
    }
  } else {
#line 193
    tmp___1 = 0;
  }
#line 193
  return (tmp___1);
}
}
#line 201 "/home/wslee/benchmarks/clif-0.93/input.c"
int init_input(int argc1 , char **argv1 ) 
{ 
  int b ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 211
  s = argc1 - 1;
#line 212
  spf[0].fp = stdin;
#line 213
  spf[0].name = (char *)"stdin";
#line 214
  spf[0].line_counter = 1;
#line 215
  b = 1;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (b < argc1)) {
#line 215
      goto while_break;
    }
    {
#line 220
    spf[argc1 - b].fp = fopen((char const   */* __restrict  */)*(argv1 + b), (char const   */* __restrict  */)"r");
#line 221
    spf[argc1 - b].name = *(argv1 + b);
#line 222
    spf[argc1 - b].line_counter = 1;
    }
#line 223
    if ((unsigned long )spf[argc1 - b].fp == (unsigned long )((void *)0)) {
      {
#line 225
      s = argc1 - b;
#line 226
      error_message(7001);
      }
#line 227
      return (-1);
    }
#line 215
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  yyin = spf[s].fp;
#line 238
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 348 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 354
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 38 "/home/wslee/benchmarks/clif-0.93/printfx.h"
int printfx(char *format  , ...) ;
#line 30 "/home/wslee/benchmarks/clif-0.93/printf_unix.c"
int fprintfx(FILE *stream  , ...) 
{ 
  va_list point___0 ;
  char *format ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 40
  __builtin_va_start(point___0, stream);
#line 45
  tmp___1 = __builtin_va_arg(point___0, char *);
#line 45
  format = tmp___1;
#line 46
  tmp___0 = vfprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)format,
                     point___0);
#line 47
  __builtin_va_end(point___0);
  }
#line 48
  return (tmp___0);
}
}
#line 51 "/home/wslee/benchmarks/clif-0.93/printf_unix.c"
int printfx(char *format  , ...) 
{ 
  va_list point___0 ;
  int tmp___0 ;

  {
  {
#line 60
  __builtin_va_start(point___0, format);
#line 65
  tmp___0 = vprintf((char const   */* __restrict  */)format, point___0);
#line 66
  __builtin_va_end(point___0);
  }
#line 67
  return (tmp___0);
}
}
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 41 "/home/wslee/benchmarks/clif-0.93/allocx.h"
void deallocate(unsigned int a ) ;
#line 45
void *reallocx(void *ptr , unsigned int size ) ;
#line 46
void freex(void *ptr ) ;
#line 67 "/home/wslee/benchmarks/clif-0.93/allocx.c"
static struct pool_chunk first[2]  = {      {(struct pool_chunk *)((void *)0), (char *)0, (char *)0}, 
        {(struct pool_chunk *)((void *)0), (char *)0, (char *)0}};
#line 67 "/home/wslee/benchmarks/clif-0.93/allocx.c"
static struct pool_chunk *pool[2]  = {      & first[0],      & first[1]};
#line 67 "/home/wslee/benchmarks/clif-0.93/allocx.c"
static struct pool_chunk *freeblock  ;
#line 71 "/home/wslee/benchmarks/clif-0.93/allocx.c"
char *callocx(unsigned int n , unsigned int size ) 
{ 
  void *tmp___0 ;

  {
  {
#line 75
  tmp___0 = calloc(n, size);
  }
#line 75
  return ((char *)tmp___0);
}
}
#line 78 "/home/wslee/benchmarks/clif-0.93/allocx.c"
char *allocate(unsigned int n , unsigned int a ) 
{ 
  register struct pool_chunk *cp ;
  unsigned int m ;
  char *tmp___0 ;
  struct pool_chunk *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 85
  if (! ((unsigned long )a < sizeof(pool) / sizeof(pool[0]))) {
    {
#line 85
    __assert_fail("a < sizeof(pool)/sizeof(pool[0])", "/home/wslee/benchmarks/clif-0.93/allocx.c",
                  85U, "allocate");
    }
  }
#line 88
  cp = pool[a];
#line 90
  if (n & 7U) {
#line 91
    n += 8U - (n & 7U);
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! ((unsigned long )(cp->position + n) > (unsigned long )cp->limit)) {
#line 93
      goto while_break;
    }
#line 95
    tmp___1 = freeblock;
#line 95
    cp->next = tmp___1;
#line 95
    if ((unsigned long )((void *)0) != (unsigned long )tmp___1) {
#line 97
      freeblock = freeblock->next;
#line 98
      cp = cp->next;
    } else {
      {
#line 102
      m = (unsigned int )((sizeof(union header ) + (unsigned long )n) + 10240UL);
#line 103
      tmp___0 = callocx(1U, m);
#line 103
      cp->next = (struct pool_chunk *)tmp___0;
#line 104
      cp = cp->next;
      }
#line 105
      if ((unsigned long )((void *)0) == (unsigned long )cp) {
        {
#line 107
        error_message(4002);
#line 108
        exit(1);
        }
      }
#line 110
      cp->limit = (char *)cp + m;
    }
#line 112
    cp->position = (char *)(cp + sizeof(union header ));
#line 113
    cp->next = (struct pool_chunk *)((void *)0);
#line 114
    pool[a] = cp;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  cp->position += n;
#line 117
  return (cp->position - n);
}
}
#line 120 "/home/wslee/benchmarks/clif-0.93/allocx.c"
void deallocate(unsigned int a ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 125
  if (! ((unsigned long )a < sizeof(pool) / sizeof(pool[0]))) {
    {
#line 125
    __assert_fail("a < sizeof(pool)/sizeof(pool[0])", "/home/wslee/benchmarks/clif-0.93/allocx.c",
                  125U, "deallocate");
    }
  }
#line 128
  (pool[a])->next = freeblock;
#line 129
  freeblock = first[a].next;
#line 130
  first[a].next = (struct pool_chunk *)((void *)0);
#line 131
  pool[a] = & first[a];
#line 132
  return;
}
}
#line 134 "/home/wslee/benchmarks/clif-0.93/allocx.c"
void init_zero(char *p , unsigned int n ) 
{ 
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    tmp___1 = n;
#line 139
    n --;
#line 139
    if (! tmp___1) {
#line 139
      goto while_break;
    }
#line 140
    tmp___0 = p;
#line 140
    p ++;
#line 140
    *tmp___0 = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 143 "/home/wslee/benchmarks/clif-0.93/allocx.c"
void *mallocx(unsigned int size ) 
{ 
  register void *res ;
  void *tmp___0 ;

  {
  {
#line 147
  tmp___0 = malloc(size);
#line 147
  res = tmp___0;
  }
#line 149
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 150
    error_message(4002);
    }
  }
#line 151
  return (res);
}
}
#line 154 "/home/wslee/benchmarks/clif-0.93/allocx.c"
void *reallocx(void *ptr , unsigned int size ) 
{ 
  register void *res ;
  void *tmp___0 ;

  {
  {
#line 159
  tmp___0 = realloc(ptr, size);
#line 159
  res = tmp___0;
  }
#line 161
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 162
    error_message(4002);
    }
  }
#line 163
  return (res);
}
}
#line 166 "/home/wslee/benchmarks/clif-0.93/allocx.c"
void freex(void *ptr ) 
{ 


  {
  {
#line 170
  free(ptr);
  }
#line 170
  return;
}
}
#line 819 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 65 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 41 "/home/wslee/benchmarks/clif-0.93/global.h"
int char_counter ;
#line 42
char line_buf[10000] ;
#line 44
char *mem_start ;
#line 45
char *stack ;
#line 46
char *bp ;
#line 49
char *frame ;
#line 53
char **ast ;
#line 54
char *pc ;
#line 57
char *fixst ;
#line 61
char *tmp ;
#line 62
char *tmph ;
#line 66
char *tmp_start ;
#line 69
char *proc_name[256] ;
#line 89
int dim[256] ;
#line 90
int poc ;
#line 107
struct return1 *rp ;
#line 111
char *kodp1 ;
#line 113
char *kodp2 ;
#line 131
union fix *fixp ;
#line 30 "/home/wslee/benchmarks/clif-0.93/comp_maint.h"
int implicit_cast(void) ;
#line 32
int l_value_cast(void) ;
#line 36
void retfix(void) ;
#line 40
int cofix(void) ;
#line 44
int brfix(void) ;
#line 47
void fix_cont_w(void) ;
#line 50
void fix_cont_f(void) ;
#line 53
void fix_break_w(void) ;
#line 56
void fix_break_f(void) ;
#line 59
void fix_ret(void) ;
#line 62
void fix_break_s(void) ;
#line 64
int add_to_spec_list(void) ;
#line 66
void search_duplicate_labels(void) ;
#line 67
int add_constant_to_list(int int_const ) ;
#line 68
void add_default_to_fixp(void) ;
#line 69
int yyerror(char *s___0 ) ;
#line 70
void func_def_s(void) ;
#line 71
void func_def_r(void) ;
#line 72
void enter_scope(void) ;
#line 73
void exit_scope(void) ;
#line 76
int verbose ;
#line 78
void move2lvalue(void) ;
#line 85
void clear_internal_type(struct internal_type *def ) ;
#line 90
void put_array_subscript(struct internal_type **identtab_type ) ;
#line 94
int compare2trees(struct internal_type *table , struct internal_type *def ) ;
#line 96
int type_transform(enum intern_arit_class type , enum intern_func_class typec , int flag___0 ) ;
#line 99
void clif(int argc , char **argv ) ;
#line 119
int error_line_number ;
#line 122 "/home/wslee/benchmarks/clif-0.93/comp_maint.h"
int error_count  ;
#line 127 "/home/wslee/benchmarks/clif-0.93/comp_maint.h"
struct internal_type *l_type_spec  ;
#line 131 "/home/wslee/benchmarks/clif-0.93/comp_maint.h"
struct ident_list_str *ident_list  ;
#line 137
void put2table(char *name___0 , struct internal_type *type ) ;
#line 140
int get_num_args(struct internal_type *type ) ;
#line 143
void promote_type(void) ;
#line 145
void check_spec_constr(struct internal_type *type , char *name___0 ) ;
#line 1 "/home/wslee/benchmarks/clif-0.93/version.h"
char version[5]  = {      (char )'0',      (char )'.',      (char )'9',      (char )'3', 
        (char )'\000'};
#line 36 "/home/wslee/benchmarks/clif-0.93/ys.h"
int yyparse(void) ;
#line 36 "/home/wslee/benchmarks/clif-0.93/run_str.h"
char *argvv[100] ;
#line 37
int argc_counter ;
#line 38
int yy_rs_parse(void) ;
#line 41
void init_rs(int argc1 , char **argv1 ) ;
#line 37 "/home/wslee/benchmarks/clif-0.93/ls.h"
extern char yytext[] ;
#line 37 "/home/wslee/benchmarks/clif-0.93/tables.h"
int hastab_init(void) ;
#line 38
int identtab_init(void) ;
#line 39
int hastab_goto_init(void) ;
#line 51
int has(char *var_name ) ;
#line 53
int has_loc(int type , char *var_name ) ;
#line 58
void clear_hash_tab(void) ;
#line 59
void clear_tag_tab(void) ;
#line 99
void enter_file_scope(void) ;
#line 103
int get_declaration_line(char *name___0 ) ;
#line 29 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_comment  ;
#line 32 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_format  ;
#line 35 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_implicit  ;
#line 38 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_inhibit  ;
#line 42 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_return_type  ;
#line 45 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_trigraphs  ;
#line 48 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_unused  ;
#line 51 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_uninitialized  ;
#line 54 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_extra  ;
#line 57 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warning_aggregate_return  ;
#line 60 "/home/wslee/benchmarks/clif-0.93/flags.h"
int warnings_are_errors  ;
#line 69 "/home/wslee/benchmarks/clif-0.93/flags.h"
int handle_main  ;
#line 72 "/home/wslee/benchmarks/clif-0.93/flags.h"
int call_by_value  ;
#line 78 "/home/wslee/benchmarks/clif-0.93/flags.h"
int dbg_symbols  ;
#line 36 "/home/wslee/benchmarks/clif-0.93/virtual_machine.h"
int exec(void) ;
#line 63 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static void print_file_name(void) ;
#line 67
static void print_source_line(void) ;
#line 69
static void print_error_number(int err_no ) ;
#line 70
static void print_line_number(int line_no ) ;
#line 71
static char *type2string(struct internal_type *type ) ;
#line 73
static void info(void) ;
#line 76
static int init(void) ;
#line 80
static int hierarchy(int t ) ;
#line 84
static int pointer_cast(void) ;
#line 88
static int add_subs_to_spec_list(struct internal_type **type ) ;
#line 93 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int func_def_f  =    0;
#line 95
static void mov2lvalue(struct internal_type *typec , enum intern_arit_class type ) ;
#line 99
static struct internal_type *copy_type(struct internal_type *type ) ;
#line 103
static int type_compare(struct internal_type *type1 , struct internal_type *type2 ) ;
#line 107
static struct internal_type *cyclic_def(struct internal_type *type1 , struct internal_type *type2 ) ;
#line 111
static int start_main(void) ;
#line 116 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int source_line_number  =    0;
#line 119 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int error_line_number  =    0;
#line 126 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int warning_yes  =    0;
#line 165 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int no_compile_only  =    1;
#line 175 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int call_by_reference  =    1;
#line 182 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int pri[514]  ;
#line 192 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
FILEATTR pf  ;
#line 192 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
FILEATTR spf[100]  ;
#line 194 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
FILE *cop  ;
#line 204 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int bc  =    10;
#line 212 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static struct list_const1 *tmp_m  ;
#line 212 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static struct list_const1 *tmp_c  ;
#line 214 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int scope_level  =    0;
#line 215 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int verbose  =    0;
#line 217 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
char *_clif_debug  ;
#line 221 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
jmp_buf jmpbuf  ;
#line 227 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static void info(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 230
  fprintfx(stderr, "\t\t\tC-like Interpreter Framework Clif\n");
#line 232
  fprintfx(stderr, "\t\t\tVersion %s\n", version);
#line 233
  fprintfx(stderr, "\t\t\tFor help run with parameter -help\n");
#line 234
  fprintfx(stderr, "\t\t\tCopyright (c) 1992 - 1998\n");
#line 235
  fprintfx(stderr, "\t\t\tHruz Tomas and Koren Ludovit\n");
#line 236
  fprintfx(stderr, "\t\t\tClif comes with ABSOLUTELY NO WARRANTY;\n");
#line 237
  fprintfx(stderr, "\t\t\tfor details type clif -w .\n");
#line 238
  fprintfx(stderr, "\t\t\tThis is free software, and you are welcome\n");
#line 239
  fprintfx(stderr, "\t\t\tto redistribute it under certain conditions;\n");
#line 240
  fprintfx(stderr, "\t\t\ttype clif -c for details.\n\n");
  }
#line 241
  return;
}
}
#line 243 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void clif(int argc , char **argv ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;

  {
  {
#line 252
  init_rs(argc, argv);
#line 253
  tmp___0 = yy_rs_parse();
  }
#line 253
  if (-1 == tmp___0) {
#line 254
    return;
  }
#line 255
  if (verbose) {
    {
#line 257
    info();
#line 258
    printfx((char *)"\nThis is interpreter Clif \n\n");
    }
  }
  {
#line 264
  tmp___1 = init();
  }
#line 264
  if (0 == tmp___1) {
#line 265
    return;
  }
  {
#line 266
  argc_counter ++;
#line 266
  tmp___2 = init_input(argc_counter, argvv);
  }
#line 266
  if (-1 == tmp___2) {
#line 268
    return;
  }
#line 270
  if (1 == call_by_reference) {
#line 270
    if (1 == call_by_value) {
      {
#line 272
      error_message(7002);
      }
    }
  }
  {
#line 274
  fatal_handler_register();
#line 277
  tmp___3 = _setjmp((struct __jmp_buf_tag *)(jmpbuf));
  }
#line 277
  if (tmp___3) {
#line 278
    return;
  }
  {
#line 283
  yyparse();
  }
#line 285
  if (handle_main) {
#line 285
    if (no_compile_only) {
      {
#line 287
      tmp___4 = start_main();
      }
#line 287
      if (tmp___4) {
#line 288
        return;
      }
      {
#line 290
      virtual_machine_suspended = 0;
#line 292
      exec();
      }
    }
  }
#line 294
  return;
}
}
#line 309 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int brfix(void) 
{ 
  union fix *fixp_arch ;
  struct break1 *bp___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct break1 *bp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct break1 *bp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 314
  fixp_arch = fixp;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (291 == fixp->if1.major)) {
#line 319
      goto while_break;
    }
#line 320
    fixp --;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if ((unsigned long )fixp == (unsigned long )((union fix *)fixst)) {
    {
#line 324
    error_message(3000);
#line 325
    fixp = fixp_arch;
    }
#line 326
    return (-1);
  }
#line 328
  if (295 == fixp->while1.major) {
#line 332
    if ((unsigned long )((void *)0) == (unsigned long )fixp->while1.bnext) {
      {
#line 337
      tmp___0 = allocate((unsigned int )sizeof(struct break1 ), 1U);
#line 337
      fixp->while1.bnext = (struct break1 *)tmp___0;
#line 339
      (fixp->while1.bnext)->adr = kodp;
#line 340
      (fixp->while1.bnext)->next = (struct break1 *)((void *)0);
      }
    } else {
#line 344
      bp___0 = fixp->while1.bnext;
      {
#line 345
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 345
        if (! ((unsigned long )((void *)0) != (unsigned long )bp___0->next)) {
#line 345
          goto while_break___0;
        }
#line 346
        bp___0 = bp___0->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 350
      tmp___1 = allocate((unsigned int )sizeof(struct break1 ), 1U);
#line 350
      bp___0->next = (struct break1 *)tmp___1;
#line 352
      (bp___0->next)->adr = kodp;
#line 353
      (bp___0->next)->next = (struct break1 *)((void *)0);
      }
    }
  }
#line 356
  if (296 == fixp->for1.major) {
#line 360
    if ((unsigned long )((void *)0) == (unsigned long )fixp->for1.bnext) {
      {
#line 365
      tmp___2 = allocate((unsigned int )sizeof(struct break1 ), 1U);
#line 365
      fixp->for1.bnext = (struct break1 *)tmp___2;
#line 367
      (fixp->for1.bnext)->adr = kodp;
#line 368
      (fixp->for1.bnext)->next = (struct break1 *)((void *)0);
      }
    } else {
#line 372
      bp___1 = fixp->for1.bnext;
      {
#line 373
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 373
        if (! ((unsigned long )((void *)0) != (unsigned long )bp___1->next)) {
#line 373
          goto while_break___1;
        }
#line 374
        bp___1 = bp___1->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 378
      tmp___3 = allocate((unsigned int )sizeof(struct break1 ), 1U);
#line 378
      bp___1->next = (struct break1 *)tmp___3;
#line 380
      (bp___1->next)->adr = kodp;
#line 381
      (bp___1->next)->next = (struct break1 *)((void *)0);
      }
    }
  }
#line 384
  if (294 == fixp->switch1.major) {
#line 388
    if ((unsigned long )((void *)0) == (unsigned long )fixp->switch1.bnext) {
      {
#line 393
      tmp___4 = allocate((unsigned int )sizeof(struct break1 ), 1U);
#line 393
      fixp->switch1.bnext = (struct break1 *)tmp___4;
#line 395
      (fixp->switch1.bnext)->adr = kodp;
#line 396
      (fixp->switch1.bnext)->next = (struct break1 *)((void *)0);
      }
    } else {
#line 400
      bp___2 = fixp->switch1.bnext;
      {
#line 401
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 401
        if (! ((unsigned long )((void *)0) != (unsigned long )bp___2->next)) {
#line 401
          goto while_break___2;
        }
#line 402
        bp___2 = bp___2->next;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 406
      tmp___5 = allocate((unsigned int )sizeof(struct break1 ), 1U);
#line 406
      bp___2->next = (struct break1 *)tmp___5;
#line 408
      (bp___2->next)->adr = kodp;
#line 409
      (bp___2->next)->next = (struct break1 *)((void *)0);
      }
    }
  }
#line 412
  fixp = fixp_arch;
#line 413
  return (0);
}
}
#line 420 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int cofix(void) 
{ 
  union fix *fixp_arch ;
  struct cont1 *cp ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct cont1 *cp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 426
  fixp_arch = fixp;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (291 == fixp->if1.major)) {
#line 428
      goto while_break;
    }
#line 429
    fixp --;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  if ((unsigned long )fixp == (unsigned long )((union fix *)fixst)) {
    {
#line 433
    error_message(3001);
    }
#line 434
    return (-1);
  }
#line 436
  if (295 == fixp->while1.major) {
#line 440
    if ((unsigned long )((void *)0) == (unsigned long )fixp->while1.cnext) {
      {
#line 445
      tmp___0 = allocate((unsigned int )sizeof(struct cont1 ), 1U);
#line 445
      fixp->while1.cnext = (struct cont1 *)tmp___0;
#line 447
      (fixp->while1.cnext)->adr = kodp;
#line 448
      (fixp->while1.cnext)->next = (struct cont1 *)((void *)0);
      }
    } else {
#line 452
      cp = fixp->while1.cnext;
      {
#line 453
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 453
        if (! ((unsigned long )((void *)0) != (unsigned long )cp->next)) {
#line 453
          goto while_break___0;
        }
#line 454
        cp = cp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 459
      tmp___1 = allocate((unsigned int )sizeof(struct cont1 ), 1U);
#line 459
      cp->next = (struct cont1 *)tmp___1;
#line 461
      (cp->next)->adr = kodp;
#line 462
      (cp->next)->next = (struct cont1 *)((void *)0);
      }
    }
  }
#line 465
  if (296 == fixp->for1.major) {
#line 469
    if ((unsigned long )((void *)0) == (unsigned long )fixp->for1.cnext) {
      {
#line 474
      tmp___2 = allocate((unsigned int )sizeof(struct cont1 ), 1U);
#line 474
      fixp->for1.cnext = (struct cont1 *)tmp___2;
#line 476
      (fixp->for1.cnext)->adr = kodp;
#line 477
      (fixp->for1.cnext)->next = (struct cont1 *)((void *)0);
      }
    } else {
#line 481
      cp___0 = fixp->for1.cnext;
      {
#line 482
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 482
        if (! ((unsigned long )((void *)0) != (unsigned long )cp___0->next)) {
#line 482
          goto while_break___1;
        }
#line 483
        cp___0 = cp___0->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 487
      tmp___3 = allocate((unsigned int )sizeof(struct cont1 ), 1U);
#line 487
      cp___0->next = (struct cont1 *)tmp___3;
#line 489
      (cp___0->next)->adr = kodp;
#line 490
      (cp___0->next)->next = (struct cont1 *)((void *)0);
      }
    }
  }
#line 493
  fixp = fixp_arch;
#line 494
  return (0);
}
}
#line 500 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void retfix(void) 
{ 
  struct return1 *arch ;
  struct return1 *arch1 ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 505
  arch = rp;
#line 507
  if ((unsigned long )((void *)0) == (unsigned long )rp) {
    {
#line 512
    tmp___0 = allocate((unsigned int )sizeof(struct return1 ), 1U);
#line 512
    rp = (struct return1 *)tmp___0;
#line 514
    rp->adr = kodp;
#line 515
    rp->next = (struct return1 *)((void *)0);
    }
  } else {
    {
#line 519
    while (1) {
      while_continue: /* CIL Label */ ;
#line 519
      if (! ((unsigned long )((void *)0) != (unsigned long )rp)) {
#line 519
        goto while_break;
      }
#line 521
      arch1 = rp;
#line 522
      rp = rp->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 527
    tmp___1 = allocate((unsigned int )sizeof(struct return1 ), 1U);
#line 527
    rp = (struct return1 *)tmp___1;
#line 529
    rp->adr = kodp;
#line 530
    arch1->next = rp;
#line 531
    rp->next = (struct return1 *)((void *)0);
#line 532
    rp = arch;
    }
  }
#line 534
  return;
}
}
#line 539 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void fix_cont_w(void) 
{ 


  {
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 542
    if (! ((unsigned long )((void *)0) != (unsigned long )fixp->while1.cnext)) {
#line 542
      goto while_break;
    }
#line 548
    ((struct OPERAND_1_ma *)(fixp->while1.cnext)->adr)->adr = fixp->while1.jmp;
#line 550
    fixp->while1.cnext = (fixp->while1.cnext)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return;
}
}
#line 560 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void fix_cont_f(void) 
{ 


  {
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! ((unsigned long )((void *)0) != (unsigned long )fixp->for1.cnext)) {
#line 563
      goto while_break;
    }
#line 569
    ((struct OPERAND_1_ma *)(fixp->for1.cnext)->adr)->adr = fixp->for1.jmp3;
#line 571
    fixp->for1.cnext = (fixp->for1.cnext)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  return;
}
}
#line 581 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void fix_break_w(void) 
{ 


  {
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! ((unsigned long )((void *)0) != (unsigned long )fixp->while1.bnext)) {
#line 585
      goto while_break;
    }
#line 591
    ((struct OPERAND_1_ma *)(fixp->while1.bnext)->adr)->adr = kodp;
#line 592
    fixp->while1.bnext = (fixp->while1.bnext)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 600
  return;
}
}
#line 605 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void fix_break_f(void) 
{ 


  {
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! ((unsigned long )((void *)0) != (unsigned long )fixp->for1.bnext)) {
#line 608
      goto while_break;
    }
#line 614
    ((struct OPERAND_1_ma *)(fixp->for1.bnext)->adr)->adr = kodp;
#line 615
    fixp->for1.bnext = (fixp->for1.bnext)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  return;
}
}
#line 625 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void fix_ret(void) 
{ 


  {
#line 628
  if ((unsigned long )((void *)0) == (unsigned long )rp) {
#line 628
    if (! (1U & (unsigned int )((type_com[set])->output)->attribute.arit_class)) {
      {
#line 630
      error_message(6028);
      }
#line 631
      return;
    }
  }
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    if (! ((unsigned long )((void *)0) != (unsigned long )rp)) {
#line 634
      goto while_break;
    }
#line 636
    ((struct OPERAND_1_ma *)rp->adr)->adr = kodp;
#line 637
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  return;
}
}
#line 647 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void fix_break_s(void) 
{ 


  {
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! ((unsigned long )((void *)0) != (unsigned long )fixp->switch1.bnext)) {
#line 650
      goto while_break;
    }
#line 656
    ((struct OPERAND_1_ma *)(fixp->switch1.bnext)->adr)->adr = kodp;
#line 657
    fixp->switch1.bnext = (fixp->switch1.bnext)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  return;
}
}
#line 667 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int init(void) 
{ 
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 670
  tmp___0 = callocx((unsigned int )(bc * 210), 512U);
#line 670
  mem_start = tmp___0;
  }
#line 671
  if ((unsigned long )((void *)0) == (unsigned long )mem_start) {
    {
#line 673
    error_message(4000);
    }
#line 674
    return (0);
  }
  {
#line 676
  stack = mem_start + (bc * 210) * 512;
#line 677
  bp = stack;
#line 678
  frame = stack;
#line 679
  pc = mem_start;
#line 680
  kodp = mem_start;
#line 681
  kodp1 = kodp;
#line 682
  kodp2 = kodp;
#line 683
  current_instr = kodp;
#line 688
  tmp___1 = hastab_init();
  }
#line 688
  if (! tmp___1) {
#line 689
    return (0);
  }
  {
#line 690
  tmp___2 = identtab_init();
  }
#line 690
  if (! tmp___2) {
#line 691
    return (0);
  }
  {
#line 693
  tmp___3 = callocx(1999U, (unsigned int )sizeof(struct remote_has_tab ));
#line 693
  hastab_remote = (struct remote_has_tab *)tmp___3;
  }
#line 695
  if ((unsigned long )((void *)0) == (unsigned long )hastab_remote) {
    {
#line 697
    error_message(4000);
    }
#line 698
    return (0);
  }
  {
#line 703
  tmp___4 = callocx((unsigned int )(bc * 7), (unsigned int )(512UL * sizeof(char *)));
#line 703
  ast = (char **)tmp___4;
  }
#line 704
  if ((unsigned long )((void *)0) == (unsigned long )ast) {
    {
#line 706
    error_message(4000);
    }
#line 707
    return (0);
  }
  {
#line 709
  ast += (bc * 7) * 512;
#line 713
  tmp___5 = callocx((unsigned int )(bc * 52), 512U);
#line 713
  tmp = tmp___5;
  }
#line 714
  if ((unsigned long )((void *)0) == (unsigned long )tmp) {
    {
#line 716
    error_message(4000);
    }
#line 717
    return (0);
  }
  {
#line 719
  tmp += (bc * 52) * 512;
#line 720
  tmp_start = tmp;
#line 721
  tmph = tmp;
#line 725
  pri[1] = 12;
#line 726
  pri[130] = 11;
#line 726
  pri[2] = pri[130];
#line 727
  pri[258] = 10;
#line 728
  pri[140] = 9;
#line 728
  pri[12] = pri[140];
#line 729
  pri[268] = 8;
#line 730
  pri[136] = 7;
#line 730
  pri[8] = pri[136];
#line 731
  pri[264] = 6;
#line 732
  pri[152] = 5;
#line 732
  pri[24] = pri[152];
#line 733
  pri[280] = 4;
#line 734
  pri[32] = 3;
#line 735
  pri[64] = 2;
#line 736
  pri[80] = 1;
#line 740
  dim[0] = -1;
#line 741
  fixst = callocx(256U, (unsigned int )sizeof(union fix ));
  }
#line 742
  if ((unsigned long )((void *)0) == (unsigned long )fixst) {
    {
#line 744
    error_message(4000);
    }
#line 745
    return (0);
  }
  {
#line 747
  fixp = (union fix *)fixst;
#line 753
  tmp___6 = hastab_goto_init();
  }
#line 753
  if (! tmp___6) {
#line 754
    return (0);
  }
#line 776
  return (1);
}
}
#line 786 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int yyerror(char *s___0 ) 
{ 


  {
#line 793
  return (0);
}
}
#line 799 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int hierarchy(int t ) 
{ 


  {
#line 803
  return (pri[t]);
}
}
#line 809 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int implicit_cast(void) 
{ 
  enum intern_arit_class tmp___0 ;
  enum intern_arit_class tmp___1 ;
  enum intern_arit_class tmp___2 ;
  enum intern_arit_class tmp___3 ;
  enum intern_arit_class tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 812
  if ((unsigned int )(type_com[set])->attribute.type_qualifier != (unsigned int )(type_com[set - 1])->attribute.type_qualifier) {
    {
#line 817
    if ((unsigned int )(type_com[set - 1])->attribute.type_qualifier == 285U) {
#line 817
      goto case_285;
    }
#line 820
    goto switch_default;
    case_285: /* CIL Label */ 
#line 818
    type_com[set - 1] = type_com[set];
#line 819
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 821
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 824
  tmp___7 = hierarchy((int )type_ac[set]);
#line 824
  tmp___8 = hierarchy((int )type_ac[set - 1]);
  }
#line 824
  if (tmp___7 < tmp___8) {
    {
#line 828
    if ((unsigned int )type_ac[set] == 80U) {
#line 828
      goto case_80;
    }
#line 878
    if ((unsigned int )type_ac[set] == 64U) {
#line 878
      goto case_64___0;
    }
#line 925
    if ((unsigned int )type_ac[set] == 32U) {
#line 925
      goto case_32___1;
    }
#line 969
    if ((unsigned int )type_ac[set] == 280U) {
#line 969
      goto case_280___2;
    }
#line 1008
    if ((unsigned int )type_ac[set] == 152U) {
#line 1008
      goto case_152___3;
    }
#line 1008
    if ((unsigned int )type_ac[set] == 24U) {
#line 1008
      goto case_152___3;
    }
#line 1056
    if ((unsigned int )type_ac[set] == 264U) {
#line 1056
      goto case_264___4;
    }
#line 1085
    if ((unsigned int )type_ac[set] == 136U) {
#line 1085
      goto case_136___5;
    }
#line 1085
    if ((unsigned int )type_ac[set] == 8U) {
#line 1085
      goto case_136___5;
    }
#line 1116
    if ((unsigned int )type_ac[set] == 140U) {
#line 1116
      goto case_140___6;
    }
#line 1116
    if ((unsigned int )type_ac[set] == 12U) {
#line 1116
      goto case_140___6;
    }
#line 1190
    if ((unsigned int )type_ac[set] == 268U) {
#line 1190
      goto case_268___6;
    }
#line 1264
    if ((unsigned int )type_ac[set] == 2U) {
#line 1264
      goto case_2___8;
    }
#line 1338
    if ((unsigned int )type_ac[set] == 130U) {
#line 1338
      goto case_130___9;
    }
#line 1412
    if ((unsigned int )type_ac[set] == 258U) {
#line 1412
      goto case_258___10;
    }
#line 1486
    goto switch_default___12;
    case_80: /* CIL Label */ 
    {
#line 832
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 832
      goto case_136;
    }
#line 832
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 832
      goto case_136;
    }
#line 835
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 835
      goto case_264;
    }
#line 839
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 839
      goto case_152;
    }
#line 839
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 839
      goto case_152;
    }
#line 843
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 843
      goto case_140;
    }
#line 843
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 843
      goto case_140;
    }
#line 846
    if ((unsigned int )type_ac[set - 1] == 280U) {
#line 846
      goto case_280;
    }
#line 849
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 849
      goto case_268;
    }
#line 852
    if ((unsigned int )type_ac[set - 1] == 64U) {
#line 852
      goto case_64;
    }
#line 855
    if ((unsigned int )type_ac[set - 1] == 32U) {
#line 855
      goto case_32;
    }
#line 858
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 858
      goto case_2;
    }
#line 861
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 861
      goto case_130;
    }
#line 864
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 864
      goto case_258;
    }
#line 867
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 867
      goto case_1;
    }
#line 870
    goto switch_default___0;
    case_136: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 833
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 833
    ((struct OPERAND_0_mi *)kodp)->minor = 167;
#line 833
    kodp += sizeof(struct OPERAND_0_mi );
#line 834
    goto switch_break___1;
    case_264: /* CIL Label */ 
#line 836
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 836
    ((struct OPERAND_0_mi *)kodp)->minor = 169;
#line 836
    kodp += sizeof(struct OPERAND_0_mi );
#line 837
    goto switch_break___1;
    case_152: /* CIL Label */ 
    case_24: /* CIL Label */ 
#line 840
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 840
    ((struct OPERAND_0_mi *)kodp)->minor = 167;
#line 840
    kodp += sizeof(struct OPERAND_0_mi );
#line 841
    goto switch_break___1;
    case_140: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 844
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 844
    ((struct OPERAND_0_mi *)kodp)->minor = 173;
#line 844
    kodp += sizeof(struct OPERAND_0_mi );
#line 845
    goto switch_break___1;
    case_280: /* CIL Label */ 
#line 847
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 847
    ((struct OPERAND_0_mi *)kodp)->minor = 169;
#line 847
    kodp += sizeof(struct OPERAND_0_mi );
#line 848
    goto switch_break___1;
    case_268: /* CIL Label */ 
#line 850
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 850
    ((struct OPERAND_0_mi *)kodp)->minor = 177;
#line 850
    kodp += sizeof(struct OPERAND_0_mi );
#line 851
    goto switch_break___1;
    case_64: /* CIL Label */ 
#line 853
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 853
    ((struct OPERAND_0_mi *)kodp)->minor = 179;
#line 853
    kodp += sizeof(struct OPERAND_0_mi );
#line 854
    goto switch_break___1;
    case_32: /* CIL Label */ 
#line 856
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 856
    ((struct OPERAND_0_mi *)kodp)->minor = 181;
#line 856
    kodp += sizeof(struct OPERAND_0_mi );
#line 857
    goto switch_break___1;
    case_2: /* CIL Label */ 
#line 859
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 859
    ((struct OPERAND_0_mi *)kodp)->minor = 183;
#line 859
    kodp += sizeof(struct OPERAND_0_mi );
#line 860
    goto switch_break___1;
    case_130: /* CIL Label */ 
#line 862
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 862
    ((struct OPERAND_0_mi *)kodp)->minor = 185;
#line 862
    kodp += sizeof(struct OPERAND_0_mi );
#line 863
    goto switch_break___1;
    case_258: /* CIL Label */ 
#line 865
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 865
    ((struct OPERAND_0_mi *)kodp)->minor = 187;
#line 865
    kodp += sizeof(struct OPERAND_0_mi );
#line 866
    goto switch_break___1;
    case_1: /* CIL Label */ 
    {
#line 868
    error_message(1009);
    }
#line 869
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 871
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             871);
#line 872
    error_message(5000);
#line 873
    abort();
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 875
    type_ac[set - 1] = (enum intern_arit_class )80;
#line 876
    last_instr = current_instr;
#line 876
    current_instr = kodp;
#line 877
    return (1);
    case_64___0: /* CIL Label */ 
    {
#line 882
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 882
      goto case_136___0;
    }
#line 882
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 882
      goto case_136___0;
    }
#line 885
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 885
      goto case_264___0;
    }
#line 889
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 889
      goto case_152___0;
    }
#line 889
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 889
      goto case_152___0;
    }
#line 893
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 893
      goto case_140___0;
    }
#line 893
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 893
      goto case_140___0;
    }
#line 896
    if ((unsigned int )type_ac[set - 1] == 280U) {
#line 896
      goto case_280___0;
    }
#line 899
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 899
      goto case_268___0;
    }
#line 902
    if ((unsigned int )type_ac[set - 1] == 32U) {
#line 902
      goto case_32___0;
    }
#line 905
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 905
      goto case_2___0;
    }
#line 908
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 908
      goto case_130___0;
    }
#line 911
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 911
      goto case_258___0;
    }
#line 914
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 914
      goto case_1___0;
    }
#line 917
    goto switch_default___1;
    case_136___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
#line 883
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 883
    ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 883
    kodp += sizeof(struct OPERAND_0_mi );
#line 884
    goto switch_break___2;
    case_264___0: /* CIL Label */ 
#line 886
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 886
    ((struct OPERAND_0_mi *)kodp)->minor = 19;
#line 886
    kodp += sizeof(struct OPERAND_0_mi );
#line 887
    goto switch_break___2;
    case_152___0: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
#line 890
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 890
    ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 890
    kodp += sizeof(struct OPERAND_0_mi );
#line 891
    goto switch_break___2;
    case_140___0: /* CIL Label */ 
    case_12___0: /* CIL Label */ 
#line 894
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 894
    ((struct OPERAND_0_mi *)kodp)->minor = 58;
#line 894
    kodp += sizeof(struct OPERAND_0_mi );
#line 895
    goto switch_break___2;
    case_280___0: /* CIL Label */ 
#line 897
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 897
    ((struct OPERAND_0_mi *)kodp)->minor = 19;
#line 897
    kodp += sizeof(struct OPERAND_0_mi );
#line 898
    goto switch_break___2;
    case_268___0: /* CIL Label */ 
#line 900
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 900
    ((struct OPERAND_0_mi *)kodp)->minor = 74;
#line 900
    kodp += sizeof(struct OPERAND_0_mi );
#line 901
    goto switch_break___2;
    case_32___0: /* CIL Label */ 
#line 903
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 903
    ((struct OPERAND_0_mi *)kodp)->minor = 7;
#line 903
    kodp += sizeof(struct OPERAND_0_mi );
#line 904
    goto switch_break___2;
    case_2___0: /* CIL Label */ 
#line 906
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 906
    ((struct OPERAND_0_mi *)kodp)->minor = 13;
#line 906
    kodp += sizeof(struct OPERAND_0_mi );
#line 907
    goto switch_break___2;
    case_130___0: /* CIL Label */ 
#line 909
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 909
    ((struct OPERAND_0_mi *)kodp)->minor = 100;
#line 909
    kodp += sizeof(struct OPERAND_0_mi );
#line 910
    goto switch_break___2;
    case_258___0: /* CIL Label */ 
#line 912
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 912
    ((struct OPERAND_0_mi *)kodp)->minor = 116;
#line 912
    kodp += sizeof(struct OPERAND_0_mi );
#line 913
    goto switch_break___2;
    case_1___0: /* CIL Label */ 
    {
#line 915
    error_message(1009);
    }
#line 916
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 918
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             918);
#line 919
    error_message(5000);
#line 920
    abort();
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 922
    type_ac[set - 1] = (enum intern_arit_class )64;
#line 923
    last_instr = current_instr;
#line 923
    current_instr = kodp;
#line 924
    return (1);
    case_32___1: /* CIL Label */ 
    {
#line 929
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 929
      goto case_136___1;
    }
#line 929
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 929
      goto case_136___1;
    }
#line 932
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 932
      goto case_264___1;
    }
#line 936
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 936
      goto case_152___1;
    }
#line 936
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 936
      goto case_152___1;
    }
#line 940
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 940
      goto case_140___1;
    }
#line 940
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 940
      goto case_140___1;
    }
#line 943
    if ((unsigned int )type_ac[set - 1] == 280U) {
#line 943
      goto case_280___1;
    }
#line 946
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 946
      goto case_268___1;
    }
#line 949
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 949
      goto case_2___1;
    }
#line 952
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 952
      goto case_130___1;
    }
#line 955
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 955
      goto case_258___1;
    }
#line 958
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 958
      goto case_1___1;
    }
#line 961
    goto switch_default___2;
    case_136___1: /* CIL Label */ 
    case_8___1: /* CIL Label */ 
#line 930
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 930
    ((struct OPERAND_0_mi *)kodp)->minor = 4;
#line 930
    kodp += sizeof(struct OPERAND_0_mi );
#line 931
    goto switch_break___3;
    case_264___1: /* CIL Label */ 
#line 933
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 933
    ((struct OPERAND_0_mi *)kodp)->minor = 21;
#line 933
    kodp += sizeof(struct OPERAND_0_mi );
#line 934
    goto switch_break___3;
    case_152___1: /* CIL Label */ 
    case_24___1: /* CIL Label */ 
#line 937
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 937
    ((struct OPERAND_0_mi *)kodp)->minor = 4;
#line 937
    kodp += sizeof(struct OPERAND_0_mi );
#line 938
    goto switch_break___3;
    case_140___1: /* CIL Label */ 
    case_12___1: /* CIL Label */ 
#line 941
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 941
    ((struct OPERAND_0_mi *)kodp)->minor = 60;
#line 941
    kodp += sizeof(struct OPERAND_0_mi );
#line 942
    goto switch_break___3;
    case_280___1: /* CIL Label */ 
#line 944
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 944
    ((struct OPERAND_0_mi *)kodp)->minor = 21;
#line 944
    kodp += sizeof(struct OPERAND_0_mi );
#line 945
    goto switch_break___3;
    case_268___1: /* CIL Label */ 
#line 947
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 947
    ((struct OPERAND_0_mi *)kodp)->minor = 76;
#line 947
    kodp += sizeof(struct OPERAND_0_mi );
#line 948
    goto switch_break___3;
    case_2___1: /* CIL Label */ 
#line 950
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 950
    ((struct OPERAND_0_mi *)kodp)->minor = 16;
#line 950
    kodp += sizeof(struct OPERAND_0_mi );
#line 951
    goto switch_break___3;
    case_130___1: /* CIL Label */ 
#line 953
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 953
    ((struct OPERAND_0_mi *)kodp)->minor = 102;
#line 953
    kodp += sizeof(struct OPERAND_0_mi );
#line 954
    goto switch_break___3;
    case_258___1: /* CIL Label */ 
#line 956
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 956
    ((struct OPERAND_0_mi *)kodp)->minor = 118;
#line 956
    kodp += sizeof(struct OPERAND_0_mi );
#line 957
    goto switch_break___3;
    case_1___1: /* CIL Label */ 
    {
#line 959
    error_message(1009);
    }
#line 960
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
    {
#line 962
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             962);
#line 963
    error_message(5000);
#line 964
    abort();
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 966
    type_ac[set - 1] = (enum intern_arit_class )32;
#line 967
    last_instr = current_instr;
#line 967
    current_instr = kodp;
#line 968
    return (1);
    case_280___2: /* CIL Label */ 
    {
#line 973
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 973
      goto case_136___2;
    }
#line 973
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 973
      goto case_136___2;
    }
#line 976
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 976
      goto case_264___2;
    }
#line 980
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 980
      goto case_152___2;
    }
#line 980
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 980
      goto case_152___2;
    }
#line 984
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 984
      goto case_140___2;
    }
#line 984
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 984
      goto case_140___2;
    }
#line 987
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 987
      goto case_268___2;
    }
#line 990
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 990
      goto case_2___2;
    }
#line 993
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 993
      goto case_130___2;
    }
#line 996
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 996
      goto case_258___2;
    }
#line 999
    goto switch_default___3;
    case_136___2: /* CIL Label */ 
    case_8___2: /* CIL Label */ 
#line 974
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 974
    ((struct OPERAND_0_mi *)kodp)->minor = 150;
#line 974
    kodp += sizeof(struct OPERAND_0_mi );
#line 975
    goto switch_break___4;
    case_264___2: /* CIL Label */ ;
#line 978
    goto switch_break___4;
    case_152___2: /* CIL Label */ 
    case_24___2: /* CIL Label */ 
#line 981
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 981
    ((struct OPERAND_0_mi *)kodp)->minor = 150;
#line 981
    kodp += sizeof(struct OPERAND_0_mi );
#line 982
    goto switch_break___4;
    case_140___2: /* CIL Label */ 
    case_12___2: /* CIL Label */ 
#line 985
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 985
    ((struct OPERAND_0_mi *)kodp)->minor = 64;
#line 985
    kodp += sizeof(struct OPERAND_0_mi );
#line 986
    goto switch_break___4;
    case_268___2: /* CIL Label */ 
#line 988
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 988
    ((struct OPERAND_0_mi *)kodp)->minor = 80;
#line 988
    kodp += sizeof(struct OPERAND_0_mi );
#line 989
    goto switch_break___4;
    case_2___2: /* CIL Label */ 
#line 991
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 991
    ((struct OPERAND_0_mi *)kodp)->minor = 94;
#line 991
    kodp += sizeof(struct OPERAND_0_mi );
#line 992
    goto switch_break___4;
    case_130___2: /* CIL Label */ 
#line 994
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 994
    ((struct OPERAND_0_mi *)kodp)->minor = 110;
#line 994
    kodp += sizeof(struct OPERAND_0_mi );
#line 995
    goto switch_break___4;
    case_258___2: /* CIL Label */ 
#line 997
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 997
    ((struct OPERAND_0_mi *)kodp)->minor = 126;
#line 997
    kodp += sizeof(struct OPERAND_0_mi );
#line 998
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
    {
#line 1000
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1000);
#line 1001
    error_message(5000);
#line 1002
    abort();
    }
    switch_break___4: /* CIL Label */ ;
    }
#line 1004
    type_ac[set - 1] = (enum intern_arit_class )280;
#line 1005
    last_instr = current_instr;
#line 1005
    current_instr = kodp;
#line 1006
    return (1);
    case_152___3: /* CIL Label */ 
    case_24___3: /* CIL Label */ 
    {
#line 1012
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 1012
      goto case_136___3;
    }
#line 1012
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 1012
      goto case_136___3;
    }
#line 1015
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 1015
      goto case_264___3;
    }
#line 1033
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 1033
      goto case_140___3;
    }
#line 1033
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 1033
      goto case_140___3;
    }
#line 1036
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 1036
      goto case_268___3;
    }
#line 1039
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 1039
      goto case_2___3;
    }
#line 1042
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 1042
      goto case_130___3;
    }
#line 1045
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 1045
      goto case_258___3;
    }
#line 1048
    goto switch_default___4;
    case_136___3: /* CIL Label */ 
    case_8___3: /* CIL Label */ ;
#line 1014
    goto switch_break___5;
    case_264___3: /* CIL Label */ ;
#line 1031
    goto switch_break___5;
    case_140___3: /* CIL Label */ 
    case_12___3: /* CIL Label */ 
#line 1034
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1034
    ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1034
    kodp += sizeof(struct OPERAND_0_mi );
#line 1035
    goto switch_break___5;
    case_268___3: /* CIL Label */ 
#line 1037
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1037
    ((struct OPERAND_0_mi *)kodp)->minor = 78;
#line 1037
    kodp += sizeof(struct OPERAND_0_mi );
#line 1038
    goto switch_break___5;
    case_2___3: /* CIL Label */ 
#line 1040
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1040
    ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1040
    kodp += sizeof(struct OPERAND_0_mi );
#line 1041
    goto switch_break___5;
    case_130___3: /* CIL Label */ 
#line 1043
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1043
    ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 1043
    kodp += sizeof(struct OPERAND_0_mi );
#line 1044
    goto switch_break___5;
    case_258___3: /* CIL Label */ 
#line 1046
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1046
    ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 1046
    kodp += sizeof(struct OPERAND_0_mi );
#line 1047
    goto switch_break___5;
    switch_default___4: /* CIL Label */ 
    {
#line 1049
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1049);
#line 1050
    error_message(5000);
#line 1051
    abort();
    }
    switch_break___5: /* CIL Label */ ;
    }
#line 1053
    type_ac[set - 1] = (enum intern_arit_class )24;
#line 1054
    last_instr = current_instr;
#line 1054
    current_instr = kodp;
#line 1055
    return (1);
    case_264___4: /* CIL Label */ 
    {
#line 1060
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 1060
      goto case_136___4;
    }
#line 1060
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 1060
      goto case_136___4;
    }
#line 1064
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 1064
      goto case_140___4;
    }
#line 1064
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 1064
      goto case_140___4;
    }
#line 1067
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 1067
      goto case_2___4;
    }
#line 1070
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 1070
      goto case_130___4;
    }
#line 1073
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 1073
      goto case_258___4;
    }
#line 1076
    goto switch_default___5;
    case_136___4: /* CIL Label */ 
    case_8___4: /* CIL Label */ 
#line 1061
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1061
    ((struct OPERAND_0_mi *)kodp)->minor = 150;
#line 1061
    kodp += sizeof(struct OPERAND_0_mi );
#line 1062
    goto switch_break___6;
    case_140___4: /* CIL Label */ 
    case_12___4: /* CIL Label */ 
#line 1065
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1065
    ((struct OPERAND_0_mi *)kodp)->minor = 68;
#line 1065
    kodp += sizeof(struct OPERAND_0_mi );
#line 1066
    goto switch_break___6;
    case_2___4: /* CIL Label */ 
#line 1068
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1068
    ((struct OPERAND_0_mi *)kodp)->minor = 94;
#line 1068
    kodp += sizeof(struct OPERAND_0_mi );
#line 1069
    goto switch_break___6;
    case_130___4: /* CIL Label */ 
#line 1071
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1071
    ((struct OPERAND_0_mi *)kodp)->minor = 110;
#line 1071
    kodp += sizeof(struct OPERAND_0_mi );
#line 1072
    goto switch_break___6;
    case_258___4: /* CIL Label */ 
#line 1074
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1074
    ((struct OPERAND_0_mi *)kodp)->minor = 126;
#line 1074
    kodp += sizeof(struct OPERAND_0_mi );
#line 1075
    goto switch_break___6;
    switch_default___5: /* CIL Label */ 
    {
#line 1077
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1077);
#line 1078
    error_message(5000);
#line 1079
    abort();
    }
    switch_break___6: /* CIL Label */ ;
    }
#line 1081
    type_ac[set - 1] = (enum intern_arit_class )264;
#line 1082
    last_instr = current_instr;
#line 1082
    current_instr = kodp;
#line 1083
    return (1);
    case_136___5: /* CIL Label */ 
    case_8___5: /* CIL Label */ 
    {
#line 1089
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 1089
      goto case_140___5;
    }
#line 1089
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 1089
      goto case_140___5;
    }
#line 1092
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 1092
      goto case_268___4;
    }
#line 1095
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 1095
      goto case_2___5;
    }
#line 1098
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 1098
      goto case_130___5;
    }
#line 1101
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 1101
      goto case_258___5;
    }
#line 1104
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 1104
      goto case_1___2;
    }
#line 1107
    goto switch_default___6;
    case_140___5: /* CIL Label */ 
    case_12___5: /* CIL Label */ 
#line 1090
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1090
    ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1090
    kodp += sizeof(struct OPERAND_0_mi );
#line 1091
    goto switch_break___7;
    case_268___4: /* CIL Label */ 
#line 1093
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1093
    ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1093
    kodp += sizeof(struct OPERAND_0_mi );
#line 1094
    goto switch_break___7;
    case_2___5: /* CIL Label */ 
#line 1096
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1096
    ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1096
    kodp += sizeof(struct OPERAND_0_mi );
#line 1097
    goto switch_break___7;
    case_130___5: /* CIL Label */ 
#line 1099
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1099
    ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 1099
    kodp += sizeof(struct OPERAND_0_mi );
#line 1100
    goto switch_break___7;
    case_258___5: /* CIL Label */ 
#line 1102
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1102
    ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 1102
    kodp += sizeof(struct OPERAND_0_mi );
#line 1103
    goto switch_break___7;
    case_1___2: /* CIL Label */ 
    {
#line 1105
    error_message(1009);
    }
#line 1106
    goto switch_break___7;
    switch_default___6: /* CIL Label */ 
    {
#line 1108
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1108);
#line 1109
    error_message(5000);
#line 1110
    abort();
    }
    switch_break___7: /* CIL Label */ ;
    }
#line 1112
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1113
    last_instr = current_instr;
#line 1113
    current_instr = kodp;
#line 1114
    return (1);
    case_140___6: /* CIL Label */ 
    case_12___6: /* CIL Label */ 
    {
#line 1120
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 1120
      goto case_136___6;
    }
#line 1120
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 1120
      goto case_136___6;
    }
#line 1124
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 1124
      goto case_264___5;
    }
#line 1129
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 1129
      goto case_152___4;
    }
#line 1129
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 1129
      goto case_152___4;
    }
#line 1134
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 1134
      goto case_140___7;
    }
#line 1134
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 1134
      goto case_140___7;
    }
#line 1140
    if ((unsigned int )type_ac[set - 1] == 280U) {
#line 1140
      goto case_280___3;
    }
#line 1144
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 1144
      goto case_268___5;
    }
#line 1150
    if ((unsigned int )type_ac[set - 1] == 64U) {
#line 1150
      goto case_64___1;
    }
#line 1154
    if ((unsigned int )type_ac[set - 1] == 80U) {
#line 1154
      goto case_80___0;
    }
#line 1158
    if ((unsigned int )type_ac[set - 1] == 32U) {
#line 1158
      goto case_32___2;
    }
#line 1162
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 1162
      goto case_2___6;
    }
#line 1168
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 1168
      goto case_130___6;
    }
#line 1174
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 1174
      goto case_258___6;
    }
#line 1180
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 1180
      goto case_1___3;
    }
#line 1183
    goto switch_default___7;
    case_136___6: /* CIL Label */ 
    case_8___6: /* CIL Label */ 
#line 1121
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1121
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1121
    kodp += sizeof(struct OPERAND_0_mi );
#line 1122
    type_ac[set] = (enum intern_arit_class )8;
#line 1123
    goto switch_break___8;
    case_264___5: /* CIL Label */ 
#line 1125
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1125
    ((struct OPERAND_0_mi *)kodp)->minor = 67;
#line 1125
    kodp += sizeof(struct OPERAND_0_mi );
#line 1126
    type_ac[set] = (enum intern_arit_class )264;
#line 1127
    goto switch_break___8;
    case_152___4: /* CIL Label */ 
    case_24___4: /* CIL Label */ 
#line 1130
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1130
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1130
    kodp += sizeof(struct OPERAND_0_mi );
#line 1131
    type_ac[set] = (enum intern_arit_class )24;
#line 1132
    goto switch_break___8;
    case_140___7: /* CIL Label */ 
    case_12___7: /* CIL Label */ 
#line 1135
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1135
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1135
    kodp += sizeof(struct OPERAND_0_mi );
#line 1135
    last_instr = current_instr;
#line 1135
    current_instr = kodp;
#line 1136
    type_ac[set] = (enum intern_arit_class )8;
#line 1137
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1137
    ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1137
    kodp += sizeof(struct OPERAND_0_mi );
#line 1138
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1139
    goto switch_break___8;
    case_280___3: /* CIL Label */ 
#line 1141
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1141
    ((struct OPERAND_0_mi *)kodp)->minor = 63;
#line 1141
    kodp += sizeof(struct OPERAND_0_mi );
#line 1142
    type_ac[set] = (enum intern_arit_class )280;
#line 1143
    goto switch_break___8;
    case_268___5: /* CIL Label */ 
#line 1145
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1145
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1145
    kodp += sizeof(struct OPERAND_0_mi );
#line 1145
    last_instr = current_instr;
#line 1145
    current_instr = kodp;
#line 1146
    type_ac[set] = (enum intern_arit_class )8;
#line 1147
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1147
    ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1147
    kodp += sizeof(struct OPERAND_0_mi );
#line 1148
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1149
    goto switch_break___8;
    case_64___1: /* CIL Label */ 
#line 1151
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1151
    ((struct OPERAND_0_mi *)kodp)->minor = 57;
#line 1151
    kodp += sizeof(struct OPERAND_0_mi );
#line 1152
    type_ac[set] = (enum intern_arit_class )64;
#line 1153
    goto switch_break___8;
    case_80___0: /* CIL Label */ 
#line 1155
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1155
    ((struct OPERAND_0_mi *)kodp)->minor = 172;
#line 1155
    kodp += sizeof(struct OPERAND_0_mi );
#line 1156
    type_ac[set] = (enum intern_arit_class )80;
#line 1157
    goto switch_break___8;
    case_32___2: /* CIL Label */ 
#line 1159
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1159
    ((struct OPERAND_0_mi *)kodp)->minor = 59;
#line 1159
    kodp += sizeof(struct OPERAND_0_mi );
#line 1160
    type_ac[set] = (enum intern_arit_class )32;
#line 1161
    goto switch_break___8;
    case_2___6: /* CIL Label */ 
#line 1163
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1163
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1163
    kodp += sizeof(struct OPERAND_0_mi );
#line 1163
    last_instr = current_instr;
#line 1163
    current_instr = kodp;
#line 1164
    type_ac[set] = (enum intern_arit_class )8;
#line 1165
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1165
    ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1165
    kodp += sizeof(struct OPERAND_0_mi );
#line 1166
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1167
    goto switch_break___8;
    case_130___6: /* CIL Label */ 
#line 1169
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1169
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1169
    kodp += sizeof(struct OPERAND_0_mi );
#line 1169
    last_instr = current_instr;
#line 1169
    current_instr = kodp;
#line 1170
    type_ac[set] = (enum intern_arit_class )8;
#line 1171
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1171
    ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 1171
    kodp += sizeof(struct OPERAND_0_mi );
#line 1172
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1173
    goto switch_break___8;
    case_258___6: /* CIL Label */ 
#line 1175
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1175
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1175
    kodp += sizeof(struct OPERAND_0_mi );
#line 1175
    last_instr = current_instr;
#line 1175
    current_instr = kodp;
#line 1176
    type_ac[set] = (enum intern_arit_class )8;
#line 1177
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1177
    ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 1177
    kodp += sizeof(struct OPERAND_0_mi );
#line 1178
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1179
    goto switch_break___8;
    case_1___3: /* CIL Label */ 
    {
#line 1181
    error_message(1009);
    }
#line 1182
    goto switch_break___8;
    switch_default___7: /* CIL Label */ 
    {
#line 1184
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1184);
#line 1185
    error_message(5000);
#line 1186
    abort();
    }
    switch_break___8: /* CIL Label */ ;
    }
#line 1188
    last_instr = current_instr;
#line 1188
    current_instr = kodp;
#line 1189
    return (1);
    case_268___6: /* CIL Label */ 
    {
#line 1194
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 1194
      goto case_136___7;
    }
#line 1194
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 1194
      goto case_136___7;
    }
#line 1198
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 1198
      goto case_264___6;
    }
#line 1203
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 1203
      goto case_152___5;
    }
#line 1203
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 1203
      goto case_152___5;
    }
#line 1208
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 1208
      goto case_140___8;
    }
#line 1208
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 1208
      goto case_140___8;
    }
#line 1214
    if ((unsigned int )type_ac[set - 1] == 280U) {
#line 1214
      goto case_280___4;
    }
#line 1218
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 1218
      goto case_268___7;
    }
#line 1224
    if ((unsigned int )type_ac[set - 1] == 64U) {
#line 1224
      goto case_64___2;
    }
#line 1228
    if ((unsigned int )type_ac[set - 1] == 80U) {
#line 1228
      goto case_80___1;
    }
#line 1232
    if ((unsigned int )type_ac[set - 1] == 32U) {
#line 1232
      goto case_32___3;
    }
#line 1236
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 1236
      goto case_2___7;
    }
#line 1242
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 1242
      goto case_130___7;
    }
#line 1248
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 1248
      goto case_258___7;
    }
#line 1254
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 1254
      goto case_1___4;
    }
#line 1257
    goto switch_default___8;
    case_136___7: /* CIL Label */ 
    case_8___7: /* CIL Label */ 
#line 1195
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1195
    ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 1195
    kodp += sizeof(struct OPERAND_0_mi );
#line 1196
    type_ac[set] = (enum intern_arit_class )8;
#line 1197
    goto switch_break___9;
    case_264___6: /* CIL Label */ 
#line 1199
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1199
    ((struct OPERAND_0_mi *)kodp)->minor = 83;
#line 1199
    kodp += sizeof(struct OPERAND_0_mi );
#line 1200
    type_ac[set] = (enum intern_arit_class )264;
#line 1201
    goto switch_break___9;
    case_152___5: /* CIL Label */ 
    case_24___5: /* CIL Label */ 
#line 1204
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1204
    ((struct OPERAND_0_mi *)kodp)->minor = 77;
#line 1204
    kodp += sizeof(struct OPERAND_0_mi );
#line 1205
    type_ac[set] = (enum intern_arit_class )24;
#line 1206
    goto switch_break___9;
    case_140___8: /* CIL Label */ 
    case_12___8: /* CIL Label */ 
#line 1209
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1209
    ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 1209
    kodp += sizeof(struct OPERAND_0_mi );
#line 1209
    last_instr = current_instr;
#line 1209
    current_instr = kodp;
#line 1210
    type_ac[set] = (enum intern_arit_class )8;
#line 1211
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1211
    ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1211
    kodp += sizeof(struct OPERAND_0_mi );
#line 1212
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1213
    goto switch_break___9;
    case_280___4: /* CIL Label */ 
#line 1215
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1215
    ((struct OPERAND_0_mi *)kodp)->minor = 79;
#line 1215
    kodp += sizeof(struct OPERAND_0_mi );
#line 1216
    type_ac[set] = (enum intern_arit_class )280;
#line 1217
    goto switch_break___9;
    case_268___7: /* CIL Label */ 
#line 1219
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1219
    ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 1219
    kodp += sizeof(struct OPERAND_0_mi );
#line 1219
    last_instr = current_instr;
#line 1219
    current_instr = kodp;
#line 1220
    type_ac[set] = (enum intern_arit_class )8;
#line 1221
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1221
    ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1221
    kodp += sizeof(struct OPERAND_0_mi );
#line 1222
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1223
    goto switch_break___9;
    case_64___2: /* CIL Label */ 
#line 1225
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1225
    ((struct OPERAND_0_mi *)kodp)->minor = 73;
#line 1225
    kodp += sizeof(struct OPERAND_0_mi );
#line 1226
    type_ac[set] = (enum intern_arit_class )64;
#line 1227
    goto switch_break___9;
    case_80___1: /* CIL Label */ 
#line 1229
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1229
    ((struct OPERAND_0_mi *)kodp)->minor = 176;
#line 1229
    kodp += sizeof(struct OPERAND_0_mi );
#line 1230
    type_ac[set] = (enum intern_arit_class )80;
#line 1231
    goto switch_break___9;
    case_32___3: /* CIL Label */ 
#line 1233
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1233
    ((struct OPERAND_0_mi *)kodp)->minor = 75;
#line 1233
    kodp += sizeof(struct OPERAND_0_mi );
#line 1234
    type_ac[set] = (enum intern_arit_class )32;
#line 1235
    goto switch_break___9;
    case_2___7: /* CIL Label */ 
#line 1237
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1237
    ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 1237
    kodp += sizeof(struct OPERAND_0_mi );
#line 1237
    last_instr = current_instr;
#line 1237
    current_instr = kodp;
#line 1238
    type_ac[set] = (enum intern_arit_class )8;
#line 1239
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1239
    ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1239
    kodp += sizeof(struct OPERAND_0_mi );
#line 1240
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1241
    goto switch_break___9;
    case_130___7: /* CIL Label */ 
#line 1243
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1243
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1243
    kodp += sizeof(struct OPERAND_0_mi );
#line 1243
    last_instr = current_instr;
#line 1243
    current_instr = kodp;
#line 1244
    type_ac[set] = (enum intern_arit_class )8;
#line 1245
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1245
    ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 1245
    kodp += sizeof(struct OPERAND_0_mi );
#line 1246
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1247
    goto switch_break___9;
    case_258___7: /* CIL Label */ 
#line 1249
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1249
    ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 1249
    kodp += sizeof(struct OPERAND_0_mi );
#line 1249
    last_instr = current_instr;
#line 1249
    current_instr = kodp;
#line 1250
    type_ac[set] = (enum intern_arit_class )8;
#line 1251
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1251
    ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 1251
    kodp += sizeof(struct OPERAND_0_mi );
#line 1252
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1253
    goto switch_break___9;
    case_1___4: /* CIL Label */ 
    {
#line 1255
    error_message(1009);
    }
#line 1256
    goto switch_break___9;
    switch_default___8: /* CIL Label */ 
    {
#line 1258
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1258);
#line 1259
    error_message(5000);
#line 1260
    abort();
    }
    switch_break___9: /* CIL Label */ ;
    }
#line 1262
    last_instr = current_instr;
#line 1262
    current_instr = kodp;
#line 1263
    return (1);
    case_2___8: /* CIL Label */ 
    {
#line 1268
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 1268
      goto case_136___8;
    }
#line 1268
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 1268
      goto case_136___8;
    }
#line 1272
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 1272
      goto case_264___7;
    }
#line 1277
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 1277
      goto case_152___6;
    }
#line 1277
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 1277
      goto case_152___6;
    }
#line 1282
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 1282
      goto case_140___9;
    }
#line 1282
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 1282
      goto case_140___9;
    }
#line 1288
    if ((unsigned int )type_ac[set - 1] == 280U) {
#line 1288
      goto case_280___5;
    }
#line 1292
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 1292
      goto case_268___8;
    }
#line 1298
    if ((unsigned int )type_ac[set - 1] == 64U) {
#line 1298
      goto case_64___3;
    }
#line 1302
    if ((unsigned int )type_ac[set - 1] == 80U) {
#line 1302
      goto case_80___2;
    }
#line 1306
    if ((unsigned int )type_ac[set - 1] == 32U) {
#line 1306
      goto case_32___4;
    }
#line 1310
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 1310
      goto case_2___9;
    }
#line 1316
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 1316
      goto case_130___8;
    }
#line 1322
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 1322
      goto case_258___8;
    }
#line 1328
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 1328
      goto case_1___5;
    }
#line 1331
    goto switch_default___9;
    case_136___8: /* CIL Label */ 
    case_8___8: /* CIL Label */ 
#line 1269
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1269
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1269
    kodp += sizeof(struct OPERAND_0_mi );
#line 1270
    type_ac[set] = (enum intern_arit_class )8;
#line 1271
    goto switch_break___10;
    case_264___7: /* CIL Label */ 
#line 1273
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1273
    ((struct OPERAND_0_mi *)kodp)->minor = 93;
#line 1273
    kodp += sizeof(struct OPERAND_0_mi );
#line 1274
    type_ac[set] = (enum intern_arit_class )264;
#line 1275
    goto switch_break___10;
    case_152___6: /* CIL Label */ 
    case_24___6: /* CIL Label */ 
#line 1278
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1278
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1278
    kodp += sizeof(struct OPERAND_0_mi );
#line 1279
    type_ac[set] = (enum intern_arit_class )24;
#line 1280
    goto switch_break___10;
    case_140___9: /* CIL Label */ 
    case_12___9: /* CIL Label */ 
#line 1283
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1283
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1283
    kodp += sizeof(struct OPERAND_0_mi );
#line 1283
    last_instr = current_instr;
#line 1283
    current_instr = kodp;
#line 1284
    type_ac[set] = (enum intern_arit_class )8;
#line 1285
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1285
    ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1285
    kodp += sizeof(struct OPERAND_0_mi );
#line 1286
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1287
    goto switch_break___10;
    case_280___5: /* CIL Label */ 
#line 1289
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1289
    ((struct OPERAND_0_mi *)kodp)->minor = 93;
#line 1289
    kodp += sizeof(struct OPERAND_0_mi );
#line 1290
    type_ac[set] = (enum intern_arit_class )280;
#line 1291
    goto switch_break___10;
    case_268___8: /* CIL Label */ 
#line 1293
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1293
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1293
    kodp += sizeof(struct OPERAND_0_mi );
#line 1293
    last_instr = current_instr;
#line 1293
    current_instr = kodp;
#line 1294
    type_ac[set] = (enum intern_arit_class )8;
#line 1295
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1295
    ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1295
    kodp += sizeof(struct OPERAND_0_mi );
#line 1296
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1297
    goto switch_break___10;
    case_64___3: /* CIL Label */ 
#line 1299
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1299
    ((struct OPERAND_0_mi *)kodp)->minor = 12;
#line 1299
    kodp += sizeof(struct OPERAND_0_mi );
#line 1300
    type_ac[set] = (enum intern_arit_class )64;
#line 1301
    goto switch_break___10;
    case_80___2: /* CIL Label */ 
#line 1303
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1303
    ((struct OPERAND_0_mi *)kodp)->minor = 182;
#line 1303
    kodp += sizeof(struct OPERAND_0_mi );
#line 1304
    type_ac[set] = (enum intern_arit_class )80;
#line 1305
    goto switch_break___10;
    case_32___4: /* CIL Label */ 
#line 1307
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1307
    ((struct OPERAND_0_mi *)kodp)->minor = 15;
#line 1307
    kodp += sizeof(struct OPERAND_0_mi );
#line 1308
    type_ac[set] = (enum intern_arit_class )32;
#line 1309
    goto switch_break___10;
    case_2___9: /* CIL Label */ 
#line 1311
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1311
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1311
    kodp += sizeof(struct OPERAND_0_mi );
#line 1311
    last_instr = current_instr;
#line 1311
    current_instr = kodp;
#line 1312
    type_ac[set] = (enum intern_arit_class )8;
#line 1313
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1313
    ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1313
    kodp += sizeof(struct OPERAND_0_mi );
#line 1314
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1315
    goto switch_break___10;
    case_130___8: /* CIL Label */ 
#line 1317
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1317
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1317
    kodp += sizeof(struct OPERAND_0_mi );
#line 1317
    last_instr = current_instr;
#line 1317
    current_instr = kodp;
#line 1318
    type_ac[set] = (enum intern_arit_class )8;
#line 1319
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1319
    ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 1319
    kodp += sizeof(struct OPERAND_0_mi );
#line 1320
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1321
    goto switch_break___10;
    case_258___8: /* CIL Label */ 
#line 1323
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1323
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1323
    kodp += sizeof(struct OPERAND_0_mi );
#line 1323
    last_instr = current_instr;
#line 1323
    current_instr = kodp;
#line 1324
    type_ac[set] = (enum intern_arit_class )8;
#line 1325
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1325
    ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 1325
    kodp += sizeof(struct OPERAND_0_mi );
#line 1326
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1327
    goto switch_break___10;
    case_1___5: /* CIL Label */ 
    {
#line 1329
    error_message(1009);
    }
#line 1330
    goto switch_break___10;
    switch_default___9: /* CIL Label */ 
    {
#line 1332
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1332);
#line 1333
    error_message(5000);
#line 1334
    abort();
    }
    switch_break___10: /* CIL Label */ ;
    }
#line 1336
    last_instr = current_instr;
#line 1336
    current_instr = kodp;
#line 1337
    return (1);
    case_130___9: /* CIL Label */ 
    {
#line 1342
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 1342
      goto case_136___9;
    }
#line 1342
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 1342
      goto case_136___9;
    }
#line 1346
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 1346
      goto case_264___8;
    }
#line 1351
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 1351
      goto case_152___7;
    }
#line 1351
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 1351
      goto case_152___7;
    }
#line 1356
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 1356
      goto case_140___10;
    }
#line 1356
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 1356
      goto case_140___10;
    }
#line 1362
    if ((unsigned int )type_ac[set - 1] == 280U) {
#line 1362
      goto case_280___6;
    }
#line 1366
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 1366
      goto case_268___9;
    }
#line 1372
    if ((unsigned int )type_ac[set - 1] == 64U) {
#line 1372
      goto case_64___4;
    }
#line 1376
    if ((unsigned int )type_ac[set - 1] == 80U) {
#line 1376
      goto case_80___3;
    }
#line 1380
    if ((unsigned int )type_ac[set - 1] == 32U) {
#line 1380
      goto case_32___5;
    }
#line 1384
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 1384
      goto case_2___10;
    }
#line 1390
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 1390
      goto case_130___10;
    }
#line 1396
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 1396
      goto case_258___9;
    }
#line 1402
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 1402
      goto case_1___6;
    }
#line 1405
    goto switch_default___10;
    case_136___9: /* CIL Label */ 
    case_8___9: /* CIL Label */ 
#line 1343
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1343
    ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1343
    kodp += sizeof(struct OPERAND_0_mi );
#line 1344
    type_ac[set] = (enum intern_arit_class )8;
#line 1345
    goto switch_break___11;
    case_264___8: /* CIL Label */ 
#line 1347
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1347
    ((struct OPERAND_0_mi *)kodp)->minor = 109;
#line 1347
    kodp += sizeof(struct OPERAND_0_mi );
#line 1348
    type_ac[set] = (enum intern_arit_class )264;
#line 1349
    goto switch_break___11;
    case_152___7: /* CIL Label */ 
    case_24___7: /* CIL Label */ 
#line 1352
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1352
    ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1352
    kodp += sizeof(struct OPERAND_0_mi );
#line 1353
    type_ac[set] = (enum intern_arit_class )24;
#line 1354
    goto switch_break___11;
    case_140___10: /* CIL Label */ 
    case_12___10: /* CIL Label */ 
#line 1357
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1357
    ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1357
    kodp += sizeof(struct OPERAND_0_mi );
#line 1357
    last_instr = current_instr;
#line 1357
    current_instr = kodp;
#line 1358
    type_ac[set] = (enum intern_arit_class )8;
#line 1359
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1359
    ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1359
    kodp += sizeof(struct OPERAND_0_mi );
#line 1360
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1361
    goto switch_break___11;
    case_280___6: /* CIL Label */ 
#line 1363
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1363
    ((struct OPERAND_0_mi *)kodp)->minor = 109;
#line 1363
    kodp += sizeof(struct OPERAND_0_mi );
#line 1364
    type_ac[set] = (enum intern_arit_class )280;
#line 1365
    goto switch_break___11;
    case_268___9: /* CIL Label */ 
#line 1367
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1367
    ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1367
    kodp += sizeof(struct OPERAND_0_mi );
#line 1367
    last_instr = current_instr;
#line 1367
    current_instr = kodp;
#line 1368
    type_ac[set] = (enum intern_arit_class )8;
#line 1369
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1369
    ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1369
    kodp += sizeof(struct OPERAND_0_mi );
#line 1370
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1371
    goto switch_break___11;
    case_64___4: /* CIL Label */ 
#line 1373
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1373
    ((struct OPERAND_0_mi *)kodp)->minor = 99;
#line 1373
    kodp += sizeof(struct OPERAND_0_mi );
#line 1374
    type_ac[set] = (enum intern_arit_class )64;
#line 1375
    goto switch_break___11;
    case_80___3: /* CIL Label */ 
#line 1377
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1377
    ((struct OPERAND_0_mi *)kodp)->minor = 184;
#line 1377
    kodp += sizeof(struct OPERAND_0_mi );
#line 1378
    type_ac[set] = (enum intern_arit_class )80;
#line 1379
    goto switch_break___11;
    case_32___5: /* CIL Label */ 
#line 1381
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1381
    ((struct OPERAND_0_mi *)kodp)->minor = 101;
#line 1381
    kodp += sizeof(struct OPERAND_0_mi );
#line 1382
    type_ac[set] = (enum intern_arit_class )32;
#line 1383
    goto switch_break___11;
    case_2___10: /* CIL Label */ 
#line 1385
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1385
    ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1385
    kodp += sizeof(struct OPERAND_0_mi );
#line 1385
    last_instr = current_instr;
#line 1385
    current_instr = kodp;
#line 1386
    type_ac[set] = (enum intern_arit_class )8;
#line 1387
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1387
    ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1387
    kodp += sizeof(struct OPERAND_0_mi );
#line 1388
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1389
    goto switch_break___11;
    case_130___10: /* CIL Label */ 
#line 1391
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1391
    ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1391
    kodp += sizeof(struct OPERAND_0_mi );
#line 1391
    last_instr = current_instr;
#line 1391
    current_instr = kodp;
#line 1392
    type_ac[set] = (enum intern_arit_class )8;
#line 1393
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1393
    ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 1393
    kodp += sizeof(struct OPERAND_0_mi );
#line 1394
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1395
    goto switch_break___11;
    case_258___9: /* CIL Label */ 
#line 1397
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1397
    ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1397
    kodp += sizeof(struct OPERAND_0_mi );
#line 1397
    last_instr = current_instr;
#line 1397
    current_instr = kodp;
#line 1398
    type_ac[set] = (enum intern_arit_class )8;
#line 1399
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1399
    ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 1399
    kodp += sizeof(struct OPERAND_0_mi );
#line 1400
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1401
    goto switch_break___11;
    case_1___6: /* CIL Label */ 
    {
#line 1403
    error_message(1009);
    }
#line 1404
    goto switch_break___11;
    switch_default___10: /* CIL Label */ 
    {
#line 1406
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1406);
#line 1407
    error_message(5000);
#line 1408
    abort();
    }
    switch_break___11: /* CIL Label */ ;
    }
#line 1410
    last_instr = current_instr;
#line 1410
    current_instr = kodp;
#line 1411
    return (1);
    case_258___10: /* CIL Label */ 
    {
#line 1416
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 1416
      goto case_136___10;
    }
#line 1416
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 1416
      goto case_136___10;
    }
#line 1420
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 1420
      goto case_264___9;
    }
#line 1425
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 1425
      goto case_152___8;
    }
#line 1425
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 1425
      goto case_152___8;
    }
#line 1430
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 1430
      goto case_140___11;
    }
#line 1430
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 1430
      goto case_140___11;
    }
#line 1436
    if ((unsigned int )type_ac[set - 1] == 280U) {
#line 1436
      goto case_280___7;
    }
#line 1440
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 1440
      goto case_268___10;
    }
#line 1446
    if ((unsigned int )type_ac[set - 1] == 64U) {
#line 1446
      goto case_64___5;
    }
#line 1450
    if ((unsigned int )type_ac[set - 1] == 80U) {
#line 1450
      goto case_80___4;
    }
#line 1454
    if ((unsigned int )type_ac[set - 1] == 32U) {
#line 1454
      goto case_32___6;
    }
#line 1458
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 1458
      goto case_2___11;
    }
#line 1464
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 1464
      goto case_130___11;
    }
#line 1470
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 1470
      goto case_258___11;
    }
#line 1476
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 1476
      goto case_1___7;
    }
#line 1479
    goto switch_default___11;
    case_136___10: /* CIL Label */ 
    case_8___10: /* CIL Label */ 
#line 1417
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1417
    ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1417
    kodp += sizeof(struct OPERAND_0_mi );
#line 1418
    type_ac[set] = (enum intern_arit_class )8;
#line 1419
    goto switch_break___12;
    case_264___9: /* CIL Label */ 
#line 1421
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1421
    ((struct OPERAND_0_mi *)kodp)->minor = 125;
#line 1421
    kodp += sizeof(struct OPERAND_0_mi );
#line 1422
    type_ac[set] = (enum intern_arit_class )264;
#line 1423
    goto switch_break___12;
    case_152___8: /* CIL Label */ 
    case_24___8: /* CIL Label */ 
#line 1426
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1426
    ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1426
    kodp += sizeof(struct OPERAND_0_mi );
#line 1427
    type_ac[set] = (enum intern_arit_class )24;
#line 1428
    goto switch_break___12;
    case_140___11: /* CIL Label */ 
    case_12___11: /* CIL Label */ 
#line 1431
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1431
    ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1431
    kodp += sizeof(struct OPERAND_0_mi );
#line 1431
    last_instr = current_instr;
#line 1431
    current_instr = kodp;
#line 1432
    type_ac[set] = (enum intern_arit_class )8;
#line 1433
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1433
    ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1433
    kodp += sizeof(struct OPERAND_0_mi );
#line 1434
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1435
    goto switch_break___12;
    case_280___7: /* CIL Label */ 
#line 1437
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1437
    ((struct OPERAND_0_mi *)kodp)->minor = 125;
#line 1437
    kodp += sizeof(struct OPERAND_0_mi );
#line 1438
    type_ac[set] = (enum intern_arit_class )280;
#line 1439
    goto switch_break___12;
    case_268___10: /* CIL Label */ 
#line 1441
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1441
    ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1441
    kodp += sizeof(struct OPERAND_0_mi );
#line 1441
    last_instr = current_instr;
#line 1441
    current_instr = kodp;
#line 1442
    type_ac[set] = (enum intern_arit_class )8;
#line 1443
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1443
    ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1443
    kodp += sizeof(struct OPERAND_0_mi );
#line 1444
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1445
    goto switch_break___12;
    case_64___5: /* CIL Label */ 
#line 1447
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1447
    ((struct OPERAND_0_mi *)kodp)->minor = 115;
#line 1447
    kodp += sizeof(struct OPERAND_0_mi );
#line 1448
    type_ac[set] = (enum intern_arit_class )64;
#line 1449
    goto switch_break___12;
    case_80___4: /* CIL Label */ 
#line 1451
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1451
    ((struct OPERAND_0_mi *)kodp)->minor = 186;
#line 1451
    kodp += sizeof(struct OPERAND_0_mi );
#line 1452
    type_ac[set] = (enum intern_arit_class )80;
#line 1453
    goto switch_break___12;
    case_32___6: /* CIL Label */ 
#line 1455
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1455
    ((struct OPERAND_0_mi *)kodp)->minor = 117;
#line 1455
    kodp += sizeof(struct OPERAND_0_mi );
#line 1456
    type_ac[set] = (enum intern_arit_class )32;
#line 1457
    goto switch_break___12;
    case_2___11: /* CIL Label */ 
#line 1459
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1459
    ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1459
    kodp += sizeof(struct OPERAND_0_mi );
#line 1459
    last_instr = current_instr;
#line 1459
    current_instr = kodp;
#line 1460
    type_ac[set] = (enum intern_arit_class )8;
#line 1461
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1461
    ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1461
    kodp += sizeof(struct OPERAND_0_mi );
#line 1462
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1463
    goto switch_break___12;
    case_130___11: /* CIL Label */ 
#line 1465
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1465
    ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1465
    kodp += sizeof(struct OPERAND_0_mi );
#line 1465
    last_instr = current_instr;
#line 1465
    current_instr = kodp;
#line 1466
    type_ac[set] = (enum intern_arit_class )8;
#line 1467
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1467
    ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 1467
    kodp += sizeof(struct OPERAND_0_mi );
#line 1468
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1469
    goto switch_break___12;
    case_258___11: /* CIL Label */ 
#line 1471
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1471
    ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1471
    kodp += sizeof(struct OPERAND_0_mi );
#line 1471
    last_instr = current_instr;
#line 1471
    current_instr = kodp;
#line 1472
    type_ac[set] = (enum intern_arit_class )8;
#line 1473
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1473
    ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 1473
    kodp += sizeof(struct OPERAND_0_mi );
#line 1474
    type_ac[set - 1] = (enum intern_arit_class )8;
#line 1475
    goto switch_break___12;
    case_1___7: /* CIL Label */ 
    {
#line 1477
    error_message(1009);
    }
#line 1478
    goto switch_break___12;
    switch_default___11: /* CIL Label */ 
    {
#line 1480
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1480);
#line 1481
    error_message(5000);
#line 1482
    abort();
    }
    switch_break___12: /* CIL Label */ ;
    }
#line 1484
    last_instr = current_instr;
#line 1484
    current_instr = kodp;
#line 1485
    return (1);
    switch_default___12: /* CIL Label */ 
    {
#line 1487
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             1487);
#line 1488
    error_message(5000);
#line 1489
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1492
    tmp___5 = hierarchy((int )type_ac[set]);
#line 1492
    tmp___6 = hierarchy((int )type_ac[set - 1]);
    }
#line 1492
    if (tmp___5 > tmp___6) {
      {
#line 1496
      if ((unsigned int )type_ac[set - 1] == 80U) {
#line 1496
        goto case_80___5;
      }
#line 1542
      if ((unsigned int )type_ac[set - 1] == 64U) {
#line 1542
        goto case_64___7;
      }
#line 1588
      if ((unsigned int )type_ac[set - 1] == 32U) {
#line 1588
        goto case_32___9;
      }
#line 1631
      if ((unsigned int )type_ac[set - 1] == 280U) {
#line 1631
        goto case_280___11;
      }
#line 1668
      if ((unsigned int )type_ac[set - 1] == 24U) {
#line 1668
        goto case_24___13;
      }
#line 1715
      if ((unsigned int )type_ac[set - 1] == 264U) {
#line 1715
        goto case_264___15;
      }
#line 1742
      if ((unsigned int )type_ac[set - 1] == 8U) {
#line 1742
        goto case_8___17;
      }
#line 1765
      if ((unsigned int )type_ac[set - 1] == 140U) {
#line 1765
        goto case_140___18;
      }
#line 1765
      if ((unsigned int )type_ac[set - 1] == 12U) {
#line 1765
        goto case_140___18;
      }
#line 1839
      if ((unsigned int )type_ac[set - 1] == 268U) {
#line 1839
        goto case_268___17;
      }
#line 1913
      if ((unsigned int )type_ac[set - 1] == 2U) {
#line 1913
        goto case_2___21;
      }
#line 1987
      if ((unsigned int )type_ac[set - 1] == 130U) {
#line 1987
        goto case_130___22;
      }
#line 2061
      if ((unsigned int )type_ac[set - 1] == 258U) {
#line 2061
        goto case_258___23;
      }
#line 2135
      goto switch_default___25;
      case_80___5: /* CIL Label */ 
      {
#line 1500
      if ((unsigned int )type_ac[set] == 136U) {
#line 1500
        goto case_136___11;
      }
#line 1500
      if ((unsigned int )type_ac[set] == 8U) {
#line 1500
        goto case_136___11;
      }
#line 1503
      if ((unsigned int )type_ac[set] == 264U) {
#line 1503
        goto case_264___10;
      }
#line 1507
      if ((unsigned int )type_ac[set] == 152U) {
#line 1507
        goto case_152___9;
      }
#line 1507
      if ((unsigned int )type_ac[set] == 24U) {
#line 1507
        goto case_152___9;
      }
#line 1511
      if ((unsigned int )type_ac[set] == 140U) {
#line 1511
        goto case_140___12;
      }
#line 1511
      if ((unsigned int )type_ac[set] == 12U) {
#line 1511
        goto case_140___12;
      }
#line 1514
      if ((unsigned int )type_ac[set] == 280U) {
#line 1514
        goto case_280___8;
      }
#line 1517
      if ((unsigned int )type_ac[set] == 268U) {
#line 1517
        goto case_268___11;
      }
#line 1520
      if ((unsigned int )type_ac[set] == 64U) {
#line 1520
        goto case_64___6;
      }
#line 1523
      if ((unsigned int )type_ac[set] == 32U) {
#line 1523
        goto case_32___7;
      }
#line 1526
      if ((unsigned int )type_ac[set] == 2U) {
#line 1526
        goto case_2___12;
      }
#line 1529
      if ((unsigned int )type_ac[set] == 130U) {
#line 1529
        goto case_130___12;
      }
#line 1532
      if ((unsigned int )type_ac[set] == 258U) {
#line 1532
        goto case_258___12;
      }
#line 1535
      goto switch_default___13;
      case_136___11: /* CIL Label */ 
      case_8___11: /* CIL Label */ 
#line 1501
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1501
      ((struct OPERAND_0_mi *)kodp)->minor = 166;
#line 1501
      kodp += sizeof(struct OPERAND_0_mi );
#line 1502
      goto switch_break___14;
      case_264___10: /* CIL Label */ 
#line 1504
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1504
      ((struct OPERAND_0_mi *)kodp)->minor = 168;
#line 1504
      kodp += sizeof(struct OPERAND_0_mi );
#line 1505
      goto switch_break___14;
      case_152___9: /* CIL Label */ 
      case_24___9: /* CIL Label */ 
#line 1508
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1508
      ((struct OPERAND_0_mi *)kodp)->minor = 166;
#line 1508
      kodp += sizeof(struct OPERAND_0_mi );
#line 1509
      goto switch_break___14;
      case_140___12: /* CIL Label */ 
      case_12___12: /* CIL Label */ 
#line 1512
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1512
      ((struct OPERAND_0_mi *)kodp)->minor = 172;
#line 1512
      kodp += sizeof(struct OPERAND_0_mi );
#line 1513
      goto switch_break___14;
      case_280___8: /* CIL Label */ 
#line 1515
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1515
      ((struct OPERAND_0_mi *)kodp)->minor = 168;
#line 1515
      kodp += sizeof(struct OPERAND_0_mi );
#line 1516
      goto switch_break___14;
      case_268___11: /* CIL Label */ 
#line 1518
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1518
      ((struct OPERAND_0_mi *)kodp)->minor = 176;
#line 1518
      kodp += sizeof(struct OPERAND_0_mi );
#line 1519
      goto switch_break___14;
      case_64___6: /* CIL Label */ 
#line 1521
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1521
      ((struct OPERAND_0_mi *)kodp)->minor = 178;
#line 1521
      kodp += sizeof(struct OPERAND_0_mi );
#line 1522
      goto switch_break___14;
      case_32___7: /* CIL Label */ 
#line 1524
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1524
      ((struct OPERAND_0_mi *)kodp)->minor = 180;
#line 1524
      kodp += sizeof(struct OPERAND_0_mi );
#line 1525
      goto switch_break___14;
      case_2___12: /* CIL Label */ 
#line 1527
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1527
      ((struct OPERAND_0_mi *)kodp)->minor = 182;
#line 1527
      kodp += sizeof(struct OPERAND_0_mi );
#line 1528
      goto switch_break___14;
      case_130___12: /* CIL Label */ 
#line 1530
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1530
      ((struct OPERAND_0_mi *)kodp)->minor = 184;
#line 1530
      kodp += sizeof(struct OPERAND_0_mi );
#line 1531
      goto switch_break___14;
      case_258___12: /* CIL Label */ 
#line 1533
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1533
      ((struct OPERAND_0_mi *)kodp)->minor = 186;
#line 1533
      kodp += sizeof(struct OPERAND_0_mi );
#line 1534
      goto switch_break___14;
      switch_default___13: /* CIL Label */ 
      {
#line 1536
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1536);
#line 1537
      error_message(5000);
#line 1538
      abort();
      }
      switch_break___14: /* CIL Label */ ;
      }
#line 1540
      last_instr = current_instr;
#line 1540
      current_instr = kodp;
#line 1541
      return (1);
      case_64___7: /* CIL Label */ 
      {
#line 1546
      if ((unsigned int )type_ac[set] == 136U) {
#line 1546
        goto case_136___12;
      }
#line 1546
      if ((unsigned int )type_ac[set] == 8U) {
#line 1546
        goto case_136___12;
      }
#line 1549
      if ((unsigned int )type_ac[set] == 264U) {
#line 1549
        goto case_264___11;
      }
#line 1553
      if ((unsigned int )type_ac[set] == 152U) {
#line 1553
        goto case_152___10;
      }
#line 1553
      if ((unsigned int )type_ac[set] == 24U) {
#line 1553
        goto case_152___10;
      }
#line 1557
      if ((unsigned int )type_ac[set] == 140U) {
#line 1557
        goto case_140___13;
      }
#line 1557
      if ((unsigned int )type_ac[set] == 12U) {
#line 1557
        goto case_140___13;
      }
#line 1560
      if ((unsigned int )type_ac[set] == 280U) {
#line 1560
        goto case_280___9;
      }
#line 1563
      if ((unsigned int )type_ac[set] == 268U) {
#line 1563
        goto case_268___12;
      }
#line 1566
      if ((unsigned int )type_ac[set] == 32U) {
#line 1566
        goto case_32___8;
      }
#line 1569
      if ((unsigned int )type_ac[set] == 2U) {
#line 1569
        goto case_2___13;
      }
#line 1572
      if ((unsigned int )type_ac[set] == 130U) {
#line 1572
        goto case_130___13;
      }
#line 1575
      if ((unsigned int )type_ac[set] == 258U) {
#line 1575
        goto case_258___13;
      }
#line 1578
      if ((unsigned int )type_ac[set] == 1U) {
#line 1578
        goto case_1___8;
      }
#line 1581
      goto switch_default___14;
      case_136___12: /* CIL Label */ 
      case_8___12: /* CIL Label */ 
#line 1547
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1547
      ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 1547
      kodp += sizeof(struct OPERAND_0_mi );
#line 1548
      goto switch_break___15;
      case_264___11: /* CIL Label */ 
#line 1550
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1550
      ((struct OPERAND_0_mi *)kodp)->minor = 18;
#line 1550
      kodp += sizeof(struct OPERAND_0_mi );
#line 1551
      goto switch_break___15;
      case_152___10: /* CIL Label */ 
      case_24___10: /* CIL Label */ 
#line 1554
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1554
      ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 1554
      kodp += sizeof(struct OPERAND_0_mi );
#line 1555
      goto switch_break___15;
      case_140___13: /* CIL Label */ 
      case_12___13: /* CIL Label */ 
#line 1558
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1558
      ((struct OPERAND_0_mi *)kodp)->minor = 57;
#line 1558
      kodp += sizeof(struct OPERAND_0_mi );
#line 1559
      goto switch_break___15;
      case_280___9: /* CIL Label */ 
#line 1561
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1561
      ((struct OPERAND_0_mi *)kodp)->minor = 18;
#line 1561
      kodp += sizeof(struct OPERAND_0_mi );
#line 1562
      goto switch_break___15;
      case_268___12: /* CIL Label */ 
#line 1564
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1564
      ((struct OPERAND_0_mi *)kodp)->minor = 73;
#line 1564
      kodp += sizeof(struct OPERAND_0_mi );
#line 1565
      goto switch_break___15;
      case_32___8: /* CIL Label */ 
#line 1567
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1567
      ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 1567
      kodp += sizeof(struct OPERAND_0_mi );
#line 1568
      goto switch_break___15;
      case_2___13: /* CIL Label */ 
#line 1570
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1570
      ((struct OPERAND_0_mi *)kodp)->minor = 12;
#line 1570
      kodp += sizeof(struct OPERAND_0_mi );
#line 1571
      goto switch_break___15;
      case_130___13: /* CIL Label */ 
#line 1573
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1573
      ((struct OPERAND_0_mi *)kodp)->minor = 99;
#line 1573
      kodp += sizeof(struct OPERAND_0_mi );
#line 1574
      goto switch_break___15;
      case_258___13: /* CIL Label */ 
#line 1576
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1576
      ((struct OPERAND_0_mi *)kodp)->minor = 115;
#line 1576
      kodp += sizeof(struct OPERAND_0_mi );
#line 1577
      goto switch_break___15;
      case_1___8: /* CIL Label */ 
      {
#line 1579
      error_message(1009);
      }
#line 1580
      goto switch_break___15;
      switch_default___14: /* CIL Label */ 
      {
#line 1582
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1582);
#line 1583
      error_message(5000);
#line 1584
      abort();
      }
      switch_break___15: /* CIL Label */ ;
      }
#line 1586
      last_instr = current_instr;
#line 1586
      current_instr = kodp;
#line 1587
      return (1);
      case_32___9: /* CIL Label */ 
      {
#line 1592
      if ((unsigned int )type_ac[set] == 136U) {
#line 1592
        goto case_136___13;
      }
#line 1592
      if ((unsigned int )type_ac[set] == 8U) {
#line 1592
        goto case_136___13;
      }
#line 1595
      if ((unsigned int )type_ac[set] == 264U) {
#line 1595
        goto case_264___12;
      }
#line 1599
      if ((unsigned int )type_ac[set] == 152U) {
#line 1599
        goto case_152___11;
      }
#line 1599
      if ((unsigned int )type_ac[set] == 24U) {
#line 1599
        goto case_152___11;
      }
#line 1603
      if ((unsigned int )type_ac[set] == 140U) {
#line 1603
        goto case_140___14;
      }
#line 1603
      if ((unsigned int )type_ac[set] == 12U) {
#line 1603
        goto case_140___14;
      }
#line 1606
      if ((unsigned int )type_ac[set] == 280U) {
#line 1606
        goto case_280___10;
      }
#line 1609
      if ((unsigned int )type_ac[set] == 268U) {
#line 1609
        goto case_268___13;
      }
#line 1612
      if ((unsigned int )type_ac[set] == 2U) {
#line 1612
        goto case_2___14;
      }
#line 1615
      if ((unsigned int )type_ac[set] == 130U) {
#line 1615
        goto case_130___14;
      }
#line 1618
      if ((unsigned int )type_ac[set] == 258U) {
#line 1618
        goto case_258___14;
      }
#line 1621
      if ((unsigned int )type_ac[set] == 1U) {
#line 1621
        goto case_1___9;
      }
#line 1624
      goto switch_default___15;
      case_136___13: /* CIL Label */ 
      case_8___13: /* CIL Label */ 
#line 1593
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1593
      ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 1593
      kodp += sizeof(struct OPERAND_0_mi );
#line 1594
      goto switch_break___16;
      case_264___12: /* CIL Label */ 
#line 1596
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1596
      ((struct OPERAND_0_mi *)kodp)->minor = 20;
#line 1596
      kodp += sizeof(struct OPERAND_0_mi );
#line 1597
      goto switch_break___16;
      case_152___11: /* CIL Label */ 
      case_24___11: /* CIL Label */ 
#line 1600
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1600
      ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 1600
      kodp += sizeof(struct OPERAND_0_mi );
#line 1601
      goto switch_break___16;
      case_140___14: /* CIL Label */ 
      case_12___14: /* CIL Label */ 
#line 1604
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1604
      ((struct OPERAND_0_mi *)kodp)->minor = 59;
#line 1604
      kodp += sizeof(struct OPERAND_0_mi );
#line 1605
      goto switch_break___16;
      case_280___10: /* CIL Label */ 
#line 1607
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1607
      ((struct OPERAND_0_mi *)kodp)->minor = 20;
#line 1607
      kodp += sizeof(struct OPERAND_0_mi );
#line 1608
      goto switch_break___16;
      case_268___13: /* CIL Label */ 
#line 1610
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1610
      ((struct OPERAND_0_mi *)kodp)->minor = 75;
#line 1610
      kodp += sizeof(struct OPERAND_0_mi );
#line 1611
      goto switch_break___16;
      case_2___14: /* CIL Label */ 
#line 1613
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1613
      ((struct OPERAND_0_mi *)kodp)->minor = 15;
#line 1613
      kodp += sizeof(struct OPERAND_0_mi );
#line 1614
      goto switch_break___16;
      case_130___14: /* CIL Label */ 
#line 1616
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1616
      ((struct OPERAND_0_mi *)kodp)->minor = 101;
#line 1616
      kodp += sizeof(struct OPERAND_0_mi );
#line 1617
      goto switch_break___16;
      case_258___14: /* CIL Label */ 
#line 1619
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1619
      ((struct OPERAND_0_mi *)kodp)->minor = 117;
#line 1619
      kodp += sizeof(struct OPERAND_0_mi );
#line 1620
      goto switch_break___16;
      case_1___9: /* CIL Label */ 
      {
#line 1622
      error_message(1009);
      }
#line 1623
      goto switch_break___16;
      switch_default___15: /* CIL Label */ 
      {
#line 1625
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1625);
#line 1626
      error_message(5000);
#line 1627
      abort();
      }
      switch_break___16: /* CIL Label */ ;
      }
#line 1629
      last_instr = current_instr;
#line 1629
      current_instr = kodp;
#line 1630
      return (1);
      case_280___11: /* CIL Label */ 
      {
#line 1635
      if ((unsigned int )type_ac[set] == 136U) {
#line 1635
        goto case_136___14;
      }
#line 1635
      if ((unsigned int )type_ac[set] == 8U) {
#line 1635
        goto case_136___14;
      }
#line 1638
      if ((unsigned int )type_ac[set] == 264U) {
#line 1638
        goto case_264___13;
      }
#line 1642
      if ((unsigned int )type_ac[set] == 152U) {
#line 1642
        goto case_152___12;
      }
#line 1642
      if ((unsigned int )type_ac[set] == 24U) {
#line 1642
        goto case_152___12;
      }
#line 1646
      if ((unsigned int )type_ac[set] == 140U) {
#line 1646
        goto case_140___15;
      }
#line 1646
      if ((unsigned int )type_ac[set] == 12U) {
#line 1646
        goto case_140___15;
      }
#line 1649
      if ((unsigned int )type_ac[set] == 268U) {
#line 1649
        goto case_268___14;
      }
#line 1652
      if ((unsigned int )type_ac[set] == 2U) {
#line 1652
        goto case_2___15;
      }
#line 1655
      if ((unsigned int )type_ac[set] == 130U) {
#line 1655
        goto case_130___15;
      }
#line 1658
      if ((unsigned int )type_ac[set] == 258U) {
#line 1658
        goto case_258___15;
      }
#line 1661
      goto switch_default___16;
      case_136___14: /* CIL Label */ 
      case_8___14: /* CIL Label */ 
#line 1636
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1636
      ((struct OPERAND_0_mi *)kodp)->minor = 149;
#line 1636
      kodp += sizeof(struct OPERAND_0_mi );
#line 1637
      goto switch_break___17;
      case_264___13: /* CIL Label */ ;
#line 1640
      goto switch_break___17;
      case_152___12: /* CIL Label */ 
      case_24___12: /* CIL Label */ 
#line 1643
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1643
      ((struct OPERAND_0_mi *)kodp)->minor = 149;
#line 1643
      kodp += sizeof(struct OPERAND_0_mi );
#line 1644
      goto switch_break___17;
      case_140___15: /* CIL Label */ 
      case_12___15: /* CIL Label */ 
#line 1647
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1647
      ((struct OPERAND_0_mi *)kodp)->minor = 63;
#line 1647
      kodp += sizeof(struct OPERAND_0_mi );
#line 1648
      goto switch_break___17;
      case_268___14: /* CIL Label */ 
#line 1650
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1650
      ((struct OPERAND_0_mi *)kodp)->minor = 79;
#line 1650
      kodp += sizeof(struct OPERAND_0_mi );
#line 1651
      goto switch_break___17;
      case_2___15: /* CIL Label */ 
#line 1653
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1653
      ((struct OPERAND_0_mi *)kodp)->minor = 93;
#line 1653
      kodp += sizeof(struct OPERAND_0_mi );
#line 1654
      goto switch_break___17;
      case_130___15: /* CIL Label */ 
#line 1656
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1656
      ((struct OPERAND_0_mi *)kodp)->minor = 109;
#line 1656
      kodp += sizeof(struct OPERAND_0_mi );
#line 1657
      goto switch_break___17;
      case_258___15: /* CIL Label */ 
#line 1659
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1659
      ((struct OPERAND_0_mi *)kodp)->minor = 125;
#line 1659
      kodp += sizeof(struct OPERAND_0_mi );
#line 1660
      goto switch_break___17;
      switch_default___16: /* CIL Label */ 
      {
#line 1662
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1662);
#line 1663
      error_message(5000);
#line 1664
      abort();
      }
      switch_break___17: /* CIL Label */ ;
      }
#line 1666
      last_instr = current_instr;
#line 1666
      current_instr = kodp;
#line 1667
      return (1);
      case_24___13: /* CIL Label */ 
      {
#line 1672
      if ((unsigned int )type_ac[set] == 136U) {
#line 1672
        goto case_136___15;
      }
#line 1672
      if ((unsigned int )type_ac[set] == 8U) {
#line 1672
        goto case_136___15;
      }
#line 1675
      if ((unsigned int )type_ac[set] == 264U) {
#line 1675
        goto case_264___14;
      }
#line 1693
      if ((unsigned int )type_ac[set] == 140U) {
#line 1693
        goto case_140___16;
      }
#line 1693
      if ((unsigned int )type_ac[set] == 12U) {
#line 1693
        goto case_140___16;
      }
#line 1696
      if ((unsigned int )type_ac[set] == 268U) {
#line 1696
        goto case_268___15;
      }
#line 1699
      if ((unsigned int )type_ac[set] == 2U) {
#line 1699
        goto case_2___16;
      }
#line 1702
      if ((unsigned int )type_ac[set] == 130U) {
#line 1702
        goto case_130___16;
      }
#line 1705
      if ((unsigned int )type_ac[set] == 258U) {
#line 1705
        goto case_258___16;
      }
#line 1708
      goto switch_default___17;
      case_136___15: /* CIL Label */ 
      case_8___15: /* CIL Label */ ;
#line 1674
      goto switch_break___18;
      case_264___14: /* CIL Label */ ;
#line 1691
      goto switch_break___18;
      case_140___16: /* CIL Label */ 
      case_12___16: /* CIL Label */ 
#line 1694
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1694
      ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1694
      kodp += sizeof(struct OPERAND_0_mi );
#line 1695
      goto switch_break___18;
      case_268___15: /* CIL Label */ 
#line 1697
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1697
      ((struct OPERAND_0_mi *)kodp)->minor = 77;
#line 1697
      kodp += sizeof(struct OPERAND_0_mi );
#line 1698
      goto switch_break___18;
      case_2___16: /* CIL Label */ 
#line 1700
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1700
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1700
      kodp += sizeof(struct OPERAND_0_mi );
#line 1701
      goto switch_break___18;
      case_130___16: /* CIL Label */ 
#line 1703
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1703
      ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1703
      kodp += sizeof(struct OPERAND_0_mi );
#line 1704
      goto switch_break___18;
      case_258___16: /* CIL Label */ 
#line 1706
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1706
      ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1706
      kodp += sizeof(struct OPERAND_0_mi );
#line 1707
      goto switch_break___18;
      switch_default___17: /* CIL Label */ 
      {
#line 1709
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1709);
#line 1710
      error_message(5000);
#line 1711
      abort();
      }
      switch_break___18: /* CIL Label */ ;
      }
#line 1713
      last_instr = current_instr;
#line 1713
      current_instr = kodp;
#line 1714
      return (1);
      case_264___15: /* CIL Label */ 
      {
#line 1719
      if ((unsigned int )type_ac[set] == 136U) {
#line 1719
        goto case_136___16;
      }
#line 1719
      if ((unsigned int )type_ac[set] == 8U) {
#line 1719
        goto case_136___16;
      }
#line 1723
      if ((unsigned int )type_ac[set] == 140U) {
#line 1723
        goto case_140___17;
      }
#line 1723
      if ((unsigned int )type_ac[set] == 12U) {
#line 1723
        goto case_140___17;
      }
#line 1726
      if ((unsigned int )type_ac[set] == 2U) {
#line 1726
        goto case_2___17;
      }
#line 1729
      if ((unsigned int )type_ac[set] == 130U) {
#line 1729
        goto case_130___17;
      }
#line 1732
      if ((unsigned int )type_ac[set] == 258U) {
#line 1732
        goto case_258___17;
      }
#line 1735
      goto switch_default___18;
      case_136___16: /* CIL Label */ 
      case_8___16: /* CIL Label */ 
#line 1720
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1720
      ((struct OPERAND_0_mi *)kodp)->minor = 149;
#line 1720
      kodp += sizeof(struct OPERAND_0_mi );
#line 1721
      goto switch_break___19;
      case_140___17: /* CIL Label */ 
      case_12___17: /* CIL Label */ 
#line 1724
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1724
      ((struct OPERAND_0_mi *)kodp)->minor = 67;
#line 1724
      kodp += sizeof(struct OPERAND_0_mi );
#line 1725
      goto switch_break___19;
      case_2___17: /* CIL Label */ 
#line 1727
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1727
      ((struct OPERAND_0_mi *)kodp)->minor = 93;
#line 1727
      kodp += sizeof(struct OPERAND_0_mi );
#line 1728
      goto switch_break___19;
      case_130___17: /* CIL Label */ 
#line 1730
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1730
      ((struct OPERAND_0_mi *)kodp)->minor = 109;
#line 1730
      kodp += sizeof(struct OPERAND_0_mi );
#line 1731
      goto switch_break___19;
      case_258___17: /* CIL Label */ 
#line 1733
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1733
      ((struct OPERAND_0_mi *)kodp)->minor = 125;
#line 1733
      kodp += sizeof(struct OPERAND_0_mi );
#line 1734
      goto switch_break___19;
      switch_default___18: /* CIL Label */ 
      {
#line 1736
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1736);
#line 1737
      error_message(5000);
#line 1738
      abort();
      }
      switch_break___19: /* CIL Label */ ;
      }
#line 1740
      last_instr = current_instr;
#line 1740
      current_instr = kodp;
#line 1741
      return (1);
      case_8___17: /* CIL Label */ 
      {
#line 1745
      if ((unsigned int )type_ac[set] == 2U) {
#line 1745
        goto case_2___18;
      }
#line 1748
      if ((unsigned int )type_ac[set] == 130U) {
#line 1748
        goto case_130___18;
      }
#line 1751
      if ((unsigned int )type_ac[set] == 258U) {
#line 1751
        goto case_258___18;
      }
#line 1754
      if ((unsigned int )type_ac[set] == 1U) {
#line 1754
        goto case_1___10;
      }
#line 1757
      goto switch_default___19;
      case_2___18: /* CIL Label */ 
#line 1746
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1746
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1746
      kodp += sizeof(struct OPERAND_0_mi );
#line 1747
      goto switch_break___20;
      case_130___18: /* CIL Label */ 
#line 1749
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1749
      ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1749
      kodp += sizeof(struct OPERAND_0_mi );
#line 1750
      goto switch_break___20;
      case_258___18: /* CIL Label */ 
#line 1752
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1752
      ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1752
      kodp += sizeof(struct OPERAND_0_mi );
#line 1753
      goto switch_break___20;
      case_1___10: /* CIL Label */ 
      {
#line 1755
      error_message(1009);
      }
#line 1756
      goto switch_break___20;
      switch_default___19: /* CIL Label */ 
      {
#line 1758
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1758);
#line 1759
      error_message(5000);
#line 1760
      abort();
      }
      switch_break___20: /* CIL Label */ ;
      }
#line 1762
      last_instr = current_instr;
#line 1762
      current_instr = kodp;
#line 1763
      return (1);
      case_140___18: /* CIL Label */ 
      case_12___18: /* CIL Label */ 
      {
#line 1769
      if ((unsigned int )type_ac[set] == 136U) {
#line 1769
        goto case_136___17;
      }
#line 1769
      if ((unsigned int )type_ac[set] == 8U) {
#line 1769
        goto case_136___17;
      }
#line 1773
      if ((unsigned int )type_ac[set] == 264U) {
#line 1773
        goto case_264___16;
      }
#line 1778
      if ((unsigned int )type_ac[set] == 152U) {
#line 1778
        goto case_152___13;
      }
#line 1778
      if ((unsigned int )type_ac[set] == 24U) {
#line 1778
        goto case_152___13;
      }
#line 1783
      if ((unsigned int )type_ac[set] == 140U) {
#line 1783
        goto case_140___19;
      }
#line 1783
      if ((unsigned int )type_ac[set] == 12U) {
#line 1783
        goto case_140___19;
      }
#line 1789
      if ((unsigned int )type_ac[set] == 280U) {
#line 1789
        goto case_280___12;
      }
#line 1793
      if ((unsigned int )type_ac[set] == 268U) {
#line 1793
        goto case_268___16;
      }
#line 1799
      if ((unsigned int )type_ac[set] == 64U) {
#line 1799
        goto case_64___8;
      }
#line 1803
      if ((unsigned int )type_ac[set] == 80U) {
#line 1803
        goto case_80___6;
      }
#line 1807
      if ((unsigned int )type_ac[set] == 32U) {
#line 1807
        goto case_32___10;
      }
#line 1811
      if ((unsigned int )type_ac[set] == 2U) {
#line 1811
        goto case_2___19;
      }
#line 1817
      if ((unsigned int )type_ac[set] == 130U) {
#line 1817
        goto case_130___19;
      }
#line 1823
      if ((unsigned int )type_ac[set] == 258U) {
#line 1823
        goto case_258___19;
      }
#line 1829
      if ((unsigned int )type_ac[set] == 1U) {
#line 1829
        goto case_1___11;
      }
#line 1832
      goto switch_default___20;
      case_136___17: /* CIL Label */ 
      case_8___18: /* CIL Label */ 
#line 1770
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1770
      ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1770
      kodp += sizeof(struct OPERAND_0_mi );
#line 1771
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1772
      goto switch_break___21;
      case_264___16: /* CIL Label */ 
#line 1774
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1774
      ((struct OPERAND_0_mi *)kodp)->minor = 68;
#line 1774
      kodp += sizeof(struct OPERAND_0_mi );
#line 1775
      type_ac[set - 1] = (enum intern_arit_class )264;
#line 1776
      goto switch_break___21;
      case_152___13: /* CIL Label */ 
      case_24___14: /* CIL Label */ 
#line 1779
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1779
      ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1779
      kodp += sizeof(struct OPERAND_0_mi );
#line 1780
      type_ac[set - 1] = (enum intern_arit_class )24;
#line 1781
      goto switch_break___21;
      case_140___19: /* CIL Label */ 
      case_12___19: /* CIL Label */ 
#line 1784
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1784
      ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1784
      kodp += sizeof(struct OPERAND_0_mi );
#line 1784
      last_instr = current_instr;
#line 1784
      current_instr = kodp;
#line 1785
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1786
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1786
      ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1786
      kodp += sizeof(struct OPERAND_0_mi );
#line 1787
      type_ac[set] = (enum intern_arit_class )8;
#line 1788
      goto switch_break___21;
      case_280___12: /* CIL Label */ 
#line 1790
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1790
      ((struct OPERAND_0_mi *)kodp)->minor = 64;
#line 1790
      kodp += sizeof(struct OPERAND_0_mi );
#line 1791
      type_ac[set - 1] = (enum intern_arit_class )280;
#line 1792
      goto switch_break___21;
      case_268___16: /* CIL Label */ 
#line 1794
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1794
      ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1794
      kodp += sizeof(struct OPERAND_0_mi );
#line 1794
      last_instr = current_instr;
#line 1794
      current_instr = kodp;
#line 1795
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1796
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1796
      ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 1796
      kodp += sizeof(struct OPERAND_0_mi );
#line 1797
      type_ac[set] = (enum intern_arit_class )8;
#line 1798
      goto switch_break___21;
      case_64___8: /* CIL Label */ 
#line 1800
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1800
      ((struct OPERAND_0_mi *)kodp)->minor = 58;
#line 1800
      kodp += sizeof(struct OPERAND_0_mi );
#line 1801
      type_ac[set - 1] = (enum intern_arit_class )64;
#line 1802
      goto switch_break___21;
      case_80___6: /* CIL Label */ 
#line 1804
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1804
      ((struct OPERAND_0_mi *)kodp)->minor = 173;
#line 1804
      kodp += sizeof(struct OPERAND_0_mi );
#line 1805
      type_ac[set - 1] = (enum intern_arit_class )80;
#line 1806
      goto switch_break___21;
      case_32___10: /* CIL Label */ 
#line 1808
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1808
      ((struct OPERAND_0_mi *)kodp)->minor = 60;
#line 1808
      kodp += sizeof(struct OPERAND_0_mi );
#line 1809
      type_ac[set - 1] = (enum intern_arit_class )32;
#line 1810
      goto switch_break___21;
      case_2___19: /* CIL Label */ 
#line 1812
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1812
      ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1812
      kodp += sizeof(struct OPERAND_0_mi );
#line 1812
      last_instr = current_instr;
#line 1812
      current_instr = kodp;
#line 1813
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1814
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1814
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1814
      kodp += sizeof(struct OPERAND_0_mi );
#line 1815
      type_ac[set] = (enum intern_arit_class )8;
#line 1816
      goto switch_break___21;
      case_130___19: /* CIL Label */ 
#line 1818
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1818
      ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1818
      kodp += sizeof(struct OPERAND_0_mi );
#line 1818
      last_instr = current_instr;
#line 1818
      current_instr = kodp;
#line 1819
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1820
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1820
      ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1820
      kodp += sizeof(struct OPERAND_0_mi );
#line 1821
      type_ac[set] = (enum intern_arit_class )8;
#line 1822
      goto switch_break___21;
      case_258___19: /* CIL Label */ 
#line 1824
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1824
      ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1824
      kodp += sizeof(struct OPERAND_0_mi );
#line 1824
      last_instr = current_instr;
#line 1824
      current_instr = kodp;
#line 1825
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1826
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1826
      ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1826
      kodp += sizeof(struct OPERAND_0_mi );
#line 1827
      type_ac[set] = (enum intern_arit_class )8;
#line 1828
      goto switch_break___21;
      case_1___11: /* CIL Label */ 
      {
#line 1830
      error_message(1009);
      }
#line 1831
      goto switch_break___21;
      switch_default___20: /* CIL Label */ 
      {
#line 1833
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1833);
#line 1834
      error_message(5000);
#line 1835
      abort();
      }
      switch_break___21: /* CIL Label */ ;
      }
#line 1837
      last_instr = current_instr;
#line 1837
      current_instr = kodp;
#line 1838
      return (1);
      case_268___17: /* CIL Label */ 
      {
#line 1843
      if ((unsigned int )type_ac[set] == 136U) {
#line 1843
        goto case_136___18;
      }
#line 1843
      if ((unsigned int )type_ac[set] == 8U) {
#line 1843
        goto case_136___18;
      }
#line 1847
      if ((unsigned int )type_ac[set] == 264U) {
#line 1847
        goto case_264___17;
      }
#line 1852
      if ((unsigned int )type_ac[set] == 152U) {
#line 1852
        goto case_152___14;
      }
#line 1852
      if ((unsigned int )type_ac[set] == 24U) {
#line 1852
        goto case_152___14;
      }
#line 1857
      if ((unsigned int )type_ac[set] == 140U) {
#line 1857
        goto case_140___20;
      }
#line 1857
      if ((unsigned int )type_ac[set] == 12U) {
#line 1857
        goto case_140___20;
      }
#line 1863
      if ((unsigned int )type_ac[set] == 280U) {
#line 1863
        goto case_280___13;
      }
#line 1867
      if ((unsigned int )type_ac[set] == 268U) {
#line 1867
        goto case_268___18;
      }
#line 1873
      if ((unsigned int )type_ac[set] == 64U) {
#line 1873
        goto case_64___9;
      }
#line 1877
      if ((unsigned int )type_ac[set] == 80U) {
#line 1877
        goto case_80___7;
      }
#line 1881
      if ((unsigned int )type_ac[set] == 32U) {
#line 1881
        goto case_32___11;
      }
#line 1885
      if ((unsigned int )type_ac[set] == 2U) {
#line 1885
        goto case_2___20;
      }
#line 1891
      if ((unsigned int )type_ac[set] == 130U) {
#line 1891
        goto case_130___20;
      }
#line 1897
      if ((unsigned int )type_ac[set] == 258U) {
#line 1897
        goto case_258___20;
      }
#line 1903
      if ((unsigned int )type_ac[set] == 1U) {
#line 1903
        goto case_1___12;
      }
#line 1906
      goto switch_default___21;
      case_136___18: /* CIL Label */ 
      case_8___19: /* CIL Label */ 
#line 1844
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1844
      ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1844
      kodp += sizeof(struct OPERAND_0_mi );
#line 1845
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1846
      goto switch_break___22;
      case_264___17: /* CIL Label */ 
#line 1848
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1848
      ((struct OPERAND_0_mi *)kodp)->minor = 84;
#line 1848
      kodp += sizeof(struct OPERAND_0_mi );
#line 1849
      type_ac[set - 1] = (enum intern_arit_class )264;
#line 1850
      goto switch_break___22;
      case_152___14: /* CIL Label */ 
      case_24___15: /* CIL Label */ 
#line 1853
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1853
      ((struct OPERAND_0_mi *)kodp)->minor = 78;
#line 1853
      kodp += sizeof(struct OPERAND_0_mi );
#line 1854
      type_ac[set - 1] = (enum intern_arit_class )24;
#line 1855
      goto switch_break___22;
      case_140___20: /* CIL Label */ 
      case_12___20: /* CIL Label */ 
#line 1858
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1858
      ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1858
      kodp += sizeof(struct OPERAND_0_mi );
#line 1858
      last_instr = current_instr;
#line 1858
      current_instr = kodp;
#line 1859
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1860
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1860
      ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1860
      kodp += sizeof(struct OPERAND_0_mi );
#line 1861
      type_ac[set] = (enum intern_arit_class )8;
#line 1862
      goto switch_break___22;
      case_280___13: /* CIL Label */ 
#line 1864
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1864
      ((struct OPERAND_0_mi *)kodp)->minor = 80;
#line 1864
      kodp += sizeof(struct OPERAND_0_mi );
#line 1865
      type_ac[set - 1] = (enum intern_arit_class )280;
#line 1866
      goto switch_break___22;
      case_268___18: /* CIL Label */ 
#line 1868
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1868
      ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1868
      kodp += sizeof(struct OPERAND_0_mi );
#line 1868
      last_instr = current_instr;
#line 1868
      current_instr = kodp;
#line 1869
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1870
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1870
      ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 1870
      kodp += sizeof(struct OPERAND_0_mi );
#line 1871
      type_ac[set] = (enum intern_arit_class )8;
#line 1872
      goto switch_break___22;
      case_64___9: /* CIL Label */ 
#line 1874
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1874
      ((struct OPERAND_0_mi *)kodp)->minor = 74;
#line 1874
      kodp += sizeof(struct OPERAND_0_mi );
#line 1875
      type_ac[set - 1] = (enum intern_arit_class )64;
#line 1876
      goto switch_break___22;
      case_80___7: /* CIL Label */ 
#line 1878
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1878
      ((struct OPERAND_0_mi *)kodp)->minor = 177;
#line 1878
      kodp += sizeof(struct OPERAND_0_mi );
#line 1879
      type_ac[set - 1] = (enum intern_arit_class )80;
#line 1880
      goto switch_break___22;
      case_32___11: /* CIL Label */ 
#line 1882
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1882
      ((struct OPERAND_0_mi *)kodp)->minor = 76;
#line 1882
      kodp += sizeof(struct OPERAND_0_mi );
#line 1883
      type_ac[set - 1] = (enum intern_arit_class )32;
#line 1884
      goto switch_break___22;
      case_2___20: /* CIL Label */ 
#line 1886
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1886
      ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1886
      kodp += sizeof(struct OPERAND_0_mi );
#line 1886
      last_instr = current_instr;
#line 1886
      current_instr = kodp;
#line 1887
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1888
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1888
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1888
      kodp += sizeof(struct OPERAND_0_mi );
#line 1889
      type_ac[set] = (enum intern_arit_class )8;
#line 1890
      goto switch_break___22;
      case_130___20: /* CIL Label */ 
#line 1892
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1892
      ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 1892
      kodp += sizeof(struct OPERAND_0_mi );
#line 1892
      last_instr = current_instr;
#line 1892
      current_instr = kodp;
#line 1893
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1894
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1894
      ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1894
      kodp += sizeof(struct OPERAND_0_mi );
#line 1895
      type_ac[set] = (enum intern_arit_class )8;
#line 1896
      goto switch_break___22;
      case_258___20: /* CIL Label */ 
#line 1898
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1898
      ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 1898
      kodp += sizeof(struct OPERAND_0_mi );
#line 1898
      last_instr = current_instr;
#line 1898
      current_instr = kodp;
#line 1899
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1900
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1900
      ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1900
      kodp += sizeof(struct OPERAND_0_mi );
#line 1901
      type_ac[set] = (enum intern_arit_class )8;
#line 1902
      goto switch_break___22;
      case_1___12: /* CIL Label */ 
      {
#line 1904
      error_message(1009);
      }
#line 1905
      goto switch_break___22;
      switch_default___21: /* CIL Label */ 
      {
#line 1907
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1907);
#line 1908
      error_message(5000);
#line 1909
      abort();
      }
      switch_break___22: /* CIL Label */ ;
      }
#line 1911
      last_instr = current_instr;
#line 1911
      current_instr = kodp;
#line 1912
      return (1);
      case_2___21: /* CIL Label */ 
      {
#line 1917
      if ((unsigned int )type_ac[set] == 136U) {
#line 1917
        goto case_136___19;
      }
#line 1917
      if ((unsigned int )type_ac[set] == 8U) {
#line 1917
        goto case_136___19;
      }
#line 1921
      if ((unsigned int )type_ac[set] == 264U) {
#line 1921
        goto case_264___18;
      }
#line 1926
      if ((unsigned int )type_ac[set] == 152U) {
#line 1926
        goto case_152___15;
      }
#line 1926
      if ((unsigned int )type_ac[set] == 24U) {
#line 1926
        goto case_152___15;
      }
#line 1931
      if ((unsigned int )type_ac[set] == 140U) {
#line 1931
        goto case_140___21;
      }
#line 1931
      if ((unsigned int )type_ac[set] == 12U) {
#line 1931
        goto case_140___21;
      }
#line 1937
      if ((unsigned int )type_ac[set] == 280U) {
#line 1937
        goto case_280___14;
      }
#line 1941
      if ((unsigned int )type_ac[set] == 268U) {
#line 1941
        goto case_268___19;
      }
#line 1947
      if ((unsigned int )type_ac[set] == 64U) {
#line 1947
        goto case_64___10;
      }
#line 1951
      if ((unsigned int )type_ac[set] == 80U) {
#line 1951
        goto case_80___8;
      }
#line 1955
      if ((unsigned int )type_ac[set] == 32U) {
#line 1955
        goto case_32___12;
      }
#line 1959
      if ((unsigned int )type_ac[set] == 2U) {
#line 1959
        goto case_2___22;
      }
#line 1965
      if ((unsigned int )type_ac[set] == 130U) {
#line 1965
        goto case_130___21;
      }
#line 1971
      if ((unsigned int )type_ac[set] == 258U) {
#line 1971
        goto case_258___21;
      }
#line 1977
      if ((unsigned int )type_ac[set] == 1U) {
#line 1977
        goto case_1___13;
      }
#line 1980
      goto switch_default___22;
      case_136___19: /* CIL Label */ 
      case_8___20: /* CIL Label */ 
#line 1918
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1918
      ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1918
      kodp += sizeof(struct OPERAND_0_mi );
#line 1919
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1920
      goto switch_break___23;
      case_264___18: /* CIL Label */ 
#line 1922
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1922
      ((struct OPERAND_0_mi *)kodp)->minor = 94;
#line 1922
      kodp += sizeof(struct OPERAND_0_mi );
#line 1923
      type_ac[set - 1] = (enum intern_arit_class )264;
#line 1924
      goto switch_break___23;
      case_152___15: /* CIL Label */ 
      case_24___16: /* CIL Label */ 
#line 1927
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1927
      ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1927
      kodp += sizeof(struct OPERAND_0_mi );
#line 1928
      type_ac[set - 1] = (enum intern_arit_class )24;
#line 1929
      goto switch_break___23;
      case_140___21: /* CIL Label */ 
      case_12___21: /* CIL Label */ 
#line 1932
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1932
      ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1932
      kodp += sizeof(struct OPERAND_0_mi );
#line 1932
      last_instr = current_instr;
#line 1932
      current_instr = kodp;
#line 1933
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1934
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1934
      ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 1934
      kodp += sizeof(struct OPERAND_0_mi );
#line 1935
      type_ac[set] = (enum intern_arit_class )8;
#line 1936
      goto switch_break___23;
      case_280___14: /* CIL Label */ 
#line 1938
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1938
      ((struct OPERAND_0_mi *)kodp)->minor = 94;
#line 1938
      kodp += sizeof(struct OPERAND_0_mi );
#line 1939
      type_ac[set - 1] = (enum intern_arit_class )280;
#line 1940
      goto switch_break___23;
      case_268___19: /* CIL Label */ 
#line 1942
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1942
      ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1942
      kodp += sizeof(struct OPERAND_0_mi );
#line 1942
      last_instr = current_instr;
#line 1942
      current_instr = kodp;
#line 1943
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1944
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1944
      ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 1944
      kodp += sizeof(struct OPERAND_0_mi );
#line 1945
      type_ac[set] = (enum intern_arit_class )8;
#line 1946
      goto switch_break___23;
      case_64___10: /* CIL Label */ 
#line 1948
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1948
      ((struct OPERAND_0_mi *)kodp)->minor = 13;
#line 1948
      kodp += sizeof(struct OPERAND_0_mi );
#line 1949
      type_ac[set - 1] = (enum intern_arit_class )64;
#line 1950
      goto switch_break___23;
      case_80___8: /* CIL Label */ 
#line 1952
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1952
      ((struct OPERAND_0_mi *)kodp)->minor = 183;
#line 1952
      kodp += sizeof(struct OPERAND_0_mi );
#line 1953
      type_ac[set - 1] = (enum intern_arit_class )80;
#line 1954
      goto switch_break___23;
      case_32___12: /* CIL Label */ 
#line 1956
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1956
      ((struct OPERAND_0_mi *)kodp)->minor = 16;
#line 1956
      kodp += sizeof(struct OPERAND_0_mi );
#line 1957
      type_ac[set - 1] = (enum intern_arit_class )32;
#line 1958
      goto switch_break___23;
      case_2___22: /* CIL Label */ 
#line 1960
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1960
      ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1960
      kodp += sizeof(struct OPERAND_0_mi );
#line 1960
      last_instr = current_instr;
#line 1960
      current_instr = kodp;
#line 1961
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1962
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1962
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1962
      kodp += sizeof(struct OPERAND_0_mi );
#line 1963
      type_ac[set] = (enum intern_arit_class )8;
#line 1964
      goto switch_break___23;
      case_130___21: /* CIL Label */ 
#line 1966
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1966
      ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1966
      kodp += sizeof(struct OPERAND_0_mi );
#line 1966
      last_instr = current_instr;
#line 1966
      current_instr = kodp;
#line 1967
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1968
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1968
      ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 1968
      kodp += sizeof(struct OPERAND_0_mi );
#line 1969
      type_ac[set] = (enum intern_arit_class )8;
#line 1970
      goto switch_break___23;
      case_258___21: /* CIL Label */ 
#line 1972
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1972
      ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 1972
      kodp += sizeof(struct OPERAND_0_mi );
#line 1972
      last_instr = current_instr;
#line 1972
      current_instr = kodp;
#line 1973
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1974
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1974
      ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 1974
      kodp += sizeof(struct OPERAND_0_mi );
#line 1975
      type_ac[set] = (enum intern_arit_class )8;
#line 1976
      goto switch_break___23;
      case_1___13: /* CIL Label */ 
      {
#line 1978
      error_message(1009);
      }
#line 1979
      goto switch_break___23;
      switch_default___22: /* CIL Label */ 
      {
#line 1981
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               1981);
#line 1982
      error_message(5000);
#line 1983
      abort();
      }
      switch_break___23: /* CIL Label */ ;
      }
#line 1985
      last_instr = current_instr;
#line 1985
      current_instr = kodp;
#line 1986
      return (1);
      case_130___22: /* CIL Label */ 
      {
#line 1991
      if ((unsigned int )type_ac[set] == 136U) {
#line 1991
        goto case_136___20;
      }
#line 1991
      if ((unsigned int )type_ac[set] == 8U) {
#line 1991
        goto case_136___20;
      }
#line 1995
      if ((unsigned int )type_ac[set] == 264U) {
#line 1995
        goto case_264___19;
      }
#line 2000
      if ((unsigned int )type_ac[set] == 152U) {
#line 2000
        goto case_152___16;
      }
#line 2000
      if ((unsigned int )type_ac[set] == 24U) {
#line 2000
        goto case_152___16;
      }
#line 2005
      if ((unsigned int )type_ac[set] == 140U) {
#line 2005
        goto case_140___22;
      }
#line 2005
      if ((unsigned int )type_ac[set] == 12U) {
#line 2005
        goto case_140___22;
      }
#line 2011
      if ((unsigned int )type_ac[set] == 280U) {
#line 2011
        goto case_280___15;
      }
#line 2015
      if ((unsigned int )type_ac[set] == 268U) {
#line 2015
        goto case_268___20;
      }
#line 2021
      if ((unsigned int )type_ac[set] == 64U) {
#line 2021
        goto case_64___11;
      }
#line 2025
      if ((unsigned int )type_ac[set] == 80U) {
#line 2025
        goto case_80___9;
      }
#line 2029
      if ((unsigned int )type_ac[set] == 32U) {
#line 2029
        goto case_32___13;
      }
#line 2033
      if ((unsigned int )type_ac[set] == 2U) {
#line 2033
        goto case_2___23;
      }
#line 2039
      if ((unsigned int )type_ac[set] == 130U) {
#line 2039
        goto case_130___23;
      }
#line 2045
      if ((unsigned int )type_ac[set] == 258U) {
#line 2045
        goto case_258___22;
      }
#line 2051
      if ((unsigned int )type_ac[set] == 1U) {
#line 2051
        goto case_1___14;
      }
#line 2054
      goto switch_default___23;
      case_136___20: /* CIL Label */ 
      case_8___21: /* CIL Label */ 
#line 1992
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1992
      ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 1992
      kodp += sizeof(struct OPERAND_0_mi );
#line 1993
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 1994
      goto switch_break___24;
      case_264___19: /* CIL Label */ 
#line 1996
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 1996
      ((struct OPERAND_0_mi *)kodp)->minor = 110;
#line 1996
      kodp += sizeof(struct OPERAND_0_mi );
#line 1997
      type_ac[set - 1] = (enum intern_arit_class )264;
#line 1998
      goto switch_break___24;
      case_152___16: /* CIL Label */ 
      case_24___17: /* CIL Label */ 
#line 2001
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2001
      ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 2001
      kodp += sizeof(struct OPERAND_0_mi );
#line 2002
      type_ac[set - 1] = (enum intern_arit_class )24;
#line 2003
      goto switch_break___24;
      case_140___22: /* CIL Label */ 
      case_12___22: /* CIL Label */ 
#line 2006
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2006
      ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 2006
      kodp += sizeof(struct OPERAND_0_mi );
#line 2006
      last_instr = current_instr;
#line 2006
      current_instr = kodp;
#line 2007
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2008
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2008
      ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 2008
      kodp += sizeof(struct OPERAND_0_mi );
#line 2009
      type_ac[set] = (enum intern_arit_class )8;
#line 2010
      goto switch_break___24;
      case_280___15: /* CIL Label */ 
#line 2012
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2012
      ((struct OPERAND_0_mi *)kodp)->minor = 110;
#line 2012
      kodp += sizeof(struct OPERAND_0_mi );
#line 2013
      type_ac[set - 1] = (enum intern_arit_class )280;
#line 2014
      goto switch_break___24;
      case_268___20: /* CIL Label */ 
#line 2016
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2016
      ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 2016
      kodp += sizeof(struct OPERAND_0_mi );
#line 2016
      last_instr = current_instr;
#line 2016
      current_instr = kodp;
#line 2017
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2018
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2018
      ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 2018
      kodp += sizeof(struct OPERAND_0_mi );
#line 2019
      type_ac[set] = (enum intern_arit_class )8;
#line 2020
      goto switch_break___24;
      case_64___11: /* CIL Label */ 
#line 2022
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2022
      ((struct OPERAND_0_mi *)kodp)->minor = 100;
#line 2022
      kodp += sizeof(struct OPERAND_0_mi );
#line 2023
      type_ac[set - 1] = (enum intern_arit_class )64;
#line 2024
      goto switch_break___24;
      case_80___9: /* CIL Label */ 
#line 2026
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2026
      ((struct OPERAND_0_mi *)kodp)->minor = 185;
#line 2026
      kodp += sizeof(struct OPERAND_0_mi );
#line 2027
      type_ac[set - 1] = (enum intern_arit_class )80;
#line 2028
      goto switch_break___24;
      case_32___13: /* CIL Label */ 
#line 2030
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2030
      ((struct OPERAND_0_mi *)kodp)->minor = 102;
#line 2030
      kodp += sizeof(struct OPERAND_0_mi );
#line 2031
      type_ac[set - 1] = (enum intern_arit_class )32;
#line 2032
      goto switch_break___24;
      case_2___23: /* CIL Label */ 
#line 2034
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2034
      ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 2034
      kodp += sizeof(struct OPERAND_0_mi );
#line 2034
      last_instr = current_instr;
#line 2034
      current_instr = kodp;
#line 2035
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2036
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2036
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 2036
      kodp += sizeof(struct OPERAND_0_mi );
#line 2037
      type_ac[set] = (enum intern_arit_class )8;
#line 2038
      goto switch_break___24;
      case_130___23: /* CIL Label */ 
#line 2040
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2040
      ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 2040
      kodp += sizeof(struct OPERAND_0_mi );
#line 2040
      last_instr = current_instr;
#line 2040
      current_instr = kodp;
#line 2041
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2042
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2042
      ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 2042
      kodp += sizeof(struct OPERAND_0_mi );
#line 2043
      type_ac[set] = (enum intern_arit_class )8;
#line 2044
      goto switch_break___24;
      case_258___22: /* CIL Label */ 
#line 2046
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2046
      ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 2046
      kodp += sizeof(struct OPERAND_0_mi );
#line 2046
      last_instr = current_instr;
#line 2046
      current_instr = kodp;
#line 2047
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2048
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2048
      ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 2048
      kodp += sizeof(struct OPERAND_0_mi );
#line 2049
      type_ac[set] = (enum intern_arit_class )8;
#line 2050
      goto switch_break___24;
      case_1___14: /* CIL Label */ 
      {
#line 2052
      error_message(1009);
      }
#line 2053
      goto switch_break___24;
      switch_default___23: /* CIL Label */ 
      {
#line 2055
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               2055);
#line 2056
      error_message(5000);
#line 2057
      abort();
      }
      switch_break___24: /* CIL Label */ ;
      }
#line 2059
      last_instr = current_instr;
#line 2059
      current_instr = kodp;
#line 2060
      return (1);
      case_258___23: /* CIL Label */ 
      {
#line 2065
      if ((unsigned int )type_ac[set] == 136U) {
#line 2065
        goto case_136___21;
      }
#line 2065
      if ((unsigned int )type_ac[set] == 8U) {
#line 2065
        goto case_136___21;
      }
#line 2069
      if ((unsigned int )type_ac[set] == 264U) {
#line 2069
        goto case_264___20;
      }
#line 2074
      if ((unsigned int )type_ac[set] == 152U) {
#line 2074
        goto case_152___17;
      }
#line 2074
      if ((unsigned int )type_ac[set] == 24U) {
#line 2074
        goto case_152___17;
      }
#line 2079
      if ((unsigned int )type_ac[set] == 140U) {
#line 2079
        goto case_140___23;
      }
#line 2079
      if ((unsigned int )type_ac[set] == 12U) {
#line 2079
        goto case_140___23;
      }
#line 2085
      if ((unsigned int )type_ac[set] == 280U) {
#line 2085
        goto case_280___16;
      }
#line 2089
      if ((unsigned int )type_ac[set] == 268U) {
#line 2089
        goto case_268___21;
      }
#line 2095
      if ((unsigned int )type_ac[set] == 64U) {
#line 2095
        goto case_64___12;
      }
#line 2099
      if ((unsigned int )type_ac[set] == 80U) {
#line 2099
        goto case_80___10;
      }
#line 2103
      if ((unsigned int )type_ac[set] == 32U) {
#line 2103
        goto case_32___14;
      }
#line 2107
      if ((unsigned int )type_ac[set] == 2U) {
#line 2107
        goto case_2___24;
      }
#line 2113
      if ((unsigned int )type_ac[set] == 130U) {
#line 2113
        goto case_130___24;
      }
#line 2119
      if ((unsigned int )type_ac[set] == 258U) {
#line 2119
        goto case_258___24;
      }
#line 2125
      if ((unsigned int )type_ac[set] == 1U) {
#line 2125
        goto case_1___15;
      }
#line 2128
      goto switch_default___24;
      case_136___21: /* CIL Label */ 
      case_8___22: /* CIL Label */ 
#line 2066
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2066
      ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 2066
      kodp += sizeof(struct OPERAND_0_mi );
#line 2067
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2068
      goto switch_break___25;
      case_264___20: /* CIL Label */ 
#line 2070
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2070
      ((struct OPERAND_0_mi *)kodp)->minor = 126;
#line 2070
      kodp += sizeof(struct OPERAND_0_mi );
#line 2071
      type_ac[set - 1] = (enum intern_arit_class )264;
#line 2072
      goto switch_break___25;
      case_152___17: /* CIL Label */ 
      case_24___18: /* CIL Label */ 
#line 2075
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2075
      ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 2075
      kodp += sizeof(struct OPERAND_0_mi );
#line 2076
      type_ac[set - 1] = (enum intern_arit_class )24;
#line 2077
      goto switch_break___25;
      case_140___23: /* CIL Label */ 
      case_12___23: /* CIL Label */ 
#line 2080
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2080
      ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 2080
      kodp += sizeof(struct OPERAND_0_mi );
#line 2080
      last_instr = current_instr;
#line 2080
      current_instr = kodp;
#line 2081
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2082
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2082
      ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 2082
      kodp += sizeof(struct OPERAND_0_mi );
#line 2083
      type_ac[set] = (enum intern_arit_class )8;
#line 2084
      goto switch_break___25;
      case_280___16: /* CIL Label */ 
#line 2086
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2086
      ((struct OPERAND_0_mi *)kodp)->minor = 126;
#line 2086
      kodp += sizeof(struct OPERAND_0_mi );
#line 2087
      type_ac[set - 1] = (enum intern_arit_class )280;
#line 2088
      goto switch_break___25;
      case_268___21: /* CIL Label */ 
#line 2090
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2090
      ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 2090
      kodp += sizeof(struct OPERAND_0_mi );
#line 2090
      last_instr = current_instr;
#line 2090
      current_instr = kodp;
#line 2091
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2092
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2092
      ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 2092
      kodp += sizeof(struct OPERAND_0_mi );
#line 2093
      type_ac[set] = (enum intern_arit_class )8;
#line 2094
      goto switch_break___25;
      case_64___12: /* CIL Label */ 
#line 2096
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2096
      ((struct OPERAND_0_mi *)kodp)->minor = 116;
#line 2096
      kodp += sizeof(struct OPERAND_0_mi );
#line 2097
      type_ac[set - 1] = (enum intern_arit_class )64;
#line 2098
      goto switch_break___25;
      case_80___10: /* CIL Label */ 
#line 2100
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2100
      ((struct OPERAND_0_mi *)kodp)->minor = 187;
#line 2100
      kodp += sizeof(struct OPERAND_0_mi );
#line 2101
      type_ac[set - 1] = (enum intern_arit_class )80;
#line 2102
      goto switch_break___25;
      case_32___14: /* CIL Label */ 
#line 2104
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2104
      ((struct OPERAND_0_mi *)kodp)->minor = 118;
#line 2104
      kodp += sizeof(struct OPERAND_0_mi );
#line 2105
      type_ac[set - 1] = (enum intern_arit_class )32;
#line 2106
      goto switch_break___25;
      case_2___24: /* CIL Label */ 
#line 2108
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2108
      ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 2108
      kodp += sizeof(struct OPERAND_0_mi );
#line 2108
      last_instr = current_instr;
#line 2108
      current_instr = kodp;
#line 2109
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2110
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2110
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 2110
      kodp += sizeof(struct OPERAND_0_mi );
#line 2111
      type_ac[set] = (enum intern_arit_class )8;
#line 2112
      goto switch_break___25;
      case_130___24: /* CIL Label */ 
#line 2114
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2114
      ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 2114
      kodp += sizeof(struct OPERAND_0_mi );
#line 2114
      last_instr = current_instr;
#line 2114
      current_instr = kodp;
#line 2115
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2116
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2116
      ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 2116
      kodp += sizeof(struct OPERAND_0_mi );
#line 2117
      type_ac[set] = (enum intern_arit_class )8;
#line 2118
      goto switch_break___25;
      case_258___24: /* CIL Label */ 
#line 2120
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2120
      ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 2120
      kodp += sizeof(struct OPERAND_0_mi );
#line 2120
      last_instr = current_instr;
#line 2120
      current_instr = kodp;
#line 2121
      type_ac[set - 1] = (enum intern_arit_class )8;
#line 2122
      ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2122
      ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 2122
      kodp += sizeof(struct OPERAND_0_mi );
#line 2123
      type_ac[set] = (enum intern_arit_class )8;
#line 2124
      goto switch_break___25;
      case_1___15: /* CIL Label */ 
      {
#line 2126
      error_message(1009);
      }
#line 2127
      goto switch_break___25;
      switch_default___24: /* CIL Label */ 
      {
#line 2129
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               2129);
#line 2130
      error_message(5000);
#line 2131
      abort();
      }
      switch_break___25: /* CIL Label */ ;
      }
#line 2133
      last_instr = current_instr;
#line 2133
      current_instr = kodp;
#line 2134
      return (1);
      switch_default___25: /* CIL Label */ 
      {
#line 2136
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               2136);
#line 2137
      error_message(5000);
#line 2138
      abort();
      }
      switch_break___13: /* CIL Label */ ;
      }
    } else {
#line 2143
      if (2U == (unsigned int )type_ac[set]) {
#line 2145
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2145
        ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 2145
        kodp += sizeof(struct OPERAND_0_mi );
#line 2145
        last_instr = current_instr;
#line 2145
        current_instr = kodp;
#line 2146
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2146
        ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 2146
        kodp += sizeof(struct OPERAND_0_mi );
#line 2146
        last_instr = current_instr;
#line 2146
        current_instr = kodp;
#line 2147
        tmp___0 = (enum intern_arit_class )8;
#line 2147
        type_ac[set - 1] = tmp___0;
#line 2147
        type_ac[set] = tmp___0;
      } else
#line 2149
      if (130U == (unsigned int )type_ac[set]) {
#line 2151
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2151
        ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 2151
        kodp += sizeof(struct OPERAND_0_mi );
#line 2151
        last_instr = current_instr;
#line 2151
        current_instr = kodp;
#line 2152
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2152
        ((struct OPERAND_0_mi *)kodp)->minor = 108;
#line 2152
        kodp += sizeof(struct OPERAND_0_mi );
#line 2152
        last_instr = current_instr;
#line 2152
        current_instr = kodp;
#line 2153
        tmp___1 = (enum intern_arit_class )8;
#line 2153
        type_ac[set - 1] = tmp___1;
#line 2153
        type_ac[set] = tmp___1;
      } else
#line 2155
      if (258U == (unsigned int )type_ac[set]) {
#line 2157
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2157
        ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 2157
        kodp += sizeof(struct OPERAND_0_mi );
#line 2157
        last_instr = current_instr;
#line 2157
        current_instr = kodp;
#line 2158
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2158
        ((struct OPERAND_0_mi *)kodp)->minor = 124;
#line 2158
        kodp += sizeof(struct OPERAND_0_mi );
#line 2158
        last_instr = current_instr;
#line 2158
        current_instr = kodp;
#line 2159
        tmp___2 = (enum intern_arit_class )8;
#line 2159
        type_ac[set - 1] = tmp___2;
#line 2159
        type_ac[set] = tmp___2;
      } else
#line 2161
      if (12U == (unsigned int )type_ac[set]) {
#line 2161
        goto _L;
      } else
#line 2161
      if (140U == (unsigned int )type_ac[set]) {
        _L: /* CIL Label */ 
#line 2164
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2164
        ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 2164
        kodp += sizeof(struct OPERAND_0_mi );
#line 2164
        last_instr = current_instr;
#line 2164
        current_instr = kodp;
#line 2165
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2165
        ((struct OPERAND_0_mi *)kodp)->minor = 66;
#line 2165
        kodp += sizeof(struct OPERAND_0_mi );
#line 2165
        last_instr = current_instr;
#line 2165
        current_instr = kodp;
#line 2166
        tmp___3 = (enum intern_arit_class )8;
#line 2166
        type_ac[set - 1] = tmp___3;
#line 2166
        type_ac[set] = tmp___3;
      } else
#line 2168
      if (268U == (unsigned int )type_ac[set]) {
#line 2175
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2175
        ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 2175
        kodp += sizeof(struct OPERAND_0_mi );
#line 2175
        last_instr = current_instr;
#line 2175
        current_instr = kodp;
#line 2176
        ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2176
        ((struct OPERAND_0_mi *)kodp)->minor = 82;
#line 2176
        kodp += sizeof(struct OPERAND_0_mi );
#line 2176
        last_instr = current_instr;
#line 2176
        current_instr = kodp;
#line 2177
        tmp___4 = (enum intern_arit_class )8;
#line 2177
        type_ac[set - 1] = tmp___4;
#line 2177
        type_ac[set] = tmp___4;
      }
#line 2180
      return (1);
    }
  }
}
}
#line 2187 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int l_value_cast(void) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 2190
  tmp___0 = pointer_cast();
  }
#line 2190
  if (tmp___0) {
#line 2191
    return (1);
  }
#line 2193
  if (4096U == (unsigned int )(type_com[set])->attribute.type_qualifier) {
#line 2193
    if (2U & (unsigned int )(type_com[set - 1])->attribute.arit_class) {
#line 2196
      if (8U & (unsigned int )(type_com[set])->attribute.arit_class) {
#line 2196
        if (*((int *)(type_com[set])->attribute.domain) > 255) {
          {
#line 2198
          error_message(6026);
          }
        }
      }
    }
  }
  {
#line 2202
  tmp___1 = hierarchy((int )type_ac[set]);
#line 2202
  tmp___2 = hierarchy((int )type_ac[set - 1]);
  }
#line 2202
  if (tmp___1 != tmp___2) {
    {
#line 2207
    if ((unsigned int )type_ac[set - 1] == 136U) {
#line 2207
      goto case_136;
    }
#line 2207
    if ((unsigned int )type_ac[set - 1] == 8U) {
#line 2207
      goto case_136;
    }
#line 2255
    if ((unsigned int )type_ac[set - 1] == 264U) {
#line 2255
      goto case_264___0;
    }
#line 2305
    if ((unsigned int )type_ac[set - 1] == 152U) {
#line 2305
      goto case_152___1;
    }
#line 2305
    if ((unsigned int )type_ac[set - 1] == 24U) {
#line 2305
      goto case_152___1;
    }
#line 2354
    if ((unsigned int )type_ac[set - 1] == 140U) {
#line 2354
      goto case_140___2;
    }
#line 2354
    if ((unsigned int )type_ac[set - 1] == 12U) {
#line 2354
      goto case_140___2;
    }
#line 2402
    if ((unsigned int )type_ac[set - 1] == 280U) {
#line 2402
      goto case_280___3;
    }
#line 2451
    if ((unsigned int )type_ac[set - 1] == 268U) {
#line 2451
      goto case_268___4;
    }
#line 2500
    if ((unsigned int )type_ac[set - 1] == 64U) {
#line 2500
      goto case_64___5;
    }
#line 2549
    if ((unsigned int )type_ac[set - 1] == 80U) {
#line 2549
      goto case_80___6;
    }
#line 2598
    if ((unsigned int )type_ac[set - 1] == 32U) {
#line 2598
      goto case_32___7;
    }
#line 2647
    if ((unsigned int )type_ac[set - 1] == 2U) {
#line 2647
      goto case_2___8;
    }
#line 2696
    if ((unsigned int )type_ac[set - 1] == 130U) {
#line 2696
      goto case_130___9;
    }
#line 2745
    if ((unsigned int )type_ac[set - 1] == 258U) {
#line 2745
      goto case_258___10;
    }
#line 2794
    if ((unsigned int )type_ac[set - 1] == 1U) {
#line 2794
      goto case_1___11;
    }
#line 2797
    goto switch_default___11;
    case_136: /* CIL Label */ 
    case_8: /* CIL Label */ 
    {
#line 2210
    if ((unsigned int )type_ac[set] == 264U) {
#line 2210
      goto case_264;
    }
#line 2214
    if ((unsigned int )type_ac[set] == 152U) {
#line 2214
      goto case_152;
    }
#line 2214
    if ((unsigned int )type_ac[set] == 24U) {
#line 2214
      goto case_152;
    }
#line 2218
    if ((unsigned int )type_ac[set] == 140U) {
#line 2218
      goto case_140;
    }
#line 2218
    if ((unsigned int )type_ac[set] == 12U) {
#line 2218
      goto case_140;
    }
#line 2221
    if ((unsigned int )type_ac[set] == 280U) {
#line 2221
      goto case_280;
    }
#line 2224
    if ((unsigned int )type_ac[set] == 268U) {
#line 2224
      goto case_268;
    }
#line 2227
    if ((unsigned int )type_ac[set] == 64U) {
#line 2227
      goto case_64;
    }
#line 2230
    if ((unsigned int )type_ac[set] == 80U) {
#line 2230
      goto case_80;
    }
#line 2233
    if ((unsigned int )type_ac[set] == 32U) {
#line 2233
      goto case_32;
    }
#line 2236
    if ((unsigned int )type_ac[set] == 2U) {
#line 2236
      goto case_2;
    }
#line 2239
    if ((unsigned int )type_ac[set] == 130U) {
#line 2239
      goto case_130;
    }
#line 2242
    if ((unsigned int )type_ac[set] == 258U) {
#line 2242
      goto case_258;
    }
#line 2245
    if ((unsigned int )type_ac[set] == 1U) {
#line 2245
      goto case_1;
    }
#line 2248
    goto switch_default;
    case_264: /* CIL Label */ 
#line 2211
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2211
    ((struct OPERAND_0_mi *)kodp)->minor = 26;
#line 2211
    kodp += sizeof(struct OPERAND_0_mi );
#line 2212
    goto switch_break___0;
    case_152: /* CIL Label */ 
    case_24: /* CIL Label */ ;
#line 2216
    goto switch_break___0;
    case_140: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 2219
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2219
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 2219
    kodp += sizeof(struct OPERAND_0_mi );
#line 2220
    goto switch_break___0;
    case_280: /* CIL Label */ 
#line 2222
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2222
    ((struct OPERAND_0_mi *)kodp)->minor = 26;
#line 2222
    kodp += sizeof(struct OPERAND_0_mi );
#line 2223
    goto switch_break___0;
    case_268: /* CIL Label */ 
#line 2225
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2225
    ((struct OPERAND_0_mi *)kodp)->minor = 81;
#line 2225
    kodp += sizeof(struct OPERAND_0_mi );
#line 2226
    goto switch_break___0;
    case_64: /* CIL Label */ 
#line 2228
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2228
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 2228
    kodp += sizeof(struct OPERAND_0_mi );
#line 2229
    goto switch_break___0;
    case_80: /* CIL Label */ 
#line 2231
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2231
    ((struct OPERAND_0_mi *)kodp)->minor = 159;
#line 2231
    kodp += sizeof(struct OPERAND_0_mi );
#line 2232
    goto switch_break___0;
    case_32: /* CIL Label */ 
#line 2234
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2234
    ((struct OPERAND_0_mi *)kodp)->minor = 5;
#line 2234
    kodp += sizeof(struct OPERAND_0_mi );
#line 2235
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 2237
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2237
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 2237
    kodp += sizeof(struct OPERAND_0_mi );
#line 2238
    goto switch_break___0;
    case_130: /* CIL Label */ 
#line 2240
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2240
    ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 2240
    kodp += sizeof(struct OPERAND_0_mi );
#line 2241
    goto switch_break___0;
    case_258: /* CIL Label */ 
#line 2243
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2243
    ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 2243
    kodp += sizeof(struct OPERAND_0_mi );
#line 2244
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 2246
    error_message(1010);
    }
#line 2247
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 2249
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2249);
#line 2250
    error_message(5000);
#line 2251
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 2253
    last_instr = current_instr;
#line 2253
    current_instr = kodp;
#line 2254
    return (1);
    case_264___0: /* CIL Label */ 
    {
#line 2259
    if ((unsigned int )type_ac[set] == 136U) {
#line 2259
      goto case_136___0;
    }
#line 2259
    if ((unsigned int )type_ac[set] == 8U) {
#line 2259
      goto case_136___0;
    }
#line 2263
    if ((unsigned int )type_ac[set] == 152U) {
#line 2263
      goto case_152___0;
    }
#line 2263
    if ((unsigned int )type_ac[set] == 24U) {
#line 2263
      goto case_152___0;
    }
#line 2267
    if ((unsigned int )type_ac[set] == 140U) {
#line 2267
      goto case_140___0;
    }
#line 2267
    if ((unsigned int )type_ac[set] == 12U) {
#line 2267
      goto case_140___0;
    }
#line 2270
    if ((unsigned int )type_ac[set] == 280U) {
#line 2270
      goto case_280___0;
    }
#line 2273
    if ((unsigned int )type_ac[set] == 268U) {
#line 2273
      goto case_268___0;
    }
#line 2276
    if ((unsigned int )type_ac[set] == 64U) {
#line 2276
      goto case_64___0;
    }
#line 2279
    if ((unsigned int )type_ac[set] == 80U) {
#line 2279
      goto case_80___0;
    }
#line 2282
    if ((unsigned int )type_ac[set] == 32U) {
#line 2282
      goto case_32___0;
    }
#line 2285
    if ((unsigned int )type_ac[set] == 2U) {
#line 2285
      goto case_2___0;
    }
#line 2288
    if ((unsigned int )type_ac[set] == 130U) {
#line 2288
      goto case_130___0;
    }
#line 2291
    if ((unsigned int )type_ac[set] == 258U) {
#line 2291
      goto case_258___0;
    }
#line 2294
    if ((unsigned int )type_ac[set] == 1U) {
#line 2294
      goto case_1___0;
    }
#line 2297
    goto switch_default___0;
    case_136___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
#line 2260
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2260
    ((struct OPERAND_0_mi *)kodp)->minor = 149;
#line 2260
    kodp += sizeof(struct OPERAND_0_mi );
#line 2261
    goto switch_break___1;
    case_152___0: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
#line 2264
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2264
    ((struct OPERAND_0_mi *)kodp)->minor = 149;
#line 2264
    kodp += sizeof(struct OPERAND_0_mi );
#line 2265
    goto switch_break___1;
    case_140___0: /* CIL Label */ 
    case_12___0: /* CIL Label */ 
#line 2268
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2268
    ((struct OPERAND_0_mi *)kodp)->minor = 67;
#line 2268
    kodp += sizeof(struct OPERAND_0_mi );
#line 2269
    goto switch_break___1;
    case_280___0: /* CIL Label */ ;
#line 2272
    goto switch_break___1;
    case_268___0: /* CIL Label */ 
#line 2274
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2274
    ((struct OPERAND_0_mi *)kodp)->minor = 83;
#line 2274
    kodp += sizeof(struct OPERAND_0_mi );
#line 2275
    goto switch_break___1;
    case_64___0: /* CIL Label */ 
#line 2277
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2277
    ((struct OPERAND_0_mi *)kodp)->minor = 133;
#line 2277
    kodp += sizeof(struct OPERAND_0_mi );
#line 2278
    goto switch_break___1;
    case_80___0: /* CIL Label */ 
#line 2280
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2280
    ((struct OPERAND_0_mi *)kodp)->minor = 160;
#line 2280
    kodp += sizeof(struct OPERAND_0_mi );
#line 2281
    goto switch_break___1;
    case_32___0: /* CIL Label */ 
#line 2283
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2283
    ((struct OPERAND_0_mi *)kodp)->minor = 140;
#line 2283
    kodp += sizeof(struct OPERAND_0_mi );
#line 2284
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
#line 2286
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2286
    ((struct OPERAND_0_mi *)kodp)->minor = 93;
#line 2286
    kodp += sizeof(struct OPERAND_0_mi );
#line 2287
    goto switch_break___1;
    case_130___0: /* CIL Label */ 
#line 2289
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2289
    ((struct OPERAND_0_mi *)kodp)->minor = 109;
#line 2289
    kodp += sizeof(struct OPERAND_0_mi );
#line 2290
    goto switch_break___1;
    case_258___0: /* CIL Label */ 
#line 2292
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2292
    ((struct OPERAND_0_mi *)kodp)->minor = 125;
#line 2292
    kodp += sizeof(struct OPERAND_0_mi );
#line 2293
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
    {
#line 2295
    error_message(1010);
    }
#line 2296
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 2298
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2298);
#line 2299
    error_message(5000);
#line 2300
    abort();
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 2302
    last_instr = current_instr;
#line 2302
    current_instr = kodp;
#line 2303
    return (1);
    case_152___1: /* CIL Label */ 
    case_24___1: /* CIL Label */ 
    {
#line 2309
    if ((unsigned int )type_ac[set] == 136U) {
#line 2309
      goto case_136___1;
    }
#line 2309
    if ((unsigned int )type_ac[set] == 8U) {
#line 2309
      goto case_136___1;
    }
#line 2312
    if ((unsigned int )type_ac[set] == 264U) {
#line 2312
      goto case_264___1;
    }
#line 2316
    if ((unsigned int )type_ac[set] == 140U) {
#line 2316
      goto case_140___1;
    }
#line 2316
    if ((unsigned int )type_ac[set] == 12U) {
#line 2316
      goto case_140___1;
    }
#line 2319
    if ((unsigned int )type_ac[set] == 280U) {
#line 2319
      goto case_280___1;
    }
#line 2322
    if ((unsigned int )type_ac[set] == 268U) {
#line 2322
      goto case_268___1;
    }
#line 2325
    if ((unsigned int )type_ac[set] == 64U) {
#line 2325
      goto case_64___1;
    }
#line 2328
    if ((unsigned int )type_ac[set] == 80U) {
#line 2328
      goto case_80___1;
    }
#line 2331
    if ((unsigned int )type_ac[set] == 32U) {
#line 2331
      goto case_32___1;
    }
#line 2334
    if ((unsigned int )type_ac[set] == 2U) {
#line 2334
      goto case_2___1;
    }
#line 2337
    if ((unsigned int )type_ac[set] == 130U) {
#line 2337
      goto case_130___1;
    }
#line 2340
    if ((unsigned int )type_ac[set] == 258U) {
#line 2340
      goto case_258___1;
    }
#line 2343
    if ((unsigned int )type_ac[set] == 1U) {
#line 2343
      goto case_1___1;
    }
#line 2346
    goto switch_default___1;
    case_136___1: /* CIL Label */ 
    case_8___1: /* CIL Label */ ;
#line 2311
    goto switch_break___2;
    case_264___1: /* CIL Label */ 
#line 2313
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2313
    ((struct OPERAND_0_mi *)kodp)->minor = 22;
#line 2313
    kodp += sizeof(struct OPERAND_0_mi );
#line 2314
    goto switch_break___2;
    case_140___1: /* CIL Label */ 
    case_12___1: /* CIL Label */ 
#line 2317
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2317
    ((struct OPERAND_0_mi *)kodp)->minor = 65;
#line 2317
    kodp += sizeof(struct OPERAND_0_mi );
#line 2318
    goto switch_break___2;
    case_280___1: /* CIL Label */ 
#line 2320
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2320
    ((struct OPERAND_0_mi *)kodp)->minor = 22;
#line 2320
    kodp += sizeof(struct OPERAND_0_mi );
#line 2321
    goto switch_break___2;
    case_268___1: /* CIL Label */ 
#line 2323
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2323
    ((struct OPERAND_0_mi *)kodp)->minor = 77;
#line 2323
    kodp += sizeof(struct OPERAND_0_mi );
#line 2324
    goto switch_break___2;
    case_64___1: /* CIL Label */ 
#line 2326
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2326
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 2326
    kodp += sizeof(struct OPERAND_0_mi );
#line 2327
    goto switch_break___2;
    case_80___1: /* CIL Label */ 
#line 2329
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2329
    ((struct OPERAND_0_mi *)kodp)->minor = 159;
#line 2329
    kodp += sizeof(struct OPERAND_0_mi );
#line 2330
    goto switch_break___2;
    case_32___1: /* CIL Label */ 
#line 2332
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2332
    ((struct OPERAND_0_mi *)kodp)->minor = 5;
#line 2332
    kodp += sizeof(struct OPERAND_0_mi );
#line 2333
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
#line 2335
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2335
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 2335
    kodp += sizeof(struct OPERAND_0_mi );
#line 2336
    goto switch_break___2;
    case_130___1: /* CIL Label */ 
#line 2338
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2338
    ((struct OPERAND_0_mi *)kodp)->minor = 107;
#line 2338
    kodp += sizeof(struct OPERAND_0_mi );
#line 2339
    goto switch_break___2;
    case_258___1: /* CIL Label */ 
#line 2341
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2341
    ((struct OPERAND_0_mi *)kodp)->minor = 123;
#line 2341
    kodp += sizeof(struct OPERAND_0_mi );
#line 2342
    goto switch_break___2;
    case_1___1: /* CIL Label */ 
    {
#line 2344
    error_message(1010);
    }
#line 2345
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 2347
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2347);
#line 2348
    error_message(5000);
#line 2349
    abort();
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 2351
    last_instr = current_instr;
#line 2351
    current_instr = kodp;
#line 2352
    return (1);
    case_140___2: /* CIL Label */ 
    case_12___2: /* CIL Label */ 
    {
#line 2358
    if ((unsigned int )type_ac[set] == 136U) {
#line 2358
      goto case_136___2;
    }
#line 2358
    if ((unsigned int )type_ac[set] == 8U) {
#line 2358
      goto case_136___2;
    }
#line 2361
    if ((unsigned int )type_ac[set] == 264U) {
#line 2361
      goto case_264___2;
    }
#line 2365
    if ((unsigned int )type_ac[set] == 152U) {
#line 2365
      goto case_152___2;
    }
#line 2365
    if ((unsigned int )type_ac[set] == 24U) {
#line 2365
      goto case_152___2;
    }
#line 2368
    if ((unsigned int )type_ac[set] == 280U) {
#line 2368
      goto case_280___2;
    }
#line 2371
    if ((unsigned int )type_ac[set] == 268U) {
#line 2371
      goto case_268___2;
    }
#line 2374
    if ((unsigned int )type_ac[set] == 64U) {
#line 2374
      goto case_64___2;
    }
#line 2377
    if ((unsigned int )type_ac[set] == 80U) {
#line 2377
      goto case_80___2;
    }
#line 2380
    if ((unsigned int )type_ac[set] == 32U) {
#line 2380
      goto case_32___2;
    }
#line 2383
    if ((unsigned int )type_ac[set] == 2U) {
#line 2383
      goto case_2___2;
    }
#line 2386
    if ((unsigned int )type_ac[set] == 130U) {
#line 2386
      goto case_130___2;
    }
#line 2389
    if ((unsigned int )type_ac[set] == 258U) {
#line 2389
      goto case_258___2;
    }
#line 2392
    if ((unsigned int )type_ac[set] == 1U) {
#line 2392
      goto case_1___2;
    }
#line 2395
    goto switch_default___2;
    case_136___2: /* CIL Label */ 
    case_8___2: /* CIL Label */ 
#line 2359
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2359
    ((struct OPERAND_0_mi *)kodp)->minor = 151;
#line 2359
    kodp += sizeof(struct OPERAND_0_mi );
#line 2360
    goto switch_break___3;
    case_264___2: /* CIL Label */ 
#line 2362
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2362
    ((struct OPERAND_0_mi *)kodp)->minor = 27;
#line 2362
    kodp += sizeof(struct OPERAND_0_mi );
#line 2363
    goto switch_break___3;
    case_152___2: /* CIL Label */ 
    case_24___2: /* CIL Label */ 
#line 2366
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2366
    ((struct OPERAND_0_mi *)kodp)->minor = 151;
#line 2366
    kodp += sizeof(struct OPERAND_0_mi );
#line 2367
    goto switch_break___3;
    case_280___2: /* CIL Label */ 
#line 2369
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2369
    ((struct OPERAND_0_mi *)kodp)->minor = 27;
#line 2369
    kodp += sizeof(struct OPERAND_0_mi );
#line 2370
    goto switch_break___3;
    case_268___2: /* CIL Label */ 
#line 2372
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2372
    ((struct OPERAND_0_mi *)kodp)->minor = 85;
#line 2372
    kodp += sizeof(struct OPERAND_0_mi );
#line 2373
    goto switch_break___3;
    case_64___2: /* CIL Label */ 
#line 2375
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2375
    ((struct OPERAND_0_mi *)kodp)->minor = 134;
#line 2375
    kodp += sizeof(struct OPERAND_0_mi );
#line 2376
    goto switch_break___3;
    case_80___2: /* CIL Label */ 
#line 2378
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2378
    ((struct OPERAND_0_mi *)kodp)->minor = 161;
#line 2378
    kodp += sizeof(struct OPERAND_0_mi );
#line 2379
    goto switch_break___3;
    case_32___2: /* CIL Label */ 
#line 2381
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2381
    ((struct OPERAND_0_mi *)kodp)->minor = 141;
#line 2381
    kodp += sizeof(struct OPERAND_0_mi );
#line 2382
    goto switch_break___3;
    case_2___2: /* CIL Label */ 
#line 2384
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2384
    ((struct OPERAND_0_mi *)kodp)->minor = 95;
#line 2384
    kodp += sizeof(struct OPERAND_0_mi );
#line 2385
    goto switch_break___3;
    case_130___2: /* CIL Label */ 
#line 2387
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2387
    ((struct OPERAND_0_mi *)kodp)->minor = 111;
#line 2387
    kodp += sizeof(struct OPERAND_0_mi );
#line 2388
    goto switch_break___3;
    case_258___2: /* CIL Label */ 
#line 2390
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2390
    ((struct OPERAND_0_mi *)kodp)->minor = 127;
#line 2390
    kodp += sizeof(struct OPERAND_0_mi );
#line 2391
    goto switch_break___3;
    case_1___2: /* CIL Label */ 
    {
#line 2393
    error_message(1010);
    }
#line 2394
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
    {
#line 2396
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2396);
#line 2397
    error_message(5000);
#line 2398
    abort();
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 2400
    last_instr = current_instr;
#line 2400
    current_instr = kodp;
#line 2401
    return (1);
    case_280___3: /* CIL Label */ 
    {
#line 2406
    if ((unsigned int )type_ac[set] == 136U) {
#line 2406
      goto case_136___3;
    }
#line 2406
    if ((unsigned int )type_ac[set] == 8U) {
#line 2406
      goto case_136___3;
    }
#line 2409
    if ((unsigned int )type_ac[set] == 264U) {
#line 2409
      goto case_264___3;
    }
#line 2413
    if ((unsigned int )type_ac[set] == 140U) {
#line 2413
      goto case_140___3;
    }
#line 2413
    if ((unsigned int )type_ac[set] == 12U) {
#line 2413
      goto case_140___3;
    }
#line 2417
    if ((unsigned int )type_ac[set] == 152U) {
#line 2417
      goto case_152___3;
    }
#line 2417
    if ((unsigned int )type_ac[set] == 24U) {
#line 2417
      goto case_152___3;
    }
#line 2420
    if ((unsigned int )type_ac[set] == 268U) {
#line 2420
      goto case_268___3;
    }
#line 2423
    if ((unsigned int )type_ac[set] == 64U) {
#line 2423
      goto case_64___3;
    }
#line 2426
    if ((unsigned int )type_ac[set] == 80U) {
#line 2426
      goto case_80___3;
    }
#line 2429
    if ((unsigned int )type_ac[set] == 32U) {
#line 2429
      goto case_32___3;
    }
#line 2432
    if ((unsigned int )type_ac[set] == 2U) {
#line 2432
      goto case_2___3;
    }
#line 2435
    if ((unsigned int )type_ac[set] == 130U) {
#line 2435
      goto case_130___3;
    }
#line 2438
    if ((unsigned int )type_ac[set] == 258U) {
#line 2438
      goto case_258___3;
    }
#line 2441
    if ((unsigned int )type_ac[set] == 1U) {
#line 2441
      goto case_1___3;
    }
#line 2444
    goto switch_default___3;
    case_136___3: /* CIL Label */ 
    case_8___3: /* CIL Label */ 
#line 2407
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2407
    ((struct OPERAND_0_mi *)kodp)->minor = 149;
#line 2407
    kodp += sizeof(struct OPERAND_0_mi );
#line 2408
    goto switch_break___4;
    case_264___3: /* CIL Label */ ;
#line 2411
    goto switch_break___4;
    case_140___3: /* CIL Label */ 
    case_12___3: /* CIL Label */ 
#line 2414
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2414
    ((struct OPERAND_0_mi *)kodp)->minor = 63;
#line 2414
    kodp += sizeof(struct OPERAND_0_mi );
#line 2415
    goto switch_break___4;
    case_152___3: /* CIL Label */ 
    case_24___3: /* CIL Label */ 
#line 2418
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2418
    ((struct OPERAND_0_mi *)kodp)->minor = 149;
#line 2418
    kodp += sizeof(struct OPERAND_0_mi );
#line 2419
    goto switch_break___4;
    case_268___3: /* CIL Label */ 
#line 2421
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2421
    ((struct OPERAND_0_mi *)kodp)->minor = 79;
#line 2421
    kodp += sizeof(struct OPERAND_0_mi );
#line 2422
    goto switch_break___4;
    case_64___3: /* CIL Label */ 
#line 2424
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2424
    ((struct OPERAND_0_mi *)kodp)->minor = 133;
#line 2424
    kodp += sizeof(struct OPERAND_0_mi );
#line 2425
    goto switch_break___4;
    case_80___3: /* CIL Label */ 
#line 2427
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2427
    ((struct OPERAND_0_mi *)kodp)->minor = 160;
#line 2427
    kodp += sizeof(struct OPERAND_0_mi );
#line 2428
    goto switch_break___4;
    case_32___3: /* CIL Label */ 
#line 2430
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2430
    ((struct OPERAND_0_mi *)kodp)->minor = 140;
#line 2430
    kodp += sizeof(struct OPERAND_0_mi );
#line 2431
    goto switch_break___4;
    case_2___3: /* CIL Label */ 
#line 2433
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2433
    ((struct OPERAND_0_mi *)kodp)->minor = 93;
#line 2433
    kodp += sizeof(struct OPERAND_0_mi );
#line 2434
    goto switch_break___4;
    case_130___3: /* CIL Label */ 
#line 2436
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2436
    ((struct OPERAND_0_mi *)kodp)->minor = 109;
#line 2436
    kodp += sizeof(struct OPERAND_0_mi );
#line 2437
    goto switch_break___4;
    case_258___3: /* CIL Label */ 
#line 2439
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2439
    ((struct OPERAND_0_mi *)kodp)->minor = 125;
#line 2439
    kodp += sizeof(struct OPERAND_0_mi );
#line 2440
    goto switch_break___4;
    case_1___3: /* CIL Label */ 
    {
#line 2442
    error_message(1010);
    }
#line 2443
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
    {
#line 2445
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2445);
#line 2446
    error_message(5000);
#line 2447
    abort();
    }
    switch_break___4: /* CIL Label */ ;
    }
#line 2449
    last_instr = current_instr;
#line 2449
    current_instr = kodp;
#line 2450
    return (1);
    case_268___4: /* CIL Label */ 
    {
#line 2455
    if ((unsigned int )type_ac[set] == 136U) {
#line 2455
      goto case_136___4;
    }
#line 2455
    if ((unsigned int )type_ac[set] == 8U) {
#line 2455
      goto case_136___4;
    }
#line 2458
    if ((unsigned int )type_ac[set] == 264U) {
#line 2458
      goto case_264___4;
    }
#line 2462
    if ((unsigned int )type_ac[set] == 140U) {
#line 2462
      goto case_140___4;
    }
#line 2462
    if ((unsigned int )type_ac[set] == 12U) {
#line 2462
      goto case_140___4;
    }
#line 2466
    if ((unsigned int )type_ac[set] == 152U) {
#line 2466
      goto case_152___4;
    }
#line 2466
    if ((unsigned int )type_ac[set] == 24U) {
#line 2466
      goto case_152___4;
    }
#line 2469
    if ((unsigned int )type_ac[set] == 280U) {
#line 2469
      goto case_280___4;
    }
#line 2472
    if ((unsigned int )type_ac[set] == 64U) {
#line 2472
      goto case_64___4;
    }
#line 2475
    if ((unsigned int )type_ac[set] == 80U) {
#line 2475
      goto case_80___4;
    }
#line 2478
    if ((unsigned int )type_ac[set] == 32U) {
#line 2478
      goto case_32___4;
    }
#line 2481
    if ((unsigned int )type_ac[set] == 2U) {
#line 2481
      goto case_2___4;
    }
#line 2484
    if ((unsigned int )type_ac[set] == 130U) {
#line 2484
      goto case_130___4;
    }
#line 2487
    if ((unsigned int )type_ac[set] == 258U) {
#line 2487
      goto case_258___4;
    }
#line 2490
    if ((unsigned int )type_ac[set] == 1U) {
#line 2490
      goto case_1___4;
    }
#line 2493
    goto switch_default___4;
    case_136___4: /* CIL Label */ 
    case_8___4: /* CIL Label */ 
#line 2456
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2456
    ((struct OPERAND_0_mi *)kodp)->minor = 152;
#line 2456
    kodp += sizeof(struct OPERAND_0_mi );
#line 2457
    goto switch_break___5;
    case_264___4: /* CIL Label */ 
#line 2459
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2459
    ((struct OPERAND_0_mi *)kodp)->minor = 28;
#line 2459
    kodp += sizeof(struct OPERAND_0_mi );
#line 2460
    goto switch_break___5;
    case_140___4: /* CIL Label */ 
    case_12___4: /* CIL Label */ 
#line 2463
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2463
    ((struct OPERAND_0_mi *)kodp)->minor = 69;
#line 2463
    kodp += sizeof(struct OPERAND_0_mi );
#line 2464
    goto switch_break___5;
    case_152___4: /* CIL Label */ 
    case_24___4: /* CIL Label */ 
#line 2467
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2467
    ((struct OPERAND_0_mi *)kodp)->minor = 152;
#line 2467
    kodp += sizeof(struct OPERAND_0_mi );
#line 2468
    goto switch_break___5;
    case_280___4: /* CIL Label */ 
#line 2470
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2470
    ((struct OPERAND_0_mi *)kodp)->minor = 28;
#line 2470
    kodp += sizeof(struct OPERAND_0_mi );
#line 2471
    goto switch_break___5;
    case_64___4: /* CIL Label */ 
#line 2473
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2473
    ((struct OPERAND_0_mi *)kodp)->minor = 135;
#line 2473
    kodp += sizeof(struct OPERAND_0_mi );
#line 2474
    goto switch_break___5;
    case_80___4: /* CIL Label */ 
#line 2476
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2476
    ((struct OPERAND_0_mi *)kodp)->minor = 162;
#line 2476
    kodp += sizeof(struct OPERAND_0_mi );
#line 2477
    goto switch_break___5;
    case_32___4: /* CIL Label */ 
#line 2479
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2479
    ((struct OPERAND_0_mi *)kodp)->minor = 142;
#line 2479
    kodp += sizeof(struct OPERAND_0_mi );
#line 2480
    goto switch_break___5;
    case_2___4: /* CIL Label */ 
#line 2482
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2482
    ((struct OPERAND_0_mi *)kodp)->minor = 96;
#line 2482
    kodp += sizeof(struct OPERAND_0_mi );
#line 2483
    goto switch_break___5;
    case_130___4: /* CIL Label */ 
#line 2485
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2485
    ((struct OPERAND_0_mi *)kodp)->minor = 112;
#line 2485
    kodp += sizeof(struct OPERAND_0_mi );
#line 2486
    goto switch_break___5;
    case_258___4: /* CIL Label */ 
#line 2488
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2488
    ((struct OPERAND_0_mi *)kodp)->minor = 128;
#line 2488
    kodp += sizeof(struct OPERAND_0_mi );
#line 2489
    goto switch_break___5;
    case_1___4: /* CIL Label */ 
    {
#line 2491
    error_message(1010);
    }
#line 2492
    goto switch_break___5;
    switch_default___4: /* CIL Label */ 
    {
#line 2494
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2494);
#line 2495
    error_message(5000);
#line 2496
    abort();
    }
    switch_break___5: /* CIL Label */ ;
    }
#line 2498
    last_instr = current_instr;
#line 2498
    current_instr = kodp;
#line 2499
    return (1);
    case_64___5: /* CIL Label */ 
    {
#line 2504
    if ((unsigned int )type_ac[set] == 136U) {
#line 2504
      goto case_136___5;
    }
#line 2504
    if ((unsigned int )type_ac[set] == 8U) {
#line 2504
      goto case_136___5;
    }
#line 2507
    if ((unsigned int )type_ac[set] == 264U) {
#line 2507
      goto case_264___5;
    }
#line 2511
    if ((unsigned int )type_ac[set] == 152U) {
#line 2511
      goto case_152___5;
    }
#line 2511
    if ((unsigned int )type_ac[set] == 24U) {
#line 2511
      goto case_152___5;
    }
#line 2515
    if ((unsigned int )type_ac[set] == 140U) {
#line 2515
      goto case_140___5;
    }
#line 2515
    if ((unsigned int )type_ac[set] == 12U) {
#line 2515
      goto case_140___5;
    }
#line 2518
    if ((unsigned int )type_ac[set] == 280U) {
#line 2518
      goto case_280___5;
    }
#line 2521
    if ((unsigned int )type_ac[set] == 268U) {
#line 2521
      goto case_268___5;
    }
#line 2524
    if ((unsigned int )type_ac[set] == 80U) {
#line 2524
      goto case_80___5;
    }
#line 2527
    if ((unsigned int )type_ac[set] == 32U) {
#line 2527
      goto case_32___5;
    }
#line 2530
    if ((unsigned int )type_ac[set] == 2U) {
#line 2530
      goto case_2___5;
    }
#line 2533
    if ((unsigned int )type_ac[set] == 130U) {
#line 2533
      goto case_130___5;
    }
#line 2536
    if ((unsigned int )type_ac[set] == 258U) {
#line 2536
      goto case_258___5;
    }
#line 2539
    if ((unsigned int )type_ac[set] == 1U) {
#line 2539
      goto case_1___5;
    }
#line 2542
    goto switch_default___5;
    case_136___5: /* CIL Label */ 
    case_8___5: /* CIL Label */ 
#line 2505
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2505
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 2505
    kodp += sizeof(struct OPERAND_0_mi );
#line 2506
    goto switch_break___6;
    case_264___5: /* CIL Label */ 
#line 2508
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2508
    ((struct OPERAND_0_mi *)kodp)->minor = 18;
#line 2508
    kodp += sizeof(struct OPERAND_0_mi );
#line 2509
    goto switch_break___6;
    case_152___5: /* CIL Label */ 
    case_24___5: /* CIL Label */ 
#line 2512
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2512
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 2512
    kodp += sizeof(struct OPERAND_0_mi );
#line 2513
    goto switch_break___6;
    case_140___5: /* CIL Label */ 
    case_12___5: /* CIL Label */ 
#line 2516
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2516
    ((struct OPERAND_0_mi *)kodp)->minor = 57;
#line 2516
    kodp += sizeof(struct OPERAND_0_mi );
#line 2517
    goto switch_break___6;
    case_280___5: /* CIL Label */ 
#line 2519
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2519
    ((struct OPERAND_0_mi *)kodp)->minor = 18;
#line 2519
    kodp += sizeof(struct OPERAND_0_mi );
#line 2520
    goto switch_break___6;
    case_268___5: /* CIL Label */ 
#line 2522
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2522
    ((struct OPERAND_0_mi *)kodp)->minor = 73;
#line 2522
    kodp += sizeof(struct OPERAND_0_mi );
#line 2523
    goto switch_break___6;
    case_80___5: /* CIL Label */ 
#line 2525
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2525
    ((struct OPERAND_0_mi *)kodp)->minor = 155;
#line 2525
    kodp += sizeof(struct OPERAND_0_mi );
#line 2526
    goto switch_break___6;
    case_32___5: /* CIL Label */ 
#line 2528
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2528
    ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 2528
    kodp += sizeof(struct OPERAND_0_mi );
#line 2529
    goto switch_break___6;
    case_2___5: /* CIL Label */ 
#line 2531
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2531
    ((struct OPERAND_0_mi *)kodp)->minor = 12;
#line 2531
    kodp += sizeof(struct OPERAND_0_mi );
#line 2532
    goto switch_break___6;
    case_130___5: /* CIL Label */ 
#line 2534
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2534
    ((struct OPERAND_0_mi *)kodp)->minor = 99;
#line 2534
    kodp += sizeof(struct OPERAND_0_mi );
#line 2535
    goto switch_break___6;
    case_258___5: /* CIL Label */ 
#line 2537
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2537
    ((struct OPERAND_0_mi *)kodp)->minor = 115;
#line 2537
    kodp += sizeof(struct OPERAND_0_mi );
#line 2538
    goto switch_break___6;
    case_1___5: /* CIL Label */ 
    {
#line 2540
    error_message(1010);
    }
#line 2541
    goto switch_break___6;
    switch_default___5: /* CIL Label */ 
    {
#line 2543
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2543);
#line 2544
    error_message(5000);
#line 2545
    abort();
    }
    switch_break___6: /* CIL Label */ ;
    }
#line 2547
    last_instr = current_instr;
#line 2547
    current_instr = kodp;
#line 2548
    return (1);
    case_80___6: /* CIL Label */ 
    {
#line 2553
    if ((unsigned int )type_ac[set] == 136U) {
#line 2553
      goto case_136___6;
    }
#line 2553
    if ((unsigned int )type_ac[set] == 8U) {
#line 2553
      goto case_136___6;
    }
#line 2556
    if ((unsigned int )type_ac[set] == 264U) {
#line 2556
      goto case_264___6;
    }
#line 2560
    if ((unsigned int )type_ac[set] == 152U) {
#line 2560
      goto case_152___6;
    }
#line 2560
    if ((unsigned int )type_ac[set] == 24U) {
#line 2560
      goto case_152___6;
    }
#line 2564
    if ((unsigned int )type_ac[set] == 140U) {
#line 2564
      goto case_140___6;
    }
#line 2564
    if ((unsigned int )type_ac[set] == 12U) {
#line 2564
      goto case_140___6;
    }
#line 2567
    if ((unsigned int )type_ac[set] == 280U) {
#line 2567
      goto case_280___6;
    }
#line 2570
    if ((unsigned int )type_ac[set] == 268U) {
#line 2570
      goto case_268___6;
    }
#line 2573
    if ((unsigned int )type_ac[set] == 64U) {
#line 2573
      goto case_64___6;
    }
#line 2576
    if ((unsigned int )type_ac[set] == 32U) {
#line 2576
      goto case_32___6;
    }
#line 2579
    if ((unsigned int )type_ac[set] == 2U) {
#line 2579
      goto case_2___6;
    }
#line 2582
    if ((unsigned int )type_ac[set] == 130U) {
#line 2582
      goto case_130___6;
    }
#line 2585
    if ((unsigned int )type_ac[set] == 258U) {
#line 2585
      goto case_258___6;
    }
#line 2588
    if ((unsigned int )type_ac[set] == 1U) {
#line 2588
      goto case_1___6;
    }
#line 2591
    goto switch_default___6;
    case_136___6: /* CIL Label */ 
    case_8___6: /* CIL Label */ 
#line 2554
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2554
    ((struct OPERAND_0_mi *)kodp)->minor = 166;
#line 2554
    kodp += sizeof(struct OPERAND_0_mi );
#line 2555
    goto switch_break___7;
    case_264___6: /* CIL Label */ 
#line 2557
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2557
    ((struct OPERAND_0_mi *)kodp)->minor = 168;
#line 2557
    kodp += sizeof(struct OPERAND_0_mi );
#line 2558
    goto switch_break___7;
    case_152___6: /* CIL Label */ 
    case_24___6: /* CIL Label */ 
#line 2561
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2561
    ((struct OPERAND_0_mi *)kodp)->minor = 166;
#line 2561
    kodp += sizeof(struct OPERAND_0_mi );
#line 2562
    goto switch_break___7;
    case_140___6: /* CIL Label */ 
    case_12___6: /* CIL Label */ 
#line 2565
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2565
    ((struct OPERAND_0_mi *)kodp)->minor = 172;
#line 2565
    kodp += sizeof(struct OPERAND_0_mi );
#line 2566
    goto switch_break___7;
    case_280___6: /* CIL Label */ 
#line 2568
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2568
    ((struct OPERAND_0_mi *)kodp)->minor = 168;
#line 2568
    kodp += sizeof(struct OPERAND_0_mi );
#line 2569
    goto switch_break___7;
    case_268___6: /* CIL Label */ 
#line 2571
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2571
    ((struct OPERAND_0_mi *)kodp)->minor = 176;
#line 2571
    kodp += sizeof(struct OPERAND_0_mi );
#line 2572
    goto switch_break___7;
    case_64___6: /* CIL Label */ 
#line 2574
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2574
    ((struct OPERAND_0_mi *)kodp)->minor = 178;
#line 2574
    kodp += sizeof(struct OPERAND_0_mi );
#line 2575
    goto switch_break___7;
    case_32___6: /* CIL Label */ 
#line 2577
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2577
    ((struct OPERAND_0_mi *)kodp)->minor = 180;
#line 2577
    kodp += sizeof(struct OPERAND_0_mi );
#line 2578
    goto switch_break___7;
    case_2___6: /* CIL Label */ 
#line 2580
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2580
    ((struct OPERAND_0_mi *)kodp)->minor = 182;
#line 2580
    kodp += sizeof(struct OPERAND_0_mi );
#line 2581
    goto switch_break___7;
    case_130___6: /* CIL Label */ 
#line 2583
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2583
    ((struct OPERAND_0_mi *)kodp)->minor = 184;
#line 2583
    kodp += sizeof(struct OPERAND_0_mi );
#line 2584
    goto switch_break___7;
    case_258___6: /* CIL Label */ 
#line 2586
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2586
    ((struct OPERAND_0_mi *)kodp)->minor = 186;
#line 2586
    kodp += sizeof(struct OPERAND_0_mi );
#line 2587
    goto switch_break___7;
    case_1___6: /* CIL Label */ 
    {
#line 2589
    error_message(1010);
    }
#line 2590
    goto switch_break___7;
    switch_default___6: /* CIL Label */ 
    {
#line 2592
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2592);
#line 2593
    error_message(5000);
#line 2594
    abort();
    }
    switch_break___7: /* CIL Label */ ;
    }
#line 2596
    last_instr = current_instr;
#line 2596
    current_instr = kodp;
#line 2597
    return (1);
    case_32___7: /* CIL Label */ 
    {
#line 2602
    if ((unsigned int )type_ac[set] == 136U) {
#line 2602
      goto case_136___7;
    }
#line 2602
    if ((unsigned int )type_ac[set] == 8U) {
#line 2602
      goto case_136___7;
    }
#line 2605
    if ((unsigned int )type_ac[set] == 264U) {
#line 2605
      goto case_264___7;
    }
#line 2609
    if ((unsigned int )type_ac[set] == 152U) {
#line 2609
      goto case_152___7;
    }
#line 2609
    if ((unsigned int )type_ac[set] == 24U) {
#line 2609
      goto case_152___7;
    }
#line 2613
    if ((unsigned int )type_ac[set] == 140U) {
#line 2613
      goto case_140___7;
    }
#line 2613
    if ((unsigned int )type_ac[set] == 12U) {
#line 2613
      goto case_140___7;
    }
#line 2616
    if ((unsigned int )type_ac[set] == 280U) {
#line 2616
      goto case_280___7;
    }
#line 2619
    if ((unsigned int )type_ac[set] == 268U) {
#line 2619
      goto case_268___7;
    }
#line 2622
    if ((unsigned int )type_ac[set] == 64U) {
#line 2622
      goto case_64___7;
    }
#line 2625
    if ((unsigned int )type_ac[set] == 80U) {
#line 2625
      goto case_80___7;
    }
#line 2628
    if ((unsigned int )type_ac[set] == 2U) {
#line 2628
      goto case_2___7;
    }
#line 2631
    if ((unsigned int )type_ac[set] == 130U) {
#line 2631
      goto case_130___7;
    }
#line 2634
    if ((unsigned int )type_ac[set] == 258U) {
#line 2634
      goto case_258___7;
    }
#line 2637
    if ((unsigned int )type_ac[set] == 1U) {
#line 2637
      goto case_1___7;
    }
#line 2640
    goto switch_default___7;
    case_136___7: /* CIL Label */ 
    case_8___7: /* CIL Label */ 
#line 2603
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2603
    ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 2603
    kodp += sizeof(struct OPERAND_0_mi );
#line 2604
    goto switch_break___8;
    case_264___7: /* CIL Label */ 
#line 2606
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2606
    ((struct OPERAND_0_mi *)kodp)->minor = 20;
#line 2606
    kodp += sizeof(struct OPERAND_0_mi );
#line 2607
    goto switch_break___8;
    case_152___7: /* CIL Label */ 
    case_24___7: /* CIL Label */ 
#line 2610
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2610
    ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 2610
    kodp += sizeof(struct OPERAND_0_mi );
#line 2611
    goto switch_break___8;
    case_140___7: /* CIL Label */ 
    case_12___7: /* CIL Label */ 
#line 2614
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2614
    ((struct OPERAND_0_mi *)kodp)->minor = 59;
#line 2614
    kodp += sizeof(struct OPERAND_0_mi );
#line 2615
    goto switch_break___8;
    case_280___7: /* CIL Label */ 
#line 2617
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2617
    ((struct OPERAND_0_mi *)kodp)->minor = 20;
#line 2617
    kodp += sizeof(struct OPERAND_0_mi );
#line 2618
    goto switch_break___8;
    case_268___7: /* CIL Label */ 
#line 2620
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2620
    ((struct OPERAND_0_mi *)kodp)->minor = 75;
#line 2620
    kodp += sizeof(struct OPERAND_0_mi );
#line 2621
    goto switch_break___8;
    case_64___7: /* CIL Label */ 
#line 2623
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2623
    ((struct OPERAND_0_mi *)kodp)->minor = 8;
#line 2623
    kodp += sizeof(struct OPERAND_0_mi );
#line 2624
    goto switch_break___8;
    case_80___7: /* CIL Label */ 
#line 2626
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2626
    ((struct OPERAND_0_mi *)kodp)->minor = 156;
#line 2626
    kodp += sizeof(struct OPERAND_0_mi );
#line 2627
    goto switch_break___8;
    case_2___7: /* CIL Label */ 
#line 2629
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2629
    ((struct OPERAND_0_mi *)kodp)->minor = 15;
#line 2629
    kodp += sizeof(struct OPERAND_0_mi );
#line 2630
    goto switch_break___8;
    case_130___7: /* CIL Label */ 
#line 2632
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2632
    ((struct OPERAND_0_mi *)kodp)->minor = 101;
#line 2632
    kodp += sizeof(struct OPERAND_0_mi );
#line 2633
    goto switch_break___8;
    case_258___7: /* CIL Label */ 
#line 2635
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2635
    ((struct OPERAND_0_mi *)kodp)->minor = 117;
#line 2635
    kodp += sizeof(struct OPERAND_0_mi );
#line 2636
    goto switch_break___8;
    case_1___7: /* CIL Label */ 
    {
#line 2638
    error_message(1010);
    }
#line 2639
    goto switch_break___8;
    switch_default___7: /* CIL Label */ 
    {
#line 2641
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2641);
#line 2642
    error_message(5000);
#line 2643
    abort();
    }
    switch_break___8: /* CIL Label */ ;
    }
#line 2645
    last_instr = current_instr;
#line 2645
    current_instr = kodp;
#line 2646
    return (1);
    case_2___8: /* CIL Label */ 
    {
#line 2651
    if ((unsigned int )type_ac[set] == 136U) {
#line 2651
      goto case_136___8;
    }
#line 2651
    if ((unsigned int )type_ac[set] == 8U) {
#line 2651
      goto case_136___8;
    }
#line 2654
    if ((unsigned int )type_ac[set] == 264U) {
#line 2654
      goto case_264___8;
    }
#line 2658
    if ((unsigned int )type_ac[set] == 152U) {
#line 2658
      goto case_152___8;
    }
#line 2658
    if ((unsigned int )type_ac[set] == 24U) {
#line 2658
      goto case_152___8;
    }
#line 2662
    if ((unsigned int )type_ac[set] == 140U) {
#line 2662
      goto case_140___8;
    }
#line 2662
    if ((unsigned int )type_ac[set] == 12U) {
#line 2662
      goto case_140___8;
    }
#line 2665
    if ((unsigned int )type_ac[set] == 280U) {
#line 2665
      goto case_280___8;
    }
#line 2668
    if ((unsigned int )type_ac[set] == 268U) {
#line 2668
      goto case_268___8;
    }
#line 2671
    if ((unsigned int )type_ac[set] == 64U) {
#line 2671
      goto case_64___8;
    }
#line 2674
    if ((unsigned int )type_ac[set] == 80U) {
#line 2674
      goto case_80___8;
    }
#line 2677
    if ((unsigned int )type_ac[set] == 32U) {
#line 2677
      goto case_32___8;
    }
#line 2680
    if ((unsigned int )type_ac[set] == 130U) {
#line 2680
      goto case_130___8;
    }
#line 2683
    if ((unsigned int )type_ac[set] == 258U) {
#line 2683
      goto case_258___8;
    }
#line 2686
    if ((unsigned int )type_ac[set] == 1U) {
#line 2686
      goto case_1___8;
    }
#line 2689
    goto switch_default___8;
    case_136___8: /* CIL Label */ 
    case_8___8: /* CIL Label */ 
#line 2652
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2652
    ((struct OPERAND_0_mi *)kodp)->minor = 11;
#line 2652
    kodp += sizeof(struct OPERAND_0_mi );
#line 2653
    goto switch_break___9;
    case_264___8: /* CIL Label */ 
#line 2655
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2655
    ((struct OPERAND_0_mi *)kodp)->minor = 29;
#line 2655
    kodp += sizeof(struct OPERAND_0_mi );
#line 2656
    goto switch_break___9;
    case_152___8: /* CIL Label */ 
    case_24___8: /* CIL Label */ 
#line 2659
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2659
    ((struct OPERAND_0_mi *)kodp)->minor = 11;
#line 2659
    kodp += sizeof(struct OPERAND_0_mi );
#line 2660
    goto switch_break___9;
    case_140___8: /* CIL Label */ 
    case_12___8: /* CIL Label */ 
#line 2663
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2663
    ((struct OPERAND_0_mi *)kodp)->minor = 70;
#line 2663
    kodp += sizeof(struct OPERAND_0_mi );
#line 2664
    goto switch_break___9;
    case_280___8: /* CIL Label */ 
#line 2666
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2666
    ((struct OPERAND_0_mi *)kodp)->minor = 29;
#line 2666
    kodp += sizeof(struct OPERAND_0_mi );
#line 2667
    goto switch_break___9;
    case_268___8: /* CIL Label */ 
#line 2669
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2669
    ((struct OPERAND_0_mi *)kodp)->minor = 86;
#line 2669
    kodp += sizeof(struct OPERAND_0_mi );
#line 2670
    goto switch_break___9;
    case_64___8: /* CIL Label */ 
#line 2672
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2672
    ((struct OPERAND_0_mi *)kodp)->minor = 14;
#line 2672
    kodp += sizeof(struct OPERAND_0_mi );
#line 2673
    goto switch_break___9;
    case_80___8: /* CIL Label */ 
#line 2675
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2675
    ((struct OPERAND_0_mi *)kodp)->minor = 163;
#line 2675
    kodp += sizeof(struct OPERAND_0_mi );
#line 2676
    goto switch_break___9;
    case_32___8: /* CIL Label */ 
#line 2678
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2678
    ((struct OPERAND_0_mi *)kodp)->minor = 17;
#line 2678
    kodp += sizeof(struct OPERAND_0_mi );
#line 2679
    goto switch_break___9;
    case_130___8: /* CIL Label */ 
#line 2681
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2681
    ((struct OPERAND_0_mi *)kodp)->minor = 113;
#line 2681
    kodp += sizeof(struct OPERAND_0_mi );
#line 2682
    goto switch_break___9;
    case_258___8: /* CIL Label */ 
#line 2684
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2684
    ((struct OPERAND_0_mi *)kodp)->minor = 129;
#line 2684
    kodp += sizeof(struct OPERAND_0_mi );
#line 2685
    goto switch_break___9;
    case_1___8: /* CIL Label */ 
    {
#line 2687
    error_message(1010);
    }
#line 2688
    goto switch_break___9;
    switch_default___8: /* CIL Label */ 
    {
#line 2690
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2690);
#line 2691
    error_message(5000);
#line 2692
    abort();
    }
    switch_break___9: /* CIL Label */ ;
    }
#line 2694
    last_instr = current_instr;
#line 2694
    current_instr = kodp;
#line 2695
    return (1);
    case_130___9: /* CIL Label */ 
    {
#line 2700
    if ((unsigned int )type_ac[set] == 136U) {
#line 2700
      goto case_136___9;
    }
#line 2700
    if ((unsigned int )type_ac[set] == 8U) {
#line 2700
      goto case_136___9;
    }
#line 2703
    if ((unsigned int )type_ac[set] == 264U) {
#line 2703
      goto case_264___9;
    }
#line 2707
    if ((unsigned int )type_ac[set] == 152U) {
#line 2707
      goto case_152___9;
    }
#line 2707
    if ((unsigned int )type_ac[set] == 24U) {
#line 2707
      goto case_152___9;
    }
#line 2711
    if ((unsigned int )type_ac[set] == 140U) {
#line 2711
      goto case_140___9;
    }
#line 2711
    if ((unsigned int )type_ac[set] == 12U) {
#line 2711
      goto case_140___9;
    }
#line 2714
    if ((unsigned int )type_ac[set] == 280U) {
#line 2714
      goto case_280___9;
    }
#line 2717
    if ((unsigned int )type_ac[set] == 268U) {
#line 2717
      goto case_268___9;
    }
#line 2720
    if ((unsigned int )type_ac[set] == 64U) {
#line 2720
      goto case_64___9;
    }
#line 2723
    if ((unsigned int )type_ac[set] == 80U) {
#line 2723
      goto case_80___9;
    }
#line 2726
    if ((unsigned int )type_ac[set] == 32U) {
#line 2726
      goto case_32___9;
    }
#line 2729
    if ((unsigned int )type_ac[set] == 2U) {
#line 2729
      goto case_2___9;
    }
#line 2732
    if ((unsigned int )type_ac[set] == 258U) {
#line 2732
      goto case_258___9;
    }
#line 2735
    if ((unsigned int )type_ac[set] == 1U) {
#line 2735
      goto case_1___9;
    }
#line 2738
    goto switch_default___9;
    case_136___9: /* CIL Label */ 
    case_8___9: /* CIL Label */ 
#line 2701
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2701
    ((struct OPERAND_0_mi *)kodp)->minor = 153;
#line 2701
    kodp += sizeof(struct OPERAND_0_mi );
#line 2702
    goto switch_break___10;
    case_264___9: /* CIL Label */ 
#line 2704
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2704
    ((struct OPERAND_0_mi *)kodp)->minor = 30;
#line 2704
    kodp += sizeof(struct OPERAND_0_mi );
#line 2705
    goto switch_break___10;
    case_152___9: /* CIL Label */ 
    case_24___9: /* CIL Label */ 
#line 2708
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2708
    ((struct OPERAND_0_mi *)kodp)->minor = 153;
#line 2708
    kodp += sizeof(struct OPERAND_0_mi );
#line 2709
    goto switch_break___10;
    case_140___9: /* CIL Label */ 
    case_12___9: /* CIL Label */ 
#line 2712
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2712
    ((struct OPERAND_0_mi *)kodp)->minor = 72;
#line 2712
    kodp += sizeof(struct OPERAND_0_mi );
#line 2713
    goto switch_break___10;
    case_280___9: /* CIL Label */ 
#line 2715
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2715
    ((struct OPERAND_0_mi *)kodp)->minor = 30;
#line 2715
    kodp += sizeof(struct OPERAND_0_mi );
#line 2716
    goto switch_break___10;
    case_268___9: /* CIL Label */ 
#line 2718
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2718
    ((struct OPERAND_0_mi *)kodp)->minor = 88;
#line 2718
    kodp += sizeof(struct OPERAND_0_mi );
#line 2719
    goto switch_break___10;
    case_64___9: /* CIL Label */ 
#line 2721
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2721
    ((struct OPERAND_0_mi *)kodp)->minor = 136;
#line 2721
    kodp += sizeof(struct OPERAND_0_mi );
#line 2722
    goto switch_break___10;
    case_80___9: /* CIL Label */ 
#line 2724
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2724
    ((struct OPERAND_0_mi *)kodp)->minor = 165;
#line 2724
    kodp += sizeof(struct OPERAND_0_mi );
#line 2725
    goto switch_break___10;
    case_32___9: /* CIL Label */ 
#line 2727
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2727
    ((struct OPERAND_0_mi *)kodp)->minor = 143;
#line 2727
    kodp += sizeof(struct OPERAND_0_mi );
#line 2728
    goto switch_break___10;
    case_2___9: /* CIL Label */ 
#line 2730
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2730
    ((struct OPERAND_0_mi *)kodp)->minor = 97;
#line 2730
    kodp += sizeof(struct OPERAND_0_mi );
#line 2731
    goto switch_break___10;
    case_258___9: /* CIL Label */ 
#line 2733
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2733
    ((struct OPERAND_0_mi *)kodp)->minor = 130;
#line 2733
    kodp += sizeof(struct OPERAND_0_mi );
#line 2734
    goto switch_break___10;
    case_1___9: /* CIL Label */ 
    {
#line 2736
    error_message(1010);
    }
#line 2737
    goto switch_break___10;
    switch_default___9: /* CIL Label */ 
    {
#line 2739
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2739);
#line 2740
    error_message(5000);
#line 2741
    abort();
    }
    switch_break___10: /* CIL Label */ ;
    }
#line 2743
    last_instr = current_instr;
#line 2743
    current_instr = kodp;
#line 2744
    return (1);
    case_258___10: /* CIL Label */ 
    {
#line 2749
    if ((unsigned int )type_ac[set] == 136U) {
#line 2749
      goto case_136___10;
    }
#line 2749
    if ((unsigned int )type_ac[set] == 8U) {
#line 2749
      goto case_136___10;
    }
#line 2752
    if ((unsigned int )type_ac[set] == 264U) {
#line 2752
      goto case_264___10;
    }
#line 2756
    if ((unsigned int )type_ac[set] == 152U) {
#line 2756
      goto case_152___10;
    }
#line 2756
    if ((unsigned int )type_ac[set] == 24U) {
#line 2756
      goto case_152___10;
    }
#line 2760
    if ((unsigned int )type_ac[set] == 140U) {
#line 2760
      goto case_140___10;
    }
#line 2760
    if ((unsigned int )type_ac[set] == 12U) {
#line 2760
      goto case_140___10;
    }
#line 2763
    if ((unsigned int )type_ac[set] == 280U) {
#line 2763
      goto case_280___10;
    }
#line 2766
    if ((unsigned int )type_ac[set] == 268U) {
#line 2766
      goto case_268___10;
    }
#line 2769
    if ((unsigned int )type_ac[set] == 64U) {
#line 2769
      goto case_64___10;
    }
#line 2772
    if ((unsigned int )type_ac[set] == 80U) {
#line 2772
      goto case_80___10;
    }
#line 2775
    if ((unsigned int )type_ac[set] == 32U) {
#line 2775
      goto case_32___10;
    }
#line 2778
    if ((unsigned int )type_ac[set] == 2U) {
#line 2778
      goto case_2___10;
    }
#line 2781
    if ((unsigned int )type_ac[set] == 130U) {
#line 2781
      goto case_130___10;
    }
#line 2784
    if ((unsigned int )type_ac[set] == 1U) {
#line 2784
      goto case_1___10;
    }
#line 2787
    goto switch_default___10;
    case_136___10: /* CIL Label */ 
    case_8___10: /* CIL Label */ 
#line 2750
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2750
    ((struct OPERAND_0_mi *)kodp)->minor = 154;
#line 2750
    kodp += sizeof(struct OPERAND_0_mi );
#line 2751
    goto switch_break___11;
    case_264___10: /* CIL Label */ 
#line 2753
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2753
    ((struct OPERAND_0_mi *)kodp)->minor = 31;
#line 2753
    kodp += sizeof(struct OPERAND_0_mi );
#line 2754
    goto switch_break___11;
    case_152___10: /* CIL Label */ 
    case_24___10: /* CIL Label */ 
#line 2757
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2757
    ((struct OPERAND_0_mi *)kodp)->minor = 154;
#line 2757
    kodp += sizeof(struct OPERAND_0_mi );
#line 2758
    goto switch_break___11;
    case_140___10: /* CIL Label */ 
    case_12___10: /* CIL Label */ 
#line 2761
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2761
    ((struct OPERAND_0_mi *)kodp)->minor = 71;
#line 2761
    kodp += sizeof(struct OPERAND_0_mi );
#line 2762
    goto switch_break___11;
    case_280___10: /* CIL Label */ 
#line 2764
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2764
    ((struct OPERAND_0_mi *)kodp)->minor = 31;
#line 2764
    kodp += sizeof(struct OPERAND_0_mi );
#line 2765
    goto switch_break___11;
    case_268___10: /* CIL Label */ 
#line 2767
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2767
    ((struct OPERAND_0_mi *)kodp)->minor = 87;
#line 2767
    kodp += sizeof(struct OPERAND_0_mi );
#line 2768
    goto switch_break___11;
    case_64___10: /* CIL Label */ 
#line 2770
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2770
    ((struct OPERAND_0_mi *)kodp)->minor = 137;
#line 2770
    kodp += sizeof(struct OPERAND_0_mi );
#line 2771
    goto switch_break___11;
    case_80___10: /* CIL Label */ 
#line 2773
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2773
    ((struct OPERAND_0_mi *)kodp)->minor = 164;
#line 2773
    kodp += sizeof(struct OPERAND_0_mi );
#line 2774
    goto switch_break___11;
    case_32___10: /* CIL Label */ 
#line 2776
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2776
    ((struct OPERAND_0_mi *)kodp)->minor = 144;
#line 2776
    kodp += sizeof(struct OPERAND_0_mi );
#line 2777
    goto switch_break___11;
    case_2___10: /* CIL Label */ 
#line 2779
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2779
    ((struct OPERAND_0_mi *)kodp)->minor = 98;
#line 2779
    kodp += sizeof(struct OPERAND_0_mi );
#line 2780
    goto switch_break___11;
    case_130___10: /* CIL Label */ 
#line 2782
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 2782
    ((struct OPERAND_0_mi *)kodp)->minor = 114;
#line 2782
    kodp += sizeof(struct OPERAND_0_mi );
#line 2783
    goto switch_break___11;
    case_1___10: /* CIL Label */ 
    {
#line 2785
    error_message(1010);
    }
#line 2786
    goto switch_break___11;
    switch_default___10: /* CIL Label */ 
    {
#line 2788
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2788);
#line 2789
    error_message(5000);
#line 2790
    abort();
    }
    switch_break___11: /* CIL Label */ ;
    }
#line 2792
    last_instr = current_instr;
#line 2792
    current_instr = kodp;
#line 2793
    return (1);
    case_1___11: /* CIL Label */ 
    {
#line 2795
    fprintfx(stderr, "void conversion not supported yet\n");
    }
#line 2796
    return (1);
    switch_default___11: /* CIL Label */ 
    {
#line 2798
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             2798);
#line 2799
    error_message(5000);
#line 2800
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 2804
    return (1);
  }
}
}
#line 2810 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int pointer_cast(void) 
{ 
  struct internal_type *lval_type ;
  struct internal_type *rval_type ;
  int tmp___0 ;

  {
#line 2813
  lval_type = type_com[set - 1];
#line 2813
  rval_type = type_com[set];
#line 2816
  if (2048U == (unsigned int )lval_type->attribute.function_class) {
#line 2817
    lval_type = lval_type->output;
  } else
#line 2816
  if (2049U == (unsigned int )lval_type->attribute.function_class) {
#line 2817
    lval_type = lval_type->output;
  }
#line 2818
  if (2048U == (unsigned int )rval_type->attribute.function_class) {
#line 2819
    rval_type = rval_type->output;
  } else
#line 2818
  if (2049U == (unsigned int )rval_type->attribute.function_class) {
#line 2819
    rval_type = rval_type->output;
  }
#line 2821
  if (1028U == (unsigned int )lval_type->attribute.function_class) {
#line 2821
    if (1028U == (unsigned int )rval_type->attribute.function_class) {
#line 2821
      goto _L___7;
    } else
#line 2821
    if (1025U == (unsigned int )rval_type->attribute.function_class) {
      _L___7: /* CIL Label */ 
      {
#line 2824
      tmp___0 = type_compare(rval_type, lval_type);
      }
#line 2824
      if (tmp___0) {
        {
#line 2825
        error_message(6013);
        }
      }
    } else {
#line 2821
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 2827
  if (1028U == (unsigned int )lval_type->attribute.function_class) {
#line 2827
    if (1029U == (unsigned int )rval_type->attribute.function_class) {
      {
#line 2829
      error_message(1028);
      }
    } else
#line 2827
    if (1030U == (unsigned int )rval_type->attribute.function_class) {
      {
#line 2829
      error_message(1028);
      }
    } else {
#line 2827
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 2830
  if (1028U == (unsigned int )rval_type->attribute.function_class) {
    {
#line 2831
    error_message(6012);
    }
  } else
#line 2832
  if (1028U == (unsigned int )lval_type->attribute.function_class) {
    {
#line 2833
    error_message(6012);
    }
  } else
#line 2838
  if (1029U == (unsigned int )lval_type->attribute.function_class) {
#line 2838
    if (1029U == (unsigned int )rval_type->attribute.function_class) {
#line 2838
      goto _L___2;
    } else {
#line 2838
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 2838
  if (1030U == (unsigned int )lval_type->attribute.function_class) {
#line 2838
    if (1030U == (unsigned int )rval_type->attribute.function_class) {
      _L___2: /* CIL Label */ 
#line 2841
      if ((unsigned long )lval_type != (unsigned long )rval_type) {
        {
#line 2842
        error_message(1028);
        }
      } else {
#line 2844
        return (0);
      }
    } else {
#line 2838
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2846
  if (1029U == (unsigned int )rval_type->attribute.function_class) {
#line 2846
    if (! (1029U == (unsigned int )lval_type->attribute.function_class)) {
      {
#line 2850
      error_message(1028);
      }
    } else {
#line 2846
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2846
  if (! (1029U == (unsigned int )rval_type->attribute.function_class)) {
#line 2846
    if (1029U == (unsigned int )lval_type->attribute.function_class) {
      {
#line 2850
      error_message(1028);
      }
    } else {
#line 2846
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2846
  if (1030U == (unsigned int )rval_type->attribute.function_class) {
#line 2846
    if (! (1030U == (unsigned int )lval_type->attribute.function_class)) {
      {
#line 2850
      error_message(1028);
      }
    } else {
#line 2846
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2846
  if (! (1030U == (unsigned int )rval_type->attribute.function_class)) {
#line 2846
    if (1030U == (unsigned int )lval_type->attribute.function_class) {
      {
#line 2850
      error_message(1028);
      }
    } else {
#line 2852
      return (0);
    }
  } else {
#line 2852
    return (0);
  }
#line 2853
  return (1);
}
}
#line 2860 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void array_subscript(struct internal_type *pom ) 
{ 


  {
#line 2864
  poc ++;
#line 2864
  dim[poc] = ((struct range *)pom->attribute.domain)->upper;
#line 2865
  pom = pom->arity;
  {
#line 2866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2866
    if (! ((unsigned long )((void *)0) != (unsigned long )pom)) {
#line 2866
      goto while_break;
    }
#line 2868
    poc ++;
#line 2868
    dim[poc] = ((struct range *)pom->attribute.domain)->upper;
#line 2869
    pom = pom->arity;
  }
  while_break: /* CIL Label */ ;
  }
#line 2871
  return;
}
}
#line 2876 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void put_array_subscript(struct internal_type **identtab_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct internal_type *pom ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 2881
  if (! poc) {
#line 2882
    return;
  }
  {
#line 2884
  tmp___0 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 2884
  (*identtab_type)->input = (struct internal_type *)tmp___0;
#line 2886
  ((*identtab_type)->input)->attribute.arit_class = (enum intern_arit_class )8;
#line 2888
  tmp___1 = allocate((unsigned int )sizeof(struct range ), 0U);
#line 2888
  ((*identtab_type)->input)->attribute.domain = tmp___1;
#line 2890
  ((struct range *)((*identtab_type)->input)->attribute.domain)->lower = 0;
#line 2891
  ((struct range *)((*identtab_type)->input)->attribute.domain)->upper = dim[poc];
#line 2892
  tmp___2 = poc;
#line 2892
  poc --;
#line 2892
  dim[tmp___2] = -1;
  }
#line 2893
  if (-1 != dim[poc]) {
    {
#line 2897
    tmp___3 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 2897
    pom = (struct internal_type *)tmp___3;
#line 2899
    pom->attribute.arit_class = (enum intern_arit_class )8;
#line 2900
    tmp___4 = allocate((unsigned int )sizeof(struct range ), 0U);
#line 2900
    pom->attribute.domain = tmp___4;
#line 2902
    ((struct range *)pom->attribute.domain)->lower = 0;
#line 2903
    ((struct range *)pom->attribute.domain)->upper = dim[poc];
#line 2904
    tmp___5 = poc;
#line 2904
    poc --;
#line 2904
    dim[tmp___5] = -1;
#line 2905
    ((*identtab_type)->input)->arity = pom;
    }
    {
#line 2911
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2911
      if (! (-1 != dim[poc])) {
#line 2911
        goto while_break;
      }
      {
#line 2913
      tmp___6 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 2913
      pom->arity = (struct internal_type *)tmp___6;
#line 2915
      (pom->arity)->attribute.arit_class = (enum intern_arit_class )8;
#line 2916
      tmp___7 = allocate((unsigned int )sizeof(struct range ), 0U);
#line 2916
      (pom->arity)->attribute.domain = tmp___7;
#line 2918
      pom = pom->arity;
#line 2919
      ((struct range *)pom->attribute.domain)->lower = 0;
#line 2920
      ((struct range *)pom->attribute.domain)->upper = dim[poc];
#line 2921
      tmp___8 = poc;
#line 2921
      poc --;
#line 2921
      dim[tmp___8] = -1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2924
  return;
}
}
#line 2945 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int last_error_line  ;
#line 3829 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int no_trig  ;
#line 2939 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void error_message(int err_no  , ...) 
{ 
  va_list point___0 ;
  int tmp___0 ;
  char *text___0 ;
  char *tmp___2 ;
  char *arg ;
  char *tmp___4 ;
  char *arg___0 ;
  char *tmp___6 ;
  char *arg___1 ;
  char *tmp___8 ;
  char *arg___2 ;
  char *tmp___10 ;
  char *arg___3 ;
  char *tmp___12 ;
  char *arg___4 ;
  char *tmp___14 ;
  char *name___0 ;
  char *tmp___16 ;
  char *name___1 ;
  char *tmp___18 ;
  char *name___2 ;
  char *tmp___20 ;
  char *name___3 ;
  char *tmp___22 ;
  char *name___4 ;
  char *tmp___24 ;
  char *name___5 ;
  char *tmp___26 ;
  char *tmp_line ;
  char *beg ;
  char *end ;
  char *com ;
  int n ;
  int n_tmp_line ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  char *tmp___31 ;
  char const   *tmp___32 ;
  char *tmp___33 ;
  char const   *tmp___34 ;
  char buf[2] ;
  char tmp___35 ;
  char tmp___36 ;
  int arg___5 ;
  int tmp___38 ;
  int arg___6 ;
  int tmp___40 ;
  struct internal_type *type ;
  struct internal_type *tmp___42 ;
  int arg___7 ;
  int tmp___44 ;
  char *tmp___45 ;
  struct internal_type *type1 ;
  struct internal_type *tmp___47 ;
  struct internal_type *type2 ;
  struct internal_type *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *type___0 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *name___6 ;
  char *tmp___56 ;
  struct internal_type *type___1 ;
  struct internal_type *tmp___58 ;
  int arg___8 ;
  int tmp___60 ;
  char *tmp___61 ;
  char *name___7 ;
  char *tmp___63 ;
  void *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;

  {
  {
#line 2948
  __builtin_va_start(point___0, err_no);
  }
#line 2954
  if (warning_inhibit) {
#line 2954
    if (err_no >= 6000) {
#line 2954
      if (err_no < 7000) {
#line 2955
        goto end;
      }
    }
  }
#line 2956
  if (err_no < 6000) {
#line 2958
    error_count ++;
#line 2959
    last_error_line = spf[s].line_counter;
  } else
#line 2956
  if (err_no >= 7000) {
#line 2958
    error_count ++;
#line 2959
    last_error_line = spf[s].line_counter;
  } else
#line 2961
  if (warnings_are_errors) {
#line 2962
    error_count ++;
  }
#line 2965
  if (last_error_line == spf[s].line_counter) {
#line 2965
    if (err_no >= 6000) {
#line 2965
      if (err_no < 7000) {
#line 2967
        goto end;
      }
    }
  }
  {
#line 2973
  if (err_no == 1000) {
#line 2973
    goto case_1000;
  }
#line 2979
  if (err_no == 1001) {
#line 2979
    goto case_1001;
  }
#line 2994
  if (err_no == 1002) {
#line 2994
    goto case_1002;
  }
#line 3000
  if (err_no == 1003) {
#line 3000
    goto case_1003;
  }
#line 3006
  if (err_no == 1004) {
#line 3006
    goto case_1004;
  }
#line 3022
  if (err_no == 1005) {
#line 3022
    goto case_1005;
  }
#line 3029
  if (err_no == 1006) {
#line 3029
    goto case_1006;
  }
#line 3035
  if (err_no == 1007) {
#line 3035
    goto case_1007;
  }
#line 3040
  if (err_no == 1008) {
#line 3040
    goto case_1008;
  }
#line 3045
  if (err_no == 1009) {
#line 3045
    goto case_1009;
  }
#line 3050
  if (err_no == 1010) {
#line 3050
    goto case_1010;
  }
#line 3055
  if (err_no == 1011) {
#line 3055
    goto case_1011;
  }
#line 3061
  if (err_no == 1012) {
#line 3061
    goto case_1012;
  }
#line 3067
  if (err_no == 1013) {
#line 3067
    goto case_1013;
  }
#line 3072
  if (err_no == 1014) {
#line 3072
    goto case_1014;
  }
#line 3077
  if (err_no == 1015) {
#line 3077
    goto case_1015;
  }
#line 3085
  if (err_no == 1016) {
#line 3085
    goto case_1016;
  }
#line 3090
  if (err_no == 1017) {
#line 3090
    goto case_1017;
  }
#line 3096
  if (err_no == 1018) {
#line 3096
    goto case_1018;
  }
#line 3102
  if (err_no == 1019) {
#line 3102
    goto case_1019;
  }
#line 3108
  if (err_no == 1020) {
#line 3108
    goto case_1020;
  }
#line 3113
  if (err_no == 1021) {
#line 3113
    goto case_1021;
  }
#line 3118
  if (err_no == 1022) {
#line 3118
    goto case_1022;
  }
#line 3123
  if (err_no == 1023) {
#line 3123
    goto case_1023;
  }
#line 3129
  if (err_no == 1024) {
#line 3129
    goto case_1024;
  }
#line 3135
  if (err_no == 1025) {
#line 3135
    goto case_1025;
  }
#line 3139
  if (err_no == 1026) {
#line 3139
    goto case_1026;
  }
#line 3146
  if (err_no == 1027) {
#line 3146
    goto case_1027;
  }
#line 3151
  if (err_no == 1028) {
#line 3151
    goto case_1028;
  }
#line 3156
  if (err_no == 1029) {
#line 3156
    goto case_1029;
  }
#line 3161
  if (err_no == 1030) {
#line 3161
    goto case_1030;
  }
#line 3166
  if (err_no == 1031) {
#line 3166
    goto case_1031;
  }
#line 3171
  if (err_no == 1032) {
#line 3171
    goto case_1032;
  }
#line 3176
  if (err_no == 1033) {
#line 3176
    goto case_1033;
  }
#line 3184
  if (err_no == 1034) {
#line 3184
    goto case_1034;
  }
#line 3189
  if (err_no == 1035) {
#line 3189
    goto case_1035;
  }
#line 3197
  if (err_no == 1036) {
#line 3197
    goto case_1036;
  }
#line 3204
  if (err_no == 1037) {
#line 3204
    goto case_1037;
  }
#line 3211
  if (err_no == 1038) {
#line 3211
    goto case_1038;
  }
#line 3219
  if (err_no == 1039) {
#line 3219
    goto case_1039;
  }
#line 3226
  if (err_no == 1040) {
#line 3226
    goto case_1040;
  }
#line 3233
  if (err_no == 2000) {
#line 3233
    goto case_2000;
  }
#line 3244
  if (err_no == 2002) {
#line 3244
    goto case_2002;
  }
#line 3250
  if (err_no == 2003) {
#line 3250
    goto case_2003;
  }
#line 3256
  if (err_no == 2004) {
#line 3256
    goto case_2004;
  }
#line 3261
  if (err_no == 2005) {
#line 3261
    goto case_2005;
  }
#line 3267
  if (err_no == 2006) {
#line 3267
    goto case_2006;
  }
#line 3273
  if (err_no == 2007) {
#line 3273
    goto case_2007;
  }
#line 3279
  if (err_no == 2008) {
#line 3279
    goto case_2008;
  }
#line 3285
  if (err_no == 2009) {
#line 3285
    goto case_2009;
  }
#line 3291
  if (err_no == 2010) {
#line 3291
    goto case_2010;
  }
#line 3297
  if (err_no == 2011) {
#line 3297
    goto case_2011;
  }
#line 3303
  if (err_no == 2012) {
#line 3303
    goto case_2012;
  }
#line 3312
  if (err_no == 2013) {
#line 3312
    goto case_2013;
  }
#line 3321
  if (err_no == 2014) {
#line 3321
    goto case_2014;
  }
#line 3330
  if (err_no == 2015) {
#line 3330
    goto case_2015;
  }
#line 3339
  if (err_no == 2016) {
#line 3339
    goto case_2016;
  }
#line 3348
  if (err_no == 2017) {
#line 3348
    goto case_2017;
  }
#line 3363
  if (err_no == 2018) {
#line 3363
    goto case_2018;
  }
#line 3375
  if (err_no == 3000) {
#line 3375
    goto case_3000;
  }
#line 3380
  if (err_no == 3001) {
#line 3380
    goto case_3001;
  }
#line 3385
  if (err_no == 3002) {
#line 3385
    goto case_3002;
  }
#line 3390
  if (err_no == 3003) {
#line 3390
    goto case_3003;
  }
#line 3398
  if (err_no == 3004) {
#line 3398
    goto case_3004;
  }
#line 3404
  if (err_no == 3005) {
#line 3404
    goto case_3005;
  }
#line 3414
  if (err_no == 4000) {
#line 3414
    goto case_4000;
  }
#line 3419
  if (err_no == 4001) {
#line 3419
    goto case_4001;
  }
#line 3424
  if (err_no == 4002) {
#line 3424
    goto case_4002;
  }
#line 3429
  if (err_no == 4003) {
#line 3429
    goto case_4003;
  }
#line 3434
  if (err_no == 4004) {
#line 3434
    goto case_4004;
  }
#line 3443
  if (err_no == 5000) {
#line 3443
    goto case_5000;
  }
#line 3453
  if (err_no == 5001) {
#line 3453
    goto case_5001;
  }
#line 3463
  if (err_no == 5002) {
#line 3463
    goto case_5002;
  }
#line 3473
  if (err_no == 5003) {
#line 3473
    goto case_5003;
  }
#line 3487
  if (err_no == 6000) {
#line 3487
    goto case_6000;
  }
#line 3496
  if (err_no == 6001) {
#line 3496
    goto case_6001;
  }
#line 3504
  if (err_no == 6002) {
#line 3504
    goto case_6002;
  }
#line 3512
  if (err_no == 6003) {
#line 3512
    goto case_6003;
  }
#line 3535
  if (err_no == 6004) {
#line 3535
    goto case_6004;
  }
#line 3544
  if (err_no == 6005) {
#line 3544
    goto case_6005;
  }
#line 3553
  if (err_no == 6006) {
#line 3553
    goto case_6006;
  }
#line 3576
  if (err_no == 6007) {
#line 3576
    goto case_6007;
  }
#line 3584
  if (err_no == 6008) {
#line 3584
    goto case_6008;
  }
#line 3592
  if (err_no == 6009) {
#line 3592
    goto case_6009;
  }
#line 3651
  if (err_no == 6010) {
#line 3651
    goto case_6010;
  }
#line 3656
  if (err_no == 6011) {
#line 3656
    goto case_6011;
  }
#line 3660
  if (err_no == 6012) {
#line 3660
    goto case_6012;
  }
#line 3669
  if (err_no == 6013) {
#line 3669
    goto case_6013;
  }
#line 3674
  if (err_no == 6014) {
#line 3674
    goto case_6014;
  }
#line 3686
  if (err_no == 6015) {
#line 3686
    goto case_6015;
  }
#line 3696
  if (err_no == 6016) {
#line 3696
    goto case_6016;
  }
#line 3706
  if (err_no == 6017) {
#line 3706
    goto case_6017;
  }
#line 3717
  if (err_no == 6018) {
#line 3717
    goto case_6018;
  }
#line 3725
  if (err_no == 6019) {
#line 3725
    goto case_6019;
  }
#line 3733
  if (err_no == 6020) {
#line 3733
    goto case_6020;
  }
#line 3741
  if (err_no == 6021) {
#line 3741
    goto case_6021;
  }
#line 3749
  if (err_no == 6022) {
#line 3749
    goto case_6022;
  }
#line 3756
  if (err_no == 6023) {
#line 3756
    goto case_6023;
  }
#line 3763
  if (err_no == 6024) {
#line 3763
    goto case_6024;
  }
#line 3775
  if (err_no == 6025) {
#line 3775
    goto case_6025;
  }
#line 3782
  if (err_no == 6026) {
#line 3782
    goto case_6026;
  }
#line 3786
  if (err_no == 6027) {
#line 3786
    goto case_6027;
  }
#line 3790
  if (err_no == 6028) {
#line 3790
    goto case_6028;
  }
#line 3798
  if (err_no == 6029) {
#line 3798
    goto case_6029;
  }
#line 3806
  if (err_no == 6030) {
#line 3806
    goto case_6030;
  }
#line 3815
  if (err_no == 6031) {
#line 3815
    goto case_6031;
  }
#line 3826
  if (err_no == 6032) {
#line 3826
    goto case_6032;
  }
#line 3836
  if (err_no == 6033) {
#line 3836
    goto case_6033;
  }
#line 3844
  if (err_no == 6034) {
#line 3844
    goto case_6034;
  }
#line 3852
  if (err_no == 6035) {
#line 3852
    goto case_6035;
  }
#line 3864
  if (err_no == 7000) {
#line 3864
    goto case_7000;
  }
#line 3869
  if (err_no == 7001) {
#line 3869
    goto case_7001;
  }
#line 3875
  if (err_no == 7002) {
#line 3875
    goto case_7002;
  }
#line 3880
  if (err_no == 7003) {
#line 3880
    goto case_7003;
  }
#line 3886
  goto switch_default;
  case_1000: /* CIL Label */ 
  {
#line 2974
  print_file_name();
#line 2974
  print_line_number(spf[s].line_counter);
#line 2974
  print_error_number(err_no);
#line 2975
  fprintfx(stderr, "variable `%s\' isn\'t declared\n", text);
  }
#line 2978
  goto switch_break;
  case_1001: /* CIL Label */ 
  {
#line 2980
  print_file_name();
#line 2980
  print_line_number(spf[s].line_counter);
#line 2980
  print_error_number(err_no);
#line 2986
  fprintfx(stderr, "`%s\' redeclared as different kind of symbol\n", text);
#line 2990
  print_file_name();
#line 2990
  tmp___0 = get_declaration_line(text);
#line 2990
  print_line_number(tmp___0);
#line 2990
  print_error_number(err_no);
#line 2991
  fprintfx(stderr, "previous declaration of `%s\'\n", text);
  }
#line 2993
  goto switch_break;
  case_1002: /* CIL Label */ 
  {
#line 2995
  print_file_name();
#line 2995
  print_line_number(spf[s].line_counter);
#line 2995
  print_error_number(err_no);
#line 2996
  fprintfx(stderr, "remote procedure %s is not declared\n", proc_name_text[proc]);
  }
#line 2999
  goto switch_break;
  case_1003: /* CIL Label */ 
  {
#line 3001
  print_file_name();
#line 3001
  print_line_number(spf[s].line_counter);
#line 3001
  print_error_number(err_no);
#line 3002
  fprintfx(stderr, "local variable `%s\' was already declared\n", text);
  }
#line 3005
  goto switch_break;
  case_1004: /* CIL Label */ 
  {
#line 3015
  tmp___2 = __builtin_va_arg(point___0, char *);
#line 3015
  text___0 = tmp___2;
#line 3016
  print_file_name();
#line 3016
  print_line_number(spf[s].line_counter);
#line 3016
  print_error_number(err_no);
#line 3017
  fprintfx(stderr, "parse error before `%s\'\n", text___0);
  }
#line 3021
  goto switch_break;
  case_1005: /* CIL Label */ 
  {
#line 3023
  print_source_line();
#line 3024
  print_file_name();
#line 3024
  print_line_number(spf[s].line_counter);
#line 3024
  print_error_number(err_no);
#line 3025
  fprintfx(stderr, "invalid type of the operand, %d-th character\n", char_counter);
  }
#line 3028
  goto switch_break;
  case_1006: /* CIL Label */ 
  {
#line 3030
  print_file_name();
#line 3030
  print_error_number(err_no);
#line 3031
  fprintfx(stderr, "remote function `%s\' already declared\n", text);
  }
#line 3034
  goto switch_break;
  case_1007: /* CIL Label */ 
  {
#line 3036
  print_file_name();
#line 3036
  print_line_number(spf[s].line_counter);
#line 3036
  print_error_number(err_no);
#line 3037
  fprintfx(stderr, "remote function isn\'t declared\n");
  }
#line 3039
  goto switch_break;
  case_1008: /* CIL Label */ 
  {
#line 3041
  print_file_name();
#line 3041
  print_line_number(spf[s].line_counter);
#line 3041
  print_error_number(err_no);
#line 3042
  fprintfx(stderr, "remote functions are not in the load table\n");
  }
#line 3044
  goto switch_break;
  case_1009: /* CIL Label */ 
  {
#line 3046
  print_file_name();
#line 3046
  print_line_number(spf[s].line_counter);
#line 3046
  print_error_number(err_no);
#line 3047
  fprintfx(stderr, "`void\' type in expression\n");
  }
#line 3049
  goto switch_break;
  case_1010: /* CIL Label */ 
  {
#line 3051
  print_file_name();
#line 3051
  print_line_number(spf[s].line_counter);
#line 3051
  print_error_number(err_no);
#line 3052
  fprintfx(stderr, "`void\' type assigned to l_value\n");
  }
#line 3054
  goto switch_break;
  case_1011: /* CIL Label */ 
  {
#line 3056
  print_file_name();
#line 3056
  print_line_number(spf[s].line_counter);
#line 3056
  print_error_number(err_no);
#line 3057
  fprintfx(stderr, "load can\'t open file `%s\'\n", yytext);
  }
#line 3060
  goto switch_break;
  case_1012: /* CIL Label */ 
  {
#line 3062
  print_file_name();
#line 3062
  print_line_number(spf[s].line_counter);
#line 3062
  print_error_number(err_no);
#line 3063
  fprintfx(stderr, "variable or field `%s\' declared void\n", text);
  }
#line 3066
  goto switch_break;
  case_1013: /* CIL Label */ 
  {
#line 3068
  print_file_name();
#line 3068
  print_line_number(spf[s].line_counter);
#line 3068
  print_error_number(err_no);
#line 3069
  fprintfx(stderr, "switch quantity not an integer\n");
  }
#line 3071
  goto switch_break;
  case_1014: /* CIL Label */ 
  {
#line 3073
  print_file_name();
#line 3073
  print_line_number(spf[s].line_counter);
#line 3073
  print_error_number(err_no);
#line 3074
  fprintfx(stderr, "case label does not reduce to an integer constant\n");
  }
#line 3076
  goto switch_break;
  case_1015: /* CIL Label */ 
  {
#line 3078
  print_file_name();
#line 3078
  print_line_number(tmp_c->line_number);
#line 3078
  print_error_number(err_no);
#line 3079
  fprintfx(stderr, "duplicate case value\n");
#line 3081
  print_file_name();
#line 3081
  print_line_number(tmp_m->line_number);
#line 3081
  print_error_number(err_no);
#line 3082
  fprintfx(stderr, "this is the first entry for that value\n");
  }
#line 3084
  goto switch_break;
  case_1016: /* CIL Label */ 
  {
#line 3086
  print_file_name();
#line 3086
  print_line_number(spf[s].line_counter);
#line 3086
  print_error_number(err_no);
#line 3087
  fprintfx(stderr, "case label not within a switch statement\n");
  }
#line 3089
  goto switch_break;
  case_1017: /* CIL Label */ 
  {
#line 3091
  print_file_name();
#line 3091
  print_line_number(spf[s].line_counter);
#line 3091
  print_error_number(err_no);
#line 3092
  fprintfx(stderr, "redefinition of `struct %s\'\n", text);
  }
#line 3095
  goto switch_break;
  case_1018: /* CIL Label */ 
  {
#line 3097
  print_file_name();
#line 3097
  print_line_number(spf[s].line_counter);
#line 3097
  print_error_number(err_no);
#line 3098
  fprintfx(stderr, "redefinition of `union %s\'\n", text);
  }
#line 3101
  goto switch_break;
  case_1019: /* CIL Label */ 
  {
#line 3103
  print_file_name();
#line 3103
  print_line_number(spf[s].line_counter);
#line 3103
  print_error_number(err_no);
#line 3104
  fprintfx(stderr, "redefinition of `enum %s\'\n", text);
  }
#line 3107
  goto switch_break;
  case_1020: /* CIL Label */ 
  {
#line 3109
  print_file_name();
#line 3109
  print_line_number(spf[s].line_counter);
#line 3109
  print_error_number(err_no);
#line 3110
  fprintfx(stderr, "conversion to non-scalar type requested\n");
  }
#line 3112
  goto switch_break;
  case_1021: /* CIL Label */ 
  {
#line 3114
  print_file_name();
#line 3114
  print_line_number(spf[s].line_counter);
#line 3114
  print_error_number(err_no);
#line 3115
  fprintfx(stderr, "invalid type argument of `->\'\n");
  }
#line 3117
  goto switch_break;
  case_1022: /* CIL Label */ 
  {
#line 3119
  print_file_name();
#line 3119
  print_line_number(spf[s].line_counter);
#line 3119
  print_error_number(err_no);
#line 3120
  fprintfx(stderr, "invalid lvalue in unary `&\'\n");
  }
#line 3122
  goto switch_break;
  case_1023: /* CIL Label */ 
  {
#line 3124
  print_file_name();
#line 3124
  print_line_number(spf[s].line_counter);
#line 3124
  print_error_number(err_no);
#line 3125
  fprintfx(stderr, "storage size of `%s\' isn\'t known\n", text);
  }
#line 3128
  goto switch_break;
  case_1024: /* CIL Label */ 
  {
#line 3130
  print_file_name();
#line 3130
  print_line_number(spf[s].line_counter);
#line 3130
  print_error_number(err_no);
#line 3131
  fprintfx(stderr, "parameter `%s\' has incomplete type\n", text);
  }
#line 3134
  goto switch_break;
  case_1025: /* CIL Label */ 
  {
#line 3136
  print_file_name();
#line 3136
  print_line_number(spf[s].line_counter);
#line 3136
  print_error_number(err_no);
#line 3137
  fprintfx(stderr, "field `%s\' has incomplete type\n", text);
  }
#line 3138
  goto switch_break;
  case_1026: /* CIL Label */ 
  {
#line 3140
  print_file_name();
#line 3140
  print_line_number(spf[s].line_counter);
#line 3140
  print_error_number(err_no);
#line 3141
  fprintfx(stderr, "`%s\' defined as wrong kind of tag\n", text);
  }
#line 3144
  goto switch_break;
  case_1027: /* CIL Label */ 
  {
#line 3147
  print_file_name();
#line 3147
  print_line_number(spf[s].line_counter);
#line 3147
  print_error_number(err_no);
#line 3148
  fprintfx(stderr, "sizeof applied to an incomplete type\n");
  }
#line 3150
  goto switch_break;
  case_1028: /* CIL Label */ 
  {
#line 3152
  print_file_name();
#line 3152
  print_line_number(spf[s].line_counter);
#line 3152
  print_error_number(err_no);
#line 3153
  fprintfx(stderr, "incompatible types in assignment\n");
  }
#line 3155
  goto switch_break;
  case_1029: /* CIL Label */ 
  {
#line 3157
  print_file_name();
#line 3157
  print_line_number(spf[s].line_counter);
#line 3157
  print_error_number(err_no);
#line 3158
  fprintfx(stderr, "invalid type argument of `unary *\'\n");
  }
#line 3160
  goto switch_break;
  case_1030: /* CIL Label */ 
  {
#line 3162
  print_file_name();
#line 3162
  print_line_number(spf[s].line_counter);
#line 3162
  print_error_number(err_no);
#line 3163
  fprintfx(stderr, "wrong type argument to bit-complement\n");
  }
#line 3165
  goto switch_break;
  case_1031: /* CIL Label */ 
  {
#line 3167
  print_file_name();
#line 3167
  print_line_number(spf[s].line_counter);
#line 3167
  print_error_number(err_no);
#line 3168
  fprintfx(stderr, "wrong type argument to unary minus\n");
  }
#line 3170
  goto switch_break;
  case_1032: /* CIL Label */ 
  {
#line 3172
  print_file_name();
#line 3172
  print_line_number(spf[s].line_counter);
#line 3172
  print_error_number(err_no);
#line 3173
  fprintfx(stderr, "wrong type argument to unary plus\n");
  }
#line 3175
  goto switch_break;
  case_1033: /* CIL Label */ 
  {
#line 3178
  tmp___4 = __builtin_va_arg(point___0, char *);
#line 3178
  arg = tmp___4;
#line 3179
  print_file_name();
#line 3179
  print_line_number(spf[s].line_counter);
#line 3179
  print_error_number(err_no);
#line 3180
  fprintfx(stderr, "invalid operands to binary %s\n", arg);
  }
#line 3183
  goto switch_break;
  case_1034: /* CIL Label */ 
  {
#line 3185
  print_file_name();
#line 3185
  print_line_number(spf[s].line_counter);
#line 3185
  print_error_number(err_no);
#line 3186
  fprintfx(stderr, "invalid lvalue in assignment\n");
  }
#line 3188
  goto switch_break;
  case_1035: /* CIL Label */ 
  {
#line 3191
  tmp___6 = __builtin_va_arg(point___0, char *);
#line 3191
  arg___0 = tmp___6;
#line 3192
  print_file_name();
#line 3192
  print_line_number(spf[s].line_counter);
#line 3192
  print_error_number(err_no);
#line 3193
  fprintfx(stderr, "invalid lvalue in %s\n", arg___0);
  }
#line 3196
  goto switch_break;
  case_1036: /* CIL Label */ 
  {
#line 3199
  tmp___8 = __builtin_va_arg(point___0, char *);
#line 3199
  arg___1 = tmp___8;
#line 3200
  print_file_name();
#line 3200
  print_line_number(spf[s].line_counter);
#line 3200
  print_error_number(err_no);
#line 3201
  fprintfx(stderr, "function definition declared `%s\'\n", arg___1);
  }
#line 3203
  goto switch_break;
  case_1037: /* CIL Label */ 
  {
#line 3206
  tmp___10 = __builtin_va_arg(point___0, char *);
#line 3206
  arg___2 = tmp___10;
#line 3207
  print_file_name();
#line 3207
  print_line_number(spf[s].line_counter);
#line 3207
  print_error_number(err_no);
#line 3208
  fprintfx(stderr, "typedef `%s\' is initialized\n", arg___2);
  }
#line 3210
  goto switch_break;
  case_1038: /* CIL Label */ 
  {
#line 3213
  tmp___12 = __builtin_va_arg(point___0, char *);
#line 3213
  arg___3 = tmp___12;
#line 3214
  print_file_name();
#line 3214
  print_line_number(spf[s].line_counter);
#line 3214
  print_error_number(err_no);
#line 3215
  fprintfx(stderr, "`%s\' undeclared here (not in a function)\n", arg___3);
  }
#line 3218
  goto switch_break;
  case_1039: /* CIL Label */ 
  {
#line 3221
  tmp___14 = __builtin_va_arg(point___0, char *);
#line 3221
  arg___4 = tmp___14;
#line 3222
  print_file_name();
#line 3222
  print_line_number(spf[s].line_counter);
#line 3222
  print_error_number(err_no);
#line 3223
  fprintfx(stderr, "parse error before %s constant\n", arg___4);
  }
#line 3225
  goto switch_break;
  case_1040: /* CIL Label */ 
  {
#line 3227
  print_file_name();
#line 3227
  print_line_number(spf[s].line_counter);
#line 3227
  print_error_number(err_no);
#line 3228
  fprintfx(stderr, "invalid initializer\n");
  }
#line 3229
  goto switch_break;
  case_2000: /* CIL Label */ 
  {
#line 3234
  print_file_name();
#line 3234
  print_line_number(spf[s].line_counter);
#line 3234
  print_error_number(err_no);
#line 3240
  fprintfx(stderr, "subscripted value is neither array nor pointer\n");
  }
#line 3243
  goto switch_break;
  case_2002: /* CIL Label */ 
  {
#line 3245
  print_source_line();
#line 3246
  print_file_name();
#line 3246
  print_line_number(spf[s].line_counter);
#line 3246
  print_error_number(err_no);
#line 3247
  fprintfx(stderr, "invalid type of array subscript\n");
  }
#line 3249
  goto switch_break;
  case_2003: /* CIL Label */ 
  {
#line 3251
  print_source_line();
#line 3252
  print_file_name();
#line 3252
  print_line_number(spf[s].line_counter);
#line 3252
  print_error_number(err_no);
#line 3253
  fprintfx(stderr, "type of formal parameter does not match previous declaration\n");
  }
#line 3255
  goto switch_break;
  case_2004: /* CIL Label */ 
  {
#line 3257
  print_file_name();
#line 3257
  print_line_number(spf[s].line_counter);
#line 3257
  print_error_number(err_no);
#line 3258
  fprintfx(stderr, "number of formal parameters does not match previous declaration\n");
  }
#line 3260
  goto switch_break;
  case_2005: /* CIL Label */ 
  {
#line 3262
  print_source_line();
#line 3263
  print_file_name();
#line 3263
  print_line_number(spf[s].line_counter);
#line 3263
  print_error_number(err_no);
#line 3264
  fprintfx(stderr, "name of formal paramter does not match previous declaration\n");
  }
#line 3266
  goto switch_break;
  case_2006: /* CIL Label */ 
  {
#line 3268
  print_source_line();
#line 3269
  print_file_name();
#line 3269
  print_line_number(spf[s].line_counter);
#line 3269
  print_error_number(err_no);
#line 3270
  fprintfx(stderr, "size of array subscript of formal parameter does not match previous declaration\n");
  }
#line 3272
  goto switch_break;
  case_2007: /* CIL Label */ 
  {
#line 3274
  print_source_line();
#line 3275
  print_file_name();
#line 3275
  print_line_number(spf[s].line_counter);
#line 3275
  print_error_number(err_no);
#line 3276
  fprintfx(stderr, "number of array subscripts of formal parameter does not match previous declaration\n");
  }
#line 3278
  goto switch_break;
  case_2008: /* CIL Label */ 
  {
#line 3280
  print_file_name();
#line 3280
  print_line_number(spf[s].line_counter);
#line 3280
  print_error_number(err_no);
#line 3281
  fprintfx(stderr, "structure has no member named `%s\'\n", text);
  }
#line 3284
  goto switch_break;
  case_2009: /* CIL Label */ 
  {
#line 3286
  print_file_name();
#line 3286
  print_line_number(spf[s].line_counter);
#line 3286
  print_error_number(err_no);
#line 3287
  fprintfx(stderr, "request for member `%s\' in something not a structure or union\n",
           text);
  }
#line 3290
  goto switch_break;
  case_2010: /* CIL Label */ 
  {
#line 3292
  print_file_name();
#line 3292
  print_line_number(spf[s].line_counter);
#line 3292
  print_error_number(err_no);
#line 3293
  fprintfx(stderr, "too few arguments to function `%s\'\n", text);
  }
#line 3296
  goto switch_break;
  case_2011: /* CIL Label */ 
  {
#line 3298
  print_file_name();
#line 3298
  print_line_number(spf[s].line_counter);
#line 3298
  print_error_number(err_no);
#line 3299
  fprintfx(stderr, "too many arguments to function `%s\'\n", text);
  }
#line 3302
  goto switch_break;
  case_2012: /* CIL Label */ 
  {
#line 3305
  tmp___16 = __builtin_va_arg(point___0, char *);
#line 3305
  name___0 = tmp___16;
#line 3306
  print_file_name();
#line 3306
  print_line_number(spf[s].line_counter);
#line 3306
  print_error_number(err_no);
#line 3307
  fprintfx(stderr, "long, short, signed or unsigned invalid for `%s\'\n", name___0);
  }
#line 3311
  goto switch_break;
  case_2013: /* CIL Label */ 
  {
#line 3314
  tmp___18 = __builtin_va_arg(point___0, char *);
#line 3314
  name___1 = tmp___18;
#line 3315
  print_file_name();
#line 3315
  print_line_number(spf[s].line_counter);
#line 3315
  print_error_number(err_no);
#line 3316
  fprintfx(stderr, "long or short specified with char for `%s\'\n", name___1);
  }
#line 3320
  goto switch_break;
  case_2014: /* CIL Label */ 
  {
#line 3323
  tmp___20 = __builtin_va_arg(point___0, char *);
#line 3323
  name___2 = tmp___20;
#line 3324
  print_file_name();
#line 3324
  print_line_number(spf[s].line_counter);
#line 3324
  print_error_number(err_no);
#line 3325
  fprintfx(stderr, "short, signed or unsigned invalid for `%s\'\n", name___2);
  }
#line 3329
  goto switch_break;
  case_2015: /* CIL Label */ 
  {
#line 3332
  tmp___22 = __builtin_va_arg(point___0, char *);
#line 3332
  name___3 = tmp___22;
#line 3333
  print_file_name();
#line 3333
  print_line_number(spf[s].line_counter);
#line 3333
  print_error_number(err_no);
#line 3334
  fprintfx(stderr, "signed and unsigned given together for `%s\'\n", name___3);
  }
#line 3338
  goto switch_break;
  case_2016: /* CIL Label */ 
  {
#line 3341
  tmp___24 = __builtin_va_arg(point___0, char *);
#line 3341
  name___4 = tmp___24;
#line 3342
  print_file_name();
#line 3342
  print_line_number(spf[s].line_counter);
#line 3342
  print_error_number(err_no);
#line 3343
  fprintfx(stderr, "long and short specified together for `%s\'\n", name___4);
  }
#line 3347
  goto switch_break;
  case_2017: /* CIL Label */ 
  {
#line 3353
  print_file_name();
#line 3353
  print_line_number(spf[s].line_counter);
#line 3353
  print_error_number(err_no);
#line 3359
  fprintfx(stderr, "multiple storage classes in declaration\n");
  }
#line 3362
  goto switch_break;
  case_2018: /* CIL Label */ 
  {
#line 3365
  tmp___26 = __builtin_va_arg(point___0, char *);
#line 3365
  name___5 = tmp___26;
#line 3366
  print_file_name();
#line 3366
  print_line_number(spf[s].line_counter);
#line 3366
  print_error_number(err_no);
#line 3367
  fprintfx(stderr, "storage class specified for parameter `%s\'\n", name___5);
  }
#line 3371
  goto switch_break;
  case_3000: /* CIL Label */ 
  {
#line 3376
  print_file_name();
#line 3376
  print_line_number(spf[s].line_counter);
#line 3376
  print_error_number(err_no);
#line 3377
  fprintfx(stderr, "`break\' outside loop or switch\n");
  }
#line 3379
  goto switch_break;
  case_3001: /* CIL Label */ 
  {
#line 3381
  print_file_name();
#line 3381
  print_line_number(spf[s].line_counter);
#line 3381
  print_error_number(err_no);
#line 3382
  fprintfx(stderr, "bad used `continue\'\n");
  }
#line 3384
  goto switch_break;
  case_3002: /* CIL Label */ 
  {
#line 3386
  print_file_name();
#line 3386
  print_line_number(spf[s].line_counter);
#line 3386
  print_error_number(err_no);
#line 3387
  fprintfx(stderr, "default label not within a switch statement\n");
  }
#line 3389
  goto switch_break;
  case_3003: /* CIL Label */ 
  {
#line 3391
  print_file_name();
#line 3391
  print_line_number(spf[s].line_counter);
#line 3391
  print_error_number(err_no);
#line 3392
  fprintfx(stderr, "multiple default labels in one switch\n");
#line 3394
  print_file_name();
#line 3394
  print_line_number(fixp->switch1.def_use.line_number);
#line 3394
  print_error_number(err_no);
#line 3395
  fprintfx(stderr, "this is the first default label\n");
  }
#line 3397
  goto switch_break;
  case_3004: /* CIL Label */ 
  {
#line 3399
  print_file_name();
#line 3399
  print_line_number(spf[s].line_counter);
#line 3399
  print_error_number(err_no);
#line 3400
  fprintfx(stderr, "duplicate label `%s\'\n", text);
  }
#line 3403
  goto switch_break;
  case_3005: /* CIL Label */ 
  {
#line 3405
  print_file_name();
#line 3405
  print_line_number(error_line_number);
#line 3405
  print_error_number(err_no);
#line 3406
  fprintfx(stderr, "label `%s\' used but not defined\n", text);
  }
#line 3409
  goto switch_break;
  case_4000: /* CIL Label */ 
  {
#line 3415
  print_error_number(err_no);
#line 3416
  fprintfx(stderr, "interpreter: full memory\n");
  }
#line 3418
  goto switch_break;
  case_4001: /* CIL Label */ 
  {
#line 3420
  print_error_number(err_no);
#line 3421
  fprintfx(stderr, "interpreter: stack overflow\n");
  }
#line 3423
  goto switch_break;
  case_4002: /* CIL Label */ 
  {
#line 3425
  print_error_number(err_no);
#line 3426
  fprintfx(stderr, "operating system out of memory\n");
  }
#line 3428
  goto switch_break;
  case_4003: /* CIL Label */ 
  {
#line 3430
  print_error_number(err_no);
#line 3431
  fprintfx(stderr, "interpreter: Undefined symbol `main\'\n");
  }
#line 3433
  goto switch_break;
  case_4004: /* CIL Label */ 
  {
#line 3435
  print_error_number(err_no);
#line 3436
  fprintfx(stderr, "cannot set signals\n");
  }
#line 3438
  goto switch_break;
  case_5000: /* CIL Label */ 
  {
#line 3444
  fprintfx(stderr, "Compile Fatal ");
#line 3446
  print_error_number(err_no);
#line 3447
  fprintfx(stderr, "Interpreter Internal Error (unknown operand type) in line %d e-mail: %s\n",
           spf[s].line_counter, "koren@vm.stuba.sk");
#line 3450
  print_source_line();
#line 3451
  fprintfx(stderr, "\n");
  }
#line 3452
  goto switch_break;
  case_5001: /* CIL Label */ 
  {
#line 3454
  fprintfx(stderr, "Run-time Fatal ");
#line 3456
  print_error_number(err_no);
#line 3457
  fprintfx(stderr, " Internal Interpreter Error (unknown instruction) e-mail: %s\n",
           "koren@vm.stuba.sk");
#line 3460
  print_source_line();
#line 3461
  fprintfx(stderr, "\n");
  }
#line 3462
  goto switch_break;
  case_5002: /* CIL Label */ 
  {
#line 3464
  fprintfx(stderr, "Compile Fatal ");
#line 3466
  print_error_number(err_no);
#line 3467
  fprintfx(stderr, " Interpreter Internal Error (error in book-keeping) in line %d e-mail: %s\n",
           spf[s].line_counter, "koren@vm.stuba.sk");
#line 3470
  print_source_line();
#line 3471
  fprintfx(stderr, "\n");
  }
#line 3472
  goto switch_break;
  case_5003: /* CIL Label */ 
  {
#line 3474
  fprintfx(stderr, "Compile Fatal ");
#line 3476
  print_error_number(err_no);
#line 3477
  fprintfx(stderr, " Internal Interpreter Error (error in operand type) in line %d e-mail: %s\n",
           spf[s].line_counter, "koren@vm.stuba.sk");
#line 3480
  print_source_line();
#line 3481
  fprintfx(stderr, "\n");
  }
#line 3482
  goto switch_break;
  case_6000: /* CIL Label */ 
#line 3488
  if (warning_yes) {
    {
#line 3490
    print_file_name();
#line 3490
    print_line_number(spf[s].line_counter);
#line 3490
    print_error_number(err_no);
#line 3491
    fprintfx(stderr, "remote function %s already declared\n", text);
    }
  }
#line 3495
  goto end;
  case_6001: /* CIL Label */ 
#line 3497
  if (warning_yes) {
    {
#line 3499
    print_file_name();
#line 3499
    print_line_number(spf[s].line_counter);
#line 3499
    print_error_number(err_no);
#line 3500
    fprintfx(stderr, "`return\' with no value, in function returning non-void\n");
    }
  } else
#line 3497
  if (warning_return_type) {
    {
#line 3499
    print_file_name();
#line 3499
    print_line_number(spf[s].line_counter);
#line 3499
    print_error_number(err_no);
#line 3500
    fprintfx(stderr, "`return\' with no value, in function returning non-void\n");
    }
  }
#line 3503
  goto end;
  case_6002: /* CIL Label */ 
#line 3505
  if (warning_yes) {
    {
#line 3507
    print_file_name();
#line 3507
    print_line_number(spf[s].line_counter);
#line 3507
    print_error_number(err_no);
#line 3508
    fprintfx(stderr, "`return\' with a value, in function returning void\n");
    }
  } else
#line 3505
  if (warning_return_type) {
    {
#line 3507
    print_file_name();
#line 3507
    print_line_number(spf[s].line_counter);
#line 3507
    print_error_number(err_no);
#line 3508
    fprintfx(stderr, "`return\' with a value, in function returning void\n");
    }
  }
#line 3511
  goto end;
  case_6003: /* CIL Label */ 
#line 3513
  if (warning_extra) {
#line 3513
    goto _L;
  } else
#line 3513
  if (warning_unused) {
    _L: /* CIL Label */ 
#line 3515
    if (proc_name_text[proc]) {
      {
#line 3517
      print_file_name();
#line 3517
      print_error_number(err_no);
#line 3518
      fprintfx(stderr, "unused variable `%s\'\n", text);
      }
    } else {
      {
#line 3524
      print_file_name();
#line 3525
      fprintfx(stderr, " In block finishing at line %d:\n", spf[s].line_counter);
#line 3528
      print_file_name();
#line 3528
      print_error_number(err_no);
#line 3529
      fprintfx(stderr, "unused variable `%s\'\n", text);
      }
    }
  }
#line 3534
  goto end;
  case_6004: /* CIL Label */ 
#line 3536
  if (warning_yes) {
    {
#line 3538
    print_file_name();
#line 3538
    print_line_number(error_line_number);
#line 3538
    print_error_number(err_no);
#line 3539
    fprintfx(stderr, "label `%s\' defined but not used\n", text);
    }
  } else
#line 3536
  if (warning_unused) {
    {
#line 3538
    print_file_name();
#line 3538
    print_line_number(error_line_number);
#line 3538
    print_error_number(err_no);
#line 3539
    fprintfx(stderr, "label `%s\' defined but not used\n", text);
    }
  }
#line 3543
  goto end;
  case_6005: /* CIL Label */ 
#line 3545
  if (warning_yes) {
    {
#line 3547
    print_file_name();
#line 3547
    print_error_number(err_no);
#line 3548
    fprintfx(stderr, " `/*\' within comment\n");
    }
  } else
#line 3545
  if (warning_comment) {
    {
#line 3547
    print_file_name();
#line 3547
    print_error_number(err_no);
#line 3548
    fprintfx(stderr, " `/*\' within comment\n");
    }
  }
#line 3552
  goto end;
  case_6006: /* CIL Label */ 
#line 3554
  if (warning_yes) {
#line 3554
    goto _L___0;
  } else
#line 3554
  if (warning_uninitialized) {
    _L___0: /* CIL Label */ 
#line 3556
    if (proc_name_text[proc]) {
      {
#line 3558
      print_file_name();
#line 3558
      print_error_number(err_no);
#line 3559
      fprintfx(stderr, "`%s\' might be used uninitialized in this function\n", text);
      }
    } else {
      {
#line 3565
      print_file_name();
#line 3566
      fprintfx(stderr, " In block finishing at line %d:\n", spf[s].line_counter);
#line 3569
      print_file_name();
#line 3569
      print_error_number(err_no);
#line 3570
      fprintfx(stderr, "`%s\' might be used uninitialized in the block\n", text);
      }
    }
  }
#line 3575
  goto end;
  case_6007: /* CIL Label */ 
#line 3577
  if (warning_extra) {
    {
#line 3579
    print_file_name();
#line 3579
    print_line_number(spf[s].line_counter);
#line 3579
    print_error_number(err_no);
#line 3580
    fprintfx(stderr, "number of locals is greater than the ANSI allows\n");
    }
  }
#line 3583
  goto end;
  case_6008: /* CIL Label */ 
#line 3585
  if (warning_extra) {
    {
#line 3587
    print_file_name();
#line 3587
    print_line_number(spf[s].line_counter);
#line 3587
    print_error_number(err_no);
#line 3588
    fprintfx(stderr, "number of params is greater than the ANSI allows\n");
    }
  }
#line 3591
  goto end;
  case_6009: /* CIL Label */ 
#line 3593
  if (warning_yes) {
#line 3593
    goto _L___1;
  } else
#line 3593
  if (warning_implicit) {
    _L___1: /* CIL Label */ 
    {
#line 3599
    tmp___27 = strlen((char const   *)(line_buf));
#line 3599
    n_tmp_line = (int )tmp___27;
#line 3600
    tmp___28 = malloc((size_t )(n_tmp_line + 1));
#line 3600
    tmp_line = (char *)tmp___28;
    }
#line 3601
    if ((unsigned long )((void *)0) == (unsigned long )tmp_line) {
      {
#line 3603
      perror("");
#line 3604
      abort();
      }
    }
    {
#line 3607
    strcpy((char */* __restrict  */)tmp_line, (char const   */* __restrict  */)(line_buf));
#line 3608
    beg = strrchr((char const   *)tmp_line, '(');
    }
#line 3609
    if ((unsigned long )((void *)0) == (unsigned long )beg) {
#line 3610
      beg = tmp_line;
    } else {
#line 3612
      beg ++;
    }
    {
#line 3613
    tmp___29 = strlen((char const   *)beg);
#line 3613
    n = (int )tmp___29;
    }
#line 3614
    if (44 == (int )*(beg + (n - 1))) {
#line 3615
      *(beg + (n - 1)) = (char )'\000';
    }
    {
#line 3616
    com = strrchr((char const   *)beg, ',');
    }
#line 3617
    if ((unsigned long )((void *)0) != (unsigned long )com) {
#line 3618
      beg = com + 1;
    }
    {
#line 3619
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3619
      if (! ((int )*beg == 32)) {
#line 3619
        if (! ((int )*beg == 9)) {
#line 3619
          goto while_break;
        }
      }
#line 3619
      beg ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3621
    end = strrchr((char const   *)beg, ' ');
#line 3622
    com = strchr((char const   *)beg, ' ');
    }
#line 3623
    if ((unsigned long )end != (unsigned long )com) {
#line 3624
      *end = (char )'\000';
    } else {
#line 3626
      *(tmp_line + (n_tmp_line - 1)) = (char )'\000';
    }
    {
#line 3628
    tmp___30 = strlen((char const   *)beg);
#line 3628
    n = (int )tmp___30;
    }
#line 3629
    if ((int )*(beg + (n - 1)) == 32) {
#line 3630
      *(beg + (n - 1)) = (char )'\000';
    }
    {
#line 3632
    com = strchr((char const   *)beg, ' ');
#line 3634
    print_file_name();
#line 3634
    print_line_number(spf[s].line_counter);
#line 3634
    print_error_number(err_no);
    }
#line 3635
    if ((int )*(beg + 0) == 0) {
      {
#line 3636
      abort();
      }
    }
#line 3637
    if ((unsigned long )((void *)0) == (unsigned long )com) {
      {
#line 3638
      fprintfx(stderr, "anonymous %s declared inside parameter list\n", beg);
      }
    } else {
      {
#line 3641
      fprintfx(stderr, "`%s\' declared inside parameter list\n", beg);
      }
    }
    {
#line 3643
    print_file_name();
#line 3643
    print_line_number(spf[s].line_counter);
#line 3643
    print_error_number(err_no);
#line 3644
    fprintfx(stderr, "its scope is only this definition or declaration,\n");
#line 3646
    print_file_name();
#line 3646
    print_line_number(spf[s].line_counter);
#line 3646
    print_error_number(err_no);
#line 3647
    fprintfx(stderr, "which is probably not what you want.\n");
#line 3648
    free((void *)tmp_line);
    }
  }
#line 3650
  goto end;
  case_6010: /* CIL Label */ 
  {
#line 3652
  print_file_name();
#line 3652
  print_line_number(spf[s].line_counter);
#line 3652
  print_error_number(err_no);
#line 3653
  fprintfx(stderr, "useless keyword or type name in empty declaration\n");
  }
#line 3655
  goto end;
  case_6011: /* CIL Label */ 
  {
#line 3657
  print_file_name();
#line 3657
  print_line_number(spf[s].line_counter);
#line 3657
  print_error_number(err_no);
#line 3658
  fprintfx(stderr, "empty declaration\n");
  }
#line 3659
  goto end;
  case_6012: /* CIL Label */ 
  {
#line 3661
  print_file_name();
#line 3661
  print_line_number(spf[s].line_counter);
#line 3661
  print_error_number(err_no);
  }
#line 3662
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3662
    tmp___32 = "pointer";
  } else {
    {
#line 3662
    tmp___31 = type2string(type_com[set]);
#line 3662
    tmp___32 = (char const   *)tmp___31;
    }
  }
#line 3662
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
#line 3662
    tmp___34 = "pointer";
  } else {
    {
#line 3662
    tmp___33 = type2string(type_com[set - 1]);
#line 3662
    tmp___34 = (char const   *)tmp___33;
    }
  }
  {
#line 3662
  fprintfx(stderr, "assignment makes %s from %s without a cast\n", tmp___34, tmp___32);
  }
#line 3668
  goto end;
  case_6013: /* CIL Label */ 
  {
#line 3670
  print_file_name();
#line 3670
  print_line_number(spf[s].line_counter);
#line 3670
  print_error_number(err_no);
#line 3671
  fprintfx(stderr, "assignment from incompatible pointer type\n");
  }
#line 3673
  goto end;
  case_6014: /* CIL Label */ 
#line 3675
  if (warning_yes) {
#line 3675
    goto _L___2;
  } else
#line 3675
  if (warning_format) {
    _L___2: /* CIL Label */ 
    {
#line 3678
    tmp___35 = __builtin_va_arg(point___0, int );
#line 3678
    buf[0] = tmp___35;
#line 3679
    tmp___36 = __builtin_va_arg(point___0, int );
#line 3679
    buf[1] = tmp___36;
#line 3680
    print_file_name();
#line 3680
    print_line_number(spf[s].line_counter);
#line 3680
    print_error_number(err_no);
#line 3681
    fprintfx(stderr, "use of `%c\' length character with `%c\' type character\n",
             (int )buf[0], (int )buf[1]);
    }
  }
#line 3685
  goto end;
  case_6015: /* CIL Label */ 
#line 3687
  if (warning_yes) {
#line 3687
    goto _L___3;
  } else
#line 3687
  if (warning_format) {
    _L___3: /* CIL Label */ 
    {
#line 3689
    tmp___38 = __builtin_va_arg(point___0, int );
#line 3689
    arg___5 = tmp___38;
#line 3690
    print_file_name();
#line 3690
    print_line_number(spf[s].line_counter);
#line 3690
    print_error_number(err_no);
#line 3691
    fprintfx(stderr, "long long int format, different type arg (arg %d)\n", arg___5);
    }
  }
#line 3695
  goto end;
  case_6016: /* CIL Label */ 
#line 3697
  if (warning_yes) {
#line 3697
    goto _L___4;
  } else
#line 3697
  if (warning_format) {
    _L___4: /* CIL Label */ 
    {
#line 3699
    tmp___40 = __builtin_va_arg(point___0, int );
#line 3699
    arg___6 = tmp___40;
#line 3700
    print_file_name();
#line 3700
    print_line_number(spf[s].line_counter);
#line 3700
    print_error_number(err_no);
#line 3701
    fprintfx(stderr, "long long unsigned int format, different type arg (arg %d)\n",
             arg___6);
    }
  }
#line 3705
  goto end;
  case_6017: /* CIL Label */ 
#line 3707
  if (warning_yes) {
#line 3707
    goto _L___5;
  } else
#line 3707
  if (warning_format) {
    _L___5: /* CIL Label */ 
    {
#line 3709
    tmp___42 = __builtin_va_arg(point___0, struct internal_type *);
#line 3709
    type = tmp___42;
#line 3710
    tmp___44 = __builtin_va_arg(point___0, int );
#line 3710
    arg___7 = tmp___44;
#line 3711
    print_file_name();
#line 3711
    print_line_number(spf[s].line_counter);
#line 3711
    print_error_number(err_no);
#line 3712
    tmp___45 = type2string(type);
#line 3712
    fprintfx(stderr, "%s format, different type arg (arg %d)\n", tmp___45, arg___7);
    }
  }
#line 3716
  goto end;
  case_6018: /* CIL Label */ 
#line 3718
  if (warning_yes) {
    {
#line 3720
    print_file_name();
#line 3720
    print_line_number(spf[s].line_counter);
#line 3720
    print_error_number(err_no);
#line 3721
    fprintfx(stderr, "spurious trailing `%%\' in format\n");
    }
  } else
#line 3718
  if (warning_format) {
    {
#line 3720
    print_file_name();
#line 3720
    print_line_number(spf[s].line_counter);
#line 3720
    print_error_number(err_no);
#line 3721
    fprintfx(stderr, "spurious trailing `%%\' in format\n");
    }
  }
#line 3724
  goto end;
  case_6019: /* CIL Label */ 
#line 3726
  if (warning_yes) {
    {
#line 3728
    print_file_name();
#line 3728
    print_line_number(spf[s].line_counter);
#line 3728
    print_error_number(err_no);
#line 3729
    fprintfx(stderr, "conversion lacks type at end of format\n");
    }
  } else
#line 3726
  if (warning_format) {
    {
#line 3728
    print_file_name();
#line 3728
    print_line_number(spf[s].line_counter);
#line 3728
    print_error_number(err_no);
#line 3729
    fprintfx(stderr, "conversion lacks type at end of format\n");
    }
  }
#line 3732
  goto end;
  case_6020: /* CIL Label */ 
#line 3734
  if (warning_yes) {
    {
#line 3736
    print_file_name();
#line 3736
    print_line_number(spf[s].line_counter);
#line 3736
    print_error_number(err_no);
#line 3737
    fprintfx(stderr, "repeated ` \' flag in format\n");
    }
  } else
#line 3734
  if (warning_format) {
    {
#line 3736
    print_file_name();
#line 3736
    print_line_number(spf[s].line_counter);
#line 3736
    print_error_number(err_no);
#line 3737
    fprintfx(stderr, "repeated ` \' flag in format\n");
    }
  }
#line 3740
  goto end;
  case_6021: /* CIL Label */ 
#line 3742
  if (warning_yes) {
    {
#line 3744
    print_file_name();
#line 3744
    print_line_number(spf[s].line_counter);
#line 3744
    print_error_number(err_no);
#line 3745
    fprintfx(stderr, "too few arguments for format\n");
    }
  } else
#line 3742
  if (warning_format) {
    {
#line 3744
    print_file_name();
#line 3744
    print_line_number(spf[s].line_counter);
#line 3744
    print_error_number(err_no);
#line 3745
    fprintfx(stderr, "too few arguments for format\n");
    }
  }
#line 3748
  goto end;
  case_6022: /* CIL Label */ 
#line 3750
  if (warning_yes) {
    {
#line 3752
    print_file_name();
#line 3752
    print_line_number(spf[s].line_counter);
#line 3752
    print_error_number(err_no);
#line 3753
    fprintfx(stderr, "too many arguments for format\n");
    }
  } else
#line 3750
  if (warning_format) {
    {
#line 3752
    print_file_name();
#line 3752
    print_line_number(spf[s].line_counter);
#line 3752
    print_error_number(err_no);
#line 3753
    fprintfx(stderr, "too many arguments for format\n");
    }
  }
#line 3755
  goto end;
  case_6023: /* CIL Label */ 
#line 3757
  if (warning_yes) {
    {
#line 3759
    print_file_name();
#line 3759
    print_line_number(spf[s].line_counter);
#line 3759
    print_error_number(err_no);
#line 3760
    fprintfx(stderr, "embedded `\\0\' in format\n");
    }
  } else
#line 3757
  if (warning_format) {
    {
#line 3759
    print_file_name();
#line 3759
    print_line_number(spf[s].line_counter);
#line 3759
    print_error_number(err_no);
#line 3760
    fprintfx(stderr, "embedded `\\0\' in format\n");
    }
  }
#line 3762
  goto end;
  case_6024: /* CIL Label */ 
#line 3764
  if (warning_yes) {
    {
#line 3766
    tmp___47 = __builtin_va_arg(point___0, struct internal_type *);
#line 3766
    type1 = tmp___47;
#line 3766
    tmp___49 = __builtin_va_arg(point___0, struct internal_type *);
#line 3766
    type2 = tmp___49;
#line 3769
    print_file_name();
#line 3769
    print_line_number(spf[s].line_counter);
#line 3769
    print_error_number(err_no);
#line 3770
    tmp___50 = type2string(type2);
#line 3770
    tmp___51 = type2string(type1);
#line 3770
    fprintfx(stderr, "comparison between %s and %s\n", tmp___51, tmp___50);
    }
  }
#line 3774
  goto end;
  case_6025: /* CIL Label */ 
  {
#line 3777
  tmp___53 = __builtin_va_arg(point___0, char *);
#line 3777
  type___0 = tmp___53;
#line 3778
  print_file_name();
#line 3778
  print_line_number(spf[s].line_counter);
#line 3778
  print_error_number(err_no);
#line 3779
  fprintfx(stderr, "duplicate `%s\'\n", type___0);
  }
#line 3781
  goto end;
  case_6026: /* CIL Label */ 
  {
#line 3783
  print_file_name();
#line 3783
  print_line_number(spf[s].line_counter);
#line 3783
  print_error_number(err_no);
#line 3784
  fprintfx(stderr, "overflow in implicit constant conversion\n");
  }
#line 3785
  goto end;
  case_6027: /* CIL Label */ 
  {
#line 3787
  print_file_name();
#line 3787
  print_line_number(spf[s].line_counter);
#line 3787
  print_error_number(err_no);
#line 3788
  fprintfx(stderr, "statement with no effect\n");
  }
#line 3789
  goto end;
  case_6028: /* CIL Label */ 
#line 3791
  if (warning_yes) {
    {
#line 3791
    tmp___54 = strcmp((char const   *)text, "main");
    }
#line 3791
    if (tmp___54) {
      {
#line 3793
      print_file_name();
#line 3793
      print_line_number(spf[s].line_counter);
#line 3793
      print_error_number(err_no);
#line 3794
      fprintfx(stderr, "control reaches end of non-void function\n");
      }
    }
  }
#line 3797
  goto end;
  case_6029: /* CIL Label */ 
#line 3799
  if (warning_yes) {
    {
#line 3801
    print_file_name();
#line 3801
    print_line_number(spf[s].line_counter);
#line 3801
    print_error_number(err_no);
#line 3802
    fprintfx(stderr, "left-hand operand of comma expression has no effect\n");
    }
  }
#line 3805
  goto end;
  case_6030: /* CIL Label */ 
#line 3807
  if (warning_yes) {
    {
#line 3809
    tmp___56 = __builtin_va_arg(point___0, char *);
#line 3809
    name___6 = tmp___56;
#line 3810
    print_file_name();
#line 3810
    print_line_number(spf[s].line_counter);
#line 3810
    print_error_number(err_no);
#line 3811
    fprintfx(stderr, "missing braces around initializer for `%s\'\n", name___6);
    }
  }
#line 3814
  goto end;
  case_6031: /* CIL Label */ 
#line 3816
  if (warning_yes) {
#line 3816
    goto _L___6;
  } else
#line 3816
  if (warning_format) {
    _L___6: /* CIL Label */ 
    {
#line 3818
    tmp___58 = __builtin_va_arg(point___0, struct internal_type *);
#line 3818
    type___1 = tmp___58;
#line 3819
    tmp___60 = __builtin_va_arg(point___0, int );
#line 3819
    arg___8 = tmp___60;
#line 3820
    print_file_name();
#line 3820
    print_line_number(spf[s].line_counter);
#line 3820
    print_error_number(err_no);
#line 3821
    tmp___61 = type2string(type___1);
#line 3821
    fprintfx(stderr, "%s format, pointer arg (arg %d)\n", tmp___61, arg___8);
    }
  }
#line 3825
  goto end;
  case_6032: /* CIL Label */ 
#line 3827
  if (warning_yes) {
    {
#line 3830
    no_trig ++;
#line 3831
    print_file_name();
#line 3831
    print_line_number(spf[s].line_counter);
#line 3831
    print_error_number(err_no);
#line 3832
    fprintfx(stderr, "trigraph encountered\n");
    }
  } else
#line 3827
  if (warning_trigraphs) {
    {
#line 3830
    no_trig ++;
#line 3831
    print_file_name();
#line 3831
    print_line_number(spf[s].line_counter);
#line 3831
    print_error_number(err_no);
#line 3832
    fprintfx(stderr, "trigraph encountered\n");
    }
  }
#line 3835
  goto end;
  case_6033: /* CIL Label */ 
  {
#line 3838
  tmp___63 = __builtin_va_arg(point___0, char *);
#line 3838
  name___7 = tmp___63;
#line 3839
  print_file_name();
#line 3839
  print_line_number(spf[s].line_counter);
#line 3839
  print_error_number(err_no);
#line 3840
  fprintfx(stderr, "unknown escape sequence `\\%s\'\n", name___7);
  }
#line 3843
  goto end;
  case_6034: /* CIL Label */ 
#line 3845
  if (warning_aggregate_return) {
    {
#line 3847
    print_file_name();
#line 3847
    print_line_number(spf[s].line_counter);
#line 3847
    print_error_number(err_no);
#line 3848
    fprintfx(stderr, "function returns an aggregate\n");
    }
  }
#line 3851
  goto end;
  case_6035: /* CIL Label */ 
#line 3853
  if (warning_aggregate_return) {
    {
#line 3855
    print_file_name();
#line 3855
    print_line_number(spf[s].line_counter);
#line 3855
    print_error_number(err_no);
#line 3856
    fprintfx(stderr, "function call has aggregate value\n");
    }
  }
#line 3859
  goto end;
  case_7000: /* CIL Label */ 
  {
#line 3865
  print_error_number(err_no);
#line 3866
  fprintfx(stderr, "in run-string and/or in `clif.ini\' file\n");
  }
#line 3868
  goto switch_break;
  case_7001: /* CIL Label */ 
  {
#line 3870
  print_error_number(err_no);
#line 3871
  fprintfx(stderr, "interpreter: can\'t open file %s\n", spf[s].name);
  }
#line 3874
  goto switch_break;
  case_7002: /* CIL Label */ 
  {
#line 3876
  print_error_number(err_no);
#line 3877
  fprintfx(stderr, "`-fcall-by-value\' and `-fcall-by-reference\' are conflicting options. `-fcall-by-reference\' ignored.\n");
  }
#line 3879
  goto switch_break;
  case_7003: /* CIL Label */ 
  {
#line 3881
  print_file_name();
#line 3881
  print_line_number(spf[s].line_counter);
#line 3881
  print_error_number(err_no);
#line 3882
  fprintfx(stderr, "`-fhandle-main\' option and syntax on this line are conflicting.\n");
  }
#line 3884
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 3887
  fprintfx(stderr, "Fatal error invalid error number (%d) e-mail: %s\n", err_no, "koren@vm.stuba.sk");
  }
#line 3890
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3895
  no_compile_only = 0;
  end: 
#line 3897
  if (error_count > 10) {
    {
#line 3899
    fprintfx(stderr, "too many errors giving up\n");
#line 3901
    exit(1);
    }
  }
  {
#line 3903
  __builtin_va_end(point___0);
  }
#line 3904
  return;
}
}
#line 3910 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static char *function_name  ;
#line 3907 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static void print_file_name(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 3912
  fprintfx(stderr, "%s:", spf[s].name);
  }
#line 3913
  if (proc) {
#line 3913
    if (! func_def_f) {
#line 3913
      if ((unsigned long )function_name != (unsigned long )proc_name_text[proc]) {
#line 3913
        if ((unsigned long )proc_name[proc] == (unsigned long )((void *)0)) {
          {
#line 3917
          fprintfx(stderr, " In function `%s\':\n", proc_name_text[proc]);
#line 3919
          function_name = proc_name_text[proc];
#line 3920
          fprintfx(stderr, "%s:", spf[s].name);
          }
        } else {
#line 3913
          goto _L___1;
        }
      } else {
#line 3913
        goto _L___1;
      }
    } else {
#line 3913
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3922
  if (proc > 1) {
#line 3922
    if ((unsigned long )function_name != (unsigned long )proc_name_text[1]) {
#line 3922
      if ((unsigned long )proc_name[1] == (unsigned long )((void *)0)) {
        {
#line 3926
        fprintfx(stderr, " In function `%s\':\n", proc_name_text[1]);
#line 3928
        function_name = proc_name_text[1];
#line 3929
        fprintfx(stderr, "%s:", spf[s].name);
        }
      }
    }
  }
#line 3931
  return;
}
}
#line 3934 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static void print_source_line(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 3937
  if (source_line_number != spf[s].line_counter) {
    {
#line 3939
    fprintfx(stderr, "\nSource line: %s\n", line_buf);
#line 3940
    fprintfx(stderr, "            %*s^", char_counter, " ");
#line 3941
    fprintfx(stderr, "\n");
#line 3942
    source_line_number = spf[s].line_counter;
    }
  }
#line 3944
  return;
}
}
#line 3947 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static void print_error_number(int err_no ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 3957
  if (6000 <= err_no) {
#line 3957
    if (7000 > err_no) {
      {
#line 3958
      fprintfx(stderr, " warning: ", err_no);
      }
    } else {
      {
#line 3960
      fprintfx(stderr, " ");
      }
    }
  } else {
    {
#line 3960
    fprintfx(stderr, " ");
    }
  }
#line 3962
  return;
}
}
#line 3965 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static void print_line_number(int line_no ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 3972
  fprintfx(stderr, "%d:", line_no);
  }
#line 3974
  return;
}
}
#line 3977 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static char *type2string(struct internal_type *type ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 3981
  if (1028U == (unsigned int )type->attribute.function_class) {
#line 3982
    return ((char *)"pointer");
  } else
#line 3981
  if (1025U == (unsigned int )type->attribute.function_class) {
#line 3982
    return ((char *)"pointer");
  }
  {
#line 3987
  if ((unsigned int )type->attribute.arit_class == 8U) {
#line 3987
    goto case_8;
  }
#line 3987
  if ((unsigned int )type->attribute.arit_class == 258U) {
#line 3987
    goto case_8;
  }
#line 3989
  if ((unsigned int )type->attribute.arit_class == 64U) {
#line 3989
    goto case_64;
  }
#line 3991
  if ((unsigned int )type->attribute.arit_class == 32U) {
#line 3991
    goto case_32;
  }
#line 3993
  if ((unsigned int )type->attribute.arit_class == 2U) {
#line 3993
    goto case_2;
  }
#line 3995
  if ((unsigned int )type->attribute.arit_class == 1U) {
#line 3995
    goto case_1;
  }
#line 3997
  goto switch_default;
  case_8: /* CIL Label */ 
  case_258: /* CIL Label */ 
#line 3988
  return ((char *)"integer");
  case_64: /* CIL Label */ 
#line 3990
  return ((char *)"double");
  case_32: /* CIL Label */ 
#line 3992
  return ((char *)"float");
  case_2: /* CIL Label */ 
#line 3994
  return ((char *)"char");
  case_1: /* CIL Label */ 
#line 3996
  return ((char *)"void");
  switch_default: /* CIL Label */ 
  {
#line 3998
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c", 3998);
#line 3999
  error_message(5000);
#line 4000
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 4009 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int type_transform(enum intern_arit_class type , enum intern_func_class typec , int flag___0 ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 4015
  if (flag___0) {
    {
#line 4023
    if ((unsigned int )typec == 1031U) {
#line 4023
      goto case_1031;
    }
#line 4023
    if ((unsigned int )typec == 1025U) {
#line 4023
      goto case_1031;
    }
#line 4023
    if ((unsigned int )typec == 1024U) {
#line 4023
      goto case_1031;
    }
#line 4023
    if ((unsigned int )typec == 2048U) {
#line 4023
      goto case_1031;
    }
#line 4023
    if ((unsigned int )typec == 2049U) {
#line 4023
      goto case_1031;
    }
#line 4077
    goto switch_default___0;
    case_1031: /* CIL Label */ 
    case_1025: /* CIL Label */ 
    case_1024: /* CIL Label */ 
    case_2048: /* CIL Label */ 
    case_2049: /* CIL Label */ 
    {
#line 4026
    if ((unsigned int )type == 130U) {
#line 4026
      goto case_130;
    }
#line 4028
    if ((unsigned int )type == 258U) {
#line 4028
      goto case_258;
    }
#line 4030
    if ((unsigned int )type == 2U) {
#line 4030
      goto case_2;
    }
#line 4033
    if ((unsigned int )type == 136U) {
#line 4033
      goto case_136;
    }
#line 4033
    if ((unsigned int )type == 8U) {
#line 4033
      goto case_136;
    }
#line 4035
    if ((unsigned int )type == 264U) {
#line 4035
      goto case_264;
    }
#line 4038
    if ((unsigned int )type == 152U) {
#line 4038
      goto case_152;
    }
#line 4038
    if ((unsigned int )type == 24U) {
#line 4038
      goto case_152;
    }
#line 4040
    if ((unsigned int )type == 280U) {
#line 4040
      goto case_280;
    }
#line 4043
    if ((unsigned int )type == 140U) {
#line 4043
      goto case_140;
    }
#line 4043
    if ((unsigned int )type == 12U) {
#line 4043
      goto case_140;
    }
#line 4045
    if ((unsigned int )type == 268U) {
#line 4045
      goto case_268;
    }
#line 4047
    if ((unsigned int )type == 64U) {
#line 4047
      goto case_64;
    }
#line 4049
    if ((unsigned int )type == 80U) {
#line 4049
      goto case_80;
    }
#line 4051
    if ((unsigned int )type == 32U) {
#line 4051
      goto case_32;
    }
#line 4053
    goto switch_default;
    case_130: /* CIL Label */ 
#line 4027
    return (1290);
    case_258: /* CIL Label */ 
#line 4029
    return (1291);
    case_2: /* CIL Label */ 
#line 4031
    return (1289);
    case_136: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 4034
    return (1280);
    case_264: /* CIL Label */ 
#line 4036
    return (1281);
    case_152: /* CIL Label */ 
    case_24: /* CIL Label */ 
#line 4039
    return (1282);
    case_280: /* CIL Label */ 
#line 4041
    return (1283);
    case_140: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 4044
    return (1284);
    case_268: /* CIL Label */ 
#line 4046
    return (1285);
    case_64: /* CIL Label */ 
#line 4048
    return (1286);
    case_80: /* CIL Label */ 
#line 4050
    return (1287);
    case_32: /* CIL Label */ 
#line 4052
    return (1288);
    switch_default: /* CIL Label */ 
    {
#line 4054
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             4054);
#line 4055
    error_message(5000);
#line 4056
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 4058
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 4078
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             4078);
#line 4079
    error_message(5000);
#line 4080
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 4091
    if ((unsigned int )typec == 1024U) {
#line 4091
      goto case_1024___0;
    }
#line 4091
    if ((unsigned int )typec == 1028U) {
#line 4091
      goto case_1024___0;
    }
#line 4091
    if ((unsigned int )typec == 1031U) {
#line 4091
      goto case_1024___0;
    }
#line 4091
    if ((unsigned int )typec == 2048U) {
#line 4091
      goto case_1024___0;
    }
#line 4091
    if ((unsigned int )typec == 2049U) {
#line 4091
      goto case_1024___0;
    }
#line 4127
    if ((unsigned int )typec == 1025U) {
#line 4127
      goto case_1025___0;
    }
#line 4143
    goto switch_default___3;
    case_1024___0: /* CIL Label */ 
    case_1028: /* CIL Label */ 
    case_1031___0: /* CIL Label */ 
    case_2048___0: /* CIL Label */ 
    case_2049___0: /* CIL Label */ 
    {
#line 4094
    if ((unsigned int )type == 130U) {
#line 4094
      goto case_130___0;
    }
#line 4096
    if ((unsigned int )type == 258U) {
#line 4096
      goto case_258___0;
    }
#line 4098
    if ((unsigned int )type == 2U) {
#line 4098
      goto case_2___0;
    }
#line 4101
    if ((unsigned int )type == 136U) {
#line 4101
      goto case_136___0;
    }
#line 4101
    if ((unsigned int )type == 8U) {
#line 4101
      goto case_136___0;
    }
#line 4103
    if ((unsigned int )type == 264U) {
#line 4103
      goto case_264___0;
    }
#line 4106
    if ((unsigned int )type == 152U) {
#line 4106
      goto case_152___0;
    }
#line 4106
    if ((unsigned int )type == 24U) {
#line 4106
      goto case_152___0;
    }
#line 4108
    if ((unsigned int )type == 280U) {
#line 4108
      goto case_280___0;
    }
#line 4111
    if ((unsigned int )type == 140U) {
#line 4111
      goto case_140___0;
    }
#line 4111
    if ((unsigned int )type == 12U) {
#line 4111
      goto case_140___0;
    }
#line 4113
    if ((unsigned int )type == 268U) {
#line 4113
      goto case_268___0;
    }
#line 4115
    if ((unsigned int )type == 64U) {
#line 4115
      goto case_64___0;
    }
#line 4117
    if ((unsigned int )type == 80U) {
#line 4117
      goto case_80___0;
    }
#line 4119
    if ((unsigned int )type == 32U) {
#line 4119
      goto case_32___0;
    }
#line 4121
    goto switch_default___1;
    case_130___0: /* CIL Label */ 
#line 4095
    return (1290);
    case_258___0: /* CIL Label */ 
#line 4097
    return (1291);
    case_2___0: /* CIL Label */ 
#line 4099
    return (1289);
    case_136___0: /* CIL Label */ 
    case_8___0: /* CIL Label */ 
#line 4102
    return (1280);
    case_264___0: /* CIL Label */ 
#line 4104
    return (1281);
    case_152___0: /* CIL Label */ 
    case_24___0: /* CIL Label */ 
#line 4107
    return (1282);
    case_280___0: /* CIL Label */ 
#line 4109
    return (1283);
    case_140___0: /* CIL Label */ 
    case_12___0: /* CIL Label */ 
#line 4112
    return (1284);
    case_268___0: /* CIL Label */ 
#line 4114
    return (1285);
    case_64___0: /* CIL Label */ 
#line 4116
    return (1286);
    case_80___0: /* CIL Label */ 
#line 4118
    return (1287);
    case_32___0: /* CIL Label */ 
#line 4120
    return (1288);
    switch_default___1: /* CIL Label */ 
    {
#line 4122
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             4122);
#line 4123
    error_message(5000);
#line 4124
    abort();
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 4126
    goto switch_break___1;
    case_1025___0: /* CIL Label */ 
    {
#line 4130
    if ((unsigned int )type == 2U) {
#line 4130
      goto case_2___1;
    }
#line 4132
    if ((unsigned int )type == 8U) {
#line 4132
      goto case_8___1;
    }
#line 4134
    if ((unsigned int )type == 64U) {
#line 4134
      goto case_64___1;
    }
#line 4136
    if ((unsigned int )type == 32U) {
#line 4136
      goto case_32___1;
    }
#line 4138
    goto switch_default___2;
    case_2___1: /* CIL Label */ 
#line 4131
    return (1539);
    case_8___1: /* CIL Label */ 
#line 4133
    return (1536);
    case_64___1: /* CIL Label */ 
#line 4135
    return (1537);
    case_32___1: /* CIL Label */ 
#line 4137
    return (1538);
    switch_default___2: /* CIL Label */ 
    {
#line 4139
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             4139);
#line 4140
    error_message(5000);
#line 4141
    abort();
    }
    switch_break___3: /* CIL Label */ ;
    }
    switch_default___3: /* CIL Label */ 
    {
#line 4144
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             4144);
#line 4145
    error_message(5000);
#line 4146
    abort();
    }
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 4149
  return (-1);
}
}
#line 4162 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int add_to_spec_list(void) 
{ 
  struct internal_type *tmp_l ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 4167
  if ((unsigned long )((void *)0) == (unsigned long )l_type_spec) {
    {
#line 4169
    l_type_spec = copy_type(typeh[type_spec_count]);
    }
#line 4171
    if (1025U == (unsigned int )(typeh[type_spec_count])->attribute.function_class) {
      {
#line 4171
      tmp___0 = add_subs_to_spec_list(& l_type_spec);
      }
#line 4171
      if (-1 == tmp___0) {
        {
#line 4171
        tmp___1 = add_subs_to_spec_list(& typeh[type_spec_count]);
        }
#line 4171
        if (-1 == tmp___1) {
#line 4174
          return (-1);
        }
      }
    }
  } else {
#line 4178
    tmp_l = l_type_spec;
    {
#line 4179
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4179
      if (! ((unsigned long )((void *)0) != (unsigned long )tmp_l->arity)) {
#line 4179
        goto while_break;
      }
#line 4180
      tmp_l = tmp_l->arity;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4181
    tmp_l->arity = copy_type(typeh[type_spec_count]);
    }
#line 4183
    if (1025U == (unsigned int )(typeh[type_spec_count])->attribute.function_class) {
      {
#line 4183
      tmp___2 = add_subs_to_spec_list(& tmp_l->arity);
      }
#line 4183
      if (-1 == tmp___2) {
        {
#line 4183
        tmp___3 = add_subs_to_spec_list(& typeh[type_spec_count]);
        }
#line 4183
        if (-1 == tmp___3) {
#line 4186
          return (-1);
        }
      }
    }
  }
#line 4188
  return (0);
}
}
#line 4193 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int add_to_ident_list(void) 
{ 
  struct ident_list_str *tmp_l ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 4198
  if ((unsigned long )((void *)0) == (unsigned long )ident_list) {
    {
#line 4200
    tmp___0 = allocate((unsigned int )sizeof(struct ident_list_str ), 0U);
#line 4200
    ident_list = (struct ident_list_str *)tmp___0;
#line 4202
    ident_list->ident = text;
#line 4203
    ident_list->next = (struct ident_list_str *)((void *)0);
    }
  } else {
#line 4207
    tmp_l = ident_list;
    {
#line 4208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4208
      if (! ((unsigned long )((void *)0) != (unsigned long )tmp_l->next)) {
#line 4208
        goto while_break;
      }
#line 4209
      tmp_l = tmp_l->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4210
    tmp___1 = allocate((unsigned int )sizeof(struct ident_list_str ), 0U);
#line 4210
    tmp_l->next = (struct ident_list_str *)tmp___1;
#line 4212
    (tmp_l->next)->ident = text;
#line 4213
    (tmp_l->next)->next = (struct ident_list_str *)((void *)0);
    }
  }
#line 4215
  return (0);
}
}
#line 4223 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int compare2trees(struct internal_type *table , struct internal_type *def ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4236
  if ((unsigned int )table->attribute.function_class == 2048U) {
#line 4236
    if ((unsigned int )def->attribute.function_class == 2048U) {
#line 4239
      if ((unsigned long )table->input == (unsigned long )((void *)0)) {
#line 4239
        if ((unsigned long )def->input != (unsigned long )((void *)0)) {
          {
#line 4240
          table->input = copy_type(def->input);
          }
        } else {
#line 4239
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 4241
      if ((unsigned long )table->input != (unsigned long )((void *)0)) {
#line 4241
        if ((unsigned long )def->input == (unsigned long )((void *)0)) {
          {
#line 4242
          def->input = copy_type(table->input);
          }
        }
      }
    }
  }
#line 4246
  if ((unsigned long )((void *)0) != (unsigned long )table->input) {
#line 4246
    if ((unsigned long )((void *)0) == (unsigned long )def->input) {
      {
#line 4249
      error_message(2003);
      }
#line 4250
      return (-1);
    } else {
#line 4246
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 4246
  if ((unsigned long )((void *)0) == (unsigned long )table->input) {
#line 4246
    if ((unsigned long )((void *)0) != (unsigned long )def->input) {
      {
#line 4249
      error_message(2003);
      }
#line 4250
      return (-1);
    }
  }
#line 4252
  if ((unsigned long )((void *)0) != (unsigned long )table->output) {
#line 4252
    if ((unsigned long )((void *)0) == (unsigned long )def->output) {
      {
#line 4255
      error_message(2003);
      }
#line 4256
      return (-1);
    } else {
#line 4252
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 4252
  if ((unsigned long )((void *)0) == (unsigned long )table->output) {
#line 4252
    if ((unsigned long )((void *)0) != (unsigned long )def->output) {
      {
#line 4255
      error_message(2003);
      }
#line 4256
      return (-1);
    }
  }
#line 4258
  if ((unsigned long )((void *)0) != (unsigned long )table->arity) {
#line 4258
    if ((unsigned long )((void *)0) == (unsigned long )def->arity) {
#line 4258
      goto _L___4;
    } else {
#line 4258
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 4258
  if ((unsigned long )((void *)0) == (unsigned long )table->arity) {
#line 4258
    if ((unsigned long )((void *)0) != (unsigned long )def->arity) {
      _L___4: /* CIL Label */ 
#line 4264
      if ((unsigned long )((void *)0) != (unsigned long )table->attribute.domain) {
#line 4264
        if ((unsigned long )((void *)0) == (unsigned long )def->attribute.domain) {
          {
#line 4269
          error_message(2007);
          }
#line 4270
          return (-1);
        } else {
#line 4264
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 4264
      if ((unsigned long )((void *)0) == (unsigned long )table->attribute.domain) {
#line 4264
        if ((unsigned long )((void *)0) != (unsigned long )def->attribute.domain) {
          {
#line 4269
          error_message(2007);
          }
#line 4270
          return (-1);
        } else {
#line 4264
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 4272
      if ((unsigned long )((void *)0) == (unsigned long )table->attribute.domain) {
#line 4272
        if ((unsigned long )((void *)0) == (unsigned long )def->attribute.domain) {
          {
#line 4275
          error_message(2004);
          }
#line 4276
          return (-1);
        } else {
          {
#line 4280
          error_message(2007);
          }
#line 4281
          return (-1);
        }
      } else {
        {
#line 4280
        error_message(2007);
        }
#line 4281
        return (-1);
      }
    }
  }
#line 4287
  if ((unsigned long )((void *)0) != (unsigned long )table->attribute.domain) {
#line 4287
    if ((unsigned long )((void *)0) == (unsigned long )def->attribute.domain) {
      {
#line 4292
      error_message(2007);
      }
#line 4293
      return (-1);
    } else {
#line 4287
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 4287
  if ((unsigned long )((void *)0) == (unsigned long )table->attribute.domain) {
#line 4287
    if ((unsigned long )((void *)0) != (unsigned long )def->attribute.domain) {
      {
#line 4292
      error_message(2007);
      }
#line 4293
      return (-1);
    }
  }
#line 4295
  if ((unsigned long )((void *)0) != (unsigned long )table->attribute.domain) {
#line 4295
    if ((unsigned long )((void *)0) != (unsigned long )def->attribute.domain) {
#line 4298
      if (-2 == ((struct range *)table->attribute.domain)->upper) {
#line 4300
        ((struct range *)table->attribute.domain)->upper = ((struct range *)def->attribute.domain)->upper;
      }
#line 4307
      if (-2 != ((struct range *)def->attribute.domain)->upper) {
#line 4307
        if (((struct range *)table->attribute.domain)->lower != ((struct range *)def->attribute.domain)->lower) {
          {
#line 4314
          error_message(2006);
          }
#line 4315
          return (-1);
        } else
#line 4307
        if (((struct range *)table->attribute.domain)->upper != ((struct range *)def->attribute.domain)->upper) {
          {
#line 4314
          error_message(2006);
          }
#line 4315
          return (-1);
        }
      }
    }
  }
#line 4319
  if ((unsigned int )table->attribute.function_class != (unsigned int )def->attribute.function_class) {
    {
#line 4325
    error_message(2003);
    }
#line 4326
    return (-1);
  } else
#line 4319
  if (table->attribute.export_type != def->attribute.export_type) {
    {
#line 4325
    error_message(2003);
    }
#line 4326
    return (-1);
  } else
#line 4319
  if (table->attribute.memory_size != def->attribute.memory_size) {
    {
#line 4325
    error_message(2003);
    }
#line 4326
    return (-1);
  }
#line 4330
  if ((unsigned int )table->attribute.arit_class != (unsigned int )def->attribute.arit_class) {
    {
#line 4332
    error_message(2003);
    }
#line 4333
    return (-1);
  }
#line 4336
  if ((unsigned long )((void *)0) != (unsigned long )table->input) {
#line 4336
    if ((unsigned long )((void *)0) != (unsigned long )def->input) {
      {
#line 4336
      tmp___0 = compare2trees(table->input, def->input);
      }
#line 4336
      if (-1 == tmp___0) {
#line 4339
        return (-1);
      }
    }
  }
#line 4340
  if ((unsigned long )((void *)0) != (unsigned long )table->arity) {
#line 4340
    if ((unsigned long )((void *)0) != (unsigned long )def->arity) {
      {
#line 4340
      tmp___1 = compare2trees(table->arity, def->arity);
      }
#line 4340
      if (-1 == tmp___1) {
#line 4343
        return (-1);
      }
    }
  }
#line 4344
  if ((unsigned long )((void *)0) != (unsigned long )table->output) {
#line 4344
    if ((unsigned long )((void *)0) != (unsigned long )def->output) {
      {
#line 4344
      tmp___2 = compare2trees(table->output, def->output);
      }
#line 4344
      if (-1 == tmp___2) {
#line 4347
        return (-1);
      }
    }
  }
#line 4352
  return (0);
}
}
#line 4357 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static struct internal_type *copy_type(struct internal_type *type ) 
{ 
  struct internal_type *new_type ;
  char *tmp___0 ;

  {
#line 4363
  if ((unsigned long )((void *)0) == (unsigned long )type) {
#line 4364
    return ((struct internal_type *)((void *)0));
  }
  {
#line 4366
  tmp___0 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 4366
  new_type = (struct internal_type *)tmp___0;
#line 4368
  new_type->input = type->input;
#line 4369
  new_type->arity = type->arity;
#line 4370
  new_type->field_name = type->field_name;
#line 4371
  new_type->offset = type->offset;
#line 4372
  new_type->attribute.function_class = type->attribute.function_class;
#line 4373
  new_type->attribute.export_type = type->attribute.export_type;
#line 4374
  new_type->attribute.type_qualifier = type->attribute.type_qualifier;
#line 4375
  new_type->attribute.storage_class_specifier = type->attribute.storage_class_specifier;
#line 4377
  new_type->attribute.arit_class = type->attribute.arit_class;
#line 4378
  new_type->attribute.memory_size = type->attribute.memory_size;
#line 4379
  new_type->attribute.domain = type->attribute.domain;
#line 4380
  new_type->output = type->output;
  }
#line 4382
  return (new_type);
}
}
#line 4390 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int add_subs_to_spec_list(struct internal_type **type ) 
{ 
  int count_tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct internal_type *walk ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 4396
  count_tmp = poc;
#line 4398
  tmp___0 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 4398
  (*type)->input = (struct internal_type *)tmp___0;
#line 4400
  ((*type)->input)->attribute.arit_class = (enum intern_arit_class )8;
#line 4401
  tmp___1 = allocate((unsigned int )sizeof(struct range ), 0U);
#line 4401
  ((*type)->input)->attribute.domain = tmp___1;
#line 4403
  ((struct range *)((*type)->input)->attribute.domain)->lower = 0;
#line 4404
  tmp___2 = count_tmp;
#line 4404
  count_tmp --;
#line 4404
  ((struct range *)((*type)->input)->attribute.domain)->upper = dim[tmp___2];
  }
#line 4406
  if (-1 != dim[count_tmp]) {
    {
#line 4410
    tmp___3 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 4410
    walk = (struct internal_type *)tmp___3;
#line 4412
    walk->attribute.arit_class = (enum intern_arit_class )8;
#line 4413
    tmp___4 = allocate((unsigned int )sizeof(struct range ), 0U);
#line 4413
    walk->attribute.domain = tmp___4;
#line 4415
    ((struct range *)walk->attribute.domain)->lower = 0;
#line 4416
    tmp___5 = count_tmp;
#line 4416
    count_tmp --;
#line 4416
    ((struct range *)walk->attribute.domain)->upper = dim[tmp___5];
#line 4417
    ((*type)->input)->arity = walk;
    }
    {
#line 4418
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4418
      if (! (-1 != dim[count_tmp])) {
#line 4418
        goto while_break;
      }
      {
#line 4420
      tmp___6 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 4420
      walk->arity = (struct internal_type *)tmp___6;
#line 4422
      walk = walk->arity;
#line 4423
      walk->attribute.arit_class = (enum intern_arit_class )8;
#line 4424
      tmp___7 = allocate((unsigned int )sizeof(struct range ), 0U);
#line 4424
      walk->attribute.domain = tmp___7;
#line 4426
      ((struct range *)walk->attribute.domain)->lower = 0;
#line 4427
      tmp___8 = count_tmp;
#line 4427
      count_tmp --;
#line 4427
      ((struct range *)walk->attribute.domain)->upper = dim[tmp___8];
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 4431
  return (0);
}
}
#line 4435 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void clear_internal_type(struct internal_type *def ) 
{ 
  struct internal_type *cyclic_pointer ;

  {
#line 4441
  if (1028U == (unsigned int )def->attribute.function_class) {
    {
#line 4441
    cyclic_pointer = cyclic_def(def, def->output);
    }
#line 4441
    if ((unsigned long )((void *)0) != (unsigned long )cyclic_pointer) {
#line 4443
      cyclic_pointer->output = (struct internal_type *)((void *)0);
    }
  }
#line 4444
  if ((unsigned long )((void *)0) != (unsigned long )def->input) {
    {
#line 4445
    clear_internal_type(def->input);
    }
  }
#line 4446
  if ((unsigned long )((void *)0) != (unsigned long )def->arity) {
    {
#line 4447
    clear_internal_type(def->arity);
    }
  }
#line 4448
  if ((unsigned long )((void *)0) != (unsigned long )def->output) {
    {
#line 4449
    clear_internal_type(def->output);
    }
  }
#line 4450
  if ((unsigned long )((void *)0) != (unsigned long )def->attribute.domain) {
#line 4455
    return;
  }
#line 4460
  return;
}
}
#line 4463 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void search_duplicate_labels(void) 
{ 
  int counter ;
  int i ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 4466
  counter = 1;
#line 4468
  if (294 == fixp->switch1.major) {
#line 4468
    if ((unsigned long )((void *)0) != (unsigned long )fixp->switch1.next) {
#line 4470
      tmp_c = fixp->switch1.next;
      {
#line 4471
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4471
        if (! ((unsigned long )((void *)0) != (unsigned long )tmp_c->next)) {
#line 4471
          goto while_break;
        }
#line 4473
        tmp_c = tmp_c->next;
#line 4474
        tmp_m = fixp->switch1.next;
#line 4475
        counter ++;
#line 4478
        i = 1;
        {
#line 4478
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4478
          if (! (i < counter)) {
#line 4478
            goto while_break___0;
          }
#line 4480
          if (tmp_m->constant == tmp_c->constant) {
            {
#line 4482
            error_message(1015);
            }
#line 4483
            return;
          }
#line 4485
          tmp_m = tmp_m->next;
#line 4478
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 4491
      fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
               4491);
#line 4492
      error_message(5002);
#line 4493
      abort();
      }
    }
  } else {
    {
#line 4491
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             4491);
#line 4492
    error_message(5002);
#line 4493
    abort();
    }
  }
#line 4495
  return;
}
}
#line 4498 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int add_constant_to_list(int int_const ) 
{ 
  union fix *fixp_arch ;
  struct list_const1 *ptr ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 4507
  fixp_arch = fixp;
  {
#line 4509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4509
    if (! (291 == fixp->if1.major)) {
#line 4509
      goto while_break;
    }
#line 4510
    fixp --;
  }
  while_break: /* CIL Label */ ;
  }
#line 4512
  if ((unsigned long )fixp == (unsigned long )((union fix *)fixst)) {
    {
#line 4514
    error_message(1016);
#line 4515
    fixp = fixp_arch;
    }
#line 4516
    return (1);
  }
#line 4520
  if (294 == fixp->switch1.major) {
#line 4522
    if ((unsigned long )((void *)0) == (unsigned long )fixp->switch1.next) {
      {
#line 4524
      tmp___0 = allocate((unsigned int )sizeof(struct list_const1 ), 0U);
#line 4524
      fixp->switch1.next = (struct list_const1 *)tmp___0;
#line 4528
      (fixp->switch1.next)->line_number = spf[s].line_counter;
#line 4529
      (fixp->switch1.next)->constant = int_const;
#line 4530
      (fixp->switch1.next)->next = (struct list_const1 *)((void *)0);
      }
    } else {
#line 4534
      ptr = fixp->switch1.next;
      {
#line 4535
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4535
        if (! ((unsigned long )((void *)0) != (unsigned long )ptr->next)) {
#line 4535
          goto while_break___0;
        }
#line 4536
        ptr = ptr->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 4537
      tmp___1 = allocate((unsigned int )sizeof(struct list_const1 ), 0U);
#line 4537
      ptr->next = (struct list_const1 *)tmp___1;
#line 4539
      (ptr->next)->line_number = spf[s].line_counter;
#line 4540
      (ptr->next)->constant = int_const;
#line 4541
      (ptr->next)->next = (struct list_const1 *)((void *)0);
      }
    }
  } else {
    {
#line 4546
    error_message(1016);
#line 4547
    fixp = fixp_arch;
    }
#line 4548
    return (1);
  }
#line 4551
  fixp = fixp_arch;
#line 4553
  return (0);
}
}
#line 4556 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void add_default_to_fixp(void) 
{ 
  union fix *fixp_arch ;

  {
#line 4563
  fixp_arch = fixp;
  {
#line 4565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4565
    if (! (291 == fixp->if1.major)) {
#line 4565
      goto while_break;
    }
#line 4566
    fixp --;
  }
  while_break: /* CIL Label */ ;
  }
#line 4568
  if ((unsigned long )fixp == (unsigned long )((union fix *)fixst)) {
    {
#line 4570
    error_message(3002);
#line 4571
    fixp = fixp_arch;
    }
#line 4572
    return;
  }
#line 4574
  if (294 == fixp->switch1.major) {
#line 4578
    if (0 == fixp->switch1.def_use.def_flag) {
#line 4580
      fixp->switch1.def_use.def_flag = 1;
#line 4581
      fixp->switch1.def_use.line_number = spf[s].line_counter;
#line 4582
      fixp->switch1.def_use.adr = kodp;
    } else {
      {
#line 4586
      error_message(3003);
#line 4587
      fixp = fixp_arch;
      }
#line 4588
      return;
    }
  } else {
    {
#line 4593
    error_message(3002);
#line 4594
    fixp = fixp_arch;
    }
#line 4595
    return;
  }
#line 4598
  fixp = fixp_arch;
#line 4600
  return;
}
}
#line 4606 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void func_def_s(void) 
{ 


  {
#line 4609
  func_def_f = 1;
#line 4610
  return;
}
}
#line 4613 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void func_def_r(void) 
{ 


  {
#line 4616
  func_def_f = 0;
#line 4617
  return;
}
}
#line 4632 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void enter_scope(void) 
{ 


  {
#line 4635
  if (func_def_f) {
#line 4636
    func_def_f = 0;
  } else {
#line 4638
    scope_level ++;
  }
#line 4639
  return;
}
}
#line 4642 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void exit_scope(void) 
{ 


  {
  {
#line 4645
  clear_hash_tab();
#line 4646
  clear_tag_tab();
  }
#line 4647
  if (scope_level) {
#line 4647
    scope_level --;
  }
#line 4648
  return;
}
}
#line 4651 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static void mov2lvalue(struct internal_type *typec , enum intern_arit_class type ) 
{ 
  register int i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 4660
  if ((unsigned int )typec->attribute.function_class == 1024U) {
#line 4660
    goto case_1024;
  }
#line 4660
  if ((unsigned int )typec->attribute.function_class == 1025U) {
#line 4660
    goto case_1024;
  }
#line 4660
  if ((unsigned int )typec->attribute.function_class == 1028U) {
#line 4660
    goto case_1024;
  }
#line 4709
  if ((unsigned int )typec->attribute.function_class == 1031U) {
#line 4709
    goto case_1031;
  }
#line 4723
  if ((unsigned int )typec->attribute.function_class == 1030U) {
#line 4723
    goto case_1030;
  }
#line 4723
  if ((unsigned int )typec->attribute.function_class == 1029U) {
#line 4723
    goto case_1030;
  }
#line 4735
  goto switch_default___0;
  case_1024: /* CIL Label */ 
  case_1025: /* CIL Label */ 
  case_1028: /* CIL Label */ 
  {
#line 4664
  if ((unsigned int )type == 136U) {
#line 4664
    goto case_136;
  }
#line 4664
  if ((unsigned int )type == 8U) {
#line 4664
    goto case_136;
  }
#line 4667
  if ((unsigned int )type == 264U) {
#line 4667
    goto case_264;
  }
#line 4671
  if ((unsigned int )type == 152U) {
#line 4671
    goto case_152;
  }
#line 4671
  if ((unsigned int )type == 24U) {
#line 4671
    goto case_152;
  }
#line 4674
  if ((unsigned int )type == 280U) {
#line 4674
    goto case_280;
  }
#line 4678
  if ((unsigned int )type == 140U) {
#line 4678
    goto case_140;
  }
#line 4678
  if ((unsigned int )type == 12U) {
#line 4678
    goto case_140;
  }
#line 4681
  if ((unsigned int )type == 268U) {
#line 4681
    goto case_268;
  }
#line 4684
  if ((unsigned int )type == 64U) {
#line 4684
    goto case_64;
  }
#line 4687
  if ((unsigned int )type == 80U) {
#line 4687
    goto case_80;
  }
#line 4690
  if ((unsigned int )type == 32U) {
#line 4690
    goto case_32;
  }
#line 4693
  if ((unsigned int )type == 2U) {
#line 4693
    goto case_2;
  }
#line 4696
  if ((unsigned int )type == 130U) {
#line 4696
    goto case_130;
  }
#line 4699
  if ((unsigned int )type == 258U) {
#line 4699
    goto case_258;
  }
#line 4702
  goto switch_default;
  case_136: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 4665
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4665
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4665
  kodp += sizeof(struct OPERAND_0_mi );
#line 4666
  goto switch_break___0;
  case_264: /* CIL Label */ 
#line 4668
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4668
  ((struct OPERAND_0_mi *)kodp)->minor = 12;
#line 4668
  kodp += sizeof(struct OPERAND_0_mi );
#line 4669
  goto switch_break___0;
  case_152: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 4672
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4672
  ((struct OPERAND_0_mi *)kodp)->minor = 13;
#line 4672
  kodp += sizeof(struct OPERAND_0_mi );
#line 4673
  goto switch_break___0;
  case_280: /* CIL Label */ 
#line 4675
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4675
  ((struct OPERAND_0_mi *)kodp)->minor = 14;
#line 4675
  kodp += sizeof(struct OPERAND_0_mi );
#line 4676
  goto switch_break___0;
  case_140: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 4679
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4679
  ((struct OPERAND_0_mi *)kodp)->minor = 15;
#line 4679
  kodp += sizeof(struct OPERAND_0_mi );
#line 4680
  goto switch_break___0;
  case_268: /* CIL Label */ 
#line 4682
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4682
  ((struct OPERAND_0_mi *)kodp)->minor = 16;
#line 4682
  kodp += sizeof(struct OPERAND_0_mi );
#line 4683
  goto switch_break___0;
  case_64: /* CIL Label */ 
#line 4685
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4685
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4685
  kodp += sizeof(struct OPERAND_0_mi );
#line 4686
  goto switch_break___0;
  case_80: /* CIL Label */ 
#line 4688
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4688
  ((struct OPERAND_0_mi *)kodp)->minor = 258;
#line 4688
  kodp += sizeof(struct OPERAND_0_mi );
#line 4689
  goto switch_break___0;
  case_32: /* CIL Label */ 
#line 4691
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4691
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4691
  kodp += sizeof(struct OPERAND_0_mi );
#line 4692
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 4694
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4694
  ((struct OPERAND_0_mi *)kodp)->minor = 768;
#line 4694
  kodp += sizeof(struct OPERAND_0_mi );
#line 4695
  goto switch_break___0;
  case_130: /* CIL Label */ 
#line 4697
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4697
  ((struct OPERAND_0_mi *)kodp)->minor = 770;
#line 4697
  kodp += sizeof(struct OPERAND_0_mi );
#line 4698
  goto switch_break___0;
  case_258: /* CIL Label */ 
#line 4700
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4700
  ((struct OPERAND_0_mi *)kodp)->minor = 771;
#line 4700
  kodp += sizeof(struct OPERAND_0_mi );
#line 4701
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 4703
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c", 4703);
#line 4704
  error_message(5000);
#line 4705
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 4707
  last_instr = current_instr;
#line 4707
  current_instr = kodp;
#line 4708
  goto switch_break;
  case_1031: /* CIL Label */ 
#line 4710
  if (8U == (unsigned int )type) {
#line 4712
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4712
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4712
    kodp += sizeof(struct OPERAND_0_mi );
#line 4713
    last_instr = current_instr;
#line 4713
    current_instr = kodp;
  } else {
    {
#line 4717
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             4717);
#line 4718
    error_message(5000);
#line 4719
    abort();
    }
  }
#line 4721
  goto switch_break;
  case_1030: /* CIL Label */ 
  case_1029: /* CIL Label */ 
#line 4727
  i = 0;
  {
#line 4727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4727
    if (! (i < typec->attribute.memory_size)) {
#line 4727
      goto while_break;
    }
#line 4729
    ((struct OPERAND_1_i *)kodp)->major = 32;
#line 4729
    ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 4729
    ((struct OPERAND_1_i *)kodp)->num = i;
#line 4729
    kodp += sizeof(struct OPERAND_1_i );
#line 4729
    last_instr = current_instr;
#line 4729
    current_instr = kodp;
#line 4730
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4730
    ((struct OPERAND_0_mi *)kodp)->minor = 11;
#line 4730
    kodp += sizeof(struct OPERAND_0_mi );
#line 4730
    last_instr = current_instr;
#line 4730
    current_instr = kodp;
#line 4727
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4733
  ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 4733
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4733
  kodp += sizeof(struct OPERAND_0_mi );
#line 4733
  last_instr = current_instr;
#line 4733
  current_instr = kodp;
#line 4734
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 4737
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c", 4737);
#line 4738
  error_message(5002);
#line 4739
  abort();
  }
#line 4740
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4742
  return;
}
}
#line 4746 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void move2lvalue(void) 
{ 


  {
  {
#line 4749
  mov2lvalue(type_com[set], type_ac[set]);
  }
#line 4750
  return;
}
}
#line 4754 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int type_compare(struct internal_type *type1 , struct internal_type *type2 ) 
{ 


  {
#line 4758
  if (1028U == (unsigned int )type2->attribute.function_class) {
#line 4758
    if (1025U == (unsigned int )type1->attribute.function_class) {
#line 4758
      if ((unsigned long )type1->output == (unsigned long )type2->output) {
#line 4764
        ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4764
        ((struct OPERAND_0_mi *)kodp)->minor = 8;
#line 4764
        kodp += sizeof(struct OPERAND_0_mi );
#line 4764
        last_instr = current_instr;
#line 4764
        current_instr = kodp;
      } else {
#line 4758
        goto _L___4;
      }
    } else {
#line 4758
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 4766
  if (1028U == (unsigned int )type2->attribute.function_class) {
#line 4766
    if (1025U == (unsigned int )type1->attribute.function_class) {
      {
#line 4767
      error_message(1028);
      }
    } else {
#line 4766
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 4768
  if (1028U == (unsigned int )type1->attribute.function_class) {
#line 4768
    if (1028U == (unsigned int )type2->attribute.function_class) {
#line 4768
      if (1024U == (unsigned int )(type1->output)->attribute.function_class) {
#line 4768
        if (1024U == (unsigned int )(type2->output)->attribute.function_class) {
#line 4771
          if ((unsigned int )(type1->output)->attribute.arit_class == (unsigned int )(type2->output)->attribute.arit_class) {
#line 4773
            return (0);
          } else {
            {
#line 4775
            error_message(6013);
            }
          }
        } else {
#line 4768
          goto _L___1;
        }
      } else {
#line 4768
        goto _L___1;
      }
    } else {
#line 4768
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 4777
  if (1028U == (unsigned int )type1->attribute.function_class) {
#line 4777
    if (1028U == (unsigned int )type2->attribute.function_class) {
#line 4777
      if ((unsigned long )type1->output != (unsigned long )type2->output) {
        {
#line 4779
        error_message(1028);
        }
      }
    }
  }
#line 4780
  return (0);
}
}
#line 4785 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static struct internal_type *cyclic_def(struct internal_type *type1 , struct internal_type *type2 ) 
{ 
  struct internal_type *result ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 4789
  result = (struct internal_type *)((void *)0);
#line 4791
  if ((unsigned long )type1 == (unsigned long )((void *)0)) {
    {
#line 4793
    fprintfx(stderr, "%s:%d: cyclic_def with bad parameter\n", "/home/wslee/benchmarks/clif-0.93/comp_maint.c",
             4794);
#line 4795
    abort();
    }
  }
#line 4798
  if ((unsigned long )type2 == (unsigned long )((void *)0)) {
#line 4799
    return (result);
  }
#line 4801
  if (1028U == (unsigned int )type2->attribute.function_class) {
#line 4801
    if ((unsigned long )type1->output == (unsigned long )type2->output) {
#line 4802
      result = type2;
    }
  }
#line 4804
  if (! result) {
#line 4804
    if ((unsigned long )type2->input != (unsigned long )((void *)0)) {
      {
#line 4805
      result = cyclic_def(type1, type2->input);
      }
    }
  }
#line 4806
  if (! result) {
#line 4806
    if ((unsigned long )type2->arity != (unsigned long )((void *)0)) {
      {
#line 4807
      result = cyclic_def(type1, type2->arity);
      }
    }
  }
#line 4808
  if (! result) {
#line 4808
    if ((unsigned long )type2->output != (unsigned long )((void *)0)) {
      {
#line 4809
      result = cyclic_def(type1, type2->output);
      }
    }
  }
#line 4811
  return (result);
}
}
#line 4817 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void put2table(char *name___0 , struct internal_type *type ) 
{ 
  struct internal_type *walk ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4822
  walk = type;
  {
#line 4824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4824
    if (walk) {
#line 4824
      if (! (! (8195U == (unsigned int )walk->attribute.storage_class_specifier))) {
#line 4824
        goto while_break;
      }
    } else {
#line 4824
      goto while_break;
    }
#line 4825
    walk = walk->output;
  }
  while_break: /* CIL Label */ ;
  }
#line 4827
  if (walk) {
#line 4827
    if (proc == 0) {
#line 4829
      if (0U == (unsigned int )walk->attribute.arit_class) {
#line 4830
        walk->attribute.arit_class = (enum intern_arit_class )8;
      }
      {
#line 4831
      enter_file_scope();
#line 4832
      tmp___0 = has_loc(768, name___0);
      }
#line 4832
      if (-1 == tmp___0) {
#line 4833
        no_compile_only = 0;
      }
    } else {
#line 4827
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 4835
  if ((unsigned long )((void *)0) != (unsigned long )proc_name_text[proc]) {
#line 4835
    if ((unsigned long )type != (unsigned long )((void *)0)) {
      {
#line 4837
      tmp___1 = has_loc(768, name___0);
      }
#line 4837
      if (-1 == tmp___1) {
#line 4838
        no_compile_only = 0;
      }
    } else {
#line 4835
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 4840
    tmp___2 = has(name___0);
    }
#line 4840
    if (-1 == tmp___2) {
#line 4841
      no_compile_only = 0;
    }
  }
#line 4842
  return;
}
}
#line 4846 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
int get_num_args(struct internal_type *type ) 
{ 
  register struct internal_type *walk ;
  register int n ;

  {
#line 4853
  if (type) {
#line 4853
    if (2049U == (unsigned int )type->attribute.function_class) {
#line 4853
      goto _L;
    } else
#line 4853
    if (2048U == (unsigned int )type->attribute.function_class) {
      _L: /* CIL Label */ 
#line 4855
      walk = type->input;
#line 4856
      n = 0;
      {
#line 4856
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4856
        if (! walk) {
#line 4856
          goto while_break;
        }
#line 4857
        if (1U & (unsigned int )walk->attribute.arit_class) {
#line 4858
          n --;
        }
#line 4856
        walk = walk->arity;
#line 4856
        n ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 4860
  return (n);
}
}
#line 4865 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void promote_type(void) 
{ 


  {
  {
#line 4870
  if ((unsigned int )type_ac[set] == 2U) {
#line 4870
    goto case_2;
  }
#line 4874
  if ((unsigned int )type_ac[set] == 32U) {
#line 4874
    goto case_32;
  }
#line 4878
  goto switch_default;
  case_2: /* CIL Label */ 
#line 4871
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4871
  ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 4871
  kodp += sizeof(struct OPERAND_0_mi );
#line 4871
  last_instr = current_instr;
#line 4871
  current_instr = kodp;
#line 4872
  type_ac[set] = (enum intern_arit_class )8;
#line 4873
  goto switch_break;
  case_32: /* CIL Label */ 
#line 4875
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4875
  ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 4875
  kodp += sizeof(struct OPERAND_0_mi );
#line 4875
  last_instr = current_instr;
#line 4875
  current_instr = kodp;
#line 4876
  type_ac[set] = (enum intern_arit_class )64;
#line 4877
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4879
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4881
  return;
}
}
#line 4884 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
static int start_main(void) 
{ 
  struct ident_tab *ptr ;
  char *__cil_tmp2 ;

  {
  {
#line 4892
  text = string((char *)"main");
#line 4893
  ptr = point(text);
  }
#line 4894
  if ((unsigned long )((void *)0) == (unsigned long )ptr) {
    {
#line 4896
    error_message(4003);
    }
#line 4897
    return (1);
  }
#line 4899
  pc = kodp;
#line 4900
  ((struct OPERAND_1_mi *)kodp)->major = 29;
#line 4900
  ((struct OPERAND_1_mi *)kodp)->minor = 0;
#line 4900
  ((struct OPERAND_1_mi *)kodp)->adr = ptr->adr;
#line 4900
  kodp += sizeof(struct OPERAND_1_mi );
#line 4900
  last_instr = current_instr;
#line 4900
  current_instr = kodp;
#line 4901
  ((struct OPERAND_0_ma *)kodp)->major = 35;
#line 4901
  kodp += sizeof(struct OPERAND_0_ma );
#line 4901
  last_instr = current_instr;
#line 4901
  current_instr = kodp;
#line 4902
  return (0);
}
}
#line 4908 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void check_spec_constr(struct internal_type *type , char *name___0 ) 
{ 


  {
#line 4913
  if (1028U == (unsigned int )type->attribute.function_class) {
#line 4913
    goto _L;
  } else
#line 4913
  if (1025U == (unsigned int )type->attribute.function_class) {
#line 4913
    goto _L;
  } else
#line 4913
  if (2048U == (unsigned int )type->attribute.function_class) {
#line 4913
    goto _L;
  } else
#line 4913
  if (2049U == (unsigned int )type->attribute.function_class) {
    _L: /* CIL Label */ 
    {
#line 4915
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4915
      if (! type->output) {
#line 4915
        goto while_break;
      }
#line 4916
      type = type->output;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 4918
  if (1U & (unsigned int )type->attribute.arit_class) {
#line 4920
    if (128U & (unsigned int )type->attribute.arit_class) {
      {
#line 4922
      error_message(2012, name___0);
      }
    } else
#line 4920
    if (256U & (unsigned int )type->attribute.arit_class) {
      {
#line 4922
      error_message(2012, name___0);
      }
    } else
#line 4920
    if (16U & (unsigned int )type->attribute.arit_class) {
      {
#line 4922
      error_message(2012, name___0);
      }
    } else
#line 4920
    if (4U & (unsigned int )type->attribute.arit_class) {
      {
#line 4922
      error_message(2012, name___0);
      }
    }
  } else
#line 4924
  if (2U & (unsigned int )type->attribute.arit_class) {
#line 4926
    if (16U & (unsigned int )type->attribute.arit_class) {
      {
#line 4927
      error_message(2013, name___0);
      }
    } else
#line 4926
    if (4U & (unsigned int )type->attribute.arit_class) {
      {
#line 4927
      error_message(2013, name___0);
      }
    }
  } else
#line 4929
  if (! (8U & (unsigned int )type->attribute.arit_class)) {
#line 4931
    if (32U & (unsigned int )type->attribute.arit_class) {
#line 4933
      if (128U & (unsigned int )type->attribute.arit_class) {
        {
#line 4935
        error_message(2012, name___0);
        }
      } else
#line 4933
      if (256U & (unsigned int )type->attribute.arit_class) {
        {
#line 4935
        error_message(2012, name___0);
        }
      } else
#line 4933
      if (16U & (unsigned int )type->attribute.arit_class) {
        {
#line 4935
        error_message(2012, name___0);
        }
      } else
#line 4933
      if (4U & (unsigned int )type->attribute.arit_class) {
        {
#line 4935
        error_message(2012, name___0);
        }
      }
    } else
#line 4937
    if (64U & (unsigned int )type->attribute.arit_class) {
#line 4939
      if (128U & (unsigned int )type->attribute.arit_class) {
        {
#line 4941
        error_message(2014, name___0);
        }
      } else
#line 4939
      if (256U & (unsigned int )type->attribute.arit_class) {
        {
#line 4941
        error_message(2014, name___0);
        }
      } else
#line 4939
      if (4U & (unsigned int )type->attribute.arit_class) {
        {
#line 4941
        error_message(2014, name___0);
        }
      }
    } else
#line 4943
    if (! (8192U == (unsigned int )type->attribute.storage_class_specifier)) {
#line 4943
      if (8198U == (unsigned int )type->attribute.storage_class_specifier) {
#line 4943
        if (4098U == (unsigned int )type->attribute.type_qualifier) {
#line 4943
          if (0U == (unsigned int )type->attribute.arit_class) {
#line 4943
            goto _L___0;
          } else {
#line 4945
            type->attribute.arit_class = (enum intern_arit_class )((unsigned int )type->attribute.arit_class + 8U);
          }
        } else {
#line 4945
          type->attribute.arit_class = (enum intern_arit_class )((unsigned int )type->attribute.arit_class + 8U);
        }
      } else {
#line 4945
        type->attribute.arit_class = (enum intern_arit_class )((unsigned int )type->attribute.arit_class + 8U);
      }
    } else
    _L___0: /* CIL Label */ 
#line 4946
    if (! (8192U == (unsigned int )type->attribute.storage_class_specifier)) {
      {
#line 4949
      error_message(5003);
      }
    }
  }
#line 4951
  if (128U & (unsigned int )type->attribute.arit_class) {
#line 4951
    if (256U & (unsigned int )type->attribute.arit_class) {
      {
#line 4952
      error_message(2015, name___0);
      }
    } else {
#line 4951
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 4953
  if (16U & (unsigned int )type->attribute.arit_class) {
#line 4953
    if (4U & (unsigned int )type->attribute.arit_class) {
      {
#line 4954
      error_message(2016, name___0);
      }
    }
  }
#line 4955
  return;
}
}
#line 4958 "/home/wslee/benchmarks/clif-0.93/comp_maint.c"
void gen_cast_needed(void) 
{ 
  char *tmp___0 ;

  {
#line 4961
  if (call_by_value) {
    {
#line 4963
    ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4963
    ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 4963
    kodp += sizeof(struct OPERAND_0_mi );
#line 4963
    last_instr = current_instr;
#line 4963
    current_instr = kodp;
#line 4964
    type_ac[set] = (enum intern_arit_class )64;
#line 4965
    tmp___0 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 4965
    type_com[set] = (struct internal_type *)tmp___0;
#line 4967
    init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 4969
    (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 4970
    (type_com[set])->attribute.type_qualifier = (enum type_qual )4098;
#line 4971
    (type_com[set])->attribute.arit_class = type_ac[set];
#line 4972
    (type_com[set])->attribute.memory_size = (int )sizeof(double );
    }
  }
#line 4975
  return;
}
}
#line 41 "/home/wslee/benchmarks/clif-0.93/getc_unix.c"
int getcx(FILE *input___1 ) 
{ 
  int tmp___0 ;

  {
  {
#line 45
  tmp___0 = _IO_getc(input___1);
  }
#line 45
  return (tmp___0);
}
}
#line 37 "/home/wslee/benchmarks/clif-0.93/clif.c"
int main(int argc , char **argv ) ;
#line 39 "/home/wslee/benchmarks/clif-0.93/clif.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 47
  clif(argc, argv);
  }
#line 51
  return (0);
}
}
#line 413 "/usr/include/stdio.h"
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 145 "/home/wslee/benchmarks/clif-0.93/global.h"
void store_context(void) ;
#line 146
void restore_context(void) ;
#line 97 "/home/wslee/benchmarks/clif-0.93/tables.h"
void align_memory(char **p , int n ) ;
#line 49 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static int exe(char *pc1 ) ;
#line 50
static void mod_yes(void) ;
#line 51
static void div_yes(void) ;
#line 52
static void divui_yes(void) ;
#line 53
static void divli_yes(void) ;
#line 54
static void divlui_yes(void) ;
#line 55
static void divd_yes(void) ;
#line 56
static void divld_yes(void) ;
#line 57
static void divf_yes(void) ;
#line 61
static void vtrue(void) ;
#line 62
static void vfalse(void) ;
#line 63
static void move_stack_aligned(char **p , int n ) ;
#line 68
void switch_to_stdin(void) ;
#line 77 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
int exec(void) 
{ 
  int a ;
  char *__cil_tmp2 ;

  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (dbg_symbols) {
      {
#line 87
      dbg_print(pc);
      }
    }
    {
#line 88
    a = exe(pc);
    }
#line 90
    if (handler) {
      {
#line 92
      store_context();
#line 93
      clif_interrupt_level ++;
#line 93
      fprintfx(stderr, "\nclif interrupt level %d\n", clif_interrupt_level);
#line 104
      switch_to_stdin();
#line 108
      handler = 0;
      }
#line 109
      goto while_break;
    }
#line 81
    if (! (a == 0)) {
#line 81
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if (a == -2) {
#line 115
    return (0);
  } else {
#line 117
    return (1);
  }
}
}
#line 142 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static char *adr_arg[256]  ;
#line 121 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static int exe(char *pc1 ) 
{ 
  int binar ;
  int counter ;
  unsigned int binaru ;
  long binarl ;
  unsigned long binarlu ;
  double binard ;
  long double binarld ;
  float binarf ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;

  {
  {
#line 147
  if (((struct OPERAND_0_ma *)pc1)->major == 37) {
#line 147
    goto case_37;
  }
#line 705
  if (((struct OPERAND_0_ma *)pc1)->major == 43) {
#line 705
    goto case_43;
  }
#line 715
  if (((struct OPERAND_0_ma *)pc1)->major == 44) {
#line 715
    goto case_44;
  }
#line 3845
  if (((struct OPERAND_0_ma *)pc1)->major == 33) {
#line 3845
    goto case_33;
  }
#line 3899
  if (((struct OPERAND_0_ma *)pc1)->major == 40) {
#line 3899
    goto case_40;
  }
#line 4132
  if (((struct OPERAND_0_ma *)pc1)->major == 38) {
#line 4132
    goto case_38;
  }
#line 4221
  if (((struct OPERAND_0_ma *)pc1)->major == 39) {
#line 4221
    goto case_39;
  }
#line 4303
  if (((struct OPERAND_0_ma *)pc1)->major == 10) {
#line 4303
    goto case_10___1;
  }
#line 4536
  if (((struct OPERAND_0_ma *)pc1)->major == 11) {
#line 4536
    goto case_11___1;
  }
#line 4708
  if (((struct OPERAND_0_ma *)pc1)->major == 12) {
#line 4708
    goto case_12___1;
  }
#line 4833
  if (((struct OPERAND_0_ma *)pc1)->major == 14) {
#line 4833
    goto case_14___1;
  }
#line 4848
  if (((struct OPERAND_0_ma *)pc1)->major == 13) {
#line 4848
    goto case_13___1;
  }
#line 4989
  if (((struct OPERAND_0_ma *)pc1)->major == 15) {
#line 4989
    goto case_15___1;
  }
#line 5111
  if (((struct OPERAND_0_ma *)pc1)->major == 16) {
#line 5111
    goto case_16___1;
  }
#line 5235
  if (((struct OPERAND_0_ma *)pc1)->major == 17) {
#line 5235
    goto case_17___1;
  }
#line 5248
  if (((struct OPERAND_0_ma *)pc1)->major == 18) {
#line 5248
    goto case_18___1;
  }
#line 5261
  if (((struct OPERAND_0_ma *)pc1)->major == 19) {
#line 5261
    goto case_19___1;
  }
#line 5377
  if (((struct OPERAND_0_ma *)pc1)->major == 21) {
#line 5377
    goto case_21___1;
  }
#line 5493
  if (((struct OPERAND_0_ma *)pc1)->major == 20) {
#line 5493
    goto case_20___1;
  }
#line 5596
  if (((struct OPERAND_0_ma *)pc1)->major == 22) {
#line 5596
    goto case_22___0;
  }
#line 5712
  if (((struct OPERAND_0_ma *)pc1)->major == 23) {
#line 5712
    goto case_23___0;
  }
#line 5828
  if (((struct OPERAND_0_ma *)pc1)->major == 24) {
#line 5828
    goto case_24;
  }
#line 5944
  if (((struct OPERAND_0_ma *)pc1)->major == 45) {
#line 5944
    goto case_45;
  }
#line 6124
  if (((struct OPERAND_0_ma *)pc1)->major == 46) {
#line 6124
    goto case_46;
  }
#line 6135
  if (((struct OPERAND_0_ma *)pc1)->major == 47) {
#line 6135
    goto case_47;
  }
#line 6148
  if (((struct OPERAND_0_ma *)pc1)->major == 48) {
#line 6148
    goto case_48;
  }
#line 6161
  if (((struct OPERAND_0_ma *)pc1)->major == 49) {
#line 6161
    goto case_49;
  }
#line 6174
  if (((struct OPERAND_0_ma *)pc1)->major == 35) {
#line 6174
    goto case_35;
  }
#line 6183
  if (((struct OPERAND_0_ma *)pc1)->major == 50) {
#line 6183
    goto case_50;
  }
#line 6194
  if (((struct OPERAND_0_ma *)pc1)->major == 51) {
#line 6194
    goto case_51;
  }
#line 6207
  if (((struct OPERAND_0_ma *)pc1)->major == 32) {
#line 6207
    goto case_32;
  }
#line 6463
  if (((struct OPERAND_0_ma *)pc1)->major == 30) {
#line 6463
    goto case_30___0;
  }
#line 6782
  if (((struct OPERAND_0_ma *)pc1)->major == 31) {
#line 6782
    goto case_31___0;
  }
#line 7216
  if (((struct OPERAND_0_ma *)pc1)->major == 36) {
#line 7216
    goto case_36;
  }
#line 7225
  if (((struct OPERAND_0_ma *)pc1)->major == 25) {
#line 7225
    goto case_25;
  }
#line 7236
  if (((struct OPERAND_0_ma *)pc1)->major == 27) {
#line 7236
    goto case_27___0;
  }
#line 7254
  if (((struct OPERAND_0_ma *)pc1)->major == 34) {
#line 7254
    goto case_34;
  }
#line 7266
  if (((struct OPERAND_0_ma *)pc1)->major == 26) {
#line 7266
    goto case_26___0;
  }
#line 7284
  if (((struct OPERAND_0_ma *)pc1)->major == 29) {
#line 7284
    goto case_29___0;
  }
#line 7821
  if (((struct OPERAND_0_ma *)pc1)->major == 28) {
#line 7821
    goto case_28___0;
  }
#line 7833
  if (((struct OPERAND_0_ma *)pc1)->major == 52) {
#line 7833
    goto case_52;
  }
#line 7842
  goto switch_default___22;
  case_37: /* CIL Label */ 
  {
#line 151
  if (((struct OPERAND_1_mi *)pc1)->minor == 0) {
#line 151
    goto case_0;
  }
#line 168
  if (((struct OPERAND_1_mi *)pc1)->minor == 1) {
#line 168
    goto case_1;
  }
#line 181
  if (((struct OPERAND_1_mi *)pc1)->minor == 2) {
#line 181
    goto case_2;
  }
#line 194
  if (((struct OPERAND_1_mi *)pc1)->minor == 3) {
#line 194
    goto case_3;
  }
#line 207
  if (((struct OPERAND_1_mi *)pc1)->minor == 4) {
#line 207
    goto case_4;
  }
#line 220
  if (((struct OPERAND_1_mi *)pc1)->minor == 5) {
#line 220
    goto case_5;
  }
#line 233
  if (((struct OPERAND_1_mi *)pc1)->minor == 6) {
#line 233
    goto case_6;
  }
#line 247
  if (((struct OPERAND_1_mi *)pc1)->minor == 7) {
#line 247
    goto case_7;
  }
#line 260
  if (((struct OPERAND_1_mi *)pc1)->minor == 8) {
#line 260
    goto case_8;
  }
#line 275
  if (((struct OPERAND_1_mi *)pc1)->minor == 9) {
#line 275
    goto case_9;
  }
#line 290
  if (((struct OPERAND_1_mi *)pc1)->minor == 10) {
#line 290
    goto case_10;
  }
#line 307
  if (((struct OPERAND_1_mi *)pc1)->minor == 11) {
#line 307
    goto case_11;
  }
#line 322
  if (((struct OPERAND_1_mi *)pc1)->minor == 12) {
#line 322
    goto case_12;
  }
#line 339
  if (((struct OPERAND_1_mi *)pc1)->minor == 13) {
#line 339
    goto case_13;
  }
#line 356
  if (((struct OPERAND_1_mi *)pc1)->minor == 14) {
#line 356
    goto case_14;
  }
#line 373
  if (((struct OPERAND_1_mi *)pc1)->minor == 15) {
#line 373
    goto case_15;
  }
#line 390
  if (((struct OPERAND_1_mi *)pc1)->minor == 16) {
#line 390
    goto case_16;
  }
#line 407
  if (((struct OPERAND_1_mi *)pc1)->minor == 17) {
#line 407
    goto case_17;
  }
#line 424
  if (((struct OPERAND_1_mi *)pc1)->minor == 18) {
#line 424
    goto case_18;
  }
#line 441
  if (((struct OPERAND_1_mi *)pc1)->minor == 19) {
#line 441
    goto case_19;
  }
#line 458
  if (((struct OPERAND_1_mi *)pc1)->minor == 20) {
#line 458
    goto case_20;
  }
#line 475
  if (((struct OPERAND_1_mi *)pc1)->minor == 21) {
#line 475
    goto case_21;
  }
#line 492
  if (((struct OPERAND_1_mi *)pc1)->minor == 256) {
#line 492
    goto case_256;
  }
#line 509
  if (((struct OPERAND_1_mi *)pc1)->minor == 257) {
#line 509
    goto case_257;
  }
#line 526
  if (((struct OPERAND_1_mi *)pc1)->minor == 258) {
#line 526
    goto case_258;
  }
#line 543
  if (((struct OPERAND_1_mi *)pc1)->minor == 259) {
#line 543
    goto case_259;
  }
#line 560
  if (((struct OPERAND_1_mi *)pc1)->minor == 512) {
#line 560
    goto case_512;
  }
#line 577
  if (((struct OPERAND_1_mi *)pc1)->minor == 513) {
#line 577
    goto case_513;
  }
#line 594
  if (((struct OPERAND_1_mi *)pc1)->minor == 768) {
#line 594
    goto case_768;
  }
#line 611
  if (((struct OPERAND_1_mi *)pc1)->minor == 769) {
#line 611
    goto case_769;
  }
#line 628
  if (((struct OPERAND_1_mi *)pc1)->minor == 770) {
#line 628
    goto case_770;
  }
#line 645
  if (((struct OPERAND_1_mi *)pc1)->minor == 771) {
#line 645
    goto case_771;
  }
#line 662
  if (((struct OPERAND_1_mi *)pc1)->minor == 772) {
#line 662
    goto case_772;
  }
#line 679
  if (((struct OPERAND_1_mi *)pc1)->minor == 773) {
#line 679
    goto case_773;
  }
#line 695
  goto switch_default;
  case_0: /* CIL Label */ 
#line 152
  *((int *)*(ast + sizeof(char *))) = *((int *)*ast);
#line 163
  ast += sizeof(char *);
#line 164
  pc += sizeof(struct OPERAND_0_mi );
#line 165
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 169
  bp = stack;
#line 177
  pc += sizeof(struct OPERAND_0_mi );
#line 178
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 182
  stack = bp;
#line 190
  pc += sizeof(struct OPERAND_0_mi );
#line 191
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 195
  tmph = tmp;
#line 203
  pc += sizeof(struct OPERAND_0_mi );
#line 204
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 208
  frame = stack;
#line 216
  pc += sizeof(struct OPERAND_0_mi );
#line 217
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 221
  stack = frame;
#line 229
  pc += sizeof(struct OPERAND_0_mi );
#line 230
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 234
  ast -= sizeof(char *);
#line 235
  *ast = *(ast + sizeof(char *));
#line 243
  pc += sizeof(struct OPERAND_0_mi );
#line 244
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 248
  *ast = (char *)((void *)*((long *)*ast));
#line 256
  pc += sizeof(struct OPERAND_0_mi );
#line 257
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 261
  move_stack_aligned(& tmp, (int )(- sizeof(pointer_size )));
#line 262
  *((long *)tmp) = (long )*ast;
#line 263
  *ast = tmp;
#line 271
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 272
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 276
  *(ast + sizeof(char *)) = (char *)((void *)(*(ast + sizeof(char *)) + *((int *)*ast)));
#line 285
  ast += sizeof(char *);
#line 286
  pc += sizeof(struct OPERAND_0_mi );
#line 287
  goto switch_break___0;
  case_10: /* CIL Label */ 
  {
#line 291
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 292
  *((int *)tmp) = *((int *)*ast);
#line 293
  ast -= sizeof(char *);
#line 294
  *ast = tmp;
#line 303
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 304
  goto switch_break___0;
  case_11: /* CIL Label */ 
#line 308
  *(*(ast + 2UL * sizeof(char *)) + *((int *)*ast)) = *(*(ast + sizeof(char *)) + *((int *)*ast));
#line 317
  ast += sizeof(char *);
#line 318
  pc += sizeof(struct OPERAND_0_mi );
#line 319
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 323
  *((unsigned int *)*(ast + sizeof(char *))) = *((unsigned int *)*ast);
#line 334
  ast += sizeof(char *);
#line 335
  pc += sizeof(struct OPERAND_0_mi );
#line 336
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 340
  *((long *)*(ast + sizeof(char *))) = *((long *)*ast);
#line 351
  ast += sizeof(char *);
#line 352
  pc += sizeof(struct OPERAND_0_mi );
#line 353
  goto switch_break___0;
  case_14: /* CIL Label */ 
#line 357
  *((unsigned long *)*(ast + sizeof(char *))) = *((unsigned long *)*ast);
#line 368
  ast += sizeof(char *);
#line 369
  pc += sizeof(struct OPERAND_0_mi );
#line 370
  goto switch_break___0;
  case_15: /* CIL Label */ 
#line 374
  *((short *)*(ast + sizeof(char *))) = *((short *)*ast);
#line 385
  ast += sizeof(char *);
#line 386
  pc += sizeof(struct OPERAND_0_mi );
#line 387
  goto switch_break___0;
  case_16: /* CIL Label */ 
#line 391
  *((unsigned short *)*(ast + sizeof(char *))) = *((unsigned short *)*ast);
#line 402
  ast += sizeof(char *);
#line 403
  pc += sizeof(struct OPERAND_0_mi );
#line 404
  goto switch_break___0;
  case_17: /* CIL Label */ 
  {
#line 408
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 409
  *((unsigned int *)tmp) = *((unsigned int *)*ast);
#line 410
  ast -= sizeof(char *);
#line 411
  *ast = tmp;
#line 420
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 421
  goto switch_break___0;
  case_18: /* CIL Label */ 
  {
#line 425
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 426
  *((long *)tmp) = *((long *)*ast);
#line 427
  ast -= sizeof(char *);
#line 428
  *ast = tmp;
#line 437
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 438
  goto switch_break___0;
  case_19: /* CIL Label */ 
  {
#line 442
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 443
  *((unsigned long *)tmp) = *((unsigned long *)*ast);
#line 444
  ast -= sizeof(char *);
#line 445
  *ast = tmp;
#line 454
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 455
  goto switch_break___0;
  case_20: /* CIL Label */ 
  {
#line 459
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 460
  *((short *)tmp) = *((short *)*ast);
#line 461
  ast -= sizeof(char *);
#line 462
  *ast = tmp;
#line 471
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 472
  goto switch_break___0;
  case_21: /* CIL Label */ 
  {
#line 476
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 477
  *((unsigned short *)tmp) = *((unsigned short *)*ast);
#line 478
  ast -= sizeof(char *);
#line 479
  *ast = tmp;
#line 488
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 489
  goto switch_break___0;
  case_256: /* CIL Label */ 
#line 493
  *((double *)*(ast + sizeof(char *))) = *((double *)*ast);
#line 504
  ast += sizeof(char *);
#line 505
  pc += sizeof(struct OPERAND_0_mi );
#line 506
  goto switch_break___0;
  case_257: /* CIL Label */ 
  {
#line 510
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 511
  *((double *)tmp) = *((double *)*ast);
#line 512
  ast -= sizeof(char *);
#line 513
  *ast = tmp;
#line 522
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 523
  goto switch_break___0;
  case_258: /* CIL Label */ 
#line 527
  *((long double *)*(ast + sizeof(char *))) = *((long double *)*ast);
#line 538
  ast += sizeof(char *);
#line 539
  pc += sizeof(struct OPERAND_0_mi );
#line 540
  goto switch_break___0;
  case_259: /* CIL Label */ 
  {
#line 544
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 545
  *((long double *)tmp) = *((long double *)*ast);
#line 546
  ast -= sizeof(char *);
#line 547
  *ast = tmp;
#line 556
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 557
  goto switch_break___0;
  case_512: /* CIL Label */ 
#line 561
  *((float *)*(ast + sizeof(char *))) = *((float *)*ast);
#line 572
  ast += sizeof(char *);
#line 573
  pc += sizeof(struct OPERAND_0_mi );
#line 574
  goto switch_break___0;
  case_513: /* CIL Label */ 
  {
#line 578
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 579
  *((float *)tmp) = *((float *)*ast);
#line 580
  ast -= sizeof(char *);
#line 581
  *ast = tmp;
#line 590
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 591
  goto switch_break___0;
  case_768: /* CIL Label */ 
#line 595
  *(*(ast + sizeof(char *))) = *(*ast);
#line 606
  ast += sizeof(char *);
#line 607
  pc += sizeof(struct OPERAND_0_mi );
#line 608
  goto switch_break___0;
  case_769: /* CIL Label */ 
  {
#line 612
  move_stack_aligned(& tmp, (int )(- sizeof(char )));
#line 613
  *tmp = *(*ast);
#line 614
  ast -= sizeof(char *);
#line 615
  *ast = tmp;
#line 624
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 625
  goto switch_break___0;
  case_770: /* CIL Label */ 
#line 629
  *((signed char *)*(ast + sizeof(char *))) = *((signed char *)*ast);
#line 640
  ast += sizeof(char *);
#line 641
  pc += sizeof(struct OPERAND_0_mi );
#line 642
  goto switch_break___0;
  case_771: /* CIL Label */ 
#line 646
  *((unsigned char *)*(ast + sizeof(char *))) = *((unsigned char *)*ast);
#line 657
  ast += sizeof(char *);
#line 658
  pc += sizeof(struct OPERAND_0_mi );
#line 659
  goto switch_break___0;
  case_772: /* CIL Label */ 
  {
#line 663
  move_stack_aligned(& tmp, (int )(- sizeof(signed char )));
#line 664
  *((signed char *)tmp) = *((signed char *)*ast);
#line 665
  ast -= sizeof(char *);
#line 666
  *ast = tmp;
#line 675
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 676
  goto switch_break___0;
  case_773: /* CIL Label */ 
  {
#line 680
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned char )));
#line 681
  *((unsigned char *)tmp) = *((unsigned char *)*ast);
#line 682
  ast -= sizeof(char *);
#line 683
  *ast = tmp;
#line 692
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 693
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 696
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           696);
#line 697
  error_message(5001);
#line 698
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 700
  goto switch_break;
  case_43: /* CIL Label */ 
#line 706
  tmp = tmph;
#line 707
  pc += sizeof(struct OPERAND_0_ma );
#line 714
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 719
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 719
    goto case_0___0;
  }
#line 735
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 735
    goto case_1___0;
  }
#line 751
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 751
    goto case_2___0;
  }
#line 766
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 766
    goto case_3___0;
  }
#line 782
  if (((struct OPERAND_0_mi *)pc1)->minor == 4) {
#line 782
    goto case_4___0;
  }
#line 798
  if (((struct OPERAND_0_mi *)pc1)->minor == 5) {
#line 798
    goto case_5___0;
  }
#line 813
  if (((struct OPERAND_0_mi *)pc1)->minor == 6) {
#line 813
    goto case_6___0;
  }
#line 829
  if (((struct OPERAND_0_mi *)pc1)->minor == 7) {
#line 829
    goto case_7___0;
  }
#line 845
  if (((struct OPERAND_0_mi *)pc1)->minor == 8) {
#line 845
    goto case_8___0;
  }
#line 860
  if (((struct OPERAND_0_mi *)pc1)->minor == 9) {
#line 860
    goto case_9___0;
  }
#line 876
  if (((struct OPERAND_0_mi *)pc1)->minor == 10) {
#line 876
    goto case_10___0;
  }
#line 892
  if (((struct OPERAND_0_mi *)pc1)->minor == 11) {
#line 892
    goto case_11___0;
  }
#line 908
  if (((struct OPERAND_0_mi *)pc1)->minor == 12) {
#line 908
    goto case_12___0;
  }
#line 924
  if (((struct OPERAND_0_mi *)pc1)->minor == 13) {
#line 924
    goto case_13___0;
  }
#line 940
  if (((struct OPERAND_0_mi *)pc1)->minor == 14) {
#line 940
    goto case_14___0;
  }
#line 956
  if (((struct OPERAND_0_mi *)pc1)->minor == 15) {
#line 956
    goto case_15___0;
  }
#line 972
  if (((struct OPERAND_0_mi *)pc1)->minor == 16) {
#line 972
    goto case_16___0;
  }
#line 988
  if (((struct OPERAND_0_mi *)pc1)->minor == 17) {
#line 988
    goto case_17___0;
  }
#line 1003
  if (((struct OPERAND_0_mi *)pc1)->minor == 18) {
#line 1003
    goto case_18___0;
  }
#line 1019
  if (((struct OPERAND_0_mi *)pc1)->minor == 19) {
#line 1019
    goto case_19___0;
  }
#line 1035
  if (((struct OPERAND_0_mi *)pc1)->minor == 20) {
#line 1035
    goto case_20___0;
  }
#line 1051
  if (((struct OPERAND_0_mi *)pc1)->minor == 21) {
#line 1051
    goto case_21___0;
  }
#line 1067
  if (((struct OPERAND_0_mi *)pc1)->minor == 22) {
#line 1067
    goto case_22;
  }
#line 1083
  if (((struct OPERAND_0_mi *)pc1)->minor == 23) {
#line 1083
    goto case_23;
  }
#line 1134
  if (((struct OPERAND_0_mi *)pc1)->minor == 26) {
#line 1134
    goto case_26;
  }
#line 1151
  if (((struct OPERAND_0_mi *)pc1)->minor == 27) {
#line 1151
    goto case_27;
  }
#line 1169
  if (((struct OPERAND_0_mi *)pc1)->minor == 28) {
#line 1169
    goto case_28;
  }
#line 1186
  if (((struct OPERAND_0_mi *)pc1)->minor == 29) {
#line 1186
    goto case_29;
  }
#line 1202
  if (((struct OPERAND_0_mi *)pc1)->minor == 30) {
#line 1202
    goto case_30;
  }
#line 1218
  if (((struct OPERAND_0_mi *)pc1)->minor == 31) {
#line 1218
    goto case_31;
  }
#line 1644
  if (((struct OPERAND_0_mi *)pc1)->minor == 57) {
#line 1644
    goto case_57;
  }
#line 1660
  if (((struct OPERAND_0_mi *)pc1)->minor == 58) {
#line 1660
    goto case_58;
  }
#line 1677
  if (((struct OPERAND_0_mi *)pc1)->minor == 59) {
#line 1677
    goto case_59;
  }
#line 1693
  if (((struct OPERAND_0_mi *)pc1)->minor == 60) {
#line 1693
    goto case_60;
  }
#line 1745
  if (((struct OPERAND_0_mi *)pc1)->minor == 63) {
#line 1745
    goto case_63;
  }
#line 1761
  if (((struct OPERAND_0_mi *)pc1)->minor == 64) {
#line 1761
    goto case_64;
  }
#line 1778
  if (((struct OPERAND_0_mi *)pc1)->minor == 65) {
#line 1778
    goto case_65;
  }
#line 1794
  if (((struct OPERAND_0_mi *)pc1)->minor == 66) {
#line 1794
    goto case_66;
  }
#line 1811
  if (((struct OPERAND_0_mi *)pc1)->minor == 67) {
#line 1811
    goto case_67;
  }
#line 1827
  if (((struct OPERAND_0_mi *)pc1)->minor == 68) {
#line 1827
    goto case_68;
  }
#line 1845
  if (((struct OPERAND_0_mi *)pc1)->minor == 69) {
#line 1845
    goto case_69;
  }
#line 1861
  if (((struct OPERAND_0_mi *)pc1)->minor == 70) {
#line 1861
    goto case_70;
  }
#line 1877
  if (((struct OPERAND_0_mi *)pc1)->minor == 71) {
#line 1877
    goto case_71;
  }
#line 1893
  if (((struct OPERAND_0_mi *)pc1)->minor == 72) {
#line 1893
    goto case_72;
  }
#line 1911
  if (((struct OPERAND_0_mi *)pc1)->minor == 73) {
#line 1911
    goto case_73;
  }
#line 1927
  if (((struct OPERAND_0_mi *)pc1)->minor == 74) {
#line 1927
    goto case_74;
  }
#line 1944
  if (((struct OPERAND_0_mi *)pc1)->minor == 75) {
#line 1944
    goto case_75;
  }
#line 1960
  if (((struct OPERAND_0_mi *)pc1)->minor == 76) {
#line 1960
    goto case_76;
  }
#line 1977
  if (((struct OPERAND_0_mi *)pc1)->minor == 77) {
#line 1977
    goto case_77;
  }
#line 1993
  if (((struct OPERAND_0_mi *)pc1)->minor == 78) {
#line 1993
    goto case_78;
  }
#line 2011
  if (((struct OPERAND_0_mi *)pc1)->minor == 79) {
#line 2011
    goto case_79;
  }
#line 2027
  if (((struct OPERAND_0_mi *)pc1)->minor == 80) {
#line 2027
    goto case_80;
  }
#line 2044
  if (((struct OPERAND_0_mi *)pc1)->minor == 81) {
#line 2044
    goto case_81;
  }
#line 2060
  if (((struct OPERAND_0_mi *)pc1)->minor == 82) {
#line 2060
    goto case_82;
  }
#line 2077
  if (((struct OPERAND_0_mi *)pc1)->minor == 83) {
#line 2077
    goto case_83;
  }
#line 2093
  if (((struct OPERAND_0_mi *)pc1)->minor == 84) {
#line 2093
    goto case_84;
  }
#line 2111
  if (((struct OPERAND_0_mi *)pc1)->minor == 85) {
#line 2111
    goto case_85;
  }
#line 2127
  if (((struct OPERAND_0_mi *)pc1)->minor == 86) {
#line 2127
    goto case_86;
  }
#line 2143
  if (((struct OPERAND_0_mi *)pc1)->minor == 87) {
#line 2143
    goto case_87;
  }
#line 2159
  if (((struct OPERAND_0_mi *)pc1)->minor == 88) {
#line 2159
    goto case_88;
  }
#line 2244
  if (((struct OPERAND_0_mi *)pc1)->minor == 93) {
#line 2244
    goto case_93;
  }
#line 2260
  if (((struct OPERAND_0_mi *)pc1)->minor == 94) {
#line 2260
    goto case_94;
  }
#line 2277
  if (((struct OPERAND_0_mi *)pc1)->minor == 95) {
#line 2277
    goto case_95;
  }
#line 2295
  if (((struct OPERAND_0_mi *)pc1)->minor == 96) {
#line 2295
    goto case_96;
  }
#line 2311
  if (((struct OPERAND_0_mi *)pc1)->minor == 97) {
#line 2311
    goto case_97;
  }
#line 2327
  if (((struct OPERAND_0_mi *)pc1)->minor == 98) {
#line 2327
    goto case_98;
  }
#line 2343
  if (((struct OPERAND_0_mi *)pc1)->minor == 99) {
#line 2343
    goto case_99;
  }
#line 2359
  if (((struct OPERAND_0_mi *)pc1)->minor == 100) {
#line 2359
    goto case_100;
  }
#line 2375
  if (((struct OPERAND_0_mi *)pc1)->minor == 101) {
#line 2375
    goto case_101;
  }
#line 2391
  if (((struct OPERAND_0_mi *)pc1)->minor == 102) {
#line 2391
    goto case_102;
  }
#line 2476
  if (((struct OPERAND_0_mi *)pc1)->minor == 107) {
#line 2476
    goto case_107;
  }
#line 2492
  if (((struct OPERAND_0_mi *)pc1)->minor == 108) {
#line 2492
    goto case_108;
  }
#line 2508
  if (((struct OPERAND_0_mi *)pc1)->minor == 109) {
#line 2508
    goto case_109;
  }
#line 2524
  if (((struct OPERAND_0_mi *)pc1)->minor == 110) {
#line 2524
    goto case_110;
  }
#line 2541
  if (((struct OPERAND_0_mi *)pc1)->minor == 111) {
#line 2541
    goto case_111;
  }
#line 2559
  if (((struct OPERAND_0_mi *)pc1)->minor == 112) {
#line 2559
    goto case_112;
  }
#line 2576
  if (((struct OPERAND_0_mi *)pc1)->minor == 113) {
#line 2576
    goto case_113;
  }
#line 2592
  if (((struct OPERAND_0_mi *)pc1)->minor == 114) {
#line 2592
    goto case_114;
  }
#line 2608
  if (((struct OPERAND_0_mi *)pc1)->minor == 115) {
#line 2608
    goto case_115;
  }
#line 2624
  if (((struct OPERAND_0_mi *)pc1)->minor == 116) {
#line 2624
    goto case_116;
  }
#line 2640
  if (((struct OPERAND_0_mi *)pc1)->minor == 117) {
#line 2640
    goto case_117;
  }
#line 2656
  if (((struct OPERAND_0_mi *)pc1)->minor == 118) {
#line 2656
    goto case_118;
  }
#line 2741
  if (((struct OPERAND_0_mi *)pc1)->minor == 123) {
#line 2741
    goto case_123;
  }
#line 2757
  if (((struct OPERAND_0_mi *)pc1)->minor == 1124) {
#line 2757
    goto case_1124;
  }
#line 2773
  if (((struct OPERAND_0_mi *)pc1)->minor == 125) {
#line 2773
    goto case_125;
  }
#line 2789
  if (((struct OPERAND_0_mi *)pc1)->minor == 126) {
#line 2789
    goto case_126;
  }
#line 2806
  if (((struct OPERAND_0_mi *)pc1)->minor == 127) {
#line 2806
    goto case_127;
  }
#line 2824
  if (((struct OPERAND_0_mi *)pc1)->minor == 128) {
#line 2824
    goto case_128;
  }
#line 2841
  if (((struct OPERAND_0_mi *)pc1)->minor == 129) {
#line 2841
    goto case_129;
  }
#line 2857
  if (((struct OPERAND_0_mi *)pc1)->minor == 130) {
#line 2857
    goto case_130;
  }
#line 2909
  if (((struct OPERAND_0_mi *)pc1)->minor == 133) {
#line 2909
    goto case_133;
  }
#line 2926
  if (((struct OPERAND_0_mi *)pc1)->minor == 134) {
#line 2926
    goto case_134;
  }
#line 2944
  if (((struct OPERAND_0_mi *)pc1)->minor == 135) {
#line 2944
    goto case_135;
  }
#line 2961
  if (((struct OPERAND_0_mi *)pc1)->minor == 136) {
#line 2961
    goto case_136;
  }
#line 2977
  if (((struct OPERAND_0_mi *)pc1)->minor == 137) {
#line 2977
    goto case_137;
  }
#line 3029
  if (((struct OPERAND_0_mi *)pc1)->minor == 140) {
#line 3029
    goto case_140;
  }
#line 3046
  if (((struct OPERAND_0_mi *)pc1)->minor == 141) {
#line 3046
    goto case_141;
  }
#line 3064
  if (((struct OPERAND_0_mi *)pc1)->minor == 142) {
#line 3064
    goto case_142;
  }
#line 3081
  if (((struct OPERAND_0_mi *)pc1)->minor == 143) {
#line 3081
    goto case_143;
  }
#line 3097
  if (((struct OPERAND_0_mi *)pc1)->minor == 144) {
#line 3097
    goto case_144;
  }
#line 3182
  if (((struct OPERAND_0_mi *)pc1)->minor == 149) {
#line 3182
    goto case_149;
  }
#line 3198
  if (((struct OPERAND_0_mi *)pc1)->minor == 150) {
#line 3198
    goto case_150;
  }
#line 3216
  if (((struct OPERAND_0_mi *)pc1)->minor == 151) {
#line 3216
    goto case_151;
  }
#line 3234
  if (((struct OPERAND_0_mi *)pc1)->minor == 152) {
#line 3234
    goto case_152;
  }
#line 3251
  if (((struct OPERAND_0_mi *)pc1)->minor == 153) {
#line 3251
    goto case_153;
  }
#line 3267
  if (((struct OPERAND_0_mi *)pc1)->minor == 154) {
#line 3267
    goto case_154;
  }
#line 3284
  if (((struct OPERAND_0_mi *)pc1)->minor == 155) {
#line 3284
    goto case_155;
  }
#line 3300
  if (((struct OPERAND_0_mi *)pc1)->minor == 156) {
#line 3300
    goto case_156;
  }
#line 3352
  if (((struct OPERAND_0_mi *)pc1)->minor == 159) {
#line 3352
    goto case_159;
  }
#line 3368
  if (((struct OPERAND_0_mi *)pc1)->minor == 160) {
#line 3368
    goto case_160;
  }
#line 3385
  if (((struct OPERAND_0_mi *)pc1)->minor == 161) {
#line 3385
    goto case_161;
  }
#line 3403
  if (((struct OPERAND_0_mi *)pc1)->minor == 162) {
#line 3403
    goto case_162;
  }
#line 3420
  if (((struct OPERAND_0_mi *)pc1)->minor == 163) {
#line 3420
    goto case_163;
  }
#line 3436
  if (((struct OPERAND_0_mi *)pc1)->minor == 164) {
#line 3436
    goto case_164;
  }
#line 3452
  if (((struct OPERAND_0_mi *)pc1)->minor == 165) {
#line 3452
    goto case_165;
  }
#line 3468
  if (((struct OPERAND_0_mi *)pc1)->minor == 166) {
#line 3468
    goto case_166;
  }
#line 3484
  if (((struct OPERAND_0_mi *)pc1)->minor == 167) {
#line 3484
    goto case_167;
  }
#line 3501
  if (((struct OPERAND_0_mi *)pc1)->minor == 168) {
#line 3501
    goto case_168;
  }
#line 3517
  if (((struct OPERAND_0_mi *)pc1)->minor == 169) {
#line 3517
    goto case_169;
  }
#line 3570
  if (((struct OPERAND_0_mi *)pc1)->minor == 172) {
#line 3570
    goto case_172;
  }
#line 3586
  if (((struct OPERAND_0_mi *)pc1)->minor == 173) {
#line 3586
    goto case_173;
  }
#line 3640
  if (((struct OPERAND_0_mi *)pc1)->minor == 176) {
#line 3640
    goto case_176;
  }
#line 3656
  if (((struct OPERAND_0_mi *)pc1)->minor == 177) {
#line 3656
    goto case_177;
  }
#line 3674
  if (((struct OPERAND_0_mi *)pc1)->minor == 178) {
#line 3674
    goto case_178;
  }
#line 3690
  if (((struct OPERAND_0_mi *)pc1)->minor == 179) {
#line 3690
    goto case_179;
  }
#line 3707
  if (((struct OPERAND_0_mi *)pc1)->minor == 180) {
#line 3707
    goto case_180;
  }
#line 3723
  if (((struct OPERAND_0_mi *)pc1)->minor == 181) {
#line 3723
    goto case_181;
  }
#line 3740
  if (((struct OPERAND_0_mi *)pc1)->minor == 182) {
#line 3740
    goto case_182;
  }
#line 3756
  if (((struct OPERAND_0_mi *)pc1)->minor == 183) {
#line 3756
    goto case_183;
  }
#line 3773
  if (((struct OPERAND_0_mi *)pc1)->minor == 184) {
#line 3773
    goto case_184;
  }
#line 3789
  if (((struct OPERAND_0_mi *)pc1)->minor == 185) {
#line 3789
    goto case_185;
  }
#line 3806
  if (((struct OPERAND_0_mi *)pc1)->minor == 186) {
#line 3806
    goto case_186;
  }
#line 3822
  if (((struct OPERAND_0_mi *)pc1)->minor == 187) {
#line 3822
    goto case_187;
  }
#line 3839
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 720
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 721
  *((double *)tmp) = (double )*((int *)*ast);
#line 722
  *ast = tmp;
#line 731
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 732
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
  {
#line 736
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 737
  *((double *)tmp) = (double )*((int *)*(ast + sizeof(char *)));
#line 738
  *(ast + sizeof(char *)) = tmp;
#line 747
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 748
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 752
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 753
  *((int *)tmp) = (int )*((double *)*ast);
#line 754
  *ast = tmp;
#line 762
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 763
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
  {
#line 767
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 768
  *((float *)tmp) = (float )*((int *)*ast);
#line 769
  *ast = tmp;
#line 778
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 779
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
  {
#line 783
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 784
  *((float *)tmp) = (float )*((int *)*(ast + sizeof(char *)));
#line 785
  *(ast + sizeof(char *)) = tmp;
#line 794
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 795
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
  {
#line 799
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 800
  *((int *)tmp) = (int )*((float *)*ast);
#line 801
  *ast = tmp;
#line 809
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 810
  goto switch_break___1;
  case_6___0: /* CIL Label */ 
  {
#line 814
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 815
  *((double *)tmp) = (double )*((float *)*ast);
#line 816
  *ast = tmp;
#line 825
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 826
  goto switch_break___1;
  case_7___0: /* CIL Label */ 
  {
#line 830
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 831
  *((double *)tmp) = (double )*((float *)*(ast + sizeof(char *)));
#line 832
  *(ast + sizeof(char *)) = tmp;
#line 841
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 842
  goto switch_break___1;
  case_8___0: /* CIL Label */ 
  {
#line 846
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 847
  *((float *)tmp) = (float )*((double *)*ast);
#line 848
  *ast = tmp;
#line 856
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 857
  goto switch_break___1;
  case_9___0: /* CIL Label */ 
  {
#line 861
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 862
  *((int *)tmp) = (int )*(*ast);
#line 863
  *ast = tmp;
#line 872
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 873
  goto switch_break___1;
  case_10___0: /* CIL Label */ 
  {
#line 877
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 878
  *((int *)tmp) = (int )*(*(ast + sizeof(char *)));
#line 879
  *(ast + sizeof(char *)) = tmp;
#line 888
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 889
  goto switch_break___1;
  case_11___0: /* CIL Label */ 
  {
#line 893
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 894
  *tmp = (char )*((int *)*ast);
#line 895
  *ast = tmp;
#line 904
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 905
  goto switch_break___1;
  case_12___0: /* CIL Label */ 
  {
#line 909
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 910
  *((double *)tmp) = (double )*(*ast);
#line 911
  *ast = tmp;
#line 920
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 921
  goto switch_break___1;
  case_13___0: /* CIL Label */ 
  {
#line 925
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 926
  *((double *)tmp) = (double )*(*(ast + sizeof(char *)));
#line 927
  *(ast + sizeof(char *)) = tmp;
#line 936
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 937
  goto switch_break___1;
  case_14___0: /* CIL Label */ 
  {
#line 941
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 942
  *tmp = (char )*((double *)*ast);
#line 943
  *ast = tmp;
#line 952
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 953
  goto switch_break___1;
  case_15___0: /* CIL Label */ 
  {
#line 957
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 958
  *((float *)tmp) = (float )*(*ast);
#line 959
  *ast = tmp;
#line 968
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 969
  goto switch_break___1;
  case_16___0: /* CIL Label */ 
  {
#line 973
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 974
  *((float *)tmp) = (float )*(*(ast + sizeof(char *)));
#line 975
  *(ast + sizeof(char *)) = tmp;
#line 984
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 985
  goto switch_break___1;
  case_17___0: /* CIL Label */ 
  {
#line 989
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 990
  *tmp = (char )*((float *)*ast);
#line 991
  *ast = tmp;
#line 999
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1000
  goto switch_break___1;
  case_18___0: /* CIL Label */ 
  {
#line 1004
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 1005
  *((double *)tmp) = (double )*((unsigned int *)*ast);
#line 1006
  *ast = tmp;
#line 1015
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1016
  goto switch_break___1;
  case_19___0: /* CIL Label */ 
  {
#line 1020
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 1021
  *((double *)tmp) = (double )*((unsigned int *)*(ast + sizeof(char *)));
#line 1022
  *(ast + sizeof(char *)) = tmp;
#line 1031
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1032
  goto switch_break___1;
  case_20___0: /* CIL Label */ 
  {
#line 1036
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 1037
  *((float *)tmp) = (float )*((unsigned int *)*ast);
#line 1038
  *ast = tmp;
#line 1047
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1048
  goto switch_break___1;
  case_21___0: /* CIL Label */ 
  {
#line 1052
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 1053
  *((float *)tmp) = (float )*((unsigned int *)*(ast + sizeof(char *)));
#line 1054
  *(ast + sizeof(char *)) = tmp;
#line 1063
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1064
  goto switch_break___1;
  case_22: /* CIL Label */ 
  {
#line 1068
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 1069
  *((long *)tmp) = (long )*((unsigned int *)*ast);
#line 1070
  *ast = tmp;
#line 1079
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1080
  goto switch_break___1;
  case_23: /* CIL Label */ 
  {
#line 1084
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 1085
  *((long *)tmp) = (long )*((unsigned int *)*(ast + sizeof(char *)));
#line 1086
  *(ast + sizeof(char *)) = tmp;
#line 1095
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1096
  goto switch_break___1;
  case_26: /* CIL Label */ 
  {
#line 1135
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 1136
  *((int *)tmp) = (int )*((unsigned int *)*ast);
#line 1137
  *ast = tmp;
#line 1146
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1147
  goto switch_break___1;
  case_27: /* CIL Label */ 
  {
#line 1152
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 1153
  *((short *)tmp) = (short )*((unsigned int *)*ast);
#line 1154
  *ast = tmp;
#line 1163
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1164
  goto switch_break___1;
  case_28: /* CIL Label */ 
  {
#line 1170
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 1171
  *((unsigned short *)tmp) = (unsigned short )*((unsigned int *)*ast);
#line 1172
  *ast = tmp;
#line 1181
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1182
  goto switch_break___1;
  case_29: /* CIL Label */ 
  {
#line 1187
  move_stack_aligned(& tmp, (int )(- sizeof(char )));
#line 1188
  *tmp = (char )*((unsigned int *)*ast);
#line 1189
  *ast = tmp;
#line 1198
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1199
  goto switch_break___1;
  case_30: /* CIL Label */ 
  {
#line 1203
  move_stack_aligned(& tmp, (int )(- sizeof(signed char )));
#line 1204
  *((signed char *)tmp) = (signed char )*((unsigned int *)*ast);
#line 1205
  *ast = tmp;
#line 1214
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1215
  goto switch_break___1;
  case_31: /* CIL Label */ 
  {
#line 1219
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned char )));
#line 1220
  *((unsigned char *)tmp) = (unsigned char )*((unsigned int *)*ast);
#line 1221
  *ast = tmp;
#line 1230
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1231
  goto switch_break___1;
  case_57: /* CIL Label */ 
  {
#line 1645
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 1646
  *((double *)tmp) = (double )*((short *)*ast);
#line 1647
  *ast = tmp;
#line 1656
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1657
  goto switch_break___1;
  case_58: /* CIL Label */ 
  {
#line 1661
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 1662
  *((double *)tmp) = (double )*((short *)*(ast + sizeof(char *)));
#line 1664
  *(ast + sizeof(char *)) = tmp;
#line 1673
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1674
  goto switch_break___1;
  case_59: /* CIL Label */ 
  {
#line 1678
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 1679
  *((float *)tmp) = (float )*((short *)*ast);
#line 1680
  *ast = tmp;
#line 1689
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1690
  goto switch_break___1;
  case_60: /* CIL Label */ 
  {
#line 1694
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 1695
  *((float *)tmp) = (float )*((short *)*(ast + sizeof(char *)));
#line 1697
  *(ast + sizeof(char *)) = tmp;
#line 1706
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1707
  goto switch_break___1;
  case_63: /* CIL Label */ 
  {
#line 1746
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 1747
  *((unsigned long *)tmp) = (unsigned long )*((short *)*ast);
#line 1748
  *ast = tmp;
#line 1757
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1758
  goto switch_break___1;
  case_64: /* CIL Label */ 
  {
#line 1762
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 1763
  *((unsigned long *)tmp) = (unsigned long )*((short *)*(ast + sizeof(char *)));
#line 1765
  *(ast + sizeof(char *)) = tmp;
#line 1774
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1775
  goto switch_break___1;
  case_65: /* CIL Label */ 
  {
#line 1779
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 1780
  *((int *)tmp) = (int )*((short *)*ast);
#line 1781
  *ast = tmp;
#line 1790
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1791
  goto switch_break___1;
  case_66: /* CIL Label */ 
  {
#line 1795
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 1796
  *((int *)tmp) = (int )*((short *)*(ast + sizeof(char *)));
#line 1798
  *(ast + sizeof(char *)) = tmp;
#line 1807
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1808
  goto switch_break___1;
  case_67: /* CIL Label */ 
  {
#line 1812
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 1813
  *((unsigned int *)tmp) = (unsigned int )*((short *)*ast);
#line 1814
  *ast = tmp;
#line 1823
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1824
  goto switch_break___1;
  case_68: /* CIL Label */ 
  {
#line 1828
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 1829
  *((unsigned int *)tmp) = (unsigned int )*((short *)*(ast + sizeof(char *)));
#line 1831
  *(ast + sizeof(char *)) = tmp;
#line 1841
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1842
  goto switch_break___1;
  case_69: /* CIL Label */ 
  {
#line 1846
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 1847
  *((unsigned short *)tmp) = (unsigned short )*((short *)*ast);
#line 1848
  *ast = tmp;
#line 1857
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1858
  goto switch_break___1;
  case_70: /* CIL Label */ 
  {
#line 1862
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 1863
  *tmp = (char )*((short *)*ast);
#line 1864
  *ast = tmp;
#line 1873
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1874
  goto switch_break___1;
  case_71: /* CIL Label */ 
  {
#line 1878
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 1879
  *((unsigned char *)tmp) = (unsigned char )*((short *)*ast);
#line 1880
  *ast = tmp;
#line 1889
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1890
  goto switch_break___1;
  case_72: /* CIL Label */ 
  {
#line 1894
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 1895
  *((signed char *)tmp) = (signed char )*((short *)*ast);
#line 1896
  *ast = tmp;
#line 1905
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1906
  goto switch_break___1;
  case_73: /* CIL Label */ 
  {
#line 1912
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 1913
  *((double *)tmp) = (double )*((unsigned short *)*ast);
#line 1914
  *ast = tmp;
#line 1923
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1924
  goto switch_break___1;
  case_74: /* CIL Label */ 
  {
#line 1928
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 1929
  *((double *)tmp) = (double )*((unsigned short *)*(ast + sizeof(char *)));
#line 1931
  *(ast + sizeof(char *)) = tmp;
#line 1940
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1941
  goto switch_break___1;
  case_75: /* CIL Label */ 
  {
#line 1945
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 1946
  *((float *)tmp) = (float )*((unsigned short *)*ast);
#line 1947
  *ast = tmp;
#line 1956
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1957
  goto switch_break___1;
  case_76: /* CIL Label */ 
  {
#line 1961
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 1962
  *((float *)tmp) = (float )*((unsigned short *)*(ast + sizeof(char *)));
#line 1964
  *(ast + sizeof(char *)) = tmp;
#line 1973
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1974
  goto switch_break___1;
  case_77: /* CIL Label */ 
  {
#line 1978
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 1979
  *((long *)tmp) = (long )*((unsigned short *)*ast);
#line 1980
  *ast = tmp;
#line 1989
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 1990
  goto switch_break___1;
  case_78: /* CIL Label */ 
  {
#line 1994
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 1995
  *((long *)tmp) = (long )*((unsigned short *)*(ast + sizeof(char *)));
#line 1997
  *(ast + sizeof(char *)) = tmp;
#line 2007
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2008
  goto switch_break___1;
  case_79: /* CIL Label */ 
  {
#line 2012
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 2013
  *((unsigned long *)tmp) = (unsigned long )*((unsigned short *)*ast);
#line 2014
  *ast = tmp;
#line 2023
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2024
  goto switch_break___1;
  case_80: /* CIL Label */ 
  {
#line 2028
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 2029
  *((unsigned long *)tmp) = (unsigned long )*((unsigned short *)*(ast + sizeof(char *)));
#line 2031
  *(ast + sizeof(char *)) = tmp;
#line 2040
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2041
  goto switch_break___1;
  case_81: /* CIL Label */ 
  {
#line 2045
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2046
  *((int *)tmp) = (int )*((unsigned short *)*ast);
#line 2047
  *ast = tmp;
#line 2056
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2057
  goto switch_break___1;
  case_82: /* CIL Label */ 
  {
#line 2061
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2062
  *((int *)tmp) = (int )*((unsigned short *)*(ast + sizeof(char *)));
#line 2064
  *(ast + sizeof(char *)) = tmp;
#line 2073
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2074
  goto switch_break___1;
  case_83: /* CIL Label */ 
  {
#line 2078
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 2079
  *((unsigned int *)tmp) = (unsigned int )*((unsigned short *)*ast);
#line 2080
  *ast = tmp;
#line 2089
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2090
  goto switch_break___1;
  case_84: /* CIL Label */ 
  {
#line 2094
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 2095
  *((unsigned int *)tmp) = (unsigned int )*((unsigned short *)*(ast + sizeof(char *)));
#line 2097
  *(ast + sizeof(char *)) = tmp;
#line 2107
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2108
  goto switch_break___1;
  case_85: /* CIL Label */ 
  {
#line 2112
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 2113
  *((short *)tmp) = (short )*((unsigned short *)*ast);
#line 2114
  *ast = tmp;
#line 2123
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2124
  goto switch_break___1;
  case_86: /* CIL Label */ 
  {
#line 2128
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2129
  *tmp = (char )*((unsigned short *)*ast);
#line 2130
  *ast = tmp;
#line 2139
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2140
  goto switch_break___1;
  case_87: /* CIL Label */ 
  {
#line 2144
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2145
  *((unsigned char *)tmp) = (unsigned char )*((unsigned short *)*ast);
#line 2146
  *ast = tmp;
#line 2155
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2156
  goto switch_break___1;
  case_88: /* CIL Label */ 
  {
#line 2160
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2161
  *((signed char *)tmp) = (signed char )*((unsigned short *)*ast);
#line 2162
  *ast = tmp;
#line 2171
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2172
  goto switch_break___1;
  case_93: /* CIL Label */ 
  {
#line 2245
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 2246
  *((unsigned int *)tmp) = (unsigned int )*(*ast);
#line 2247
  *ast = tmp;
#line 2256
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2257
  goto switch_break___1;
  case_94: /* CIL Label */ 
  {
#line 2261
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 2262
  *((unsigned int *)tmp) = (unsigned int )*(*(ast + sizeof(char *)));
#line 2263
  *(ast + sizeof(char *)) = tmp;
#line 2272
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2273
  goto switch_break___1;
  case_95: /* CIL Label */ 
  {
#line 2278
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 2279
  *((short *)tmp) = (short )*(*ast);
#line 2280
  *ast = tmp;
#line 2289
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2290
  goto switch_break___1;
  case_96: /* CIL Label */ 
  {
#line 2296
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 2297
  *((unsigned short *)tmp) = (unsigned short )*(*ast);
#line 2298
  *ast = tmp;
#line 2307
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2308
  goto switch_break___1;
  case_97: /* CIL Label */ 
  {
#line 2312
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2313
  *((signed char *)tmp) = (signed char )*(*ast);
#line 2314
  *ast = tmp;
#line 2323
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2324
  goto switch_break___1;
  case_98: /* CIL Label */ 
  {
#line 2328
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2329
  *((unsigned char *)tmp) = (unsigned char )*(*ast);
#line 2330
  *ast = tmp;
#line 2339
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2340
  goto switch_break___1;
  case_99: /* CIL Label */ 
  {
#line 2344
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 2345
  *((double *)tmp) = (double )*((signed char *)*ast);
#line 2346
  *ast = tmp;
#line 2355
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2356
  goto switch_break___1;
  case_100: /* CIL Label */ 
  {
#line 2360
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 2361
  *((double *)tmp) = (double )*((signed char *)*(ast + sizeof(char *)));
#line 2362
  *(ast + sizeof(char *)) = tmp;
#line 2371
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2372
  goto switch_break___1;
  case_101: /* CIL Label */ 
  {
#line 2376
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 2377
  *((float *)tmp) = (float )*((signed char *)*ast);
#line 2378
  *ast = tmp;
#line 2387
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2388
  goto switch_break___1;
  case_102: /* CIL Label */ 
  {
#line 2392
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 2393
  *((float *)tmp) = (float )*((signed char *)*(ast + sizeof(char *)));
#line 2394
  *(ast + sizeof(char *)) = tmp;
#line 2403
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2404
  goto switch_break___1;
  case_107: /* CIL Label */ 
  {
#line 2477
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2478
  *((int *)tmp) = (int )*((signed char *)*ast);
#line 2479
  *ast = tmp;
#line 2488
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2489
  goto switch_break___1;
  case_108: /* CIL Label */ 
  {
#line 2493
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2494
  *((int *)tmp) = (int )*((signed char *)*(ast + sizeof(char *)));
#line 2495
  *(ast + sizeof(char *)) = tmp;
#line 2504
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2505
  goto switch_break___1;
  case_109: /* CIL Label */ 
  {
#line 2509
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 2510
  *((unsigned int *)tmp) = (unsigned int )*((signed char *)*ast);
#line 2511
  *ast = tmp;
#line 2520
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2521
  goto switch_break___1;
  case_110: /* CIL Label */ 
  {
#line 2525
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 2526
  *((unsigned int *)tmp) = (unsigned int )*((signed char *)*(ast + sizeof(char *)));
#line 2527
  *(ast + sizeof(char *)) = tmp;
#line 2536
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2537
  goto switch_break___1;
  case_111: /* CIL Label */ 
  {
#line 2542
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 2543
  *((short *)tmp) = (short )*((signed char *)*ast);
#line 2544
  *ast = tmp;
#line 2553
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2554
  goto switch_break___1;
  case_112: /* CIL Label */ 
  {
#line 2560
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 2561
  *((unsigned short *)tmp) = (unsigned short )*((signed char *)*ast);
#line 2562
  *ast = tmp;
#line 2571
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2572
  goto switch_break___1;
  case_113: /* CIL Label */ 
  {
#line 2577
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2578
  *tmp = (char )*((signed char *)*ast);
#line 2579
  *ast = tmp;
#line 2588
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2589
  goto switch_break___1;
  case_114: /* CIL Label */ 
  {
#line 2593
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2594
  *((unsigned char *)tmp) = (unsigned char )*((signed char *)*ast);
#line 2595
  *ast = tmp;
#line 2604
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2605
  goto switch_break___1;
  case_115: /* CIL Label */ 
  {
#line 2609
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 2610
  *((double *)tmp) = (double )*((unsigned char *)*ast);
#line 2611
  *ast = tmp;
#line 2620
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2621
  goto switch_break___1;
  case_116: /* CIL Label */ 
  {
#line 2625
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 2626
  *((double *)tmp) = (double )*((unsigned char *)*(ast + sizeof(char *)));
#line 2627
  *(ast + sizeof(char *)) = tmp;
#line 2636
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2637
  goto switch_break___1;
  case_117: /* CIL Label */ 
  {
#line 2641
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 2642
  *((float *)tmp) = (float )*((unsigned char *)*ast);
#line 2643
  *ast = tmp;
#line 2652
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2653
  goto switch_break___1;
  case_118: /* CIL Label */ 
  {
#line 2657
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 2658
  *((float *)tmp) = (float )*((unsigned char *)*(ast + sizeof(char *)));
#line 2659
  *(ast + sizeof(char *)) = tmp;
#line 2668
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2669
  goto switch_break___1;
  case_123: /* CIL Label */ 
  {
#line 2742
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2743
  *((int *)tmp) = (int )*((unsigned char *)*ast);
#line 2744
  *ast = tmp;
#line 2753
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2754
  goto switch_break___1;
  case_1124: /* CIL Label */ 
  {
#line 2758
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2759
  *((int *)tmp) = (int )*((unsigned char *)*(ast + sizeof(char *)));
#line 2760
  *(ast + sizeof(char *)) = tmp;
#line 2769
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2770
  goto switch_break___1;
  case_125: /* CIL Label */ 
  {
#line 2774
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 2775
  *((unsigned int *)tmp) = (unsigned int )*((unsigned char *)*ast);
#line 2776
  *ast = tmp;
#line 2785
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2786
  goto switch_break___1;
  case_126: /* CIL Label */ 
  {
#line 2790
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 2791
  *((unsigned int *)tmp) = (unsigned int )*((unsigned char *)*(ast + sizeof(char *)));
#line 2792
  *(ast + sizeof(char *)) = tmp;
#line 2801
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2802
  goto switch_break___1;
  case_127: /* CIL Label */ 
  {
#line 2807
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 2808
  *((short *)tmp) = (short )*((unsigned char *)*ast);
#line 2809
  *ast = tmp;
#line 2818
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2819
  goto switch_break___1;
  case_128: /* CIL Label */ 
  {
#line 2825
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 2826
  *((unsigned short *)tmp) = (unsigned short )*((unsigned char *)*ast);
#line 2827
  *ast = tmp;
#line 2836
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2837
  goto switch_break___1;
  case_129: /* CIL Label */ 
  {
#line 2842
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2843
  *tmp = (char )*((unsigned char *)*ast);
#line 2844
  *ast = tmp;
#line 2853
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2854
  goto switch_break___1;
  case_130: /* CIL Label */ 
  {
#line 2858
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 2859
  *((signed char *)tmp) = (signed char )*((unsigned char *)*ast);
#line 2860
  *ast = tmp;
#line 2869
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2870
  goto switch_break___1;
  case_133: /* CIL Label */ 
  {
#line 2910
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 2911
  *((unsigned int *)tmp) = (unsigned int )*((double *)*ast);
#line 2912
  *ast = tmp;
#line 2921
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2922
  goto switch_break___1;
  case_134: /* CIL Label */ 
  {
#line 2927
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 2928
  *((short *)tmp) = (short )*((double *)*ast);
#line 2929
  *ast = tmp;
#line 2938
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2939
  goto switch_break___1;
  case_135: /* CIL Label */ 
  {
#line 2945
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 2946
  *((unsigned short *)tmp) = (unsigned short )*((double *)*ast);
#line 2947
  *ast = tmp;
#line 2956
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2957
  goto switch_break___1;
  case_136: /* CIL Label */ 
  {
#line 2962
  move_stack_aligned(& tmp, (int )(- sizeof(signed char )));
#line 2963
  *((signed char *)tmp) = (signed char )*((double *)*ast);
#line 2964
  *ast = tmp;
#line 2973
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2974
  goto switch_break___1;
  case_137: /* CIL Label */ 
  {
#line 2978
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned char )));
#line 2979
  *((unsigned char *)tmp) = (unsigned char )*((double *)*ast);
#line 2980
  *ast = tmp;
#line 2989
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 2990
  goto switch_break___1;
  case_140: /* CIL Label */ 
  {
#line 3030
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 3031
  *((unsigned int *)tmp) = (unsigned int )*((float *)*ast);
#line 3032
  *ast = tmp;
#line 3041
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3042
  goto switch_break___1;
  case_141: /* CIL Label */ 
  {
#line 3047
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 3048
  *((short *)tmp) = (short )*((float *)*ast);
#line 3049
  *ast = tmp;
#line 3058
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3059
  goto switch_break___1;
  case_142: /* CIL Label */ 
  {
#line 3065
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 3066
  *((unsigned short *)tmp) = (unsigned short )*((float *)*ast);
#line 3067
  *ast = tmp;
#line 3076
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3077
  goto switch_break___1;
  case_143: /* CIL Label */ 
  {
#line 3082
  move_stack_aligned(& tmp, (int )(- sizeof(signed char )));
#line 3083
  *((signed char *)tmp) = (signed char )*((float *)*ast);
#line 3084
  *ast = tmp;
#line 3093
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3094
  goto switch_break___1;
  case_144: /* CIL Label */ 
  {
#line 3098
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned char )));
#line 3099
  *((unsigned char *)tmp) = (unsigned char )*((float *)*ast);
#line 3100
  *ast = tmp;
#line 3109
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3110
  goto switch_break___1;
  case_149: /* CIL Label */ 
  {
#line 3183
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 3184
  *((unsigned int *)tmp) = (unsigned int )*((int *)*ast);
#line 3185
  *ast = tmp;
#line 3194
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3195
  goto switch_break___1;
  case_150: /* CIL Label */ 
  {
#line 3199
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 3200
  *((unsigned int *)tmp) = (unsigned int )*((int *)*(ast + sizeof(char *)));
#line 3202
  *(ast + sizeof(char *)) = tmp;
#line 3211
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3212
  goto switch_break___1;
  case_151: /* CIL Label */ 
  {
#line 3217
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 3218
  *((short *)tmp) = (short )*((int *)*ast);
#line 3219
  *ast = tmp;
#line 3228
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3229
  goto switch_break___1;
  case_152: /* CIL Label */ 
  {
#line 3235
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 3236
  *((unsigned short *)tmp) = (unsigned short )*((int *)*ast);
#line 3237
  *ast = tmp;
#line 3246
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3247
  goto switch_break___1;
  case_153: /* CIL Label */ 
  {
#line 3252
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 3253
  *((signed char *)tmp) = (signed char )*((int *)*ast);
#line 3254
  *ast = tmp;
#line 3263
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3264
  goto switch_break___1;
  case_154: /* CIL Label */ 
  {
#line 3268
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 3269
  *((unsigned char *)tmp) = (unsigned char )*((int *)*ast);
#line 3270
  *ast = tmp;
#line 3279
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3280
  goto switch_break___1;
  case_155: /* CIL Label */ 
  {
#line 3285
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 3286
  *((double *)tmp) = (double )*((long double *)*ast);
#line 3287
  *ast = tmp;
#line 3296
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3297
  goto switch_break___1;
  case_156: /* CIL Label */ 
  {
#line 3301
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 3302
  *((float *)tmp) = (float )*((long double *)*ast);
#line 3303
  *ast = tmp;
#line 3312
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3313
  goto switch_break___1;
  case_159: /* CIL Label */ 
  {
#line 3353
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 3354
  *((int *)tmp) = (int )*((long double *)*ast);
#line 3355
  *ast = tmp;
#line 3364
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3365
  goto switch_break___1;
  case_160: /* CIL Label */ 
  {
#line 3369
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 3370
  *((unsigned int *)tmp) = (unsigned int )*((long double *)*ast);
#line 3371
  *ast = tmp;
#line 3380
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3381
  goto switch_break___1;
  case_161: /* CIL Label */ 
  {
#line 3386
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 3387
  *((short *)tmp) = (short )*((long double *)*ast);
#line 3388
  *ast = tmp;
#line 3397
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3398
  goto switch_break___1;
  case_162: /* CIL Label */ 
  {
#line 3404
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 3405
  *((unsigned short *)tmp) = (unsigned short )*((long double *)*ast);
#line 3406
  *ast = tmp;
#line 3415
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3416
  goto switch_break___1;
  case_163: /* CIL Label */ 
  {
#line 3421
  move_stack_aligned(& tmp, (int )(- sizeof(char )));
#line 3422
  *tmp = (char )*((long double *)*ast);
#line 3423
  *ast = tmp;
#line 3432
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3433
  goto switch_break___1;
  case_164: /* CIL Label */ 
  {
#line 3437
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned char )));
#line 3438
  *((unsigned char *)tmp) = (unsigned char )*((long double *)*ast);
#line 3439
  *ast = tmp;
#line 3448
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3449
  goto switch_break___1;
  case_165: /* CIL Label */ 
  {
#line 3453
  move_stack_aligned(& tmp, (int )(- sizeof(signed char )));
#line 3454
  *((signed char *)tmp) = (signed char )*((long double *)*ast);
#line 3455
  *ast = tmp;
#line 3464
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3465
  goto switch_break___1;
  case_166: /* CIL Label */ 
  {
#line 3469
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3470
  *((long double *)tmp) = (long double )*((int *)*ast);
#line 3471
  *ast = tmp;
#line 3480
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3481
  goto switch_break___1;
  case_167: /* CIL Label */ 
  {
#line 3485
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3486
  *((long double *)tmp) = (long double )*((int *)*(ast + sizeof(char *)));
#line 3488
  *(ast + sizeof(char *)) = tmp;
#line 3497
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3498
  goto switch_break___1;
  case_168: /* CIL Label */ 
  {
#line 3502
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3503
  *((long double *)tmp) = (long double )*((unsigned int *)*ast);
#line 3504
  *ast = tmp;
#line 3513
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3514
  goto switch_break___1;
  case_169: /* CIL Label */ 
  {
#line 3518
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3519
  *((long double *)tmp) = (long double )*((unsigned int *)*(ast + sizeof(char *)));
#line 3521
  *(ast + sizeof(char *)) = tmp;
#line 3530
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3531
  goto switch_break___1;
  case_172: /* CIL Label */ 
  {
#line 3571
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3572
  *((long double *)tmp) = (long double )*((short *)*ast);
#line 3573
  *ast = tmp;
#line 3582
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3583
  goto switch_break___1;
  case_173: /* CIL Label */ 
  {
#line 3587
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3588
  *((long double *)tmp) = (long double )*((short *)*(ast + sizeof(char *)));
#line 3590
  *(ast + sizeof(char *)) = tmp;
#line 3599
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3600
  goto switch_break___1;
  case_176: /* CIL Label */ 
  {
#line 3641
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3642
  *((long double *)tmp) = (long double )*((unsigned short *)*ast);
#line 3643
  *ast = tmp;
#line 3652
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3653
  goto switch_break___1;
  case_177: /* CIL Label */ 
  {
#line 3657
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3658
  *((long double *)tmp) = (long double )*((unsigned short *)*(ast + sizeof(char *)));
#line 3660
  *(ast + sizeof(char *)) = tmp;
#line 3669
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3670
  goto switch_break___1;
  case_178: /* CIL Label */ 
  {
#line 3675
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3676
  *((long double *)tmp) = (long double )*((double *)*ast);
#line 3677
  *ast = tmp;
#line 3686
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3687
  goto switch_break___1;
  case_179: /* CIL Label */ 
  {
#line 3691
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3692
  *((long double *)tmp) = (long double )*((double *)*(ast + sizeof(char *)));
#line 3694
  *(ast + sizeof(char *)) = tmp;
#line 3703
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3704
  goto switch_break___1;
  case_180: /* CIL Label */ 
  {
#line 3708
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3709
  *((long double *)tmp) = (long double )*((float *)*ast);
#line 3710
  *ast = tmp;
#line 3719
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3720
  goto switch_break___1;
  case_181: /* CIL Label */ 
  {
#line 3724
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3725
  *((long double *)tmp) = (long double )*((float *)*(ast + sizeof(char *)));
#line 3727
  *(ast + sizeof(char *)) = tmp;
#line 3736
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3737
  goto switch_break___1;
  case_182: /* CIL Label */ 
  {
#line 3741
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3742
  *((long double *)tmp) = (long double )*(*ast);
#line 3743
  *ast = tmp;
#line 3752
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3753
  goto switch_break___1;
  case_183: /* CIL Label */ 
  {
#line 3757
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3758
  *((long double *)tmp) = (long double )*(*(ast + sizeof(char *)));
#line 3760
  *(ast + sizeof(char *)) = tmp;
#line 3769
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3770
  goto switch_break___1;
  case_184: /* CIL Label */ 
  {
#line 3774
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3775
  *((long double *)tmp) = (long double )*((signed char *)*ast);
#line 3776
  *ast = tmp;
#line 3785
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3786
  goto switch_break___1;
  case_185: /* CIL Label */ 
  {
#line 3790
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3791
  *((long double *)tmp) = (long double )*((signed char *)*(ast + sizeof(char *)));
#line 3793
  *(ast + sizeof(char *)) = tmp;
#line 3802
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3803
  goto switch_break___1;
  case_186: /* CIL Label */ 
  {
#line 3807
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3808
  *((long double *)tmp) = (long double )*((unsigned char *)*ast);
#line 3809
  *ast = tmp;
#line 3818
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3819
  goto switch_break___1;
  case_187: /* CIL Label */ 
  {
#line 3823
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 3824
  *((long double *)tmp) = (long double )*((unsigned char *)*(ast + sizeof(char *)));
#line 3826
  *(ast + sizeof(char *)) = tmp;
#line 3835
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 3836
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 3840
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           3840);
#line 3841
  error_message(5001);
#line 3842
  abort();
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 3844
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 3849
  if (((struct OPERAND_1_mi *)pc1)->minor == 0) {
#line 3849
    goto case_0___1;
  }
#line 3864
  if (((struct OPERAND_1_mi *)pc1)->minor == 1) {
#line 3864
    goto case_1___1;
  }
#line 3880
  if (((struct OPERAND_1_mi *)pc1)->minor == 2) {
#line 3880
    goto case_2___1;
  }
#line 3893
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 3850
  ast -= sizeof(char *);
#line 3851
  *ast = ((struct OPERAND_1_mi *)pc1)->adr;
#line 3860
  pc += sizeof(struct OPERAND_1_mi );
#line 3861
  goto switch_break___2;
  case_1___1: /* CIL Label */ 
#line 3865
  ast -= sizeof(char *);
#line 3866
  *ast = bp + ((struct OPERAND_1_i *)pc1)->num;
#line 3876
  pc += sizeof(struct OPERAND_1_i );
#line 3877
  goto switch_break___2;
  case_2___1: /* CIL Label */ 
#line 3881
  ast -= sizeof(char *);
#line 3882
  *ast = *((char **)(bp + ((struct OPERAND_1_i *)pc1)->num));
#line 3890
  pc += sizeof(struct OPERAND_1_i );
#line 3891
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 3894
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           3894);
#line 3895
  error_message(5001);
#line 3896
  abort();
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 3898
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 3903
  if (((struct OPERAND_1_mi *)pc1)->minor == 0) {
#line 3903
    goto case_0___2;
  }
#line 3911
  if (((struct OPERAND_1_mi *)pc1)->minor == 1) {
#line 3911
    goto case_1___2;
  }
#line 3926
  if (((struct OPERAND_1_mi *)pc1)->minor == 2) {
#line 3926
    goto case_2___2;
  }
#line 3941
  if (((struct OPERAND_1_mi *)pc1)->minor == 3) {
#line 3941
    goto case_3___1;
  }
#line 3956
  if (((struct OPERAND_1_mi *)pc1)->minor == 4) {
#line 3956
    goto case_4___1;
  }
#line 3971
  if (((struct OPERAND_1_mi *)pc1)->minor == 5) {
#line 3971
    goto case_5___1;
  }
#line 3986
  if (((struct OPERAND_1_mi *)pc1)->minor == 6) {
#line 3986
    goto case_6___1;
  }
#line 4001
  if (((struct OPERAND_1_mi *)pc1)->minor == 7) {
#line 4001
    goto case_7___1;
  }
#line 4017
  if (((struct OPERAND_1_mi *)pc1)->minor == 256) {
#line 4017
    goto case_256___0;
  }
#line 4032
  if (((struct OPERAND_1_mi *)pc1)->minor == 257) {
#line 4032
    goto case_257___0;
  }
#line 4048
  if (((struct OPERAND_1_mi *)pc1)->minor == 512) {
#line 4048
    goto case_512___0;
  }
#line 4064
  if (((struct OPERAND_1_mi *)pc1)->minor == 768) {
#line 4064
    goto case_768___0;
  }
#line 4079
  if (((struct OPERAND_1_mi *)pc1)->minor == 769) {
#line 4079
    goto case_769___0;
  }
#line 4094
  if (((struct OPERAND_1_mi *)pc1)->minor == 770) {
#line 4094
    goto case_770___0;
  }
#line 4109
  if (((struct OPERAND_1_mi *)pc1)->minor == 771) {
#line 4109
    goto case_771___0;
  }
#line 4125
  goto switch_default___2;
  case_0___2: /* CIL Label */ 
#line 3904
  ast += sizeof(char *);
#line 3905
  pc += sizeof(struct OPERAND_0_mi );
#line 3910
  goto switch_break___3;
  case_1___2: /* CIL Label */ 
#line 3912
  *((char **)(stack + ((struct OPERAND_1_i *)pc)->num)) = *ast;
#line 3913
  ast += sizeof(char *);
#line 3924
  pc += sizeof(struct OPERAND_1_i );
#line 3925
  goto switch_break___3;
  case_2___2: /* CIL Label */ 
#line 3927
  *((int *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((int *)*ast);
#line 3928
  ast += sizeof(char *);
#line 3939
  pc += sizeof(struct OPERAND_1_i );
#line 3940
  goto switch_break___3;
  case_3___1: /* CIL Label */ 
#line 3942
  *((unsigned int *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((unsigned int *)*ast);
#line 3943
  ast += sizeof(char *);
#line 3954
  pc += sizeof(struct OPERAND_1_i );
#line 3955
  goto switch_break___3;
  case_4___1: /* CIL Label */ 
#line 3957
  *((long *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((long *)*ast);
#line 3958
  ast += sizeof(char *);
#line 3969
  pc += sizeof(struct OPERAND_1_i );
#line 3970
  goto switch_break___3;
  case_5___1: /* CIL Label */ 
#line 3972
  *((unsigned long *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((unsigned long *)*ast);
#line 3973
  ast += sizeof(char *);
#line 3984
  pc += sizeof(struct OPERAND_1_i );
#line 3985
  goto switch_break___3;
  case_6___1: /* CIL Label */ 
#line 3987
  *((short *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((short *)*ast);
#line 3988
  ast += sizeof(char *);
#line 3999
  pc += sizeof(struct OPERAND_1_i );
#line 4000
  goto switch_break___3;
  case_7___1: /* CIL Label */ 
#line 4002
  *((unsigned short *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((unsigned short *)*ast);
#line 4003
  ast += sizeof(char *);
#line 4014
  pc += sizeof(struct OPERAND_1_i );
#line 4015
  goto switch_break___3;
  case_256___0: /* CIL Label */ 
#line 4018
  *((double *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((double *)*ast);
#line 4019
  ast += sizeof(char *);
#line 4030
  pc += sizeof(struct OPERAND_1_i );
#line 4031
  goto switch_break___3;
  case_257___0: /* CIL Label */ 
#line 4033
  *((long double *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((long double *)*ast);
#line 4034
  ast += sizeof(char *);
#line 4045
  pc += sizeof(struct OPERAND_1_i );
#line 4046
  goto switch_break___3;
  case_512___0: /* CIL Label */ 
#line 4049
  *((float *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((float *)*ast);
#line 4050
  ast += sizeof(char *);
#line 4061
  pc += sizeof(struct OPERAND_1_i );
#line 4062
  goto switch_break___3;
  case_768___0: /* CIL Label */ 
#line 4065
  *(stack + ((struct OPERAND_1_i *)pc)->num) = *(*ast);
#line 4066
  ast += sizeof(char *);
#line 4077
  pc += sizeof(struct OPERAND_1_i );
#line 4078
  goto switch_break___3;
  case_769___0: /* CIL Label */ 
#line 4080
  *((signed char *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((signed char *)*ast);
#line 4081
  ast += sizeof(char *);
#line 4092
  pc += sizeof(struct OPERAND_1_i );
#line 4093
  goto switch_break___3;
  case_770___0: /* CIL Label */ 
#line 4095
  *((unsigned char *)(stack + ((struct OPERAND_1_i *)pc)->num)) = *((unsigned char *)*ast);
#line 4096
  ast += sizeof(char *);
#line 4107
  pc += sizeof(struct OPERAND_1_i );
#line 4108
  goto switch_break___3;
  case_771___0: /* CIL Label */ 
#line 4110
  *(stack + ((struct OPERAND_1_i *)pc)->num) = *(*ast + ((struct OPERAND_1_i *)pc)->num);
#line 4122
  pc += sizeof(struct OPERAND_1_i );
#line 4123
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 4126
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           4126);
#line 4127
  error_message(5001);
#line 4128
  abort();
  }
  switch_break___3: /* CIL Label */ ;
  }
#line 4130
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 4152
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 4152
    goto case_1___3;
  }
#line 4183
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 4183
    goto case_3___2;
  }
#line 4199
  if (((struct OPERAND_0_mi *)pc1)->minor == 4) {
#line 4199
    goto case_4___2;
  }
#line 4214
  goto switch_default___3;
  case_1___3: /* CIL Label */ 
#line 4153
  stack -= sizeof(char *);
#line 4155
  *((char **)stack) = bp;
#line 4164
  pc += sizeof(struct OPERAND_0_mi );
#line 4165
  goto switch_break___4;
  case_3___2: /* CIL Label */ 
#line 4184
  stack -= sizeof(char *);
#line 4186
  *((char **)stack) = tmph;
#line 4195
  pc += sizeof(struct OPERAND_0_mi );
#line 4196
  goto switch_break___4;
  case_4___2: /* CIL Label */ 
#line 4200
  stack -= sizeof(char *);
#line 4202
  *((char **)stack) = frame;
#line 4211
  pc += sizeof(struct OPERAND_0_mi );
#line 4212
  goto switch_break___4;
  switch_default___3: /* CIL Label */ 
  {
#line 4215
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           4215);
#line 4216
  error_message(5001);
#line 4217
  abort();
  }
  switch_break___4: /* CIL Label */ ;
  }
#line 4219
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 4225
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 4225
    goto case_0___3;
  }
#line 4239
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 4239
    goto case_1___4;
  }
#line 4253
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 4253
    goto case_2___3;
  }
#line 4266
  goto switch_default___4;
  case_0___3: /* CIL Label */ 
#line 4226
  bp = *((char **)stack);
#line 4227
  stack += sizeof(char *);
#line 4235
  pc += sizeof(struct OPERAND_0_mi );
#line 4236
  goto switch_break___5;
  case_1___4: /* CIL Label */ 
#line 4240
  tmph = *((char **)stack);
#line 4241
  stack += sizeof(char *);
#line 4249
  pc += sizeof(struct OPERAND_0_mi );
#line 4250
  goto switch_break___5;
  case_2___3: /* CIL Label */ 
#line 4254
  frame = *((char **)stack);
#line 4255
  stack += sizeof(char *);
#line 4263
  pc += sizeof(struct OPERAND_0_mi );
#line 4264
  goto switch_break___5;
  switch_default___4: /* CIL Label */ 
  {
#line 4267
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           4267);
#line 4268
  error_message(5001);
#line 4269
  abort();
  }
  switch_break___5: /* CIL Label */ ;
  }
#line 4271
  goto switch_break;
  case_10___1: /* CIL Label */ 
  {
#line 4307
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 4307
    goto case_0___4;
  }
#line 4324
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 4324
    goto case_1___5;
  }
#line 4338
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 4338
    goto case_2___4;
  }
#line 4355
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 4355
    goto case_3___3;
  }
#line 4391
  if (((struct OPERAND_0_mi *)pc1)->minor == 5) {
#line 4391
    goto case_5___2;
  }
#line 4427
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 4427
    goto case_256___1;
  }
#line 4444
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 4444
    goto case_257___1;
  }
#line 4461
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 4461
    goto case_512___1;
  }
#line 4530
  goto switch_default___5;
  case_0___4: /* CIL Label */ 
  {
#line 4308
  binar = *((int *)*ast) + *((int *)*(ast + sizeof(char *)));
#line 4309
  ast += sizeof(char *);
#line 4310
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 4311
  *ast = tmp;
#line 4312
  *((int *)*ast) = binar;
#line 4320
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4321
  goto switch_break___6;
  case_1___5: /* CIL Label */ 
#line 4325
  stack += ((struct OPERAND_1_i *)pc1)->num;
#line 4334
  pc += sizeof(struct OPERAND_1_i );
#line 4335
  goto switch_break___6;
  case_2___4: /* CIL Label */ 
  {
#line 4339
  binaru = *((unsigned int *)*ast) + *((unsigned int *)*(ast + sizeof(char *)));
#line 4340
  ast += sizeof(char *);
#line 4341
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 4342
  *ast = tmp;
#line 4343
  *((unsigned int *)*ast) = binaru;
#line 4351
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4352
  goto switch_break___6;
  case_3___3: /* CIL Label */ 
  {
#line 4356
  binarl = *((long *)*ast) + *((long *)*(ast + sizeof(char *)));
#line 4357
  ast += sizeof(char *);
#line 4358
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 4359
  *ast = tmp;
#line 4360
  *((long *)*ast) = binarl;
#line 4368
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4369
  goto switch_break___6;
  case_5___2: /* CIL Label */ 
  {
#line 4392
  binarlu = *((unsigned long *)*ast) + *((unsigned long *)*(ast + sizeof(char *)));
#line 4393
  ast += sizeof(char *);
#line 4394
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 4395
  *ast = tmp;
#line 4396
  *((unsigned long *)*ast) = binarlu;
#line 4404
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4405
  goto switch_break___6;
  case_256___1: /* CIL Label */ 
  {
#line 4428
  binard = *((double *)*ast) + *((double *)*(ast + sizeof(char *)));
#line 4429
  ast += sizeof(char *);
#line 4430
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 4431
  *ast = tmp;
#line 4432
  *((double *)*ast) = binard;
#line 4440
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4441
  goto switch_break___6;
  case_257___1: /* CIL Label */ 
  {
#line 4445
  binarld = *((long double *)*ast) + *((long double *)*(ast + sizeof(char *)));
#line 4446
  ast += sizeof(char *);
#line 4447
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 4448
  *ast = tmp;
#line 4449
  *((long double *)*ast) = binarld;
#line 4457
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4458
  goto switch_break___6;
  case_512___1: /* CIL Label */ 
  {
#line 4462
  binarf = *((float *)*ast) + *((float *)*(ast + sizeof(char *)));
#line 4463
  ast += sizeof(char *);
#line 4464
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 4465
  *ast = tmp;
#line 4466
  *((float *)*ast) = binarf;
#line 4474
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4475
  goto switch_break___6;
  switch_default___5: /* CIL Label */ 
  {
#line 4531
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           4531);
#line 4532
  error_message(5001);
#line 4533
  abort();
  }
  switch_break___6: /* CIL Label */ ;
  }
#line 4535
  goto switch_break;
  case_11___1: /* CIL Label */ 
  {
#line 4540
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 4540
    goto case_0___5;
  }
#line 4558
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 4558
    goto case_1___6;
  }
#line 4573
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 4573
    goto case_2___5;
  }
#line 4591
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 4591
    goto case_3___4;
  }
#line 4609
  if (((struct OPERAND_0_mi *)pc1)->minor == 4) {
#line 4609
    goto case_4___3;
  }
#line 4627
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 4627
    goto case_256___2;
  }
#line 4645
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 4645
    goto case_257___2;
  }
#line 4663
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 4663
    goto case_512___2;
  }
#line 4701
  goto switch_default___6;
  case_0___5: /* CIL Label */ 
  {
#line 4541
  binar = *((int *)*(ast + sizeof(char *))) - *((int *)*ast);
#line 4542
  ast += sizeof(char *);
#line 4543
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 4544
  *ast = tmp;
#line 4545
  *((int *)*ast) = binar;
#line 4554
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4555
  goto switch_break___7;
  case_1___6: /* CIL Label */ 
#line 4559
  stack -= ((struct OPERAND_1_i *)pc1)->num;
#line 4569
  pc += sizeof(struct OPERAND_1_i );
#line 4570
  goto switch_break___7;
  case_2___5: /* CIL Label */ 
  {
#line 4574
  binaru = *((unsigned int *)*(ast + sizeof(char *))) - *((unsigned int *)*ast);
#line 4575
  ast += sizeof(char *);
#line 4576
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 4577
  *ast = tmp;
#line 4578
  *((unsigned int *)*ast) = binaru;
#line 4587
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4588
  goto switch_break___7;
  case_3___4: /* CIL Label */ 
  {
#line 4592
  binarl = *((long *)*(ast + sizeof(char *))) - *((long *)*ast);
#line 4593
  ast += sizeof(char *);
#line 4594
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 4595
  *ast = tmp;
#line 4596
  *((long *)*ast) = binarl;
#line 4605
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4606
  goto switch_break___7;
  case_4___3: /* CIL Label */ 
  {
#line 4610
  binarlu = *((unsigned long *)*(ast + sizeof(char *))) - *((unsigned long *)*ast);
#line 4611
  ast += sizeof(char *);
#line 4612
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 4613
  *ast = tmp;
#line 4614
  *((unsigned long *)*ast) = binarlu;
#line 4623
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4624
  goto switch_break___7;
  case_256___2: /* CIL Label */ 
  {
#line 4628
  binard = *((double *)*(ast + sizeof(char *))) - *((double *)*ast);
#line 4629
  ast += sizeof(char *);
#line 4630
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 4631
  *ast = tmp;
#line 4632
  *((double *)*ast) = binard;
#line 4641
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4642
  goto switch_break___7;
  case_257___2: /* CIL Label */ 
  {
#line 4646
  binarld = *((long double *)*(ast + sizeof(char *))) - *((long double *)*ast);
#line 4647
  ast += sizeof(char *);
#line 4648
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 4649
  *ast = tmp;
#line 4650
  *((long double *)*ast) = binarld;
#line 4659
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4660
  goto switch_break___7;
  case_512___2: /* CIL Label */ 
  {
#line 4664
  binarf = *((float *)*(ast + sizeof(char *))) - *((float *)*ast);
#line 4665
  ast += sizeof(char *);
#line 4666
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 4667
  *ast = tmp;
#line 4668
  *((float *)*ast) = binarf;
#line 4677
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4678
  goto switch_break___7;
  switch_default___6: /* CIL Label */ 
  {
#line 4702
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           4702);
#line 4703
  error_message(5001);
#line 4704
  abort();
  }
  switch_break___7: /* CIL Label */ ;
  }
#line 4706
  goto switch_break;
  case_12___1: /* CIL Label */ 
  {
#line 4712
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 4712
    goto case_0___6;
  }
#line 4726
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 4726
    goto case_1___7;
  }
#line 4740
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 4740
    goto case_2___6;
  }
#line 4754
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 4754
    goto case_3___5;
  }
#line 4768
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 4768
    goto case_256___3;
  }
#line 4782
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 4782
    goto case_257___3;
  }
#line 4796
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 4796
    goto case_512___3;
  }
#line 4826
  goto switch_default___7;
  case_0___6: /* CIL Label */ 
  {
#line 4713
  binar = *((int *)*ast) * *((int *)*(ast + sizeof(char *)));
#line 4714
  ast += sizeof(char *);
#line 4715
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 4716
  *ast = tmp;
#line 4717
  *((int *)*ast) = binar;
#line 4722
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4723
  goto switch_break___8;
  case_1___7: /* CIL Label */ 
  {
#line 4727
  binaru = *((unsigned int *)*ast) * *((unsigned int *)*(ast + sizeof(char *)));
#line 4728
  ast += sizeof(char *);
#line 4729
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 4730
  *ast = tmp;
#line 4731
  *((unsigned int *)*ast) = binaru;
#line 4736
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4737
  goto switch_break___8;
  case_2___6: /* CIL Label */ 
  {
#line 4741
  binarl = *((long *)*ast) * *((long *)*(ast + sizeof(char *)));
#line 4742
  ast += sizeof(char *);
#line 4743
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 4744
  *ast = tmp;
#line 4745
  *((long *)*ast) = binarl;
#line 4750
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4751
  goto switch_break___8;
  case_3___5: /* CIL Label */ 
  {
#line 4755
  binarlu = *((unsigned long *)*ast) * *((unsigned long *)*(ast + sizeof(char *)));
#line 4756
  ast += sizeof(char *);
#line 4757
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 4758
  *ast = tmp;
#line 4759
  *((unsigned long *)*ast) = binarlu;
#line 4764
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4765
  goto switch_break___8;
  case_256___3: /* CIL Label */ 
  {
#line 4769
  binard = *((double *)*ast) * *((double *)*(ast + sizeof(char *)));
#line 4770
  ast += sizeof(char *);
#line 4771
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 4772
  *ast = tmp;
#line 4773
  *((double *)*ast) = binard;
#line 4778
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4779
  goto switch_break___8;
  case_257___3: /* CIL Label */ 
  {
#line 4783
  binarld = *((long double *)*ast) * *((long double *)*(ast + sizeof(char *)));
#line 4784
  ast += sizeof(char *);
#line 4785
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 4786
  *ast = tmp;
#line 4787
  *((long double *)*ast) = (long double )binard;
#line 4792
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4793
  goto switch_break___8;
  case_512___3: /* CIL Label */ 
  {
#line 4797
  binarf = *((float *)*ast) * *((float *)*(ast + sizeof(char *)));
#line 4798
  ast += sizeof(char *);
#line 4799
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 4800
  *ast = tmp;
#line 4801
  *((float *)*ast) = binarf;
#line 4806
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 4807
  goto switch_break___8;
  switch_default___7: /* CIL Label */ 
  {
#line 4827
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           4827);
#line 4828
  error_message(5001);
#line 4829
  abort();
  }
  switch_break___8: /* CIL Label */ ;
  }
#line 4831
  goto switch_break;
  case_14___1: /* CIL Label */ 
#line 4834
  if (*((int *)*ast) != 0) {
    {
#line 4835
    mod_yes();
    }
  } else {
    {
#line 4838
    fprintfx(stderr, "\ninterpreter: divide by zero \n\n");
    }
#line 4839
    return (-2);
  }
#line 4845
  pc += sizeof(struct OPERAND_0_ma );
#line 4846
  goto switch_break;
  case_13___1: /* CIL Label */ 
  {
#line 4852
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 4852
    goto case_0___7;
  }
#line 4868
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 4868
    goto case_1___8;
  }
#line 4884
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 4884
    goto case_2___7;
  }
#line 4900
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 4900
    goto case_3___6;
  }
#line 4916
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 4916
    goto case_256___4;
  }
#line 4932
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 4932
    goto case_257___4;
  }
#line 4948
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 4948
    goto case_512___4;
  }
#line 4982
  goto switch_default___8;
  case_0___7: /* CIL Label */ 
#line 4853
  if (*((int *)*ast) != 0) {
    {
#line 4854
    div_yes();
    }
  } else {
    {
#line 4857
    fprintfx(stderr, "\ninterpreter: divide by zero \n\n");
    }
#line 4858
    return (-2);
  }
#line 4864
  pc += sizeof(struct OPERAND_0_mi );
#line 4865
  goto switch_break___9;
  case_1___8: /* CIL Label */ 
#line 4869
  if (*((unsigned int *)*ast) != 0U) {
    {
#line 4870
    divui_yes();
    }
  } else {
    {
#line 4873
    fprintfx(stderr, "\ninterpreter: divide by zero \n\n");
    }
#line 4874
    return (-2);
  }
#line 4880
  pc += sizeof(struct OPERAND_0_mi );
#line 4881
  goto switch_break___9;
  case_2___7: /* CIL Label */ 
#line 4885
  if (*((unsigned int *)*ast) != 0U) {
    {
#line 4886
    divli_yes();
    }
  } else {
    {
#line 4889
    fprintfx(stderr, "\ninterpreter: divide by zero \n\n");
    }
#line 4890
    return (-2);
  }
#line 4896
  pc += sizeof(struct OPERAND_0_mi );
#line 4897
  goto switch_break___9;
  case_3___6: /* CIL Label */ 
#line 4901
  if (*((unsigned long *)*ast) != 0UL) {
    {
#line 4902
    divlui_yes();
    }
  } else {
    {
#line 4905
    fprintfx(stderr, "\ninterpreter: divide by zero \n\n");
    }
#line 4906
    return (-2);
  }
#line 4912
  pc += sizeof(struct OPERAND_0_mi );
#line 4913
  goto switch_break___9;
  case_256___4: /* CIL Label */ 
#line 4917
  if (*((double *)*ast) != (double )0) {
    {
#line 4918
    divd_yes();
    }
  } else {
    {
#line 4921
    fprintfx(stderr, "\ninterpreter: divide by zero \n\n");
    }
#line 4922
    return (-2);
  }
#line 4928
  pc += sizeof(struct OPERAND_0_mi );
#line 4929
  goto switch_break___9;
  case_257___4: /* CIL Label */ 
#line 4933
  if (*((long double *)*ast) != (long double )0) {
    {
#line 4934
    divld_yes();
    }
  } else {
    {
#line 4937
    fprintfx(stderr, "\ninterpreter: divide by zero \n\n");
    }
#line 4938
    return (-2);
  }
#line 4944
  pc += sizeof(struct OPERAND_0_mi );
#line 4945
  goto switch_break___9;
  case_512___4: /* CIL Label */ 
#line 4949
  if (*((float *)*ast) != (float )0) {
    {
#line 4950
    divf_yes();
    }
  } else {
    {
#line 4953
    fprintfx(stderr, "\ninterpreter: divide by zero \n\n");
    }
#line 4954
    return (-2);
  }
#line 4960
  pc += sizeof(struct OPERAND_0_mi );
#line 4961
  goto switch_break___9;
  switch_default___8: /* CIL Label */ 
  {
#line 4983
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           4983);
#line 4984
  error_message(5001);
#line 4985
  abort();
  }
  switch_break___9: /* CIL Label */ ;
  }
#line 4987
  goto switch_break;
  case_15___1: /* CIL Label */ 
  {
#line 4993
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 4993
    goto case_0___8;
  }
#line 5007
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 5007
    goto case_1___9;
  }
#line 5021
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 5021
    goto case_2___8;
  }
#line 5035
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 5035
    goto case_3___7;
  }
#line 5049
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 5049
    goto case_256___5;
  }
#line 5062
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 5062
    goto case_257___5;
  }
#line 5075
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 5075
    goto case_512___5;
  }
#line 5104
  goto switch_default___9;
  case_0___8: /* CIL Label */ 
#line 4994
  if (*((int *)*(ast + sizeof(char *)))) {
#line 4994
    tmp___0 = 1;
  } else
#line 4994
  if (*((int *)*ast)) {
#line 4994
    tmp___0 = 1;
  } else {
#line 4994
    tmp___0 = 0;
  }
  {
#line 4994
  binar = tmp___0;
#line 4995
  ast += sizeof(char *);
#line 4996
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 4997
  *ast = tmp;
#line 4998
  *((int *)*ast) = binar;
#line 5003
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5004
  goto switch_break___10;
  case_1___9: /* CIL Label */ 
#line 5008
  if (*((unsigned int *)*(ast + sizeof(char *)))) {
#line 5008
    tmp___1 = 1;
  } else
#line 5008
  if (*((unsigned int *)*ast)) {
#line 5008
    tmp___1 = 1;
  } else {
#line 5008
    tmp___1 = 0;
  }
  {
#line 5008
  binar = tmp___1;
#line 5009
  ast += sizeof(char *);
#line 5010
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5011
  *ast = tmp;
#line 5012
  *((int *)*ast) = binar;
#line 5017
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5018
  goto switch_break___10;
  case_2___8: /* CIL Label */ 
#line 5022
  if (*((long *)*(ast + sizeof(char *)))) {
#line 5022
    tmp___2 = 1;
  } else
#line 5022
  if (*((long *)*ast)) {
#line 5022
    tmp___2 = 1;
  } else {
#line 5022
    tmp___2 = 0;
  }
  {
#line 5022
  binar = tmp___2;
#line 5023
  ast += sizeof(char *);
#line 5024
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5025
  *ast = tmp;
#line 5026
  *((int *)*ast) = binar;
#line 5031
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5032
  goto switch_break___10;
  case_3___7: /* CIL Label */ 
#line 5036
  if (*((unsigned long *)*(ast + sizeof(char *)))) {
#line 5036
    tmp___3 = 1;
  } else
#line 5036
  if (*((unsigned long *)*ast)) {
#line 5036
    tmp___3 = 1;
  } else {
#line 5036
    tmp___3 = 0;
  }
  {
#line 5036
  binar = tmp___3;
#line 5037
  ast += sizeof(char *);
#line 5038
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5039
  *ast = tmp;
#line 5040
  *((int *)*ast) = binar;
#line 5045
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5046
  goto switch_break___10;
  case_256___5: /* CIL Label */ 
#line 5049
  if (*((double *)*(ast + sizeof(char *)))) {
#line 5049
    tmp___4 = 1;
  } else
#line 5049
  if (*((double *)*ast)) {
#line 5049
    tmp___4 = 1;
  } else {
#line 5049
    tmp___4 = 0;
  }
  {
#line 5049
  binar = tmp___4;
#line 5050
  ast += sizeof(char *);
#line 5051
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5052
  *ast = tmp;
#line 5053
  *((int *)*ast) = binar;
#line 5058
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5059
  goto switch_break___10;
  case_257___5: /* CIL Label */ 
#line 5062
  if (*((long double *)*(ast + sizeof(char *)))) {
#line 5062
    tmp___5 = 1;
  } else
#line 5062
  if (*((long double *)*ast)) {
#line 5062
    tmp___5 = 1;
  } else {
#line 5062
    tmp___5 = 0;
  }
  {
#line 5062
  binar = tmp___5;
#line 5063
  ast += sizeof(char *);
#line 5064
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5065
  *ast = tmp;
#line 5066
  *((int *)*ast) = binar;
#line 5071
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5072
  goto switch_break___10;
  case_512___5: /* CIL Label */ 
#line 5076
  if (*((float *)*(ast + sizeof(char *)))) {
#line 5076
    tmp___6 = 1;
  } else
#line 5076
  if (*((float *)*ast)) {
#line 5076
    tmp___6 = 1;
  } else {
#line 5076
    tmp___6 = 0;
  }
  {
#line 5076
  binar = tmp___6;
#line 5077
  ast += sizeof(char *);
#line 5078
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5079
  *ast = tmp;
#line 5080
  *((int *)*ast) = binar;
#line 5085
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5086
  goto switch_break___10;
  switch_default___9: /* CIL Label */ 
  {
#line 5105
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           5105);
#line 5106
  error_message(5001);
#line 5107
  abort();
  }
  switch_break___10: /* CIL Label */ ;
  }
#line 5109
  goto switch_break;
  case_16___1: /* CIL Label */ 
  {
#line 5115
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 5115
    goto case_0___9;
  }
#line 5129
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 5129
    goto case_1___10;
  }
#line 5143
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 5143
    goto case_2___9;
  }
#line 5157
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 5157
    goto case_3___8;
  }
#line 5171
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 5171
    goto case_256___6;
  }
#line 5185
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 5185
    goto case_257___6;
  }
#line 5199
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 5199
    goto case_512___6;
  }
#line 5228
  goto switch_default___10;
  case_0___9: /* CIL Label */ 
#line 5116
  if (*((int *)*(ast + sizeof(char *)))) {
#line 5116
    if (*((int *)*ast)) {
#line 5116
      tmp___7 = 1;
    } else {
#line 5116
      tmp___7 = 0;
    }
  } else {
#line 5116
    tmp___7 = 0;
  }
  {
#line 5116
  binar = tmp___7;
#line 5117
  ast += sizeof(char *);
#line 5118
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5119
  *ast = tmp;
#line 5120
  *((int *)*ast) = binar;
#line 5125
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5126
  goto switch_break___11;
  case_1___10: /* CIL Label */ 
#line 5130
  if (*((unsigned int *)*(ast + sizeof(char *)))) {
#line 5130
    if (*((unsigned int *)*ast)) {
#line 5130
      tmp___8 = 1;
    } else {
#line 5130
      tmp___8 = 0;
    }
  } else {
#line 5130
    tmp___8 = 0;
  }
  {
#line 5130
  binar = tmp___8;
#line 5131
  ast += sizeof(char *);
#line 5132
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5133
  *ast = tmp;
#line 5134
  *((int *)*ast) = binar;
#line 5139
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5140
  goto switch_break___11;
  case_2___9: /* CIL Label */ 
#line 5144
  if (*((long *)*(ast + sizeof(char *)))) {
#line 5144
    if (*((long *)*ast)) {
#line 5144
      tmp___9 = 1;
    } else {
#line 5144
      tmp___9 = 0;
    }
  } else {
#line 5144
    tmp___9 = 0;
  }
  {
#line 5144
  binar = tmp___9;
#line 5145
  ast += sizeof(char *);
#line 5146
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5147
  *ast = tmp;
#line 5148
  *((int *)*ast) = binar;
#line 5153
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5154
  goto switch_break___11;
  case_3___8: /* CIL Label */ 
#line 5158
  if (*((unsigned long *)*(ast + sizeof(char *)))) {
#line 5158
    if (*((unsigned long *)*ast)) {
#line 5158
      tmp___10 = 1;
    } else {
#line 5158
      tmp___10 = 0;
    }
  } else {
#line 5158
    tmp___10 = 0;
  }
  {
#line 5158
  binar = tmp___10;
#line 5159
  ast += sizeof(char *);
#line 5160
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5161
  *ast = tmp;
#line 5162
  *((int *)*ast) = binar;
#line 5167
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5168
  goto switch_break___11;
  case_256___6: /* CIL Label */ 
#line 5172
  if (*((double *)*(ast + sizeof(char *)))) {
#line 5172
    if (*((double *)*ast)) {
#line 5172
      tmp___11 = 1;
    } else {
#line 5172
      tmp___11 = 0;
    }
  } else {
#line 5172
    tmp___11 = 0;
  }
  {
#line 5172
  binar = tmp___11;
#line 5173
  ast += sizeof(char *);
#line 5174
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5175
  *ast = tmp;
#line 5176
  *((int *)*ast) = binar;
#line 5181
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5182
  goto switch_break___11;
  case_257___6: /* CIL Label */ 
#line 5186
  if (*((long double *)*(ast + sizeof(char *)))) {
#line 5186
    if (*((long double *)*ast)) {
#line 5186
      tmp___12 = 1;
    } else {
#line 5186
      tmp___12 = 0;
    }
  } else {
#line 5186
    tmp___12 = 0;
  }
  {
#line 5186
  binar = tmp___12;
#line 5187
  ast += sizeof(char *);
#line 5188
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5189
  *ast = tmp;
#line 5190
  *((int *)*ast) = binar;
#line 5195
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5196
  goto switch_break___11;
  case_512___6: /* CIL Label */ 
#line 5200
  if (*((float *)*(ast + sizeof(char *)))) {
#line 5200
    if (*((float *)*ast)) {
#line 5200
      tmp___13 = 1;
    } else {
#line 5200
      tmp___13 = 0;
    }
  } else {
#line 5200
    tmp___13 = 0;
  }
  {
#line 5200
  binar = tmp___13;
#line 5201
  ast += sizeof(char *);
#line 5202
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5203
  *ast = tmp;
#line 5204
  *((int *)*ast) = binar;
#line 5209
  pc += sizeof(struct OPERAND_0_mi );
  }
#line 5210
  goto switch_break___11;
  switch_default___10: /* CIL Label */ 
  {
#line 5229
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           5229);
#line 5230
  error_message(5001);
#line 5231
  abort();
  }
  switch_break___11: /* CIL Label */ ;
  }
#line 5233
  goto switch_break;
  case_17___1: /* CIL Label */ 
  {
#line 5236
  binar = *((int *)*(ast + sizeof(char *))) | *((int *)*ast);
#line 5237
  ast += sizeof(char *);
#line 5238
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5239
  *ast = tmp;
#line 5240
  *((int *)*ast) = binar;
#line 5245
  pc += sizeof(struct OPERAND_0_ma );
  }
#line 5246
  goto switch_break;
  case_18___1: /* CIL Label */ 
  {
#line 5249
  binar = *((int *)*(ast + sizeof(char *))) & *((int *)*ast);
#line 5250
  ast += sizeof(char *);
#line 5251
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 5252
  *ast = tmp;
#line 5253
  *((int *)*ast) = binar;
#line 5258
  pc += sizeof(struct OPERAND_0_ma );
  }
#line 5259
  goto switch_break;
  case_19___1: /* CIL Label */ 
  {
#line 5265
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 5265
    goto case_0___10;
  }
#line 5278
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 5278
    goto case_1___11;
  }
#line 5291
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 5291
    goto case_2___10;
  }
#line 5304
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 5304
    goto case_3___9;
  }
#line 5317
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 5317
    goto case_256___7;
  }
#line 5330
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 5330
    goto case_257___7;
  }
#line 5343
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 5343
    goto case_512___7;
  }
#line 5370
  goto switch_default___11;
  case_0___10: /* CIL Label */ 
#line 5266
  if (*((int *)*(ast + sizeof(char *))) == *((int *)*ast)) {
    {
#line 5267
    vtrue();
    }
  } else {
    {
#line 5269
    vfalse();
    }
  }
#line 5274
  pc += sizeof(struct OPERAND_0_mi );
#line 5275
  goto switch_break___12;
  case_1___11: /* CIL Label */ 
#line 5279
  if (*((unsigned int *)*(ast + sizeof(char *))) == *((unsigned int *)*ast)) {
    {
#line 5280
    vtrue();
    }
  } else {
    {
#line 5282
    vfalse();
    }
  }
#line 5287
  pc += sizeof(struct OPERAND_0_mi );
#line 5288
  goto switch_break___12;
  case_2___10: /* CIL Label */ 
#line 5292
  if (*((long *)*(ast + sizeof(char *))) == *((long *)*ast)) {
    {
#line 5293
    vtrue();
    }
  } else {
    {
#line 5295
    vfalse();
    }
  }
#line 5300
  pc += sizeof(struct OPERAND_0_mi );
#line 5301
  goto switch_break___12;
  case_3___9: /* CIL Label */ 
#line 5305
  if (*((unsigned long *)*(ast + sizeof(char *))) == *((unsigned long *)*ast)) {
    {
#line 5306
    vtrue();
    }
  } else {
    {
#line 5308
    vfalse();
    }
  }
#line 5313
  pc += sizeof(struct OPERAND_0_mi );
#line 5314
  goto switch_break___12;
  case_256___7: /* CIL Label */ 
#line 5318
  if (*((double *)*(ast + sizeof(char *))) == *((double *)*ast)) {
    {
#line 5319
    vtrue();
    }
  } else {
    {
#line 5321
    vfalse();
    }
  }
#line 5326
  pc += sizeof(struct OPERAND_0_mi );
#line 5327
  goto switch_break___12;
  case_257___7: /* CIL Label */ 
#line 5331
  if (*((long double *)*(ast + sizeof(char *))) == *((long double *)*ast)) {
    {
#line 5332
    vtrue();
    }
  } else {
    {
#line 5334
    vfalse();
    }
  }
#line 5339
  pc += sizeof(struct OPERAND_0_mi );
#line 5340
  goto switch_break___12;
  case_512___7: /* CIL Label */ 
#line 5344
  if (*((float *)*(ast + sizeof(char *))) == *((float *)*ast)) {
    {
#line 5345
    vtrue();
    }
  } else {
    {
#line 5347
    vfalse();
    }
  }
#line 5352
  pc += sizeof(struct OPERAND_0_mi );
#line 5353
  goto switch_break___12;
  switch_default___11: /* CIL Label */ 
  {
#line 5371
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           5371);
#line 5372
  error_message(5001);
#line 5373
  abort();
  }
  switch_break___12: /* CIL Label */ ;
  }
#line 5375
  goto switch_break;
  case_21___1: /* CIL Label */ 
  {
#line 5381
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 5381
    goto case_0___11;
  }
#line 5394
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 5394
    goto case_1___12;
  }
#line 5407
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 5407
    goto case_2___11;
  }
#line 5420
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 5420
    goto case_3___10;
  }
#line 5433
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 5433
    goto case_256___8;
  }
#line 5446
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 5446
    goto case_257___8;
  }
#line 5459
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 5459
    goto case_512___8;
  }
#line 5486
  goto switch_default___12;
  case_0___11: /* CIL Label */ 
#line 5382
  if (*((int *)*(ast + sizeof(char *))) > *((int *)*ast)) {
    {
#line 5383
    vtrue();
    }
  } else {
    {
#line 5385
    vfalse();
    }
  }
#line 5390
  pc += sizeof(struct OPERAND_0_mi );
#line 5391
  goto switch_break___13;
  case_1___12: /* CIL Label */ 
#line 5395
  if (*((unsigned int *)*(ast + sizeof(char *))) > *((unsigned int *)*ast)) {
    {
#line 5396
    vtrue();
    }
  } else {
    {
#line 5398
    vfalse();
    }
  }
#line 5403
  pc += sizeof(struct OPERAND_0_mi );
#line 5404
  goto switch_break___13;
  case_2___11: /* CIL Label */ 
#line 5408
  if (*((long *)*(ast + sizeof(char *))) > *((long *)*ast)) {
    {
#line 5409
    vtrue();
    }
  } else {
    {
#line 5411
    vfalse();
    }
  }
#line 5416
  pc += sizeof(struct OPERAND_0_mi );
#line 5417
  goto switch_break___13;
  case_3___10: /* CIL Label */ 
#line 5421
  if (*((unsigned long *)*(ast + sizeof(char *))) > *((unsigned long *)*ast)) {
    {
#line 5422
    vtrue();
    }
  } else {
    {
#line 5424
    vfalse();
    }
  }
#line 5429
  pc += sizeof(struct OPERAND_0_mi );
#line 5430
  goto switch_break___13;
  case_256___8: /* CIL Label */ 
#line 5434
  if (*((double *)*(ast + sizeof(char *))) > *((double *)*ast)) {
    {
#line 5435
    vtrue();
    }
  } else {
    {
#line 5437
    vfalse();
    }
  }
#line 5442
  pc += sizeof(struct OPERAND_0_mi );
#line 5443
  goto switch_break___13;
  case_257___8: /* CIL Label */ 
#line 5447
  if (*((long double *)*(ast + sizeof(char *))) > *((long double *)*ast)) {
    {
#line 5448
    vtrue();
    }
  } else {
    {
#line 5450
    vfalse();
    }
  }
#line 5455
  pc += sizeof(struct OPERAND_0_mi );
#line 5456
  goto switch_break___13;
  case_512___8: /* CIL Label */ 
#line 5460
  if (*((float *)*(ast + sizeof(char *))) > *((float *)*ast)) {
    {
#line 5461
    vtrue();
    }
  } else {
    {
#line 5463
    vfalse();
    }
  }
#line 5468
  pc += sizeof(struct OPERAND_0_mi );
#line 5469
  goto switch_break___13;
  switch_default___12: /* CIL Label */ 
  {
#line 5487
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           5487);
#line 5488
  error_message(5001);
#line 5489
  abort();
  }
  switch_break___13: /* CIL Label */ ;
  }
#line 5491
  goto switch_break;
  case_20___1: /* CIL Label */ 
  {
#line 5497
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 5497
    goto case_0___12;
  }
#line 5510
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 5510
    goto case_1___13;
  }
#line 5523
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 5523
    goto case_2___12;
  }
#line 5536
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 5536
    goto case_3___11;
  }
#line 5549
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 5549
    goto case_256___9;
  }
#line 5562
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 5562
    goto case_512___9;
  }
#line 5589
  goto switch_default___13;
  case_0___12: /* CIL Label */ 
#line 5498
  if (*((int *)*(ast + sizeof(char *))) < *((int *)*ast)) {
    {
#line 5499
    vtrue();
    }
  } else {
    {
#line 5501
    vfalse();
    }
  }
#line 5506
  pc += sizeof(struct OPERAND_0_mi );
#line 5507
  goto switch_break___14;
  case_1___13: /* CIL Label */ 
#line 5511
  if (*((unsigned int *)*(ast + sizeof(char *))) < *((unsigned int *)*ast)) {
    {
#line 5512
    vtrue();
    }
  } else {
    {
#line 5514
    vfalse();
    }
  }
#line 5519
  pc += sizeof(struct OPERAND_0_mi );
#line 5520
  goto switch_break___14;
  case_2___12: /* CIL Label */ 
#line 5524
  if (*((long *)*(ast + sizeof(char *))) < *((long *)*ast)) {
    {
#line 5525
    vtrue();
    }
  } else {
    {
#line 5527
    vfalse();
    }
  }
#line 5532
  pc += sizeof(struct OPERAND_0_mi );
#line 5533
  goto switch_break___14;
  case_3___11: /* CIL Label */ 
#line 5537
  if (*((unsigned long *)*(ast + sizeof(char *))) < *((unsigned long *)*ast)) {
    {
#line 5538
    vtrue();
    }
  } else {
    {
#line 5540
    vfalse();
    }
  }
#line 5545
  pc += sizeof(struct OPERAND_0_mi );
#line 5546
  goto switch_break___14;
  case_256___9: /* CIL Label */ 
#line 5550
  if (*((double *)*(ast + sizeof(char *))) < *((double *)*ast)) {
    {
#line 5551
    vtrue();
    }
  } else {
    {
#line 5553
    vfalse();
    }
  }
#line 5558
  pc += sizeof(struct OPERAND_0_mi );
#line 5559
  goto switch_break___14;
  case_512___9: /* CIL Label */ 
#line 5563
  if (*((float *)*(ast + sizeof(char *))) < *((float *)*ast)) {
    {
#line 5564
    vtrue();
    }
  } else {
    {
#line 5566
    vfalse();
    }
  }
#line 5571
  pc += sizeof(struct OPERAND_0_mi );
#line 5572
  goto switch_break___14;
  switch_default___13: /* CIL Label */ 
  {
#line 5590
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           5590);
#line 5591
  error_message(5001);
#line 5592
  abort();
  }
  switch_break___14: /* CIL Label */ ;
  }
#line 5594
  goto switch_break;
  case_22___0: /* CIL Label */ 
  {
#line 5600
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 5600
    goto case_0___13;
  }
#line 5613
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 5613
    goto case_1___14;
  }
#line 5626
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 5626
    goto case_2___13;
  }
#line 5639
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 5639
    goto case_3___12;
  }
#line 5652
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 5652
    goto case_256___10;
  }
#line 5665
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 5665
    goto case_257___9;
  }
#line 5678
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 5678
    goto case_512___10;
  }
#line 5705
  goto switch_default___14;
  case_0___13: /* CIL Label */ 
#line 5601
  if (*((int *)*(ast + sizeof(char *))) <= *((int *)*ast)) {
    {
#line 5602
    vtrue();
    }
  } else {
    {
#line 5604
    vfalse();
    }
  }
#line 5609
  pc += sizeof(struct OPERAND_0_mi );
#line 5610
  goto switch_break___15;
  case_1___14: /* CIL Label */ 
#line 5614
  if (*((unsigned int *)*(ast + sizeof(char *))) <= *((unsigned int *)*ast)) {
    {
#line 5615
    vtrue();
    }
  } else {
    {
#line 5617
    vfalse();
    }
  }
#line 5622
  pc += sizeof(struct OPERAND_0_mi );
#line 5623
  goto switch_break___15;
  case_2___13: /* CIL Label */ 
#line 5627
  if (*((long *)*(ast + sizeof(char *))) <= *((long *)*ast)) {
    {
#line 5628
    vtrue();
    }
  } else {
    {
#line 5630
    vfalse();
    }
  }
#line 5635
  pc += sizeof(struct OPERAND_0_mi );
#line 5636
  goto switch_break___15;
  case_3___12: /* CIL Label */ 
#line 5640
  if (*((unsigned long *)*(ast + sizeof(char *))) <= *((unsigned long *)*ast)) {
    {
#line 5641
    vtrue();
    }
  } else {
    {
#line 5643
    vfalse();
    }
  }
#line 5648
  pc += sizeof(struct OPERAND_0_mi );
#line 5649
  goto switch_break___15;
  case_256___10: /* CIL Label */ 
#line 5653
  if (*((double *)*(ast + sizeof(char *))) <= *((double *)*ast)) {
    {
#line 5654
    vtrue();
    }
  } else {
    {
#line 5656
    vfalse();
    }
  }
#line 5661
  pc += sizeof(struct OPERAND_0_mi );
#line 5662
  goto switch_break___15;
  case_257___9: /* CIL Label */ 
#line 5666
  if (*((long double *)*(ast + sizeof(char *))) <= *((long double *)*ast)) {
    {
#line 5667
    vtrue();
    }
  } else {
    {
#line 5669
    vfalse();
    }
  }
#line 5674
  pc += sizeof(struct OPERAND_0_mi );
#line 5675
  goto switch_break___15;
  case_512___10: /* CIL Label */ 
#line 5679
  if (*((float *)*(ast + sizeof(char *))) <= *((float *)*ast)) {
    {
#line 5680
    vtrue();
    }
  } else {
    {
#line 5682
    vfalse();
    }
  }
#line 5687
  pc += sizeof(struct OPERAND_0_mi );
#line 5688
  goto switch_break___15;
  switch_default___14: /* CIL Label */ 
  {
#line 5706
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           5706);
#line 5707
  error_message(5001);
#line 5708
  abort();
  }
  switch_break___15: /* CIL Label */ ;
  }
#line 5710
  goto switch_break;
  case_23___0: /* CIL Label */ 
  {
#line 5716
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 5716
    goto case_0___14;
  }
#line 5729
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 5729
    goto case_1___15;
  }
#line 5742
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 5742
    goto case_2___14;
  }
#line 5755
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 5755
    goto case_3___13;
  }
#line 5768
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 5768
    goto case_256___11;
  }
#line 5781
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 5781
    goto case_257___10;
  }
#line 5794
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 5794
    goto case_512___11;
  }
#line 5821
  goto switch_default___15;
  case_0___14: /* CIL Label */ 
#line 5717
  if (*((int *)*(ast + sizeof(char *))) >= *((int *)*ast)) {
    {
#line 5718
    vtrue();
    }
  } else {
    {
#line 5720
    vfalse();
    }
  }
#line 5725
  pc += sizeof(struct OPERAND_0_mi );
#line 5726
  goto switch_break___16;
  case_1___15: /* CIL Label */ 
#line 5730
  if (*((unsigned int *)*(ast + sizeof(char *))) >= *((unsigned int *)*ast)) {
    {
#line 5731
    vtrue();
    }
  } else {
    {
#line 5733
    vfalse();
    }
  }
#line 5738
  pc += sizeof(struct OPERAND_0_mi );
#line 5739
  goto switch_break___16;
  case_2___14: /* CIL Label */ 
#line 5743
  if (*((long *)*(ast + sizeof(char *))) >= *((long *)*ast)) {
    {
#line 5744
    vtrue();
    }
  } else {
    {
#line 5746
    vfalse();
    }
  }
#line 5751
  pc += sizeof(struct OPERAND_0_mi );
#line 5752
  goto switch_break___16;
  case_3___13: /* CIL Label */ 
#line 5756
  if (*((unsigned long *)*(ast + sizeof(char *))) >= *((unsigned long *)*ast)) {
    {
#line 5757
    vtrue();
    }
  } else {
    {
#line 5759
    vfalse();
    }
  }
#line 5764
  pc += sizeof(struct OPERAND_0_mi );
#line 5765
  goto switch_break___16;
  case_256___11: /* CIL Label */ 
#line 5769
  if (*((double *)*(ast + sizeof(char *))) >= *((double *)*ast)) {
    {
#line 5770
    vtrue();
    }
  } else {
    {
#line 5772
    vfalse();
    }
  }
#line 5777
  pc += sizeof(struct OPERAND_0_mi );
#line 5778
  goto switch_break___16;
  case_257___10: /* CIL Label */ 
#line 5782
  if (*((long double *)*(ast + sizeof(char *))) >= *((long double *)*ast)) {
    {
#line 5783
    vtrue();
    }
  } else {
    {
#line 5785
    vfalse();
    }
  }
#line 5790
  pc += sizeof(struct OPERAND_0_mi );
#line 5791
  goto switch_break___16;
  case_512___11: /* CIL Label */ 
#line 5795
  if (*((float *)*(ast + sizeof(char *))) >= *((float *)*ast)) {
    {
#line 5796
    vtrue();
    }
  } else {
    {
#line 5798
    vfalse();
    }
  }
#line 5803
  pc += sizeof(struct OPERAND_0_mi );
#line 5804
  goto switch_break___16;
  switch_default___15: /* CIL Label */ 
  {
#line 5822
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           5822);
#line 5823
  error_message(5001);
#line 5824
  abort();
  }
  switch_break___16: /* CIL Label */ ;
  }
#line 5826
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 5832
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 5832
    goto case_0___15;
  }
#line 5845
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 5845
    goto case_1___16;
  }
#line 5858
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 5858
    goto case_2___15;
  }
#line 5871
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 5871
    goto case_3___14;
  }
#line 5884
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 5884
    goto case_256___12;
  }
#line 5897
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 5897
    goto case_257___11;
  }
#line 5910
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 5910
    goto case_512___12;
  }
#line 5937
  goto switch_default___16;
  case_0___15: /* CIL Label */ 
#line 5833
  if (*((int *)*(ast + sizeof(char *))) != *((int *)*ast)) {
    {
#line 5834
    vtrue();
    }
  } else {
    {
#line 5836
    vfalse();
    }
  }
#line 5841
  pc += sizeof(struct OPERAND_0_mi );
#line 5842
  goto switch_break___17;
  case_1___16: /* CIL Label */ 
#line 5846
  if (*((unsigned int *)*(ast + sizeof(char *))) != *((unsigned int *)*ast)) {
    {
#line 5847
    vtrue();
    }
  } else {
    {
#line 5849
    vfalse();
    }
  }
#line 5854
  pc += sizeof(struct OPERAND_0_mi );
#line 5855
  goto switch_break___17;
  case_2___15: /* CIL Label */ 
#line 5859
  if (*((long *)*(ast + sizeof(char *))) != *((long *)*ast)) {
    {
#line 5860
    vtrue();
    }
  } else {
    {
#line 5862
    vfalse();
    }
  }
#line 5867
  pc += sizeof(struct OPERAND_0_mi );
#line 5868
  goto switch_break___17;
  case_3___14: /* CIL Label */ 
#line 5872
  if (*((unsigned long *)*(ast + sizeof(char *))) != *((unsigned long *)*ast)) {
    {
#line 5873
    vtrue();
    }
  } else {
    {
#line 5875
    vfalse();
    }
  }
#line 5880
  pc += sizeof(struct OPERAND_0_mi );
#line 5881
  goto switch_break___17;
  case_256___12: /* CIL Label */ 
#line 5885
  if (*((double *)*(ast + sizeof(char *))) != *((double *)*ast)) {
    {
#line 5886
    vtrue();
    }
  } else {
    {
#line 5888
    vfalse();
    }
  }
#line 5893
  pc += sizeof(struct OPERAND_0_mi );
#line 5894
  goto switch_break___17;
  case_257___11: /* CIL Label */ 
#line 5898
  if (*((long double *)*(ast + sizeof(char *))) != *((long double *)*ast)) {
    {
#line 5899
    vtrue();
    }
  } else {
    {
#line 5901
    vfalse();
    }
  }
#line 5906
  pc += sizeof(struct OPERAND_0_mi );
#line 5907
  goto switch_break___17;
  case_512___12: /* CIL Label */ 
#line 5911
  if (*((float *)*(ast + sizeof(char *))) != *((float *)*ast)) {
    {
#line 5912
    vtrue();
    }
  } else {
    {
#line 5914
    vfalse();
    }
  }
#line 5919
  pc += sizeof(struct OPERAND_0_mi );
#line 5920
  goto switch_break___17;
  switch_default___16: /* CIL Label */ 
  {
#line 5938
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           5938);
#line 5939
  error_message(5001);
#line 5940
  abort();
  }
  switch_break___17: /* CIL Label */ ;
  }
#line 5942
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 5948
  if (((struct OPERAND_0_mi *)pc1)->minor == 0) {
#line 5948
    goto case_0___16;
  }
#line 5969
  if (((struct OPERAND_0_mi *)pc1)->minor == 1) {
#line 5969
    goto case_1___17;
  }
#line 5990
  if (((struct OPERAND_0_mi *)pc1)->minor == 2) {
#line 5990
    goto case_2___16;
  }
#line 6011
  if (((struct OPERAND_0_mi *)pc1)->minor == 3) {
#line 6011
    goto case_3___15;
  }
#line 6032
  if (((struct OPERAND_0_mi *)pc1)->minor == 256) {
#line 6032
    goto case_256___13;
  }
#line 6053
  if (((struct OPERAND_0_mi *)pc1)->minor == 257) {
#line 6053
    goto case_257___12;
  }
#line 6074
  if (((struct OPERAND_0_mi *)pc1)->minor == 512) {
#line 6074
    goto case_512___13;
  }
#line 6117
  goto switch_default___17;
  case_0___16: /* CIL Label */ 
#line 5949
  if (! *((int *)*ast)) {
    {
#line 5952
    ast -= sizeof(char *);
#line 5953
    vtrue();
    }
  } else {
    {
#line 5958
    ast -= sizeof(char *);
#line 5959
    vfalse();
    }
  }
#line 5965
  pc += sizeof(struct OPERAND_0_mi );
#line 5966
  goto switch_break___18;
  case_1___17: /* CIL Label */ 
#line 5970
  if (! *((unsigned int *)*ast)) {
    {
#line 5973
    ast -= sizeof(char *);
#line 5974
    vtrue();
    }
  } else {
    {
#line 5979
    ast -= sizeof(char *);
#line 5980
    vfalse();
    }
  }
#line 5986
  pc += sizeof(struct OPERAND_0_mi );
#line 5987
  goto switch_break___18;
  case_2___16: /* CIL Label */ 
#line 5991
  if (! *((long *)*ast)) {
    {
#line 5994
    ast -= sizeof(char *);
#line 5995
    vtrue();
    }
  } else {
    {
#line 6000
    ast -= sizeof(char *);
#line 6001
    vfalse();
    }
  }
#line 6007
  pc += sizeof(struct OPERAND_0_mi );
#line 6008
  goto switch_break___18;
  case_3___15: /* CIL Label */ 
#line 6012
  if (! *((unsigned long *)*ast)) {
    {
#line 6015
    ast -= sizeof(char *);
#line 6016
    vtrue();
    }
  } else {
    {
#line 6021
    ast -= sizeof(char *);
#line 6022
    vfalse();
    }
  }
#line 6028
  pc += sizeof(struct OPERAND_0_mi );
#line 6029
  goto switch_break___18;
  case_256___13: /* CIL Label */ 
#line 6033
  if (! *((double *)*ast)) {
    {
#line 6036
    ast -= sizeof(char *);
#line 6037
    vtrue();
    }
  } else {
    {
#line 6042
    ast -= sizeof(char *);
#line 6043
    vfalse();
    }
  }
#line 6049
  pc += sizeof(struct OPERAND_0_mi );
#line 6050
  goto switch_break___18;
  case_257___12: /* CIL Label */ 
#line 6054
  if (! *((long double *)*ast)) {
    {
#line 6057
    ast -= sizeof(char *);
#line 6058
    vtrue();
    }
  } else {
    {
#line 6063
    ast -= sizeof(char *);
#line 6064
    vfalse();
    }
  }
#line 6070
  pc += sizeof(struct OPERAND_0_mi );
#line 6071
  goto switch_break___18;
  case_512___13: /* CIL Label */ 
#line 6075
  if (! *((float *)*ast)) {
    {
#line 6078
    ast -= sizeof(char *);
#line 6079
    vtrue();
    }
  } else {
    {
#line 6084
    ast -= sizeof(char *);
#line 6085
    vfalse();
    }
  }
#line 6091
  pc += sizeof(struct OPERAND_0_mi );
#line 6092
  goto switch_break___18;
  switch_default___17: /* CIL Label */ 
  {
#line 6118
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           6118);
#line 6119
  error_message(5001);
#line 6120
  abort();
  }
  switch_break___18: /* CIL Label */ ;
  }
#line 6122
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 6125
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 6126
  *((int *)tmp) = ~ *((int *)*ast);
#line 6127
  *ast = tmp;
#line 6132
  pc += sizeof(struct OPERAND_0_ma );
  }
#line 6133
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 6136
  binar = *((int *)*(ast + sizeof(char *))) << *((int *)*ast);
#line 6137
  ast += sizeof(char *);
#line 6138
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 6139
  *ast = tmp;
#line 6140
  *((int *)*ast) = binar;
#line 6145
  pc += sizeof(struct OPERAND_0_ma );
  }
#line 6146
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 6149
  binar = *((int *)*(ast + sizeof(char *))) >> *((int *)*ast);
#line 6150
  ast += sizeof(char *);
#line 6151
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 6152
  *ast = tmp;
#line 6153
  *((int *)*ast) = binar;
#line 6158
  pc += sizeof(struct OPERAND_0_ma );
  }
#line 6159
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 6162
  binar = *((int *)*(ast + sizeof(char *))) ^ *((int *)*ast);
#line 6163
  ast += sizeof(char *);
#line 6164
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 6165
  *ast = tmp;
#line 6166
  *((int *)*ast) = binar;
#line 6171
  pc += sizeof(struct OPERAND_0_ma );
  }
#line 6172
  goto switch_break;
  case_35: /* CIL Label */ 
#line 6179
  pc += sizeof(struct OPERAND_0_ma );
#line 6180
  return (-1);
#line 6181
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 6189
  interrupt_service_sync();
#line 6191
  pc += sizeof(struct OPERAND_0_ma );
  }
#line 6192
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 6199
  pc += sizeof(struct OPERAND_0_ma );
#line 6201
  restore_context();
  }
#line 6202
  if (clif_interrupt_level <= 0) {
#line 6202
    tmp___14 = clif_interrupt_level;
  } else {
#line 6202
    clif_interrupt_level --;
#line 6202
    tmp___14 = clif_interrupt_level;
  }
  {
#line 6202
  fprintfx(stderr, "\nclif interrupt level %d\n", tmp___14);
  }
#line 6205
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 6211
  if (((struct OPERAND_1_i *)pc1)->minor == 0) {
#line 6211
    goto case_0___17;
  }
#line 6228
  if (((struct OPERAND_1_i *)pc1)->minor == 1) {
#line 6228
    goto case_1___18;
  }
#line 6245
  if (((struct OPERAND_1_i *)pc1)->minor == 2) {
#line 6245
    goto case_2___17;
  }
#line 6262
  if (((struct OPERAND_1_i *)pc1)->minor == 3) {
#line 6262
    goto case_3___16;
  }
#line 6279
  if (((struct OPERAND_1_i *)pc1)->minor == 4) {
#line 6279
    goto case_4___4;
  }
#line 6297
  if (((struct OPERAND_1_i *)pc1)->minor == 5) {
#line 6297
    goto case_5___3;
  }
#line 6315
  if (((struct OPERAND_1_i *)pc1)->minor == 256) {
#line 6315
    goto case_256___14;
  }
#line 6337
  if (((struct OPERAND_1_i *)pc1)->minor == 257) {
#line 6337
    goto case_257___13;
  }
#line 6359
  if (((struct OPERAND_1_i *)pc1)->minor == 512) {
#line 6359
    goto case_512___14;
  }
#line 6381
  if (((struct OPERAND_1_i *)pc1)->minor == 768) {
#line 6381
    goto case_768___1;
  }
#line 6399
  if (((struct OPERAND_1_i *)pc1)->minor == 769) {
#line 6399
    goto case_769___1;
  }
#line 6421
  if (((struct OPERAND_1_i *)pc1)->minor == 770) {
#line 6421
    goto case_770___1;
  }
#line 6439
  if (((struct OPERAND_1_i *)pc1)->minor == 771) {
#line 6439
    goto case_771___1;
  }
#line 6456
  goto switch_default___18;
  case_0___17: /* CIL Label */ 
  {
#line 6212
  ast -= sizeof(char *);
#line 6213
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 6214
  *ast = tmp;
#line 6215
  *((int *)*ast) = ((struct OPERAND_1_i *)pc1)->num;
#line 6224
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6225
  goto switch_break___19;
  case_1___18: /* CIL Label */ 
  {
#line 6229
  ast -= sizeof(char *);
#line 6230
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 6231
  *ast = tmp;
#line 6232
  *((unsigned int *)*ast) = ((struct OPERAND_1_ui *)pc1)->num;
#line 6241
  pc += sizeof(struct OPERAND_1_ui );
  }
#line 6242
  goto switch_break___19;
  case_2___17: /* CIL Label */ 
  {
#line 6246
  ast -= sizeof(char *);
#line 6247
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 6248
  *ast = tmp;
#line 6249
  *((long *)*ast) = ((struct OPERAND_1_li *)pc1)->num;
#line 6258
  pc += sizeof(struct OPERAND_1_li );
  }
#line 6259
  goto switch_break___19;
  case_3___16: /* CIL Label */ 
  {
#line 6263
  ast -= sizeof(char *);
#line 6264
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 6265
  *ast = tmp;
#line 6266
  *((unsigned long *)*ast) = ((struct OPERAND_1_lui *)pc1)->num;
#line 6275
  pc += sizeof(struct OPERAND_1_lui );
  }
#line 6276
  goto switch_break___19;
  case_4___4: /* CIL Label */ 
  {
#line 6280
  ast -= sizeof(char *);
#line 6281
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 6282
  *ast = tmp;
#line 6283
  *((short *)*ast) = ((struct OPERAND_1_si *)pc1)->num;
#line 6292
  pc += sizeof(struct OPERAND_1_si );
#line 6293
  align_memory(& pc, (int )sizeof(int ));
  }
#line 6294
  goto switch_break___19;
  case_5___3: /* CIL Label */ 
  {
#line 6298
  ast -= sizeof(char *);
#line 6299
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 6300
  *ast = tmp;
#line 6301
  *((unsigned short *)*ast) = ((struct OPERAND_1_sui *)pc1)->num;
#line 6310
  pc += sizeof(struct OPERAND_1_sui );
#line 6311
  align_memory(& pc, (int )sizeof(int ));
  }
#line 6312
  goto switch_break___19;
  case_256___14: /* CIL Label */ 
  {
#line 6316
  ast -= sizeof(char *);
#line 6317
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 6318
  *ast = tmp;
#line 6322
  pc1 += sizeof(struct OPERAND_0_mi );
#line 6323
  align_memory(& pc1, (int )sizeof(double ));
#line 6324
  *((double *)*ast) = *((double *)pc1);
#line 6332
  pc1 += sizeof(double );
#line 6333
  pc = pc1;
  }
#line 6334
  goto switch_break___19;
  case_257___13: /* CIL Label */ 
  {
#line 6338
  ast -= sizeof(char *);
#line 6339
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 6340
  *ast = tmp;
#line 6344
  pc1 += sizeof(struct OPERAND_0_mi );
#line 6345
  align_memory(& pc1, (int )sizeof(long double ));
#line 6346
  *((long double *)*ast) = *((long double *)pc1);
#line 6354
  pc1 += sizeof(long double );
#line 6355
  pc = pc1;
  }
#line 6356
  goto switch_break___19;
  case_512___14: /* CIL Label */ 
  {
#line 6360
  ast -= sizeof(char *);
#line 6361
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 6362
  *ast = tmp;
#line 6366
  pc1 += sizeof(struct OPERAND_0_mi );
#line 6367
  align_memory(& pc1, (int )sizeof(float ));
#line 6368
  *((float *)*ast) = *((float *)pc1);
#line 6376
  pc1 += sizeof(float );
#line 6377
  pc = pc1;
  }
#line 6378
  goto switch_break___19;
  case_768___1: /* CIL Label */ 
  {
#line 6382
  ast -= sizeof(char *);
#line 6383
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 6384
  *ast = tmp;
#line 6385
  *(*ast) = ((struct OPERAND_1_ic *)pc1)->num;
#line 6394
  pc += sizeof(struct OPERAND_1_ic );
#line 6395
  align_memory(& pc, (int )sizeof(int ));
  }
#line 6396
  goto switch_break___19;
  case_769___1: /* CIL Label */ 
  {
#line 6400
  ast -= sizeof(char *);
#line 6401
  tmp___15 = (int )strlen(((struct OPERAND_1_mi *)pc1)->adr);
#line 6401
  binar = tmp___15 + 1;
#line 6407
  tmp -= binar;
#line 6408
  *ast = tmp;
#line 6409
  strcpy(*ast, ((struct OPERAND_1_mi *)pc1)->adr);
#line 6417
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6418
  goto switch_break___19;
  case_770___1: /* CIL Label */ 
  {
#line 6422
  ast -= sizeof(char *);
#line 6423
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 6424
  *ast = tmp;
#line 6425
  *((signed char *)*ast) = ((struct OPERAND_1_isc *)pc1)->num;
#line 6434
  pc += sizeof(struct OPERAND_1_isc );
#line 6435
  align_memory(& pc, (int )sizeof(int ));
  }
#line 6436
  goto switch_break___19;
  case_771___1: /* CIL Label */ 
  {
#line 6440
  ast -= sizeof(char *);
#line 6441
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 6442
  *ast = tmp;
#line 6443
  *((unsigned char *)*ast) = ((struct OPERAND_1_iuc *)pc1)->num;
#line 6452
  pc += sizeof(struct OPERAND_1_iuc );
#line 6453
  align_memory(& pc, (int )sizeof(int ));
  }
#line 6454
  goto switch_break___19;
  switch_default___18: /* CIL Label */ 
  {
#line 6457
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           6457);
#line 6458
  error_message(5001);
#line 6459
  abort();
  }
  switch_break___19: /* CIL Label */ ;
  }
#line 6461
  goto switch_break;
  case_30___0: /* CIL Label */ 
  {
#line 6467
  if (((struct OPERAND_1_mi *)pc1)->minor == 0) {
#line 6467
    goto case_0___18;
  }
#line 6478
  if (((struct OPERAND_1_mi *)pc1)->minor == 1) {
#line 6478
    goto case_1___19;
  }
#line 6489
  if (((struct OPERAND_1_mi *)pc1)->minor == 2) {
#line 6489
    goto case_2___18;
  }
#line 6500
  if (((struct OPERAND_1_mi *)pc1)->minor == 3) {
#line 6500
    goto case_3___17;
  }
#line 6513
  if (((struct OPERAND_1_mi *)pc1)->minor == 4) {
#line 6513
    goto case_4___5;
  }
#line 6526
  if (((struct OPERAND_1_mi *)pc1)->minor == 5) {
#line 6526
    goto case_5___4;
  }
#line 6539
  if (((struct OPERAND_1_mi *)pc1)->minor == 256) {
#line 6539
    goto case_256___15;
  }
#line 6550
  if (((struct OPERAND_1_mi *)pc1)->minor == 257) {
#line 6550
    goto case_257___14;
  }
#line 6562
  if (((struct OPERAND_1_mi *)pc1)->minor == 258) {
#line 6562
    goto case_258___0;
  }
#line 6574
  if (((struct OPERAND_1_mi *)pc1)->minor == 259) {
#line 6574
    goto case_259___0;
  }
#line 6588
  if (((struct OPERAND_1_mi *)pc1)->minor == 260) {
#line 6588
    goto case_260;
  }
#line 6602
  if (((struct OPERAND_1_mi *)pc1)->minor == 261) {
#line 6602
    goto case_261;
  }
#line 6616
  if (((struct OPERAND_1_mi *)pc1)->minor == 512) {
#line 6616
    goto case_512___15;
  }
#line 6627
  if (((struct OPERAND_1_mi *)pc1)->minor == 513) {
#line 6627
    goto case_513___0;
  }
#line 6638
  if (((struct OPERAND_1_mi *)pc1)->minor == 514) {
#line 6638
    goto case_514;
  }
#line 6650
  if (((struct OPERAND_1_mi *)pc1)->minor == 515) {
#line 6650
    goto case_515;
  }
#line 6664
  if (((struct OPERAND_1_mi *)pc1)->minor == 516) {
#line 6664
    goto case_516;
  }
#line 6678
  if (((struct OPERAND_1_mi *)pc1)->minor == 517) {
#line 6678
    goto case_517;
  }
#line 6692
  if (((struct OPERAND_1_mi *)pc1)->minor == 768) {
#line 6692
    goto case_768___2;
  }
#line 6704
  if (((struct OPERAND_1_mi *)pc1)->minor == 769) {
#line 6704
    goto case_769___2;
  }
#line 6716
  if (((struct OPERAND_1_mi *)pc1)->minor == 770) {
#line 6716
    goto case_770___2;
  }
#line 6728
  if (((struct OPERAND_1_mi *)pc1)->minor == 771) {
#line 6728
    goto case_771___2;
  }
#line 6744
  if (((struct OPERAND_1_mi *)pc1)->minor == 772) {
#line 6744
    goto case_772___0;
  }
#line 6760
  if (((struct OPERAND_1_mi *)pc1)->minor == 773) {
#line 6760
    goto case_773___0;
  }
#line 6775
  goto switch_default___19;
  case_0___18: /* CIL Label */ 
  {
#line 6468
  printfx((char *)"%d\n", *((int *)((struct OPERAND_1_mi *)pc1)->adr));
#line 6474
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6475
  goto switch_break___20;
  case_1___19: /* CIL Label */ 
  {
#line 6479
  printfx((char *)"%d\n", *((int *)(bp + ((struct OPERAND_1_i *)pc1)->num)));
#line 6485
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6486
  goto switch_break___20;
  case_2___18: /* CIL Label */ 
  {
#line 6490
  printfx((char *)"%d\n", *((int *)*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num))));
#line 6496
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6497
  goto switch_break___20;
  case_3___17: /* CIL Label */ 
  {
#line 6501
  printfx((char *)"%d\n", *((int *)(((struct OPERAND_1_mi *)pc1)->adr + (unsigned long )*((int *)*ast) * sizeof(int ))));
#line 6509
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6510
  goto switch_break___20;
  case_4___5: /* CIL Label */ 
  {
#line 6514
  printfx((char *)"%d\n", *((int *)((bp + ((struct OPERAND_1_i *)pc1)->num) + (unsigned long )*((int *)*ast) * sizeof(int ))));
#line 6522
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6523
  goto switch_break___20;
  case_5___4: /* CIL Label */ 
  {
#line 6527
  printfx((char *)"%d\n", *((int *)(*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)) + (unsigned long )*((int *)*ast) * sizeof(int ))));
#line 6535
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6536
  goto switch_break___20;
  case_256___15: /* CIL Label */ 
  {
#line 6540
  printfx((char *)"%lg\n", *((double *)((struct OPERAND_1_mi *)pc1)->adr));
#line 6546
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6547
  goto switch_break___20;
  case_257___14: /* CIL Label */ 
  {
#line 6551
  printfx((char *)"%lg\n", *((double *)(bp + ((struct OPERAND_1_i *)pc1)->num)));
#line 6558
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6559
  goto switch_break___20;
  case_258___0: /* CIL Label */ 
  {
#line 6563
  printfx((char *)"%lg\n", *((double *)*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num))));
#line 6570
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6571
  goto switch_break___20;
  case_259___0: /* CIL Label */ 
  {
#line 6575
  printfx((char *)"%lg\n", *((double *)(((struct OPERAND_1_mi *)pc1)->adr + (unsigned long )*((int *)*ast) * sizeof(double ))));
#line 6584
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6585
  goto switch_break___20;
  case_260: /* CIL Label */ 
  {
#line 6589
  printfx((char *)"%lg\n", *((double *)((bp + ((struct OPERAND_1_i *)pc1)->num) + (unsigned long )*((int *)*ast) * sizeof(double ))));
#line 6598
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6599
  goto switch_break___20;
  case_261: /* CIL Label */ 
  {
#line 6603
  printfx((char *)"%lg\n", *((double *)(*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)) + (unsigned long )*((int *)*ast) * sizeof(double ))));
#line 6612
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6613
  goto switch_break___20;
  case_512___15: /* CIL Label */ 
  {
#line 6617
  printfx((char *)"%g\n", (double )*((float *)((struct OPERAND_1_mi *)pc1)->adr));
#line 6623
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6624
  goto switch_break___20;
  case_513___0: /* CIL Label */ 
  {
#line 6628
  printfx((char *)"%g\n", (double )*((float *)(bp + ((struct OPERAND_1_i *)pc1)->num)));
#line 6634
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6635
  goto switch_break___20;
  case_514: /* CIL Label */ 
  {
#line 6639
  printfx((char *)"%g\n", (double )*((float *)*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num))));
#line 6646
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6647
  goto switch_break___20;
  case_515: /* CIL Label */ 
  {
#line 6651
  printfx((char *)"%g\n", (double )*((float *)(((struct OPERAND_1_mi *)pc1)->adr + (unsigned long )*((int *)*ast) * sizeof(float ))));
#line 6660
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6661
  goto switch_break___20;
  case_516: /* CIL Label */ 
  {
#line 6665
  printfx((char *)"%g\n", (double )*((float *)((bp + ((struct OPERAND_1_i *)pc1)->num) + (unsigned long )*((int *)*ast) * sizeof(float ))));
#line 6674
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6675
  goto switch_break___20;
  case_517: /* CIL Label */ 
  {
#line 6679
  printfx((char *)"%g\n", (double )*((float *)(*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)) + (unsigned long )*((int *)*ast) * sizeof(float ))));
#line 6688
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6689
  goto switch_break___20;
  case_768___2: /* CIL Label */ 
  {
#line 6693
  printfx((char *)"%d\n", (int )*(((struct OPERAND_1_mi *)pc1)->adr));
#line 6700
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6701
  goto switch_break___20;
  case_769___2: /* CIL Label */ 
  {
#line 6705
  printfx((char *)"%d\n", (int )*(bp + ((struct OPERAND_1_i *)pc1)->num));
#line 6712
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6713
  goto switch_break___20;
  case_770___2: /* CIL Label */ 
  {
#line 6717
  printfx((char *)"%d\n", (int )*(*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num))));
#line 6724
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6725
  goto switch_break___20;
  case_771___2: /* CIL Label */ 
  {
#line 6729
  printfx((char *)"%d\n", (int )*(((struct OPERAND_1_mi *)pc1)->adr + (unsigned long )*((int *)*ast) * sizeof(char )));
#line 6740
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6741
  goto switch_break___20;
  case_772___0: /* CIL Label */ 
  {
#line 6745
  printfx((char *)"%d\n", (int )*((bp + ((struct OPERAND_1_i *)pc1)->num) + (unsigned long )*((int *)*ast) * sizeof(char )));
#line 6756
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6757
  goto switch_break___20;
  case_773___0: /* CIL Label */ 
  {
#line 6761
  printfx((char *)"%d\n", (int )*(*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)) + (unsigned long )*((int *)*ast) * sizeof(char )));
#line 6772
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6773
  goto switch_break___20;
  switch_default___19: /* CIL Label */ 
  {
#line 6776
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           6776);
#line 6777
  error_message(5001);
#line 6778
  abort();
  }
  switch_break___20: /* CIL Label */ ;
  }
#line 6780
  goto switch_break;
  case_31___0: /* CIL Label */ 
  {
#line 6786
  if (((struct OPERAND_1_mi *)pc1)->minor == 0) {
#line 6786
    goto case_0___19;
  }
#line 6801
  if (((struct OPERAND_1_mi *)pc1)->minor == 1) {
#line 6801
    goto case_1___20;
  }
#line 6817
  if (((struct OPERAND_1_mi *)pc1)->minor == 2) {
#line 6817
    goto case_2___19;
  }
#line 6833
  if (((struct OPERAND_1_mi *)pc1)->minor == 3) {
#line 6833
    goto case_3___18;
  }
#line 6852
  if (((struct OPERAND_1_mi *)pc1)->minor == 4) {
#line 6852
    goto case_4___6;
  }
#line 6871
  if (((struct OPERAND_1_mi *)pc1)->minor == 5) {
#line 6871
    goto case_5___5;
  }
#line 6890
  if (((struct OPERAND_1_mi *)pc1)->minor == 256) {
#line 6890
    goto case_256___16;
  }
#line 6905
  if (((struct OPERAND_1_mi *)pc1)->minor == 257) {
#line 6905
    goto case_257___15;
  }
#line 6921
  if (((struct OPERAND_1_mi *)pc1)->minor == 258) {
#line 6921
    goto case_258___1;
  }
#line 6937
  if (((struct OPERAND_1_mi *)pc1)->minor == 259) {
#line 6937
    goto case_259___1;
  }
#line 6956
  if (((struct OPERAND_1_mi *)pc1)->minor == 260) {
#line 6956
    goto case_260___0;
  }
#line 6975
  if (((struct OPERAND_1_mi *)pc1)->minor == 261) {
#line 6975
    goto case_261___0;
  }
#line 6994
  if (((struct OPERAND_1_mi *)pc1)->minor == 512) {
#line 6994
    goto case_512___16;
  }
#line 7009
  if (((struct OPERAND_1_mi *)pc1)->minor == 513) {
#line 7009
    goto case_513___1;
  }
#line 7025
  if (((struct OPERAND_1_mi *)pc1)->minor == 514) {
#line 7025
    goto case_514___0;
  }
#line 7041
  if (((struct OPERAND_1_mi *)pc1)->minor == 515) {
#line 7041
    goto case_515___0;
  }
#line 7060
  if (((struct OPERAND_1_mi *)pc1)->minor == 516) {
#line 7060
    goto case_516___0;
  }
#line 7079
  if (((struct OPERAND_1_mi *)pc1)->minor == 517) {
#line 7079
    goto case_517___0;
  }
#line 7098
  if (((struct OPERAND_1_mi *)pc1)->minor == 768) {
#line 7098
    goto case_768___3;
  }
#line 7113
  if (((struct OPERAND_1_mi *)pc1)->minor == 769) {
#line 7113
    goto case_769___3;
  }
#line 7130
  if (((struct OPERAND_1_mi *)pc1)->minor == 770) {
#line 7130
    goto case_770___3;
  }
#line 7147
  if (((struct OPERAND_1_mi *)pc1)->minor == 771) {
#line 7147
    goto case_771___3;
  }
#line 7168
  if (((struct OPERAND_1_mi *)pc1)->minor == 772) {
#line 7168
    goto case_772___1;
  }
#line 7189
  if (((struct OPERAND_1_mi *)pc1)->minor == 773) {
#line 7189
    goto case_773___1;
  }
#line 7209
  goto switch_default___20;
  case_0___19: /* CIL Label */ 
  {
#line 6787
  scanf((char const   */* __restrict  */)"%d", (int *)((struct OPERAND_1_mi *)pc1)->adr);
#line 6797
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6798
  goto switch_break___21;
  case_1___20: /* CIL Label */ 
  {
#line 6802
  scanf((char const   */* __restrict  */)"%d", (int *)(bp + ((struct OPERAND_1_i *)pc1)->num));
#line 6813
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6814
  goto switch_break___21;
  case_2___19: /* CIL Label */ 
  {
#line 6818
  scanf((char const   */* __restrict  */)"%d", (int *)*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)));
#line 6829
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6830
  goto switch_break___21;
  case_3___18: /* CIL Label */ 
  {
#line 6834
  scanf((char const   */* __restrict  */)"%d", (int *)(((struct OPERAND_1_mi *)pc1)->adr + (unsigned long )*((int *)*ast) * sizeof(int )));
#line 6848
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6849
  goto switch_break___21;
  case_4___6: /* CIL Label */ 
  {
#line 6853
  scanf((char const   */* __restrict  */)"%d", (int *)((bp + ((struct OPERAND_1_i *)pc1)->num) + (unsigned long )*((int *)*ast) * sizeof(int )));
#line 6867
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6868
  goto switch_break___21;
  case_5___5: /* CIL Label */ 
  {
#line 6872
  scanf((char const   */* __restrict  */)"%d", (int *)(*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)) + (unsigned long )*((int *)*ast) * sizeof(int )));
#line 6886
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6887
  goto switch_break___21;
  case_256___16: /* CIL Label */ 
  {
#line 6891
  scanf((char const   */* __restrict  */)"%lf", (double *)((struct OPERAND_1_mi *)pc1)->adr);
#line 6901
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6902
  goto switch_break___21;
  case_257___15: /* CIL Label */ 
  {
#line 6906
  scanf((char const   */* __restrict  */)"%lf", (double *)(bp + ((struct OPERAND_1_i *)pc1)->num));
#line 6917
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6918
  goto switch_break___21;
  case_258___1: /* CIL Label */ 
  {
#line 6922
  scanf((char const   */* __restrict  */)"%lf", (double *)*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)));
#line 6933
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6934
  goto switch_break___21;
  case_259___1: /* CIL Label */ 
  {
#line 6938
  scanf((char const   */* __restrict  */)"%lf", (double *)(((struct OPERAND_1_mi *)pc1)->adr + (unsigned long )*((int *)*ast) * sizeof(double )));
#line 6952
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 6953
  goto switch_break___21;
  case_260___0: /* CIL Label */ 
  {
#line 6957
  scanf((char const   */* __restrict  */)"%lf", (double *)((bp + ((struct OPERAND_1_i *)pc1)->num) + (unsigned long )*((int *)*ast) * sizeof(double )));
#line 6971
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6972
  goto switch_break___21;
  case_261___0: /* CIL Label */ 
  {
#line 6976
  scanf((char const   */* __restrict  */)"%lf", (double *)(*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)) + (unsigned long )*((int *)*ast) * sizeof(double )));
#line 6990
  pc += sizeof(struct OPERAND_1_i );
  }
#line 6991
  goto switch_break___21;
  case_512___16: /* CIL Label */ 
  {
#line 6995
  scanf((char const   */* __restrict  */)"%f", (float *)((struct OPERAND_1_mi *)pc1)->adr);
#line 7005
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 7006
  goto switch_break___21;
  case_513___1: /* CIL Label */ 
  {
#line 7010
  scanf((char const   */* __restrict  */)"%f", (float *)(bp + ((struct OPERAND_1_i *)pc1)->num));
#line 7021
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7022
  goto switch_break___21;
  case_514___0: /* CIL Label */ 
  {
#line 7026
  scanf((char const   */* __restrict  */)"%f", (float *)*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)));
#line 7037
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7038
  goto switch_break___21;
  case_515___0: /* CIL Label */ 
  {
#line 7042
  scanf((char const   */* __restrict  */)"%f", (float *)(((struct OPERAND_1_mi *)pc1)->adr + (unsigned long )*((int *)*ast) * sizeof(float )));
#line 7056
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 7057
  goto switch_break___21;
  case_516___0: /* CIL Label */ 
  {
#line 7061
  scanf((char const   */* __restrict  */)"%f", (float *)((bp + ((struct OPERAND_1_i *)pc1)->num) + (unsigned long )*((int *)*ast) * sizeof(float )));
#line 7075
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7076
  goto switch_break___21;
  case_517___0: /* CIL Label */ 
  {
#line 7080
  scanf((char const   */* __restrict  */)"%f", (float *)(*((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)) + (unsigned long )*((int *)*ast) * sizeof(float )));
#line 7094
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7095
  goto switch_break___21;
  case_768___3: /* CIL Label */ 
  {
#line 7099
  scanf((char const   */* __restrict  */)"%1s", ((struct OPERAND_1_mi *)pc1)->adr);
#line 7109
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 7110
  goto switch_break___21;
  case_769___3: /* CIL Label */ 
  {
#line 7114
  scanf((char const   */* __restrict  */)"%1s", bp + ((struct OPERAND_1_i *)pc1)->num);
#line 7126
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7127
  goto switch_break___21;
  case_770___3: /* CIL Label */ 
  {
#line 7131
  scanf((char const   */* __restrict  */)"%1s", *((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)));
#line 7143
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7144
  goto switch_break___21;
  case_771___3: /* CIL Label */ 
  {
#line 7148
  scanf((char const   */* __restrict  */)"%1s", ((struct OPERAND_1_mi *)pc1)->adr + (unsigned long )*((int *)*ast) * sizeof(char ));
#line 7164
  pc += sizeof(struct OPERAND_1_mi );
  }
#line 7165
  goto switch_break___21;
  case_772___1: /* CIL Label */ 
  {
#line 7169
  scanf((char const   */* __restrict  */)"%1s", (bp + ((struct OPERAND_1_i *)pc1)->num) + (unsigned long )*((int *)*ast) * sizeof(char ));
#line 7185
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7186
  goto switch_break___21;
  case_773___1: /* CIL Label */ 
  {
#line 7190
  scanf((char const   */* __restrict  */)"%1s", *((char **)(bp + ((struct OPERAND_1_i *)pc1)->num)) + (unsigned long )*((int *)*ast) * sizeof(char ));
#line 7206
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7207
  goto switch_break___21;
  switch_default___20: /* CIL Label */ 
  {
#line 7210
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           7210);
#line 7211
  error_message(5001);
#line 7212
  abort();
  }
  switch_break___21: /* CIL Label */ ;
  }
#line 7214
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 7217
  printfx((char *)"%s\n", ((struct OPERAND_1_ma *)pc1)->adr);
#line 7222
  pc += sizeof(struct OPERAND_1_ma );
  }
#line 7223
  goto switch_break;
  case_25: /* CIL Label */ 
#line 7226
  pc = ((struct OPERAND_1_ma *)pc1)->adr;
#line 7234
  goto switch_break;
  case_27___0: /* CIL Label */ 
#line 7237
  if (*((int *)*ast) == 0) {
#line 7239
    pc = ((struct OPERAND_1_ma *)pc1)->adr;
  } else {
#line 7249
    pc += sizeof(struct OPERAND_1_ma );
  }
#line 7251
  ast += sizeof(char *);
#line 7252
  goto switch_break;
  case_34: /* CIL Label */ 
#line 7262
  pc += sizeof(struct OPERAND_0_ma );
#line 7263
  return (-2);
#line 7264
  goto switch_break;
  case_26___0: /* CIL Label */ 
#line 7267
  if (*((int *)*ast) != 0) {
#line 7269
    pc = ((struct OPERAND_1_ma *)pc1)->adr;
  } else {
#line 7279
    pc += sizeof(struct OPERAND_1_ma );
  }
#line 7281
  ast += sizeof(char *);
#line 7282
  goto switch_break;
  case_29___0: /* CIL Label */ 
  {
#line 7288
  if (((struct OPERAND_1_mi *)pc1)->minor == 0) {
#line 7288
    goto case_0___20;
  }
#line 7306
  if (((struct OPERAND_1_mi *)pc1)->minor == 1) {
#line 7306
    goto case_1___21;
  }
#line 7326
  if (((struct OPERAND_1_mi *)pc1)->minor == 2) {
#line 7326
    goto case_2___20;
  }
#line 7346
  if (((struct OPERAND_1_mi *)pc1)->minor == 3) {
#line 7346
    goto case_3___19;
  }
#line 7366
  if (((struct OPERAND_1_mi *)pc1)->minor == 4) {
#line 7366
    goto case_4___7;
  }
#line 7386
  if (((struct OPERAND_1_mi *)pc1)->minor == 5) {
#line 7386
    goto case_5___6;
  }
#line 7401
  if (((struct OPERAND_1_mi *)pc1)->minor == 6) {
#line 7401
    goto case_6___2;
  }
#line 7421
  if (((struct OPERAND_1_mi *)pc1)->minor == 7) {
#line 7421
    goto case_7___2;
  }
#line 7441
  if (((struct OPERAND_1_mi *)pc1)->minor == 8) {
#line 7441
    goto case_8___1;
  }
#line 7461
  if (((struct OPERAND_1_mi *)pc1)->minor == 9) {
#line 7461
    goto case_9___1;
  }
#line 7481
  if (((struct OPERAND_1_mi *)pc1)->minor == 10) {
#line 7481
    goto case_10___2;
  }
#line 7501
  if (((struct OPERAND_1_mi *)pc1)->minor == 11) {
#line 7501
    goto case_11___2;
  }
#line 7521
  if (((struct OPERAND_1_mi *)pc1)->minor == 12) {
#line 7521
    goto case_12___2;
  }
#line 7541
  if (((struct OPERAND_1_mi *)pc1)->minor == 13) {
#line 7541
    goto case_13___2;
  }
#line 7561
  if (((struct OPERAND_1_mi *)pc1)->minor == 14) {
#line 7561
    goto case_14___2;
  }
#line 7581
  if (((struct OPERAND_1_mi *)pc1)->minor == 15) {
#line 7581
    goto case_15___2;
  }
#line 7601
  if (((struct OPERAND_1_mi *)pc1)->minor == 16) {
#line 7601
    goto case_16___2;
  }
#line 7621
  if (((struct OPERAND_1_mi *)pc1)->minor == 17) {
#line 7621
    goto case_17___2;
  }
#line 7641
  if (((struct OPERAND_1_mi *)pc1)->minor == 18) {
#line 7641
    goto case_18___2;
  }
#line 7656
  if (((struct OPERAND_1_mi *)pc1)->minor == 19) {
#line 7656
    goto case_19___2;
  }
#line 7676
  if (((struct OPERAND_1_mi *)pc1)->minor == 20) {
#line 7676
    goto case_20___2;
  }
#line 7696
  if (((struct OPERAND_1_mi *)pc1)->minor == 21) {
#line 7696
    goto case_21___2;
  }
#line 7716
  if (((struct OPERAND_1_mi *)pc1)->minor == 22) {
#line 7716
    goto case_22___1;
  }
#line 7736
  if (((struct OPERAND_1_mi *)pc1)->minor == 23) {
#line 7736
    goto case_23___1;
  }
#line 7756
  if (((struct OPERAND_1_mi *)pc1)->minor == 24) {
#line 7756
    goto case_24___0;
  }
#line 7776
  if (((struct OPERAND_1_mi *)pc1)->minor == 25) {
#line 7776
    goto case_25___0;
  }
#line 7796
  if (((struct OPERAND_1_mi *)pc1)->minor == 26) {
#line 7796
    goto case_26___1;
  }
#line 7815
  goto switch_default___21;
  case_0___20: /* CIL Label */ 
#line 7289
  stack -= sizeof(char *);
#line 7291
  *((char **)stack) = pc + sizeof(struct OPERAND_1_mi );
#line 7295
  pc = ((struct OPERAND_1_mi *)pc1)->adr;
#line 7303
  goto switch_break___22;
  case_1___21: /* CIL Label */ 
#line 7307
  counter = 0;
  {
#line 7307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7307
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7307
      goto while_break;
    }
#line 7309
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7307
    counter ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7311
  ast -= sizeof(char *);
#line 7312
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7313
  *ast = tmp;
#line 7314
  *((int *)*ast) = (*((int (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7322
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7323
  goto switch_break___22;
  case_2___20: /* CIL Label */ 
#line 7327
  counter = 0;
  {
#line 7327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7327
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7327
      goto while_break___0;
    }
#line 7329
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7327
    counter ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7331
  ast -= sizeof(char *);
#line 7332
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 7333
  *ast = tmp;
#line 7334
  *((double *)*ast) = (*((double (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7342
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7343
  goto switch_break___22;
  case_3___19: /* CIL Label */ 
#line 7347
  counter = 0;
  {
#line 7347
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 7347
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7347
      goto while_break___1;
    }
#line 7349
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7347
    counter ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 7351
  ast -= sizeof(char *);
#line 7352
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 7353
  *ast = tmp;
#line 7354
  *((float *)*ast) = (*((float (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7362
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7363
  goto switch_break___22;
  case_4___7: /* CIL Label */ 
#line 7367
  counter = 0;
  {
#line 7367
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 7367
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7367
      goto while_break___2;
    }
#line 7369
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7367
    counter ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 7371
  ast -= sizeof(char *);
#line 7372
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7373
  *ast = tmp;
#line 7374
  *(*ast) = (*((char (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7382
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7383
  goto switch_break___22;
  case_5___6: /* CIL Label */ 
#line 7387
  counter = 0;
  {
#line 7387
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 7387
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7387
      goto while_break___3;
    }
#line 7389
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7387
    counter ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 7391
  (*(f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7397
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7398
  goto switch_break___22;
  case_6___2: /* CIL Label */ 
#line 7402
  counter = 0;
  {
#line 7402
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 7402
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7402
      goto while_break___4;
    }
#line 7404
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7402
    counter ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 7406
  ast -= sizeof(char *);
#line 7407
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 7408
  *ast = tmp;
#line 7409
  *((unsigned int *)*ast) = (*((unsigned int (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7417
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7418
  goto switch_break___22;
  case_7___2: /* CIL Label */ 
#line 7422
  counter = 0;
  {
#line 7422
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 7422
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7422
      goto while_break___5;
    }
#line 7424
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7422
    counter ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 7426
  ast -= sizeof(char *);
#line 7427
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 7428
  *ast = tmp;
#line 7429
  *((long *)*ast) = (*((long (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7437
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7438
  goto switch_break___22;
  case_8___1: /* CIL Label */ 
#line 7442
  counter = 0;
  {
#line 7442
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 7442
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7442
      goto while_break___6;
    }
#line 7444
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7442
    counter ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 7446
  ast -= sizeof(char *);
#line 7447
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 7448
  *ast = tmp;
#line 7449
  *((unsigned long *)*ast) = (*((unsigned long (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7457
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7458
  goto switch_break___22;
  case_9___1: /* CIL Label */ 
#line 7462
  counter = 0;
  {
#line 7462
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 7462
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7462
      goto while_break___7;
    }
#line 7464
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7462
    counter ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 7466
  ast -= sizeof(char *);
#line 7467
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 7468
  *ast = tmp;
#line 7469
  *((short *)*ast) = (*((short (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7477
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7478
  goto switch_break___22;
  case_10___2: /* CIL Label */ 
#line 7482
  counter = 0;
  {
#line 7482
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 7482
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7482
      goto while_break___8;
    }
#line 7484
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7482
    counter ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 7486
  ast -= sizeof(char *);
#line 7487
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 7488
  *ast = tmp;
#line 7489
  *((unsigned short *)*ast) = (*((unsigned short (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7497
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7498
  goto switch_break___22;
  case_11___2: /* CIL Label */ 
#line 7502
  counter = 0;
  {
#line 7502
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 7502
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7502
      goto while_break___9;
    }
#line 7504
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7502
    counter ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 7506
  ast -= sizeof(char *);
#line 7507
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 7508
  *ast = tmp;
#line 7509
  *((long double *)*ast) = (*((long double (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7517
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7518
  goto switch_break___22;
  case_12___2: /* CIL Label */ 
#line 7522
  counter = 0;
  {
#line 7522
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 7522
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7522
      goto while_break___10;
    }
#line 7524
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7522
    counter ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 7526
  ast -= sizeof(char *);
#line 7527
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7528
  *ast = tmp;
#line 7529
  *((signed char *)*ast) = (*((signed char (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7537
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7538
  goto switch_break___22;
  case_13___2: /* CIL Label */ 
#line 7542
  counter = 0;
  {
#line 7542
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 7542
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7542
      goto while_break___11;
    }
#line 7544
    adr_arg[counter] = *((char **)(stack + (unsigned long )counter * sizeof(char *)));
#line 7542
    counter ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 7546
  ast -= sizeof(char *);
#line 7547
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7548
  *ast = tmp;
#line 7549
  *((unsigned char *)*ast) = (*((unsigned char (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7557
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7558
  goto switch_break___22;
  case_14___2: /* CIL Label */ 
#line 7562
  counter = 0;
  {
#line 7562
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 7562
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7562
      goto while_break___12;
    }
#line 7564
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7562
    counter ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 7566
  ast -= sizeof(char *);
#line 7567
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7568
  *ast = tmp;
#line 7569
  *((int *)*ast) = (*((int (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7577
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7578
  goto switch_break___22;
  case_15___2: /* CIL Label */ 
#line 7582
  counter = 0;
  {
#line 7582
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 7582
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7582
      goto while_break___13;
    }
#line 7584
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7582
    counter ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 7586
  ast -= sizeof(char *);
#line 7587
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 7588
  *ast = tmp;
#line 7589
  *((double *)*ast) = (*((double (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7597
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7598
  goto switch_break___22;
  case_16___2: /* CIL Label */ 
#line 7602
  counter = 0;
  {
#line 7602
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 7602
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7602
      goto while_break___14;
    }
#line 7604
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7602
    counter ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 7606
  ast -= sizeof(char *);
#line 7607
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 7608
  *ast = tmp;
#line 7609
  *((float *)*ast) = (*((float (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7617
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7618
  goto switch_break___22;
  case_17___2: /* CIL Label */ 
#line 7622
  counter = 0;
  {
#line 7622
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 7622
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7622
      goto while_break___15;
    }
#line 7624
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7622
    counter ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 7626
  ast -= sizeof(char *);
#line 7627
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7628
  *ast = tmp;
#line 7629
  *(*ast) = (*((char (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7637
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7638
  goto switch_break___22;
  case_18___2: /* CIL Label */ 
#line 7642
  counter = 0;
  {
#line 7642
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 7642
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7642
      goto while_break___16;
    }
#line 7644
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7642
    counter ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 7646
  (*(f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7652
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7653
  goto switch_break___22;
  case_19___2: /* CIL Label */ 
#line 7657
  counter = 0;
  {
#line 7657
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 7657
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7657
      goto while_break___17;
    }
#line 7659
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7657
    counter ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 7661
  ast -= sizeof(char *);
#line 7662
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 7663
  *ast = tmp;
#line 7664
  *((unsigned int *)*ast) = (*((unsigned int (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7672
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7673
  goto switch_break___22;
  case_20___2: /* CIL Label */ 
#line 7677
  counter = 0;
  {
#line 7677
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 7677
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7677
      goto while_break___18;
    }
#line 7679
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7677
    counter ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 7681
  ast -= sizeof(char *);
#line 7682
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 7683
  *ast = tmp;
#line 7684
  *((long *)*ast) = (*((long (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7692
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7693
  goto switch_break___22;
  case_21___2: /* CIL Label */ 
#line 7697
  counter = 0;
  {
#line 7697
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 7697
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7697
      goto while_break___19;
    }
#line 7699
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7697
    counter ++;
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 7701
  ast -= sizeof(char *);
#line 7702
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 7703
  *ast = tmp;
#line 7704
  *((unsigned long *)*ast) = (*((unsigned long (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7712
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7713
  goto switch_break___22;
  case_22___1: /* CIL Label */ 
#line 7717
  counter = 0;
  {
#line 7717
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 7717
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7717
      goto while_break___20;
    }
#line 7719
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7717
    counter ++;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 7721
  ast -= sizeof(char *);
#line 7722
  move_stack_aligned(& tmp, (int )(- sizeof(short )));
#line 7723
  *ast = tmp;
#line 7724
  *((short *)*ast) = (*((short (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7732
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7733
  goto switch_break___22;
  case_23___1: /* CIL Label */ 
#line 7737
  counter = 0;
  {
#line 7737
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 7737
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7737
      goto while_break___21;
    }
#line 7739
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7737
    counter ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 7741
  ast -= sizeof(char *);
#line 7742
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned short )));
#line 7743
  *ast = tmp;
#line 7744
  *((unsigned short *)*ast) = (*((unsigned short (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7752
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7753
  goto switch_break___22;
  case_24___0: /* CIL Label */ 
#line 7757
  counter = 0;
  {
#line 7757
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 7757
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7757
      goto while_break___22;
    }
#line 7759
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7757
    counter ++;
  }
  while_break___22: /* CIL Label */ ;
  }
  {
#line 7761
  ast -= sizeof(char *);
#line 7762
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 7763
  *ast = tmp;
#line 7764
  *((long double *)*ast) = (*((long double (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7772
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7773
  goto switch_break___22;
  case_25___0: /* CIL Label */ 
#line 7777
  counter = 0;
  {
#line 7777
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 7777
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7777
      goto while_break___23;
    }
#line 7779
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7777
    counter ++;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 7781
  ast -= sizeof(char *);
#line 7782
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7783
  *ast = tmp;
#line 7784
  *((signed char *)*ast) = (*((signed char (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7792
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7793
  goto switch_break___22;
  case_26___1: /* CIL Label */ 
#line 7797
  counter = 0;
  {
#line 7797
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 7797
    if (! ((unsigned long )counter < (unsigned long )(frame - stack) / sizeof(char *))) {
#line 7797
      goto while_break___24;
    }
#line 7799
    adr_arg[counter] = stack + (unsigned long )counter * sizeof(char *);
#line 7797
    counter ++;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 7801
  ast -= sizeof(char *);
#line 7802
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7803
  *ast = tmp;
#line 7804
  *((unsigned char *)*ast) = (*((unsigned char (*)())f[((struct OPERAND_1_i *)pc)->num]))(adr_arg);
#line 7812
  pc += sizeof(struct OPERAND_1_i );
  }
#line 7813
  goto switch_break___22;
  switch_default___21: /* CIL Label */ 
  {
#line 7816
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           7816);
#line 7817
  error_message(5001);
#line 7818
  abort();
  }
  switch_break___22: /* CIL Label */ ;
  }
#line 7820
  goto switch_break;
  case_28___0: /* CIL Label */ 
#line 7822
  pc = *((char **)stack);
#line 7823
  stack += sizeof(char *);
#line 7831
  goto switch_break;
  case_52: /* CIL Label */ 
#line 7835
  tmp___16 = *ast;
#line 7836
  *ast = *(ast + sizeof(char *));
#line 7837
  *(ast + sizeof(char *)) = tmp___16;
#line 7838
  pc += sizeof(struct OPERAND_0_ma );
#line 7839
  goto switch_break;
  switch_default___22: /* CIL Label */ 
  {
#line 7843
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
           7843);
#line 7844
  error_message(5001);
#line 7845
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 7847
  return (0);
}
}
#line 7853 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void vtrue(void) 
{ 


  {
  {
#line 7856
  ast += sizeof(char *);
#line 7857
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7858
  *ast = tmp;
#line 7859
  *((int *)*ast) = 1;
  }
#line 7860
  return;
}
}
#line 7865 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void vfalse(void) 
{ 


  {
  {
#line 7868
  ast += sizeof(char *);
#line 7869
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7870
  *ast = tmp;
#line 7871
  *((int *)*ast) = 0;
  }
#line 7872
  return;
}
}
#line 7877 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void div_yes(void) 
{ 
  int binar ;

  {
  {
#line 7881
  binar = *((int *)*(ast + sizeof(char *))) / *((int *)*ast);
#line 7882
  ast += sizeof(char *);
#line 7883
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7884
  *ast = tmp;
#line 7885
  *((int *)*ast) = binar;
  }
#line 7886
  return;
}
}
#line 7888 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void divui_yes(void) 
{ 
  unsigned int binar ;

  {
  {
#line 7892
  binar = *((unsigned int *)*(ast + sizeof(char *))) / *((unsigned int *)*ast);
#line 7893
  ast += sizeof(char *);
#line 7894
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned int )));
#line 7895
  *ast = tmp;
#line 7896
  *((unsigned int *)*ast) = binar;
  }
#line 7897
  return;
}
}
#line 7899 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void divli_yes(void) 
{ 
  long binar ;

  {
  {
#line 7903
  binar = *((long *)*(ast + sizeof(char *))) / *((long *)*ast);
#line 7904
  ast += sizeof(char *);
#line 7905
  move_stack_aligned(& tmp, (int )(- sizeof(long )));
#line 7906
  *ast = tmp;
#line 7907
  *((long *)*ast) = binar;
  }
#line 7908
  return;
}
}
#line 7910 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void divlui_yes(void) 
{ 
  unsigned long binar ;

  {
  {
#line 7914
  binar = *((unsigned long *)*(ast + sizeof(char *))) / *((unsigned long *)*ast);
#line 7915
  ast += sizeof(char *);
#line 7916
  move_stack_aligned(& tmp, (int )(- sizeof(unsigned long )));
#line 7917
  *ast = tmp;
#line 7918
  *((unsigned long *)*ast) = binar;
  }
#line 7919
  return;
}
}
#line 7924 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void divd_yes(void) 
{ 
  double binard ;

  {
  {
#line 7928
  binard = *((double *)*(ast + sizeof(char *))) / *((double *)*ast);
#line 7929
  ast += sizeof(char *);
#line 7930
  move_stack_aligned(& tmp, (int )(- sizeof(double )));
#line 7931
  *ast = tmp;
#line 7932
  *((double *)*ast) = binard;
  }
#line 7933
  return;
}
}
#line 7935 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void divld_yes(void) 
{ 
  long double binard ;

  {
  {
#line 7939
  binard = *((long double *)*(ast + sizeof(char *))) / *((long double *)*ast);
#line 7940
  ast += sizeof(char *);
#line 7941
  move_stack_aligned(& tmp, (int )(- sizeof(long double )));
#line 7942
  *ast = tmp;
#line 7943
  *((long double *)*ast) = binard;
  }
#line 7944
  return;
}
}
#line 7949 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void divf_yes(void) 
{ 
  float binarf ;

  {
  {
#line 7953
  binarf = *((float *)*(ast + sizeof(char *))) / *((float *)*ast);
#line 7954
  ast += sizeof(char *);
#line 7955
  move_stack_aligned(& tmp, (int )(- sizeof(float )));
#line 7956
  *ast = tmp;
#line 7957
  *((float *)*ast) = binarf;
  }
#line 7958
  return;
}
}
#line 7979 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void mod_yes(void) 
{ 
  int binar ;

  {
  {
#line 7983
  binar = *((int *)*(ast + sizeof(char *))) % *((int *)*ast);
#line 7984
  ast += sizeof(char *);
#line 7985
  move_stack_aligned(& tmp, (int )(- sizeof(int )));
#line 7986
  *ast = tmp;
#line 7987
  *((int *)*ast) = binar;
  }
#line 7988
  return;
}
}
#line 7990 "/home/wslee/benchmarks/clif-0.93/virtual_machine.c"
static void move_stack_aligned(char **p , int n ) 
{ 
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 7996
  if (n > 0) {
#line 7996
    tmp___0 = n;
  } else {
#line 7996
    tmp___0 = - n;
  }
#line 7996
  if (! ((unsigned long )tmp___0 <= sizeof(long double ))) {
    {
#line 7996
    __assert_fail("(n > 0 ? n : -n) <= sizeof (long double)", "/home/wslee/benchmarks/clif-0.93/virtual_machine.c",
                  7996U, "move_stack_aligned");
    }
  }
  {
#line 7999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7999
    if (! ((long )*p % (long )n)) {
#line 7999
      goto while_break;
    }
#line 8000
    if (n > 0) {
#line 8000
      *p += sizeof(char );
    } else {
#line 8000
      *p -= sizeof(char );
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 8001
  *p += n;
#line 8002
  return;
}
}
#line 73 "/home/wslee/benchmarks/clif-0.93/global.h"
struct CONTEXT *context ;
#line 116
char *kodp3 ;
#line 40 "/home/wslee/benchmarks/clif-0.93/store_cont.c"
void *store_buffer_state(void) ;
#line 41
void flush_buffer(void *state ) ;
#line 44 "/home/wslee/benchmarks/clif-0.93/store_cont.c"
void store_context(void) 
{ 
  struct CONTEXT *arch ;
  char *tmp___0 ;

  {
  {
#line 48
  tmp___0 = callocx(1U, (unsigned int )sizeof(struct CONTEXT ));
#line 48
  arch = (struct CONTEXT *)tmp___0;
  }
#line 48
  if ((unsigned long )((void *)0) == (unsigned long )arch) {
    {
#line 51
    error_message(4002);
    }
#line 52
    return;
  }
  {
#line 54
  arch->previous = context;
#line 55
  context = arch;
#line 56
  context->bp = bp;
#line 57
  context->frame = frame;
#line 58
  context->kodp = kodp;
#line 59
  context->kodp1 = kodp1;
#line 60
  context->kodp2 = kodp2;
#line 61
  context->kodp3 = kodp3;
#line 62
  context->pc = pc;
#line 63
  context->stack = stack;
#line 65
  context->state = store_buffer_state();
#line 69
  context->tmp = tmp;
#line 70
  context->tmph = tmph;
#line 71
  tmph = tmp;
#line 72
  kodp1 = kodp;
#line 73
  kodp2 = kodp;
#line 74
  kodp3 = (char *)((void *)0);
#line 75
  kodp4 = (char *)((void *)0);
  }
#line 76
  return;
}
}
#line 78 "/home/wslee/benchmarks/clif-0.93/store_cont.c"
void restore_context(void) 
{ 
  struct CONTEXT *arch ;

  {
#line 82
  if ((unsigned long )context != (unsigned long )((void *)0)) {
#line 84
    if ((unsigned long )kodp2 == (unsigned long )kodp1) {
#line 86
      kodp = context->kodp;
#line 87
      kodp1 = context->kodp1;
#line 88
      kodp2 = context->kodp2;
#line 89
      kodp3 = context->kodp3;
#line 90
      kodp4 = context->kodp4;
    }
    {
#line 92
    arch = context;
#line 93
    bp = context->bp;
#line 94
    frame = context->frame;
#line 95
    pc = context->pc;
#line 96
    stack = context->stack;
#line 97
    tmp = context->tmp;
#line 98
    tmph = context->tmph;
#line 100
    flush_buffer(context->state);
#line 104
    context = context->previous;
#line 105
    free((void *)arch);
    }
  }
#line 107
  return;
}
}
#line 32 "/home/wslee/benchmarks/clif-0.93/global.c"
int s  ;
#line 33 "/home/wslee/benchmarks/clif-0.93/global.c"
int char_counter  ;
#line 34 "/home/wslee/benchmarks/clif-0.93/global.c"
char line_buf[10000]  ;
#line 36 "/home/wslee/benchmarks/clif-0.93/global.c"
char *mem_start  ;
#line 37 "/home/wslee/benchmarks/clif-0.93/global.c"
char *stack  ;
#line 38 "/home/wslee/benchmarks/clif-0.93/global.c"
char *bp  ;
#line 41 "/home/wslee/benchmarks/clif-0.93/global.c"
char *frame  ;
#line 45 "/home/wslee/benchmarks/clif-0.93/global.c"
char **ast  ;
#line 46 "/home/wslee/benchmarks/clif-0.93/global.c"
char *pc  ;
#line 49 "/home/wslee/benchmarks/clif-0.93/global.c"
char *fixst  ;
#line 53 "/home/wslee/benchmarks/clif-0.93/global.c"
char *tmp  ;
#line 54 "/home/wslee/benchmarks/clif-0.93/global.c"
char *tmph  ;
#line 58 "/home/wslee/benchmarks/clif-0.93/global.c"
char *tmp_start  ;
#line 61 "/home/wslee/benchmarks/clif-0.93/global.c"
char *proc_name[256]  ;
#line 62 "/home/wslee/benchmarks/clif-0.93/global.c"
char *proc_name_text[256]  ;
#line 63 "/home/wslee/benchmarks/clif-0.93/global.c"
char *struct_union_enum_name[256]  ;
#line 65 "/home/wslee/benchmarks/clif-0.93/global.c"
struct CONTEXT *context  ;
#line 66 "/home/wslee/benchmarks/clif-0.93/global.c"
int proc  ;
#line 70 "/home/wslee/benchmarks/clif-0.93/global.c"
int suen_count  ;
#line 74 "/home/wslee/benchmarks/clif-0.93/global.c"
struct internal_type *type_com[256]  ;
#line 78 "/home/wslee/benchmarks/clif-0.93/global.c"
int dim[256]  ;
#line 79 "/home/wslee/benchmarks/clif-0.93/global.c"
int poc  ;
#line 82 "/home/wslee/benchmarks/clif-0.93/global.c"
int remote_flag  =    0;
#line 83 "/home/wslee/benchmarks/clif-0.93/global.c"
int body_flag  =    1;
#line 84 "/home/wslee/benchmarks/clif-0.93/global.c"
int typedef_f  =    1;
#line 86 "/home/wslee/benchmarks/clif-0.93/global.c"
int enum_value  =    0;
#line 88 "/home/wslee/benchmarks/clif-0.93/global.c"
struct internal_type *typeh[256]  ;
#line 89 "/home/wslee/benchmarks/clif-0.93/global.c"
int type_spec_count  =    0;
#line 93 "/home/wslee/benchmarks/clif-0.93/global.c"
struct remote_tab *remote_ptr_C  ;
#line 102 "/home/wslee/benchmarks/clif-0.93/global.c"
struct return1 *rp  ;
#line 107 "/home/wslee/benchmarks/clif-0.93/global.c"
char *kodp  ;
#line 108 "/home/wslee/benchmarks/clif-0.93/global.c"
char *kodp1  ;
#line 110 "/home/wslee/benchmarks/clif-0.93/global.c"
char *kodp2  ;
#line 113 "/home/wslee/benchmarks/clif-0.93/global.c"
char *kodp3  ;
#line 115 "/home/wslee/benchmarks/clif-0.93/global.c"
char *kodp4  ;
#line 119 "/home/wslee/benchmarks/clif-0.93/global.c"
char *last_instr  ;
#line 119 "/home/wslee/benchmarks/clif-0.93/global.c"
char *current_instr  ;
#line 121 "/home/wslee/benchmarks/clif-0.93/global.c"
int count[256]  ;
#line 121 "/home/wslee/benchmarks/clif-0.93/global.c"
int count_arr  =    1;
#line 122 "/home/wslee/benchmarks/clif-0.93/global.c"
int virtual_machine_suspended  =    1;
#line 123 "/home/wslee/benchmarks/clif-0.93/global.c"
int clif_interrupt_level  =    0;
#line 125 "/home/wslee/benchmarks/clif-0.93/global.c"
int set  =    0;
#line 129 "/home/wslee/benchmarks/clif-0.93/global.c"
union fix *fixp  ;
#line 133 "/home/wslee/benchmarks/clif-0.93/global.c"
char *call_fix[256]  ;
#line 42 "/home/wslee/benchmarks/clif-0.93/help.c"
int help(int typ ) ;
#line 44 "/home/wslee/benchmarks/clif-0.93/help.c"
int help(int typ ) 
{ 
  FILE *spf___0 ;
  int znak ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 53
  if (typ == 1) {
#line 53
    goto case_1;
  }
#line 65
  if (typ == 2) {
#line 65
    goto case_2;
  }
#line 77
  if (typ == 3) {
#line 77
    goto case_3;
  }
#line 89
  if (typ == 4) {
#line 89
    goto case_4;
  }
#line 92
  if (typ == 5) {
#line 92
    goto case_5;
  }
#line 51
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 54
  spf___0 = fopen((char const   */* __restrict  */)"small.hlp", (char const   */* __restrict  */)"r");
  }
#line 54
  if ((unsigned long )spf___0 == (unsigned long )((void *)0)) {
    {
#line 56
    fprintfx(stderr, (char *)"\tcopy file small.hlp in this directory\n");
    }
#line 57
    return (-1);
  } else {
    {
#line 61
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 61
      znak = getcx(spf___0);
      }
#line 61
      if (! (znak != -1)) {
#line 61
        goto while_break;
      }
      {
#line 62
      _IO_putc((int )((char )znak), stdout);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 64
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 66
  spf___0 = fopen((char const   */* __restrict  */)"copying", (char const   */* __restrict  */)"r");
  }
#line 66
  if ((unsigned long )spf___0 == (unsigned long )((void *)0)) {
    {
#line 68
    fprintfx(stderr, (char *)"\tcopy file copying in this directory\n");
    }
#line 69
    return (-1);
  } else {
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 73
      znak = getcx(spf___0);
      }
#line 73
      if (! (znak != -1)) {
#line 73
        goto while_break___0;
      }
      {
#line 74
      _IO_putc((int )((char )znak), stdout);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 76
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 78
  spf___0 = fopen((char const   */* __restrict  */)"warranty", (char const   */* __restrict  */)"r");
  }
#line 78
  if ((unsigned long )spf___0 == (unsigned long )((void *)0)) {
    {
#line 80
    fprintfx(stderr, (char *)"\tcopy file warranty in this directory\n");
    }
#line 81
    return (-1);
  } else {
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 85
      znak = getcx(spf___0);
      }
#line 85
      if (! (znak != -1)) {
#line 85
        goto while_break___1;
      }
      {
#line 86
      _IO_putc((int )((char )znak), stdout);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 88
  goto switch_break;
  case_4: /* CIL Label */ 
#line 90
  verbose = 1;
#line 91
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 93
  fprintfx(stderr, (char *)"clif version %s\n", version);
  }
#line 94
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 96
  return (0);
}
}
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 49 "/home/wslee/benchmarks/clif-0.93/tables.h"
enum intern_arit_class type_ac[256]  ;
#line 52
int point_call(char *func_name ) ;
#line 54
int has_goto(char *label_name ) ;
#line 55
int has_label(char *label_name ) ;
#line 56
int has_tag(int tag_only , char *tag_name ) ;
#line 57
void fix_and_clear_goto_table(void) ;
#line 67
void set_value(char *var_name ) ;
#line 72
int add_spec_to_has(void) ;
#line 76
int add_ident_to_has(void) ;
#line 80
int add_spec_to_tag(void) ;
#line 84
int add_ident_to_tag(void) ;
#line 89
void clear_hash_tab_declaration(void) ;
#line 92
int scope_offset_get(void) ;
#line 93
int scope_offset_set(int off ) ;
#line 94
int offset_aggregate_ident(void) ;
#line 102
int typedef_p(char *name___0 ) ;
#line 105
int get_memory_size(int level , struct internal_type *walk , int initializer_number ) ;
#line 106
int get_field_size(int *pos , struct internal_type *walk ) ;
#line 107
void noninitialized_loc(char *var_name ) ;
#line 62 "/home/wslee/benchmarks/clif-0.93/tables.c"
int main_defined ;
#line 64
static struct tab *allocate_hastab_loc(void) ;
#line 65
static struct ident_tab_header *allocate_loc_tables(struct ident_tab_header *previous ) ;
#line 71
static void clear_hash_tab_next_declaration(struct tab *def ) ;
#line 75
static void clear_hash_tab_next(struct ident_tab_header *tab , struct tab *def ) ;
#line 82
static void putstruct(struct tab *np ) ;
#line 87
static void putstruct_body(struct tab *np ) ;
#line 93
static void putstruct_loc(struct tab *np , int type ) ;
#line 96
static struct tab *lookup(char *s___0 ) ;
#line 99
static struct tab *lookup_tag(char *s___0 ) ;
#line 102
static unsigned int hash_code(char *s___0 , unsigned int size ) ;
#line 105
static struct tab *lookup_loc(char *s___0 , struct ident_tab_header *identtab_loc___0 ) ;
#line 108
static struct goto_tab *lookup_goto_table(char *s___0 ) ;
#line 113
static void putstruct_tag(struct tab *np ) ;
#line 118
static void putstruct_tag_body(struct tab *np ) ;
#line 121
static int allocate_var(struct internal_type *type , char **address ) ;
#line 125 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct tab *hastab  ;
#line 131 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct goto_tab *hastab_goto  ;
#line 138 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct ident_tab_header *tagtab  ;
#line 145 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct ident_tab *identtab  ;
#line 151 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct ident_tab_header *identtab_loc  ;
#line 156 "/home/wslee/benchmarks/clif-0.93/tables.c"
static int pi  ;
#line 164
static void move_offset_aligned(int *what , int size ) ;
#line 168
static int find_member(char *name___0 , struct internal_type *type_to_find ) ;
#line 170
static int allocate_struct(struct internal_type *type ) ;
#line 171
static int allocate_aggregate(struct internal_type *type ) ;
#line 174
static void putstruct_static(struct ident_tab_loc *type ) ;
#line 176
static int memory_size(int *level , struct internal_type *walk ) ;
#line 177
static void check_init_bracket(int *level , struct internal_type *walk , char *buf ) ;
#line 180 "/home/wslee/benchmarks/clif-0.93/tables.c"
int hastab_init(void) 
{ 
  char *tmp___0 ;

  {
  {
#line 183
  tmp___0 = callocx(1999U, (unsigned int )sizeof(struct tab ));
#line 183
  hastab = (struct tab *)tmp___0;
  }
#line 184
  if ((unsigned long )((void *)0) == (unsigned long )hastab) {
    {
#line 186
    error_message(4000);
    }
#line 187
    return (0);
  }
#line 193
  return (1);
}
}
#line 196 "/home/wslee/benchmarks/clif-0.93/tables.c"
int hastab_goto_init(void) 
{ 
  char *tmp___0 ;

  {
  {
#line 199
  tmp___0 = callocx(257U, (unsigned int )sizeof(struct goto_tab ));
#line 199
  hastab_goto = (struct goto_tab *)tmp___0;
  }
#line 201
  if ((unsigned long )((void *)0) == (unsigned long )hastab_goto) {
    {
#line 203
    error_message(4000);
    }
#line 204
    return (0);
  }
#line 209
  return (1);
}
}
#line 214 "/home/wslee/benchmarks/clif-0.93/tables.c"
int identtab_init(void) 
{ 
  char *tmp___0 ;

  {
  {
#line 217
  tmp___0 = callocx(1999U, (unsigned int )sizeof(struct ident_tab ));
#line 217
  identtab = (struct ident_tab *)tmp___0;
  }
#line 219
  if ((unsigned long )((void *)0) == (unsigned long )identtab) {
    {
#line 221
    error_message(4000);
    }
#line 222
    return (0);
  }
#line 224
  pi = 0;
#line 226
  return (1);
}
}
#line 230 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct tab *allocate_hastab_loc(void) 
{ 
  struct tab *hastab_loc ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 235
  if (scope_level > 0) {
#line 235
    tmp___0 = 1;
  } else {
#line 235
    tmp___0 = 0;
  }
  {
#line 235
  tmp___1 = allocate((unsigned int )(401UL * sizeof(struct tab )), (unsigned int )tmp___0);
#line 235
  hastab_loc = (struct tab *)tmp___1;
  }
#line 238
  if ((unsigned long )((void *)0) == (unsigned long )hastab_loc) {
    {
#line 240
    error_message(4000);
    }
#line 241
    return ((struct tab *)0);
  }
#line 248
  return (hastab_loc);
}
}
#line 252 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct ident_tab_header *allocate_loc_tables(struct ident_tab_header *previous ) 
{ 
  struct ident_tab_header *identtab_loc___0 ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 258
  if (scope_level > 0) {
#line 258
    tmp___0 = 1;
  } else {
#line 258
    tmp___0 = 0;
  }
  {
#line 258
  tmp___1 = allocate((unsigned int )(401UL * sizeof(struct ident_tab_loc ) + sizeof(struct ident_tab_header )),
                     (unsigned int )tmp___0);
#line 258
  identtab_loc___0 = (struct ident_tab_header *)tmp___1;
#line 262
  init_zero((char *)identtab_loc___0, (unsigned int )(401UL * sizeof(struct ident_tab_loc ) + sizeof(struct ident_tab_header )));
#line 266
  identtab_loc___0->scope_level = scope_level;
#line 267
  identtab_loc___0->pi_loc = 0;
#line 268
  identtab_loc___0->offset = 0;
#line 269
  identtab_loc___0->previous_level = previous;
#line 270
  identtab_loc___0->hastab_loc = allocate_hastab_loc();
#line 271
  identtab_loc___0->table = (struct ident_tab_loc *)identtab_loc___0 + sizeof(struct ident_tab_header );
  }
#line 274
  return (identtab_loc___0);
}
}
#line 282 "/home/wslee/benchmarks/clif-0.93/tables.c"
void clear_hash_tab_declaration(void) 
{ 
  int i ;

  {
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (i < 401)) {
#line 287
      goto while_break;
    }
#line 289
    if ((unsigned long )((void *)0) != (unsigned long )(identtab_loc->hastab_loc + i)->name) {
#line 294
      (identtab_loc->hastab_loc + i)->name = (char *)((void *)0);
#line 295
      (identtab_loc->hastab_loc + i)->def = 0;
#line 296
      if ((unsigned long )((void *)0) != (unsigned long )(identtab_loc->hastab_loc + i)->next) {
        {
#line 297
        clear_hash_tab_next_declaration((identtab_loc->hastab_loc + i)->next);
        }
      }
    }
#line 287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  identtab_loc->pi_loc = 0;
#line 301
  return;
}
}
#line 305 "/home/wslee/benchmarks/clif-0.93/tables.c"
void clear_hash_tab(void) 
{ 
  int i ;

  {
#line 310
  if (! identtab_loc) {
#line 311
    return;
  } else
#line 310
  if (identtab_loc->scope_level < scope_level) {
#line 311
    return;
  }
#line 313
  i = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (i < 401)) {
#line 313
      goto while_break;
    }
#line 315
    if ((unsigned long )((void *)0) != (unsigned long )(identtab_loc->hastab_loc + i)->name) {
#line 317
      if (! (identtab_loc->hastab_loc + i)->count) {
        {
#line 319
        text = (identtab_loc->hastab_loc + i)->name;
#line 320
        error_message(6003);
        }
      }
#line 322
      if (0 == (identtab_loc->hastab_loc + i)->l_value_flag) {
#line 322
        if (0 != (identtab_loc->hastab_loc + i)->count) {
          {
#line 325
          text = (identtab_loc->hastab_loc + i)->name;
#line 326
          error_message(6006);
          }
        }
      }
      {
#line 331
      (identtab_loc->hastab_loc + i)->name = (char *)((void *)0);
#line 332
      clear_internal_type((identtab_loc->table + (identtab_loc->hastab_loc + i)->def)->type);
#line 334
      (identtab_loc->hastab_loc + i)->def = 0;
#line 335
      (identtab_loc->hastab_loc + i)->count = 0;
#line 336
      (identtab_loc->hastab_loc + i)->use_line_number = 0;
#line 337
      (identtab_loc->hastab_loc + i)->l_value_flag = 0;
      }
#line 338
      if ((unsigned long )((void *)0) != (unsigned long )(identtab_loc->hastab_loc + i)->next) {
        {
#line 339
        clear_hash_tab_next(identtab_loc, (identtab_loc->hastab_loc + i)->next);
        }
      }
    }
#line 313
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  identtab_loc->pi_loc = 0;
#line 344
  identtab_loc = identtab_loc->previous_level;
#line 346
  return;
}
}
#line 350 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void clear_hash_tab_next_declaration(struct tab *def ) 
{ 


  {
#line 357
  if ((unsigned long )((void *)0) != (unsigned long )def->next) {
    {
#line 359
    clear_hash_tab_next_declaration(def->next);
    }
  }
#line 364
  return;
}
}
#line 368 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void clear_hash_tab_next(struct ident_tab_header *tab , struct tab *def ) 
{ 


  {
#line 373
  if (! def->count) {
    {
#line 375
    text = def->name;
#line 376
    error_message(6003);
    }
  }
#line 378
  if (0 == def->l_value_flag) {
#line 378
    if (0 != def->count) {
      {
#line 380
      text = def->name;
#line 381
      error_message(6006);
      }
    }
  }
  {
#line 386
  clear_internal_type((tab->table + def->def)->type);
  }
#line 387
  if ((unsigned long )((void *)0) != (unsigned long )def->next) {
    {
#line 388
    clear_hash_tab_next(tab, def->next);
    }
  }
#line 392
  return;
}
}
#line 396 "/home/wslee/benchmarks/clif-0.93/tables.c"
void clear_tag_tab(void) 
{ 
  int i ;

  {
#line 401
  if (! tagtab) {
#line 402
    return;
  } else
#line 401
  if (tagtab->scope_level < scope_level) {
#line 402
    return;
  }
#line 404
  i = 0;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! (i < 401)) {
#line 404
      goto while_break;
    }
#line 406
    if ((unsigned long )((void *)0) != (unsigned long )(tagtab->hastab_loc + i)->name) {
      {
#line 411
      (tagtab->hastab_loc + i)->name = (char *)((void *)0);
#line 412
      clear_internal_type((tagtab->table + (tagtab->hastab_loc + i)->def)->type);
#line 414
      (tagtab->hastab_loc + i)->def = 0;
#line 415
      (tagtab->hastab_loc + i)->count = 0;
#line 416
      (tagtab->hastab_loc + i)->use_line_number = 0;
#line 417
      (tagtab->hastab_loc + i)->l_value_flag = 0;
      }
#line 418
      if ((unsigned long )((void *)0) != (unsigned long )(tagtab->hastab_loc + i)->next) {
        {
#line 419
        clear_hash_tab_next(tagtab, (tagtab->hastab_loc + i)->next);
        }
      }
    }
#line 404
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  tagtab->pi_loc = 0;
#line 423
  tagtab = tagtab->previous_level;
#line 425
  return;
}
}
#line 431 "/home/wslee/benchmarks/clif-0.93/tables.c"
struct ident_tab *point(char *var_name ) 
{ 
  struct tab *pa ;

  {
  {
#line 437
  pa = lookup(var_name);
  }
#line 437
  if ((unsigned long )((void *)0) == (unsigned long )pa) {
    {
#line 439
    error_message(1000);
    }
#line 440
    return ((struct ident_tab *)((void *)0));
  } else {
#line 444
    (pa->count) ++;
#line 445
    return (identtab + pa->def);
  }
}
}
#line 453 "/home/wslee/benchmarks/clif-0.93/tables.c"
int point_call(char *func_name ) 
{ 
  struct tab *pa ;
  struct FIX *arch ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 476
  pa = lookup(func_name);
  }
#line 476
  if ((unsigned long )((void *)0) == (unsigned long )pa) {
    {
#line 478
    error_message(1000);
    }
#line 479
    return (-1);
  } else {
#line 483
    if (! (identtab + pa->def)->body) {
#line 485
      arch = (identtab + pa->def)->next;
#line 485
      if ((unsigned long )((void *)0) == (unsigned long )arch) {
        {
#line 487
        tmp___0 = allocate((unsigned int )sizeof(struct FIX ), 1U);
#line 487
        arch = (struct FIX *)tmp___0;
#line 489
        arch->address = kodp;
#line 490
        arch->next = (struct FIX *)((void *)0);
#line 491
        (identtab + pa->def)->next = arch;
        }
      } else {
        {
#line 495
        while (1) {
          while_continue: /* CIL Label */ ;
#line 495
          if (! ((unsigned long )((void *)0) != (unsigned long )arch->next)) {
#line 495
            goto while_break;
          }
#line 496
          arch = arch->next;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 497
        tmp___1 = allocate((unsigned int )sizeof(struct FIX ), 1U);
#line 497
        arch->next = (struct FIX *)tmp___1;
#line 499
        (arch->next)->address = kodp;
#line 500
        (arch->next)->next = (struct FIX *)((void *)0);
        }
      }
    }
#line 503
    return (1);
  }
}
}
#line 511 "/home/wslee/benchmarks/clif-0.93/tables.c"
int has(char *var_name ) 
{ 
  struct tab *np ;
  struct tab *arch ;
  unsigned int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;

  {
  {
#line 517
  np = lookup(var_name);
  }
#line 517
  if ((unsigned long )((void *)0) == (unsigned long )np) {
    {
#line 523
    tmp___0 = hash_code(var_name, 1999U);
#line 523
    np = hastab + tmp___0;
    }
#line 524
    if ((unsigned long )((void *)0) == (unsigned long )np->name) {
      {
#line 527
      np->name = var_name;
#line 528
      np->declaration_line = spf[s].line_counter;
#line 529
      putstruct(np);
      }
    } else {
      {
#line 536
      while (1) {
        while_continue: /* CIL Label */ ;
#line 538
        arch = np;
#line 539
        np = np->next;
#line 536
        if (! ((unsigned long )((void *)0) != (unsigned long )np)) {
#line 536
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 542
      tmp___1 = allocate((unsigned int )sizeof(struct tab ), 0U);
#line 542
      np = (struct tab *)tmp___1;
#line 543
      arch->next = np;
#line 544
      np->name = var_name;
#line 545
      np->declaration_line = spf[s].line_counter;
#line 546
      putstruct(np);
      }
    }
#line 548
    pi ++;
#line 549
    arch = (struct tab *)((void *)0);
#line 550
    return (1);
  } else
#line 554
  if ((identtab + np->def)->body) {
    {
#line 556
    error_message(1001);
    }
#line 557
    return (-1);
  } else {
    {
#line 561
    putstruct_body(np);
#line 563
    tmp___2 = strcmp((char const   *)var_name, "main");
    }
#line 563
    if (! tmp___2) {
#line 564
      main_defined = 1;
    }
#line 565
    return (1);
  }
}
}
#line 575 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void putstruct(struct tab *np ) 
{ 
  int i ;
  char *tmp___0 ;
  int i___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 582
  np->def = pi;
#line 587
  (identtab + pi)->body = body_flag;
#line 588
  (identtab + pi)->next = (struct FIX *)((void *)0);
#line 589
  (identtab + pi)->adr = (char *)((void *)0);
#line 590
  (identtab + pi)->type = typeh[type_spec_count];
#line 593
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 595
    if (1025U == (unsigned int )((typeh[type_spec_count])->output)->attribute.function_class) {
      {
#line 596
      put_array_subscript(& ((identtab + pi)->type)->output);
      }
    }
#line 597
    return;
  }
  {
#line 603
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 2049U) {
#line 603
    goto case_2049;
  }
#line 603
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 2048U) {
#line 603
    goto case_2049;
  }
#line 607
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1024U) {
#line 607
    goto case_1024;
  }
#line 622
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1025U) {
#line 622
    goto case_1025;
  }
#line 633
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1031U) {
#line 633
    goto case_1031;
  }
#line 638
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1029U) {
#line 638
    goto case_1029;
  }
#line 638
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1030U) {
#line 638
    goto case_1029;
  }
#line 649
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1028U) {
#line 649
    goto case_1028;
  }
#line 655
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1026U) {
#line 655
    goto case_1026;
  }
#line 658
  goto switch_default___0;
  case_2049: /* CIL Label */ 
  case_2048: /* CIL Label */ 
#line 604
  if (! (((identtab + pi)->type)->output)->attribute.memory_size) {
    {
#line 605
    allocate_aggregate(((identtab + pi)->type)->output);
    }
  }
#line 606
  goto switch_break;
  case_1024: /* CIL Label */ 
  {
#line 610
  if ((unsigned int )(typeh[type_spec_count])->attribute.type_qualifier == 4096U) {
#line 610
    goto case_4096;
  }
#line 613
  if ((unsigned int )(typeh[type_spec_count])->attribute.type_qualifier == 4097U) {
#line 613
    goto case_4097;
  }
#line 616
  goto switch_default;
  case_4096: /* CIL Label */ 
#line 611
  (identtab + pi)->adr = ((identtab + pi)->type)->attribute.domain;
#line 612
  goto switch_break___0;
  case_4097: /* CIL Label */ 
  {
#line 614
  fprintfx(stderr, "VOLATILE not supported in bookkeeping\n");
  }
#line 615
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 617
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 619
  ((identtab + pi)->type)->attribute.memory_size = allocate_var((identtab + pi)->type,
                                                                & (identtab + pi)->adr);
  }
#line 621
  goto switch_break;
  case_1025: /* CIL Label */ 
  {
#line 623
  put_array_subscript(& (identtab + pi)->type);
#line 624
  (identtab + pi)->body = allocate_aggregate((identtab + pi)->type);
#line 625
  (identtab + pi)->adr = kodp;
#line 628
  i = 0;
  }
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
#line 628
    if (! (i < ((identtab + pi)->type)->attribute.memory_size)) {
#line 628
      goto while_break;
    }
#line 630
    tmp___0 = kodp;
#line 630
    kodp ++;
#line 630
    *tmp___0 = (char)0;
#line 628
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  goto switch_break;
  case_1031: /* CIL Label */ 
  {
#line 634
  ((identtab + pi)->type)->attribute.memory_size = allocate_var((identtab + pi)->type,
                                                                & (identtab + pi)->adr);
  }
#line 636
  goto switch_break;
  case_1029: /* CIL Label */ 
  case_1030: /* CIL Label */ 
#line 639
  if (! (identtab + pi)->body) {
    {
#line 640
    body_flag = allocate_aggregate((identtab + pi)->type);
#line 640
    (identtab + pi)->body = body_flag;
    }
  }
#line 642
  (identtab + pi)->adr = kodp;
#line 645
  i___0 = 0;
  {
#line 645
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 645
    if (! (i___0 < ((identtab + pi)->type)->attribute.memory_size)) {
#line 645
      goto while_break___0;
    }
#line 646
    tmp___1 = kodp;
#line 646
    kodp ++;
#line 646
    *tmp___1 = (char)0;
#line 645
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 648
  goto switch_break;
  case_1028: /* CIL Label */ 
#line 650
  (identtab + pi)->adr = kodp;
#line 651
  ((identtab + pi)->type)->attribute.memory_size = (int )sizeof(pointer_size );
#line 652
  kodp += sizeof(pointer_size );
#line 653
  *((char **)(identtab + pi)->adr) = (char *)((void *)0);
#line 654
  goto switch_break;
  case_1026: /* CIL Label */ 
  {
#line 656
  fprintfx(stderr, "LIB not fully supported in book-keeping\n");
  }
#line 657
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 659
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 659);
#line 660
  error_message(5002);
#line 661
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 667
  return;
}
}
#line 673 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void putstruct_body(struct tab *np ) 
{ 
  struct FIX *arch ;
  struct FIX *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 681
  if ((unsigned int )((identtab + np->def)->type)->attribute.function_class == 2048U) {
#line 681
    goto case_2048;
  }
#line 696
  goto switch_default;
  case_2048: /* CIL Label */ 
#line 682
  (identtab + np->def)->adr = kodp1;
#line 683
  (identtab + np->def)->body = body_flag;
#line 684
  arch = (identtab + np->def)->next;
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
#line 685
    if (! ((unsigned long )((void *)0) != (unsigned long )arch)) {
#line 685
      goto while_break;
    }
#line 687
    ((struct OPERAND_1_mi *)arch->address)->adr = (identtab + np->def)->adr;
#line 688
    tmp___0 = arch;
#line 689
    arch = arch->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  (identtab + np->def)->next = (struct FIX *)((void *)0);
#line 695
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 697
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 697);
#line 698
  error_message(5000);
#line 699
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 704
  return;
}
}
#line 710 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct tab *lookup(char *s___0 ) 
{ 
  struct tab *ps ;
  unsigned int tmp___0 ;

  {
  {
#line 716
  tmp___0 = hash_code(s___0, 1999U);
#line 716
  ps = hastab + tmp___0;
  }
#line 717
  if (0 == *((int *)ps)) {
#line 718
    return ((struct tab *)((void *)0));
  }
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 719
      if (! ((unsigned long )((void *)0) != (unsigned long )ps->next)) {
#line 719
        goto while_break;
      }
    } else {
#line 719
      goto while_break;
    }
#line 720
    ps = ps->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 721
  if ((unsigned long )((void *)0) == (unsigned long )ps->next) {
#line 721
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 722
      return ((struct tab *)((void *)0));
    } else {
#line 724
      return (ps);
    }
  } else {
#line 724
    return (ps);
  }
}
}
#line 733 "/home/wslee/benchmarks/clif-0.93/tables.c"
static unsigned int hash_code(char *s___0 , unsigned int size ) 
{ 
  int c ;

  {
#line 738
  c = 0;
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 740
    if (! *s___0) {
#line 740
      goto while_break;
    }
#line 742
    c = (c << 1) ^ (int )*s___0;
#line 743
    s___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 745
  if (0 > c) {
#line 746
    c = - c;
  }
#line 747
  return ((unsigned int )c % size);
}
}
#line 768
struct var_s variable[256] ;
#line 756 "/home/wslee/benchmarks/clif-0.93/tables.c"
struct ident_tab_loc *point_loc(char *var_name ) 
{ 
  struct tab *pa ;
  struct ident_tab_header *walk ;
  register int count___0 ;
  struct ident_tab_header *count_walk ;

  {
#line 760
  pa = (struct tab *)((void *)0);
#line 761
  walk = identtab_loc;
#line 769
  count___0 = 0;
#line 771
  if (identtab_loc) {
    {
#line 774
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 774
      pa = lookup_loc(var_name, walk);
      }
#line 774
      if (! ((unsigned long )((void *)0) == (unsigned long )pa)) {
#line 774
        goto while_break;
      }
#line 776
      if (walk->previous_level) {
#line 777
        walk = walk->previous_level;
      } else {
#line 779
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 782
  if (pa) {
#line 784
    count_walk = walk->previous_level;
    {
#line 788
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 788
      if (! count_walk) {
#line 788
        goto while_break___0;
      }
#line 790
      count___0 += count_walk->offset;
#line 791
      count_walk = count_walk->previous_level;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 793
    (pa->count) ++;
#line 794
    pa->use_line_number = spf[s].line_counter;
#line 795
    set ++;
#line 795
    variable[set].offset = count___0;
#line 796
    return (walk->table + pa->def);
  } else {
#line 799
    return ((struct ident_tab_loc *)((void *)0));
  }
}
}
#line 807 "/home/wslee/benchmarks/clif-0.93/tables.c"
int has_loc(int type , char *var_name ) 
{ 
  struct tab *np ;
  struct tab *arch ;
  unsigned int tmp___0 ;
  char *tmp___1 ;

  {
#line 814
  if (! identtab_loc) {
    {
#line 815
    identtab_loc = allocate_loc_tables(identtab_loc);
    }
  } else
#line 814
  if (identtab_loc->scope_level < scope_level) {
    {
#line 815
    identtab_loc = allocate_loc_tables(identtab_loc);
    }
  }
  {
#line 817
  np = lookup_loc(var_name, identtab_loc);
  }
#line 817
  if ((unsigned long )((void *)0) == (unsigned long )np) {
    {
#line 823
    tmp___0 = hash_code(var_name, 401U);
#line 823
    np = identtab_loc->hastab_loc + tmp___0;
    }
#line 824
    if ((unsigned long )((void *)0) == (unsigned long )np->name) {
      {
#line 827
      np->name = var_name;
#line 828
      np->declaration_line = spf[s].line_counter;
#line 829
      putstruct_loc(np, type);
      }
    } else {
      {
#line 836
      while (1) {
        while_continue: /* CIL Label */ ;
#line 838
        arch = np;
#line 839
        np = np->next;
#line 836
        if (! ((unsigned long )((void *)0) != (unsigned long )np)) {
#line 836
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 842
      tmp___1 = allocate((unsigned int )sizeof(struct tab ), 1U);
#line 842
      np = (struct tab *)tmp___1;
#line 843
      arch->next = np;
#line 844
      np->name = var_name;
#line 845
      np->declaration_line = spf[s].line_counter;
#line 846
      putstruct_loc(np, type);
      }
    }
#line 848
    (identtab_loc->pi_loc) ++;
#line 849
    if (identtab_loc->pi_loc > 127) {
      {
#line 850
      error_message(6007);
      }
    }
#line 851
    arch = (struct tab *)((void *)0);
#line 852
    return (1);
  } else {
    {
#line 856
    error_message(1003);
    }
#line 857
    return (-1);
  }
}
}
#line 866 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void putstruct_loc(struct tab *np , int type ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 874
  np->def = identtab_loc->pi_loc;
#line 878
  (identtab_loc->table + identtab_loc->pi_loc)->type = typeh[type_spec_count];
#line 882
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 883
    return;
  }
#line 885
  if (8195U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 885
    if (type == 768) {
      {
#line 886
      putstruct_static(identtab_loc->table + identtab_loc->pi_loc);
      }
    }
  }
  {
#line 890
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1024U) {
#line 890
    goto case_1024;
  }
#line 948
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1025U) {
#line 948
    goto case_1025;
  }
#line 1027
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1031U) {
#line 1027
    goto case_1031;
  }
#line 1051
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1029U) {
#line 1051
    goto case_1029;
  }
#line 1051
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1030U) {
#line 1051
    goto case_1029;
  }
#line 1090
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1028U) {
#line 1090
    goto case_1028;
  }
#line 1119
  goto switch_default___3;
  case_1024: /* CIL Label */ 
#line 891
  if (! (typeh[type_spec_count])->attribute.memory_size) {
    {
#line 892
    (typeh[type_spec_count])->attribute.memory_size = allocate_struct(typeh[type_spec_count]);
    }
  }
  {
#line 896
  if ((unsigned int )(typeh[type_spec_count])->attribute.type_qualifier == 4096U) {
#line 896
    goto case_4096;
  }
#line 903
  if ((unsigned int )(typeh[type_spec_count])->attribute.type_qualifier == 4097U) {
#line 903
    goto case_4097;
  }
#line 906
  goto switch_default;
  case_4096: /* CIL Label */ 
#line 897
  (identtab_loc->table + identtab_loc->pi_loc)->adr = ((identtab_loc->table + identtab_loc->pi_loc)->type)->attribute.domain;
#line 899
  (np->l_value_flag) ++;
#line 900
  (np->count) ++;
#line 901
  return;
#line 902
  goto switch_break___0;
  case_4097: /* CIL Label */ 
  {
#line 904
  fprintfx(stderr, "VOLATILE not supported in bookkeeping\n");
  }
#line 905
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 907
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 913
  if (type == 512) {
#line 913
    goto case_512;
  }
#line 933
  if (type == 768) {
#line 933
    goto case_768;
  }
#line 941
  goto switch_default___0;
  case_512: /* CIL Label */ 
#line 914
  if (call_by_reference) {
#line 916
    (identtab_loc->table + identtab_loc->pi_loc)->offset = - count[proc];
#line 918
    count[proc] = (int )((unsigned long )count[proc] - sizeof(char *));
  } else
#line 920
  if (call_by_value) {
#line 922
    if (1U & (unsigned int )((identtab_loc->table + identtab_loc->pi_loc)->type)->attribute.arit_class) {
      {
#line 923
      error_message(1012);
      }
    }
    {
#line 924
    (identtab_loc->table + identtab_loc->pi_loc)->offset = - count[proc];
#line 925
    move_offset_aligned(& count[proc], - ((identtab_loc->table + identtab_loc->pi_loc)->type)->attribute.memory_size);
    }
  }
#line 929
  np->l_value_flag = 1;
#line 930
  if (identtab_loc->pi_loc > 31) {
    {
#line 931
    error_message(6008);
    }
  }
#line 932
  goto switch_break___1;
  case_768: /* CIL Label */ 
#line 934
  if (1U & (unsigned int )((identtab_loc->table + identtab_loc->pi_loc)->type)->attribute.arit_class) {
    {
#line 935
    error_message(1012);
    }
  }
  {
#line 936
  tmp___0 = allocate_struct((identtab_loc->table + identtab_loc->pi_loc)->type);
#line 936
  move_offset_aligned(& count[proc], - tmp___0);
#line 939
  (identtab_loc->table + identtab_loc->pi_loc)->offset = count[proc];
  }
#line 940
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 942
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 942);
#line 943
  error_message(5002);
#line 944
  abort();
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 946
  ((identtab_loc->table + identtab_loc->pi_loc)->type)->attribute.function_class = (enum intern_func_class )1024;
#line 947
  goto switch_break;
  case_1025: /* CIL Label */ 
  {
#line 949
  put_array_subscript(& (identtab_loc->table + identtab_loc->pi_loc)->type);
  }
  {
#line 952
  if (type == 512) {
#line 952
    goto case_512___0;
  }
#line 958
  if (type == 768) {
#line 958
    goto case_768___0;
  }
#line 1020
  goto switch_default___2;
  case_512___0: /* CIL Label */ 
#line 953
  (identtab_loc->table + identtab_loc->pi_loc)->offset = - count[proc];
#line 955
  np->l_value_flag = 1;
#line 956
  count[proc] = (int )((unsigned long )count[proc] - sizeof(char *));
#line 957
  goto switch_break___2;
  case_768___0: /* CIL Label */ 
#line 959
  if (1024U == (unsigned int )(((identtab_loc->table + identtab_loc->pi_loc)->type)->output)->attribute.function_class) {
    {
#line 964
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 136U) {
#line 964
      goto case_136;
    }
#line 964
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 8U) {
#line 964
      goto case_136;
    }
#line 967
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 264U) {
#line 967
      goto case_264;
    }
#line 971
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 152U) {
#line 971
      goto case_152;
    }
#line 971
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 24U) {
#line 971
      goto case_152;
    }
#line 975
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 140U) {
#line 975
      goto case_140;
    }
#line 975
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 12U) {
#line 975
      goto case_140;
    }
#line 978
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 280U) {
#line 978
      goto case_280;
    }
#line 981
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 268U) {
#line 981
      goto case_268;
    }
#line 984
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 64U) {
#line 984
      goto case_64;
    }
#line 987
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 80U) {
#line 987
      goto case_80;
    }
#line 990
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 32U) {
#line 990
      goto case_32;
    }
#line 993
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 2U) {
#line 993
      goto case_2;
    }
#line 997
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 130U) {
#line 997
      goto case_130;
    }
#line 1000
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 258U) {
#line 1000
      goto case_258;
    }
#line 1003
    if ((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class == 1U) {
#line 1003
      goto case_1;
    }
#line 1006
    goto switch_default___1;
    case_136: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 965
    count[proc] = (int )((unsigned long )count[proc] - sizeof(int ) * (unsigned long )count_arr);
#line 966
    goto switch_break___3;
    case_264: /* CIL Label */ 
#line 968
    count[proc] = (int )((unsigned long )count[proc] - sizeof(unsigned int ) * (unsigned long )count_arr);
#line 969
    goto switch_break___3;
    case_152: /* CIL Label */ 
    case_24: /* CIL Label */ 
#line 972
    count[proc] = (int )((unsigned long )count[proc] - sizeof(long ) * (unsigned long )count_arr);
#line 973
    goto switch_break___3;
    case_140: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 976
    count[proc] = (int )((unsigned long )count[proc] - sizeof(short ) * (unsigned long )count_arr);
#line 977
    goto switch_break___3;
    case_280: /* CIL Label */ 
#line 979
    count[proc] = (int )((unsigned long )count[proc] - sizeof(unsigned long ) * (unsigned long )count_arr);
#line 980
    goto switch_break___3;
    case_268: /* CIL Label */ 
#line 982
    count[proc] = (int )((unsigned long )count[proc] - sizeof(unsigned short ) * (unsigned long )count_arr);
#line 983
    goto switch_break___3;
    case_64: /* CIL Label */ 
#line 985
    count[proc] = (int )((unsigned long )count[proc] - sizeof(double ) * (unsigned long )count_arr);
#line 986
    goto switch_break___3;
    case_80: /* CIL Label */ 
#line 988
    count[proc] = (int )((unsigned long )count[proc] - sizeof(long double ) * (unsigned long )count_arr);
#line 989
    goto switch_break___3;
    case_32: /* CIL Label */ 
#line 991
    count[proc] = (int )((unsigned long )count[proc] - sizeof(float ) * (unsigned long )count_arr);
#line 992
    goto switch_break___3;
    case_2: /* CIL Label */ 
#line 995
    count[proc] = (int )((unsigned long )count[proc] - sizeof(char ) * (unsigned long )count_arr);
#line 996
    goto switch_break___3;
    case_130: /* CIL Label */ 
#line 998
    count[proc] = (int )((unsigned long )count[proc] - sizeof(signed char ) * (unsigned long )count_arr);
#line 999
    goto switch_break___3;
    case_258: /* CIL Label */ 
#line 1001
    count[proc] = (int )((unsigned long )count[proc] - sizeof(unsigned char ) * (unsigned long )count_arr);
#line 1002
    goto switch_break___3;
    case_1: /* CIL Label */ 
    {
#line 1004
    error_message(1012);
    }
#line 1005
    return;
    switch_default___1: /* CIL Label */ 
    {
#line 1007
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 1007);
#line 1008
    error_message(5000);
#line 1009
    abort();
    }
    switch_break___3: /* CIL Label */ ;
    }
  } else {
    {
#line 1013
    tmp___1 = allocate_aggregate((identtab_loc->table + identtab_loc->pi_loc)->type);
    }
#line 1013
    if (! tmp___1) {
      {
#line 1014
      error_message(1024);
      }
    }
#line 1015
    count[proc] -= ((identtab_loc->table + identtab_loc->pi_loc)->type)->attribute.memory_size;
  }
#line 1018
  (identtab_loc->table + identtab_loc->pi_loc)->offset = count[proc];
#line 1019
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
  {
#line 1021
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 1021);
#line 1022
  error_message(5002);
#line 1023
  abort();
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 1025
  ((identtab_loc->table + identtab_loc->pi_loc)->type)->attribute.function_class = (enum intern_func_class )1025;
#line 1026
  goto switch_break;
  case_1031: /* CIL Label */ 
#line 1028
  if (! (typeh[type_spec_count])->attribute.memory_size) {
#line 1028
    if (type == 512) {
      {
#line 1030
      error_message(1024);
      }
    } else {
#line 1028
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1031
  if (! (typeh[type_spec_count])->attribute.memory_size) {
    {
#line 1032
    (typeh[type_spec_count])->attribute.memory_size = allocate_struct(typeh[type_spec_count]);
    }
  }
  {
#line 1037
  if (type == 512) {
#line 1037
    goto case_512___1;
  }
#line 1045
  if (type == 768) {
#line 1045
    goto case_768___1;
  }
#line 1035
  goto switch_break___4;
  case_512___1: /* CIL Label */ 
#line 1038
  (identtab_loc->table + identtab_loc->pi_loc)->offset = - count[proc];
#line 1040
  np->l_value_flag = 1;
#line 1041
  count[proc] = (int )((unsigned long )count[proc] - sizeof(char *));
#line 1042
  if (identtab_loc->pi_loc > 31) {
    {
#line 1043
    error_message(6008);
    }
  }
#line 1044
  goto switch_break___4;
  case_768___1: /* CIL Label */ 
  {
#line 1046
  move_offset_aligned(& count[proc], (int )(- sizeof(int )));
  }
#line 1047
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 1049
  goto switch_break;
  case_1029: /* CIL Label */ 
  case_1030: /* CIL Label */ 
#line 1052
  if (! (typeh[type_spec_count])->attribute.memory_size) {
    {
#line 1053
    allocate_aggregate(typeh[type_spec_count]);
    }
  }
  {
#line 1056
  if (type == 512) {
#line 1056
    goto case_512___2;
  }
#line 1072
  if (type == 768) {
#line 1072
    goto case_768___2;
  }
#line 1054
  goto switch_break___5;
  case_512___2: /* CIL Label */ 
#line 1057
  if (! ((identtab_loc->table + identtab_loc->pi_loc)->type)->attribute.memory_size) {
    {
#line 1059
    text = np->name;
#line 1060
    error_message(1024);
    }
  } else {
#line 1064
    (identtab_loc->table + identtab_loc->pi_loc)->offset = - count[proc];
#line 1066
    np->l_value_flag = 1;
#line 1067
    count[proc] = (int )((unsigned long )count[proc] - sizeof(char *));
#line 1068
    if (identtab_loc->pi_loc > 31) {
      {
#line 1069
      error_message(6008);
      }
    }
  }
#line 1071
  goto switch_break___5;
  case_768___2: /* CIL Label */ 
#line 1073
  if (! body_flag) {
    {
#line 1075
    text = np->name;
#line 1076
    error_message(1023);
    }
  } else {
#line 1080
    count[proc] -= ((identtab_loc->table + identtab_loc->pi_loc)->type)->attribute.memory_size;
#line 1082
    count[proc] = (int )((unsigned long )count[proc] - (sizeof(double ) - (unsigned long )count[proc] % sizeof(double )));
#line 1084
    (identtab_loc->table + identtab_loc->pi_loc)->offset = count[proc];
  }
#line 1087
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 1089
  goto switch_break;
  case_1028: /* CIL Label */ 
#line 1091
  if (! (typeh[type_spec_count])->attribute.memory_size) {
#line 1092
    (typeh[type_spec_count])->attribute.memory_size = (int )sizeof(pointer_size );
  }
  {
#line 1096
  if (type == 512) {
#line 1096
    goto case_512___3;
  }
#line 1104
  if (type == 768) {
#line 1104
    goto case_768___3;
  }
#line 1094
  goto switch_break___6;
  case_512___3: /* CIL Label */ 
#line 1097
  (identtab_loc->table + identtab_loc->pi_loc)->offset = - count[proc];
#line 1099
  np->l_value_flag = 1;
#line 1100
  count[proc] = (int )((unsigned long )count[proc] - sizeof(char *));
#line 1101
  if (identtab_loc->pi_loc > 31) {
    {
#line 1102
    error_message(6008);
    }
  }
#line 1103
  goto switch_break___6;
  case_768___3: /* CIL Label */ 
#line 1105
  if (! body_flag) {
    {
#line 1107
    text = np->name;
#line 1108
    error_message(1023);
    }
  } else {
    {
#line 1112
    move_offset_aligned(& count[proc], (int )(- sizeof(pointer_size )));
#line 1113
    (identtab_loc->table + identtab_loc->pi_loc)->offset = count[proc];
    }
  }
#line 1116
  goto switch_break___6;
  switch_break___6: /* CIL Label */ ;
  }
#line 1118
  goto switch_break;
  switch_default___3: /* CIL Label */ 
  {
#line 1120
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 1120);
#line 1121
  error_message(5002);
#line 1122
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1125
  (identtab_loc->table + identtab_loc->pi_loc)->previous = identtab_loc->all;
#line 1127
  identtab_loc->all = identtab_loc->table + identtab_loc->pi_loc;
#line 1133
  return;
}
}
#line 1139 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct tab *lookup_loc(char *s___0 , struct ident_tab_header *identtab_loc___0 ) 
{ 
  struct tab *ps ;
  unsigned int tmp___0 ;

  {
  {
#line 1146
  tmp___0 = hash_code(s___0, 401U);
#line 1146
  ps = identtab_loc___0->hastab_loc + tmp___0;
  }
#line 1147
  if (0 == *((int *)ps)) {
#line 1148
    return ((struct tab *)((void *)0));
  }
  {
#line 1150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1150
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 1150
      if (! ((unsigned long )((void *)0) != (unsigned long )ps->next)) {
#line 1150
        goto while_break;
      }
    } else {
#line 1150
      goto while_break;
    }
#line 1151
    ps = ps->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1152
  if ((unsigned long )((void *)0) == (unsigned long )ps->next) {
#line 1152
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 1153
      return ((struct tab *)((void *)0));
    } else {
#line 1155
      return (ps);
    }
  } else {
#line 1155
    return (ps);
  }
}
}
#line 1164 "/home/wslee/benchmarks/clif-0.93/tables.c"
int add_spec_to_has(void) 
{ 
  struct tab *pa ;
  int tmp___0 ;

  {
  {
#line 1169
  pa = lookup(proc_name_text[proc]);
  }
#line 1169
  if ((unsigned long )((void *)0) == (unsigned long )pa) {
    {
#line 1171
    error_message(1000);
    }
#line 1172
    return (-1);
  } else
#line 1174
  if ((unsigned long )((void *)0) == (unsigned long )((identtab + pa->def)->type)->input) {
#line 1176
    ((identtab + pa->def)->type)->input = l_type_spec;
#line 1177
    l_type_spec = (struct internal_type *)((void *)0);
  } else {
    {
#line 1179
    tmp___0 = compare2trees(((identtab + pa->def)->type)->input, l_type_spec);
    }
#line 1179
    if (-1 == tmp___0) {
#line 1180
      return (-1);
    }
  }
#line 1182
  return (0);
}
}
#line 1191 "/home/wslee/benchmarks/clif-0.93/tables.c"
int add_ident_to_has(void) 
{ 
  struct tab *pa ;
  struct ident_list_str *tmp___0 ;
  struct ident_list_str *tmp1 ;
  int tmp___1 ;

  {
  {
#line 1197
  pa = lookup(proc_name_text[proc]);
  }
#line 1197
  if ((unsigned long )((void *)0) == (unsigned long )pa) {
    {
#line 1199
    error_message(1000);
    }
#line 1200
    return (-1);
  } else
#line 1202
  if ((unsigned long )((void *)0) == (unsigned long )(identtab + pa->def)->list_formal_param) {
#line 1204
    (identtab + pa->def)->list_formal_param = ident_list;
#line 1205
    ident_list = (struct ident_list_str *)((void *)0);
  } else {
#line 1209
    tmp___0 = (identtab + pa->def)->list_formal_param;
    {
#line 1210
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1210
      if ((unsigned long )((void *)0) != (unsigned long )ident_list) {
#line 1210
        if (! ((unsigned long )((void *)0) != (unsigned long )tmp___0)) {
#line 1210
          goto while_break;
        }
      } else {
#line 1210
        goto while_break;
      }
      {
#line 1212
      tmp___1 = strcmp((char const   *)ident_list->ident, (char const   *)tmp___0->ident);
      }
#line 1212
      if (tmp___1) {
        {
#line 1223
        error_message(2005);
        }
#line 1224
        return (-1);
      } else {
#line 1214
        tmp___0 = tmp___0->next;
#line 1215
        tmp1 = ident_list;
#line 1216
        ident_list = ident_list->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1227
    if ((unsigned long )((void *)0) != (unsigned long )tmp___0) {
      {
#line 1229
      error_message(2004);
      }
#line 1230
      return (-1);
    } else
#line 1227
    if ((unsigned long )((void *)0) != (unsigned long )ident_list) {
      {
#line 1229
      error_message(2004);
      }
#line 1230
      return (-1);
    }
  }
#line 1233
  return (0);
}
}
#line 1237 "/home/wslee/benchmarks/clif-0.93/tables.c"
void link_function(int i ) 
{ 
  struct tab *np ;
  unsigned int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1243
  np = lookup(text);
  }
#line 1243
  if ((unsigned long )((void *)0) != (unsigned long )np) {
    {
#line 1249
    tmp___0 = hash_code(text, 1999U);
#line 1249
    np = hastab + tmp___0;
    }
    {
#line 1250
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1250
      if (! ((unsigned long )((void *)0) != (unsigned long )np->name)) {
#line 1250
        goto while_break;
      }
      {
#line 1252
      tmp___2 = strcmp((char const   *)np->name, (char const   *)text);
      }
#line 1252
      if (! tmp___2) {
#line 1254
        if (2049U == (unsigned int )((identtab + np->def)->type)->attribute.function_class) {
          {
#line 1257
          tmp___1 = allocate((unsigned int )sizeof(int ), 0U);
#line 1257
          (identtab + np->def)->adr = tmp___1;
#line 1259
          *((int *)(identtab + np->def)->adr) = i;
#line 1260
          (identtab + np->def)->body = 1;
          }
#line 1261
          goto while_break;
        } else {
          {
#line 1265
          error_message(6000);
          }
#line 1266
          return;
        }
      }
#line 1269
      np = np->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1272
  return;
}
}
#line 1275 "/home/wslee/benchmarks/clif-0.93/tables.c"
void set_value(char *var_name ) 
{ 
  struct tab *pa ;
  struct ident_tab_header *walk ;

  {
#line 1280
  walk = identtab_loc;
#line 1282
  if (identtab_loc) {
    {
#line 1284
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1284
      pa = lookup_loc(var_name, walk);
      }
#line 1284
      if (! ((unsigned long )((void *)0) == (unsigned long )pa)) {
#line 1284
        goto while_break;
      }
#line 1286
      if (walk->previous_level) {
#line 1287
        walk = walk->previous_level;
      } else {
#line 1289
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1291
    if (pa) {
#line 1293
      if (0 == pa->l_value_flag) {
#line 1293
        if (pa->use_line_number != spf[s].line_counter) {
          {
#line 1295
          error_message(6006);
          }
        }
      }
#line 1296
      (pa->l_value_flag) ++;
    }
  }
#line 1299
  return;
}
}
#line 1302 "/home/wslee/benchmarks/clif-0.93/tables.c"
void fix_and_clear_goto_table(void) 
{ 
  int i ;
  struct goto_adr *arch ;
  struct goto_adr *arch_o ;
  struct goto_tab *arch_goto ;
  struct goto_tab *arch_goto_o ;

  {
#line 1308
  i = 0;
  {
#line 1308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1308
    if (! (i < 257)) {
#line 1308
      goto while_break;
    }
#line 1310
    if ((unsigned long )((void *)0) != (unsigned long )(hastab_goto + i)->name) {
#line 1315
      arch_goto = hastab_goto + i;
#line 1316
      arch_goto_o = (struct goto_tab *)((void *)0);
      {
#line 1317
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1317
        if (! ((unsigned long )((void *)0) != (unsigned long )arch_goto)) {
#line 1317
          goto while_break___0;
        }
#line 1319
        if ((unsigned long )((void *)0) == (unsigned long )arch_goto->gnext) {
          {
#line 1321
          text = arch_goto->name;
#line 1322
          error_line_number = arch_goto->line_number;
#line 1323
          error_message(6004);
#line 1324
          error_line_number = 0;
          }
        }
#line 1326
        if ((unsigned long )((void *)0) == (unsigned long )arch_goto->label_adr) {
          {
#line 1328
          text = arch_goto->name;
#line 1329
          error_line_number = arch_goto->line_number;
#line 1330
          error_message(3005);
#line 1331
          error_line_number = 0;
          }
#line 1332
          return;
        }
#line 1335
        arch = arch_goto->gnext;
        {
#line 1336
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1336
          if (! ((unsigned long )((void *)0) != (unsigned long )arch)) {
#line 1336
            goto while_break___1;
          }
#line 1338
          ((struct OPERAND_1_ma *)arch->adr)->adr = arch_goto->label_adr;
#line 1340
          arch_o = arch;
#line 1341
          arch = arch->gnext;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1349
        if ((unsigned long )((void *)0) != (unsigned long )arch_goto_o) {
#line 1351
          arch_goto_o = arch_goto;
#line 1352
          arch_goto = arch_goto->next;
        } else {
#line 1359
          arch_goto->name = (char *)((void *)0);
#line 1360
          arch_goto->label_adr = (char *)((void *)0);
#line 1361
          arch_goto->line_number = 0;
#line 1362
          arch_goto->gnext = (struct goto_adr *)((void *)0);
#line 1363
          arch_goto_o = arch_goto;
#line 1364
          arch_goto = arch_goto->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1369
  return;
}
}
#line 1376 "/home/wslee/benchmarks/clif-0.93/tables.c"
int has_goto(char *label_name ) 
{ 
  struct goto_tab *np ;
  unsigned int tmp___0 ;
  char *tmp___1 ;
  struct goto_tab *arch ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct goto_adr *arch___0 ;
  struct goto_adr *arch_o ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1382
  np = lookup_goto_table(label_name);
  }
#line 1382
  if ((unsigned long )((void *)0) == (unsigned long )np) {
    {
#line 1388
    tmp___0 = hash_code(label_name, 257U);
#line 1388
    np = hastab_goto + tmp___0;
    }
#line 1389
    if ((unsigned long )((void *)0) == (unsigned long )np->name) {
      {
#line 1391
      np->name = label_name;
#line 1392
      tmp___1 = allocate((unsigned int )sizeof(struct goto_adr ), 0U);
#line 1392
      np->gnext = (struct goto_adr *)tmp___1;
#line 1394
      (np->gnext)->adr = kodp;
#line 1395
      (np->gnext)->line_number = spf[s].line_counter;
      }
    } else {
      {
#line 1403
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1405
        arch = np;
#line 1406
        np = np->next;
#line 1403
        if (! ((unsigned long )((void *)0) != (unsigned long )np)) {
#line 1403
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1409
      tmp___2 = allocate((unsigned int )sizeof(struct goto_tab ), 0U);
#line 1409
      np = (struct goto_tab *)tmp___2;
#line 1411
      arch->next = np;
#line 1412
      np->name = label_name;
#line 1413
      tmp___3 = allocate((unsigned int )sizeof(struct goto_adr ), 0U);
#line 1413
      np->gnext = (struct goto_adr *)tmp___3;
#line 1415
      (np->gnext)->adr = kodp;
#line 1416
      (np->gnext)->line_number = spf[s].line_counter;
#line 1417
      arch = (struct goto_tab *)((void *)0);
      }
    }
#line 1419
    return (1);
  } else {
#line 1423
    if ((unsigned long )((void *)0) != (unsigned long )np->gnext) {
#line 1427
      arch___0 = np->gnext;
      {
#line 1428
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1430
        arch_o = arch___0;
#line 1431
        arch___0 = arch___0->gnext;
#line 1428
        if (! ((unsigned long )((void *)0) != (unsigned long )arch___0)) {
#line 1428
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1434
      tmp___4 = allocate((unsigned int )sizeof(struct goto_adr ), 0U);
#line 1434
      arch___0 = (struct goto_adr *)tmp___4;
#line 1436
      arch_o->gnext = arch___0;
#line 1437
      arch___0->adr = kodp;
#line 1438
      arch___0->line_number = spf[s].line_counter;
#line 1439
      arch_o = (struct goto_adr *)((void *)0);
      }
    } else {
      {
#line 1443
      tmp___5 = allocate((unsigned int )sizeof(struct goto_adr ), 0U);
#line 1443
      np->gnext = (struct goto_adr *)tmp___5;
#line 1445
      (np->gnext)->adr = kodp;
#line 1446
      (np->gnext)->line_number = spf[s].line_counter;
      }
    }
#line 1448
    return (1);
  }
}
}
#line 1457 "/home/wslee/benchmarks/clif-0.93/tables.c"
int has_label(char *label_name ) 
{ 
  struct goto_tab *np ;
  unsigned int tmp___0 ;
  struct goto_tab *arch ;
  char *tmp___1 ;

  {
  {
#line 1463
  np = lookup_goto_table(label_name);
  }
#line 1463
  if ((unsigned long )((void *)0) == (unsigned long )np) {
    {
#line 1469
    tmp___0 = hash_code(label_name, 257U);
#line 1469
    np = hastab_goto + tmp___0;
    }
#line 1470
    if ((unsigned long )((void *)0) == (unsigned long )np->name) {
#line 1472
      np->name = text;
#line 1473
      np->label_adr = kodp;
#line 1474
      np->line_number = spf[s].line_counter;
    } else {
      {
#line 1482
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1484
        arch = np;
#line 1485
        np = np->next;
#line 1482
        if (! ((unsigned long )((void *)0) != (unsigned long )np)) {
#line 1482
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1488
      tmp___1 = allocate((unsigned int )sizeof(struct goto_tab ), 0U);
#line 1488
      np = (struct goto_tab *)tmp___1;
#line 1490
      arch->next = np;
#line 1491
      np->name = text;
#line 1492
      np->label_adr = kodp;
#line 1493
      np->line_number = spf[s].line_counter;
#line 1494
      arch = (struct goto_tab *)((void *)0);
      }
    }
#line 1496
    return (1);
  } else
#line 1500
  if ((unsigned long )((void *)0) == (unsigned long )np->label_adr) {
#line 1502
    np->label_adr = kodp;
#line 1503
    np->line_number = spf[s].line_counter;
#line 1504
    return (1);
  } else {
    {
#line 1508
    error_message(3004);
    }
#line 1509
    return (-1);
  }
}
}
#line 1519 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct goto_tab *lookup_goto_table(char *s___0 ) 
{ 
  struct goto_tab *ps ;
  unsigned int tmp___0 ;

  {
  {
#line 1525
  tmp___0 = hash_code(s___0, 257U);
#line 1525
  ps = hastab_goto + tmp___0;
  }
#line 1526
  if (0 == *((int *)ps)) {
#line 1527
    return ((struct goto_tab *)((void *)0));
  }
  {
#line 1529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1529
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 1529
      if (! ((unsigned long )((void *)0) != (unsigned long )ps->next)) {
#line 1529
        goto while_break;
      }
    } else {
#line 1529
      goto while_break;
    }
#line 1530
    ps = ps->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1531
  if ((unsigned long )((void *)0) == (unsigned long )ps->next) {
#line 1531
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 1532
      return ((struct goto_tab *)((void *)0));
    } else {
#line 1534
      return (ps);
    }
  } else {
#line 1534
    return (ps);
  }
}
}
#line 1541 "/home/wslee/benchmarks/clif-0.93/tables.c"
void align_memory(char **p , int n ) 
{ 
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1547
  if (n > 0) {
#line 1547
    tmp___0 = n;
  } else {
#line 1547
    tmp___0 = - n;
  }
#line 1547
  if (! ((unsigned long )tmp___0 <= sizeof(long double ))) {
    {
#line 1547
    __assert_fail("(n > 0 ? n : -n) <= sizeof (long double)", "/home/wslee/benchmarks/clif-0.93/tables.c",
                  1547U, "align_memory");
    }
  }
  {
#line 1550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1550
    if (! ((long )*p % (long )n)) {
#line 1550
      goto while_break;
    }
#line 1551
    if (n > 0) {
#line 1551
      *p += sizeof(char );
    } else {
#line 1551
      *p -= sizeof(char );
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1552
  return;
}
}
#line 1555 "/home/wslee/benchmarks/clif-0.93/tables.c"
int scope_offset_get(void) 
{ 


  {
#line 1558
  if (identtab_loc) {
#line 1558
    if (! proc) {
#line 1559
      return (- identtab_loc->offset);
    }
  }
#line 1560
  return (0);
}
}
#line 1564 "/home/wslee/benchmarks/clif-0.93/tables.c"
int scope_offset_set(int off ) 
{ 
  unsigned long tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1568
  if (identtab_loc) {
#line 1571
    if (! (off < 0)) {
      {
#line 1571
      __assert_fail("off < 0", "/home/wslee/benchmarks/clif-0.93/tables.c", 1571U,
                    "scope_offset_set");
      }
    }
#line 1574
    identtab_loc->offset = off;
#line 1577
    if ((unsigned long )(- off) % sizeof(double ) > 0UL) {
#line 1577
      tmp___0 = sizeof(double ) - (unsigned long )(- off) % sizeof(double );
    } else {
#line 1577
      tmp___0 = 0UL;
    }
#line 1577
    identtab_loc->offset = (int )((unsigned long )identtab_loc->offset - tmp___0);
#line 1579
    return (- identtab_loc->offset);
  }
#line 1581
  return (0);
}
}
#line 1584 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void move_offset_aligned(int *what , int size ) 
{ 
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1589
  if (size > 0) {
#line 1589
    tmp___0 = size;
  } else {
#line 1589
    tmp___0 = - size;
  }
#line 1589
  if (! ((unsigned long )tmp___0 <= sizeof(long double ))) {
    {
#line 1589
    __assert_fail("(size > 0 ? size : -size) <= sizeof (long double)", "/home/wslee/benchmarks/clif-0.93/tables.c",
                  1589U, "move_offset_aligned");
    }
  }
  {
#line 1592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1592
    if (! ((long )*what % (long )size)) {
#line 1592
      goto while_break;
    }
#line 1593
    if (size > 0) {
#line 1593
      *what = (int )((unsigned long )*what + sizeof(char ));
    } else {
#line 1593
      *what = (int )((unsigned long )*what - sizeof(char ));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1595
  *what += size;
#line 1596
  return;
}
}
#line 1602 "/home/wslee/benchmarks/clif-0.93/tables.c"
static struct tab *lookup_tag(char *s___0 ) 
{ 
  struct tab *ps ;
  unsigned int tmp___0 ;

  {
  {
#line 1608
  tmp___0 = hash_code(s___0, 401U);
#line 1608
  ps = tagtab->hastab_loc + tmp___0;
  }
#line 1609
  if (0 == *((int *)ps)) {
#line 1610
    return ((struct tab *)((void *)0));
  }
  {
#line 1612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1612
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 1612
      if (! ((unsigned long )((void *)0) != (unsigned long )ps->next)) {
#line 1612
        goto while_break;
      }
    } else {
#line 1612
      goto while_break;
    }
#line 1613
    ps = ps->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1614
  if ((unsigned long )((void *)0) == (unsigned long )ps->next) {
#line 1614
    if ((unsigned long )ps->name != (unsigned long )s___0) {
#line 1615
      return ((struct tab *)((void *)0));
    } else {
#line 1617
      return (ps);
    }
  } else {
#line 1617
    return (ps);
  }
}
}
#line 1621 "/home/wslee/benchmarks/clif-0.93/tables.c"
int has_tag(int tag_only , char *tag_name ) 
{ 
  struct tab *pa ;
  struct tab *arch ;
  struct ident_tab_header *walk ;
  unsigned int tmp___0 ;
  char *tmp___1 ;

  {
#line 1626
  pa = (struct tab *)((void *)0);
#line 1629
  if (! tagtab) {
    {
#line 1630
    tagtab = allocate_loc_tables(tagtab);
    }
  } else
#line 1629
  if (tagtab->scope_level < scope_level) {
    {
#line 1630
    tagtab = allocate_loc_tables(tagtab);
    }
  }
#line 1632
  walk = tagtab;
#line 1633
  if (tag_only) {
    {
#line 1635
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1635
      pa = lookup_loc(tag_name, walk);
      }
#line 1635
      if (! ((unsigned long )((void *)0) == (unsigned long )pa)) {
#line 1635
        goto while_break;
      }
#line 1637
      if (walk->previous_level) {
#line 1638
        walk = walk->previous_level;
      } else {
#line 1640
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1644
    pa = lookup_loc(tag_name, walk);
    }
  }
#line 1646
  if (! pa) {
    {
#line 1652
    tmp___0 = hash_code(tag_name, 401U);
#line 1652
    pa = walk->hastab_loc + tmp___0;
    }
#line 1653
    if ((unsigned long )((void *)0) == (unsigned long )pa->name) {
      {
#line 1656
      pa->name = tag_name;
#line 1657
      putstruct_tag(pa);
      }
    } else {
      {
#line 1664
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1666
        arch = pa;
#line 1667
        pa = pa->next;
#line 1664
        if (! ((unsigned long )((void *)0) != (unsigned long )pa)) {
#line 1664
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1670
      tmp___1 = allocate((unsigned int )sizeof(struct tab ), 0U);
#line 1670
      pa = (struct tab *)tmp___1;
#line 1671
      arch->next = pa;
#line 1672
      pa->name = tag_name;
#line 1673
      putstruct_tag(pa);
      }
    }
#line 1675
    (walk->pi_loc) ++;
#line 1676
    arch = (struct tab *)((void *)0);
#line 1677
    return (0);
  } else
#line 1679
  if ((walk->table + pa->def)->body) {
#line 1679
    if (! tag_only) {
#line 1683
      if ((unsigned int )((walk->table + pa->def)->type)->attribute.function_class != (unsigned int )(typeh[type_spec_count])->attribute.function_class) {
        {
#line 1685
        error_message(1026);
        }
      } else
#line 1686
      if (1029U == (unsigned int )((walk->table + pa->def)->type)->attribute.function_class) {
        {
#line 1687
        error_message(1017);
        }
      } else
#line 1688
      if (1030U == (unsigned int )((walk->table + pa->def)->type)->attribute.function_class) {
        {
#line 1689
        error_message(1018);
        }
      } else
#line 1690
      if (1031U == (unsigned int )((walk->table + pa->def)->type)->attribute.function_class) {
        {
#line 1691
        error_message(1019);
        }
      }
#line 1692
      return (-1);
    } else {
#line 1679
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1694
  if (! tag_only) {
#line 1696
    if ((unsigned long )walk == (unsigned long )tagtab) {
      {
#line 1698
      putstruct_tag_body(pa);
      }
#line 1701
      return ((walk->table + pa->def)->body);
    } else {
#line 1704
      return (0);
    }
  } else {
#line 1708
    body_flag = (walk->table + pa->def)->body;
#line 1709
    if (! (walk->table + pa->def)->body) {
#line 1709
      if ((unsigned long )struct_union_enum_name[suen_count] != (unsigned long )tag_name) {
        {
#line 1711
        error_message(1023);
        }
      }
    }
#line 1713
    typeh[type_spec_count] = (walk->table + pa->def)->type;
#line 1714
    return (1);
  }
}
}
#line 1719 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void putstruct_tag(struct tab *np ) 
{ 


  {
#line 1726
  np->def = tagtab->pi_loc;
#line 1731
  (tagtab->table + np->def)->body = body_flag;
#line 1732
  (tagtab->table + np->def)->adr = (char *)((void *)0);
#line 1733
  (tagtab->table + np->def)->type = typeh[type_spec_count];
#line 1734
  return;
}
}
#line 1736 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void putstruct_tag_body(struct tab *np ) 
{ 


  {
#line 1740
  if (! no_compile_only) {
#line 1741
    return;
  }
  {
#line 1742
  body_flag = allocate_aggregate((tagtab->table + np->def)->type);
#line 1742
  (tagtab->table + np->def)->body = body_flag;
  }
#line 1744
  return;
}
}
#line 1750 "/home/wslee/benchmarks/clif-0.93/tables.c"
int add_spec_to_tag(void) 
{ 
  struct tab *pa ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1755
  pa = lookup_tag(proc_name_text[proc]);
  }
#line 1755
  if ((unsigned long )((void *)0) == (unsigned long )pa) {
    {
#line 1757
    error_message(1000);
    }
#line 1758
    return (-1);
  } else
#line 1760
  if (8192U == (unsigned int )((tagtab->table + pa->def)->type)->attribute.storage_class_specifier) {
#line 1760
    if ((unsigned long )((void *)0) == (unsigned long )((tagtab->table + pa->def)->type)->input) {
#line 1763
      (((tagtab->table + pa->def)->type)->output)->input = l_type_spec;
#line 1764
      l_type_spec = (struct internal_type *)((void *)0);
    } else {
#line 1760
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1766
  if (! (8192U == (unsigned int )((tagtab->table + pa->def)->type)->attribute.storage_class_specifier)) {
#line 1766
    if ((unsigned long )((void *)0) == (unsigned long )((tagtab->table + pa->def)->type)->input) {
#line 1769
      ((tagtab->table + pa->def)->type)->input = l_type_spec;
#line 1770
      l_type_spec = (struct internal_type *)((void *)0);
    } else {
#line 1766
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1774
    text = proc_name_text[proc];
    {
#line 1777
    if ((unsigned int )((tagtab->table + pa->def)->type)->attribute.function_class == 1029U) {
#line 1777
      goto case_1029;
    }
#line 1780
    if ((unsigned int )((tagtab->table + pa->def)->type)->attribute.function_class == 1030U) {
#line 1780
      goto case_1030;
    }
#line 1783
    if ((unsigned int )((tagtab->table + pa->def)->type)->attribute.function_class == 1031U) {
#line 1783
      goto case_1031;
    }
#line 1786
    goto switch_default;
    case_1029: /* CIL Label */ 
    {
#line 1778
    error_message(1017);
    }
#line 1779
    goto switch_break;
    case_1030: /* CIL Label */ 
    {
#line 1781
    error_message(1018);
    }
#line 1782
    goto switch_break;
    case_1031: /* CIL Label */ 
    {
#line 1784
    error_message(1019);
    }
#line 1785
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1787
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 1787);
#line 1788
    error_message(5000);
#line 1789
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 1791
    return (-1);
  }
#line 1793
  return (0);
}
}
#line 1800 "/home/wslee/benchmarks/clif-0.93/tables.c"
int add_ident_to_tag(void) 
{ 
  struct tab *pa ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1805
  pa = lookup_tag(proc_name_text[proc]);
  }
#line 1805
  if ((unsigned long )((void *)0) == (unsigned long )pa) {
    {
#line 1807
    error_message(1000);
    }
#line 1808
    return (-1);
  } else
#line 1810
  if ((unsigned long )((void *)0) == (unsigned long )(tagtab->table + pa->def)->list_formal_param) {
#line 1812
    (tagtab->table + pa->def)->list_formal_param = ident_list;
#line 1813
    ident_list = (struct ident_list_str *)((void *)0);
  } else {
#line 1817
    text = proc_name_text[proc];
    {
#line 1820
    if ((unsigned int )((tagtab->table + pa->def)->type)->attribute.function_class == 1029U) {
#line 1820
      goto case_1029;
    }
#line 1823
    if ((unsigned int )((tagtab->table + pa->def)->type)->attribute.function_class == 1030U) {
#line 1823
      goto case_1030;
    }
#line 1826
    if ((unsigned int )((tagtab->table + pa->def)->type)->attribute.function_class == 1031U) {
#line 1826
      goto case_1031;
    }
#line 1829
    goto switch_default;
    case_1029: /* CIL Label */ 
    {
#line 1821
    error_message(1017);
    }
#line 1822
    goto switch_break;
    case_1030: /* CIL Label */ 
    {
#line 1824
    error_message(1018);
    }
#line 1825
    goto switch_break;
    case_1031: /* CIL Label */ 
    {
#line 1827
    error_message(1019);
    }
#line 1828
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1830
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 1830);
#line 1831
    error_message(5000);
#line 1832
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 1834
    return (-1);
  }
#line 1836
  return (0);
}
}
#line 1842 "/home/wslee/benchmarks/clif-0.93/tables.c"
static int allocate_var(struct internal_type *type , char **address ) 
{ 
  int char_array_size ;
  int count_help ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1847
  count_help = 0;
#line 1849
  if (4096U == (unsigned int )type->attribute.type_qualifier) {
    {
#line 1854
    if ((unsigned int )type->attribute.arit_class == 136U) {
#line 1854
      goto case_136;
    }
#line 1854
    if ((unsigned int )type->attribute.arit_class == 8U) {
#line 1854
      goto case_136;
    }
#line 1857
    if ((unsigned int )type->attribute.arit_class == 264U) {
#line 1857
      goto case_264;
    }
#line 1861
    if ((unsigned int )type->attribute.arit_class == 152U) {
#line 1861
      goto case_152;
    }
#line 1861
    if ((unsigned int )type->attribute.arit_class == 24U) {
#line 1861
      goto case_152;
    }
#line 1865
    if ((unsigned int )type->attribute.arit_class == 140U) {
#line 1865
      goto case_140;
    }
#line 1865
    if ((unsigned int )type->attribute.arit_class == 12U) {
#line 1865
      goto case_140;
    }
#line 1868
    if ((unsigned int )type->attribute.arit_class == 280U) {
#line 1868
      goto case_280;
    }
#line 1871
    if ((unsigned int )type->attribute.arit_class == 268U) {
#line 1871
      goto case_268;
    }
#line 1874
    if ((unsigned int )type->attribute.arit_class == 64U) {
#line 1874
      goto case_64;
    }
#line 1877
    if ((unsigned int )type->attribute.arit_class == 80U) {
#line 1877
      goto case_80;
    }
#line 1880
    if ((unsigned int )type->attribute.arit_class == 32U) {
#line 1880
      goto case_32;
    }
#line 1883
    if ((unsigned int )type->attribute.arit_class == 2U) {
#line 1883
      goto case_2;
    }
#line 1886
    if ((unsigned int )type->attribute.arit_class == 130U) {
#line 1886
      goto case_130;
    }
#line 1889
    if ((unsigned int )type->attribute.arit_class == 258U) {
#line 1889
      goto case_258;
    }
#line 1892
    goto switch_default;
    case_136: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 1855
    return ((int )sizeof(int ));
#line 1856
    goto switch_break;
    case_264: /* CIL Label */ 
#line 1858
    return ((int )sizeof(unsigned int ));
#line 1859
    goto switch_break;
    case_152: /* CIL Label */ 
    case_24: /* CIL Label */ 
#line 1862
    return ((int )sizeof(long ));
#line 1863
    goto switch_break;
    case_140: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 1866
    return ((int )sizeof(short ));
#line 1867
    goto switch_break;
    case_280: /* CIL Label */ 
#line 1869
    return ((int )sizeof(unsigned long ));
#line 1870
    goto switch_break;
    case_268: /* CIL Label */ 
#line 1872
    return ((int )sizeof(unsigned short ));
#line 1873
    goto switch_break;
    case_64: /* CIL Label */ 
#line 1875
    return ((int )sizeof(double ));
#line 1876
    goto switch_break;
    case_80: /* CIL Label */ 
#line 1878
    return ((int )sizeof(long double ));
#line 1879
    goto switch_break;
    case_32: /* CIL Label */ 
#line 1881
    return ((int )sizeof(float ));
#line 1882
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1884
    return ((int )sizeof(char ));
#line 1885
    goto switch_break;
    case_130: /* CIL Label */ 
#line 1887
    return ((int )sizeof(signed char ));
#line 1888
    goto switch_break;
    case_258: /* CIL Label */ 
#line 1890
    return ((int )sizeof(unsigned char ));
#line 1891
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1893
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 1893);
#line 1894
    error_message(5000);
#line 1895
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1901
  if ((unsigned int )type->attribute.function_class == 1024U) {
#line 1901
    goto case_1024;
  }
#line 2003
  if ((unsigned int )type->attribute.function_class == 1025U) {
#line 2003
    goto case_1025;
  }
#line 2199
  if ((unsigned int )type->attribute.function_class == 1031U) {
#line 2199
    goto case_1031;
  }
#line 2215
  goto switch_default___2;
  case_1024: /* CIL Label */ 
  {
#line 1905
  if ((unsigned int )type->attribute.arit_class == 136U) {
#line 1905
    goto case_136___0;
  }
#line 1905
  if ((unsigned int )type->attribute.arit_class == 8U) {
#line 1905
    goto case_136___0;
  }
#line 1915
  if ((unsigned int )type->attribute.arit_class == 264U) {
#line 1915
    goto case_264___0;
  }
#line 1923
  if ((unsigned int )type->attribute.arit_class == 152U) {
#line 1923
    goto case_152___0;
  }
#line 1923
  if ((unsigned int )type->attribute.arit_class == 24U) {
#line 1923
    goto case_152___0;
  }
#line 1931
  if ((unsigned int )type->attribute.arit_class == 140U) {
#line 1931
    goto case_140___0;
  }
#line 1931
  if ((unsigned int )type->attribute.arit_class == 12U) {
#line 1931
    goto case_140___0;
  }
#line 1938
  if ((unsigned int )type->attribute.arit_class == 280U) {
#line 1938
    goto case_280___0;
  }
#line 1945
  if ((unsigned int )type->attribute.arit_class == 268U) {
#line 1945
    goto case_268___0;
  }
#line 1952
  if ((unsigned int )type->attribute.arit_class == 64U) {
#line 1952
    goto case_64___0;
  }
#line 1961
  if ((unsigned int )type->attribute.arit_class == 80U) {
#line 1961
    goto case_80___0;
  }
#line 1968
  if ((unsigned int )type->attribute.arit_class == 32U) {
#line 1968
    goto case_32___0;
  }
#line 1977
  if ((unsigned int )type->attribute.arit_class == 2U) {
#line 1977
    goto case_2___0;
  }
#line 1985
  if ((unsigned int )type->attribute.arit_class == 130U) {
#line 1985
    goto case_130___0;
  }
#line 1991
  if ((unsigned int )type->attribute.arit_class == 258U) {
#line 1991
    goto case_258___0;
  }
#line 1997
  goto switch_default___0;
  case_136___0: /* CIL Label */ 
  case_8___0: /* CIL Label */ 
  {
#line 1906
  align_memory(& kodp, (int )sizeof(int ));
#line 1907
  *address = kodp;
#line 1911
  *((int *)kodp) = 0;
#line 1912
  kodp += sizeof(int );
  }
#line 1913
  return ((int )sizeof(int ));
#line 1914
  goto switch_break___1;
  case_264___0: /* CIL Label */ 
  {
#line 1916
  align_memory(& kodp, (int )sizeof(unsigned int ));
#line 1917
  *address = kodp;
#line 1918
  *((unsigned int *)kodp) = 0U;
#line 1919
  kodp += sizeof(unsigned int );
  }
#line 1920
  return ((int )sizeof(unsigned int ));
#line 1921
  goto switch_break___1;
  case_152___0: /* CIL Label */ 
  case_24___0: /* CIL Label */ 
  {
#line 1924
  align_memory(& kodp, (int )sizeof(long ));
#line 1925
  *address = kodp;
#line 1926
  *((long *)kodp) = 0L;
#line 1927
  kodp += sizeof(long );
  }
#line 1928
  return ((int )sizeof(long ));
#line 1929
  goto switch_break___1;
  case_140___0: /* CIL Label */ 
  case_12___0: /* CIL Label */ 
  {
#line 1932
  align_memory(& kodp, (int )sizeof(short ));
#line 1933
  *address = kodp;
#line 1934
  *((short *)kodp) = (short)0;
#line 1935
  kodp += sizeof(short );
  }
#line 1936
  return ((int )sizeof(short ));
#line 1937
  goto switch_break___1;
  case_280___0: /* CIL Label */ 
  {
#line 1939
  align_memory(& kodp, (int )sizeof(unsigned long ));
#line 1940
  *address = kodp;
#line 1941
  *((unsigned long *)kodp) = 0UL;
#line 1942
  kodp += sizeof(unsigned long );
  }
#line 1943
  return ((int )sizeof(unsigned long ));
#line 1944
  goto switch_break___1;
  case_268___0: /* CIL Label */ 
  {
#line 1946
  align_memory(& kodp, (int )sizeof(unsigned short ));
#line 1947
  *address = kodp;
#line 1948
  *((unsigned short *)kodp) = (unsigned short)0;
#line 1949
  kodp += sizeof(unsigned short );
  }
#line 1950
  return ((int )sizeof(unsigned short ));
#line 1951
  goto switch_break___1;
  case_64___0: /* CIL Label */ 
  {
#line 1953
  align_memory(& kodp, (int )sizeof(double ));
#line 1954
  *address = kodp;
#line 1957
  *((double *)kodp) = (double )0;
#line 1958
  kodp += sizeof(double );
  }
#line 1959
  return ((int )sizeof(double ));
#line 1960
  goto switch_break___1;
  case_80___0: /* CIL Label */ 
  {
#line 1962
  align_memory(& kodp, (int )sizeof(long double ));
#line 1963
  *address = kodp;
#line 1964
  *((long double *)kodp) = (long double )0;
#line 1965
  kodp += sizeof(long double );
  }
#line 1966
  return ((int )sizeof(long double ));
#line 1967
  goto switch_break___1;
  case_32___0: /* CIL Label */ 
  {
#line 1969
  align_memory(& kodp, (int )sizeof(float ));
#line 1970
  *address = kodp;
#line 1973
  *((float *)kodp) = (float )0;
#line 1974
  kodp += sizeof(float );
  }
#line 1975
  return ((int )sizeof(float ));
#line 1976
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
#line 1978
  *address = kodp;
#line 1981
  *kodp = (char)0;
#line 1982
  kodp += sizeof(char );
#line 1983
  return ((int )sizeof(char ));
#line 1984
  goto switch_break___1;
  case_130___0: /* CIL Label */ 
#line 1986
  *address = kodp;
#line 1987
  *((signed char *)kodp) = (signed char)0;
#line 1988
  kodp += sizeof(signed char );
#line 1989
  return ((int )sizeof(signed char ));
#line 1990
  goto switch_break___1;
  case_258___0: /* CIL Label */ 
#line 1992
  *address = kodp;
#line 1993
  *((unsigned char *)kodp) = (unsigned char)0;
#line 1994
  kodp += sizeof(unsigned char );
#line 1995
  return ((int )sizeof(unsigned char ));
#line 1996
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 1998
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 1998);
#line 1999
  error_message(5000);
#line 2000
  abort();
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 2002
  goto switch_break___0;
  case_1025: /* CIL Label */ 
  {
#line 2007
  if ((unsigned int )(type->output)->attribute.arit_class == 136U) {
#line 2007
    goto case_136___1;
  }
#line 2007
  if ((unsigned int )(type->output)->attribute.arit_class == 8U) {
#line 2007
    goto case_136___1;
  }
#line 2018
  if ((unsigned int )(type->output)->attribute.arit_class == 264U) {
#line 2018
    goto case_264___1;
  }
#line 2031
  if ((unsigned int )(type->output)->attribute.arit_class == 152U) {
#line 2031
    goto case_152___1;
  }
#line 2031
  if ((unsigned int )(type->output)->attribute.arit_class == 24U) {
#line 2031
    goto case_152___1;
  }
#line 2044
  if ((unsigned int )(type->output)->attribute.arit_class == 140U) {
#line 2044
    goto case_140___1;
  }
#line 2044
  if ((unsigned int )(type->output)->attribute.arit_class == 12U) {
#line 2044
    goto case_140___1;
  }
#line 2056
  if ((unsigned int )(type->output)->attribute.arit_class == 280U) {
#line 2056
    goto case_280___1;
  }
#line 2068
  if ((unsigned int )(type->output)->attribute.arit_class == 268U) {
#line 2068
    goto case_268___1;
  }
#line 2080
  if ((unsigned int )(type->output)->attribute.arit_class == 64U) {
#line 2080
    goto case_64___1;
  }
#line 2091
  if ((unsigned int )(type->output)->attribute.arit_class == 80U) {
#line 2091
    goto case_80___1;
  }
#line 2102
  if ((unsigned int )(type->output)->attribute.arit_class == 32U) {
#line 2102
    goto case_32___1;
  }
#line 2113
  if ((unsigned int )(type->output)->attribute.arit_class == 2U) {
#line 2113
    goto case_2___1;
  }
#line 2139
  if ((unsigned int )(type->output)->attribute.arit_class == 130U) {
#line 2139
    goto case_130___1;
  }
#line 2166
  if ((unsigned int )(type->output)->attribute.arit_class == 258U) {
#line 2166
    goto case_258___1;
  }
#line 2193
  goto switch_default___1;
  case_136___1: /* CIL Label */ 
  case_8___1: /* CIL Label */ 
#line 2008
  *address = kodp;
#line 2009
  count_help = count_arr - 1;
  {
#line 2010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2010
    if (! count_help) {
#line 2010
      goto while_break;
    }
#line 2012
    *((int *)(kodp + (unsigned long )count_help * sizeof(int ))) = 0;
#line 2013
    count_help --;
  }
  while_break: /* CIL Label */ ;
  }
#line 2015
  kodp += (unsigned long )count_arr * sizeof(int );
#line 2016
  return ((int )((unsigned long )count_arr * sizeof(int )));
#line 2017
  goto switch_break___2;
  case_264___1: /* CIL Label */ 
#line 2019
  *address = kodp;
#line 2020
  count_help = count_arr - 1;
  {
#line 2021
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2021
    if (! count_help) {
#line 2021
      goto while_break___0;
    }
#line 2023
    *((unsigned int *)(kodp + (unsigned long )count_help * sizeof(unsigned int ))) = 0U;
#line 2025
    count_help --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2027
  kodp += (unsigned long )count_arr * sizeof(unsigned int );
#line 2028
  return ((int )((unsigned long )count_arr * sizeof(unsigned int )));
#line 2029
  goto switch_break___2;
  case_152___1: /* CIL Label */ 
  case_24___1: /* CIL Label */ 
#line 2032
  *address = kodp;
#line 2033
  count_help = count_arr - 1;
  {
#line 2034
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2034
    if (! count_help) {
#line 2034
      goto while_break___1;
    }
#line 2036
    *((long *)(kodp + (unsigned long )count_help * sizeof(long ))) = 0L;
#line 2038
    count_help --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2040
  kodp += (unsigned long )count_arr * sizeof(long );
#line 2041
  return ((int )((unsigned long )count_arr * sizeof(long )));
#line 2042
  goto switch_break___2;
  case_140___1: /* CIL Label */ 
  case_12___1: /* CIL Label */ 
#line 2045
  *address = kodp;
#line 2046
  count_help = count_arr - 1;
  {
#line 2047
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2047
    if (! count_help) {
#line 2047
      goto while_break___2;
    }
#line 2049
    *((short *)(kodp + (unsigned long )count_help * sizeof(short ))) = (short)0;
#line 2051
    count_help --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2053
  kodp += (unsigned long )count_arr * sizeof(short );
#line 2054
  return ((int )((unsigned long )count_arr * sizeof(short )));
#line 2055
  goto switch_break___2;
  case_280___1: /* CIL Label */ 
#line 2057
  *address = kodp;
#line 2058
  count_help = count_arr - 1;
  {
#line 2059
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2059
    if (! count_help) {
#line 2059
      goto while_break___3;
    }
#line 2061
    *((unsigned long *)(kodp + (unsigned long )count_help * sizeof(unsigned long ))) = 0UL;
#line 2063
    count_help --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2065
  kodp += (unsigned long )count_arr * sizeof(unsigned long );
#line 2066
  return ((int )((unsigned long )count_arr * sizeof(unsigned long )));
#line 2067
  goto switch_break___2;
  case_268___1: /* CIL Label */ 
#line 2069
  *address = kodp;
#line 2070
  count_help = count_arr - 1;
  {
#line 2071
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2071
    if (! count_help) {
#line 2071
      goto while_break___4;
    }
#line 2073
    *((unsigned short *)(kodp + (unsigned long )count_help * sizeof(unsigned short ))) = (unsigned short)0;
#line 2075
    count_help --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2077
  kodp += (unsigned long )count_arr * sizeof(unsigned short );
#line 2078
  return ((int )((unsigned long )count_arr * sizeof(unsigned short )));
#line 2079
  goto switch_break___2;
  case_64___1: /* CIL Label */ 
#line 2081
  *address = kodp;
#line 2082
  count_help = count_arr - 1;
  {
#line 2083
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2083
    if (! count_help) {
#line 2083
      goto while_break___5;
    }
#line 2085
    *((double *)(kodp + (unsigned long )count_help * sizeof(double ))) = (double )0;
#line 2086
    count_help --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2088
  kodp += (unsigned long )count_arr * sizeof(double );
#line 2089
  return ((int )((unsigned long )count_arr * sizeof(double )));
#line 2090
  goto switch_break___2;
  case_80___1: /* CIL Label */ 
#line 2092
  *address = kodp;
#line 2093
  count_help = count_arr - 1;
  {
#line 2094
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2094
    if (! count_help) {
#line 2094
      goto while_break___6;
    }
#line 2096
    *((long double *)(kodp + (unsigned long )count_help * sizeof(long double ))) = (long double )0;
#line 2098
    count_help --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2100
  kodp += (unsigned long )count_arr * sizeof(long double );
#line 2101
  return ((int )((unsigned long )count_arr * sizeof(long double )));
  case_32___1: /* CIL Label */ 
#line 2103
  *address = kodp;
#line 2104
  count_help = count_arr - 1;
  {
#line 2105
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2105
    if (! count_help) {
#line 2105
      goto while_break___7;
    }
#line 2107
    *((float *)(kodp + (unsigned long )count_help * sizeof(float ))) = (float )0;
#line 2108
    count_help --;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2110
  kodp += (unsigned long )count_arr * sizeof(float );
#line 2111
  return ((int )((unsigned long )count_arr * sizeof(float )));
#line 2112
  goto switch_break___2;
  case_2___1: /* CIL Label */ 
#line 2114
  *address = kodp;
#line 2115
  count_help = count_arr - 1;
  {
#line 2116
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2116
    if (! count_help) {
#line 2116
      goto while_break___8;
    }
#line 2118
    *(kodp + (unsigned long )count_help * sizeof(char )) = (char)0;
#line 2119
    count_help --;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 2121
  char_array_size = (int )((unsigned long )count_arr * sizeof(char ));
#line 2126
  if (char_array_size & 3) {
#line 2128
    kodp += (4 - (char_array_size & 3)) + char_array_size;
#line 2130
    return ((4 - (char_array_size & 3)) + char_array_size);
  } else {
#line 2135
    kodp += char_array_size;
#line 2136
    return (char_array_size);
  }
#line 2138
  goto switch_break___2;
  case_130___1: /* CIL Label */ 
#line 2140
  *address = kodp;
#line 2141
  count_help = count_arr - 1;
  {
#line 2142
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2142
    if (! count_help) {
#line 2142
      goto while_break___9;
    }
#line 2144
    *((signed char *)(kodp + (unsigned long )count_help * sizeof(signed char ))) = (signed char)0;
#line 2146
    count_help --;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2148
  char_array_size = (int )((unsigned long )count_arr * sizeof(signed char ));
#line 2153
  if (char_array_size & 3) {
#line 2155
    kodp += (4 - (char_array_size & 3)) + char_array_size;
#line 2157
    return ((4 - (char_array_size & 3)) + char_array_size);
  } else {
#line 2162
    kodp += char_array_size;
#line 2163
    return (char_array_size);
  }
#line 2165
  goto switch_break___2;
  case_258___1: /* CIL Label */ 
#line 2167
  *address = kodp;
#line 2168
  count_help = count_arr - 1;
  {
#line 2169
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2169
    if (! count_help) {
#line 2169
      goto while_break___10;
    }
#line 2171
    *((unsigned char *)(kodp + (unsigned long )count_help * sizeof(unsigned char ))) = (unsigned char)0;
#line 2173
    count_help --;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2175
  char_array_size = (int )((unsigned long )count_arr * sizeof(unsigned char ));
#line 2180
  if (char_array_size & 3) {
#line 2182
    kodp += (4 - (char_array_size & 3)) + char_array_size;
#line 2184
    return ((4 - (char_array_size & 3)) + char_array_size);
  } else {
#line 2189
    kodp += char_array_size;
#line 2190
    return (char_array_size);
  }
#line 2192
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 2194
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 2194);
#line 2195
  error_message(5000);
#line 2196
  abort();
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 2198
  goto switch_break___0;
  case_1031: /* CIL Label */ 
#line 2200
  if (8U == (unsigned int )type->attribute.arit_class) {
    {
#line 2202
    align_memory(& kodp, (int )sizeof(int ));
#line 2203
    *address = kodp;
#line 2204
    *((int *)kodp) = 0;
#line 2205
    kodp += sizeof(int );
    }
#line 2206
    return ((int )sizeof(int ));
  } else {
    {
#line 2210
    fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 2210);
#line 2211
    error_message(5000);
#line 2212
    abort();
    }
  }
#line 2214
  goto switch_break___0;
  switch_default___2: /* CIL Label */ 
  {
#line 2216
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 2216);
#line 2217
  error_message(5000);
#line 2218
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 2220
  return (0);
}
}
#line 2224 "/home/wslee/benchmarks/clif-0.93/tables.c"
static int allocate_struct(struct internal_type *type ) 
{ 
  int char_array_size ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2232
  if ((unsigned int )type->attribute.function_class == 1024U) {
#line 2232
    goto case_1024;
  }
#line 2279
  if ((unsigned int )type->attribute.function_class == 1025U) {
#line 2279
    goto case_1025;
  }
#line 2352
  if ((unsigned int )type->attribute.function_class == 1031U) {
#line 2352
    goto case_1031;
  }
#line 2355
  if ((unsigned int )type->attribute.function_class == 1028U) {
#line 2355
    goto case_1028;
  }
#line 2358
  goto switch_default___1;
  case_1024: /* CIL Label */ 
  {
#line 2236
  if ((unsigned int )type->attribute.arit_class == 136U) {
#line 2236
    goto case_136;
  }
#line 2236
  if ((unsigned int )type->attribute.arit_class == 8U) {
#line 2236
    goto case_136;
  }
#line 2239
  if ((unsigned int )type->attribute.arit_class == 264U) {
#line 2239
    goto case_264;
  }
#line 2243
  if ((unsigned int )type->attribute.arit_class == 152U) {
#line 2243
    goto case_152;
  }
#line 2243
  if ((unsigned int )type->attribute.arit_class == 24U) {
#line 2243
    goto case_152;
  }
#line 2247
  if ((unsigned int )type->attribute.arit_class == 140U) {
#line 2247
    goto case_140;
  }
#line 2247
  if ((unsigned int )type->attribute.arit_class == 12U) {
#line 2247
    goto case_140;
  }
#line 2250
  if ((unsigned int )type->attribute.arit_class == 280U) {
#line 2250
    goto case_280;
  }
#line 2253
  if ((unsigned int )type->attribute.arit_class == 268U) {
#line 2253
    goto case_268;
  }
#line 2256
  if ((unsigned int )type->attribute.arit_class == 64U) {
#line 2256
    goto case_64;
  }
#line 2258
  if ((unsigned int )type->attribute.arit_class == 80U) {
#line 2258
    goto case_80;
  }
#line 2261
  if ((unsigned int )type->attribute.arit_class == 32U) {
#line 2261
    goto case_32;
  }
#line 2263
  if ((unsigned int )type->attribute.arit_class == 2U) {
#line 2263
    goto case_2;
  }
#line 2265
  if ((unsigned int )type->attribute.arit_class == 130U) {
#line 2265
    goto case_130;
  }
#line 2268
  if ((unsigned int )type->attribute.arit_class == 258U) {
#line 2268
    goto case_258;
  }
#line 2271
  if ((unsigned int )type->attribute.arit_class == 1U) {
#line 2271
    goto case_1;
  }
#line 2273
  goto switch_default;
  case_136: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 2237
  return ((int )sizeof(int ));
#line 2238
  goto switch_break___0;
  case_264: /* CIL Label */ 
#line 2240
  return ((int )sizeof(unsigned int ));
#line 2241
  goto switch_break___0;
  case_152: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 2244
  return ((int )sizeof(long ));
#line 2245
  goto switch_break___0;
  case_140: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 2248
  return ((int )sizeof(short ));
#line 2249
  goto switch_break___0;
  case_280: /* CIL Label */ 
#line 2251
  return ((int )sizeof(unsigned long ));
#line 2252
  goto switch_break___0;
  case_268: /* CIL Label */ 
#line 2254
  return ((int )sizeof(unsigned short ));
#line 2255
  goto switch_break___0;
  case_64: /* CIL Label */ 
#line 2257
  return ((int )sizeof(double ));
  case_80: /* CIL Label */ 
#line 2259
  return ((int )sizeof(long double ));
#line 2260
  goto switch_break___0;
  case_32: /* CIL Label */ 
#line 2262
  return ((int )sizeof(float ));
  case_2: /* CIL Label */ 
#line 2264
  return ((int )sizeof(char ));
  case_130: /* CIL Label */ 
#line 2266
  return ((int )sizeof(signed char ));
#line 2267
  goto switch_break___0;
  case_258: /* CIL Label */ 
#line 2269
  return ((int )sizeof(unsigned char ));
#line 2270
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 2272
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 2274
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 2274);
#line 2275
  error_message(5000);
#line 2276
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 2278
  goto switch_break;
  case_1025: /* CIL Label */ 
  {
#line 2283
  if ((unsigned int )(type->output)->attribute.arit_class == 136U) {
#line 2283
    goto case_136___0;
  }
#line 2283
  if ((unsigned int )(type->output)->attribute.arit_class == 8U) {
#line 2283
    goto case_136___0;
  }
#line 2286
  if ((unsigned int )(type->output)->attribute.arit_class == 264U) {
#line 2286
    goto case_264___0;
  }
#line 2290
  if ((unsigned int )(type->output)->attribute.arit_class == 152U) {
#line 2290
    goto case_152___0;
  }
#line 2290
  if ((unsigned int )(type->output)->attribute.arit_class == 24U) {
#line 2290
    goto case_152___0;
  }
#line 2294
  if ((unsigned int )(type->output)->attribute.arit_class == 140U) {
#line 2294
    goto case_140___0;
  }
#line 2294
  if ((unsigned int )(type->output)->attribute.arit_class == 12U) {
#line 2294
    goto case_140___0;
  }
#line 2297
  if ((unsigned int )(type->output)->attribute.arit_class == 280U) {
#line 2297
    goto case_280___0;
  }
#line 2300
  if ((unsigned int )(type->output)->attribute.arit_class == 268U) {
#line 2300
    goto case_268___0;
  }
#line 2303
  if ((unsigned int )(type->output)->attribute.arit_class == 64U) {
#line 2303
    goto case_64___0;
  }
#line 2305
  if ((unsigned int )(type->output)->attribute.arit_class == 80U) {
#line 2305
    goto case_80___0;
  }
#line 2308
  if ((unsigned int )(type->output)->attribute.arit_class == 32U) {
#line 2308
    goto case_32___0;
  }
#line 2310
  if ((unsigned int )(type->output)->attribute.arit_class == 2U) {
#line 2310
    goto case_2___0;
  }
#line 2322
  if ((unsigned int )(type->output)->attribute.arit_class == 130U) {
#line 2322
    goto case_130___0;
  }
#line 2333
  if ((unsigned int )(type->output)->attribute.arit_class == 258U) {
#line 2333
    goto case_258___0;
  }
#line 2344
  if ((unsigned int )(type->output)->attribute.arit_class == 1U) {
#line 2344
    goto case_1___0;
  }
#line 2346
  goto switch_default___0;
  case_136___0: /* CIL Label */ 
  case_8___0: /* CIL Label */ 
#line 2284
  return ((int )((unsigned long )count_arr * sizeof(int )));
#line 2285
  goto switch_break___1;
  case_264___0: /* CIL Label */ 
#line 2287
  return ((int )((unsigned long )count_arr * sizeof(unsigned int )));
#line 2288
  goto switch_break___1;
  case_152___0: /* CIL Label */ 
  case_24___0: /* CIL Label */ 
#line 2291
  return ((int )((unsigned long )count_arr * sizeof(long )));
#line 2292
  goto switch_break___1;
  case_140___0: /* CIL Label */ 
  case_12___0: /* CIL Label */ 
#line 2295
  return ((int )((unsigned long )count_arr * sizeof(short )));
#line 2296
  goto switch_break___1;
  case_280___0: /* CIL Label */ 
#line 2298
  return ((int )((unsigned long )count_arr * sizeof(unsigned long )));
#line 2299
  goto switch_break___1;
  case_268___0: /* CIL Label */ 
#line 2301
  return ((int )((unsigned long )count_arr * sizeof(unsigned short )));
#line 2302
  goto switch_break___1;
  case_64___0: /* CIL Label */ 
#line 2304
  return ((int )((unsigned long )count_arr * sizeof(double )));
  case_80___0: /* CIL Label */ 
#line 2306
  return ((int )((unsigned long )count_arr * sizeof(long double )));
#line 2307
  goto switch_break___1;
  case_32___0: /* CIL Label */ 
#line 2309
  return ((int )((unsigned long )count_arr * sizeof(float )));
  case_2___0: /* CIL Label */ 
#line 2311
  char_array_size = (int )((unsigned long )count_arr * sizeof(char ));
#line 2316
  if (char_array_size & 3) {
#line 2317
    return ((4 - (char_array_size & 3)) + char_array_size);
  } else {
#line 2320
    return (char_array_size);
  }
#line 2321
  goto switch_break___1;
  case_130___0: /* CIL Label */ 
#line 2323
  char_array_size = (int )((unsigned long )count_arr * sizeof(signed char ));
#line 2327
  if (char_array_size & 3) {
#line 2328
    return ((4 - (char_array_size & 3)) + char_array_size);
  } else {
#line 2331
    return (char_array_size);
  }
#line 2332
  goto switch_break___1;
  case_258___0: /* CIL Label */ 
#line 2334
  char_array_size = (int )((unsigned long )count_arr * sizeof(unsigned char ));
#line 2338
  if (char_array_size & 3) {
#line 2339
    return ((4 - (char_array_size & 3)) + char_array_size);
  } else {
#line 2342
    return (char_array_size);
  }
#line 2343
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
#line 2345
  return (0);
  switch_default___0: /* CIL Label */ 
  {
#line 2347
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 2347);
#line 2348
  error_message(5000);
#line 2349
  abort();
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 2351
  goto switch_break;
  case_1031: /* CIL Label */ 
#line 2353
  return ((int )sizeof(int ));
#line 2354
  goto switch_break;
  case_1028: /* CIL Label */ 
#line 2356
  return ((int )sizeof(pointer_size ));
#line 2357
  goto switch_break;
  switch_default___1: /* CIL Label */ 
  {
#line 2359
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 2359);
#line 2360
  error_message(5000);
#line 2361
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 2363
  return (0);
}
}
#line 2369 "/home/wslee/benchmarks/clif-0.93/tables.c"
static int find_member(char *name___0 , struct internal_type *type_to_find ) 
{ 
  int offset ;
  int tmp___0 ;

  {
#line 2374
  offset = 0;
  {
#line 2376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2376
    if ((unsigned long )type_to_find != (unsigned long )((void *)0)) {
      {
#line 2376
      tmp___0 = strcmp((char const   *)name___0, (char const   *)type_to_find->field_name);
      }
#line 2376
      if (! tmp___0) {
#line 2376
        goto while_break;
      }
    } else {
#line 2376
      goto while_break;
    }
#line 2376
    type_to_find = type_to_find->arity;
  }
  while_break: /* CIL Label */ ;
  }
#line 2381
  if ((unsigned long )((void *)0) == (unsigned long )type_to_find) {
    {
#line 2383
    text = name___0;
#line 2384
    error_message(2008);
    }
#line 2385
    return (-1);
  }
#line 2387
  offset = type_to_find->offset;
#line 2389
  type_com[set] = type_to_find;
#line 2390
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 2391
    type_ac[set] = (enum intern_arit_class )24;
  } else {
#line 2393
    type_ac[set] = type_to_find->attribute.arit_class;
  }
#line 2394
  return (offset);
}
}
#line 2398 "/home/wslee/benchmarks/clif-0.93/tables.c"
int offset_aggregate_ident(void) 
{ 
  int tmp___0 ;

  {
  {
#line 2401
  tmp___0 = find_member(text, type_com[set]);
  }
#line 2401
  return (tmp___0);
}
}
#line 2404 "/home/wslee/benchmarks/clif-0.93/tables.c"
static int allocate_aggregate(struct internal_type *type ) 
{ 
  struct internal_type *walk ;
  int size ;
  int first_align ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 2408
  walk = type->input;
#line 2409
  size = 0;
#line 2410
  first_align = 0;
#line 2412
  if (8192U == (unsigned int )type->attribute.storage_class_specifier) {
#line 2412
    if (! type->attribute.memory_size) {
      {
#line 2414
      type->attribute.memory_size = allocate_aggregate(type->output);
      }
#line 2416
      return (1);
    }
  }
#line 2419
  if (1024U == (unsigned int )type->attribute.function_class) {
#line 2419
    if (! type->attribute.memory_size) {
      {
#line 2421
      type->attribute.memory_size = allocate_struct(type);
      }
#line 2422
      return (1);
    }
  }
#line 2425
  if (1031U == (unsigned int )type->attribute.function_class) {
#line 2425
    if (! type->attribute.memory_size) {
      {
#line 2427
      type->attribute.memory_size = allocate_struct(type);
      }
#line 2428
      return (1);
    }
  }
#line 2431
  if ((unsigned long )((void *)0) == (unsigned long )walk) {
#line 2432
    return (0);
  }
  {
#line 2436
  if ((unsigned int )type->attribute.function_class == 1025U) {
#line 2436
    goto case_1025;
  }
#line 2455
  if ((unsigned int )type->attribute.function_class == 1029U) {
#line 2455
    goto case_1029;
  }
#line 2496
  if ((unsigned int )type->attribute.function_class == 1030U) {
#line 2496
    goto case_1030;
  }
#line 2527
  goto switch_default;
  case_1025: /* CIL Label */ 
#line 2438
  if (! (type->output)->attribute.memory_size) {
    {
#line 2439
    allocate_aggregate(type->output);
    }
  }
#line 2440
  size = 1;
#line 2441
  if (0 >= ((struct range *)walk->attribute.domain)->upper) {
#line 2442
    return (0);
  }
  {
#line 2443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2443
    if (! walk) {
#line 2443
      goto while_break;
    }
#line 2445
    size *= ((struct range *)walk->attribute.domain)->upper - ((struct range *)walk->attribute.domain)->lower;
#line 2447
    walk->attribute.memory_size = size * (type->output)->attribute.memory_size;
#line 2449
    walk = walk->arity;
  }
  while_break: /* CIL Label */ ;
  }
#line 2451
  type->attribute.memory_size = size * (type->output)->attribute.memory_size;
#line 2454
  goto switch_break;
  case_1029: /* CIL Label */ 
  {
#line 2456
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2456
    if (! walk) {
#line 2456
      goto while_break___0;
    }
#line 2458
    if (! walk->attribute.memory_size) {
#line 2460
      if (1025U == (unsigned int )walk->attribute.function_class) {
        {
#line 2461
        allocate_aggregate(walk);
        }
      } else
#line 2460
      if (1029U == (unsigned int )walk->attribute.function_class) {
        {
#line 2461
        allocate_aggregate(walk);
        }
      } else {
        {
#line 2463
        tmp___0 = allocate_struct(walk);
#line 2463
        walk->attribute.memory_size += tmp___0;
        }
      }
    }
#line 2465
    type->attribute.memory_size += walk->attribute.memory_size;
#line 2468
    if (! first_align) {
#line 2469
      if (walk->attribute.memory_size > 4) {
#line 2469
        first_align = 4;
      } else {
#line 2469
        first_align = walk->attribute.memory_size;
      }
    }
#line 2473
    if (walk->attribute.memory_size <= 4) {
#line 2474
      size = type->attribute.memory_size % walk->attribute.memory_size;
    } else {
#line 2477
      size = type->attribute.memory_size % 4;
    }
#line 2478
    if (size > 0) {
#line 2478
      if (walk->attribute.memory_size <= 4) {
#line 2480
        type->attribute.memory_size += walk->attribute.memory_size - size;
      } else {
#line 2478
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2482
    if (size > 0) {
#line 2483
      type->attribute.memory_size += 4 - size;
    }
#line 2485
    walk->offset = type->attribute.memory_size - walk->attribute.memory_size;
#line 2487
    walk = walk->arity;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2489
  size = type->attribute.memory_size % first_align;
#line 2490
  if (size > 0) {
#line 2494
    type->attribute.memory_size += first_align - size;
  }
#line 2495
  goto switch_break;
  case_1030: /* CIL Label */ 
  {
#line 2497
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2497
    if (! walk) {
#line 2497
      goto while_break___1;
    }
#line 2499
    if (! walk->attribute.memory_size) {
#line 2501
      if (1025U == (unsigned int )walk->attribute.function_class) {
        {
#line 2502
        allocate_aggregate(walk);
        }
      } else
#line 2501
      if (1029U == (unsigned int )walk->attribute.function_class) {
        {
#line 2502
        allocate_aggregate(walk);
        }
      } else {
        {
#line 2504
        walk->attribute.memory_size = allocate_struct(walk);
        }
      }
    }
#line 2506
    if (type->attribute.memory_size < walk->attribute.memory_size) {
#line 2508
      type->attribute.memory_size = walk->attribute.memory_size;
#line 2511
      if (walk->attribute.memory_size <= 4) {
#line 2512
        size = type->attribute.memory_size % walk->attribute.memory_size;
      } else {
#line 2515
        size = type->attribute.memory_size % 4;
      }
#line 2516
      if (size > 0) {
#line 2516
        if (walk->attribute.memory_size <= 4) {
#line 2518
          type->attribute.memory_size += walk->attribute.memory_size - size;
        } else {
#line 2516
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2520
      if (size > 0) {
#line 2521
        type->attribute.memory_size += 4 - size;
      }
    }
#line 2524
    walk = walk->arity;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2526
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2528
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 2528);
#line 2529
  error_message(5002);
#line 2530
  abort();
  }
#line 2531
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2533
  return (1);
}
}
#line 2538 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void putstruct_static(struct ident_tab_loc *type ) 
{ 
  int i ;
  char *tmp___0 ;
  int i___0 ;
  char *tmp___1 ;
  int i___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 2545
  if ((unsigned int )(type->type)->attribute.function_class == 2049U) {
#line 2545
    goto case_2049;
  }
#line 2545
  if ((unsigned int )(type->type)->attribute.function_class == 2048U) {
#line 2545
    goto case_2049;
  }
#line 2547
  if ((unsigned int )(type->type)->attribute.function_class == 1024U) {
#line 2547
    goto case_1024;
  }
#line 2562
  if ((unsigned int )(type->type)->attribute.function_class == 1025U) {
#line 2562
    goto case_1025;
  }
#line 2573
  if ((unsigned int )(type->type)->attribute.function_class == 1031U) {
#line 2573
    goto case_1031;
  }
#line 2577
  if ((unsigned int )(type->type)->attribute.function_class == 1029U) {
#line 2577
    goto case_1029;
  }
#line 2588
  if ((unsigned int )(type->type)->attribute.function_class == 1030U) {
#line 2588
    goto case_1030;
  }
#line 2599
  if ((unsigned int )(type->type)->attribute.function_class == 1028U) {
#line 2599
    goto case_1028;
  }
#line 2604
  if ((unsigned int )(type->type)->attribute.function_class == 1026U) {
#line 2604
    goto case_1026;
  }
#line 2607
  goto switch_default___0;
  case_2049: /* CIL Label */ 
  case_2048: /* CIL Label */ 
#line 2546
  goto switch_break;
  case_1024: /* CIL Label */ 
  {
#line 2550
  if ((unsigned int )(type->type)->attribute.type_qualifier == 4096U) {
#line 2550
    goto case_4096;
  }
#line 2553
  if ((unsigned int )(type->type)->attribute.type_qualifier == 4097U) {
#line 2553
    goto case_4097;
  }
#line 2556
  goto switch_default;
  case_4096: /* CIL Label */ 
#line 2551
  type->adr = (type->type)->attribute.domain;
#line 2552
  goto switch_break___0;
  case_4097: /* CIL Label */ 
  {
#line 2554
  fprintfx(stderr, "VOLATILE not supported in bookkeeping\n");
  }
#line 2555
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 2557
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 2559
  (type->type)->attribute.memory_size = allocate_var(type->type, & type->adr);
  }
#line 2561
  goto switch_break;
  case_1025: /* CIL Label */ 
  {
#line 2563
  put_array_subscript(& type->type);
#line 2564
  type->body = allocate_aggregate(type->type);
#line 2565
  type->adr = kodp;
#line 2568
  i = 0;
  }
  {
#line 2568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2568
    if (! (i < (type->type)->attribute.memory_size)) {
#line 2568
      goto while_break;
    }
#line 2570
    tmp___0 = kodp;
#line 2570
    kodp ++;
#line 2570
    *tmp___0 = (char)0;
#line 2568
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2572
  goto switch_break;
  case_1031: /* CIL Label */ 
  {
#line 2574
  (type->type)->attribute.memory_size = allocate_var(type->type, & type->adr);
  }
#line 2576
  goto switch_break;
  case_1029: /* CIL Label */ 
#line 2578
  if (! type->body) {
    {
#line 2579
    body_flag = allocate_aggregate(type->type);
#line 2579
    type->body = body_flag;
    }
  }
#line 2581
  type->adr = kodp;
#line 2584
  i___0 = 0;
  {
#line 2584
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2584
    if (! (i___0 < (type->type)->attribute.memory_size)) {
#line 2584
      goto while_break___0;
    }
#line 2585
    tmp___1 = kodp;
#line 2585
    kodp ++;
#line 2585
    *tmp___1 = (char)0;
#line 2584
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2587
  goto switch_break;
  case_1030: /* CIL Label */ 
#line 2589
  if (! type->body) {
    {
#line 2590
    body_flag = allocate_aggregate(type->type);
#line 2590
    type->body = body_flag;
    }
  }
#line 2592
  type->adr = kodp;
#line 2595
  i___1 = 0;
  {
#line 2595
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2595
    if (! (i___1 < (type->type)->attribute.memory_size)) {
#line 2595
      goto while_break___1;
    }
#line 2596
    tmp___2 = kodp;
#line 2596
    kodp ++;
#line 2596
    *tmp___2 = (char)0;
#line 2595
    i___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2598
  goto switch_break;
  case_1028: /* CIL Label */ 
#line 2600
  type->adr = kodp;
#line 2601
  kodp += sizeof(pointer_size );
#line 2602
  *((char **)type->adr) = (char *)((void *)0);
#line 2603
  goto switch_break;
  case_1026: /* CIL Label */ 
  {
#line 2605
  fprintfx(stderr, "LIB not fully supported in book-keeping\n");
  }
#line 2606
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 2608
  fprintfx(stderr, "%s:%d:\n", "/home/wslee/benchmarks/clif-0.93/tables.c", 2608);
#line 2609
  error_message(5002);
#line 2610
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 2612
  return;
}
}
#line 2617 "/home/wslee/benchmarks/clif-0.93/tables.c"
void enter_file_scope(void) 
{ 


  {
#line 2620
  if (! identtab_loc) {
    {
#line 2621
    identtab_loc = allocate_loc_tables(identtab_loc);
    }
  }
#line 2623
  if ((unsigned long )identtab_loc->file_scope != (unsigned long )spf[s].name) {
#line 2624
    identtab_loc->file_scope = spf[s].name;
  }
#line 2625
  return;
}
}
#line 2628 "/home/wslee/benchmarks/clif-0.93/tables.c"
void exit_file_scope(void) 
{ 


  {
#line 2631
  if (identtab_loc) {
#line 2631
    if ((unsigned long )identtab_loc->file_scope == (unsigned long )spf[s].name) {
#line 2632
      identtab_loc->file_scope = (char *)((void *)0);
    }
  }
#line 2633
  return;
}
}
#line 2638 "/home/wslee/benchmarks/clif-0.93/tables.c"
int typedef_p(char *name___0 ) 
{ 
  struct tab *pa ;
  struct ident_tab_header *walk ;

  {
#line 2642
  pa = (struct tab *)((void *)0);
#line 2643
  walk = identtab_loc;
#line 2645
  if (! typedef_f) {
#line 2646
    return (0);
  }
#line 2648
  if (identtab_loc) {
    {
#line 2651
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2651
      pa = lookup_loc(name___0, walk);
      }
#line 2651
      if (! ((unsigned long )((void *)0) == (unsigned long )pa)) {
#line 2651
        goto while_break;
      }
#line 2653
      if (walk->previous_level) {
#line 2654
        walk = walk->previous_level;
      } else {
#line 2656
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2659
  if (pa) {
#line 2659
    if (8192U == (unsigned int )((walk->table + pa->def)->type)->attribute.storage_class_specifier) {
#line 2660
      return (1);
    } else {
#line 2659
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2661
  if ((unsigned long )((void *)0) == (unsigned long )pa) {
    {
#line 2663
    pa = lookup(name___0);
    }
#line 2664
    if (pa) {
#line 2664
      if (8192U == (unsigned int )((identtab + pa->def)->type)->attribute.storage_class_specifier) {
#line 2665
        return (1);
      }
    }
  }
#line 2667
  return (0);
}
}
#line 2672 "/home/wslee/benchmarks/clif-0.93/tables.c"
int get_declaration_line(char *name___0 ) 
{ 
  struct tab *pa ;
  struct ident_tab_header *walk ;

  {
#line 2676
  pa = (struct tab *)((void *)0);
#line 2677
  walk = identtab_loc;
#line 2679
  if (identtab_loc) {
    {
#line 2682
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2682
      pa = lookup_loc(name___0, walk);
      }
#line 2682
      if (! ((unsigned long )((void *)0) == (unsigned long )pa)) {
#line 2682
        goto while_break;
      }
#line 2684
      if (walk->previous_level) {
#line 2685
        walk = walk->previous_level;
      } else {
#line 2687
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2690
  if (pa) {
#line 2691
    return (pa->declaration_line);
  }
  {
#line 2693
  pa = lookup(name___0);
  }
#line 2694
  if (pa) {
#line 2695
    return (pa->declaration_line);
  }
#line 2696
  return (0);
}
}
#line 2702 "/home/wslee/benchmarks/clif-0.93/tables.c"
static int memory_size(int *level , struct internal_type *walk ) 
{ 
  int result ;

  {
#line 2707
  result = 0;
#line 2709
  if (! *level) {
#line 2709
    if (walk->attribute.memory_size) {
#line 2710
      return (walk->attribute.memory_size);
    }
  }
#line 2712
  if (*level) {
#line 2712
    if (! result) {
#line 2712
      if (walk->output) {
        {
#line 2714
        (*level) --;
#line 2715
        result = memory_size(level, walk->output);
        }
#line 2716
        if (1025U == (unsigned int )walk->attribute.function_class) {
#line 2716
          if (! (1029U == (unsigned int )(walk->output)->attribute.function_class)) {
#line 2716
            if (! (1030U == (unsigned int )(walk->output)->attribute.function_class)) {
#line 2721
              (*level) ++;
#line 2722
              result = 0;
            }
          }
        }
      }
    }
  }
#line 2726
  if (*level) {
#line 2726
    if (! result) {
#line 2726
      if (walk->input) {
#line 2728
        if (! (1025U == (unsigned int )walk->attribute.function_class)) {
#line 2729
          (*level) --;
        }
        {
#line 2730
        result = memory_size(level, walk->input);
        }
      }
    }
  }
#line 2733
  if (*level) {
#line 2733
    if (! result) {
#line 2733
      if (walk->arity) {
        {
#line 2735
        (*level) --;
#line 2736
        result = memory_size(level, walk->arity);
        }
      }
    }
  }
#line 2739
  return (result);
}
}
#line 2746 "/home/wslee/benchmarks/clif-0.93/tables.c"
static void check_init_bracket(int *level , struct internal_type *walk , char *buf ) 
{ 
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int i ;
  size_t tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 2753
  if (1029U == (unsigned int )walk->attribute.function_class) {
    {
#line 2753
    tmp___1 = strlen((char const   *)(walk->input)->field_name);
#line 2753
    tmp___2 = strlen((char const   *)buf);
    }
#line 2753
    if (tmp___1 + tmp___2 < 8191U) {
      {
#line 2756
      strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)".");
#line 2757
      strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)(walk->input)->field_name);
      }
    } else {
#line 2753
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2759
  if (1025U == (unsigned int )walk->attribute.function_class) {
#line 2759
    goto _L;
  } else
#line 2759
  if (walk->arity) {
    _L: /* CIL Label */ 
    {
#line 2759
    tmp___0 = strlen((char const   *)buf);
    }
#line 2759
    if (tmp___0 + 4U < 8192U) {
      {
#line 2760
      strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"[0]");
      }
    }
  }
#line 2762
  if (walk->output) {
    {
#line 2764
    (*level) ++;
#line 2765
    check_init_bracket(level, walk->output, buf);
    }
#line 2766
    if (1025U == (unsigned int )walk->attribute.function_class) {
      {
#line 2768
      tmp___3 = strlen((char const   *)buf);
#line 2768
      i = (int )(tmp___3 - 1U);
      }
#line 2769
      if (93 == (int )*(buf + i)) {
#line 2770
        *(buf + (i - 2)) = (char )'\000';
      }
#line 2771
      (*level) --;
    }
  }
#line 2774
  if (walk->input) {
    {
#line 2776
    (*level) ++;
#line 2777
    check_init_bracket(level, walk->input, buf);
    }
#line 2778
    if (walk->arity) {
#line 2779
      (*level) --;
    }
  }
#line 2781
  if (walk->arity) {
    {
#line 2783
    (*level) ++;
#line 2784
    check_init_bracket(level, walk->arity, buf);
    }
  }
#line 2786
  return;
}
}
#line 2796 "/home/wslee/benchmarks/clif-0.93/tables.c"
static int aggregate_level  ;
#line 2789 "/home/wslee/benchmarks/clif-0.93/tables.c"
int get_memory_size(int level , struct internal_type *walk , int initializer_number ) 
{ 
  char buf[8192] ;
  int j ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;

  {
#line 2799
  if (1 == initializer_number) {
    {
#line 2801
    aggregate_level = 0;
#line 2802
    tmp___0 = strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)text,
                      (size_t )8192);
    }
#line 2802
    if (tmp___0) {
      {
#line 2803
      check_init_bracket(& aggregate_level, walk, buf);
      }
    }
#line 2804
    if (aggregate_level > level) {
      {
#line 2805
      error_message(6030, buf);
      }
    }
  }
#line 2808
  if (1 == level) {
#line 2809
    j = 1;
  } else {
#line 2811
    j = aggregate_level - level;
  }
  {
#line 2812
  tmp___1 = memory_size(& j, walk);
  }
#line 2812
  return (tmp___1);
}
}
#line 2818 "/home/wslee/benchmarks/clif-0.93/tables.c"
int get_field_size(int *pos , struct internal_type *walk ) 
{ 
  int result ;

  {
#line 2823
  result = 0;
#line 2825
  if (1024U == (unsigned int )walk->attribute.function_class) {
#line 2825
    if (walk->attribute.memory_size) {
#line 2827
      result = walk->attribute.memory_size;
#line 2828
      (*pos) --;
    }
  }
#line 2831
  if (*pos) {
#line 2831
    if (! (1024U == (unsigned int )walk->attribute.function_class)) {
#line 2831
      if (walk->output) {
        {
#line 2832
        result = get_field_size(pos, walk->output);
        }
      }
    }
  }
#line 2834
  if (*pos) {
#line 2834
    if (1029U == (unsigned int )walk->attribute.function_class) {
#line 2834
      goto _L;
    } else
#line 2834
    if (1030U == (unsigned int )walk->attribute.function_class) {
      _L: /* CIL Label */ 
#line 2834
      if (walk->input) {
        {
#line 2835
        result = get_field_size(pos, walk->input);
        }
      }
    }
  }
#line 2837
  return (result);
}
}
#line 2842 "/home/wslee/benchmarks/clif-0.93/tables.c"
void noninitialized_loc(char *var_name ) 
{ 
  struct tab *pa ;

  {
#line 2846
  pa = (struct tab *)((void *)0);
#line 2848
  if (identtab_loc) {
    {
#line 2849
    pa = lookup_loc(var_name, identtab_loc);
    }
  }
#line 2851
  if (pa) {
#line 2853
    (pa->count) --;
#line 2854
    pa->use_line_number = 0;
  }
#line 2856
  return;
}
}
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 101 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
int yy_rs_leng  ;
#line 102
FILE *yy_rs_in ;
#line 102
FILE *yy_rs_out ;
#line 201 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static YY_rs__BUFFER_STATE yy_rs__current_buffer  =    (YY_rs__BUFFER_STATE )0;
#line 211 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static char yy_rs__hold_char  ;
#line 213 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static int yy_rs__n_chars  ;
#line 219 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static char *yy_rs__c_buf_p  =    (char *)0;
#line 220 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static int yy_rs__init  =    1;
#line 221 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static int yy_rs__start  =    0;
#line 226 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static int yy_rs__did_buffer_switch_on_eof  ;
#line 228
void yy_rs_restart(FILE *input_rs__file ) ;
#line 230
void yy_rs__switch_to_buffer(YY_rs__BUFFER_STATE new_buffer ) ;
#line 231
void yy_rs__load_buffer_state(void) ;
#line 232
YY_rs__BUFFER_STATE yy_rs__create_buffer(FILE *file , int size ) ;
#line 233
void yy_rs__delete_buffer(YY_rs__BUFFER_STATE b ) ;
#line 234
void yy_rs__init_buffer(YY_rs__BUFFER_STATE b , FILE *file ) ;
#line 235
void yy_rs__flush_buffer(YY_rs__BUFFER_STATE b ) ;
#line 238
YY_rs__BUFFER_STATE yy_rs__scan_buffer(char *base , yy_rs__size_t size ) ;
#line 239
YY_rs__BUFFER_STATE yy_rs__scan_string(char const   *yy_rs__str ) ;
#line 240
YY_rs__BUFFER_STATE yy_rs__scan_bytes(char const   *bytes , int len ) ;
#line 242
static void *yy_rs__flex_alloc(yy_rs__size_t size ) ;
#line 243
static void *yy_rs__flex_realloc(void *ptr , yy_rs__size_t size ) ;
#line 244
static void yy_rs__flex_free(void *ptr ) ;
#line 265 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
FILE *yy_rs_in  =    (FILE *)0;
#line 265 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
FILE *yy_rs_out  =    (FILE *)0;
#line 267 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
char *yy_rs_text  ;
#line 270
static yy_rs__state_type yy_rs__get_previous_state(void) ;
#line 271
static yy_rs__state_type yy_rs__try_NUL_trans(yy_rs__state_type yy_rs__current_state ) ;
#line 272
static int yy_rs__get_next_buffer(void) ;
#line 273
static void yy_rs__fatal_error(char const   *msg ) ;
#line 287 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static short const   yy_rs__accept[230]  = 
#line 287
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )48, 
        (short const   )46,      (short const   )1,      (short const   )2,      (short const   )46, 
        (short const   )45,      (short const   )45,      (short const   )3,      (short const   )0, 
        (short const   )18,      (short const   )0,      (short const   )0,      (short const   )16, 
        (short const   )40,      (short const   )28,      (short const   )27,      (short const   )0, 
        (short const   )0,      (short const   )12,      (short const   )23,      (short const   )45, 
        (short const   )19,      (short const   )45,      (short const   )20,      (short const   )17, 
        (short const   )24,      (short const   )3,      (short const   )0,      (short const   )0, 
        (short const   )39,      (short const   )0,      (short const   )4,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )6, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )5, 
        (short const   )45,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )45,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )14, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )38,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )15,      (short const   )0,      (short const   )13,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )31,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )22,      (short const   )44, 
        (short const   )42,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )32,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )37,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )21,      (short const   )43,      (short const   )41, 
        (short const   )0,      (short const   )26,      (short const   )0,      (short const   )30, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )25, 
        (short const   )0,      (short const   )33,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )35,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )34,      (short const   )36,      (short const   )0,      (short const   )0, 
        (short const   )11,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )9,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )29,      (short const   )0,      (short const   )0,      (short const   )10, 
        (short const   )7,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )8,      (short const   )0};
#line 316 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static int const   yy_rs__ec[256]  = 
#line 316
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )7,      (int const   )7,      (int const   )7, 
        (int const   )7,      (int const   )7,      (int const   )7,      (int const   )7, 
        (int const   )7,      (int const   )7,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )8, 
        (int const   )1,      (int const   )9,      (int const   )10,      (int const   )11, 
        (int const   )5,      (int const   )12,      (int const   )5,      (int const   )13, 
        (int const   )14,      (int const   )15,      (int const   )5,      (int const   )5, 
        (int const   )16,      (int const   )5,      (int const   )17,      (int const   )18, 
        (int const   )19,      (int const   )5,      (int const   )20,      (int const   )21, 
        (int const   )22,      (int const   )5,      (int const   )23,      (int const   )24, 
        (int const   )5,      (int const   )25,      (int const   )5,      (int const   )1, 
        (int const   )5,      (int const   )1,      (int const   )1,      (int const   )5, 
        (int const   )1,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )32, 
        (int const   )33,      (int const   )34,      (int const   )5,      (int const   )5, 
        (int const   )35,      (int const   )36,      (int const   )37,      (int const   )38, 
        (int const   )39,      (int const   )5,      (int const   )40,      (int const   )41, 
        (int const   )42,      (int const   )43,      (int const   )44,      (int const   )45, 
        (int const   )5,      (int const   )46,      (int const   )47,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )5,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1};
#line 348 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static int const   yy_rs__meta[48]  = 
#line 348
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )1,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2};
#line 357 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static short const   yy_rs__base[232]  = 
#line 357
  {      (short const   )0,      (short const   )0,      (short const   )8,      (short const   )313, 
        (short const   )314,      (short const   )314,      (short const   )314,      (short const   )13, 
        (short const   )0,      (short const   )51,      (short const   )305,      (short const   )86, 
        (short const   )314,      (short const   )2,      (short const   )0,      (short const   )13, 
        (short const   )17,      (short const   )123,      (short const   )1,      (short const   )265, 
        (short const   )23,      (short const   )314,      (short const   )22,      (short const   )0, 
        (short const   )314,      (short const   )21,      (short const   )0,      (short const   )22, 
        (short const   )0,      (short const   )303,      (short const   )15,      (short const   )38, 
        (short const   )42,      (short const   )54,      (short const   )314,      (short const   )16, 
        (short const   )48,      (short const   )46,      (short const   )47,      (short const   )50, 
        (short const   )271,      (short const   )268,      (short const   )269,      (short const   )270, 
        (short const   )275,      (short const   )264,      (short const   )266,      (short const   )314, 
        (short const   )276,      (short const   )275,      (short const   )262,      (short const   )0, 
        (short const   )53,      (short const   )52,      (short const   )57,      (short const   )54, 
        (short const   )61,      (short const   )52,      (short const   )74,      (short const   )85, 
        (short const   )82,      (short const   )267,      (short const   )263,      (short const   )261, 
        (short const   )256,      (short const   )255,      (short const   )255,      (short const   )251, 
        (short const   )258,      (short const   )65,      (short const   )256,      (short const   )253, 
        (short const   )285,      (short const   )84,      (short const   )79,      (short const   )88, 
        (short const   )107,      (short const   )95,      (short const   )90,      (short const   )314, 
        (short const   )98,      (short const   )103,      (short const   )112,      (short const   )248, 
        (short const   )314,      (short const   )251,      (short const   )248,      (short const   )249, 
        (short const   )249,      (short const   )240,      (short const   )250,      (short const   )239, 
        (short const   )239,      (short const   )244,      (short const   )249,      (short const   )249, 
        (short const   )0,      (short const   )105,      (short const   )314,      (short const   )122, 
        (short const   )118,      (short const   )120,      (short const   )124,      (short const   )121, 
        (short const   )126,      (short const   )130,      (short const   )246,      (short const   )245, 
        (short const   )234,      (short const   )247,      (short const   )238,      (short const   )231, 
        (short const   )230,      (short const   )235,      (short const   )238,      (short const   )263, 
        (short const   )231,      (short const   )239,      (short const   )133,      (short const   )134, 
        (short const   )138,      (short const   )141,      (short const   )155,      (short const   )147, 
        (short const   )152,      (short const   )149,      (short const   )232,      (short const   )226, 
        (short const   )314,      (short const   )220,      (short const   )233,      (short const   )223, 
        (short const   )233,      (short const   )232,      (short const   )228,      (short const   )229, 
        (short const   )225,      (short const   )219,      (short const   )160,      (short const   )160, 
        (short const   )157,      (short const   )157,      (short const   )314,      (short const   )314, 
        (short const   )314,      (short const   )155,      (short const   )227,      (short const   )210, 
        (short const   )314,      (short const   )217,      (short const   )246,      (short const   )210, 
        (short const   )213,      (short const   )314,      (short const   )201,      (short const   )242, 
        (short const   )210,      (short const   )314,      (short const   )314,      (short const   )314, 
        (short const   )156,      (short const   )314,      (short const   )202,      (short const   )314, 
        (short const   )201,      (short const   )200,      (short const   )208,      (short const   )206, 
        (short const   )235,      (short const   )202,      (short const   )233,      (short const   )314, 
        (short const   )206,      (short const   )314,      (short const   )189,      (short const   )193, 
        (short const   )186,      (short const   )142,      (short const   )206,      (short const   )204, 
        (short const   )226,      (short const   )190,      (short const   )314,      (short const   )198, 
        (short const   )197,      (short const   )200,      (short const   )191,      (short const   )178, 
        (short const   )183,      (short const   )192,      (short const   )192,      (short const   )189, 
        (short const   )184,      (short const   )181,      (short const   )213,      (short const   )186, 
        (short const   )314,      (short const   )314,      (short const   )185,      (short const   )171, 
        (short const   )314,      (short const   )144,      (short const   )171,      (short const   )172, 
        (short const   )181,      (short const   )180,      (short const   )183,      (short const   )165, 
        (short const   )177,      (short const   )314,      (short const   )175,      (short const   )170, 
        (short const   )160,      (short const   )161,      (short const   )167,      (short const   )153, 
        (short const   )158,      (short const   )165,      (short const   )145,      (short const   )153, 
        (short const   )314,      (short const   )115,      (short const   )113,      (short const   )314, 
        (short const   )314,      (short const   )74,      (short const   )61,      (short const   )46, 
        (short const   )314,      (short const   )314,      (short const   )202,      (short const   )3};
#line 387 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static short const   yy_rs__def[232]  = 
#line 387
  {      (short const   )0,      (short const   )230,      (short const   )230,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )231,      (short const   )231,      (short const   )231,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )231, 
        (short const   )229,      (short const   )231,      (short const   )231,      (short const   )231, 
        (short const   )231,      (short const   )231,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )231, 
        (short const   )231,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )231,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )231,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )0,      (short const   )229,      (short const   )229};
#line 417 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static short const   yy_rs__nxt[362]  = 
#line 417
  {      (short const   )0,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )23,      (short const   )9,      (short const   )10, 
        (short const   )4,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )34,      (short const   )9,      (short const   )10, 
        (short const   )4,      (short const   )11,      (short const   )35,      (short const   )35, 
        (short const   )229,      (short const   )12,      (short const   )229,      (short const   )13, 
        (short const   )14,      (short const   )36,      (short const   )229,      (short const   )15, 
        (short const   )229,      (short const   )37,      (short const   )34,      (short const   )38, 
        (short const   )51,      (short const   )53,      (short const   )52,      (short const   )57, 
        (short const   )16,      (short const   )17,      (short const   )35,      (short const   )35, 
        (short const   )13,      (short const   )18,      (short const   )19,      (short const   )36, 
        (short const   )20,      (short const   )21,      (short const   )15,      (short const   )37, 
        (short const   )38,      (short const   )51,      (short const   )54,      (short const   )48, 
        (short const   )52,      (short const   )53,      (short const   )55,      (short const   )57, 
        (short const   )49,      (short const   )16,      (short const   )22,      (short const   )24, 
        (short const   )50,      (short const   )25,      (short const   )26,      (short const   )56, 
        (short const   )58,      (short const   )27,      (short const   )59,      (short const   )60, 
        (short const   )54,      (short const   )73,      (short const   )60,      (short const   )74, 
        (short const   )55,      (short const   )75,      (short const   )76,      (short const   )28, 
        (short const   )228,      (short const   )78,      (short const   )25,      (short const   )26, 
        (short const   )56,      (short const   )77,      (short const   )61,      (short const   )58, 
        (short const   )27,      (short const   )62,      (short const   )59,      (short const   )60, 
        (short const   )73,      (short const   )227,      (short const   )60,      (short const   )74, 
        (short const   )75,      (short const   )79,      (short const   )76,      (short const   )80, 
        (short const   )28,      (short const   )30,      (short const   )78,      (short const   )91, 
        (short const   )31,      (short const   )77,      (short const   )82,      (short const   )96, 
        (short const   )97,      (short const   )102,      (short const   )81,      (short const   )98, 
        (short const   )92,      (short const   )32,      (short const   )33,      (short const   )226, 
        (short const   )80,      (short const   )79,      (short const   )30,      (short const   )101, 
        (short const   )103,      (short const   )99,      (short const   )104,      (short const   )31, 
        (short const   )118,      (short const   )105,      (short const   )82,      (short const   )96, 
        (short const   )102,      (short const   )97,      (short const   )81,      (short const   )98, 
        (short const   )100,      (short const   )121,      (short const   )32,      (short const   )33, 
        (short const   )38,      (short const   )120,      (short const   )99,      (short const   )101, 
        (short const   )103,      (short const   )104,      (short const   )105,      (short const   )118, 
        (short const   )119,      (short const   )122,      (short const   )123,      (short const   )225, 
        (short const   )124,      (short const   )224,      (short const   )121,      (short const   )125, 
        (short const   )100,      (short const   )39,      (short const   )138,      (short const   )40, 
        (short const   )120,      (short const   )41,      (short const   )42,      (short const   )139, 
        (short const   )140,      (short const   )43,      (short const   )141,      (short const   )143, 
        (short const   )119,      (short const   )122,      (short const   )123,      (short const   )44, 
        (short const   )124,      (short const   )45,      (short const   )46,      (short const   )125, 
        (short const   )142,      (short const   )144,      (short const   )138,      (short const   )145, 
        (short const   )158,      (short const   )157,      (short const   )159,      (short const   )139, 
        (short const   )140,      (short const   )143,      (short const   )141,      (short const   )160, 
        (short const   )161,      (short const   )171,      (short const   )184,      (short const   )223, 
        (short const   )205,      (short const   )222,      (short const   )185,      (short const   )142, 
        (short const   )206,      (short const   )144,      (short const   )158,      (short const   )145, 
        (short const   )157,      (short const   )221,      (short const   )159,      (short const   )220, 
        (short const   )219,      (short const   )218,      (short const   )217,      (short const   )160, 
        (short const   )216,      (short const   )161,      (short const   )171,      (short const   )8, 
        (short const   )8,      (short const   )215,      (short const   )214,      (short const   )213, 
        (short const   )212,      (short const   )211,      (short const   )210,      (short const   )209, 
        (short const   )208,      (short const   )207,      (short const   )204,      (short const   )203, 
        (short const   )202,      (short const   )201,      (short const   )200,      (short const   )199, 
        (short const   )198,      (short const   )197,      (short const   )196,      (short const   )195, 
        (short const   )194,      (short const   )193,      (short const   )192,      (short const   )191, 
        (short const   )190,      (short const   )189,      (short const   )188,      (short const   )187, 
        (short const   )186,      (short const   )183,      (short const   )182,      (short const   )181, 
        (short const   )180,      (short const   )179,      (short const   )178,      (short const   )177, 
        (short const   )176,      (short const   )175,      (short const   )174,      (short const   )173, 
        (short const   )172,      (short const   )170,      (short const   )169,      (short const   )168, 
        (short const   )167,      (short const   )166,      (short const   )165,      (short const   )164, 
        (short const   )163,      (short const   )162,      (short const   )156,      (short const   )155, 
        (short const   )154,      (short const   )153,      (short const   )152,      (short const   )151, 
        (short const   )150,      (short const   )149,      (short const   )148,      (short const   )147, 
        (short const   )146,      (short const   )137,      (short const   )136,      (short const   )135, 
        (short const   )134,      (short const   )133,      (short const   )132,      (short const   )131, 
        (short const   )130,      (short const   )129,      (short const   )128,      (short const   )127, 
        (short const   )126,      (short const   )117,      (short const   )116,      (short const   )115, 
        (short const   )114,      (short const   )113,      (short const   )112,      (short const   )111, 
        (short const   )110,      (short const   )109,      (short const   )108,      (short const   )107, 
        (short const   )106,      (short const   )95,      (short const   )94,      (short const   )93, 
        (short const   )90,      (short const   )89,      (short const   )88,      (short const   )87, 
        (short const   )86,      (short const   )85,      (short const   )84,      (short const   )83, 
        (short const   )72,      (short const   )71,      (short const   )70,      (short const   )69, 
        (short const   )68,      (short const   )67,      (short const   )66,      (short const   )65, 
        (short const   )64,      (short const   )63,      (short const   )29,      (short const   )47, 
        (short const   )29,      (short const   )229,      (short const   )3,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229};
#line 461 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static short const   yy_rs__chk[362]  = 
#line 461
  {      (short const   )0,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )231,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )2,      (short const   )2,      (short const   )2, 
        (short const   )2,      (short const   )13,      (short const   )2,      (short const   )2, 
        (short const   )2,      (short const   )7,      (short const   )14,      (short const   )18, 
        (short const   )0,      (short const   )7,      (short const   )0,      (short const   )7, 
        (short const   )7,      (short const   )15,      (short const   )0,      (short const   )7, 
        (short const   )0,      (short const   )16,      (short const   )13,      (short const   )22, 
        (short const   )25,      (short const   )30,      (short const   )27,      (short const   )35, 
        (short const   )7,      (short const   )7,      (short const   )14,      (short const   )18, 
        (short const   )7,      (short const   )7,      (short const   )7,      (short const   )15, 
        (short const   )7,      (short const   )7,      (short const   )7,      (short const   )16, 
        (short const   )22,      (short const   )25,      (short const   )31,      (short const   )20, 
        (short const   )27,      (short const   )30,      (short const   )32,      (short const   )35, 
        (short const   )20,      (short const   )7,      (short const   )7,      (short const   )9, 
        (short const   )20,      (short const   )9,      (short const   )9,      (short const   )33, 
        (short const   )36,      (short const   )9,      (short const   )37,      (short const   )38, 
        (short const   )31,      (short const   )52,      (short const   )39,      (short const   )53, 
        (short const   )32,      (short const   )54,      (short const   )55,      (short const   )9, 
        (short const   )227,      (short const   )57,      (short const   )9,      (short const   )9, 
        (short const   )33,      (short const   )56,      (short const   )39,      (short const   )36, 
        (short const   )9,      (short const   )39,      (short const   )37,      (short const   )38, 
        (short const   )52,      (short const   )226,      (short const   )39,      (short const   )53, 
        (short const   )54,      (short const   )58,      (short const   )55,      (short const   )59, 
        (short const   )9,      (short const   )11,      (short const   )57,      (short const   )69, 
        (short const   )11,      (short const   )56,      (short const   )60,      (short const   )73, 
        (short const   )74,      (short const   )78,      (short const   )59,      (short const   )75, 
        (short const   )69,      (short const   )11,      (short const   )11,      (short const   )225, 
        (short const   )59,      (short const   )58,      (short const   )11,      (short const   )77, 
        (short const   )80,      (short const   )76,      (short const   )81,      (short const   )11, 
        (short const   )97,      (short const   )82,      (short const   )60,      (short const   )73, 
        (short const   )78,      (short const   )74,      (short const   )59,      (short const   )75, 
        (short const   )76,      (short const   )101,      (short const   )11,      (short const   )11, 
        (short const   )17,      (short const   )100,      (short const   )76,      (short const   )77, 
        (short const   )80,      (short const   )81,      (short const   )82,      (short const   )97, 
        (short const   )99,      (short const   )102,      (short const   )103,      (short const   )222, 
        (short const   )104,      (short const   )221,      (short const   )101,      (short const   )105, 
        (short const   )76,      (short const   )17,      (short const   )118,      (short const   )17, 
        (short const   )100,      (short const   )17,      (short const   )17,      (short const   )119, 
        (short const   )120,      (short const   )17,      (short const   )121,      (short const   )123, 
        (short const   )99,      (short const   )102,      (short const   )103,      (short const   )17, 
        (short const   )104,      (short const   )17,      (short const   )17,      (short const   )105, 
        (short const   )122,      (short const   )124,      (short const   )118,      (short const   )125, 
        (short const   )139,      (short const   )138,      (short const   )140,      (short const   )119, 
        (short const   )120,      (short const   )123,      (short const   )121,      (short const   )141, 
        (short const   )145,      (short const   )160,      (short const   )177,      (short const   )219, 
        (short const   )201,      (short const   )218,      (short const   )177,      (short const   )122, 
        (short const   )201,      (short const   )124,      (short const   )139,      (short const   )125, 
        (short const   )138,      (short const   )217,      (short const   )140,      (short const   )216, 
        (short const   )215,      (short const   )214,      (short const   )213,      (short const   )141, 
        (short const   )212,      (short const   )145,      (short const   )160,      (short const   )230, 
        (short const   )230,      (short const   )211,      (short const   )210,      (short const   )208, 
        (short const   )207,      (short const   )206,      (short const   )205,      (short const   )204, 
        (short const   )203,      (short const   )202,      (short const   )199,      (short const   )198, 
        (short const   )195,      (short const   )194,      (short const   )193,      (short const   )192, 
        (short const   )191,      (short const   )190,      (short const   )189,      (short const   )188, 
        (short const   )187,      (short const   )186,      (short const   )185,      (short const   )184, 
        (short const   )183,      (short const   )181,      (short const   )180,      (short const   )179, 
        (short const   )178,      (short const   )176,      (short const   )175,      (short const   )174, 
        (short const   )172,      (short const   )170,      (short const   )169,      (short const   )168, 
        (short const   )167,      (short const   )166,      (short const   )165,      (short const   )164, 
        (short const   )162,      (short const   )156,      (short const   )155,      (short const   )154, 
        (short const   )152,      (short const   )151,      (short const   )150,      (short const   )149, 
        (short const   )147,      (short const   )146,      (short const   )137,      (short const   )136, 
        (short const   )135,      (short const   )134,      (short const   )133,      (short const   )132, 
        (short const   )131,      (short const   )130,      (short const   )129,      (short const   )127, 
        (short const   )126,      (short const   )117,      (short const   )116,      (short const   )115, 
        (short const   )114,      (short const   )113,      (short const   )112,      (short const   )111, 
        (short const   )110,      (short const   )109,      (short const   )108,      (short const   )107, 
        (short const   )106,      (short const   )95,      (short const   )94,      (short const   )93, 
        (short const   )92,      (short const   )91,      (short const   )90,      (short const   )89, 
        (short const   )88,      (short const   )87,      (short const   )86,      (short const   )85, 
        (short const   )83,      (short const   )72,      (short const   )71,      (short const   )70, 
        (short const   )68,      (short const   )67,      (short const   )66,      (short const   )65, 
        (short const   )64,      (short const   )63,      (short const   )62,      (short const   )61, 
        (short const   )50,      (short const   )49,      (short const   )48,      (short const   )46, 
        (short const   )45,      (short const   )44,      (short const   )43,      (short const   )42, 
        (short const   )41,      (short const   )40,      (short const   )29,      (short const   )19, 
        (short const   )10,      (short const   )3,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229};
#line 505 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static yy_rs__state_type yy_rs__last_accepting_state  ;
#line 506 "/home/wslee/benchmarks/clif-0.93/rs-lex.c"
static char *yy_rs__last_accepting_cpos  ;
#line 35 "/home/wslee/benchmarks/clif-0.93/rs-parser.h"
YY_rs_STYPE yy_rs_lval ;
#line 52 "/home/wslee/benchmarks/clif-0.93/init_rs.c"
FILE *pfrs  ;
#line 54 "/home/wslee/benchmarks/clif-0.93/init_rs.c"
static char *argv_rs[200]  ;
#line 55 "/home/wslee/benchmarks/clif-0.93/init_rs.c"
static int argc_rs  ;
#line 60
static void switch_to_char_buffer___0(void) ;
#line 64 "/home/wslee/benchmarks/clif-0.93/init_rs.c"
char name[9]  = 
#line 64
  {      (char )'c',      (char )'l',      (char )'i',      (char )'f', 
        (char )'.',      (char )'i',      (char )'n',      (char )'i', 
        (char )'\000'};
#line 68
int yy_rs_wrap(void) ;
#line 133 "/home/wslee/benchmarks/clif-0.93/init_rs.c"
static void switch_to_char_buffer___0(void) 
{ 
  register int i ;
  register int len ;
  char *str_ptr ;
  int tmp_len ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 136
  len = 0;
#line 137
  str_ptr = (char *)((void *)0);
#line 138
  i = 1;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (i < argc_rs)) {
#line 138
      goto while_break;
    }
    {
#line 140
    tmp___0 = strlen((char const   *)argv_rs[i]);
#line 140
    tmp_len = (int )tmp___0;
#line 141
    tmp___1 = reallocx((void *)str_ptr, (unsigned int )((tmp_len + len) + 1));
#line 141
    str_ptr = (char *)tmp___1;
    }
#line 142
    if ((unsigned long )str_ptr == (unsigned long )((void *)0)) {
      {
#line 144
      error_message(4002);
      }
#line 145
      return;
    }
#line 147
    if (len > 0) {
#line 149
      *(str_ptr + len) = (char )' ';
#line 150
      *(str_ptr + (len + 1)) = (char )'\000';
#line 151
      len ++;
    } else {
#line 154
      *(str_ptr + 0) = (char )'\000';
    }
    {
#line 155
    len += tmp_len;
#line 156
    strcat((char */* __restrict  */)str_ptr, (char const   */* __restrict  */)argv_rs[i]);
#line 138
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  if ((unsigned long )((void *)0) != (unsigned long )str_ptr) {
    {
#line 159
    yy_rs__scan_string((char const   *)str_ptr);
    }
  }
#line 160
  return;
}
}
#line 167 "/home/wslee/benchmarks/clif-0.93/init_rs.c"
void init_rs(int argc1 , char **argv1 ) 
{ 
  int b ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 174
  tmp___0 = callocx(1U, 6U);
#line 174
  argvv[0] = tmp___0;
  }
#line 174
  if ((unsigned long )argvv[0] == (unsigned long )((void *)0)) {
    {
#line 176
    error_message(4002);
    }
#line 177
    return;
  }
  {
#line 179
  strcpy((char */* __restrict  */)argvv[0], (char const   */* __restrict  */)"stdin");
#line 181
  b = 1;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (b < argc1)) {
#line 181
      goto while_break;
    }
    {
#line 183
    tmp___2 = strlen((char const   *)*(argv1 + b));
#line 183
    tmp___3 = callocx(1U, tmp___2 + 1U);
#line 183
    tmp___1 = tmp___3;
#line 183
    argv_rs[b] = tmp___1;
    }
#line 183
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 186
      error_message(4002);
      }
#line 187
      return;
    }
    {
#line 189
    strcpy((char */* __restrict  */)argv_rs[b], (char const   */* __restrict  */)*(argv1 + b));
#line 181
    b ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  argc_rs = argc1;
#line 192
  pfrs = fopen((char const   */* __restrict  */)(name), (char const   */* __restrict  */)"r");
#line 199
  yy_rs_in = pfrs;
  }
#line 201
  return;
}
}
#line 211 "/home/wslee/benchmarks/clif-0.93/init_rs.c"
static int flag  ;
#line 207 "/home/wslee/benchmarks/clif-0.93/init_rs.c"
int yy_rs_wrap(void) 
{ 


  {
#line 212
  if (! flag) {
    {
#line 214
    switch_to_char_buffer___0();
#line 215
    flag = 1;
    }
#line 216
    return (0);
  }
#line 219
  return (1);
}
}
#line 712 "lex.yy_rs_.c"
int yy_rs_lex(void) 
{ 
  register yy_rs__state_type yy_rs__current_state ;
  register char *yy_rs__cp ;
  register char *yy_rs__bp ;
  register int yy_rs__act ;
  register YY_rs__CHAR yy_rs__c ;
  int yy_rs__amount_of_matched_text ;
  yy_rs__state_type yy_rs__next_state ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 722
  if (yy_rs__init) {
#line 724
    yy_rs__init = 0;
#line 730
    if (! yy_rs__start) {
#line 731
      yy_rs__start = 1;
    }
#line 733
    if (! yy_rs_in) {
#line 734
      yy_rs_in = stdin;
    }
#line 736
    if (! yy_rs_out) {
#line 737
      yy_rs_out = stdout;
    }
#line 739
    if (! yy_rs__current_buffer) {
      {
#line 740
      yy_rs__current_buffer = yy_rs__create_buffer(yy_rs_in, 16384);
      }
    }
    {
#line 743
    yy_rs__load_buffer_state();
    }
  }
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    yy_rs__cp = yy_rs__c_buf_p;
#line 751
    *yy_rs__cp = yy_rs__hold_char;
#line 756
    yy_rs__bp = yy_rs__cp;
#line 758
    yy_rs__current_state = yy_rs__start;
    yy_rs__match: 
    {
#line 760
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 762
      yy_rs__c = (YY_rs__CHAR )yy_rs__ec[(unsigned int )((unsigned char )*yy_rs__cp)];
#line 763
      if (yy_rs__accept[yy_rs__current_state]) {
#line 765
        yy_rs__last_accepting_state = yy_rs__current_state;
#line 766
        yy_rs__last_accepting_cpos = yy_rs__cp;
      }
      {
#line 768
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 768
        if (! ((int const   )yy_rs__chk[(int const   )yy_rs__base[yy_rs__current_state] + (int const   )yy_rs__c] != (int const   )yy_rs__current_state)) {
#line 768
          goto while_break___1;
        }
#line 770
        yy_rs__current_state = (int )yy_rs__def[yy_rs__current_state];
#line 771
        if (yy_rs__current_state >= 230) {
#line 772
          yy_rs__c = (YY_rs__CHAR )yy_rs__meta[(unsigned int )yy_rs__c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 774
      yy_rs__current_state = (yy_rs__state_type )yy_rs__nxt[(unsigned int )yy_rs__base[yy_rs__current_state] + (unsigned int )yy_rs__c];
#line 775
      yy_rs__cp ++;
#line 760
      if (! ((int const   )yy_rs__base[yy_rs__current_state] != 314)) {
#line 760
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_rs__find_action: 
#line 780
    yy_rs__act = (int )yy_rs__accept[yy_rs__current_state];
#line 781
    if (yy_rs__act == 0) {
#line 783
      yy_rs__cp = yy_rs__last_accepting_cpos;
#line 784
      yy_rs__current_state = yy_rs__last_accepting_state;
#line 785
      yy_rs__act = (int )yy_rs__accept[yy_rs__current_state];
    }
#line 788
    yy_rs_text = yy_rs__bp;
#line 788
    yy_rs_leng = (int )(yy_rs__cp - yy_rs__bp);
#line 788
    yy_rs__hold_char = *yy_rs__cp;
#line 788
    *yy_rs__cp = (char )'\000';
#line 788
    yy_rs__c_buf_p = yy_rs__cp;
    do_action: 
    {
#line 796
    if (yy_rs__act == 0) {
#line 796
      goto case_0;
    }
#line 803
    if (yy_rs__act == 1) {
#line 803
      goto case_1;
    }
#line 72
    if (yy_rs__act == 2) {
#line 72 "run_str.l"
      goto case_2;
    }
#line 73
    if (yy_rs__act == 3) {
#line 73
      goto case_3;
    }
#line 77
    if (yy_rs__act == 4) {
#line 77
      goto case_4;
    }
#line 78
    if (yy_rs__act == 5) {
#line 78
      goto case_5;
    }
#line 82
    if (yy_rs__act == 6) {
#line 82
      goto case_6;
    }
#line 83
    if (yy_rs__act == 7) {
#line 83
      goto case_7;
    }
#line 84
    if (yy_rs__act == 8) {
#line 84
      goto case_8;
    }
#line 85
    if (yy_rs__act == 9) {
#line 85
      goto case_9;
    }
#line 86
    if (yy_rs__act == 10) {
#line 86
      goto case_10;
    }
#line 87
    if (yy_rs__act == 11) {
#line 87
      goto case_11;
    }
#line 88
    if (yy_rs__act == 12) {
#line 88
      goto case_12;
    }
#line 89
    if (yy_rs__act == 13) {
#line 89
      goto case_13;
    }
#line 90
    if (yy_rs__act == 14) {
#line 90
      goto case_14;
    }
#line 91
    if (yy_rs__act == 15) {
#line 91
      goto case_15;
    }
#line 95
    if (yy_rs__act == 16) {
#line 95
      goto case_16;
    }
#line 96
    if (yy_rs__act == 17) {
#line 96
      goto case_17;
    }
#line 97
    if (yy_rs__act == 18) {
#line 97
      goto case_18;
    }
#line 98
    if (yy_rs__act == 19) {
#line 98
      goto case_19;
    }
#line 99
    if (yy_rs__act == 20) {
#line 99
      goto case_20;
    }
#line 100
    if (yy_rs__act == 21) {
#line 100
      goto case_21;
    }
#line 101
    if (yy_rs__act == 22) {
#line 101
      goto case_22;
    }
#line 102
    if (yy_rs__act == 23) {
#line 102
      goto case_23;
    }
#line 103
    if (yy_rs__act == 24) {
#line 103
      goto case_24;
    }
#line 104
    if (yy_rs__act == 25) {
#line 104
      goto case_25;
    }
#line 105
    if (yy_rs__act == 26) {
#line 105
      goto case_26;
    }
#line 106
    if (yy_rs__act == 27) {
#line 106
      goto case_27;
    }
#line 107
    if (yy_rs__act == 28) {
#line 107
      goto case_28;
    }
#line 108
    if (yy_rs__act == 29) {
#line 108
      goto case_29;
    }
#line 109
    if (yy_rs__act == 30) {
#line 109
      goto case_30;
    }
#line 110
    if (yy_rs__act == 31) {
#line 110
      goto case_31;
    }
#line 111
    if (yy_rs__act == 32) {
#line 111
      goto case_32;
    }
#line 112
    if (yy_rs__act == 33) {
#line 112
      goto case_33;
    }
#line 113
    if (yy_rs__act == 34) {
#line 113
      goto case_34;
    }
#line 114
    if (yy_rs__act == 35) {
#line 114
      goto case_35;
    }
#line 115
    if (yy_rs__act == 36) {
#line 115
      goto case_36;
    }
#line 116
    if (yy_rs__act == 37) {
#line 116
      goto case_37;
    }
#line 117
    if (yy_rs__act == 38) {
#line 117
      goto case_38;
    }
#line 118
    if (yy_rs__act == 39) {
#line 118
      goto case_39;
    }
#line 119
    if (yy_rs__act == 40) {
#line 119
      goto case_40;
    }
#line 120
    if (yy_rs__act == 41) {
#line 120
      goto case_41;
    }
#line 121
    if (yy_rs__act == 42) {
#line 121
      goto case_42;
    }
#line 122
    if (yy_rs__act == 43) {
#line 122
      goto case_43;
    }
#line 123
    if (yy_rs__act == 44) {
#line 123
      goto case_44;
    }
#line 124
    if (yy_rs__act == 45) {
#line 124
      goto case_45;
    }
#line 129
    if (yy_rs__act == 46) {
#line 129
      goto case_46;
    }
#line 130
    if (yy_rs__act == 47) {
#line 130
      goto case_47;
    }
#line 1052
    if (yy_rs__act == 49) {
#line 1052 "lex.yy_rs_.c"
      goto case_49;
    }
#line 1055
    if (yy_rs__act == 48) {
#line 1055
      goto case_48;
    }
#line 1177
    goto switch_default;
    case_0: /* CIL Label */ 
#line 798
    *yy_rs__cp = yy_rs__hold_char;
#line 799
    yy_rs__cp = yy_rs__last_accepting_cpos;
#line 800
    yy_rs__current_state = yy_rs__last_accepting_state;
#line 801
    goto yy_rs__find_action;
    case_1: /* CIL Label */ ;
#line 71 "run_str.l"
    goto switch_break;
    case_2: /* CIL Label */ ;
#line 72
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 72
    sscanf((char const   */* __restrict  */)yy_rs_text, (char const   */* __restrict  */)"%d",
           & yy_rs_lval.myy_rs_int);
    }
#line 72
    return (258);
#line 76
    goto switch_break;
    case_4: /* CIL Label */ 
#line 76
    return (260);
#line 77
    goto switch_break;
    case_5: /* CIL Label */ 
#line 77
    return (260);
#line 81
    goto switch_break;
    case_6: /* CIL Label */ 
#line 81
    return (284);
#line 82
    goto switch_break;
    case_7: /* CIL Label */ 
#line 82
    return (280);
#line 83
    goto switch_break;
    case_8: /* CIL Label */ 
#line 83
    return (282);
#line 84
    goto switch_break;
    case_9: /* CIL Label */ 
#line 84
    return (281);
#line 85
    goto switch_break;
    case_10: /* CIL Label */ 
#line 85
    return (283);
#line 86
    goto switch_break;
    case_11: /* CIL Label */ 
#line 86
    return (279);
#line 87
    goto switch_break;
    case_12: /* CIL Label */ 
#line 87
    return (285);
#line 88
    goto switch_break;
    case_13: /* CIL Label */ 
#line 88
    return (261);
#line 89
    goto switch_break;
    case_14: /* CIL Label */ 
#line 89
    return (261);
#line 90
    goto switch_break;
    case_15: /* CIL Label */ 
#line 90
    return (261);
#line 94
    goto switch_break;
    case_16: /* CIL Label */ 
#line 94
    return (261);
#line 95
    goto switch_break;
    case_17: /* CIL Label */ 
#line 95
    return (261);
#line 96
    goto switch_break;
    case_18: /* CIL Label */ 
#line 96
    return (261);
#line 97
    goto switch_break;
    case_19: /* CIL Label */ 
#line 97
    return (261);
#line 98
    goto switch_break;
    case_20: /* CIL Label */ 
#line 98
    return (265);
#line 99
    goto switch_break;
    case_21: /* CIL Label */ 
#line 99
    return (265);
#line 100
    goto switch_break;
    case_22: /* CIL Label */ 
#line 100
    return (265);
#line 101
    goto switch_break;
    case_23: /* CIL Label */ 
#line 101
    return (268);
#line 102
    goto switch_break;
    case_24: /* CIL Label */ 
#line 102
    return (264);
#line 103
    goto switch_break;
    case_25: /* CIL Label */ 
#line 103
    return (264);
#line 104
    goto switch_break;
    case_26: /* CIL Label */ 
#line 104
    return (264);
#line 105
    goto switch_break;
    case_27: /* CIL Label */ 
#line 105
    return (262);
#line 106
    goto switch_break;
    case_28: /* CIL Label */ 
#line 106
    return (276);
#line 107
    goto switch_break;
    case_29: /* CIL Label */ 
#line 107
    return (277);
#line 108
    goto switch_break;
    case_30: /* CIL Label */ 
#line 108
    return (269);
#line 109
    goto switch_break;
    case_31: /* CIL Label */ 
#line 109
    return (278);
#line 110
    goto switch_break;
    case_32: /* CIL Label */ 
#line 110
    return (270);
#line 111
    goto switch_break;
    case_33: /* CIL Label */ 
#line 111
    return (271);
#line 112
    goto switch_break;
    case_34: /* CIL Label */ 
#line 112
    return (272);
#line 113
    goto switch_break;
    case_35: /* CIL Label */ 
#line 113
    return (273);
#line 114
    goto switch_break;
    case_36: /* CIL Label */ 
#line 114
    return (275);
#line 115
    goto switch_break;
    case_37: /* CIL Label */ 
#line 115
    return (274);
#line 116
    goto switch_break;
    case_38: /* CIL Label */ 
#line 116
    return (263);
#line 117
    goto switch_break;
    case_39: /* CIL Label */ 
#line 117
    return (267);
#line 118
    goto switch_break;
    case_40: /* CIL Label */ 
#line 118
    return (267);
#line 119
    goto switch_break;
    case_41: /* CIL Label */ 
#line 119
    return (267);
#line 120
    goto switch_break;
    case_42: /* CIL Label */ 
#line 120
    return (267);
#line 121
    goto switch_break;
    case_43: /* CIL Label */ 
#line 121
    return (266);
#line 122
    goto switch_break;
    case_44: /* CIL Label */ 
#line 122
    return (266);
#line 123
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 126
    yy_rs_lval.myy_rs_string = string(yy_rs_text);
    }
#line 127
    return (259);
#line 128
    goto switch_break;
    case_46: /* CIL Label */ 
#line 128
    return ((int )*yy_rs_text);
#line 129
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 129
    fwrite((void const   */* __restrict  */)yy_rs_text, (size_t )yy_rs_leng, (size_t )1,
           (FILE */* __restrict  */)yy_rs_out);
    }
#line 130
    goto switch_break;
    case_49: /* CIL Label */ 
#line 1053 "lex.yy_rs_.c"
    return (0);
    case_48: /* CIL Label */ 
#line 1058
    yy_rs__amount_of_matched_text = (int )(yy_rs__cp - yy_rs_text) - 1;
#line 1061
    *yy_rs__cp = yy_rs__hold_char;
#line 1064
    if (yy_rs__current_buffer->yy_rs__buffer_status == 0) {
#line 1075
      yy_rs__n_chars = yy_rs__current_buffer->yy_rs__n_chars;
#line 1076
      yy_rs__current_buffer->yy_rs__input_rs__file = yy_rs_in;
#line 1077
      yy_rs__current_buffer->yy_rs__buffer_status = 1;
    }
#line 1087
    if ((unsigned long )yy_rs__c_buf_p <= (unsigned long )(yy_rs__current_buffer->yy_rs__ch_buf + yy_rs__n_chars)) {
      {
#line 1091
      yy_rs__c_buf_p = yy_rs_text + yy_rs__amount_of_matched_text;
#line 1093
      yy_rs__current_state = yy_rs__get_previous_state();
#line 1104
      yy_rs__next_state = yy_rs__try_NUL_trans(yy_rs__current_state);
#line 1106
      yy_rs__bp = yy_rs_text + 0;
      }
#line 1108
      if (yy_rs__next_state) {
#line 1111
        yy_rs__c_buf_p ++;
#line 1111
        yy_rs__cp = yy_rs__c_buf_p;
#line 1112
        yy_rs__current_state = yy_rs__next_state;
#line 1113
        goto yy_rs__match;
      } else {
#line 1118
        yy_rs__cp = yy_rs__c_buf_p;
#line 1119
        goto yy_rs__find_action;
      }
    } else {
      {
#line 1123
      tmp___0 = yy_rs__get_next_buffer();
      }
      {
#line 1125
      if (tmp___0 == 1) {
#line 1125
        goto case_1___0;
      }
#line 1154
      if (tmp___0 == 0) {
#line 1154
        goto case_0___0;
      }
#line 1164
      if (tmp___0 == 2) {
#line 1164
        goto case_2___0;
      }
#line 1123
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1127
      yy_rs__did_buffer_switch_on_eof = 0;
#line 1129
      tmp___1 = yy_rs_wrap();
      }
#line 1129
      if (tmp___1) {
#line 1140
        yy_rs__c_buf_p = yy_rs_text + 0;
#line 1142
        yy_rs__act = (48 + (yy_rs__start - 1) / 2) + 1;
#line 1143
        goto do_action;
      } else
#line 1148
      if (! yy_rs__did_buffer_switch_on_eof) {
        {
#line 1149
        yy_rs_restart(yy_rs_in);
        }
      }
#line 1151
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1155
      yy_rs__c_buf_p = yy_rs_text + yy_rs__amount_of_matched_text;
#line 1158
      yy_rs__current_state = yy_rs__get_previous_state();
#line 1160
      yy_rs__cp = yy_rs__c_buf_p;
#line 1161
      yy_rs__bp = yy_rs_text + 0;
      }
#line 1162
      goto yy_rs__match;
      case_2___0: /* CIL Label */ 
      {
#line 1165
      yy_rs__c_buf_p = yy_rs__current_buffer->yy_rs__ch_buf + yy_rs__n_chars;
#line 1168
      yy_rs__current_state = yy_rs__get_previous_state();
#line 1170
      yy_rs__cp = yy_rs__c_buf_p;
#line 1171
      yy_rs__bp = yy_rs_text + 0;
      }
#line 1172
      goto yy_rs__find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1174
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1178
    yy_rs__fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1193 "lex.yy_rs_.c"
static int yy_rs__get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp___0 ;
  char *tmp___1 ;
  int num_to_read ;
  YY_rs__BUFFER_STATE b ;
  int yy_rs__c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 1195
  dest = yy_rs__current_buffer->yy_rs__ch_buf;
#line 1196
  source = yy_rs_text;
#line 1200
  if ((unsigned long )yy_rs__c_buf_p > (unsigned long )(yy_rs__current_buffer->yy_rs__ch_buf + (yy_rs__n_chars + 1))) {
    {
#line 1201
    yy_rs__fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1204
  if (yy_rs__current_buffer->yy_rs__fill_buffer == 0) {
#line 1206
    if (yy_rs__c_buf_p - yy_rs_text == 1L) {
#line 1211
      return (1);
    } else {
#line 1219
      return (2);
    }
  }
#line 1226
  number_to_move = (int )(yy_rs__c_buf_p - yy_rs_text) - 1;
#line 1228
  i = 0;
  {
#line 1228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1228
    if (! (i < number_to_move)) {
#line 1228
      goto while_break;
    }
#line 1229
    tmp___0 = dest;
#line 1229
    dest ++;
#line 1229
    tmp___1 = source;
#line 1229
    source ++;
#line 1229
    *tmp___0 = *tmp___1;
#line 1228
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1231
  if (yy_rs__current_buffer->yy_rs__buffer_status == 2) {
#line 1235
    yy_rs__n_chars = 0;
#line 1235
    yy_rs__current_buffer->yy_rs__n_chars = yy_rs__n_chars;
  } else {
#line 1239
    num_to_read = (int )((yy_rs__current_buffer->yy_rs__buf_size - (yy_rs__size_t )number_to_move) - 1U);
    {
#line 1242
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1242
      if (! (num_to_read <= 0)) {
#line 1242
        goto while_break___0;
      }
#line 1250
      b = yy_rs__current_buffer;
#line 1252
      yy_rs__c_buf_p_offset = (int )(yy_rs__c_buf_p - b->yy_rs__ch_buf);
#line 1255
      if (b->yy_rs__is_our_buffer) {
#line 1257
        new_size = (int )(b->yy_rs__buf_size * 2U);
#line 1259
        if (new_size <= 0) {
#line 1260
          b->yy_rs__buf_size += b->yy_rs__buf_size / 8U;
        } else {
#line 1262
          b->yy_rs__buf_size *= 2U;
        }
        {
#line 1264
        tmp___2 = yy_rs__flex_realloc((void *)b->yy_rs__ch_buf, b->yy_rs__buf_size + 2U);
#line 1264
        b->yy_rs__ch_buf = (char *)tmp___2;
        }
      } else {
#line 1271
        b->yy_rs__ch_buf = (char *)0;
      }
#line 1273
      if (! b->yy_rs__ch_buf) {
        {
#line 1274
        yy_rs__fatal_error("fatal error - scanner input_rs_ buffer overflow");
        }
      }
#line 1277
      yy_rs__c_buf_p = b->yy_rs__ch_buf + yy_rs__c_buf_p_offset;
#line 1279
      num_to_read = (int )((yy_rs__current_buffer->yy_rs__buf_size - (yy_rs__size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1284
    if (num_to_read > 8192) {
#line 1285
      num_to_read = 8192;
    }
#line 1288
    if (yy_rs__current_buffer->yy_rs__is_interactive) {
#line 1288
      c = '*';
#line 1288
      n = 0;
      {
#line 1288
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1288
        if (n < num_to_read) {
          {
#line 1288
          c = _IO_getc(yy_rs_in);
          }
#line 1288
          if (c != -1) {
#line 1288
            if (! (c != 10)) {
#line 1288
              goto while_break___1;
            }
          } else {
#line 1288
            goto while_break___1;
          }
        } else {
#line 1288
          goto while_break___1;
        }
#line 1288
        *((yy_rs__current_buffer->yy_rs__ch_buf + number_to_move) + n) = (char )c;
#line 1288
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1288
      if (c == 10) {
#line 1288
        tmp___3 = n;
#line 1288
        n ++;
#line 1288
        *((yy_rs__current_buffer->yy_rs__ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1288
      if (c == -1) {
        {
#line 1288
        tmp___4 = ferror(yy_rs_in);
        }
#line 1288
        if (tmp___4) {
          {
#line 1288
          yy_rs__fatal_error("input_rs_ in flex scanner failed");
          }
        }
      }
#line 1288
      yy_rs__n_chars = n;
    } else {
      {
#line 1288
      tmp___5 = fread((void */* __restrict  */)(yy_rs__current_buffer->yy_rs__ch_buf + number_to_move),
                      (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yy_rs_in);
#line 1288
      yy_rs__n_chars = (int )tmp___5;
      }
#line 1288
      if (yy_rs__n_chars == 0) {
        {
#line 1288
        tmp___6 = ferror(yy_rs_in);
        }
#line 1288
        if (tmp___6) {
          {
#line 1288
          yy_rs__fatal_error("input_rs_ in flex scanner failed");
          }
        }
      }
    }
#line 1291
    yy_rs__current_buffer->yy_rs__n_chars = yy_rs__n_chars;
  }
#line 1294
  if (yy_rs__n_chars == 0) {
#line 1296
    if (number_to_move == 0) {
      {
#line 1298
      ret_val = 1;
#line 1299
      yy_rs_restart(yy_rs_in);
      }
    } else {
#line 1304
      ret_val = 2;
#line 1305
      yy_rs__current_buffer->yy_rs__buffer_status = 2;
    }
  } else {
#line 1311
    ret_val = 0;
  }
#line 1313
  yy_rs__n_chars += number_to_move;
#line 1314
  *(yy_rs__current_buffer->yy_rs__ch_buf + yy_rs__n_chars) = (char)0;
#line 1315
  *(yy_rs__current_buffer->yy_rs__ch_buf + (yy_rs__n_chars + 1)) = (char)0;
#line 1317
  yy_rs_text = yy_rs__current_buffer->yy_rs__ch_buf + 0;
#line 1319
  return (ret_val);
}
}
#line 1325 "lex.yy_rs_.c"
static yy_rs__state_type yy_rs__get_previous_state(void) 
{ 
  register yy_rs__state_type yy_rs__current_state ;
  register char *yy_rs__cp ;
  register YY_rs__CHAR yy_rs__c ;
  int tmp___0 ;

  {
#line 1330
  yy_rs__current_state = yy_rs__start;
#line 1332
  yy_rs__cp = yy_rs_text + 0;
  {
#line 1332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1332
    if (! ((unsigned long )yy_rs__cp < (unsigned long )yy_rs__c_buf_p)) {
#line 1332
      goto while_break;
    }
#line 1334
    if (*yy_rs__cp) {
#line 1334
      tmp___0 = yy_rs__ec[(unsigned int )((unsigned char )*yy_rs__cp)];
    } else {
#line 1334
      tmp___0 = (int const   )1;
    }
#line 1334
    yy_rs__c = (YY_rs__CHAR )tmp___0;
#line 1335
    if (yy_rs__accept[yy_rs__current_state]) {
#line 1337
      yy_rs__last_accepting_state = yy_rs__current_state;
#line 1338
      yy_rs__last_accepting_cpos = yy_rs__cp;
    }
    {
#line 1340
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1340
      if (! ((int const   )yy_rs__chk[(int const   )yy_rs__base[yy_rs__current_state] + (int const   )yy_rs__c] != (int const   )yy_rs__current_state)) {
#line 1340
        goto while_break___0;
      }
#line 1342
      yy_rs__current_state = (int )yy_rs__def[yy_rs__current_state];
#line 1343
      if (yy_rs__current_state >= 230) {
#line 1344
        yy_rs__c = (YY_rs__CHAR )yy_rs__meta[(unsigned int )yy_rs__c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1346
    yy_rs__current_state = (yy_rs__state_type )yy_rs__nxt[(unsigned int )yy_rs__base[yy_rs__current_state] + (unsigned int )yy_rs__c];
#line 1332
    yy_rs__cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1349
  return (yy_rs__current_state);
}
}
#line 1360 "lex.yy_rs_.c"
static yy_rs__state_type yy_rs__try_NUL_trans(yy_rs__state_type yy_rs__current_state ) 
{ 
  register int yy_rs__is_jam ;
  register char *yy_rs__cp ;
  register YY_rs__CHAR yy_rs__c ;
  int tmp___0 ;

  {
#line 1367
  yy_rs__cp = yy_rs__c_buf_p;
#line 1369
  yy_rs__c = (YY_rs__CHAR )1;
#line 1370
  if (yy_rs__accept[yy_rs__current_state]) {
#line 1372
    yy_rs__last_accepting_state = yy_rs__current_state;
#line 1373
    yy_rs__last_accepting_cpos = yy_rs__cp;
  }
  {
#line 1375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1375
    if (! ((int const   )yy_rs__chk[(int const   )yy_rs__base[yy_rs__current_state] + (int const   )yy_rs__c] != (int const   )yy_rs__current_state)) {
#line 1375
      goto while_break;
    }
#line 1377
    yy_rs__current_state = (int )yy_rs__def[yy_rs__current_state];
#line 1378
    if (yy_rs__current_state >= 230) {
#line 1379
      yy_rs__c = (YY_rs__CHAR )yy_rs__meta[(unsigned int )yy_rs__c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1381
  yy_rs__current_state = (yy_rs__state_type )yy_rs__nxt[(unsigned int )yy_rs__base[yy_rs__current_state] + (unsigned int )yy_rs__c];
#line 1382
  yy_rs__is_jam = yy_rs__current_state == 229;
#line 1384
  if (yy_rs__is_jam) {
#line 1384
    tmp___0 = 0;
  } else {
#line 1384
    tmp___0 = yy_rs__current_state;
  }
#line 1384
  return (tmp___0);
}
}
#line 1507 "lex.yy_rs_.c"
void yy_rs_restart(FILE *input_rs__file ) 
{ 


  {
#line 1513
  if (! yy_rs__current_buffer) {
    {
#line 1514
    yy_rs__current_buffer = yy_rs__create_buffer(yy_rs_in, 16384);
    }
  }
  {
#line 1516
  yy_rs__init_buffer(yy_rs__current_buffer, input_rs__file);
#line 1517
  yy_rs__load_buffer_state();
  }
#line 1518
  return;
}
}
#line 1522 "lex.yy_rs_.c"
void yy_rs__switch_to_buffer(YY_rs__BUFFER_STATE new_buffer ) 
{ 


  {
#line 1528
  if ((unsigned long )yy_rs__current_buffer == (unsigned long )new_buffer) {
#line 1529
    return;
  }
#line 1531
  if (yy_rs__current_buffer) {
#line 1534
    *yy_rs__c_buf_p = yy_rs__hold_char;
#line 1535
    yy_rs__current_buffer->yy_rs__buf_pos = yy_rs__c_buf_p;
#line 1536
    yy_rs__current_buffer->yy_rs__n_chars = yy_rs__n_chars;
  }
  {
#line 1539
  yy_rs__current_buffer = new_buffer;
#line 1540
  yy_rs__load_buffer_state();
#line 1547
  yy_rs__did_buffer_switch_on_eof = 1;
  }
#line 1548
  return;
}
}
#line 1552 "lex.yy_rs_.c"
void yy_rs__load_buffer_state(void) 
{ 


  {
#line 1557
  yy_rs__n_chars = yy_rs__current_buffer->yy_rs__n_chars;
#line 1558
  yy_rs__c_buf_p = yy_rs__current_buffer->yy_rs__buf_pos;
#line 1558
  yy_rs_text = yy_rs__c_buf_p;
#line 1559
  yy_rs_in = yy_rs__current_buffer->yy_rs__input_rs__file;
#line 1560
  yy_rs__hold_char = *yy_rs__c_buf_p;
#line 1561
  return;
}
}
#line 1565 "lex.yy_rs_.c"
YY_rs__BUFFER_STATE yy_rs__create_buffer(FILE *file , int size ) 
{ 
  YY_rs__BUFFER_STATE b ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1574
  tmp___0 = yy_rs__flex_alloc((yy_rs__size_t )sizeof(struct yy_rs__buffer_state ));
#line 1574
  b = (YY_rs__BUFFER_STATE )tmp___0;
  }
#line 1575
  if (! b) {
    {
#line 1576
    yy_rs__fatal_error("out of dynamic memory in yy_rs__create_buffer()");
    }
  }
  {
#line 1578
  b->yy_rs__buf_size = (yy_rs__size_t )size;
#line 1583
  tmp___1 = yy_rs__flex_alloc(b->yy_rs__buf_size + 2U);
#line 1583
  b->yy_rs__ch_buf = (char *)tmp___1;
  }
#line 1584
  if (! b->yy_rs__ch_buf) {
    {
#line 1585
    yy_rs__fatal_error("out of dynamic memory in yy_rs__create_buffer()");
    }
  }
  {
#line 1587
  b->yy_rs__is_our_buffer = 1;
#line 1589
  yy_rs__init_buffer(b, file);
  }
#line 1591
  return (b);
}
}
#line 1596 "lex.yy_rs_.c"
void yy_rs__delete_buffer(YY_rs__BUFFER_STATE b ) 
{ 


  {
#line 1602
  if (! b) {
#line 1603
    return;
  }
#line 1605
  if ((unsigned long )b == (unsigned long )yy_rs__current_buffer) {
#line 1606
    yy_rs__current_buffer = (YY_rs__BUFFER_STATE )0;
  }
#line 1608
  if (b->yy_rs__is_our_buffer) {
    {
#line 1609
    yy_rs__flex_free((void *)b->yy_rs__ch_buf);
    }
  }
  {
#line 1611
  yy_rs__flex_free((void *)b);
  }
#line 1612
  return;
}
}
#line 1617
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 1622 "lex.yy_rs_.c"
void yy_rs__init_buffer(YY_rs__BUFFER_STATE b , FILE *file ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1631
  yy_rs__flush_buffer(b);
#line 1633
  b->yy_rs__input_rs__file = file;
#line 1634
  b->yy_rs__fill_buffer = 1;
  }
#line 1642
  if (file) {
    {
#line 1642
    tmp___0 = fileno(file);
#line 1642
    tmp___1 = isatty(tmp___0);
#line 1642
    b->yy_rs__is_interactive = tmp___1 > 0;
    }
  } else {
#line 1642
    b->yy_rs__is_interactive = 0;
  }
#line 1645
  return;
}
}
#line 1649 "lex.yy_rs_.c"
void yy_rs__flush_buffer(YY_rs__BUFFER_STATE b ) 
{ 


  {
#line 1656
  if (! b) {
#line 1657
    return;
  }
#line 1659
  b->yy_rs__n_chars = 0;
#line 1665
  *(b->yy_rs__ch_buf + 0) = (char)0;
#line 1666
  *(b->yy_rs__ch_buf + 1) = (char)0;
#line 1668
  b->yy_rs__buf_pos = b->yy_rs__ch_buf + 0;
#line 1670
  b->yy_rs__at_bol = 1;
#line 1671
  b->yy_rs__buffer_status = 0;
#line 1673
  if ((unsigned long )b == (unsigned long )yy_rs__current_buffer) {
    {
#line 1674
    yy_rs__load_buffer_state();
    }
  }
#line 1675
  return;
}
}
#line 1680 "lex.yy_rs_.c"
YY_rs__BUFFER_STATE yy_rs__scan_buffer(char *base , yy_rs__size_t size ) 
{ 
  YY_rs__BUFFER_STATE b ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 1689
  if (size < 2U) {
#line 1693
    return ((YY_rs__BUFFER_STATE )0);
  } else
#line 1689
  if ((int )*(base + (size - 2U)) != 0) {
#line 1693
    return ((YY_rs__BUFFER_STATE )0);
  } else
#line 1689
  if ((int )*(base + (size - 1U)) != 0) {
#line 1693
    return ((YY_rs__BUFFER_STATE )0);
  }
  {
#line 1695
  tmp___0 = yy_rs__flex_alloc((yy_rs__size_t )sizeof(struct yy_rs__buffer_state ));
#line 1695
  b = (YY_rs__BUFFER_STATE )tmp___0;
  }
#line 1696
  if (! b) {
    {
#line 1697
    yy_rs__fatal_error("out of dynamic memory in yy_rs__scan_buffer()");
    }
  }
  {
#line 1699
  b->yy_rs__buf_size = size - 2U;
#line 1700
  tmp___1 = base;
#line 1700
  b->yy_rs__ch_buf = tmp___1;
#line 1700
  b->yy_rs__buf_pos = tmp___1;
#line 1701
  b->yy_rs__is_our_buffer = 0;
#line 1702
  b->yy_rs__input_rs__file = (FILE *)0;
#line 1703
  b->yy_rs__n_chars = (int )b->yy_rs__buf_size;
#line 1704
  b->yy_rs__is_interactive = 0;
#line 1705
  b->yy_rs__at_bol = 1;
#line 1706
  b->yy_rs__fill_buffer = 0;
#line 1707
  b->yy_rs__buffer_status = 0;
#line 1709
  yy_rs__switch_to_buffer(b);
  }
#line 1711
  return (b);
}
}
#line 1718 "lex.yy_rs_.c"
YY_rs__BUFFER_STATE yy_rs__scan_string(char const   *yy_rs__str ) 
{ 
  int len ;
  YY_rs__BUFFER_STATE tmp___0 ;

  {
#line 1725
  len = 0;
  {
#line 1725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1725
    if (! *(yy_rs__str + len)) {
#line 1725
      goto while_break;
    }
#line 1725
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1728
  tmp___0 = yy_rs__scan_bytes(yy_rs__str, len);
  }
#line 1728
  return (tmp___0);
}
}
#line 1735 "lex.yy_rs_.c"
YY_rs__BUFFER_STATE yy_rs__scan_bytes(char const   *bytes , int len ) 
{ 
  YY_rs__BUFFER_STATE b ;
  char *buf ;
  yy_rs__size_t n ;
  int i ;
  void *tmp___0 ;
  char tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1748
  n = (yy_rs__size_t )(len + 2);
#line 1749
  tmp___0 = yy_rs__flex_alloc(n);
#line 1749
  buf = (char *)tmp___0;
  }
#line 1750
  if (! buf) {
    {
#line 1751
    yy_rs__fatal_error("out of dynamic memory in yy_rs__scan_bytes()");
    }
  }
#line 1753
  i = 0;
  {
#line 1753
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1753
    if (! (i < len)) {
#line 1753
      goto while_break;
    }
#line 1754
    *(buf + i) = (char )*(bytes + i);
#line 1753
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1756
  tmp___1 = (char)0;
#line 1756
  *(buf + (len + 1)) = tmp___1;
#line 1756
  *(buf + len) = tmp___1;
#line 1758
  b = yy_rs__scan_buffer(buf, n);
  }
#line 1759
  if (! b) {
    {
#line 1760
    yy_rs__fatal_error("bad buffer in yy_rs__scan_bytes()");
    }
  }
#line 1765
  b->yy_rs__is_our_buffer = 1;
#line 1767
  return (b);
}
}
#line 1829 "lex.yy_rs_.c"
static void yy_rs__fatal_error(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1835
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1836
  exit(2);
  }
}
}
#line 1893 "lex.yy_rs_.c"
static void *yy_rs__flex_alloc(yy_rs__size_t size ) 
{ 
  void *tmp___0 ;

  {
  {
#line 1899
  tmp___0 = malloc(size);
  }
#line 1899
  return (tmp___0);
}
}
#line 1903 "lex.yy_rs_.c"
static void *yy_rs__flex_realloc(void *ptr , yy_rs__size_t size ) 
{ 
  void *tmp___0 ;

  {
  {
#line 1917
  tmp___0 = realloc((void *)((char *)ptr), size);
  }
#line 1917
  return (tmp___0);
}
}
#line 1921 "lex.yy_rs_.c"
static void yy_rs__flex_free(void *ptr ) 
{ 


  {
  {
#line 1927
  free(ptr);
  }
#line 1928
  return;
}
}
#line 54 "run_str.y"
int argc_counter  =    0;
#line 56 "run_str.y"
char *argvv[100]  ;
#line 68
int yy_rs_error(char *s___0 ) ;
#line 70 "run_str.y"
int yy_rs_error(char *s___0 ) 
{ 


  {
#line 74
  return (0);
}
}
#line 93 "run_str.y"
static char const   yy_rs_translate[286]  = 
#line 93
  {      (char const   )0,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )13,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )1,      (char const   )2,      (char const   )3,      (char const   )4, 
        (char const   )5,      (char const   )6,      (char const   )7,      (char const   )8, 
        (char const   )9,      (char const   )10,      (char const   )11,      (char const   )12, 
        (char const   )14,      (char const   )15,      (char const   )16,      (char const   )17, 
        (char const   )18,      (char const   )19,      (char const   )20,      (char const   )21, 
        (char const   )22,      (char const   )23,      (char const   )24,      (char const   )25, 
        (char const   )26,      (char const   )27,      (char const   )28,      (char const   )29, 
        (char const   )30,      (char const   )31};
#line 165 "run_str.y"
static short const   yy_rs_r1[31]  = 
#line 165
  {      (short const   )0,      (short const   )32,      (short const   )32,      (short const   )33, 
        (short const   )33,      (short const   )33,      (short const   )33,      (short const   )33, 
        (short const   )33,      (short const   )33,      (short const   )33,      (short const   )33, 
        (short const   )33,      (short const   )33,      (short const   )33,      (short const   )33, 
        (short const   )33,      (short const   )33,      (short const   )33,      (short const   )33, 
        (short const   )33,      (short const   )33,      (short const   )33,      (short const   )33, 
        (short const   )33,      (short const   )33,      (short const   )33,      (short const   )33, 
        (short const   )33,      (short const   )33,      (short const   )33};
#line 171 "run_str.y"
static short const   yy_rs_r2[31]  = 
#line 171
  {      (short const   )0,      (short const   )2,      (short const   )0,      (short const   )3, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1};
#line 177 "run_str.y"
static short const   yy_rs_defact[35]  = 
#line 177
  {      (short const   )2,      (short const   )0,      (short const   )30,      (short const   )14, 
        (short const   )0,      (short const   )13,      (short const   )8,      (short const   )17, 
        (short const   )29,      (short const   )9,      (short const   )15,      (short const   )16, 
        (short const   )24,      (short const   )19,      (short const   )22,      (short const   )23, 
        (short const   )25,      (short const   )26,      (short const   )28,      (short const   )27, 
        (short const   )21,      (short const   )18,      (short const   )20,      (short const   )12, 
        (short const   )4,      (short const   )6,      (short const   )5,      (short const   )7, 
        (short const   )10,      (short const   )11,      (short const   )1,      (short const   )0, 
        (short const   )3,      (short const   )0,      (short const   )0};
#line 184 "run_str.y"
static short const   yy_rs_defgoto[2]  = {      (short const   )1,      (short const   )30};
#line 188 "run_str.y"
static short const   yy_rs_pact[35]  = 
#line 188
  {      (short const   )-32768,      (short const   )0,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-11,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )10, 
        (short const   )-32768,      (short const   )3,      (short const   )-32768};
#line 195 "run_str.y"
static short const   yy_rs_pgoto[2]  = {      (short const   )-32768,      (short const   )-32768};
#line 203 "run_str.y"
static short const   yy_rs_table[32]  = 
#line 203
  {      (short const   )33,      (short const   )2,      (short const   )31,      (short const   )34, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )32,      (short const   )12,      (short const   )13, 
        (short const   )14,      (short const   )15,      (short const   )16,      (short const   )17, 
        (short const   )18,      (short const   )19,      (short const   )20,      (short const   )21, 
        (short const   )22,      (short const   )23,      (short const   )24,      (short const   )25, 
        (short const   )26,      (short const   )27,      (short const   )28,      (short const   )29};
#line 210 "run_str.y"
static short const   yy_rs_check[32]  = 
#line 210
  {      (short const   )0,      (short const   )1,      (short const   )13,      (short const   )0, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )3,      (short const   )14,      (short const   )15, 
        (short const   )16,      (short const   )17,      (short const   )18,      (short const   )19, 
        (short const   )20,      (short const   )21,      (short const   )22,      (short const   )23, 
        (short const   )24,      (short const   )25,      (short const   )26,      (short const   )27, 
        (short const   )28,      (short const   )29,      (short const   )30,      (short const   )31};
#line 116 "/usr/share/misc/bison.simple"
int yy_rs_char  ;
#line 117 "/usr/share/misc/bison.simple"
YY_rs_STYPE yy_rs_lval  ;
#line 125 "/usr/share/misc/bison.simple"
int yy_rs_nerrs  ;
#line 106 "run_str.y"
void dump_yacc(void) ;
#line 216 "/usr/share/misc/bison.simple"
int yy_rs_parse(void) 
{ 
  register int yy_rs_state ;
  register int yy_rs_n ;
  register short *yy_rs_ssp ;
  register YY_rs_STYPE *yy_rs_vsp ;
  int yy_rs_errstatus ;
  int yy_rs_char1 ;
  short yy_rs_ssa[200] ;
  YY_rs_STYPE yy_rs_vsa[200] ;
  short *yy_rs_ss ;
  YY_rs_STYPE *yy_rs_vs ;
  int yy_rs_stacksize ;
  YY_rs_STYPE yy_rs_val ;
  int yy_rs_len ;
  YY_rs_STYPE *yy_rs_vs1 ;
  short *yy_rs_ss1 ;
  int size ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 225
  yy_rs_char1 = 0;
#line 230
  yy_rs_ss = yy_rs_ssa;
#line 231
  yy_rs_vs = yy_rs_vsa;
#line 243
  yy_rs_stacksize = 200;
#line 265
  yy_rs_state = 0;
#line 266
  yy_rs_errstatus = 0;
#line 267
  yy_rs_nerrs = 0;
#line 268
  yy_rs_char = -2;
#line 275
  yy_rs_ssp = yy_rs_ss - 1;
#line 276
  yy_rs_vsp = yy_rs_vs;
  yy_rs_newstate: 
#line 286
  yy_rs_ssp ++;
#line 286
  *yy_rs_ssp = (short )yy_rs_state;
#line 288
  if ((unsigned long )yy_rs_ssp >= (unsigned long )((yy_rs_ss + yy_rs_stacksize) - 1)) {
#line 292
    yy_rs_vs1 = yy_rs_vs;
#line 293
    yy_rs_ss1 = yy_rs_ss;
#line 299
    size = (int )((yy_rs_ssp - yy_rs_ss) + 1L);
#line 325
    if (yy_rs_stacksize >= 10000) {
      {
#line 327
      yy_rs_error((char *)"parser stack overflow");
      }
#line 328
      return (2);
    }
#line 330
    yy_rs_stacksize *= 2;
#line 331
    if (yy_rs_stacksize > 10000) {
#line 332
      yy_rs_stacksize = 10000;
    }
    {
#line 333
    tmp___0 = __builtin_alloca((unsigned long )yy_rs_stacksize * sizeof(*yy_rs_ssp));
#line 333
    yy_rs_ss = (short *)tmp___0;
#line 334
    __builtin_memcpy((void *)((char *)yy_rs_ss), (void const   *)((char *)yy_rs_ss1),
                     (unsigned long )size * sizeof(*yy_rs_ssp));
#line 335
    tmp___1 = __builtin_alloca((unsigned long )yy_rs_stacksize * sizeof(*yy_rs_vsp));
#line 335
    yy_rs_vs = (YY_rs_STYPE *)tmp___1;
#line 336
    __builtin_memcpy((void *)((char *)yy_rs_vs), (void const   *)((char *)yy_rs_vs1),
                     (unsigned long )size * sizeof(*yy_rs_vsp));
#line 343
    yy_rs_ssp = (yy_rs_ss + size) - 1;
#line 344
    yy_rs_vsp = (yy_rs_vs + size) - 1;
    }
#line 354
    if ((unsigned long )yy_rs_ssp >= (unsigned long )((yy_rs_ss + yy_rs_stacksize) - 1)) {
#line 355
      return (1);
    }
  }
#line 363
  goto yy_rs_backup;
  yy_rs_backup: 
#line 372
  yy_rs_n = (int )yy_rs_pact[yy_rs_state];
#line 373
  if (yy_rs_n == -32768) {
#line 374
    goto yy_rs_default;
  }
#line 381
  if (yy_rs_char == -2) {
    {
#line 387
    yy_rs_char = yy_rs_lex();
    }
  }
#line 392
  if (yy_rs_char <= 0) {
#line 394
    yy_rs_char1 = 0;
#line 395
    yy_rs_char = 0;
  } else
#line 404
  if ((unsigned int )yy_rs_char <= 285U) {
#line 404
    yy_rs_char1 = (int )yy_rs_translate[yy_rs_char];
  } else {
#line 404
    yy_rs_char1 = 34;
  }
#line 420
  yy_rs_n += yy_rs_char1;
#line 421
  if (yy_rs_n < 0) {
#line 422
    goto yy_rs_default;
  } else
#line 421
  if (yy_rs_n > 31) {
#line 422
    goto yy_rs_default;
  } else
#line 421
  if ((int const   )yy_rs_check[yy_rs_n] != (int const   )yy_rs_char1) {
#line 422
    goto yy_rs_default;
  }
#line 424
  yy_rs_n = (int )yy_rs_table[yy_rs_n];
#line 433
  if (yy_rs_n < 0) {
#line 435
    if (yy_rs_n == -32768) {
#line 436
      goto yy_rs_errlab;
    }
#line 437
    yy_rs_n = - yy_rs_n;
#line 438
    goto yy_rs_reduce;
  } else
#line 440
  if (yy_rs_n == 0) {
#line 441
    goto yy_rs_errlab;
  }
#line 443
  if (yy_rs_n == 34) {
#line 444
    return (0);
  }
#line 454
  if (yy_rs_char != 0) {
#line 455
    yy_rs_char = -2;
  }
#line 457
  yy_rs_vsp ++;
#line 457
  *yy_rs_vsp = yy_rs_lval;
#line 463
  if (yy_rs_errstatus) {
#line 463
    yy_rs_errstatus --;
  }
#line 465
  yy_rs_state = yy_rs_n;
#line 466
  goto yy_rs_newstate;
  yy_rs_default: 
#line 471
  yy_rs_n = (int )yy_rs_defact[yy_rs_state];
#line 472
  if (yy_rs_n == 0) {
#line 473
    goto yy_rs_errlab;
  }
  yy_rs_reduce: 
#line 477
  yy_rs_len = (int )yy_rs_r2[yy_rs_n];
#line 478
  if (yy_rs_len > 0) {
#line 479
    yy_rs_val = *(yy_rs_vsp + (1 - yy_rs_len));
  }
  {
#line 499
  if (yy_rs_n == 3) {
#line 499
    goto case_3;
  }
#line 88
  if (yy_rs_n == 4) {
#line 88 "run_str.y"
    goto case_4;
  }
#line 91
  if (yy_rs_n == 5) {
#line 91
    goto case_5;
  }
#line 93
  if (yy_rs_n == 6) {
#line 93
    goto case_6;
  }
#line 95
  if (yy_rs_n == 7) {
#line 95
    goto case_7;
  }
#line 97
  if (yy_rs_n == 8) {
#line 97
    goto case_8;
  }
#line 99
  if (yy_rs_n == 9) {
#line 99
    goto case_9;
  }
#line 105
  if (yy_rs_n == 10) {
#line 105
    goto case_10;
  }
#line 110
  if (yy_rs_n == 11) {
#line 110
    goto case_11;
  }
#line 113
  if (yy_rs_n == 12) {
#line 113
    goto case_12;
  }
#line 116
  if (yy_rs_n == 13) {
#line 116
    goto case_13;
  }
#line 122
  if (yy_rs_n == 14) {
#line 122
    goto case_14;
  }
#line 125
  if (yy_rs_n == 15) {
#line 125
    goto case_15;
  }
#line 131
  if (yy_rs_n == 16) {
#line 131
    goto case_16;
  }
#line 137
  if (yy_rs_n == 17) {
#line 137
    goto case_17;
  }
#line 140
  if (yy_rs_n == 18) {
#line 140
    goto case_18;
  }
#line 143
  if (yy_rs_n == 19) {
#line 143
    goto case_19;
  }
#line 146
  if (yy_rs_n == 20) {
#line 146
    goto case_20;
  }
#line 149
  if (yy_rs_n == 21) {
#line 149
    goto case_21;
  }
#line 152
  if (yy_rs_n == 22) {
#line 152
    goto case_22;
  }
#line 155
  if (yy_rs_n == 23) {
#line 155
    goto case_23;
  }
#line 158
  if (yy_rs_n == 24) {
#line 158
    goto case_24;
  }
#line 161
  if (yy_rs_n == 25) {
#line 161
    goto case_25;
  }
#line 164
  if (yy_rs_n == 26) {
#line 164
    goto case_26;
  }
#line 167
  if (yy_rs_n == 27) {
#line 167
    goto case_27;
  }
#line 170
  if (yy_rs_n == 28) {
#line 170
    goto case_28;
  }
#line 173
  if (yy_rs_n == 29) {
#line 173
    goto case_29;
  }
#line 179
  if (yy_rs_n == 30) {
#line 179
    goto case_30;
  }
#line 497 "/usr/share/misc/bison.simple"
  goto switch_break;
  case_3: /* CIL Label */ 
#line 86 "run_str.y"
  bc = (yy_rs_vsp + 0)->myy_rs_int;
#line 87
  goto switch_break;
  case_4: /* CIL Label */ 
#line 89
  call_by_reference = 1;
#line 90
  goto switch_break;
  case_5: /* CIL Label */ 
#line 91
  call_by_reference = 0;
#line 92
  goto switch_break;
  case_6: /* CIL Label */ 
#line 93
  call_by_value = 1;
#line 94
  goto switch_break;
  case_7: /* CIL Label */ 
#line 95
  call_by_value = 0;
#line 96
  goto switch_break;
  case_8: /* CIL Label */ 
#line 97
  no_compile_only = 0;
#line 98
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 101
  tmp___2 = help(2);
  }
#line 101
  if (tmp___2 == -1) {
#line 102
    return (-1);
  }
#line 104
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 107
  dump_yacc();
  }
#line 109
  goto switch_break;
  case_11: /* CIL Label */ 
#line 111
  dbg_symbols = 1;
#line 112
  goto switch_break;
  case_12: /* CIL Label */ 
#line 114
  handle_main = 1;
#line 115
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 118
  tmp___3 = help(1);
  }
#line 118
  if (tmp___3 == -1) {
#line 119
    return (-1);
  }
#line 121
  goto switch_break;
  case_14: /* CIL Label */ 
#line 123
  argc_counter ++;
#line 123
  argvv[argc_counter] = (yy_rs_vsp + 0)->myy_rs_string;
#line 124
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 127
  tmp___4 = help(4);
  }
#line 127
  if (tmp___4 == -1) {
#line 128
    return (-1);
  }
#line 130
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 133
  tmp___5 = help(5);
  }
#line 133
  if (tmp___5 == -1) {
#line 134
    return (-1);
  }
#line 136
  goto switch_break;
  case_17: /* CIL Label */ 
#line 138
  warning_yes = 1;
#line 139
  goto switch_break;
  case_18: /* CIL Label */ 
#line 141
  warning_aggregate_return = 1;
#line 142
  goto switch_break;
  case_19: /* CIL Label */ 
#line 144
  warning_comment = 1;
#line 145
  goto switch_break;
  case_20: /* CIL Label */ 
#line 147
  warnings_are_errors = 1;
#line 148
  goto switch_break;
  case_21: /* CIL Label */ 
#line 150
  warning_extra = 1;
#line 151
  goto switch_break;
  case_22: /* CIL Label */ 
#line 153
  warning_format = 1;
#line 154
  goto switch_break;
  case_23: /* CIL Label */ 
#line 156
  warning_implicit = 1;
#line 157
  goto switch_break;
  case_24: /* CIL Label */ 
#line 159
  warning_inhibit = 1;
#line 160
  goto switch_break;
  case_25: /* CIL Label */ 
#line 162
  warning_return_type = 1;
#line 163
  goto switch_break;
  case_26: /* CIL Label */ 
#line 165
  warning_trigraphs = 1;
#line 166
  goto switch_break;
  case_27: /* CIL Label */ 
#line 168
  warning_uninitialized = 1;
#line 169
  goto switch_break;
  case_28: /* CIL Label */ 
#line 171
  warning_unused = 1;
#line 172
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 175
  tmp___6 = help(3);
  }
#line 175
  if (tmp___6 == -1) {
#line 176
    return (-1);
  }
#line 178
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 181
  error_message(7000);
  }
#line 181
  return (-1);
#line 183
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 499 "/usr/share/misc/bison.simple"
  yy_rs_vsp -= yy_rs_len;
#line 500
  yy_rs_ssp -= yy_rs_len;
#line 516
  yy_rs_vsp ++;
#line 516
  *yy_rs_vsp = yy_rs_val;
#line 540
  yy_rs_n = (int )yy_rs_r1[yy_rs_n];
#line 542
  yy_rs_state = (int )((int const   )yy_rs_pgoto[yy_rs_n - 32] + (int const   )*yy_rs_ssp);
#line 543
  if (yy_rs_state >= 0) {
#line 543
    if (yy_rs_state <= 31) {
#line 543
      if ((int const   )yy_rs_check[yy_rs_state] == (int const   )*yy_rs_ssp) {
#line 544
        yy_rs_state = (int )yy_rs_table[yy_rs_state];
      } else {
#line 546
        yy_rs_state = (int )yy_rs_defgoto[yy_rs_n - 32];
      }
    } else {
#line 546
      yy_rs_state = (int )yy_rs_defgoto[yy_rs_n - 32];
    }
  } else {
#line 546
    yy_rs_state = (int )yy_rs_defgoto[yy_rs_n - 32];
  }
#line 548
  goto yy_rs_newstate;
  yy_rs_errlab: 
#line 552
  if (! yy_rs_errstatus) {
    {
#line 555
    yy_rs_nerrs ++;
#line 598
    yy_rs_error((char *)"parse error");
    }
  }
#line 601
  goto yy_rs_errlab1;
  yy_rs_errlab1: 
#line 604
  if (yy_rs_errstatus == 3) {
#line 609
    if (yy_rs_char == 0) {
#line 610
      return (1);
    }
#line 617
    yy_rs_char = -2;
  }
#line 623
  yy_rs_errstatus = 3;
#line 625
  goto yy_rs_errhandle;
  yy_rs_errdefault: 
#line 638
  if ((unsigned long )yy_rs_ssp == (unsigned long )yy_rs_ss) {
#line 638
    return (1);
  }
#line 639
  yy_rs_vsp --;
#line 640
  yy_rs_ssp --;
#line 640
  yy_rs_state = (int )*yy_rs_ssp;
  yy_rs_errhandle: 
#line 658
  yy_rs_n = (int )yy_rs_pact[yy_rs_state];
#line 659
  if (yy_rs_n == -32768) {
#line 660
    goto yy_rs_errdefault;
  }
#line 662
  yy_rs_n ++;
#line 663
  if (yy_rs_n < 0) {
#line 664
    goto yy_rs_errdefault;
  } else
#line 663
  if (yy_rs_n > 31) {
#line 664
    goto yy_rs_errdefault;
  } else
#line 663
  if ((int const   )yy_rs_check[yy_rs_n] != 1) {
#line 664
    goto yy_rs_errdefault;
  }
#line 666
  yy_rs_n = (int )yy_rs_table[yy_rs_n];
#line 667
  if (yy_rs_n < 0) {
#line 669
    if (yy_rs_n == -32768) {
#line 670
      goto yy_rs_errdefault;
    }
#line 671
    yy_rs_n = - yy_rs_n;
#line 672
    goto yy_rs_reduce;
  } else
#line 674
  if (yy_rs_n == 0) {
#line 675
    goto yy_rs_errdefault;
  }
#line 677
  if (yy_rs_n == 34) {
#line 678
    return (0);
  }
#line 685
  yy_rs_vsp ++;
#line 685
  *yy_rs_vsp = yy_rs_lval;
#line 690
  yy_rs_state = yy_rs_n;
#line 691
  goto yy_rs_newstate;
}
}
#line 29 "/home/wslee/benchmarks/clif-0.93/keyword.c"
static int hash___0(char *str___0 , unsigned int len ) ;
#line 29 "/home/wslee/benchmarks/clif-0.93/keyword.c"
static unsigned char hash_table[128]  = 
#line 29
  {      (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)40,      (unsigned char)96,      (unsigned char)0, 
        (unsigned char)96,      (unsigned char)0,      (unsigned char)5,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)40,      (unsigned char)96,      (unsigned char)96, 
        (unsigned char)25,      (unsigned char)45,      (unsigned char)10,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)96,      (unsigned char)5,      (unsigned char)20, 
        (unsigned char)0,      (unsigned char)25,      (unsigned char)96,      (unsigned char)50, 
        (unsigned char)30,      (unsigned char)10,      (unsigned char)10,      (unsigned char)96, 
        (unsigned char)96,      (unsigned char)96,      (unsigned char)96,      (unsigned char)96};
#line 24 "/home/wslee/benchmarks/clif-0.93/keyword.c"
static int hash___0(char *str___0 , unsigned int len ) 
{ 
  register int hval ;

  {
#line 45
  hval = (int )len;
  {
#line 52
  if (hval == 2) {
#line 52
    goto case_2;
  }
#line 49
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 51
  hval += (int )hash_table[*(str___0 + 2)];
  case_2: /* CIL Label */ 
#line 53
  hval += (int )hash_table[*(str___0 + 1)];
  switch_break: /* CIL Label */ ;
  }
#line 55
  return (hval);
}
}
#line 64
struct el_mc *in_word_set(char *str___0 , unsigned int len ) ;
#line 64 "/home/wslee/benchmarks/clif-0.93/keyword.c"
static struct el_mc wordlist[97]  = 
#line 64
  {      {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"do", 297}, 
        {(char *)"rpc", 274}, 
        {(char *)"goto", 301}, 
        {(char *)"", 0}, 
        {(char *)"return", 300}, 
        {(char *)"if", 291}, 
        {(char *)"for", 296}, 
        {(char *)"", 0}, 
        {(char *)"break", 299}, 
        {(char *)"struct", 288}, 
        {(char *)"default", 303}, 
        {(char *)"int", 276}, 
        {(char *)"long", 281}, 
        {(char *)"const", 285}, 
        {(char *)"", 0}, 
        {(char *)"typedef", 307}, 
        {(char *)"continue", 298}, 
        {(char *)"intrinsic", 273}, 
        {(char *)"short", 282}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"register", 269}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"resume", 305}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"auto", 267}, 
        {(char *)"float", 278}, 
        {(char *)"double", 277}, 
        {(char *)"", 0}, 
        {(char *)"volatile", 286}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"extern", 270}, 
        {(char *)"", 0}, 
        {(char *)"unsigned", 284}, 
        {(char *)"enum", 287}, 
        {(char *)"", 0}, 
        {(char *)"export_type", 306}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"void", 280}, 
        {(char *)"", 0}, 
        {(char *)"static", 268}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"else", 292}, 
        {(char *)"", 0}, 
        {(char *)"remote", 271}, 
        {(char *)"", 0}, 
        {(char *)"csuspend", 304}, 
        {(char *)"", 0}, 
        {(char *)"union", 289}, 
        {(char *)"sizeof", 293}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"char", 279}, 
        {(char *)"while", 295}, 
        {(char *)"signed", 283}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"case", 302}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"exit", 290}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"switch", 294}};
#line 58 "/home/wslee/benchmarks/clif-0.93/keyword.c"
struct el_mc *in_word_set(char *str___0 , unsigned int len ) 
{ 
  register int key ;
  int tmp___0 ;
  register char *s___0 ;
  int tmp___1 ;

  {
#line 130
  if (len <= 11U) {
#line 130
    if (len >= 2U) {
      {
#line 132
      tmp___0 = hash___0(str___0, len);
#line 132
      key = tmp___0;
      }
#line 134
      if (key <= 96) {
#line 134
        if (key >= 2) {
#line 136
          s___0 = wordlist[key].name;
#line 138
          if ((int )*s___0 == (int )*str___0) {
            {
#line 138
            tmp___1 = strcmp(str___0 + 1, s___0 + 1);
            }
#line 138
            if (! tmp___1) {
#line 139
              return (& wordlist[key]);
            }
          }
        }
      }
    }
  }
#line 142
  return ((struct el_mc *)0);
}
}
#line 799 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 340
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 142 "lex.yy.c"
int yyleng  ;
#line 144
FILE *yyout ;
#line 244 "lex.yy.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 245 "lex.yy.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 246 "lex.yy.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 264 "lex.yy.c"
static char yy_hold_char  ;
#line 265 "lex.yy.c"
static int yy_n_chars  ;
#line 269 "lex.yy.c"
static char *yy_c_buf_p  =    (char *)0;
#line 270 "lex.yy.c"
static int yy_init  =    1;
#line 271 "lex.yy.c"
static int yy_start  =    0;
#line 276 "lex.yy.c"
static int yy_did_buffer_switch_on_eof  ;
#line 278
void yyrestart(FILE *input_file ) ;
#line 279
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 280
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 281
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 282
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 283
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 284
void yypop_buffer_state(void) ;
#line 286
static void yyensure_buffer_stack(void) ;
#line 287
static void yy_load_buffer_state(void) ;
#line 288
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 292
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 293
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) ;
#line 294
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) ;
#line 296
void *yyalloc(yy_size_t size ) ;
#line 297
void *yyrealloc(void *ptr , yy_size_t size ) ;
#line 298
void yyfree(void *ptr ) ;
#line 328 "lex.yy.c"
FILE *yyin  =    (FILE *)0;
#line 328 "lex.yy.c"
FILE *yyout  =    (FILE *)0;
#line 332
int yylineno ;
#line 334 "lex.yy.c"
int yylineno  =    1;
#line 336 "lex.yy.c"
char *yytext  ;
#line 339
static yy_state_type yy_get_previous_state(void) ;
#line 340
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 341
static int yy_get_next_buffer(void) ;
#line 342
static void yy_fatal_error(char const   *msg ) ;
#line 363 "lex.yy.c"
static flex_int16_t const   yy_accept[130]  = 
#line 363
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )56, 
        (flex_int16_t const   )54,      (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )40, 
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54, 
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54, 
        (flex_int16_t const   )54,      (flex_int16_t const   )12,      (flex_int16_t const   )12,      (flex_int16_t const   )54, 
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )54,      (flex_int16_t const   )18,      (flex_int16_t const   )54, 
        (flex_int16_t const   )41,      (flex_int16_t const   )37,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )28,      (flex_int16_t const   )32,      (flex_int16_t const   )29,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )26, 
        (flex_int16_t const   )38,      (flex_int16_t const   )24,      (flex_int16_t const   )39,      (flex_int16_t const   )25, 
        (flex_int16_t const   )44,      (flex_int16_t const   )15,      (flex_int16_t const   )0,      (flex_int16_t const   )27, 
        (flex_int16_t const   )15,      (flex_int16_t const   )12,      (flex_int16_t const   )0,      (flex_int16_t const   )9, 
        (flex_int16_t const   )8,      (flex_int16_t const   )0,      (flex_int16_t const   )43,      (flex_int16_t const   )36, 
        (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )42,      (flex_int16_t const   )0, 
        (flex_int16_t const   )18,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )30, 
        (flex_int16_t const   )18,      (flex_int16_t const   )31,      (flex_int16_t const   )33,      (flex_int16_t const   )21, 
        (flex_int16_t const   )21,      (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )0, 
        (flex_int16_t const   )17,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )15,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )15,      (flex_int16_t const   )11,      (flex_int16_t const   )10, 
        (flex_int16_t const   )7,      (flex_int16_t const   )23,      (flex_int16_t const   )22,      (flex_int16_t const   )51, 
        (flex_int16_t const   )49,      (flex_int16_t const   )46,      (flex_int16_t const   )48,      (flex_int16_t const   )53, 
        (flex_int16_t const   )47,      (flex_int16_t const   )50,      (flex_int16_t const   )45,      (flex_int16_t const   )52, 
        (flex_int16_t const   )0,      (flex_int16_t const   )18,      (flex_int16_t const   )21,      (flex_int16_t const   )0, 
        (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )0,      (flex_int16_t const   )16, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )15, 
        (flex_int16_t const   )19,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )15, 
        (flex_int16_t const   )4,      (flex_int16_t const   )3,      (flex_int16_t const   )18,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )15,      (flex_int16_t const   )6, 
        (flex_int16_t const   )5,      (flex_int16_t const   )0,      (flex_int16_t const   )20,      (flex_int16_t const   )0, 
        (flex_int16_t const   )20,      (flex_int16_t const   )0};
#line 381 "lex.yy.c"
static flex_int32_t const   yy_ec[256]  = 
#line 381
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )10, 
        (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )14, 
        (flex_int32_t const   )7,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )19,      (flex_int32_t const   )19, 
        (flex_int32_t const   )19,      (flex_int32_t const   )19,      (flex_int32_t const   )19,      (flex_int32_t const   )19, 
        (flex_int32_t const   )20,      (flex_int32_t const   )20,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )21,      (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )24, 
        (flex_int32_t const   )7,      (flex_int32_t const   )25,      (flex_int32_t const   )25,      (flex_int32_t const   )25, 
        (flex_int32_t const   )25,      (flex_int32_t const   )26,      (flex_int32_t const   )27,      (flex_int32_t const   )28, 
        (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )28, 
        (flex_int32_t const   )29,      (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )28, 
        (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )28, 
        (flex_int32_t const   )28,      (flex_int32_t const   )30,      (flex_int32_t const   )28,      (flex_int32_t const   )28, 
        (flex_int32_t const   )31,      (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )7, 
        (flex_int32_t const   )32,      (flex_int32_t const   )7,      (flex_int32_t const   )33,      (flex_int32_t const   )28, 
        (flex_int32_t const   )7,      (flex_int32_t const   )34,      (flex_int32_t const   )35,      (flex_int32_t const   )25, 
        (flex_int32_t const   )36,      (flex_int32_t const   )26,      (flex_int32_t const   )37,      (flex_int32_t const   )28, 
        (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )28, 
        (flex_int32_t const   )38,      (flex_int32_t const   )28,      (flex_int32_t const   )39,      (flex_int32_t const   )40, 
        (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )41,      (flex_int32_t const   )28, 
        (flex_int32_t const   )42,      (flex_int32_t const   )30,      (flex_int32_t const   )43,      (flex_int32_t const   )28, 
        (flex_int32_t const   )44,      (flex_int32_t const   )28,      (flex_int32_t const   )28,      (flex_int32_t const   )7, 
        (flex_int32_t const   )45,      (flex_int32_t const   )7,      (flex_int32_t const   )46,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 413 "lex.yy.c"
static flex_int32_t const   yy_meta[47]  = 
#line 413
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )2,      (flex_int32_t const   )2};
#line 422 "lex.yy.c"
static flex_int16_t const   yy_base[136]  = 
#line 422
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )257, 
        (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )229, 
        (flex_int16_t const   )218,      (flex_int16_t const   )227,      (flex_int16_t const   )38,      (flex_int16_t const   )42, 
        (flex_int16_t const   )226,      (flex_int16_t const   )35,      (flex_int16_t const   )36,      (flex_int16_t const   )34, 
        (flex_int16_t const   )42,      (flex_int16_t const   )59,      (flex_int16_t const   )203,      (flex_int16_t const   )40, 
        (flex_int16_t const   )224,      (flex_int16_t const   )45,      (flex_int16_t const   )221,      (flex_int16_t const   )0, 
        (flex_int16_t const   )59,      (flex_int16_t const   )219,      (flex_int16_t const   )66,      (flex_int16_t const   )28, 
        (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )50,      (flex_int16_t const   )64, 
        (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )230, 
        (flex_int16_t const   )229,      (flex_int16_t const   )228,      (flex_int16_t const   )101,      (flex_int16_t const   )343, 
        (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )343, 
        (flex_int16_t const   )343,      (flex_int16_t const   )128,      (flex_int16_t const   )67,      (flex_int16_t const   )343, 
        (flex_int16_t const   )72,      (flex_int16_t const   )183,      (flex_int16_t const   )90,      (flex_int16_t const   )195, 
        (flex_int16_t const   )57,      (flex_int16_t const   )0,      (flex_int16_t const   )202,      (flex_int16_t const   )343, 
        (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )200,      (flex_int16_t const   )162, 
        (flex_int16_t const   )0,      (flex_int16_t const   )177,      (flex_int16_t const   )94,      (flex_int16_t const   )343, 
        (flex_int16_t const   )174,      (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )157, 
        (flex_int16_t const   )194,      (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )194, 
        (flex_int16_t const   )189,      (flex_int16_t const   )83,      (flex_int16_t const   )103,      (flex_int16_t const   )0, 
        (flex_int16_t const   )109,      (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )181, 
        (flex_int16_t const   )70,      (flex_int16_t const   )177,      (flex_int16_t const   )163,      (flex_int16_t const   )173, 
        (flex_int16_t const   )96,      (flex_int16_t const   )215,      (flex_int16_t const   )343,      (flex_int16_t const   )343, 
        (flex_int16_t const   )101,      (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )343, 
        (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )343, 
        (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )343,      (flex_int16_t const   )343, 
        (flex_int16_t const   )158,      (flex_int16_t const   )122,      (flex_int16_t const   )199,      (flex_int16_t const   )150, 
        (flex_int16_t const   )252,      (flex_int16_t const   )289,      (flex_int16_t const   )143,      (flex_int16_t const   )343, 
        (flex_int16_t const   )152,      (flex_int16_t const   )143,      (flex_int16_t const   )132,      (flex_int16_t const   )162, 
        (flex_int16_t const   )120,      (flex_int16_t const   )192,      (flex_int16_t const   )195,      (flex_int16_t const   )198, 
        (flex_int16_t const   )87,      (flex_int16_t const   )140,      (flex_int16_t const   )130,      (flex_int16_t const   )102, 
        (flex_int16_t const   )151,      (flex_int16_t const   )201,      (flex_int16_t const   )211,      (flex_int16_t const   )343, 
        (flex_int16_t const   )343,      (flex_int16_t const   )232,      (flex_int16_t const   )95,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )343,      (flex_int16_t const   )326,      (flex_int16_t const   )330, 
        (flex_int16_t const   )332,      (flex_int16_t const   )337,      (flex_int16_t const   )67,      (flex_int16_t const   )59};
#line 441 "lex.yy.c"
static flex_int16_t const   yy_def[136]  = 
#line 441
  {      (flex_int16_t const   )0,      (flex_int16_t const   )129,      (flex_int16_t const   )1,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )130,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )131, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )17,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )132, 
        (flex_int16_t const   )132,      (flex_int16_t const   )129,      (flex_int16_t const   )132,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )130,      (flex_int16_t const   )130, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )133,      (flex_int16_t const   )129, 
        (flex_int16_t const   )45,      (flex_int16_t const   )17,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )134,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )132,      (flex_int16_t const   )130,      (flex_int16_t const   )131,      (flex_int16_t const   )129, 
        (flex_int16_t const   )132,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )130,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )135, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )133, 
        (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )48,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )134,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )38,      (flex_int16_t const   )132,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )130,      (flex_int16_t const   )130,      (flex_int16_t const   )130,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )135,      (flex_int16_t const   )129,      (flex_int16_t const   )85, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )85, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )132,      (flex_int16_t const   )129, 
        (flex_int16_t const   )133,      (flex_int16_t const   )129,      (flex_int16_t const   )85,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )0,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129};
#line 460 "lex.yy.c"
static flex_int16_t const   yy_nxt[390]  = 
#line 460
  {      (flex_int16_t const   )0,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )5,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )4, 
        (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )4, 
        (flex_int16_t const   )4,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )4,      (flex_int16_t const   )25,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )26,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )33, 
        (flex_int16_t const   )36,      (flex_int16_t const   )40,      (flex_int16_t const   )65,      (flex_int16_t const   )42, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )46, 
        (flex_int16_t const   )67,      (flex_int16_t const   )41,      (flex_int16_t const   )43,      (flex_int16_t const   )44, 
        (flex_int16_t const   )34,      (flex_int16_t const   )54,      (flex_int16_t const   )55,      (flex_int16_t const   )109, 
        (flex_int16_t const   )47,      (flex_int16_t const   )61,      (flex_int16_t const   )37,      (flex_int16_t const   )57, 
        (flex_int16_t const   )58,      (flex_int16_t const   )62,      (flex_int16_t const   )68,      (flex_int16_t const   )88, 
        (flex_int16_t const   )61,      (flex_int16_t const   )66,      (flex_int16_t const   )38,      (flex_int16_t const   )48, 
        (flex_int16_t const   )62,      (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )49, 
        (flex_int16_t const   )80,      (flex_int16_t const   )128,      (flex_int16_t const   )31,      (flex_int16_t const   )80, 
        (flex_int16_t const   )81,      (flex_int16_t const   )50,      (flex_int16_t const   )87,      (flex_int16_t const   )112, 
        (flex_int16_t const   )51,      (flex_int16_t const   )52,      (flex_int16_t const   )82,      (flex_int16_t const   )82, 
        (flex_int16_t const   )82,      (flex_int16_t const   )107,      (flex_int16_t const   )120,      (flex_int16_t const   )87, 
        (flex_int16_t const   )31,      (flex_int16_t const   )51,      (flex_int16_t const   )83,      (flex_int16_t const   )128, 
        (flex_int16_t const   )36,      (flex_int16_t const   )108,      (flex_int16_t const   )108,      (flex_int16_t const   )53, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )64,      (flex_int16_t const   )71, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )72, 
        (flex_int16_t const   )69,      (flex_int16_t const   )69,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )123,      (flex_int16_t const   )37,      (flex_int16_t const   )73, 
        (flex_int16_t const   )74,      (flex_int16_t const   )108,      (flex_int16_t const   )108,      (flex_int16_t const   )110, 
        (flex_int16_t const   )110,      (flex_int16_t const   )71,      (flex_int16_t const   )100,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )117, 
        (flex_int16_t const   )75,      (flex_int16_t const   )71,      (flex_int16_t const   )125,      (flex_int16_t const   )71, 
        (flex_int16_t const   )71,      (flex_int16_t const   )120,      (flex_int16_t const   )71,      (flex_int16_t const   )116, 
        (flex_int16_t const   )71,      (flex_int16_t const   )126,      (flex_int16_t const   )71,      (flex_int16_t const   )71, 
        (flex_int16_t const   )71,      (flex_int16_t const   )75,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )105,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )69,      (flex_int16_t const   )76,      (flex_int16_t const   )77, 
        (flex_int16_t const   )61,      (flex_int16_t const   )78,      (flex_int16_t const   )118,      (flex_int16_t const   )102, 
        (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )69,      (flex_int16_t const   )61, 
        (flex_int16_t const   )80,      (flex_int16_t const   )77,      (flex_int16_t const   )78,      (flex_int16_t const   )91, 
        (flex_int16_t const   )127,      (flex_int16_t const   )124,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )92,      (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )31, 
        (flex_int16_t const   )74,      (flex_int16_t const   )95,      (flex_int16_t const   )124,      (flex_int16_t const   )96, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )97, 
        (flex_int16_t const   )98,      (flex_int16_t const   )99,      (flex_int16_t const   )103,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )113,      (flex_int16_t const   )80,      (flex_int16_t const   )115, 
        (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )80,      (flex_int16_t const   )103, 
        (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )69, 
        (flex_int16_t const   )105,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )69,      (flex_int16_t const   )61,      (flex_int16_t const   )121,      (flex_int16_t const   )121, 
        (flex_int16_t const   )101,      (flex_int16_t const   )31,      (flex_int16_t const   )122,      (flex_int16_t const   )122, 
        (flex_int16_t const   )122,      (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )115, 
        (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )122, 
        (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )90,      (flex_int16_t const   )106, 
        (flex_int16_t const   )89,      (flex_int16_t const   )86,      (flex_int16_t const   )31,      (flex_int16_t const   )129, 
        (flex_int16_t const   )103,      (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )122, 
        (flex_int16_t const   )106,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )125,      (flex_int16_t const   )103,      (flex_int16_t const   )70,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )63,      (flex_int16_t const   )77,      (flex_int16_t const   )126, 
        (flex_int16_t const   )78,      (flex_int16_t const   )59,      (flex_int16_t const   )56,      (flex_int16_t const   )129, 
        (flex_int16_t const   )39,      (flex_int16_t const   )32,      (flex_int16_t const   )31,      (flex_int16_t const   )29, 
        (flex_int16_t const   )77,      (flex_int16_t const   )78,      (flex_int16_t const   )104,      (flex_int16_t const   )104, 
        (flex_int16_t const   )104,      (flex_int16_t const   )129,      (flex_int16_t const   )105,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )106,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )31,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )106,      (flex_int16_t const   )104, 
        (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )129,      (flex_int16_t const   )61, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )106,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )31,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )106, 
        (flex_int16_t const   )30,      (flex_int16_t const   )129,      (flex_int16_t const   )30,      (flex_int16_t const   )30, 
        (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )35, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )79,      (flex_int16_t const   )79, 
        (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )3, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129};
#line 506 "lex.yy.c"
static flex_int16_t const   yy_chk[390]  = 
#line 506
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )10, 
        (flex_int16_t const   )11,      (flex_int16_t const   )13,      (flex_int16_t const   )27,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )30,      (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )14, 
        (flex_int16_t const   )10,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )135, 
        (flex_int16_t const   )16,      (flex_int16_t const   )24,      (flex_int16_t const   )11,      (flex_int16_t const   )21, 
        (flex_int16_t const   )21,      (flex_int16_t const   )24,      (flex_int16_t const   )31,      (flex_int16_t const   )134, 
        (flex_int16_t const   )26,      (flex_int16_t const   )27,      (flex_int16_t const   )11,      (flex_int16_t const   )17, 
        (flex_int16_t const   )26,      (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )17, 
        (flex_int16_t const   )46,      (flex_int16_t const   )128,      (flex_int16_t const   )30,      (flex_int16_t const   )80, 
        (flex_int16_t const   )46,      (flex_int16_t const   )17,      (flex_int16_t const   )52,      (flex_int16_t const   )80, 
        (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )73,      (flex_int16_t const   )127,      (flex_int16_t const   )52, 
        (flex_int16_t const   )31,      (flex_int16_t const   )17,      (flex_int16_t const   )48,      (flex_int16_t const   )126, 
        (flex_int16_t const   )62,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )17, 
        (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )26,      (flex_int16_t const   )38, 
        (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )38, 
        (flex_int16_t const   )119,      (flex_int16_t const   )74,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )116,      (flex_int16_t const   )62,      (flex_int16_t const   )38, 
        (flex_int16_t const   )38,      (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )76, 
        (flex_int16_t const   )76,      (flex_int16_t const   )38,      (flex_int16_t const   )62,      (flex_int16_t const   )76, 
        (flex_int16_t const   )76,      (flex_int16_t const   )76,      (flex_int16_t const   )88,      (flex_int16_t const   )88, 
        (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )118,      (flex_int16_t const   )38, 
        (flex_int16_t const   )38,      (flex_int16_t const   )112,      (flex_int16_t const   )38,      (flex_int16_t const   )88, 
        (flex_int16_t const   )38,      (flex_int16_t const   )118,      (flex_int16_t const   )38,      (flex_int16_t const   )38, 
        (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )106,      (flex_int16_t const   )110,      (flex_int16_t const   )110, 
        (flex_int16_t const   )110,      (flex_int16_t const   )109,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )103,      (flex_int16_t const   )45,      (flex_int16_t const   )101,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )108,      (flex_int16_t const   )67, 
        (flex_int16_t const   )120,      (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )59, 
        (flex_int16_t const   )120,      (flex_int16_t const   )117,      (flex_int16_t const   )108,      (flex_int16_t const   )108, 
        (flex_int16_t const   )59,      (flex_int16_t const   )59,      (flex_int16_t const   )59,      (flex_int16_t const   )106, 
        (flex_int16_t const   )100,      (flex_int16_t const   )59,      (flex_int16_t const   )117,      (flex_int16_t const   )59, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )59, 
        (flex_int16_t const   )59,      (flex_int16_t const   )59,      (flex_int16_t const   )67,      (flex_int16_t const   )83, 
        (flex_int16_t const   )83,      (flex_int16_t const   )82,      (flex_int16_t const   )81,      (flex_int16_t const   )83, 
        (flex_int16_t const   )83,      (flex_int16_t const   )83,      (flex_int16_t const   )79,      (flex_int16_t const   )67, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )72, 
        (flex_int16_t const   )68,      (flex_int16_t const   )102,      (flex_int16_t const   )102,      (flex_int16_t const   )102, 
        (flex_int16_t const   )71,      (flex_int16_t const   )102,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )64,      (flex_int16_t const   )61,      (flex_int16_t const   )113,      (flex_int16_t const   )113, 
        (flex_int16_t const   )113,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )121, 
        (flex_int16_t const   )121,      (flex_int16_t const   )121,      (flex_int16_t const   )58,      (flex_int16_t const   )68, 
        (flex_int16_t const   )54,      (flex_int16_t const   )51,      (flex_int16_t const   )68,      (flex_int16_t const   )49, 
        (flex_int16_t const   )102,      (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )122, 
        (flex_int16_t const   )68,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )125,      (flex_int16_t const   )102,      (flex_int16_t const   )37,      (flex_int16_t const   )36, 
        (flex_int16_t const   )35,      (flex_int16_t const   )25,      (flex_int16_t const   )85,      (flex_int16_t const   )125, 
        (flex_int16_t const   )85,      (flex_int16_t const   )22,      (flex_int16_t const   )20,      (flex_int16_t const   )18, 
        (flex_int16_t const   )12,      (flex_int16_t const   )9,      (flex_int16_t const   )8,      (flex_int16_t const   )7, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )104,      (flex_int16_t const   )104, 
        (flex_int16_t const   )104,      (flex_int16_t const   )3,      (flex_int16_t const   )104,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )104,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )104,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )104,      (flex_int16_t const   )105, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )0,      (flex_int16_t const   )105, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )105,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )105,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )105, 
        (flex_int16_t const   )130,      (flex_int16_t const   )0,      (flex_int16_t const   )130,      (flex_int16_t const   )130, 
        (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131,      (flex_int16_t const   )131, 
        (flex_int16_t const   )132,      (flex_int16_t const   )132,      (flex_int16_t const   )133,      (flex_int16_t const   )133, 
        (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129, 
        (flex_int16_t const   )129,      (flex_int16_t const   )129};
#line 552 "lex.yy.c"
static yy_state_type yy_last_accepting_state  ;
#line 553 "lex.yy.c"
static char *yy_last_accepting_cpos  ;
#line 555
int yy_flex_debug ;
#line 556 "lex.yy.c"
int yy_flex_debug  =    0;
#line 137 "/home/wslee/benchmarks/clif-0.93/global.h"
char *text  ;
#line 90 "/home/wslee/benchmarks/clif-0.93/token.h"
YYSTYPE yylval ;
#line 44 "ls.l"
char message[250]  ;
#line 42 "/home/wslee/benchmarks/clif-0.93/input.h"
void switch_to_char_buffer(void) ;
#line 43
int switch_to_buffer(void) ;
#line 61 "ls.l"
static int find_ident(char *s___0 , int len ) ;
#line 659 "lex.yy.c"
int yywrap(void) ;
#line 678
static int input___0(void) ;
#line 758
int yylex(void) ;
#line 780 "lex.yy.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp___0 ;
  register YY_CHAR yy_c ;
  int i ;
  int j ;
  int i___0 ;
  int tmp___1 ;
  char *str___0 ;
  char *tmp___2 ;
  char name___0[20] ;
  char *tmp_p ;
  int w ;
  int ab ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  YY_BUFFER_STATE tmp___8 ;
  int wide_string ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 790
  if (yy_init) {
#line 792
    yy_init = 0;
#line 798
    if (! yy_start) {
#line 799
      yy_start = 1;
    }
#line 801
    if (! yyin) {
#line 802
      yyin = stdin;
    }
#line 804
    if (! yyout) {
#line 805
      yyout = stdout;
    }
#line 807
    if (yy_buffer_stack) {
#line 807
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 807
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 807
    if (! tmp___0) {
      {
#line 808
      yyensure_buffer_stack();
#line 809
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 813
    yy_load_buffer_state();
    }
  }
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    yy_cp = yy_c_buf_p;
#line 821
    *yy_cp = yy_hold_char;
#line 826
    yy_bp = yy_cp;
#line 828
    yy_current_state = yy_start;
    yy_match: 
    {
#line 830
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 832
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 833
      if (yy_accept[yy_current_state]) {
#line 835
        yy_last_accepting_state = yy_current_state;
#line 836
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 838
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 838
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 838
          goto while_break___1;
        }
#line 840
        yy_current_state = (int )yy_def[yy_current_state];
#line 841
        if (yy_current_state >= 130) {
#line 842
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 844
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 845
      yy_cp ++;
#line 830
      if (! ((int const   )yy_base[yy_current_state] != 343)) {
#line 830
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 850
    yy_act = (int )yy_accept[yy_current_state];
#line 851
    if (yy_act == 0) {
#line 853
      yy_cp = yy_last_accepting_cpos;
#line 854
      yy_current_state = yy_last_accepting_state;
#line 855
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 858
    yytext = yy_bp;
#line 858
    yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 858
    yy_hold_char = *yy_cp;
#line 858
    *yy_cp = (char )'\000';
#line 858
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 864
    if (yy_act == 0) {
#line 864
      goto case_0;
    }
#line 871
    if (yy_act == 1) {
#line 871
      goto case_1;
    }
#line 97
    if (yy_act == 2) {
#line 97 "ls.l"
      goto case_2;
    }
#line 106
    if (yy_act == 3) {
#line 106
      goto case_3;
    }
#line 112
    if (yy_act == 4) {
#line 112
      goto case_4;
    }
#line 118
    if (yy_act == 5) {
#line 118
      goto case_5;
    }
#line 124
    if (yy_act == 6) {
#line 124
      goto case_6;
    }
#line 130
    if (yy_act == 7) {
#line 130
      goto case_7;
    }
#line 136
    if (yy_act == 8) {
#line 136
      goto case_8;
    }
#line 144
    if (yy_act == 9) {
#line 144
      goto case_9;
    }
#line 152
    if (yy_act == 10) {
#line 152
      goto case_10;
    }
#line 160
    if (yy_act == 11) {
#line 160
      goto case_11;
    }
#line 168
    if (yy_act == 12) {
#line 168
      goto case_12;
    }
#line 176
    if (yy_act == 13) {
#line 176
      goto case_13;
    }
#line 184
    if (yy_act == 14) {
#line 184
      goto case_14;
    }
#line 192
    if (yy_act == 15) {
#line 192
      goto case_15;
    }
#line 200
    if (yy_act == 16) {
#line 200
      goto case_16;
    }
#line 206
    if (yy_act == 17) {
#line 206
      goto case_17;
    }
#line 291
    if (yy_act == 18) {
#line 291
      goto case_18;
    }
#line 313
    if (yy_act == 19) {
#line 313
      goto case_19;
    }
#line 335
    if (yy_act == 20) {
#line 335
      goto case_20;
    }
#line 381
    if (yy_act == 21) {
#line 381
      goto case_21;
    }
#line 401
    if (yy_act == 22) {
#line 401
      goto case_22;
    }
#line 402
    if (yy_act == 23) {
#line 402
      goto case_23;
    }
#line 403
    if (yy_act == 24) {
#line 403
      goto case_24;
    }
#line 404
    if (yy_act == 25) {
#line 404
      goto case_25;
    }
#line 405
    if (yy_act == 26) {
#line 405
      goto case_26;
    }
#line 406
    if (yy_act == 27) {
#line 406
      goto case_27;
    }
#line 407
    if (yy_act == 28) {
#line 407
      goto case_28;
    }
#line 408
    if (yy_act == 29) {
#line 408
      goto case_29;
    }
#line 409
    if (yy_act == 30) {
#line 409
      goto case_30;
    }
#line 410
    if (yy_act == 31) {
#line 410
      goto case_31;
    }
#line 411
    if (yy_act == 32) {
#line 411
      goto case_32;
    }
#line 412
    if (yy_act == 33) {
#line 412
      goto case_33;
    }
#line 413
    if (yy_act == 34) {
#line 413
      goto case_34___0;
    }
#line 414
    if (yy_act == 35) {
#line 414
      goto case_35;
    }
#line 415
    if (yy_act == 36) {
#line 415
      goto case_36;
    }
#line 416
    if (yy_act == 37) {
#line 416
      goto case_37;
    }
#line 417
    if (yy_act == 38) {
#line 417
      goto case_38;
    }
#line 418
    if (yy_act == 39) {
#line 418
      goto case_39___0;
    }
#line 419
    if (yy_act == 40) {
#line 419
      goto case_40;
    }
#line 420
    if (yy_act == 41) {
#line 420
      goto case_41;
    }
#line 421
    if (yy_act == 42) {
#line 421
      goto case_42;
    }
#line 422
    if (yy_act == 43) {
#line 422
      goto case_43;
    }
#line 423
    if (yy_act == 44) {
#line 423
      goto case_44;
    }
#line 424
    if (yy_act == 45) {
#line 424
      goto case_45;
    }
#line 429
    if (yy_act == 46) {
#line 429
      goto case_46;
    }
#line 434
    if (yy_act == 47) {
#line 434
      goto case_47;
    }
#line 439
    if (yy_act == 48) {
#line 439
      goto case_48;
    }
#line 444
    if (yy_act == 49) {
#line 444
      goto case_49;
    }
#line 449
    if (yy_act == 50) {
#line 449
      goto case_50;
    }
#line 454
    if (yy_act == 51) {
#line 454
      goto case_51;
    }
#line 459
    if (yy_act == 52) {
#line 459
      goto case_52;
    }
#line 464
    if (yy_act == 53) {
#line 464
      goto case_53;
    }
#line 469
    if (yy_act == 54) {
#line 469
      goto case_54;
    }
#line 474
    if (yy_act == 55) {
#line 474
      goto case_55;
    }
#line 1477
    if (yy_act == 57) {
#line 1477 "lex.yy.c"
      goto case_57;
    }
#line 1480
    if (yy_act == 56) {
#line 1480
      goto case_56;
    }
#line 1602
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 866
    *yy_cp = yy_hold_char;
#line 867
    yy_cp = yy_last_accepting_cpos;
#line 868
    yy_current_state = yy_last_accepting_state;
#line 869
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 92 "ls.l"
    char_counter += yyleng;
#line 92
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 96
    goto switch_break;
    case_2: /* CIL Label */ 
#line 98
    (spf[s].line_counter) ++;
#line 99
    line_buf[0] = (char)0;
#line 100
    char_counter = 0;
#line 102
    if (dbg_symbols) {
      {
#line 103
      dbg_create();
      }
    }
#line 105
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 106
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%ux",
           & yylval.myuint);
#line 107
    char_counter += yyleng;
#line 108
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 109
    return (258);
#line 111
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 112
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%lx",
           & yylval.mylint);
#line 113
    char_counter += yyleng;
#line 114
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 115
    return (259);
#line 117
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 118
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%lux",
           & yylval.myluint);
#line 119
    char_counter += yyleng;
#line 120
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 121
    return (260);
#line 123
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 124
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%lx",
           & yylval.myluint);
#line 125
    char_counter += yyleng;
#line 126
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 127
    return (260);
#line 129
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 130
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%x",
           & yylval.myint);
#line 131
    char_counter += yyleng;
#line 132
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 133
    return (257);
#line 135
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 136
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%u",
           & yylval.myuint);
#line 137
    char_counter += yyleng;
#line 138
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 139
    return (258);
#line 143
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 144
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%ld",
           & yylval.mylint);
#line 145
    char_counter += yyleng;
#line 146
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 147
    return (259);
#line 151
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 152
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%lu",
           & yylval.myluint);
#line 153
    char_counter += yyleng;
#line 154
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 155
    return (260);
#line 159
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 160
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%lu",
           & yylval.myluint);
#line 161
    char_counter += yyleng;
#line 162
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 163
    return (260);
#line 167
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 168
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%d",
           & yylval.myint);
#line 169
    char_counter += yyleng;
#line 170
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 171
    return (257);
#line 175
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 176
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%f",
           & yylval.myfloat);
#line 177
    char_counter += yyleng;
#line 178
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 179
    return (263);
#line 183
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 184
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%Lf",
           & yylval.myldouble);
#line 185
    char_counter += yyleng;
#line 186
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 187
    return (262);
#line 191
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 192
    sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%lf",
           & yylval.mydouble);
#line 193
    char_counter += yyleng;
#line 194
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 195
    return (261);
#line 199
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 199
    char_counter += yyleng;
#line 200
    *(yytext + 0) = (char)0;
#line 201
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"\'\\0\'");
#line 202
    yylval.mychar = (char)0;
    }
#line 203
    return (266);
#line 205
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 207
    char_counter += yyleng;
#line 208
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
#line 209
    i = 1;
    }
    {
#line 209
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 209
      if (! ((int )*(yytext + i) != 0)) {
#line 209
        goto while_break___2;
      }
#line 210
      if ((int )*(yytext + (i - 1)) == 92) {
#line 210
        if ((int )*(yytext + i) == 88) {
          {
#line 212
          error_message(6033, "X");
          }
#line 213
          goto while_break___2;
        }
      }
#line 209
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 215
    if ((int )*(yytext + 0) == 108) {
      {
#line 217
      error_message(1038, "l");
#line 218
      error_message(1039, "character");
      }
    }
#line 233
    i = 0;
    {
#line 233
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 233
      if (! ((int )*(yytext + i) != 0)) {
#line 233
        goto while_break___3;
      }
#line 234
      if ((int )*(yytext + i) == 39) {
#line 235
        goto while_break___3;
      }
#line 233
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 236
    j = i + 1;
#line 236
    i = 0;
    {
#line 236
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 236
      if (! ((int )*(yytext + j) != 0)) {
#line 236
        goto while_break___4;
      }
#line 237
      *(yytext + i) = *(yytext + j);
#line 236
      j ++;
#line 236
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 238
    *(yytext + i) = (char )'\000';
#line 239
    if ((int )*(yytext + 0) == 92) {
      {
#line 243
      if ((int )*(yytext + 1) == 39) {
#line 243
        goto case_39;
      }
#line 246
      if ((int )*(yytext + 1) == 34) {
#line 246
        goto case_34;
      }
#line 249
      if ((int )*(yytext + 1) == 63) {
#line 249
        goto case_63;
      }
#line 252
      if ((int )*(yytext + 1) == 92) {
#line 252
        goto case_92;
      }
#line 255
      if ((int )*(yytext + 1) == 97) {
#line 255
        goto case_97;
      }
#line 258
      if ((int )*(yytext + 1) == 98) {
#line 258
        goto case_98;
      }
#line 261
      if ((int )*(yytext + 1) == 102) {
#line 261
        goto case_102;
      }
#line 264
      if ((int )*(yytext + 1) == 110) {
#line 264
        goto case_110;
      }
#line 267
      if ((int )*(yytext + 1) == 114) {
#line 267
        goto case_114;
      }
#line 270
      if ((int )*(yytext + 1) == 116) {
#line 270
        goto case_116;
      }
#line 273
      if ((int )*(yytext + 1) == 118) {
#line 273
        goto case_118;
      }
#line 276
      if ((int )*(yytext + 1) == 120) {
#line 276
        goto case_120;
      }
#line 280
      goto switch_default;
      case_39: /* CIL Label */ 
#line 244
      yylval.mychar = (char )'\'';
#line 245
      goto switch_break___0;
      case_34: /* CIL Label */ 
#line 247
      yylval.mychar = (char )'\"';
#line 248
      goto switch_break___0;
      case_63: /* CIL Label */ 
#line 250
      yylval.mychar = (char )'?';
#line 251
      goto switch_break___0;
      case_92: /* CIL Label */ 
#line 253
      yylval.mychar = (char )'\\';
#line 254
      goto switch_break___0;
      case_97: /* CIL Label */ 
#line 256
      yylval.mychar = (char )'\a';
#line 257
      goto switch_break___0;
      case_98: /* CIL Label */ 
#line 259
      yylval.mychar = (char )'\b';
#line 260
      goto switch_break___0;
      case_102: /* CIL Label */ 
#line 262
      yylval.mychar = (char )'\f';
#line 263
      goto switch_break___0;
      case_110: /* CIL Label */ 
#line 265
      yylval.mychar = (char )'\n';
#line 266
      goto switch_break___0;
      case_114: /* CIL Label */ 
#line 268
      yylval.mychar = (char )'\r';
#line 269
      goto switch_break___0;
      case_116: /* CIL Label */ 
#line 271
      yylval.mychar = (char )'\t';
#line 272
      goto switch_break___0;
      case_118: /* CIL Label */ 
#line 274
      yylval.mychar = (char )'\v';
#line 275
      goto switch_break___0;
      case_120: /* CIL Label */ 
      {
#line 277
      *(yytext + 0) = (char )'0';
#line 278
      sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%x",
             (unsigned int *)(& yylval.mychar));
      }
#line 279
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 281
      *(yytext + 0) = (char )'0';
#line 282
      sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%o",
             (unsigned int *)(& yylval.mychar));
      }
#line 283
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 287
      sscanf((char const   */* __restrict  */)yytext, (char const   */* __restrict  */)"%c",
             & yylval.mychar);
      }
    }
#line 288
    return (266);
#line 290
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 292
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
#line 293
    char_counter += yyleng;
#line 294
    i___0 = find_ident(yytext, yyleng);
    }
#line 297
    if (i___0) {
#line 298
      return (i___0);
    } else {
      {
#line 301
      text = string(yytext);
#line 302
      yylval.mystring = text;
#line 306
      tmp___1 = typedef_p(text);
      }
#line 306
      if (tmp___1) {
#line 307
        return (308);
      } else {
#line 309
        return (275);
      }
    }
#line 312
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 316
    char_counter += yyleng;
#line 317
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
#line 318
    tmp___2 = strstr((char const   *)(yytext + 2), "/*");
    }
#line 318
    if ((unsigned long )((void *)0) != (unsigned long )tmp___2) {
      {
#line 319
      error_message(6005);
      }
    }
    {
#line 324
    str___0 = yytext;
#line 325
    str___0 = strstr((char const   *)str___0, "\n");
    }
    {
#line 326
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 326
      if (! ((unsigned long )str___0 != (unsigned long )((void *)0))) {
#line 326
        goto while_break___5;
      }
      {
#line 328
      (spf[s].line_counter) ++;
#line 329
      str___0 ++;
#line 330
      str___0 = strstr((char const   *)str___0, "\n");
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 334
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 335
    ab = ' ';
#line 336
    char_counter += yyleng;
#line 337
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
#line 338
    w = 0;
    }
    {
#line 338
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 338
      if (! (ab != 59)) {
#line 338
        goto while_break___6;
      }
      {
#line 340
      ab = input___0();
#line 341
      name___0[w] = (char )ab;
#line 338
      w ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 343
    tmp___3 = strchr((char const   *)(name___0), ')');
#line 343
    tmp_p = tmp___3;
    }
#line 344
    if ((unsigned long )((void *)0) == (unsigned long )tmp_p) {
      {
#line 346
      error_message(1004, ")");
      }
#line 347
      return (0);
    }
    {
#line 349
    *tmp_p = (char )'\000';
#line 350
    tmp___4 = strchr((char const   *)(name___0), ' ');
#line 350
    tmp_p = tmp___4;
    }
#line 351
    if ((unsigned long )((void *)0) != (unsigned long )tmp_p) {
#line 353
      *tmp_p = (char )'\000';
    }
    {
#line 355
    char_counter += w;
#line 355
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)(name___0));
#line 356
    s ++;
#line 357
    spf[s].fp = fopen((char const   */* __restrict  */)(name___0), (char const   */* __restrict  */)"r");
    }
#line 358
    if ((unsigned long )((void *)0) == (unsigned long )spf[s].fp) {
      {
#line 360
      *(yytext + 0) = (char )'\000';
#line 360
      s --;
#line 361
      strcpy((char */* __restrict  */)yytext, (char const   */* __restrict  */)(name___0));
#line 362
      error_message(1011);
      }
#line 363
      return (0);
    }
    {
#line 365
    tmp___6 = strlen((char const   *)(name___0));
#line 365
    tmp___7 = allocate(tmp___6 + 1U, 0U);
#line 365
    tmp___5 = tmp___7;
#line 365
    spf[s].name = tmp___5;
    }
#line 365
    if ((unsigned long )((void *)0) == (unsigned long )tmp___5) {
      {
#line 368
      error_message(4002);
      }
#line 369
      return (0);
    }
    {
#line 371
    strcpy((char */* __restrict  */)spf[s].name, (char const   */* __restrict  */)(name___0));
#line 372
    spf[s].line_counter = 1;
#line 374
    tmp___8 = yy_create_buffer(spf[s].fp, 16384);
#line 374
    yy_switch_to_buffer(tmp___8);
    }
#line 380
    goto switch_break;
    case_21: /* CIL Label */ 
#line 380
    wide_string = 0;
#line 381
    char_counter += yyleng;
#line 382
    if ((int )*(yytext + 0) == 108) {
      {
#line 384
      error_message(1040);
#line 385
      error_message(1039, "string");
      }
    } else
#line 387
    if ((int )*(yytext + 0) == 76) {
#line 388
      wide_string = 1;
    }
    {
#line 389
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
#line 390
    s_conv(yytext);
#line 394
    yylval.mystring = string(yytext);
    }
#line 395
    if (wide_string) {
#line 396
      return (265);
    } else {
#line 398
      return (264);
    }
#line 400
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 400
    char_counter += yyleng;
#line 400
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 400
    return (315);
#line 401
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 401
    char_counter += yyleng;
#line 401
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 401
    return (314);
#line 402
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 402
    char_counter += yyleng;
#line 402
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 402
    return (312);
#line 403
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 403
    char_counter += yyleng;
#line 403
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 403
    return (313);
#line 404
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 404
    char_counter += yyleng;
#line 404
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 404
    return (309);
#line 405
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 405
    char_counter += yyleng;
#line 405
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 405
    return (310);
#line 406
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 406
    char_counter += yyleng;
#line 406
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 406
    return (311);
#line 407
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 407
    char_counter += yyleng;
#line 407
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 407
    return (316);
#line 408
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 408
    char_counter += yyleng;
#line 408
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 408
    return (317);
#line 409
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 409
    char_counter += yyleng;
#line 409
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 409
    return (318);
#line 410
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 410
    char_counter += yyleng;
#line 410
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 410
    return (320);
#line 411
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 411
    char_counter += yyleng;
#line 411
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 411
    return (319);
#line 412
    goto switch_break;
    case_34___0: /* CIL Label */ 
    {
#line 412
    char_counter += yyleng;
#line 412
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 412
    return (321);
#line 413
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 413
    char_counter += yyleng;
#line 413
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 413
    return (324);
#line 414
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 414
    char_counter += yyleng;
#line 414
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 414
    return (323);
#line 415
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 415
    char_counter += yyleng;
#line 415
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 415
    return (322);
#line 416
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 416
    char_counter += yyleng;
#line 416
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 416
    return (329);
#line 417
    goto switch_break;
    case_39___0: /* CIL Label */ 
    {
#line 417
    char_counter += yyleng;
#line 417
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 417
    return (330);
#line 418
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 418
    char_counter += yyleng;
#line 418
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 418
    return (327);
#line 419
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 419
    char_counter += yyleng;
#line 419
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 419
    return (328);
#line 420
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 420
    char_counter += yyleng;
#line 420
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 420
    return (326);
#line 421
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 421
    char_counter += yyleng;
#line 421
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 421
    return (325);
#line 422
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 422
    char_counter += yyleng;
#line 422
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 422
    return (331);
#line 423
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 423
    char_counter += yyleng;
#line 424
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"#");
#line 425
    error_message(6032);
    }
#line 426
    return ('#');
#line 428
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 428
    char_counter += yyleng;
#line 429
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"[");
#line 430
    error_message(6032);
    }
#line 431
    return ('[');
#line 433
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 433
    char_counter += yyleng;
#line 434
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"\\");
#line 435
    error_message(6032);
    }
#line 436
    return ('\\');
#line 438
    goto switch_break;
    case_48: /* CIL Label */ 
    {
#line 438
    char_counter += yyleng;
#line 439
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"]");
#line 440
    error_message(6032);
    }
#line 441
    return (']');
#line 443
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 443
    char_counter += yyleng;
#line 444
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"^");
#line 445
    error_message(6032);
    }
#line 446
    return ('^');
#line 448
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 448
    char_counter += yyleng;
#line 449
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"{");
#line 450
    error_message(6032);
    }
#line 451
    return ('{');
#line 453
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 453
    char_counter += yyleng;
#line 454
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"|");
#line 455
    error_message(6032);
    }
#line 456
    return ('|');
#line 458
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 458
    char_counter += yyleng;
#line 459
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"}");
#line 460
    error_message(6032);
    }
#line 461
    return ('}');
#line 463
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 463
    char_counter += yyleng;
#line 464
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)"~");
#line 465
    error_message(6032);
    }
#line 466
    return ('~');
#line 468
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 469
    char_counter += yyleng;
#line 469
    strcat((char */* __restrict  */)(line_buf), (char const   */* __restrict  */)yytext);
    }
#line 469
    return ((int )*yytext);
#line 473
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 473
    fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1, (FILE */* __restrict  */)yyout);
    }
#line 474
    goto switch_break;
    case_57: /* CIL Label */ 
#line 1478 "lex.yy.c"
    return (0);
    case_56: /* CIL Label */ 
#line 1483
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1486
    *yy_cp = yy_hold_char;
#line 1489
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1500
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1501
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
#line 1502
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1512
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1516
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1518
      yy_current_state = yy_get_previous_state();
#line 1529
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1531
      yy_bp = yytext + 0;
      }
#line 1533
      if (yy_next_state) {
#line 1536
        yy_c_buf_p ++;
#line 1536
        yy_cp = yy_c_buf_p;
#line 1537
        yy_current_state = yy_next_state;
#line 1538
        goto yy_match;
      } else {
#line 1543
        yy_cp = yy_c_buf_p;
#line 1544
        goto yy_find_action;
      }
    } else {
      {
#line 1548
      tmp___9 = yy_get_next_buffer();
      }
      {
#line 1550
      if (tmp___9 == 1) {
#line 1550
        goto case_1___0;
      }
#line 1579
      if (tmp___9 == 0) {
#line 1579
        goto case_0___0;
      }
#line 1589
      if (tmp___9 == 2) {
#line 1589
        goto case_2___0;
      }
#line 1548
      goto switch_break___1;
      case_1___0: /* CIL Label */ 
      {
#line 1552
      yy_did_buffer_switch_on_eof = 0;
#line 1554
      tmp___10 = yywrap();
      }
#line 1554
      if (tmp___10) {
#line 1565
        yy_c_buf_p = yytext + 0;
#line 1567
        yy_act = (56 + (yy_start - 1) / 2) + 1;
#line 1568
        goto do_action;
      } else
#line 1573
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1574
        yyrestart(yyin);
        }
      }
#line 1576
      goto switch_break___1;
      case_0___0: /* CIL Label */ 
      {
#line 1580
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1583
      yy_current_state = yy_get_previous_state();
#line 1585
      yy_cp = yy_c_buf_p;
#line 1586
      yy_bp = yytext + 0;
      }
#line 1587
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1590
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1593
      yy_current_state = yy_get_previous_state();
#line 1595
      yy_cp = yy_c_buf_p;
#line 1596
      yy_bp = yytext + 0;
      }
#line 1597
      goto yy_find_action;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 1599
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 1603
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1616 "lex.yy.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___2 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___3 ;
  int c ;
  size_t n ;
  size_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 1618
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1619
  source = yytext;
#line 1623
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1624
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1627
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1629
    if (yy_c_buf_p - yytext == 1L) {
#line 1634
      return (1);
    } else {
#line 1642
      return (2);
    }
  }
#line 1649
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1651
  i = 0;
  {
#line 1651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1651
    if (! (i < number_to_move)) {
#line 1651
      goto while_break;
    }
#line 1652
    tmp___0 = dest;
#line 1652
    dest ++;
#line 1652
    tmp___1 = source;
#line 1652
    source ++;
#line 1652
    *tmp___0 = *tmp___1;
#line 1651
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1654
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1658
    yy_n_chars = 0;
#line 1658
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1662
    num_to_read = ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U;
    {
#line 1665
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1665
      if (! (num_to_read <= 0U)) {
#line 1665
        goto while_break___0;
      }
#line 1669
      if (yy_buffer_stack) {
#line 1669
        tmp___2 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1669
        tmp___2 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1669
      b = tmp___2;
#line 1671
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1674
      if (b->yy_is_our_buffer) {
#line 1676
        new_size = (int )(b->yy_buf_size * 2U);
#line 1678
        if (new_size <= 0) {
#line 1679
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1681
          b->yy_buf_size *= 2U;
        }
        {
#line 1683
        tmp___3 = yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1683
        b->yy_ch_buf = (char *)tmp___3;
        }
      } else {
#line 1689
        b->yy_ch_buf = (char *)0;
      }
#line 1691
      if (! b->yy_ch_buf) {
        {
#line 1692
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1695
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1697
      num_to_read = ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1702
    if (num_to_read > 8192U) {
#line 1703
      num_to_read = (size_t )8192;
    }
#line 1706
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1706
      c = '*';
#line 1706
      n = (size_t )0;
      {
#line 1706
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1706
        if (n < num_to_read) {
          {
#line 1706
          c = _IO_getc(yyin);
          }
#line 1706
          if (c != -1) {
#line 1706
            if (! (c != 10)) {
#line 1706
              goto while_break___1;
            }
          } else {
#line 1706
            goto while_break___1;
          }
        } else {
#line 1706
          goto while_break___1;
        }
#line 1706
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1706
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1706
      if (c == 10) {
#line 1706
        tmp___4 = n;
#line 1706
        n ++;
#line 1706
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___4) = (char )c;
      }
#line 1706
      if (c == -1) {
        {
#line 1706
        tmp___5 = ferror(yyin);
        }
#line 1706
        if (tmp___5) {
          {
#line 1706
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1706
      yy_n_chars = (int )n;
    } else {
      {
#line 1706
      tmp___6 = __errno_location();
#line 1706
      *tmp___6 = 0;
      }
      {
#line 1706
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1706
        tmp___9 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, num_to_read, (FILE */* __restrict  */)yyin);
#line 1706
        yy_n_chars = (int )tmp___9;
        }
#line 1706
        if (yy_n_chars == 0) {
          {
#line 1706
          tmp___10 = ferror(yyin);
          }
#line 1706
          if (! tmp___10) {
#line 1706
            goto while_break___2;
          }
        } else {
#line 1706
          goto while_break___2;
        }
        {
#line 1706
        tmp___7 = __errno_location();
        }
#line 1706
        if (*tmp___7 != 4) {
          {
#line 1706
          yy_fatal_error("input in flex scanner failed");
          }
#line 1706
          goto while_break___2;
        }
        {
#line 1706
        tmp___8 = __errno_location();
#line 1706
        *tmp___8 = 0;
#line 1706
        clearerr(yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1709
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1712
  if (yy_n_chars == 0) {
#line 1714
    if (number_to_move == 0) {
      {
#line 1716
      ret_val = 1;
#line 1717
      yyrestart(yyin);
      }
    } else {
#line 1722
      ret_val = 2;
#line 1723
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1729
    ret_val = 0;
  }
#line 1731
  yy_n_chars += number_to_move;
#line 1732
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1733
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1735
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1737
  return (ret_val);
}
}
#line 1742 "lex.yy.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp___0 ;

  {
#line 1747
  yy_current_state = yy_start;
#line 1749
  yy_cp = yytext + 0;
  {
#line 1749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1749
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1749
      goto while_break;
    }
#line 1751
    if (*yy_cp) {
#line 1751
      tmp___0 = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1751
      tmp___0 = (flex_int32_t const   )1;
    }
#line 1751
    yy_c = (YY_CHAR )tmp___0;
#line 1752
    if (yy_accept[yy_current_state]) {
#line 1754
      yy_last_accepting_state = yy_current_state;
#line 1755
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1757
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1757
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1757
        goto while_break___0;
      }
#line 1759
      yy_current_state = (int )yy_def[yy_current_state];
#line 1760
      if (yy_current_state >= 130) {
#line 1761
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1763
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1749
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1766
  return (yy_current_state);
}
}
#line 1774 "lex.yy.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp___0 ;

  {
#line 1777
  yy_cp = yy_c_buf_p;
#line 1779
  yy_c = (YY_CHAR )1;
#line 1780
  if (yy_accept[yy_current_state]) {
#line 1782
    yy_last_accepting_state = yy_current_state;
#line 1783
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1785
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1785
      goto while_break;
    }
#line 1787
    yy_current_state = (int )yy_def[yy_current_state];
#line 1788
    if (yy_current_state >= 130) {
#line 1789
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1791
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1792
  yy_is_jam = yy_current_state == 129;
#line 1794
  if (yy_is_jam) {
#line 1794
    tmp___0 = 0;
  } else {
#line 1794
    tmp___0 = yy_current_state;
  }
#line 1794
  return (tmp___0);
}
}
#line 1838 "lex.yy.c"
static int input___0(void) 
{ 
  int c ;
  int offset ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1844
  *yy_c_buf_p = yy_hold_char;
#line 1846
  if ((int )*yy_c_buf_p == 0) {
#line 1852
    if ((unsigned long )yy_c_buf_p < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
#line 1854
      *yy_c_buf_p = (char )'\000';
    } else {
      {
#line 1858
      offset = (int )(yy_c_buf_p - yytext);
#line 1859
      yy_c_buf_p ++;
#line 1861
      tmp___0 = yy_get_next_buffer();
      }
      {
#line 1863
      if (tmp___0 == 2) {
#line 1863
        goto case_2;
      }
#line 1879
      if (tmp___0 == 1) {
#line 1879
        goto case_1;
      }
#line 1893
      if (tmp___0 == 0) {
#line 1893
        goto case_0;
      }
#line 1861
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1875
      yyrestart(yyin);
      }
      case_1: /* CIL Label */ 
      {
#line 1881
      tmp___1 = yywrap();
      }
#line 1881
      if (tmp___1) {
#line 1882
        return (-1);
      }
#line 1884
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1885
        yyrestart(yyin);
        }
      }
      {
#line 1889
      tmp___2 = input___0();
      }
#line 1889
      return (tmp___2);
      case_0: /* CIL Label */ 
#line 1894
      yy_c_buf_p = yytext + offset;
#line 1895
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1900
  c = (int )*((unsigned char *)yy_c_buf_p);
#line 1901
  *yy_c_buf_p = (char )'\000';
#line 1902
  yy_c_buf_p ++;
#line 1902
  yy_hold_char = *yy_c_buf_p;
#line 1904
  return (c);
}
}
#line 1913 "lex.yy.c"
void yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1916
  if (yy_buffer_stack) {
#line 1916
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1916
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1916
  if (! tmp___0) {
    {
#line 1917
    yyensure_buffer_stack();
#line 1918
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 1922
  if (yy_buffer_stack) {
#line 1922
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1922
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1922
  yy_init_buffer(tmp___1, input_file);
#line 1923
  yy_load_buffer_state();
  }
#line 1924
  return;
}
}
#line 1930 "lex.yy.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
  {
#line 1938
  yyensure_buffer_stack();
  }
#line 1939
  if (yy_buffer_stack) {
#line 1939
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1939
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1939
  if ((unsigned long )tmp___0 == (unsigned long )new_buffer) {
#line 1940
    return;
  }
#line 1942
  if (yy_buffer_stack) {
#line 1942
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1942
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1942
  if (tmp___1) {
#line 1945
    *yy_c_buf_p = yy_hold_char;
#line 1946
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1947
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1950
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1951
  yy_load_buffer_state();
#line 1958
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1959
  return;
}
}
#line 1961 "lex.yy.c"
static void yy_load_buffer_state(void) 
{ 


  {
#line 1963
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1964
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1964
  yytext = yy_c_buf_p;
#line 1965
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1966
  yy_hold_char = *yy_c_buf_p;
#line 1967
  return;
}
}
#line 1975 "lex.yy.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1979
  tmp___0 = yyalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1979
  b = (YY_BUFFER_STATE )tmp___0;
  }
#line 1980
  if (! b) {
    {
#line 1981
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1983
  b->yy_buf_size = (yy_size_t )size;
#line 1988
  tmp___1 = yyalloc(b->yy_buf_size + 2U);
#line 1988
  b->yy_ch_buf = (char *)tmp___1;
  }
#line 1989
  if (! b->yy_ch_buf) {
    {
#line 1990
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1992
  b->yy_is_our_buffer = 1;
#line 1994
  yy_init_buffer(b, file);
  }
#line 1996
  return (b);
}
}
#line 2003 "lex.yy.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2006
  if (! b) {
#line 2007
    return;
  }
#line 2009
  if (yy_buffer_stack) {
#line 2009
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2009
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2009
  if ((unsigned long )b == (unsigned long )tmp___0) {
#line 2010
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 2012
  if (b->yy_is_our_buffer) {
    {
#line 2013
    yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 2015
  yyfree((void *)b);
  }
#line 2016
  return;
}
}
#line 2026 "lex.yy.c"
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 2029
  tmp___0 = __errno_location();
#line 2029
  oerrno = *tmp___0;
#line 2031
  yy_flush_buffer(b);
#line 2033
  b->yy_input_file = file;
#line 2034
  b->yy_fill_buffer = 1;
  }
#line 2040
  if (yy_buffer_stack) {
#line 2040
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2040
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2040
  if ((unsigned long )b != (unsigned long )tmp___1) {
#line 2041
    b->yy_bs_lineno = 1;
#line 2042
    b->yy_bs_column = 0;
  }
#line 2045
  if (file) {
    {
#line 2045
    tmp___2 = fileno(file);
#line 2045
    tmp___3 = isatty(tmp___2);
#line 2045
    b->yy_is_interactive = tmp___3 > 0;
    }
  } else {
#line 2045
    b->yy_is_interactive = 0;
  }
  {
#line 2047
  tmp___4 = __errno_location();
#line 2047
  *tmp___4 = oerrno;
  }
#line 2048
  return;
}
}
#line 2054 "lex.yy.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2056
  if (! b) {
#line 2057
    return;
  }
#line 2059
  b->yy_n_chars = 0;
#line 2065
  *(b->yy_ch_buf + 0) = (char)0;
#line 2066
  *(b->yy_ch_buf + 1) = (char)0;
#line 2068
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2070
  b->yy_at_bol = 1;
#line 2071
  b->yy_buffer_status = 0;
#line 2073
  if (yy_buffer_stack) {
#line 2073
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2073
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2073
  if ((unsigned long )b == (unsigned long )tmp___0) {
    {
#line 2074
    yy_load_buffer_state();
    }
  }
#line 2075
  return;
}
}
#line 2083 "lex.yy.c"
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2085
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2086
    return;
  }
  {
#line 2088
  yyensure_buffer_stack();
  }
#line 2091
  if (yy_buffer_stack) {
#line 2091
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2091
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2091
  if (tmp___0) {
#line 2094
    *yy_c_buf_p = yy_hold_char;
#line 2095
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 2096
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 2100
  if (yy_buffer_stack) {
#line 2100
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2100
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2100
  if (tmp___1) {
#line 2101
    yy_buffer_stack_top ++;
  }
  {
#line 2102
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 2105
  yy_load_buffer_state();
#line 2106
  yy_did_buffer_switch_on_eof = 1;
  }
#line 2107
  return;
}
}
#line 2113 "lex.yy.c"
void yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;
  YY_BUFFER_STATE tmp___2 ;

  {
#line 2115
  if (yy_buffer_stack) {
#line 2115
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2115
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2115
  if (! tmp___0) {
#line 2116
    return;
  }
#line 2118
  if (yy_buffer_stack) {
#line 2118
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2118
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2118
  yy_delete_buffer(tmp___1);
#line 2119
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2120
  if (yy_buffer_stack_top > 0U) {
#line 2121
    yy_buffer_stack_top --;
  }
#line 2123
  if (yy_buffer_stack) {
#line 2123
    tmp___2 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2123
    tmp___2 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2123
  if (tmp___2) {
    {
#line 2124
    yy_load_buffer_state();
#line 2125
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2127
  return;
}
}
#line 2132 "lex.yy.c"
static void yyensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp___0 ;
  int grow_size ;
  void *tmp___1 ;

  {
#line 2136
  if (! yy_buffer_stack) {
    {
#line 2142
    num_to_alloc = 1;
#line 2143
    tmp___0 = yyalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2143
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
#line 2147
    memset((void *)yy_buffer_stack, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2149
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 2150
    yy_buffer_stack_top = (size_t )0;
    }
#line 2151
    return;
  }
#line 2154
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1U) {
    {
#line 2157
    grow_size = 8;
#line 2159
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 2160
    tmp___1 = yyrealloc((void *)yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2160
    yy_buffer_stack = (struct yy_buffer_state **)tmp___1;
#line 2166
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 2167
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2169
  return;
}
}
#line 2177 "lex.yy.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 2181
  if (size < 2U) {
#line 2185
    return ((YY_BUFFER_STATE )0);
  } else
#line 2181
  if ((int )*(base + (size - 2U)) != 0) {
#line 2185
    return ((YY_BUFFER_STATE )0);
  } else
#line 2181
  if ((int )*(base + (size - 1U)) != 0) {
#line 2185
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2187
  tmp___0 = yyalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 2187
  b = (YY_BUFFER_STATE )tmp___0;
  }
#line 2188
  if (! b) {
    {
#line 2189
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 2191
  b->yy_buf_size = size - 2U;
#line 2192
  tmp___1 = base;
#line 2192
  b->yy_ch_buf = tmp___1;
#line 2192
  b->yy_buf_pos = tmp___1;
#line 2193
  b->yy_is_our_buffer = 0;
#line 2194
  b->yy_input_file = (FILE *)0;
#line 2195
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2196
  b->yy_is_interactive = 0;
#line 2197
  b->yy_at_bol = 1;
#line 2198
  b->yy_fill_buffer = 0;
#line 2199
  b->yy_buffer_status = 0;
#line 2201
  yy_switch_to_buffer(b);
  }
#line 2203
  return (b);
}
}
#line 2215 "lex.yy.c"
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) 
{ 
  size_t tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
  {
#line 2218
  tmp___0 = strlen(yy_str);
#line 2218
  tmp___1 = yy_scan_bytes(yy_str, (int )tmp___0);
  }
#line 2218
  return (tmp___1);
}
}
#line 2228 "lex.yy.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp___0 ;
  char tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2236
  n = (yy_size_t )(len + 2);
#line 2237
  tmp___0 = yyalloc(n);
#line 2237
  buf = (char *)tmp___0;
  }
#line 2238
  if (! buf) {
    {
#line 2239
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 2241
  i = 0;
  {
#line 2241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2241
    if (! (i < len)) {
#line 2241
      goto while_break;
    }
#line 2242
    *(buf + i) = (char )*(bytes + i);
#line 2241
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2244
  tmp___1 = (char)0;
#line 2244
  *(buf + (len + 1)) = tmp___1;
#line 2244
  *(buf + len) = tmp___1;
#line 2246
  b = yy_scan_buffer(buf, n);
  }
#line 2247
  if (! b) {
    {
#line 2248
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 2253
  b->yy_is_our_buffer = 1;
#line 2255
  return (b);
}
}
#line 2262 "lex.yy.c"
static void yy_fatal_error(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 2264
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2265
  exit(2);
  }
}
}
#line 2290 "lex.yy.c"
int yyget_lineno(void) 
{ 


  {
#line 2293
  return (yylineno);
}
}
#line 2299 "lex.yy.c"
FILE *yyget_in(void) 
{ 


  {
#line 2301
  return (yyin);
}
}
#line 2307 "lex.yy.c"
FILE *yyget_out(void) 
{ 


  {
#line 2309
  return (yyout);
}
}
#line 2315 "lex.yy.c"
int yyget_leng(void) 
{ 


  {
#line 2317
  return (yyleng);
}
}
#line 2324 "lex.yy.c"
char *yyget_text(void) 
{ 


  {
#line 2326
  return (yytext);
}
}
#line 2333 "lex.yy.c"
void yyset_lineno(int line_number ) 
{ 


  {
#line 2336
  yylineno = line_number;
#line 2337
  return;
}
}
#line 2345 "lex.yy.c"
void yyset_in(FILE *in_str ) 
{ 


  {
#line 2347
  yyin = in_str;
#line 2348
  return;
}
}
#line 2350 "lex.yy.c"
void yyset_out(FILE *out_str ) 
{ 


  {
#line 2352
  yyout = out_str;
#line 2353
  return;
}
}
#line 2355 "lex.yy.c"
int yyget_debug(void) 
{ 


  {
#line 2357
  return (yy_flex_debug);
}
}
#line 2360 "lex.yy.c"
void yyset_debug(int bdebug ) 
{ 


  {
#line 2362
  yy_flex_debug = bdebug;
#line 2363
  return;
}
}
#line 2366 "lex.yy.c"
int yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
  {
#line 2370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2370
    if (yy_buffer_stack) {
#line 2370
      tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2370
      tmp___1 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2370
    if (! tmp___1) {
#line 2370
      goto while_break;
    }
#line 2371
    if (yy_buffer_stack) {
#line 2371
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2371
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2371
    yy_delete_buffer(tmp___0);
#line 2372
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2373
    yypop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2377
  yyfree((void *)yy_buffer_stack);
#line 2378
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
  }
#line 2380
  return (0);
}
}
#line 2407 "lex.yy.c"
void *yyalloc(yy_size_t size ) 
{ 
  void *tmp___0 ;

  {
  {
#line 2409
  tmp___0 = malloc(size);
  }
#line 2409
  return (tmp___0);
}
}
#line 2412 "lex.yy.c"
void *yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp___0 ;

  {
  {
#line 2421
  tmp___0 = realloc((void *)((char *)ptr), size);
  }
#line 2421
  return (tmp___0);
}
}
#line 2424 "lex.yy.c"
void yyfree(void *ptr ) 
{ 


  {
  {
#line 2426
  free((void *)((char *)ptr));
  }
#line 2427
  return;
}
}
#line 486 "ls.l"
static int find_ident(char *s___0 , int len ) 
{ 
  register struct el_mc *ret_val ;

  {
  {
#line 492
  ret_val = in_word_set(s___0, (unsigned int )len);
  }
#line 493
  if (ret_val) {
#line 494
    return (ret_val->kval);
  } else {
#line 496
    return (0);
  }
}
}
#line 499 "ls.l"
int yywrap(void) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 503
  tmp___0 = switch_to_buffer();
  }
#line 503
  if (tmp___0) {
#line 503
    tmp___1 = 0;
  } else {
#line 503
    tmp___1 = 1;
  }
#line 503
  return (tmp___1);
}
}
#line 533 "ls.l"
void switch_to_stdin(void) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
  {
#line 536
  s ++;
#line 537
  spf[s] = spf[0];
#line 538
  tmp___0 = yy_create_buffer(stdin, 16384);
#line 538
  yy_switch_to_buffer(tmp___0);
  }
#line 539
  if (yy_buffer_stack) {
#line 539
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 539
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 539
  if (! tmp___1) {
    {
#line 539
    yyensure_buffer_stack();
#line 539
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 539
  (*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive = 1;
#line 540
  return;
}
}
#line 542 "ls.l"
void switch_to_char_buffer(void) 
{ 


  {
  {
#line 545
  yy_scan_string((char const   *)(string_resume));
  }
#line 546
  return;
}
}
#line 548 "ls.l"
int switch_to_buffer(void) 
{ 
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;
  int tmp___2 ;

  {
  {
#line 551
  tmp___2 = terminate_buffer();
  }
#line 551
  if (tmp___2) {
#line 552
    return (0);
  } else {
#line 555
    if (yy_buffer_stack) {
#line 555
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 555
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 555
    yy_delete_buffer(tmp___0);
#line 556
    tmp___1 = yy_create_buffer(spf[s].fp, 16384);
#line 556
    yy_switch_to_buffer(tmp___1);
    }
  }
#line 559
  return (1);
}
}
#line 562 "ls.l"
void *store_buffer_state(void) 
{ 
  YY_BUFFER_STATE *state ;
  char *tmp___0 ;

  {
  {
#line 566
  tmp___0 = allocate((unsigned int )sizeof(YY_BUFFER_STATE ), 0U);
#line 566
  state = (YY_BUFFER_STATE *)tmp___0;
  }
#line 567
  if (yy_buffer_stack) {
#line 567
    *state = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 567
    *state = (YY_BUFFER_STATE )((void *)0);
  }
#line 568
  return ((void *)state);
}
}
#line 571 "ls.l"
void flush_buffer(void *state ) 
{ 
  YY_BUFFER_STATE tmp___0 ;

  {
#line 575
  if (yy_buffer_stack) {
#line 575
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 575
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 575
  yy_flush_buffer(tmp___0);
#line 576
  yy_switch_to_buffer(*((YY_BUFFER_STATE *)state));
  }
#line 580
  return;
}
}
#line 32 "/home/wslee/benchmarks/clif-0.93/parser.h"
static int param_flag  =    0;
#line 33 "/home/wslee/benchmarks/clif-0.93/parser.h"
static int atom_type_flag  =    0;
#line 35 "/home/wslee/benchmarks/clif-0.93/parser.h"
struct var_s variable[256]  ;
#line 43 "/home/wslee/benchmarks/clif-0.93/parser.h"
static int it_is_in_case  =    0;
#line 45 "/home/wslee/benchmarks/clif-0.93/parser.h"
static char *jmp1  ;
#line 51 "/home/wslee/benchmarks/clif-0.93/parser.h"
static int subscript_flag[256]  ;
#line 53 "/home/wslee/benchmarks/clif-0.93/parser.h"
static int is_address  =    0;
#line 59 "/home/wslee/benchmarks/clif-0.93/parser.h"
static int struct_union_field[256]  ;
#line 61 "/home/wslee/benchmarks/clif-0.93/parser.h"
static char *or_jmp[256]  ;
#line 61 "/home/wslee/benchmarks/clif-0.93/parser.h"
static char *and_jmp[256]  ;
#line 65 "/home/wslee/benchmarks/clif-0.93/parser.h"
int main_defined  ;
#line 67 "/home/wslee/benchmarks/clif-0.93/parser.h"
static int initialize_only  ;
#line 70 "/home/wslee/benchmarks/clif-0.93/parser.h"
static int full_bracketing  ;
#line 73 "/home/wslee/benchmarks/clif-0.93/parser.h"
static int aggregate_memory_size[256]  ;
#line 111 "ys.y"
static char const   yytranslate[332]  = 
#line 111 "ys.y"
  {      (char const   )0,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )85,      (char const   )72,      (char const   )2, 
        (char const   )90,      (char const   )91,      (char const   )83,      (char const   )81, 
        (char const   )99,      (char const   )82,      (char const   )94,      (char const   )84, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )55,      (char const   )96, 
        (char const   )75,      (char const   )67,      (char const   )77,      (char const   )56, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )92, 
        (char const   )2,      (char const   )93,      (char const   )71,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )98, 
        (char const   )70,      (char const   )97,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )1,      (char const   )3,      (char const   )4,      (char const   )5, 
        (char const   )6,      (char const   )7,      (char const   )8,      (char const   )9, 
        (char const   )10,      (char const   )11,      (char const   )12,      (char const   )13, 
        (char const   )14,      (char const   )15,      (char const   )16,      (char const   )17, 
        (char const   )18,      (char const   )19,      (char const   )20,      (char const   )21, 
        (char const   )22,      (char const   )23,      (char const   )24,      (char const   )25, 
        (char const   )26,      (char const   )27,      (char const   )28,      (char const   )29, 
        (char const   )30,      (char const   )31,      (char const   )32,      (char const   )33, 
        (char const   )34,      (char const   )35,      (char const   )36,      (char const   )37, 
        (char const   )38,      (char const   )39,      (char const   )40,      (char const   )41, 
        (char const   )42,      (char const   )43,      (char const   )44,      (char const   )45, 
        (char const   )46,      (char const   )47,      (char const   )48,      (char const   )49, 
        (char const   )50,      (char const   )51,      (char const   )52,      (char const   )53, 
        (char const   )54,      (char const   )57,      (char const   )58,      (char const   )59, 
        (char const   )60,      (char const   )61,      (char const   )62,      (char const   )63, 
        (char const   )64,      (char const   )65,      (char const   )66,      (char const   )68, 
        (char const   )69,      (char const   )73,      (char const   )74,      (char const   )76, 
        (char const   )78,      (char const   )79,      (char const   )80,      (char const   )86, 
        (char const   )87,      (char const   )88,      (char const   )89,      (char const   )95};
#line 149 "ys.y"
static short const   yyprhs[358]  = 
#line 149
  {      (short const   )0,      (short const   )0,      (short const   )3,      (short const   )4, 
        (short const   )7,      (short const   )8,      (short const   )10,      (short const   )12, 
        (short const   )15,      (short const   )17,      (short const   )20,      (short const   )22, 
        (short const   )26,      (short const   )28,      (short const   )31,      (short const   )34, 
        (short const   )37,      (short const   )40,      (short const   )44,      (short const   )47, 
        (short const   )49,      (short const   )52,      (short const   )54,      (short const   )57, 
        (short const   )59,      (short const   )62,      (short const   )63,      (short const   )67, 
        (short const   )76,      (short const   )85,      (short const   )89,      (short const   )91, 
        (short const   )93,      (short const   )96,      (short const   )98,      (short const   )100, 
        (short const   )102,      (short const   )105,      (short const   )108,      (short const   )109, 
        (short const   )116,      (short const   )117,      (short const   )124,      (short const   )125, 
        (short const   )126,      (short const   )134,      (short const   )135,      (short const   )144, 
        (short const   )148,      (short const   )150,      (short const   )152,      (short const   )154, 
        (short const   )155,      (short const   )161,      (short const   )162,      (short const   )167, 
        (short const   )168,      (short const   )173,      (short const   )174,      (short const   )178, 
        (short const   )181,      (short const   )183,      (short const   )185,      (short const   )187, 
        (short const   )189,      (short const   )191,      (short const   )193,      (short const   )195, 
        (short const   )197,      (short const   )199,      (short const   )201,      (short const   )203, 
        (short const   )205,      (short const   )207,      (short const   )209,      (short const   )211, 
        (short const   )213,      (short const   )216,      (short const   )219,      (short const   )223, 
        (short const   )225,      (short const   )228,      (short const   )229,      (short const   )236, 
        (short const   )237,      (short const   )243,      (short const   )246,      (short const   )248, 
        (short const   )250,      (short const   )252,      (short const   )255,      (short const   )260, 
        (short const   )262,      (short const   )265,      (short const   )267,      (short const   )270, 
        (short const   )272,      (short const   )276,      (short const   )278,      (short const   )281, 
        (short const   )285,      (short const   )286,      (short const   )292,      (short const   )293, 
        (short const   )300,      (short const   )303,      (short const   )305,      (short const   )309, 
        (short const   )311,      (short const   )315,      (short const   )318,      (short const   )320, 
        (short const   )322,      (short const   )325,      (short const   )327,      (short const   )328, 
        (short const   )332,      (short const   )335,      (short const   )339,      (short const   )341, 
        (short const   )342,      (short const   )347,      (short const   )350,      (short const   )354, 
        (short const   )356,      (short const   )358,      (short const   )361,      (short const   )365, 
        (short const   )368,      (short const   )372,      (short const   )376,      (short const   )381, 
        (short const   )384,      (short const   )388,      (short const   )392,      (short const   )397, 
        (short const   )399,      (short const   )401,      (short const   )403,      (short const   )405, 
        (short const   )407,      (short const   )409,      (short const   )412,      (short const   )413, 
        (short const   )419,      (short const   )423,      (short const   )429,      (short const   )431, 
        (short const   )433,      (short const   )439,      (short const   )446,      (short const   )451, 
        (short const   )452,      (short const   )456,      (short const   )457,      (short const   )462, 
        (short const   )463,      (short const   )468,      (short const   )469,      (short const   )475, 
        (short const   )476,      (short const   )481,      (short const   )482,      (short const   )488, 
        (short const   )490,      (short const   )491,      (short const   )495,      (short const   )496, 
        (short const   )501,      (short const   )502,      (short const   )507,      (short const   )508, 
        (short const   )513,      (short const   )514,      (short const   )518,      (short const   )519, 
        (short const   )523,      (short const   )524,      (short const   )529,      (short const   )530, 
        (short const   )535,      (short const   )538,      (short const   )539,      (short const   )543, 
        (short const   )544,      (short const   )549,      (short const   )550,      (short const   )555, 
        (short const   )556,      (short const   )561,      (short const   )562,      (short const   )568, 
        (short const   )569,      (short const   )575,      (short const   )578,      (short const   )581, 
        (short const   )585,      (short const   )586,      (short const   )591,      (short const   )592, 
        (short const   )595,      (short const   )596,      (short const   )601,      (short const   )603, 
        (short const   )605,      (short const   )606,      (short const   )611,      (short const   )612, 
        (short const   )613,      (short const   )620,      (short const   )621,      (short const   )626, 
        (short const   )631,      (short const   )632,      (short const   )639,      (short const   )640, 
        (short const   )644,      (short const   )645,      (short const   )652,      (short const   )657, 
        (short const   )658,      (short const   )666,      (short const   )671,      (short const   )672, 
        (short const   )680,      (short const   )686,      (short const   )687,      (short const   )696, 
        (short const   )699,      (short const   )703,      (short const   )708,      (short const   )712, 
        (short const   )716,      (short const   )717,      (short const   )723,      (short const   )724, 
        (short const   )728,      (short const   )729,      (short const   )734,      (short const   )735, 
        (short const   )741,      (short const   )742,      (short const   )749,      (short const   )750, 
        (short const   )757,      (short const   )758,      (short const   )763,      (short const   )764, 
        (short const   )770,      (short const   )771,      (short const   )778,      (short const   )779, 
        (short const   )787,      (short const   )788,      (short const   )796,      (short const   )799, 
        (short const   )800,      (short const   )805,      (short const   )808,      (short const   )809, 
        (short const   )814,      (short const   )818,      (short const   )822,      (short const   )823, 
        (short const   )826,      (short const   )828,      (short const   )830,      (short const   )833, 
        (short const   )834,      (short const   )839,      (short const   )841,      (short const   )843, 
        (short const   )845,      (short const   )847,      (short const   )849,      (short const   )851, 
        (short const   )853,      (short const   )855,      (short const   )857,      (short const   )859, 
        (short const   )861,      (short const   )865,      (short const   )867,      (short const   )869, 
        (short const   )870,      (short const   )876,      (short const   )880,      (short const   )884, 
        (short const   )887,      (short const   )890,      (short const   )891,      (short const   )896, 
        (short const   )898,      (short const   )901,      (short const   )904,      (short const   )907, 
        (short const   )910,      (short const   )913,      (short const   )914,      (short const   )918, 
        (short const   )922,      (short const   )926,      (short const   )929,      (short const   )934, 
        (short const   )936,      (short const   )941,      (short const   )943,      (short const   )947, 
        (short const   )951,      (short const   )955,      (short const   )957,      (short const   )961, 
        (short const   )965,      (short const   )967,      (short const   )971,      (short const   )975, 
        (short const   )977,      (short const   )981,      (short const   )985,      (short const   )989, 
        (short const   )993,      (short const   )995,      (short const   )999,      (short const   )1003, 
        (short const   )1005,      (short const   )1009,      (short const   )1011,      (short const   )1015, 
        (short const   )1017,      (short const   )1021,      (short const   )1023,      (short const   )1024, 
        (short const   )1029,      (short const   )1031,      (short const   )1032,      (short const   )1037, 
        (short const   )1039,      (short const   )1040,      (short const   )1041,      (short const   )1049, 
        (short const   )1051,      (short const   )1052,      (short const   )1057,      (short const   )1060, 
        (short const   )1061,      (short const   )1065,      (short const   )1069,      (short const   )1073, 
        (short const   )1077,      (short const   )1081,      (short const   )1085,      (short const   )1089, 
        (short const   )1093,      (short const   )1097,      (short const   )1101,      (short const   )1103, 
        (short const   )1104,      (short const   )1109};
#line 188 "ys.y"
static short const   yyrhs[1111]  = 
#line 188
  {      (short const   )100,      (short const   )102,      (short const   )0,      (short const   )0, 
        (short const   )101,      (short const   )103,      (short const   )0,      (short const   )0, 
        (short const   )107,      (short const   )0,      (short const   )108,      (short const   )0, 
        (short const   )51,      (short const   )96,      (short const   )0,      (short const   )96, 
        (short const   )0,      (short const   )1,      (short const   )96,      (short const   )0, 
        (short const   )108,      (short const   )0,      (short const   )47,      (short const   )21, 
        (short const   )96,      (short const   )0,      (short const   )96,      (short const   )0, 
        (short const   )1,      (short const   )97,      (short const   )0,      (short const   )1, 
        (short const   )96,      (short const   )0,      (short const   )45,      (short const   )96, 
        (short const   )0,      (short const   )44,      (short const   )96,      (short const   )0, 
        (short const   )46,      (short const   )251,      (short const   )96,      (short const   )0, 
        (short const   )46,      (short const   )96,      (short const   )0,      (short const   )154, 
        (short const   )0,      (short const   )154,      (short const   )105,      (short const   )0, 
        (short const   )126,      (short const   )0,      (short const   )126,      (short const   )105, 
        (short const   )0,      (short const   )127,      (short const   )0,      (short const   )127, 
        (short const   )105,      (short const   )0,      (short const   )0,      (short const   )106, 
        (short const   )105,      (short const   )158,      (short const   )0,      (short const   )17, 
        (short const   )98,      (short const   )19,      (short const   )99,      (short const   )10, 
        (short const   )97,      (short const   )21,      (short const   )96,      (short const   )0, 
        (short const   )17,      (short const   )98,      (short const   )20,      (short const   )99, 
        (short const   )10,      (short const   )97,      (short const   )21,      (short const   )96, 
        (short const   )0,      (short const   )18,      (short const   )21,      (short const   )96, 
        (short const   )0,      (short const   )189,      (short const   )0,      (short const   )194, 
        (short const   )0,      (short const   )251,      (short const   )96,      (short const   )0, 
        (short const   )109,      (short const   )0,      (short const   )112,      (short const   )0, 
        (short const   )104,      (short const   )0,      (short const   )36,      (short const   )96, 
        (short const   )0,      (short const   )50,      (short const   )96,      (short const   )0, 
        (short const   )0,      (short const   )37,      (short const   )90,      (short const   )251, 
        (short const   )91,      (short const   )110,      (short const   )186,      (short const   )0, 
        (short const   )0,      (short const   )40,      (short const   )90,      (short const   )251, 
        (short const   )91,      (short const   )111,      (short const   )188,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )41,      (short const   )113, 
        (short const   )90,      (short const   )251,      (short const   )91,      (short const   )114, 
        (short const   )116,      (short const   )0,      (short const   )0,      (short const   )43, 
        (short const   )115,      (short const   )117,      (short const   )41,      (short const   )90, 
        (short const   )251,      (short const   )91,      (short const   )96,      (short const   )0, 
        (short const   )42,      (short const   )119,      (short const   )118,      (short const   )0, 
        (short const   )103,      (short const   )0,      (short const   )103,      (short const   )0, 
        (short const   )103,      (short const   )0,      (short const   )0,      (short const   )90, 
        (short const   )251,      (short const   )96,      (short const   )120,      (short const   )122, 
        (short const   )0,      (short const   )0,      (short const   )90,      (short const   )96, 
        (short const   )121,      (short const   )122,      (short const   )0,      (short const   )0, 
        (short const   )251,      (short const   )96,      (short const   )123,      (short const   )125, 
        (short const   )0,      (short const   )0,      (short const   )96,      (short const   )124, 
        (short const   )125,      (short const   )0,      (short const   )251,      (short const   )91, 
        (short const   )0,      (short const   )91,      (short const   )0,      (short const   )22, 
        (short const   )0,      (short const   )23,      (short const   )0,      (short const   )24, 
        (short const   )0,      (short const   )25,      (short const   )0,      (short const   )26, 
        (short const   )0,      (short const   )27,      (short const   )0,      (short const   )28, 
        (short const   )0,      (short const   )29,      (short const   )0,      (short const   )30, 
        (short const   )0,      (short const   )130,      (short const   )0,      (short const   )139, 
        (short const   )0,      (short const   )54,      (short const   )0,      (short const   )31, 
        (short const   )0,      (short const   )32,      (short const   )0,      (short const   )83, 
        (short const   )0,      (short const   )83,      (short const   )129,      (short const   )0, 
        (short const   )83,      (short const   )128,      (short const   )0,      (short const   )83, 
        (short const   )129,      (short const   )128,      (short const   )0,      (short const   )127, 
        (short const   )0,      (short const   )129,      (short const   )127,      (short const   )0, 
        (short const   )0,      (short const   )133,      (short const   )21,      (short const   )131, 
        (short const   )98,      (short const   )134,      (short const   )97,      (short const   )0, 
        (short const   )0,      (short const   )133,      (short const   )132,      (short const   )98, 
        (short const   )134,      (short const   )97,      (short const   )0,      (short const   )133, 
        (short const   )21,      (short const   )0,      (short const   )34,      (short const   )0, 
        (short const   )35,      (short const   )0,      (short const   )135,      (short const   )0, 
        (short const   )134,      (short const   )135,      (short const   )0,      (short const   )106, 
        (short const   )136,      (short const   )137,      (short const   )96,      (short const   )0, 
        (short const   )126,      (short const   )0,      (short const   )126,      (short const   )136, 
        (short const   )0,      (short const   )127,      (short const   )0,      (short const   )127, 
        (short const   )136,      (short const   )0,      (short const   )138,      (short const   )0, 
        (short const   )137,      (short const   )99,      (short const   )138,      (short const   )0, 
        (short const   )144,      (short const   )0,      (short const   )55,      (short const   )253, 
        (short const   )0,      (short const   )144,      (short const   )55,      (short const   )253, 
        (short const   )0,      (short const   )0,      (short const   )33,      (short const   )98, 
        (short const   )140,      (short const   )142,      (short const   )97,      (short const   )0, 
        (short const   )0,      (short const   )33,      (short const   )21,      (short const   )98, 
        (short const   )141,      (short const   )142,      (short const   )97,      (short const   )0, 
        (short const   )33,      (short const   )21,      (short const   )0,      (short const   )143, 
        (short const   )0,      (short const   )142,      (short const   )99,      (short const   )143, 
        (short const   )0,      (short const   )21,      (short const   )0,      (short const   )21, 
        (short const   )67,      (short const   )253,      (short const   )0,      (short const   )128, 
        (short const   )145,      (short const   )0,      (short const   )145,      (short const   )0, 
        (short const   )21,      (short const   )0,      (short const   )21,      (short const   )202, 
        (short const   )0,      (short const   )247,      (short const   )0,      (short const   )0, 
        (short const   )98,      (short const   )147,      (short const   )148,      (short const   )0, 
        (short const   )149,      (short const   )97,      (short const   )0,      (short const   )149, 
        (short const   )99,      (short const   )97,      (short const   )0,      (short const   )146, 
        (short const   )0,      (short const   )0,      (short const   )149,      (short const   )99, 
        (short const   )150,      (short const   )146,      (short const   )0,      (short const   )106, 
        (short const   )136,      (short const   )0,      (short const   )106,      (short const   )136, 
        (short const   )152,      (short const   )0,      (short const   )128,      (short const   )0, 
        (short const   )153,      (short const   )0,      (short const   )128,      (short const   )153, 
        (short const   )0,      (short const   )90,      (short const   )152,      (short const   )91, 
        (short const   )0,      (short const   )92,      (short const   )93,      (short const   )0, 
        (short const   )153,      (short const   )92,      (short const   )93,      (short const   )0, 
        (short const   )92,      (short const   )253,      (short const   )93,      (short const   )0, 
        (short const   )153,      (short const   )92,      (short const   )253,      (short const   )93, 
        (short const   )0,      (short const   )90,      (short const   )91,      (short const   )0, 
        (short const   )153,      (short const   )90,      (short const   )91,      (short const   )0, 
        (short const   )90,      (short const   )155,      (short const   )91,      (short const   )0, 
        (short const   )153,      (short const   )90,      (short const   )155,      (short const   )91, 
        (short const   )0,      (short const   )53,      (short const   )0,      (short const   )16, 
        (short const   )0,      (short const   )52,      (short const   )0,      (short const   )14, 
        (short const   )0,      (short const   )13,      (short const   )0,      (short const   )15, 
        (short const   )0,      (short const   )106,      (short const   )105,      (short const   )0, 
        (short const   )0,      (short const   )106,      (short const   )105,      (short const   )99, 
        (short const   )156,      (short const   )155,      (short const   )0,      (short const   )106, 
        (short const   )105,      (short const   )157,      (short const   )0,      (short const   )106, 
        (short const   )105,      (short const   )157,      (short const   )99,      (short const   )155, 
        (short const   )0,      (short const   )202,      (short const   )0,      (short const   )128, 
        (short const   )0,      (short const   )90,      (short const   )128,      (short const   )91, 
        (short const   )90,      (short const   )91,      (short const   )0,      (short const   )90, 
        (short const   )128,      (short const   )91,      (short const   )90,      (short const   )155, 
        (short const   )91,      (short const   )0,      (short const   )90,      (short const   )128, 
        (short const   )91,      (short const   )202,      (short const   )0,      (short const   )0, 
        (short const   )21,      (short const   )159,      (short const   )182,      (short const   )0, 
        (short const   )0,      (short const   )21,      (short const   )202,      (short const   )160, 
        (short const   )182,      (short const   )0,      (short const   )0,      (short const   )128, 
        (short const   )21,      (short const   )161,      (short const   )182,      (short const   )0, 
        (short const   )0,      (short const   )128,      (short const   )21,      (short const   )202, 
        (short const   )162,      (short const   )182,      (short const   )0,      (short const   )0, 
        (short const   )21,      (short const   )90,      (short const   )163,      (short const   )165, 
        (short const   )0,      (short const   )0,      (short const   )128,      (short const   )21, 
        (short const   )90,      (short const   )164,      (short const   )165,      (short const   )0, 
        (short const   )96,      (short const   )0,      (short const   )0,      (short const   )91, 
        (short const   )166,      (short const   )182,      (short const   )0,      (short const   )0, 
        (short const   )155,      (short const   )91,      (short const   )167,      (short const   )182, 
        (short const   )0,      (short const   )0,      (short const   )197,      (short const   )91, 
        (short const   )168,      (short const   )182,      (short const   )0,      (short const   )0, 
        (short const   )197,      (short const   )91,      (short const   )169,      (short const   )194, 
        (short const   )0,      (short const   )0,      (short const   )91,      (short const   )170, 
        (short const   )194,      (short const   )0,      (short const   )0,      (short const   )91, 
        (short const   )172,      (short const   )182,      (short const   )0,      (short const   )0, 
        (short const   )155,      (short const   )91,      (short const   )173,      (short const   )182, 
        (short const   )0,      (short const   )0,      (short const   )197,      (short const   )91, 
        (short const   )174,      (short const   )182,      (short const   )0,      (short const   )1, 
        (short const   )98,      (short const   )0,      (short const   )0,      (short const   )21, 
        (short const   )176,      (short const   )182,      (short const   )0,      (short const   )0, 
        (short const   )21,      (short const   )202,      (short const   )177,      (short const   )182, 
        (short const   )0,      (short const   )0,      (short const   )21,      (short const   )90, 
        (short const   )178,      (short const   )171,      (short const   )0,      (short const   )0, 
        (short const   )128,      (short const   )21,      (short const   )179,      (short const   )182, 
        (short const   )0,      (short const   )0,      (short const   )128,      (short const   )21, 
        (short const   )202,      (short const   )180,      (short const   )182,      (short const   )0, 
        (short const   )0,      (short const   )128,      (short const   )21,      (short const   )90, 
        (short const   )181,      (short const   )171,      (short const   )0,      (short const   )96, 
        (short const   )184,      (short const   )0,      (short const   )185,      (short const   )96, 
        (short const   )0,      (short const   )99,      (short const   )184,      (short const   )175, 
        (short const   )0,      (short const   )0,      (short const   )185,      (short const   )183, 
        (short const   )99,      (short const   )175,      (short const   )0,      (short const   )0, 
        (short const   )67,      (short const   )146,      (short const   )0,      (short const   )0, 
        (short const   )103,      (short const   )187,      (short const   )38,      (short const   )103, 
        (short const   )0,      (short const   )103,      (short const   )0,      (short const   )103, 
        (short const   )0,      (short const   )0,      (short const   )21,      (short const   )55, 
        (short const   )190,      (short const   )103,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )48,      (short const   )191,      (short const   )253, 
        (short const   )192,      (short const   )55,      (short const   )103,      (short const   )0, 
        (short const   )0,      (short const   )49,      (short const   )55,      (short const   )193, 
        (short const   )103,      (short const   )0,      (short const   )98,      (short const   )196, 
        (short const   )101,      (short const   )97,      (short const   )0,      (short const   )0, 
        (short const   )98,      (short const   )196,      (short const   )203,      (short const   )195, 
        (short const   )101,      (short const   )97,      (short const   )0,      (short const   )0, 
        (short const   )106,      (short const   )105,      (short const   )21,      (short const   )0, 
        (short const   )0,      (short const   )106,      (short const   )105,      (short const   )21, 
        (short const   )99,      (short const   )198,      (short const   )197,      (short const   )0, 
        (short const   )106,      (short const   )105,      (short const   )21,      (short const   )202, 
        (short const   )0,      (short const   )0,      (short const   )106,      (short const   )105, 
        (short const   )21,      (short const   )202,      (short const   )99,      (short const   )199, 
        (short const   )197,      (short const   )0,      (short const   )106,      (short const   )105, 
        (short const   )128,      (short const   )21,      (short const   )0,      (short const   )0, 
        (short const   )106,      (short const   )105,      (short const   )128,      (short const   )21, 
        (short const   )99,      (short const   )200,      (short const   )197,      (short const   )0, 
        (short const   )106,      (short const   )105,      (short const   )128,      (short const   )21, 
        (short const   )202,      (short const   )0,      (short const   )0,      (short const   )106, 
        (short const   )105,      (short const   )128,      (short const   )21,      (short const   )202, 
        (short const   )99,      (short const   )201,      (short const   )197,      (short const   )0, 
        (short const   )92,      (short const   )93,      (short const   )0,      (short const   )92, 
        (short const   )3,      (short const   )93,      (short const   )0,      (short const   )202, 
        (short const   )92,      (short const   )3,      (short const   )93,      (short const   )0, 
        (short const   )106,      (short const   )105,      (short const   )205,      (short const   )0, 
        (short const   )106,      (short const   )105,      (short const   )96,      (short const   )0, 
        (short const   )0,      (short const   )106,      (short const   )105,      (short const   )96, 
        (short const   )204,      (short const   )203,      (short const   )0,      (short const   )0, 
        (short const   )21,      (short const   )206,      (short const   )216,      (short const   )0, 
        (short const   )0,      (short const   )21,      (short const   )202,      (short const   )207, 
        (short const   )216,      (short const   )0,      (short const   )0,      (short const   )21, 
        (short const   )90,      (short const   )91,      (short const   )208,      (short const   )216, 
        (short const   )0,      (short const   )0,      (short const   )21,      (short const   )90, 
        (short const   )155,      (short const   )91,      (short const   )209,      (short const   )216, 
        (short const   )0,      (short const   )0,      (short const   )21,      (short const   )90, 
        (short const   )197,      (short const   )91,      (short const   )210,      (short const   )216, 
        (short const   )0,      (short const   )0,      (short const   )128,      (short const   )21, 
        (short const   )211,      (short const   )216,      (short const   )0,      (short const   )0, 
        (short const   )128,      (short const   )21,      (short const   )202,      (short const   )212, 
        (short const   )216,      (short const   )0,      (short const   )0,      (short const   )128, 
        (short const   )21,      (short const   )90,      (short const   )91,      (short const   )213, 
        (short const   )216,      (short const   )0,      (short const   )0,      (short const   )128, 
        (short const   )21,      (short const   )90,      (short const   )155,      (short const   )91, 
        (short const   )214,      (short const   )216,      (short const   )0,      (short const   )0, 
        (short const   )128,      (short const   )21,      (short const   )90,      (short const   )197, 
        (short const   )91,      (short const   )215,      (short const   )216,      (short const   )0, 
        (short const   )96,      (short const   )219,      (short const   )0,      (short const   )0, 
        (short const   )96,      (short const   )219,      (short const   )217,      (short const   )203, 
        (short const   )0,      (short const   )220,      (short const   )96,      (short const   )0, 
        (short const   )0,      (short const   )220,      (short const   )96,      (short const   )218, 
        (short const   )203,      (short const   )0,      (short const   )99,      (short const   )219, 
        (short const   )205,      (short const   )0,      (short const   )220,      (short const   )99, 
        (short const   )205,      (short const   )0,      (short const   )0,      (short const   )67, 
        (short const   )146,      (short const   )0,      (short const   )222,      (short const   )0, 
        (short const   )91,      (short const   )0,      (short const   )247,      (short const   )91, 
        (short const   )0,      (short const   )0,      (short const   )247,      (short const   )99, 
        (short const   )223,      (short const   )222,      (short const   )0,      (short const   )225, 
        (short const   )0,      (short const   )3,      (short const   )0,      (short const   )4, 
        (short const   )0,      (short const   )5,      (short const   )0,      (short const   )6, 
        (short const   )0,      (short const   )7,      (short const   )0,      (short const   )8, 
        (short const   )0,      (short const   )9,      (short const   )0,      (short const   )10, 
        (short const   )0,      (short const   )11,      (short const   )0,      (short const   )12, 
        (short const   )0,      (short const   )90,      (short const   )251,      (short const   )91, 
        (short const   )0,      (short const   )21,      (short const   )0,      (short const   )224, 
        (short const   )0,      (short const   )0,      (short const   )226,      (short const   )227, 
        (short const   )92,      (short const   )251,      (short const   )93,      (short const   )0, 
        (short const   )226,      (short const   )94,      (short const   )21,      (short const   )0, 
        (short const   )226,      (short const   )95,      (short const   )21,      (short const   )0, 
        (short const   )226,      (short const   )88,      (short const   )0,      (short const   )226, 
        (short const   )89,      (short const   )0,      (short const   )0,      (short const   )226, 
        (short const   )90,      (short const   )228,      (short const   )221,      (short const   )0, 
        (short const   )226,      (short const   )0,      (short const   )72,      (short const   )229, 
        (short const   )0,      (short const   )83,      (short const   )229,      (short const   )0, 
        (short const   )86,      (short const   )229,      (short const   )0,      (short const   )87, 
        (short const   )229,      (short const   )0,      (short const   )81,      (short const   )229, 
        (short const   )0,      (short const   )0,      (short const   )82,      (short const   )230, 
        (short const   )229,      (short const   )0,      (short const   )88,      (short const   )229, 
        (short const   )249,      (short const   )0,      (short const   )89,      (short const   )229, 
        (short const   )249,      (short const   )0,      (short const   )39,      (short const   )229, 
        (short const   )0,      (short const   )39,      (short const   )90,      (short const   )151, 
        (short const   )91,      (short const   )0,      (short const   )229,      (short const   )0, 
        (short const   )90,      (short const   )151,      (short const   )91,      (short const   )231, 
        (short const   )0,      (short const   )231,      (short const   )0,      (short const   )232, 
        (short const   )83,      (short const   )231,      (short const   )0,      (short const   )232, 
        (short const   )84,      (short const   )231,      (short const   )0,      (short const   )232, 
        (short const   )85,      (short const   )231,      (short const   )0,      (short const   )232, 
        (short const   )0,      (short const   )233,      (short const   )81,      (short const   )232, 
        (short const   )0,      (short const   )233,      (short const   )82,      (short const   )232, 
        (short const   )0,      (short const   )233,      (short const   )0,      (short const   )234, 
        (short const   )79,      (short const   )233,      (short const   )0,      (short const   )234, 
        (short const   )80,      (short const   )233,      (short const   )0,      (short const   )234, 
        (short const   )0,      (short const   )235,      (short const   )75,      (short const   )234, 
        (short const   )0,      (short const   )235,      (short const   )77,      (short const   )234, 
        (short const   )0,      (short const   )235,      (short const   )76,      (short const   )234, 
        (short const   )0,      (short const   )235,      (short const   )78,      (short const   )234, 
        (short const   )0,      (short const   )235,      (short const   )0,      (short const   )236, 
        (short const   )73,      (short const   )235,      (short const   )0,      (short const   )236, 
        (short const   )74,      (short const   )235,      (short const   )0,      (short const   )236, 
        (short const   )0,      (short const   )237,      (short const   )72,      (short const   )236, 
        (short const   )0,      (short const   )237,      (short const   )0,      (short const   )238, 
        (short const   )71,      (short const   )237,      (short const   )0,      (short const   )238, 
        (short const   )0,      (short const   )239,      (short const   )70,      (short const   )238, 
        (short const   )0,      (short const   )239,      (short const   )0,      (short const   )0, 
        (short const   )240,      (short const   )69,      (short const   )241,      (short const   )239, 
        (short const   )0,      (short const   )240,      (short const   )0,      (short const   )0, 
        (short const   )242,      (short const   )68,      (short const   )243,      (short const   )240, 
        (short const   )0,      (short const   )242,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )242,      (short const   )56,      (short const   )245, 
        (short const   )251,      (short const   )55,      (short const   )246,      (short const   )244, 
        (short const   )0,      (short const   )244,      (short const   )0,      (short const   )0, 
        (short const   )229,      (short const   )248,      (short const   )67,      (short const   )247, 
        (short const   )0,      (short const   )229,      (short const   )250,      (short const   )0, 
        (short const   )0,      (short const   )57,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )58,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )59,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )60,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )61,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )62,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )63,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )64,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )65,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )66,      (short const   )249,      (short const   )247, 
        (short const   )0,      (short const   )247,      (short const   )0,      (short const   )0, 
        (short const   )251,      (short const   )99,      (short const   )252,      (short const   )247, 
        (short const   )0,      (short const   )244,      (short const   )0};
#line 305 "ys.y"
static short const   yyrline[358]  = 
#line 305
  {      (short const   )0,      (short const   )154,      (short const   )187,      (short const   )193, 
        (short const   )194,      (short const   )200,      (short const   )201,      (short const   )206, 
        (short const   )212,      (short const   )213,      (short const   )225,      (short const   )226, 
        (short const   )234,      (short const   )235,      (short const   )239,      (short const   )258, 
        (short const   )264,      (short const   )270,      (short const   )290,      (short const   )311, 
        (short const   )312,      (short const   )313,      (short const   )314,      (short const   )315, 
        (short const   )316,      (short const   )319,      (short const   )350,      (short const   )354, 
        (short const   )372,      (short const   )374,      (short const   )387,      (short const   )389, 
        (short const   )395,      (short const   )437,      (short const   )438,      (short const   )439, 
        (short const   )440,      (short const   )450,      (short const   )473,      (short const   )488, 
        (short const   )488,      (short const   )503,      (short const   )526,      (short const   )536, 
        (short const   )548,      (short const   )548,      (short const   )559,      (short const   )580, 
        (short const   )597,      (short const   )614,      (short const   )621,      (short const   )624, 
        (short const   )670,      (short const   )670,      (short const   )680,      (short const   )682, 
        (short const   )697,      (short const   )697,      (short const   )704,      (short const   )706, 
        (short const   )753,      (short const   )772,      (short const   )783,      (short const   )794, 
        (short const   )805,      (short const   )816,      (short const   )826,      (short const   )842, 
        (short const   )858,      (short const   )874,      (short const   )890,      (short const   )891, 
        (short const   )892,      (short const   )921,      (short const   )931,      (short const   )944, 
        (short const   )966,      (short const   )967,      (short const   )968,      (short const   )972, 
        (short const   )973,      (short const   )977,      (short const   )987,      (short const   )1002, 
        (short const   )1008,      (short const   )1018,      (short const   )1038,      (short const   )1056, 
        (short const   )1076,      (short const   )1080,      (short const   )1087,      (short const   )1095, 
        (short const   )1096,      (short const   )1097,      (short const   )1098,      (short const   )1102, 
        (short const   )1103,      (short const   )1107,      (short const   )1108,      (short const   )1109, 
        (short const   )1113,      (short const   )1132,      (short const   )1137,      (short const   )1161, 
        (short const   )1171,      (short const   )1195,      (short const   )1196,      (short const   )1200, 
        (short const   )1224,      (short const   )1229,      (short const   )1239,      (short const   )1248, 
        (short const   )1267,      (short const   )1308,      (short const   )1309,      (short const   )1318, 
        (short const   )1321,      (short const   )1361,      (short const   )1368,      (short const   )1389, 
        (short const   )1399,      (short const   )1414,      (short const   )1415,      (short const   )1419, 
        (short const   )1420,      (short const   )1421,      (short const   )1425,      (short const   )1426, 
        (short const   )1427,      (short const   )1428,      (short const   )1429,      (short const   )1430, 
        (short const   )1431,      (short const   )1432,      (short const   )1433,      (short const   )1437, 
        (short const   )1462,      (short const   )1477,      (short const   )1488,      (short const   )1497, 
        (short const   )1506,      (short const   )1520,      (short const   )1532,      (short const   )1545, 
        (short const   )1545,      (short const   )1547,      (short const   )1551,      (short const   )1573, 
        (short const   )1583,      (short const   )1595,      (short const   )1609,      (short const   )1638, 
        (short const   )1652,      (short const   )1652,      (short const   )1689,      (short const   )1689, 
        (short const   )1716,      (short const   )1716,      (short const   )1757,      (short const   )1757, 
        (short const   )1823,      (short const   )1823,      (short const   )1891,      (short const   )1891, 
        (short const   )1907,      (short const   )1926,      (short const   )1926,      (short const   )1947, 
        (short const   )1947,      (short const   )1971,      (short const   )1971,      (short const   )1992, 
        (short const   )2011,      (short const   )2038,      (short const   )2060,      (short const   )2073, 
        (short const   )2073,      (short const   )2087,      (short const   )2087,      (short const   )2105, 
        (short const   )2105,      (short const   )2115,      (short const   )2130,      (short const   )2130, 
        (short const   )2168,      (short const   )2168,      (short const   )2232,      (short const   )2232, 
        (short const   )2258,      (short const   )2258,      (short const   )2298,      (short const   )2298, 
        (short const   )2360,      (short const   )2363,      (short const   )2367,      (short const   )2371, 
        (short const   )2372,      (short const   )2400,      (short const   )2403,      (short const   )2446, 
        (short const   )2550,      (short const   )2556,      (short const   )2562,      (short const   )2569, 
        (short const   )2577,      (short const   )2587,      (short const   )2587,      (short const   )2606, 
        (short const   )2626,      (short const   )2628,      (short const   )2633,      (short const   )2642, 
        (short const   )2646,      (short const   )2652,      (short const   )2656,      (short const   )2667, 
        (short const   )2686,      (short const   )2706,      (short const   )2706,      (short const   )2733, 
        (short const   )2763,      (short const   )2763,      (short const   )2782,      (short const   )2802, 
        (short const   )2802,      (short const   )2829,      (short const   )2858,      (short const   )2863, 
        (short const   )2868,      (short const   )2874,      (short const   )2885,      (short const   )2886, 
        (short const   )2897,      (short const   )2909,      (short const   )2912,      (short const   )2933, 
        (short const   )2933,      (short const   )2980,      (short const   )2980,      (short const   )2984, 
        (short const   )2984,      (short const   )2988,      (short const   )2988,      (short const   )2992, 
        (short const   )2992,      (short const   )3024,      (short const   )3024,      (short const   )3072, 
        (short const   )3072,      (short const   )3093,      (short const   )3093,      (short const   )3114, 
        (short const   )3114,      (short const   )3134,      (short const   )3138,      (short const   )3142, 
        (short const   )3147,      (short const   )3147,      (short const   )3151,      (short const   )3156, 
        (short const   )3156,      (short const   )3157,      (short const   )3160,      (short const   )3204, 
        (short const   )3337,      (short const   )3338,      (short const   )3346,      (short const   )3435, 
        (short const   )3521,      (short const   )3532,      (short const   )3554,      (short const   )3575, 
        (short const   )3597,      (short const   )3619,      (short const   )3641,      (short const   )3659, 
        (short const   )3677,      (short const   )3695,      (short const   )3719,      (short const   )3769, 
        (short const   )3787,      (short const   )3790,      (short const   )3797,      (short const   )3798, 
        (short const   )3838,      (short const   )3870,      (short const   )3925,      (short const   )3968, 
        (short const   )4001,      (short const   )4037,      (short const   )4066,      (short const   )4103, 
        (short const   )4141,      (short const   )4192,      (short const   )4209,      (short const   )4231, 
        (short const   )4254,      (short const   )4260,      (short const   )4266,      (short const   )4273, 
        (short const   )4291,      (short const   )4309,      (short const   )4333,      (short const   )4355, 
        (short const   )4356,      (short const   )4482,      (short const   )4483,      (short const   )4499, 
        (short const   )4515,      (short const   )4541,      (short const   )4542,      (short const   )4568, 
        (short const   )4596,      (short const   )4597,      (short const   )4624,      (short const   )4651, 
        (short const   )4652,      (short const   )4671,      (short const   )4690,      (short const   )4709, 
        (short const   )4730,      (short const   )4731,      (short const   )4750,      (short const   )4775, 
        (short const   )4776,      (short const   )4803,      (short const   )4804,      (short const   )4831, 
        (short const   )4832,      (short const   )4859,      (short const   )4860,      (short const   )4882, 
        (short const   )4910,      (short const   )4911,      (short const   )4933,      (short const   )4962, 
        (short const   )4963,      (short const   )4975,      (short const   )4984,      (short const   )4996, 
        (short const   )4997,      (short const   )5020,      (short const   )5030,      (short const   )5036, 
        (short const   )5052,      (short const   )5069,      (short const   )5086,      (short const   )5114, 
        (short const   )5142,      (short const   )5170,      (short const   )5198,      (short const   )5226, 
        (short const   )5255,      (short const   )5284,      (short const   )5316,      (short const   )5317, 
        (short const   )5362,      (short const   )5365};
#line 348 "ys.y"
static char const   * const  yytname[255]  = 
#line 348
  {      (char const   */* const  */)"$",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined.",      (char const   */* const  */)"NUMBERI", 
        (char const   */* const  */)"NUMBERUI",      (char const   */* const  */)"NUMBERLI",      (char const   */* const  */)"NUMBERLUI",      (char const   */* const  */)"NUMBERD", 
        (char const   */* const  */)"NUMBERLD",      (char const   */* const  */)"NUMBERF",      (char const   */* const  */)"STRINGC",      (char const   */* const  */)"WSTRINGC", 
        (char const   */* const  */)"NUMBERC",      (char const   */* const  */)"AUTO",      (char const   */* const  */)"STATIC",      (char const   */* const  */)"REGISTER", 
        (char const   */* const  */)"EXTERN",      (char const   */* const  */)"REMOTE",      (char const   */* const  */)"UNLOAD",      (char const   */* const  */)"INTRINSIC", 
        (char const   */* const  */)"RPC",      (char const   */* const  */)"IDENT",      (char const   */* const  */)"INT",      (char const   */* const  */)"DOUBLE", 
        (char const   */* const  */)"FLOAT",      (char const   */* const  */)"CHAR",      (char const   */* const  */)"VOID",      (char const   */* const  */)"LONG", 
        (char const   */* const  */)"SHORT",      (char const   */* const  */)"SIGNED",      (char const   */* const  */)"UNSIGNED",      (char const   */* const  */)"CONST", 
        (char const   */* const  */)"VOLATILE",      (char const   */* const  */)"ENUM",      (char const   */* const  */)"STRUCT",      (char const   */* const  */)"UNION", 
        (char const   */* const  */)"EXIT",      (char const   */* const  */)"IF",      (char const   */* const  */)"ELSE",      (char const   */* const  */)"SIZEOF", 
        (char const   */* const  */)"SWITCH",      (char const   */* const  */)"WHILE",      (char const   */* const  */)"FOR",      (char const   */* const  */)"DO", 
        (char const   */* const  */)"CONTINUE",      (char const   */* const  */)"BREAK",      (char const   */* const  */)"RETURN",      (char const   */* const  */)"GOTO", 
        (char const   */* const  */)"CASE",      (char const   */* const  */)"DEFAULT",      (char const   */* const  */)"CSUSPEND",      (char const   */* const  */)"RESUME", 
        (char const   */* const  */)"EXPORT_T",      (char const   */* const  */)"TYPEDEF",      (char const   */* const  */)"TYPENAME",      (char const   */* const  */)"\':\'", 
        (char const   */* const  */)"\'?\'",      (char const   */* const  */)"MUL_ASSIGN",      (char const   */* const  */)"DIV_ASSIGN",      (char const   */* const  */)"MOD_ASSIGN", 
        (char const   */* const  */)"ADD_ASSIGN",      (char const   */* const  */)"SUB_ASSIGN",      (char const   */* const  */)"LEFT_ASSIGN",      (char const   */* const  */)"RIGHT_ASSIGN", 
        (char const   */* const  */)"AND_ASSIGN",      (char const   */* const  */)"XOR_ASSIGN",      (char const   */* const  */)"OR_ASSIGN",      (char const   */* const  */)"\'=\'", 
        (char const   */* const  */)"OR_A",      (char const   */* const  */)"AND_A",      (char const   */* const  */)"\'|\'",      (char const   */* const  */)"\'^\'", 
        (char const   */* const  */)"\'&\'",      (char const   */* const  */)"EQ_A",      (char const   */* const  */)"NE_A",      (char const   */* const  */)"\'<\'", 
        (char const   */* const  */)"LQ",      (char const   */* const  */)"\'>\'",      (char const   */* const  */)"GQ",      (char const   */* const  */)"SHIL", 
        (char const   */* const  */)"SHIR",      (char const   */* const  */)"\'+\'",      (char const   */* const  */)"\'-\'",      (char const   */* const  */)"\'*\'", 
        (char const   */* const  */)"\'/\'",      (char const   */* const  */)"\'%\'",      (char const   */* const  */)"NEG_T",      (char const   */* const  */)"NEG_B", 
        (char const   */* const  */)"PP",      (char const   */* const  */)"MM",      (char const   */* const  */)"\'(\'",      (char const   */* const  */)"\')\'", 
        (char const   */* const  */)"\'[\'",      (char const   */* const  */)"\']\'",      (char const   */* const  */)"\'.\'",      (char const   */* const  */)"PTR", 
        (char const   */* const  */)"\';\'",      (char const   */* const  */)"\'}\'",      (char const   */* const  */)"\'{\'",      (char const   */* const  */)"\',\'", 
        (char const   */* const  */)"list_stat_0",      (char const   */* const  */)"list_stat",      (char const   */* const  */)"stat_0",      (char const   */* const  */)"stat_1", 
        (char const   */* const  */)"jump_statement",      (char const   */* const  */)"declaration_specifiers",      (char const   */* const  */)"M",      (char const   */* const  */)"declarations", 
        (char const   */* const  */)"statement",      (char const   */* const  */)"selection_statement",      (char const   */* const  */)"@1",      (char const   */* const  */)"@2", 
        (char const   */* const  */)"iteration_statement",      (char const   */* const  */)"@3",      (char const   */* const  */)"@4",      (char const   */* const  */)"@5", 
        (char const   */* const  */)"while_stat",      (char const   */* const  */)"do_while_stat",      (char const   */* const  */)"for_stat",      (char const   */* const  */)"for", 
        (char const   */* const  */)"@6",      (char const   */* const  */)"@7",      (char const   */* const  */)"for_expr1",      (char const   */* const  */)"@8", 
        (char const   */* const  */)"@9",      (char const   */* const  */)"for_expr2",      (char const   */* const  */)"type_specifier",      (char const   */* const  */)"type_qualifier", 
        (char const   */* const  */)"pointer",      (char const   */* const  */)"type_qualifier_list",      (char const   */* const  */)"struct_or_union_specifier",      (char const   */* const  */)"@10", 
        (char const   */* const  */)"@11",      (char const   */* const  */)"struct_or_union",      (char const   */* const  */)"struct_declaration_list",      (char const   */* const  */)"struct_declaration", 
        (char const   */* const  */)"specifier_qualifier_list",      (char const   */* const  */)"struct_declarator_list",      (char const   */* const  */)"struct_declarator",      (char const   */* const  */)"enum_specifier", 
        (char const   */* const  */)"@12",      (char const   */* const  */)"@13",      (char const   */* const  */)"enumerator_list",      (char const   */* const  */)"enumerator", 
        (char const   */* const  */)"declarator",      (char const   */* const  */)"direct_declarator",      (char const   */* const  */)"initializer",      (char const   */* const  */)"@14", 
        (char const   */* const  */)"initializer_list_complete",      (char const   */* const  */)"initializer_list",      (char const   */* const  */)"@15",      (char const   */* const  */)"type_name", 
        (char const   */* const  */)"abstract_declarator",      (char const   */* const  */)"direct_abstract_declarator",      (char const   */* const  */)"storage_class_specifier",      (char const   */* const  */)"list_type_spec", 
        (char const   */* const  */)"@16",      (char const   */* const  */)"list_dim_or_pointer",      (char const   */* const  */)"first_dekl",      (char const   */* const  */)"@17", 
        (char const   */* const  */)"@18",      (char const   */* const  */)"@19",      (char const   */* const  */)"@20",      (char const   */* const  */)"@21", 
        (char const   */* const  */)"@22",      (char const   */* const  */)"func_first",      (char const   */* const  */)"@23",      (char const   */* const  */)"@24", 
        (char const   */* const  */)"@25",      (char const   */* const  */)"@26",      (char const   */* const  */)"@27",      (char const   */* const  */)"func_rest", 
        (char const   */* const  */)"@28",      (char const   */* const  */)"@29",      (char const   */* const  */)"@30",      (char const   */* const  */)"list_dekl", 
        (char const   */* const  */)"@31",      (char const   */* const  */)"@32",      (char const   */* const  */)"@33",      (char const   */* const  */)"@34", 
        (char const   */* const  */)"@35",      (char const   */* const  */)"@36",      (char const   */* const  */)"initializer_optional",      (char const   */* const  */)"@37", 
        (char const   */* const  */)"R",      (char const   */* const  */)"initialization",      (char const   */* const  */)"then",      (char const   */* const  */)"@38", 
        (char const   */* const  */)"switch_body",      (char const   */* const  */)"labeled_statement",      (char const   */* const  */)"@39",      (char const   */* const  */)"@40", 
        (char const   */* const  */)"@41",      (char const   */* const  */)"@42",      (char const   */* const  */)"compound_statement",      (char const   */* const  */)"@43", 
        (char const   */* const  */)"N",      (char const   */* const  */)"list_form_param",      (char const   */* const  */)"@44",      (char const   */* const  */)"@45", 
        (char const   */* const  */)"@46",      (char const   */* const  */)"@47",      (char const   */* const  */)"list_dim",      (char const   */* const  */)"list_loc_dekl", 
        (char const   */* const  */)"@48",      (char const   */* const  */)"list_loc_dekl_1",      (char const   */* const  */)"@49",      (char const   */* const  */)"@50", 
        (char const   */* const  */)"@51",      (char const   */* const  */)"@52",      (char const   */* const  */)"@53",      (char const   */* const  */)"@54", 
        (char const   */* const  */)"@55",      (char const   */* const  */)"@56",      (char const   */* const  */)"@57",      (char const   */* const  */)"@58", 
        (char const   */* const  */)"initializer_optional_loc",      (char const   */* const  */)"@59",      (char const   */* const  */)"@60",      (char const   */* const  */)"P", 
        (char const   */* const  */)"local_initialization",      (char const   */* const  */)"call",      (char const   */* const  */)"list_param",      (char const   */* const  */)"@61", 
        (char const   */* const  */)"primary_expression",      (char const   */* const  */)"ident",      (char const   */* const  */)"postfix_expression",      (char const   */* const  */)"@62", 
        (char const   */* const  */)"@63",      (char const   */* const  */)"unary_expression",      (char const   */* const  */)"@64",      (char const   */* const  */)"cast_expression", 
        (char const   */* const  */)"multiplicative_expression",      (char const   */* const  */)"additive_expression",      (char const   */* const  */)"shift_expression",      (char const   */* const  */)"relational_expression", 
        (char const   */* const  */)"equality_expression",      (char const   */* const  */)"bit_AND_expression",      (char const   */* const  */)"exclusive_OR_expression",      (char const   */* const  */)"inclusive_OR_expression", 
        (char const   */* const  */)"logical_AND_expression",      (char const   */* const  */)"@65",      (char const   */* const  */)"logical_OR_expression",      (char const   */* const  */)"@66", 
        (char const   */* const  */)"conditional_expression",      (char const   */* const  */)"@67",      (char const   */* const  */)"@68",      (char const   */* const  */)"assignment_expression", 
        (char const   */* const  */)"@69",      (char const   */* const  */)"ae_empty",      (char const   */* const  */)"assignment_operator",      (char const   */* const  */)"expression", 
        (char const   */* const  */)"@70",      (char const   */* const  */)"constant_expression",      (char const   */* const  */)((void *)0)};
#line 385 "ys.y"
static short const   yyr1[358]  = 
#line 385
  {      (short const   )0,      (short const   )100,      (short const   )100,      (short const   )101, 
        (short const   )101,      (short const   )102,      (short const   )102,      (short const   )102, 
        (short const   )102,      (short const   )102,      (short const   )103,      (short const   )103, 
        (short const   )103,      (short const   )103,      (short const   )103,      (short const   )104, 
        (short const   )104,      (short const   )104,      (short const   )104,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )106,      (short const   )107,      (short const   )107, 
        (short const   )107,      (short const   )107,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )108,      (short const   )108, 
        (short const   )108,      (short const   )108,      (short const   )110,      (short const   )109, 
        (short const   )111,      (short const   )109,      (short const   )113,      (short const   )114, 
        (short const   )112,      (short const   )115,      (short const   )112,      (short const   )112, 
        (short const   )116,      (short const   )117,      (short const   )118,      (short const   )120, 
        (short const   )119,      (short const   )121,      (short const   )119,      (short const   )123, 
        (short const   )122,      (short const   )124,      (short const   )122,      (short const   )125, 
        (short const   )125,      (short const   )126,      (short const   )126,      (short const   )126, 
        (short const   )126,      (short const   )126,      (short const   )126,      (short const   )126, 
        (short const   )126,      (short const   )126,      (short const   )126,      (short const   )126, 
        (short const   )126,      (short const   )127,      (short const   )127,      (short const   )128, 
        (short const   )128,      (short const   )128,      (short const   )128,      (short const   )129, 
        (short const   )129,      (short const   )131,      (short const   )130,      (short const   )132, 
        (short const   )130,      (short const   )130,      (short const   )133,      (short const   )133, 
        (short const   )134,      (short const   )134,      (short const   )135,      (short const   )136, 
        (short const   )136,      (short const   )136,      (short const   )136,      (short const   )137, 
        (short const   )137,      (short const   )138,      (short const   )138,      (short const   )138, 
        (short const   )140,      (short const   )139,      (short const   )141,      (short const   )139, 
        (short const   )139,      (short const   )142,      (short const   )142,      (short const   )143, 
        (short const   )143,      (short const   )144,      (short const   )144,      (short const   )145, 
        (short const   )145,      (short const   )146,      (short const   )147,      (short const   )146, 
        (short const   )148,      (short const   )148,      (short const   )149,      (short const   )150, 
        (short const   )149,      (short const   )151,      (short const   )151,      (short const   )152, 
        (short const   )152,      (short const   )152,      (short const   )153,      (short const   )153, 
        (short const   )153,      (short const   )153,      (short const   )153,      (short const   )153, 
        (short const   )153,      (short const   )153,      (short const   )153,      (short const   )154, 
        (short const   )154,      (short const   )154,      (short const   )154,      (short const   )154, 
        (short const   )154,      (short const   )155,      (short const   )156,      (short const   )155, 
        (short const   )155,      (short const   )155,      (short const   )157,      (short const   )157, 
        (short const   )157,      (short const   )157,      (short const   )157,      (short const   )159, 
        (short const   )158,      (short const   )160,      (short const   )158,      (short const   )161, 
        (short const   )158,      (short const   )162,      (short const   )158,      (short const   )163, 
        (short const   )158,      (short const   )164,      (short const   )158,      (short const   )158, 
        (short const   )166,      (short const   )165,      (short const   )167,      (short const   )165, 
        (short const   )168,      (short const   )165,      (short const   )169,      (short const   )165, 
        (short const   )170,      (short const   )165,      (short const   )172,      (short const   )171, 
        (short const   )173,      (short const   )171,      (short const   )174,      (short const   )171, 
        (short const   )171,      (short const   )176,      (short const   )175,      (short const   )177, 
        (short const   )175,      (short const   )178,      (short const   )175,      (short const   )179, 
        (short const   )175,      (short const   )180,      (short const   )175,      (short const   )181, 
        (short const   )175,      (short const   )182,      (short const   )182,      (short const   )182, 
        (short const   )183,      (short const   )182,      (short const   )184,      (short const   )185, 
        (short const   )187,      (short const   )186,      (short const   )186,      (short const   )188, 
        (short const   )190,      (short const   )189,      (short const   )191,      (short const   )192, 
        (short const   )189,      (short const   )193,      (short const   )189,      (short const   )194, 
        (short const   )195,      (short const   )194,      (short const   )196,      (short const   )197, 
        (short const   )198,      (short const   )197,      (short const   )197,      (short const   )199, 
        (short const   )197,      (short const   )197,      (short const   )200,      (short const   )197, 
        (short const   )197,      (short const   )201,      (short const   )197,      (short const   )202, 
        (short const   )202,      (short const   )202,      (short const   )203,      (short const   )203, 
        (short const   )204,      (short const   )203,      (short const   )206,      (short const   )205, 
        (short const   )207,      (short const   )205,      (short const   )208,      (short const   )205, 
        (short const   )209,      (short const   )205,      (short const   )210,      (short const   )205, 
        (short const   )211,      (short const   )205,      (short const   )212,      (short const   )205, 
        (short const   )213,      (short const   )205,      (short const   )214,      (short const   )205, 
        (short const   )215,      (short const   )205,      (short const   )216,      (short const   )217, 
        (short const   )216,      (short const   )216,      (short const   )218,      (short const   )216, 
        (short const   )216,      (short const   )216,      (short const   )219,      (short const   )220, 
        (short const   )221,      (short const   )221,      (short const   )222,      (short const   )223, 
        (short const   )222,      (short const   )224,      (short const   )224,      (short const   )224, 
        (short const   )224,      (short const   )224,      (short const   )224,      (short const   )224, 
        (short const   )224,      (short const   )224,      (short const   )224,      (short const   )224, 
        (short const   )224,      (short const   )225,      (short const   )226,      (short const   )227, 
        (short const   )226,      (short const   )226,      (short const   )226,      (short const   )226, 
        (short const   )226,      (short const   )228,      (short const   )226,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )230,      (short const   )229,      (short const   )229, 
        (short const   )229,      (short const   )229,      (short const   )229,      (short const   )231, 
        (short const   )231,      (short const   )232,      (short const   )232,      (short const   )232, 
        (short const   )232,      (short const   )233,      (short const   )233,      (short const   )233, 
        (short const   )234,      (short const   )234,      (short const   )234,      (short const   )235, 
        (short const   )235,      (short const   )235,      (short const   )235,      (short const   )235, 
        (short const   )236,      (short const   )236,      (short const   )236,      (short const   )237, 
        (short const   )237,      (short const   )238,      (short const   )238,      (short const   )239, 
        (short const   )239,      (short const   )240,      (short const   )241,      (short const   )240, 
        (short const   )242,      (short const   )243,      (short const   )242,      (short const   )244, 
        (short const   )245,      (short const   )246,      (short const   )244,      (short const   )247, 
        (short const   )248,      (short const   )247,      (short const   )247,      (short const   )249, 
        (short const   )250,      (short const   )250,      (short const   )250,      (short const   )250, 
        (short const   )250,      (short const   )250,      (short const   )250,      (short const   )250, 
        (short const   )250,      (short const   )250,      (short const   )251,      (short const   )252, 
        (short const   )251,      (short const   )253};
#line 424 "ys.y"
static short const   yyr2[358]  = 
#line 424
  {      (short const   )0,      (short const   )2,      (short const   )0,      (short const   )2, 
        (short const   )0,      (short const   )1,      (short const   )1,      (short const   )2, 
        (short const   )1,      (short const   )2,      (short const   )1,      (short const   )3, 
        (short const   )1,      (short const   )2,      (short const   )2,      (short const   )2, 
        (short const   )2,      (short const   )3,      (short const   )2,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )1, 
        (short const   )2,      (short const   )0,      (short const   )3,      (short const   )8, 
        (short const   )8,      (short const   )3,      (short const   )1,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )2,      (short const   )2,      (short const   )0,      (short const   )6, 
        (short const   )0,      (short const   )6,      (short const   )0,      (short const   )0, 
        (short const   )7,      (short const   )0,      (short const   )8,      (short const   )3, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )0, 
        (short const   )5,      (short const   )0,      (short const   )4,      (short const   )0, 
        (short const   )4,      (short const   )0,      (short const   )3,      (short const   )2, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )2,      (short const   )2,      (short const   )3,      (short const   )1, 
        (short const   )2,      (short const   )0,      (short const   )6,      (short const   )0, 
        (short const   )5,      (short const   )2,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )2,      (short const   )4,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )1, 
        (short const   )3,      (short const   )1,      (short const   )2,      (short const   )3, 
        (short const   )0,      (short const   )5,      (short const   )0,      (short const   )6, 
        (short const   )2,      (short const   )1,      (short const   )3,      (short const   )1, 
        (short const   )3,      (short const   )2,      (short const   )1,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )0,      (short const   )3, 
        (short const   )2,      (short const   )3,      (short const   )1,      (short const   )0, 
        (short const   )4,      (short const   )2,      (short const   )3,      (short const   )1, 
        (short const   )1,      (short const   )2,      (short const   )3,      (short const   )2, 
        (short const   )3,      (short const   )3,      (short const   )4,      (short const   )2, 
        (short const   )3,      (short const   )3,      (short const   )4,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )2,      (short const   )0,      (short const   )5, 
        (short const   )3,      (short const   )5,      (short const   )1,      (short const   )1, 
        (short const   )5,      (short const   )6,      (short const   )4,      (short const   )0, 
        (short const   )3,      (short const   )0,      (short const   )4,      (short const   )0, 
        (short const   )4,      (short const   )0,      (short const   )5,      (short const   )0, 
        (short const   )4,      (short const   )0,      (short const   )5,      (short const   )1, 
        (short const   )0,      (short const   )3,      (short const   )0,      (short const   )4, 
        (short const   )0,      (short const   )4,      (short const   )0,      (short const   )4, 
        (short const   )0,      (short const   )3,      (short const   )0,      (short const   )3, 
        (short const   )0,      (short const   )4,      (short const   )0,      (short const   )4, 
        (short const   )2,      (short const   )0,      (short const   )3,      (short const   )0, 
        (short const   )4,      (short const   )0,      (short const   )4,      (short const   )0, 
        (short const   )4,      (short const   )0,      (short const   )5,      (short const   )0, 
        (short const   )5,      (short const   )2,      (short const   )2,      (short const   )3, 
        (short const   )0,      (short const   )4,      (short const   )0,      (short const   )2, 
        (short const   )0,      (short const   )4,      (short const   )1,      (short const   )1, 
        (short const   )0,      (short const   )4,      (short const   )0,      (short const   )0, 
        (short const   )6,      (short const   )0,      (short const   )4,      (short const   )4, 
        (short const   )0,      (short const   )6,      (short const   )0,      (short const   )3, 
        (short const   )0,      (short const   )6,      (short const   )4,      (short const   )0, 
        (short const   )7,      (short const   )4,      (short const   )0,      (short const   )7, 
        (short const   )5,      (short const   )0,      (short const   )8,      (short const   )2, 
        (short const   )3,      (short const   )4,      (short const   )3,      (short const   )3, 
        (short const   )0,      (short const   )5,      (short const   )0,      (short const   )3, 
        (short const   )0,      (short const   )4,      (short const   )0,      (short const   )5, 
        (short const   )0,      (short const   )6,      (short const   )0,      (short const   )6, 
        (short const   )0,      (short const   )4,      (short const   )0,      (short const   )5, 
        (short const   )0,      (short const   )6,      (short const   )0,      (short const   )7, 
        (short const   )0,      (short const   )7,      (short const   )2,      (short const   )0, 
        (short const   )4,      (short const   )2,      (short const   )0,      (short const   )4, 
        (short const   )3,      (short const   )3,      (short const   )0,      (short const   )2, 
        (short const   )1,      (short const   )1,      (short const   )2,      (short const   )0, 
        (short const   )4,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )3,      (short const   )1,      (short const   )1,      (short const   )0, 
        (short const   )5,      (short const   )3,      (short const   )3,      (short const   )2, 
        (short const   )2,      (short const   )0,      (short const   )4,      (short const   )1, 
        (short const   )2,      (short const   )2,      (short const   )2,      (short const   )2, 
        (short const   )2,      (short const   )0,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )2,      (short const   )4,      (short const   )1, 
        (short const   )4,      (short const   )1,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )1,      (short const   )3,      (short const   )3, 
        (short const   )1,      (short const   )3,      (short const   )3,      (short const   )1, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )1,      (short const   )3,      (short const   )3,      (short const   )1, 
        (short const   )3,      (short const   )1,      (short const   )3,      (short const   )1, 
        (short const   )3,      (short const   )1,      (short const   )0,      (short const   )4, 
        (short const   )1,      (short const   )0,      (short const   )4,      (short const   )1, 
        (short const   )0,      (short const   )0,      (short const   )7,      (short const   )1, 
        (short const   )0,      (short const   )4,      (short const   )2,      (short const   )0, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )3,      (short const   )3, 
        (short const   )3,      (short const   )3,      (short const   )1,      (short const   )0, 
        (short const   )4,      (short const   )1};
#line 463 "ys.y"
static short const   yydefact[602]  = 
#line 463
  {      (short const   )2,      (short const   )0,      (short const   )0,      (short const   )270, 
        (short const   )271,      (short const   )272,      (short const   )273,      (short const   )274, 
        (short const   )275,      (short const   )276,      (short const   )277,      (short const   )278, 
        (short const   )279,      (short const   )0,      (short const   )0,      (short const   )281, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )42,      (short const   )0,      (short const   )45,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )206,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )297,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )25,      (short const   )8, 
        (short const   )214,      (short const   )1,      (short const   )35,      (short const   )0, 
        (short const   )5,      (short const   )6,      (short const   )33,      (short const   )34, 
        (short const   )30,      (short const   )31,      (short const   )282,      (short const   )269, 
        (short const   )291,      (short const   )303,      (short const   )305,      (short const   )309, 
        (short const   )312,      (short const   )315,      (short const   )320,      (short const   )323, 
        (short const   )325,      (short const   )327,      (short const   )329,      (short const   )332, 
        (short const   )335,      (short const   )339,      (short const   )354,      (short const   )0, 
        (short const   )9,      (short const   )0,      (short const   )0,      (short const   )204, 
        (short const   )36,      (short const   )0,      (short const   )281,      (short const   )25, 
        (short const   )301,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )16,      (short const   )15, 
        (short const   )18,      (short const   )0,      (short const   )0,      (short const   )209, 
        (short const   )37,      (short const   )7,      (short const   )0,      (short const   )292, 
        (short const   )296,      (short const   )0,      (short const   )293,      (short const   )294, 
        (short const   )295,      (short const   )343,      (short const   )343,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )4,      (short const   )139, 
        (short const   )138,      (short const   )140,      (short const   )136,      (short const   )61, 
        (short const   )62,      (short const   )63,      (short const   )64,      (short const   )65, 
        (short const   )66,      (short const   )67,      (short const   )68,      (short const   )69, 
        (short const   )73,      (short const   )74,      (short const   )0,      (short const   )86, 
        (short const   )87,      (short const   )137,      (short const   )135,      (short const   )72, 
        (short const   )0,      (short const   )21,      (short const   )23,      (short const   )70, 
        (short const   )83,      (short const   )71,      (short const   )19,      (short const   )287, 
        (short const   )288,      (short const   )289,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )343,      (short const   )343,      (short const   )343, 
        (short const   )343,      (short const   )343,      (short const   )343,      (short const   )343, 
        (short const   )343,      (short const   )343,      (short const   )343,      (short const   )0, 
        (short const   )342,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )330,      (short const   )336,      (short const   )333, 
        (short const   )32,      (short const   )355,      (short const   )0,      (short const   )0, 
        (short const   )29,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )53,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )12,      (short const   )50, 
        (short const   )10,      (short const   )47,      (short const   )49,      (short const   )0, 
        (short const   )17,      (short const   )303,      (short const   )357,      (short const   )207, 
        (short const   )0,      (short const   )298,      (short const   )299,      (short const   )300, 
        (short const   )91,      (short const   )93,      (short const   )121,      (short const   )0, 
        (short const   )280,      (short const   )0,      (short const   )0,      (short const   )212, 
        (short const   )104,      (short const   )100,      (short const   )151,      (short const   )75, 
        (short const   )163,      (short const   )0,      (short const   )26,      (short const   )22, 
        (short const   )24,      (short const   )85,      (short const   )0,      (short const   )20, 
        (short const   )0,      (short const   )285,      (short const   )286,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )306, 
        (short const   )307,      (short const   )308,      (short const   )310,      (short const   )311, 
        (short const   )313,      (short const   )314,      (short const   )316,      (short const   )318, 
        (short const   )317,      (short const   )319,      (short const   )321,      (short const   )322, 
        (short const   )324,      (short const   )326,      (short const   )328,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )205,      (short const   )38,      (short const   )302, 
        (short const   )40,      (short const   )0,      (short const   )0,      (short const   )51, 
        (short const   )14,      (short const   )13,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )210,      (short const   )92,      (short const   )94, 
        (short const   )25,      (short const   )0,      (short const   )123,      (short const   )122, 
        (short const   )124,      (short const   )304,      (short const   )211,      (short const   )3, 
        (short const   )0,      (short const   )4,      (short const   )102,      (short const   )0, 
        (short const   )159,      (short const   )0,      (short const   )0,      (short const   )153, 
        (short const   )79,      (short const   )77,      (short const   )76,      (short const   )155, 
        (short const   )0,      (short const   )25,      (short const   )265,      (short const   )290, 
        (short const   )264,      (short const   )0,      (short const   )0,      (short const   )344, 
        (short const   )345,      (short const   )346,      (short const   )347,      (short const   )348, 
        (short const   )349,      (short const   )350,      (short const   )351,      (short const   )352, 
        (short const   )353,      (short const   )341,      (short const   )331,      (short const   )0, 
        (short const   )334,      (short const   )356,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )43,      (short const   )57, 
        (short const   )54,      (short const   )0,      (short const   )0,      (short const   )11, 
        (short const   )0,      (short const   )0,      (short const   )131,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )127,      (short const   )0, 
        (short const   )125,      (short const   )25,      (short const   )0,      (short const   )234, 
        (short const   )231,      (short const   )0,      (short const   )230,      (short const   )0, 
        (short const   )0,      (short const   )107,      (short const   )0,      (short const   )105, 
        (short const   )25,      (short const   )0,      (short const   )227,      (short const   )0, 
        (short const   )198,      (short const   )198,      (short const   )152,      (short const   )196, 
        (short const   )0,      (short const   )0,      (short const   )80,      (short const   )78, 
        (short const   )161,      (short const   )0,      (short const   )157,      (short const   )25, 
        (short const   )0,      (short const   )25,      (short const   )88,      (short const   )266, 
        (short const   )267,      (short const   )284,      (short const   )337,      (short const   )0, 
        (short const   )0,      (short const   )202,      (short const   )39,      (short const   )203, 
        (short const   )41,      (short const   )0,      (short const   )0,      (short const   )55, 
        (short const   )52,      (short const   )0,      (short const   )208,      (short const   )141, 
        (short const   )126,      (short const   )133,      (short const   )129,      (short const   )132, 
        (short const   )0,      (short const   )128,      (short const   )0,      (short const   )25, 
        (short const   )236,      (short const   )0,      (short const   )25,      (short const   )244, 
        (short const   )213,      (short const   )0,      (short const   )0,      (short const   )101, 
        (short const   )0,      (short const   )164,      (short const   )0,      (short const   )0, 
        (short const   )160,      (short const   )0,      (short const   )228,      (short const   )114, 
        (short const   )199,      (short const   )113,      (short const   )193,      (short const   )0, 
        (short const   )194,      (short const   )0,      (short const   )0,      (short const   )154, 
        (short const   )25,      (short const   )156,      (short const   )0,      (short const   )25, 
        (short const   )0,      (short const   )84,      (short const   )89,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )48,      (short const   )44,      (short const   )60,      (short const   )58, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )142,      (short const   )147,      (short const   )144,      (short const   )146, 
        (short const   )134,      (short const   )130,      (short const   )238,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )262, 
        (short const   )262,      (short const   )235,      (short const   )0,      (short const   )233, 
        (short const   )25,      (short const   )246,      (short const   )0,      (short const   )103, 
        (short const   )108,      (short const   )106,      (short const   )0,      (short const   )0, 
        (short const   )141,      (short const   )166,      (short const   )168,      (short const   )0, 
        (short const   )181,      (short const   )0,      (short const   )195,      (short const   )0, 
        (short const   )229,      (short const   )162,      (short const   )158,      (short const   )82, 
        (short const   )111,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )95,      (short const   )97,      (short const   )110,      (short const   )268, 
        (short const   )338,      (short const   )27,      (short const   )28,      (short const   )0, 
        (short const   )59,      (short const   )56,      (short const   )46,      (short const   )0, 
        (short const   )25,      (short const   )25,      (short const   )0,      (short const   )240, 
        (short const   )242,      (short const   )237,      (short const   )263,      (short const   )254, 
        (short const   )0,      (short const   )257,      (short const   )0,      (short const   )248, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )245, 
        (short const   )165,      (short const   )173,      (short const   )215,      (short const   )147, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )118, 
        (short const   )115,      (short const   )0,      (short const   )185,      (short const   )0, 
        (short const   )183,      (short const   )187,      (short const   )197,      (short const   )112, 
        (short const   )98,      (short const   )109,      (short const   )90,      (short const   )0, 
        (short const   )0,      (short const   )201,      (short const   )0,      (short const   )143, 
        (short const   )145,      (short const   )239,      (short const   )0,      (short const   )0, 
        (short const   )25,      (short const   )260,      (short const   )25,      (short const   )261, 
        (short const   )0,      (short const   )250,      (short const   )252,      (short const   )247, 
        (short const   )216,      (short const   )218,      (short const   )221,      (short const   )167, 
        (short const   )169,      (short const   )171,      (short const   )116,      (short const   )119, 
        (short const   )0,      (short const   )182,      (short const   )0,      (short const   )191, 
        (short const   )0,      (short const   )189,      (short const   )96,      (short const   )99, 
        (short const   )25,      (short const   )150,      (short const   )241,      (short const   )243, 
        (short const   )256,      (short const   )259,      (short const   )249,      (short const   )0, 
        (short const   )0,      (short const   )25,      (short const   )219,      (short const   )222, 
        (short const   )224,      (short const   )117,      (short const   )0,      (short const   )0, 
        (short const   )174,      (short const   )0,      (short const   )186,      (short const   )0, 
        (short const   )184,      (short const   )0,      (short const   )188,      (short const   )0, 
        (short const   )148,      (short const   )0,      (short const   )251,      (short const   )253, 
        (short const   )0,      (short const   )217,      (short const   )25,      (short const   )25, 
        (short const   )225,      (short const   )120,      (short const   )180,      (short const   )0, 
        (short const   )176,      (short const   )178,      (short const   )192,      (short const   )190, 
        (short const   )149,      (short const   )0,      (short const   )220,      (short const   )223, 
        (short const   )25,      (short const   )175,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )226,      (short const   )177,      (short const   )179, 
        (short const   )0,      (short const   )0};
#line 527 "ys.y"
static short const   yydefgoto[154]  = 
#line 527
  {      (short const   )1,      (short const   )201,      (short const   )41,      (short const   )275, 
        (short const   )42,      (short const   )124,      (short const   )394,      (short const   )44, 
        (short const   )184,      (short const   )46,      (short const   )312,      (short const   )313, 
        (short const   )47,      (short const   )78,      (short const   )369,      (short const   )81, 
        (short const   )421,      (short const   )187,      (short const   )185,      (short const   )80, 
        (short const   )318,      (short const   )258,      (short const   )316,      (short const   )425, 
        (short const   )370,      (short const   )423,      (short const   )125,      (short const   )126, 
        (short const   )333,      (short const   )286,      (short const   )127,      (short const   )288, 
        (short const   )214,      (short const   )128,      (short const   )357,      (short const   )358, 
        (short const   )198,      (short const   )467,      (short const   )468,      (short const   )129, 
        (short const   )279,      (short const   )336,      (short const   )338,      (short const   )339, 
        (short const   )469,      (short const   )470,      (short const   )400,      (short const   )455, 
        (short const   )504,      (short const   )505,      (short const   )562,      (short const   )100, 
        (short const   )271,      (short const   )272,      (short const   )130,      (short const   )395, 
        (short const   )480,      (short const   )430,      (short const   )210,      (short const   )282, 
        (short const   )349,      (short const   )353,      (short const   )410,      (short const   )340, 
        (short const   )408,      (short const   )396,      (short const   )450,      (short const   )500, 
        (short const   )501,      (short const   )502,      (short const   )451,      (short const   )566, 
        (short const   )583,      (short const   )594,      (short const   )595,      (short const   )458, 
        (short const   )507,      (short const   )542,      (short const   )540,      (short const   )544, 
        (short const   )571,      (short const   )569,      (short const   )346,      (short const   )405, 
        (short const   )402,      (short const   )347,      (short const   )366,      (short const   )419, 
        (short const   )368,      (short const   )48,      (short const   )173,      (short const   )86, 
        (short const   )264,      (short const   )192,      (short const   )49,      (short const   )277, 
        (short const   )102,      (short const   )397,      (short const   )557,      (short const   )578, 
        (short const   )579,      (short const   )592,      (short const   )431,      (short const   )203, 
        (short const   )386,      (short const   )334,      (short const   )385,      (short const   )437, 
        (short const   )482,      (short const   )522,      (short const   )523,      (short const   )446, 
        (short const   )494,      (short const   )528,      (short const   )555,      (short const   )556, 
        (short const   )441,      (short const   )524,      (short const   )526,      (short const   )487, 
        (short const   )442,      (short const   )291,      (short const   )292,      (short const   )415, 
        (short const   )50,      (short const   )51,      (short const   )52,      (short const   )136, 
        (short const   )216,      (short const   )53,      (short const   )93,      (short const   )54, 
        (short const   )55,      (short const   )56,      (short const   )57,      (short const   )58, 
        (short const   )59,      (short const   )60,      (short const   )61,      (short const   )62, 
        (short const   )63,      (short const   )247,      (short const   )64,      (short const   )249, 
        (short const   )65,      (short const   )248,      (short const   )416,      (short const   )66, 
        (short const   )147,      (short const   )194,      (short const   )148,      (short const   )67, 
        (short const   )250,      (short const   )191};
#line 546 "ys.y"
static short const   yypact[602]  = 
#line 546
  {      (short const   )-32768,      (short const   )589,      (short const   )-74,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-54,      (short const   )43,      (short const   )13, 
        (short const   )-14,      (short const   )-4,      (short const   )498,      (short const   )62, 
        (short const   )-32768,      (short const   )71,      (short const   )-32768,      (short const   )69, 
        (short const   )87,      (short const   )933,      (short const   )-32768,      (short const   )153, 
        (short const   )122,      (short const   )127,      (short const   )1236,      (short const   )1236, 
        (short const   )-32768,      (short const   )1236,      (short const   )1236,      (short const   )1236, 
        (short const   )1236,      (short const   )1236,      (short const   )1288,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )1366, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )121,      (short const   )500,      (short const   )-32768,      (short const   )118, 
        (short const   )157,      (short const   )164,      (short const   )150,      (short const   )180, 
        (short const   )142,      (short const   )189,      (short const   )235,      (short const   )239, 
        (short const   )60,      (short const   )-32768,      (short const   )-32768,      (short const   )123, 
        (short const   )-32768,      (short const   )246,      (short const   )216,      (short const   )-32768, 
        (short const   )-32768,      (short const   )1288,      (short const   )-32768,      (short const   )1288, 
        (short const   )-32768,      (short const   )1288,      (short const   )231,      (short const   )978, 
        (short const   )881,      (short const   )881,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )141,      (short const   )1288,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )1288,      (short const   )-32768, 
        (short const   )-32768,      (short const   )1236,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )715, 
        (short const   )233,      (short const   )-29,      (short const   )1399,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )9,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )12,      (short const   )1366,      (short const   )1366,      (short const   )-32768, 
        (short const   )301,      (short const   )-32768,      (short const   )1366,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )305,      (short const   )306, 
        (short const   )237,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )263, 
        (short const   )-32768,      (short const   )1288,      (short const   )1288,      (short const   )1288, 
        (short const   )1288,      (short const   )1288,      (short const   )1288,      (short const   )1288, 
        (short const   )1288,      (short const   )1288,      (short const   )1288,      (short const   )1288, 
        (short const   )1288,      (short const   )1288,      (short const   )1288,      (short const   )1288, 
        (short const   )1288,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )232,      (short const   )234, 
        (short const   )-32768,      (short const   )881,      (short const   )27,      (short const   )245, 
        (short const   )32,      (short const   )1288,      (short const   )-32768,      (short const   )152, 
        (short const   )214,      (short const   )319,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )300, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )881,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )715,      (short const   )715,      (short const   )37,      (short const   )1288, 
        (short const   )-32768,      (short const   )685,      (short const   )1366,      (short const   )-32768, 
        (short const   )244,      (short const   )-32768,      (short const   )139,      (short const   )10, 
        (short const   )-32768,      (short const   )324,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )249,      (short const   )250,      (short const   )-32768, 
        (short const   )1179,      (short const   )-32768,      (short const   )-32768,      (short const   )1288, 
        (short const   )1288,      (short const   )1288,      (short const   )1288,      (short const   )1288, 
        (short const   )1288,      (short const   )1288,      (short const   )1288,      (short const   )1288, 
        (short const   )1288,      (short const   )1288,      (short const   )1288,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )118,      (short const   )118, 
        (short const   )157,      (short const   )157,      (short const   )164,      (short const   )164, 
        (short const   )164,      (short const   )164,      (short const   )150,      (short const   )150, 
        (short const   )180,      (short const   )142,      (short const   )189,      (short const   )1288, 
        (short const   )1288,      (short const   )1288,      (short const   )1288,      (short const   )339, 
        (short const   )340,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )68,      (short const   )1030,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )255,      (short const   )262, 
        (short const   )298,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )86,      (short const   )1086,      (short const   )182,      (short const   )-32768, 
        (short const   )186,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )17,      (short const   )-32768,      (short const   )-32768,      (short const   )334, 
        (short const   )-32768,      (short const   )5,      (short const   )55,      (short const   )265, 
        (short const   )-32768,      (short const   )-32768,      (short const   )10,      (short const   )187, 
        (short const   )260,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )90,      (short const   )81,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )235,      (short const   )6, 
        (short const   )239,      (short const   )-32768,      (short const   )264,      (short const   )266, 
        (short const   )881,      (short const   )881,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )163,      (short const   )1030,      (short const   )-32768, 
        (short const   )1288,      (short const   )881,      (short const   )-32768,      (short const   )1366, 
        (short const   )269,      (short const   )271,      (short const   )-32768,      (short const   )272, 
        (short const   )186,      (short const   )273,      (short const   )1142,      (short const   )190, 
        (short const   )1432,      (short const   )345,      (short const   )-32768,      (short const   )783, 
        (short const   )334,      (short const   )302,      (short const   )20,      (short const   )-32768, 
        (short const   )276,      (short const   )277,      (short const   )-32768,      (short const   )452, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )275, 
        (short const   )369,      (short const   )55,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )55,      (short const   )265,      (short const   )-32768, 
        (short const   )715,      (short const   )278,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )353, 
        (short const   )355,      (short const   )342,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )881,      (short const   )1199,      (short const   )-32768, 
        (short const   )-32768,      (short const   )96,      (short const   )-32768,      (short const   )80, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )286,      (short const   )-32768,      (short const   )285,      (short const   )291, 
        (short const   )265,      (short const   )95,      (short const   )-32768,      (short const   )194, 
        (short const   )-32768,      (short const   )196,      (short const   )1288,      (short const   )-32768, 
        (short const   )334,      (short const   )288,      (short const   )1366,      (short const   )292, 
        (short const   )-32768,      (short const   )296,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )11, 
        (short const   )-32768,      (short const   )289,      (short const   )297,      (short const   )-32768, 
        (short const   )276,      (short const   )-32768,      (short const   )55,      (short const   )294, 
        (short const   )8,      (short const   )-32768,      (short const   )-32768,      (short const   )1288, 
        (short const   )1288,      (short const   )293,      (short const   )304,      (short const   )356, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )105,      (short const   )1199,      (short const   )307,      (short const   )310, 
        (short const   )-32768,      (short const   )-32768,      (short const   )303,      (short const   )265, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )314, 
        (short const   )315,      (short const   )95,      (short const   )452,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )165,      (short const   )-32768, 
        (short const   )316,      (short const   )265,      (short const   )95,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )55,      (short const   )311, 
        (short const   )0,      (short const   )-32768,      (short const   )313,      (short const   )452, 
        (short const   )204,      (short const   )375,      (short const   )-32768,      (short const   )11, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )309,      (short const   )1288,      (short const   )377,      (short const   )174, 
        (short const   )-32768,      (short const   )357,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )881, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )322, 
        (short const   )-32768,      (short const   )-32768,      (short const   )95,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )1465, 
        (short const   )14,      (short const   )1498,      (short const   )14,      (short const   )-32768, 
        (short const   )323,      (short const   )325,      (short const   )95,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-52,      (short const   )394, 
        (short const   )55,      (short const   )55,      (short const   )311,      (short const   )-32768, 
        (short const   )-32768,      (short const   )200,      (short const   )-32768,      (short const   )55, 
        (short const   )265,      (short const   )210,      (short const   )-32768,      (short const   )265, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )8, 
        (short const   )1288,      (short const   )-32768,      (short const   )211,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )95,      (short const   )95, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )95,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )72,      (short const   )100,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )320, 
        (short const   )1108,      (short const   )-32768,      (short const   )55,      (short const   )-32768, 
        (short const   )55,      (short const   )265,      (short const   )-32768,      (short const   )-32768, 
        (short const   )327,      (short const   )265,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )95, 
        (short const   )95,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )106,      (short const   )-32768,      (short const   )452,      (short const   )321, 
        (short const   )-32768,      (short const   )330,      (short const   )-32768,      (short const   )331, 
        (short const   )-32768,      (short const   )1108,      (short const   )-32768,      (short const   )55, 
        (short const   )-32768,      (short const   )333,      (short const   )-32768,      (short const   )-32768, 
        (short const   )1366,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )55, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )28,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )55,      (short const   )55, 
        (short const   )394,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )425,      (short const   )-32768};
#line 610 "ys.y"
static short const   yypgoto[154]  = 
#line 610
  {      (short const   )-32768,      (short const   )149,      (short const   )-32768,      (short const   )-71, 
        (short const   )-32768,      (short const   )-123,      (short const   )-1,      (short const   )-32768, 
        (short const   )426,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )110,      (short const   )-32768, 
        (short const   )-32768,      (short const   )4,      (short const   )-87,      (short const   )-93, 
        (short const   )-120,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )75,      (short const   )-330, 
        (short const   )-172,      (short const   )-32768,      (short const   )-82,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )98,      (short const   )54, 
        (short const   )-32768,      (short const   )-19,      (short const   )-412,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )374, 
        (short const   )183,      (short const   )184,      (short const   )-32768,      (short const   )-223, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )42,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-117, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )7, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-163,      (short const   )-32768, 
        (short const   )120,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-417,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-372,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-175,      (short const   )-371, 
        (short const   )-32768,      (short const   )-184,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-398,      (short const   )-32768,      (short const   )-32768,      (short const   )30, 
        (short const   )-32768,      (short const   )-32768,      (short const   )52,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-17,      (short const   )-32768,      (short const   )-84, 
        (short const   )138,      (short const   )160,      (short const   )77,      (short const   )159, 
        (short const   )312,      (short const   )308,      (short const   )317,      (short const   )221, 
        (short const   )223,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-81,      (short const   )-32768,      (short const   )-32768,      (short const   )-170, 
        (short const   )-32768,      (short const   )299,      (short const   )-32768,      (short const   )-2, 
        (short const   )-32768,      (short const   )-241};
#line 633 "ys.y"
static short const   yytable[1553]  = 
#line 633
  {      (short const   )43,      (short const   )76,      (short const   )211,      (short const   )212, 
        (short const   )209,      (short const   )190,      (short const   )197,      (short const   )215, 
        (short const   )341,      (short const   )183,      (short const   )186,      (short const   )436, 
        (short const   )196,      (short const   )91,      (short const   )92,      (short const   )443, 
        (short const   )94,      (short const   )95,      (short const   )96,      (short const   )97, 
        (short const   )98,      (short const   )498,      (short const   )68,      (short const   )85, 
        (short const   )266,      (short const   )267,      (short const   )486,      (short const   )414, 
        (short const   )327,      (short const   )464,      (short const   )204,      (short const   )283, 
        (short const   )456,      (short const   )206,      (short const   )497,      (short const   )331, 
        (short const   )101,      (short const   )99,      (short const   )331,      (short const   )485, 
        (short const   )281,      (short const   )116,      (short const   )117,      (short const   )503, 
        (short const   )69,      (short const   )325,      (short const   )293,      (short const   )532, 
        (short const   )495,      (short const   )498,      (short const   )295,      (short const   )296, 
        (short const   )297,      (short const   )298,      (short const   )299,      (short const   )300, 
        (short const   )301,      (short const   )302,      (short const   )303,      (short const   )304, 
        (short const   )305,      (short const   )362,      (short const   )200,      (short const   )465, 
        (short const   )70,      (short const   )231,      (short const   )232,      (short const   )233, 
        (short const   )71,      (short const   )189,      (short const   )169,      (short const   )174, 
        (short const   )493,      (short const   )101,      (short const   )99,      (short const   )176, 
        (short const   )193,      (short const   )179,      (short const   )270,      (short const   )276, 
        (short const   )309,      (short const   )414,      (short const   )72,      (short const   )207, 
        (short const   )521,      (short const   )537,      (short const   )73,      (short const   )285, 
        (short const   )101,      (short const   )382,      (short const   )427,      (short const   )207, 
        (short const   )281,      (short const   )207,      (short const   )207,      (short const   )207, 
        (short const   )531,      (short const   )207,      (short const   )342,      (short const   )428, 
        (short const   )207,      (short const   )202,      (short const   )253,      (short const   )197, 
        (short const   )197,      (short const   )169,      (short const   )380,      (short const   )205, 
        (short const   )208,      (short const   )196,      (short const   )196,      (short const   )207, 
        (short const   )354,      (short const   )332,      (short const   )284,      (short const   )273, 
        (short const   )166,      (short const   )391,      (short const   )254,      (short const   )392, 
        (short const   )207,      (short const   )265,      (short const   )343,      (short const   )256, 
        (short const   )550,      (short const   )551,      (short const   )169,      (short const   )268, 
        (short const   )167,      (short const   )269,      (short const   )554,      (short const   )169, 
        (short const   )189,      (short const   )189,      (short const   )189,      (short const   )189, 
        (short const   )189,      (short const   )189,      (short const   )189,      (short const   )189, 
        (short const   )189,      (short const   )189,      (short const   )189,      (short const   )189, 
        (short const   )189,      (short const   )189,      (short const   )189,      (short const   )189, 
        (short const   )270,      (short const   )448,      (short const   )581,      (short const   )344, 
        (short const   )77,      (short const   )552,      (short const   )345,      (short const   )553, 
        (short const   )384,      (short const   )574,      (short const   )575,      (short const   )314, 
        (short const   )435,      (short const   )79,      (short const   )438,      (short const   )207, 
        (short const   )348,      (short const   )82,      (short const   )351,      (short const   )169, 
        (short const   )567,      (short const   )207,      (short const   )427,      (short const   )558, 
        (short const   )281,      (short const   )401,      (short const   )361,      (short const   )257, 
        (short const   )268,      (short const   )322,      (short const   )269,      (short const   )428, 
        (short const   )169,      (short const   )359,      (short const   )189,      (short const   )83, 
        (short const   )412,      (short const   )577,      (short const   )407,      (short const   )426, 
        (short const   )190,      (short const   )360,      (short const   )409,      (short const   )439, 
        (short const   )281,      (short const   )350,      (short const   )440,      (short const   )169, 
        (short const   )476,      (short const   )567,      (short const   )348,      (short const   )559, 
        (short const   )375,      (short const   )149,      (short const   )150,      (short const   )151, 
        (short const   )169,      (short const   )580,      (short const   )590,      (short const   )591, 
        (short const   )87,      (short const   )131,      (short const   )132,      (short const   )133, 
        (short const   )445,      (short const   )-283,      (short const   )162,      (short const   )134, 
        (short const   )135,      (short const   )294,      (short const   )88,      (short const   )168, 
        (short const   )597,      (short const   )492,      (short const   )169,      (short const   )89, 
        (short const   )512,      (short const   )156,      (short const   )157,      (short const   )158, 
        (short const   )159,      (short const   )280,      (short const   )189,      (short const   )281, 
        (short const   )189,      (short const   )238,      (short const   )239,      (short const   )240, 
        (short const   )241,      (short const   )188,      (short const   )152,      (short const   )153, 
        (short const   )169,      (short const   )365,      (short const   )367,      (short const   )154, 
        (short const   )155,      (short const   )293,      (short const   )307,      (short const   )462, 
        (short const   )259,      (short const   )190,      (short const   )374,      (short const   )169, 
        (short const   )189,      (short const   )160,      (short const   )161,      (short const   )429, 
        (short const   )317,      (short const   )519,      (short const   )520,      (short const   )371, 
        (short const   )163,      (short const   )489,      (short const   )169,      (short const   )197, 
        (short const   )490,      (short const   )170,      (short const   )171,      (short const   )323, 
        (short const   )401,      (short const   )196,      (short const   )514,      (short const   )452, 
        (short const   )268,      (short const   )515,      (short const   )269,      (short const   )547, 
        (short const   )329,      (short const   )352,      (short const   )330,      (short const   )281, 
        (short const   )383,      (short const   )508,      (short const   )281,      (short const   )457, 
        (short const   )444,      (short const   )401,      (short const   )281,      (short const   )496, 
        (short const   )356,      (short const   )511,      (short const   )234,      (short const   )235, 
        (short const   )466,      (short const   )447,      (short const   )506,      (short const   )392, 
        (short const   )281,      (short const   )538,      (short const   )420,      (short const   )539, 
        (short const   )543,      (short const   )548,      (short const   )281,      (short const   )281, 
        (short const   )525,      (short const   )164,      (short const   )527,      (short const   )479, 
        (short const   )165,      (short const   )190,      (short const   )260,      (short const   )261, 
        (short const   )172,      (short const   )189,      (short const   )236,      (short const   )237, 
        (short const   )317,      (short const   )565,      (short const   )373,      (short const   )242, 
        (short const   )243,      (short const   )177,      (short const   )213,      (short const   )533, 
        (short const   )199,      (short const   )573,      (short const   )217,      (short const   )218, 
        (short const   )323,      (short const   )219,      (short const   )230,      (short const   )251, 
        (short const   )499,      (short const   )252,      (short const   )545,      (short const   )472, 
        (short const   )255,      (short const   )535,      (short const   )536,      (short const   )457, 
        (short const   )262,      (short const   )263,      (short const   )278,      (short const   )549, 
        (short const   )541,      (short const   )287,      (short const   )565,      (short const   )-81, 
        (short const   )289,      (short const   )310,      (short const   )311,      (short const   )319, 
        (short const   )320,      (short const   )321,      (short const   )356,      (short const   )337, 
        (short const   )356,      (short const   )348,      (short const   )355,      (short const   )560, 
        (short const   )376,      (short const   )363,      (short const   )377,      (short const   )364, 
        (short const   )379,      (short const   )378,      (short const   )387,      (short const   )393, 
        (short const   )424,      (short const   )390,      (short const   )398,      (short const   )404, 
        (short const   )406,      (short const   )189,      (short const   )417,      (short const   )413, 
        (short const   )418,      (short const   )432,      (short const   )433,      (short const   )568, 
        (short const   )-200,      (short const   )570,      (short const   )434,      (short const   )453, 
        (short const   )190,      (short const   )202,      (short const   )-172,      (short const   )454, 
        (short const   )459,      (short const   )473,      (short const   )460,      (short const   )463, 
        (short const   )401,      (short const   )207,      (short const   )475,      (short const   )466, 
        (short const   )509,      (short const   )195,      (short const   )464,      (short const   )189, 
        (short const   )474,      (short const   )281,      (short const   )481,      (short const   )478, 
        (short const   )517,      (short const   )483,      (short const   )484,      (short const   )491, 
        (short const   )587,      (short const   )40,      (short const   )356,      (short const   )-170, 
        (short const   )516,      (short const   )518,      (short const   )529,      (short const   )534, 
        (short const   )530,      (short const   )561,      (short const   )572,      (short const   )582, 
        (short const   )593,      (short const   )584,      (short const   )585,      (short const   )424, 
        (short const   )588,      (short const   )601,      (short const   )335,      (short const   )45, 
        (short const   )372,      (short const   )477,      (short const   )411,      (short const   )598, 
        (short const   )599,      (short const   )546,      (short const   )389,      (short const   )190, 
        (short const   )220,      (short const   )221,      (short const   )222,      (short const   )223, 
        (short const   )224,      (short const   )225,      (short const   )226,      (short const   )227, 
        (short const   )228,      (short const   )229,      (short const   )449,      (short const   )513, 
        (short const   )189,      (short const   )175,      (short const   )461,      (short const   )324, 
        (short const   )586,      (short const   )589,      (short const   )328,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )403,      (short const   )510,      (short const   )471, 
        (short const   )306,      (short const   )596,      (short const   )488,      (short const   )245, 
        (short const   )308,      (short const   )74,      (short const   )244,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )323, 
        (short const   )323,      (short const   )246,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )18, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )189, 
        (short const   )0,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )74, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )202, 
        (short const   )30,      (short const   )202,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )31,      (short const   )32,      (short const   )33, 
        (short const   )0,      (short const   )18,      (short const   )34,      (short const   )35, 
        (short const   )36,      (short const   )37,      (short const   )38,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )323, 
        (short const   )0,      (short const   )0,      (short const   )399,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )576,      (short const   )137,      (short const   )138,      (short const   )139, 
        (short const   )140,      (short const   )141,      (short const   )142,      (short const   )143, 
        (short const   )144,      (short const   )145,      (short const   )146,      (short const   )-340, 
        (short const   )0,      (short const   )0,      (short const   )30,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )576,      (short const   )576,      (short const   )31, 
        (short const   )32,      (short const   )33,      (short const   )0,      (short const   )0, 
        (short const   )34,      (short const   )35,      (short const   )36,      (short const   )37, 
        (short const   )75,      (short const   )600,      (short const   )2,      (short const   )576, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )13,      (short const   )14, 
        (short const   )0,      (short const   )0,      (short const   )15,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )16,      (short const   )17,      (short const   )0, 
        (short const   )18,      (short const   )19,      (short const   )20,      (short const   )21, 
        (short const   )22,      (short const   )23,      (short const   )24,      (short const   )25, 
        (short const   )0,      (short const   )26,      (short const   )27,      (short const   )28, 
        (short const   )29,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )30,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )31,      (short const   )32, 
        (short const   )33,      (short const   )0,      (short const   )0,      (short const   )34, 
        (short const   )35,      (short const   )36,      (short const   )37,      (short const   )38, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )39,      (short const   )180,      (short const   )40, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )15,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )16,      (short const   )17,      (short const   )0, 
        (short const   )18,      (short const   )19,      (short const   )20,      (short const   )21, 
        (short const   )22,      (short const   )23,      (short const   )24,      (short const   )25, 
        (short const   )181,      (short const   )26,      (short const   )27,      (short const   )28, 
        (short const   )0,      (short const   )107,      (short const   )108,      (short const   )109, 
        (short const   )110,      (short const   )111,      (short const   )112,      (short const   )113, 
        (short const   )114,      (short const   )115,      (short const   )116,      (short const   )117, 
        (short const   )118,      (short const   )119,      (short const   )120,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )30,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )31,      (short const   )32, 
        (short const   )33,      (short const   )123,      (short const   )0,      (short const   )34, 
        (short const   )35,      (short const   )36,      (short const   )37,      (short const   )38, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )182,      (short const   )274,      (short const   )40, 
        (short const   )180,      (short const   )0,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )15,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )16, 
        (short const   )17,      (short const   )0,      (short const   )18,      (short const   )19, 
        (short const   )20,      (short const   )21,      (short const   )22,      (short const   )23, 
        (short const   )24,      (short const   )25,      (short const   )181,      (short const   )26, 
        (short const   )27,      (short const   )28,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )30, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )31,      (short const   )32,      (short const   )33,      (short const   )0, 
        (short const   )0,      (short const   )34,      (short const   )35,      (short const   )36, 
        (short const   )37,      (short const   )38,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )182, 
        (short const   )388,      (short const   )40,      (short const   )180,      (short const   )0, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )15,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )16,      (short const   )17,      (short const   )0, 
        (short const   )18,      (short const   )19,      (short const   )20,      (short const   )21, 
        (short const   )22,      (short const   )23,      (short const   )24,      (short const   )25, 
        (short const   )181,      (short const   )26,      (short const   )27,      (short const   )28, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )30,      (short const   )74,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )31,      (short const   )32, 
        (short const   )33,      (short const   )0,      (short const   )0,      (short const   )34, 
        (short const   )35,      (short const   )36,      (short const   )37,      (short const   )38, 
        (short const   )18,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )182,      (short const   )0,      (short const   )40, 
        (short const   )0,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )74, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )30,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )31,      (short const   )32, 
        (short const   )33,      (short const   )18,      (short const   )0,      (short const   )34, 
        (short const   )35,      (short const   )36,      (short const   )37,      (short const   )38, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )84,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )30,      (short const   )74, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )31, 
        (short const   )32,      (short const   )33,      (short const   )0,      (short const   )0, 
        (short const   )34,      (short const   )35,      (short const   )36,      (short const   )37, 
        (short const   )38,      (short const   )18,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )178,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )30,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )74, 
        (short const   )0,      (short const   )563,      (short const   )0,      (short const   )31, 
        (short const   )32,      (short const   )33,      (short const   )0,      (short const   )0, 
        (short const   )34,      (short const   )35,      (short const   )36,      (short const   )37, 
        (short const   )38,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )18,      (short const   )315,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )0,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )30,      (short const   )0, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )74, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )31, 
        (short const   )32,      (short const   )33,      (short const   )0,      (short const   )0, 
        (short const   )34,      (short const   )35,      (short const   )36,      (short const   )37, 
        (short const   )38,      (short const   )0,      (short const   )0,      (short const   )326, 
        (short const   )0,      (short const   )18,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )564, 
        (short const   )74,      (short const   )0,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )0,      (short const   )0,      (short const   )30,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )18,      (short const   )0, 
        (short const   )74,      (short const   )0,      (short const   )0,      (short const   )31, 
        (short const   )32,      (short const   )33,      (short const   )0,      (short const   )0, 
        (short const   )34,      (short const   )35,      (short const   )36,      (short const   )37, 
        (short const   )38,      (short const   )0,      (short const   )0,      (short const   )381, 
        (short const   )0,      (short const   )0,      (short const   )18,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )0,      (short const   )0,      (short const   )30, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )74,      (short const   )0,      (short const   )0, 
        (short const   )31,      (short const   )32,      (short const   )33,      (short const   )0, 
        (short const   )0,      (short const   )34,      (short const   )35,      (short const   )36, 
        (short const   )37,      (short const   )38,      (short const   )290,      (short const   )30, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )18, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )31,      (short const   )32,      (short const   )33,      (short const   )0, 
        (short const   )0,      (short const   )34,      (short const   )35,      (short const   )36, 
        (short const   )37,      (short const   )38,      (short const   )422,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )30,      (short const   )74,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )31,      (short const   )32,      (short const   )33, 
        (short const   )0,      (short const   )0,      (short const   )34,      (short const   )35, 
        (short const   )36,      (short const   )37,      (short const   )90,      (short const   )18, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )30,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )31,      (short const   )32,      (short const   )33, 
        (short const   )0,      (short const   )0,      (short const   )34,      (short const   )35, 
        (short const   )36,      (short const   )37,      (short const   )38,      (short const   )103, 
        (short const   )104,      (short const   )105,      (short const   )106,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )107,      (short const   )108,      (short const   )109,      (short const   )110, 
        (short const   )111,      (short const   )112,      (short const   )113,      (short const   )114, 
        (short const   )115,      (short const   )116,      (short const   )117,      (short const   )118, 
        (short const   )119,      (short const   )120,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )0,      (short const   )0,      (short const   )121,      (short const   )122, 
        (short const   )123,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-25,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )-232,      (short const   )-232,      (short const   )-232, 
        (short const   )-232,      (short const   )0,      (short const   )0,      (short const   )-25, 
        (short const   )-25,      (short const   )-25,      (short const   )-232,      (short const   )-232, 
        (short const   )-232,      (short const   )-232,      (short const   )-232,      (short const   )-232, 
        (short const   )-232,      (short const   )-232,      (short const   )-232,      (short const   )-232, 
        (short const   )-232,      (short const   )-232,      (short const   )-232,      (short const   )-232, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )-255,      (short const   )-255, 
        (short const   )-255,      (short const   )-255,      (short const   )0,      (short const   )0, 
        (short const   )-232,      (short const   )-232,      (short const   )-232,      (short const   )-255, 
        (short const   )-255,      (short const   )-255,      (short const   )-255,      (short const   )-255, 
        (short const   )-255,      (short const   )-255,      (short const   )-255,      (short const   )-255, 
        (short const   )-255,      (short const   )-255,      (short const   )-255,      (short const   )-255, 
        (short const   )-255,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )-258, 
        (short const   )-258,      (short const   )-258,      (short const   )-258,      (short const   )0, 
        (short const   )0,      (short const   )-255,      (short const   )-255,      (short const   )-255, 
        (short const   )-258,      (short const   )-258,      (short const   )-258,      (short const   )-258, 
        (short const   )-258,      (short const   )-258,      (short const   )-258,      (short const   )-258, 
        (short const   )-258,      (short const   )-258,      (short const   )-258,      (short const   )-258, 
        (short const   )-258,      (short const   )-258,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )-258,      (short const   )-258, 
        (short const   )-258};
#line 792 "ys.y"
static short const   yycheck[1553]  = 
#line 792
  {      (short const   )1,      (short const   )18,      (short const   )125,      (short const   )126, 
        (short const   )124,      (short const   )86,      (short const   )99,      (short const   )130, 
        (short const   )3,      (short const   )80,      (short const   )81,      (short const   )383, 
        (short const   )99,      (short const   )30,      (short const   )31,      (short const   )386, 
        (short const   )33,      (short const   )34,      (short const   )35,      (short const   )36, 
        (short const   )37,      (short const   )21,      (short const   )96,      (short const   )25, 
        (short const   )196,      (short const   )197,      (short const   )438,      (short const   )357, 
        (short const   )269,      (short const   )21,      (short const   )21,      (short const   )206, 
        (short const   )21,      (short const   )21,      (short const   )451,      (short const   )21, 
        (short const   )38,      (short const   )38,      (short const   )21,      (short const   )437, 
        (short const   )92,      (short const   )31,      (short const   )32,      (short const   )455, 
        (short const   )98,      (short const   )268,      (short const   )216,      (short const   )99, 
        (short const   )446,      (short const   )21,      (short const   )220,      (short const   )221, 
        (short const   )222,      (short const   )223,      (short const   )224,      (short const   )225, 
        (short const   )226,      (short const   )227,      (short const   )228,      (short const   )229, 
        (short const   )230,      (short const   )55,      (short const   )91,      (short const   )55, 
        (short const   )21,      (short const   )149,      (short const   )150,      (short const   )151, 
        (short const   )55,      (short const   )86,      (short const   )99,      (short const   )73, 
        (short const   )444,      (short const   )75,      (short const   )75,      (short const   )77, 
        (short const   )93,      (short const   )79,      (short const   )198,      (short const   )202, 
        (short const   )250,      (short const   )411,      (short const   )96,      (short const   )83, 
        (short const   )482,      (short const   )502,      (short const   )90,      (short const   )207, 
        (short const   )90,      (short const   )330,      (short const   )90,      (short const   )83, 
        (short const   )92,      (short const   )83,      (short const   )83,      (short const   )83, 
        (short const   )494,      (short const   )83,      (short const   )93,      (short const   )99, 
        (short const   )83,      (short const   )102,      (short const   )173,      (short const   )196, 
        (short const   )197,      (short const   )99,      (short const   )329,      (short const   )98, 
        (short const   )96,      (short const   )196,      (short const   )197,      (short const   )83, 
        (short const   )287,      (short const   )96,      (short const   )207,      (short const   )199, 
        (short const   )56,      (short const   )97,      (short const   )91,      (short const   )99, 
        (short const   )83,      (short const   )192,      (short const   )67,      (short const   )91, 
        (short const   )522,      (short const   )523,      (short const   )99,      (short const   )90, 
        (short const   )68,      (short const   )92,      (short const   )528,      (short const   )99, 
        (short const   )149,      (short const   )150,      (short const   )151,      (short const   )152, 
        (short const   )153,      (short const   )154,      (short const   )155,      (short const   )156, 
        (short const   )157,      (short const   )158,      (short const   )159,      (short const   )160, 
        (short const   )161,      (short const   )162,      (short const   )163,      (short const   )164, 
        (short const   )268,      (short const   )390,      (short const   )562,      (short const   )96, 
        (short const   )90,      (short const   )524,      (short const   )99,      (short const   )526, 
        (short const   )331,      (short const   )555,      (short const   )556,      (short const   )91, 
        (short const   )383,      (short const   )90,      (short const   )67,      (short const   )83, 
        (short const   )92,      (short const   )96,      (short const   )286,      (short const   )99, 
        (short const   )540,      (short const   )83,      (short const   )90,      (short const   )99, 
        (short const   )92,      (short const   )343,      (short const   )93,      (short const   )177, 
        (short const   )90,      (short const   )91,      (short const   )92,      (short const   )99, 
        (short const   )99,      (short const   )91,      (short const   )199,      (short const   )96, 
        (short const   )356,      (short const   )557,      (short const   )349,      (short const   )91, 
        (short const   )269,      (short const   )99,      (short const   )353,      (short const   )96, 
        (short const   )92,      (short const   )286,      (short const   )99,      (short const   )99, 
        (short const   )91,      (short const   )569,      (short const   )92,      (short const   )99, 
        (short const   )323,      (short const   )83,      (short const   )84,      (short const   )85, 
        (short const   )99,      (short const   )99,      (short const   )578,      (short const   )579, 
        (short const   )55,      (short const   )88,      (short const   )89,      (short const   )90, 
        (short const   )387,      (short const   )92,      (short const   )72,      (short const   )94, 
        (short const   )95,      (short const   )219,      (short const   )96,      (short const   )96, 
        (short const   )592,      (short const   )444,      (short const   )99,      (short const   )96, 
        (short const   )465,      (short const   )75,      (short const   )76,      (short const   )77, 
        (short const   )78,      (short const   )90,      (short const   )247,      (short const   )92, 
        (short const   )249,      (short const   )156,      (short const   )157,      (short const   )158, 
        (short const   )159,      (short const   )96,      (short const   )81,      (short const   )82, 
        (short const   )99,      (short const   )312,      (short const   )313,      (short const   )79, 
        (short const   )80,      (short const   )415,      (short const   )248,      (short const   )410, 
        (short const   )96,      (short const   )330,      (short const   )321,      (short const   )99, 
        (short const   )269,      (short const   )73,      (short const   )74,      (short const   )375, 
        (short const   )258,      (short const   )480,      (short const   )481,      (short const   )96, 
        (short const   )71,      (short const   )96,      (short const   )99,      (short const   )356, 
        (short const   )99,      (short const   )19,      (short const   )20,      (short const   )268, 
        (short const   )438,      (short const   )356,      (short const   )96,      (short const   )394, 
        (short const   )90,      (short const   )99,      (short const   )92,      (short const   )516, 
        (short const   )90,      (short const   )90,      (short const   )92,      (short const   )92, 
        (short const   )90,      (short const   )456,      (short const   )92,      (short const   )403, 
        (short const   )90,      (short const   )455,      (short const   )92,      (short const   )450, 
        (short const   )289,      (short const   )464,      (short const   )152,      (short const   )153, 
        (short const   )412,      (short const   )97,      (short const   )90,      (short const   )99, 
        (short const   )92,      (short const   )97,      (short const   )369,      (short const   )99, 
        (short const   )90,      (short const   )90,      (short const   )92,      (short const   )92, 
        (short const   )488,      (short const   )70,      (short const   )490,      (short const   )427, 
        (short const   )69,      (short const   )390,      (short const   )96,      (short const   )97, 
        (short const   )96,      (short const   )330,      (short const   )154,      (short const   )155, 
        (short const   )318,      (short const   )540,      (short const   )320,      (short const   )160, 
        (short const   )161,      (short const   )90,      (short const   )21,      (short const   )498, 
        (short const   )91,      (short const   )548,      (short const   )21,      (short const   )21, 
        (short const   )329,      (short const   )92,      (short const   )67,      (short const   )99, 
        (short const   )452,      (short const   )99,      (short const   )509,      (short const   )416, 
        (short const   )91,      (short const   )500,      (short const   )501,      (short const   )459, 
        (short const   )21,      (short const   )41,      (short const   )98,      (short const   )518, 
        (short const   )507,      (short const   )21,      (short const   )569,      (short const   )98, 
        (short const   )98,      (short const   )10,      (short const   )10,      (short const   )96, 
        (short const   )90,      (short const   )55,      (short const   )355,      (short const   )21, 
        (short const   )357,      (short const   )92,      (short const   )98,      (short const   )534, 
        (short const   )91,      (short const   )97,      (short const   )91,      (short const   )97, 
        (short const   )91,      (short const   )93,      (short const   )21,      (short const   )91, 
        (short const   )370,      (short const   )67,      (short const   )93,      (short const   )96, 
        (short const   )3,      (short const   )390,      (short const   )21,      (short const   )97, 
        (short const   )21,      (short const   )91,      (short const   )93,      (short const   )542, 
        (short const   )38,      (short const   )544,      (short const   )91,      (short const   )91, 
        (short const   )465,      (short const   )386,      (short const   )98,      (short const   )91, 
        (short const   )99,      (short const   )96,      (short const   )93,      (short const   )97, 
        (short const   )562,      (short const   )83,      (short const   )38,      (short const   )515, 
        (short const   )21,      (short const   )98,      (short const   )21,      (short const   )416, 
        (short const   )96,      (short const   )92,      (short const   )99,      (short const   )96, 
        (short const   )475,      (short const   )91,      (short const   )91,      (short const   )91, 
        (short const   )571,      (short const   )98,      (short const   )411,      (short const   )98, 
        (short const   )55,      (short const   )91,      (short const   )91,      (short const   )21, 
        (short const   )91,      (short const   )97,      (short const   )91,      (short const   )98, 
        (short const   )583,      (short const   )91,      (short const   )91,      (short const   )425, 
        (short const   )91,      (short const   )0,      (short const   )277,      (short const   )1, 
        (short const   )318,      (short const   )425,      (short const   )355,      (short const   )594, 
        (short const   )595,      (short const   )515,      (short const   )336,      (short const   )516, 
        (short const   )137,      (short const   )138,      (short const   )139,      (short const   )140, 
        (short const   )141,      (short const   )142,      (short const   )143,      (short const   )144, 
        (short const   )145,      (short const   )146,      (short const   )392,      (short const   )466, 
        (short const   )465,      (short const   )75,      (short const   )408,      (short const   )268, 
        (short const   )569,      (short const   )576,      (short const   )270,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )345,      (short const   )459,      (short const   )415, 
        (short const   )247,      (short const   )589,      (short const   )440,      (short const   )163, 
        (short const   )249,      (short const   )21,      (short const   )162,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )480, 
        (short const   )481,      (short const   )164,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )39, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )516, 
        (short const   )-1,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )21, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )524, 
        (short const   )72,      (short const   )526,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )81,      (short const   )82,      (short const   )83, 
        (short const   )-1,      (short const   )39,      (short const   )86,      (short const   )87, 
        (short const   )88,      (short const   )89,      (short const   )90,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )548, 
        (short const   )-1,      (short const   )-1,      (short const   )98,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )557,      (short const   )57,      (short const   )58,      (short const   )59, 
        (short const   )60,      (short const   )61,      (short const   )62,      (short const   )63, 
        (short const   )64,      (short const   )65,      (short const   )66,      (short const   )67, 
        (short const   )-1,      (short const   )-1,      (short const   )72,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )578,      (short const   )579,      (short const   )81, 
        (short const   )82,      (short const   )83,      (short const   )-1,      (short const   )-1, 
        (short const   )86,      (short const   )87,      (short const   )88,      (short const   )89, 
        (short const   )90,      (short const   )0,      (short const   )1,      (short const   )592, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )13,      (short const   )14, 
        (short const   )15,      (short const   )16,      (short const   )17,      (short const   )18, 
        (short const   )-1,      (short const   )-1,      (short const   )21,      (short const   )22, 
        (short const   )23,      (short const   )24,      (short const   )25,      (short const   )26, 
        (short const   )27,      (short const   )28,      (short const   )29,      (short const   )30, 
        (short const   )31,      (short const   )32,      (short const   )33,      (short const   )34, 
        (short const   )35,      (short const   )36,      (short const   )37,      (short const   )-1, 
        (short const   )39,      (short const   )40,      (short const   )41,      (short const   )42, 
        (short const   )43,      (short const   )44,      (short const   )45,      (short const   )46, 
        (short const   )-1,      (short const   )48,      (short const   )49,      (short const   )50, 
        (short const   )51,      (short const   )52,      (short const   )53,      (short const   )54, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )72,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )81,      (short const   )82, 
        (short const   )83,      (short const   )-1,      (short const   )-1,      (short const   )86, 
        (short const   )87,      (short const   )88,      (short const   )89,      (short const   )90, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )96,      (short const   )1,      (short const   )98, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )21,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )36,      (short const   )37,      (short const   )-1, 
        (short const   )39,      (short const   )40,      (short const   )41,      (short const   )42, 
        (short const   )43,      (short const   )44,      (short const   )45,      (short const   )46, 
        (short const   )47,      (short const   )48,      (short const   )49,      (short const   )50, 
        (short const   )-1,      (short const   )22,      (short const   )23,      (short const   )24, 
        (short const   )25,      (short const   )26,      (short const   )27,      (short const   )28, 
        (short const   )29,      (short const   )30,      (short const   )31,      (short const   )32, 
        (short const   )33,      (short const   )34,      (short const   )35,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )72,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )81,      (short const   )82, 
        (short const   )83,      (short const   )54,      (short const   )-1,      (short const   )86, 
        (short const   )87,      (short const   )88,      (short const   )89,      (short const   )90, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )96,      (short const   )97,      (short const   )98, 
        (short const   )1,      (short const   )-1,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )21,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )36, 
        (short const   )37,      (short const   )-1,      (short const   )39,      (short const   )40, 
        (short const   )41,      (short const   )42,      (short const   )43,      (short const   )44, 
        (short const   )45,      (short const   )46,      (short const   )47,      (short const   )48, 
        (short const   )49,      (short const   )50,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )72, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )81,      (short const   )82,      (short const   )83,      (short const   )-1, 
        (short const   )-1,      (short const   )86,      (short const   )87,      (short const   )88, 
        (short const   )89,      (short const   )90,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )96, 
        (short const   )97,      (short const   )98,      (short const   )1,      (short const   )-1, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )21,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )36,      (short const   )37,      (short const   )-1, 
        (short const   )39,      (short const   )40,      (short const   )41,      (short const   )42, 
        (short const   )43,      (short const   )44,      (short const   )45,      (short const   )46, 
        (short const   )47,      (short const   )48,      (short const   )49,      (short const   )50, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )3,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )72,      (short const   )21,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )81,      (short const   )82, 
        (short const   )83,      (short const   )-1,      (short const   )-1,      (short const   )86, 
        (short const   )87,      (short const   )88,      (short const   )89,      (short const   )90, 
        (short const   )39,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )96,      (short const   )-1,      (short const   )98, 
        (short const   )-1,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )21, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )72,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )81,      (short const   )82, 
        (short const   )83,      (short const   )39,      (short const   )-1,      (short const   )86, 
        (short const   )87,      (short const   )88,      (short const   )89,      (short const   )90, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )96,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )72,      (short const   )21, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )81, 
        (short const   )82,      (short const   )83,      (short const   )-1,      (short const   )-1, 
        (short const   )86,      (short const   )87,      (short const   )88,      (short const   )89, 
        (short const   )90,      (short const   )39,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )96,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )72,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )21, 
        (short const   )-1,      (short const   )1,      (short const   )-1,      (short const   )81, 
        (short const   )82,      (short const   )83,      (short const   )-1,      (short const   )-1, 
        (short const   )86,      (short const   )87,      (short const   )88,      (short const   )89, 
        (short const   )90,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )16,      (short const   )39,      (short const   )96,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )22,      (short const   )23, 
        (short const   )24,      (short const   )25,      (short const   )26,      (short const   )27, 
        (short const   )28,      (short const   )29,      (short const   )30,      (short const   )31, 
        (short const   )32,      (short const   )33,      (short const   )34,      (short const   )35, 
        (short const   )-1,      (short const   )3,      (short const   )4,      (short const   )5, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )72,      (short const   )-1, 
        (short const   )52,      (short const   )53,      (short const   )54,      (short const   )21, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )81, 
        (short const   )82,      (short const   )83,      (short const   )-1,      (short const   )-1, 
        (short const   )86,      (short const   )87,      (short const   )88,      (short const   )89, 
        (short const   )90,      (short const   )-1,      (short const   )-1,      (short const   )93, 
        (short const   )-1,      (short const   )39,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )91, 
        (short const   )21,      (short const   )-1,      (short const   )3,      (short const   )4, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )8, 
        (short const   )9,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )-1,      (short const   )-1,      (short const   )72,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )39,      (short const   )-1, 
        (short const   )21,      (short const   )-1,      (short const   )-1,      (short const   )81, 
        (short const   )82,      (short const   )83,      (short const   )-1,      (short const   )-1, 
        (short const   )86,      (short const   )87,      (short const   )88,      (short const   )89, 
        (short const   )90,      (short const   )-1,      (short const   )-1,      (short const   )93, 
        (short const   )-1,      (short const   )-1,      (short const   )39,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )-1,      (short const   )-1,      (short const   )72, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )21,      (short const   )-1,      (short const   )-1, 
        (short const   )81,      (short const   )82,      (short const   )83,      (short const   )-1, 
        (short const   )-1,      (short const   )86,      (short const   )87,      (short const   )88, 
        (short const   )89,      (short const   )90,      (short const   )91,      (short const   )72, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )39, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )81,      (short const   )82,      (short const   )83,      (short const   )-1, 
        (short const   )-1,      (short const   )86,      (short const   )87,      (short const   )88, 
        (short const   )89,      (short const   )90,      (short const   )91,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )72,      (short const   )21,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )81,      (short const   )82,      (short const   )83, 
        (short const   )-1,      (short const   )-1,      (short const   )86,      (short const   )87, 
        (short const   )88,      (short const   )89,      (short const   )90,      (short const   )39, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )72,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )81,      (short const   )82,      (short const   )83, 
        (short const   )-1,      (short const   )-1,      (short const   )86,      (short const   )87, 
        (short const   )88,      (short const   )89,      (short const   )90,      (short const   )13, 
        (short const   )14,      (short const   )15,      (short const   )16,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )22,      (short const   )23,      (short const   )24,      (short const   )25, 
        (short const   )26,      (short const   )27,      (short const   )28,      (short const   )29, 
        (short const   )30,      (short const   )31,      (short const   )32,      (short const   )33, 
        (short const   )34,      (short const   )35,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )13,      (short const   )14,      (short const   )15,      (short const   )16, 
        (short const   )-1,      (short const   )-1,      (short const   )52,      (short const   )53, 
        (short const   )54,      (short const   )22,      (short const   )23,      (short const   )24, 
        (short const   )25,      (short const   )26,      (short const   )27,      (short const   )28, 
        (short const   )29,      (short const   )30,      (short const   )31,      (short const   )32, 
        (short const   )33,      (short const   )34,      (short const   )35,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )16,      (short const   )-1,      (short const   )-1,      (short const   )52, 
        (short const   )53,      (short const   )54,      (short const   )22,      (short const   )23, 
        (short const   )24,      (short const   )25,      (short const   )26,      (short const   )27, 
        (short const   )28,      (short const   )29,      (short const   )30,      (short const   )31, 
        (short const   )32,      (short const   )33,      (short const   )34,      (short const   )35, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )13,      (short const   )14, 
        (short const   )15,      (short const   )16,      (short const   )-1,      (short const   )-1, 
        (short const   )52,      (short const   )53,      (short const   )54,      (short const   )22, 
        (short const   )23,      (short const   )24,      (short const   )25,      (short const   )26, 
        (short const   )27,      (short const   )28,      (short const   )29,      (short const   )30, 
        (short const   )31,      (short const   )32,      (short const   )33,      (short const   )34, 
        (short const   )35,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )13, 
        (short const   )14,      (short const   )15,      (short const   )16,      (short const   )-1, 
        (short const   )-1,      (short const   )52,      (short const   )53,      (short const   )54, 
        (short const   )22,      (short const   )23,      (short const   )24,      (short const   )25, 
        (short const   )26,      (short const   )27,      (short const   )28,      (short const   )29, 
        (short const   )30,      (short const   )31,      (short const   )32,      (short const   )33, 
        (short const   )34,      (short const   )35,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )-1,      (short const   )-1, 
        (short const   )-1,      (short const   )-1,      (short const   )52,      (short const   )53, 
        (short const   )54};
#line 137 "/usr/share/misc/bison.simple"
int yychar  ;
#line 138 "/usr/share/misc/bison.simple"
YYSTYPE yylval  ;
#line 146 "/usr/share/misc/bison.simple"
int yynerrs  ;
#line 150 "/usr/share/misc/bison.simple"
int yydebug  ;
#line 246 "/usr/share/misc/bison.simple"
int yyparse(void) 
{ 
  register int yystate ;
  register int yyn ;
  register short *yyssp ;
  register YYSTYPE *yyvsp ;
  int yyerrstatus ;
  int yychar1 ;
  short yyssa[200] ;
  YYSTYPE yyvsa[200] ;
  short *yyss ;
  YYSTYPE *yyvs ;
  int yystacksize ;
  int yyfree_stacks ;
  YYSTYPE yyval ;
  int yylen ;
  YYSTYPE *yyvs1 ;
  short *yyss1 ;
  int size ;
  void *tmp___0 ;
  void *tmp___1 ;
  int i ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  struct ident_tab_loc *ptr ;
  int unused_p ;
  struct ident_tab *ptr1 ;
  struct ident_tab *tmp___20 ;
  struct internal_type *help___0 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  struct internal_type *type ;
  int tmp___38 ;
  int tmp___39 ;
  struct internal_type *help___1 ;
  struct internal_type *arch ;
  struct internal_type *type___0 ;
  char *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int bracket_initializers ;
  int i___0 ;
  int j ;
  int tmp___44 ;
  int k ;
  int tmp___45 ;
  int tmp___46 ;
  int i___1 ;
  int j___0 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  struct internal_type *help___2 ;
  char *tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  struct internal_type *help___3 ;
  char *tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  struct internal_type *help___4 ;
  struct internal_type *arch___0 ;
  char *tmp___71 ;
  struct internal_type *type___1 ;
  struct internal_type *help___5 ;
  struct internal_type *arch___1 ;
  char *tmp___72 ;
  int tmp___73 ;
  struct internal_type *help___6 ;
  struct internal_type *arch___2 ;
  char *tmp___74 ;
  struct internal_type *help___7 ;
  struct internal_type *arch___3 ;
  char *tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  char *tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  struct internal_type *help___8 ;
  struct internal_type *arch___4 ;
  char *tmp___102 ;
  int tmp___103 ;
  struct internal_type *help___9 ;
  struct internal_type *arch___5 ;
  char *tmp___104 ;
  struct internal_type *type___2 ;
  struct internal_type *help___10 ;
  struct internal_type *arch___6 ;
  char *tmp___105 ;
  int tmp___106 ;
  struct internal_type *help___11 ;
  struct internal_type *arch___7 ;
  char *tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  register int i___2 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  char *help___12 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  struct internal_type *help___13 ;
  char *tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  struct internal_type *help___14 ;
  char *tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  struct internal_type *help___15 ;
  char *tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  struct internal_type *help___16 ;
  char *tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  struct internal_type *help___17 ;
  struct internal_type *arch___8 ;
  char *tmp___165 ;
  int tmp___166 ;
  int tmp___167 ;
  struct internal_type *type___3 ;
  int tmp___168 ;
  struct internal_type *help___18 ;
  struct internal_type *arch___9 ;
  char *tmp___169 ;
  int tmp___170 ;
  int tmp___171 ;
  struct internal_type *type___4 ;
  struct internal_type *type___5 ;
  struct internal_type *type___6 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  int tmp___177 ;
  int tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;
  register int i___3 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  int tmp___184 ;
  int tmp___185 ;
  int tmp___186 ;
  int tmp___187 ;
  int tmp___188 ;
  register int i___4 ;
  int tmp___189 ;
  int tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  int tmp___193 ;
  int tmp___194 ;
  int tmp___195 ;
  register int i___5 ;
  int tmp___196 ;
  int tmp___197 ;
  int tmp___198 ;
  char *tmp___199 ;
  int tmp___200 ;
  char *tmp___201 ;
  int tmp___202 ;
  char *tmp___203 ;
  int tmp___204 ;
  char *tmp___205 ;
  int tmp___206 ;
  char *tmp___207 ;
  char *tmp___208 ;
  char *tmp___209 ;
  char *tmp___210 ;
  char *tmp___211 ;
  size_t tmp___212 ;
  char *tmp___213 ;
  char *tmp___214 ;
  int i___6 ;
  int j___1 ;
  size_t tmp___215 ;
  size_t tmp___216 ;
  char *tmp___217 ;
  int tmp___218 ;
  int tmp___219 ;
  int tmp___220 ;
  int tmp___221 ;
  int aggr_offset ;
  int aggr_offset___0 ;
  struct ident_tab *help___19 ;
  int tmp___222 ;
  int tmp___223 ;
  int tmp___224 ;
  struct internal_type *arch___10 ;
  int tmp___225 ;
  char *tmp___226 ;
  int tmp___227 ;
  char *tmp___228 ;
  char *tmp___229 ;
  char *tmp___230 ;
  int tmp___231 ;
  int tmp___232 ;
  int tmp___233 ;
  int tmp___234 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___242 ;
  int tmp___243 ;
  int tmp___244 ;
  int tmp___245 ;
  int tmp___246 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___253 ;
  char *tmp___254 ;
  int tmp___255 ;
  char *tmp___256 ;
  int tmp___257 ;
  int tmp___258 ;
  int tmp___259 ;
  char *tmp___260 ;
  int tmp___261 ;
  char *tmp___262 ;
  int tmp___263 ;
  int tmp___264 ;
  int tmp___265 ;
  int tmp___266 ;
  int tmp___267 ;
  int tmp___268 ;
  int tmp___269 ;
  int tmp___270 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___276 ;
  int tmp___277 ;
  int tmp___278 ;
  int tmp___279 ;
  int tmp___280 ;
  int tmp___281 ;
  int tmp___282 ;
  int tmp___283 ;
  short *ssp1 ;
  short *ssp1___0 ;
  void *__cil_tmp362 ;
  void *__cil_tmp363 ;
  void *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;
  char *__cil_tmp402 ;
  char *__cil_tmp403 ;
  char *__cil_tmp404 ;
  char *__cil_tmp405 ;
  char *__cil_tmp406 ;
  char *__cil_tmp407 ;
  char *__cil_tmp408 ;
  char *__cil_tmp409 ;
  char *__cil_tmp410 ;
  char *__cil_tmp411 ;
  char *__cil_tmp412 ;
  char *__cil_tmp413 ;
  char *__cil_tmp414 ;
  char *__cil_tmp415 ;
  char *__cil_tmp416 ;
  char *__cil_tmp417 ;
  char *__cil_tmp418 ;
  char *__cil_tmp419 ;
  char *__cil_tmp420 ;
  char *__cil_tmp421 ;
  char *__cil_tmp422 ;
  char *__cil_tmp423 ;
  char *__cil_tmp424 ;
  char *__cil_tmp425 ;
  char *__cil_tmp426 ;
  char *__cil_tmp427 ;
  char *__cil_tmp428 ;
  char *__cil_tmp429 ;
  char *__cil_tmp430 ;
  char *__cil_tmp431 ;
  char *__cil_tmp432 ;
  char *__cil_tmp433 ;
  char *__cil_tmp434 ;
  char *__cil_tmp435 ;
  char *__cil_tmp436 ;
  char *__cil_tmp437 ;
  char *__cil_tmp438 ;
  char *__cil_tmp439 ;
  char *__cil_tmp440 ;
  char *__cil_tmp441 ;
  char *__cil_tmp442 ;
  char *__cil_tmp443 ;
  char *__cil_tmp444 ;
  char *__cil_tmp445 ;
  char *__cil_tmp446 ;
  char *__cil_tmp447 ;
  char *__cil_tmp448 ;
  char *__cil_tmp449 ;
  char *__cil_tmp450 ;
  char *__cil_tmp451 ;
  char *__cil_tmp452 ;
  char *__cil_tmp453 ;
  char *__cil_tmp454 ;
  char *__cil_tmp455 ;
  char *__cil_tmp456 ;
  char *__cil_tmp457 ;
  char *__cil_tmp458 ;
  char *__cil_tmp459 ;
  char *__cil_tmp460 ;
  char *__cil_tmp461 ;
  char *__cil_tmp462 ;
  char *__cil_tmp463 ;
  char *__cil_tmp464 ;
  char *__cil_tmp465 ;
  char *__cil_tmp466 ;
  char *__cil_tmp467 ;
  char *__cil_tmp468 ;
  char *__cil_tmp469 ;
  char *__cil_tmp470 ;
  char *__cil_tmp471 ;
  char *__cil_tmp472 ;
  char *__cil_tmp473 ;
  char *__cil_tmp474 ;
  char *__cil_tmp475 ;
  char *__cil_tmp476 ;
  char *__cil_tmp477 ;
  char *__cil_tmp478 ;
  char *__cil_tmp479 ;
  char *__cil_tmp480 ;
  char *__cil_tmp481 ;
  char *__cil_tmp482 ;
  char *__cil_tmp483 ;
  char *__cil_tmp484 ;
  char *__cil_tmp485 ;
  char *__cil_tmp486 ;
  char *__cil_tmp487 ;
  char *__cil_tmp488 ;
  char *__cil_tmp489 ;
  char *__cil_tmp490 ;
  char *__cil_tmp491 ;
  char *__cil_tmp492 ;
  char *__cil_tmp493 ;
  char *__cil_tmp494 ;
  char *__cil_tmp495 ;
  char *__cil_tmp496 ;
  char *__cil_tmp497 ;
  char *__cil_tmp498 ;
  char *__cil_tmp499 ;
  char *__cil_tmp500 ;
  char *__cil_tmp501 ;
  char *__cil_tmp502 ;
  char *__cil_tmp503 ;
  char *__cil_tmp504 ;
  char *__cil_tmp505 ;
  char *__cil_tmp506 ;
  char *__cil_tmp507 ;
  char *__cil_tmp508 ;
  char *__cil_tmp509 ;
  char *__cil_tmp510 ;
  char *__cil_tmp511 ;
  char *__cil_tmp512 ;
  char *__cil_tmp513 ;
  char *__cil_tmp514 ;
  char *__cil_tmp515 ;
  char *__cil_tmp516 ;
  char *__cil_tmp517 ;
  char *__cil_tmp518 ;
  char *__cil_tmp519 ;
  char *__cil_tmp520 ;
  char *__cil_tmp521 ;
  char *__cil_tmp522 ;
  char *__cil_tmp523 ;
  char *__cil_tmp524 ;
  char *__cil_tmp525 ;
  char *__cil_tmp526 ;
  char *__cil_tmp527 ;
  char *__cil_tmp528 ;
  char *__cil_tmp529 ;
  char *__cil_tmp530 ;
  char *__cil_tmp531 ;
  char *__cil_tmp532 ;
  char *__cil_tmp533 ;
  char *__cil_tmp534 ;
  char *__cil_tmp535 ;
  char *__cil_tmp536 ;
  char *__cil_tmp537 ;
  char *__cil_tmp538 ;
  char *__cil_tmp539 ;
  char *__cil_tmp540 ;
  char *__cil_tmp541 ;
  char *__cil_tmp542 ;
  char *__cil_tmp543 ;
  char *__cil_tmp544 ;
  char *__cil_tmp545 ;
  char *__cil_tmp546 ;
  char *__cil_tmp547 ;
  char *__cil_tmp548 ;
  char *__cil_tmp549 ;
  char *__cil_tmp550 ;
  char *__cil_tmp551 ;
  char *__cil_tmp552 ;
  char *__cil_tmp553 ;
  char *__cil_tmp554 ;
  char *__cil_tmp555 ;
  char *__cil_tmp556 ;
  char *__cil_tmp557 ;
  char *__cil_tmp558 ;
  char *__cil_tmp559 ;
  char *__cil_tmp560 ;
  char *__cil_tmp561 ;
  char *__cil_tmp562 ;
  char *__cil_tmp563 ;
  char *__cil_tmp564 ;
  char *__cil_tmp565 ;
  char *__cil_tmp566 ;
  char *__cil_tmp567 ;
  char *__cil_tmp568 ;
  char *__cil_tmp569 ;
  char *__cil_tmp570 ;
  char *__cil_tmp571 ;
  char *__cil_tmp572 ;
  char *__cil_tmp573 ;
  char *__cil_tmp574 ;
  char *__cil_tmp575 ;
  char *__cil_tmp576 ;
  char *__cil_tmp577 ;
  char *__cil_tmp578 ;
  char *__cil_tmp579 ;
  char *__cil_tmp580 ;
  char *__cil_tmp581 ;
  char *__cil_tmp582 ;
  char *__cil_tmp583 ;
  char *__cil_tmp584 ;
  char *__cil_tmp585 ;
  char *__cil_tmp586 ;
  char *__cil_tmp587 ;
  char *__cil_tmp588 ;
  char *__cil_tmp589 ;
  char *__cil_tmp590 ;
  char *__cil_tmp591 ;
  char *__cil_tmp592 ;
  char *__cil_tmp593 ;
  char *__cil_tmp594 ;
  char *__cil_tmp595 ;
  char *__cil_tmp596 ;
  char *__cil_tmp597 ;
  char *__cil_tmp598 ;
  char *__cil_tmp599 ;
  char *__cil_tmp600 ;
  char *__cil_tmp601 ;
  char *__cil_tmp602 ;
  char *__cil_tmp603 ;
  char *__cil_tmp604 ;
  char *__cil_tmp605 ;
  char *__cil_tmp606 ;
  char *__cil_tmp607 ;
  char *__cil_tmp608 ;
  char *__cil_tmp609 ;
  char *__cil_tmp610 ;
  char *__cil_tmp611 ;
  char *__cil_tmp612 ;
  char *__cil_tmp613 ;
  char *__cil_tmp614 ;
  char *__cil_tmp615 ;
  char *__cil_tmp616 ;
  char *__cil_tmp617 ;
  char *__cil_tmp618 ;
  char *__cil_tmp619 ;
  char *__cil_tmp620 ;
  char *__cil_tmp621 ;
  char *__cil_tmp622 ;

  {
#line 255
  yychar1 = 0;
#line 260
  yyss = yyssa;
#line 261
  yyvs = yyvsa;
#line 273
  yystacksize = 200;
#line 274
  yyfree_stacks = 0;
#line 292
  if (yydebug) {
    {
#line 293
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
    }
  }
#line 296
  yystate = 0;
#line 297
  yyerrstatus = 0;
#line 298
  yynerrs = 0;
#line 299
  yychar = -2;
#line 306
  yyssp = yyss - 1;
#line 307
  yyvsp = yyvs;
  yynewstate: 
#line 317
  yyssp ++;
#line 317
  *yyssp = (short )yystate;
#line 319
  if ((unsigned long )yyssp >= (unsigned long )((yyss + yystacksize) - 1)) {
#line 323
    yyvs1 = yyvs;
#line 324
    yyss1 = yyss;
#line 330
    size = (int )((yyssp - yyss) + 1L);
#line 356
    if (yystacksize >= 10000) {
      {
#line 358
      yyerror((char *)"parser stack overflow");
      }
#line 359
      if (yyfree_stacks) {
        {
#line 361
        free((void *)yyss);
#line 362
        free((void *)yyvs);
        }
      }
#line 367
      return (2);
    }
#line 369
    yystacksize *= 2;
#line 370
    if (yystacksize > 10000) {
#line 371
      yystacksize = 10000;
    }
    {
#line 375
    tmp___0 = __builtin_alloca((unsigned long )yystacksize * sizeof(*yyssp));
#line 375
    yyss = (short *)tmp___0;
#line 376
    __builtin_memcpy((void *)((char *)yyss), (void const   *)((char *)yyss1), (unsigned long )((unsigned int )size * (unsigned int )sizeof(*yyssp)));
#line 378
    tmp___1 = __builtin_alloca((unsigned long )yystacksize * sizeof(*yyvsp));
#line 378
    yyvs = (YYSTYPE *)tmp___1;
#line 379
    __builtin_memcpy((void *)((char *)yyvs), (void const   *)((char *)yyvs1), (unsigned long )((unsigned int )size * (unsigned int )sizeof(*yyvsp)));
#line 388
    yyssp = (yyss + size) - 1;
#line 389
    yyvsp = (yyvs + size) - 1;
    }
#line 395
    if (yydebug) {
      {
#line 396
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %d\n",
              yystacksize);
      }
    }
#line 399
    if ((unsigned long )yyssp >= (unsigned long )((yyss + yystacksize) - 1)) {
#line 400
      goto yyabortlab;
    }
  }
#line 404
  if (yydebug) {
    {
#line 405
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
            yystate);
    }
  }
#line 408
  goto yybackup;
  yybackup: 
#line 417
  yyn = (int )yypact[yystate];
#line 418
  if (yyn == -32768) {
#line 419
    goto yydefault;
  }
#line 426
  if (yychar == -2) {
#line 429
    if (yydebug) {
      {
#line 430
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
      }
    }
    {
#line 432
    yychar = yylex();
    }
  }
#line 437
  if (yychar <= 0) {
#line 439
    yychar1 = 0;
#line 440
    yychar = 0;
#line 443
    if (yydebug) {
      {
#line 444
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
      }
    }
  } else {
#line 449
    if ((unsigned int )yychar <= 331U) {
#line 449
      yychar1 = (int )yytranslate[yychar];
    } else {
#line 449
      yychar1 = 254;
    }
#line 452
    if (yydebug) {
      {
#line 454
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Next token is %d (%s",
              yychar, yytname[yychar1]);
#line 460
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
      }
    }
  }
#line 465
  yyn += yychar1;
#line 466
  if (yyn < 0) {
#line 467
    goto yydefault;
  } else
#line 466
  if (yyn > 1552) {
#line 467
    goto yydefault;
  } else
#line 466
  if ((int const   )yycheck[yyn] != (int const   )yychar1) {
#line 467
    goto yydefault;
  }
#line 469
  yyn = (int )yytable[yyn];
#line 478
  if (yyn < 0) {
#line 480
    if (yyn == -32768) {
#line 481
      goto yyerrlab;
    }
#line 482
    yyn = - yyn;
#line 483
    goto yyreduce;
  } else
#line 485
  if (yyn == 0) {
#line 486
    goto yyerrlab;
  }
#line 488
  if (yyn == 601) {
#line 489
    goto yyacceptlab;
  }
#line 494
  if (yydebug) {
    {
#line 495
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shifting token %d (%s), ",
            yychar, yytname[yychar1]);
    }
  }
#line 499
  if (yychar != 0) {
#line 500
    yychar = -2;
  }
#line 502
  yyvsp ++;
#line 502
  *yyvsp = yylval;
#line 508
  if (yyerrstatus) {
#line 508
    yyerrstatus --;
  }
#line 510
  yystate = yyn;
#line 511
  goto yynewstate;
  yydefault: 
#line 516
  yyn = (int )yydefact[yystate];
#line 517
  if (yyn == 0) {
#line 518
    goto yyerrlab;
  }
  yyreduce: 
#line 522
  yylen = (int )yyr2[yyn];
#line 523
  if (yylen > 0) {
#line 524
    yyval = *(yyvsp + (1 - yylen));
  }
#line 527
  if (yydebug) {
    {
#line 531
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing via rule %d (line %d), ",
            yyn, (int const   )yyrline[yyn]);
#line 535
    i = (int )yyprhs[yyn];
    }
    {
#line 535
    while (1) {
      while_continue: /* CIL Label */ ;
#line 535
      if (! ((int const   )yyrhs[i] > 0)) {
#line 535
        goto while_break;
      }
      {
#line 536
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yytname[yyrhs[i]]);
#line 535
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 537
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -> %s\n",
            yytname[yyr1[yyn]]);
    }
  }
  {
#line 544
  if (yyn == 1) {
#line 544
    goto case_1;
  }
#line 188
  if (yyn == 6) {
#line 188 "ys.y"
    goto case_6;
  }
#line 207
  if (yyn == 7) {
#line 207
    goto case_7;
  }
#line 213
  if (yyn == 9) {
#line 213
    goto case_9;
  }
#line 221
  if (yyn == 11) {
#line 221
    goto case_11;
  }
#line 235
  if (yyn == 13) {
#line 235
    goto case_13;
  }
#line 240
  if (yyn == 14) {
#line 240
    goto case_14;
  }
#line 244
  if (yyn == 15) {
#line 244
    goto case_15;
  }
#line 264
  if (yyn == 16) {
#line 264
    goto case_16;
  }
#line 270
  if (yyn == 17) {
#line 270
    goto case_17;
  }
#line 290
  if (yyn == 18) {
#line 290
    goto case_18;
  }
#line 298
  if (yyn == 25) {
#line 298
    goto case_25;
  }
#line 337
  if (yyn == 27) {
#line 337
    goto case_27;
  }
#line 372
  if (yyn == 28) {
#line 372
    goto case_28;
  }
#line 375
  if (yyn == 29) {
#line 375
    goto case_29;
  }
#line 379
  if (yyn == 31) {
#line 379
    goto case_31;
  }
#line 395
  if (yyn == 32) {
#line 395
    goto case_32;
  }
#line 437
  if (yyn == 36) {
#line 437
    goto case_36;
  }
#line 445
  if (yyn == 37) {
#line 445
    goto case_37;
  }
#line 455
  if (yyn == 38) {
#line 455
    goto case_38;
  }
#line 487
  if (yyn == 40) {
#line 487
    goto case_40;
  }
#line 503
  if (yyn == 41) {
#line 503
    goto case_41;
  }
#line 522
  if (yyn == 42) {
#line 522
    goto case_42;
  }
#line 537
  if (yyn == 43) {
#line 537
    goto case_43;
  }
#line 547
  if (yyn == 45) {
#line 547
    goto case_45;
  }
#line 559
  if (yyn == 46) {
#line 559
    goto case_46;
  }
#line 580
  if (yyn == 47) {
#line 580
    goto case_47;
  }
#line 592
  if (yyn == 48) {
#line 592
    goto case_48;
  }
#line 612
  if (yyn == 51) {
#line 612
    goto case_51;
  }
#line 669
  if (yyn == 53) {
#line 669
    goto case_53;
  }
#line 680
  if (yyn == 55) {
#line 680
    goto case_55;
  }
#line 696
  if (yyn == 57) {
#line 696
    goto case_57;
  }
#line 704
  if (yyn == 59) {
#line 704
    goto case_59;
  }
#line 753
  if (yyn == 60) {
#line 753
    goto case_60;
  }
#line 765
  if (yyn == 61) {
#line 765
    goto case_61;
  }
#line 783
  if (yyn == 62) {
#line 783
    goto case_62;
  }
#line 794
  if (yyn == 63) {
#line 794
    goto case_63;
  }
#line 805
  if (yyn == 64) {
#line 805
    goto case_64___2;
  }
#line 816
  if (yyn == 65) {
#line 816
    goto case_65;
  }
#line 827
  if (yyn == 66) {
#line 827
    goto case_66;
  }
#line 843
  if (yyn == 67) {
#line 843
    goto case_67;
  }
#line 859
  if (yyn == 68) {
#line 859
    goto case_68;
  }
#line 875
  if (yyn == 69) {
#line 875
    goto case_69;
  }
#line 891
  if (yyn == 72) {
#line 891
    goto case_72;
  }
#line 919
  if (yyn == 73) {
#line 919
    goto case_73;
  }
#line 931
  if (yyn == 74) {
#line 931
    goto case_74;
  }
#line 941
  if (yyn == 75) {
#line 941
    goto case_75;
  }
#line 967
  if (yyn == 81) {
#line 967
    goto case_81;
  }
#line 988
  if (yyn == 82) {
#line 988
    goto case_82;
  }
#line 1003
  if (yyn == 83) {
#line 1003
    goto case_83;
  }
#line 1009
  if (yyn == 84) {
#line 1009
    goto case_84;
  }
#line 1019
  if (yyn == 85) {
#line 1019
    goto case_85;
  }
#line 1036
  if (yyn == 86) {
#line 1036
    goto case_86;
  }
#line 1056
  if (yyn == 87) {
#line 1056
    goto case_87;
  }
#line 1074
  if (yyn == 88) {
#line 1074
    goto case_88;
  }
#line 1081
  if (yyn == 89) {
#line 1081
    goto case_89;
  }
#line 1085
  if (yyn == 90) {
#line 1085
    goto case_90;
  }
#line 1093
  if (yyn == 100) {
#line 1093
    goto case_100;
  }
#line 1133
  if (yyn == 101) {
#line 1133
    goto case_101;
  }
#line 1137
  if (yyn == 102) {
#line 1137
    goto case_102;
  }
#line 1162
  if (yyn == 103) {
#line 1162
    goto case_103;
  }
#line 1171
  if (yyn == 104) {
#line 1171
    goto case_104;
  }
#line 1193
  if (yyn == 107) {
#line 1193
    goto case_107;
  }
#line 1225
  if (yyn == 108) {
#line 1225
    goto case_108;
  }
#line 1227
  if (yyn == 109) {
#line 1227
    goto case_109;
  }
#line 1240
  if (yyn == 111) {
#line 1240
    goto case_111;
  }
#line 1268
  if (yyn == 112) {
#line 1268
    goto case_112;
  }
#line 1306
  if (yyn == 114) {
#line 1306
    goto case_114;
  }
#line 1318
  if (yyn == 116) {
#line 1318
    goto case_116;
  }
#line 1362
  if (yyn == 117) {
#line 1362
    goto case_117;
  }
#line 1366
  if (yyn == 118) {
#line 1366
    goto case_118;
  }
#line 1390
  if (yyn == 119) {
#line 1390
    goto case_119;
  }
#line 1399
  if (yyn == 120) {
#line 1399
    goto case_120;
  }
#line 1412
  if (yyn == 135) {
#line 1412
    goto case_135;
  }
#line 1463
  if (yyn == 136) {
#line 1463
    goto case_136___2;
  }
#line 1477
  if (yyn == 137) {
#line 1477
    goto case_137;
  }
#line 1488
  if (yyn == 138) {
#line 1488
    goto case_138;
  }
#line 1498
  if (yyn == 139) {
#line 1498
    goto case_139;
  }
#line 1507
  if (yyn == 140) {
#line 1507
    goto case_140___2;
  }
#line 1516
  if (yyn == 141) {
#line 1516
    goto case_141;
  }
#line 1532
  if (yyn == 142) {
#line 1532
    goto case_142;
  }
#line 1544
  if (yyn == 146) {
#line 1544
    goto case_146;
  }
#line 1573
  if (yyn == 147) {
#line 1573
    goto case_147;
  }
#line 1583
  if (yyn == 148) {
#line 1583
    goto case_148;
  }
#line 1595
  if (yyn == 149) {
#line 1595
    goto case_149;
  }
#line 1609
  if (yyn == 150) {
#line 1609
    goto case_150;
  }
#line 1631
  if (yyn == 151) {
#line 1631
    goto case_151;
  }
#line 1651
  if (yyn == 153) {
#line 1651
    goto case_153;
  }
#line 1688
  if (yyn == 155) {
#line 1688
    goto case_155;
  }
#line 1715
  if (yyn == 157) {
#line 1715
    goto case_157;
  }
#line 1756
  if (yyn == 159) {
#line 1756
    goto case_159;
  }
#line 1822
  if (yyn == 161) {
#line 1822
    goto case_161;
  }
#line 1890
  if (yyn == 163) {
#line 1890
    goto case_163;
  }
#line 1906
  if (yyn == 164) {
#line 1906
    goto case_164;
  }
#line 1925
  if (yyn == 166) {
#line 1925
    goto case_166;
  }
#line 1946
  if (yyn == 168) {
#line 1946
    goto case_168;
  }
#line 1970
  if (yyn == 170) {
#line 1970
    goto case_170;
  }
#line 1992
  if (yyn == 171) {
#line 1992
    goto case_171;
  }
#line 2011
  if (yyn == 172) {
#line 2011
    goto case_172;
  }
#line 2038
  if (yyn == 173) {
#line 2038
    goto case_173;
  }
#line 2059
  if (yyn == 174) {
#line 2059
    goto case_174;
  }
#line 2072
  if (yyn == 176) {
#line 2072
    goto case_176;
  }
#line 2086
  if (yyn == 178) {
#line 2086
    goto case_178;
  }
#line 2104
  if (yyn == 180) {
#line 2104
    goto case_180;
  }
#line 2111
  if (yyn == 181) {
#line 2111
    goto case_181;
  }
#line 2129
  if (yyn == 183) {
#line 2129
    goto case_183;
  }
#line 2167
  if (yyn == 185) {
#line 2167
    goto case_185;
  }
#line 2231
  if (yyn == 187) {
#line 2231
    goto case_187;
  }
#line 2257
  if (yyn == 189) {
#line 2257
    goto case_189;
  }
#line 2297
  if (yyn == 191) {
#line 2297
    goto case_191;
  }
#line 2360
  if (yyn == 193) {
#line 2360
    goto case_193;
  }
#line 2368
  if (yyn == 194) {
#line 2368
    goto case_194;
  }
#line 2372
  if (yyn == 196) {
#line 2372
    goto case_196;
  }
#line 2401
  if (yyn == 198) {
#line 2401
    goto case_198;
  }
#line 2444
  if (yyn == 199) {
#line 2444
    goto case_199;
  }
#line 2545
  if (yyn == 200) {
#line 2545
    goto case_200;
  }
#line 2557
  if (yyn == 201) {
#line 2557
    goto case_201;
  }
#line 2562
  if (yyn == 202) {
#line 2562
    goto case_202;
  }
#line 2568
  if (yyn == 204) {
#line 2568
    goto case_204;
  }
#line 2583
  if (yyn == 206) {
#line 2583
    goto case_206;
  }
#line 2606
  if (yyn == 207) {
#line 2606
    goto case_207;
  }
#line 2627
  if (yyn == 209) {
#line 2627
    goto case_209;
  }
#line 2633
  if (yyn == 212) {
#line 2633
    goto case_212;
  }
#line 2653
  if (yyn == 214) {
#line 2653
    goto case_214;
  }
#line 2661
  if (yyn == 215) {
#line 2661
    goto case_215;
  }
#line 2686
  if (yyn == 216) {
#line 2686
    goto case_216;
  }
#line 2705
  if (yyn == 218) {
#line 2705
    goto case_218;
  }
#line 2733
  if (yyn == 219) {
#line 2733
    goto case_219;
  }
#line 2762
  if (yyn == 221) {
#line 2762
    goto case_221;
  }
#line 2782
  if (yyn == 222) {
#line 2782
    goto case_222;
  }
#line 2801
  if (yyn == 224) {
#line 2801
    goto case_224;
  }
#line 2829
  if (yyn == 225) {
#line 2829
    goto case_225;
  }
#line 2858
  if (yyn == 227) {
#line 2858
    goto case_227;
  }
#line 2868
  if (yyn == 228) {
#line 2868
    goto case_228;
  }
#line 2874
  if (yyn == 229) {
#line 2874
    goto case_229;
  }
#line 2880
  if (yyn == 231) {
#line 2880
    goto case_231;
  }
#line 2898
  if (yyn == 232) {
#line 2898
    goto case_232;
  }
#line 2909
  if (yyn == 234) {
#line 2909
    goto case_234;
  }
#line 2932
  if (yyn == 236) {
#line 2932
    goto case_236;
  }
#line 2979
  if (yyn == 238) {
#line 2979
    goto case_238;
  }
#line 2983
  if (yyn == 240) {
#line 2983
    goto case_240;
  }
#line 2987
  if (yyn == 242) {
#line 2987
    goto case_242;
  }
#line 2991
  if (yyn == 244) {
#line 2991
    goto case_244;
  }
#line 3023
  if (yyn == 246) {
#line 3023
    goto case_246;
  }
#line 3071
  if (yyn == 248) {
#line 3071
    goto case_248;
  }
#line 3092
  if (yyn == 250) {
#line 3092
    goto case_250;
  }
#line 3113
  if (yyn == 252) {
#line 3113
    goto case_252;
  }
#line 3134
  if (yyn == 254) {
#line 3134
    goto case_254;
  }
#line 3143
  if (yyn == 255) {
#line 3143
    goto case_255;
  }
#line 3147
  if (yyn == 257) {
#line 3147
    goto case_257;
  }
#line 3152
  if (yyn == 258) {
#line 3152
    goto case_258___4;
  }
#line 3156
  if (yyn == 262) {
#line 3156
    goto case_262;
  }
#line 3202
  if (yyn == 263) {
#line 3202
    goto case_263;
  }
#line 3334
  if (yyn == 265) {
#line 3334
    goto case_265;
  }
#line 3343
  if (yyn == 266) {
#line 3343
    goto case_266;
  }
#line 3435
  if (yyn == 267) {
#line 3435
    goto case_267;
  }
#line 3521
  if (yyn == 269) {
#line 3521
    goto case_269;
  }
#line 3551
  if (yyn == 270) {
#line 3551
    goto case_270;
  }
#line 3575
  if (yyn == 271) {
#line 3575
    goto case_271;
  }
#line 3597
  if (yyn == 272) {
#line 3597
    goto case_272;
  }
#line 3619
  if (yyn == 273) {
#line 3619
    goto case_273;
  }
#line 3641
  if (yyn == 274) {
#line 3641
    goto case_274;
  }
#line 3659
  if (yyn == 275) {
#line 3659
    goto case_275;
  }
#line 3677
  if (yyn == 276) {
#line 3677
    goto case_276;
  }
#line 3695
  if (yyn == 277) {
#line 3695
    goto case_277;
  }
#line 3719
  if (yyn == 278) {
#line 3719
    goto case_278;
  }
#line 3769
  if (yyn == 279) {
#line 3769
    goto case_279;
  }
#line 3787
  if (yyn == 281) {
#line 3787
    goto case_281;
  }
#line 3795
  if (yyn == 283) {
#line 3795
    goto case_283;
  }
#line 3839
  if (yyn == 284) {
#line 3839
    goto case_284;
  }
#line 3870
  if (yyn == 285) {
#line 3870
    goto case_285;
  }
#line 3925
  if (yyn == 286) {
#line 3925
    goto case_286;
  }
#line 3968
  if (yyn == 287) {
#line 3968
    goto case_287;
  }
#line 4001
  if (yyn == 288) {
#line 4001
    goto case_288;
  }
#line 4034
  if (yyn == 289) {
#line 4034
    goto case_289;
  }
#line 4066
  if (yyn == 290) {
#line 4066
    goto case_290;
  }
#line 4098
  if (yyn == 291) {
#line 4098
    goto case_291;
  }
#line 4141
  if (yyn == 292) {
#line 4141
    goto case_292;
  }
#line 4192
  if (yyn == 293) {
#line 4192
    goto case_293;
  }
#line 4209
  if (yyn == 294) {
#line 4209
    goto case_294;
  }
#line 4231
  if (yyn == 295) {
#line 4231
    goto case_295;
  }
#line 4254
  if (yyn == 296) {
#line 4254
    goto case_296;
  }
#line 4261
  if (yyn == 297) {
#line 4261
    goto case_297;
  }
#line 4266
  if (yyn == 298) {
#line 4266
    goto case_298;
  }
#line 4273
  if (yyn == 299) {
#line 4273
    goto case_299;
  }
#line 4291
  if (yyn == 300) {
#line 4291
    goto case_300;
  }
#line 4309
  if (yyn == 301) {
#line 4309
    goto case_301;
  }
#line 4333
  if (yyn == 302) {
#line 4333
    goto case_302;
  }
#line 4353
  if (yyn == 304) {
#line 4353
    goto case_304;
  }
#line 4480
  if (yyn == 306) {
#line 4480
    goto case_306;
  }
#line 4499
  if (yyn == 307) {
#line 4499
    goto case_307;
  }
#line 4515
  if (yyn == 308) {
#line 4515
    goto case_308;
  }
#line 4539
  if (yyn == 310) {
#line 4539
    goto case_310;
  }
#line 4568
  if (yyn == 311) {
#line 4568
    goto case_311;
  }
#line 4594
  if (yyn == 313) {
#line 4594
    goto case_313;
  }
#line 4624
  if (yyn == 314) {
#line 4624
    goto case_314;
  }
#line 4649
  if (yyn == 316) {
#line 4649
    goto case_316;
  }
#line 4671
  if (yyn == 317) {
#line 4671
    goto case_317;
  }
#line 4690
  if (yyn == 318) {
#line 4690
    goto case_318;
  }
#line 4709
  if (yyn == 319) {
#line 4709
    goto case_319;
  }
#line 4728
  if (yyn == 321) {
#line 4728
    goto case_321;
  }
#line 4750
  if (yyn == 322) {
#line 4750
    goto case_322;
  }
#line 4769
  if (yyn == 324) {
#line 4769
    goto case_324;
  }
#line 4801
  if (yyn == 326) {
#line 4801
    goto case_326;
  }
#line 4829
  if (yyn == 328) {
#line 4829
    goto case_328;
  }
#line 4857
  if (yyn == 330) {
#line 4857
    goto case_330;
  }
#line 4882
  if (yyn == 331) {
#line 4882
    goto case_331;
  }
#line 4908
  if (yyn == 333) {
#line 4908
    goto case_333;
  }
#line 4933
  if (yyn == 334) {
#line 4933
    goto case_334;
  }
#line 4959
  if (yyn == 336) {
#line 4959
    goto case_336;
  }
#line 4976
  if (yyn == 337) {
#line 4976
    goto case_337;
  }
#line 4984
  if (yyn == 338) {
#line 4984
    goto case_338;
  }
#line 4990
  if (yyn == 340) {
#line 4990
    goto case_340;
  }
#line 5021
  if (yyn == 341) {
#line 5021
    goto case_341;
  }
#line 5030
  if (yyn == 343) {
#line 5030
    goto case_343;
  }
#line 5049
  if (yyn == 344) {
#line 5049
    goto case_344;
  }
#line 5069
  if (yyn == 345) {
#line 5069
    goto case_345;
  }
#line 5086
  if (yyn == 346) {
#line 5086
    goto case_346;
  }
#line 5114
  if (yyn == 347) {
#line 5114
    goto case_347;
  }
#line 5142
  if (yyn == 348) {
#line 5142
    goto case_348;
  }
#line 5170
  if (yyn == 349) {
#line 5170
    goto case_349;
  }
#line 5198
  if (yyn == 350) {
#line 5198
    goto case_350;
  }
#line 5226
  if (yyn == 351) {
#line 5226
    goto case_351;
  }
#line 5255
  if (yyn == 352) {
#line 5255
    goto case_352;
  }
#line 5284
  if (yyn == 353) {
#line 5284
    goto case_353;
  }
#line 5313
  if (yyn == 355) {
#line 5313
    goto case_355;
  }
#line 542 "/usr/share/misc/bison.simple"
  goto switch_break;
  case_1: /* CIL Label */ 
#line 160 "ys.y"
  ((struct OPERAND_0_ma *)kodp)->major = 35;
#line 160
  kodp += sizeof(struct OPERAND_0_ma );
#line 160
  last_instr = current_instr;
#line 160
  current_instr = kodp;
#line 161
  if (handle_main) {
#line 161
    if (! no_compile_only) {
      {
#line 162
      fix_and_clear_goto_table();
      }
    }
  }
#line 163
  if (no_compile_only) {
#line 163
    if (! handle_main) {
#line 163
      goto _L___0;
    } else
#line 163
    if (initialize_only) {
      _L___0: /* CIL Label */ 
      {
#line 168
      fix_and_clear_goto_table();
#line 170
      virtual_machine_suspended = 0;
#line 172
      tmp___2 = exec();
      }
#line 172
      if (0 == tmp___2) {
#line 173
        return (0);
      }
#line 175
      virtual_machine_suspended = 1;
    } else {
#line 163
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 178
  if (! s) {
#line 179
    return (0);
  }
#line 180
  if (initialize_only) {
#line 180
    initialize_only --;
  }
#line 182
  kodp = kodp1;
#line 182
  pc = kodp;
#line 182
  current_instr = kodp;
#line 182
  last_instr = kodp;
#line 187
  goto switch_break;
  case_6: /* CIL Label */ 
#line 203
  if (handle_main) {
    {
#line 204
    error_message(7003);
    }
  }
#line 206
  goto switch_break;
  case_7: /* CIL Label */ 
#line 208
  if (handle_main) {
    {
#line 209
    error_message(7003);
    }
  }
#line 210
  ((struct OPERAND_0_ma *)kodp)->major = 51;
#line 210
  kodp += sizeof(struct OPERAND_0_ma );
#line 210
  last_instr = current_instr;
#line 210
  current_instr = kodp;
#line 212
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 215
  yyerrstatus = 0;
#line 218
  error_message(1004, text);
  }
#line 220
  goto switch_break;
  case_11: /* CIL Label */ 
#line 228
  if (no_compile_only) {
    {
#line 230
    has_goto((yyvsp + -1)->mystring);
#line 231
    ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 231
    kodp += sizeof(struct OPERAND_1_ma );
#line 231
    last_instr = current_instr;
#line 231
    current_instr = kodp;
    }
  }
#line 234
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 237
  yyerrstatus = 0;
#line 237
  error_message(1004, "}");
  }
#line 239
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 241
  yyerrstatus = 0;
#line 241
  error_message(1004, ";");
  }
#line 243
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 260
  brfix();
#line 261
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 261
  kodp += sizeof(struct OPERAND_1_ma );
#line 261
  last_instr = current_instr;
#line 261
  current_instr = kodp;
  }
#line 263
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 266
  cofix();
#line 267
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 267
  kodp += sizeof(struct OPERAND_1_ma );
#line 267
  last_instr = current_instr;
#line 267
  current_instr = kodp;
  }
#line 269
  goto switch_break;
  case_17: /* CIL Label */ 
#line 272
  if (1U == (unsigned int )type_ac[set - 1]) {
    {
#line 273
    error_message(6002);
    }
  }
  {
#line 274
  tmp___3 = l_value_cast();
  }
#line 274
  if (-1 == tmp___3) {
#line 274
    if (2 < set) {
#line 275
      no_compile_only = 0;
    }
  }
#line 276
  variable[set].adr = (char *)((void *)0);
#line 276
  variable[set].offset = 0;
#line 277
  subscript_flag[set] = 0;
#line 277
  struct_union_field[set] = 0;
#line 277
  type_ac[set] = (enum intern_arit_class )0;
#line 277
  tmp___4 = set;
#line 277
  set --;
#line 277
  type_com[tmp___4] = (struct internal_type *)((void *)0);
#line 277
  if (0 > set) {
    {
#line 277
    error_message(5003);
    }
  }
#line 278
  if ((unsigned long )((void *)0) != (unsigned long )kodp3) {
    {
#line 280
    memmovex((void *)(kodp3 + sizeof(struct OPERAND_0_ma )), (void *)kodp3, (unsigned int )(kodp - kodp3));
#line 282
    ((struct OPERAND_0_ma *)kodp3)->major = 43;
#line 282
    kodp += sizeof(struct OPERAND_0_ma );
#line 282
    last_instr = current_instr;
#line 282
    current_instr = kodp;
#line 283
    kodp3 = (char *)((void *)0);
    }
  }
  {
#line 285
  retfix();
#line 286
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 286
  kodp += sizeof(struct OPERAND_1_ma );
#line 286
  last_instr = current_instr;
#line 286
  current_instr = kodp;
#line 287
  is_address = 0;
  }
#line 289
  goto switch_break;
  case_18: /* CIL Label */ 
#line 292
  if (1U != (unsigned int )type_ac[set]) {
    {
#line 293
    error_message(6001);
    }
  }
  {
#line 294
  retfix();
#line 295
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 295
  kodp += sizeof(struct OPERAND_1_ma );
#line 295
  last_instr = current_instr;
#line 295
  current_instr = kodp;
  }
#line 297
  goto switch_break;
  case_25: /* CIL Label */ 
#line 321
  type_spec_count ++;
#line 321
  if (scope_level > 0) {
#line 321
    tmp___5 = 1;
  } else {
#line 321
    tmp___5 = 0;
  }
  {
#line 321
  tmp___6 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___5);
#line 321
  typeh[type_spec_count] = (struct internal_type *)tmp___6;
#line 324
  init_zero((char *)typeh[type_spec_count], (unsigned int )sizeof(struct internal_type ));
#line 326
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1024;
#line 328
  (typeh[type_spec_count])->attribute.type_qualifier = (enum type_qual )4098;
#line 330
  (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )0;
#line 332
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 334
  body_flag = 1;
  }
#line 336
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 356
  type_spec_count ++;
#line 356
  tmp___7 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 356
  typeh[type_spec_count] = (struct internal_type *)tmp___7;
#line 358
  init_zero((char *)typeh[type_spec_count], (unsigned int )sizeof(struct internal_type ));
#line 361
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1026;
#line 363
  body_flag = 1;
#line 364
  tmp___8 = has((yyvsp + -1)->mystring);
  }
#line 364
  if (-1 == tmp___8) {
#line 365
    no_compile_only = 0;
  }
  {
#line 366
  tmp___9 = load_new();
  }
#line 366
  if (! tmp___9) {
    {
#line 366
    tmp___10 = load(& remote_ptr_C);
    }
#line 366
    if (! tmp___10) {
      {
#line 368
      has_remote(remote_ptr_C);
      }
    }
  }
#line 369
  tmp___11 = type_spec_count;
#line 369
  type_spec_count --;
#line 369
  typeh[tmp___11] = (struct internal_type *)((void *)0);
#line 371
  goto switch_break;
  case_28: /* CIL Label */ 
#line 374
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 376
  body_flag = 0;
#line 376
  unload();
  }
#line 378
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 391
  ((struct OPERAND_1_i *)kodp)->major = 10;
#line 391
  ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 391
  ((struct OPERAND_1_i *)kodp)->num = scope_offset_get();
#line 391
  kodp += sizeof(struct OPERAND_1_i );
#line 391
  last_instr = current_instr;
#line 391
  current_instr = kodp;
#line 392
  exit_scope();
  }
#line 394
  goto switch_break;
  case_32: /* CIL Label */ 
#line 400
  if (! (2048U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 400
    if (! (2049U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 400
      if (! (((struct OPERAND_0_mi *)last_instr)->major == 37)) {
#line 400
        if (! (((struct OPERAND_0_mi *)last_instr)->major == 40)) {
          {
#line 403
          error_message(6027);
          }
        }
      }
    }
  }
  {
#line 422
  if ((unsigned int )type_ac[set] == 258U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 130U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 2U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 32U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 80U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 64U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 268U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 140U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 12U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 280U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 152U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 24U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 264U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 136U) {
#line 422
    goto case_258;
  }
#line 422
  if ((unsigned int )type_ac[set] == 8U) {
#line 422
    goto case_258;
  }
#line 425
  if ((unsigned int )type_ac[set] == 1U) {
#line 425
    goto case_1___0;
  }
#line 427
  goto switch_default;
  case_258: /* CIL Label */ 
  case_130: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_32___0: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_268: /* CIL Label */ 
  case_140: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_280: /* CIL Label */ 
  case_152: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_264: /* CIL Label */ 
  case_136: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 423
  ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 423
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 423
  kodp += sizeof(struct OPERAND_0_mi );
#line 423
  last_instr = current_instr;
#line 423
  current_instr = kodp;
#line 424
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 426
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 428
  fprintfx(stderr, "%s:%d:\n", "ys.y", 428);
#line 429
  error_message(5000);
  }
#line 429
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
#line 431
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 431
  kodp += sizeof(struct OPERAND_0_ma );
#line 431
  last_instr = current_instr;
#line 431
  current_instr = kodp;
#line 431
  kodp3 = (char *)((void *)0);
#line 432
  is_address = 0;
#line 433
  variable[set].adr = (char *)((void *)0);
#line 433
  variable[set].offset = 0;
#line 434
  subscript_flag[set] = 0;
#line 434
  struct_union_field[set] = 0;
#line 434
  type_ac[set] = (enum intern_arit_class )0;
#line 434
  tmp___12 = set;
#line 434
  set --;
#line 434
  type_com[tmp___12] = (struct internal_type *)((void *)0);
#line 434
  if (0 > set) {
    {
#line 434
    error_message(5003);
    }
  }
#line 436
  goto switch_break;
  case_36: /* CIL Label */ 
#line 442
  ((struct OPERAND_0_ma *)kodp)->major = 34;
#line 442
  kodp += sizeof(struct OPERAND_0_ma );
#line 442
  last_instr = current_instr;
#line 442
  current_instr = kodp;
#line 444
  goto switch_break;
  case_37: /* CIL Label */ 
#line 452
  ((struct OPERAND_0_ma *)kodp)->major = 50;
#line 452
  kodp += sizeof(struct OPERAND_0_ma );
#line 452
  last_instr = current_instr;
#line 452
  current_instr = kodp;
#line 454
  goto switch_break;
  case_38: /* CIL Label */ 
#line 475
  variable[set].adr = (char *)((void *)0);
#line 475
  variable[set].offset = 0;
#line 476
  subscript_flag[set] = 0;
#line 476
  struct_union_field[set] = 0;
#line 476
  type_ac[set] = (enum intern_arit_class )0;
#line 476
  tmp___13 = set;
#line 476
  set --;
#line 476
  type_com[tmp___13] = (struct internal_type *)((void *)0);
#line 476
  if (0 > set) {
    {
#line 476
    error_message(5003);
    }
  }
#line 477
  kodp3 = (char *)((void *)0);
#line 477
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 477
  kodp += sizeof(struct OPERAND_0_ma );
#line 477
  last_instr = current_instr;
#line 477
  current_instr = kodp;
#line 477
  fixp ++;
#line 481
  fixp->if1.major = 291;
#line 482
  fixp->if1.jz = kodp;
#line 483
  ((struct OPERAND_1_ma *)kodp)->major = 27;
#line 483
  kodp += sizeof(struct OPERAND_1_ma );
#line 483
  last_instr = current_instr;
#line 483
  current_instr = kodp;
#line 484
  is_address = 0;
#line 486
  goto switch_break;
  case_40: /* CIL Label */ 
#line 490
  if (8U != (unsigned int )type_ac[set]) {
    {
#line 491
    error_message(1013);
    }
  }
#line 492
  kodp3 = (char *)((void *)0);
#line 492
  fixp ++;
#line 496
  fixp->switch1.major = 294;
#line 497
  fixp->switch1.jz = (char *)((void *)0);
#line 498
  fixp->switch1.def_use.def_flag = 0;
#line 499
  fixp->switch1.jmp = kodp;
#line 499
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 499
  kodp += sizeof(struct OPERAND_1_ma );
#line 499
  last_instr = current_instr;
#line 499
  current_instr = kodp;
#line 500
  is_address = 0;
#line 502
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 504
  search_duplicate_labels();
  }
#line 505
  if (fixp->switch1.def_use.def_flag) {
#line 511
    ((struct OPERAND_1_ma *)fixp->switch1.jz)->adr = fixp->switch1.def_use.adr;
  } else
#line 513
  if ((unsigned long )((void *)0) != (unsigned long )fixp->switch1.jz) {
#line 514
    ((struct OPERAND_1_ma *)fixp->switch1.jz)->adr = kodp;
  }
  {
#line 516
  fix_break_s();
#line 517
  variable[set].adr = (char *)((void *)0);
#line 517
  variable[set].offset = 0;
#line 518
  subscript_flag[set] = 0;
#line 518
  struct_union_field[set] = 0;
#line 518
  type_ac[set] = (enum intern_arit_class )0;
#line 518
  tmp___14 = set;
#line 518
  set --;
#line 518
  type_com[tmp___14] = (struct internal_type *)((void *)0);
  }
#line 518
  if (0 > set) {
    {
#line 518
    error_message(5003);
    }
  }
#line 519
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 519
  kodp += sizeof(struct OPERAND_0_ma );
#line 519
  last_instr = current_instr;
#line 519
  current_instr = kodp;
#line 519
  fixp --;
#line 521
  goto switch_break;
  case_42: /* CIL Label */ 
#line 528
  fixp ++;
#line 529
  fixp->while1.major = 295;
#line 530
  fixp->while1.jmp = kodp;
#line 536
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 538
  promote_type();
#line 539
  variable[set].adr = (char *)((void *)0);
#line 539
  variable[set].offset = 0;
#line 540
  subscript_flag[set] = 0;
#line 540
  struct_union_field[set] = 0;
#line 540
  type_ac[set] = (enum intern_arit_class )0;
#line 540
  tmp___15 = set;
#line 540
  set --;
#line 540
  type_com[tmp___15] = (struct internal_type *)((void *)0);
  }
#line 540
  if (0 > set) {
    {
#line 540
    error_message(5003);
    }
  }
#line 541
  kodp3 = (char *)((void *)0);
#line 541
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 541
  kodp += sizeof(struct OPERAND_0_ma );
#line 541
  last_instr = current_instr;
#line 541
  current_instr = kodp;
#line 542
  fixp->while1.jz = kodp;
#line 543
  ((struct OPERAND_1_ma *)kodp)->major = 27;
#line 543
  kodp += sizeof(struct OPERAND_1_ma );
#line 543
  last_instr = current_instr;
#line 543
  current_instr = kodp;
#line 544
  is_address = 0;
#line 546
  goto switch_break;
  case_45: /* CIL Label */ 
#line 550
  fixp ++;
#line 551
  fixp->while1.major = 295;
#line 552
  fixp->while1.jmp = kodp;
#line 558
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 561
  promote_type();
#line 562
  variable[set].adr = (char *)((void *)0);
#line 562
  variable[set].offset = 0;
#line 563
  subscript_flag[set] = 0;
#line 563
  struct_union_field[set] = 0;
#line 563
  type_ac[set] = (enum intern_arit_class )0;
#line 563
  tmp___16 = set;
#line 563
  set --;
#line 563
  type_com[tmp___16] = (struct internal_type *)((void *)0);
  }
#line 563
  if (0 > set) {
    {
#line 563
    error_message(5003);
    }
  }
  {
#line 564
  kodp3 = (char *)((void *)0);
#line 564
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 564
  kodp += sizeof(struct OPERAND_0_ma );
#line 564
  last_instr = current_instr;
#line 564
  current_instr = kodp;
#line 565
  fixp->while1.jz = kodp;
#line 566
  ((struct OPERAND_1_ma *)kodp)->major = 27;
#line 566
  kodp += sizeof(struct OPERAND_1_ma );
#line 566
  last_instr = current_instr;
#line 566
  current_instr = kodp;
#line 567
  ((struct OPERAND_1_ma *)kodp)->adr = fixp->while1.jmp;
#line 568
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 568
  kodp += sizeof(struct OPERAND_1_ma );
#line 568
  last_instr = current_instr;
#line 568
  current_instr = kodp;
#line 569
  ((struct OPERAND_1_ma *)fixp->while1.jz)->adr = kodp;
#line 574
  fix_break_w();
#line 575
  fix_cont_w();
#line 576
  fixp --;
#line 577
  is_address = 0;
  }
#line 579
  goto switch_break;
  case_47: /* CIL Label */ 
#line 582
  ((struct OPERAND_1_ma *)kodp)->adr = fixp->for1.jmp3;
#line 583
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 583
  kodp += sizeof(struct OPERAND_1_ma );
#line 583
  last_instr = current_instr;
#line 583
  current_instr = kodp;
#line 584
  if ((unsigned long )((void *)0) != (unsigned long )fixp->for1.jn) {
#line 585
    ((struct OPERAND_1_ma *)fixp->for1.jn)->adr = kodp;
  }
  {
#line 587
  fix_break_f();
#line 588
  fix_cont_f();
#line 589
  fixp --;
  }
#line 591
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 599
  ((struct OPERAND_1_ma *)kodp)->adr = fixp->while1.jmp;
#line 601
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 601
  kodp += sizeof(struct OPERAND_1_ma );
#line 601
  last_instr = current_instr;
#line 601
  current_instr = kodp;
#line 602
  ((struct OPERAND_1_ma *)fixp->while1.jz)->adr = kodp;
#line 607
  fix_break_w();
#line 608
  fix_cont_w();
#line 609
  fixp --;
  }
#line 611
  goto switch_break;
  case_51: /* CIL Label */ 
#line 626
  if (! (2048U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 626
    if (! (2049U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 626
      if (! (((struct OPERAND_0_mi *)last_instr)->major == 37)) {
#line 626
        if (! (((struct OPERAND_0_mi *)last_instr)->major == 40)) {
          {
#line 629
          error_message(6027);
          }
        }
      }
    }
  }
  {
#line 648
  if ((unsigned int )type_ac[set] == 258U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 130U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 2U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 32U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 80U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 64U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 268U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 140U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 12U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 280U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 152U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 24U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 264U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 136U) {
#line 648
    goto case_258___0;
  }
#line 648
  if ((unsigned int )type_ac[set] == 8U) {
#line 648
    goto case_258___0;
  }
#line 651
  if ((unsigned int )type_ac[set] == 1U) {
#line 651
    goto case_1___1;
  }
#line 653
  goto switch_default___0;
  case_258___0: /* CIL Label */ 
  case_130___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_32___1: /* CIL Label */ 
  case_80___0: /* CIL Label */ 
  case_64___0: /* CIL Label */ 
  case_268___0: /* CIL Label */ 
  case_140___0: /* CIL Label */ 
  case_12___0: /* CIL Label */ 
  case_280___0: /* CIL Label */ 
  case_152___0: /* CIL Label */ 
  case_24___0: /* CIL Label */ 
  case_264___0: /* CIL Label */ 
  case_136___0: /* CIL Label */ 
  case_8___0: /* CIL Label */ 
#line 649
  ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 649
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 649
  kodp += sizeof(struct OPERAND_0_mi );
#line 649
  last_instr = current_instr;
#line 649
  current_instr = kodp;
#line 650
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 652
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 654
  fprintfx(stderr, "%s:%d:\n", "ys.y", 654);
#line 655
  error_message(5000);
  }
#line 655
  return (0);
  switch_break___1: /* CIL Label */ ;
  }
#line 657
  kodp3 = (char *)((void *)0);
#line 658
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 658
  kodp += sizeof(struct OPERAND_0_ma );
#line 658
  last_instr = current_instr;
#line 658
  current_instr = kodp;
#line 658
  fixp ++;
#line 662
  fixp->for1.major = 296;
#line 663
  jmp1 = kodp;
#line 664
  is_address = 0;
#line 665
  variable[set].adr = (char *)((void *)0);
#line 665
  variable[set].offset = 0;
#line 666
  subscript_flag[set] = 0;
#line 666
  struct_union_field[set] = 0;
#line 666
  type_ac[set] = (enum intern_arit_class )0;
#line 666
  tmp___17 = set;
#line 666
  set --;
#line 666
  type_com[tmp___17] = (struct internal_type *)((void *)0);
#line 666
  if (0 > set) {
    {
#line 666
    error_message(5003);
    }
  }
#line 668
  goto switch_break;
  case_53: /* CIL Label */ 
#line 672
  fixp ++;
#line 676
  fixp->for1.major = 296;
#line 677
  jmp1 = kodp;
#line 679
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 684
  promote_type();
#line 685
  variable[set].adr = (char *)((void *)0);
#line 685
  variable[set].offset = 0;
#line 686
  subscript_flag[set] = 0;
#line 686
  struct_union_field[set] = 0;
#line 686
  type_ac[set] = (enum intern_arit_class )0;
#line 686
  tmp___18 = set;
#line 686
  set --;
#line 686
  type_com[tmp___18] = (struct internal_type *)((void *)0);
  }
#line 686
  if (0 > set) {
    {
#line 686
    error_message(5003);
    }
  }
#line 687
  kodp3 = (char *)((void *)0);
#line 687
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 687
  kodp += sizeof(struct OPERAND_0_ma );
#line 687
  last_instr = current_instr;
#line 687
  current_instr = kodp;
#line 688
  fixp->for1.jn = kodp;
#line 689
  ((struct OPERAND_1_ma *)kodp)->major = 27;
#line 689
  kodp += sizeof(struct OPERAND_1_ma );
#line 689
  last_instr = current_instr;
#line 689
  current_instr = kodp;
#line 690
  fixp->for1.jmp2 = kodp;
#line 691
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 691
  kodp += sizeof(struct OPERAND_1_ma );
#line 691
  last_instr = current_instr;
#line 691
  current_instr = kodp;
#line 692
  fixp->for1.jmp3 = kodp;
#line 693
  is_address = 0;
#line 695
  goto switch_break;
  case_57: /* CIL Label */ 
#line 699
  fixp->for1.jn = (char *)((void *)0);
#line 700
  fixp->for1.jmp2 = (char *)((void *)0);
#line 701
  fixp->for1.jmp3 = kodp;
#line 703
  goto switch_break;
  case_59: /* CIL Label */ 
#line 708
  if (! (2048U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 708
    if (! (2049U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 708
      if (! (((struct OPERAND_0_mi *)last_instr)->major == 37)) {
#line 708
        if (! (((struct OPERAND_0_mi *)last_instr)->major == 40)) {
          {
#line 711
          error_message(6027);
          }
        }
      }
    }
  }
  {
#line 730
  if ((unsigned int )type_ac[set] == 258U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 130U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 2U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 32U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 80U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 64U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 268U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 140U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 12U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 280U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 152U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 24U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 264U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 136U) {
#line 730
    goto case_258___1;
  }
#line 730
  if ((unsigned int )type_ac[set] == 8U) {
#line 730
    goto case_258___1;
  }
#line 733
  if ((unsigned int )type_ac[set] == 1U) {
#line 733
    goto case_1___2;
  }
#line 735
  goto switch_default___1;
  case_258___1: /* CIL Label */ 
  case_130___1: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
  case_32___2: /* CIL Label */ 
  case_80___1: /* CIL Label */ 
  case_64___1: /* CIL Label */ 
  case_268___1: /* CIL Label */ 
  case_140___1: /* CIL Label */ 
  case_12___1: /* CIL Label */ 
  case_280___1: /* CIL Label */ 
  case_152___1: /* CIL Label */ 
  case_24___1: /* CIL Label */ 
  case_264___1: /* CIL Label */ 
  case_136___1: /* CIL Label */ 
  case_8___1: /* CIL Label */ 
#line 731
  ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 731
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 731
  kodp += sizeof(struct OPERAND_0_mi );
#line 731
  last_instr = current_instr;
#line 731
  current_instr = kodp;
#line 732
  goto switch_break___2;
  case_1___2: /* CIL Label */ 
#line 734
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 736
  fprintfx(stderr, "%s:%d:\n", "ys.y", 736);
#line 737
  error_message(5000);
  }
#line 737
  return (0);
  switch_break___2: /* CIL Label */ ;
  }
#line 739
  kodp3 = (char *)((void *)0);
#line 740
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 740
  kodp += sizeof(struct OPERAND_0_ma );
#line 740
  last_instr = current_instr;
#line 740
  current_instr = kodp;
#line 741
  if ((unsigned long )((void *)0) != (unsigned long )fixp->for1.jn) {
#line 743
    ((struct OPERAND_1_ma *)kodp)->adr = jmp1;
#line 744
    ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 744
    kodp += sizeof(struct OPERAND_1_ma );
#line 744
    last_instr = current_instr;
#line 744
    current_instr = kodp;
#line 745
    ((struct OPERAND_1_ma *)fixp->for1.jmp2)->adr = kodp;
  }
#line 748
  is_address = 0;
#line 749
  variable[set].adr = (char *)((void *)0);
#line 749
  variable[set].offset = 0;
#line 750
  subscript_flag[set] = 0;
#line 750
  struct_union_field[set] = 0;
#line 750
  type_ac[set] = (enum intern_arit_class )0;
#line 750
  tmp___19 = set;
#line 750
  set --;
#line 750
  type_com[tmp___19] = (struct internal_type *)((void *)0);
#line 750
  if (0 > set) {
    {
#line 750
    error_message(5003);
    }
  }
#line 752
  goto switch_break;
  case_60: /* CIL Label */ 
#line 755
  if ((unsigned long )((void *)0) != (unsigned long )fixp->for1.jn) {
#line 757
    fixp->for1.jmp3 = jmp1;
#line 758
    ((struct OPERAND_1_ma *)fixp->for1.jmp2)->adr = kodp;
  } else {
#line 762
    fixp->for1.jmp3 = kodp;
  }
#line 764
  goto switch_break;
  case_61: /* CIL Label */ 
#line 774
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 775
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class + 8U);
  } else {
#line 778
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 8U);
  }
#line 780
  typedef_f = 0;
#line 782
  goto switch_break;
  case_62: /* CIL Label */ 
#line 785
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 786
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class + 64U);
  } else {
#line 789
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 64U);
  }
#line 791
  typedef_f = 0;
#line 793
  goto switch_break;
  case_63: /* CIL Label */ 
#line 796
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 797
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class + 32U);
  } else {
#line 800
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 32U);
  }
#line 802
  typedef_f = 0;
#line 804
  goto switch_break;
  case_64___2: /* CIL Label */ 
#line 807
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 808
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class + 2U);
  } else {
#line 811
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 2U);
  }
#line 813
  typedef_f = 0;
#line 815
  goto switch_break;
  case_65: /* CIL Label */ 
#line 818
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 819
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class + 1U);
  } else {
#line 822
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 1U);
  }
#line 824
  typedef_f = 0;
#line 826
  goto switch_break;
  case_66: /* CIL Label */ 
#line 828
  if (16U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 829
    error_message(6025, "long");
    }
  }
#line 830
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 832
    if (16U & (unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class) {
      {
#line 833
      error_message(6025, "long");
      }
    }
#line 834
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class + 16U);
  } else {
#line 838
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 16U);
  }
#line 840
  typedef_f = 0;
#line 842
  goto switch_break;
  case_67: /* CIL Label */ 
#line 844
  if (4U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 845
    error_message(6025, "short");
    }
  }
#line 846
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 848
    if (4U & (unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class) {
      {
#line 849
      error_message(6025, "short");
      }
    }
#line 850
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class + 4U);
  } else {
#line 854
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 4U);
  }
#line 856
  typedef_f = 0;
#line 858
  goto switch_break;
  case_68: /* CIL Label */ 
#line 860
  if (128U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 861
    error_message(6025, "signed");
    }
  }
#line 862
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 864
    if (128U & (unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class) {
      {
#line 865
      error_message(6025, "signed");
      }
    }
#line 866
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class + 128U);
  } else {
#line 870
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 128U);
  }
#line 872
  typedef_f = 0;
#line 874
  goto switch_break;
  case_69: /* CIL Label */ 
#line 876
  if (256U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 877
    error_message(6025, "unsigned");
    }
  }
#line 878
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 880
    if (256U & (unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class) {
      {
#line 881
      error_message(6025, "unsigned");
      }
    }
#line 882
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )((unsigned int )((typeh[type_spec_count])->output)->attribute.arit_class + 256U);
  } else {
#line 886
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )((unsigned int )(typeh[type_spec_count])->attribute.arit_class + 256U);
  }
#line 888
  typedef_f = 0;
#line 890
  goto switch_break;
  case_72: /* CIL Label */ 
#line 895
  unused_p = 0U == (unsigned int )(typeh[type_spec_count])->attribute.arit_class;
#line 896
  if (! unused_p) {
    {
#line 898
    error_message(1001);
#line 899
    no_compile_only = 0;
    }
  }
  {
#line 901
  ptr = point_loc((yyvsp + 0)->mystring);
  }
#line 902
  if ((unsigned long )((void *)0) == (unsigned long )ptr) {
    {
#line 904
    tmp___20 = point((yyvsp + 0)->mystring);
#line 904
    ptr1 = tmp___20;
    }
#line 905
    if ((unsigned long )((void *)0) == (unsigned long )ptr1) {
#line 906
      no_compile_only = 0;
    }
#line 907
    if (unused_p) {
#line 908
      typeh[type_spec_count] = (ptr1->type)->output;
    } else {
#line 910
      ptr1->type = typeh[type_spec_count];
    }
  } else
#line 912
  if (unused_p) {
#line 913
    typeh[type_spec_count] = (ptr->type)->output;
  } else {
#line 915
    ptr->type = typeh[type_spec_count];
  }
#line 916
  typedef_f = 0;
#line 918
  goto switch_break;
  case_73: /* CIL Label */ 
#line 923
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 924
    ((typeh[type_spec_count])->output)->attribute.type_qualifier = (enum type_qual )4096;
  } else {
#line 927
    (typeh[type_spec_count])->attribute.type_qualifier = (enum type_qual )4096;
  }
#line 930
  goto switch_break;
  case_74: /* CIL Label */ 
#line 933
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 934
    ((typeh[type_spec_count])->output)->attribute.type_qualifier = (enum type_qual )4097;
  } else {
#line 937
    (typeh[type_spec_count])->attribute.type_qualifier = (enum type_qual )4097;
  }
#line 940
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 947
  tmp___21 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 947
  help___0 = (struct internal_type *)tmp___21;
#line 949
  init_zero((char *)help___0, (unsigned int )sizeof(struct internal_type ));
  }
#line 951
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 953
    help___0->output = (typeh[type_spec_count])->output;
#line 954
    (typeh[type_spec_count])->output = help___0;
#line 955
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )1028;
  } else {
#line 960
    help___0->output = typeh[type_spec_count];
#line 961
    typeh[type_spec_count] = help___0;
#line 962
    (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1028;
  }
#line 966
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 979
  typedef_f = 0;
#line 980
  body_flag = 0;
#line 981
  tmp___22 = has_tag(0, (yyvsp + 0)->mystring);
  }
#line 981
  if (-1 == tmp___22) {
#line 982
    no_compile_only = 0;
  }
#line 983
  suen_count ++;
#line 983
  struct_union_enum_name[suen_count] = text;
#line 984
  if (param_flag) {
    {
#line 985
    error_message(6009);
    }
  }
#line 987
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 989
  proc ++;
#line 989
  proc_name_text[proc] = struct_union_enum_name[suen_count];
#line 991
  tmp___23 = add_spec_to_tag();
  }
#line 991
  if (-1 == tmp___23) {
#line 992
    no_compile_only = 0;
  }
  {
#line 993
  tmp___24 = add_ident_to_tag();
  }
#line 993
  if (-1 == tmp___24) {
#line 994
    no_compile_only = 0;
  }
  {
#line 995
  tmp___25 = proc;
#line 995
  proc --;
#line 995
  proc_name_text[tmp___25] = (char *)((void *)0);
#line 996
  body_flag = 1;
#line 997
  text = struct_union_enum_name[suen_count];
#line 998
  tmp___26 = has_tag(0, text);
  }
#line 998
  if (-1 == tmp___26) {
#line 999
    no_compile_only = 0;
  }
#line 1000
  tmp___27 = suen_count;
#line 1000
  suen_count --;
#line 1000
  struct_union_enum_name[tmp___27] = (char *)((void *)0);
#line 1002
  goto switch_break;
  case_83: /* CIL Label */ 
#line 1004
  typedef_f = 0;
#line 1005
  if (param_flag) {
    {
#line 1006
    error_message(6009);
    }
  }
#line 1008
  goto switch_break;
  case_84: /* CIL Label */ 
#line 1010
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1011
    ((typeh[type_spec_count])->output)->input = l_type_spec;
  } else {
#line 1013
    (typeh[type_spec_count])->input = l_type_spec;
  }
#line 1014
  l_type_spec = (struct internal_type *)((void *)0);
#line 1015
  if (param_flag) {
    {
#line 1016
    error_message(6009);
    }
  }
#line 1018
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 1020
  typedef_f = 0;
#line 1021
  body_flag = 0;
#line 1022
  body_flag = has_tag(1, (yyvsp + 0)->mystring);
  }
#line 1022
  if (-1 == body_flag) {
#line 1023
    no_compile_only = 0;
  }
#line 1024
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1026
    if (0 == ((typeh[type_spec_count])->output)->attribute.memory_size) {
#line 1027
      suen_count ++;
#line 1027
      struct_union_enum_name[suen_count] = (yyvsp + 0)->mystring;
    }
  } else
#line 1031
  if (0 == (typeh[type_spec_count])->attribute.memory_size) {
#line 1032
    suen_count ++;
#line 1032
    struct_union_enum_name[suen_count] = (yyvsp + 0)->mystring;
  }
#line 1035
  goto switch_break;
  case_86: /* CIL Label */ 
#line 1040
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1042
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )8;
#line 1044
    ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )1029;
  } else {
#line 1049
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
#line 1051
    (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1029;
  }
#line 1055
  goto switch_break;
  case_87: /* CIL Label */ 
#line 1058
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1060
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )8;
#line 1062
    ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )1030;
  } else {
#line 1067
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
#line 1069
    (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1030;
  }
#line 1073
  goto switch_break;
  case_88: /* CIL Label */ 
#line 1078
  tmp___28 = type_spec_count;
#line 1078
  type_spec_count --;
#line 1078
  typeh[tmp___28] = (struct internal_type *)((void *)0);
#line 1080
  goto switch_break;
  case_89: /* CIL Label */ 
#line 1082
  tmp___29 = type_spec_count;
#line 1082
  type_spec_count --;
#line 1082
  typeh[tmp___29] = (struct internal_type *)((void *)0);
#line 1084
  goto switch_break;
  case_90: /* CIL Label */ 
#line 1089
  if (1 < suen_count) {
#line 1090
    tmp___30 = suen_count;
#line 1090
    suen_count --;
#line 1090
    struct_union_enum_name[tmp___30] = (char *)((void *)0);
  }
#line 1092
  goto switch_break;
  case_100: /* CIL Label */ 
#line 1115
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1117
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )8;
#line 1119
    ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )1031;
  } else {
#line 1124
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
#line 1125
    (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1031;
  }
#line 1128
  if (param_flag) {
    {
#line 1129
    error_message(6009);
    }
  }
#line 1130
  typedef_f = 0;
#line 1132
  goto switch_break;
  case_101: /* CIL Label */ 
#line 1134
  enum_value = 0;
#line 1136
  goto switch_break;
  case_102: /* CIL Label */ 
#line 1139
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1141
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )8;
#line 1143
    ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )1031;
  } else {
#line 1148
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
#line 1150
    (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1031;
  }
  {
#line 1153
  body_flag = 0;
#line 1154
  tmp___31 = has_tag(0, (yyvsp + -1)->mystring);
  }
#line 1154
  if (-1 == tmp___31) {
#line 1155
    no_compile_only = 0;
  }
#line 1156
  suen_count ++;
#line 1156
  struct_union_enum_name[suen_count] = text;
#line 1157
  if (param_flag) {
    {
#line 1158
    error_message(6009);
    }
  }
#line 1159
  typedef_f = 0;
#line 1161
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 1163
  enum_value = 0;
#line 1164
  body_flag = 1;
#line 1165
  text = struct_union_enum_name[suen_count];
#line 1166
  tmp___32 = has_tag(0, text);
  }
#line 1166
  if (-1 == tmp___32) {
#line 1167
    no_compile_only = 0;
  }
#line 1168
  tmp___33 = suen_count;
#line 1168
  suen_count --;
#line 1168
  struct_union_enum_name[tmp___33] = (char *)((void *)0);
#line 1170
  goto switch_break;
  case_104: /* CIL Label */ 
#line 1173
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1175
    ((typeh[type_spec_count])->output)->attribute.arit_class = (enum intern_arit_class )8;
#line 1177
    ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )1031;
  } else {
#line 1182
    (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
#line 1184
    (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1031;
  }
  {
#line 1187
  body_flag = 0;
#line 1188
  body_flag = has_tag(1, (yyvsp + 0)->mystring);
  }
#line 1188
  if (-1 == body_flag) {
#line 1189
    no_compile_only = 0;
  }
#line 1190
  typedef_f = 0;
#line 1192
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 1202
  type_spec_count ++;
#line 1202
  tmp___34 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 1202
  typeh[type_spec_count] = (struct internal_type *)tmp___34;
#line 1204
  init_zero((char *)typeh[type_spec_count], (unsigned int )sizeof(struct internal_type ));
#line 1206
  (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
#line 1208
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1024;
#line 1210
  (typeh[type_spec_count])->attribute.type_qualifier = (enum type_qual )4096;
#line 1212
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 1214
  tmp___35 = allocate((unsigned int )sizeof(int ), 0U);
#line 1214
  (typeh[type_spec_count])->attribute.domain = tmp___35;
#line 1216
  init_zero((typeh[type_spec_count])->attribute.domain, (unsigned int )sizeof(struct internal_type ));
#line 1218
  tmp___36 = enum_value;
#line 1218
  enum_value ++;
#line 1218
  *((int *)(typeh[type_spec_count])->attribute.domain) = tmp___36;
#line 1221
  put2table((yyvsp + 0)->mystring, typeh[type_spec_count]);
#line 1222
  tmp___37 = type_spec_count;
#line 1222
  type_spec_count --;
#line 1222
  typeh[tmp___37] = (struct internal_type *)((void *)0);
  }
#line 1224
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 1225
  fprintfx(stderr, "Assignment in an enumeration not supported yet\n");
  }
#line 1226
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 1233
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1233
    if (! (1028U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
#line 1233
      goto while_break___0;
    }
#line 1235
    typeh[type_spec_count] = (typeh[type_spec_count])->output;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1239
  goto switch_break;
  case_111: /* CIL Label */ 
#line 1250
  type = typeh[type_spec_count];
#line 1251
  if (8192U == (unsigned int )type->attribute.storage_class_specifier) {
#line 1252
    type = type->output;
  }
#line 1253
  if (1029U == (unsigned int )type->attribute.function_class) {
#line 1253
    goto _L___1;
  } else
#line 1253
  if (1030U == (unsigned int )type->attribute.function_class) {
    _L___1: /* CIL Label */ 
#line 1253
    if (suen_count > 1) {
#line 1253
      if (0 == type->attribute.memory_size) {
        {
#line 1257
        error_message(1025);
#line 1258
        no_compile_only = 0;
        }
      }
    }
  }
  {
#line 1260
  type->field_name = (yyvsp + 0)->mystring;
#line 1261
  tmp___38 = add_to_spec_list();
  }
#line 1261
  if (-1 == tmp___38) {
#line 1262
    no_compile_only = 0;
  }
  {
#line 1263
  type->field_name = (char *)((void *)0);
#line 1264
  tmp___39 = add_to_ident_list();
  }
#line 1264
  if (-1 == tmp___39) {
#line 1265
    no_compile_only = 0;
  }
#line 1267
  goto switch_break;
  case_112: /* CIL Label */ 
#line 1269
  type___0 = typeh[type_spec_count];
#line 1271
  if (8192U == (unsigned int )type___0->attribute.storage_class_specifier) {
#line 1272
    type___0 = type___0->output;
  }
#line 1273
  if (1029U == (unsigned int )type___0->attribute.function_class) {
#line 1273
    goto _L___2;
  } else
#line 1273
  if (1030U == (unsigned int )type___0->attribute.function_class) {
    _L___2: /* CIL Label */ 
#line 1273
    if (suen_count > 1) {
#line 1273
      if (0 == type___0->attribute.memory_size) {
        {
#line 1277
        error_message(1025);
#line 1278
        no_compile_only = 0;
        }
      }
    }
  }
  {
#line 1280
  tmp___40 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 1280
  help___1 = (struct internal_type *)tmp___40;
#line 1282
  init_zero((char *)help___1, (unsigned int )sizeof(struct internal_type ));
#line 1284
  help___1->output = type___0;
#line 1285
  help___1->attribute.function_class = (enum intern_func_class )1025;
#line 1286
  help___1->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 1287
  help___1->field_name = (yyvsp + -1)->mystring;
#line 1288
  arch = type___0;
  }
#line 1289
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1290
    (typeh[type_spec_count])->output = help___1;
  } else {
#line 1292
    typeh[type_spec_count] = help___1;
  }
  {
#line 1293
  tmp___41 = add_to_spec_list();
  }
#line 1293
  if (-1 == tmp___41) {
#line 1294
    no_compile_only = 0;
  }
  {
#line 1295
  help___1->field_name = (char *)((void *)0);
#line 1296
  tmp___42 = add_to_ident_list();
  }
#line 1296
  if (-1 == tmp___42) {
#line 1297
    no_compile_only = 0;
  }
#line 1298
  count_arr = 1;
#line 1299
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1300
    typedef_copy(arch);
    }
  } else {
#line 1302
    typeh[type_spec_count] = arch;
  }
  {
#line 1303
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1303
    if (! (-1 != dim[poc])) {
#line 1303
      goto while_break___1;
    }
#line 1303
    tmp___43 = poc;
#line 1303
    poc --;
#line 1303
    dim[tmp___43] = -1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1305
  goto switch_break;
  case_114: /* CIL Label */ 
#line 1311
  if (! initialize_only) {
#line 1311
    if (! full_bracketing) {
#line 1313
      ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 1313
      ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 1313
      kodp += sizeof(struct OPERAND_0_mi );
#line 1313
      last_instr = current_instr;
#line 1313
      current_instr = kodp;
    }
  }
#line 1315
  full_bracketing ++;
#line 1317
  goto switch_break;
  case_116: /* CIL Label */ 
#line 1324
  if (dim[poc] >= 0) {
#line 1324
    if (full_bracketing == poc) {
#line 1326
      bracket_initializers = initialize_only % dim[poc - 1];
#line 1328
      if (bracket_initializers) {
#line 1329
        initialize_only += dim[poc - 1] - bracket_initializers;
      }
#line 1331
      aggregate_memory_size[full_bracketing] = 0;
    }
  }
#line 1333
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 1335
    i___0 = initialize_only;
#line 1335
    tmp___44 = get_field_size(& i___0, type_com[set]);
#line 1335
    j = tmp___44;
#line 1335
    k = aggregate_memory_size[full_bracketing];
#line 1338
    i___0 = j * initialize_only;
    }
    {
#line 1339
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1339
      if (0 != k) {
#line 1339
        if (! (i___0 >= k)) {
#line 1339
          goto while_break___2;
        }
      } else {
#line 1339
        goto while_break___2;
      }
#line 1340
      k += aggregate_memory_size[full_bracketing];
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1342
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1342
      if (! (i___0 < k)) {
#line 1342
        goto while_break___3;
      }
      {
#line 1344
      ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 1344
      ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 1344
      kodp += sizeof(struct OPERAND_0_mi );
#line 1344
      last_instr = current_instr;
#line 1344
      current_instr = kodp;
#line 1345
      ((struct OPERAND_1_i *)kodp)->major = 32;
#line 1345
      ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 1345
      ((struct OPERAND_1_i *)kodp)->num = i___0;
#line 1345
      kodp += sizeof(struct OPERAND_1_i );
#line 1345
      last_instr = current_instr;
#line 1345
      current_instr = kodp;
#line 1346
      ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 1346
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1346
      kodp += sizeof(struct OPERAND_0_mi );
#line 1346
      last_instr = current_instr;
#line 1346
      current_instr = kodp;
#line 1347
      ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 1347
      ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 1347
      ((struct OPERAND_1_ic *)kodp)->num = (char)0;
#line 1347
      kodp += sizeof(struct OPERAND_1_ic );
#line 1347
      align_memory(& kodp, (int )sizeof(int ));
#line 1347
      last_instr = current_instr;
#line 1347
      current_instr = kodp;
#line 1348
      ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 1348
      ((struct OPERAND_0_mi *)kodp)->minor = 768;
#line 1348
      kodp += sizeof(struct OPERAND_0_mi );
#line 1348
      last_instr = current_instr;
#line 1348
      current_instr = kodp;
#line 1349
      ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 1349
      ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 1349
      kodp += sizeof(struct OPERAND_0_mi );
#line 1349
      last_instr = current_instr;
#line 1349
      current_instr = kodp;
#line 1342
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1351
    if (j * initialize_only < k) {
#line 1352
      initialize_only = k / j;
    }
  }
#line 1354
  if (full_bracketing > 1) {
#line 1354
    if (! (type_com[set])->attribute.memory_size) {
#line 1356
      (type_com[set])->attribute.memory_size += 2 * aggregate_memory_size[full_bracketing];
    }
  }
#line 1358
  aggregate_memory_size[full_bracketing] = 0;
#line 1359
  full_bracketing --;
#line 1361
  goto switch_break;
  case_117: /* CIL Label */ 
#line 1363
  full_bracketing --;
#line 1365
  goto switch_break;
  case_118: /* CIL Label */ 
#line 1370
  if (set > 1) {
    {
#line 1372
    initialize_only ++;
#line 1373
    tmp___45 = l_value_cast();
    }
#line 1373
    if (-1 == tmp___45) {
#line 1374
      no_compile_only = 0;
    }
#line 1375
    variable[set].adr = (char *)((void *)0);
#line 1375
    variable[set].offset = 0;
#line 1376
    subscript_flag[set] = 0;
#line 1376
    struct_union_field[set] = 0;
#line 1376
    type_ac[set] = (enum intern_arit_class )0;
#line 1376
    tmp___46 = set;
#line 1376
    set --;
#line 1376
    type_com[tmp___46] = (struct internal_type *)((void *)0);
#line 1376
    if (0 > set) {
      {
#line 1376
      error_message(5003);
      }
    }
    {
#line 1377
    move2lvalue();
#line 1378
    ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 1378
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 1378
    kodp += sizeof(struct OPERAND_0_mi );
#line 1378
    last_instr = current_instr;
#line 1378
    current_instr = kodp;
    }
  }
#line 1380
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 1383
    aggregate_memory_size[full_bracketing] = get_memory_size(full_bracketing, type_com[set],
                                                             initialize_only);
    }
  } else
#line 1380
  if (1029U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 1383
    aggregate_memory_size[full_bracketing] = get_memory_size(full_bracketing, type_com[set],
                                                             initialize_only);
    }
  }
#line 1389
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 1391
  i___1 = initialize_only;
#line 1391
  tmp___47 = get_field_size(& i___1, type_com[set]);
#line 1391
  j___0 = tmp___47;
#line 1393
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 1393
  ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 1393
  kodp += sizeof(struct OPERAND_0_mi );
#line 1393
  last_instr = current_instr;
#line 1393
  current_instr = kodp;
#line 1394
  ((struct OPERAND_1_i *)kodp)->major = 32;
#line 1394
  ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 1394
  ((struct OPERAND_1_i *)kodp)->num = initialize_only * j___0;
#line 1394
  kodp += sizeof(struct OPERAND_1_i );
#line 1395
  last_instr = current_instr;
#line 1395
  current_instr = kodp;
#line 1396
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 1396
  ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 1396
  kodp += sizeof(struct OPERAND_0_mi );
#line 1396
  last_instr = current_instr;
#line 1396
  current_instr = kodp;
  }
#line 1398
  goto switch_break;
  case_120: /* CIL Label */ 
#line 1400
  if (set > 1) {
    {
#line 1402
    initialize_only ++;
#line 1403
    tmp___48 = l_value_cast();
    }
#line 1403
    if (-1 == tmp___48) {
#line 1404
      no_compile_only = 0;
    }
#line 1405
    variable[set].adr = (char *)((void *)0);
#line 1405
    variable[set].offset = 0;
#line 1406
    subscript_flag[set] = 0;
#line 1406
    struct_union_field[set] = 0;
#line 1406
    type_ac[set] = (enum intern_arit_class )0;
#line 1406
    tmp___49 = set;
#line 1406
    set --;
#line 1406
    type_com[tmp___49] = (struct internal_type *)((void *)0);
#line 1406
    if (0 > set) {
      {
#line 1406
      error_message(5003);
      }
    }
    {
#line 1407
    move2lvalue();
#line 1408
    ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 1408
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 1408
    kodp += sizeof(struct OPERAND_0_mi );
#line 1408
    last_instr = current_instr;
#line 1408
    current_instr = kodp;
    }
  }
#line 1411
  goto switch_break;
  case_135: /* CIL Label */ 
#line 1439
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1440
    error_message(6025, "typedef");
    }
  } else
#line 1441
  if (! (8198U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier)) {
    {
#line 1442
    error_message(2017);
    }
  }
#line 1443
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8192;
#line 1445
  type_spec_count ++;
#line 1445
  if (scope_level > 0) {
#line 1445
    tmp___50 = 1;
  } else {
#line 1445
    tmp___50 = 0;
  }
  {
#line 1445
  tmp___51 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___50);
#line 1445
  typeh[type_spec_count] = (struct internal_type *)tmp___51;
#line 1448
  init_zero((char *)typeh[type_spec_count], (unsigned int )sizeof(struct internal_type ));
#line 1450
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1024;
#line 1452
  (typeh[type_spec_count])->attribute.type_qualifier = (enum type_qual )4098;
#line 1454
  (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )0;
#line 1456
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 1458
  (typeh[type_spec_count - 1])->output = typeh[type_spec_count];
#line 1460
  tmp___52 = type_spec_count;
#line 1460
  type_spec_count --;
#line 1460
  typeh[tmp___52] = (struct internal_type *)((void *)0);
  }
#line 1462
  goto switch_break;
  case_136___2: /* CIL Label */ 
#line 1466
  if (8193U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1467
    error_message(6025, "extern");
    }
  } else
#line 1468
  if (! (8198U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier)) {
#line 1468
    if (! (8194U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier)) {
      {
#line 1470
      error_message(2017);
      }
    }
  }
#line 1471
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8193;
#line 1473
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2049;
#line 1476
  goto switch_break;
  case_137: /* CIL Label */ 
#line 1481
  (typeh[type_spec_count])->attribute.export_type = 2050;
#line 1482
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8194;
#line 1484
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2049;
#line 1487
  goto switch_break;
  case_138: /* CIL Label */ 
#line 1490
  if (8195U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1491
    error_message(6025, "static");
    }
  } else
#line 1492
  if (! (8198U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier)) {
    {
#line 1493
    error_message(2017);
    }
  }
#line 1494
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8195;
#line 1497
  goto switch_break;
  case_139: /* CIL Label */ 
#line 1499
  if (8196U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1500
    error_message(6025, "auto");
    }
  } else
#line 1501
  if (! (8198U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier)) {
    {
#line 1502
    error_message(2017);
    }
  }
#line 1503
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8196;
#line 1506
  goto switch_break;
  case_140___2: /* CIL Label */ 
#line 1508
  if (8197U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1509
    error_message(6025, "register");
    }
  } else
#line 1510
  if (! (8198U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier)) {
    {
#line 1511
    error_message(2017);
    }
  }
#line 1512
  (typeh[type_spec_count])->attribute.storage_class_specifier = (enum storage_class_specifier )8197;
#line 1515
  goto switch_break;
  case_141: /* CIL Label */ 
#line 1522
  if (! (8198U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier)) {
    {
#line 1523
    error_message(2018, "type name");
    }
  }
  {
#line 1524
  check_spec_constr(typeh[type_spec_count], (char *)"type name");
  }
#line 1525
  if (! body_flag) {
    {
#line 1526
    error_message(6009);
    }
  }
  {
#line 1527
  tmp___53 = add_to_spec_list();
  }
#line 1527
  if (-1 == tmp___53) {
#line 1528
    no_compile_only = 0;
  }
#line 1529
  tmp___54 = type_spec_count;
#line 1529
  type_spec_count --;
#line 1529
  typeh[tmp___54] = (struct internal_type *)((void *)0);
#line 1531
  goto switch_break;
  case_142: /* CIL Label */ 
#line 1534
  if (! (8198U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier)) {
    {
#line 1535
    error_message(2018, "type name");
    }
  }
  {
#line 1536
  check_spec_constr(typeh[type_spec_count], (char *)"type name");
  }
#line 1537
  if (! body_flag) {
    {
#line 1538
    error_message(6009);
    }
  }
  {
#line 1539
  tmp___55 = add_to_spec_list();
  }
#line 1539
  if (-1 == tmp___55) {
#line 1540
    no_compile_only = 0;
  }
#line 1541
  tmp___56 = type_spec_count;
#line 1541
  type_spec_count --;
#line 1541
  typeh[tmp___56] = (struct internal_type *)((void *)0);
#line 1543
  goto switch_break;
  case_146: /* CIL Label */ 
#line 1554
  if (! (8198U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier)) {
    {
#line 1555
    error_message(2018, "type name");
    }
  }
  {
#line 1556
  check_spec_constr(typeh[type_spec_count], (char *)"type name");
  }
#line 1557
  if (! body_flag) {
    {
#line 1558
    error_message(6009);
    }
  }
  {
#line 1559
  tmp___57 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 1559
  help___2 = (struct internal_type *)tmp___57;
#line 1561
  init_zero((char *)help___2, (unsigned int )sizeof(struct internal_type ));
#line 1562
  help___2->output = typeh[type_spec_count];
#line 1563
  typeh[type_spec_count] = help___2;
#line 1564
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1025;
#line 1566
  tmp___58 = add_to_spec_list();
  }
#line 1566
  if (-1 == tmp___58) {
#line 1567
    no_compile_only = 0;
  }
#line 1568
  count_arr = 1;
#line 1569
  tmp___59 = type_spec_count;
#line 1569
  type_spec_count --;
#line 1569
  typeh[tmp___59] = (struct internal_type *)((void *)0);
  {
#line 1570
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1570
    if (! (-1 != dim[poc])) {
#line 1570
      goto while_break___4;
    }
#line 1570
    tmp___60 = poc;
#line 1570
    poc --;
#line 1570
    dim[tmp___60] = -1;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1572
  goto switch_break;
  case_147: /* CIL Label */ 
  {
#line 1575
  check_spec_constr(typeh[type_spec_count], (char *)"type name");
  }
#line 1576
  if (! body_flag) {
    {
#line 1577
    error_message(6009);
    }
  }
  {
#line 1578
  tmp___61 = add_to_spec_list();
  }
#line 1578
  if (-1 == tmp___61) {
#line 1579
    no_compile_only = 0;
  }
#line 1580
  tmp___62 = type_spec_count;
#line 1580
  type_spec_count --;
#line 1580
  typeh[tmp___62] = (struct internal_type *)((void *)0);
#line 1582
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 1585
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2048;
#line 1587
  check_spec_constr(typeh[type_spec_count], (char *)"type name");
  }
#line 1588
  if (! body_flag) {
    {
#line 1589
    error_message(6009);
    }
  }
  {
#line 1590
  tmp___63 = add_to_spec_list();
  }
#line 1590
  if (-1 == tmp___63) {
#line 1591
    no_compile_only = 0;
  }
#line 1592
  tmp___64 = type_spec_count;
#line 1592
  type_spec_count --;
#line 1592
  typeh[tmp___64] = (struct internal_type *)((void *)0);
#line 1594
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 1597
  check_spec_constr(typeh[type_spec_count], (char *)"type name");
  }
#line 1598
  if (! body_flag) {
    {
#line 1599
    error_message(6009);
    }
  }
  {
#line 1600
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2048;
#line 1602
  (typeh[type_spec_count])->input = l_type_spec;
#line 1603
  l_type_spec = (struct internal_type *)((void *)0);
#line 1604
  tmp___65 = add_to_spec_list();
  }
#line 1604
  if (-1 == tmp___65) {
#line 1605
    no_compile_only = 0;
  }
#line 1606
  tmp___66 = type_spec_count;
#line 1606
  type_spec_count --;
#line 1606
  typeh[tmp___66] = (struct internal_type *)((void *)0);
#line 1608
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 1612
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2048;
#line 1614
  check_spec_constr(typeh[type_spec_count], (char *)"type name");
  }
#line 1615
  if (! body_flag) {
    {
#line 1616
    error_message(6009);
    }
  }
  {
#line 1617
  tmp___67 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 1617
  help___3 = (struct internal_type *)tmp___67;
#line 1619
  init_zero((char *)help___3, (unsigned int )sizeof(struct internal_type ));
#line 1620
  help___3->output = typeh[type_spec_count];
#line 1621
  typeh[type_spec_count] = help___3;
#line 1622
  (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )1025;
#line 1624
  tmp___68 = add_to_spec_list();
  }
#line 1624
  if (-1 == tmp___68) {
#line 1625
    no_compile_only = 0;
  }
#line 1626
  count_arr = 1;
#line 1627
  tmp___69 = type_spec_count;
#line 1627
  type_spec_count --;
#line 1627
  typeh[tmp___69] = (struct internal_type *)((void *)0);
  {
#line 1628
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1628
    if (! (-1 != dim[poc])) {
#line 1628
      goto while_break___5;
    }
#line 1628
    tmp___70 = poc;
#line 1628
    poc --;
#line 1628
    dim[tmp___70] = -1;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1630
  goto switch_break;
  case_151: /* CIL Label */ 
#line 1640
  if (1U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 1641
    error_message(1012);
    }
  }
  {
#line 1642
  check_spec_constr(typeh[type_spec_count], (yyvsp + 0)->mystring);
#line 1643
  put2table((yyvsp + 0)->mystring, typeh[type_spec_count]);
#line 1644
  align_memory(& kodp, (int )sizeof(int ));
#line 1645
  kodp1 = kodp;
#line 1645
  pc = kodp;
#line 1646
  body_flag = 0;
#line 1647
  lookup_tables((yyvsp + 0)->mystring, variable);
#line 1648
  typedef_f = 1;
  }
#line 1650
  goto switch_break;
  case_153: /* CIL Label */ 
#line 1655
  if (1U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 1656
    error_message(1012);
    }
  }
  {
#line 1657
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
#line 1658
  tmp___71 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 1658
  help___4 = (struct internal_type *)tmp___71;
#line 1660
  init_zero((char *)help___4, (unsigned int )sizeof(struct internal_type ));
  }
#line 1661
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1663
    help___4->output = (typeh[type_spec_count])->output;
#line 1664
    arch___0 = (typeh[type_spec_count])->output;
#line 1665
    (typeh[type_spec_count])->output = help___4;
  } else {
#line 1669
    help___4->output = typeh[type_spec_count];
#line 1670
    arch___0 = typeh[type_spec_count];
#line 1671
    typeh[type_spec_count] = help___4;
  }
  {
#line 1673
  help___4->attribute.function_class = (enum intern_func_class )1025;
#line 1674
  help___4->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 1675
  put2table((yyvsp + -1)->mystring, typeh[type_spec_count]);
#line 1676
  count_arr = 1;
#line 1677
  kodp1 = kodp;
#line 1677
  pc = kodp;
#line 1678
  body_flag = 0;
#line 1679
  lookup_tables((yyvsp + -1)->mystring, variable);
#line 1680
  initialize_only = 0;
#line 1681
  typedef_f = 1;
  }
#line 1682
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1683
    typedef_copy(arch___0);
    }
  } else {
#line 1685
    typeh[type_spec_count] = arch___0;
  }
#line 1687
  goto switch_break;
  case_155: /* CIL Label */ 
  {
#line 1692
  check_spec_constr(typeh[type_spec_count], (yyvsp + 0)->mystring);
#line 1693
  put2table((yyvsp + 0)->mystring, typeh[type_spec_count]);
  }
#line 1694
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1695
    type___1 = (typeh[type_spec_count])->output;
  } else {
#line 1697
    type___1 = typeh[type_spec_count];
  }
  {
#line 1700
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1700
    if (! (1028U == (unsigned int )type___1->attribute.function_class)) {
#line 1700
      goto while_break___6;
    }
#line 1702
    type___1 = type___1->output;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1704
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1705
    typedef_copy(type___1);
    }
  } else {
#line 1707
    typeh[type_spec_count] = type___1;
  }
  {
#line 1708
  align_memory(& kodp, (int )sizeof(int ));
#line 1709
  kodp1 = kodp;
#line 1709
  pc = kodp;
#line 1710
  body_flag = 0;
#line 1711
  lookup_tables((yyvsp + 0)->mystring, variable);
#line 1712
  typedef_f = 1;
  }
#line 1714
  goto switch_break;
  case_157: /* CIL Label */ 
  {
#line 1719
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
#line 1720
  tmp___72 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 1720
  help___5 = (struct internal_type *)tmp___72;
#line 1722
  init_zero((char *)help___5, (unsigned int )sizeof(struct internal_type ));
  }
#line 1724
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1726
    help___5->output = (typeh[type_spec_count])->output;
#line 1727
    arch___1 = (typeh[type_spec_count])->output;
#line 1728
    (typeh[type_spec_count])->output = help___5;
  } else {
#line 1732
    help___5->output = typeh[type_spec_count];
#line 1733
    arch___1 = typeh[type_spec_count];
#line 1734
    typeh[type_spec_count] = help___5;
  }
  {
#line 1736
  help___5->attribute.function_class = (enum intern_func_class )1025;
#line 1737
  help___5->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 1739
  put2table((yyvsp + -1)->mystring, typeh[type_spec_count]);
#line 1740
  count_arr = 1;
#line 1741
  kodp1 = kodp;
#line 1741
  pc = kodp;
#line 1742
  body_flag = 0;
#line 1743
  lookup_tables((yyvsp + -1)->mystring, variable);
  }
#line 1744
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1745
    typedef_copy(arch___1);
    }
  } else {
#line 1747
    typeh[type_spec_count] = arch___1;
  }
  {
#line 1750
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1750
    if (! (1028U == (unsigned int )arch___1->attribute.function_class)) {
#line 1750
      goto while_break___7;
    }
#line 1751
    arch___1 = arch___1->output;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1752
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1752
    if (! (-1 != dim[poc])) {
#line 1752
      goto while_break___8;
    }
#line 1752
    tmp___73 = poc;
#line 1752
    poc --;
#line 1752
    dim[tmp___73] = -1;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1753
  typedef_f = 1;
#line 1755
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 1764
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
  }
#line 1765
  if (1029U == (unsigned int )(typeh[type_spec_count])->attribute.function_class) {
    {
#line 1767
    error_message(6034);
    }
  } else
#line 1765
  if (1030U == (unsigned int )(typeh[type_spec_count])->attribute.function_class) {
    {
#line 1767
    error_message(6034);
    }
  }
  {
#line 1768
  tmp___74 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 1768
  help___6 = (struct internal_type *)tmp___74;
#line 1770
  init_zero((char *)help___6, (unsigned int )sizeof(struct internal_type ));
  }
#line 1772
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1774
    help___6->output = (typeh[type_spec_count])->output;
#line 1775
    arch___2 = (typeh[type_spec_count])->output;
#line 1776
    (typeh[type_spec_count])->output = help___6;
#line 1777
    if (2049U == (unsigned int )(((typeh[type_spec_count])->output)->output)->attribute.function_class) {
#line 1778
      ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )2049;
    } else {
#line 1781
      ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )2048;
    }
#line 1783
    ((typeh[type_spec_count])->output)->attribute.export_type = (((typeh[type_spec_count])->output)->output)->attribute.export_type;
#line 1785
    set ++;
#line 1785
    type_ac[set] = (((typeh[type_spec_count])->output)->output)->attribute.arit_class;
#line 1787
    type_com[set] = (typeh[type_spec_count])->output;
  } else {
#line 1791
    help___6->output = typeh[type_spec_count];
#line 1792
    arch___2 = typeh[type_spec_count];
#line 1793
    typeh[type_spec_count] = help___6;
#line 1794
    if (2049U == (unsigned int )((typeh[type_spec_count])->output)->attribute.function_class) {
#line 1795
      (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2049;
    } else {
#line 1798
      (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2048;
    }
#line 1800
    (typeh[type_spec_count])->attribute.export_type = ((typeh[type_spec_count])->output)->attribute.export_type;
#line 1802
    set ++;
#line 1802
    type_ac[set] = ((typeh[type_spec_count])->output)->attribute.arit_class;
#line 1804
    type_com[set] = typeh[type_spec_count];
  }
  {
#line 1806
  body_flag = 0;
#line 1807
  put2table((yyvsp + -1)->mystring, typeh[type_spec_count]);
#line 1808
  variable[set].adr = kodp;
#line 1809
  variable[set].name = (yyvsp + -1)->mystring;
#line 1810
  proc ++;
#line 1810
  count[proc] = (int )(- (3UL * sizeof(char *)));
#line 1811
  proc_name_text[proc] = text;
  }
#line 1812
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1813
    typedef_copy(arch___2);
    }
  } else {
#line 1815
    typeh[type_spec_count] = arch___2;
  }
  {
#line 1816
  param_flag = 1;
#line 1817
  enter_scope();
#line 1818
  func_def_s();
#line 1819
  typedef_f = 1;
  }
#line 1821
  goto switch_break;
  case_161: /* CIL Label */ 
  {
#line 1830
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
#line 1831
  tmp___75 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 1831
  help___7 = (struct internal_type *)tmp___75;
#line 1833
  init_zero((char *)help___7, (unsigned int )sizeof(struct internal_type ));
  }
#line 1835
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 1837
    help___7->output = (typeh[type_spec_count])->output;
#line 1838
    arch___3 = (typeh[type_spec_count])->output;
#line 1839
    (typeh[type_spec_count])->output = help___7;
#line 1840
    if (2049U == (unsigned int )(((typeh[type_spec_count])->output)->output)->attribute.function_class) {
#line 1841
      ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )2049;
    } else {
#line 1844
      ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )2048;
    }
#line 1846
    ((typeh[type_spec_count])->output)->attribute.export_type = (((typeh[type_spec_count])->output)->output)->attribute.export_type;
#line 1848
    set ++;
#line 1848
    type_ac[set] = (((typeh[type_spec_count])->output)->output)->attribute.arit_class;
#line 1850
    type_com[set] = (typeh[type_spec_count])->output;
  } else {
#line 1854
    help___7->output = typeh[type_spec_count];
#line 1855
    arch___3 = typeh[type_spec_count];
#line 1856
    typeh[type_spec_count] = help___7;
#line 1857
    if (2049U == (unsigned int )((typeh[type_spec_count])->output)->attribute.function_class) {
#line 1858
      (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2049;
    } else {
#line 1861
      (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2048;
    }
#line 1863
    (typeh[type_spec_count])->attribute.export_type = ((typeh[type_spec_count])->output)->attribute.export_type;
#line 1865
    set ++;
#line 1865
    type_ac[set] = ((typeh[type_spec_count])->output)->attribute.arit_class;
#line 1867
    type_com[set] = typeh[type_spec_count];
  }
  {
#line 1869
  body_flag = 0;
#line 1870
  put2table((yyvsp + -1)->mystring, typeh[type_spec_count]);
#line 1871
  variable[set].adr = kodp;
#line 1872
  variable[set].name = (yyvsp + -1)->mystring;
#line 1873
  proc ++;
#line 1873
  count[proc] = (int )(- (3UL * sizeof(char *)));
#line 1874
  proc_name_text[proc] = text;
  }
#line 1875
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1876
    typedef_copy(arch___3);
    }
  } else {
#line 1878
    typeh[type_spec_count] = arch___3;
  }
  {
#line 1882
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1882
    if (! (1028U == (unsigned int )arch___3->attribute.function_class)) {
#line 1882
      goto while_break___9;
    }
#line 1883
    arch___3 = arch___3->output;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 1884
  param_flag = 1;
#line 1885
  enter_scope();
#line 1886
  func_def_s();
#line 1887
  typedef_f = 1;
  }
#line 1889
  goto switch_break;
  case_163: /* CIL Label */ 
#line 1893
  if (! (1031U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
#line 1893
    if (! (1030U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
#line 1893
      if (! (1029U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
        {
#line 1897
        error_message(6010);
#line 1898
        error_message(6011);
#line 1899
        variable[set].adr = (char *)((void *)0);
#line 1899
        variable[set].offset = 0;
#line 1900
        subscript_flag[set] = 0;
#line 1900
        struct_union_field[set] = 0;
#line 1900
        type_ac[set] = (enum intern_arit_class )0;
#line 1900
        tmp___76 = set;
#line 1900
        set --;
#line 1900
        type_com[tmp___76] = (struct internal_type *)((void *)0);
        }
#line 1900
        if (0 > set) {
          {
#line 1900
          error_message(5003);
          }
        }
      }
    }
  }
#line 1902
  tmp___77 = type_spec_count;
#line 1902
  type_spec_count --;
#line 1902
  typeh[tmp___77] = (struct internal_type *)((void *)0);
#line 1903
  typedef_f = 1;
#line 1905
  goto switch_break;
  case_164: /* CIL Label */ 
  {
#line 1909
  count[proc] = 0;
#line 1917
  tmp___78 = proc;
#line 1917
  proc --;
#line 1917
  proc_name_text[tmp___78] = (char *)((void *)0);
#line 1919
  param_flag = 0;
#line 1920
  func_def_r();
#line 1921
  exit_scope();
#line 1922
  typedef_f = 1;
  }
#line 1924
  goto switch_break;
  case_166: /* CIL Label */ 
  {
#line 1928
  count[proc] = 0;
#line 1929
  tmp___79 = add_spec_to_has();
  }
#line 1929
  if (-1 == tmp___79) {
#line 1930
    no_compile_only = 0;
  }
  {
#line 1938
  tmp___80 = proc;
#line 1938
  proc --;
#line 1938
  proc_name_text[tmp___80] = (char *)((void *)0);
#line 1940
  param_flag = 0;
#line 1941
  func_def_r();
#line 1942
  exit_scope();
#line 1943
  typedef_f = 1;
  }
#line 1945
  goto switch_break;
  case_168: /* CIL Label */ 
  {
#line 1949
  count[proc] = 0;
#line 1950
  tmp___81 = add_spec_to_has();
  }
#line 1950
  if (-1 == tmp___81) {
#line 1951
    no_compile_only = 0;
  }
  {
#line 1952
  tmp___82 = add_ident_to_has();
  }
#line 1952
  if (-1 == tmp___82) {
#line 1953
    no_compile_only = 0;
  }
  {
#line 1954
  clear_hash_tab_declaration();
#line 1962
  tmp___83 = proc;
#line 1962
  proc --;
#line 1962
  proc_name_text[tmp___83] = (char *)((void *)0);
#line 1964
  param_flag = 0;
#line 1965
  func_def_r();
#line 1966
  exit_scope();
#line 1967
  typedef_f = 1;
  }
#line 1969
  goto switch_break;
  case_170: /* CIL Label */ 
#line 1973
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1974
    error_message(1036, "typedef");
    }
  } else
#line 1975
  if (8197U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1976
    error_message(1036, "register");
    }
  } else
#line 1977
  if (8196U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 1978
    error_message(1036, "auto");
    }
  }
  {
#line 1979
  tmp___84 = add_spec_to_has();
  }
#line 1979
  if (-1 == tmp___84) {
#line 1980
    no_compile_only = 0;
  }
  {
#line 1981
  tmp___85 = add_ident_to_has();
  }
#line 1981
  if (-1 == tmp___85) {
#line 1982
    no_compile_only = 0;
  }
#line 1983
  ((struct OPERAND_0_mi *)kodp)->major = 38;
#line 1983
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 1983
  kodp += sizeof(struct OPERAND_0_mi );
#line 1983
  last_instr = current_instr;
#line 1983
  current_instr = kodp;
#line 1983
  ((struct OPERAND_0_mi *)kodp)->major = 38;
#line 1983
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 1983
  kodp += sizeof(struct OPERAND_0_mi );
#line 1983
  last_instr = current_instr;
#line 1983
  current_instr = kodp;
#line 1983
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 1983
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 1983
  kodp += sizeof(struct OPERAND_0_mi );
#line 1983
  last_instr = current_instr;
#line 1983
  current_instr = kodp;
#line 1983
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 1983
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 1983
  kodp += sizeof(struct OPERAND_0_mi );
#line 1983
  last_instr = current_instr;
#line 1983
  current_instr = kodp;
#line 1984
  count[proc] = - count[proc];
#line 1985
  count[proc] = (int )((unsigned long )count[proc] % sizeof(double ));
#line 1986
  count[proc] = - count[proc];
#line 1987
  tmp___86 = type_spec_count;
#line 1987
  type_spec_count --;
#line 1987
  typeh[tmp___86] = (struct internal_type *)((void *)0);
#line 1988
  param_flag = 0;
#line 1989
  typedef_f = 1;
#line 1991
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 1993
  text = proc_name_text[proc];
#line 1994
  fix_ret();
#line 1995
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 1995
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 1995
  kodp += sizeof(struct OPERAND_0_mi );
#line 1995
  last_instr = current_instr;
#line 1995
  current_instr = kodp;
#line 1995
  ((struct OPERAND_0_mi *)kodp)->major = 39;
#line 1995
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 1995
  kodp += sizeof(struct OPERAND_0_mi );
#line 1995
  last_instr = current_instr;
#line 1995
  current_instr = kodp;
#line 1995
  ((struct OPERAND_0_mi *)kodp)->major = 39;
#line 1995
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 1995
  kodp += sizeof(struct OPERAND_0_mi );
#line 1995
  last_instr = current_instr;
#line 1995
  current_instr = kodp;
#line 1995
  ((struct OPERAND_0_ma *)kodp)->major = 28;
#line 1995
  kodp += sizeof(struct OPERAND_0_ma );
#line 1995
  last_instr = current_instr;
#line 1995
  current_instr = kodp;
#line 1996
  variable[set].adr = (char *)((void *)0);
#line 1996
  variable[set].offset = 0;
#line 1997
  subscript_flag[set] = 0;
#line 1997
  struct_union_field[set] = 0;
#line 1997
  type_ac[set] = (enum intern_arit_class )0;
#line 1997
  tmp___87 = set;
#line 1997
  set --;
#line 1997
  type_com[tmp___87] = (struct internal_type *)((void *)0);
  }
#line 1997
  if (0 > set) {
    {
#line 1997
    error_message(5003);
    }
  }
  {
#line 1998
  body_flag = 1;
#line 1999
  put2table(text, (struct internal_type *)((void *)0));
#line 2000
  body_flag = 0;
#line 2001
  kodp1 = kodp;
#line 2001
  pc = kodp;
#line 2002
  exit_scope();
#line 2006
  proc_name_text[proc] = (char *)((void *)0);
#line 2007
  tmp___88 = proc;
#line 2007
  proc --;
#line 2007
  count[tmp___88] = 0;
  }
#line 2010
  goto switch_break;
  case_172: /* CIL Label */ 
#line 2013
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2014
    error_message(1036, "typedef");
    }
  } else
#line 2015
  if (8197U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2016
    error_message(1036, "register");
    }
  } else
#line 2017
  if (8196U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2018
    error_message(1036, "auto");
    }
  }
  {
#line 2019
  type_spec_count ++;
#line 2019
  tmp___89 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 2019
  typeh[type_spec_count] = (struct internal_type *)tmp___89;
#line 2021
  init_zero((char *)typeh[type_spec_count], (unsigned int )sizeof(struct internal_type ));
#line 2023
  (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )1;
#line 2025
  tmp___90 = add_to_spec_list();
  }
#line 2025
  if (-1 == tmp___90) {
#line 2026
    no_compile_only = 0;
  }
  {
#line 2027
  tmp___91 = add_spec_to_has();
  }
#line 2027
  if (-1 == tmp___91) {
#line 2028
    no_compile_only = 0;
  }
#line 2029
  ((struct OPERAND_0_mi *)kodp)->major = 38;
#line 2029
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 2029
  kodp += sizeof(struct OPERAND_0_mi );
#line 2029
  last_instr = current_instr;
#line 2029
  current_instr = kodp;
#line 2029
  ((struct OPERAND_0_mi *)kodp)->major = 38;
#line 2029
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 2029
  kodp += sizeof(struct OPERAND_0_mi );
#line 2029
  last_instr = current_instr;
#line 2029
  current_instr = kodp;
#line 2029
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 2029
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 2029
  kodp += sizeof(struct OPERAND_0_mi );
#line 2029
  last_instr = current_instr;
#line 2029
  current_instr = kodp;
#line 2029
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 2029
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 2029
  kodp += sizeof(struct OPERAND_0_mi );
#line 2029
  last_instr = current_instr;
#line 2029
  current_instr = kodp;
#line 2030
  count[proc] = - count[proc];
#line 2031
  count[proc] = (int )((unsigned long )count[proc] % sizeof(double ));
#line 2032
  count[proc] = - count[proc];
#line 2033
  tmp___92 = type_spec_count;
#line 2033
  type_spec_count --;
#line 2033
  typeh[tmp___92] = (struct internal_type *)((void *)0);
#line 2034
  param_flag = 0;
#line 2035
  typedef_f = 1;
#line 2037
  goto switch_break;
  case_173: /* CIL Label */ 
  {
#line 2039
  text = proc_name_text[proc];
#line 2040
  fix_ret();
#line 2041
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 2041
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 2041
  kodp += sizeof(struct OPERAND_0_mi );
#line 2041
  last_instr = current_instr;
#line 2041
  current_instr = kodp;
#line 2041
  ((struct OPERAND_0_mi *)kodp)->major = 39;
#line 2041
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 2041
  kodp += sizeof(struct OPERAND_0_mi );
#line 2041
  last_instr = current_instr;
#line 2041
  current_instr = kodp;
#line 2041
  ((struct OPERAND_0_mi *)kodp)->major = 39;
#line 2041
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 2041
  kodp += sizeof(struct OPERAND_0_mi );
#line 2041
  last_instr = current_instr;
#line 2041
  current_instr = kodp;
#line 2041
  ((struct OPERAND_0_ma *)kodp)->major = 28;
#line 2041
  kodp += sizeof(struct OPERAND_0_ma );
#line 2041
  last_instr = current_instr;
#line 2041
  current_instr = kodp;
#line 2042
  variable[set].adr = (char *)((void *)0);
#line 2042
  variable[set].offset = 0;
#line 2043
  subscript_flag[set] = 0;
#line 2043
  struct_union_field[set] = 0;
#line 2043
  type_ac[set] = (enum intern_arit_class )0;
#line 2043
  tmp___93 = set;
#line 2043
  set --;
#line 2043
  type_com[tmp___93] = (struct internal_type *)((void *)0);
  }
#line 2043
  if (0 > set) {
    {
#line 2043
    error_message(5003);
    }
  }
  {
#line 2044
  body_flag = 1;
#line 2045
  put2table(text, (struct internal_type *)((void *)0));
#line 2046
  body_flag = 0;
#line 2047
  kodp1 = kodp;
#line 2047
  pc = kodp;
#line 2048
  exit_scope();
#line 2052
  proc_name_text[proc] = (char *)((void *)0);
#line 2053
  tmp___94 = proc;
#line 2053
  proc --;
#line 2053
  count[tmp___94] = 0;
#line 2055
  tmp___95 = type_spec_count;
#line 2055
  type_spec_count --;
#line 2055
  typeh[tmp___95] = (struct internal_type *)((void *)0);
#line 2056
  typedef_f = 1;
  }
#line 2058
  goto switch_break;
  case_174: /* CIL Label */ 
#line 2062
  count[proc] = 0;
#line 2066
  tmp___96 = proc;
#line 2066
  proc --;
#line 2066
  proc_name_text[tmp___96] = (char *)((void *)0);
#line 2068
  param_flag = 0;
#line 2069
  typedef_f = 1;
#line 2071
  goto switch_break;
  case_176: /* CIL Label */ 
  {
#line 2075
  count[proc] = 0;
#line 2076
  tmp___97 = add_spec_to_has();
  }
#line 2076
  if (-1 == tmp___97) {
#line 2077
    no_compile_only = 0;
  }
#line 2081
  tmp___98 = proc;
#line 2081
  proc --;
#line 2081
  proc_name_text[tmp___98] = (char *)((void *)0);
#line 2083
  typedef_f = 1;
#line 2085
  goto switch_break;
  case_178: /* CIL Label */ 
  {
#line 2089
  count[proc] = 0;
#line 2090
  tmp___99 = add_spec_to_has();
  }
#line 2090
  if (-1 == tmp___99) {
#line 2091
    no_compile_only = 0;
  }
  {
#line 2092
  tmp___100 = add_ident_to_has();
  }
#line 2092
  if (-1 == tmp___100) {
#line 2093
    no_compile_only = 0;
  }
  {
#line 2094
  clear_hash_tab_declaration();
#line 2098
  tmp___101 = proc;
#line 2098
  proc --;
#line 2098
  proc_name_text[tmp___101] = (char *)((void *)0);
#line 2100
  param_flag = 0;
#line 2101
  typedef_f = 1;
  }
#line 2103
  goto switch_break;
  case_180: /* CIL Label */ 
  {
#line 2107
  yyerrstatus = 0;
#line 2107
  proc --;
#line 2108
  error_message(1004, "{");
#line 2108
  proc ++;
  }
#line 2110
  goto switch_break;
  case_181: /* CIL Label */ 
#line 2117
  if (1U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 2118
    error_message(1012);
    }
  }
  {
#line 2119
  check_spec_constr(typeh[type_spec_count], (yyvsp + 0)->mystring);
#line 2120
  body_flag = 1;
#line 2121
  put2table((yyvsp + 0)->mystring, typeh[type_spec_count]);
#line 2122
  align_memory(& kodp, (int )sizeof(int ));
#line 2123
  kodp1 = kodp;
#line 2123
  pc = kodp;
#line 2124
  body_flag = 0;
#line 2125
  lookup_tables((yyvsp + 0)->mystring, variable);
#line 2126
  typedef_f = 1;
  }
#line 2128
  goto switch_break;
  case_183: /* CIL Label */ 
#line 2133
  if (1U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 2134
    error_message(1012);
    }
  }
  {
#line 2135
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
#line 2136
  tmp___102 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 2136
  help___8 = (struct internal_type *)tmp___102;
#line 2138
  init_zero((char *)help___8, (unsigned int )sizeof(struct internal_type ));
  }
#line 2139
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 2141
    help___8->output = (typeh[type_spec_count])->output;
#line 2142
    arch___4 = (typeh[type_spec_count])->output;
#line 2143
    (typeh[type_spec_count])->output = help___8;
  } else {
#line 2147
    help___8->output = typeh[type_spec_count];
#line 2148
    arch___4 = typeh[type_spec_count];
#line 2149
    typeh[type_spec_count] = help___8;
  }
  {
#line 2151
  help___8->attribute.function_class = (enum intern_func_class )1025;
#line 2152
  help___8->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 2153
  body_flag = 1;
#line 2154
  put2table((yyvsp + -1)->mystring, typeh[type_spec_count]);
#line 2155
  count_arr = 1;
#line 2156
  kodp1 = kodp;
#line 2156
  pc = kodp;
#line 2157
  body_flag = 0;
#line 2158
  lookup_tables((yyvsp + -1)->mystring, variable);
  }
#line 2159
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2160
    typedef_copy(arch___4);
    }
  } else {
#line 2162
    typeh[type_spec_count] = arch___4;
  }
  {
#line 2163
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2163
    if (! (-1 != dim[poc])) {
#line 2163
      goto while_break___10;
    }
#line 2163
    tmp___103 = poc;
#line 2163
    poc --;
#line 2163
    dim[tmp___103] = -1;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2164
  typedef_f = 1;
#line 2166
  goto switch_break;
  case_185: /* CIL Label */ 
  {
#line 2175
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
  }
#line 2176
  if (1029U == (unsigned int )(typeh[type_spec_count])->attribute.function_class) {
    {
#line 2178
    error_message(6034);
    }
  } else
#line 2176
  if (1030U == (unsigned int )(typeh[type_spec_count])->attribute.function_class) {
    {
#line 2178
    error_message(6034);
    }
  }
  {
#line 2179
  tmp___104 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 2179
  help___9 = (struct internal_type *)tmp___104;
#line 2181
  init_zero((char *)help___9, (unsigned int )sizeof(struct internal_type ));
  }
#line 2183
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2185
    typedef_copy((typeh[type_spec_count])->output);
#line 2186
    help___9->output = (typeh[type_spec_count])->output;
#line 2187
    arch___5 = (typeh[type_spec_count])->output;
#line 2188
    (typeh[type_spec_count])->output = help___9;
    }
#line 2189
    if (2049U == (unsigned int )(((typeh[type_spec_count])->output)->output)->attribute.function_class) {
#line 2190
      ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )2049;
    } else {
#line 2193
      ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )2048;
    }
#line 2195
    ((typeh[type_spec_count])->output)->attribute.export_type = (((typeh[type_spec_count])->output)->output)->attribute.export_type;
#line 2197
    set ++;
#line 2197
    type_ac[set] = (((typeh[type_spec_count])->output)->output)->attribute.arit_class;
#line 2199
    type_com[set] = (typeh[type_spec_count])->output;
  } else {
#line 2203
    help___9->output = typeh[type_spec_count];
#line 2204
    arch___5 = typeh[type_spec_count];
#line 2205
    typeh[type_spec_count] = help___9;
#line 2206
    if (2049U == (unsigned int )((typeh[type_spec_count])->output)->attribute.function_class) {
#line 2207
      (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2049;
    } else {
#line 2210
      (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2048;
    }
#line 2212
    (typeh[type_spec_count])->attribute.export_type = ((typeh[type_spec_count])->output)->attribute.export_type;
#line 2214
    set ++;
#line 2214
    type_ac[set] = ((typeh[type_spec_count])->output)->attribute.arit_class;
#line 2216
    type_com[set] = typeh[type_spec_count];
  }
  {
#line 2218
  body_flag = 0;
#line 2219
  put2table((yyvsp + -1)->mystring, typeh[type_spec_count]);
#line 2220
  variable[set].adr = kodp;
#line 2221
  variable[set].name = (yyvsp + -1)->mystring;
#line 2222
  proc ++;
#line 2222
  count[proc] = (int )(- (3UL * sizeof(char *)));
#line 2223
  proc_name_text[proc] = text;
  }
#line 2224
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2225
    typedef_copy(arch___5);
    }
  } else {
#line 2227
    typeh[type_spec_count] = arch___5;
  }
#line 2228
  typedef_f = 1;
#line 2230
  goto switch_break;
  case_187: /* CIL Label */ 
  {
#line 2235
  check_spec_constr(typeh[type_spec_count], (yyvsp + 0)->mystring);
#line 2236
  body_flag = 1;
#line 2237
  put2table((yyvsp + 0)->mystring, typeh[type_spec_count]);
  }
#line 2238
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 2239
    type___2 = (typeh[type_spec_count])->output;
  } else {
#line 2241
    type___2 = typeh[type_spec_count];
  }
  {
#line 2244
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2244
    if (! (1028U == (unsigned int )type___2->attribute.function_class)) {
#line 2244
      goto while_break___11;
    }
#line 2245
    type___2 = type___2->output;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 2246
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2247
    typedef_copy(type___2);
    }
  } else {
#line 2249
    typeh[type_spec_count] = type___2;
  }
  {
#line 2250
  align_memory(& kodp, (int )sizeof(int ));
#line 2251
  kodp1 = kodp;
#line 2251
  pc = kodp;
#line 2252
  body_flag = 0;
#line 2253
  lookup_tables((yyvsp + 0)->mystring, variable);
#line 2254
  typedef_f = 1;
  }
#line 2256
  goto switch_break;
  case_189: /* CIL Label */ 
  {
#line 2261
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
#line 2262
  tmp___105 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 2262
  help___10 = (struct internal_type *)tmp___105;
#line 2264
  init_zero((char *)help___10, (unsigned int )sizeof(struct internal_type ));
  }
#line 2265
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 2267
    help___10->output = (typeh[type_spec_count])->output;
#line 2268
    arch___6 = (typeh[type_spec_count])->output;
#line 2269
    (typeh[type_spec_count])->output = help___10;
  } else {
#line 2273
    help___10->output = typeh[type_spec_count];
#line 2274
    arch___6 = typeh[type_spec_count];
#line 2275
    typeh[type_spec_count] = help___10;
  }
  {
#line 2277
  help___10->attribute.function_class = (enum intern_func_class )1025;
#line 2278
  help___10->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 2279
  body_flag = 1;
#line 2280
  put2table((yyvsp + -1)->mystring, typeh[type_spec_count]);
#line 2281
  count_arr = 1;
#line 2282
  kodp1 = kodp;
#line 2282
  pc = kodp;
#line 2283
  body_flag = 0;
#line 2284
  lookup_tables((yyvsp + -1)->mystring, variable);
  }
#line 2285
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2286
    typedef_copy(arch___6);
    }
  } else {
#line 2288
    typeh[type_spec_count] = arch___6;
  }
  {
#line 2291
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2291
    if (! (1028U == (unsigned int )arch___6->attribute.function_class)) {
#line 2291
      goto while_break___12;
    }
#line 2292
    arch___6 = arch___6->output;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 2293
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 2293
    if (! (-1 != dim[poc])) {
#line 2293
      goto while_break___13;
    }
#line 2293
    tmp___106 = poc;
#line 2293
    poc --;
#line 2293
    dim[tmp___106] = -1;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 2294
  typedef_f = 1;
#line 2296
  goto switch_break;
  case_191: /* CIL Label */ 
  {
#line 2305
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
#line 2306
  tmp___107 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 2306
  help___11 = (struct internal_type *)tmp___107;
#line 2308
  init_zero((char *)help___11, (unsigned int )sizeof(struct internal_type ));
  }
#line 2309
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 2311
    help___11->output = (typeh[type_spec_count])->output;
#line 2312
    arch___7 = (typeh[type_spec_count])->output;
#line 2313
    (typeh[type_spec_count])->output = help___11;
#line 2314
    if (2049U == (unsigned int )(((typeh[type_spec_count])->output)->output)->attribute.function_class) {
#line 2315
      ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )2049;
    } else {
#line 2318
      ((typeh[type_spec_count])->output)->attribute.function_class = (enum intern_func_class )2048;
    }
#line 2320
    ((typeh[type_spec_count])->output)->attribute.export_type = (((typeh[type_spec_count])->output)->output)->attribute.export_type;
#line 2322
    set ++;
#line 2322
    type_ac[set] = (((typeh[type_spec_count])->output)->output)->attribute.arit_class;
#line 2324
    type_com[set] = (typeh[type_spec_count])->output;
  } else {
#line 2328
    help___11->output = typeh[type_spec_count];
#line 2329
    arch___7 = typeh[type_spec_count];
#line 2330
    typeh[type_spec_count] = help___11;
#line 2331
    if (2049U == (unsigned int )((typeh[type_spec_count])->output)->attribute.function_class) {
#line 2332
      (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2049;
    } else {
#line 2335
      (typeh[type_spec_count])->attribute.function_class = (enum intern_func_class )2048;
    }
#line 2337
    (typeh[type_spec_count])->attribute.export_type = ((typeh[type_spec_count])->output)->attribute.export_type;
#line 2339
    set ++;
#line 2339
    type_ac[set] = ((typeh[type_spec_count])->output)->attribute.arit_class;
#line 2341
    type_com[set] = typeh[type_spec_count];
  }
  {
#line 2343
  body_flag = 0;
#line 2344
  put2table((yyvsp + -1)->mystring, typeh[type_spec_count]);
#line 2345
  variable[set].adr = kodp;
#line 2346
  variable[set].name = (yyvsp + -1)->mystring;
#line 2347
  proc ++;
#line 2347
  count[proc] = (int )(- (3UL * sizeof(char *)));
#line 2348
  proc_name_text[proc] = text;
  }
#line 2349
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2350
    typedef_copy(arch___7);
    }
  } else {
#line 2352
    typeh[type_spec_count] = arch___7;
  }
  {
#line 2355
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 2355
    if (! (1028U == (unsigned int )arch___7->attribute.function_class)) {
#line 2355
      goto while_break___14;
    }
#line 2356
    arch___7 = arch___7->output;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 2357
  typedef_f = 1;
#line 2359
  goto switch_break;
  case_193: /* CIL Label */ 
#line 2365
  tmp___108 = type_spec_count;
#line 2365
  type_spec_count --;
#line 2365
  typeh[tmp___108] = (struct internal_type *)((void *)0);
#line 2367
  goto switch_break;
  case_194: /* CIL Label */ 
#line 2369
  tmp___109 = type_spec_count;
#line 2369
  type_spec_count --;
#line 2369
  typeh[tmp___109] = (struct internal_type *)((void *)0);
#line 2371
  goto switch_break;
  case_196: /* CIL Label */ 
#line 2380
  ((struct OPERAND_0_ma *)kodp)->major = 35;
#line 2380
  kodp += sizeof(struct OPERAND_0_ma );
#line 2380
  last_instr = current_instr;
#line 2380
  current_instr = kodp;
#line 2381
  if (no_compile_only) {
#line 2381
    if (! handle_main) {
#line 2381
      goto _L___4;
    } else
#line 2381
    if (initialize_only) {
      _L___4: /* CIL Label */ 
      {
#line 2385
      virtual_machine_suspended = 0;
#line 2387
      tmp___110 = exec();
      }
#line 2387
      if (0 == tmp___110) {
#line 2388
        return (0);
      }
#line 2390
      virtual_machine_suspended = 1;
    } else {
#line 2381
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2393
  if (! s) {
#line 2394
    return (0);
  }
#line 2395
  if (initialize_only) {
#line 2395
    initialize_only --;
  }
#line 2397
  kodp = kodp1;
#line 2397
  pc = kodp;
#line 2397
  current_instr = kodp;
#line 2397
  last_instr = kodp;
#line 2400
  goto switch_break;
  case_198: /* CIL Label */ 
#line 2405
  if (! (2048U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 2405
    if (! (2049U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 2405
      if (! (8192U == (unsigned int )(type_com[set])->attribute.storage_class_specifier)) {
        {
#line 2426
        if ((unsigned int )type_ac[set] == 258U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 130U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 2U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 32U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 80U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 64U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 268U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 140U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 12U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 280U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 152U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 24U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 264U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 136U) {
#line 2426
          goto case_258___2;
        }
#line 2426
        if ((unsigned int )type_ac[set] == 8U) {
#line 2426
          goto case_258___2;
        }
#line 2429
        if ((unsigned int )type_ac[set] == 1U) {
#line 2429
          goto case_1___3;
        }
#line 2431
        goto switch_default___2;
        case_258___2: /* CIL Label */ 
        case_130___2: /* CIL Label */ 
        case_2___2: /* CIL Label */ 
        case_32___3: /* CIL Label */ 
        case_80___2: /* CIL Label */ 
        case_64___3: /* CIL Label */ 
        case_268___2: /* CIL Label */ 
        case_140___3: /* CIL Label */ 
        case_12___2: /* CIL Label */ 
        case_280___2: /* CIL Label */ 
        case_152___2: /* CIL Label */ 
        case_24___2: /* CIL Label */ 
        case_264___2: /* CIL Label */ 
        case_136___3: /* CIL Label */ 
        case_8___2: /* CIL Label */ 
#line 2427
        ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 2427
        ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 2427
        kodp += sizeof(struct OPERAND_0_mi );
#line 2427
        last_instr = current_instr;
#line 2427
        current_instr = kodp;
#line 2428
        goto switch_break___3;
        case_1___3: /* CIL Label */ 
#line 2430
        goto switch_break___3;
        switch_default___2: /* CIL Label */ 
        {
#line 2432
        fprintfx(stderr, "%s:%d:\n", "ys.y", 2432);
#line 2433
        error_message(5000);
        }
#line 2433
        return (0);
        switch_break___3: /* CIL Label */ ;
        }
#line 2435
        ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 2435
        kodp += sizeof(struct OPERAND_0_ma );
#line 2435
        last_instr = current_instr;
#line 2435
        current_instr = kodp;
      }
    }
  }
#line 2437
  kodp3 = (char *)((void *)0);
#line 2438
  is_address = 0;
#line 2439
  variable[set].adr = (char *)((void *)0);
#line 2439
  variable[set].offset = 0;
#line 2440
  subscript_flag[set] = 0;
#line 2440
  struct_union_field[set] = 0;
#line 2440
  type_ac[set] = (enum intern_arit_class )0;
#line 2440
  tmp___111 = set;
#line 2440
  set --;
#line 2440
  type_com[tmp___111] = (struct internal_type *)((void *)0);
#line 2440
  if (0 > set) {
    {
#line 2440
    error_message(5003);
    }
  }
  {
#line 2441
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 2441
    if (! (-1 != dim[poc])) {
#line 2441
      goto while_break___15;
    }
#line 2441
    tmp___112 = poc;
#line 2441
    poc --;
#line 2441
    dim[tmp___112] = -1;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 2443
  goto switch_break;
  case_199: /* CIL Label */ 
#line 2448
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2449
    error_message(1037, text);
    }
  }
#line 2454
  if (1024U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 2456
    tmp___113 = l_value_cast();
    }
#line 2456
    if (-1 == tmp___113) {
#line 2457
      no_compile_only = 0;
    }
#line 2458
    variable[set].adr = (char *)((void *)0);
#line 2458
    variable[set].offset = 0;
#line 2459
    subscript_flag[set] = 0;
#line 2459
    struct_union_field[set] = 0;
#line 2459
    type_ac[set] = (enum intern_arit_class )0;
#line 2459
    tmp___114 = set;
#line 2459
    set --;
#line 2459
    type_com[tmp___114] = (struct internal_type *)((void *)0);
#line 2459
    if (0 > set) {
      {
#line 2459
      error_message(5003);
      }
    }
    {
#line 2460
    move2lvalue();
    }
  } else
#line 2462
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 2464
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 2464
      if (! (-1 != dim[poc])) {
#line 2464
        goto while_break___16;
      }
#line 2464
      tmp___115 = poc;
#line 2464
      poc --;
#line 2464
      dim[tmp___115] = -1;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 2465
    if (4096U == (unsigned int )(type_com[set])->attribute.type_qualifier) {
#line 2467
      (type_com[set - 1])->attribute.domain = (type_com[set])->attribute.domain;
#line 2469
      if (! (type_com[set - 1])->attribute.memory_size) {
#line 2470
        (type_com[set - 1])->attribute.memory_size = (type_com[set])->attribute.memory_size;
      }
#line 2472
      if (2U & (unsigned int )((type_com[set])->output)->attribute.arit_class) {
#line 2476
        i___2 = 0;
        {
#line 2476
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 2476
          if (! (i___2 < (type_com[set])->attribute.memory_size)) {
#line 2476
            goto while_break___17;
          }
#line 2480
          ((struct OPERAND_1_i *)kodp)->major = 32;
#line 2480
          ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 2480
          ((struct OPERAND_1_i *)kodp)->num = i___2;
#line 2480
          kodp += sizeof(struct OPERAND_1_i );
#line 2480
          last_instr = current_instr;
#line 2480
          current_instr = kodp;
#line 2481
          ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 2481
          ((struct OPERAND_0_mi *)kodp)->minor = 11;
#line 2481
          kodp += sizeof(struct OPERAND_0_mi );
#line 2481
          last_instr = current_instr;
#line 2481
          current_instr = kodp;
#line 2476
          i___2 ++;
        }
        while_break___17: /* CIL Label */ ;
        }
      }
#line 2484
      if (! (1028U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 2486
        ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 2486
        ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 2486
        kodp += sizeof(struct OPERAND_0_mi );
#line 2486
        last_instr = current_instr;
#line 2486
        current_instr = kodp;
#line 2487
        variable[set].adr = (char *)((void *)0);
#line 2487
        variable[set].offset = 0;
#line 2488
        subscript_flag[set] = 0;
#line 2488
        struct_union_field[set] = 0;
#line 2488
        type_ac[set] = (enum intern_arit_class )0;
#line 2488
        tmp___116 = set;
#line 2488
        set --;
#line 2488
        type_com[tmp___116] = (struct internal_type *)((void *)0);
#line 2488
        if (0 > set) {
          {
#line 2488
          error_message(5003);
          }
        }
      }
    } else
#line 2491
    if (! (type_com[set])->attribute.memory_size) {
      {
#line 2493
      (type_com[set])->attribute.memory_size = initialize_only * ((type_com[set])->output)->attribute.memory_size;
#line 2496
      poc ++;
#line 2496
      dim[poc] = initialize_only;
#line 2497
      put_array_subscript(& type_com[set]);
      }
    }
    {
#line 2499
    kodp1 += (type_com[set])->attribute.memory_size;
#line 2500
    align_memory(& kodp1, (int )sizeof(int ));
    }
#line 2501
    if (set > 1) {
#line 2501
      if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
#line 2504
        ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 2504
        ((struct OPERAND_0_mi *)kodp)->minor = 13;
#line 2504
        kodp += sizeof(struct OPERAND_0_mi );
#line 2504
        last_instr = current_instr;
#line 2504
        current_instr = kodp;
#line 2505
        variable[set].adr = (char *)((void *)0);
#line 2505
        variable[set].offset = 0;
#line 2506
        subscript_flag[set] = 0;
#line 2506
        struct_union_field[set] = 0;
#line 2506
        type_ac[set] = (enum intern_arit_class )0;
#line 2506
        tmp___117 = set;
#line 2506
        set --;
#line 2506
        type_com[tmp___117] = (struct internal_type *)((void *)0);
#line 2506
        if (0 > set) {
          {
#line 2506
          error_message(5003);
          }
        }
      }
    }
  }
  {
#line 2527
  if ((unsigned int )type_ac[set] == 258U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 130U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 2U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 32U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 80U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 64U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 268U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 140U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 12U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 280U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 152U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 24U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 264U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 136U) {
#line 2527
    goto case_258___3;
  }
#line 2527
  if ((unsigned int )type_ac[set] == 8U) {
#line 2527
    goto case_258___3;
  }
#line 2530
  if ((unsigned int )type_ac[set] == 1U) {
#line 2530
    goto case_1___4;
  }
#line 2532
  goto switch_default___3;
  case_258___3: /* CIL Label */ 
  case_130___3: /* CIL Label */ 
  case_2___3: /* CIL Label */ 
  case_32___4: /* CIL Label */ 
  case_80___3: /* CIL Label */ 
  case_64___4: /* CIL Label */ 
  case_268___3: /* CIL Label */ 
  case_140___4: /* CIL Label */ 
  case_12___3: /* CIL Label */ 
  case_280___3: /* CIL Label */ 
  case_152___3: /* CIL Label */ 
  case_24___3: /* CIL Label */ 
  case_264___3: /* CIL Label */ 
  case_136___4: /* CIL Label */ 
  case_8___3: /* CIL Label */ 
#line 2528
  ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 2528
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 2528
  kodp += sizeof(struct OPERAND_0_mi );
#line 2528
  last_instr = current_instr;
#line 2528
  current_instr = kodp;
#line 2529
  goto switch_break___4;
  case_1___4: /* CIL Label */ 
#line 2531
  goto switch_break___4;
  switch_default___3: /* CIL Label */ 
  {
#line 2533
  fprintfx(stderr, "%s:%d:\n", "ys.y", 2533);
#line 2534
  error_message(5000);
  }
#line 2535
  return (0);
  switch_break___4: /* CIL Label */ ;
  }
#line 2537
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 2537
  kodp += sizeof(struct OPERAND_0_ma );
#line 2537
  last_instr = current_instr;
#line 2537
  current_instr = kodp;
#line 2537
  kodp3 = (char *)((void *)0);
#line 2538
  is_address = 0;
#line 2539
  variable[set].adr = (char *)((void *)0);
#line 2539
  variable[set].offset = 0;
#line 2540
  subscript_flag[set] = 0;
#line 2540
  struct_union_field[set] = 0;
#line 2540
  type_ac[set] = (enum intern_arit_class )0;
#line 2540
  tmp___118 = set;
#line 2540
  set --;
#line 2540
  type_com[tmp___118] = (struct internal_type *)((void *)0);
#line 2540
  if (0 > set) {
    {
#line 2540
    error_message(5003);
    }
  }
#line 2541
  if (handle_main) {
#line 2542
    initialize_only = 1;
  }
#line 2544
  goto switch_break;
  case_200: /* CIL Label */ 
#line 2552
  fixp->if1.jmp = kodp;
#line 2553
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 2553
  kodp += sizeof(struct OPERAND_1_ma );
#line 2553
  last_instr = current_instr;
#line 2553
  current_instr = kodp;
#line 2554
  ((struct OPERAND_1_ma *)fixp->if1.jz)->adr = kodp;
#line 2556
  goto switch_break;
  case_201: /* CIL Label */ 
#line 2558
  ((struct OPERAND_1_ma *)fixp->if1.jmp)->adr = kodp;
#line 2559
  fixp --;
#line 2561
  goto switch_break;
  case_202: /* CIL Label */ 
#line 2564
  ((struct OPERAND_1_ma *)fixp->if1.jz)->adr = kodp;
#line 2565
  fixp --;
#line 2567
  goto switch_break;
  case_204: /* CIL Label */ 
#line 2579
  if (no_compile_only) {
    {
#line 2580
    has_label((yyvsp + -1)->mystring);
    }
  }
#line 2582
  goto switch_break;
  case_206: /* CIL Label */ 
#line 2589
  help___12 = fixp->switch1.jmp;
#line 2593
  fixp->switch1.jmp = kodp;
#line 2593
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 2593
  kodp += sizeof(struct OPERAND_1_ma );
#line 2593
  last_instr = current_instr;
#line 2593
  current_instr = kodp;
#line 2594
  if ((unsigned long )fixp->switch1.jz != (unsigned long )((void *)0)) {
#line 2596
    ((struct OPERAND_1_ma *)fixp->switch1.jz)->adr = kodp;
  }
#line 2597
  if ((unsigned long )help___12 != (unsigned long )((void *)0)) {
#line 2599
    ((struct OPERAND_1_ma *)help___12)->adr = kodp;
  }
#line 2600
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 2600
  ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 2600
  kodp += sizeof(struct OPERAND_0_mi );
#line 2600
  last_instr = current_instr;
#line 2600
  current_instr = kodp;
#line 2603
  it_is_in_case = 1;
#line 2605
  goto switch_break;
  case_207: /* CIL Label */ 
#line 2607
  if (4096U != (unsigned int )(type_com[set])->attribute.type_qualifier) {
    {
#line 2609
    error_message(1014);
    }
  } else
#line 2607
  if (8U != (unsigned int )type_ac[set]) {
    {
#line 2609
    error_message(1014);
    }
  }
#line 2610
  variable[set].adr = (char *)((void *)0);
#line 2610
  variable[set].offset = 0;
#line 2611
  subscript_flag[set] = 0;
#line 2611
  struct_union_field[set] = 0;
#line 2611
  type_ac[set] = (enum intern_arit_class )0;
#line 2611
  tmp___119 = set;
#line 2611
  set --;
#line 2611
  type_com[tmp___119] = (struct internal_type *)((void *)0);
#line 2611
  if (0 > set) {
    {
#line 2611
    error_message(5003);
    }
  }
#line 2612
  ((struct OPERAND_0_mi *)kodp)->major = 19;
#line 2612
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 2612
  kodp += sizeof(struct OPERAND_0_mi );
#line 2612
  last_instr = current_instr;
#line 2612
  current_instr = kodp;
#line 2613
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 2613
  kodp += sizeof(struct OPERAND_0_ma );
#line 2613
  last_instr = current_instr;
#line 2613
  current_instr = kodp;
#line 2616
  fixp->switch1.jz = kodp;
#line 2617
  ((struct OPERAND_1_ma *)kodp)->major = 27;
#line 2617
  kodp += sizeof(struct OPERAND_1_ma );
#line 2617
  last_instr = current_instr;
#line 2617
  current_instr = kodp;
#line 2621
  ((struct OPERAND_1_ma *)fixp->switch1.jmp)->adr = kodp;
#line 2623
  fixp->switch1.jmp = (char *)((void *)0);
#line 2624
  it_is_in_case = 0;
#line 2626
  goto switch_break;
  case_209: /* CIL Label */ 
  {
#line 2630
  add_default_to_fixp();
  }
#line 2632
  goto switch_break;
  case_212: /* CIL Label */ 
#line 2648
  if (error_count) {
#line 2648
    goto switch_break;
  }
  {
#line 2649
  ((struct OPERAND_1_i *)kodp)->major = 11;
#line 2649
  ((struct OPERAND_1_i *)kodp)->num = scope_offset_set(count[proc]);
#line 2649
  ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 2649
  kodp += sizeof(struct OPERAND_1_i );
#line 2649
  last_instr = current_instr;
#line 2649
  current_instr = kodp;
#line 2650
  count[proc] = 0;
  }
#line 2652
  goto switch_break;
  case_214: /* CIL Label */ 
  {
#line 2658
  enter_scope();
  }
#line 2660
  goto switch_break;
  case_215: /* CIL Label */ 
#line 2669
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2670
    error_message(2018, (yyvsp + 0)->mystring);
    }
  } else
#line 2671
  if (8193U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2672
    error_message(2018, (yyvsp + 0)->mystring);
    }
  }
  {
#line 2673
  check_spec_constr(typeh[type_spec_count], (yyvsp + 0)->mystring);
  }
#line 2674
  if (! body_flag) {
    {
#line 2675
    error_message(6009);
    }
  }
  {
#line 2676
  tmp___120 = add_to_spec_list();
  }
#line 2676
  if (-1 == tmp___120) {
#line 2677
    no_compile_only = 0;
  }
  {
#line 2678
  tmp___121 = has_loc(512, (yyvsp + 0)->mystring);
  }
#line 2678
  if (-1 == tmp___121) {
#line 2679
    no_compile_only = 0;
  }
  {
#line 2680
  tmp___122 = add_to_ident_list();
  }
#line 2680
  if (-1 == tmp___122) {
#line 2681
    no_compile_only = 0;
  }
#line 2682
  tmp___123 = type_spec_count;
#line 2682
  type_spec_count --;
#line 2682
  typeh[tmp___123] = (struct internal_type *)((void *)0);
#line 2683
  typedef_f = 1;
#line 2685
  goto switch_break;
  case_216: /* CIL Label */ 
#line 2688
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2689
    error_message(2018, (yyvsp + -1)->mystring);
    }
  } else
#line 2690
  if (8193U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2691
    error_message(2018, (yyvsp + -1)->mystring);
    }
  }
  {
#line 2692
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
  }
#line 2693
  if (! body_flag) {
    {
#line 2694
    error_message(6009);
    }
  }
  {
#line 2695
  tmp___124 = add_to_spec_list();
  }
#line 2695
  if (-1 == tmp___124) {
#line 2696
    no_compile_only = 0;
  }
  {
#line 2697
  tmp___125 = has_loc(512, (yyvsp + -1)->mystring);
  }
#line 2697
  if (-1 == tmp___125) {
#line 2698
    no_compile_only = 0;
  }
  {
#line 2699
  tmp___126 = add_to_ident_list();
  }
#line 2699
  if (-1 == tmp___126) {
#line 2700
    no_compile_only = 0;
  }
#line 2701
  tmp___127 = type_spec_count;
#line 2701
  type_spec_count --;
#line 2701
  typeh[tmp___127] = (struct internal_type *)((void *)0);
#line 2702
  typedef_f = 1;
#line 2704
  goto switch_break;
  case_218: /* CIL Label */ 
#line 2709
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2710
    error_message(2018, (yyvsp + -1)->mystring);
    }
  } else
#line 2711
  if (8193U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2712
    error_message(2018, (yyvsp + -1)->mystring);
    }
  }
  {
#line 2713
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
#line 2714
  tmp___128 = allocate((unsigned int )sizeof(struct internal_type ), 1U);
#line 2714
  help___13 = (struct internal_type *)tmp___128;
#line 2716
  init_zero((char *)help___13, (unsigned int )sizeof(struct internal_type ));
#line 2717
  help___13->output = typeh[type_spec_count];
#line 2718
  help___13->attribute.function_class = (enum intern_func_class )1025;
#line 2719
  help___13->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 2720
  typeh[type_spec_count] = help___13;
#line 2721
  tmp___129 = add_to_spec_list();
  }
#line 2721
  if (-1 == tmp___129) {
#line 2722
    no_compile_only = 0;
  }
  {
#line 2723
  tmp___130 = has_loc(512, (yyvsp + -1)->mystring);
  }
#line 2723
  if (-1 == tmp___130) {
#line 2724
    no_compile_only = 0;
  }
  {
#line 2725
  tmp___131 = add_to_ident_list();
  }
#line 2725
  if (-1 == tmp___131) {
#line 2726
    no_compile_only = 0;
  }
#line 2727
  count_arr = 1;
#line 2728
  tmp___132 = type_spec_count;
#line 2728
  type_spec_count --;
#line 2728
  typeh[tmp___132] = (struct internal_type *)((void *)0);
  {
#line 2729
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 2729
    if (! (-1 != dim[poc])) {
#line 2729
      goto while_break___18;
    }
#line 2729
    tmp___133 = poc;
#line 2729
    poc --;
#line 2729
    dim[tmp___133] = -1;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 2730
  typedef_f = 1;
#line 2732
  goto switch_break;
  case_219: /* CIL Label */ 
#line 2736
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2737
    error_message(2018, (yyvsp + -2)->mystring);
    }
  } else
#line 2738
  if (8193U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2739
    error_message(2018, (yyvsp + -2)->mystring);
    }
  }
  {
#line 2740
  check_spec_constr(typeh[type_spec_count], (yyvsp + -2)->mystring);
#line 2741
  tmp___134 = allocate((unsigned int )sizeof(struct internal_type ), 1U);
#line 2741
  help___14 = (struct internal_type *)tmp___134;
#line 2743
  init_zero((char *)help___14, (unsigned int )sizeof(struct internal_type ));
#line 2744
  help___14->output = typeh[type_spec_count];
#line 2745
  help___14->attribute.function_class = (enum intern_func_class )1025;
#line 2746
  help___14->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 2747
  typeh[type_spec_count] = help___14;
#line 2748
  tmp___135 = add_to_spec_list();
  }
#line 2748
  if (-1 == tmp___135) {
#line 2749
    no_compile_only = 0;
  }
  {
#line 2750
  tmp___136 = has_loc(512, (yyvsp + -2)->mystring);
  }
#line 2750
  if (-1 == tmp___136) {
#line 2751
    no_compile_only = 0;
  }
  {
#line 2752
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 2752
    if (! (-1 != dim[poc])) {
#line 2752
      goto while_break___19;
    }
#line 2753
    tmp___137 = poc;
#line 2753
    poc --;
#line 2753
    dim[tmp___137] = -1;
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 2754
  tmp___138 = add_to_ident_list();
  }
#line 2754
  if (-1 == tmp___138) {
#line 2755
    no_compile_only = 0;
  }
#line 2756
  count_arr = 1;
#line 2757
  tmp___139 = type_spec_count;
#line 2757
  type_spec_count --;
#line 2757
  typeh[tmp___139] = (struct internal_type *)((void *)0);
  {
#line 2758
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 2758
    if (! (-1 != dim[poc])) {
#line 2758
      goto while_break___20;
    }
#line 2758
    tmp___140 = poc;
#line 2758
    poc --;
#line 2758
    dim[tmp___140] = -1;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 2759
  typedef_f = 1;
#line 2761
  goto switch_break;
  case_221: /* CIL Label */ 
#line 2765
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2766
    error_message(2018, (yyvsp + 0)->mystring);
    }
  } else
#line 2767
  if (8193U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2768
    error_message(2018, (yyvsp + 0)->mystring);
    }
  }
  {
#line 2769
  check_spec_constr(typeh[type_spec_count], (yyvsp + 0)->mystring);
  }
#line 2770
  if (! body_flag) {
    {
#line 2771
    error_message(6009);
    }
  }
  {
#line 2772
  tmp___141 = add_to_spec_list();
  }
#line 2772
  if (-1 == tmp___141) {
#line 2773
    no_compile_only = 0;
  }
  {
#line 2774
  tmp___142 = has_loc(512, (yyvsp + 0)->mystring);
  }
#line 2774
  if (-1 == tmp___142) {
#line 2775
    no_compile_only = 0;
  }
  {
#line 2776
  tmp___143 = add_to_ident_list();
  }
#line 2776
  if (-1 == tmp___143) {
#line 2777
    no_compile_only = 0;
  }
#line 2778
  tmp___144 = type_spec_count;
#line 2778
  type_spec_count --;
#line 2778
  typeh[tmp___144] = (struct internal_type *)((void *)0);
#line 2779
  typedef_f = 1;
#line 2781
  goto switch_break;
  case_222: /* CIL Label */ 
#line 2784
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2785
    error_message(2018, (yyvsp + -1)->mystring);
    }
  } else
#line 2786
  if (8193U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2787
    error_message(2018, (yyvsp + -1)->mystring);
    }
  }
  {
#line 2788
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
  }
#line 2789
  if (! body_flag) {
    {
#line 2790
    error_message(6009);
    }
  }
  {
#line 2791
  tmp___145 = add_to_spec_list();
  }
#line 2791
  if (-1 == tmp___145) {
#line 2792
    no_compile_only = 0;
  }
  {
#line 2793
  tmp___146 = has_loc(512, (yyvsp + -1)->mystring);
  }
#line 2793
  if (-1 == tmp___146) {
#line 2794
    no_compile_only = 0;
  }
  {
#line 2795
  tmp___147 = add_to_ident_list();
  }
#line 2795
  if (-1 == tmp___147) {
#line 2796
    no_compile_only = 0;
  }
#line 2797
  tmp___148 = type_spec_count;
#line 2797
  type_spec_count --;
#line 2797
  typeh[tmp___148] = (struct internal_type *)((void *)0);
#line 2798
  typedef_f = 1;
#line 2800
  goto switch_break;
  case_224: /* CIL Label */ 
#line 2805
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2806
    error_message(2018, (yyvsp + -1)->mystring);
    }
  } else
#line 2807
  if (8193U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2808
    error_message(2018, (yyvsp + -1)->mystring);
    }
  }
  {
#line 2809
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
#line 2810
  tmp___149 = allocate((unsigned int )sizeof(struct internal_type ), 1U);
#line 2810
  help___15 = (struct internal_type *)tmp___149;
#line 2812
  init_zero((char *)help___15, (unsigned int )sizeof(struct internal_type ));
#line 2813
  help___15->output = typeh[type_spec_count];
#line 2814
  help___15->attribute.function_class = (enum intern_func_class )1025;
#line 2815
  help___15->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 2816
  typeh[type_spec_count] = help___15;
#line 2817
  tmp___150 = add_to_spec_list();
  }
#line 2817
  if (-1 == tmp___150) {
#line 2818
    no_compile_only = 0;
  }
  {
#line 2819
  tmp___151 = has_loc(512, (yyvsp + -1)->mystring);
  }
#line 2819
  if (-1 == tmp___151) {
#line 2820
    no_compile_only = 0;
  }
  {
#line 2821
  tmp___152 = add_to_ident_list();
  }
#line 2821
  if (-1 == tmp___152) {
#line 2822
    no_compile_only = 0;
  }
#line 2823
  count_arr = 1;
#line 2824
  tmp___153 = type_spec_count;
#line 2824
  type_spec_count --;
#line 2824
  typeh[tmp___153] = (struct internal_type *)((void *)0);
  {
#line 2825
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 2825
    if (! (-1 != dim[poc])) {
#line 2825
      goto while_break___21;
    }
#line 2825
    tmp___154 = poc;
#line 2825
    poc --;
#line 2825
    dim[tmp___154] = -1;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 2826
  typedef_f = 1;
#line 2828
  goto switch_break;
  case_225: /* CIL Label */ 
#line 2832
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2833
    error_message(2018, (yyvsp + -2)->mystring);
    }
  } else
#line 2834
  if (8193U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2835
    error_message(2018, (yyvsp + -2)->mystring);
    }
  }
  {
#line 2836
  check_spec_constr(typeh[type_spec_count], (yyvsp + -2)->mystring);
#line 2837
  tmp___155 = allocate((unsigned int )sizeof(struct internal_type ), 1U);
#line 2837
  help___16 = (struct internal_type *)tmp___155;
#line 2839
  init_zero((char *)help___16, (unsigned int )sizeof(struct internal_type ));
#line 2840
  help___16->output = typeh[type_spec_count];
#line 2841
  help___16->attribute.function_class = (enum intern_func_class )1025;
#line 2842
  help___16->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 2843
  typeh[type_spec_count] = help___16;
#line 2844
  tmp___156 = add_to_spec_list();
  }
#line 2844
  if (-1 == tmp___156) {
#line 2845
    no_compile_only = 0;
  }
  {
#line 2846
  tmp___157 = has_loc(512, (yyvsp + -2)->mystring);
  }
#line 2846
  if (-1 == tmp___157) {
#line 2847
    no_compile_only = 0;
  }
  {
#line 2848
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 2848
    if (! (-1 != dim[poc])) {
#line 2848
      goto while_break___22;
    }
#line 2849
    tmp___158 = poc;
#line 2849
    poc --;
#line 2849
    dim[tmp___158] = -1;
  }
  while_break___22: /* CIL Label */ ;
  }
  {
#line 2850
  tmp___159 = add_to_ident_list();
  }
#line 2850
  if (-1 == tmp___159) {
#line 2851
    no_compile_only = 0;
  }
#line 2852
  count_arr = 1;
#line 2853
  tmp___160 = type_spec_count;
#line 2853
  type_spec_count --;
#line 2853
  typeh[tmp___160] = (struct internal_type *)((void *)0);
  {
#line 2854
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 2854
    if (! (-1 != dim[poc])) {
#line 2854
      goto while_break___23;
    }
#line 2854
    tmp___161 = poc;
#line 2854
    poc --;
#line 2854
    dim[tmp___161] = -1;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 2855
  typedef_f = 1;
#line 2857
  goto switch_break;
  case_227: /* CIL Label */ 
#line 2865
  poc ++;
#line 2865
  dim[poc] = -2;
#line 2867
  goto switch_break;
  case_228: /* CIL Label */ 
#line 2870
  count_arr *= (yyvsp + -1)->myint;
#line 2871
  poc ++;
#line 2871
  dim[poc] = (yyvsp + -1)->myint;
#line 2873
  goto switch_break;
  case_229: /* CIL Label */ 
#line 2876
  count_arr *= (yyvsp + -1)->myint;
#line 2877
  poc ++;
#line 2877
  dim[poc] = (yyvsp + -1)->myint;
#line 2879
  goto switch_break;
  case_231: /* CIL Label */ 
#line 2888
  if (! (1031U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
#line 2888
    if (! (1030U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
#line 2888
      if (! (1029U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
        {
#line 2892
        error_message(6010);
#line 2893
        error_message(6011);
        }
      }
    }
  }
#line 2895
  tmp___162 = type_spec_count;
#line 2895
  type_spec_count --;
#line 2895
  typeh[tmp___162] = (struct internal_type *)((void *)0);
#line 2897
  goto switch_break;
  case_232: /* CIL Label */ 
#line 2899
  if (! (1031U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
#line 2899
    if (! (1030U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
#line 2899
      if (! (1029U == (unsigned int )(typeh[type_spec_count])->attribute.function_class)) {
        {
#line 2903
        error_message(6010);
#line 2904
        error_message(6011);
        }
      }
    }
  }
#line 2906
  tmp___163 = type_spec_count;
#line 2906
  type_spec_count --;
#line 2906
  typeh[tmp___163] = (struct internal_type *)((void *)0);
#line 2908
  goto switch_break;
  case_234: /* CIL Label */ 
  {
#line 2914
  check_spec_constr(typeh[type_spec_count], (yyvsp + 0)->mystring);
  }
#line 2915
  if (1U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 2916
    error_message(1012);
    }
  }
#line 2917
  if (8195U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 2919
    jmp1 = kodp;
#line 2920
    ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 2920
    kodp += sizeof(struct OPERAND_1_ma );
#line 2920
    last_instr = current_instr;
#line 2920
    current_instr = kodp;
#line 2921
    if (0U == (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
#line 2922
      (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
    }
  }
  {
#line 2925
  tmp___164 = has_loc(768, (yyvsp + 0)->mystring);
  }
#line 2925
  if (-1 == tmp___164) {
#line 2926
    no_compile_only = 0;
  }
#line 2927
  if (8195U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 2928
    ((struct OPERAND_1_ma *)jmp1)->adr = kodp;
  }
  {
#line 2929
  lookup_tables((yyvsp + 0)->mystring, variable);
  }
#line 2931
  goto switch_break;
  case_236: /* CIL Label */ 
  {
#line 2936
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
  }
#line 2937
  if (1U & (unsigned int )(typeh[type_spec_count])->attribute.arit_class) {
    {
#line 2938
    error_message(1012);
    }
  }
  {
#line 2939
  tmp___165 = allocate((unsigned int )sizeof(struct internal_type ), 1U);
#line 2939
  help___17 = (struct internal_type *)tmp___165;
#line 2941
  init_zero((char *)help___17, (unsigned int )sizeof(struct internal_type ));
  }
#line 2942
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 2944
    help___17->output = (typeh[type_spec_count])->output;
#line 2945
    arch___8 = (typeh[type_spec_count])->output;
#line 2946
    (typeh[type_spec_count])->output = help___17;
  } else {
#line 2950
    help___17->output = typeh[type_spec_count];
#line 2951
    arch___8 = typeh[type_spec_count];
#line 2952
    typeh[type_spec_count] = help___17;
  }
#line 2954
  help___17->attribute.function_class = (enum intern_func_class )1025;
#line 2955
  if (8195U == (unsigned int )(help___17->output)->attribute.storage_class_specifier) {
#line 2957
    jmp1 = kodp;
#line 2958
    ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 2958
    kodp += sizeof(struct OPERAND_1_ma );
#line 2958
    last_instr = current_instr;
#line 2958
    current_instr = kodp;
#line 2959
    if ((unsigned int )(help___17->output)->attribute.arit_class == 0U) {
#line 2961
      (help___17->output)->attribute.arit_class = (enum intern_arit_class )8;
    }
#line 2963
    help___17->attribute.storage_class_specifier = (enum storage_class_specifier )8195;
  }
  {
#line 2966
  tmp___166 = has_loc(768, (yyvsp + -1)->mystring);
  }
#line 2966
  if (-1 == tmp___166) {
#line 2967
    no_compile_only = 0;
  }
#line 2968
  if (8195U == (unsigned int )(help___17->output)->attribute.storage_class_specifier) {
#line 2969
    ((struct OPERAND_1_ma *)jmp1)->adr = kodp;
  }
#line 2970
  count_arr = 1;
#line 2971
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 2972
    typedef_copy(arch___8);
    }
  } else {
#line 2974
    typeh[type_spec_count] = arch___8;
  }
  {
#line 2975
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 2975
    if (! (-1 != dim[poc])) {
#line 2975
      goto while_break___24;
    }
#line 2975
    tmp___167 = poc;
#line 2975
    poc --;
#line 2975
    dim[tmp___167] = -1;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 2976
  lookup_tables((yyvsp + -1)->mystring, variable);
  }
#line 2978
  goto switch_break;
  case_238: /* CIL Label */ 
#line 2982
  goto switch_break;
  case_240: /* CIL Label */ 
#line 2986
  goto switch_break;
  case_242: /* CIL Label */ 
#line 2990
  goto switch_break;
  case_244: /* CIL Label */ 
  {
#line 2995
  check_spec_constr(typeh[type_spec_count], (yyvsp + 0)->mystring);
  }
#line 2996
  if (8195U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 2998
    jmp1 = kodp;
#line 2999
    ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 2999
    kodp += sizeof(struct OPERAND_1_ma );
#line 2999
    last_instr = current_instr;
#line 2999
    current_instr = kodp;
#line 3000
    if ((unsigned int )(typeh[type_spec_count])->attribute.arit_class == 0U) {
#line 3002
      (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
    }
  }
  {
#line 3005
  tmp___168 = has_loc(768, (yyvsp + 0)->mystring);
  }
#line 3005
  if (-1 == tmp___168) {
#line 3006
    no_compile_only = 0;
  }
#line 3007
  if (8195U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 3008
    ((struct OPERAND_1_ma *)jmp1)->adr = kodp;
  }
#line 3009
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 3011
    type___3 = (typeh[type_spec_count])->output;
#line 3012
    typedef_copy((typeh[type_spec_count])->output);
    }
  } else {
#line 3015
    type___3 = typeh[type_spec_count];
  }
  {
#line 3018
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 3018
    if (! (1028U == (unsigned int )type___3->attribute.function_class)) {
#line 3018
      goto while_break___25;
    }
#line 3019
    type___3 = type___3->output;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 3020
  lookup_tables((yyvsp + 0)->mystring, variable);
  }
#line 3022
  goto switch_break;
  case_246: /* CIL Label */ 
  {
#line 3027
  check_spec_constr(typeh[type_spec_count], (yyvsp + -1)->mystring);
#line 3028
  tmp___169 = allocate((unsigned int )sizeof(struct internal_type ), 1U);
#line 3028
  help___18 = (struct internal_type *)tmp___169;
#line 3030
  init_zero((char *)help___18, (unsigned int )sizeof(struct internal_type ));
  }
#line 3031
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 3033
    help___18->output = (typeh[type_spec_count])->output;
#line 3034
    arch___9 = (typeh[type_spec_count])->output;
#line 3035
    (typeh[type_spec_count])->output = help___18;
  } else {
#line 3039
    help___18->output = typeh[type_spec_count];
#line 3040
    arch___9 = typeh[type_spec_count];
#line 3041
    typeh[type_spec_count] = help___18;
  }
#line 3043
  help___18->attribute.function_class = (enum intern_func_class )1025;
#line 3044
  help___18->attribute.storage_class_specifier = (enum storage_class_specifier )8198;
#line 3045
  if (8195U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 3047
    jmp1 = kodp;
#line 3048
    ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 3048
    kodp += sizeof(struct OPERAND_1_ma );
#line 3048
    last_instr = current_instr;
#line 3048
    current_instr = kodp;
#line 3049
    if ((unsigned int )(typeh[type_spec_count])->attribute.arit_class == 0U) {
#line 3051
      (typeh[type_spec_count])->attribute.arit_class = (enum intern_arit_class )8;
    }
  }
  {
#line 3054
  tmp___170 = has_loc(768, (yyvsp + -1)->mystring);
  }
#line 3054
  if (-1 == tmp___170) {
#line 3055
    no_compile_only = 0;
  }
#line 3056
  if (8195U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 3057
    ((struct OPERAND_1_ma *)jmp1)->adr = kodp;
  }
#line 3058
  count_arr = 1;
#line 3059
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 3060
    typedef_copy(arch___9);
    }
  } else {
#line 3062
    typeh[type_spec_count] = arch___9;
  }
  {
#line 3065
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 3065
    if (! (1028U == (unsigned int )((typeh[type_spec_count])->output)->attribute.function_class)) {
#line 3065
      goto while_break___26;
    }
#line 3066
    arch___9 = arch___9->output;
  }
  while_break___26: /* CIL Label */ ;
  }
  {
#line 3067
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 3067
    if (! (-1 != dim[poc])) {
#line 3067
      goto while_break___27;
    }
#line 3067
    tmp___171 = poc;
#line 3067
    poc --;
#line 3067
    dim[tmp___171] = -1;
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 3068
  lookup_tables((yyvsp + -1)->mystring, variable);
  }
#line 3070
  goto switch_break;
  case_248: /* CIL Label */ 
  {
#line 3075
  check_spec_constr(typeh[type_spec_count], (yyvsp + -2)->mystring);
  }
#line 3076
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 3077
    type___4 = (typeh[type_spec_count])->output;
  } else {
#line 3079
    type___4 = typeh[type_spec_count];
  }
  {
#line 3082
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 3082
    if (! (1028U == (unsigned int )type___4->attribute.function_class)) {
#line 3082
      goto while_break___28;
    }
#line 3083
    type___4 = type___4->output;
  }
  while_break___28: /* CIL Label */ ;
  }
#line 3084
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 3085
    typedef_copy(type___4);
    }
  } else {
#line 3087
    typeh[type_spec_count] = type___4;
  }
  {
#line 3088
  param_flag = 0;
#line 3089
  lookup_tables((yyvsp + -2)->mystring, variable);
  }
#line 3091
  goto switch_break;
  case_250: /* CIL Label */ 
  {
#line 3096
  check_spec_constr(typeh[type_spec_count], (yyvsp + -3)->mystring);
  }
#line 3097
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 3098
    type___5 = (typeh[type_spec_count])->output;
  } else {
#line 3100
    type___5 = typeh[type_spec_count];
  }
  {
#line 3103
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 3103
    if (! (1028U == (unsigned int )type___5->attribute.function_class)) {
#line 3103
      goto while_break___29;
    }
#line 3104
    type___5 = type___5->output;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 3105
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 3106
    typedef_copy(type___5);
    }
  } else {
#line 3108
    typeh[type_spec_count] = type___5;
  }
  {
#line 3109
  param_flag = 0;
#line 3110
  lookup_tables((yyvsp + -3)->mystring, variable);
  }
#line 3112
  goto switch_break;
  case_252: /* CIL Label */ 
  {
#line 3117
  check_spec_constr(typeh[type_spec_count], (yyvsp + -3)->mystring);
  }
#line 3118
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 3119
    type___6 = (typeh[type_spec_count])->output;
  } else {
#line 3121
    type___6 = typeh[type_spec_count];
  }
  {
#line 3124
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 3124
    if (! (1028U == (unsigned int )type___6->attribute.function_class)) {
#line 3124
      goto while_break___30;
    }
#line 3125
    type___6 = type___6->output;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 3126
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 3127
    typedef_copy(type___6);
    }
  } else {
#line 3129
    typeh[type_spec_count] = type___6;
  }
  {
#line 3130
  param_flag = 0;
#line 3131
  lookup_tables((yyvsp + -3)->mystring, variable);
  }
#line 3133
  goto switch_break;
  case_254: /* CIL Label */ 
#line 3140
  tmp___172 = type_spec_count;
#line 3140
  type_spec_count --;
#line 3140
  typeh[tmp___172] = (struct internal_type *)((void *)0);
#line 3142
  goto switch_break;
  case_255: /* CIL Label */ 
#line 3144
  tmp___173 = type_spec_count;
#line 3144
  type_spec_count --;
#line 3144
  typeh[tmp___173] = (struct internal_type *)((void *)0);
#line 3146
  goto switch_break;
  case_257: /* CIL Label */ 
#line 3149
  tmp___174 = type_spec_count;
#line 3149
  type_spec_count --;
#line 3149
  typeh[tmp___174] = (struct internal_type *)((void *)0);
#line 3151
  goto switch_break;
  case_258___4: /* CIL Label */ 
#line 3153
  tmp___175 = type_spec_count;
#line 3153
  type_spec_count --;
#line 3153
  typeh[tmp___175] = (struct internal_type *)((void *)0);
#line 3155
  goto switch_break;
  case_262: /* CIL Label */ 
#line 3162
  if (! (2048U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 3162
    if (! (2049U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 3162
      if (! (8192U == (unsigned int )(type_com[set])->attribute.storage_class_specifier)) {
        {
#line 3183
        if ((unsigned int )type_ac[set] == 258U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 130U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 2U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 32U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 80U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 64U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 268U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 140U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 12U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 280U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 152U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 24U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 264U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 136U) {
#line 3183
          goto case_258___5;
        }
#line 3183
        if ((unsigned int )type_ac[set] == 8U) {
#line 3183
          goto case_258___5;
        }
#line 3186
        if ((unsigned int )type_ac[set] == 1U) {
#line 3186
          goto case_1___5;
        }
#line 3188
        goto switch_default___4;
        case_258___5: /* CIL Label */ 
        case_130___4: /* CIL Label */ 
        case_2___4: /* CIL Label */ 
        case_32___5: /* CIL Label */ 
        case_80___4: /* CIL Label */ 
        case_64___5: /* CIL Label */ 
        case_268___4: /* CIL Label */ 
        case_140___5: /* CIL Label */ 
        case_12___4: /* CIL Label */ 
        case_280___4: /* CIL Label */ 
        case_152___4: /* CIL Label */ 
        case_24___4: /* CIL Label */ 
        case_264___4: /* CIL Label */ 
        case_136___5: /* CIL Label */ 
        case_8___4: /* CIL Label */ 
#line 3184
        ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 3184
        ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3184
        kodp += sizeof(struct OPERAND_0_mi );
#line 3184
        last_instr = current_instr;
#line 3184
        current_instr = kodp;
#line 3185
        goto switch_break___5;
        case_1___5: /* CIL Label */ 
#line 3187
        goto switch_break___5;
        switch_default___4: /* CIL Label */ 
        {
#line 3189
        fprintfx(stderr, "%s:%d:\n", "ys.y", 3189);
#line 3190
        error_message(5000);
        }
#line 3191
        return (0);
        switch_break___5: /* CIL Label */ ;
        }
        {
#line 3193
        ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 3193
        kodp += sizeof(struct OPERAND_0_ma );
#line 3193
        last_instr = current_instr;
#line 3193
        current_instr = kodp;
#line 3194
        noninitialized_loc(variable[set].name);
        }
      }
    }
  }
#line 3196
  is_address = 0;
#line 3197
  variable[set].adr = (char *)((void *)0);
#line 3197
  variable[set].offset = 0;
#line 3198
  subscript_flag[set] = 0;
#line 3198
  struct_union_field[set] = 0;
#line 3198
  type_ac[set] = (enum intern_arit_class )0;
#line 3198
  tmp___176 = set;
#line 3198
  set --;
#line 3198
  type_com[tmp___176] = (struct internal_type *)((void *)0);
#line 3198
  if (0 > set) {
    {
#line 3198
    error_message(5003);
    }
  }
  {
#line 3199
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 3199
    if (! (-1 != dim[poc])) {
#line 3199
      goto while_break___31;
    }
#line 3199
    tmp___177 = poc;
#line 3199
    poc --;
#line 3199
    dim[tmp___177] = -1;
  }
  while_break___31: /* CIL Label */ ;
  }
#line 3201
  goto switch_break;
  case_263: /* CIL Label */ 
#line 3206
  if (8192U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
    {
#line 3207
    error_message(1037, text);
    }
  }
#line 3212
  if (1024U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 3214
    tmp___178 = l_value_cast();
    }
#line 3214
    if (-1 == tmp___178) {
#line 3215
      no_compile_only = 0;
    }
#line 3216
    variable[set].adr = (char *)((void *)0);
#line 3216
    variable[set].offset = 0;
#line 3217
    subscript_flag[set] = 0;
#line 3217
    struct_union_field[set] = 0;
#line 3217
    type_ac[set] = (enum intern_arit_class )0;
#line 3217
    tmp___179 = set;
#line 3217
    set --;
#line 3217
    type_com[tmp___179] = (struct internal_type *)((void *)0);
#line 3217
    if (0 > set) {
      {
#line 3217
      error_message(5003);
      }
    }
    {
#line 3218
    move2lvalue();
    }
  } else
#line 3220
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 3222
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 3222
      if (! (-1 != dim[poc])) {
#line 3222
        goto while_break___32;
      }
#line 3222
      tmp___180 = poc;
#line 3222
      poc --;
#line 3222
      dim[tmp___180] = -1;
    }
    while_break___32: /* CIL Label */ ;
    }
#line 3223
    if (4096U == (unsigned int )(type_com[set])->attribute.type_qualifier) {
#line 3225
      (type_com[set - 1])->attribute.domain = (type_com[set])->attribute.domain;
#line 3227
      if (! (type_com[set - 1])->attribute.memory_size) {
#line 3228
        (type_com[set - 1])->attribute.memory_size = (type_com[set])->attribute.memory_size;
      }
#line 3233
      i___3 = 0;
      {
#line 3233
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 3233
        if (! (i___3 < (type_com[set])->attribute.memory_size)) {
#line 3233
          goto while_break___33;
        }
#line 3237
        ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3237
        ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3237
        ((struct OPERAND_1_i *)kodp)->num = i___3;
#line 3237
        kodp += sizeof(struct OPERAND_1_i );
#line 3237
        last_instr = current_instr;
#line 3237
        current_instr = kodp;
#line 3238
        ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3238
        ((struct OPERAND_0_mi *)kodp)->minor = 11;
#line 3238
        kodp += sizeof(struct OPERAND_0_mi );
#line 3238
        last_instr = current_instr;
#line 3238
        current_instr = kodp;
#line 3233
        i___3 ++;
      }
      while_break___33: /* CIL Label */ ;
      }
#line 3240
      if (! (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class)) {
#line 3242
        ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 3242
        ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3242
        kodp += sizeof(struct OPERAND_0_mi );
#line 3242
        last_instr = current_instr;
#line 3242
        current_instr = kodp;
#line 3243
        variable[set].adr = (char *)((void *)0);
#line 3243
        variable[set].offset = 0;
#line 3244
        subscript_flag[set] = 0;
#line 3244
        struct_union_field[set] = 0;
#line 3244
        type_ac[set] = (enum intern_arit_class )0;
#line 3244
        tmp___181 = set;
#line 3244
        set --;
#line 3244
        type_com[tmp___181] = (struct internal_type *)((void *)0);
#line 3244
        if (0 > set) {
          {
#line 3244
          error_message(5003);
          }
        }
      }
#line 3246
      if (2U & (unsigned int )((type_com[set])->output)->attribute.arit_class) {
#line 3246
        if (proc) {
#line 3247
          (num_args[proc]) --;
        }
      }
    } else
#line 3250
    if (! (type_com[set])->attribute.memory_size) {
      {
#line 3252
      (type_com[set])->attribute.memory_size = initialize_only * ((type_com[set])->output)->attribute.memory_size;
#line 3255
      poc ++;
#line 3255
      dim[poc] = initialize_only;
#line 3256
      put_array_subscript(& type_com[set]);
      }
    }
#line 3258
    if (set > 1) {
#line 3258
      if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
#line 3261
        ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3261
        ((struct OPERAND_0_mi *)kodp)->minor = 13;
#line 3261
        kodp += sizeof(struct OPERAND_0_mi );
#line 3261
        last_instr = current_instr;
#line 3261
        current_instr = kodp;
#line 3262
        variable[set].adr = (char *)((void *)0);
#line 3262
        variable[set].offset = 0;
#line 3263
        subscript_flag[set] = 0;
#line 3263
        struct_union_field[set] = 0;
#line 3263
        type_ac[set] = (enum intern_arit_class )0;
#line 3263
        tmp___182 = set;
#line 3263
        set --;
#line 3263
        type_com[tmp___182] = (struct internal_type *)((void *)0);
#line 3263
        if (0 > set) {
          {
#line 3263
          error_message(5003);
          }
        }
      }
    }
  }
  {
#line 3284
  if ((unsigned int )type_ac[set] == 258U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 130U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 2U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 32U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 80U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 64U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 268U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 140U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 12U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 280U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 152U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 24U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 264U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 136U) {
#line 3284
    goto case_258___6;
  }
#line 3284
  if ((unsigned int )type_ac[set] == 8U) {
#line 3284
    goto case_258___6;
  }
#line 3287
  if ((unsigned int )type_ac[set] == 1U) {
#line 3287
    goto case_1___6;
  }
#line 3289
  goto switch_default___5;
  case_258___6: /* CIL Label */ 
  case_130___5: /* CIL Label */ 
  case_2___5: /* CIL Label */ 
  case_32___6: /* CIL Label */ 
  case_80___5: /* CIL Label */ 
  case_64___6: /* CIL Label */ 
  case_268___5: /* CIL Label */ 
  case_140___6: /* CIL Label */ 
  case_12___5: /* CIL Label */ 
  case_280___5: /* CIL Label */ 
  case_152___5: /* CIL Label */ 
  case_24___5: /* CIL Label */ 
  case_264___5: /* CIL Label */ 
  case_136___6: /* CIL Label */ 
  case_8___5: /* CIL Label */ 
#line 3285
  ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 3285
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3285
  kodp += sizeof(struct OPERAND_0_mi );
#line 3285
  last_instr = current_instr;
#line 3285
  current_instr = kodp;
#line 3286
  goto switch_break___6;
  case_1___6: /* CIL Label */ 
#line 3288
  goto switch_break___6;
  switch_default___5: /* CIL Label */ 
  {
#line 3290
  fprintfx(stderr, "%s:%d:\n", "ys.y", 3290);
#line 3291
  error_message(5000);
  }
#line 3292
  return (0);
  switch_break___6: /* CIL Label */ ;
  }
#line 3294
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 3294
  kodp += sizeof(struct OPERAND_0_ma );
#line 3294
  last_instr = current_instr;
#line 3294
  current_instr = kodp;
#line 3295
  is_address = 0;
#line 3296
  if (handle_main) {
#line 3297
    initialize_only = 1;
  }
#line 3298
  if (8195U == (unsigned int )(typeh[type_spec_count])->attribute.storage_class_specifier) {
#line 3306
    pc = ((struct OPERAND_1_ma *)jmp1)->adr;
#line 3307
    ((struct OPERAND_0_ma *)kodp)->major = 35;
#line 3307
    kodp += sizeof(struct OPERAND_0_ma );
#line 3307
    last_instr = current_instr;
#line 3307
    current_instr = kodp;
#line 3308
    if (no_compile_only) {
#line 3308
      if (! handle_main) {
#line 3308
        goto _L___6;
      } else
#line 3308
      if (initialize_only) {
        _L___6: /* CIL Label */ 
        {
#line 3312
        virtual_machine_suspended = 0;
#line 3314
        tmp___183 = exec();
        }
#line 3314
        if (0 == tmp___183) {
#line 3315
          return (0);
        }
#line 3317
        virtual_machine_suspended = 1;
      } else {
#line 3308
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 3320
    if (! s) {
#line 3321
      return (0);
    }
#line 3322
    if (initialize_only) {
#line 3322
      initialize_only --;
    }
#line 3324
    if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3325
      ((struct OPERAND_1_ma *)jmp1)->adr += (type_com[set])->attribute.memory_size;
    }
#line 3327
    kodp = ((struct OPERAND_1_ma *)jmp1)->adr;
  }
  {
#line 3329
  set_value(variable[set].name);
#line 3330
  variable[set].adr = (char *)((void *)0);
#line 3330
  variable[set].offset = 0;
#line 3331
  subscript_flag[set] = 0;
#line 3331
  struct_union_field[set] = 0;
#line 3331
  type_ac[set] = (enum intern_arit_class )0;
#line 3331
  tmp___184 = set;
#line 3331
  set --;
#line 3331
  type_com[tmp___184] = (struct internal_type *)((void *)0);
  }
#line 3331
  if (0 > set) {
    {
#line 3331
    error_message(5003);
    }
  }
#line 3333
  goto switch_break;
  case_265: /* CIL Label */ 
#line 3340
  param_flag = 0;
#line 3342
  goto switch_break;
  case_266: /* CIL Label */ 
  {
#line 3348
  (args[proc]) ++;
#line 3349
  tmp___185 = strcmp((char const   *)proc_name_text[proc], "printf");
  }
#line 3349
  if (tmp___185) {
    {
#line 3349
    tmp___186 = strcmp((char const   *)proc_name_text[proc], "fprintf");
    }
#line 3349
    if (tmp___186) {
      {
#line 3349
      tmp___187 = strcmp((char const   *)proc_name_text[proc], "scanf");
      }
#line 3349
      if (tmp___187) {
        {
#line 3349
        tmp___188 = strcmp((char const   *)proc_name_text[proc], "fscanf");
        }
#line 3349
        if (! tmp___188) {
          {
#line 3356
          compare_format_args(format_args[proc][args[proc]], type_com[set], type_ac[set]);
#line 3359
          format_args[proc][args[proc]] = (FORMAT_ARGS )((void *)0);
          }
        }
      } else {
        {
#line 3356
        compare_format_args(format_args[proc][args[proc]], type_com[set], type_ac[set]);
#line 3359
        format_args[proc][args[proc]] = (FORMAT_ARGS )((void *)0);
        }
      }
    } else {
      {
#line 3356
      compare_format_args(format_args[proc][args[proc]], type_com[set], type_ac[set]);
#line 3359
      format_args[proc][args[proc]] = (FORMAT_ARGS )((void *)0);
      }
    }
  } else {
    {
#line 3356
    compare_format_args(format_args[proc][args[proc]], type_com[set], type_ac[set]);
#line 3359
    format_args[proc][args[proc]] = (FORMAT_ARGS )((void *)0);
    }
  }
#line 3361
  if (1029U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 3363
    error_message(6035);
    }
  } else
#line 3361
  if (1030U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 3363
    error_message(6035);
    }
  }
#line 3364
  if (call_by_value) {
#line 3366
    if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3370
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3370
      ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3370
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3370
      kodp += sizeof(struct OPERAND_1_i );
#line 3371
      count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
    } else
#line 3366
    if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
      {
#line 3366
      tmp___189 = strcmp((char const   *)proc_name_text[proc], "printf");
      }
#line 3366
      if (tmp___189) {
        {
#line 3366
        tmp___190 = strcmp((char const   *)proc_name_text[proc], "fprintf");
        }
#line 3366
        if (tmp___190) {
#line 3366
          goto _L___8;
        } else {
#line 3370
          ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3370
          ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3370
          ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3370
          kodp += sizeof(struct OPERAND_1_i );
#line 3371
          count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
        }
      } else {
#line 3370
        ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3370
        ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3370
        ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3370
        kodp += sizeof(struct OPERAND_1_i );
#line 3371
        count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
      }
    } else
    _L___8: /* CIL Label */ 
#line 3373
    if (1029U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3373
      goto _L___7;
    } else
#line 3373
    if (1030U == (unsigned int )(type_com[set])->attribute.function_class) {
      _L___7: /* CIL Label */ 
#line 3377
      i___4 = count[proc];
      {
#line 3377
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 3377
        if (! (i___4 < (type_com[set])->attribute.memory_size)) {
#line 3377
          goto while_break___34;
        }
#line 3381
        ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3381
        ((struct OPERAND_1_i *)kodp)->minor = 771;
#line 3381
        ((struct OPERAND_1_i *)kodp)->num = i___4;
#line 3381
        kodp += sizeof(struct OPERAND_1_i );
#line 3381
        last_instr = current_instr;
#line 3381
        current_instr = kodp;
#line 3377
        i___4 ++;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 3383
      count[proc] += (type_com[set])->attribute.memory_size;
#line 3385
      ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 3385
      ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3385
      kodp += sizeof(struct OPERAND_0_mi );
    } else {
      {
#line 3389
      if ((unsigned int )type_ac[set] == 136U) {
#line 3389
        goto case_136___7;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 8U) {
#line 3389
        goto case_136___7;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 264U) {
#line 3389
        goto case_264___6;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 152U) {
#line 3389
        goto case_152___6;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 24U) {
#line 3389
        goto case_152___6;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 280U) {
#line 3389
        goto case_280___6;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 140U) {
#line 3389
        goto case_140___7;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 12U) {
#line 3389
        goto case_140___7;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 268U) {
#line 3389
        goto case_268___6;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 64U) {
#line 3389
        goto case_64___7;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 80U) {
#line 3389
        goto case_80___6;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 32U) {
#line 3389
        goto case_32___7;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 2U) {
#line 3389
        goto case_2___6;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 130U) {
#line 3389
        goto case_130___6;
      }
#line 3389
      if ((unsigned int )type_ac[set] == 258U) {
#line 3389
        goto case_258___7;
      }
#line 3389
      goto switch_default___6;
      case_136___7: /* CIL Label */ 
      case_8___6: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 2;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_264___6: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 3;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_152___6: /* CIL Label */ 
      case_24___6: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 4;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_280___6: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 5;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_140___7: /* CIL Label */ 
      case_12___6: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 6;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_268___6: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 7;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_64___7: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 256;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_80___6: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 257;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_32___7: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 512;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_2___6: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 768;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_130___6: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 769;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      case_258___7: /* CIL Label */ 
#line 3389
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3389
      ((struct OPERAND_1_i *)kodp)->minor = 770;
#line 3389
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3389
      kodp += sizeof(struct OPERAND_1_i );
#line 3389
      goto switch_break___7;
      switch_default___6: /* CIL Label */ 
      {
#line 3389
      fprintfx(stderr, "%s:%d:\n", "ys.y", 3389);
#line 3389
      error_message(5000);
      }
#line 3389
      return (0);
      switch_break___7: /* CIL Label */ ;
      }
#line 3390
      if (2048U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3392
        count[proc] += ((type_com[set])->output)->attribute.memory_size;
      } else
#line 3390
      if (2049U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3392
        count[proc] += ((type_com[set])->output)->attribute.memory_size;
      } else {
#line 3395
        count[proc] += (type_com[set])->attribute.memory_size;
      }
    }
#line 3398
    if ((unsigned long )count[proc] % sizeof(int ) > 0UL) {
#line 3399
      count[proc] = (int )((unsigned long )count[proc] + (sizeof(int ) - (unsigned long )count[proc] % sizeof(int )));
    }
  } else
#line 3402
  if (call_by_reference) {
#line 3404
    ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3404
    ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3404
    ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3404
    kodp += sizeof(struct OPERAND_1_i );
#line 3405
    count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
  }
#line 3407
  last_instr = current_instr;
#line 3407
  current_instr = kodp;
#line 3407
  param_flag = 0;
#line 3411
  if (2050 == (type_com[set - 1])->attribute.export_type) {
    {
#line 3413
    ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3413
    ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3413
    ((struct OPERAND_1_i *)kodp)->num = type_transform(type_ac[set], (type_com[set])->attribute.function_class,
                                                       atom_type_flag);
#line 3413
    kodp += sizeof(struct OPERAND_1_i );
#line 3416
    last_instr = current_instr;
#line 3416
    current_instr = kodp;
    }
#line 3417
    if (call_by_value) {
#line 3419
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3419
      ((struct OPERAND_1_i *)kodp)->minor = 2;
#line 3419
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3419
      kodp += sizeof(struct OPERAND_1_i );
#line 3420
      count[proc] = (int )((unsigned long )count[proc] + sizeof(int ));
    } else
#line 3422
    if (call_by_reference) {
#line 3424
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3424
      ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3424
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3424
      kodp += sizeof(struct OPERAND_1_i );
#line 3425
      count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
    }
#line 3427
    last_instr = current_instr;
#line 3427
    current_instr = kodp;
  }
#line 3429
  atom_type_flag = 0;
#line 3430
  variable[set].adr = (char *)((void *)0);
#line 3430
  variable[set].offset = 0;
#line 3431
  subscript_flag[set] = 0;
#line 3431
  struct_union_field[set] = 0;
#line 3431
  type_ac[set] = (enum intern_arit_class )0;
#line 3431
  tmp___191 = set;
#line 3431
  set --;
#line 3431
  type_com[tmp___191] = (struct internal_type *)((void *)0);
#line 3431
  if (0 > set) {
    {
#line 3431
    error_message(5003);
    }
  }
#line 3432
  is_address = 0;
#line 3434
  goto switch_break;
  case_267: /* CIL Label */ 
  {
#line 3437
  (args[proc]) ++;
#line 3438
  tmp___192 = strcmp((char const   *)proc_name_text[proc], "printf");
  }
#line 3438
  if (tmp___192) {
    {
#line 3438
    tmp___193 = strcmp((char const   *)proc_name_text[proc], "fprintf");
    }
#line 3438
    if (tmp___193) {
      {
#line 3438
      tmp___194 = strcmp((char const   *)proc_name_text[proc], "scanf");
      }
#line 3438
      if (tmp___194) {
        {
#line 3438
        tmp___195 = strcmp((char const   *)proc_name_text[proc], "fscanf");
        }
#line 3438
        if (! tmp___195) {
          {
#line 3445
          compare_format_args(format_args[proc][args[proc]], type_com[set], type_ac[set]);
#line 3448
          format_args[proc][args[proc]] = (FORMAT_ARGS )((void *)0);
          }
        }
      } else {
        {
#line 3445
        compare_format_args(format_args[proc][args[proc]], type_com[set], type_ac[set]);
#line 3448
        format_args[proc][args[proc]] = (FORMAT_ARGS )((void *)0);
        }
      }
    } else {
      {
#line 3445
      compare_format_args(format_args[proc][args[proc]], type_com[set], type_ac[set]);
#line 3448
      format_args[proc][args[proc]] = (FORMAT_ARGS )((void *)0);
      }
    }
  } else {
    {
#line 3445
    compare_format_args(format_args[proc][args[proc]], type_com[set], type_ac[set]);
#line 3448
    format_args[proc][args[proc]] = (FORMAT_ARGS )((void *)0);
    }
  }
#line 3450
  if (1029U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 3452
    error_message(6035);
    }
  } else
#line 3450
  if (1030U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 3452
    error_message(6035);
    }
  }
#line 3453
  if (call_by_value) {
#line 3455
    if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3459
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3459
      ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3459
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3459
      kodp += sizeof(struct OPERAND_1_i );
#line 3460
      count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
    } else
#line 3455
    if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
      {
#line 3455
      tmp___196 = strcmp((char const   *)proc_name_text[proc], "printf");
      }
#line 3455
      if (tmp___196) {
        {
#line 3455
        tmp___197 = strcmp((char const   *)proc_name_text[proc], "fprintf");
        }
#line 3455
        if (tmp___197) {
#line 3455
          goto _L___10;
        } else {
#line 3459
          ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3459
          ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3459
          ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3459
          kodp += sizeof(struct OPERAND_1_i );
#line 3460
          count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
        }
      } else {
#line 3459
        ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3459
        ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3459
        ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3459
        kodp += sizeof(struct OPERAND_1_i );
#line 3460
        count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
      }
    } else
    _L___10: /* CIL Label */ 
#line 3462
    if (1029U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3462
      goto _L___9;
    } else
#line 3462
    if (1030U == (unsigned int )(type_com[set])->attribute.function_class) {
      _L___9: /* CIL Label */ 
#line 3466
      i___5 = count[proc];
      {
#line 3466
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 3466
        if (! (i___5 < (type_com[set])->attribute.memory_size)) {
#line 3466
          goto while_break___35;
        }
#line 3470
        ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3470
        ((struct OPERAND_1_i *)kodp)->minor = 771;
#line 3470
        ((struct OPERAND_1_i *)kodp)->num = i___5;
#line 3470
        kodp += sizeof(struct OPERAND_1_i );
#line 3470
        last_instr = current_instr;
#line 3470
        current_instr = kodp;
#line 3466
        i___5 ++;
      }
      while_break___35: /* CIL Label */ ;
      }
#line 3472
      count[proc] += (type_com[set])->attribute.memory_size;
#line 3474
      ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 3474
      ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3474
      kodp += sizeof(struct OPERAND_0_mi );
    } else {
      {
#line 3478
      if ((unsigned int )type_ac[set] == 136U) {
#line 3478
        goto case_136___8;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 8U) {
#line 3478
        goto case_136___8;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 264U) {
#line 3478
        goto case_264___7;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 152U) {
#line 3478
        goto case_152___7;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 24U) {
#line 3478
        goto case_152___7;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 280U) {
#line 3478
        goto case_280___7;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 140U) {
#line 3478
        goto case_140___8;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 12U) {
#line 3478
        goto case_140___8;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 268U) {
#line 3478
        goto case_268___7;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 64U) {
#line 3478
        goto case_64___8;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 80U) {
#line 3478
        goto case_80___7;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 32U) {
#line 3478
        goto case_32___8;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 2U) {
#line 3478
        goto case_2___7;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 130U) {
#line 3478
        goto case_130___7;
      }
#line 3478
      if ((unsigned int )type_ac[set] == 258U) {
#line 3478
        goto case_258___8;
      }
#line 3478
      goto switch_default___7;
      case_136___8: /* CIL Label */ 
      case_8___7: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 2;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_264___7: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 3;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_152___7: /* CIL Label */ 
      case_24___7: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 4;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_280___7: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 5;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_140___8: /* CIL Label */ 
      case_12___7: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 6;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_268___7: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 7;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_64___8: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 256;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_80___7: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 257;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_32___8: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 512;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_2___7: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 768;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_130___7: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 769;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      case_258___8: /* CIL Label */ 
#line 3478
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3478
      ((struct OPERAND_1_i *)kodp)->minor = 770;
#line 3478
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3478
      kodp += sizeof(struct OPERAND_1_i );
#line 3478
      goto switch_break___8;
      switch_default___7: /* CIL Label */ 
      {
#line 3478
      fprintfx(stderr, "%s:%d:\n", "ys.y", 3478);
#line 3478
      error_message(5000);
      }
#line 3478
      return (0);
      switch_break___8: /* CIL Label */ ;
      }
#line 3479
      if (2048U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3481
        count[proc] += ((type_com[set])->output)->attribute.memory_size;
      } else
#line 3479
      if (2049U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3481
        count[proc] += ((type_com[set])->output)->attribute.memory_size;
      } else {
#line 3484
        count[proc] += (type_com[set])->attribute.memory_size;
      }
    }
#line 3487
    if ((unsigned long )count[proc] % sizeof(int ) > 0UL) {
#line 3488
      count[proc] = (int )((unsigned long )count[proc] + (sizeof(int ) - (unsigned long )count[proc] % sizeof(int )));
    }
  } else
#line 3491
  if (call_by_reference) {
#line 3493
    ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3493
    ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3493
    ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3493
    kodp += sizeof(struct OPERAND_1_i );
#line 3494
    count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
  }
#line 3496
  last_instr = current_instr;
#line 3496
  current_instr = kodp;
#line 3497
  if (2050 == (type_com[set - 1])->attribute.export_type) {
    {
#line 3499
    ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3499
    ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3499
    ((struct OPERAND_1_i *)kodp)->num = type_transform(type_ac[set], (type_com[set])->attribute.function_class,
                                                       atom_type_flag);
#line 3499
    kodp += sizeof(struct OPERAND_1_i );
#line 3502
    last_instr = current_instr;
#line 3502
    current_instr = kodp;
    }
#line 3503
    if (call_by_value) {
      {
#line 3505
      if ((unsigned int )type_ac[set] == 136U) {
#line 3505
        goto case_136___9;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 8U) {
#line 3505
        goto case_136___9;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 264U) {
#line 3505
        goto case_264___8;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 152U) {
#line 3505
        goto case_152___8;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 24U) {
#line 3505
        goto case_152___8;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 280U) {
#line 3505
        goto case_280___8;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 140U) {
#line 3505
        goto case_140___9;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 12U) {
#line 3505
        goto case_140___9;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 268U) {
#line 3505
        goto case_268___8;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 64U) {
#line 3505
        goto case_64___9;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 80U) {
#line 3505
        goto case_80___8;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 32U) {
#line 3505
        goto case_32___9;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 2U) {
#line 3505
        goto case_2___8;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 130U) {
#line 3505
        goto case_130___8;
      }
#line 3505
      if ((unsigned int )type_ac[set] == 258U) {
#line 3505
        goto case_258___9;
      }
#line 3505
      goto switch_default___8;
      case_136___9: /* CIL Label */ 
      case_8___8: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 2;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_264___8: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 3;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_152___8: /* CIL Label */ 
      case_24___8: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 4;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_280___8: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 5;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_140___9: /* CIL Label */ 
      case_12___8: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 6;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_268___8: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 7;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_64___9: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 256;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_80___8: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 257;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_32___9: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 512;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_2___8: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 768;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_130___8: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 769;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      case_258___9: /* CIL Label */ 
#line 3505
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3505
      ((struct OPERAND_1_i *)kodp)->minor = 770;
#line 3505
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3505
      kodp += sizeof(struct OPERAND_1_i );
#line 3505
      goto switch_break___9;
      switch_default___8: /* CIL Label */ 
      {
#line 3505
      fprintfx(stderr, "%s:%d:\n", "ys.y", 3505);
#line 3505
      error_message(5000);
      }
#line 3505
      return (0);
      switch_break___9: /* CIL Label */ ;
      }
#line 3506
      count[proc] = (int )((unsigned long )count[proc] + sizeof(int ));
    } else
#line 3508
    if (call_by_reference) {
#line 3510
      ((struct OPERAND_1_i *)kodp)->major = 40;
#line 3510
      ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 3510
      ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 3510
      kodp += sizeof(struct OPERAND_1_i );
#line 3511
      count[proc] = (int )((unsigned long )count[proc] + sizeof(char *));
    }
#line 3513
    last_instr = current_instr;
#line 3513
    current_instr = kodp;
  }
#line 3515
  atom_type_flag = 0;
#line 3516
  variable[set].adr = (char *)((void *)0);
#line 3516
  variable[set].offset = 0;
#line 3517
  subscript_flag[set] = 0;
#line 3517
  struct_union_field[set] = 0;
#line 3517
  type_ac[set] = (enum intern_arit_class )0;
#line 3517
  tmp___198 = set;
#line 3517
  set --;
#line 3517
  type_com[tmp___198] = (struct internal_type *)((void *)0);
#line 3517
  if (0 > set) {
    {
#line 3517
    error_message(5003);
    }
  }
#line 3518
  is_address = 0;
#line 3520
  goto switch_break;
  case_269: /* CIL Label */ 
  {
#line 3543
  if ((unsigned int )(type_com[set])->attribute.function_class == 1028U) {
#line 3543
    goto case_1028;
  }
#line 3543
  if ((unsigned int )(type_com[set])->attribute.function_class == 2049U) {
#line 3543
    goto case_1028;
  }
#line 3543
  if ((unsigned int )(type_com[set])->attribute.function_class == 2048U) {
#line 3543
    goto case_1028;
  }
#line 3543
  if ((unsigned int )(type_com[set])->attribute.function_class == 1030U) {
#line 3543
    goto case_1028;
  }
#line 3543
  if ((unsigned int )(type_com[set])->attribute.function_class == 1029U) {
#line 3543
    goto case_1028;
  }
#line 3543
  if ((unsigned int )(type_com[set])->attribute.function_class == 1025U) {
#line 3543
    goto case_1028;
  }
#line 3543
  if ((unsigned int )(type_com[set])->attribute.function_class == 1024U) {
#line 3543
    goto case_1028;
  }
#line 3543
  if ((unsigned int )(type_com[set])->attribute.function_class == 1031U) {
#line 3543
    goto case_1028;
  }
#line 3545
  goto switch_default___9;
  case_1028: /* CIL Label */ 
  case_2049: /* CIL Label */ 
  case_2048: /* CIL Label */ 
  case_1030: /* CIL Label */ 
  case_1029: /* CIL Label */ 
  case_1025: /* CIL Label */ 
  case_1024: /* CIL Label */ 
  case_1031: /* CIL Label */ 
#line 3544
  goto switch_break___10;
  switch_default___9: /* CIL Label */ 
  {
#line 3546
  fprintfx(stderr, "%s:%d:\n", "ys.y", 3546);
#line 3547
  error_message(5000);
  }
#line 3547
  return (0);
  switch_break___10: /* CIL Label */ ;
  }
#line 3550
  goto switch_break;
  case_270: /* CIL Label */ 
  {
#line 3556
  ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3556
  ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3556
  ((struct OPERAND_1_i *)kodp)->num = (yyvsp + 0)->myint;
#line 3556
  kodp += sizeof(struct OPERAND_1_i );
#line 3556
  last_instr = current_instr;
#line 3556
  current_instr = kodp;
#line 3557
  set ++;
#line 3557
  type_ac[set] = (enum intern_arit_class )8;
#line 3558
  tmp___199 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3558
  type_com[set] = (struct internal_type *)tmp___199;
#line 3560
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3562
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 3563
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3564
  (type_com[set])->attribute.arit_class = (enum intern_arit_class )8;
#line 3565
  (type_com[set])->attribute.memory_size = (int )sizeof(int );
  }
#line 3566
  if (it_is_in_case) {
    {
#line 3566
    tmp___200 = add_constant_to_list((yyvsp + 0)->myint);
    }
#line 3566
    if (-1 == tmp___200) {
#line 3568
      return (0);
    } else {
#line 3570
      (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_i *)(kodp - sizeof(struct OPERAND_1_i )))->num);
    }
  } else {
#line 3570
    (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_i *)(kodp - sizeof(struct OPERAND_1_i )))->num);
  }
#line 3574
  goto switch_break;
  case_271: /* CIL Label */ 
  {
#line 3577
  ((struct OPERAND_1_ui *)kodp)->major = 32;
#line 3577
  ((struct OPERAND_1_ui *)kodp)->minor = 1;
#line 3577
  ((struct OPERAND_1_ui *)kodp)->num = (yyvsp + 0)->myuint;
#line 3577
  kodp += sizeof(struct OPERAND_1_ui );
#line 3577
  last_instr = current_instr;
#line 3577
  current_instr = kodp;
#line 3578
  set ++;
#line 3578
  type_ac[set] = (enum intern_arit_class )264;
#line 3579
  tmp___201 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3579
  type_com[set] = (struct internal_type *)tmp___201;
#line 3581
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3583
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 3584
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3585
  (type_com[set])->attribute.arit_class = type_ac[set];
#line 3586
  (type_com[set])->attribute.memory_size = (int )sizeof(unsigned int );
  }
#line 3588
  if (it_is_in_case) {
    {
#line 3588
    tmp___202 = add_constant_to_list((int )(yyvsp + 0)->myuint);
    }
#line 3588
    if (-1 == tmp___202) {
#line 3590
      return (0);
    } else {
#line 3592
      (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_ui *)(kodp - sizeof(struct OPERAND_1_ui )))->num);
    }
  } else {
#line 3592
    (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_ui *)(kodp - sizeof(struct OPERAND_1_ui )))->num);
  }
#line 3596
  goto switch_break;
  case_272: /* CIL Label */ 
  {
#line 3599
  ((struct OPERAND_1_li *)kodp)->major = 32;
#line 3599
  ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 3599
  ((struct OPERAND_1_li *)kodp)->num = (yyvsp + 0)->mylint;
#line 3599
  kodp += sizeof(struct OPERAND_1_li );
#line 3599
  last_instr = current_instr;
#line 3599
  current_instr = kodp;
#line 3600
  set ++;
#line 3600
  type_ac[set] = (enum intern_arit_class )24;
#line 3601
  tmp___203 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3601
  type_com[set] = (struct internal_type *)tmp___203;
#line 3603
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3605
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 3606
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3607
  (type_com[set])->attribute.arit_class = type_ac[set];
#line 3608
  (type_com[set])->attribute.memory_size = (int )sizeof(long );
  }
#line 3610
  if (it_is_in_case) {
    {
#line 3610
    tmp___204 = add_constant_to_list((int )(yyvsp + 0)->mylint);
    }
#line 3610
    if (-1 == tmp___204) {
#line 3612
      return (0);
    } else {
#line 3614
      (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_li *)(kodp - sizeof(struct OPERAND_1_li )))->num);
    }
  } else {
#line 3614
    (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_li *)(kodp - sizeof(struct OPERAND_1_li )))->num);
  }
#line 3618
  goto switch_break;
  case_273: /* CIL Label */ 
  {
#line 3621
  ((struct OPERAND_1_lui *)kodp)->major = 32;
#line 3621
  ((struct OPERAND_1_lui *)kodp)->minor = 3;
#line 3621
  ((struct OPERAND_1_lui *)kodp)->num = (yyvsp + 0)->myluint;
#line 3621
  kodp += sizeof(struct OPERAND_1_lui );
#line 3621
  last_instr = current_instr;
#line 3621
  current_instr = kodp;
#line 3622
  set ++;
#line 3622
  type_ac[set] = (enum intern_arit_class )280;
#line 3623
  tmp___205 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3623
  type_com[set] = (struct internal_type *)tmp___205;
#line 3625
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3627
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 3628
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3629
  (type_com[set])->attribute.arit_class = type_ac[set];
#line 3630
  (type_com[set])->attribute.memory_size = (int )sizeof(unsigned long );
  }
#line 3632
  if (it_is_in_case) {
    {
#line 3632
    tmp___206 = add_constant_to_list((int )(yyvsp + 0)->myluint);
    }
#line 3632
    if (-1 == tmp___206) {
#line 3634
      return (0);
    } else {
#line 3636
      (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_lui *)(kodp - sizeof(struct OPERAND_1_lui )))->num);
    }
  } else {
#line 3636
    (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_lui *)(kodp - sizeof(struct OPERAND_1_lui )))->num);
  }
#line 3640
  goto switch_break;
  case_274: /* CIL Label */ 
  {
#line 3643
  ((struct OPERAND_1_id *)kodp)->major = 32;
#line 3643
  ((struct OPERAND_1_id *)kodp)->minor = 256;
#line 3643
  kodp += sizeof(struct OPERAND_0_mi );
#line 3643
  align_memory(& kodp, (int )sizeof(double ));
#line 3643
  *((double *)kodp) = (yyvsp + 0)->mydouble;
#line 3643
  kodp += sizeof(double );
#line 3643
  last_instr = current_instr;
#line 3643
  current_instr = kodp;
#line 3644
  set ++;
#line 3644
  type_ac[set] = (enum intern_arit_class )64;
#line 3645
  tmp___207 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3645
  type_com[set] = (struct internal_type *)tmp___207;
#line 3647
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3649
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 3650
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3651
  (type_com[set])->attribute.arit_class = type_ac[set];
#line 3652
  (type_com[set])->attribute.memory_size = (int )sizeof(double );
#line 3654
  (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_id *)(kodp - sizeof(struct OPERAND_1_id )))->num);
  }
#line 3658
  goto switch_break;
  case_275: /* CIL Label */ 
  {
#line 3661
  ((struct OPERAND_1_ild *)kodp)->major = 32;
#line 3661
  ((struct OPERAND_1_ild *)kodp)->minor = 257;
#line 3661
  kodp += sizeof(struct OPERAND_0_mi );
#line 3661
  align_memory(& kodp, (int )sizeof(long double ));
#line 3661
  *((long double *)kodp) = (yyvsp + 0)->myldouble;
#line 3661
  kodp += sizeof(long double );
#line 3661
  last_instr = current_instr;
#line 3661
  current_instr = kodp;
#line 3662
  set ++;
#line 3662
  type_ac[set] = (enum intern_arit_class )80;
#line 3663
  tmp___208 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3663
  type_com[set] = (struct internal_type *)tmp___208;
#line 3665
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3667
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 3668
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3669
  (type_com[set])->attribute.arit_class = type_ac[set];
#line 3670
  (type_com[set])->attribute.memory_size = (int )sizeof(long double );
#line 3672
  (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_ild *)(kodp - sizeof(struct OPERAND_1_ild )))->num);
  }
#line 3676
  goto switch_break;
  case_276: /* CIL Label */ 
  {
#line 3679
  ((struct OPERAND_1_if *)kodp)->major = 32;
#line 3679
  ((struct OPERAND_1_if *)kodp)->minor = 512;
#line 3679
  kodp += sizeof(struct OPERAND_0_mi );
#line 3679
  align_memory(& kodp, (int )sizeof(float ));
#line 3679
  *((float *)kodp) = (yyvsp + 0)->myfloat;
#line 3679
  kodp += sizeof(float );
#line 3679
  last_instr = current_instr;
#line 3679
  current_instr = kodp;
#line 3680
  set ++;
#line 3680
  type_ac[set] = (enum intern_arit_class )32;
#line 3681
  tmp___209 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3681
  type_com[set] = (struct internal_type *)tmp___209;
#line 3683
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3685
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 3686
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3687
  (type_com[set])->attribute.arit_class = type_ac[set];
#line 3688
  (type_com[set])->attribute.memory_size = (int )sizeof(float );
#line 3690
  (type_com[set])->attribute.domain = (char *)(& ((struct OPERAND_1_if *)(kodp - sizeof(struct OPERAND_1_if )))->num);
  }
#line 3694
  goto switch_break;
  case_277: /* CIL Label */ 
  {
#line 3697
  ((struct OPERAND_1_mi *)kodp)->major = 32;
#line 3697
  ((struct OPERAND_1_mi *)kodp)->minor = 769;
#line 3697
  ((struct OPERAND_1_mi *)kodp)->adr = (yyvsp + 0)->mystring;
#line 3697
  kodp += sizeof(struct OPERAND_1_mi );
#line 3697
  last_instr = current_instr;
#line 3697
  current_instr = kodp;
#line 3698
  set ++;
#line 3698
  type_ac[set] = (enum intern_arit_class )2;
#line 3699
  tmp___210 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3699
  type_com[set] = (struct internal_type *)tmp___210;
#line 3701
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3703
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3704
  (type_com[set])->attribute.function_class = (enum intern_func_class )1025;
#line 3705
  tmp___211 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3705
  (type_com[set])->output = (struct internal_type *)tmp___211;
#line 3707
  init_zero((char *)(type_com[set])->output, (unsigned int )sizeof(struct internal_type ));
#line 3709
  ((type_com[set])->output)->attribute.arit_class = type_ac[set];
#line 3711
  (type_com[set])->attribute.domain = ((struct OPERAND_1_mi *)(kodp - sizeof(struct OPERAND_1_mi )))->adr;
#line 3714
  tmp___212 = strlen((char const   *)(yyvsp + 0)->mystring);
#line 3714
  (type_com[set])->attribute.memory_size = (int )(tmp___212 + 1U);
#line 3716
  variable[set].adr = (char *)((void *)0);
#line 3716
  variable[set].offset = 0;
  }
#line 3718
  goto switch_break;
  case_278: /* CIL Label */ 
  {
#line 3721
  set ++;
#line 3721
  tmp___213 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3721
  type_com[set] = (struct internal_type *)tmp___213;
#line 3723
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3725
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3726
  (type_com[set])->attribute.function_class = (enum intern_func_class )1025;
#line 3727
  tmp___214 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3727
  (type_com[set])->output = (struct internal_type *)tmp___214;
#line 3729
  init_zero((char *)(type_com[set])->output, (unsigned int )sizeof(struct internal_type ));
  }
#line 3731
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
#line 3731
    if (8U & (unsigned int )((type_com[set - 1])->output)->attribute.arit_class) {
      {
#line 3734
      tmp___215 = strlen((char const   *)(yyvsp + 0)->mystring);
#line 3734
      j___1 = (int )tmp___215;
#line 3735
      type_ac[set] = (enum intern_arit_class )8;
#line 3736
      i___6 = 1;
      }
      {
#line 3736
      while (1) {
        while_continue___36: /* CIL Label */ ;
#line 3736
        if (! (i___6 < j___1)) {
#line 3736
          goto while_break___36;
        }
        {
#line 3738
        ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3738
        ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 3738
        kodp += sizeof(struct OPERAND_0_mi );
#line 3738
        last_instr = current_instr;
#line 3738
        current_instr = kodp;
#line 3739
        ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3739
        ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3739
        ((struct OPERAND_1_i *)kodp)->num = (int )((unsigned long )(i___6 - 1) * sizeof(int ));
#line 3739
        kodp += sizeof(struct OPERAND_1_i );
#line 3740
        last_instr = current_instr;
#line 3740
        current_instr = kodp;
#line 3741
        ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3741
        ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 3741
        kodp += sizeof(struct OPERAND_0_mi );
#line 3741
        last_instr = current_instr;
#line 3741
        current_instr = kodp;
#line 3742
        ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3742
        ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3742
        ((struct OPERAND_1_i *)kodp)->num = (int )*((yyvsp + 0)->mystring + i___6);
#line 3742
        kodp += sizeof(struct OPERAND_1_i );
#line 3742
        last_instr = current_instr;
#line 3742
        current_instr = kodp;
#line 3743
        move2lvalue();
#line 3744
        ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 3744
        ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3744
        kodp += sizeof(struct OPERAND_0_mi );
#line 3744
        last_instr = current_instr;
#line 3744
        current_instr = kodp;
#line 3736
        i___6 ++;
        }
      }
      while_break___36: /* CIL Label */ ;
      }
#line 3746
      (type_com[set])->attribute.memory_size = (int )((unsigned long )j___1 * sizeof(int ));
#line 3750
      (type_com[set])->attribute.domain = (yyvsp + 0)->mystring + 1;
    } else {
#line 3731
      goto _L___11;
    }
  } else {
    _L___11: /* CIL Label */ 
    {
#line 3756
    ((struct OPERAND_1_mi *)kodp)->major = 32;
#line 3756
    ((struct OPERAND_1_mi *)kodp)->minor = 769;
#line 3756
    ((struct OPERAND_1_mi *)kodp)->adr = (yyvsp + 0)->mystring + 1;
#line 3756
    kodp += sizeof(struct OPERAND_1_mi );
#line 3756
    last_instr = current_instr;
#line 3756
    current_instr = kodp;
#line 3757
    type_ac[set] = (enum intern_arit_class )2;
#line 3758
    tmp___216 = strlen((char const   *)(yyvsp + 0)->mystring);
#line 3758
    (type_com[set])->attribute.memory_size = (int )(tmp___216 + 1U);
#line 3760
    (type_com[set])->attribute.domain = ((struct OPERAND_1_mi *)(kodp - sizeof(struct OPERAND_1_mi )))->adr;
    }
  }
#line 3764
  ((type_com[set])->output)->attribute.arit_class = type_ac[set];
#line 3766
  variable[set].adr = (char *)((void *)0);
#line 3766
  variable[set].offset = 0;
#line 3768
  goto switch_break;
  case_279: /* CIL Label */ 
  {
#line 3771
  ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 3771
  ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 3771
  ((struct OPERAND_1_ic *)kodp)->num = (yyvsp + 0)->mychar;
#line 3771
  kodp += sizeof(struct OPERAND_1_ic );
#line 3771
  align_memory(& kodp, (int )sizeof(int ));
#line 3771
  last_instr = current_instr;
#line 3771
  current_instr = kodp;
#line 3772
  set ++;
#line 3772
  type_ac[set] = (enum intern_arit_class )2;
#line 3773
  tmp___217 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 3773
  type_com[set] = (struct internal_type *)tmp___217;
#line 3775
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 3777
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 3778
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 3779
  (type_com[set])->attribute.arit_class = type_ac[set];
#line 3780
  (type_com[set])->attribute.memory_size = (int )sizeof(char );
#line 3782
  (type_com[set])->attribute.domain = & ((struct OPERAND_1_ic *)(kodp - sizeof(struct OPERAND_1_ic )))->num;
  }
#line 3786
  goto switch_break;
  case_281: /* CIL Label */ 
  {
#line 3792
  lookup_tables((yyvsp + 0)->mystring, variable);
  }
#line 3794
  goto switch_break;
  case_283: /* CIL Label */ 
#line 3800
  if (subscript_flag[set]) {
#line 3805
    atom_type_flag = 1;
#line 3806
    if (1 == poc) {
#line 3808
      ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3808
      ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3808
      ((struct OPERAND_1_i *)kodp)->num = dim[poc];
#line 3808
      kodp += sizeof(struct OPERAND_1_i );
#line 3808
      last_instr = current_instr;
#line 3808
      current_instr = kodp;
#line 3809
      ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 3809
      ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3809
      kodp += sizeof(struct OPERAND_0_mi );
#line 3809
      last_instr = current_instr;
#line 3809
      current_instr = kodp;
#line 3810
      tmp___218 = poc;
#line 3810
      poc --;
#line 3810
      dim[tmp___218] = -1;
    } else
#line 3812
    if (1 < poc) {
#line 3814
      ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3814
      ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3814
      ((struct OPERAND_1_i *)kodp)->num = dim[poc];
#line 3814
      kodp += sizeof(struct OPERAND_1_i );
#line 3814
      last_instr = current_instr;
#line 3814
      current_instr = kodp;
#line 3815
      ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 3815
      ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3815
      kodp += sizeof(struct OPERAND_0_mi );
#line 3815
      last_instr = current_instr;
#line 3815
      current_instr = kodp;
#line 3816
      tmp___219 = poc;
#line 3816
      poc --;
#line 3816
      dim[tmp___219] = -1;
    } else
#line 3818
    if (! (1028U == (unsigned int )(type_com[set])->attribute.function_class)) {
      {
#line 3819
      error_message(2000);
      }
    }
  } else {
#line 3823
    if (poc) {
#line 3824
      tmp___220 = poc;
#line 3824
      poc --;
#line 3824
      dim[tmp___220] = -1;
    }
#line 3825
    if (! (1025U == (unsigned int )(type_com[set])->attribute.function_class)) {
#line 3825
      if (! (1028U == (unsigned int )(type_com[set])->attribute.function_class)) {
        {
#line 3827
        error_message(2000);
        }
      }
    }
#line 3828
    if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3834
      ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3834
      ((struct OPERAND_0_mi *)kodp)->minor = 7;
#line 3834
      kodp += sizeof(struct OPERAND_0_mi );
#line 3834
      last_instr = current_instr;
#line 3834
      current_instr = kodp;
    }
  }
#line 3838
  goto switch_break;
  case_284: /* CIL Label */ 
#line 3840
  if (8U != (unsigned int )type_ac[set]) {
    {
#line 3841
    error_message(2002);
    }
  } else {
#line 3844
    if (subscript_flag[set - 1]) {
#line 3846
      ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3846
      ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3846
      kodp += sizeof(struct OPERAND_0_mi );
#line 3846
      last_instr = current_instr;
#line 3846
      current_instr = kodp;
    }
#line 3848
    (subscript_flag[set - 1]) ++;
  }
#line 3850
  variable[set].adr = (char *)((void *)0);
#line 3850
  variable[set].offset = 0;
#line 3851
  subscript_flag[set] = 0;
#line 3851
  struct_union_field[set] = 0;
#line 3851
  type_ac[set] = (enum intern_arit_class )0;
#line 3851
  tmp___221 = set;
#line 3851
  set --;
#line 3851
  type_com[tmp___221] = (struct internal_type *)((void *)0);
#line 3851
  if (0 > set) {
    {
#line 3851
    error_message(5003);
    }
  }
#line 3852
  if (! poc) {
#line 3854
    (subscript_flag[set]) --;
#line 3855
    ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3855
    ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3855
    ((struct OPERAND_1_i *)kodp)->num = ((type_com[set])->output)->attribute.memory_size;
#line 3855
    kodp += sizeof(struct OPERAND_1_i );
#line 3856
    last_instr = current_instr;
#line 3856
    current_instr = kodp;
#line 3857
    ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 3857
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3857
    kodp += sizeof(struct OPERAND_0_mi );
#line 3857
    last_instr = current_instr;
#line 3857
    current_instr = kodp;
#line 3858
    if (struct_union_field[set]) {
#line 3858
      ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3858
      ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3858
      kodp += sizeof(struct OPERAND_0_mi );
#line 3858
      last_instr = current_instr;
#line 3858
      current_instr = kodp;
    }
#line 3858
    struct_union_field[set] = 0;
#line 3859
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3859
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 3859
    kodp += sizeof(struct OPERAND_0_mi );
#line 3859
    last_instr = current_instr;
#line 3859
    current_instr = kodp;
#line 3860
    kodp3 = kodp;
#line 3861
    type_com[set] = (type_com[set])->output;
#line 3862
    if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3863
      type_ac[set] = (enum intern_arit_class )24;
    } else {
#line 3865
      type_ac[set] = (type_com[set])->attribute.arit_class;
    }
  }
#line 3869
  goto switch_break;
  case_285: /* CIL Label */ 
#line 3875
  aggr_offset = 0;
#line 3877
  if (1029U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3877
    goto _L___14;
  } else
#line 3877
  if (1030U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___14: /* CIL Label */ 
#line 3877
    if ((unsigned long )((void *)0) != (unsigned long )(type_com[set])->input) {
      {
#line 3881
      type_com[set] = (type_com[set])->input;
#line 3882
      aggr_offset = offset_aggregate_ident();
      }
    } else {
#line 3877
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 3884
  if ((unsigned long )((void *)0) != (unsigned long )(type_com[set])->output) {
#line 3884
    if (1029U == (unsigned int )((type_com[set])->output)->attribute.function_class) {
#line 3884
      goto _L___12;
    } else
#line 3884
    if (1030U == (unsigned int )((type_com[set])->output)->attribute.function_class) {
      _L___12: /* CIL Label */ 
#line 3884
      if ((unsigned long )((void *)0) != (unsigned long )((type_com[set])->output)->input) {
#line 3889
        if (subscript_flag[set]) {
#line 3891
          ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3891
          ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3891
          ((struct OPERAND_1_i *)kodp)->num = ((type_com[set])->output)->attribute.memory_size;
#line 3891
          kodp += sizeof(struct OPERAND_1_i );
#line 3892
          last_instr = current_instr;
#line 3892
          current_instr = kodp;
#line 3893
          ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 3893
          ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3893
          kodp += sizeof(struct OPERAND_0_mi );
#line 3893
          last_instr = current_instr;
#line 3893
          current_instr = kodp;
        }
        {
#line 3895
        type_com[set] = ((type_com[set])->output)->input;
#line 3896
        aggr_offset = offset_aggregate_ident();
        }
#line 3897
        if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
          {
#line 3899
          array_subscript((type_com[set])->input);
#line 3900
          type_ac[set] = ((type_com[set])->output)->attribute.arit_class;
          }
        } else
#line 3903
        if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3904
          type_ac[set] = (enum intern_arit_class )24;
        }
      } else {
        {
#line 3908
        text = (yyvsp + 0)->mystring;
#line 3909
        error_message(2009);
        }
      }
    } else {
      {
#line 3908
      text = (yyvsp + 0)->mystring;
#line 3909
      error_message(2009);
      }
    }
  } else {
    {
#line 3908
    text = (yyvsp + 0)->mystring;
#line 3909
    error_message(2009);
    }
  }
#line 3911
  ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3911
  ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3911
  ((struct OPERAND_1_i *)kodp)->num = aggr_offset;
#line 3911
  kodp += sizeof(struct OPERAND_1_i );
#line 3911
  last_instr = current_instr;
#line 3911
  current_instr = kodp;
#line 3912
  if (struct_union_field[set]) {
#line 3914
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3914
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3914
    kodp += sizeof(struct OPERAND_0_mi );
#line 3914
    last_instr = current_instr;
#line 3914
    current_instr = kodp;
#line 3915
    (struct_union_field[set]) --;
  }
#line 3917
  if (subscript_flag[set]) {
#line 3919
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3919
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3919
    kodp += sizeof(struct OPERAND_0_mi );
#line 3919
    last_instr = current_instr;
#line 3919
    current_instr = kodp;
#line 3920
    (subscript_flag[set]) --;
  }
#line 3922
  (struct_union_field[set]) ++;
#line 3924
  goto switch_break;
  case_286: /* CIL Label */ 
#line 3928
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3931
    if (subscript_flag[set] > 0) {
#line 3931
      (subscript_flag[set]) --;
    }
#line 3933
    if ((unsigned long )variable[set].adr != (unsigned long )((void *)0)) {
#line 3933
      goto _L___15;
    } else
#line 3933
    if (variable[set].offset != 0) {
      _L___15: /* CIL Label */ 
#line 3933
      if (! (1024U == (unsigned int )((type_com[set])->output)->attribute.function_class)) {
#line 3937
        if (struct_union_field[set]) {
#line 3939
          ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3939
          ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 3939
          kodp += sizeof(struct OPERAND_0_mi );
#line 3939
          last_instr = current_instr;
#line 3939
          current_instr = kodp;
#line 3940
          (struct_union_field[set]) --;
        }
#line 3942
        ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3942
        ((struct OPERAND_0_mi *)kodp)->minor = 7;
#line 3942
        kodp += sizeof(struct OPERAND_0_mi );
#line 3942
        last_instr = current_instr;
#line 3942
        current_instr = kodp;
      }
    }
#line 3944
    if ((unsigned long )((void *)0) != (unsigned long )((type_com[set])->output)->input) {
      {
#line 3946
      type_com[set] = ((type_com[set])->output)->input;
#line 3947
      type_ac[set] = (type_com[set])->attribute.arit_class;
#line 3949
      aggr_offset___0 = offset_aggregate_ident();
#line 3950
      ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3950
      ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3950
      ((struct OPERAND_1_i *)kodp)->num = aggr_offset___0;
#line 3950
      kodp += sizeof(struct OPERAND_1_i );
#line 3950
      last_instr = current_instr;
#line 3950
      current_instr = kodp;
      }
#line 3952
      if (struct_union_field[set]) {
#line 3954
        ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3954
        ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3954
        kodp += sizeof(struct OPERAND_0_mi );
#line 3954
        last_instr = current_instr;
#line 3954
        current_instr = kodp;
#line 3955
        (struct_union_field[set]) --;
      }
#line 3957
      (struct_union_field[set]) ++;
#line 3958
      if ((unsigned int )type_ac[set] == 0U) {
#line 3959
        type_ac[set] = (enum intern_arit_class )24;
      }
    } else {
      {
#line 3962
      fprintfx(stderr, "FIXME:%d\n", 3962);
      }
    }
  } else {
    {
#line 3965
    error_message(1021);
    }
  }
#line 3967
  goto switch_break;
  case_287: /* CIL Label */ 
#line 3970
  if (struct_union_field[set]) {
#line 3972
    if (variable[set].offset) {
#line 3972
      goto _L___16;
    } else
#line 3972
    if ((unsigned long )variable[set].adr != (unsigned long )((void *)0)) {
      _L___16: /* CIL Label */ 
#line 3972
      if (struct_union_field[set] > 0) {
#line 3972
        (struct_union_field[set]) --;
      }
#line 3972
      if (struct_union_field[set]) {
#line 3972
        ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3972
        ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3972
        kodp += sizeof(struct OPERAND_0_mi );
#line 3972
        last_instr = current_instr;
#line 3972
        current_instr = kodp;
      }
#line 3972
      struct_union_field[set] = 0;
    }
#line 3973
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3973
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 3973
    kodp += sizeof(struct OPERAND_0_mi );
#line 3973
    last_instr = current_instr;
#line 3973
    current_instr = kodp;
#line 3974
    variable[set].adr = (char *)((void *)0);
#line 3975
    variable[set].offset = 0;
  } else
#line 3977
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 3979
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3979
    ((struct OPERAND_0_mi *)kodp)->minor = 18;
#line 3979
    kodp += sizeof(struct OPERAND_0_mi );
#line 3979
    last_instr = current_instr;
#line 3979
    current_instr = kodp;
#line 3980
    ((struct OPERAND_0_ma *)kodp)->major = 52;
#line 3980
    kodp += sizeof(struct OPERAND_0_ma );
#line 3980
    last_instr = current_instr;
#line 3980
    current_instr = kodp;
#line 3981
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3981
    ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 3981
    kodp += sizeof(struct OPERAND_0_mi );
#line 3981
    last_instr = current_instr;
#line 3981
    current_instr = kodp;
#line 3982
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 3982
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 3982
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set])->output)->attribute.memory_size;
#line 3982
    kodp += sizeof(struct OPERAND_1_li );
#line 3983
    last_instr = current_instr;
#line 3983
    current_instr = kodp;
#line 3984
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3984
    ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 3984
    kodp += sizeof(struct OPERAND_0_mi );
#line 3984
    last_instr = current_instr;
#line 3984
    current_instr = kodp;
#line 3985
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3985
    ((struct OPERAND_0_mi *)kodp)->minor = 13;
#line 3985
    kodp += sizeof(struct OPERAND_0_mi );
#line 3985
    last_instr = current_instr;
#line 3985
    current_instr = kodp;
#line 3986
    ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 3986
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3986
    kodp += sizeof(struct OPERAND_0_mi );
#line 3986
    last_instr = current_instr;
#line 3986
    current_instr = kodp;
#line 3987
    goto switch_break;
  }
#line 3989
  if (! (((struct OPERAND_0_ma *)last_instr)->major == 33)) {
#line 3989
    if (! (((struct OPERAND_0_mi *)last_instr)->major == 37)) {
      {
#line 3990
      error_message(1035, "increment");
      }
    }
  }
  {
#line 3992
  if ((unsigned int )type_ac[set] == 136U) {
#line 3992
    goto case_136___10;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 8U) {
#line 3992
    goto case_136___10;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 264U) {
#line 3992
    goto case_264___9;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 152U) {
#line 3992
    goto case_152___9;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 24U) {
#line 3992
    goto case_152___9;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 280U) {
#line 3992
    goto case_280___9;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 140U) {
#line 3992
    goto case_140___10;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 12U) {
#line 3992
    goto case_140___10;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 268U) {
#line 3992
    goto case_268___9;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 64U) {
#line 3992
    goto case_64___10;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 80U) {
#line 3992
    goto case_80___9;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 32U) {
#line 3992
    goto case_32___10;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 2U) {
#line 3992
    goto case_2___9;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 130U) {
#line 3992
    goto case_130___9;
  }
#line 3992
  if ((unsigned int )type_ac[set] == 258U) {
#line 3992
    goto case_258___10;
  }
#line 3992
  goto switch_default___10;
  case_136___10: /* CIL Label */ 
  case_8___9: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_264___9: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 17;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_152___9: /* CIL Label */ 
  case_24___9: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 18;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_280___9: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 19;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_140___10: /* CIL Label */ 
  case_12___9: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 20;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_268___9: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 21;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_64___10: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_80___9: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 259;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_32___10: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 513;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_2___9: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 769;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_130___9: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 772;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  case_258___10: /* CIL Label */ 
#line 3992
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3992
  ((struct OPERAND_0_mi *)kodp)->minor = 773;
#line 3992
  kodp += sizeof(struct OPERAND_0_mi );
#line 3992
  goto switch_break___11;
  switch_default___10: /* CIL Label */ 
  {
#line 3992
  fprintfx(stderr, "%s:%d:\n", "ys.y", 3992);
#line 3992
  error_message(5000);
  }
#line 3992
  return (0);
  switch_break___11: /* CIL Label */ ;
  }
#line 3992
  last_instr = current_instr;
#line 3992
  current_instr = kodp;
#line 3993
  ((struct OPERAND_0_ma *)kodp)->major = 52;
#line 3993
  kodp += sizeof(struct OPERAND_0_ma );
#line 3993
  last_instr = current_instr;
#line 3993
  current_instr = kodp;
#line 3994
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3994
  ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 3994
  kodp += sizeof(struct OPERAND_0_mi );
#line 3994
  last_instr = current_instr;
#line 3994
  current_instr = kodp;
  {
#line 3995
  if ((unsigned int )type_ac[set] == 136U) {
#line 3995
    goto case_136___11;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 8U) {
#line 3995
    goto case_136___11;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 264U) {
#line 3995
    goto case_264___10;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 152U) {
#line 3995
    goto case_152___10;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 24U) {
#line 3995
    goto case_152___10;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 280U) {
#line 3995
    goto case_280___10;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 140U) {
#line 3995
    goto case_140___11;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 12U) {
#line 3995
    goto case_140___11;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 268U) {
#line 3995
    goto case_268___10;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 64U) {
#line 3995
    goto case_64___11;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 80U) {
#line 3995
    goto case_80___10;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 32U) {
#line 3995
    goto case_32___11;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 2U) {
#line 3995
    goto case_2___10;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 130U) {
#line 3995
    goto case_130___10;
  }
#line 3995
  if ((unsigned int )type_ac[set] == 258U) {
#line 3995
    goto case_258___11;
  }
#line 3995
  goto switch_default___11;
  case_136___11: /* CIL Label */ 
  case_8___10: /* CIL Label */ 
#line 3995
  ((struct OPERAND_1_i *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 3995
  ((struct OPERAND_1_i *)kodp)->num = 1;
#line 3995
  kodp += sizeof(struct OPERAND_1_i );
#line 3995
  goto switch_break___12;
  case_264___10: /* CIL Label */ 
#line 3995
  ((struct OPERAND_1_ui *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_ui *)kodp)->minor = 1;
#line 3995
  ((struct OPERAND_1_ui *)kodp)->num = 1U;
#line 3995
  kodp += sizeof(struct OPERAND_1_ui );
#line 3995
  goto switch_break___12;
  case_152___10: /* CIL Label */ 
  case_24___10: /* CIL Label */ 
#line 3995
  ((struct OPERAND_1_li *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 3995
  ((struct OPERAND_1_li *)kodp)->num = 1L;
#line 3995
  kodp += sizeof(struct OPERAND_1_li );
#line 3995
  goto switch_break___12;
  case_280___10: /* CIL Label */ 
#line 3995
  ((struct OPERAND_1_lui *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_lui *)kodp)->minor = 3;
#line 3995
  ((struct OPERAND_1_lui *)kodp)->num = 1UL;
#line 3995
  kodp += sizeof(struct OPERAND_1_lui );
#line 3995
  goto switch_break___12;
  case_140___11: /* CIL Label */ 
  case_12___10: /* CIL Label */ 
  {
#line 3995
  ((struct OPERAND_1_si *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_si *)kodp)->minor = 4;
#line 3995
  ((struct OPERAND_1_si *)kodp)->num = (short)1;
#line 3995
  kodp += sizeof(struct OPERAND_1_si );
#line 3995
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 3995
  goto switch_break___12;
  case_268___10: /* CIL Label */ 
  {
#line 3995
  ((struct OPERAND_1_sui *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_sui *)kodp)->minor = 5;
#line 3995
  ((struct OPERAND_1_sui *)kodp)->num = (unsigned short)1;
#line 3995
  kodp += sizeof(struct OPERAND_1_sui );
#line 3995
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 3995
  goto switch_break___12;
  case_64___11: /* CIL Label */ 
  {
#line 3995
  ((struct OPERAND_1_id *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_id *)kodp)->minor = 256;
#line 3995
  kodp += sizeof(struct OPERAND_0_mi );
#line 3995
  align_memory(& kodp, (int )sizeof(double ));
#line 3995
  *((double *)kodp) = (double )1;
#line 3995
  kodp += sizeof(double );
  }
#line 3995
  goto switch_break___12;
  case_80___10: /* CIL Label */ 
  {
#line 3995
  ((struct OPERAND_1_ild *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_ild *)kodp)->minor = 257;
#line 3995
  kodp += sizeof(struct OPERAND_0_mi );
#line 3995
  align_memory(& kodp, (int )sizeof(long double ));
#line 3995
  *((long double *)kodp) = (long double )1;
#line 3995
  kodp += sizeof(long double );
  }
#line 3995
  goto switch_break___12;
  case_32___11: /* CIL Label */ 
  {
#line 3995
  ((struct OPERAND_1_if *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_if *)kodp)->minor = 512;
#line 3995
  kodp += sizeof(struct OPERAND_0_mi );
#line 3995
  align_memory(& kodp, (int )sizeof(float ));
#line 3995
  *((float *)kodp) = (float )1;
#line 3995
  kodp += sizeof(float );
  }
#line 3995
  goto switch_break___12;
  case_2___10: /* CIL Label */ 
  {
#line 3995
  ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 3995
  ((struct OPERAND_1_ic *)kodp)->num = (char)1;
#line 3995
  kodp += sizeof(struct OPERAND_1_ic );
#line 3995
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 3995
  goto switch_break___12;
  case_130___10: /* CIL Label */ 
  {
#line 3995
  ((struct OPERAND_1_isc *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_isc *)kodp)->minor = 770;
#line 3995
  ((struct OPERAND_1_isc *)kodp)->num = (signed char)1;
#line 3995
  kodp += sizeof(struct OPERAND_1_isc );
#line 3995
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 3995
  goto switch_break___12;
  case_258___11: /* CIL Label */ 
  {
#line 3995
  ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 3995
  ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 3995
  ((struct OPERAND_1_ic *)kodp)->num = (char)1;
#line 3995
  kodp += sizeof(struct OPERAND_1_ic );
#line 3995
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 3995
  goto switch_break___12;
  switch_default___11: /* CIL Label */ 
  {
#line 3995
  fprintfx(stderr, "%s:%d:\n", "ys.y", 3995);
#line 3995
  error_message(5000);
  }
#line 3995
  return (0);
  switch_break___12: /* CIL Label */ ;
  }
#line 3995
  last_instr = current_instr;
#line 3995
  current_instr = kodp;
  {
#line 3996
  if ((unsigned int )type_ac[set] == 136U) {
#line 3996
    goto case_136___12;
  }
#line 3996
  if ((unsigned int )type_ac[set] == 8U) {
#line 3996
    goto case_136___12;
  }
#line 3996
  if ((unsigned int )type_ac[set] == 264U) {
#line 3996
    goto case_264___11;
  }
#line 3996
  if ((unsigned int )type_ac[set] == 152U) {
#line 3996
    goto case_152___11;
  }
#line 3996
  if ((unsigned int )type_ac[set] == 24U) {
#line 3996
    goto case_152___11;
  }
#line 3996
  if ((unsigned int )type_ac[set] == 280U) {
#line 3996
    goto case_280___11;
  }
#line 3996
  if ((unsigned int )type_ac[set] == 64U) {
#line 3996
    goto case_64___12;
  }
#line 3996
  if ((unsigned int )type_ac[set] == 80U) {
#line 3996
    goto case_80___11;
  }
#line 3996
  if ((unsigned int )type_ac[set] == 32U) {
#line 3996
    goto case_32___12;
  }
#line 3996
  goto switch_default___12;
  case_136___12: /* CIL Label */ 
  case_8___11: /* CIL Label */ 
#line 3996
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3996
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3996
  kodp += sizeof(struct OPERAND_0_mi );
#line 3996
  goto switch_break___13;
  case_264___11: /* CIL Label */ 
#line 3996
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3996
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 3996
  kodp += sizeof(struct OPERAND_0_mi );
#line 3996
  goto switch_break___13;
  case_152___11: /* CIL Label */ 
  case_24___11: /* CIL Label */ 
#line 3996
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3996
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 3996
  kodp += sizeof(struct OPERAND_0_mi );
#line 3996
  goto switch_break___13;
  case_280___11: /* CIL Label */ 
#line 3996
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3996
  ((struct OPERAND_0_mi *)kodp)->minor = 5;
#line 3996
  kodp += sizeof(struct OPERAND_0_mi );
#line 3996
  goto switch_break___13;
  case_64___12: /* CIL Label */ 
#line 3996
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3996
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 3996
  kodp += sizeof(struct OPERAND_0_mi );
#line 3996
  goto switch_break___13;
  case_80___11: /* CIL Label */ 
#line 3996
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3996
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 3996
  kodp += sizeof(struct OPERAND_0_mi );
#line 3996
  goto switch_break___13;
  case_32___12: /* CIL Label */ 
#line 3996
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 3996
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 3996
  kodp += sizeof(struct OPERAND_0_mi );
#line 3996
  goto switch_break___13;
  switch_default___12: /* CIL Label */ 
  {
#line 3996
  fprintfx(stderr, "%s:%d:\n", "ys.y", 3996);
#line 3996
  error_message(5000);
  }
#line 3996
  return (0);
  switch_break___13: /* CIL Label */ ;
  }
#line 3996
  last_instr = current_instr;
#line 3996
  current_instr = kodp;
  {
#line 3997
  if ((unsigned int )type_ac[set] == 136U) {
#line 3997
    goto case_136___13;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 8U) {
#line 3997
    goto case_136___13;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 264U) {
#line 3997
    goto case_264___12;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 152U) {
#line 3997
    goto case_152___12;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 24U) {
#line 3997
    goto case_152___12;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 280U) {
#line 3997
    goto case_280___12;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 140U) {
#line 3997
    goto case_140___12;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 12U) {
#line 3997
    goto case_140___12;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 268U) {
#line 3997
    goto case_268___11;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 64U) {
#line 3997
    goto case_64___13;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 80U) {
#line 3997
    goto case_80___12;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 32U) {
#line 3997
    goto case_32___13;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 2U) {
#line 3997
    goto case_2___11;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 130U) {
#line 3997
    goto case_130___11;
  }
#line 3997
  if ((unsigned int )type_ac[set] == 258U) {
#line 3997
    goto case_258___12;
  }
#line 3997
  goto switch_default___13;
  case_136___13: /* CIL Label */ 
  case_8___12: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_264___12: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 12;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_152___12: /* CIL Label */ 
  case_24___12: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 13;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_280___12: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 14;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_140___12: /* CIL Label */ 
  case_12___11: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 15;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_268___11: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 16;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_64___13: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_80___12: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 258;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_32___13: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_2___11: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 768;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_130___11: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 770;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  case_258___12: /* CIL Label */ 
#line 3997
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 3997
  ((struct OPERAND_0_mi *)kodp)->minor = 771;
#line 3997
  kodp += sizeof(struct OPERAND_0_mi );
#line 3997
  goto switch_break___14;
  switch_default___13: /* CIL Label */ 
  {
#line 3997
  fprintfx(stderr, "%s:%d:\n", "ys.y", 3997);
#line 3997
  error_message(5000);
  }
#line 3997
  return (0);
  switch_break___14: /* CIL Label */ ;
  }
#line 3997
  last_instr = current_instr;
#line 3997
  current_instr = kodp;
#line 3998
  ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 3998
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 3998
  kodp += sizeof(struct OPERAND_0_mi );
#line 3998
  last_instr = current_instr;
#line 3998
  current_instr = kodp;
#line 4000
  goto switch_break;
  case_288: /* CIL Label */ 
#line 4003
  if (struct_union_field[set]) {
#line 4005
    if (variable[set].offset) {
#line 4005
      goto _L___17;
    } else
#line 4005
    if ((unsigned long )variable[set].adr != (unsigned long )((void *)0)) {
      _L___17: /* CIL Label */ 
#line 4005
      if (struct_union_field[set] > 0) {
#line 4005
        (struct_union_field[set]) --;
      }
#line 4005
      if (struct_union_field[set]) {
#line 4005
        ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4005
        ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4005
        kodp += sizeof(struct OPERAND_0_mi );
#line 4005
        last_instr = current_instr;
#line 4005
        current_instr = kodp;
      }
#line 4005
      struct_union_field[set] = 0;
    }
#line 4006
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4006
    ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 4006
    kodp += sizeof(struct OPERAND_0_mi );
#line 4006
    last_instr = current_instr;
#line 4006
    current_instr = kodp;
#line 4007
    variable[set].adr = (char *)((void *)0);
#line 4008
    variable[set].offset = 0;
  } else
#line 4010
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4012
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4012
    ((struct OPERAND_0_mi *)kodp)->minor = 18;
#line 4012
    kodp += sizeof(struct OPERAND_0_mi );
#line 4012
    last_instr = current_instr;
#line 4012
    current_instr = kodp;
#line 4013
    ((struct OPERAND_0_ma *)kodp)->major = 52;
#line 4013
    kodp += sizeof(struct OPERAND_0_ma );
#line 4013
    last_instr = current_instr;
#line 4013
    current_instr = kodp;
#line 4014
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4014
    ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 4014
    kodp += sizeof(struct OPERAND_0_mi );
#line 4014
    last_instr = current_instr;
#line 4014
    current_instr = kodp;
#line 4015
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4015
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4015
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set])->output)->attribute.memory_size;
#line 4015
    kodp += sizeof(struct OPERAND_1_li );
#line 4016
    last_instr = current_instr;
#line 4016
    current_instr = kodp;
#line 4017
    ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4017
    ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4017
    kodp += sizeof(struct OPERAND_0_mi );
#line 4017
    last_instr = current_instr;
#line 4017
    current_instr = kodp;
#line 4018
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4018
    ((struct OPERAND_0_mi *)kodp)->minor = 13;
#line 4018
    kodp += sizeof(struct OPERAND_0_mi );
#line 4018
    last_instr = current_instr;
#line 4018
    current_instr = kodp;
#line 4019
    ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 4019
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4019
    kodp += sizeof(struct OPERAND_0_mi );
#line 4019
    last_instr = current_instr;
#line 4019
    current_instr = kodp;
#line 4020
    goto switch_break;
  }
#line 4022
  if (! (((struct OPERAND_0_ma *)last_instr)->major == 33)) {
#line 4022
    if (! (((struct OPERAND_0_mi *)last_instr)->major == 37)) {
      {
#line 4023
      error_message(1035, "decrement");
      }
    }
  }
  {
#line 4025
  if ((unsigned int )type_ac[set] == 136U) {
#line 4025
    goto case_136___14;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 8U) {
#line 4025
    goto case_136___14;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 264U) {
#line 4025
    goto case_264___13;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 152U) {
#line 4025
    goto case_152___13;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 24U) {
#line 4025
    goto case_152___13;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 280U) {
#line 4025
    goto case_280___13;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 140U) {
#line 4025
    goto case_140___13;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 12U) {
#line 4025
    goto case_140___13;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 268U) {
#line 4025
    goto case_268___12;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 64U) {
#line 4025
    goto case_64___14;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 80U) {
#line 4025
    goto case_80___13;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 32U) {
#line 4025
    goto case_32___14;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 2U) {
#line 4025
    goto case_2___12;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 130U) {
#line 4025
    goto case_130___12;
  }
#line 4025
  if ((unsigned int )type_ac[set] == 258U) {
#line 4025
    goto case_258___13;
  }
#line 4025
  goto switch_default___14;
  case_136___14: /* CIL Label */ 
  case_8___13: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 10;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_264___13: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 17;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_152___13: /* CIL Label */ 
  case_24___13: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 18;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_280___13: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 19;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_140___13: /* CIL Label */ 
  case_12___12: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 20;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_268___12: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 21;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_64___14: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_80___13: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 259;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_32___14: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 513;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_2___12: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 769;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_130___12: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 772;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  case_258___13: /* CIL Label */ 
#line 4025
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4025
  ((struct OPERAND_0_mi *)kodp)->minor = 773;
#line 4025
  kodp += sizeof(struct OPERAND_0_mi );
#line 4025
  goto switch_break___15;
  switch_default___14: /* CIL Label */ 
  {
#line 4025
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4025);
#line 4025
  error_message(5000);
  }
#line 4025
  return (0);
  switch_break___15: /* CIL Label */ ;
  }
#line 4025
  last_instr = current_instr;
#line 4025
  current_instr = kodp;
#line 4026
  ((struct OPERAND_0_ma *)kodp)->major = 52;
#line 4026
  kodp += sizeof(struct OPERAND_0_ma );
#line 4026
  last_instr = current_instr;
#line 4026
  current_instr = kodp;
#line 4027
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4027
  ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 4027
  kodp += sizeof(struct OPERAND_0_mi );
#line 4027
  last_instr = current_instr;
#line 4027
  current_instr = kodp;
  {
#line 4028
  if ((unsigned int )type_ac[set] == 136U) {
#line 4028
    goto case_136___15;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 8U) {
#line 4028
    goto case_136___15;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 264U) {
#line 4028
    goto case_264___14;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 152U) {
#line 4028
    goto case_152___14;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 24U) {
#line 4028
    goto case_152___14;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 280U) {
#line 4028
    goto case_280___14;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 140U) {
#line 4028
    goto case_140___14;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 12U) {
#line 4028
    goto case_140___14;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 268U) {
#line 4028
    goto case_268___13;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 64U) {
#line 4028
    goto case_64___15;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 80U) {
#line 4028
    goto case_80___14;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 32U) {
#line 4028
    goto case_32___15;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 2U) {
#line 4028
    goto case_2___13;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 130U) {
#line 4028
    goto case_130___13;
  }
#line 4028
  if ((unsigned int )type_ac[set] == 258U) {
#line 4028
    goto case_258___14;
  }
#line 4028
  goto switch_default___15;
  case_136___15: /* CIL Label */ 
  case_8___14: /* CIL Label */ 
#line 4028
  ((struct OPERAND_1_i *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 4028
  ((struct OPERAND_1_i *)kodp)->num = 1;
#line 4028
  kodp += sizeof(struct OPERAND_1_i );
#line 4028
  goto switch_break___16;
  case_264___14: /* CIL Label */ 
#line 4028
  ((struct OPERAND_1_ui *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_ui *)kodp)->minor = 1;
#line 4028
  ((struct OPERAND_1_ui *)kodp)->num = 1U;
#line 4028
  kodp += sizeof(struct OPERAND_1_ui );
#line 4028
  goto switch_break___16;
  case_152___14: /* CIL Label */ 
  case_24___14: /* CIL Label */ 
#line 4028
  ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4028
  ((struct OPERAND_1_li *)kodp)->num = 1L;
#line 4028
  kodp += sizeof(struct OPERAND_1_li );
#line 4028
  goto switch_break___16;
  case_280___14: /* CIL Label */ 
#line 4028
  ((struct OPERAND_1_lui *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_lui *)kodp)->minor = 3;
#line 4028
  ((struct OPERAND_1_lui *)kodp)->num = 1UL;
#line 4028
  kodp += sizeof(struct OPERAND_1_lui );
#line 4028
  goto switch_break___16;
  case_140___14: /* CIL Label */ 
  case_12___13: /* CIL Label */ 
  {
#line 4028
  ((struct OPERAND_1_si *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_si *)kodp)->minor = 4;
#line 4028
  ((struct OPERAND_1_si *)kodp)->num = (short)1;
#line 4028
  kodp += sizeof(struct OPERAND_1_si );
#line 4028
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4028
  goto switch_break___16;
  case_268___13: /* CIL Label */ 
  {
#line 4028
  ((struct OPERAND_1_sui *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_sui *)kodp)->minor = 5;
#line 4028
  ((struct OPERAND_1_sui *)kodp)->num = (unsigned short)1;
#line 4028
  kodp += sizeof(struct OPERAND_1_sui );
#line 4028
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4028
  goto switch_break___16;
  case_64___15: /* CIL Label */ 
  {
#line 4028
  ((struct OPERAND_1_id *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_id *)kodp)->minor = 256;
#line 4028
  kodp += sizeof(struct OPERAND_0_mi );
#line 4028
  align_memory(& kodp, (int )sizeof(double ));
#line 4028
  *((double *)kodp) = (double )1;
#line 4028
  kodp += sizeof(double );
  }
#line 4028
  goto switch_break___16;
  case_80___14: /* CIL Label */ 
  {
#line 4028
  ((struct OPERAND_1_ild *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_ild *)kodp)->minor = 257;
#line 4028
  kodp += sizeof(struct OPERAND_0_mi );
#line 4028
  align_memory(& kodp, (int )sizeof(long double ));
#line 4028
  *((long double *)kodp) = (long double )1;
#line 4028
  kodp += sizeof(long double );
  }
#line 4028
  goto switch_break___16;
  case_32___15: /* CIL Label */ 
  {
#line 4028
  ((struct OPERAND_1_if *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_if *)kodp)->minor = 512;
#line 4028
  kodp += sizeof(struct OPERAND_0_mi );
#line 4028
  align_memory(& kodp, (int )sizeof(float ));
#line 4028
  *((float *)kodp) = (float )1;
#line 4028
  kodp += sizeof(float );
  }
#line 4028
  goto switch_break___16;
  case_2___13: /* CIL Label */ 
  {
#line 4028
  ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 4028
  ((struct OPERAND_1_ic *)kodp)->num = (char)1;
#line 4028
  kodp += sizeof(struct OPERAND_1_ic );
#line 4028
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4028
  goto switch_break___16;
  case_130___13: /* CIL Label */ 
  {
#line 4028
  ((struct OPERAND_1_isc *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_isc *)kodp)->minor = 770;
#line 4028
  ((struct OPERAND_1_isc *)kodp)->num = (signed char)1;
#line 4028
  kodp += sizeof(struct OPERAND_1_isc );
#line 4028
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4028
  goto switch_break___16;
  case_258___14: /* CIL Label */ 
  {
#line 4028
  ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 4028
  ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 4028
  ((struct OPERAND_1_ic *)kodp)->num = (char)1;
#line 4028
  kodp += sizeof(struct OPERAND_1_ic );
#line 4028
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4028
  goto switch_break___16;
  switch_default___15: /* CIL Label */ 
  {
#line 4028
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4028);
#line 4028
  error_message(5000);
  }
#line 4028
  return (0);
  switch_break___16: /* CIL Label */ ;
  }
#line 4028
  last_instr = current_instr;
#line 4028
  current_instr = kodp;
  {
#line 4029
  if ((unsigned int )type_ac[set] == 136U) {
#line 4029
    goto case_136___16;
  }
#line 4029
  if ((unsigned int )type_ac[set] == 8U) {
#line 4029
    goto case_136___16;
  }
#line 4029
  if ((unsigned int )type_ac[set] == 264U) {
#line 4029
    goto case_264___15;
  }
#line 4029
  if ((unsigned int )type_ac[set] == 152U) {
#line 4029
    goto case_152___15;
  }
#line 4029
  if ((unsigned int )type_ac[set] == 24U) {
#line 4029
    goto case_152___15;
  }
#line 4029
  if ((unsigned int )type_ac[set] == 280U) {
#line 4029
    goto case_280___15;
  }
#line 4029
  if ((unsigned int )type_ac[set] == 64U) {
#line 4029
    goto case_64___16;
  }
#line 4029
  if ((unsigned int )type_ac[set] == 80U) {
#line 4029
    goto case_80___15;
  }
#line 4029
  if ((unsigned int )type_ac[set] == 32U) {
#line 4029
    goto case_32___16;
  }
#line 4029
  goto switch_default___16;
  case_136___16: /* CIL Label */ 
  case_8___15: /* CIL Label */ 
#line 4029
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4029
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4029
  kodp += sizeof(struct OPERAND_0_mi );
#line 4029
  goto switch_break___17;
  case_264___15: /* CIL Label */ 
#line 4029
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4029
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4029
  kodp += sizeof(struct OPERAND_0_mi );
#line 4029
  goto switch_break___17;
  case_152___15: /* CIL Label */ 
  case_24___15: /* CIL Label */ 
#line 4029
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4029
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4029
  kodp += sizeof(struct OPERAND_0_mi );
#line 4029
  goto switch_break___17;
  case_280___15: /* CIL Label */ 
#line 4029
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4029
  ((struct OPERAND_0_mi *)kodp)->minor = 4;
#line 4029
  kodp += sizeof(struct OPERAND_0_mi );
#line 4029
  goto switch_break___17;
  case_64___16: /* CIL Label */ 
#line 4029
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4029
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4029
  kodp += sizeof(struct OPERAND_0_mi );
#line 4029
  goto switch_break___17;
  case_80___15: /* CIL Label */ 
#line 4029
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4029
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4029
  kodp += sizeof(struct OPERAND_0_mi );
#line 4029
  goto switch_break___17;
  case_32___16: /* CIL Label */ 
#line 4029
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4029
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4029
  kodp += sizeof(struct OPERAND_0_mi );
#line 4029
  goto switch_break___17;
  switch_default___16: /* CIL Label */ 
  {
#line 4029
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4029);
#line 4029
  error_message(5000);
  }
#line 4029
  return (0);
  switch_break___17: /* CIL Label */ ;
  }
#line 4029
  last_instr = current_instr;
#line 4029
  current_instr = kodp;
  {
#line 4030
  if ((unsigned int )type_ac[set] == 136U) {
#line 4030
    goto case_136___17;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 8U) {
#line 4030
    goto case_136___17;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 264U) {
#line 4030
    goto case_264___16;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 152U) {
#line 4030
    goto case_152___16;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 24U) {
#line 4030
    goto case_152___16;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 280U) {
#line 4030
    goto case_280___16;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 140U) {
#line 4030
    goto case_140___15;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 12U) {
#line 4030
    goto case_140___15;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 268U) {
#line 4030
    goto case_268___14;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 64U) {
#line 4030
    goto case_64___17;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 80U) {
#line 4030
    goto case_80___16;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 32U) {
#line 4030
    goto case_32___17;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 2U) {
#line 4030
    goto case_2___14;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 130U) {
#line 4030
    goto case_130___14;
  }
#line 4030
  if ((unsigned int )type_ac[set] == 258U) {
#line 4030
    goto case_258___15;
  }
#line 4030
  goto switch_default___17;
  case_136___17: /* CIL Label */ 
  case_8___16: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_264___16: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 12;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_152___16: /* CIL Label */ 
  case_24___16: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 13;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_280___16: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 14;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_140___15: /* CIL Label */ 
  case_12___14: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 15;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_268___14: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 16;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_64___17: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_80___16: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 258;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_32___17: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_2___14: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 768;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_130___14: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 770;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  case_258___15: /* CIL Label */ 
#line 4030
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4030
  ((struct OPERAND_0_mi *)kodp)->minor = 771;
#line 4030
  kodp += sizeof(struct OPERAND_0_mi );
#line 4030
  goto switch_break___18;
  switch_default___17: /* CIL Label */ 
  {
#line 4030
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4030);
#line 4030
  error_message(5000);
  }
#line 4030
  return (0);
  switch_break___18: /* CIL Label */ ;
  }
#line 4030
  last_instr = current_instr;
#line 4030
  current_instr = kodp;
#line 4031
  ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 4031
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4031
  kodp += sizeof(struct OPERAND_0_mi );
#line 4031
  last_instr = current_instr;
#line 4031
  current_instr = kodp;
#line 4033
  goto switch_break;
  case_289: /* CIL Label */ 
  {
#line 4040
  text = proc_name_text[proc];
#line 4041
  help___19 = point(text);
  }
#line 4042
  if ((unsigned long )((void *)0) == (unsigned long )help___19) {
#line 4043
    no_compile_only = 0;
  }
#line 4044
  if (help___19->body) {
#line 4045
    proc_name[proc] = help___19->adr;
  }
#line 4046
  if (! num_args[proc]) {
    {
#line 4047
    num_args[proc] = get_num_args(help___19->type);
    }
  }
#line 4048
  param_flag = 1;
  {
#line 4054
  if ((unsigned int )(type_com[set])->attribute.function_class == 2049U) {
#line 4054
    goto case_2049___0;
  }
#line 4060
  goto switch_default___18;
  case_2049___0: /* CIL Label */ 
#line 4055
  ((struct OPERAND_0_mi *)kodp)->major = 38;
#line 4055
  ((struct OPERAND_0_mi *)kodp)->minor = 4;
#line 4055
  kodp += sizeof(struct OPERAND_0_mi );
#line 4055
  last_instr = current_instr;
#line 4055
  current_instr = kodp;
#line 4056
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4056
  ((struct OPERAND_0_mi *)kodp)->minor = 4;
#line 4056
  kodp += sizeof(struct OPERAND_0_mi );
#line 4056
  last_instr = current_instr;
#line 4056
  current_instr = kodp;
#line 4059
  goto switch_break___19;
  switch_default___18: /* CIL Label */ 
#line 4061
  goto switch_break___19;
  switch_break___19: /* CIL Label */ ;
  }
#line 4063
  call_fix[proc] = kodp;
#line 4063
  ((struct OPERAND_1_i *)kodp)->major = 11;
#line 4063
  ((struct OPERAND_1_i *)kodp)->num = 0;
#line 4063
  ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 4063
  kodp += sizeof(struct OPERAND_1_i );
#line 4063
  last_instr = current_instr;
#line 4063
  current_instr = kodp;
#line 4065
  goto switch_break;
  case_290: /* CIL Label */ 
#line 4067
  text = proc_name_text[proc];
#line 4068
  if (num_args[proc] != 0) {
#line 4069
    if (num_args[proc] > args[proc]) {
      {
#line 4070
      error_message(2010);
      }
    } else
#line 4071
    if (num_args[proc] < args[proc]) {
      {
#line 4072
      error_message(2011);
      }
    }
  }
  {
#line 4073
  tmp___222 = point_call(text);
  }
#line 4073
  if (-1 == tmp___222) {
#line 4074
    no_compile_only = 0;
  }
#line 4075
  if (2048U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4077
    ((struct OPERAND_1_mi *)kodp)->major = 29;
#line 4077
    ((struct OPERAND_1_mi *)kodp)->minor = 0;
#line 4077
    ((struct OPERAND_1_mi *)kodp)->adr = proc_name[proc];
#line 4077
    kodp += sizeof(struct OPERAND_1_mi );
#line 4077
    last_instr = current_instr;
#line 4077
    current_instr = kodp;
#line 4078
    ((struct OPERAND_1_i *)kodp)->major = 10;
#line 4078
    ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 4078
    ((struct OPERAND_1_i *)kodp)->num = count[proc];
#line 4078
    kodp += sizeof(struct OPERAND_1_i );
#line 4078
    last_instr = current_instr;
#line 4078
    current_instr = kodp;
  } else {
    {
#line 4082
    if ((unsigned int )type_ac[set] == 136U) {
#line 4082
      goto case_136___18;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 8U) {
#line 4082
      goto case_136___18;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 264U) {
#line 4082
      goto case_264___17;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 152U) {
#line 4082
      goto case_152___17;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 24U) {
#line 4082
      goto case_152___17;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 280U) {
#line 4082
      goto case_280___17;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 140U) {
#line 4082
      goto case_140___16;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 12U) {
#line 4082
      goto case_140___16;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 268U) {
#line 4082
      goto case_268___15;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 64U) {
#line 4082
      goto case_64___18;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 80U) {
#line 4082
      goto case_80___17;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 32U) {
#line 4082
      goto case_32___18;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 2U) {
#line 4082
      goto case_2___15;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 130U) {
#line 4082
      goto case_130___15;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 258U) {
#line 4082
      goto case_258___16;
    }
#line 4082
    if ((unsigned int )type_ac[set] == 1U) {
#line 4082
      goto case_1___7;
    }
#line 4082
    goto switch_default___19;
    case_136___18: /* CIL Label */ 
    case_8___17: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 14;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 1;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_264___17: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 19;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 6;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_152___17: /* CIL Label */ 
    case_24___17: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 20;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 7;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_280___17: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 21;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 8;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_140___16: /* CIL Label */ 
    case_12___15: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 22;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 9;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_268___15: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 23;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 10;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_64___18: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 15;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 2;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_80___17: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 24;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 11;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_32___18: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 16;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 3;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_2___15: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 17;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 4;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_130___15: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 25;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 12;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_258___16: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 26;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 13;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    case_1___7: /* CIL Label */ 
#line 4082
    if (call_by_value) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 18;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    } else
#line 4082
    if (call_by_reference) {
#line 4082
      ((struct OPERAND_1_i *)kodp)->major = 29;
#line 4082
      ((struct OPERAND_1_i *)kodp)->minor = 5;
#line 4082
      ((struct OPERAND_1_i *)kodp)->num = *((int *)proc_name[proc]);
#line 4082
      kodp += sizeof(struct OPERAND_1_i );
    }
#line 4082
    goto switch_break___20;
    switch_default___19: /* CIL Label */ 
    {
#line 4082
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4082);
#line 4082
    error_message(5000);
    }
#line 4082
    return (0);
    switch_break___20: /* CIL Label */ ;
    }
#line 4082
    last_instr = current_instr;
#line 4082
    current_instr = kodp;
#line 4083
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4083
    ((struct OPERAND_0_mi *)kodp)->minor = 5;
#line 4083
    kodp += sizeof(struct OPERAND_0_mi );
#line 4083
    last_instr = current_instr;
#line 4083
    current_instr = kodp;
#line 4084
    ((struct OPERAND_0_mi *)kodp)->major = 39;
#line 4084
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4084
    kodp += sizeof(struct OPERAND_0_mi );
#line 4084
    last_instr = current_instr;
#line 4084
    current_instr = kodp;
  }
#line 4086
  ((struct OPERAND_1_i *)call_fix[proc])->num = count[proc];
#line 4087
  count[proc] = 0;
#line 4091
  proc_name[proc] = (char *)((void *)0);
#line 4092
  num_args[proc] = 0;
#line 4093
  args[proc] = 0;
#line 4094
  tmp___223 = proc;
#line 4094
  proc --;
#line 4094
  proc_name_text[tmp___223] = (char *)((void *)0);
#line 4097
  goto switch_break;
  case_291: /* CIL Label */ 
  {
#line 4109
  if ((unsigned int )(type_com[set])->attribute.function_class == 1024U) {
#line 4109
    goto case_1024___0;
  }
#line 4109
  if ((unsigned int )(type_com[set])->attribute.function_class == 1031U) {
#line 4109
    goto case_1024___0;
  }
#line 4109
  if ((unsigned int )(type_com[set])->attribute.function_class == 1028U) {
#line 4109
    goto case_1024___0;
  }
#line 4121
  if ((unsigned int )(type_com[set])->attribute.function_class == 1025U) {
#line 4121
    goto case_1025___0;
  }
#line 4129
  if ((unsigned int )(type_com[set])->attribute.function_class == 1030U) {
#line 4129
    goto case_1030___0;
  }
#line 4129
  if ((unsigned int )(type_com[set])->attribute.function_class == 1029U) {
#line 4129
    goto case_1030___0;
  }
#line 4132
  if ((unsigned int )(type_com[set])->attribute.function_class == 2049U) {
#line 4132
    goto case_2049___1;
  }
#line 4132
  if ((unsigned int )(type_com[set])->attribute.function_class == 2048U) {
#line 4132
    goto case_2049___1;
  }
#line 4134
  goto switch_default___20;
  case_1024___0: /* CIL Label */ 
  case_1031___0: /* CIL Label */ 
  case_1028___0: /* CIL Label */ 
#line 4110
  if ((unsigned long )((void *)0) != (unsigned long )(type_com[set])->field_name) {
#line 4112
    if (variable[set].offset) {
#line 4112
      goto _L___18;
    } else
#line 4112
    if ((unsigned long )variable[set].adr != (unsigned long )((void *)0)) {
      _L___18: /* CIL Label */ 
#line 4112
      if (struct_union_field[set] > 0) {
#line 4112
        (struct_union_field[set]) --;
      }
#line 4112
      if (struct_union_field[set]) {
#line 4112
        ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4112
        ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4112
        kodp += sizeof(struct OPERAND_0_mi );
#line 4112
        last_instr = current_instr;
#line 4112
        current_instr = kodp;
      }
#line 4112
      struct_union_field[set] = 0;
    }
#line 4113
    if (variable[set].offset != 0) {
#line 4116
      ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4116
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 4116
      kodp += sizeof(struct OPERAND_0_mi );
#line 4116
      last_instr = current_instr;
#line 4116
      current_instr = kodp;
    } else
#line 4113
    if ((unsigned long )variable[set].adr != (unsigned long )((void *)0)) {
#line 4116
      ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4116
      ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 4116
      kodp += sizeof(struct OPERAND_0_mi );
#line 4116
      last_instr = current_instr;
#line 4116
      current_instr = kodp;
    }
#line 4118
    kodp3 = kodp;
  }
#line 4120
  goto switch_break___21;
  case_1025___0: /* CIL Label */ 
#line 4122
  if (param_flag) {
#line 4122
    if (! subscript_flag[set]) {
#line 4124
      kodp3 = kodp;
      {
#line 4125
      while (1) {
        while_continue___37: /* CIL Label */ ;
#line 4125
        if (! (-1 != dim[poc])) {
#line 4125
          goto while_break___37;
        }
#line 4125
        tmp___224 = poc;
#line 4125
        poc --;
#line 4125
        dim[tmp___224] = -1;
      }
      while_break___37: /* CIL Label */ ;
      }
    }
  }
#line 4127
  goto switch_break___21;
  case_1030___0: /* CIL Label */ 
  case_1029___0: /* CIL Label */ 
#line 4130
  goto switch_break___21;
  case_2049___1: /* CIL Label */ 
  case_2048___0: /* CIL Label */ 
#line 4133
  goto switch_break___21;
  switch_default___20: /* CIL Label */ 
  {
#line 4135
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4135);
#line 4136
  error_message(5000);
#line 4137
  abort();
  }
  switch_break___21: /* CIL Label */ ;
  }
#line 4140
  goto switch_break;
  case_292: /* CIL Label */ 
#line 4143
  if (is_address) {
    {
#line 4144
    error_message(1022);
    }
  } else {
#line 4148
    kodp3 = kodp;
#line 4149
    is_address = 1;
    {
#line 4155
    if ((unsigned int )(type_com[set])->attribute.function_class == 1030U) {
#line 4155
      goto case_1030___1;
    }
#line 4155
    if ((unsigned int )(type_com[set])->attribute.function_class == 1029U) {
#line 4155
      goto case_1030___1;
    }
#line 4155
    if ((unsigned int )(type_com[set])->attribute.function_class == 1025U) {
#line 4155
      goto case_1030___1;
    }
#line 4155
    if ((unsigned int )(type_com[set])->attribute.function_class == 1024U) {
#line 4155
      goto case_1030___1;
    }
#line 4184
    goto switch_default___21;
    case_1030___1: /* CIL Label */ 
    case_1029___1: /* CIL Label */ 
    case_1025___1: /* CIL Label */ 
    case_1024___1: /* CIL Label */ 
#line 4156
    if ((unsigned long )((void *)0) != (unsigned long )(type_com[set])->field_name) {
#line 4156
      goto _L___19;
    } else
#line 4156
    if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
      _L___19: /* CIL Label */ 
#line 4156
      if ((unsigned long )variable[set].adr == (unsigned long )((void *)0)) {
#line 4156
        if (variable[set].offset == 0) {
#line 4161
          ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4161
          ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4161
          kodp += sizeof(struct OPERAND_0_mi );
#line 4161
          last_instr = current_instr;
#line 4161
          current_instr = kodp;
        }
      }
    }
#line 4163
    if ((unsigned long )variable[set].adr != (unsigned long )((void *)0)) {
#line 4166
      ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4166
      ((struct OPERAND_0_mi *)kodp)->minor = 8;
#line 4166
      kodp += sizeof(struct OPERAND_0_mi );
#line 4166
      last_instr = current_instr;
#line 4166
      current_instr = kodp;
    } else
#line 4163
    if (variable[set].offset != 0) {
#line 4166
      ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4166
      ((struct OPERAND_0_mi *)kodp)->minor = 8;
#line 4166
      kodp += sizeof(struct OPERAND_0_mi );
#line 4166
      last_instr = current_instr;
#line 4166
      current_instr = kodp;
    }
#line 4168
    if (scope_level > 0) {
#line 4168
      tmp___225 = 1;
    } else {
#line 4168
      tmp___225 = 0;
    }
    {
#line 4168
    tmp___226 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___225);
#line 4168
    arch___10 = (struct internal_type *)tmp___226;
#line 4171
    init_zero((char *)arch___10, (unsigned int )sizeof(struct internal_type ));
#line 4173
    arch___10->attribute.function_class = (enum intern_func_class )1028;
#line 4174
    arch___10->attribute.type_qualifier = (enum type_qual )4098;
#line 4175
    arch___10->attribute.memory_size = (int )sizeof(pointer_size );
    }
#line 4177
    if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4178
      arch___10->output = (type_com[set])->output;
    } else {
#line 4180
      arch___10->output = type_com[set];
    }
#line 4181
    type_com[set] = arch___10;
#line 4182
    type_ac[set] = (enum intern_arit_class )8;
#line 4183
    goto switch_break___22;
    switch_default___21: /* CIL Label */ 
    {
#line 4185
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4185);
#line 4186
    error_message(5000);
    }
#line 4186
    return (0);
#line 4187
    goto switch_break___22;
    switch_break___22: /* CIL Label */ ;
    }
  }
#line 4191
  goto switch_break;
  case_293: /* CIL Label */ 
#line 4194
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4196
    type_com[set] = (type_com[set])->output;
#line 4197
    ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4197
    ((struct OPERAND_0_mi *)kodp)->minor = 7;
#line 4197
    kodp += sizeof(struct OPERAND_0_mi );
#line 4197
    last_instr = current_instr;
#line 4197
    current_instr = kodp;
#line 4198
    type_ac[set] = (type_com[set])->attribute.arit_class;
  } else
#line 4200
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4202
    type_com[set] = (type_com[set])->output;
#line 4203
    type_ac[set] = (type_com[set])->attribute.arit_class;
  } else {
    {
#line 4206
    error_message(1029);
    }
  }
#line 4208
  goto switch_break;
  case_294: /* CIL Label */ 
#line 4211
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4211
    goto _L___20;
  } else
#line 4211
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___20: /* CIL Label */ 
#line 4214
    if (scope_level > 0) {
#line 4214
      tmp___227 = 1;
    } else {
#line 4214
      tmp___227 = 0;
    }
    {
#line 4214
    tmp___228 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___227);
#line 4214
    type_com[set] = (struct internal_type *)tmp___228;
#line 4217
    init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 4219
    (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 4221
    (type_com[set])->attribute.type_qualifier = (enum type_qual )4098;
#line 4223
    (type_com[set])->attribute.arit_class = (enum intern_arit_class )8;
    }
  }
#line 4226
  kodp3 = kodp;
  {
#line 4227
  if ((unsigned int )type_ac[set] == 136U) {
#line 4227
    goto case_136___19;
  }
#line 4227
  if ((unsigned int )type_ac[set] == 8U) {
#line 4227
    goto case_136___19;
  }
#line 4227
  if ((unsigned int )type_ac[set] == 264U) {
#line 4227
    goto case_264___18;
  }
#line 4227
  if ((unsigned int )type_ac[set] == 152U) {
#line 4227
    goto case_152___18;
  }
#line 4227
  if ((unsigned int )type_ac[set] == 24U) {
#line 4227
    goto case_152___18;
  }
#line 4227
  if ((unsigned int )type_ac[set] == 280U) {
#line 4227
    goto case_280___18;
  }
#line 4227
  if ((unsigned int )type_ac[set] == 64U) {
#line 4227
    goto case_64___19;
  }
#line 4227
  if ((unsigned int )type_ac[set] == 80U) {
#line 4227
    goto case_80___18;
  }
#line 4227
  if ((unsigned int )type_ac[set] == 32U) {
#line 4227
    goto case_32___19;
  }
#line 4227
  goto switch_default___22;
  case_136___19: /* CIL Label */ 
  case_8___18: /* CIL Label */ 
#line 4227
  ((struct OPERAND_0_mi *)kodp)->major = 45;
#line 4227
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4227
  kodp += sizeof(struct OPERAND_0_mi );
#line 4227
  goto switch_break___23;
  case_264___18: /* CIL Label */ 
#line 4227
  ((struct OPERAND_0_mi *)kodp)->major = 45;
#line 4227
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4227
  kodp += sizeof(struct OPERAND_0_mi );
#line 4227
  goto switch_break___23;
  case_152___18: /* CIL Label */ 
  case_24___18: /* CIL Label */ 
#line 4227
  ((struct OPERAND_0_mi *)kodp)->major = 45;
#line 4227
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4227
  kodp += sizeof(struct OPERAND_0_mi );
#line 4227
  goto switch_break___23;
  case_280___18: /* CIL Label */ 
#line 4227
  ((struct OPERAND_0_mi *)kodp)->major = 45;
#line 4227
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4227
  kodp += sizeof(struct OPERAND_0_mi );
#line 4227
  goto switch_break___23;
  case_64___19: /* CIL Label */ 
#line 4227
  ((struct OPERAND_0_mi *)kodp)->major = 45;
#line 4227
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4227
  kodp += sizeof(struct OPERAND_0_mi );
#line 4227
  goto switch_break___23;
  case_80___18: /* CIL Label */ 
#line 4227
  ((struct OPERAND_0_mi *)kodp)->major = 45;
#line 4227
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4227
  kodp += sizeof(struct OPERAND_0_mi );
#line 4227
  goto switch_break___23;
  case_32___19: /* CIL Label */ 
#line 4227
  ((struct OPERAND_0_mi *)kodp)->major = 45;
#line 4227
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4227
  kodp += sizeof(struct OPERAND_0_mi );
#line 4227
  goto switch_break___23;
  switch_default___22: /* CIL Label */ 
  {
#line 4227
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4227);
#line 4227
  error_message(5000);
  }
#line 4227
  return (0);
  switch_break___23: /* CIL Label */ ;
  }
#line 4228
  last_instr = current_instr;
#line 4228
  current_instr = kodp;
#line 4228
  type_ac[set] = (enum intern_arit_class )8;
#line 4230
  goto switch_break;
  case_295: /* CIL Label */ 
#line 4233
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4235
    error_message(1030);
    }
  } else
#line 4233
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4235
    error_message(1030);
    }
  }
#line 4236
  if (8U == (unsigned int )type_ac[set]) {
    {
#line 4240
    if ((unsigned int )type_ac[set] == 8U) {
#line 4240
      goto case_8___19;
    }
#line 4244
    goto switch_default___23;
    case_8___19: /* CIL Label */ 
#line 4241
    kodp3 = kodp;
#line 4242
    ((struct OPERAND_0_ma *)kodp)->major = 46;
#line 4242
    kodp += sizeof(struct OPERAND_0_ma );
#line 4243
    goto switch_break___24;
    switch_default___23: /* CIL Label */ 
    {
#line 4245
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4245);
#line 4246
    error_message(5000);
    }
#line 4246
    return (0);
    switch_break___24: /* CIL Label */ ;
    }
#line 4248
    last_instr = current_instr;
#line 4248
    current_instr = kodp;
#line 4248
    type_ac[set] = (enum intern_arit_class )8;
  } else {
    {
#line 4251
    error_message(1005);
    }
  }
#line 4253
  goto switch_break;
  case_296: /* CIL Label */ 
#line 4256
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4258
    error_message(1032);
    }
  } else
#line 4256
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4258
    error_message(1032);
    }
  }
#line 4260
  goto switch_break;
  case_297: /* CIL Label */ 
#line 4262
  kodp3 = kodp;
  {
#line 4263
  if ((unsigned int )type_ac[set] == 136U) {
#line 4263
    goto case_136___20;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 8U) {
#line 4263
    goto case_136___20;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 264U) {
#line 4263
    goto case_264___19;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 152U) {
#line 4263
    goto case_152___19;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 24U) {
#line 4263
    goto case_152___19;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 280U) {
#line 4263
    goto case_280___19;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 140U) {
#line 4263
    goto case_140___17;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 12U) {
#line 4263
    goto case_140___17;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 268U) {
#line 4263
    goto case_268___16;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 64U) {
#line 4263
    goto case_64___20;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 80U) {
#line 4263
    goto case_80___19;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 32U) {
#line 4263
    goto case_32___20;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 2U) {
#line 4263
    goto case_2___16;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 130U) {
#line 4263
    goto case_130___16;
  }
#line 4263
  if ((unsigned int )type_ac[set] == 258U) {
#line 4263
    goto case_258___17;
  }
#line 4263
  goto switch_default___24;
  case_136___20: /* CIL Label */ 
  case_8___20: /* CIL Label */ 
#line 4263
  ((struct OPERAND_1_i *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 4263
  ((struct OPERAND_1_i *)kodp)->num = 0;
#line 4263
  kodp += sizeof(struct OPERAND_1_i );
#line 4263
  goto switch_break___25;
  case_264___19: /* CIL Label */ 
#line 4263
  ((struct OPERAND_1_ui *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_ui *)kodp)->minor = 1;
#line 4263
  ((struct OPERAND_1_ui *)kodp)->num = 0U;
#line 4263
  kodp += sizeof(struct OPERAND_1_ui );
#line 4263
  goto switch_break___25;
  case_152___19: /* CIL Label */ 
  case_24___19: /* CIL Label */ 
#line 4263
  ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4263
  ((struct OPERAND_1_li *)kodp)->num = 0L;
#line 4263
  kodp += sizeof(struct OPERAND_1_li );
#line 4263
  goto switch_break___25;
  case_280___19: /* CIL Label */ 
#line 4263
  ((struct OPERAND_1_lui *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_lui *)kodp)->minor = 3;
#line 4263
  ((struct OPERAND_1_lui *)kodp)->num = 0UL;
#line 4263
  kodp += sizeof(struct OPERAND_1_lui );
#line 4263
  goto switch_break___25;
  case_140___17: /* CIL Label */ 
  case_12___16: /* CIL Label */ 
  {
#line 4263
  ((struct OPERAND_1_si *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_si *)kodp)->minor = 4;
#line 4263
  ((struct OPERAND_1_si *)kodp)->num = (short)0;
#line 4263
  kodp += sizeof(struct OPERAND_1_si );
#line 4263
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4263
  goto switch_break___25;
  case_268___16: /* CIL Label */ 
  {
#line 4263
  ((struct OPERAND_1_sui *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_sui *)kodp)->minor = 5;
#line 4263
  ((struct OPERAND_1_sui *)kodp)->num = (unsigned short)0;
#line 4263
  kodp += sizeof(struct OPERAND_1_sui );
#line 4263
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4263
  goto switch_break___25;
  case_64___20: /* CIL Label */ 
  {
#line 4263
  ((struct OPERAND_1_id *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_id *)kodp)->minor = 256;
#line 4263
  kodp += sizeof(struct OPERAND_0_mi );
#line 4263
  align_memory(& kodp, (int )sizeof(double ));
#line 4263
  *((double *)kodp) = (double )0;
#line 4263
  kodp += sizeof(double );
  }
#line 4263
  goto switch_break___25;
  case_80___19: /* CIL Label */ 
  {
#line 4263
  ((struct OPERAND_1_ild *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_ild *)kodp)->minor = 257;
#line 4263
  kodp += sizeof(struct OPERAND_0_mi );
#line 4263
  align_memory(& kodp, (int )sizeof(long double ));
#line 4263
  *((long double *)kodp) = (long double )0;
#line 4263
  kodp += sizeof(long double );
  }
#line 4263
  goto switch_break___25;
  case_32___20: /* CIL Label */ 
  {
#line 4263
  ((struct OPERAND_1_if *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_if *)kodp)->minor = 512;
#line 4263
  kodp += sizeof(struct OPERAND_0_mi );
#line 4263
  align_memory(& kodp, (int )sizeof(float ));
#line 4263
  *((float *)kodp) = (float )0;
#line 4263
  kodp += sizeof(float );
  }
#line 4263
  goto switch_break___25;
  case_2___16: /* CIL Label */ 
  {
#line 4263
  ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 4263
  ((struct OPERAND_1_ic *)kodp)->num = (char)0;
#line 4263
  kodp += sizeof(struct OPERAND_1_ic );
#line 4263
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4263
  goto switch_break___25;
  case_130___16: /* CIL Label */ 
  {
#line 4263
  ((struct OPERAND_1_isc *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_isc *)kodp)->minor = 770;
#line 4263
  ((struct OPERAND_1_isc *)kodp)->num = (signed char)0;
#line 4263
  kodp += sizeof(struct OPERAND_1_isc );
#line 4263
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4263
  goto switch_break___25;
  case_258___17: /* CIL Label */ 
  {
#line 4263
  ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 4263
  ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 4263
  ((struct OPERAND_1_ic *)kodp)->num = (char)0;
#line 4263
  kodp += sizeof(struct OPERAND_1_ic );
#line 4263
  align_memory(& kodp, (int )sizeof(int ));
  }
#line 4263
  goto switch_break___25;
  switch_default___24: /* CIL Label */ 
  {
#line 4263
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4263);
#line 4263
  error_message(5000);
  }
#line 4263
  return (0);
  switch_break___25: /* CIL Label */ ;
  }
#line 4263
  last_instr = current_instr;
#line 4263
  current_instr = kodp;
#line 4265
  goto switch_break;
  case_298: /* CIL Label */ 
#line 4267
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4269
    error_message(1031);
    }
  } else
#line 4267
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4269
    error_message(1031);
    }
  }
  {
#line 4270
  if ((unsigned int )type_ac[set] == 136U) {
#line 4270
    goto case_136___21;
  }
#line 4270
  if ((unsigned int )type_ac[set] == 8U) {
#line 4270
    goto case_136___21;
  }
#line 4270
  if ((unsigned int )type_ac[set] == 264U) {
#line 4270
    goto case_264___20;
  }
#line 4270
  if ((unsigned int )type_ac[set] == 152U) {
#line 4270
    goto case_152___20;
  }
#line 4270
  if ((unsigned int )type_ac[set] == 24U) {
#line 4270
    goto case_152___20;
  }
#line 4270
  if ((unsigned int )type_ac[set] == 280U) {
#line 4270
    goto case_280___20;
  }
#line 4270
  if ((unsigned int )type_ac[set] == 64U) {
#line 4270
    goto case_64___21;
  }
#line 4270
  if ((unsigned int )type_ac[set] == 80U) {
#line 4270
    goto case_80___20;
  }
#line 4270
  if ((unsigned int )type_ac[set] == 32U) {
#line 4270
    goto case_32___21;
  }
#line 4270
  goto switch_default___25;
  case_136___21: /* CIL Label */ 
  case_8___21: /* CIL Label */ 
#line 4270
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4270
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4270
  kodp += sizeof(struct OPERAND_0_mi );
#line 4270
  goto switch_break___26;
  case_264___20: /* CIL Label */ 
#line 4270
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4270
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4270
  kodp += sizeof(struct OPERAND_0_mi );
#line 4270
  goto switch_break___26;
  case_152___20: /* CIL Label */ 
  case_24___20: /* CIL Label */ 
#line 4270
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4270
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4270
  kodp += sizeof(struct OPERAND_0_mi );
#line 4270
  goto switch_break___26;
  case_280___20: /* CIL Label */ 
#line 4270
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4270
  ((struct OPERAND_0_mi *)kodp)->minor = 4;
#line 4270
  kodp += sizeof(struct OPERAND_0_mi );
#line 4270
  goto switch_break___26;
  case_64___21: /* CIL Label */ 
#line 4270
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4270
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4270
  kodp += sizeof(struct OPERAND_0_mi );
#line 4270
  goto switch_break___26;
  case_80___20: /* CIL Label */ 
#line 4270
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4270
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4270
  kodp += sizeof(struct OPERAND_0_mi );
#line 4270
  goto switch_break___26;
  case_32___21: /* CIL Label */ 
#line 4270
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4270
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4270
  kodp += sizeof(struct OPERAND_0_mi );
#line 4270
  goto switch_break___26;
  switch_default___25: /* CIL Label */ 
  {
#line 4270
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4270);
#line 4270
  error_message(5000);
  }
#line 4270
  return (0);
  switch_break___26: /* CIL Label */ ;
  }
#line 4270
  last_instr = current_instr;
#line 4270
  current_instr = kodp;
#line 4272
  goto switch_break;
  case_299: /* CIL Label */ 
#line 4275
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4277
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4277
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4277
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set])->output)->attribute.memory_size;
#line 4277
    kodp += sizeof(struct OPERAND_1_li );
#line 4278
    last_instr = current_instr;
#line 4278
    current_instr = kodp;
#line 4279
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4279
    ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4279
    kodp += sizeof(struct OPERAND_0_mi );
  } else {
    {
#line 4283
    if ((unsigned int )type_ac[set] == 136U) {
#line 4283
      goto case_136___22;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 8U) {
#line 4283
      goto case_136___22;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 264U) {
#line 4283
      goto case_264___21;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 152U) {
#line 4283
      goto case_152___21;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 24U) {
#line 4283
      goto case_152___21;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 280U) {
#line 4283
      goto case_280___21;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 140U) {
#line 4283
      goto case_140___18;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 12U) {
#line 4283
      goto case_140___18;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 268U) {
#line 4283
      goto case_268___17;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 64U) {
#line 4283
      goto case_64___22;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 80U) {
#line 4283
      goto case_80___21;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 32U) {
#line 4283
      goto case_32___22;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 2U) {
#line 4283
      goto case_2___17;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 130U) {
#line 4283
      goto case_130___17;
    }
#line 4283
    if ((unsigned int )type_ac[set] == 258U) {
#line 4283
      goto case_258___18;
    }
#line 4283
    goto switch_default___26;
    case_136___22: /* CIL Label */ 
    case_8___22: /* CIL Label */ 
#line 4283
    ((struct OPERAND_1_i *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 4283
    ((struct OPERAND_1_i *)kodp)->num = 1;
#line 4283
    kodp += sizeof(struct OPERAND_1_i );
#line 4283
    goto switch_break___27;
    case_264___21: /* CIL Label */ 
#line 4283
    ((struct OPERAND_1_ui *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_ui *)kodp)->minor = 1;
#line 4283
    ((struct OPERAND_1_ui *)kodp)->num = 1U;
#line 4283
    kodp += sizeof(struct OPERAND_1_ui );
#line 4283
    goto switch_break___27;
    case_152___21: /* CIL Label */ 
    case_24___21: /* CIL Label */ 
#line 4283
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4283
    ((struct OPERAND_1_li *)kodp)->num = 1L;
#line 4283
    kodp += sizeof(struct OPERAND_1_li );
#line 4283
    goto switch_break___27;
    case_280___21: /* CIL Label */ 
#line 4283
    ((struct OPERAND_1_lui *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_lui *)kodp)->minor = 3;
#line 4283
    ((struct OPERAND_1_lui *)kodp)->num = 1UL;
#line 4283
    kodp += sizeof(struct OPERAND_1_lui );
#line 4283
    goto switch_break___27;
    case_140___18: /* CIL Label */ 
    case_12___17: /* CIL Label */ 
    {
#line 4283
    ((struct OPERAND_1_si *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_si *)kodp)->minor = 4;
#line 4283
    ((struct OPERAND_1_si *)kodp)->num = (short)1;
#line 4283
    kodp += sizeof(struct OPERAND_1_si );
#line 4283
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4283
    goto switch_break___27;
    case_268___17: /* CIL Label */ 
    {
#line 4283
    ((struct OPERAND_1_sui *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_sui *)kodp)->minor = 5;
#line 4283
    ((struct OPERAND_1_sui *)kodp)->num = (unsigned short)1;
#line 4283
    kodp += sizeof(struct OPERAND_1_sui );
#line 4283
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4283
    goto switch_break___27;
    case_64___22: /* CIL Label */ 
    {
#line 4283
    ((struct OPERAND_1_id *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_id *)kodp)->minor = 256;
#line 4283
    kodp += sizeof(struct OPERAND_0_mi );
#line 4283
    align_memory(& kodp, (int )sizeof(double ));
#line 4283
    *((double *)kodp) = (double )1;
#line 4283
    kodp += sizeof(double );
    }
#line 4283
    goto switch_break___27;
    case_80___21: /* CIL Label */ 
    {
#line 4283
    ((struct OPERAND_1_ild *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_ild *)kodp)->minor = 257;
#line 4283
    kodp += sizeof(struct OPERAND_0_mi );
#line 4283
    align_memory(& kodp, (int )sizeof(long double ));
#line 4283
    *((long double *)kodp) = (long double )1;
#line 4283
    kodp += sizeof(long double );
    }
#line 4283
    goto switch_break___27;
    case_32___22: /* CIL Label */ 
    {
#line 4283
    ((struct OPERAND_1_if *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_if *)kodp)->minor = 512;
#line 4283
    kodp += sizeof(struct OPERAND_0_mi );
#line 4283
    align_memory(& kodp, (int )sizeof(float ));
#line 4283
    *((float *)kodp) = (float )1;
#line 4283
    kodp += sizeof(float );
    }
#line 4283
    goto switch_break___27;
    case_2___17: /* CIL Label */ 
    {
#line 4283
    ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 4283
    ((struct OPERAND_1_ic *)kodp)->num = (char)1;
#line 4283
    kodp += sizeof(struct OPERAND_1_ic );
#line 4283
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4283
    goto switch_break___27;
    case_130___17: /* CIL Label */ 
    {
#line 4283
    ((struct OPERAND_1_isc *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_isc *)kodp)->minor = 770;
#line 4283
    ((struct OPERAND_1_isc *)kodp)->num = (signed char)1;
#line 4283
    kodp += sizeof(struct OPERAND_1_isc );
#line 4283
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4283
    goto switch_break___27;
    case_258___18: /* CIL Label */ 
    {
#line 4283
    ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 4283
    ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 4283
    ((struct OPERAND_1_ic *)kodp)->num = (char)1;
#line 4283
    kodp += sizeof(struct OPERAND_1_ic );
#line 4283
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4283
    goto switch_break___27;
    switch_default___26: /* CIL Label */ 
    {
#line 4283
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4283);
#line 4283
    error_message(5000);
    }
#line 4283
    return (0);
    switch_break___27: /* CIL Label */ ;
    }
#line 4283
    last_instr = current_instr;
#line 4283
    current_instr = kodp;
    {
#line 4284
    if ((unsigned int )type_ac[set] == 136U) {
#line 4284
      goto case_136___23;
    }
#line 4284
    if ((unsigned int )type_ac[set] == 8U) {
#line 4284
      goto case_136___23;
    }
#line 4284
    if ((unsigned int )type_ac[set] == 264U) {
#line 4284
      goto case_264___22;
    }
#line 4284
    if ((unsigned int )type_ac[set] == 152U) {
#line 4284
      goto case_152___22;
    }
#line 4284
    if ((unsigned int )type_ac[set] == 24U) {
#line 4284
      goto case_152___22;
    }
#line 4284
    if ((unsigned int )type_ac[set] == 280U) {
#line 4284
      goto case_280___22;
    }
#line 4284
    if ((unsigned int )type_ac[set] == 64U) {
#line 4284
      goto case_64___23;
    }
#line 4284
    if ((unsigned int )type_ac[set] == 80U) {
#line 4284
      goto case_80___22;
    }
#line 4284
    if ((unsigned int )type_ac[set] == 32U) {
#line 4284
      goto case_32___23;
    }
#line 4284
    goto switch_default___27;
    case_136___23: /* CIL Label */ 
    case_8___23: /* CIL Label */ 
#line 4284
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4284
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4284
    kodp += sizeof(struct OPERAND_0_mi );
#line 4284
    goto switch_break___28;
    case_264___22: /* CIL Label */ 
#line 4284
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4284
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4284
    kodp += sizeof(struct OPERAND_0_mi );
#line 4284
    goto switch_break___28;
    case_152___22: /* CIL Label */ 
    case_24___22: /* CIL Label */ 
#line 4284
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4284
    ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4284
    kodp += sizeof(struct OPERAND_0_mi );
#line 4284
    goto switch_break___28;
    case_280___22: /* CIL Label */ 
#line 4284
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4284
    ((struct OPERAND_0_mi *)kodp)->minor = 5;
#line 4284
    kodp += sizeof(struct OPERAND_0_mi );
#line 4284
    goto switch_break___28;
    case_64___23: /* CIL Label */ 
#line 4284
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4284
    ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4284
    kodp += sizeof(struct OPERAND_0_mi );
#line 4284
    goto switch_break___28;
    case_80___22: /* CIL Label */ 
#line 4284
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4284
    ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4284
    kodp += sizeof(struct OPERAND_0_mi );
#line 4284
    goto switch_break___28;
    case_32___23: /* CIL Label */ 
#line 4284
    ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4284
    ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4284
    kodp += sizeof(struct OPERAND_0_mi );
#line 4284
    goto switch_break___28;
    switch_default___27: /* CIL Label */ 
    {
#line 4284
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4284);
#line 4284
    error_message(5000);
    }
#line 4284
    return (0);
    switch_break___28: /* CIL Label */ ;
    }
  }
  {
#line 4286
  last_instr = current_instr;
#line 4286
  current_instr = kodp;
#line 4286
  kodp3 = kodp;
#line 4287
  move2lvalue();
#line 4288
  variable[set].adr = (char *)((void *)0);
#line 4288
  variable[set].offset = 0;
  }
#line 4290
  goto switch_break;
  case_300: /* CIL Label */ 
#line 4293
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4295
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4295
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4295
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set])->output)->attribute.memory_size;
#line 4295
    kodp += sizeof(struct OPERAND_1_li );
#line 4296
    last_instr = current_instr;
#line 4296
    current_instr = kodp;
#line 4297
    ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4297
    ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4297
    kodp += sizeof(struct OPERAND_0_mi );
  } else {
    {
#line 4301
    if ((unsigned int )type_ac[set] == 136U) {
#line 4301
      goto case_136___24;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 8U) {
#line 4301
      goto case_136___24;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 264U) {
#line 4301
      goto case_264___23;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 152U) {
#line 4301
      goto case_152___23;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 24U) {
#line 4301
      goto case_152___23;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 280U) {
#line 4301
      goto case_280___23;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 140U) {
#line 4301
      goto case_140___19;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 12U) {
#line 4301
      goto case_140___19;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 268U) {
#line 4301
      goto case_268___18;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 64U) {
#line 4301
      goto case_64___24;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 80U) {
#line 4301
      goto case_80___23;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 32U) {
#line 4301
      goto case_32___24;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 2U) {
#line 4301
      goto case_2___18;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 130U) {
#line 4301
      goto case_130___18;
    }
#line 4301
    if ((unsigned int )type_ac[set] == 258U) {
#line 4301
      goto case_258___19;
    }
#line 4301
    goto switch_default___28;
    case_136___24: /* CIL Label */ 
    case_8___24: /* CIL Label */ 
#line 4301
    ((struct OPERAND_1_i *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 4301
    ((struct OPERAND_1_i *)kodp)->num = 1;
#line 4301
    kodp += sizeof(struct OPERAND_1_i );
#line 4301
    goto switch_break___29;
    case_264___23: /* CIL Label */ 
#line 4301
    ((struct OPERAND_1_ui *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_ui *)kodp)->minor = 1;
#line 4301
    ((struct OPERAND_1_ui *)kodp)->num = 1U;
#line 4301
    kodp += sizeof(struct OPERAND_1_ui );
#line 4301
    goto switch_break___29;
    case_152___23: /* CIL Label */ 
    case_24___23: /* CIL Label */ 
#line 4301
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4301
    ((struct OPERAND_1_li *)kodp)->num = 1L;
#line 4301
    kodp += sizeof(struct OPERAND_1_li );
#line 4301
    goto switch_break___29;
    case_280___23: /* CIL Label */ 
#line 4301
    ((struct OPERAND_1_lui *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_lui *)kodp)->minor = 3;
#line 4301
    ((struct OPERAND_1_lui *)kodp)->num = 1UL;
#line 4301
    kodp += sizeof(struct OPERAND_1_lui );
#line 4301
    goto switch_break___29;
    case_140___19: /* CIL Label */ 
    case_12___18: /* CIL Label */ 
    {
#line 4301
    ((struct OPERAND_1_si *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_si *)kodp)->minor = 4;
#line 4301
    ((struct OPERAND_1_si *)kodp)->num = (short)1;
#line 4301
    kodp += sizeof(struct OPERAND_1_si );
#line 4301
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4301
    goto switch_break___29;
    case_268___18: /* CIL Label */ 
    {
#line 4301
    ((struct OPERAND_1_sui *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_sui *)kodp)->minor = 5;
#line 4301
    ((struct OPERAND_1_sui *)kodp)->num = (unsigned short)1;
#line 4301
    kodp += sizeof(struct OPERAND_1_sui );
#line 4301
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4301
    goto switch_break___29;
    case_64___24: /* CIL Label */ 
    {
#line 4301
    ((struct OPERAND_1_id *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_id *)kodp)->minor = 256;
#line 4301
    kodp += sizeof(struct OPERAND_0_mi );
#line 4301
    align_memory(& kodp, (int )sizeof(double ));
#line 4301
    *((double *)kodp) = (double )1;
#line 4301
    kodp += sizeof(double );
    }
#line 4301
    goto switch_break___29;
    case_80___23: /* CIL Label */ 
    {
#line 4301
    ((struct OPERAND_1_ild *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_ild *)kodp)->minor = 257;
#line 4301
    kodp += sizeof(struct OPERAND_0_mi );
#line 4301
    align_memory(& kodp, (int )sizeof(long double ));
#line 4301
    *((long double *)kodp) = (long double )1;
#line 4301
    kodp += sizeof(long double );
    }
#line 4301
    goto switch_break___29;
    case_32___24: /* CIL Label */ 
    {
#line 4301
    ((struct OPERAND_1_if *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_if *)kodp)->minor = 512;
#line 4301
    kodp += sizeof(struct OPERAND_0_mi );
#line 4301
    align_memory(& kodp, (int )sizeof(float ));
#line 4301
    *((float *)kodp) = (float )1;
#line 4301
    kodp += sizeof(float );
    }
#line 4301
    goto switch_break___29;
    case_2___18: /* CIL Label */ 
    {
#line 4301
    ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 4301
    ((struct OPERAND_1_ic *)kodp)->num = (char)1;
#line 4301
    kodp += sizeof(struct OPERAND_1_ic );
#line 4301
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4301
    goto switch_break___29;
    case_130___18: /* CIL Label */ 
    {
#line 4301
    ((struct OPERAND_1_isc *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_isc *)kodp)->minor = 770;
#line 4301
    ((struct OPERAND_1_isc *)kodp)->num = (signed char)1;
#line 4301
    kodp += sizeof(struct OPERAND_1_isc );
#line 4301
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4301
    goto switch_break___29;
    case_258___19: /* CIL Label */ 
    {
#line 4301
    ((struct OPERAND_1_ic *)kodp)->major = 32;
#line 4301
    ((struct OPERAND_1_ic *)kodp)->minor = 768;
#line 4301
    ((struct OPERAND_1_ic *)kodp)->num = (char)1;
#line 4301
    kodp += sizeof(struct OPERAND_1_ic );
#line 4301
    align_memory(& kodp, (int )sizeof(int ));
    }
#line 4301
    goto switch_break___29;
    switch_default___28: /* CIL Label */ 
    {
#line 4301
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4301);
#line 4301
    error_message(5000);
    }
#line 4301
    return (0);
    switch_break___29: /* CIL Label */ ;
    }
#line 4301
    last_instr = current_instr;
#line 4301
    current_instr = kodp;
    {
#line 4302
    if ((unsigned int )type_ac[set] == 136U) {
#line 4302
      goto case_136___25;
    }
#line 4302
    if ((unsigned int )type_ac[set] == 8U) {
#line 4302
      goto case_136___25;
    }
#line 4302
    if ((unsigned int )type_ac[set] == 264U) {
#line 4302
      goto case_264___24;
    }
#line 4302
    if ((unsigned int )type_ac[set] == 152U) {
#line 4302
      goto case_152___24;
    }
#line 4302
    if ((unsigned int )type_ac[set] == 24U) {
#line 4302
      goto case_152___24;
    }
#line 4302
    if ((unsigned int )type_ac[set] == 280U) {
#line 4302
      goto case_280___24;
    }
#line 4302
    if ((unsigned int )type_ac[set] == 64U) {
#line 4302
      goto case_64___25;
    }
#line 4302
    if ((unsigned int )type_ac[set] == 80U) {
#line 4302
      goto case_80___24;
    }
#line 4302
    if ((unsigned int )type_ac[set] == 32U) {
#line 4302
      goto case_32___25;
    }
#line 4302
    goto switch_default___29;
    case_136___25: /* CIL Label */ 
    case_8___25: /* CIL Label */ 
#line 4302
    ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4302
    ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4302
    kodp += sizeof(struct OPERAND_0_mi );
#line 4302
    goto switch_break___30;
    case_264___24: /* CIL Label */ 
#line 4302
    ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4302
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4302
    kodp += sizeof(struct OPERAND_0_mi );
#line 4302
    goto switch_break___30;
    case_152___24: /* CIL Label */ 
    case_24___24: /* CIL Label */ 
#line 4302
    ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4302
    ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4302
    kodp += sizeof(struct OPERAND_0_mi );
#line 4302
    goto switch_break___30;
    case_280___24: /* CIL Label */ 
#line 4302
    ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4302
    ((struct OPERAND_0_mi *)kodp)->minor = 4;
#line 4302
    kodp += sizeof(struct OPERAND_0_mi );
#line 4302
    goto switch_break___30;
    case_64___25: /* CIL Label */ 
#line 4302
    ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4302
    ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4302
    kodp += sizeof(struct OPERAND_0_mi );
#line 4302
    goto switch_break___30;
    case_80___24: /* CIL Label */ 
#line 4302
    ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4302
    ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4302
    kodp += sizeof(struct OPERAND_0_mi );
#line 4302
    goto switch_break___30;
    case_32___25: /* CIL Label */ 
#line 4302
    ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4302
    ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4302
    kodp += sizeof(struct OPERAND_0_mi );
#line 4302
    goto switch_break___30;
    switch_default___29: /* CIL Label */ 
    {
#line 4302
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4302);
#line 4302
    error_message(5000);
    }
#line 4302
    return (0);
    switch_break___30: /* CIL Label */ ;
    }
  }
  {
#line 4304
  last_instr = current_instr;
#line 4304
  current_instr = kodp;
#line 4304
  kodp3 = kodp;
#line 4305
  move2lvalue();
#line 4306
  variable[set].adr = (char *)((void *)0);
#line 4306
  variable[set].offset = 0;
  }
#line 4308
  goto switch_break;
  case_301: /* CIL Label */ 
#line 4311
  if ((unsigned long )((void *)0) != (unsigned long )kodp4) {
#line 4313
    kodp = kodp4;
#line 4314
    kodp4 = (char *)((void *)0);
  }
#line 4316
  if ((type_com[set])->attribute.memory_size) {
#line 4318
    ((struct OPERAND_1_i *)kodp)->major = 32;
#line 4318
    ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 4318
    ((struct OPERAND_1_i *)kodp)->num = (type_com[set])->attribute.memory_size;
#line 4318
    kodp += sizeof(struct OPERAND_1_i );
#line 4319
    last_instr = current_instr;
#line 4319
    current_instr = kodp;
  } else {
    {
#line 4322
    error_message(1027);
    }
  }
  {
#line 4323
  type_ac[set] = (enum intern_arit_class )8;
#line 4324
  tmp___229 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 4324
  type_com[set] = (struct internal_type *)tmp___229;
#line 4326
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 4328
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 4329
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 4330
  (type_com[set])->attribute.memory_size = (int )sizeof(int );
  }
#line 4332
  goto switch_break;
  case_302: /* CIL Label */ 
#line 4335
  if ((typeh[type_spec_count])->attribute.memory_size) {
#line 4337
    ((struct OPERAND_1_i *)kodp)->major = 32;
#line 4337
    ((struct OPERAND_1_i *)kodp)->minor = 0;
#line 4337
    ((struct OPERAND_1_i *)kodp)->num = (typeh[type_spec_count])->attribute.memory_size;
#line 4337
    kodp += sizeof(struct OPERAND_1_i );
#line 4338
    last_instr = current_instr;
#line 4338
    current_instr = kodp;
  } else {
    {
#line 4341
    error_message(1027);
    }
  }
  {
#line 4342
  set ++;
#line 4342
  type_ac[set] = (enum intern_arit_class )8;
#line 4343
  tmp___230 = allocate((unsigned int )sizeof(struct internal_type ), 0U);
#line 4343
  type_com[set] = (struct internal_type *)tmp___230;
#line 4345
  init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 4347
  (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 4348
  (type_com[set])->attribute.type_qualifier = (enum type_qual )4096;
#line 4349
  (type_com[set])->attribute.memory_size = (int )sizeof(int );
#line 4350
  tmp___231 = type_spec_count;
#line 4350
  type_spec_count --;
#line 4350
  typeh[tmp___231] = (struct internal_type *)((void *)0);
  }
#line 4352
  goto switch_break;
  case_304: /* CIL Label */ 
  {
#line 4358
  check_spec_constr(typeh[type_spec_count], (char *)"type name");
#line 4359
  (typeh[type_spec_count])->attribute.memory_size = set_memory_size((typeh[type_spec_count])->attribute.arit_class);
  }
  {
#line 4363
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1024U) {
#line 4363
    goto case_1024___2;
  }
#line 4466
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1030U) {
#line 4466
    goto case_1030___2;
  }
#line 4466
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1029U) {
#line 4466
    goto case_1030___2;
  }
#line 4466
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1025U) {
#line 4466
    goto case_1030___2;
  }
#line 4469
  if ((unsigned int )(typeh[type_spec_count])->attribute.function_class == 1028U) {
#line 4469
    goto case_1028___1;
  }
#line 4471
  goto switch_default___36;
  case_1024___2: /* CIL Label */ 
#line 4364
  kodp3 = kodp;
  {
#line 4367
  if ((unsigned int )(typeh[type_spec_count])->attribute.arit_class == 8U) {
#line 4367
    goto case_8___26;
  }
#line 4386
  if ((unsigned int )(typeh[type_spec_count])->attribute.arit_class == 64U) {
#line 4386
    goto case_64___27;
  }
#line 4405
  if ((unsigned int )(typeh[type_spec_count])->attribute.arit_class == 32U) {
#line 4405
    goto case_32___28;
  }
#line 4424
  if ((unsigned int )(typeh[type_spec_count])->attribute.arit_class == 2U) {
#line 4424
    goto case_2___22;
  }
#line 4443
  if ((unsigned int )(typeh[type_spec_count])->attribute.arit_class == 1U) {
#line 4443
    goto case_1___8;
  }
#line 4457
  goto switch_default___35;
  case_8___26: /* CIL Label */ 
  {
#line 4370
  if ((unsigned int )type_ac[set] == 8U) {
#line 4370
    goto case_8___27;
  }
#line 4372
  if ((unsigned int )type_ac[set] == 64U) {
#line 4372
    goto case_64___26;
  }
#line 4375
  if ((unsigned int )type_ac[set] == 32U) {
#line 4375
    goto case_32___26;
  }
#line 4378
  if ((unsigned int )type_ac[set] == 2U) {
#line 4378
    goto case_2___19;
  }
#line 4381
  goto switch_default___30;
  case_8___27: /* CIL Label */ 
#line 4371
  goto switch_break___33;
  case_64___26: /* CIL Label */ 
#line 4373
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4373
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4373
  kodp += sizeof(struct OPERAND_0_mi );
#line 4373
  last_instr = current_instr;
#line 4373
  current_instr = kodp;
#line 4374
  goto switch_break___33;
  case_32___26: /* CIL Label */ 
#line 4376
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4376
  ((struct OPERAND_0_mi *)kodp)->minor = 5;
#line 4376
  kodp += sizeof(struct OPERAND_0_mi );
#line 4376
  last_instr = current_instr;
#line 4376
  current_instr = kodp;
#line 4377
  goto switch_break___33;
  case_2___19: /* CIL Label */ 
#line 4379
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4379
  ((struct OPERAND_0_mi *)kodp)->minor = 9;
#line 4379
  kodp += sizeof(struct OPERAND_0_mi );
#line 4379
  last_instr = current_instr;
#line 4379
  current_instr = kodp;
#line 4380
  goto switch_break___33;
  switch_default___30: /* CIL Label */ 
  {
#line 4382
  error_message(1005);
  }
  switch_break___33: /* CIL Label */ ;
  }
#line 4384
  type_ac[set] = (enum intern_arit_class )8;
#line 4385
  goto switch_break___32;
  case_64___27: /* CIL Label */ 
  {
#line 4389
  if ((unsigned int )type_ac[set] == 8U) {
#line 4389
    goto case_8___28;
  }
#line 4392
  if ((unsigned int )type_ac[set] == 64U) {
#line 4392
    goto case_64___28;
  }
#line 4394
  if ((unsigned int )type_ac[set] == 32U) {
#line 4394
    goto case_32___27;
  }
#line 4397
  if ((unsigned int )type_ac[set] == 2U) {
#line 4397
    goto case_2___20;
  }
#line 4400
  goto switch_default___31;
  case_8___28: /* CIL Label */ 
#line 4390
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4390
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4390
  kodp += sizeof(struct OPERAND_0_mi );
#line 4390
  last_instr = current_instr;
#line 4390
  current_instr = kodp;
#line 4391
  goto switch_break___34;
  case_64___28: /* CIL Label */ 
#line 4393
  goto switch_break___34;
  case_32___27: /* CIL Label */ 
#line 4395
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4395
  ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 4395
  kodp += sizeof(struct OPERAND_0_mi );
#line 4395
  last_instr = current_instr;
#line 4395
  current_instr = kodp;
#line 4396
  goto switch_break___34;
  case_2___20: /* CIL Label */ 
#line 4398
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4398
  ((struct OPERAND_0_mi *)kodp)->minor = 12;
#line 4398
  kodp += sizeof(struct OPERAND_0_mi );
#line 4398
  last_instr = current_instr;
#line 4398
  current_instr = kodp;
#line 4399
  goto switch_break___34;
  switch_default___31: /* CIL Label */ 
  {
#line 4401
  error_message(1005);
  }
  switch_break___34: /* CIL Label */ ;
  }
#line 4403
  type_ac[set] = (enum intern_arit_class )64;
#line 4404
  goto switch_break___32;
  case_32___28: /* CIL Label */ 
  {
#line 4408
  if ((unsigned int )type_ac[set] == 8U) {
#line 4408
    goto case_8___29;
  }
#line 4411
  if ((unsigned int )type_ac[set] == 64U) {
#line 4411
    goto case_64___29;
  }
#line 4414
  if ((unsigned int )type_ac[set] == 32U) {
#line 4414
    goto case_32___29;
  }
#line 4416
  if ((unsigned int )type_ac[set] == 2U) {
#line 4416
    goto case_2___21;
  }
#line 4419
  goto switch_default___32;
  case_8___29: /* CIL Label */ 
#line 4409
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4409
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4409
  kodp += sizeof(struct OPERAND_0_mi );
#line 4409
  last_instr = current_instr;
#line 4409
  current_instr = kodp;
#line 4410
  goto switch_break___35;
  case_64___29: /* CIL Label */ 
#line 4412
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4412
  ((struct OPERAND_0_mi *)kodp)->minor = 8;
#line 4412
  kodp += sizeof(struct OPERAND_0_mi );
#line 4412
  last_instr = current_instr;
#line 4412
  current_instr = kodp;
#line 4413
  goto switch_break___35;
  case_32___29: /* CIL Label */ 
#line 4415
  goto switch_break___35;
  case_2___21: /* CIL Label */ 
#line 4417
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4417
  ((struct OPERAND_0_mi *)kodp)->minor = 15;
#line 4417
  kodp += sizeof(struct OPERAND_0_mi );
#line 4417
  last_instr = current_instr;
#line 4417
  current_instr = kodp;
#line 4418
  goto switch_break___35;
  switch_default___32: /* CIL Label */ 
  {
#line 4420
  error_message(1005);
  }
  switch_break___35: /* CIL Label */ ;
  }
#line 4422
  type_ac[set] = (enum intern_arit_class )32;
#line 4423
  goto switch_break___32;
  case_2___22: /* CIL Label */ 
  {
#line 4427
  if ((unsigned int )type_ac[set] == 8U) {
#line 4427
    goto case_8___30;
  }
#line 4430
  if ((unsigned int )type_ac[set] == 64U) {
#line 4430
    goto case_64___30;
  }
#line 4433
  if ((unsigned int )type_ac[set] == 32U) {
#line 4433
    goto case_32___30;
  }
#line 4436
  if ((unsigned int )type_ac[set] == 2U) {
#line 4436
    goto case_2___23;
  }
#line 4438
  goto switch_default___33;
  case_8___30: /* CIL Label */ 
#line 4428
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4428
  ((struct OPERAND_0_mi *)kodp)->minor = 11;
#line 4428
  kodp += sizeof(struct OPERAND_0_mi );
#line 4428
  last_instr = current_instr;
#line 4428
  current_instr = kodp;
#line 4429
  goto switch_break___36;
  case_64___30: /* CIL Label */ 
#line 4431
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4431
  ((struct OPERAND_0_mi *)kodp)->minor = 14;
#line 4431
  kodp += sizeof(struct OPERAND_0_mi );
#line 4431
  last_instr = current_instr;
#line 4431
  current_instr = kodp;
#line 4432
  goto switch_break___36;
  case_32___30: /* CIL Label */ 
#line 4434
  ((struct OPERAND_0_mi *)kodp)->major = 44;
#line 4434
  ((struct OPERAND_0_mi *)kodp)->minor = 17;
#line 4434
  kodp += sizeof(struct OPERAND_0_mi );
#line 4434
  last_instr = current_instr;
#line 4434
  current_instr = kodp;
#line 4435
  goto switch_break___36;
  case_2___23: /* CIL Label */ 
#line 4437
  goto switch_break___36;
  switch_default___33: /* CIL Label */ 
  {
#line 4439
  error_message(1005);
  }
  switch_break___36: /* CIL Label */ ;
  }
#line 4441
  type_ac[set] = (enum intern_arit_class )2;
#line 4442
  goto switch_break___32;
  case_1___8: /* CIL Label */ 
  {
#line 4450
  if ((unsigned int )type_ac[set] == 1U) {
#line 4450
    goto case_1___9;
  }
#line 4450
  if ((unsigned int )type_ac[set] == 2U) {
#line 4450
    goto case_1___9;
  }
#line 4450
  if ((unsigned int )type_ac[set] == 64U) {
#line 4450
    goto case_1___9;
  }
#line 4450
  if ((unsigned int )type_ac[set] == 8U) {
#line 4450
    goto case_1___9;
  }
#line 4452
  goto switch_default___34;
  case_1___9: /* CIL Label */ 
  case_2___24: /* CIL Label */ 
  case_64___31: /* CIL Label */ 
  case_8___31: /* CIL Label */ 
#line 4451
  goto switch_break___37;
  switch_default___34: /* CIL Label */ 
  {
#line 4453
  error_message(1005);
  }
  switch_break___37: /* CIL Label */ ;
  }
#line 4455
  type_ac[set] = (enum intern_arit_class )1;
#line 4456
  goto switch_break___32;
  switch_default___35: /* CIL Label */ 
  {
#line 4458
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4459);
#line 4460
  error_message(5000);
#line 4461
  abort();
  }
  switch_break___32: /* CIL Label */ ;
  }
#line 4463
  goto switch_break___31;
  case_1030___2: /* CIL Label */ 
  case_1029___2: /* CIL Label */ 
  case_1025___2: /* CIL Label */ 
  {
#line 4467
  error_message(1020);
  }
#line 4468
  goto switch_break___31;
  case_1028___1: /* CIL Label */ 
#line 4470
  goto switch_break___31;
  switch_default___36: /* CIL Label */ 
  {
#line 4472
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4472);
#line 4473
  error_message(5002);
#line 4474
  abort();
  }
  switch_break___31: /* CIL Label */ ;
  }
#line 4476
  type_com[set] = typeh[type_spec_count];
#line 4477
  tmp___232 = type_spec_count;
#line 4477
  type_spec_count --;
#line 4477
  typeh[tmp___232] = (struct internal_type *)((void *)0);
#line 4479
  goto switch_break;
  case_306: /* CIL Label */ 
#line 4485
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4489
    error_message(1033, "*");
    }
  } else
#line 4485
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4489
    error_message(1033, "*");
    }
  } else
#line 4485
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4489
    error_message(1033, "*");
    }
  } else
#line 4485
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4489
    error_message(1033, "*");
    }
  }
  {
#line 4490
  tmp___233 = implicit_cast();
  }
#line 4490
  if (-1 == tmp___233) {
#line 4491
    no_compile_only = 0;
  }
#line 4492
  variable[set].adr = (char *)((void *)0);
#line 4492
  variable[set].offset = 0;
#line 4493
  subscript_flag[set] = 0;
#line 4493
  struct_union_field[set] = 0;
#line 4493
  type_ac[set] = (enum intern_arit_class )0;
#line 4493
  tmp___234 = set;
#line 4493
  set --;
#line 4493
  type_com[tmp___234] = (struct internal_type *)((void *)0);
#line 4493
  if (0 > set) {
    {
#line 4493
    error_message(5003);
    }
  }
#line 4494
  kodp3 = kodp;
  {
#line 4495
  if ((unsigned int )type_ac[set] == 136U) {
#line 4495
    goto case_136___26;
  }
#line 4495
  if ((unsigned int )type_ac[set] == 8U) {
#line 4495
    goto case_136___26;
  }
#line 4495
  if ((unsigned int )type_ac[set] == 264U) {
#line 4495
    goto case_264___25;
  }
#line 4495
  if ((unsigned int )type_ac[set] == 152U) {
#line 4495
    goto case_152___25;
  }
#line 4495
  if ((unsigned int )type_ac[set] == 24U) {
#line 4495
    goto case_152___25;
  }
#line 4495
  if ((unsigned int )type_ac[set] == 280U) {
#line 4495
    goto case_280___25;
  }
#line 4495
  if ((unsigned int )type_ac[set] == 64U) {
#line 4495
    goto case_64___32;
  }
#line 4495
  if ((unsigned int )type_ac[set] == 80U) {
#line 4495
    goto case_80___25;
  }
#line 4495
  if ((unsigned int )type_ac[set] == 32U) {
#line 4495
    goto case_32___31;
  }
#line 4495
  goto switch_default___37;
  case_136___26: /* CIL Label */ 
  case_8___32: /* CIL Label */ 
#line 4495
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4495
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4495
  kodp += sizeof(struct OPERAND_0_mi );
#line 4495
  goto switch_break___38;
  case_264___25: /* CIL Label */ 
#line 4495
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4495
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4495
  kodp += sizeof(struct OPERAND_0_mi );
#line 4495
  goto switch_break___38;
  case_152___25: /* CIL Label */ 
  case_24___25: /* CIL Label */ 
#line 4495
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4495
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4495
  kodp += sizeof(struct OPERAND_0_mi );
#line 4495
  goto switch_break___38;
  case_280___25: /* CIL Label */ 
#line 4495
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4495
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4495
  kodp += sizeof(struct OPERAND_0_mi );
#line 4495
  goto switch_break___38;
  case_64___32: /* CIL Label */ 
#line 4495
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4495
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4495
  kodp += sizeof(struct OPERAND_0_mi );
#line 4495
  goto switch_break___38;
  case_80___25: /* CIL Label */ 
#line 4495
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4495
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4495
  kodp += sizeof(struct OPERAND_0_mi );
#line 4495
  goto switch_break___38;
  case_32___31: /* CIL Label */ 
#line 4495
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4495
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4495
  kodp += sizeof(struct OPERAND_0_mi );
#line 4495
  goto switch_break___38;
  switch_default___37: /* CIL Label */ 
  {
#line 4495
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4495);
#line 4495
  error_message(5000);
  }
#line 4495
  return (0);
  switch_break___38: /* CIL Label */ ;
  }
#line 4496
  last_instr = current_instr;
#line 4496
  current_instr = kodp;
#line 4498
  goto switch_break;
  case_307: /* CIL Label */ 
#line 4501
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4505
    error_message(1033, "/");
    }
  } else
#line 4501
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4505
    error_message(1033, "/");
    }
  } else
#line 4501
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4505
    error_message(1033, "/");
    }
  } else
#line 4501
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4505
    error_message(1033, "/");
    }
  }
  {
#line 4506
  tmp___235 = implicit_cast();
  }
#line 4506
  if (-1 == tmp___235) {
#line 4507
    no_compile_only = 0;
  }
#line 4508
  variable[set].adr = (char *)((void *)0);
#line 4508
  variable[set].offset = 0;
#line 4509
  subscript_flag[set] = 0;
#line 4509
  struct_union_field[set] = 0;
#line 4509
  type_ac[set] = (enum intern_arit_class )0;
#line 4509
  tmp___236 = set;
#line 4509
  set --;
#line 4509
  type_com[tmp___236] = (struct internal_type *)((void *)0);
#line 4509
  if (0 > set) {
    {
#line 4509
    error_message(5003);
    }
  }
#line 4510
  kodp3 = kodp;
  {
#line 4511
  if ((unsigned int )type_ac[set] == 136U) {
#line 4511
    goto case_136___27;
  }
#line 4511
  if ((unsigned int )type_ac[set] == 8U) {
#line 4511
    goto case_136___27;
  }
#line 4511
  if ((unsigned int )type_ac[set] == 264U) {
#line 4511
    goto case_264___26;
  }
#line 4511
  if ((unsigned int )type_ac[set] == 152U) {
#line 4511
    goto case_152___26;
  }
#line 4511
  if ((unsigned int )type_ac[set] == 24U) {
#line 4511
    goto case_152___26;
  }
#line 4511
  if ((unsigned int )type_ac[set] == 280U) {
#line 4511
    goto case_280___26;
  }
#line 4511
  if ((unsigned int )type_ac[set] == 64U) {
#line 4511
    goto case_64___33;
  }
#line 4511
  if ((unsigned int )type_ac[set] == 80U) {
#line 4511
    goto case_80___26;
  }
#line 4511
  if ((unsigned int )type_ac[set] == 32U) {
#line 4511
    goto case_32___32;
  }
#line 4511
  goto switch_default___38;
  case_136___27: /* CIL Label */ 
  case_8___33: /* CIL Label */ 
#line 4511
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 4511
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4511
  kodp += sizeof(struct OPERAND_0_mi );
#line 4511
  goto switch_break___39;
  case_264___26: /* CIL Label */ 
#line 4511
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 4511
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4511
  kodp += sizeof(struct OPERAND_0_mi );
#line 4511
  goto switch_break___39;
  case_152___26: /* CIL Label */ 
  case_24___26: /* CIL Label */ 
#line 4511
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 4511
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4511
  kodp += sizeof(struct OPERAND_0_mi );
#line 4511
  goto switch_break___39;
  case_280___26: /* CIL Label */ 
#line 4511
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 4511
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4511
  kodp += sizeof(struct OPERAND_0_mi );
#line 4511
  goto switch_break___39;
  case_64___33: /* CIL Label */ 
#line 4511
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 4511
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4511
  kodp += sizeof(struct OPERAND_0_mi );
#line 4511
  goto switch_break___39;
  case_80___26: /* CIL Label */ 
#line 4511
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 4511
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4511
  kodp += sizeof(struct OPERAND_0_mi );
#line 4511
  goto switch_break___39;
  case_32___32: /* CIL Label */ 
#line 4511
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 4511
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4511
  kodp += sizeof(struct OPERAND_0_mi );
#line 4511
  goto switch_break___39;
  switch_default___38: /* CIL Label */ 
  {
#line 4511
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4511);
#line 4511
  error_message(5000);
  }
#line 4511
  return (0);
  switch_break___39: /* CIL Label */ ;
  }
#line 4512
  last_instr = current_instr;
#line 4512
  current_instr = kodp;
#line 4514
  goto switch_break;
  case_308: /* CIL Label */ 
#line 4517
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4521
    error_message(1033, "%");
    }
  } else
#line 4517
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4521
    error_message(1033, "%");
    }
  } else
#line 4517
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4521
    error_message(1033, "%");
    }
  } else
#line 4517
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4521
    error_message(1033, "%");
    }
  }
#line 4522
  if (8U == (unsigned int )type_ac[set]) {
#line 4524
    set --;
    {
#line 4526
    if ((unsigned int )type_ac[set] == 8U) {
#line 4526
      goto case_8___34;
    }
#line 4530
    goto switch_default___39;
    case_8___34: /* CIL Label */ 
#line 4527
    kodp3 = kodp;
#line 4528
    ((struct OPERAND_0_ma *)kodp)->major = 14;
#line 4528
    kodp += sizeof(struct OPERAND_0_ma );
#line 4528
    last_instr = current_instr;
#line 4528
    current_instr = kodp;
#line 4529
    goto switch_break___40;
    switch_default___39: /* CIL Label */ 
    {
#line 4531
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4531);
#line 4532
    error_message(5000);
    }
#line 4532
    return (0);
    switch_break___40: /* CIL Label */ ;
    }
  } else {
    {
#line 4536
    error_message(1005);
    }
  }
#line 4538
  goto switch_break;
  case_310: /* CIL Label */ 
#line 4544
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4544
    goto _L___22;
  } else
#line 4544
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___22: /* CIL Label */ 
#line 4547
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4547
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4547
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set])->output)->attribute.memory_size;
#line 4547
    kodp += sizeof(struct OPERAND_1_li );
#line 4548
    last_instr = current_instr;
#line 4548
    current_instr = kodp;
#line 4549
    ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4549
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4549
    kodp += sizeof(struct OPERAND_0_mi );
#line 4549
    last_instr = current_instr;
#line 4549
    current_instr = kodp;
#line 4550
    type_com[set - 1] = type_com[set];
  } else
#line 4552
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
#line 4552
    goto _L___21;
  } else
#line 4552
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    _L___21: /* CIL Label */ 
#line 4555
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4555
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4555
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set - 1])->output)->attribute.memory_size;
#line 4555
    kodp += sizeof(struct OPERAND_1_li );
#line 4556
    last_instr = current_instr;
#line 4556
    current_instr = kodp;
#line 4557
    ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4557
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4557
    kodp += sizeof(struct OPERAND_0_mi );
#line 4557
    last_instr = current_instr;
#line 4557
    current_instr = kodp;
  }
  {
#line 4559
  tmp___237 = implicit_cast();
  }
#line 4559
  if (-1 == tmp___237) {
#line 4560
    no_compile_only = 0;
  }
#line 4561
  variable[set].adr = (char *)((void *)0);
#line 4561
  variable[set].offset = 0;
#line 4562
  subscript_flag[set] = 0;
#line 4562
  struct_union_field[set] = 0;
#line 4562
  type_ac[set] = (enum intern_arit_class )0;
#line 4562
  tmp___238 = set;
#line 4562
  set --;
#line 4562
  type_com[tmp___238] = (struct internal_type *)((void *)0);
#line 4562
  if (0 > set) {
    {
#line 4562
    error_message(5003);
    }
  }
#line 4563
  kodp3 = kodp;
  {
#line 4564
  if ((unsigned int )type_ac[set] == 136U) {
#line 4564
    goto case_136___28;
  }
#line 4564
  if ((unsigned int )type_ac[set] == 8U) {
#line 4564
    goto case_136___28;
  }
#line 4564
  if ((unsigned int )type_ac[set] == 264U) {
#line 4564
    goto case_264___27;
  }
#line 4564
  if ((unsigned int )type_ac[set] == 152U) {
#line 4564
    goto case_152___27;
  }
#line 4564
  if ((unsigned int )type_ac[set] == 24U) {
#line 4564
    goto case_152___27;
  }
#line 4564
  if ((unsigned int )type_ac[set] == 280U) {
#line 4564
    goto case_280___27;
  }
#line 4564
  if ((unsigned int )type_ac[set] == 64U) {
#line 4564
    goto case_64___34;
  }
#line 4564
  if ((unsigned int )type_ac[set] == 80U) {
#line 4564
    goto case_80___27;
  }
#line 4564
  if ((unsigned int )type_ac[set] == 32U) {
#line 4564
    goto case_32___33;
  }
#line 4564
  goto switch_default___40;
  case_136___28: /* CIL Label */ 
  case_8___35: /* CIL Label */ 
#line 4564
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4564
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4564
  kodp += sizeof(struct OPERAND_0_mi );
#line 4564
  goto switch_break___41;
  case_264___27: /* CIL Label */ 
#line 4564
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4564
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4564
  kodp += sizeof(struct OPERAND_0_mi );
#line 4564
  goto switch_break___41;
  case_152___27: /* CIL Label */ 
  case_24___27: /* CIL Label */ 
#line 4564
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4564
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4564
  kodp += sizeof(struct OPERAND_0_mi );
#line 4564
  goto switch_break___41;
  case_280___27: /* CIL Label */ 
#line 4564
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4564
  ((struct OPERAND_0_mi *)kodp)->minor = 5;
#line 4564
  kodp += sizeof(struct OPERAND_0_mi );
#line 4564
  goto switch_break___41;
  case_64___34: /* CIL Label */ 
#line 4564
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4564
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4564
  kodp += sizeof(struct OPERAND_0_mi );
#line 4564
  goto switch_break___41;
  case_80___27: /* CIL Label */ 
#line 4564
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4564
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4564
  kodp += sizeof(struct OPERAND_0_mi );
#line 4564
  goto switch_break___41;
  case_32___33: /* CIL Label */ 
#line 4564
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 4564
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4564
  kodp += sizeof(struct OPERAND_0_mi );
#line 4564
  goto switch_break___41;
  switch_default___40: /* CIL Label */ 
  {
#line 4564
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4564);
#line 4564
  error_message(5000);
  }
#line 4564
  return (0);
  switch_break___41: /* CIL Label */ ;
  }
#line 4565
  last_instr = current_instr;
#line 4565
  current_instr = kodp;
#line 4567
  goto switch_break;
  case_311: /* CIL Label */ 
#line 4570
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4570
    goto _L___24;
  } else
#line 4570
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___24: /* CIL Label */ 
#line 4573
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4573
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4573
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set])->output)->attribute.memory_size;
#line 4573
    kodp += sizeof(struct OPERAND_1_li );
#line 4574
    last_instr = current_instr;
#line 4574
    current_instr = kodp;
#line 4575
    ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4575
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4575
    kodp += sizeof(struct OPERAND_0_mi );
#line 4575
    last_instr = current_instr;
#line 4575
    current_instr = kodp;
#line 4576
    type_com[set - 1] = type_com[set];
  } else
#line 4578
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
#line 4578
    goto _L___23;
  } else
#line 4578
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    _L___23: /* CIL Label */ 
#line 4581
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 4581
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 4581
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set - 1])->output)->attribute.memory_size;
#line 4581
    kodp += sizeof(struct OPERAND_1_li );
#line 4582
    last_instr = current_instr;
#line 4582
    current_instr = kodp;
#line 4583
    ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 4583
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4583
    kodp += sizeof(struct OPERAND_0_mi );
#line 4583
    last_instr = current_instr;
#line 4583
    current_instr = kodp;
  }
  {
#line 4585
  tmp___239 = implicit_cast();
  }
#line 4585
  if (-1 == tmp___239) {
#line 4586
    no_compile_only = 0;
  }
#line 4587
  variable[set].adr = (char *)((void *)0);
#line 4587
  variable[set].offset = 0;
#line 4588
  subscript_flag[set] = 0;
#line 4588
  struct_union_field[set] = 0;
#line 4588
  type_ac[set] = (enum intern_arit_class )0;
#line 4588
  tmp___240 = set;
#line 4588
  set --;
#line 4588
  type_com[tmp___240] = (struct internal_type *)((void *)0);
#line 4588
  if (0 > set) {
    {
#line 4588
    error_message(5003);
    }
  }
#line 4589
  kodp3 = kodp;
  {
#line 4590
  if ((unsigned int )type_ac[set] == 136U) {
#line 4590
    goto case_136___29;
  }
#line 4590
  if ((unsigned int )type_ac[set] == 8U) {
#line 4590
    goto case_136___29;
  }
#line 4590
  if ((unsigned int )type_ac[set] == 264U) {
#line 4590
    goto case_264___28;
  }
#line 4590
  if ((unsigned int )type_ac[set] == 152U) {
#line 4590
    goto case_152___28;
  }
#line 4590
  if ((unsigned int )type_ac[set] == 24U) {
#line 4590
    goto case_152___28;
  }
#line 4590
  if ((unsigned int )type_ac[set] == 280U) {
#line 4590
    goto case_280___28;
  }
#line 4590
  if ((unsigned int )type_ac[set] == 64U) {
#line 4590
    goto case_64___35;
  }
#line 4590
  if ((unsigned int )type_ac[set] == 80U) {
#line 4590
    goto case_80___28;
  }
#line 4590
  if ((unsigned int )type_ac[set] == 32U) {
#line 4590
    goto case_32___34;
  }
#line 4590
  goto switch_default___41;
  case_136___29: /* CIL Label */ 
  case_8___36: /* CIL Label */ 
#line 4590
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4590
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4590
  kodp += sizeof(struct OPERAND_0_mi );
#line 4590
  goto switch_break___42;
  case_264___28: /* CIL Label */ 
#line 4590
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4590
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4590
  kodp += sizeof(struct OPERAND_0_mi );
#line 4590
  goto switch_break___42;
  case_152___28: /* CIL Label */ 
  case_24___28: /* CIL Label */ 
#line 4590
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4590
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4590
  kodp += sizeof(struct OPERAND_0_mi );
#line 4590
  goto switch_break___42;
  case_280___28: /* CIL Label */ 
#line 4590
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4590
  ((struct OPERAND_0_mi *)kodp)->minor = 4;
#line 4590
  kodp += sizeof(struct OPERAND_0_mi );
#line 4590
  goto switch_break___42;
  case_64___35: /* CIL Label */ 
#line 4590
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4590
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4590
  kodp += sizeof(struct OPERAND_0_mi );
#line 4590
  goto switch_break___42;
  case_80___28: /* CIL Label */ 
#line 4590
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4590
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4590
  kodp += sizeof(struct OPERAND_0_mi );
#line 4590
  goto switch_break___42;
  case_32___34: /* CIL Label */ 
#line 4590
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 4590
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4590
  kodp += sizeof(struct OPERAND_0_mi );
#line 4590
  goto switch_break___42;
  switch_default___41: /* CIL Label */ 
  {
#line 4590
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4590);
#line 4590
  error_message(5000);
  }
#line 4590
  return (0);
  switch_break___42: /* CIL Label */ ;
  }
#line 4591
  last_instr = current_instr;
#line 4591
  current_instr = kodp;
#line 4593
  goto switch_break;
  case_313: /* CIL Label */ 
#line 4599
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4603
    error_message(1033, "<<");
    }
  } else
#line 4599
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4603
    error_message(1033, "<<");
    }
  } else
#line 4599
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4603
    error_message(1033, "<<");
    }
  } else
#line 4599
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4603
    error_message(1033, "<<");
    }
  }
#line 4604
  if (error_count) {
#line 4604
    goto switch_break;
  }
#line 4605
  if (8U == (unsigned int )type_ac[set]) {
#line 4607
    set --;
    {
#line 4609
    if ((unsigned int )type_ac[set] == 8U) {
#line 4609
      goto case_8___37;
    }
#line 4613
    goto switch_default___42;
    case_8___37: /* CIL Label */ 
#line 4610
    kodp3 = kodp;
#line 4611
    ((struct OPERAND_0_ma *)kodp)->major = 47;
#line 4611
    kodp += sizeof(struct OPERAND_0_ma );
#line 4612
    goto switch_break___43;
    switch_default___42: /* CIL Label */ 
    {
#line 4614
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4615);
#line 4616
    error_message(5000);
    }
#line 4616
    return (0);
    switch_break___43: /* CIL Label */ ;
    }
  } else {
    {
#line 4620
    error_message(1005);
    }
  }
#line 4621
  last_instr = current_instr;
#line 4621
  current_instr = kodp;
#line 4623
  goto switch_break;
  case_314: /* CIL Label */ 
#line 4626
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4630
    error_message(1033, ">>");
    }
  } else
#line 4626
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4630
    error_message(1033, ">>");
    }
  } else
#line 4626
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4630
    error_message(1033, ">>");
    }
  } else
#line 4626
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4630
    error_message(1033, ">>");
    }
  }
#line 4631
  if (8U == (unsigned int )type_ac[set]) {
#line 4633
    set --;
    {
#line 4635
    if ((unsigned int )type_ac[set] == 8U) {
#line 4635
      goto case_8___38;
    }
#line 4639
    goto switch_default___43;
    case_8___38: /* CIL Label */ 
#line 4636
    kodp3 = kodp;
#line 4637
    ((struct OPERAND_0_ma *)kodp)->major = 48;
#line 4637
    kodp += sizeof(struct OPERAND_0_ma );
#line 4638
    goto switch_break___44;
    switch_default___43: /* CIL Label */ 
    {
#line 4640
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4640);
#line 4641
    error_message(5000);
    }
#line 4641
    return (0);
    switch_break___44: /* CIL Label */ ;
    }
  } else {
    {
#line 4645
    error_message(1005);
    }
  }
#line 4646
  last_instr = current_instr;
#line 4646
  current_instr = kodp;
#line 4648
  goto switch_break;
  case_316: /* CIL Label */ 
#line 4654
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4656
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4654
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4656
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4658
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4660
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  } else
#line 4658
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4660
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  }
  {
#line 4662
  tmp___241 = implicit_cast();
  }
#line 4662
  if (-1 == tmp___241) {
#line 4663
    no_compile_only = 0;
  }
#line 4664
  variable[set].adr = (char *)((void *)0);
#line 4664
  variable[set].offset = 0;
#line 4665
  subscript_flag[set] = 0;
#line 4665
  struct_union_field[set] = 0;
#line 4665
  type_ac[set] = (enum intern_arit_class )0;
#line 4665
  tmp___242 = set;
#line 4665
  set --;
#line 4665
  type_com[tmp___242] = (struct internal_type *)((void *)0);
#line 4665
  if (0 > set) {
    {
#line 4665
    error_message(5003);
    }
  }
#line 4666
  kodp3 = kodp;
  {
#line 4667
  if ((unsigned int )type_ac[set] == 136U) {
#line 4667
    goto case_136___30;
  }
#line 4667
  if ((unsigned int )type_ac[set] == 8U) {
#line 4667
    goto case_136___30;
  }
#line 4667
  if ((unsigned int )type_ac[set] == 264U) {
#line 4667
    goto case_264___29;
  }
#line 4667
  if ((unsigned int )type_ac[set] == 152U) {
#line 4667
    goto case_152___29;
  }
#line 4667
  if ((unsigned int )type_ac[set] == 24U) {
#line 4667
    goto case_152___29;
  }
#line 4667
  if ((unsigned int )type_ac[set] == 280U) {
#line 4667
    goto case_280___29;
  }
#line 4667
  if ((unsigned int )type_ac[set] == 64U) {
#line 4667
    goto case_64___36;
  }
#line 4667
  if ((unsigned int )type_ac[set] == 80U) {
#line 4667
    goto case_80___29;
  }
#line 4667
  if ((unsigned int )type_ac[set] == 32U) {
#line 4667
    goto case_32___35;
  }
#line 4667
  goto switch_default___44;
  case_136___30: /* CIL Label */ 
  case_8___39: /* CIL Label */ 
#line 4667
  ((struct OPERAND_0_mi *)kodp)->major = 20;
#line 4667
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4667
  kodp += sizeof(struct OPERAND_0_mi );
#line 4667
  goto switch_break___45;
  case_264___29: /* CIL Label */ 
#line 4667
  ((struct OPERAND_0_mi *)kodp)->major = 20;
#line 4667
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4667
  kodp += sizeof(struct OPERAND_0_mi );
#line 4667
  goto switch_break___45;
  case_152___29: /* CIL Label */ 
  case_24___29: /* CIL Label */ 
#line 4667
  ((struct OPERAND_0_mi *)kodp)->major = 20;
#line 4667
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4667
  kodp += sizeof(struct OPERAND_0_mi );
#line 4667
  goto switch_break___45;
  case_280___29: /* CIL Label */ 
#line 4667
  ((struct OPERAND_0_mi *)kodp)->major = 20;
#line 4667
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4667
  kodp += sizeof(struct OPERAND_0_mi );
#line 4667
  goto switch_break___45;
  case_64___36: /* CIL Label */ 
#line 4667
  ((struct OPERAND_0_mi *)kodp)->major = 20;
#line 4667
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4667
  kodp += sizeof(struct OPERAND_0_mi );
#line 4667
  goto switch_break___45;
  case_80___29: /* CIL Label */ 
#line 4667
  ((struct OPERAND_0_mi *)kodp)->major = 20;
#line 4667
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4667
  kodp += sizeof(struct OPERAND_0_mi );
#line 4667
  goto switch_break___45;
  case_32___35: /* CIL Label */ 
#line 4667
  ((struct OPERAND_0_mi *)kodp)->major = 20;
#line 4667
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4667
  kodp += sizeof(struct OPERAND_0_mi );
#line 4667
  goto switch_break___45;
  switch_default___44: /* CIL Label */ 
  {
#line 4667
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4667);
#line 4667
  error_message(5000);
  }
#line 4667
  return (0);
  switch_break___45: /* CIL Label */ ;
  }
#line 4668
  last_instr = current_instr;
#line 4668
  current_instr = kodp;
#line 4668
  type_ac[set] = (enum intern_arit_class )8;
#line 4670
  goto switch_break;
  case_317: /* CIL Label */ 
#line 4673
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4675
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4673
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4675
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4677
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4679
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  } else
#line 4677
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4679
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  }
  {
#line 4681
  tmp___243 = implicit_cast();
  }
#line 4681
  if (-1 == tmp___243) {
#line 4682
    no_compile_only = 0;
  }
#line 4683
  variable[set].adr = (char *)((void *)0);
#line 4683
  variable[set].offset = 0;
#line 4684
  subscript_flag[set] = 0;
#line 4684
  struct_union_field[set] = 0;
#line 4684
  type_ac[set] = (enum intern_arit_class )0;
#line 4684
  tmp___244 = set;
#line 4684
  set --;
#line 4684
  type_com[tmp___244] = (struct internal_type *)((void *)0);
#line 4684
  if (0 > set) {
    {
#line 4684
    error_message(5003);
    }
  }
#line 4685
  kodp3 = kodp;
  {
#line 4686
  if ((unsigned int )type_ac[set] == 136U) {
#line 4686
    goto case_136___31;
  }
#line 4686
  if ((unsigned int )type_ac[set] == 8U) {
#line 4686
    goto case_136___31;
  }
#line 4686
  if ((unsigned int )type_ac[set] == 264U) {
#line 4686
    goto case_264___30;
  }
#line 4686
  if ((unsigned int )type_ac[set] == 152U) {
#line 4686
    goto case_152___30;
  }
#line 4686
  if ((unsigned int )type_ac[set] == 24U) {
#line 4686
    goto case_152___30;
  }
#line 4686
  if ((unsigned int )type_ac[set] == 280U) {
#line 4686
    goto case_280___30;
  }
#line 4686
  if ((unsigned int )type_ac[set] == 64U) {
#line 4686
    goto case_64___37;
  }
#line 4686
  if ((unsigned int )type_ac[set] == 80U) {
#line 4686
    goto case_80___30;
  }
#line 4686
  if ((unsigned int )type_ac[set] == 32U) {
#line 4686
    goto case_32___36;
  }
#line 4686
  goto switch_default___45;
  case_136___31: /* CIL Label */ 
  case_8___40: /* CIL Label */ 
#line 4686
  ((struct OPERAND_0_mi *)kodp)->major = 21;
#line 4686
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4686
  kodp += sizeof(struct OPERAND_0_mi );
#line 4686
  goto switch_break___46;
  case_264___30: /* CIL Label */ 
#line 4686
  ((struct OPERAND_0_mi *)kodp)->major = 21;
#line 4686
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4686
  kodp += sizeof(struct OPERAND_0_mi );
#line 4686
  goto switch_break___46;
  case_152___30: /* CIL Label */ 
  case_24___30: /* CIL Label */ 
#line 4686
  ((struct OPERAND_0_mi *)kodp)->major = 21;
#line 4686
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4686
  kodp += sizeof(struct OPERAND_0_mi );
#line 4686
  goto switch_break___46;
  case_280___30: /* CIL Label */ 
#line 4686
  ((struct OPERAND_0_mi *)kodp)->major = 21;
#line 4686
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4686
  kodp += sizeof(struct OPERAND_0_mi );
#line 4686
  goto switch_break___46;
  case_64___37: /* CIL Label */ 
#line 4686
  ((struct OPERAND_0_mi *)kodp)->major = 21;
#line 4686
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4686
  kodp += sizeof(struct OPERAND_0_mi );
#line 4686
  goto switch_break___46;
  case_80___30: /* CIL Label */ 
#line 4686
  ((struct OPERAND_0_mi *)kodp)->major = 21;
#line 4686
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4686
  kodp += sizeof(struct OPERAND_0_mi );
#line 4686
  goto switch_break___46;
  case_32___36: /* CIL Label */ 
#line 4686
  ((struct OPERAND_0_mi *)kodp)->major = 21;
#line 4686
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4686
  kodp += sizeof(struct OPERAND_0_mi );
#line 4686
  goto switch_break___46;
  switch_default___45: /* CIL Label */ 
  {
#line 4686
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4686);
#line 4686
  error_message(5000);
  }
#line 4686
  return (0);
  switch_break___46: /* CIL Label */ ;
  }
#line 4687
  last_instr = current_instr;
#line 4687
  current_instr = kodp;
#line 4687
  type_ac[set] = (enum intern_arit_class )8;
#line 4689
  goto switch_break;
  case_318: /* CIL Label */ 
#line 4692
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4694
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4692
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4694
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4696
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4698
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  } else
#line 4696
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4698
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  }
  {
#line 4700
  tmp___245 = implicit_cast();
  }
#line 4700
  if (-1 == tmp___245) {
#line 4701
    no_compile_only = 0;
  }
#line 4702
  variable[set].adr = (char *)((void *)0);
#line 4702
  variable[set].offset = 0;
#line 4703
  subscript_flag[set] = 0;
#line 4703
  struct_union_field[set] = 0;
#line 4703
  type_ac[set] = (enum intern_arit_class )0;
#line 4703
  tmp___246 = set;
#line 4703
  set --;
#line 4703
  type_com[tmp___246] = (struct internal_type *)((void *)0);
#line 4703
  if (0 > set) {
    {
#line 4703
    error_message(5003);
    }
  }
#line 4704
  kodp3 = kodp;
  {
#line 4705
  if ((unsigned int )type_ac[set] == 136U) {
#line 4705
    goto case_136___32;
  }
#line 4705
  if ((unsigned int )type_ac[set] == 8U) {
#line 4705
    goto case_136___32;
  }
#line 4705
  if ((unsigned int )type_ac[set] == 264U) {
#line 4705
    goto case_264___31;
  }
#line 4705
  if ((unsigned int )type_ac[set] == 152U) {
#line 4705
    goto case_152___31;
  }
#line 4705
  if ((unsigned int )type_ac[set] == 24U) {
#line 4705
    goto case_152___31;
  }
#line 4705
  if ((unsigned int )type_ac[set] == 280U) {
#line 4705
    goto case_280___31;
  }
#line 4705
  if ((unsigned int )type_ac[set] == 64U) {
#line 4705
    goto case_64___38;
  }
#line 4705
  if ((unsigned int )type_ac[set] == 80U) {
#line 4705
    goto case_80___31;
  }
#line 4705
  if ((unsigned int )type_ac[set] == 32U) {
#line 4705
    goto case_32___37;
  }
#line 4705
  goto switch_default___46;
  case_136___32: /* CIL Label */ 
  case_8___41: /* CIL Label */ 
#line 4705
  ((struct OPERAND_0_mi *)kodp)->major = 22;
#line 4705
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4705
  kodp += sizeof(struct OPERAND_0_mi );
#line 4705
  goto switch_break___47;
  case_264___31: /* CIL Label */ 
#line 4705
  ((struct OPERAND_0_mi *)kodp)->major = 22;
#line 4705
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4705
  kodp += sizeof(struct OPERAND_0_mi );
#line 4705
  goto switch_break___47;
  case_152___31: /* CIL Label */ 
  case_24___31: /* CIL Label */ 
#line 4705
  ((struct OPERAND_0_mi *)kodp)->major = 22;
#line 4705
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4705
  kodp += sizeof(struct OPERAND_0_mi );
#line 4705
  goto switch_break___47;
  case_280___31: /* CIL Label */ 
#line 4705
  ((struct OPERAND_0_mi *)kodp)->major = 22;
#line 4705
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4705
  kodp += sizeof(struct OPERAND_0_mi );
#line 4705
  goto switch_break___47;
  case_64___38: /* CIL Label */ 
#line 4705
  ((struct OPERAND_0_mi *)kodp)->major = 22;
#line 4705
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4705
  kodp += sizeof(struct OPERAND_0_mi );
#line 4705
  goto switch_break___47;
  case_80___31: /* CIL Label */ 
#line 4705
  ((struct OPERAND_0_mi *)kodp)->major = 22;
#line 4705
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4705
  kodp += sizeof(struct OPERAND_0_mi );
#line 4705
  goto switch_break___47;
  case_32___37: /* CIL Label */ 
#line 4705
  ((struct OPERAND_0_mi *)kodp)->major = 22;
#line 4705
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4705
  kodp += sizeof(struct OPERAND_0_mi );
#line 4705
  goto switch_break___47;
  switch_default___46: /* CIL Label */ 
  {
#line 4705
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4705);
#line 4705
  error_message(5000);
  }
#line 4705
  return (0);
  switch_break___47: /* CIL Label */ ;
  }
#line 4706
  last_instr = current_instr;
#line 4706
  current_instr = kodp;
#line 4706
  type_ac[set] = (enum intern_arit_class )8;
#line 4708
  goto switch_break;
  case_319: /* CIL Label */ 
#line 4711
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4713
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4711
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4713
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4715
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4717
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  } else
#line 4715
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4717
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  }
  {
#line 4719
  tmp___247 = implicit_cast();
  }
#line 4719
  if (-1 == tmp___247) {
#line 4720
    no_compile_only = 0;
  }
#line 4721
  variable[set].adr = (char *)((void *)0);
#line 4721
  variable[set].offset = 0;
#line 4722
  subscript_flag[set] = 0;
#line 4722
  struct_union_field[set] = 0;
#line 4722
  type_ac[set] = (enum intern_arit_class )0;
#line 4722
  tmp___248 = set;
#line 4722
  set --;
#line 4722
  type_com[tmp___248] = (struct internal_type *)((void *)0);
#line 4722
  if (0 > set) {
    {
#line 4722
    error_message(5003);
    }
  }
#line 4723
  kodp3 = kodp;
  {
#line 4724
  if ((unsigned int )type_ac[set] == 136U) {
#line 4724
    goto case_136___33;
  }
#line 4724
  if ((unsigned int )type_ac[set] == 8U) {
#line 4724
    goto case_136___33;
  }
#line 4724
  if ((unsigned int )type_ac[set] == 264U) {
#line 4724
    goto case_264___32;
  }
#line 4724
  if ((unsigned int )type_ac[set] == 152U) {
#line 4724
    goto case_152___32;
  }
#line 4724
  if ((unsigned int )type_ac[set] == 24U) {
#line 4724
    goto case_152___32;
  }
#line 4724
  if ((unsigned int )type_ac[set] == 280U) {
#line 4724
    goto case_280___32;
  }
#line 4724
  if ((unsigned int )type_ac[set] == 64U) {
#line 4724
    goto case_64___39;
  }
#line 4724
  if ((unsigned int )type_ac[set] == 80U) {
#line 4724
    goto case_80___32;
  }
#line 4724
  if ((unsigned int )type_ac[set] == 32U) {
#line 4724
    goto case_32___38;
  }
#line 4724
  goto switch_default___47;
  case_136___33: /* CIL Label */ 
  case_8___42: /* CIL Label */ 
#line 4724
  ((struct OPERAND_0_mi *)kodp)->major = 23;
#line 4724
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4724
  kodp += sizeof(struct OPERAND_0_mi );
#line 4724
  goto switch_break___48;
  case_264___32: /* CIL Label */ 
#line 4724
  ((struct OPERAND_0_mi *)kodp)->major = 23;
#line 4724
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4724
  kodp += sizeof(struct OPERAND_0_mi );
#line 4724
  goto switch_break___48;
  case_152___32: /* CIL Label */ 
  case_24___32: /* CIL Label */ 
#line 4724
  ((struct OPERAND_0_mi *)kodp)->major = 23;
#line 4724
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4724
  kodp += sizeof(struct OPERAND_0_mi );
#line 4724
  goto switch_break___48;
  case_280___32: /* CIL Label */ 
#line 4724
  ((struct OPERAND_0_mi *)kodp)->major = 23;
#line 4724
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4724
  kodp += sizeof(struct OPERAND_0_mi );
#line 4724
  goto switch_break___48;
  case_64___39: /* CIL Label */ 
#line 4724
  ((struct OPERAND_0_mi *)kodp)->major = 23;
#line 4724
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4724
  kodp += sizeof(struct OPERAND_0_mi );
#line 4724
  goto switch_break___48;
  case_80___32: /* CIL Label */ 
#line 4724
  ((struct OPERAND_0_mi *)kodp)->major = 23;
#line 4724
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4724
  kodp += sizeof(struct OPERAND_0_mi );
#line 4724
  goto switch_break___48;
  case_32___38: /* CIL Label */ 
#line 4724
  ((struct OPERAND_0_mi *)kodp)->major = 23;
#line 4724
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4724
  kodp += sizeof(struct OPERAND_0_mi );
#line 4724
  goto switch_break___48;
  switch_default___47: /* CIL Label */ 
  {
#line 4724
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4724);
#line 4724
  error_message(5000);
  }
#line 4724
  return (0);
  switch_break___48: /* CIL Label */ ;
  }
#line 4725
  last_instr = current_instr;
#line 4725
  current_instr = kodp;
#line 4725
  type_ac[set] = (enum intern_arit_class )8;
#line 4727
  goto switch_break;
  case_321: /* CIL Label */ 
#line 4733
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4735
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4733
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4735
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4737
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4739
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  } else
#line 4737
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4739
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  }
  {
#line 4741
  tmp___249 = implicit_cast();
  }
#line 4741
  if (-1 == tmp___249) {
#line 4742
    no_compile_only = 0;
  }
#line 4743
  variable[set].adr = (char *)((void *)0);
#line 4743
  variable[set].offset = 0;
#line 4744
  subscript_flag[set] = 0;
#line 4744
  struct_union_field[set] = 0;
#line 4744
  type_ac[set] = (enum intern_arit_class )0;
#line 4744
  tmp___250 = set;
#line 4744
  set --;
#line 4744
  type_com[tmp___250] = (struct internal_type *)((void *)0);
#line 4744
  if (0 > set) {
    {
#line 4744
    error_message(5003);
    }
  }
#line 4745
  kodp3 = kodp;
  {
#line 4746
  if ((unsigned int )type_ac[set] == 136U) {
#line 4746
    goto case_136___34;
  }
#line 4746
  if ((unsigned int )type_ac[set] == 8U) {
#line 4746
    goto case_136___34;
  }
#line 4746
  if ((unsigned int )type_ac[set] == 264U) {
#line 4746
    goto case_264___33;
  }
#line 4746
  if ((unsigned int )type_ac[set] == 152U) {
#line 4746
    goto case_152___33;
  }
#line 4746
  if ((unsigned int )type_ac[set] == 24U) {
#line 4746
    goto case_152___33;
  }
#line 4746
  if ((unsigned int )type_ac[set] == 280U) {
#line 4746
    goto case_280___33;
  }
#line 4746
  if ((unsigned int )type_ac[set] == 64U) {
#line 4746
    goto case_64___40;
  }
#line 4746
  if ((unsigned int )type_ac[set] == 80U) {
#line 4746
    goto case_80___33;
  }
#line 4746
  if ((unsigned int )type_ac[set] == 32U) {
#line 4746
    goto case_32___39;
  }
#line 4746
  goto switch_default___48;
  case_136___34: /* CIL Label */ 
  case_8___43: /* CIL Label */ 
#line 4746
  ((struct OPERAND_0_mi *)kodp)->major = 19;
#line 4746
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4746
  kodp += sizeof(struct OPERAND_0_mi );
#line 4746
  goto switch_break___49;
  case_264___33: /* CIL Label */ 
#line 4746
  ((struct OPERAND_0_mi *)kodp)->major = 19;
#line 4746
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4746
  kodp += sizeof(struct OPERAND_0_mi );
#line 4746
  goto switch_break___49;
  case_152___33: /* CIL Label */ 
  case_24___33: /* CIL Label */ 
#line 4746
  ((struct OPERAND_0_mi *)kodp)->major = 19;
#line 4746
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4746
  kodp += sizeof(struct OPERAND_0_mi );
#line 4746
  goto switch_break___49;
  case_280___33: /* CIL Label */ 
#line 4746
  ((struct OPERAND_0_mi *)kodp)->major = 19;
#line 4746
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4746
  kodp += sizeof(struct OPERAND_0_mi );
#line 4746
  goto switch_break___49;
  case_64___40: /* CIL Label */ 
#line 4746
  ((struct OPERAND_0_mi *)kodp)->major = 19;
#line 4746
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4746
  kodp += sizeof(struct OPERAND_0_mi );
#line 4746
  goto switch_break___49;
  case_80___33: /* CIL Label */ 
#line 4746
  ((struct OPERAND_0_mi *)kodp)->major = 19;
#line 4746
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4746
  kodp += sizeof(struct OPERAND_0_mi );
#line 4746
  goto switch_break___49;
  case_32___39: /* CIL Label */ 
#line 4746
  ((struct OPERAND_0_mi *)kodp)->major = 19;
#line 4746
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4746
  kodp += sizeof(struct OPERAND_0_mi );
#line 4746
  goto switch_break___49;
  switch_default___48: /* CIL Label */ 
  {
#line 4746
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4746);
#line 4746
  error_message(5000);
  }
#line 4746
  return (0);
  switch_break___49: /* CIL Label */ ;
  }
#line 4747
  last_instr = current_instr;
#line 4747
  current_instr = kodp;
#line 4747
  type_ac[set] = (enum intern_arit_class )8;
#line 4749
  goto switch_break;
  case_322: /* CIL Label */ 
#line 4752
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4754
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4752
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4754
    error_message(6024, type_com[set], type_com[set - 1]);
    }
  } else
#line 4756
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4758
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  } else
#line 4756
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4758
    error_message(6024, type_com[set - 1], type_com[set]);
    }
  }
  {
#line 4760
  tmp___251 = implicit_cast();
  }
#line 4760
  if (-1 == tmp___251) {
#line 4761
    no_compile_only = 0;
  }
#line 4762
  variable[set].adr = (char *)((void *)0);
#line 4762
  variable[set].offset = 0;
#line 4763
  subscript_flag[set] = 0;
#line 4763
  struct_union_field[set] = 0;
#line 4763
  type_ac[set] = (enum intern_arit_class )0;
#line 4763
  tmp___252 = set;
#line 4763
  set --;
#line 4763
  type_com[tmp___252] = (struct internal_type *)((void *)0);
#line 4763
  if (0 > set) {
    {
#line 4763
    error_message(5003);
    }
  }
#line 4764
  kodp3 = kodp;
  {
#line 4765
  if ((unsigned int )type_ac[set] == 136U) {
#line 4765
    goto case_136___35;
  }
#line 4765
  if ((unsigned int )type_ac[set] == 8U) {
#line 4765
    goto case_136___35;
  }
#line 4765
  if ((unsigned int )type_ac[set] == 264U) {
#line 4765
    goto case_264___34;
  }
#line 4765
  if ((unsigned int )type_ac[set] == 152U) {
#line 4765
    goto case_152___34;
  }
#line 4765
  if ((unsigned int )type_ac[set] == 24U) {
#line 4765
    goto case_152___34;
  }
#line 4765
  if ((unsigned int )type_ac[set] == 280U) {
#line 4765
    goto case_280___34;
  }
#line 4765
  if ((unsigned int )type_ac[set] == 64U) {
#line 4765
    goto case_64___41;
  }
#line 4765
  if ((unsigned int )type_ac[set] == 80U) {
#line 4765
    goto case_80___34;
  }
#line 4765
  if ((unsigned int )type_ac[set] == 32U) {
#line 4765
    goto case_32___40;
  }
#line 4765
  goto switch_default___49;
  case_136___35: /* CIL Label */ 
  case_8___44: /* CIL Label */ 
#line 4765
  ((struct OPERAND_0_mi *)kodp)->major = 24;
#line 4765
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4765
  kodp += sizeof(struct OPERAND_0_mi );
#line 4765
  goto switch_break___50;
  case_264___34: /* CIL Label */ 
#line 4765
  ((struct OPERAND_0_mi *)kodp)->major = 24;
#line 4765
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4765
  kodp += sizeof(struct OPERAND_0_mi );
#line 4765
  goto switch_break___50;
  case_152___34: /* CIL Label */ 
  case_24___34: /* CIL Label */ 
#line 4765
  ((struct OPERAND_0_mi *)kodp)->major = 24;
#line 4765
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4765
  kodp += sizeof(struct OPERAND_0_mi );
#line 4765
  goto switch_break___50;
  case_280___34: /* CIL Label */ 
#line 4765
  ((struct OPERAND_0_mi *)kodp)->major = 24;
#line 4765
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4765
  kodp += sizeof(struct OPERAND_0_mi );
#line 4765
  goto switch_break___50;
  case_64___41: /* CIL Label */ 
#line 4765
  ((struct OPERAND_0_mi *)kodp)->major = 24;
#line 4765
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4765
  kodp += sizeof(struct OPERAND_0_mi );
#line 4765
  goto switch_break___50;
  case_80___34: /* CIL Label */ 
#line 4765
  ((struct OPERAND_0_mi *)kodp)->major = 24;
#line 4765
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4765
  kodp += sizeof(struct OPERAND_0_mi );
#line 4765
  goto switch_break___50;
  case_32___40: /* CIL Label */ 
#line 4765
  ((struct OPERAND_0_mi *)kodp)->major = 24;
#line 4765
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4765
  kodp += sizeof(struct OPERAND_0_mi );
#line 4765
  goto switch_break___50;
  switch_default___49: /* CIL Label */ 
  {
#line 4765
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4765);
#line 4765
  error_message(5000);
  }
#line 4765
  return (0);
  switch_break___50: /* CIL Label */ ;
  }
#line 4766
  last_instr = current_instr;
#line 4766
  current_instr = kodp;
#line 4766
  type_ac[set] = (enum intern_arit_class )8;
#line 4768
  goto switch_break;
  case_324: /* CIL Label */ 
#line 4778
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4782
    error_message(1033, "&");
    }
  } else
#line 4778
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4782
    error_message(1033, "&");
    }
  } else
#line 4778
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4782
    error_message(1033, "&");
    }
  } else
#line 4778
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4782
    error_message(1033, "&");
    }
  }
#line 4783
  if (8U == (unsigned int )type_ac[set]) {
#line 4785
    set --;
    {
#line 4787
    if ((unsigned int )type_ac[set] == 8U) {
#line 4787
      goto case_8___45;
    }
#line 4791
    goto switch_default___50;
    case_8___45: /* CIL Label */ 
#line 4788
    kodp3 = kodp;
#line 4789
    ((struct OPERAND_0_ma *)kodp)->major = 18;
#line 4789
    kodp += sizeof(struct OPERAND_0_ma );
#line 4790
    goto switch_break___51;
    switch_default___50: /* CIL Label */ 
    {
#line 4792
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4792);
#line 4793
    error_message(5000);
    }
#line 4793
    return (0);
    switch_break___51: /* CIL Label */ ;
    }
  } else {
    {
#line 4797
    error_message(1005);
    }
  }
#line 4798
  last_instr = current_instr;
#line 4798
  current_instr = kodp;
#line 4800
  goto switch_break;
  case_326: /* CIL Label */ 
#line 4806
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4810
    error_message(1033, "^");
    }
  } else
#line 4806
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4810
    error_message(1033, "^");
    }
  } else
#line 4806
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4810
    error_message(1033, "^");
    }
  } else
#line 4806
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4810
    error_message(1033, "^");
    }
  }
#line 4811
  if (8U == (unsigned int )type_ac[set]) {
#line 4813
    set --;
    {
#line 4815
    if ((unsigned int )type_ac[set] == 8U) {
#line 4815
      goto case_8___46;
    }
#line 4819
    goto switch_default___51;
    case_8___46: /* CIL Label */ 
#line 4816
    kodp3 = kodp;
#line 4817
    ((struct OPERAND_0_ma *)kodp)->major = 49;
#line 4817
    kodp += sizeof(struct OPERAND_0_ma );
#line 4818
    goto switch_break___52;
    switch_default___51: /* CIL Label */ 
    {
#line 4820
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4820);
#line 4821
    error_message(5000);
    }
#line 4821
    return (0);
    switch_break___52: /* CIL Label */ ;
    }
  } else {
    {
#line 4825
    error_message(1005);
    }
  }
#line 4826
  last_instr = current_instr;
#line 4826
  current_instr = kodp;
#line 4828
  goto switch_break;
  case_328: /* CIL Label */ 
#line 4834
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4838
    error_message(1033, "|");
    }
  } else
#line 4834
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 4838
    error_message(1033, "|");
    }
  } else
#line 4834
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4838
    error_message(1033, "|");
    }
  } else
#line 4834
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 4838
    error_message(1033, "|");
    }
  }
#line 4839
  if (8U == (unsigned int )type_ac[set]) {
#line 4841
    set --;
    {
#line 4843
    if ((unsigned int )type_ac[set] == 8U) {
#line 4843
      goto case_8___47;
    }
#line 4847
    goto switch_default___52;
    case_8___47: /* CIL Label */ 
#line 4844
    kodp3 = kodp;
#line 4845
    ((struct OPERAND_0_ma *)kodp)->major = 17;
#line 4845
    kodp += sizeof(struct OPERAND_0_ma );
#line 4846
    goto switch_break___53;
    switch_default___52: /* CIL Label */ 
    {
#line 4848
    fprintfx(stderr, "%s:%d:\n", "ys.y", 4848);
#line 4849
    error_message(5000);
    }
#line 4849
    return (0);
    switch_break___53: /* CIL Label */ ;
    }
  } else {
    {
#line 4853
    error_message(1005);
    }
  }
#line 4854
  last_instr = current_instr;
#line 4854
  current_instr = kodp;
#line 4856
  goto switch_break;
  case_330: /* CIL Label */ 
#line 4862
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4862
    goto _L___25;
  } else
#line 4862
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___25: /* CIL Label */ 
#line 4865
    if (scope_level > 0) {
#line 4865
      tmp___253 = 1;
    } else {
#line 4865
      tmp___253 = 0;
    }
    {
#line 4865
    tmp___254 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___253);
#line 4865
    type_com[set] = (struct internal_type *)tmp___254;
#line 4868
    init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 4870
    (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 4872
    (type_com[set])->attribute.type_qualifier = (enum type_qual )4098;
#line 4874
    (type_com[set])->attribute.arit_class = (enum intern_arit_class )24;
    }
  }
#line 4877
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4877
  ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 4877
  kodp += sizeof(struct OPERAND_0_mi );
#line 4877
  last_instr = current_instr;
#line 4877
  current_instr = kodp;
#line 4878
  and_jmp[set] = kodp;
#line 4879
  ((struct OPERAND_1_ma *)kodp)->major = 27;
#line 4879
  kodp += sizeof(struct OPERAND_1_ma );
#line 4879
  last_instr = current_instr;
#line 4879
  current_instr = kodp;
#line 4881
  goto switch_break;
  case_331: /* CIL Label */ 
#line 4883
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4883
    goto _L___26;
  } else
#line 4883
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___26: /* CIL Label */ 
#line 4886
    if (scope_level > 0) {
#line 4886
      tmp___255 = 1;
    } else {
#line 4886
      tmp___255 = 0;
    }
    {
#line 4886
    tmp___256 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___255);
#line 4886
    type_com[set] = (struct internal_type *)tmp___256;
#line 4889
    init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 4891
    (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 4893
    (type_com[set])->attribute.type_qualifier = (enum type_qual )4098;
#line 4895
    (type_com[set])->attribute.arit_class = (enum intern_arit_class )24;
    }
  }
  {
#line 4898
  tmp___257 = implicit_cast();
  }
#line 4898
  if (-1 == tmp___257) {
#line 4899
    no_compile_only = 0;
  }
#line 4900
  variable[set].adr = (char *)((void *)0);
#line 4900
  variable[set].offset = 0;
#line 4901
  subscript_flag[set] = 0;
#line 4901
  struct_union_field[set] = 0;
#line 4901
  type_ac[set] = (enum intern_arit_class )0;
#line 4901
  tmp___258 = set;
#line 4901
  set --;
#line 4901
  type_com[tmp___258] = (struct internal_type *)((void *)0);
#line 4901
  if (0 > set) {
    {
#line 4901
    error_message(5003);
    }
  }
#line 4902
  kodp3 = kodp;
  {
#line 4903
  if ((unsigned int )type_ac[set] == 136U) {
#line 4903
    goto case_136___36;
  }
#line 4903
  if ((unsigned int )type_ac[set] == 8U) {
#line 4903
    goto case_136___36;
  }
#line 4903
  if ((unsigned int )type_ac[set] == 264U) {
#line 4903
    goto case_264___35;
  }
#line 4903
  if ((unsigned int )type_ac[set] == 152U) {
#line 4903
    goto case_152___35;
  }
#line 4903
  if ((unsigned int )type_ac[set] == 24U) {
#line 4903
    goto case_152___35;
  }
#line 4903
  if ((unsigned int )type_ac[set] == 280U) {
#line 4903
    goto case_280___35;
  }
#line 4903
  if ((unsigned int )type_ac[set] == 64U) {
#line 4903
    goto case_64___42;
  }
#line 4903
  if ((unsigned int )type_ac[set] == 80U) {
#line 4903
    goto case_80___35;
  }
#line 4903
  if ((unsigned int )type_ac[set] == 32U) {
#line 4903
    goto case_32___41;
  }
#line 4903
  goto switch_default___53;
  case_136___36: /* CIL Label */ 
  case_8___48: /* CIL Label */ 
#line 4903
  ((struct OPERAND_0_mi *)kodp)->major = 16;
#line 4903
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4903
  kodp += sizeof(struct OPERAND_0_mi );
#line 4903
  goto switch_break___54;
  case_264___35: /* CIL Label */ 
#line 4903
  ((struct OPERAND_0_mi *)kodp)->major = 16;
#line 4903
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4903
  kodp += sizeof(struct OPERAND_0_mi );
#line 4903
  goto switch_break___54;
  case_152___35: /* CIL Label */ 
  case_24___35: /* CIL Label */ 
#line 4903
  ((struct OPERAND_0_mi *)kodp)->major = 16;
#line 4903
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4903
  kodp += sizeof(struct OPERAND_0_mi );
#line 4903
  goto switch_break___54;
  case_280___35: /* CIL Label */ 
#line 4903
  ((struct OPERAND_0_mi *)kodp)->major = 16;
#line 4903
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4903
  kodp += sizeof(struct OPERAND_0_mi );
#line 4903
  goto switch_break___54;
  case_64___42: /* CIL Label */ 
#line 4903
  ((struct OPERAND_0_mi *)kodp)->major = 16;
#line 4903
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4903
  kodp += sizeof(struct OPERAND_0_mi );
#line 4903
  goto switch_break___54;
  case_80___35: /* CIL Label */ 
#line 4903
  ((struct OPERAND_0_mi *)kodp)->major = 16;
#line 4903
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4903
  kodp += sizeof(struct OPERAND_0_mi );
#line 4903
  goto switch_break___54;
  case_32___41: /* CIL Label */ 
#line 4903
  ((struct OPERAND_0_mi *)kodp)->major = 16;
#line 4903
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4903
  kodp += sizeof(struct OPERAND_0_mi );
#line 4903
  goto switch_break___54;
  switch_default___53: /* CIL Label */ 
  {
#line 4903
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4903);
#line 4903
  error_message(5000);
  }
#line 4903
  return (0);
  switch_break___54: /* CIL Label */ ;
  }
#line 4904
  last_instr = current_instr;
#line 4904
  current_instr = kodp;
#line 4904
  type_ac[set] = (enum intern_arit_class )8;
#line 4905
  ((struct OPERAND_1_ma *)and_jmp[set])->adr = kodp;
#line 4907
  goto switch_break;
  case_333: /* CIL Label */ 
#line 4913
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4913
    goto _L___27;
  } else
#line 4913
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___27: /* CIL Label */ 
#line 4916
    if (scope_level > 0) {
#line 4916
      tmp___259 = 1;
    } else {
#line 4916
      tmp___259 = 0;
    }
    {
#line 4916
    tmp___260 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___259);
#line 4916
    type_com[set] = (struct internal_type *)tmp___260;
#line 4919
    init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 4921
    (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 4923
    (type_com[set])->attribute.type_qualifier = (enum type_qual )4098;
#line 4925
    (type_com[set])->attribute.arit_class = (enum intern_arit_class )24;
    }
  }
#line 4928
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 4928
  ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 4928
  kodp += sizeof(struct OPERAND_0_mi );
#line 4928
  last_instr = current_instr;
#line 4928
  current_instr = kodp;
#line 4929
  or_jmp[set] = kodp;
#line 4930
  ((struct OPERAND_1_ma *)kodp)->major = 26;
#line 4930
  kodp += sizeof(struct OPERAND_1_ma );
#line 4930
  last_instr = current_instr;
#line 4930
  current_instr = kodp;
#line 4932
  goto switch_break;
  case_334: /* CIL Label */ 
#line 4934
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 4934
    goto _L___28;
  } else
#line 4934
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___28: /* CIL Label */ 
#line 4937
    if (scope_level > 0) {
#line 4937
      tmp___261 = 1;
    } else {
#line 4937
      tmp___261 = 0;
    }
    {
#line 4937
    tmp___262 = allocate((unsigned int )sizeof(struct internal_type ), (unsigned int )tmp___261);
#line 4937
    type_com[set] = (struct internal_type *)tmp___262;
#line 4940
    init_zero((char *)type_com[set], (unsigned int )sizeof(struct internal_type ));
#line 4942
    (type_com[set])->attribute.function_class = (enum intern_func_class )1024;
#line 4944
    (type_com[set])->attribute.type_qualifier = (enum type_qual )4098;
#line 4946
    (type_com[set])->attribute.arit_class = (enum intern_arit_class )24;
    }
  }
  {
#line 4949
  tmp___263 = implicit_cast();
  }
#line 4949
  if (-1 == tmp___263) {
#line 4950
    no_compile_only = 0;
  }
#line 4951
  variable[set].adr = (char *)((void *)0);
#line 4951
  variable[set].offset = 0;
#line 4952
  subscript_flag[set] = 0;
#line 4952
  struct_union_field[set] = 0;
#line 4952
  type_ac[set] = (enum intern_arit_class )0;
#line 4952
  tmp___264 = set;
#line 4952
  set --;
#line 4952
  type_com[tmp___264] = (struct internal_type *)((void *)0);
#line 4952
  if (0 > set) {
    {
#line 4952
    error_message(5003);
    }
  }
#line 4953
  kodp3 = kodp;
  {
#line 4954
  if ((unsigned int )type_ac[set] == 136U) {
#line 4954
    goto case_136___37;
  }
#line 4954
  if ((unsigned int )type_ac[set] == 8U) {
#line 4954
    goto case_136___37;
  }
#line 4954
  if ((unsigned int )type_ac[set] == 264U) {
#line 4954
    goto case_264___36;
  }
#line 4954
  if ((unsigned int )type_ac[set] == 152U) {
#line 4954
    goto case_152___36;
  }
#line 4954
  if ((unsigned int )type_ac[set] == 24U) {
#line 4954
    goto case_152___36;
  }
#line 4954
  if ((unsigned int )type_ac[set] == 280U) {
#line 4954
    goto case_280___36;
  }
#line 4954
  if ((unsigned int )type_ac[set] == 64U) {
#line 4954
    goto case_64___43;
  }
#line 4954
  if ((unsigned int )type_ac[set] == 80U) {
#line 4954
    goto case_80___36;
  }
#line 4954
  if ((unsigned int )type_ac[set] == 32U) {
#line 4954
    goto case_32___42;
  }
#line 4954
  goto switch_default___54;
  case_136___37: /* CIL Label */ 
  case_8___49: /* CIL Label */ 
#line 4954
  ((struct OPERAND_0_mi *)kodp)->major = 15;
#line 4954
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 4954
  kodp += sizeof(struct OPERAND_0_mi );
#line 4954
  goto switch_break___55;
  case_264___36: /* CIL Label */ 
#line 4954
  ((struct OPERAND_0_mi *)kodp)->major = 15;
#line 4954
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 4954
  kodp += sizeof(struct OPERAND_0_mi );
#line 4954
  goto switch_break___55;
  case_152___36: /* CIL Label */ 
  case_24___36: /* CIL Label */ 
#line 4954
  ((struct OPERAND_0_mi *)kodp)->major = 15;
#line 4954
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 4954
  kodp += sizeof(struct OPERAND_0_mi );
#line 4954
  goto switch_break___55;
  case_280___36: /* CIL Label */ 
#line 4954
  ((struct OPERAND_0_mi *)kodp)->major = 15;
#line 4954
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 4954
  kodp += sizeof(struct OPERAND_0_mi );
#line 4954
  goto switch_break___55;
  case_64___43: /* CIL Label */ 
#line 4954
  ((struct OPERAND_0_mi *)kodp)->major = 15;
#line 4954
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 4954
  kodp += sizeof(struct OPERAND_0_mi );
#line 4954
  goto switch_break___55;
  case_80___36: /* CIL Label */ 
#line 4954
  ((struct OPERAND_0_mi *)kodp)->major = 15;
#line 4954
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 4954
  kodp += sizeof(struct OPERAND_0_mi );
#line 4954
  goto switch_break___55;
  case_32___42: /* CIL Label */ 
#line 4954
  ((struct OPERAND_0_mi *)kodp)->major = 15;
#line 4954
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 4954
  kodp += sizeof(struct OPERAND_0_mi );
#line 4954
  goto switch_break___55;
  switch_default___54: /* CIL Label */ 
  {
#line 4954
  fprintfx(stderr, "%s:%d:\n", "ys.y", 4954);
#line 4954
  error_message(5000);
  }
#line 4954
  return (0);
  switch_break___55: /* CIL Label */ ;
  }
#line 4955
  last_instr = current_instr;
#line 4955
  current_instr = kodp;
#line 4955
  type_ac[set] = (enum intern_arit_class )8;
#line 4956
  ((struct OPERAND_1_ma *)or_jmp[set])->adr = kodp;
#line 4958
  goto switch_break;
  case_336: /* CIL Label */ 
#line 4965
  variable[set].adr = (char *)((void *)0);
#line 4965
  variable[set].offset = 0;
#line 4966
  subscript_flag[set] = 0;
#line 4966
  struct_union_field[set] = 0;
#line 4966
  type_ac[set] = (enum intern_arit_class )0;
#line 4966
  tmp___265 = set;
#line 4966
  set --;
#line 4966
  type_com[tmp___265] = (struct internal_type *)((void *)0);
#line 4966
  if (0 > set) {
    {
#line 4966
    error_message(5003);
    }
  }
#line 4967
  kodp3 = (char *)((void *)0);
#line 4967
  ((struct OPERAND_0_ma *)kodp)->major = 43;
#line 4967
  kodp += sizeof(struct OPERAND_0_ma );
#line 4967
  last_instr = current_instr;
#line 4967
  current_instr = kodp;
#line 4967
  fixp ++;
#line 4971
  fixp->if1.major = 291;
#line 4972
  fixp->if1.jz = kodp;
#line 4973
  ((struct OPERAND_1_ma *)kodp)->major = 27;
#line 4973
  kodp += sizeof(struct OPERAND_1_ma );
#line 4973
  last_instr = current_instr;
#line 4973
  current_instr = kodp;
#line 4975
  goto switch_break;
  case_337: /* CIL Label */ 
#line 4977
  fixp->if1.jmp = kodp;
#line 4978
  ((struct OPERAND_1_ma *)kodp)->major = 25;
#line 4978
  kodp += sizeof(struct OPERAND_1_ma );
#line 4978
  last_instr = current_instr;
#line 4978
  current_instr = kodp;
#line 4979
  ((struct OPERAND_1_ma *)fixp->if1.jz)->adr = kodp;
#line 4980
  variable[set].adr = (char *)((void *)0);
#line 4980
  variable[set].offset = 0;
#line 4981
  subscript_flag[set] = 0;
#line 4981
  struct_union_field[set] = 0;
#line 4981
  type_ac[set] = (enum intern_arit_class )0;
#line 4981
  tmp___266 = set;
#line 4981
  set --;
#line 4981
  type_com[tmp___266] = (struct internal_type *)((void *)0);
#line 4981
  if (0 > set) {
    {
#line 4981
    error_message(5003);
    }
  }
#line 4983
  goto switch_break;
  case_338: /* CIL Label */ 
#line 4985
  ((struct OPERAND_1_ma *)fixp->if1.jmp)->adr = kodp;
#line 4987
  fixp --;
#line 4989
  goto switch_break;
  case_340: /* CIL Label */ 
#line 4999
  if (((struct OPERAND_0_mi *)last_instr)->major == 40) {
    {
#line 5000
    error_message(1034);
    }
  }
  {
#line 5001
  set_value(variable[set].name);
  }
  {
#line 5009
  if ((unsigned int )(type_com[set])->attribute.function_class == 1030U) {
#line 5009
    goto case_1030___3;
  }
#line 5009
  if ((unsigned int )(type_com[set])->attribute.function_class == 1028U) {
#line 5009
    goto case_1030___3;
  }
#line 5009
  if ((unsigned int )(type_com[set])->attribute.function_class == 1031U) {
#line 5009
    goto case_1030___3;
  }
#line 5009
  if ((unsigned int )(type_com[set])->attribute.function_class == 1029U) {
#line 5009
    goto case_1030___3;
  }
#line 5009
  if ((unsigned int )(type_com[set])->attribute.function_class == 1025U) {
#line 5009
    goto case_1030___3;
  }
#line 5009
  if ((unsigned int )(type_com[set])->attribute.function_class == 1024U) {
#line 5009
    goto case_1030___3;
  }
#line 5012
  if ((unsigned int )(type_com[set])->attribute.function_class == 2049U) {
#line 5012
    goto case_2049___2;
  }
#line 5012
  if ((unsigned int )(type_com[set])->attribute.function_class == 2048U) {
#line 5012
    goto case_2049___2;
  }
#line 5015
  goto switch_default___55;
  case_1030___3: /* CIL Label */ 
  case_1028___2: /* CIL Label */ 
  case_1031___1: /* CIL Label */ 
  case_1029___3: /* CIL Label */ 
  case_1025___3: /* CIL Label */ 
  case_1024___3: /* CIL Label */ 
#line 5010
  goto switch_break___56;
  case_2049___2: /* CIL Label */ 
  case_2048___1: /* CIL Label */ 
  {
#line 5013
  error_message(1034);
  }
#line 5014
  goto switch_break___56;
  switch_default___55: /* CIL Label */ 
  {
#line 5016
  fprintfx(stderr, "%s:%d:\n", "ys.y", 5016);
#line 5017
  error_message(5000);
  }
#line 5017
  return (0);
  switch_break___56: /* CIL Label */ ;
  }
#line 5020
  goto switch_break;
  case_341: /* CIL Label */ 
  {
#line 5022
  tmp___267 = l_value_cast();
  }
#line 5022
  if (-1 == tmp___267) {
#line 5023
    no_compile_only = 0;
  }
#line 5024
  variable[set].adr = (char *)((void *)0);
#line 5024
  variable[set].offset = 0;
#line 5025
  subscript_flag[set] = 0;
#line 5025
  struct_union_field[set] = 0;
#line 5025
  type_ac[set] = (enum intern_arit_class )0;
#line 5025
  tmp___268 = set;
#line 5025
  set --;
#line 5025
  type_com[tmp___268] = (struct internal_type *)((void *)0);
#line 5025
  if (0 > set) {
    {
#line 5025
    error_message(5003);
    }
  }
  {
#line 5026
  move2lvalue();
#line 5027
  variable[set].adr = (char *)((void *)0);
#line 5027
  variable[set].offset = 0;
  }
#line 5029
  goto switch_break;
  case_343: /* CIL Label */ 
#line 5046
  ((struct OPERAND_0_mi *)kodp)->major = 37;
#line 5046
  ((struct OPERAND_0_mi *)kodp)->minor = 6;
#line 5046
  kodp += sizeof(struct OPERAND_0_mi );
#line 5046
  last_instr = current_instr;
#line 5046
  current_instr = kodp;
#line 5048
  goto switch_break;
  case_344: /* CIL Label */ 
#line 5054
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5058
    error_message(1033, "*");
    }
  } else
#line 5054
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5058
    error_message(1033, "*");
    }
  } else
#line 5054
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5058
    error_message(1033, "*");
    }
  } else
#line 5054
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5058
    error_message(1033, "*");
    }
  }
  {
#line 5059
  tmp___269 = l_value_cast();
  }
#line 5059
  if (-1 == tmp___269) {
#line 5060
    no_compile_only = 0;
  }
#line 5061
  variable[set].adr = (char *)((void *)0);
#line 5061
  variable[set].offset = 0;
#line 5062
  subscript_flag[set] = 0;
#line 5062
  struct_union_field[set] = 0;
#line 5062
  type_ac[set] = (enum intern_arit_class )0;
#line 5062
  tmp___270 = set;
#line 5062
  set --;
#line 5062
  type_com[tmp___270] = (struct internal_type *)((void *)0);
#line 5062
  if (0 > set) {
    {
#line 5062
    error_message(5003);
    }
  }
  {
#line 5063
  if ((unsigned int )type_ac[set] == 136U) {
#line 5063
    goto case_136___38;
  }
#line 5063
  if ((unsigned int )type_ac[set] == 8U) {
#line 5063
    goto case_136___38;
  }
#line 5063
  if ((unsigned int )type_ac[set] == 264U) {
#line 5063
    goto case_264___37;
  }
#line 5063
  if ((unsigned int )type_ac[set] == 152U) {
#line 5063
    goto case_152___37;
  }
#line 5063
  if ((unsigned int )type_ac[set] == 24U) {
#line 5063
    goto case_152___37;
  }
#line 5063
  if ((unsigned int )type_ac[set] == 280U) {
#line 5063
    goto case_280___37;
  }
#line 5063
  if ((unsigned int )type_ac[set] == 64U) {
#line 5063
    goto case_64___44;
  }
#line 5063
  if ((unsigned int )type_ac[set] == 80U) {
#line 5063
    goto case_80___37;
  }
#line 5063
  if ((unsigned int )type_ac[set] == 32U) {
#line 5063
    goto case_32___43;
  }
#line 5063
  goto switch_default___56;
  case_136___38: /* CIL Label */ 
  case_8___50: /* CIL Label */ 
#line 5063
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5063
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 5063
  kodp += sizeof(struct OPERAND_0_mi );
#line 5063
  goto switch_break___57;
  case_264___37: /* CIL Label */ 
#line 5063
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5063
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 5063
  kodp += sizeof(struct OPERAND_0_mi );
#line 5063
  goto switch_break___57;
  case_152___37: /* CIL Label */ 
  case_24___37: /* CIL Label */ 
#line 5063
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5063
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 5063
  kodp += sizeof(struct OPERAND_0_mi );
#line 5063
  goto switch_break___57;
  case_280___37: /* CIL Label */ 
#line 5063
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5063
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 5063
  kodp += sizeof(struct OPERAND_0_mi );
#line 5063
  goto switch_break___57;
  case_64___44: /* CIL Label */ 
#line 5063
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5063
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 5063
  kodp += sizeof(struct OPERAND_0_mi );
#line 5063
  goto switch_break___57;
  case_80___37: /* CIL Label */ 
#line 5063
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5063
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 5063
  kodp += sizeof(struct OPERAND_0_mi );
#line 5063
  goto switch_break___57;
  case_32___43: /* CIL Label */ 
#line 5063
  ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5063
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 5063
  kodp += sizeof(struct OPERAND_0_mi );
#line 5063
  goto switch_break___57;
  switch_default___56: /* CIL Label */ 
  {
#line 5063
  fprintfx(stderr, "%s:%d:\n", "ys.y", 5063);
#line 5063
  error_message(5000);
  }
#line 5063
  return (0);
  switch_break___57: /* CIL Label */ ;
  }
  {
#line 5064
  last_instr = current_instr;
#line 5064
  current_instr = kodp;
#line 5064
  kodp3 = kodp;
#line 5065
  move2lvalue();
#line 5066
  variable[set].adr = (char *)((void *)0);
#line 5066
  variable[set].offset = 0;
  }
#line 5068
  goto switch_break;
  case_345: /* CIL Label */ 
#line 5071
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5075
    error_message(1033, "/");
    }
  } else
#line 5071
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5075
    error_message(1033, "/");
    }
  } else
#line 5071
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5075
    error_message(1033, "/");
    }
  } else
#line 5071
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5075
    error_message(1033, "/");
    }
  }
  {
#line 5076
  tmp___271 = l_value_cast();
  }
#line 5076
  if (-1 == tmp___271) {
#line 5077
    no_compile_only = 0;
  }
#line 5078
  variable[set].adr = (char *)((void *)0);
#line 5078
  variable[set].offset = 0;
#line 5079
  subscript_flag[set] = 0;
#line 5079
  struct_union_field[set] = 0;
#line 5079
  type_ac[set] = (enum intern_arit_class )0;
#line 5079
  tmp___272 = set;
#line 5079
  set --;
#line 5079
  type_com[tmp___272] = (struct internal_type *)((void *)0);
#line 5079
  if (0 > set) {
    {
#line 5079
    error_message(5003);
    }
  }
  {
#line 5080
  if ((unsigned int )type_ac[set] == 136U) {
#line 5080
    goto case_136___39;
  }
#line 5080
  if ((unsigned int )type_ac[set] == 8U) {
#line 5080
    goto case_136___39;
  }
#line 5080
  if ((unsigned int )type_ac[set] == 264U) {
#line 5080
    goto case_264___38;
  }
#line 5080
  if ((unsigned int )type_ac[set] == 152U) {
#line 5080
    goto case_152___38;
  }
#line 5080
  if ((unsigned int )type_ac[set] == 24U) {
#line 5080
    goto case_152___38;
  }
#line 5080
  if ((unsigned int )type_ac[set] == 280U) {
#line 5080
    goto case_280___38;
  }
#line 5080
  if ((unsigned int )type_ac[set] == 64U) {
#line 5080
    goto case_64___45;
  }
#line 5080
  if ((unsigned int )type_ac[set] == 80U) {
#line 5080
    goto case_80___38;
  }
#line 5080
  if ((unsigned int )type_ac[set] == 32U) {
#line 5080
    goto case_32___44;
  }
#line 5080
  goto switch_default___57;
  case_136___39: /* CIL Label */ 
  case_8___51: /* CIL Label */ 
#line 5080
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 5080
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 5080
  kodp += sizeof(struct OPERAND_0_mi );
#line 5080
  goto switch_break___58;
  case_264___38: /* CIL Label */ 
#line 5080
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 5080
  ((struct OPERAND_0_mi *)kodp)->minor = 1;
#line 5080
  kodp += sizeof(struct OPERAND_0_mi );
#line 5080
  goto switch_break___58;
  case_152___38: /* CIL Label */ 
  case_24___38: /* CIL Label */ 
#line 5080
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 5080
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 5080
  kodp += sizeof(struct OPERAND_0_mi );
#line 5080
  goto switch_break___58;
  case_280___38: /* CIL Label */ 
#line 5080
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 5080
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 5080
  kodp += sizeof(struct OPERAND_0_mi );
#line 5080
  goto switch_break___58;
  case_64___45: /* CIL Label */ 
#line 5080
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 5080
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 5080
  kodp += sizeof(struct OPERAND_0_mi );
#line 5080
  goto switch_break___58;
  case_80___38: /* CIL Label */ 
#line 5080
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 5080
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 5080
  kodp += sizeof(struct OPERAND_0_mi );
#line 5080
  goto switch_break___58;
  case_32___44: /* CIL Label */ 
#line 5080
  ((struct OPERAND_0_mi *)kodp)->major = 13;
#line 5080
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 5080
  kodp += sizeof(struct OPERAND_0_mi );
#line 5080
  goto switch_break___58;
  switch_default___57: /* CIL Label */ 
  {
#line 5080
  fprintfx(stderr, "%s:%d:\n", "ys.y", 5080);
#line 5080
  error_message(5000);
  }
#line 5080
  return (0);
  switch_break___58: /* CIL Label */ ;
  }
  {
#line 5081
  last_instr = current_instr;
#line 5081
  current_instr = kodp;
#line 5081
  kodp3 = kodp;
#line 5082
  move2lvalue();
#line 5083
  variable[set].adr = (char *)((void *)0);
#line 5083
  variable[set].offset = 0;
  }
#line 5085
  goto switch_break;
  case_346: /* CIL Label */ 
#line 5088
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5092
    error_message(1033, "%");
    }
  } else
#line 5088
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5092
    error_message(1033, "%");
    }
  } else
#line 5088
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5092
    error_message(1033, "%");
    }
  } else
#line 5088
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5092
    error_message(1033, "%");
    }
  }
#line 5093
  if (8U == (unsigned int )type_ac[set]) {
#line 5095
    variable[set].adr = (char *)((void *)0);
#line 5095
    variable[set].offset = 0;
#line 5096
    subscript_flag[set] = 0;
#line 5096
    struct_union_field[set] = 0;
#line 5096
    type_ac[set] = (enum intern_arit_class )0;
#line 5096
    tmp___273 = set;
#line 5096
    set --;
#line 5096
    type_com[tmp___273] = (struct internal_type *)((void *)0);
#line 5096
    if (0 > set) {
      {
#line 5096
      error_message(5003);
      }
    }
    {
#line 5099
    if ((unsigned int )type_ac[set] == 8U) {
#line 5099
      goto case_8___52;
    }
#line 5102
    goto switch_default___58;
    case_8___52: /* CIL Label */ 
#line 5100
    ((struct OPERAND_0_ma *)kodp)->major = 14;
#line 5100
    kodp += sizeof(struct OPERAND_0_ma );
#line 5101
    goto switch_break___59;
    switch_default___58: /* CIL Label */ 
    {
#line 5103
    fprintfx(stderr, "%s:%d:\n", "ys.y", 5103);
#line 5104
    error_message(5000);
    }
#line 5104
    return (0);
    switch_break___59: /* CIL Label */ ;
    }
    {
#line 5106
    last_instr = current_instr;
#line 5106
    current_instr = kodp;
#line 5106
    kodp3 = kodp;
#line 5107
    move2lvalue();
#line 5108
    variable[set].adr = (char *)((void *)0);
#line 5108
    variable[set].offset = 0;
    }
  } else {
    {
#line 5111
    error_message(1005);
    }
  }
#line 5113
  goto switch_break;
  case_347: /* CIL Label */ 
#line 5116
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 5116
    goto _L___30;
  } else
#line 5116
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___30: /* CIL Label */ 
#line 5119
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 5119
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 5119
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set])->output)->attribute.memory_size;
#line 5119
    kodp += sizeof(struct OPERAND_1_li );
#line 5120
    last_instr = current_instr;
#line 5120
    current_instr = kodp;
#line 5121
    ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5121
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 5121
    kodp += sizeof(struct OPERAND_0_mi );
#line 5121
    last_instr = current_instr;
#line 5121
    current_instr = kodp;
#line 5122
    type_com[set - 1] = type_com[set];
  } else
#line 5124
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
#line 5124
    goto _L___29;
  } else
#line 5124
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    _L___29: /* CIL Label */ 
#line 5127
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 5127
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 5127
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set - 1])->output)->attribute.memory_size;
#line 5127
    kodp += sizeof(struct OPERAND_1_li );
#line 5128
    last_instr = current_instr;
#line 5128
    current_instr = kodp;
#line 5129
    ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5129
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 5129
    kodp += sizeof(struct OPERAND_0_mi );
#line 5129
    last_instr = current_instr;
#line 5129
    current_instr = kodp;
#line 5130
    type_com[set] = type_com[set - 1];
  }
  {
#line 5132
  tmp___274 = l_value_cast();
  }
#line 5132
  if (-1 == tmp___274) {
#line 5133
    no_compile_only = 0;
  }
#line 5134
  variable[set].adr = (char *)((void *)0);
#line 5134
  variable[set].offset = 0;
#line 5135
  subscript_flag[set] = 0;
#line 5135
  struct_union_field[set] = 0;
#line 5135
  type_ac[set] = (enum intern_arit_class )0;
#line 5135
  tmp___275 = set;
#line 5135
  set --;
#line 5135
  type_com[tmp___275] = (struct internal_type *)((void *)0);
#line 5135
  if (0 > set) {
    {
#line 5135
    error_message(5003);
    }
  }
  {
#line 5136
  if ((unsigned int )type_ac[set] == 136U) {
#line 5136
    goto case_136___40;
  }
#line 5136
  if ((unsigned int )type_ac[set] == 8U) {
#line 5136
    goto case_136___40;
  }
#line 5136
  if ((unsigned int )type_ac[set] == 264U) {
#line 5136
    goto case_264___39;
  }
#line 5136
  if ((unsigned int )type_ac[set] == 152U) {
#line 5136
    goto case_152___39;
  }
#line 5136
  if ((unsigned int )type_ac[set] == 24U) {
#line 5136
    goto case_152___39;
  }
#line 5136
  if ((unsigned int )type_ac[set] == 280U) {
#line 5136
    goto case_280___39;
  }
#line 5136
  if ((unsigned int )type_ac[set] == 64U) {
#line 5136
    goto case_64___46;
  }
#line 5136
  if ((unsigned int )type_ac[set] == 80U) {
#line 5136
    goto case_80___39;
  }
#line 5136
  if ((unsigned int )type_ac[set] == 32U) {
#line 5136
    goto case_32___45;
  }
#line 5136
  goto switch_default___59;
  case_136___40: /* CIL Label */ 
  case_8___53: /* CIL Label */ 
#line 5136
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 5136
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 5136
  kodp += sizeof(struct OPERAND_0_mi );
#line 5136
  goto switch_break___60;
  case_264___39: /* CIL Label */ 
#line 5136
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 5136
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 5136
  kodp += sizeof(struct OPERAND_0_mi );
#line 5136
  goto switch_break___60;
  case_152___39: /* CIL Label */ 
  case_24___39: /* CIL Label */ 
#line 5136
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 5136
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 5136
  kodp += sizeof(struct OPERAND_0_mi );
#line 5136
  goto switch_break___60;
  case_280___39: /* CIL Label */ 
#line 5136
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 5136
  ((struct OPERAND_0_mi *)kodp)->minor = 5;
#line 5136
  kodp += sizeof(struct OPERAND_0_mi );
#line 5136
  goto switch_break___60;
  case_64___46: /* CIL Label */ 
#line 5136
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 5136
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 5136
  kodp += sizeof(struct OPERAND_0_mi );
#line 5136
  goto switch_break___60;
  case_80___39: /* CIL Label */ 
#line 5136
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 5136
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 5136
  kodp += sizeof(struct OPERAND_0_mi );
#line 5136
  goto switch_break___60;
  case_32___45: /* CIL Label */ 
#line 5136
  ((struct OPERAND_0_mi *)kodp)->major = 10;
#line 5136
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 5136
  kodp += sizeof(struct OPERAND_0_mi );
#line 5136
  goto switch_break___60;
  switch_default___59: /* CIL Label */ 
  {
#line 5136
  fprintfx(stderr, "%s:%d:\n", "ys.y", 5136);
#line 5136
  error_message(5000);
  }
#line 5136
  return (0);
  switch_break___60: /* CIL Label */ ;
  }
  {
#line 5137
  last_instr = current_instr;
#line 5137
  current_instr = kodp;
#line 5137
  kodp3 = kodp;
#line 5138
  move2lvalue();
#line 5139
  variable[set].adr = (char *)((void *)0);
#line 5139
  variable[set].offset = 0;
  }
#line 5141
  goto switch_break;
  case_348: /* CIL Label */ 
#line 5144
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
#line 5144
    goto _L___32;
  } else
#line 5144
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    _L___32: /* CIL Label */ 
#line 5147
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 5147
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 5147
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set])->output)->attribute.memory_size;
#line 5147
    kodp += sizeof(struct OPERAND_1_li );
#line 5148
    last_instr = current_instr;
#line 5148
    current_instr = kodp;
#line 5149
    ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5149
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 5149
    kodp += sizeof(struct OPERAND_0_mi );
#line 5149
    last_instr = current_instr;
#line 5149
    current_instr = kodp;
#line 5150
    type_com[set - 1] = type_com[set];
  } else
#line 5152
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
#line 5152
    goto _L___31;
  } else
#line 5152
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    _L___31: /* CIL Label */ 
#line 5155
    ((struct OPERAND_1_li *)kodp)->major = 32;
#line 5155
    ((struct OPERAND_1_li *)kodp)->minor = 2;
#line 5155
    ((struct OPERAND_1_li *)kodp)->num = (long )((type_com[set - 1])->output)->attribute.memory_size;
#line 5155
    kodp += sizeof(struct OPERAND_1_li );
#line 5156
    last_instr = current_instr;
#line 5156
    current_instr = kodp;
#line 5157
    ((struct OPERAND_0_mi *)kodp)->major = 12;
#line 5157
    ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 5157
    kodp += sizeof(struct OPERAND_0_mi );
#line 5157
    last_instr = current_instr;
#line 5157
    current_instr = kodp;
#line 5158
    type_com[set] = type_com[set - 1];
  }
  {
#line 5160
  tmp___276 = l_value_cast();
  }
#line 5160
  if (-1 == tmp___276) {
#line 5161
    no_compile_only = 0;
  }
#line 5162
  variable[set].adr = (char *)((void *)0);
#line 5162
  variable[set].offset = 0;
#line 5163
  subscript_flag[set] = 0;
#line 5163
  struct_union_field[set] = 0;
#line 5163
  type_ac[set] = (enum intern_arit_class )0;
#line 5163
  tmp___277 = set;
#line 5163
  set --;
#line 5163
  type_com[tmp___277] = (struct internal_type *)((void *)0);
#line 5163
  if (0 > set) {
    {
#line 5163
    error_message(5003);
    }
  }
  {
#line 5164
  if ((unsigned int )type_ac[set] == 136U) {
#line 5164
    goto case_136___41;
  }
#line 5164
  if ((unsigned int )type_ac[set] == 8U) {
#line 5164
    goto case_136___41;
  }
#line 5164
  if ((unsigned int )type_ac[set] == 264U) {
#line 5164
    goto case_264___40;
  }
#line 5164
  if ((unsigned int )type_ac[set] == 152U) {
#line 5164
    goto case_152___40;
  }
#line 5164
  if ((unsigned int )type_ac[set] == 24U) {
#line 5164
    goto case_152___40;
  }
#line 5164
  if ((unsigned int )type_ac[set] == 280U) {
#line 5164
    goto case_280___40;
  }
#line 5164
  if ((unsigned int )type_ac[set] == 64U) {
#line 5164
    goto case_64___47;
  }
#line 5164
  if ((unsigned int )type_ac[set] == 80U) {
#line 5164
    goto case_80___40;
  }
#line 5164
  if ((unsigned int )type_ac[set] == 32U) {
#line 5164
    goto case_32___46;
  }
#line 5164
  goto switch_default___60;
  case_136___41: /* CIL Label */ 
  case_8___54: /* CIL Label */ 
#line 5164
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 5164
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 5164
  kodp += sizeof(struct OPERAND_0_mi );
#line 5164
  goto switch_break___61;
  case_264___40: /* CIL Label */ 
#line 5164
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 5164
  ((struct OPERAND_0_mi *)kodp)->minor = 2;
#line 5164
  kodp += sizeof(struct OPERAND_0_mi );
#line 5164
  goto switch_break___61;
  case_152___40: /* CIL Label */ 
  case_24___40: /* CIL Label */ 
#line 5164
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 5164
  ((struct OPERAND_0_mi *)kodp)->minor = 3;
#line 5164
  kodp += sizeof(struct OPERAND_0_mi );
#line 5164
  goto switch_break___61;
  case_280___40: /* CIL Label */ 
#line 5164
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 5164
  ((struct OPERAND_0_mi *)kodp)->minor = 4;
#line 5164
  kodp += sizeof(struct OPERAND_0_mi );
#line 5164
  goto switch_break___61;
  case_64___47: /* CIL Label */ 
#line 5164
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 5164
  ((struct OPERAND_0_mi *)kodp)->minor = 256;
#line 5164
  kodp += sizeof(struct OPERAND_0_mi );
#line 5164
  goto switch_break___61;
  case_80___40: /* CIL Label */ 
#line 5164
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 5164
  ((struct OPERAND_0_mi *)kodp)->minor = 257;
#line 5164
  kodp += sizeof(struct OPERAND_0_mi );
#line 5164
  goto switch_break___61;
  case_32___46: /* CIL Label */ 
#line 5164
  ((struct OPERAND_0_mi *)kodp)->major = 11;
#line 5164
  ((struct OPERAND_0_mi *)kodp)->minor = 512;
#line 5164
  kodp += sizeof(struct OPERAND_0_mi );
#line 5164
  goto switch_break___61;
  switch_default___60: /* CIL Label */ 
  {
#line 5164
  fprintfx(stderr, "%s:%d:\n", "ys.y", 5164);
#line 5164
  error_message(5000);
  }
#line 5164
  return (0);
  switch_break___61: /* CIL Label */ ;
  }
  {
#line 5165
  last_instr = current_instr;
#line 5165
  current_instr = kodp;
#line 5165
  kodp3 = kodp;
#line 5166
  move2lvalue();
#line 5167
  variable[set].adr = (char *)((void *)0);
#line 5167
  variable[set].offset = 0;
  }
#line 5169
  goto switch_break;
  case_349: /* CIL Label */ 
#line 5172
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5176
    error_message(1033, "<<");
    }
  } else
#line 5172
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5176
    error_message(1033, "<<");
    }
  } else
#line 5172
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5176
    error_message(1033, "<<");
    }
  } else
#line 5172
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5176
    error_message(1033, "<<");
    }
  }
#line 5177
  if (8U == (unsigned int )type_ac[set]) {
#line 5179
    variable[set].adr = (char *)((void *)0);
#line 5179
    variable[set].offset = 0;
#line 5180
    subscript_flag[set] = 0;
#line 5180
    struct_union_field[set] = 0;
#line 5180
    type_ac[set] = (enum intern_arit_class )0;
#line 5180
    tmp___278 = set;
#line 5180
    set --;
#line 5180
    type_com[tmp___278] = (struct internal_type *)((void *)0);
#line 5180
    if (0 > set) {
      {
#line 5180
      error_message(5003);
      }
    }
    {
#line 5183
    if ((unsigned int )type_ac[set] == 8U) {
#line 5183
      goto case_8___55;
    }
#line 5186
    goto switch_default___61;
    case_8___55: /* CIL Label */ 
#line 5184
    ((struct OPERAND_0_ma *)kodp)->major = 47;
#line 5184
    kodp += sizeof(struct OPERAND_0_ma );
#line 5185
    goto switch_break___62;
    switch_default___61: /* CIL Label */ 
    {
#line 5187
    fprintfx(stderr, "%s:%d:\n", "ys.y", 5187);
#line 5188
    error_message(5000);
    }
#line 5188
    return (0);
    switch_break___62: /* CIL Label */ ;
    }
    {
#line 5190
    last_instr = current_instr;
#line 5190
    current_instr = kodp;
#line 5190
    kodp3 = kodp;
#line 5191
    move2lvalue();
#line 5192
    variable[set].adr = (char *)((void *)0);
#line 5192
    variable[set].offset = 0;
    }
  } else {
    {
#line 5195
    error_message(1005);
    }
  }
#line 5197
  goto switch_break;
  case_350: /* CIL Label */ 
#line 5200
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5204
    error_message(1033, ">>");
    }
  } else
#line 5200
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5204
    error_message(1033, ">>");
    }
  } else
#line 5200
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5204
    error_message(1033, ">>");
    }
  } else
#line 5200
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5204
    error_message(1033, ">>");
    }
  }
#line 5205
  if (8U == (unsigned int )type_ac[set]) {
#line 5207
    variable[set].adr = (char *)((void *)0);
#line 5207
    variable[set].offset = 0;
#line 5208
    subscript_flag[set] = 0;
#line 5208
    struct_union_field[set] = 0;
#line 5208
    type_ac[set] = (enum intern_arit_class )0;
#line 5208
    tmp___279 = set;
#line 5208
    set --;
#line 5208
    type_com[tmp___279] = (struct internal_type *)((void *)0);
#line 5208
    if (0 > set) {
      {
#line 5208
      error_message(5003);
      }
    }
    {
#line 5211
    if ((unsigned int )type_ac[set] == 8U) {
#line 5211
      goto case_8___56;
    }
#line 5214
    goto switch_default___62;
    case_8___56: /* CIL Label */ 
#line 5212
    ((struct OPERAND_0_ma *)kodp)->major = 48;
#line 5212
    kodp += sizeof(struct OPERAND_0_ma );
#line 5213
    goto switch_break___63;
    switch_default___62: /* CIL Label */ 
    {
#line 5215
    fprintfx(stderr, "%s:%d:\n", "ys.y", 5215);
#line 5216
    error_message(5000);
    }
#line 5216
    return (0);
    switch_break___63: /* CIL Label */ ;
    }
    {
#line 5218
    last_instr = current_instr;
#line 5218
    current_instr = kodp;
#line 5218
    kodp3 = kodp;
#line 5219
    move2lvalue();
#line 5220
    variable[set].adr = (char *)((void *)0);
#line 5220
    variable[set].offset = 0;
    }
  } else {
    {
#line 5223
    error_message(1005);
    }
  }
#line 5225
  goto switch_break;
  case_351: /* CIL Label */ 
#line 5228
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5232
    error_message(1033, "&");
    }
  } else
#line 5228
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5232
    error_message(1033, "&");
    }
  } else
#line 5228
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5232
    error_message(1033, "&");
    }
  } else
#line 5228
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5232
    error_message(1033, "&");
    }
  }
#line 5233
  if (error_count) {
#line 5233
    goto switch_break;
  }
#line 5234
  if (8U == (unsigned int )type_ac[set]) {
#line 5236
    variable[set].adr = (char *)((void *)0);
#line 5236
    variable[set].offset = 0;
#line 5237
    subscript_flag[set] = 0;
#line 5237
    struct_union_field[set] = 0;
#line 5237
    type_ac[set] = (enum intern_arit_class )0;
#line 5237
    tmp___280 = set;
#line 5237
    set --;
#line 5237
    type_com[tmp___280] = (struct internal_type *)((void *)0);
#line 5237
    if (0 > set) {
      {
#line 5237
      error_message(5003);
      }
    }
    {
#line 5240
    if ((unsigned int )type_ac[set] == 8U) {
#line 5240
      goto case_8___57;
    }
#line 5243
    goto switch_default___63;
    case_8___57: /* CIL Label */ 
#line 5241
    ((struct OPERAND_0_ma *)kodp)->major = 18;
#line 5241
    kodp += sizeof(struct OPERAND_0_ma );
#line 5242
    goto switch_break___64;
    switch_default___63: /* CIL Label */ 
    {
#line 5244
    fprintfx(stderr, "%s:%d:\n", "ys.y", 5244);
#line 5245
    error_message(5000);
    }
#line 5245
    return (0);
    switch_break___64: /* CIL Label */ ;
    }
    {
#line 5247
    last_instr = current_instr;
#line 5247
    current_instr = kodp;
#line 5247
    kodp3 = kodp;
#line 5248
    move2lvalue();
#line 5249
    variable[set].adr = (char *)((void *)0);
#line 5249
    variable[set].offset = 0;
    }
  } else {
    {
#line 5252
    error_message(1005);
    }
  }
#line 5254
  goto switch_break;
  case_352: /* CIL Label */ 
#line 5257
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5261
    error_message(1033, "^");
    }
  } else
#line 5257
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5261
    error_message(1033, "^");
    }
  } else
#line 5257
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5261
    error_message(1033, "^");
    }
  } else
#line 5257
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5261
    error_message(1033, "^");
    }
  }
#line 5262
  if (error_count) {
#line 5262
    goto switch_break;
  }
#line 5263
  if (8U == (unsigned int )type_ac[set]) {
#line 5265
    variable[set].adr = (char *)((void *)0);
#line 5265
    variable[set].offset = 0;
#line 5266
    subscript_flag[set] = 0;
#line 5266
    struct_union_field[set] = 0;
#line 5266
    type_ac[set] = (enum intern_arit_class )0;
#line 5266
    tmp___281 = set;
#line 5266
    set --;
#line 5266
    type_com[tmp___281] = (struct internal_type *)((void *)0);
#line 5266
    if (0 > set) {
      {
#line 5266
      error_message(5003);
      }
    }
    {
#line 5269
    if ((unsigned int )type_ac[set] == 8U) {
#line 5269
      goto case_8___58;
    }
#line 5272
    goto switch_default___64;
    case_8___58: /* CIL Label */ 
#line 5270
    ((struct OPERAND_0_ma *)kodp)->major = 49;
#line 5270
    kodp += sizeof(struct OPERAND_0_ma );
#line 5271
    goto switch_break___65;
    switch_default___64: /* CIL Label */ 
    {
#line 5273
    fprintfx(stderr, "%s:%d:\n", "ys.y", 5273);
#line 5274
    error_message(5000);
    }
#line 5274
    return (0);
    switch_break___65: /* CIL Label */ ;
    }
    {
#line 5276
    last_instr = current_instr;
#line 5276
    current_instr = kodp;
#line 5276
    kodp3 = kodp;
#line 5277
    move2lvalue();
#line 5278
    variable[set].adr = (char *)((void *)0);
#line 5278
    variable[set].offset = 0;
    }
  } else {
    {
#line 5281
    error_message(1005);
    }
  }
#line 5283
  goto switch_break;
  case_353: /* CIL Label */ 
#line 5286
  if (1028U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5290
    error_message(1033, "|");
    }
  } else
#line 5286
  if (1025U == (unsigned int )(type_com[set])->attribute.function_class) {
    {
#line 5290
    error_message(1033, "|");
    }
  } else
#line 5286
  if (1028U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5290
    error_message(1033, "|");
    }
  } else
#line 5286
  if (1025U == (unsigned int )(type_com[set - 1])->attribute.function_class) {
    {
#line 5290
    error_message(1033, "|");
    }
  }
#line 5291
  if (error_count) {
#line 5291
    goto switch_break;
  }
#line 5292
  if (8U == (unsigned int )type_ac[set]) {
#line 5294
    variable[set].adr = (char *)((void *)0);
#line 5294
    variable[set].offset = 0;
#line 5295
    subscript_flag[set] = 0;
#line 5295
    struct_union_field[set] = 0;
#line 5295
    type_ac[set] = (enum intern_arit_class )0;
#line 5295
    tmp___282 = set;
#line 5295
    set --;
#line 5295
    type_com[tmp___282] = (struct internal_type *)((void *)0);
#line 5295
    if (0 > set) {
      {
#line 5295
      error_message(5003);
      }
    }
    {
#line 5298
    if ((unsigned int )type_ac[set] == 8U) {
#line 5298
      goto case_8___59;
    }
#line 5301
    goto switch_default___65;
    case_8___59: /* CIL Label */ 
#line 5299
    ((struct OPERAND_0_ma *)kodp)->major = 17;
#line 5299
    kodp += sizeof(struct OPERAND_0_ma );
#line 5300
    goto switch_break___66;
    switch_default___65: /* CIL Label */ 
    {
#line 5302
    fprintfx(stderr, "%s:%d:\n", "ys.y", 5302);
#line 5303
    error_message(5000);
    }
#line 5303
    return (0);
    switch_break___66: /* CIL Label */ ;
    }
    {
#line 5305
    last_instr = current_instr;
#line 5305
    current_instr = kodp;
#line 5305
    kodp3 = kodp;
#line 5306
    move2lvalue();
#line 5307
    variable[set].adr = (char *)((void *)0);
#line 5307
    variable[set].offset = 0;
    }
  } else {
    {
#line 5310
    error_message(1005);
    }
  }
#line 5312
  goto switch_break;
  case_355: /* CIL Label */ 
#line 5327
  if (! (((struct OPERAND_0_mi *)last_instr)->major == 37)) {
    {
#line 5328
    error_message(6029);
    }
  }
  {
#line 5347
  if ((unsigned int )type_ac[set] == 258U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 130U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 2U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 32U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 80U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 64U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 268U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 140U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 12U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 280U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 152U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 24U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 264U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 136U) {
#line 5347
    goto case_258___20;
  }
#line 5347
  if ((unsigned int )type_ac[set] == 8U) {
#line 5347
    goto case_258___20;
  }
#line 5350
  if ((unsigned int )type_ac[set] == 1U) {
#line 5350
    goto case_1___10;
  }
#line 5352
  goto switch_default___66;
  case_258___20: /* CIL Label */ 
  case_130___19: /* CIL Label */ 
  case_2___25: /* CIL Label */ 
  case_32___47: /* CIL Label */ 
  case_80___41: /* CIL Label */ 
  case_64___48: /* CIL Label */ 
  case_268___19: /* CIL Label */ 
  case_140___20: /* CIL Label */ 
  case_12___19: /* CIL Label */ 
  case_280___41: /* CIL Label */ 
  case_152___41: /* CIL Label */ 
  case_24___41: /* CIL Label */ 
  case_264___41: /* CIL Label */ 
  case_136___42: /* CIL Label */ 
  case_8___60: /* CIL Label */ 
#line 5348
  ((struct OPERAND_0_mi *)kodp)->major = 40;
#line 5348
  ((struct OPERAND_0_mi *)kodp)->minor = 0;
#line 5348
  kodp += sizeof(struct OPERAND_0_mi );
#line 5348
  last_instr = current_instr;
#line 5348
  current_instr = kodp;
#line 5349
  goto switch_break___67;
  case_1___10: /* CIL Label */ 
#line 5351
  goto switch_break___67;
  switch_default___66: /* CIL Label */ 
  {
#line 5353
  fprintfx(stderr, "%s:%d:\n", "ys.y", 5353);
#line 5354
  error_message(5000);
  }
#line 5354
  return (0);
  switch_break___67: /* CIL Label */ ;
  }
#line 5356
  kodp3 = (char *)((void *)0);
#line 5357
  is_address = 0;
#line 5358
  variable[set].adr = (char *)((void *)0);
#line 5358
  variable[set].offset = 0;
#line 5359
  subscript_flag[set] = 0;
#line 5359
  struct_union_field[set] = 0;
#line 5359
  type_ac[set] = (enum intern_arit_class )0;
#line 5359
  tmp___283 = set;
#line 5359
  set --;
#line 5359
  type_com[tmp___283] = (struct internal_type *)((void *)0);
#line 5359
  if (0 > set) {
    {
#line 5359
    error_message(5003);
    }
  }
#line 5361
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 544 "/usr/share/misc/bison.simple"
  yyvsp -= yylen;
#line 545
  yyssp -= yylen;
#line 551
  if (yydebug) {
    {
#line 553
    ssp1 = yyss - 1;
#line 554
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"state stack now");
    }
    {
#line 555
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 555
      if (! ((unsigned long )ssp1 != (unsigned long )yyssp)) {
#line 555
        goto while_break___38;
      }
      {
#line 556
      ssp1 ++;
#line 556
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
              (int )*ssp1);
      }
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 557
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 561
  yyvsp ++;
#line 561
  *yyvsp = yyval;
#line 585
  yyn = (int )yyr1[yyn];
#line 587
  yystate = (int )((int const   )yypgoto[yyn - 100] + (int const   )*yyssp);
#line 588
  if (yystate >= 0) {
#line 588
    if (yystate <= 1552) {
#line 588
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 589
        yystate = (int )yytable[yystate];
      } else {
#line 591
        yystate = (int )yydefgoto[yyn - 100];
      }
    } else {
#line 591
      yystate = (int )yydefgoto[yyn - 100];
    }
  } else {
#line 591
    yystate = (int )yydefgoto[yyn - 100];
  }
#line 593
  goto yynewstate;
  yyerrlab: 
#line 597
  if (! yyerrstatus) {
    {
#line 600
    yynerrs ++;
#line 643
    yyerror((char *)"parse error");
    }
  }
#line 646
  goto yyerrlab1;
  yyerrlab1: 
#line 649
  if (yyerrstatus == 3) {
#line 654
    if (yychar == 0) {
#line 655
      goto yyabortlab;
    }
#line 658
    if (yydebug) {
      {
#line 659
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Discarding token %d (%s).\n",
              yychar, yytname[yychar1]);
      }
    }
#line 662
    yychar = -2;
  }
#line 668
  yyerrstatus = 3;
#line 670
  goto yyerrhandle;
  yyerrdefault: 
#line 683
  if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 683
    goto yyabortlab;
  }
#line 684
  yyvsp --;
#line 685
  yyssp --;
#line 685
  yystate = (int )*yyssp;
#line 691
  if (yydebug) {
    {
#line 693
    ssp1___0 = yyss - 1;
#line 694
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: state stack now");
    }
    {
#line 695
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 695
      if (! ((unsigned long )ssp1___0 != (unsigned long )yyssp)) {
#line 695
        goto while_break___39;
      }
      {
#line 696
      ssp1___0 ++;
#line 696
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
              (int )*ssp1___0);
      }
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 697
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  yyerrhandle: 
#line 703
  yyn = (int )yypact[yystate];
#line 704
  if (yyn == -32768) {
#line 705
    goto yyerrdefault;
  }
#line 707
  yyn ++;
#line 708
  if (yyn < 0) {
#line 709
    goto yyerrdefault;
  } else
#line 708
  if (yyn > 1552) {
#line 709
    goto yyerrdefault;
  } else
#line 708
  if ((int const   )yycheck[yyn] != 1) {
#line 709
    goto yyerrdefault;
  }
#line 711
  yyn = (int )yytable[yyn];
#line 712
  if (yyn < 0) {
#line 714
    if (yyn == -32768) {
#line 715
      goto yyerrdefault;
    }
#line 716
    yyn = - yyn;
#line 717
    goto yyreduce;
  } else
#line 719
  if (yyn == 0) {
#line 720
    goto yyerrdefault;
  }
#line 722
  if (yyn == 601) {
#line 723
    goto yyacceptlab;
  }
#line 726
  if (yydebug) {
    {
#line 727
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shifting error token, ");
    }
  }
#line 730
  yyvsp ++;
#line 730
  *yyvsp = yylval;
#line 735
  yystate = yyn;
#line 736
  goto yynewstate;
  yyacceptlab: 
#line 740
  if (yyfree_stacks) {
    {
#line 742
    free((void *)yyss);
#line 743
    free((void *)yyvs);
    }
  }
#line 748
  return (0);
  yyabortlab: 
#line 752
  if (yyfree_stacks) {
    {
#line 754
    free((void *)yyss);
#line 755
    free((void *)yyvs);
    }
  }
#line 760
  return (1);
}
}
#line 5371 "ys.y"
void dump_yacc(void) 
{ 


  {
#line 5375
  yydebug = 1;
#line 5379
  return;
}
}
