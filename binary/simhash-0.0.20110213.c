/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 134 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
struct hashinfo {
   unsigned short nshingle ;
   unsigned int nfeature ;
   unsigned int *feature ;
};
#line 134 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
typedef struct hashinfo hashinfo;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.h"
void hash_reset(int size ) ;
#line 8
int hash_contains(unsigned int crc ) ;
#line 9
void hash_insert(unsigned int crc ) ;
#line 10
int hash_delete(unsigned int crc ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
static char *occ  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
static int *hash  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
static int nhash  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
static int next_pow2(int n ) 
{ 
  int m ;

  {
#line 30
  m = 1;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (n > 0)) {
#line 31
      goto while_break;
    }
#line 32
    n >>= 1;
#line 33
    m <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return (m);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
static void hash_alloc(void) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 40
  tmp = malloc((unsigned long )nhash * sizeof(int ));
#line 40
  hash = (int *)tmp;
  }
#line 41
  if (! hash) {
    {
#line 41
    __assert_fail("hash", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c",
                  41U, "hash_alloc");
    }
  }
  {
#line 42
  tmp___0 = malloc((size_t )nhash);
#line 42
  occ = (char *)tmp___0;
  }
#line 43
  if (! occ) {
    {
#line 43
    __assert_fail("occ", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c",
                  43U, "hash_alloc");
    }
  }
#line 44
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < nhash)) {
#line 44
      goto while_break;
    }
#line 45
    *(occ + i) = (char)0;
#line 44
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
void hash_reset(int size ) 
{ 


  {
  {
#line 52
  nhash = 7 * size;
#line 53
  nhash = next_pow2(nhash);
#line 54
  hash_alloc();
  }
#line 55
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
static int do_hash_insert(unsigned int crc ) 
{ 
  int count ;
  unsigned int h ;
  int i ;

  {
#line 63
  h = crc;
#line 64
  count = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (count < nhash)) {
#line 64
      goto while_break;
    }
#line 65
    i = (int )(h & (unsigned int )(nhash - 1));
#line 66
    if ((int )*(occ + i) != 1) {
#line 67
      *(occ + i) = (char)1;
#line 68
      *(hash + i) = (int )crc;
#line 69
      return (1);
    }
#line 71
    if ((unsigned int )*(hash + i) == crc) {
#line 72
      return (1);
    }
#line 73
    h += (unsigned int )(2 * (nhash / 4) + 1);
#line 64
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return (0);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
static void gc(void) 
{ 
  int i ;
  int *oldhash ;
  char *oldocc ;
  int tmp ;

  {
  {
#line 81
  oldhash = hash;
#line 82
  oldocc = occ;
#line 83
  hash_alloc();
#line 84
  i = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < nhash)) {
#line 84
      goto while_break;
    }
#line 85
    if ((int )*(oldocc + i) == 1) {
      {
#line 86
      tmp = do_hash_insert((unsigned int )*(oldhash + i));
      }
#line 86
      if (! tmp) {
        {
#line 87
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"internal error: gc failed, table full\n");
#line 88
        exit(1);
        }
      }
    }
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  free((void *)oldhash);
#line 93
  free((void *)oldocc);
  }
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
void hash_insert(unsigned int crc ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 97
  tmp = do_hash_insert(crc);
  }
#line 97
  if (tmp) {
#line 98
    return;
  }
  {
#line 99
  gc();
#line 100
  tmp___0 = do_hash_insert(crc);
  }
#line 100
  if (tmp___0) {
#line 101
    return;
  }
  {
#line 102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"internal error: insert failed, table full\n");
#line 103
  abort();
  }
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
static int do_hash_contains(unsigned int crc ) 
{ 
  int count ;
  unsigned int h ;
  int i ;

  {
#line 109
  h = crc;
#line 110
  count = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (count < nhash)) {
#line 110
      goto while_break;
    }
#line 111
    i = (int )(h & (unsigned int )(nhash - 1));
#line 112
    if ((int )*(occ + i) == 0) {
#line 113
      return (0);
    }
#line 114
    if ((int )*(occ + i) == 1) {
#line 114
      if ((unsigned int )*(hash + i) == crc) {
#line 115
        return (1);
      }
    }
#line 116
    h += (unsigned int )(2 * (nhash / 4) + 1);
#line 110
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return (-1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
int hash_contains(unsigned int crc ) 
{ 
  int result ;
  int tmp ;

  {
  {
#line 122
  tmp = do_hash_contains(crc);
#line 122
  result = tmp;
  }
#line 123
  if (result >= 0) {
#line 124
    return (result);
  }
  {
#line 125
  gc();
#line 126
  result = do_hash_contains(crc);
  }
#line 127
  if (result >= 0) {
#line 128
    return (result);
  }
  {
#line 129
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"internal error: can\'t find value, table full\n");
#line 130
  abort();
  }
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
static int do_hash_delete(unsigned int crc ) 
{ 
  int count ;
  unsigned int h ;
  int i ;

  {
#line 136
  h = crc;
#line 137
  count = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (count < nhash)) {
#line 137
      goto while_break;
    }
#line 138
    i = (int )(h & (unsigned int )(nhash - 1));
#line 139
    if ((int )*(occ + i) == 1) {
#line 139
      if ((unsigned int )*(hash + i) == crc) {
#line 140
        *(occ + i) = (char)2;
#line 141
        return (1);
      }
    }
#line 143
    if ((int )*(occ + i) == 0) {
#line 144
      return (0);
    }
#line 145
    h += (unsigned int )(2 * (nhash / 4) + 1);
#line 137
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (-1);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/hash.c"
int hash_delete(unsigned int crc ) 
{ 
  int result ;
  int tmp ;

  {
  {
#line 151
  tmp = do_hash_delete(crc);
#line 151
  result = tmp;
  }
#line 152
  if (result >= 0) {
#line 153
    return (result);
  }
  {
#line 154
  gc();
#line 155
  result = do_hash_delete(crc);
  }
#line 156
  if (result >= 0) {
#line 157
    return (result);
  }
  {
#line 158
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"internal error: delete failed, table full\n");
#line 159
  abort();
  }
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/crc.h"
int hash_crc32(char *buf___0 , int i0 , int nbuf ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/crc32.c"
static unsigned int crc32_tab[256]  = 
#line 46 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 92 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/crc32.c"
int hash_crc32(char *buf___0 , int i0 , int nbuf ) 
{ 
  int i ;
  int crc ;

  {
#line 93
  i = i0;
#line 94
  crc = (int )(~ 0U);
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    crc = (int )(crc32_tab[(crc ^ (int )*(buf___0 + i)) & 255] ^ (unsigned int )(crc >> 8));
#line 97
    i = (i + 1) % nbuf;
#line 95
    if (! (i != i0)) {
#line 95
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return ((int )((unsigned int )crc ^ 4294967295U));
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.h"
unsigned int *heap ;
#line 8
int nheap ;
#line 9
void heap_reset(int size ) ;
#line 10
unsigned int heap_extract_max(void) ;
#line 11
void heap_insert(unsigned int v ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
int nshingle  =    8;
#line 54 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
int nfeature  =    128;
#line 56 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
int pset  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
int debug_trace  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static struct option long_options[7]  = {      {"write-hashfile", 0, (int *)0, 'w'}, 
        {"match-files", 0, (int *)0, 'm'}, 
        {"compare-hashfile", 0, (int *)0, 'c'}, 
        {"shingle-size", 1, (int *)0, 's'}, 
        {"feature-set-size", 1, (int *)0, 'f'}, 
        {"debug-trace", 1, (int *)0, 'd'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 79 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static void crc_insert(unsigned int crc ) 
{ 
  int tmp ;
  unsigned int m ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 80
  if (debug_trace) {
    {
#line 81
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">got %x\n",
            crc);
    }
  }
#line 82
  if (nheap == nfeature) {
#line 82
    if (crc >= *(heap + 0)) {
#line 83
      return;
    }
  }
  {
#line 84
  tmp = hash_contains(crc);
  }
#line 84
  if (tmp) {
#line 85
    if (debug_trace) {
      {
#line 86
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">dup\n");
      }
    }
#line 87
    return;
  }
#line 89
  if (nheap == nfeature) {
    {
#line 90
    tmp___0 = heap_extract_max();
#line 90
    m = tmp___0;
#line 91
    tmp___1 = hash_delete(m);
    }
#line 91
    if (! tmp___1) {
      {
#line 91
      __assert_fail("hash_delete(m)", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                    91U, "crc_insert");
      }
    }
#line 92
    if (debug_trace) {
      {
#line 93
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">pop %x\n",
              m);
      }
    }
  }
#line 95
  if (debug_trace) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">push\n");
    }
  }
  {
#line 97
  hash_insert(crc);
#line 98
  heap_insert(crc);
  }
#line 99
  return;
}
}
#line 105
static int running_crc(FILE *f ) ;
#line 105 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static char *buf  =    (char *)0;
#line 103 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static int running_crc(FILE *f ) 
{ 
  int i ;
  void *tmp ;
  int ch ;
  int tmp___0 ;
  int ch___0 ;
  int tmp___1 ;

  {
#line 106
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    {
#line 107
    tmp = malloc((size_t )nshingle);
#line 107
    buf = (char *)tmp;
    }
#line 108
    if (! buf) {
      {
#line 108
      __assert_fail("buf", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                    108U, "running_crc");
      }
    }
  }
#line 110
  i = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i < nshingle)) {
#line 110
      goto while_break;
    }
    {
#line 111
    tmp___0 = fgetc(f);
#line 111
    ch = tmp___0;
    }
#line 112
    if (ch == -1) {
      {
#line 113
      fclose(f);
      }
#line 114
      return (0);
    }
#line 116
    *(buf + i) = (char )ch;
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  i = 0;
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 121
    tmp___1 = hash_crc32(buf, i, nshingle);
#line 121
    crc_insert((unsigned int )tmp___1);
#line 122
    ch___0 = fgetc(f);
    }
#line 123
    if (ch___0 == -1) {
      {
#line 124
      fclose(f);
      }
#line 125
      return (1);
    }
#line 127
    *(buf + i) = (char )ch___0;
#line 128
    i = (i + 1) % nshingle;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 130
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                130U, "running_crc");
  }
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static void free_hashinfo(hashinfo *hi ) 
{ 


  {
  {
#line 141
  free((void *)hi->feature);
#line 142
  free((void *)hi);
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static hashinfo *get_hashinfo(void) 
{ 
  hashinfo *hi ;
  void *tmp ;
  unsigned int *crcs ;
  void *tmp___0 ;
  int i ;
  int tmp___1 ;

  {
  {
#line 146
  tmp = malloc(sizeof(*hi));
#line 146
  hi = (hashinfo *)tmp;
#line 147
  tmp___0 = malloc((unsigned long )nheap * sizeof(*(crcs + 0)));
#line 147
  crcs = (unsigned int *)tmp___0;
#line 148
  i = 0;
  }
#line 149
  if (! hi) {
    {
#line 149
    __assert_fail("hi", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                  149U, "get_hashinfo");
    }
  }
#line 150
  if (! crcs) {
    {
#line 150
    __assert_fail("crcs", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                  150U, "get_hashinfo");
    }
  }
#line 151
  hi->nshingle = (unsigned short )nshingle;
#line 152
  hi->nfeature = (unsigned int )nheap;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (nheap > 0)) {
#line 153
      goto while_break;
    }
    {
#line 154
    tmp___1 = i;
#line 154
    i ++;
#line 154
    *(crcs + tmp___1) = heap_extract_max();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  hi->feature = crcs;
#line 156
  return (hi);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static hashinfo *hash_file(FILE *f ) 
{ 
  int tmp ;
  hashinfo *tmp___0 ;

  {
  {
#line 160
  heap_reset(nfeature);
#line 161
  hash_reset(nfeature);
#line 162
  tmp = running_crc(f);
  }
#line 162
  if (! tmp) {
#line 163
    return ((hashinfo *)0);
  }
  {
#line 164
  tmp___0 = get_hashinfo();
  }
#line 164
  return (tmp___0);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static hashinfo *hash_filename(char *filename ) 
{ 
  FILE *f ;
  FILE *tmp ;
  hashinfo *hi ;

  {
  {
#line 169
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 169
  f = tmp;
  }
#line 171
  if (! f) {
    {
#line 172
    perror((char const   *)filename);
#line 173
    exit(1);
    }
  }
  {
#line 175
  hi = hash_file(f);
  }
#line 176
  return (hi);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static void write_hash(hashinfo *hi , FILE *f ) 
{ 
  short s ;
  uint16_t tmp ;
  int i ;
  uint16_t tmp___0 ;
  unsigned int hv ;
  uint32_t tmp___1 ;

  {
  {
#line 181
  tmp = htons((uint16_t )51969);
#line 181
  s = (short )tmp;
#line 183
  fwrite((void const   */* __restrict  */)(& s), sizeof(short ), (size_t )1, (FILE */* __restrict  */)f);
#line 184
  tmp___0 = htons(hi->nshingle);
#line 184
  s = (short )tmp___0;
#line 185
  fwrite((void const   */* __restrict  */)(& s), sizeof(short ), (size_t )1, (FILE */* __restrict  */)f);
#line 186
  i = 0;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! ((unsigned int )i < hi->nfeature)) {
#line 186
      goto while_break;
    }
    {
#line 187
    tmp___1 = htonl(*(hi->feature + i));
#line 187
    hv = tmp___1;
#line 188
    fwrite((void const   */* __restrict  */)(& hv), sizeof(unsigned int ), (size_t )1,
           (FILE */* __restrict  */)f);
#line 186
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static char nambuf[4097]  ;
#line 192 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static void write_hashes(int argc , char **argv ) 
{ 
  int i ;
  hashinfo *hi ;
  hashinfo *tmp ;
  FILE *of ;

  {
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < argc)) {
#line 195
      goto while_break;
    }
    {
#line 196
    tmp = hash_filename(*(argv + i));
#line 196
    hi = tmp;
    }
#line 198
    if ((unsigned long )hi == (unsigned long )((hashinfo *)0)) {
      {
#line 199
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: not hashed\n",
              *(argv + i));
      }
#line 200
      goto __Cont;
    }
    {
#line 202
    strncpy((char */* __restrict  */)(nambuf), (char const   */* __restrict  */)*(argv + i),
            4096UL - sizeof(".sim"));
#line 204
    nambuf[4096UL - sizeof(".sim")] = (char )'\000';
#line 205
    strcat((char */* __restrict  */)(nambuf), (char const   */* __restrict  */)".sim");
#line 206
    of = fopen((char const   */* __restrict  */)(nambuf), (char const   */* __restrict  */)"w");
    }
#line 207
    if (! of) {
      {
#line 208
      perror((char const   *)*(argv + i));
#line 209
      exit(1);
      }
    }
    {
#line 211
    write_hash(hi, of);
#line 212
    fclose(of);
#line 213
    free_hashinfo(hi);
    }
    __Cont: /* CIL Label */ 
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static hashinfo *read_hash(FILE *f ) 
{ 
  hashinfo *h ;
  void *tmp ;
  short s ;
  int i ;
  unsigned short version ;
  void *tmp___0 ;
  int fe ;
  int nread ;
  size_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 220
  tmp = malloc(sizeof(hashinfo ));
#line 220
  h = (hashinfo *)tmp;
  }
#line 224
  if (! h) {
    {
#line 224
    __assert_fail("h", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                  224U, "read_hash");
    }
  }
  {
#line 225
  fread((void */* __restrict  */)(& s), sizeof(short ), (size_t )1, (FILE */* __restrict  */)f);
#line 226
  version = ntohs((uint16_t )s);
  }
#line 227
  if ((int )version != 51969) {
    {
#line 228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad file version\n");
    }
#line 229
    return ((hashinfo *)0);
  }
  {
#line 231
  fread((void */* __restrict  */)(& s), sizeof(short ), (size_t )1, (FILE */* __restrict  */)f);
#line 232
  h->nshingle = ntohs((uint16_t )s);
#line 233
  h->nfeature = 16U;
#line 234
  tmp___0 = malloc((unsigned long )h->nfeature * sizeof(int ));
#line 234
  h->feature = (unsigned int *)tmp___0;
  }
#line 235
  if (! h->feature) {
    {
#line 235
    __assert_fail("h->feature", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                  235U, "read_hash");
    }
  }
#line 236
  i = 0;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 239
    tmp___1 = fread((void */* __restrict  */)(& fe), sizeof(int ), (size_t )1, (FILE */* __restrict  */)f);
#line 239
    nread = (int )tmp___1;
    }
#line 240
    if (nread <= 0) {
      {
#line 241
      tmp___2 = ferror(f);
      }
#line 241
      if (tmp___2) {
        {
#line 242
        perror("fread");
        }
#line 243
        return ((hashinfo *)0);
      }
      {
#line 245
      h->nfeature = (unsigned int )i;
#line 246
      tmp___3 = realloc((void *)h->feature, (unsigned long )h->nfeature * sizeof(int ));
#line 246
      h->feature = (unsigned int *)tmp___3;
      }
#line 247
      if (! h->feature) {
        {
#line 247
        __assert_fail("h->feature", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                      247U, "read_hash");
        }
      }
#line 248
      return (h);
    }
#line 250
    if ((unsigned int )i >= h->nfeature) {
      {
#line 251
      h->nfeature *= 2U;
#line 252
      tmp___4 = realloc((void *)h->feature, (unsigned long )h->nfeature * sizeof(int ));
#line 252
      h->feature = (unsigned int *)tmp___4;
      }
#line 253
      if (! h->feature) {
        {
#line 253
        __assert_fail("h->feature", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                      253U, "read_hash");
        }
      }
    }
    {
#line 255
    tmp___5 = i;
#line 255
    i ++;
#line 255
    *(h->feature + tmp___5) = ntohl((uint32_t )fe);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  h->nfeature = (unsigned int )i;
#line 258
  abort();
  }
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static hashinfo *read_hashfile(char *name ) 
{ 
  FILE *f ;
  FILE *tmp ;
  hashinfo *hi ;

  {
  {
#line 264
  tmp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
#line 264
  f = tmp;
  }
#line 266
  if (! f) {
    {
#line 267
    perror((char const   *)name);
#line 268
    exit(1);
    }
  }
  {
#line 270
  hi = read_hash(f);
  }
#line 271
  return (hi);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static double score(hashinfo *hi1 , hashinfo *hi2 ) 
{ 
  double unionsize ;
  double intersectsize ;
  int i1 ;
  int i2 ;
  int count ;
  int matchcount ;

  {
#line 284
  i1 = (int )(hi1->nfeature - 1U);
#line 285
  i2 = (int )(hi2->nfeature - 1U);
#line 286
  count = 0;
#line 287
  matchcount = 0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (i1 >= 0) {
#line 288
      if (! (i2 >= 0)) {
#line 288
        goto while_break;
      }
    } else {
#line 288
      goto while_break;
    }
#line 289
    if (*(hi1->feature + i1) < *(hi2->feature + i2)) {
#line 290
      i1 --;
#line 291
      goto while_continue;
    }
#line 293
    if (*(hi1->feature + i1) > *(hi2->feature + i2)) {
#line 294
      i2 --;
#line 295
      goto while_continue;
    }
#line 297
    matchcount ++;
#line 298
    i1 --;
#line 299
    i2 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  count = (int )hi1->nfeature;
#line 302
  if ((unsigned int )count > hi2->nfeature) {
#line 303
    count = (int )hi2->nfeature;
  }
#line 304
  intersectsize = (double )matchcount;
#line 305
  unionsize = (double )(2 * count - matchcount);
#line 306
  return (intersectsize / unionsize);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
void print_score(int fieldwidth , double s ) 
{ 
  int lead ;
  int i ;
  double tmp ;

  {
#line 310
  lead = fieldwidth - 3;
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! (i < lead)) {
#line 312
      goto while_break;
    }
    {
#line 313
    printf((char const   */* __restrict  */)" ");
#line 312
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  if (s == (double )-1) {
    {
#line 315
    printf((char const   */* __restrict  */)" ? ");
    }
  } else
#line 316
  if (s == 1.0) {
    {
#line 317
    printf((char const   */* __restrict  */)"1.0");
    }
  } else {
    {
#line 319
    tmp = floor(s * (double )100);
#line 319
    printf((char const   */* __restrict  */)".%02d", (int )tmp);
    }
  }
#line 321
  return;
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static void compare_hashes(char *name1 , char *name2 ) 
{ 
  hashinfo *hi1 ;
  hashinfo *hi2 ;
  double tmp ;

  {
  {
#line 325
  hi1 = read_hashfile(name1);
  }
#line 326
  if (! hi1) {
    {
#line 327
    exit(1);
    }
  }
  {
#line 328
  hi2 = read_hashfile(name2);
  }
#line 329
  if (! hi2) {
    {
#line 330
    exit(1);
    }
  }
#line 331
  if ((int )hi1->nshingle != (int )hi2->nshingle) {
    {
#line 332
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"shingle size mismatch\n");
#line 333
    exit(1);
    }
  }
  {
#line 342
  tmp = score(hi1, hi2);
#line 342
  print_score(0, tmp);
#line 343
  printf((char const   */* __restrict  */)"\n");
#line 344
  free_hashinfo(hi1);
#line 345
  free_hashinfo(hi2);
  }
#line 346
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static int width(int n ) 
{ 
  int i ;
  int k ;

  {
#line 350
  i = 0;
#line 351
  k = 1;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (k <= n)) {
#line 352
      goto while_break;
    }
#line 353
    k *= 10;
#line 354
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (i);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static void print_index(int fieldwidth , int value ) 
{ 
  int n ;
  int tmp ;
  int lead ;
  int i ;

  {
  {
#line 360
  tmp = width(value);
#line 360
  n = tmp;
#line 361
  lead = fieldwidth - n;
#line 363
  i = 0;
  }
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! (i < lead)) {
#line 363
      goto while_break;
    }
    {
#line 364
    printf((char const   */* __restrict  */)" ");
#line 363
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 365
  printf((char const   */* __restrict  */)"%d", value);
  }
#line 366
  return;
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static void match_hashes(int argc , char **argv ) 
{ 
  hashinfo **his ;
  void *tmp ;
  double **scores ;
  void *tmp___0 ;
  int nfilename ;
  int i ;
  int j ;
  int fieldwidth ;
  void *tmp___1 ;
  int n ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 369
  tmp = malloc((unsigned long )argc * sizeof(*his));
#line 369
  his = (hashinfo **)tmp;
#line 370
  tmp___0 = malloc((unsigned long )argc * sizeof(*scores));
#line 370
  scores = (double **)tmp___0;
#line 371
  nfilename = 0;
  }
#line 374
  if (argc <= 0) {
#line 375
    return;
  }
#line 376
  if (! his) {
    {
#line 376
    __assert_fail("his", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                  376U, "match_hashes");
    }
  }
#line 377
  if (! scores) {
    {
#line 377
    __assert_fail("scores", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                  377U, "match_hashes");
    }
  }
#line 379
  i = 0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (i < argc)) {
#line 379
      goto while_break;
    }
    {
#line 380
    *(his + i) = hash_filename(*(argv + i));
#line 379
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  i = 0;
  {
#line 382
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 382
    if (! (i < argc)) {
#line 382
      goto while_break___0;
    }
    {
#line 383
    tmp___1 = malloc((unsigned long )argc * sizeof(*(*scores)));
#line 383
    *(scores + i) = (double *)tmp___1;
    }
#line 384
    if (! *(scores + i)) {
      {
#line 384
      __assert_fail("scores[i]", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c",
                    384U, "match_hashes");
      }
    }
#line 385
    j = 0;
    {
#line 385
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 385
      if (! (j < i)) {
#line 385
        goto while_break___1;
      }
#line 386
      if (*(his + i)) {
#line 386
        if (*(his + j)) {
          {
#line 387
          *(*(scores + i) + j) = score(*(his + i), *(his + j));
          }
        } else {
#line 389
          *(*(scores + i) + j) = (double )-1;
        }
      } else {
#line 389
        *(*(scores + i) + j) = (double )-1;
      }
#line 385
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 382
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 392
  i = 0;
  {
#line 392
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 392
    if (! (i < argc)) {
#line 392
      goto while_break___2;
    }
    {
#line 393
    tmp___2 = strlen((char const   *)*(argv + i));
#line 393
    n = (int )tmp___2;
    }
#line 394
    if (n > nfilename) {
#line 395
      nfilename = n;
    }
#line 392
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 398
  fieldwidth = width(argc);
  }
#line 399
  if (fieldwidth < 3) {
#line 400
    fieldwidth = 3;
  }
#line 402
  i = 0;
  {
#line 402
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 402
    if (! (i <= nfilename + fieldwidth)) {
#line 402
      goto while_break___3;
    }
    {
#line 403
    printf((char const   */* __restrict  */)" ");
#line 402
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 404
  i = 1;
  {
#line 404
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 404
    if (! (i < argc - 1)) {
#line 404
      goto while_break___4;
    }
    {
#line 405
    print_index(fieldwidth, i);
#line 406
    printf((char const   */* __restrict  */)" ");
#line 404
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 408
  print_index(fieldwidth, argc - 1);
#line 409
  printf((char const   */* __restrict  */)"\n");
#line 411
  i = 0;
  }
  {
#line 411
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 411
    if (! (i < argc)) {
#line 411
      goto while_break___5;
    }
    {
#line 412
    printf((char const   */* __restrict  */)"%s", *(argv + i));
#line 413
    tmp___3 = strlen((char const   *)*(argv + i));
#line 413
    j = (int )tmp___3;
    }
    {
#line 413
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 413
      if (! (j <= nfilename)) {
#line 413
        goto while_break___6;
      }
      {
#line 414
      printf((char const   */* __restrict  */)" ");
#line 413
      j ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 415
    print_index(fieldwidth, i + 1);
    }
#line 416
    if (i > 0) {
      {
#line 417
      printf((char const   */* __restrict  */)" ");
      }
    }
#line 418
    j = 0;
    {
#line 418
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 418
      if (! (j < i - 1)) {
#line 418
        goto while_break___7;
      }
      {
#line 419
      print_score(fieldwidth, *(*(scores + i) + j));
#line 420
      printf((char const   */* __restrict  */)" ");
#line 418
      j ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 422
    if (i > 0) {
      {
#line 423
      print_score(fieldwidth, *(*(scores + i) + (i - 1)));
      }
    }
    {
#line 424
    printf((char const   */* __restrict  */)"\n");
#line 411
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 426
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
static void usage(void) 
{ 


  {
  {
#line 430
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"simhash: usage:\n\tsimhash [-s nshingles] [-f nfeatures] [file]\n\tsimhash [-s nshingles] [-f nfeatures] [-w|-m] file ...\n\tsimhash -c hashfile hashfile\n");
#line 434
  exit(1);
  }
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/simhash.c"
int main(int argc , char **argv ) 
{ 
  char mode ;
  FILE *fin ;
  int tmp ;
  hashinfo *hi ;

  {
#line 438
  mode = (char )'?';
#line 439
  fin = stdin;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 442
    tmp = getopt_long(argc, (char * const  *)argv, "wmcs:f:d", (struct option  const  *)(long_options),
                      (int *)0);
    }
    {
#line 444
    if (tmp == 119) {
#line 444
      goto case_119;
    }
#line 447
    if (tmp == 109) {
#line 447
      goto case_109;
    }
#line 450
    if (tmp == 99) {
#line 450
      goto case_99;
    }
#line 453
    if (tmp == 115) {
#line 453
      goto case_115;
    }
#line 461
    if (tmp == 102) {
#line 461
      goto case_102;
    }
#line 469
    if (tmp == 100) {
#line 469
      goto case_100;
    }
#line 442
    goto switch_break;
    case_119: /* CIL Label */ 
#line 445
    mode = (char )'w';
#line 446
    goto while_continue;
    case_109: /* CIL Label */ 
#line 448
    mode = (char )'m';
#line 449
    goto while_continue;
    case_99: /* CIL Label */ 
#line 451
    mode = (char )'c';
#line 452
    goto while_continue;
    case_115: /* CIL Label */ 
    {
#line 454
    nshingle = atoi((char const   *)optarg);
    }
#line 455
    if (nshingle < 4) {
      {
#line 456
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"simhash: shingle size must be at least 4\n");
#line 457
      exit(1);
      }
    }
#line 459
    pset = 1;
#line 460
    goto while_continue;
    case_102: /* CIL Label */ 
    {
#line 462
    nfeature = atoi((char const   *)optarg);
    }
#line 463
    if (nfeature < 1) {
      {
#line 464
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"simhash: feature set size must be at least 1\n");
#line 465
      exit(1);
      }
    }
#line 467
    pset = 1;
#line 468
    goto while_continue;
    case_100: /* CIL Label */ 
#line 470
    debug_trace = 1;
    switch_break: /* CIL Label */ ;
    }
#line 472
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 476
  if ((int )mode == 63) {
#line 476
    goto case_63;
  }
#line 501
  if ((int )mode == 119) {
#line 501
    goto case_119___0;
  }
#line 504
  if ((int )mode == 99) {
#line 504
    goto case_99___0;
  }
#line 511
  if ((int )mode == 109) {
#line 511
    goto case_109___0;
  }
#line 475
  goto switch_break___0;
  case_63: /* CIL Label */ 
  {
#line 479
  if (argc - optind == 1) {
#line 479
    goto case_1;
  }
#line 488
  if (argc - optind == 0) {
#line 488
    goto case_0;
  }
#line 477
  goto switch_break___1;
  case_1: /* CIL Label */ 
  {
#line 480
  hi = hash_filename(*(argv + optind));
  }
#line 481
  if (! hi) {
    {
#line 482
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not hashable\n",
            *(argv + optind));
    }
#line 483
    return (-1);
  }
  {
#line 485
  write_hash(hi, stdout);
#line 486
  free_hashinfo(hi);
  }
#line 487
  return (0);
  case_0: /* CIL Label */ 
  {
#line 489
  hi = hash_file(fin);
  }
#line 490
  if (! hi) {
    {
#line 491
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stdin not hashable\n");
    }
#line 492
    return (-1);
  }
  {
#line 494
  write_hash(hi, stdout);
#line 495
  free_hashinfo(hi);
  }
#line 496
  return (0);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 498
  usage();
#line 499
  abort();
  }
  case_119___0: /* CIL Label */ 
  {
#line 502
  write_hashes(argc - optind, argv + optind);
  }
#line 503
  return (0);
  case_99___0: /* CIL Label */ 
#line 505
  if (pset) {
    {
#line 506
    usage();
    }
  }
#line 507
  if (optind != argc - 2) {
    {
#line 508
    usage();
    }
  }
  {
#line 509
  compare_hashes(*(argv + optind), *(argv + (optind + 1)));
  }
#line 510
  return (0);
  case_109___0: /* CIL Label */ 
  {
#line 512
  match_hashes(argc - optind, argv + optind);
  }
#line 513
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 515
  abort();
  }
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c"
unsigned int *heap  =    (unsigned int *)0;
#line 19 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c"
int nheap  =    0;
#line 20 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c"
static int maxheap  =    0;
#line 22 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c"
void heap_reset(int size ) 
{ 
  void *tmp ;

  {
#line 23
  nheap = 0;
#line 24
  maxheap = size;
#line 25
  if (heap) {
    {
#line 26
    free((void *)heap);
    }
  }
  {
#line 27
  tmp = malloc((unsigned long )size * sizeof(*heap));
#line 27
  heap = (unsigned int *)tmp;
  }
#line 28
  if (! heap) {
    {
#line 28
    __assert_fail("heap", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c",
                  28U, "heap_reset");
    }
  }
#line 29
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c"
static void downheap(void) 
{ 
  int tmp ;
  int i ;
  int left ;
  int right ;

  {
#line 35
  i = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    left = (i << 1) + 1;
#line 38
    right = left + 1;
#line 39
    if (left >= nheap) {
#line 40
      return;
    }
#line 41
    if (right >= nheap) {
#line 42
      if (*(heap + i) < *(heap + left)) {
#line 43
        tmp = (int )*(heap + left);
#line 44
        *(heap + left) = *(heap + i);
#line 45
        *(heap + i) = (unsigned int )tmp;
      }
#line 47
      return;
    }
#line 49
    if (*(heap + i) >= *(heap + left)) {
#line 49
      if (*(heap + i) >= *(heap + right)) {
#line 51
        return;
      }
    }
#line 52
    if (*(heap + left) > *(heap + right)) {
#line 53
      tmp = (int )*(heap + left);
#line 54
      *(heap + left) = *(heap + i);
#line 55
      *(heap + i) = (unsigned int )tmp;
#line 56
      i = left;
    } else {
#line 58
      tmp = (int )*(heap + right);
#line 59
      *(heap + right) = *(heap + i);
#line 60
      *(heap + i) = (unsigned int )tmp;
#line 61
      i = right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c"
unsigned int heap_extract_max(void) 
{ 
  unsigned int m ;

  {
#line 68
  if (! (nheap > 0)) {
    {
#line 68
    __assert_fail("nheap > 0", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c",
                  68U, "heap_extract_max");
    }
  }
  {
#line 71
  m = *(heap + 0);
#line 72
  nheap --;
#line 72
  *(heap + 0) = *(heap + nheap);
#line 74
  downheap();
  }
#line 76
  return (m);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c"
static void upheap(void) 
{ 
  int i ;
  int tmp ;
  int parent ;

  {
#line 82
  i = nheap - 1;
#line 83
  if (! (nheap > 0)) {
    {
#line 83
    __assert_fail("nheap > 0", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c",
                  83U, "upheap");
    }
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i > 0)) {
#line 84
      goto while_break;
    }
#line 86
    parent = (i - 1) >> 1;
#line 87
    if (*(heap + parent) >= *(heap + i)) {
#line 88
      return;
    }
#line 89
    tmp = (int )*(heap + parent);
#line 90
    *(heap + parent) = *(heap + i);
#line 91
    *(heap + i) = (unsigned int )tmp;
#line 92
    i = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c"
void heap_insert(unsigned int v ) 
{ 
  int tmp ;

  {
#line 97
  if (! (nheap < maxheap)) {
    {
#line 97
    __assert_fail("nheap < maxheap", "/home/june/repo/benchmarks/collector/temp/simhash-0.0.20110213/heap.c",
                  97U, "heap_insert");
    }
  }
  {
#line 98
  tmp = nheap;
#line 98
  nheap ++;
#line 98
  *(heap + tmp) = v;
#line 99
  upheap();
  }
#line 100
  return;
}
}
