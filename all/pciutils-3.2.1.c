/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 24 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/types.h"
typedef u_int8_t u8;
#line 25 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/types.h"
typedef u_int16_t u16;
#line 32 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/types.h"
typedef unsigned long u64;
#line 43 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/types.h"
typedef u64 pciaddr_t;
#line 29 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
struct pci_methods;
#line 46
struct pci_dev;
#line 46
struct pci_param;
#line 46
struct id_entry;
#line 46
struct id_bucket;
#line 46 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
struct pci_access {
   unsigned int method ;
   int writeable ;
   int buscentric ;
   char *id_file_name ;
   int free_id_name ;
   int numeric_ids ;
   unsigned int id_lookup_mode ;
   int debugging ;
   void ( /* format attribute */  (*error))(char *msg  , ...) ;
   void ( /* format attribute */  (*warning))(char *msg  , ...) ;
   void ( /* format attribute */  (*debug))(char *msg  , ...) ;
   struct pci_dev *devices ;
   struct pci_methods *methods ;
   struct pci_param *params ;
   struct id_entry **id_hash ;
   struct id_bucket *current_id_bucket ;
   int id_load_failed ;
   int id_cache_status ;
   int fd ;
   int fd_rw ;
   int fd_pos ;
   int fd_vpd ;
   struct pci_dev *cached_dev ;
};
#line 100 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
struct pci_param {
   struct pci_param *next ;
   char *param ;
   char *value ;
   int value_malloced ;
   char *help ;
};
#line 117
struct pci_cap;
#line 117 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
struct pci_dev {
   struct pci_dev *next ;
   u16 domain ;
   u8 bus ;
   u8 dev ;
   u8 func ;
   int known_fields ;
   u16 vendor_id ;
   u16 device_id ;
   u16 device_class ;
   int irq ;
   pciaddr_t base_addr[6] ;
   pciaddr_t size[6] ;
   pciaddr_t rom_base_addr ;
   pciaddr_t rom_size ;
   struct pci_cap *first_cap ;
   char *phy_slot ;
   char *module_alias ;
   struct pci_access *access ;
   struct pci_methods *methods ;
   u8 *cache ;
   int cache_len ;
   int hdrtype ;
   void *aux ;
};
#line 178 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
struct pci_cap {
   struct pci_cap *next ;
   u16 id ;
   u16 type ;
   unsigned int addr ;
};
#line 18 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysdep.h"
typedef u8 byte;
#line 25 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/internal.h"
struct pci_methods {
   char *name ;
   char *help ;
   void (*config)(struct pci_access * ) ;
   int (*detect)(struct pci_access * ) ;
   void (*init)(struct pci_access * ) ;
   void (*cleanup)(struct pci_access * ) ;
   void (*scan)(struct pci_access * ) ;
   int (*fill_info)(struct pci_dev * , int flags ) ;
   int (*read)(struct pci_dev * , int pos , byte *buf , int len ) ;
   int (*write)(struct pci_dev * , int pos , byte *buf , int len ) ;
   int (*read_vpd)(struct pci_dev * , int pos , byte *buf , int len ) ;
   void (*init_dev)(struct pci_dev * ) ;
   void (*cleanup_dev)(struct pci_dev * ) ;
};
#line 16 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
struct dump_data {
   int len ;
   int allocated ;
   byte data[1] ;
};
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 26 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/types.h"
typedef u_int32_t u32;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 13 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.h"
struct id_entry {
   struct id_entry *next ;
   u32 id12 ;
   u32 id34 ;
   byte cat ;
   byte src ;
   char name[1] ;
};
#line 32
enum id_entry_src {
    SRC_UNKNOWN = 0,
    SRC_CACHE = 1,
    SRC_NET = 2,
    SRC_LOCAL = 3
} ;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 19 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysdep.h"
typedef u16 word;
#line 194 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
struct pci_filter {
   int domain ;
   int bus ;
   int slot ;
   int func ;
   int vendor ;
   int device ;
};
#line 52 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-parse.c"
typedef FILE *pci_file;
#line 14 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-hash.c"
struct id_bucket {
   struct id_bucket *next ;
   unsigned int full ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 38 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-net.c"
struct dns_state {
   u16 counts[4] ;
   byte *sections[5] ;
   byte *sec_ptr ;
   byte *sec_end ;
   u16 rr_type ;
   u16 rr_class ;
   u32 rr_ttl ;
   u16 rr_len ;
   byte *rr_data ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 89 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
struct pci_dev *pci_get_dev(struct pci_access *a , int domain , int bus , int dev ,
                            int func ) ;
#line 108
char *pci_get_param(struct pci_access *acc , char *param ) ;
#line 44 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/internal.h"
int pci_generic_fill_info(struct pci_dev *d , int flags ) ;
#line 49
void *pci_malloc(struct pci_access *a , int size ) ;
#line 50
void pci_mfree(void *x ) ;
#line 55
int pci_link_dev(struct pci_access *a , struct pci_dev *d ) ;
#line 62
void pci_define_param(struct pci_access *acc , char *param , char *value , char *help ) ;
#line 70
struct pci_methods pm_dump ;
#line 21 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static void dump_config(struct pci_access *a ) 
{ 


  {
  {
#line 24
  pci_define_param(a, (char *)"dump.name", (char *)"", (char *)"Name of the bus dump file to read from");
  }
#line 25
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static int dump_detect(struct pci_access *a ) 
{ 
  char *name ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 30
  tmp = pci_get_param(a, (char *)"dump.name");
#line 30
  name = tmp;
  }
#line 31
  if (name) {
#line 31
    if (*(name + 0)) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  } else {
#line 31
    tmp___0 = 0;
  }
#line 31
  return (tmp___0);
}
}
#line 34 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static void dump_alloc_data(struct pci_dev *dev , int len ) 
{ 
  struct dump_data *dd ;
  void *tmp ;

  {
  {
#line 37
  tmp = pci_malloc(dev->access, (int )((sizeof(struct dump_data ) + (unsigned long )len) - 1UL));
#line 37
  dd = (struct dump_data *)tmp;
#line 38
  dd->allocated = len;
#line 39
  dd->len = 0;
#line 40
  memset((void *)(dd->data), 255, (size_t )len);
#line 41
  dev->aux = (void *)dd;
  }
#line 42
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static int dump_validate(char *s , char *fmt ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! *fmt) {
#line 47
      goto while_break;
    }
#line 49
    if ((int )*fmt == 35) {
      {
#line 49
      tmp = __ctype_b_loc();
      }
#line 49
      if ((int const   )*(*tmp + (int )*s) & 4096) {
#line 49
        tmp___0 = 0;
      } else {
#line 49
        tmp___0 = 1;
      }
#line 49
      tmp___1 = tmp___0;
    } else {
#line 49
      tmp___1 = (int )*fmt != (int )*s;
    }
#line 49
    if (tmp___1) {
#line 50
      return (0);
    }
#line 51
    fmt ++;
#line 51
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return (1);
}
}
#line 56 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static void dump_init(struct pci_access *a ) 
{ 
  char *name ;
  char *tmp ;
  FILE *f ;
  char buf[256] ;
  struct pci_dev *dev ;
  int len ;
  int mn ;
  int bn ;
  int dn ;
  int fn ;
  int i ;
  int j ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *z ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct dump_data *dd ;
  char *tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 59
  tmp = pci_get_param(a, (char *)"dump.name");
#line 59
  name = tmp;
#line 62
  dev = (struct pci_dev *)((void *)0);
  }
#line 65
  if (! name) {
    {
#line 66
    (*(a->error))((char *)"dump: File name not given.");
    }
  }
  {
#line 67
  f = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 67
  if (! f) {
    {
#line 68
    tmp___0 = __errno_location();
#line 68
    tmp___1 = strerror(*tmp___0);
#line 68
    (*(a->error))((char *)"dump: Cannot open %s: %s", name, tmp___1);
    }
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    tmp___17 = fgets((char */* __restrict  */)(buf), (int )(sizeof(buf) - 1UL), (FILE */* __restrict  */)f);
    }
#line 69
    if (! tmp___17) {
#line 69
      goto while_break;
    }
    {
#line 71
    tmp___2 = strchr((char const   *)(buf), '\n');
#line 71
    z = tmp___2;
    }
#line 72
    if (! z) {
      {
#line 74
      fclose(f);
#line 75
      (*(a->error))((char *)"dump: line too long or unterminated");
      }
    }
#line 77
    tmp___3 = z;
#line 77
    z --;
#line 77
    *tmp___3 = (char)0;
#line 78
    if ((unsigned long )z >= (unsigned long )(buf)) {
#line 78
      if ((int )*z == 13) {
#line 79
        tmp___4 = z;
#line 79
        z --;
#line 79
        *tmp___4 = (char)0;
      }
    }
    {
#line 80
    len = (int )((z - buf) + 1L);
#line 81
    mn = 0;
#line 82
    tmp___13 = dump_validate(buf, (char *)"##:##.# ");
    }
#line 82
    if (tmp___13) {
      {
#line 82
      tmp___14 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%x:%x.%d",
                        & bn, & dn, & fn);
      }
#line 82
      if (tmp___14 == 3) {
        {
#line 85
        dev = pci_get_dev(a, mn, bn, dn, fn);
#line 86
        dump_alloc_data(dev, 256);
#line 87
        pci_link_dev(a, dev);
        }
      } else {
#line 82
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 82
      tmp___15 = dump_validate(buf, (char *)"####:##:##.# ");
      }
#line 82
      if (tmp___15) {
        {
#line 82
        tmp___16 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%x:%x:%x.%d",
                          & mn, & bn, & dn, & fn);
        }
#line 82
        if (tmp___16 == 4) {
          {
#line 85
          dev = pci_get_dev(a, mn, bn, dn, fn);
#line 86
          dump_alloc_data(dev, 256);
#line 87
          pci_link_dev(a, dev);
          }
        } else {
#line 82
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 89
      if (! len) {
#line 90
        dev = (struct pci_dev *)((void *)0);
      } else
#line 91
      if (dev) {
        {
#line 91
        tmp___10 = dump_validate(buf, (char *)"##: ");
        }
#line 91
        if (tmp___10) {
#line 91
          goto _L___0;
        } else {
          {
#line 91
          tmp___11 = dump_validate(buf, (char *)"###: ");
          }
#line 91
          if (tmp___11) {
            _L___0: /* CIL Label */ 
            {
#line 91
            tmp___12 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%x: ",
                              & i);
            }
#line 91
            if (tmp___12 == 1) {
              {
#line 95
              dd = (struct dump_data *)dev->aux;
#line 96
              tmp___5 = strchr((char const   *)(buf), ' ');
#line 96
              z = tmp___5 + 1;
              }
              {
#line 97
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 97
                tmp___7 = __ctype_b_loc();
                }
#line 97
                if ((int const   )*(*tmp___7 + (int )*(z + 0)) & 4096) {
                  {
#line 97
                  tmp___8 = __ctype_b_loc();
                  }
#line 97
                  if ((int const   )*(*tmp___8 + (int )*(z + 1)) & 4096) {
#line 97
                    if (! *(z + 2)) {
#line 97
                      goto _L;
                    } else
#line 97
                    if ((int )*(z + 2) == 32) {
                      _L: /* CIL Label */ 
                      {
#line 97
                      tmp___9 = sscanf((char const   */* __restrict  */)z, (char const   */* __restrict  */)"%x",
                                       & j);
                      }
#line 97
                      if (tmp___9 == 1) {
#line 97
                        if (! (j < 256)) {
#line 97
                          goto while_break___0;
                        }
                      } else {
#line 97
                        goto while_break___0;
                      }
                    } else {
#line 97
                      goto while_break___0;
                    }
                  } else {
#line 97
                    goto while_break___0;
                  }
                } else {
#line 97
                  goto while_break___0;
                }
#line 100
                if (i >= 4096) {
                  {
#line 102
                  fclose(f);
#line 103
                  (*(a->error))((char *)"dump: At most 4096 bytes of config space are supported");
                  }
                }
#line 105
                if (i >= dd->allocated) {
                  {
#line 107
                  dump_alloc_data(dev, 4096);
#line 108
                  memcpy((void */* __restrict  */)(((struct dump_data *)dev->aux)->data),
                         (void const   */* __restrict  */)(dd->data), (size_t )256);
#line 109
                  pci_mfree((void *)dd);
#line 110
                  dd = (struct dump_data *)dev->aux;
                  }
                }
#line 112
                tmp___6 = i;
#line 112
                i ++;
#line 112
                dd->data[tmp___6] = (byte )j;
#line 113
                if (i > dd->len) {
#line 114
                  dd->len = i;
                }
#line 115
                z += 2;
#line 116
                if (*z) {
#line 117
                  z ++;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 119
              if (*z) {
                {
#line 121
                fclose(f);
#line 122
                (*(a->error))((char *)"dump: Malformed line");
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  fclose(f);
  }
#line 127
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static void dump_cleanup(struct pci_access *a  __attribute__((__unused__)) ) 
{ 


  {
#line 132
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static void dump_scan(struct pci_access *a  __attribute__((__unused__)) ) 
{ 


  {
#line 137
  return;
}
}
#line 139 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static int dump_read(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  struct dump_data *dd ;
  struct pci_dev *e ;

  {
#line 143
  dd = (struct dump_data *)d->aux;
#line 143
  if (! dd) {
#line 145
    e = (d->access)->devices;
    {
#line 146
    while (1) {
      while_continue: /* CIL Label */ ;
#line 146
      if (e) {
#line 146
        if (! ((int )e->domain != (int )d->domain)) {
#line 146
          if (! ((int )e->bus != (int )d->bus)) {
#line 146
            if (! ((int )e->dev != (int )d->dev)) {
#line 146
              if (! ((int )e->func != (int )d->func)) {
#line 146
                goto while_break;
              }
            }
          }
        }
      } else {
#line 146
        goto while_break;
      }
#line 147
      e = e->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 148
    if (! e) {
#line 149
      return (0);
    }
#line 150
    dd = (struct dump_data *)e->aux;
  }
#line 152
  if (pos + len > dd->len) {
#line 153
    return (0);
  }
  {
#line 154
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(dd->data + pos),
         (size_t )len);
  }
#line 155
  return (1);
}
}
#line 158 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static int dump_write(struct pci_dev *d  __attribute__((__unused__)) , int pos  __attribute__((__unused__)) ,
                      byte *buf  __attribute__((__unused__)) , int len  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 161
  (*((d->access)->error))((char *)"Writing to dump files is not supported.");
  }
#line 162
  return (0);
}
}
#line 165 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
static void dump_cleanup_dev(struct pci_dev *d ) 
{ 


  {
#line 168
  if (d->aux) {
    {
#line 170
    pci_mfree(d->aux);
#line 171
    d->aux = (void *)0;
    }
  }
#line 173
  return;
}
}
#line 175 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/dump.c"
struct pci_methods pm_dump  = 
#line 175
     {(char *)"dump", (char *)"Reading of register dumps (set the `dump.name\' parameter)",
    & dump_config, & dump_detect, & dump_init, & dump_cleanup, & dump_scan, & pci_generic_fill_info,
    & dump_read, & dump_write, (int (*)(struct pci_dev * , int pos , byte *buf , int len ))((void *)0),
    (void (*)(struct pci_dev * ))((void *)0), & dump_cleanup_dev};
#line 43 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/internal.h"
void pci_generic_scan(struct pci_access *a ) ;
#line 45
int pci_generic_block_read(struct pci_dev *d , int pos , byte *buf , int len ) ;
#line 46
int pci_generic_block_write(struct pci_dev *d , int pos , byte *buf , int len ) ;
#line 70
struct pci_methods pm_intel_conf1 ;
#line 70
struct pci_methods pm_intel_conf2 ;
#line 38 "/usr/include/x86_64-linux-gnu/sys/io.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iopl)(int __level ) ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static unsigned char inb(unsigned short __port ) 
{ 
  unsigned char _v ;

  {
#line 47
  __asm__  volatile   ("inb %w1,%0": "=a" (_v): "Nd" (__port));
#line 48
  return (_v);
}
}
#line 60 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static unsigned short inw(unsigned short __port ) 
{ 
  unsigned short _v ;

  {
#line 65
  __asm__  volatile   ("inw %w1,%0": "=a" (_v): "Nd" (__port));
#line 66
  return (_v);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static unsigned int inl(unsigned short __port ) 
{ 
  unsigned int _v ;

  {
#line 83
  __asm__  volatile   ("inl %w1,%0": "=a" (_v): "Nd" (__port));
#line 84
  return (_v);
}
}
#line 95 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static void outb(unsigned char __value , unsigned short __port ) 
{ 


  {
#line 98
  __asm__  volatile   ("outb %b0,%w1": : "a" (__value), "Nd" (__port));
#line 99
  return;
}
}
#line 108 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static void outw(unsigned short __value , unsigned short __port ) 
{ 


  {
#line 111
  __asm__  volatile   ("outw %w0,%w1": : "a" (__value), "Nd" (__port));
#line 113
  return;
}
}
#line 122 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static void outl(unsigned int __value , unsigned short __port ) 
{ 


  {
#line 125
  __asm__  volatile   ("outl %0,%w1": : "a" (__value), "Nd" (__port));
#line 126
  return;
}
}
#line 15 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-io-linux.h"
static int intel_setup_io(struct pci_access *a  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 18
  tmp___1 = iopl(3);
  }
#line 18
  if (tmp___1 < 0) {
#line 18
    tmp___0 = 0;
  } else {
#line 18
    tmp___0 = 1;
  }
#line 18
  return (tmp___0);
}
}
#line 21 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-io-linux.h"
__inline static int intel_cleanup_io(struct pci_access *a  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 24
  iopl(3);
  }
#line 25
  return (-1);
}
}
#line 33 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static int conf12_io_enabled  =    -1;
#line 35 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static int conf12_setup_io(struct pci_access *a ) 
{ 


  {
#line 38
  if (conf12_io_enabled < 0) {
    {
#line 39
    conf12_io_enabled = intel_setup_io(a);
    }
  }
#line 40
  return (conf12_io_enabled);
}
}
#line 43 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static void conf12_init(struct pci_access *a ) 
{ 
  int tmp ;

  {
  {
#line 46
  tmp = conf12_setup_io(a);
  }
#line 46
  if (! tmp) {
    {
#line 47
    (*(a->error))((char *)"No permission to access I/O ports (you probably have to be root).");
    }
  }
#line 48
  return;
}
}
#line 50 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static void conf12_cleanup(struct pci_access *a  __attribute__((__unused__)) ) 
{ 


  {
#line 53
  if (conf12_io_enabled > 0) {
    {
#line 54
    conf12_io_enabled = intel_cleanup_io(a);
    }
  }
#line 55
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static int intel_sanity_check(struct pci_access *a , struct pci_methods *m ) 
{ 
  struct pci_dev d ;
  u16 class ;
  u16 vendor ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 73
  (*(a->debug))((char *)"...sanity check");
#line 74
  d.bus = (u8 )0;
#line 75
  d.func = (u8 )0;
#line 76
  d.dev = (u8 )0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((int )d.dev < 32)) {
#line 76
      goto while_break;
    }
    {
#line 79
    tmp = (*(m->read))(& d, 10, (byte *)(& class), (int )sizeof(class));
    }
#line 79
    if (tmp) {
#line 79
      if ((int )class == 1536) {
        {
#line 84
        (*(a->debug))((char *)"...outside the Asylum at 0/%02x/0", (int )d.dev);
        }
#line 85
        return (1);
      } else
#line 79
      if ((int )class == 768) {
        {
#line 84
        (*(a->debug))((char *)"...outside the Asylum at 0/%02x/0", (int )d.dev);
        }
#line 85
        return (1);
      } else {
#line 79
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 79
      tmp___0 = (*(m->read))(& d, 0, (byte *)(& vendor), (int )sizeof(vendor));
      }
#line 79
      if (tmp___0) {
#line 79
        if ((int )vendor == 32902) {
          {
#line 84
          (*(a->debug))((char *)"...outside the Asylum at 0/%02x/0", (int )d.dev);
          }
#line 85
          return (1);
        } else
#line 79
        if ((int )vendor == 3601) {
          {
#line 84
          (*(a->debug))((char *)"...outside the Asylum at 0/%02x/0", (int )d.dev);
          }
#line 85
          return (1);
        }
      }
    }
#line 76
    d.dev = (u8 )((int )d.dev + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  (*(a->debug))((char *)"...insane");
  }
#line 89
  return (0);
}
}
#line 98 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static int conf1_detect(struct pci_access *a ) 
{ 
  unsigned int tmp ;
  int res ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 102
  res = 0;
#line 104
  tmp___0 = conf12_setup_io(a);
  }
#line 104
  if (! tmp___0) {
    {
#line 106
    (*(a->debug))((char *)"...no I/O permission");
    }
#line 107
    return (0);
  }
  {
#line 109
  outb((unsigned char)1, (unsigned short)3323);
#line 110
  tmp = inl((unsigned short)3320);
#line 111
  outl(2147483648U, (unsigned short)3320);
#line 112
  tmp___1 = inl((unsigned short)3320);
  }
#line 112
  if (tmp___1 == 2147483648U) {
#line 113
    res = 1;
  }
  {
#line 114
  outl(tmp, (unsigned short)3320);
  }
#line 115
  if (res) {
    {
#line 116
    res = intel_sanity_check(a, & pm_intel_conf1);
    }
  }
#line 117
  return (res);
}
}
#line 120 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static int conf1_read(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int addr ;
  unsigned short tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 123
  addr = 3324 + (pos & 3);
#line 125
  if (pos >= 256) {
#line 126
    return (0);
  }
  {
#line 128
  outl(((2147483648U | (unsigned int )(((int )d->bus & 255) << 16)) | (unsigned int )(((((int )d->dev & 31) << 3) | ((int )d->func & 7)) << 8)) | (unsigned int )(pos & -4),
       (unsigned short)3320);
  }
  {
#line 132
  if (len == 1) {
#line 132
    goto case_1;
  }
#line 135
  if (len == 2) {
#line 135
    goto case_2;
  }
#line 138
  if (len == 4) {
#line 138
    goto case_4;
  }
#line 141
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 133
  *(buf + 0) = inb((unsigned short )addr);
  }
#line 134
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 136
  tmp = inw((unsigned short )addr);
#line 136
  *((u16 *)buf + 0) = tmp;
  }
#line 137
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 139
  tmp___0 = inl((unsigned short )addr);
#line 139
  *((u32 *)buf + 0) = tmp___0;
  }
#line 140
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 142
  tmp___1 = pci_generic_block_read(d, pos, buf, len);
  }
#line 142
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
#line 144
  return (1);
}
}
#line 147 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static int conf1_write(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int addr ;
  int tmp ;

  {
#line 150
  addr = 3324 + (pos & 3);
#line 152
  if (pos >= 256) {
#line 153
    return (0);
  }
  {
#line 155
  outl(((2147483648U | (unsigned int )(((int )d->bus & 255) << 16)) | (unsigned int )(((((int )d->dev & 31) << 3) | ((int )d->func & 7)) << 8)) | (unsigned int )(pos & -4),
       (unsigned short)3320);
  }
  {
#line 159
  if (len == 1) {
#line 159
    goto case_1;
  }
#line 162
  if (len == 2) {
#line 162
    goto case_2;
  }
#line 165
  if (len == 4) {
#line 165
    goto case_4;
  }
#line 168
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 160
  outb(*(buf + 0), (unsigned short )addr);
  }
#line 161
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 163
  outw(*((u16 *)buf + 0), (unsigned short )addr);
  }
#line 164
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 166
  outl(*((u32 *)buf + 0), (unsigned short )addr);
  }
#line 167
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 169
  tmp = pci_generic_block_write(d, pos, buf, len);
  }
#line 169
  return (tmp);
  switch_break: /* CIL Label */ ;
  }
#line 171
  return (1);
}
}
#line 178 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static int conf2_detect(struct pci_access *a ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
  {
#line 181
  tmp = conf12_setup_io(a);
  }
#line 181
  if (! tmp) {
    {
#line 183
    (*(a->debug))((char *)"...no I/O permission");
    }
#line 184
    return (0);
  }
  {
#line 189
  outb((unsigned char)0, (unsigned short)3323);
#line 190
  outb((unsigned char)0, (unsigned short)3320);
#line 191
  outb((unsigned char)0, (unsigned short)3322);
#line 192
  tmp___1 = inb((unsigned short)3320);
  }
#line 192
  if ((int )tmp___1 == 0) {
    {
#line 192
    tmp___2 = inb((unsigned short)3322);
    }
#line 192
    if ((int )tmp___2 == 0) {
      {
#line 193
      tmp___0 = intel_sanity_check(a, & pm_intel_conf2);
      }
#line 193
      return (tmp___0);
    } else {
#line 195
      return (0);
    }
  } else {
#line 195
    return (0);
  }
}
}
#line 198 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static int conf2_read(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int addr ;
  unsigned short tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 201
  addr = (49152 | ((int )d->dev << 8)) | pos;
#line 203
  if (pos >= 256) {
#line 204
    return (0);
  }
#line 206
  if ((int )d->dev >= 16) {
#line 208
    return (0);
  }
  {
#line 209
  outb((unsigned char )(((int )d->func << 1) | 240), (unsigned short)3320);
#line 210
  outb(d->bus, (unsigned short)3322);
  }
  {
#line 213
  if (len == 1) {
#line 213
    goto case_1;
  }
#line 216
  if (len == 2) {
#line 216
    goto case_2;
  }
#line 219
  if (len == 4) {
#line 219
    goto case_4;
  }
#line 222
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 214
  *(buf + 0) = inb((unsigned short )addr);
  }
#line 215
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 217
  tmp = inw((unsigned short )addr);
#line 217
  *((u16 *)buf + 0) = tmp;
  }
#line 218
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 220
  tmp___0 = inl((unsigned short )addr);
#line 220
  *((u32 *)buf + 0) = tmp___0;
  }
#line 221
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 223
  outb((unsigned char)0, (unsigned short)3320);
#line 224
  tmp___1 = pci_generic_block_read(d, pos, buf, len);
  }
#line 224
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 226
  outb((unsigned char)0, (unsigned short)3320);
  }
#line 227
  return (1);
}
}
#line 230 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
static int conf2_write(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int addr ;
  int tmp ;

  {
#line 233
  addr = (49152 | ((int )d->dev << 8)) | pos;
#line 235
  if (pos >= 256) {
#line 236
    return (0);
  }
#line 238
  if ((int )d->dev >= 16) {
    {
#line 239
    (*((d->access)->error))((char *)"conf2_write: only first 16 devices exist.");
    }
  }
  {
#line 240
  outb((unsigned char )(((int )d->func << 1) | 240), (unsigned short)3320);
#line 241
  outb(d->bus, (unsigned short)3322);
  }
  {
#line 244
  if (len == 1) {
#line 244
    goto case_1;
  }
#line 247
  if (len == 2) {
#line 247
    goto case_2;
  }
#line 250
  if (len == 4) {
#line 250
    goto case_4;
  }
#line 253
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 245
  outb(*(buf + 0), (unsigned short )addr);
  }
#line 246
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 248
  outw(*((u16 *)buf), (unsigned short )addr);
  }
#line 249
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 251
  outl(*((u32 *)buf), (unsigned short )addr);
  }
#line 252
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 254
  outb((unsigned char)0, (unsigned short)3320);
#line 255
  tmp = pci_generic_block_write(d, pos, buf, len);
  }
#line 255
  return (tmp);
  switch_break: /* CIL Label */ ;
  }
  {
#line 257
  outb((unsigned char)0, (unsigned short)3320);
  }
#line 258
  return (1);
}
}
#line 261 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
struct pci_methods pm_intel_conf1  = 
#line 261
     {(char *)"intel-conf1", (char *)"Raw I/O port access using Intel conf1 interface",
    (void (*)(struct pci_access * ))((void *)0), & conf1_detect, & conf12_init, & conf12_cleanup,
    & pci_generic_scan, & pci_generic_fill_info, & conf1_read, & conf1_write, (int (*)(struct pci_dev * ,
                                                                                       int pos ,
                                                                                       byte *buf ,
                                                                                       int len ))((void *)0),
    (void (*)(struct pci_dev * ))((void *)0), (void (*)(struct pci_dev * ))((void *)0)};
#line 277 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/i386-ports.c"
struct pci_methods pm_intel_conf2  = 
#line 277
     {(char *)"intel-conf2", (char *)"Raw I/O port access using Intel conf2 interface",
    (void (*)(struct pci_access * ))((void *)0), & conf2_detect, & conf12_init, & conf12_cleanup,
    & pci_generic_scan, & pci_generic_fill_info, & conf2_read, & conf2_write, (int (*)(struct pci_dev * ,
                                                                                       int pos ,
                                                                                       byte *buf ,
                                                                                       int len ))((void *)0),
    (void (*)(struct pci_dev * ))((void *)0), (void (*)(struct pci_dev * ))((void *)0)};
#line 225 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
void pci_id_cache_flush(struct pci_access *a ) ;
#line 63 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/internal.h"
int pci_set_param_internal(struct pci_access *acc , char *param , char *value , int copy ) ;
#line 47 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.h"
__inline static unsigned int pair_first(unsigned int x ) 
{ 


  {
#line 49
  return ((x >> 16) & 65535U);
}
}
#line 52 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.h"
__inline static unsigned int pair_second(unsigned int x ) 
{ 


  {
#line 54
  return (x & 65535U);
}
}
#line 57
int pci_id_insert(struct pci_access *a , int cat , int id1 , int id2 , int id3 , int id4 ,
                  char *text , enum id_entry_src src ) ;
#line 62
int pci_id_cache_load(struct pci_access *a , int flags ) ;
#line 63
void pci_id_cache_dirty(struct pci_access *a ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 22 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-cache.c"
static char const   cache_version[15]  = 
#line 22 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-cache.c"
  {      (char const   )'#',      (char const   )'P',      (char const   )'C',      (char const   )'I', 
        (char const   )'-',      (char const   )'C',      (char const   )'A',      (char const   )'C', 
        (char const   )'H',      (char const   )'E',      (char const   )'-',      (char const   )'1', 
        (char const   )'.',      (char const   )'0',      (char const   )'\000'};
#line 24 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-cache.c"
static char *get_cache_name(struct pci_access *a ) 
{ 
  char *name ;
  char *buf ;
  int tmp ;
  uid_t uid ;
  __uid_t tmp___0 ;
  struct passwd *pw ;
  struct passwd *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 28
  name = pci_get_param(a, (char *)"net.cache_name");
  }
#line 29
  if (! name) {
#line 30
    return ((char *)((void *)0));
  } else
#line 29
  if (! *(name + 0)) {
#line 30
    return ((char *)((void *)0));
  }
  {
#line 31
  tmp = strncmp((char const   *)name, "~/", (size_t )2);
  }
#line 31
  if (tmp) {
#line 32
    return (name);
  }
  {
#line 34
  tmp___0 = getuid();
#line 34
  uid = tmp___0;
#line 35
  tmp___1 = getpwuid(uid);
#line 35
  pw = tmp___1;
  }
#line 36
  if (! pw) {
#line 37
    return (name);
  }
  {
#line 39
  tmp___2 = strlen((char const   *)pw->pw_dir);
#line 39
  tmp___3 = strlen((char const   *)(name + 1));
#line 39
  tmp___4 = pci_malloc(a, (int )((tmp___2 + tmp___3) + 1UL));
#line 39
  buf = (char *)tmp___4;
#line 40
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s%s", pw->pw_dir,
          name + 1);
#line 41
  pci_set_param_internal(a, (char *)"net.cache_name", buf, 0);
  }
#line 42
  return (buf);
}
}
#line 45 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-cache.c"
int pci_id_cache_load(struct pci_access *a , int flags ) 
{ 
  char *name ;
  char line[1024] ;
  FILE *f ;
  int lino ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  int cat ;
  int id1 ;
  int id2 ;
  int id3 ;
  int id4 ;
  int cnt ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 53
  a->id_cache_status = 1;
#line 54
  name = get_cache_name(a);
  }
#line 55
  if (! name) {
#line 56
    return (0);
  }
  {
#line 57
  (*(a->debug))((char *)"Using cache %s\n", name);
  }
#line 58
  if (flags & 4194304) {
    {
#line 60
    (*(a->debug))((char *)"Not loading cache, will refresh everything\n");
#line 61
    a->id_cache_status = 2;
    }
#line 62
    return (0);
  }
  {
#line 65
  f = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
  }
#line 66
  if (! f) {
    {
#line 68
    (*(a->debug))((char *)"Cache file does not exist\n");
    }
#line 69
    return (0);
  }
#line 73
  lino = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    tmp___2 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)f);
    }
#line 74
    if (! tmp___2) {
#line 74
      goto while_break;
    }
    {
#line 76
    tmp = strchr((char const   *)(line), '\n');
#line 76
    p = tmp;
#line 77
    lino ++;
    }
#line 78
    if (p) {
#line 80
      *p = (char)0;
#line 81
      if (lino == 1) {
        {
#line 83
        tmp___0 = strcmp((char const   *)(line), cache_version);
        }
#line 83
        if (tmp___0) {
          {
#line 85
          (*(a->debug))((char *)"Unrecognized cache version %s, ignoring\n", line);
          }
#line 86
          goto while_break;
        }
#line 88
        goto while_continue;
      } else {
        {
#line 93
        tmp___1 = sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%d%x%x%x%x%n",
                         & cat, & id1, & id2, & id3, & id4, & cnt);
        }
#line 93
        if (tmp___1 >= 5) {
#line 95
          p = line + cnt;
          {
#line 96
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 96
            if (*p) {
#line 96
              if (! ((int )*p == 32)) {
#line 96
                goto while_break___0;
              }
            } else {
#line 96
              goto while_break___0;
            }
#line 97
            p ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 98
          pci_id_insert(a, cat, id1, id2, id3, id4, p, (enum id_entry_src )1);
          }
#line 99
          goto while_continue;
        }
      }
    }
    {
#line 103
    (*(a->warning))((char *)"Malformed cache file %s (line %d), ignoring", name, lino);
    }
#line 104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  tmp___3 = ferror(f);
  }
#line 107
  if (tmp___3) {
    {
#line 108
    (*(a->warning))((char *)"Error while reading %s", name);
    }
  }
  {
#line 109
  fclose(f);
  }
#line 110
  return (1);
}
}
#line 113 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-cache.c"
void pci_id_cache_flush(struct pci_access *a ) 
{ 
  int orig_status ;
  FILE *f ;
  unsigned int h ;
  struct id_entry *e ;
  struct id_entry *e2 ;
  char hostname[256] ;
  char *tmpname ;
  char *name ;
  int this_pid ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 116
  orig_status = a->id_cache_status;
#line 123
  a->id_cache_status = 0;
#line 124
  if (orig_status < 2) {
#line 125
    return;
  }
  {
#line 126
  name = get_cache_name(a);
  }
#line 127
  if (! name) {
#line 128
    return;
  }
  {
#line 130
  this_pid = getpid();
#line 131
  tmp = gethostname(hostname, sizeof(hostname));
  }
#line 131
  if (tmp < 0) {
#line 132
    hostname[0] = (char)0;
  } else {
#line 134
    hostname[sizeof(hostname) - 1UL] = (char)0;
  }
  {
#line 135
  tmp___0 = strlen((char const   *)name);
#line 135
  tmp___1 = strlen((char const   *)(hostname));
#line 135
  tmp___2 = pci_malloc(a, (int )((tmp___0 + tmp___1) + 64UL));
#line 135
  tmpname = (char *)tmp___2;
#line 136
  sprintf((char */* __restrict  */)tmpname, (char const   */* __restrict  */)"%s.tmp-%s-%d",
          name, hostname, this_pid);
#line 138
  f = fopen((char const   */* __restrict  */)tmpname, (char const   */* __restrict  */)"wb");
  }
#line 139
  if (! f) {
    {
#line 141
    tmp___3 = __errno_location();
#line 141
    tmp___4 = strerror(*tmp___3);
#line 141
    (*(a->warning))((char *)"Cannot write to %s: %s", name, tmp___4);
#line 142
    pci_mfree((void *)tmpname);
    }
#line 143
    return;
  }
  {
#line 145
  (*(a->debug))((char *)"Writing cache to %s\n", name);
#line 146
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n", cache_version);
#line 148
  h = 0U;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (h < 4099U)) {
#line 148
      goto while_break;
    }
#line 149
    e = *(a->id_hash + h);
    {
#line 149
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 149
      if (! e) {
#line 149
        goto while_break___0;
      }
#line 150
      if ((int )e->src == 1) {
#line 150
        goto _L___0;
      } else
#line 150
      if ((int )e->src == 2) {
        _L___0: /* CIL Label */ 
#line 153
        if (! e->name[0]) {
#line 154
          goto __Cont;
        }
#line 157
        e2 = *(a->id_hash + h);
        {
#line 157
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 157
          if (! ((unsigned long )e2 != (unsigned long )e)) {
#line 157
            goto while_break___1;
          }
#line 158
          if ((int )e2->src == 1) {
#line 158
            goto _L;
          } else
#line 158
          if ((int )e2->src == 2) {
            _L: /* CIL Label */ 
#line 158
            if ((int )e2->cat == (int )e->cat) {
#line 158
              if (e2->id12 == e->id12) {
#line 158
                if (e2->id34 == e->id34) {
#line 161
                  goto while_break___1;
                }
              }
            }
          }
#line 157
          e2 = e2->next;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 162
        if ((unsigned long )e2 == (unsigned long )e) {
          {
#line 163
          tmp___5 = pair_second(e->id34);
#line 163
          tmp___6 = pair_first(e->id34);
#line 163
          tmp___7 = pair_second(e->id12);
#line 163
          tmp___8 = pair_first(e->id12);
#line 163
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d %x %x %x %x %s\n",
                  (int )e->cat, tmp___8, tmp___7, tmp___6, tmp___5, e->name);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 149
      e = e->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 148
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  fflush(f);
#line 171
  tmp___9 = ferror(f);
  }
#line 171
  if (tmp___9) {
    {
#line 172
    (*(a->warning))((char *)"Error writing %s", name);
    }
  }
  {
#line 173
  fclose(f);
#line 175
  tmp___12 = rename((char const   *)tmpname, (char const   *)name);
  }
#line 175
  if (tmp___12 < 0) {
    {
#line 177
    tmp___10 = __errno_location();
#line 177
    tmp___11 = strerror(*tmp___10);
#line 177
    (*(a->warning))((char *)"Cannot rename %s to %s: %s", tmpname, name, tmp___11);
#line 178
    unlink((char const   *)tmpname);
    }
  }
  {
#line 180
  pci_mfree((void *)tmpname);
  }
#line 181
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-cache.c"
void pci_id_cache_dirty(struct pci_access *a ) 
{ 


  {
#line 201
  if (a->id_cache_status >= 1) {
#line 202
    a->id_cache_status = 2;
  }
#line 203
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 83 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
struct pci_access *pci_alloc(void) ;
#line 84
void pci_init(struct pci_access *a ) ;
#line 85
void pci_cleanup(struct pci_access *a ) ;
#line 90
void pci_free_dev(struct pci_dev *d ) ;
#line 93
int pci_lookup_method(char *name ) ;
#line 94
char *pci_get_method_name(int index___0 ) ;
#line 223
void pci_free_name_list(struct pci_access *a ) ;
#line 224
void pci_set_name_list_path(struct pci_access *a , char *name , int to_be_freed ) ;
#line 51 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/internal.h"
char *pci_strdup(struct pci_access *a , char *s ) ;
#line 64
void pci_free_params(struct pci_access *acc ) ;
#line 70
struct pci_methods pm_linux_proc ;
#line 70
struct pci_methods pm_linux_sysfs ;
#line 16 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
static struct pci_methods *pci_methods[10]  = 
#line 16 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
  {      (struct pci_methods *)((void *)0),      & pm_linux_sysfs,      & pm_linux_proc,      & pm_intel_conf1, 
        & pm_intel_conf2,      (struct pci_methods *)((void *)0),      (struct pci_methods *)((void *)0),      (struct pci_methods *)((void *)0), 
        (struct pci_methods *)((void *)0),      & pm_dump};
#line 62 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
void *pci_malloc(struct pci_access *a , int size ) 
{ 
  void *x ;
  void *tmp ;

  {
  {
#line 65
  tmp = malloc((size_t )size);
#line 65
  x = tmp;
  }
#line 67
  if (! x) {
    {
#line 68
    (*(a->error))((char *)"Out of memory (allocation of %d bytes failed)", size);
    }
  }
#line 69
  return (x);
}
}
#line 72 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
void pci_mfree(void *x ) 
{ 


  {
#line 75
  if (x) {
    {
#line 76
    free(x);
    }
  }
#line 77
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
char *pci_strdup(struct pci_access *a , char *s ) 
{ 
  int len ;
  size_t tmp ;
  char *t ;
  void *tmp___0 ;

  {
  {
#line 82
  tmp = strlen((char const   *)s);
#line 82
  len = (int )(tmp + 1UL);
#line 83
  tmp___0 = pci_malloc(a, len);
#line 83
  t = (char *)tmp___0;
#line 84
  memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)s, (size_t )len);
  }
#line 85
  return (t);
}
}
#line 88 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
static void pci_generic_error(char *msg  , ...) 
{ 
  va_list args ;

  {
  {
#line 93
  __builtin_va_start(args, msg);
#line 94
  fputs((char const   */* __restrict  */)"pcilib: ", (FILE */* __restrict  */)stderr);
#line 95
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           args);
#line 96
  fputc('\n', stderr);
#line 97
  exit(1);
  }
}
}
#line 100 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
static void pci_generic_warn(char *msg  , ...) 
{ 
  va_list args ;

  {
  {
#line 105
  __builtin_va_start(args, msg);
#line 106
  fputs((char const   */* __restrict  */)"pcilib: ", (FILE */* __restrict  */)stderr);
#line 107
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           args);
#line 108
  fputc('\n', stderr);
  }
#line 109
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
static void pci_generic_debug(char *msg  , ...) 
{ 
  va_list args ;

  {
  {
#line 116
  __builtin_va_start(args, msg);
#line 117
  vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)msg,
           args);
#line 118
  __builtin_va_end(args);
  }
#line 119
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
static void pci_null_debug(char *msg  __attribute__((__unused__))  , ...) 
{ 


  {
#line 124
  return;
}
}
#line 126 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
int pci_lookup_method(char *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < 10)) {
#line 131
      goto while_break;
    }
#line 132
    if (pci_methods[i]) {
      {
#line 132
      tmp = strcmp((char const   *)(pci_methods[i])->name, (char const   *)name);
      }
#line 132
      if (! tmp) {
#line 133
        return (i);
      }
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (-1);
}
}
#line 137 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
char *pci_get_method_name(int index___0 ) 
{ 


  {
#line 140
  if (index___0 < 0) {
#line 141
    return ((char *)((void *)0));
  } else
#line 140
  if (index___0 >= 10) {
#line 141
    return ((char *)((void *)0));
  } else
#line 142
  if (! pci_methods[index___0]) {
#line 143
    return ((char *)"");
  } else {
#line 145
    return ((pci_methods[index___0])->name);
  }
}
}
#line 148 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
struct pci_access *pci_alloc(void) 
{ 
  struct pci_access *a ;
  void *tmp ;
  int i ;

  {
  {
#line 151
  tmp = malloc(sizeof(struct pci_access ));
#line 151
  a = (struct pci_access *)tmp;
#line 154
  memset((void *)a, 0, sizeof(*a));
#line 155
  pci_set_name_list_path(a, (char *)"/usr/local/share/pci.ids", 0);
#line 157
  pci_define_param(a, (char *)"net.domain", (char *)"pci.id.ucw.cz", (char *)"DNS domain used for resolving of ID\'s");
#line 158
  pci_define_param(a, (char *)"net.cache_name", (char *)"~/.pciids-cache", (char *)"Name of the ID cache file");
#line 159
  a->id_lookup_mode = 2097152U;
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < 10)) {
#line 161
      goto while_break;
    }
#line 162
    if (pci_methods[i]) {
#line 162
      if ((pci_methods[i])->config) {
        {
#line 163
        (*((pci_methods[i])->config))(a);
        }
      }
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return (a);
}
}
#line 167 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
void pci_init(struct pci_access *a ) 
{ 
  unsigned int i ;
  int tmp ;

  {
#line 170
  if (! a->error) {
#line 171
    a->error = (void ( /* format attribute */  (*))(char *msg  , ...))(& pci_generic_error);
  }
#line 172
  if (! a->warning) {
#line 173
    a->warning = (void ( /* format attribute */  (*))(char *msg  , ...))(& pci_generic_warn);
  }
#line 174
  if (! a->debug) {
#line 175
    a->debug = (void ( /* format attribute */  (*))(char *msg  , ...))(& pci_generic_debug);
  }
#line 176
  if (! a->debugging) {
#line 177
    a->debug = (void ( /* format attribute */  (*))(char *msg  , ...))(& pci_null_debug);
  }
#line 179
  if (a->method) {
#line 181
    if (a->method >= 10U) {
      {
#line 182
      (*(a->error))((char *)"This access method is not supported.");
      }
    } else
#line 181
    if (! pci_methods[a->method]) {
      {
#line 182
      (*(a->error))((char *)"This access method is not supported.");
      }
    }
#line 183
    a->methods = pci_methods[a->method];
  } else {
#line 188
    i = 0U;
    {
#line 188
    while (1) {
      while_continue: /* CIL Label */ ;
#line 188
      if (! (i < 10U)) {
#line 188
        goto while_break;
      }
#line 189
      if (pci_methods[i]) {
        {
#line 191
        (*(a->debug))((char *)"Trying method %d...", i);
#line 192
        tmp = (*((pci_methods[i])->detect))(a);
        }
#line 192
        if (tmp) {
          {
#line 194
          (*(a->debug))((char *)"...OK\n");
#line 195
          a->methods = pci_methods[i];
#line 196
          a->method = i;
          }
#line 197
          goto while_break;
        }
        {
#line 199
        (*(a->debug))((char *)"...No.\n");
        }
      }
#line 188
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 201
    if (! a->methods) {
      {
#line 202
      (*(a->error))((char *)"Cannot find any working access method.");
      }
    }
  }
  {
#line 204
  (*(a->debug))((char *)"Decided to use %s\n", (a->methods)->name);
#line 205
  (*((a->methods)->init))(a);
  }
#line 206
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/init.c"
void pci_cleanup(struct pci_access *a ) 
{ 
  struct pci_dev *d ;
  struct pci_dev *e ;

  {
#line 213
  d = a->devices;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! d) {
#line 213
      goto while_break;
    }
    {
#line 215
    e = d->next;
#line 216
    pci_free_dev(d);
#line 213
    d = e;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if (a->methods) {
    {
#line 219
    (*((a->methods)->cleanup))(a);
    }
  }
  {
#line 220
  pci_free_name_list(a);
#line 221
  pci_free_params(a);
#line 222
  pci_set_name_list_path(a, (char *)((void *)0), 0);
#line 223
  pci_mfree((void *)a);
  }
#line 224
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 376
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 54 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/internal.h"
struct pci_dev *pci_alloc_dev(struct pci_access *a ) ;
#line 25 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static void sysfs_config(struct pci_access *a ) 
{ 


  {
  {
#line 28
  pci_define_param(a, (char *)"sysfs.path", (char *)"/sys/bus/pci", (char *)"Path to the sysfs device tree");
  }
#line 29
  return;
}
}
#line 31 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
__inline static char *sysfs_name(struct pci_access *a ) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = pci_get_param(a, (char *)"sysfs.path");
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static int sysfs_detect(struct pci_access *a ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 40
  tmp___0 = sysfs_name(a);
#line 40
  tmp___1 = access((char const   *)tmp___0, 4);
  }
#line 40
  if (tmp___1) {
    {
#line 42
    tmp = sysfs_name(a);
#line 42
    (*(a->debug))((char *)"...cannot open %s", tmp);
    }
#line 43
    return (0);
  }
  {
#line 45
  tmp___2 = sysfs_name(a);
#line 45
  (*(a->debug))((char *)"...using %s", tmp___2);
  }
#line 46
  return (1);
}
}
#line 49 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static void sysfs_init(struct pci_access *a ) 
{ 


  {
#line 52
  a->fd = -1;
#line 53
  a->fd_vpd = -1;
#line 54
  return;
}
}
#line 56 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static void sysfs_flush_cache(struct pci_access *a ) 
{ 


  {
#line 59
  if (a->fd >= 0) {
    {
#line 61
    close(a->fd);
#line 62
    a->fd = -1;
    }
  }
#line 64
  if (a->fd_vpd >= 0) {
    {
#line 66
    close(a->fd_vpd);
#line 67
    a->fd_vpd = -1;
    }
  }
#line 69
  a->cached_dev = (struct pci_dev *)((void *)0);
#line 70
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static void sysfs_cleanup(struct pci_access *a ) 
{ 


  {
  {
#line 75
  sysfs_flush_cache(a);
  }
#line 76
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static void sysfs_obj_name(struct pci_dev *d , char *object , char *buf ) 
{ 
  int n ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 82
  tmp = sysfs_name(d->access);
#line 82
  tmp___0 = snprintf((char */* __restrict  */)buf, (size_t )1024, (char const   */* __restrict  */)"%s/devices/%04x:%02x:%02x.%d/%s",
                     tmp, (int )d->domain, (int )d->bus, (int )d->dev, (int )d->func,
                     object);
#line 82
  n = tmp___0;
  }
#line 84
  if (n < 0) {
    {
#line 85
    (*((d->access)->error))((char *)"File name too long");
    }
  } else
#line 84
  if (n >= 1024) {
    {
#line 85
    (*((d->access)->error))((char *)"File name too long");
    }
  }
#line 86
  return;
}
}
#line 90 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static int sysfs_get_string(struct pci_dev *d , char *object , char *buf , int mandatory ) 
{ 
  struct pci_access *a ;
  int fd ;
  int n ;
  char namebuf[1024] ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 93
  a = d->access;
#line 97
  sysfs_obj_name(d, object, namebuf);
#line 98
  fd = open((char const   *)(namebuf), 0);
  }
#line 99
  if (fd < 0) {
#line 101
    if (mandatory) {
      {
#line 102
      tmp = __errno_location();
#line 102
      tmp___0 = strerror(*tmp);
#line 102
      (*(a->error))((char *)"Cannot open %s: %s", namebuf, tmp___0);
      }
    }
#line 103
    return (0);
  }
  {
#line 105
  tmp___1 = read(fd, (void *)buf, (size_t )1024);
#line 105
  n = (int )tmp___1;
#line 106
  close(fd);
  }
#line 107
  if (n < 0) {
    {
#line 108
    tmp___2 = __errno_location();
#line 108
    tmp___3 = strerror(*tmp___2);
#line 108
    (*(a->error))((char *)"Error reading %s: %s", namebuf, tmp___3);
    }
  }
#line 109
  if (n >= 1024) {
    {
#line 110
    (*(a->error))((char *)"Value in %s too long", namebuf);
    }
  }
#line 111
  *(buf + n) = (char)0;
#line 112
  return (1);
}
}
#line 115 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static int sysfs_get_value(struct pci_dev *d , char *object ) 
{ 
  char buf[1024] ;
  long tmp ;

  {
  {
#line 120
  sysfs_get_string(d, object, buf, 1);
#line 121
  tmp = strtol((char const   */* __restrict  */)(buf), (char **/* __restrict  */)((void *)0),
               0);
  }
#line 121
  return ((int )tmp);
}
}
#line 124 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static void sysfs_get_resources(struct pci_dev *d ) 
{ 
  struct pci_access *a ;
  char namebuf[1024] ;
  char buf[256] ;
  FILE *file ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  unsigned long long start ;
  unsigned long long end ;
  unsigned long long size ;
  unsigned long long flags ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 127
  a = d->access;
#line 132
  sysfs_obj_name(d, (char *)"resource", namebuf);
#line 133
  file = fopen((char const   */* __restrict  */)(namebuf), (char const   */* __restrict  */)"r");
  }
#line 134
  if (! file) {
    {
#line 135
    tmp = __errno_location();
#line 135
    tmp___0 = strerror(*tmp);
#line 135
    (*(a->error))((char *)"Cannot open %s: %s", namebuf, tmp___0);
    }
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < 7)) {
#line 136
      goto while_break;
    }
    {
#line 139
    tmp___1 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 139
    if (! tmp___1) {
#line 140
      goto while_break;
    }
    {
#line 141
    tmp___2 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%llx %llx %llx",
                     & start, & end, & flags);
    }
#line 141
    if (tmp___2 != 3) {
      {
#line 142
      (*(a->error))((char *)"Syntax error in %s", namebuf);
      }
    }
#line 143
    if (end > start) {
#line 144
      size = (end - start) + 1ULL;
    } else {
#line 146
      size = 0ULL;
    }
#line 147
    flags &= 15ULL;
#line 148
    if (i < 6) {
#line 150
      d->base_addr[i] = (pciaddr_t )(start | flags);
#line 151
      d->size[i] = (pciaddr_t )size;
    } else {
#line 155
      d->rom_base_addr = (pciaddr_t )(start | flags);
#line 156
      d->rom_size = (pciaddr_t )size;
    }
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  fclose(file);
  }
#line 160
  return;
}
}
#line 162 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static void sysfs_scan(struct pci_access *a ) 
{ 
  char dirname[1024] ;
  DIR *dir ;
  struct dirent *entry ;
  int n ;
  char *tmp ;
  struct pci_dev *d ;
  unsigned int dom ;
  unsigned int bus ;
  unsigned int dev ;
  unsigned int func ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 169
  tmp = sysfs_name(a);
#line 169
  n = snprintf((char */* __restrict  */)(dirname), sizeof(dirname), (char const   */* __restrict  */)"%s/devices",
               tmp);
  }
#line 170
  if (n < 0) {
    {
#line 171
    (*(a->error))((char *)"Directory name too long");
    }
  } else
#line 170
  if (n >= (int )sizeof(dirname)) {
    {
#line 171
    (*(a->error))((char *)"Directory name too long");
    }
  }
  {
#line 172
  dir = opendir((char const   *)(dirname));
  }
#line 173
  if (! dir) {
    {
#line 174
    (*(a->error))((char *)"Cannot open %s", dirname);
    }
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 175
    entry = readdir(dir);
    }
#line 175
    if (! entry) {
#line 175
      goto while_break;
    }
#line 181
    if ((int )entry->d_name[0] == 46) {
#line 182
      goto while_continue;
    }
    {
#line 184
    d = pci_alloc_dev(a);
#line 185
    tmp___0 = sscanf((char const   */* __restrict  */)(entry->d_name), (char const   */* __restrict  */)"%x:%x:%x.%d",
                     & dom, & bus, & dev, & func);
    }
#line 185
    if (tmp___0 < 4) {
      {
#line 186
      (*(a->error))((char *)"sysfs_scan: Couldn\'t parse entry name %s", entry->d_name);
      }
    }
#line 187
    d->domain = (u16 )dom;
#line 188
    d->bus = (u8 )bus;
#line 189
    d->dev = (u8 )dev;
#line 190
    d->func = (u8 )func;
#line 191
    if (! a->buscentric) {
      {
#line 193
      sysfs_get_resources(d);
#line 194
      d->irq = sysfs_get_value(d, (char *)"irq");
#line 199
      tmp___1 = sysfs_get_value(d, (char *)"vendor");
#line 199
      d->vendor_id = (u16 )tmp___1;
#line 200
      tmp___2 = sysfs_get_value(d, (char *)"device");
#line 200
      d->device_id = (u16 )tmp___2;
#line 201
      tmp___3 = sysfs_get_value(d, (char *)"class");
#line 201
      d->device_class = (u16 )(tmp___3 >> 8);
#line 202
      d->known_fields = 63;
      }
    }
    {
#line 204
    pci_link_dev(a, d);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  closedir(dir);
  }
#line 207
  return;
}
}
#line 209 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static void sysfs_fill_slots(struct pci_access *a ) 
{ 
  char dirname[1024] ;
  DIR *dir ;
  struct dirent *entry ;
  int n ;
  char *tmp ;
  char namebuf[1024] ;
  char buf[16] ;
  FILE *file ;
  unsigned int dom ;
  unsigned int bus ;
  unsigned int dev ;
  int res ;
  struct pci_dev *d ;
  char *tmp___0 ;

  {
  {
#line 217
  tmp = sysfs_name(a);
#line 217
  n = snprintf((char */* __restrict  */)(dirname), sizeof(dirname), (char const   */* __restrict  */)"%s/slots",
               tmp);
  }
#line 218
  if (n < 0) {
    {
#line 219
    (*(a->error))((char *)"Directory name too long");
    }
  } else
#line 218
  if (n >= (int )sizeof(dirname)) {
    {
#line 219
    (*(a->error))((char *)"Directory name too long");
    }
  }
  {
#line 220
  dir = opendir((char const   *)(dirname));
  }
#line 221
  if (! dir) {
#line 222
    return;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 224
    entry = readdir(dir);
    }
#line 224
    if (! entry) {
#line 224
      goto while_break;
    }
#line 229
    res = 0;
#line 233
    if ((int )entry->d_name[0] == 46) {
#line 234
      goto while_continue;
    }
    {
#line 236
    n = snprintf((char */* __restrict  */)(namebuf), (size_t )1024, (char const   */* __restrict  */)"%s/%s/%s",
                 dirname, entry->d_name, "address");
    }
#line 237
    if (n < 0) {
      {
#line 238
      (*(a->error))((char *)"File name too long");
      }
    } else
#line 237
    if (n >= 1024) {
      {
#line 238
      (*(a->error))((char *)"File name too long");
      }
    }
    {
#line 239
    file = fopen((char const   */* __restrict  */)(namebuf), (char const   */* __restrict  */)"r");
    }
#line 245
    if (! file) {
#line 246
      goto while_continue;
    }
    {
#line 248
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 248
    if (tmp___0) {
      {
#line 248
      res = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%x:%x:%x",
                   & dom, & bus, & dev);
      }
#line 248
      if (res < 3) {
        _L: /* CIL Label */ 
#line 255
        if (res != 2) {
          {
#line 256
          (*(a->warning))((char *)"sysfs_fill_slots: Couldn\'t parse entry address %s",
                          buf);
          }
        }
      } else {
#line 260
        d = a->devices;
        {
#line 260
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 260
          if (! d) {
#line 260
            goto while_break___0;
          }
#line 261
          if (dom == (unsigned int )d->domain) {
#line 261
            if (bus == (unsigned int )d->bus) {
#line 261
              if (dev == (unsigned int )d->dev) {
#line 261
                if (! d->phy_slot) {
                  {
#line 262
                  d->phy_slot = pci_strdup(a, entry->d_name);
                  }
                }
              }
            }
          }
#line 260
          d = d->next;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
#line 248
      goto _L;
    }
    {
#line 264
    fclose(file);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  closedir(dir);
  }
#line 267
  return;
}
}
#line 269 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static int sysfs_fill_info(struct pci_dev *d , int flags ) 
{ 
  struct pci_dev *pd ;
  char buf[1024] ;
  int tmp ;
  int tmp___0 ;

  {
#line 272
  if (flags & 256) {
#line 272
    if (! (d->known_fields & 256)) {
      {
#line 275
      sysfs_fill_slots(d->access);
#line 276
      pd = (d->access)->devices;
      }
      {
#line 276
      while (1) {
        while_continue: /* CIL Label */ ;
#line 276
        if (! pd) {
#line 276
          goto while_break;
        }
#line 277
        pd->known_fields |= 256;
#line 276
        pd = pd->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 280
  if (flags & 512) {
#line 280
    if (! (d->known_fields & 512)) {
      {
#line 283
      tmp = sysfs_get_string(d, (char *)"modalias", buf, 0);
      }
#line 283
      if (tmp) {
        {
#line 284
        d->module_alias = pci_strdup(d->access, buf);
        }
      }
    }
  }
  {
#line 287
  tmp___0 = pci_generic_fill_info(d, flags);
  }
#line 287
  return (tmp___0);
}
}
#line 298 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static int sysfs_setup(struct pci_dev *d , int intent ) 
{ 
  struct pci_access *a ;
  char namebuf[1024] ;
  int tmp ;
  int tmp___0 ;

  {
#line 301
  a = d->access;
#line 304
  if ((unsigned long )a->cached_dev != (unsigned long )d) {
    {
#line 306
    sysfs_flush_cache(a);
#line 307
    a->cached_dev = d;
    }
  } else
#line 304
  if (intent == 1) {
#line 304
    if (! a->fd_rw) {
      {
#line 306
      sysfs_flush_cache(a);
#line 307
      a->cached_dev = d;
      }
    }
  }
#line 310
  if (intent == 2) {
#line 312
    if (a->fd_vpd < 0) {
      {
#line 314
      sysfs_obj_name(d, (char *)"vpd", namebuf);
#line 315
      a->fd_vpd = open((char const   *)(namebuf), 0);
      }
    }
#line 318
    return (a->fd_vpd);
  }
#line 321
  if (a->fd < 0) {
    {
#line 323
    sysfs_obj_name(d, (char *)"config", namebuf);
    }
#line 324
    if (a->writeable) {
#line 324
      tmp = 1;
    } else
#line 324
    if (intent == 1) {
#line 324
      tmp = 1;
    } else {
#line 324
      tmp = 0;
    }
#line 324
    a->fd_rw = tmp;
#line 325
    if (a->fd_rw) {
#line 325
      tmp___0 = 2;
    } else {
#line 325
      tmp___0 = 0;
    }
    {
#line 325
    a->fd = open((char const   *)(namebuf), tmp___0);
    }
#line 326
    if (a->fd < 0) {
      {
#line 327
      (*(a->warning))((char *)"Cannot open %s", namebuf);
      }
    }
#line 328
    a->fd_pos = 0;
  }
#line 330
  return (a->fd);
}
}
#line 333 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static int sysfs_read(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int fd ;
  int tmp ;
  int res ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 335
  tmp = sysfs_setup(d, 0);
#line 335
  fd = tmp;
  }
#line 338
  if (fd < 0) {
#line 339
    return (0);
  }
  {
#line 340
  tmp___0 = pread(fd, (void *)buf, (size_t )len, (__off_t )pos);
#line 340
  res = (int )tmp___0;
  }
#line 341
  if (res < 0) {
    {
#line 343
    tmp___1 = __errno_location();
#line 343
    tmp___2 = strerror(*tmp___1);
#line 343
    (*((d->access)->warning))((char *)"sysfs_read: read failed: %s", tmp___2);
    }
#line 344
    return (0);
  } else
#line 346
  if (res != len) {
#line 347
    return (0);
  }
#line 348
  return (1);
}
}
#line 351 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static int sysfs_write(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int fd ;
  int tmp ;
  int res ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 353
  tmp = sysfs_setup(d, 1);
#line 353
  fd = tmp;
  }
#line 356
  if (fd < 0) {
#line 357
    return (0);
  }
  {
#line 358
  tmp___0 = pwrite(fd, (void const   *)buf, (size_t )len, (__off_t )pos);
#line 358
  res = (int )tmp___0;
  }
#line 359
  if (res < 0) {
    {
#line 361
    tmp___1 = __errno_location();
#line 361
    tmp___2 = strerror(*tmp___1);
#line 361
    (*((d->access)->warning))((char *)"sysfs_write: write failed: %s", tmp___2);
    }
#line 362
    return (0);
  } else
#line 364
  if (res != len) {
    {
#line 366
    (*((d->access)->warning))((char *)"sysfs_write: tried to write %d bytes at %d, but only %d succeeded",
                              len, pos, res);
    }
#line 367
    return (0);
  }
#line 369
  return (1);
}
}
#line 383 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static int sysfs_read_vpd(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int fd ;
  int tmp ;
  int res ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 385
  tmp = sysfs_setup(d, 2);
#line 385
  fd = tmp;
  }
#line 388
  if (fd < 0) {
#line 389
    return (0);
  }
  {
#line 390
  tmp___0 = pread(fd, (void *)buf, (size_t )len, (__off_t )pos);
#line 390
  res = (int )tmp___0;
  }
#line 391
  if (res < 0) {
    {
#line 393
    tmp___1 = __errno_location();
#line 393
    tmp___2 = strerror(*tmp___1);
#line 393
    (*((d->access)->warning))((char *)"sysfs_read_vpd: read failed: %s", tmp___2);
    }
#line 394
    return (0);
  } else
#line 396
  if (res != len) {
#line 397
    return (0);
  }
#line 398
  return (1);
}
}
#line 403 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
static void sysfs_cleanup_dev(struct pci_dev *d ) 
{ 
  struct pci_access *a ;

  {
#line 405
  a = d->access;
#line 407
  if ((unsigned long )a->cached_dev == (unsigned long )d) {
    {
#line 408
    sysfs_flush_cache(a);
    }
  }
#line 409
  return;
}
}
#line 411 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/sysfs.c"
struct pci_methods pm_linux_sysfs  = 
#line 411
     {(char *)"linux-sysfs", (char *)"The sys filesystem on Linux", & sysfs_config,
    & sysfs_detect, & sysfs_init, & sysfs_cleanup, & sysfs_scan, & sysfs_fill_info,
    & sysfs_read, & sysfs_write, & sysfs_read_vpd, (void (*)(struct pci_dev * ))((void *)0),
    & sysfs_cleanup_dev};
#line 21 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
static void proc_config(struct pci_access *a ) 
{ 


  {
  {
#line 24
  pci_define_param(a, (char *)"proc.path", (char *)"/proc/bus/pci", (char *)"Path to the procfs bus tree");
  }
#line 25
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
static int proc_detect(struct pci_access *a ) 
{ 
  char *name ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 30
  tmp = pci_get_param(a, (char *)"proc.path");
#line 30
  name = tmp;
#line 32
  tmp___0 = access((char const   *)name, 4);
  }
#line 32
  if (tmp___0) {
    {
#line 34
    (*(a->warning))((char *)"Cannot open %s", name);
    }
#line 35
    return (0);
  }
  {
#line 37
  (*(a->debug))((char *)"...using %s", name);
  }
#line 38
  return (1);
}
}
#line 41 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
static void proc_init(struct pci_access *a ) 
{ 


  {
#line 44
  a->fd = -1;
#line 45
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
static void proc_cleanup(struct pci_access *a ) 
{ 


  {
#line 50
  if (a->fd >= 0) {
    {
#line 52
    close(a->fd);
#line 53
    a->fd = -1;
    }
  }
#line 55
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
static void proc_scan(struct pci_access *a ) 
{ 
  FILE *f ;
  char buf[512] ;
  char *tmp ;
  int tmp___0 ;
  struct pci_dev *d ;
  struct pci_dev *tmp___1 ;
  unsigned int dfn ;
  unsigned int vend ;
  unsigned int cnt ;
  unsigned int known ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 63
  tmp = pci_get_param(a, (char *)"proc.path");
#line 63
  tmp___0 = snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/devices",
                     tmp);
  }
#line 63
  if ((unsigned long )tmp___0 == sizeof(buf)) {
    {
#line 64
    (*(a->error))((char *)"File name too long");
    }
  }
  {
#line 65
  f = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
  }
#line 66
  if (! f) {
    {
#line 67
    (*(a->error))((char *)"Cannot open %s", buf);
    }
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    tmp___3 = fgets((char */* __restrict  */)(buf), (int )(sizeof(buf) - 1UL), (FILE */* __restrict  */)f);
    }
#line 68
    if (! tmp___3) {
#line 68
      goto while_break;
    }
    {
#line 70
    tmp___1 = pci_alloc_dev(a);
#line 70
    d = tmp___1;
#line 74
    tmp___2 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%x %x %x %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx",
                     & dfn, & vend, & d->irq, & d->base_addr[0], & d->base_addr[1],
                     & d->base_addr[2], & d->base_addr[3], & d->base_addr[4], & d->base_addr[5],
                     & d->rom_base_addr, & d->size[0], & d->size[1], & d->size[2],
                     & d->size[3], & d->size[4], & d->size[5], & d->rom_size);
#line 74
    cnt = (unsigned int )tmp___2;
    }
#line 93
    if (cnt != 9U) {
#line 93
      if (cnt != 10U) {
#line 93
        if (cnt != 17U) {
          {
#line 94
          (*(a->error))((char *)"proc: parse error (read only %d items)", cnt);
          }
        }
      }
    }
#line 95
    d->bus = (u8 )(dfn >> 8U);
#line 96
    d->dev = (u8 )(((dfn & 255U) >> 3) & 31U);
#line 97
    d->func = (u8 )((dfn & 255U) & 7U);
#line 98
    d->vendor_id = (u16 )(vend >> 16U);
#line 99
    d->device_id = (u16 )(vend & 65535U);
#line 100
    known = 0U;
#line 101
    if (! a->buscentric) {
#line 103
      known |= 7U;
#line 104
      if (cnt >= 10U) {
#line 105
        known |= 8U;
      }
#line 106
      if (cnt >= 17U) {
#line 107
        known |= 16U;
      }
    }
    {
#line 109
    d->known_fields = (int )known;
#line 110
    pci_link_dev(a, d);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  fclose(f);
  }
#line 113
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
static int proc_setup(struct pci_dev *d , int rw ) 
{ 
  struct pci_access *a ;
  char buf[1024] ;
  int e ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 118
  a = d->access;
#line 120
  if ((unsigned long )a->cached_dev != (unsigned long )d) {
#line 120
    goto _L;
  } else
#line 120
  if (a->fd_rw < rw) {
    _L: /* CIL Label */ 
#line 124
    if (a->fd >= 0) {
      {
#line 125
      close(a->fd);
      }
    }
    {
#line 126
    tmp = pci_get_param(a, (char *)"proc.path");
#line 126
    e = snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/%02x/%02x.%d",
                 tmp, (int )d->bus, (int )d->dev, (int )d->func);
    }
#line 129
    if (e < 0) {
      {
#line 130
      (*(a->error))((char *)"File name too long");
      }
    } else
#line 129
    if (e >= (int )sizeof(buf)) {
      {
#line 130
      (*(a->error))((char *)"File name too long");
      }
    }
#line 131
    if (a->writeable) {
#line 131
      tmp___0 = 1;
    } else
#line 131
    if (rw) {
#line 131
      tmp___0 = 1;
    } else {
#line 131
      tmp___0 = 0;
    }
#line 131
    a->fd_rw = tmp___0;
#line 132
    if (a->fd_rw) {
#line 132
      tmp___1 = 2;
    } else {
#line 132
      tmp___1 = 0;
    }
    {
#line 132
    a->fd = open((char const   *)(buf), tmp___1);
    }
#line 133
    if (a->fd < 0) {
      {
#line 135
      tmp___2 = pci_get_param(a, (char *)"proc.path");
#line 135
      e = snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/%04x:%02x/%02x.%d",
                   tmp___2, (int )d->domain, (int )d->bus, (int )d->dev, (int )d->func);
      }
#line 138
      if (e < 0) {
        {
#line 139
        (*(a->error))((char *)"File name too long");
        }
      } else
#line 138
      if (e >= (int )sizeof(buf)) {
        {
#line 139
        (*(a->error))((char *)"File name too long");
        }
      }
#line 140
      if (a->fd_rw) {
#line 140
        tmp___3 = 2;
      } else {
#line 140
        tmp___3 = 0;
      }
      {
#line 140
      a->fd = open((char const   *)(buf), tmp___3);
      }
    }
#line 142
    if (a->fd < 0) {
      {
#line 143
      (*(a->warning))((char *)"Cannot open %s", buf);
      }
    }
#line 144
    a->cached_dev = d;
#line 145
    a->fd_pos = 0;
  }
#line 147
  return (a->fd);
}
}
#line 150 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
static int proc_read(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int fd ;
  int tmp ;
  int res ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 153
  tmp = proc_setup(d, 0);
#line 153
  fd = tmp;
  }
#line 156
  if (fd < 0) {
#line 157
    return (0);
  }
  {
#line 158
  tmp___0 = pread(fd, (void *)buf, (size_t )len, (__off_t )pos);
#line 158
  res = (int )tmp___0;
  }
#line 159
  if (res < 0) {
    {
#line 161
    tmp___1 = __errno_location();
#line 161
    tmp___2 = strerror(*tmp___1);
#line 161
    (*((d->access)->warning))((char *)"proc_read: read failed: %s", tmp___2);
    }
#line 162
    return (0);
  } else
#line 164
  if (res != len) {
#line 165
    return (0);
  }
#line 166
  return (1);
}
}
#line 169 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
static int proc_write(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int fd ;
  int tmp ;
  int res ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 172
  tmp = proc_setup(d, 1);
#line 172
  fd = tmp;
  }
#line 175
  if (fd < 0) {
#line 176
    return (0);
  }
  {
#line 177
  tmp___0 = pwrite(fd, (void const   *)buf, (size_t )len, (__off_t )pos);
#line 177
  res = (int )tmp___0;
  }
#line 178
  if (res < 0) {
    {
#line 180
    tmp___1 = __errno_location();
#line 180
    tmp___2 = strerror(*tmp___1);
#line 180
    (*((d->access)->warning))((char *)"proc_write: write failed: %s", tmp___2);
    }
#line 181
    return (0);
  } else
#line 183
  if (res != len) {
    {
#line 185
    (*((d->access)->warning))((char *)"proc_write: tried to write %d bytes at %d, but only %d succeeded",
                              len, pos, res);
    }
#line 186
    return (0);
  }
#line 188
  return (1);
}
}
#line 191 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
static void proc_cleanup_dev(struct pci_dev *d ) 
{ 


  {
#line 194
  if ((unsigned long )(d->access)->cached_dev == (unsigned long )d) {
#line 195
    (d->access)->cached_dev = (struct pci_dev *)((void *)0);
  }
#line 196
  return;
}
}
#line 198 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/proc.c"
struct pci_methods pm_linux_proc  = 
#line 198
     {(char *)"linux-proc", (char *)"The proc file system on Linux", & proc_config,
    & proc_detect, & proc_init, & proc_cleanup, & proc_scan, & pci_generic_fill_info,
    & proc_read, & proc_write, (int (*)(struct pci_dev * , int pos , byte *buf , int len ))((void *)0),
    (void (*)(struct pci_dev * ))((void *)0), & proc_cleanup_dev};
#line 148 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
u8 pci_read_byte(struct pci_dev *d , int pos ) ;
#line 149
u16 pci_read_word(struct pci_dev *d , int pos ) ;
#line 150
u32 pci_read_long(struct pci_dev *d , int pos ) ;
#line 188
struct pci_cap *pci_find_cap(struct pci_dev *d , unsigned int id , unsigned int type ) ;
#line 59 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/internal.h"
int pci_fill_info_v32(struct pci_dev *d , int flags ) ;
#line 67
unsigned int pci_scan_caps(struct pci_dev *d , unsigned int want_fields ) ;
#line 68
void pci_free_caps(struct pci_dev *d ) ;
#line 13 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/caps.c"
static void pci_add_cap(struct pci_dev *d , unsigned int addr , unsigned int id ,
                        unsigned int type ) 
{ 
  struct pci_cap *cap ;
  void *tmp ;

  {
  {
#line 16
  tmp = pci_malloc(d->access, (int )sizeof(*cap));
#line 16
  cap = (struct pci_cap *)tmp;
#line 18
  cap->next = d->first_cap;
#line 19
  d->first_cap = cap;
#line 20
  cap->addr = addr;
#line 21
  cap->id = (u16 )id;
#line 22
  cap->type = (u16 )type;
#line 23
  (*((d->access)->debug))((char *)"%04x:%02x:%02x.%d: Found capability %04x of type %d at %04x\n",
                          (int )d->domain, (int )d->bus, (int )d->dev, (int )d->func,
                          id, type, addr);
  }
#line 25
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/caps.c"
static void pci_scan_trad_caps(struct pci_dev *d ) 
{ 
  word status ;
  u16 tmp ;
  byte been_there[256] ;
  int where ;
  u8 tmp___0 ;
  byte id ;
  u8 tmp___1 ;
  byte next ;
  u8 tmp___2 ;
  byte tmp___3 ;

  {
  {
#line 30
  tmp = pci_read_word(d, 6);
#line 30
  status = tmp;
  }
#line 34
  if (! ((int )status & 16)) {
#line 35
    return;
  }
  {
#line 37
  memset((void *)(been_there), 0, (size_t )256);
#line 38
  tmp___0 = pci_read_byte(d, 52);
#line 38
  where = (int )tmp___0 & -4;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! where) {
#line 39
      goto while_break;
    }
    {
#line 41
    tmp___1 = pci_read_byte(d, where);
#line 41
    id = tmp___1;
#line 42
    tmp___2 = pci_read_byte(d, where + 1);
#line 42
    next = (byte )((int )tmp___2 & -4);
#line 43
    tmp___3 = been_there[where];
#line 43
    been_there[where] = (byte )((int )been_there[where] + 1);
    }
#line 43
    if (tmp___3) {
#line 44
      goto while_break;
    }
#line 45
    if ((int )id == 255) {
#line 46
      goto while_break;
    }
    {
#line 47
    pci_add_cap(d, (unsigned int )where, (unsigned int )id, 1U);
#line 48
    where = (int )next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/caps.c"
static void pci_scan_ext_caps(struct pci_dev *d ) 
{ 
  byte been_there[4096] ;
  int where ;
  struct pci_cap *tmp ;
  u32 header ;
  int id ;
  byte tmp___0 ;

  {
  {
#line 56
  where = 256;
#line 58
  tmp = pci_find_cap(d, 16U, 1U);
  }
#line 58
  if (! tmp) {
#line 59
    return;
  }
  {
#line 61
  memset((void *)(been_there), 0, (size_t )4096);
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    header = pci_read_long(d, where);
    }
#line 68
    if (! header) {
#line 69
      goto while_break;
    } else
#line 68
    if (header == 4294967295U) {
#line 69
      goto while_break;
    }
#line 70
    id = (int )(header & 65535U);
#line 71
    tmp___0 = been_there[where];
#line 71
    been_there[where] = (byte )((int )been_there[where] + 1);
#line 71
    if (tmp___0) {
#line 72
      goto while_break;
    }
    {
#line 73
    pci_add_cap(d, (unsigned int )where, (unsigned int )id, 2U);
#line 74
    where = (int )((header >> 20) & 4294967292U);
    }
#line 62
    if (! where) {
#line 62
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/caps.c"
unsigned int pci_scan_caps(struct pci_dev *d , unsigned int want_fields ) 
{ 


  {
#line 82
  if (want_fields & 128U) {
#line 82
    if (! (d->known_fields & 64)) {
#line 83
      want_fields |= 64U;
    }
  }
#line 85
  if (want_fields & 64U) {
    {
#line 86
    pci_scan_trad_caps(d);
    }
  }
#line 87
  if (want_fields & 128U) {
    {
#line 88
    pci_scan_ext_caps(d);
    }
  }
#line 89
  return (want_fields);
}
}
#line 92 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/caps.c"
void pci_free_caps(struct pci_dev *d ) 
{ 
  struct pci_cap *cap ;

  {
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    cap = d->first_cap;
#line 97
    if (! cap) {
#line 97
      goto while_break;
    }
    {
#line 99
    d->first_cap = cap->next;
#line 100
    pci_mfree((void *)cap);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/caps.c"
struct pci_cap *pci_find_cap(struct pci_dev *d , unsigned int id , unsigned int type ) 
{ 
  struct pci_cap *c ;
  int tmp ;

  {
#line 109
  if (type == 1U) {
#line 109
    tmp = 64;
  } else {
#line 109
    tmp = 128;
  }
  {
#line 109
  pci_fill_info_v32(d, tmp);
#line 110
  c = d->first_cap;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! c) {
#line 110
      goto while_break;
    }
#line 111
    if ((unsigned int )c->type == type) {
#line 111
      if ((unsigned int )c->id == id) {
#line 112
        return (c);
      }
    }
#line 110
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return ((struct pci_cap *)((void *)0));
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 199 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
void pci_filter_init(struct pci_access *a  __attribute__((__unused__)) , struct pci_filter *f ) ;
#line 200
char *pci_filter_parse_slot(struct pci_filter *f , char *str ) ;
#line 201
char *pci_filter_parse_id(struct pci_filter *f , char *str ) ;
#line 202
int pci_filter_match(struct pci_filter *f , struct pci_dev *d ) ;
#line 14 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/filter.c"
void pci_filter_init(struct pci_access *a  __attribute__((__unused__)) , struct pci_filter *f ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 17
  tmp___1 = -1;
#line 17
  f->func = tmp___1;
#line 17
  tmp___0 = tmp___1;
#line 17
  f->slot = tmp___0;
#line 17
  tmp = tmp___0;
#line 17
  f->bus = tmp;
#line 17
  f->domain = tmp;
#line 18
  tmp___2 = -1;
#line 18
  f->device = tmp___2;
#line 18
  f->vendor = tmp___2;
#line 19
  return;
}
}
#line 23 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/filter.c"
char *pci_filter_parse_slot(struct pci_filter *f , char *str ) 
{ 
  char *colon ;
  char *tmp ;
  char *dot ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *mid ;
  char *e ;
  char *bus ;
  char *colon2 ;
  char *tmp___2 ;
  char *tmp___3 ;
  long x ;
  long tmp___4 ;
  int tmp___5 ;
  long x___0 ;
  long tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  long x___1 ;
  long tmp___9 ;
  int tmp___10 ;
  long x___2 ;
  long tmp___11 ;
  int tmp___12 ;

  {
  {
#line 26
  tmp = strrchr((char const   *)str, ':');
#line 26
  colon = tmp;
  }
#line 27
  if (colon) {
#line 27
    tmp___0 = colon + 1;
  } else {
#line 27
    tmp___0 = str;
  }
  {
#line 27
  tmp___1 = strchr((char const   *)tmp___0, '.');
#line 27
  dot = tmp___1;
#line 28
  mid = str;
  }
#line 31
  if (colon) {
    {
#line 33
    tmp___2 = colon;
#line 33
    colon ++;
#line 33
    *tmp___2 = (char)0;
#line 34
    mid = colon;
#line 35
    colon2 = strchr((char const   *)str, ':');
    }
#line 36
    if (colon2) {
#line 38
      tmp___3 = colon2;
#line 38
      colon2 ++;
#line 38
      *tmp___3 = (char)0;
#line 39
      bus = colon2;
#line 40
      if (*(str + 0)) {
        {
#line 40
        tmp___5 = strcmp((char const   *)str, "*");
        }
#line 40
        if (tmp___5) {
          {
#line 42
          tmp___4 = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& e),
                           16);
#line 42
          x = tmp___4;
          }
#line 43
          if (e) {
#line 43
            if (*e) {
#line 44
              return ((char *)"Invalid domain number");
            } else {
#line 43
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 43
          if (x < 0L) {
#line 44
            return ((char *)"Invalid domain number");
          } else
#line 43
          if (x > 65535L) {
#line 44
            return ((char *)"Invalid domain number");
          }
#line 45
          f->domain = (int )x;
        }
      }
    } else {
#line 49
      bus = str;
    }
#line 50
    if (*(bus + 0)) {
      {
#line 50
      tmp___7 = strcmp((char const   *)bus, "*");
      }
#line 50
      if (tmp___7) {
        {
#line 52
        tmp___6 = strtol((char const   */* __restrict  */)bus, (char **/* __restrict  */)(& e),
                         16);
#line 52
        x___0 = tmp___6;
        }
#line 53
        if (e) {
#line 53
          if (*e) {
#line 54
            return ((char *)"Invalid bus number");
          } else {
#line 53
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 53
        if (x___0 < 0L) {
#line 54
          return ((char *)"Invalid bus number");
        } else
#line 53
        if (x___0 > 255L) {
#line 54
          return ((char *)"Invalid bus number");
        }
#line 55
        f->bus = (int )x___0;
      }
    }
  }
#line 58
  if (dot) {
#line 59
    tmp___8 = dot;
#line 59
    dot ++;
#line 59
    *tmp___8 = (char)0;
  }
#line 60
  if (*(mid + 0)) {
    {
#line 60
    tmp___10 = strcmp((char const   *)mid, "*");
    }
#line 60
    if (tmp___10) {
      {
#line 62
      tmp___9 = strtol((char const   */* __restrict  */)mid, (char **/* __restrict  */)(& e),
                       16);
#line 62
      x___1 = tmp___9;
      }
#line 63
      if (e) {
#line 63
        if (*e) {
#line 64
          return ((char *)"Invalid slot number");
        } else {
#line 63
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 63
      if (x___1 < 0L) {
#line 64
        return ((char *)"Invalid slot number");
      } else
#line 63
      if (x___1 > 31L) {
#line 64
        return ((char *)"Invalid slot number");
      }
#line 65
      f->slot = (int )x___1;
    }
  }
#line 67
  if (dot) {
#line 67
    if (*(dot + 0)) {
      {
#line 67
      tmp___12 = strcmp((char const   *)dot, "*");
      }
#line 67
      if (tmp___12) {
        {
#line 69
        tmp___11 = strtol((char const   */* __restrict  */)dot, (char **/* __restrict  */)(& e),
                          16);
#line 69
        x___2 = tmp___11;
        }
#line 70
        if (e) {
#line 70
          if (*e) {
#line 71
            return ((char *)"Invalid function number");
          } else {
#line 70
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 70
        if (x___2 < 0L) {
#line 71
          return ((char *)"Invalid function number");
        } else
#line 70
        if (x___2 > 7L) {
#line 71
          return ((char *)"Invalid function number");
        }
#line 72
        f->func = (int )x___2;
      }
    }
  }
#line 74
  return ((char *)((void *)0));
}
}
#line 79 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/filter.c"
char *pci_filter_parse_id(struct pci_filter *f , char *str ) 
{ 
  char *s ;
  char *e ;
  char *tmp ;
  long x ;
  long tmp___0 ;
  int tmp___1 ;
  long x___0 ;
  long tmp___2 ;
  int tmp___3 ;

  {
#line 84
  if (! *str) {
#line 85
    return ((char *)((void *)0));
  }
  {
#line 86
  s = strchr((char const   *)str, ':');
  }
#line 87
  if (! s) {
#line 88
    return ((char *)"\':\' expected");
  }
#line 89
  tmp = s;
#line 89
  s ++;
#line 89
  *tmp = (char)0;
#line 90
  if (*(str + 0)) {
    {
#line 90
    tmp___1 = strcmp((char const   *)str, "*");
    }
#line 90
    if (tmp___1) {
      {
#line 92
      tmp___0 = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& e),
                       16);
#line 92
      x = tmp___0;
      }
#line 93
      if (e) {
#line 93
        if (*e) {
#line 94
          return ((char *)"Invalid vendor ID");
        } else {
#line 93
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 93
      if (x < 0L) {
#line 94
        return ((char *)"Invalid vendor ID");
      } else
#line 93
      if (x > 65535L) {
#line 94
        return ((char *)"Invalid vendor ID");
      }
#line 95
      f->vendor = (int )x;
    }
  }
#line 97
  if (*(s + 0)) {
    {
#line 97
    tmp___3 = strcmp((char const   *)s, "*");
    }
#line 97
    if (tmp___3) {
      {
#line 99
      tmp___2 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)(& e),
                       16);
#line 99
      x___0 = tmp___2;
      }
#line 100
      if (e) {
#line 100
        if (*e) {
#line 101
          return ((char *)"Invalid device ID");
        } else {
#line 100
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 100
      if (x___0 < 0L) {
#line 101
        return ((char *)"Invalid device ID");
      } else
#line 100
      if (x___0 > 65535L) {
#line 101
        return ((char *)"Invalid device ID");
      }
#line 102
      f->device = (int )x___0;
    }
  }
#line 104
  return ((char *)((void *)0));
}
}
#line 107 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/filter.c"
int pci_filter_match(struct pci_filter *f , struct pci_dev *d ) 
{ 


  {
#line 110
  if (f->domain >= 0) {
#line 110
    if (f->domain != (int )d->domain) {
#line 114
      return (0);
    } else {
#line 110
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 110
  if (f->bus >= 0) {
#line 110
    if (f->bus != (int )d->bus) {
#line 114
      return (0);
    } else {
#line 110
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 110
  if (f->slot >= 0) {
#line 110
    if (f->slot != (int )d->dev) {
#line 114
      return (0);
    } else {
#line 110
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 110
  if (f->func >= 0) {
#line 110
    if (f->func != (int )d->func) {
#line 114
      return (0);
    }
  }
#line 115
  if (f->device >= 0) {
#line 115
    goto _L___3;
  } else
#line 115
  if (f->vendor >= 0) {
    _L___3: /* CIL Label */ 
    {
#line 117
    pci_fill_info_v32(d, 1);
    }
#line 118
    if (f->device >= 0) {
#line 118
      if (f->device != (int )d->device_id) {
#line 120
        return (0);
      } else {
#line 118
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 118
    if (f->vendor >= 0) {
#line 118
      if (f->vendor != (int )d->vendor_id) {
#line 120
        return (0);
      }
    }
  }
#line 122
  return (1);
}
}
#line 109 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
int pci_set_param(struct pci_access *acc , char *param , char *value ) ;
#line 111
struct pci_param *pci_walk_params(struct pci_access *acc , struct pci_param *prev ) ;
#line 15 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/params.c"
char *pci_get_param(struct pci_access *acc , char *param ) 
{ 
  struct pci_param *p ;
  int tmp ;

  {
#line 20
  p = acc->params;
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! p) {
#line 20
      goto while_break;
    }
    {
#line 21
    tmp = strcmp((char const   *)p->param, (char const   *)param);
    }
#line 21
    if (! tmp) {
#line 22
      return (p->value);
    }
#line 20
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return ((char *)((void *)0));
}
}
#line 26 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/params.c"
void pci_define_param(struct pci_access *acc , char *param , char *value , char *help ) 
{ 
  struct pci_param *p ;
  void *tmp ;

  {
  {
#line 29
  tmp = pci_malloc(acc, (int )sizeof(*p));
#line 29
  p = (struct pci_param *)tmp;
#line 31
  p->next = acc->params;
#line 32
  acc->params = p;
#line 33
  p->param = param;
#line 34
  p->value = value;
#line 35
  p->value_malloced = 0;
#line 36
  p->help = help;
  }
#line 37
  return;
}
}
#line 39 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/params.c"
int pci_set_param_internal(struct pci_access *acc , char *param , char *value , int copy ) 
{ 
  struct pci_param *p ;
  int tmp ;

  {
#line 44
  p = acc->params;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! p) {
#line 44
      goto while_break;
    }
    {
#line 45
    tmp = strcmp((char const   *)p->param, (char const   *)param);
    }
#line 45
    if (! tmp) {
#line 47
      if (p->value_malloced) {
        {
#line 48
        pci_mfree((void *)p->value);
        }
      }
#line 49
      p->value_malloced = copy;
#line 50
      if (copy) {
        {
#line 51
        p->value = pci_strdup(acc, value);
        }
      } else {
#line 53
        p->value = value;
      }
#line 54
      return (0);
    }
#line 44
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (-1);
}
}
#line 59 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/params.c"
int pci_set_param(struct pci_access *acc , char *param , char *value ) 
{ 
  int tmp ;

  {
  {
#line 62
  tmp = pci_set_param_internal(acc, param, value, 1);
  }
#line 62
  return (tmp);
}
}
#line 65 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/params.c"
void pci_free_params(struct pci_access *acc ) 
{ 
  struct pci_param *p ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    p = acc->params;
#line 70
    if (! p) {
#line 70
      goto while_break;
    }
#line 72
    acc->params = p->next;
#line 73
    if (p->value_malloced) {
      {
#line 74
      pci_mfree((void *)p->value);
      }
    }
    {
#line 75
    pci_mfree((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/params.c"
struct pci_param *pci_walk_params(struct pci_access *acc , struct pci_param *prev ) 
{ 


  {
#line 83
  if (! prev) {
#line 84
    return (acc->params);
  } else {
#line 86
    return (prev->next);
  }
}
}
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 222 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
int pci_load_name_list(struct pci_access *a ) ;
#line 58 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.h"
char *pci_id_lookup(struct pci_access *a , int flags , int cat , int id1 , int id2 ,
                    int id3 , int id4 ) ;
#line 65
void pci_id_hash_free(struct pci_access *a ) ;
#line 60 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-parse.c"
static int id_hex(char *p , int cnt ) 
{ 
  int x ;
  int tmp ;

  {
#line 62
  x = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    tmp = cnt;
#line 63
    cnt --;
#line 63
    if (! tmp) {
#line 63
      goto while_break;
    }
#line 65
    x <<= 4;
#line 66
    if ((int )*p >= 48) {
#line 66
      if ((int )*p <= 57) {
#line 67
        x += (int )*p - 48;
      } else {
#line 66
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 68
    if ((int )*p >= 97) {
#line 68
      if ((int )*p <= 102) {
#line 69
        x += ((int )*p - 97) + 10;
      } else {
#line 68
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 70
    if ((int )*p >= 65) {
#line 70
      if ((int )*p <= 70) {
#line 71
        x += ((int )*p - 65) + 10;
      } else {
#line 73
        return (-1);
      }
    } else {
#line 73
      return (-1);
    }
#line 74
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (x);
}
}
#line 79 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-parse.c"
__inline static int id_white_p(int c ) 
{ 
  int tmp ;

  {
#line 81
  if (c == 32) {
#line 81
    tmp = 1;
  } else
#line 81
  if (c == 9) {
#line 81
    tmp = 1;
  } else {
#line 81
    tmp = 0;
  }
#line 81
  return (tmp);
}
}
#line 92
static char const   *id_parse_list(struct pci_access *a , pci_file f , int *lino ) ;
#line 92 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-parse.c"
static char const   parse_error[12]  = 
#line 92
  {      (char const   )'P',      (char const   )'a',      (char const   )'r',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'r', 
        (char const   )'r',      (char const   )'o',      (char const   )'r',      (char const   )'\000'};
#line 85 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-parse.c"
static char const   *id_parse_list(struct pci_access *a , pci_file f , int *lino ) 
{ 
  char line[1024] ;
  char *p ;
  int id1 ;
  int id2 ;
  int id3 ;
  int id4 ;
  int cat ;
  int nest ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 89
  id1 = 0;
#line 89
  id2 = 0;
#line 89
  id3 = 0;
#line 89
  id4 = 0;
#line 90
  cat = -1;
#line 94
  *lino = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 95
    tmp___12 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)f);
    }
#line 95
    if (! tmp___12) {
#line 95
      goto while_break;
    }
#line 97
    (*lino) ++;
#line 98
    p = line;
    {
#line 99
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 99
      if (*p) {
#line 99
        if ((int )*p != 10) {
#line 99
          if (! ((int )*p != 13)) {
#line 99
            goto while_break___0;
          }
        } else {
#line 99
          goto while_break___0;
        }
      } else {
#line 99
        goto while_break___0;
      }
#line 100
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 101
    if (! *p) {
      {
#line 101
      tmp = feof(f);
      }
#line 101
      if (! tmp) {
#line 102
        return ("Line too long");
      }
    }
#line 103
    *p = (char)0;
#line 104
    if ((unsigned long )p > (unsigned long )(line)) {
#line 104
      if ((int )*(p + -1) == 32) {
#line 105
        p --;
#line 105
        *p = (char)0;
      } else
#line 104
      if ((int )*(p + -1) == 9) {
#line 105
        p --;
#line 105
        *p = (char)0;
      }
    }
#line 107
    p = line;
    {
#line 108
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 108
      tmp___0 = id_white_p((int )*p);
      }
#line 108
      if (! tmp___0) {
#line 108
        goto while_break___1;
      }
#line 109
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 110
    if (! *p) {
#line 111
      goto while_continue;
    } else
#line 110
    if ((int )*p == 35) {
#line 111
      goto while_continue;
    }
#line 113
    p = line;
    {
#line 114
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 114
      if (! ((int )*p == 9)) {
#line 114
        goto while_break___2;
      }
#line 115
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 116
    nest = (int )(p - line);
#line 118
    if (! nest) {
#line 120
      if ((int )*(p + 0) == 67) {
#line 120
        if ((int )*(p + 1) == 32) {
          {
#line 122
          id1 = id_hex(p + 2, 2);
          }
#line 122
          if (id1 < 0) {
#line 123
            return (parse_error);
          } else {
            {
#line 122
            tmp___1 = id_white_p((int )*(p + 4));
            }
#line 122
            if (! tmp___1) {
#line 123
              return (parse_error);
            }
          }
#line 124
          cat = 5;
#line 125
          p += 5;
        } else {
#line 120
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 127
      if ((int )*(p + 0) == 83) {
#line 127
        if ((int )*(p + 1) == 32) {
          {
#line 129
          id1 = id_hex(p + 2, 4);
          }
#line 129
          if (id1 < 0) {
#line 130
            return (parse_error);
          } else
#line 129
          if (*(p + 6)) {
#line 130
            return (parse_error);
          }
          {
#line 131
          tmp___2 = pci_id_lookup(a, 0, 1, id1, 0, 0, 0);
          }
#line 131
          if (! tmp___2) {
#line 132
            return ("Vendor does not exist");
          }
#line 133
          cat = 4;
#line 134
          goto while_continue;
        } else {
#line 127
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 136
      if ((int )*(p + 0) >= 65) {
#line 136
        if ((int )*(p + 0) <= 90) {
#line 136
          if ((int )*(p + 1) == 32) {
#line 138
            cat = 0;
#line 139
            goto while_continue;
          } else {
#line 136
            goto _L___0;
          }
        } else {
#line 136
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 143
        id1 = id_hex(p, 4);
        }
#line 143
        if (id1 < 0) {
#line 144
          return (parse_error);
        } else {
          {
#line 143
          tmp___3 = id_white_p((int )*(p + 4));
          }
#line 143
          if (! tmp___3) {
#line 144
            return (parse_error);
          }
        }
#line 145
        cat = 1;
#line 146
        p += 5;
      }
#line 148
      id4 = 0;
#line 148
      id3 = id4;
#line 148
      id2 = id3;
    } else
#line 150
    if (cat == 0) {
#line 151
      goto while_continue;
    } else
#line 152
    if (nest == 1) {
      {
#line 157
      if (cat == 3) {
#line 157
        goto case_3;
      }
#line 157
      if (cat == 2) {
#line 157
        goto case_3;
      }
#line 157
      if (cat == 1) {
#line 157
        goto case_3;
      }
#line 164
      if (cat == 4) {
#line 164
        goto case_4;
      }
#line 172
      if (cat == 7) {
#line 172
        goto case_7;
      }
#line 172
      if (cat == 6) {
#line 172
        goto case_7;
      }
#line 172
      if (cat == 5) {
#line 172
        goto case_7;
      }
#line 179
      goto switch_default;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      {
#line 158
      id2 = id_hex(p, 4);
      }
#line 158
      if (id2 < 0) {
#line 159
        return (parse_error);
      } else {
        {
#line 158
        tmp___4 = id_white_p((int )*(p + 4));
        }
#line 158
        if (! tmp___4) {
#line 159
          return (parse_error);
        }
      }
#line 160
      p += 5;
#line 161
      cat = 2;
#line 162
      id4 = 0;
#line 162
      id3 = id4;
#line 163
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 165
      id2 = id_hex(p, 4);
      }
#line 165
      if (id2 < 0) {
#line 166
        return (parse_error);
      } else {
        {
#line 165
        tmp___5 = id_white_p((int )*(p + 4));
        }
#line 165
        if (! tmp___5) {
#line 166
          return (parse_error);
        }
      }
#line 167
      p += 5;
#line 168
      id4 = 0;
#line 168
      id3 = id4;
#line 169
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      {
#line 173
      id2 = id_hex(p, 2);
      }
#line 173
      if (id2 < 0) {
#line 174
        return (parse_error);
      } else {
        {
#line 173
        tmp___6 = id_white_p((int )*(p + 2));
        }
#line 173
        if (! tmp___6) {
#line 174
          return (parse_error);
        }
      }
#line 175
      p += 3;
#line 176
      cat = 6;
#line 177
      id4 = 0;
#line 177
      id3 = id4;
#line 178
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 180
      return (parse_error);
      switch_break: /* CIL Label */ ;
      }
    } else
#line 182
    if (nest == 2) {
      {
#line 186
      if (cat == 3) {
#line 186
        goto case_3___0;
      }
#line 186
      if (cat == 2) {
#line 186
        goto case_3___0;
      }
#line 194
      if (cat == 7) {
#line 194
        goto case_7___0;
      }
#line 194
      if (cat == 6) {
#line 194
        goto case_7___0;
      }
#line 194
      if (cat == 5) {
#line 194
        goto case_7___0;
      }
#line 201
      goto switch_default___0;
      case_3___0: /* CIL Label */ 
      case_2___0: /* CIL Label */ 
      {
#line 187
      id3 = id_hex(p, 4);
      }
#line 187
      if (id3 < 0) {
#line 188
        return (parse_error);
      } else {
        {
#line 187
        tmp___7 = id_white_p((int )*(p + 4));
        }
#line 187
        if (tmp___7) {
          {
#line 187
          id4 = id_hex(p + 5, 4);
          }
#line 187
          if (id4 < 0) {
#line 188
            return (parse_error);
          } else {
            {
#line 187
            tmp___8 = id_white_p((int )*(p + 9));
            }
#line 187
            if (! tmp___8) {
#line 188
              return (parse_error);
            }
          }
        } else {
#line 188
          return (parse_error);
        }
      }
#line 189
      p += 10;
#line 190
      cat = 3;
#line 191
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
      case_6___0: /* CIL Label */ 
      case_5___0: /* CIL Label */ 
      {
#line 195
      id3 = id_hex(p, 2);
      }
#line 195
      if (id3 < 0) {
#line 196
        return (parse_error);
      } else {
        {
#line 195
        tmp___9 = id_white_p((int )*(p + 2));
        }
#line 195
        if (! tmp___9) {
#line 196
          return (parse_error);
        }
      }
#line 197
      p += 3;
#line 198
      cat = 7;
#line 199
      id4 = 0;
#line 200
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 202
      return (parse_error);
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 205
      return (parse_error);
    }
    {
#line 206
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 206
      tmp___10 = id_white_p((int )*p);
      }
#line 206
      if (! tmp___10) {
#line 206
        goto while_break___3;
      }
#line 207
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 208
    if (! *p) {
#line 209
      return (parse_error);
    }
    {
#line 210
    tmp___11 = pci_id_insert(a, cat, id1, id2, id3, id4, p, (enum id_entry_src )3);
    }
#line 210
    if (tmp___11) {
#line 211
      return ("Duplicate entry");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return ((char const   *)((void *)0));
}
}
#line 216 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-parse.c"
int pci_load_name_list(struct pci_access *a ) 
{ 
  pci_file f ;
  int lino ;
  char const   *err ;
  int tmp ;

  {
  {
#line 223
  pci_free_name_list(a);
#line 224
  a->id_load_failed = 1;
#line 225
  f = fopen((char const   */* __restrict  */)a->id_file_name, (char const   */* __restrict  */)"r");
  }
#line 225
  if (! f) {
#line 226
    return (0);
  }
  {
#line 227
  err = id_parse_list(a, f, & lino);
  }
#line 228
  if (! err) {
    {
#line 228
    tmp = ferror(f);
    }
#line 228
    if (tmp) {
#line 228
      err = "I/O error";
    }
  }
  {
#line 229
  fclose(f);
  }
#line 230
  if (err) {
    {
#line 231
    (*(a->error))((char *)"%s at %s, line %d\n", err, a->id_file_name, lino);
    }
  }
#line 232
  a->id_load_failed = 0;
#line 233
  return (1);
}
}
#line 236 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-parse.c"
void pci_free_name_list(struct pci_access *a ) 
{ 


  {
  {
#line 239
  pci_id_cache_flush(a);
#line 240
  pci_id_hash_free(a);
#line 241
  a->id_load_failed = 0;
  }
#line 242
  return;
}
}
#line 244 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-parse.c"
void pci_set_name_list_path(struct pci_access *a , char *name , int to_be_freed ) 
{ 


  {
#line 247
  if (a->free_id_name) {
    {
#line 248
    free((void *)a->id_file_name);
    }
  }
#line 249
  a->id_file_name = name;
#line 250
  a->free_id_name = to_be_freed;
#line 251
  return;
}
}
#line 42 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/internal.h"
void pci_generic_scan_bus(struct pci_access *a , byte *busmap , int bus ) ;
#line 13 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/generic.c"
void pci_generic_scan_bus(struct pci_access *a , byte *busmap , int bus ) 
{ 
  int dev ;
  int multi ;
  int ht ;
  struct pci_dev *t ;
  u32 vd ;
  u32 tmp ;
  struct pci_dev *d ;
  u8 tmp___0 ;
  u8 tmp___1 ;

  {
  {
#line 19
  (*(a->debug))((char *)"Scanning bus %02x for devices...\n", bus);
  }
#line 20
  if (*(busmap + bus)) {
    {
#line 22
    (*(a->warning))((char *)"Bus %02x seen twice (firmware bug). Ignored.", bus);
    }
#line 23
    return;
  }
  {
#line 25
  *(busmap + bus) = (byte )1;
#line 26
  t = pci_alloc_dev(a);
#line 27
  t->bus = (u8 )bus;
#line 28
  dev = 0;
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (dev < 32)) {
#line 28
      goto while_break;
    }
#line 30
    t->dev = (u8 )dev;
#line 31
    multi = 0;
#line 32
    t->func = (u8 )0;
    {
#line 32
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 32
      if (! (! t->func)) {
#line 32
        if (multi) {
#line 32
          if (! ((int )t->func < 8)) {
#line 32
            goto while_break___0;
          }
        } else {
#line 32
          goto while_break___0;
        }
      }
      {
#line 34
      tmp = pci_read_long(t, 0);
#line 34
      vd = tmp;
      }
#line 37
      if (! vd) {
#line 38
        goto __Cont;
      } else
#line 37
      if (vd == 4294967295U) {
#line 38
        goto __Cont;
      }
      {
#line 39
      tmp___0 = pci_read_byte(t, 14);
#line 39
      ht = (int )tmp___0;
      }
#line 40
      if (! t->func) {
#line 41
        multi = ht & 128;
      }
      {
#line 42
      ht &= 127;
#line 43
      d = pci_alloc_dev(a);
#line 44
      d->bus = t->bus;
#line 45
      d->dev = t->dev;
#line 46
      d->func = t->func;
#line 47
      d->vendor_id = (u16 )(vd & 65535U);
#line 48
      d->device_id = (u16 )(vd >> 16U);
#line 49
      d->known_fields = 1;
#line 50
      d->hdrtype = ht;
#line 51
      pci_link_dev(a, d);
      }
      {
#line 54
      if (ht == 0) {
#line 54
        goto case_0;
      }
#line 57
      if (ht == 2) {
#line 57
        goto case_2;
      }
#line 57
      if (ht == 1) {
#line 57
        goto case_2;
      }
#line 60
      goto switch_default;
      case_0: /* CIL Label */ 
#line 55
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      {
#line 58
      tmp___1 = pci_read_byte(t, 25);
#line 58
      pci_generic_scan_bus(a, busmap, (int )tmp___1);
      }
#line 59
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 61
      (*(a->debug))((char *)"Device %04x:%02x:%02x.%d has unknown header type %02x.\n",
                    (int )d->domain, (int )d->bus, (int )d->dev, (int )d->func, ht);
      }
      switch_break: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 32
      t->func = (u8 )((int )t->func + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 28
    dev ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  pci_free_dev(t);
  }
#line 66
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/generic.c"
void pci_generic_scan(struct pci_access *a ) 
{ 
  byte busmap[256] ;

  {
  {
#line 73
  memset((void *)(busmap), 0, sizeof(busmap));
#line 74
  pci_generic_scan_bus(a, busmap, 0);
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/generic.c"
int pci_generic_fill_info(struct pci_dev *d , int flags ) 
{ 
  struct pci_access *a ;
  u8 tmp ;
  u8 tmp___0 ;
  int cnt ;
  int i ;
  u32 x ;
  u32 tmp___1 ;
  u32 y ;
  u32 tmp___2 ;
  int reg ;
  u32 u ;
  u32 tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 80
  a = d->access;
#line 82
  if (flags & 12) {
#line 82
    if (d->hdrtype < 0) {
      {
#line 83
      tmp = pci_read_byte(d, 14);
#line 83
      d->hdrtype = (int )tmp & 127;
      }
    }
  }
#line 84
  if (flags & 1) {
    {
#line 86
    d->vendor_id = pci_read_word(d, 0);
#line 87
    d->device_id = pci_read_word(d, 2);
    }
  }
#line 89
  if (flags & 32) {
    {
#line 90
    d->device_class = pci_read_word(d, 10);
    }
  }
#line 91
  if (flags & 2) {
    {
#line 92
    tmp___0 = pci_read_byte(d, 60);
#line 92
    d->irq = (int )tmp___0;
    }
  }
#line 93
  if (flags & 4) {
    {
#line 95
    cnt = 0;
#line 96
    memset((void *)(d->base_addr), 0, sizeof(d->base_addr));
    }
    {
#line 99
    if (d->hdrtype == 0) {
#line 99
      goto case_0;
    }
#line 102
    if (d->hdrtype == 1) {
#line 102
      goto case_1;
    }
#line 105
    if (d->hdrtype == 2) {
#line 105
      goto case_2;
    }
#line 97
    goto switch_break;
    case_0: /* CIL Label */ 
#line 100
    cnt = 6;
#line 101
    goto switch_break;
    case_1: /* CIL Label */ 
#line 103
    cnt = 2;
#line 104
    goto switch_break;
    case_2: /* CIL Label */ 
#line 106
    cnt = 1;
#line 107
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 109
    if (cnt) {
#line 111
      i = 0;
      {
#line 111
      while (1) {
        while_continue: /* CIL Label */ ;
#line 111
        if (! (i < cnt)) {
#line 111
          goto while_break;
        }
        {
#line 113
        tmp___1 = pci_read_long(d, 16 + i * 4);
#line 113
        x = tmp___1;
        }
#line 114
        if (! x) {
#line 115
          goto __Cont;
        } else
#line 114
        if (x == 4294967295U) {
#line 115
          goto __Cont;
        }
#line 116
        if ((x & 1U) == 1U) {
#line 117
          d->base_addr[i] = (pciaddr_t )x;
        } else
#line 120
        if ((x & 6U) != 4U) {
#line 121
          d->base_addr[i] = (pciaddr_t )x;
        } else
#line 122
        if (i >= cnt - 1) {
          {
#line 123
          (*(a->warning))((char *)"%04x:%02x:%02x.%d: Invalid 64-bit address seen for BAR %d.",
                          (int )d->domain, (int )d->bus, (int )d->dev, (int )d->func,
                          i);
          }
        } else {
          {
#line 126
          i ++;
#line 126
          tmp___2 = pci_read_long(d, 16 + i * 4);
#line 126
          y = tmp___2;
#line 128
          d->base_addr[i - 1] = (unsigned long )x | ((pciaddr_t )y << 32);
          }
        }
        __Cont: /* CIL Label */ 
#line 111
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 140
  if (flags & 8) {
#line 142
    reg = 0;
#line 143
    d->rom_base_addr = (pciaddr_t )0;
    {
#line 146
    if (d->hdrtype == 0) {
#line 146
      goto case_0___0;
    }
#line 149
    if (d->hdrtype == 1) {
#line 149
      goto case_1___0;
    }
#line 144
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 147
    reg = 48;
#line 148
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 150
    reg = 56;
#line 151
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 153
    if (reg) {
      {
#line 155
      tmp___3 = pci_read_long(d, reg);
#line 155
      u = tmp___3;
      }
#line 156
      if (u != 4294967295U) {
#line 157
        d->rom_base_addr = (pciaddr_t )u;
      }
    }
  }
#line 160
  if (flags & 192) {
    {
#line 161
    tmp___4 = pci_scan_caps(d, (unsigned int )flags);
#line 161
    flags = (int )((unsigned int )flags | tmp___4);
    }
  }
#line 162
  return (flags & -17);
}
}
#line 165 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/generic.c"
static int pci_generic_block_op(struct pci_dev *d , int pos , byte *buf , int len ,
                                int (*r)(struct pci_dev *d , int pos , byte *buf ,
                                         int len ) ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 169
  if (pos & 1) {
#line 169
    if (len >= 1) {
      {
#line 171
      tmp = (*r)(d, pos, buf, 1);
      }
#line 171
      if (! tmp) {
#line 172
        return (0);
      }
#line 173
      pos ++;
#line 173
      buf ++;
#line 173
      len --;
    }
  }
#line 175
  if (pos & 3) {
#line 175
    if (len >= 2) {
      {
#line 177
      tmp___0 = (*r)(d, pos, buf, 2);
      }
#line 177
      if (! tmp___0) {
#line 178
        return (0);
      }
#line 179
      pos += 2;
#line 179
      buf += 2;
#line 179
      len -= 2;
    }
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (len >= 4)) {
#line 181
      goto while_break;
    }
    {
#line 183
    tmp___1 = (*r)(d, pos, buf, 4);
    }
#line 183
    if (! tmp___1) {
#line 184
      return (0);
    }
#line 185
    pos += 4;
#line 185
    buf += 4;
#line 185
    len -= 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  if (len >= 2) {
    {
#line 189
    tmp___2 = (*r)(d, pos, buf, 2);
    }
#line 189
    if (! tmp___2) {
#line 190
      return (0);
    }
#line 191
    pos += 2;
#line 191
    buf += 2;
#line 191
    len -= 2;
  }
#line 193
  if (len) {
    {
#line 193
    tmp___3 = (*r)(d, pos, buf, 1);
    }
#line 193
    if (! tmp___3) {
#line 194
      return (0);
    }
  }
#line 195
  return (1);
}
}
#line 198 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/generic.c"
int pci_generic_block_read(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int tmp ;

  {
  {
#line 201
  tmp = pci_generic_block_op(d, pos, buf, len, ((d->access)->methods)->read);
  }
#line 201
  return (tmp);
}
}
#line 204 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/generic.c"
int pci_generic_block_write(struct pci_dev *d , int pos , byte *buf , int len ) 
{ 
  int tmp ;

  {
  {
#line 207
  tmp = pci_generic_block_op(d, pos, buf, len, ((d->access)->methods)->write);
  }
#line 207
  return (tmp);
}
}
#line 42 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.h"
__inline static u32 id_pair(unsigned int x , unsigned int y ) 
{ 


  {
#line 44
  return ((x << 16) | y);
}
}
#line 30 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-hash.c"
static void *id_alloc(struct pci_access *a , unsigned int size ) 
{ 
  struct id_bucket *buck ;
  unsigned int pos ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 32
  buck = a->current_id_bucket;
#line 35
  if (! a->id_hash) {
    {
#line 37
    tmp = pci_malloc(a, (int )(sizeof(struct id_entry *) * 4099UL));
#line 37
    a->id_hash = (struct id_entry **)tmp;
#line 38
    memset((void *)a->id_hash, 0, sizeof(struct id_entry *) * 4099UL);
    }
  }
#line 41
  if (! buck) {
    {
#line 43
    tmp___0 = pci_malloc(a, 8192);
#line 43
    buck = (struct id_bucket *)tmp___0;
#line 44
    buck->next = a->current_id_bucket;
#line 45
    a->current_id_bucket = buck;
#line 46
    buck->full = (unsigned int )((sizeof(struct id_bucket ) + __alignof__(struct id_bucket )) - sizeof(struct id_bucket ) % __alignof__(struct id_bucket ));
    }
  } else
#line 41
  if (buck->full + size > 8192U) {
    {
#line 43
    tmp___0 = pci_malloc(a, 8192);
#line 43
    buck = (struct id_bucket *)tmp___0;
#line 44
    buck->next = a->current_id_bucket;
#line 45
    a->current_id_bucket = buck;
#line 46
    buck->full = (unsigned int )((sizeof(struct id_bucket ) + __alignof__(struct id_bucket )) - sizeof(struct id_bucket ) % __alignof__(struct id_bucket ));
    }
  }
#line 48
  pos = buck->full;
#line 49
  buck->full = (unsigned int )(((unsigned long )(buck->full + size) + __alignof__(struct id_bucket )) - (unsigned long )(buck->full + size) % __alignof__(struct id_bucket ));
#line 50
  return ((void *)((byte *)buck + pos));
}
}
#line 53 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-hash.c"
__inline static unsigned int id_hash(int cat , u32 id12 , u32 id34 ) 
{ 
  unsigned int h ;

  {
#line 57
  h = (id12 ^ (id34 << 3)) ^ (unsigned int )(cat << 5);
#line 58
  return (h % 4099U);
}
}
#line 61 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-hash.c"
int pci_id_insert(struct pci_access *a , int cat , int id1 , int id2 , int id3 , int id4 ,
                  char *text , enum id_entry_src src ) 
{ 
  u32 id12 ;
  u32 tmp ;
  u32 id34 ;
  u32 tmp___0 ;
  unsigned int h ;
  unsigned int tmp___1 ;
  struct id_entry *n ;
  struct id_entry *tmp___2 ;
  int len ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 64
  tmp = id_pair((unsigned int )id1, (unsigned int )id2);
#line 64
  id12 = tmp;
#line 65
  tmp___0 = id_pair((unsigned int )id3, (unsigned int )id4);
#line 65
  id34 = tmp___0;
#line 66
  tmp___1 = id_hash(cat, id12, id34);
#line 66
  h = tmp___1;
  }
#line 67
  if (a->id_hash) {
#line 67
    tmp___2 = *(a->id_hash + h);
  } else {
#line 67
    tmp___2 = (struct id_entry *)((void *)0);
  }
  {
#line 67
  n = tmp___2;
#line 68
  tmp___3 = strlen((char const   *)text);
#line 68
  len = (int )tmp___3;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (n) {
#line 70
      if (! (n->id12 != id12)) {
#line 70
        if (! (n->id34 != id34)) {
#line 70
          if (! ((int )n->cat != cat)) {
#line 70
            goto while_break;
          }
        }
      }
    } else {
#line 70
      goto while_break;
    }
#line 71
    n = n->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (n) {
#line 73
    return (1);
  }
  {
#line 74
  tmp___4 = id_alloc(a, (unsigned int )(sizeof(struct id_entry ) + (unsigned long )len));
#line 74
  n = (struct id_entry *)tmp___4;
#line 75
  n->id12 = id12;
#line 76
  n->id34 = id34;
#line 77
  n->cat = (byte )cat;
#line 78
  n->src = (byte )src;
#line 79
  memcpy((void */* __restrict  */)(n->name), (void const   */* __restrict  */)text,
         (size_t )(len + 1));
#line 80
  n->next = *(a->id_hash + h);
#line 81
  *(a->id_hash + h) = n;
  }
#line 82
  return (0);
}
}
#line 85 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-hash.c"
char *pci_id_lookup(struct pci_access *a , int flags , int cat , int id1 , int id2 ,
                    int id3 , int id4 ) 
{ 
  struct id_entry *n ;
  struct id_entry *best ;
  u32 id12 ;
  u32 tmp ;
  u32 id34 ;
  u32 tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 89
  tmp = id_pair((unsigned int )id1, (unsigned int )id2);
#line 89
  id12 = tmp;
#line 90
  tmp___0 = id_pair((unsigned int )id3, (unsigned int )id4);
#line 90
  id34 = tmp___0;
  }
#line 92
  if (a->id_hash) {
    {
#line 94
    tmp___1 = id_hash(cat, id12, id34);
#line 94
    n = *(a->id_hash + tmp___1);
#line 95
    best = (struct id_entry *)((void *)0);
    }
    {
#line 96
    while (1) {
      while_continue: /* CIL Label */ ;
#line 96
      if (! n) {
#line 96
        goto while_break;
      }
#line 98
      if (n->id12 != id12) {
#line 99
        goto __Cont;
      } else
#line 98
      if (n->id34 != id34) {
#line 99
        goto __Cont;
      } else
#line 98
      if ((int )n->cat != cat) {
#line 99
        goto __Cont;
      }
#line 100
      if ((int )n->src == 3) {
#line 100
        if (flags & 1048576) {
#line 101
          goto __Cont;
        }
      }
#line 102
      if ((int )n->src == 2) {
#line 102
        if (! (flags & 524288)) {
#line 103
          goto __Cont;
        }
      }
#line 104
      if ((int )n->src == 1) {
#line 104
        if (! (flags & 2097152)) {
#line 105
          goto __Cont;
        }
      }
#line 106
      if (! best) {
#line 107
        best = n;
      } else
#line 106
      if ((int )best->src < (int )n->src) {
#line 107
        best = n;
      }
      __Cont: /* CIL Label */ 
#line 96
      n = n->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 109
    if (best) {
#line 110
      return (best->name);
    }
  }
#line 112
  return ((char *)((void *)0));
}
}
#line 115 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-hash.c"
void pci_id_hash_free(struct pci_access *a ) 
{ 
  struct id_bucket *buck ;

  {
  {
#line 118
  pci_mfree((void *)a->id_hash);
#line 119
  a->id_hash = (struct id_entry **)((void *)0);
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! a->current_id_bucket) {
#line 120
      goto while_break;
    }
    {
#line 122
    buck = a->current_id_bucket;
#line 123
    a->current_id_bucket = buck->next;
#line 124
    pci_mfree((void *)buck);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 88 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
void pci_scan_bus(struct pci_access *a ) ;
#line 151
int pci_read_block(struct pci_dev *d , int pos , u8 *buf , int len ) ;
#line 152
int pci_read_vpd(struct pci_dev *d , int pos , u8 *buf , int len ) ;
#line 153
int pci_write_byte(struct pci_dev *d , int pos , u8 data ) ;
#line 154
int pci_write_word(struct pci_dev *d , int pos , u16 data ) ;
#line 155
int pci_write_long(struct pci_dev *d , int pos , u32 data ) ;
#line 156
int pci_write_block(struct pci_dev *d , int pos , u8 *buf , int len ) ;
#line 158
int pci_fill_info(struct pci_dev *d , int flags ) ;
#line 172
void pci_setup_cache(struct pci_dev *d , u8 *cache , int len ) ;
#line 16 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
void pci_scan_bus(struct pci_access *a ) 
{ 


  {
  {
#line 19
  (*((a->methods)->scan))(a);
  }
#line 20
  return;
}
}
#line 22 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
struct pci_dev *pci_alloc_dev(struct pci_access *a ) 
{ 
  struct pci_dev *d ;
  void *tmp ;

  {
  {
#line 25
  tmp = pci_malloc(a, (int )sizeof(struct pci_dev ));
#line 25
  d = (struct pci_dev *)tmp;
#line 27
  memset((void *)d, 0, sizeof(*d));
#line 28
  d->access = a;
#line 29
  d->methods = a->methods;
#line 30
  d->hdrtype = -1;
  }
#line 31
  if ((d->methods)->init_dev) {
    {
#line 32
    (*((d->methods)->init_dev))(d);
    }
  }
#line 33
  return (d);
}
}
#line 36 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
int pci_link_dev(struct pci_access *a , struct pci_dev *d ) 
{ 


  {
#line 39
  d->next = a->devices;
#line 40
  a->devices = d;
#line 42
  return (1);
}
}
#line 45 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
struct pci_dev *pci_get_dev(struct pci_access *a , int domain , int bus , int dev ,
                            int func ) 
{ 
  struct pci_dev *d ;
  struct pci_dev *tmp ;

  {
  {
#line 48
  tmp = pci_alloc_dev(a);
#line 48
  d = tmp;
#line 50
  d->domain = (u16 )domain;
#line 51
  d->bus = (u8 )bus;
#line 52
  d->dev = (u8 )dev;
#line 53
  d->func = (u8 )func;
  }
#line 54
  return (d);
}
}
#line 57 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
void pci_free_dev(struct pci_dev *d ) 
{ 


  {
#line 59
  if ((d->methods)->cleanup_dev) {
    {
#line 60
    (*((d->methods)->cleanup_dev))(d);
    }
  }
  {
#line 61
  pci_free_caps(d);
#line 62
  pci_mfree((void *)d->module_alias);
#line 63
  pci_mfree((void *)d->phy_slot);
#line 64
  pci_mfree((void *)d);
  }
#line 65
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
__inline static void pci_read_data(struct pci_dev *d , void *buf , int pos , int len ) 
{ 
  int tmp ;

  {
#line 70
  if (pos & (len - 1)) {
    {
#line 71
    (*((d->access)->error))((char *)"Unaligned read: pos=%02x, len=%d", pos, len);
    }
  }
#line 72
  if (pos + len <= d->cache_len) {
    {
#line 73
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(d->cache + pos),
           (size_t )len);
    }
  } else {
    {
#line 74
    tmp = (*((d->methods)->read))(d, pos, (byte *)buf, len);
    }
#line 74
    if (! tmp) {
      {
#line 75
      memset(buf, 255, (size_t )len);
      }
    }
  }
#line 76
  return;
}
}
#line 78 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
u8 pci_read_byte(struct pci_dev *d , int pos ) 
{ 
  byte buf ;

  {
  {
#line 82
  pci_read_data(d, (void *)(& buf), pos, 1);
  }
#line 83
  return (buf);
}
}
#line 86 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
u16 pci_read_word(struct pci_dev *d , int pos ) 
{ 
  word buf ;

  {
  {
#line 90
  pci_read_data(d, (void *)(& buf), pos, 2);
  }
#line 91
  return (buf);
}
}
#line 94 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
u32 pci_read_long(struct pci_dev *d , int pos ) 
{ 
  u32 buf ;

  {
  {
#line 98
  pci_read_data(d, (void *)(& buf), pos, 4);
  }
#line 99
  return (buf);
}
}
#line 102 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
int pci_read_block(struct pci_dev *d , int pos , u8 *buf , int len ) 
{ 
  int tmp ;

  {
  {
#line 105
  tmp = (*((d->methods)->read))(d, pos, buf, len);
  }
#line 105
  return (tmp);
}
}
#line 108 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
int pci_read_vpd(struct pci_dev *d , int pos , u8 *buf , int len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 111
  if ((d->methods)->read_vpd) {
    {
#line 111
    tmp = (*((d->methods)->read_vpd))(d, pos, buf, len);
#line 111
    tmp___0 = tmp;
    }
  } else {
#line 111
    tmp___0 = 0;
  }
#line 111
  return (tmp___0);
}
}
#line 114 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
__inline static int pci_write_data(struct pci_dev *d , void *buf , int pos , int len ) 
{ 
  int tmp ;

  {
#line 117
  if (pos & (len - 1)) {
    {
#line 118
    (*((d->access)->error))((char *)"Unaligned write: pos=%02x,len=%d", pos, len);
    }
  }
#line 119
  if (pos + len <= d->cache_len) {
    {
#line 120
    memcpy((void */* __restrict  */)(d->cache + pos), (void const   */* __restrict  */)buf,
           (size_t )len);
    }
  }
  {
#line 121
  tmp = (*((d->methods)->write))(d, pos, (byte *)buf, len);
  }
#line 121
  return (tmp);
}
}
#line 124 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
int pci_write_byte(struct pci_dev *d , int pos , u8 data ) 
{ 
  int tmp ;

  {
  {
#line 127
  tmp = pci_write_data(d, (void *)(& data), pos, 1);
  }
#line 127
  return (tmp);
}
}
#line 130 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
int pci_write_word(struct pci_dev *d , int pos , u16 data ) 
{ 
  word buf ;
  int tmp ;

  {
  {
#line 133
  buf = data;
#line 134
  tmp = pci_write_data(d, (void *)(& buf), pos, 2);
  }
#line 134
  return (tmp);
}
}
#line 137 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
int pci_write_long(struct pci_dev *d , int pos , u32 data ) 
{ 
  u32 buf ;
  int tmp ;

  {
  {
#line 140
  buf = data;
#line 141
  tmp = pci_write_data(d, (void *)(& buf), pos, 4);
  }
#line 141
  return (tmp);
}
}
#line 144 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
int pci_write_block(struct pci_dev *d , int pos , u8 *buf , int len ) 
{ 
  int l ;
  int tmp ;
  int tmp___0 ;

  {
#line 147
  if (pos < d->cache_len) {
#line 149
    if (pos + len >= d->cache_len) {
#line 149
      tmp = d->cache_len - pos;
    } else {
#line 149
      tmp = len;
    }
    {
#line 149
    l = tmp;
#line 150
    memcpy((void */* __restrict  */)(d->cache + pos), (void const   */* __restrict  */)buf,
           (size_t )l);
    }
  }
  {
#line 152
  tmp___0 = (*((d->methods)->write))(d, pos, buf, len);
  }
#line 152
  return (tmp___0);
}
}
#line 155 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
int pci_fill_info_v32(struct pci_dev *d , int flags ) 
{ 
  int tmp ;

  {
#line 158
  if (flags & 65536) {
    {
#line 160
    flags &= -65537;
#line 161
    d->known_fields = 0;
#line 162
    pci_free_caps(d);
    }
  }
#line 164
  if (flags & ~ d->known_fields) {
    {
#line 165
    tmp = (*((d->methods)->fill_info))(d, flags & ~ d->known_fields);
#line 165
    d->known_fields |= tmp;
    }
  }
#line 166
  return (d->known_fields);
}
}
#line 171 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
int pci_fill_info(struct pci_dev *d , int flags ) 
{ 
  int tmp ;

  {
  {
#line 171
  tmp = pci_fill_info_v32(d, flags);
  }
#line 171
  return (tmp);
}
}
#line 178 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/access.c"
void pci_setup_cache(struct pci_dev *d , u8 *cache , int len ) 
{ 


  {
#line 181
  d->cache = cache;
#line 182
  d->cache_len = len;
#line 183
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 220 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/pci.h"
char *pci_lookup_name(struct pci_access *a , char *buf , int size , int flags  , ...) ;
#line 69 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.h"
char *pci_id_net_lookup(struct pci_access *a , int cat , int id1 , int id2 , int id3 ,
                        int id4 ) ;
#line 16 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.c"
static char *id_lookup(struct pci_access *a , int flags , int cat , int id1 , int id2 ,
                       int id3 , int id4 ) 
{ 
  char *name ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 20
    name = pci_id_lookup(a, flags, cat, id1, id2, id3, id4);
    }
#line 20
    if (name) {
#line 20
      goto while_break;
    }
#line 22
    if (flags & 2097152) {
#line 22
      if (! a->id_cache_status) {
        {
#line 24
        tmp = pci_id_cache_load(a, flags);
        }
#line 24
        if (tmp) {
#line 25
          goto while_continue;
        }
      }
    }
#line 27
    if (flags & 524288) {
      {
#line 29
      name = pci_id_net_lookup(a, cat, id1, id2, id3, id4);
      }
#line 29
      if (name) {
        {
#line 31
        pci_id_insert(a, cat, id1, id2, id3, id4, name, (enum id_entry_src )2);
#line 32
        pci_mfree((void *)name);
#line 33
        pci_id_cache_dirty(a);
        }
      } else {
        {
#line 36
        pci_id_insert(a, cat, id1, id2, id3, id4, (char *)"", (enum id_entry_src )2);
        }
      }
#line 38
      goto while_continue;
    }
#line 40
    return ((char *)((void *)0));
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  if (*(name + 0)) {
#line 42
    tmp___0 = name;
  } else {
#line 42
    tmp___0 = (char *)((void *)0);
  }
#line 42
  return (tmp___0);
}
}
#line 45 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.c"
static char *id_lookup_subsys(struct pci_access *a , int flags , int iv , int id ,
                              int isv , int isd ) 
{ 
  char *d ;

  {
#line 48
  d = (char *)((void *)0);
#line 49
  if (iv > 0) {
#line 49
    if (id > 0) {
      {
#line 50
      d = id_lookup(a, flags, 3, iv, id, isv, isd);
      }
    }
  }
#line 51
  if (! d) {
    {
#line 52
    d = id_lookup(a, flags, 4, isv, isd, 0, 0);
    }
  }
#line 53
  if (! d) {
#line 53
    if (iv == isv) {
#line 53
      if (id == isd) {
        {
#line 54
        d = id_lookup(a, flags, 2, iv, id, 0, 0);
        }
      }
    }
  }
#line 55
  return (d);
}
}
#line 58 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.c"
static char *format_name(char *buf , int size , int flags , char *name , char *num ,
                         char *unknown ) 
{ 
  int res ;
  char const   *tmp ;
  char tmp___0 ;
  char tmp___1 ;

  {
#line 62
  if (flags & 131072) {
#line 62
    if (! name) {
#line 63
      return ((char *)((void *)0));
    } else {
#line 62
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 64
  if (flags & 65536) {
    {
#line 65
    res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"%s",
                   num);
    }
  } else
#line 66
  if (! name) {
#line 67
    if (flags & 262144) {
#line 67
      tmp = "%s [%s]";
    } else {
#line 67
      tmp = "%s %s";
    }
    {
#line 67
    res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)tmp,
                   unknown, num);
    }
  } else
#line 68
  if (! (flags & 262144)) {
    {
#line 69
    res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"%s",
                   name);
    }
  } else {
    {
#line 71
    res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"%s [%s]",
                   name, num);
    }
  }
#line 72
  if (res >= size) {
#line 72
    if (size >= 4) {
#line 73
      tmp___1 = (char )'.';
#line 73
      *(buf + (size - 4)) = tmp___1;
#line 73
      tmp___0 = tmp___1;
#line 73
      *(buf + (size - 3)) = tmp___0;
#line 73
      *(buf + (size - 2)) = tmp___0;
    } else {
#line 72
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 74
  if (res < 0) {
#line 75
    return ((char *)"<pci_lookup_name: buffer too small>");
  } else
#line 74
  if (res >= size) {
#line 75
    return ((char *)"<pci_lookup_name: buffer too small>");
  }
#line 76
  return (buf);
}
}
#line 79 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.c"
static char *format_name_pair(char *buf , int size , int flags , char *v , char *d ,
                              char *num ) 
{ 
  int res ;
  char tmp ;
  char tmp___0 ;

  {
#line 83
  if (flags & 131072) {
#line 83
    if (! v) {
#line 84
      return ((char *)((void *)0));
    } else
#line 83
    if (! d) {
#line 84
      return ((char *)((void *)0));
    }
  }
#line 85
  if (flags & 65536) {
    {
#line 86
    res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"%s",
                   num);
    }
  } else
#line 87
  if (flags & 262144) {
#line 89
    if (v) {
#line 89
      if (d) {
        {
#line 90
        res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"%s %s [%s]",
                       v, d, num);
        }
      } else {
#line 89
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 91
    if (! v) {
      {
#line 92
      res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"Device [%s]",
                     num);
      }
    } else {
      {
#line 94
      res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"%s Device [%s]",
                     v, num);
      }
    }
  } else
#line 98
  if (v) {
#line 98
    if (d) {
      {
#line 99
      res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"%s %s",
                     v, d);
      }
    } else {
#line 98
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 100
  if (! v) {
    {
#line 101
    res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"Device %s",
                   num);
    }
  } else {
    {
#line 103
    res = snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"%s Device %s",
                   v, num + 5);
    }
  }
#line 105
  if (res >= size) {
#line 105
    if (size >= 4) {
#line 106
      tmp___0 = (char )'.';
#line 106
      *(buf + (size - 4)) = tmp___0;
#line 106
      tmp = tmp___0;
#line 106
      *(buf + (size - 3)) = tmp;
#line 106
      *(buf + (size - 2)) = tmp;
    } else {
#line 105
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 107
  if (res < 0) {
#line 108
    return ((char *)"<pci_lookup_name: buffer too small>");
  } else
#line 107
  if (res >= size) {
#line 108
    return ((char *)"<pci_lookup_name: buffer too small>");
  }
#line 109
  return (buf);
}
}
#line 112 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names.c"
char *pci_lookup_name(struct pci_access *a , char *buf , int size , int flags  , ...) 
{ 
  va_list args ;
  char *v ;
  char *d ;
  char *cls ;
  char *pif ;
  int iv ;
  int id ;
  int isv ;
  int isd ;
  int icls ;
  int ipif ;
  char numbuf[16] ;
  char pifbuf[32] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char *tmp___31 ;

  {
  {
#line 120
  __builtin_va_start(args, flags);
#line 122
  flags = (int )((unsigned int )flags | a->id_lookup_mode);
  }
#line 123
  if (! (flags & 131072)) {
#line 125
    if (a->numeric_ids > 1) {
#line 126
      flags |= 262144;
    } else
#line 127
    if (a->numeric_ids) {
#line 128
      flags |= 65536;
    }
  }
#line 130
  if (flags & 262144) {
#line 131
    flags &= -65537;
  }
#line 133
  if (! a->id_hash) {
#line 133
    if (! (flags & 1114112)) {
#line 133
      if (! a->id_load_failed) {
        {
#line 134
        pci_load_name_list(a);
        }
      }
    }
  }
  {
#line 138
  if ((flags & 65535) == 1) {
#line 138
    goto case_1;
  }
#line 142
  if ((flags & 65535) == 2) {
#line 142
    goto case_2;
  }
#line 147
  if ((flags & 65535) == 3) {
#line 147
    goto case_3;
  }
#line 154
  if ((flags & 65535) == 9) {
#line 154
    goto case_9;
  }
#line 159
  if ((flags & 65535) == 10) {
#line 159
    goto case_10;
  }
#line 166
  if ((flags & 65535) == 11) {
#line 166
    goto case_11;
  }
#line 175
  if ((flags & 65535) == 4) {
#line 175
    goto case_4;
  }
#line 185
  if ((flags & 65535) == 16) {
#line 185
    goto case_16;
  }
#line 204
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 139
  tmp = __builtin_va_arg(args, int );
#line 139
  iv = tmp;
#line 140
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%04x",
          iv);
#line 141
  tmp___0 = id_lookup(a, flags, 1, iv, 0, 0, 0);
#line 141
  tmp___1 = format_name(buf, size, flags, tmp___0, numbuf, (char *)"Vendor");
  }
#line 141
  return (tmp___1);
  case_2: /* CIL Label */ 
  {
#line 143
  tmp___2 = __builtin_va_arg(args, int );
#line 143
  iv = tmp___2;
#line 144
  tmp___3 = __builtin_va_arg(args, int );
#line 144
  id = tmp___3;
#line 145
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%04x",
          id);
#line 146
  tmp___4 = id_lookup(a, flags, 2, iv, id, 0, 0);
#line 146
  tmp___5 = format_name(buf, size, flags, tmp___4, numbuf, (char *)"Device");
  }
#line 146
  return (tmp___5);
  case_3: /* CIL Label */ 
  {
#line 148
  tmp___6 = __builtin_va_arg(args, int );
#line 148
  iv = tmp___6;
#line 149
  tmp___7 = __builtin_va_arg(args, int );
#line 149
  id = tmp___7;
#line 150
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%04x:%04x",
          iv, id);
#line 151
  v = id_lookup(a, flags, 1, iv, 0, 0, 0);
#line 152
  d = id_lookup(a, flags, 2, iv, id, 0, 0);
#line 153
  tmp___8 = format_name_pair(buf, size, flags, v, d, numbuf);
  }
#line 153
  return (tmp___8);
  case_9: /* CIL Label */ 
  {
#line 155
  tmp___9 = __builtin_va_arg(args, int );
#line 155
  isv = tmp___9;
#line 156
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%04x",
          isv);
#line 157
  v = id_lookup(a, flags, 1, isv, 0, 0, 0);
#line 158
  tmp___10 = format_name(buf, size, flags, v, numbuf, (char *)"Unknown vendor");
  }
#line 158
  return (tmp___10);
  case_10: /* CIL Label */ 
  {
#line 160
  tmp___11 = __builtin_va_arg(args, int );
#line 160
  iv = tmp___11;
#line 161
  tmp___12 = __builtin_va_arg(args, int );
#line 161
  id = tmp___12;
#line 162
  tmp___13 = __builtin_va_arg(args, int );
#line 162
  isv = tmp___13;
#line 163
  tmp___14 = __builtin_va_arg(args, int );
#line 163
  isd = tmp___14;
#line 164
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%04x",
          isd);
#line 165
  tmp___15 = id_lookup_subsys(a, flags, iv, id, isv, isd);
#line 165
  tmp___16 = format_name(buf, size, flags, tmp___15, numbuf, (char *)"Device");
  }
#line 165
  return (tmp___16);
  case_11: /* CIL Label */ 
  {
#line 167
  tmp___17 = __builtin_va_arg(args, int );
#line 167
  iv = tmp___17;
#line 168
  tmp___18 = __builtin_va_arg(args, int );
#line 168
  id = tmp___18;
#line 169
  tmp___19 = __builtin_va_arg(args, int );
#line 169
  isv = tmp___19;
#line 170
  tmp___20 = __builtin_va_arg(args, int );
#line 170
  isd = tmp___20;
#line 171
  v = id_lookup(a, flags, 1, isv, 0, 0, 0);
#line 172
  d = id_lookup_subsys(a, flags, iv, id, isv, isd);
#line 173
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%04x:%04x",
          isv, isd);
#line 174
  tmp___21 = format_name_pair(buf, size, flags, v, d, numbuf);
  }
#line 174
  return (tmp___21);
  case_4: /* CIL Label */ 
  {
#line 176
  tmp___22 = __builtin_va_arg(args, int );
#line 176
  icls = tmp___22;
#line 177
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%04x",
          icls);
#line 178
  cls = id_lookup(a, flags, 6, icls >> 8, icls & 255, 0, 0);
  }
#line 179
  if (! cls) {
    {
#line 179
    cls = id_lookup(a, flags, 5, icls >> 8, 0, 0, 0);
    }
#line 179
    if (cls) {
#line 181
      if (! (flags & 65536)) {
#line 182
        flags |= 262144;
      }
    }
  }
  {
#line 184
  tmp___23 = format_name(buf, size, flags, cls, numbuf, (char *)"Class");
  }
#line 184
  return (tmp___23);
  case_16: /* CIL Label */ 
  {
#line 186
  tmp___24 = __builtin_va_arg(args, int );
#line 186
  icls = tmp___24;
#line 187
  tmp___25 = __builtin_va_arg(args, int );
#line 187
  ipif = tmp___25;
#line 188
  sprintf((char */* __restrict  */)(numbuf), (char const   */* __restrict  */)"%02x",
          ipif);
#line 189
  pif = id_lookup(a, flags, 7, icls >> 8, icls & 255, ipif, 0);
  }
#line 190
  if (! pif) {
#line 190
    if (icls == 257) {
#line 190
      if (! (ipif & 112)) {
#line 193
        if (ipif & 1) {
#line 193
          tmp___26 = " PriO";
        } else {
#line 193
          tmp___26 = "";
        }
#line 193
        if (ipif & 2) {
#line 193
          tmp___27 = " PriP";
        } else {
#line 193
          tmp___27 = "";
        }
#line 193
        if (ipif & 4) {
#line 193
          tmp___28 = " SecO";
        } else {
#line 193
          tmp___28 = "";
        }
#line 193
        if (ipif & 8) {
#line 193
          tmp___29 = " SecP";
        } else {
#line 193
          tmp___29 = "";
        }
#line 193
        if (ipif & 128) {
#line 193
          tmp___30 = " Master";
        } else {
#line 193
          tmp___30 = "";
        }
        {
#line 193
        sprintf((char */* __restrict  */)(pifbuf), (char const   */* __restrict  */)"%s%s%s%s%s",
                tmp___30, tmp___29, tmp___28, tmp___27, tmp___26);
#line 199
        pif = pifbuf;
        }
#line 200
        if (*pif) {
#line 201
          pif ++;
        }
      }
    }
  }
  {
#line 203
  tmp___31 = format_name(buf, size, flags, pif, numbuf, (char *)"ProgIf");
  }
#line 203
  return (tmp___31);
  switch_default: /* CIL Label */ 
#line 205
  return ((char *)"<pci_lookup_name: invalid request>");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 273 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_init)(void) ;
#line 277
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_query)(char const   * ,
                                                                                  int  ,
                                                                                  int  ,
                                                                                  u_char * ,
                                                                                  int  ) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 51 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-net.c"
static byte *dns_skip_name(byte *p , byte *end ) 
{ 
  unsigned int x ;
  byte *tmp ;
  byte *tmp___0 ;

  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 54
      goto while_break;
    }
#line 56
    tmp = p;
#line 56
    p ++;
#line 56
    x = (unsigned int )*tmp;
#line 57
    if (! x) {
#line 58
      return (p);
    }
    {
#line 61
    if ((x & 192U) == 0U) {
#line 61
      goto case_0;
    }
#line 64
    if ((x & 192U) == 192U) {
#line 64
      goto case_192;
    }
#line 67
    goto switch_default;
    case_0: /* CIL Label */ 
#line 62
    p += x;
#line 63
    goto switch_break;
    case_192: /* CIL Label */ 
#line 65
    p ++;
#line 66
    if ((unsigned long )p < (unsigned long )end) {
#line 66
      tmp___0 = p;
    } else {
#line 66
      tmp___0 = (byte *)((void *)0);
    }
#line 66
    return (tmp___0);
    switch_default: /* CIL Label */ 
#line 68
    return ((byte *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return ((byte *)((void *)0));
}
}
#line 74 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-net.c"
static int dns_parse_packet(struct dns_state *s , byte *p , unsigned int plen ) 
{ 
  byte *end ;
  unsigned int i ;
  unsigned int j ;
  unsigned int len ;
  unsigned int x  __attribute__((__unused__)) ;

  {
#line 77
  end = p + plen;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if ((unsigned long )(p + 4) > (unsigned long )end) {
#line 91
      goto err;
    }
#line 91
    x = (unsigned int )(((((int )*(p + 0) << 24) | ((int )*(p + 1) << 16)) | ((int )*(p + 2) << 8)) | (int )*(p + 3));
#line 91
    p += 4;
#line 91
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = 0U;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 4U)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 93
      if ((unsigned long )(p + 2) > (unsigned long )end) {
#line 93
        goto err;
      }
#line 93
      s->counts[i] = (u16 )(((int )*(p + 0) << 8) | (int )*(p + 1));
#line 93
      p += 2;
#line 93
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 92
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  i = 0U;
  {
#line 94
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 94
    if (! (i < 4U)) {
#line 94
      goto while_break___2;
    }
#line 96
    s->sections[i] = p;
#line 97
    j = 0U;
    {
#line 97
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 97
      if (! (j < (unsigned int )s->counts[i])) {
#line 97
        goto while_break___3;
      }
      {
#line 99
      p = dns_skip_name(p, end);
      }
#line 100
      if (! p) {
#line 101
        goto err;
      }
      {
#line 102
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 102
        if ((unsigned long )(p + 4) > (unsigned long )end) {
#line 102
          goto err;
        }
#line 102
        x = (unsigned int )(((((int )*(p + 0) << 24) | ((int )*(p + 1) << 16)) | ((int )*(p + 2) << 8)) | (int )*(p + 3));
#line 102
        p += 4;
#line 102
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 103
      if (i != 0U) {
        {
#line 105
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 105
          if ((unsigned long )(p + 4) > (unsigned long )end) {
#line 105
            goto err;
          }
#line 105
          x = (unsigned int )(((((int )*(p + 0) << 24) | ((int )*(p + 1) << 16)) | ((int )*(p + 2) << 8)) | (int )*(p + 3));
#line 105
          p += 4;
#line 105
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 106
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 106
          if ((unsigned long )(p + 2) > (unsigned long )end) {
#line 106
            goto err;
          }
#line 106
          len = (unsigned int )(((int )*(p + 0) << 8) | (int )*(p + 1));
#line 106
          p += 2;
#line 106
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 107
        p += len;
#line 108
        if ((unsigned long )p > (unsigned long )end) {
#line 109
          goto err;
        }
      }
#line 97
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 94
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 113
  s->sections[i] = p;
#line 114
  return (0);
  err: 
#line 117
  return (-1);
}
}
#line 120 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-net.c"
static void dns_init_section(struct dns_state *s , int i ) 
{ 


  {
#line 123
  s->sec_ptr = s->sections[i];
#line 124
  s->sec_end = s->sections[i + 1];
#line 125
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-net.c"
static int dns_parse_rr(struct dns_state *s ) 
{ 
  byte *p ;
  byte *end ;

  {
#line 130
  p = s->sec_ptr;
#line 131
  end = s->sec_end;
#line 133
  if ((unsigned long )p == (unsigned long )end) {
#line 134
    return (0);
  }
  {
#line 135
  p = dns_skip_name(p, end);
  }
#line 136
  if (! p) {
#line 137
    goto err;
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if ((unsigned long )(p + 2) > (unsigned long )end) {
#line 138
      goto err;
    }
#line 138
    s->rr_type = (u16 )(((int )*(p + 0) << 8) | (int )*(p + 1));
#line 138
    p += 2;
#line 138
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if ((unsigned long )(p + 2) > (unsigned long )end) {
#line 139
      goto err;
    }
#line 139
    s->rr_class = (u16 )(((int )*(p + 0) << 8) | (int )*(p + 1));
#line 139
    p += 2;
#line 139
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 140
    if ((unsigned long )(p + 4) > (unsigned long )end) {
#line 140
      goto err;
    }
#line 140
    s->rr_ttl = (u32 )(((((int )*(p + 0) << 24) | ((int )*(p + 1) << 16)) | ((int )*(p + 2) << 8)) | (int )*(p + 3));
#line 140
    p += 4;
#line 140
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 141
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 141
    if ((unsigned long )(p + 2) > (unsigned long )end) {
#line 141
      goto err;
    }
#line 141
    s->rr_len = (u16 )(((int )*(p + 0) << 8) | (int )*(p + 1));
#line 141
    p += 2;
#line 141
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 142
  s->rr_data = p;
#line 143
  s->sec_ptr = p + (int )s->rr_len;
#line 144
  return (1);
  err: 
#line 147
  return (-1);
}
}
#line 153 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-net.c"
static int resolver_inited  ;
#line 150 "/home/wheatley/newnew/temp/pciutils-3.2.1/lib/names-net.c"
char *pci_id_net_lookup(struct pci_access *a , int cat , int id1 , int id2 , int id3 ,
                        int id4 ) 
{ 
  char name[256] ;
  char dnsname[256] ;
  char txt[256] ;
  char *domain ;
  byte answer[4096] ;
  byte const   *data ;
  int res ;
  int j ;
  int dlen ;
  struct dns_state ds ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 160
  domain = pci_get_param(a, (char *)"net.domain");
  }
#line 161
  if (! domain) {
#line 162
    return ((char *)((void *)0));
  } else
#line 161
  if (! *(domain + 0)) {
#line 162
    return ((char *)((void *)0));
  }
  {
#line 166
  if (cat == 1) {
#line 166
    goto case_1;
  }
#line 169
  if (cat == 2) {
#line 169
    goto case_2;
  }
#line 172
  if (cat == 3) {
#line 172
    goto case_3;
  }
#line 175
  if (cat == 4) {
#line 175
    goto case_4;
  }
#line 178
  if (cat == 5) {
#line 178
    goto case_5;
  }
#line 181
  if (cat == 6) {
#line 181
    goto case_6;
  }
#line 184
  if (cat == 7) {
#line 184
    goto case_7;
  }
#line 187
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 167
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%04x",
          id1);
  }
#line 168
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 170
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%04x.%04x",
          id2, id1);
  }
#line 171
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 173
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%04x.%04x.%04x.%04x",
          id4, id3, id2, id1);
  }
#line 174
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 176
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%04x.%04x.s",
          id2, id1);
  }
#line 177
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 179
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%02x.c",
          id1);
  }
#line 180
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 182
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%02x.%02x.c",
          id2, id1);
  }
#line 183
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 185
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%02x.%02x.%02x.c",
          id3, id2, id1);
  }
#line 186
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 188
  return ((char *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 190
  sprintf((char */* __restrict  */)(dnsname), (char const   */* __restrict  */)"%s.%s",
          name, domain);
#line 192
  (*(a->debug))((char *)"Resolving %s\n", dnsname);
  }
#line 193
  if (! resolver_inited) {
    {
#line 195
    resolver_inited = 1;
#line 196
    __res_init();
    }
  }
  {
#line 198
  res = __res_query((char const   *)(dnsname), 1, 16, answer, (int )sizeof(answer));
  }
#line 199
  if (res < 0) {
    {
#line 201
    tmp = __h_errno_location();
#line 201
    (*(a->debug))((char *)"\tfailed, h_errno=%d\n", *tmp);
    }
#line 202
    return ((char *)((void *)0));
  }
  {
#line 204
  tmp___0 = dns_parse_packet(& ds, answer, (unsigned int )res);
  }
#line 204
  if (tmp___0 < 0) {
    {
#line 206
    (*(a->debug))((char *)"\tMalformed DNS packet received\n");
    }
#line 207
    return ((char *)((void *)0));
  }
  {
#line 209
  dns_init_section(& ds, 1);
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 210
    tmp___2 = dns_parse_rr(& ds);
    }
#line 210
    if (! (tmp___2 > 0)) {
#line 210
      goto while_break;
    }
#line 212
    if ((int )ds.rr_class != 1) {
      {
#line 214
      (*(a->debug))((char *)"\tUnexpected RR in answer: class %d, type %d\n", (int )ds.rr_class,
                    (int )ds.rr_type);
      }
#line 215
      goto while_continue;
    } else
#line 212
    if ((int )ds.rr_type != 16) {
      {
#line 214
      (*(a->debug))((char *)"\tUnexpected RR in answer: class %d, type %d\n", (int )ds.rr_class,
                    (int )ds.rr_type);
      }
#line 215
      goto while_continue;
    }
#line 217
    data = (byte const   *)ds.rr_data;
#line 218
    dlen = (int )ds.rr_len;
#line 219
    j = 0;
    {
#line 220
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 220
      if (j < dlen) {
#line 220
        if (! ((j + 1) + (int )*(data + j) <= dlen)) {
#line 220
          goto while_break___0;
        }
      } else {
#line 220
        goto while_break___0;
      }
      {
#line 222
      memcpy((void */* __restrict  */)(txt), (void const   */* __restrict  */)(data + (j + 1)),
             (size_t )*(data + j));
#line 223
      txt[*(data + j)] = (char)0;
#line 224
      j += 1 + (int )*(data + j);
#line 225
      (*(a->debug))((char *)"\t\"%s\"\n", txt);
      }
#line 226
      if ((int )txt[0] == 105) {
#line 226
        if ((int )txt[1] == 61) {
          {
#line 227
          tmp___1 = strdup((char const   *)(txt + 2));
          }
#line 227
          return (tmp___1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return ((char *)((void *)0));
}
}
