/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_62 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_63 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_62 ifr_ifrn ;
   union __anonunion_ifr_ifru_63 ifr_ifru ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_8 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_8 fd_set;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 73 "/home/june/collector/temp/axel-2.4/axel.h"
struct __anonstruct_message_t_78 {
   void *next ;
   char text[1024] ;
};
#line 73 "/home/june/collector/temp/axel-2.4/axel.h"
typedef struct __anonstruct_message_t_78 message_t;
#line 79 "/home/june/collector/temp/axel-2.4/axel.h"
typedef message_t url_t;
#line 80 "/home/june/collector/temp/axel-2.4/axel.h"
typedef message_t if_t;
#line 26 "/home/june/collector/temp/axel-2.4/conf.h"
struct __anonstruct_conf_t_79 {
   char default_filename[1024] ;
   char http_proxy[1024] ;
   char no_proxy[1024] ;
   int strip_cgi_parameters ;
   int save_state_interval ;
   int connection_timeout ;
   int reconnect_delay ;
   int num_connections ;
   int buffer_size ;
   int max_speed ;
   int verbose ;
   int alternate_output ;
   if_t *interfaces ;
   int search_timeout ;
   int search_threads ;
   int search_amount ;
   int search_top ;
   int add_header_count ;
   char add_header[10][1024] ;
   char user_agent[1024] ;
};
#line 26 "/home/june/collector/temp/axel-2.4/conf.h"
typedef struct __anonstruct_conf_t_79 conf_t;
#line 29 "/home/june/collector/temp/axel-2.4/ftp.h"
struct __anonstruct_ftp_t_80 {
   char cwd[1024] ;
   char *message ;
   int status ;
   int fd ;
   int data_fd ;
   int ftp_mode ;
   char *local_if ;
};
#line 29 "/home/june/collector/temp/axel-2.4/ftp.h"
typedef struct __anonstruct_ftp_t_80 ftp_t;
#line 28 "/home/june/collector/temp/axel-2.4/http.h"
struct __anonstruct_http_t_81 {
   char host[1024] ;
   char auth[1024] ;
   char request[2048] ;
   char headers[2048] ;
   int proto ;
   int proxy ;
   long long firstbyte ;
   long long lastbyte ;
   int status ;
   int fd ;
   char *local_if ;
};
#line 28 "/home/june/collector/temp/axel-2.4/http.h"
typedef struct __anonstruct_http_t_81 http_t;
#line 30 "/home/june/collector/temp/axel-2.4/conn.h"
struct __anonstruct_conn_t_82 {
   conf_t *conf ;
   int proto ;
   int port ;
   int proxy ;
   char host[1024] ;
   char dir[1024] ;
   char file[1024] ;
   char user[1024] ;
   char pass[1024] ;
   ftp_t ftp[1] ;
   http_t http[1] ;
   long long size ;
   long long currentbyte ;
   long long lastbyte ;
   int fd ;
   int enabled ;
   int supported ;
   int last_transfer ;
   char *message ;
   char *local_if ;
   int state ;
   pthread_t setup_thread[1] ;
};
#line 30 "/home/june/collector/temp/axel-2.4/conn.h"
typedef struct __anonstruct_conn_t_82 conn_t;
#line 26 "/home/june/collector/temp/axel-2.4/search.h"
struct __anonstruct_search_t_83 {
   char url[1024] ;
   double speed_start_time ;
   int speed ;
   int size ;
   pthread_t speed_thread[1] ;
   conf_t *conf ;
};
#line 26 "/home/june/collector/temp/axel-2.4/search.h"
typedef struct __anonstruct_search_t_83 search_t;
#line 92 "/home/june/collector/temp/axel-2.4/axel.h"
struct __anonstruct_axel_t_84 {
   conn_t *conn ;
   conf_t conf[1] ;
   char filename[1024] ;
   double start_time ;
   int next_state ;
   int finish_time ;
   long long bytes_done ;
   long long start_byte ;
   long long size ;
   int bytes_per_second ;
   int delay_time ;
   int outfd ;
   int ready ;
   message_t *message ;
   url_t *url ;
};
#line 92 "/home/june/collector/temp/axel-2.4/axel.h"
typedef struct __anonstruct_axel_t_84 axel_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 26 "/home/june/collector/temp/axel-2.4/tcp.h"
int tcp_connect(char *hostname , int port , char *local_if ) ;
#line 27
int get_if_ip(char *iface , char *ip ) ;
#line 29 "/home/june/collector/temp/axel-2.4/tcp.c"
int tcp_connect(char *hostname , int port , char *local_if ) 
{ 
  struct hostent *host ;
  struct sockaddr_in addr ;
  struct sockaddr_in local ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
#line 31
  host = (struct hostent *)((void *)0);
#line 44
  fd = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (fd < 5)) {
#line 44
      goto while_break;
    }
    {
#line 46
    host = gethostbyname((char const   *)hostname);
    }
#line 46
    if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 47
      return (-1);
    }
#line 48
    if (*(host->h_name)) {
#line 48
      goto while_break;
    }
#line 44
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (! host) {
#line 51
    return (-1);
  } else
#line 50
  if (! host->h_name) {
#line 51
    return (-1);
  } else
#line 50
  if (! *(host->h_name)) {
#line 51
    return (-1);
  }
  {
#line 53
  fd = socket(2, 1, 0);
  }
#line 53
  if (fd == -1) {
#line 54
    return (-1);
  }
#line 56
  if (local_if) {
#line 56
    if (*local_if) {
      {
#line 58
      local.sin_family = (sa_family_t )2;
#line 59
      local.sin_port = (in_port_t )0;
#line 60
      local.sin_addr.s_addr = inet_addr((char const   *)local_if);
#line 61
      tmp = bind(fd, (struct sockaddr  const  *)((struct sockaddr *)(& local)), (socklen_t )sizeof(struct sockaddr_in ));
      }
#line 61
      if (tmp == -1) {
        {
#line 63
        close(fd);
        }
#line 64
        return (-1);
      }
    }
  }
  {
#line 68
  addr.sin_family = (sa_family_t )2;
#line 69
  addr.sin_port = htons((uint16_t )port);
#line 70
  addr.sin_addr = *((struct in_addr *)*(host->h_addr_list + 0));
#line 72
  tmp___0 = connect(fd, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                    (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 72
  if (tmp___0 == -1) {
    {
#line 74
    close(fd);
    }
#line 75
    return (-1);
  }
#line 83
  return (fd);
}
}
#line 86 "/home/june/collector/temp/axel-2.4/tcp.c"
int get_if_ip(char *iface , char *ip ) 
{ 
  struct ifreq ifr ;
  int fd ;
  int tmp ;
  struct sockaddr_in *x ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 89
  tmp = socket(2, 2, 0);
#line 89
  fd = tmp;
#line 91
  memset((void *)(& ifr), 0, sizeof(struct ifreq ));
#line 93
  strcpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)iface);
#line 94
  ifr.ifr_ifru.ifru_addr.sa_family = (sa_family_t )2;
#line 95
  tmp___1 = ioctl(fd, 35093UL, & ifr);
  }
#line 95
  if (tmp___1 == 0) {
    {
#line 97
    x = (struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr);
#line 98
    tmp___0 = inet_ntoa(x->sin_addr);
#line 98
    strcpy((char */* __restrict  */)ip, (char const   */* __restrict  */)tmp___0);
    }
#line 99
    return (1);
  } else {
#line 103
    return (0);
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 517
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 521
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 524
extern int pthread_cancel(pthread_t __th ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 51 "/home/june/collector/temp/axel-2.4/http.h"
void http_decode(char *s ) ;
#line 59 "/home/june/collector/temp/axel-2.4/conn.h"
int conn_set(conn_t *conn , char *set_url ) ;
#line 60
char *conn_url(conn_t *conn ) ;
#line 61
void conn_disconnect(conn_t *conn ) ;
#line 62
int conn_init(conn_t *conn ) ;
#line 63
int conn_setup(conn_t *conn ) ;
#line 64
int conn_exec(conn_t *conn ) ;
#line 65
int conn_info(conn_t *conn ) ;
#line 108 "/home/june/collector/temp/axel-2.4/axel.h"
axel_t *axel_new(conf_t *conf , int count , void *url ) ;
#line 109
int axel_open(axel_t *axel ) ;
#line 110
void axel_start(axel_t *axel ) ;
#line 111
void axel_do(axel_t *axel ) ;
#line 112
void axel_close(axel_t *axel ) ;
#line 114
double gettime(void) ;
#line 29 "/home/june/collector/temp/axel-2.4/axel.c"
static void save_state(axel_t *axel ) ;
#line 30
static void *setup_thread(void *c ) ;
#line 31
static void axel_message(axel_t *axel , char *format  , ...) ;
#line 32
static void axel_divide(axel_t *axel ) ;
#line 34 "/home/june/collector/temp/axel-2.4/axel.c"
static char *buffer  =    (char *)((void *)0);
#line 37 "/home/june/collector/temp/axel-2.4/axel.c"
axel_t *axel_new(conf_t *conf , int count , void *url ) 
{ 
  search_t *res ;
  axel_t *axel ;
  url_t *u ;
  char *s ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  url_t *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  long long tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 45
  tmp = malloc(sizeof(axel_t ));
#line 45
  axel = (axel_t *)tmp;
#line 46
  memset((void *)axel, 0, sizeof(axel_t ));
#line 47
  axel->conf[0] = *conf;
#line 48
  tmp___0 = malloc(sizeof(conn_t ) * (unsigned long )axel->conf[0].num_connections);
#line 48
  axel->conn = (conn_t *)tmp___0;
#line 49
  memset((void *)axel->conn, 0, sizeof(conn_t ) * (unsigned long )axel->conf[0].num_connections);
  }
#line 50
  if (axel->conf[0].max_speed > 0) {
#line 52
    if ((double )((float )axel->conf[0].max_speed / (float )axel->conf[0].buffer_size) < 0.5) {
#line 54
      if (axel->conf[0].verbose >= 2) {
        {
#line 55
        tmp___1 = gettext("Buffer resized for this speed.");
#line 55
        axel_message(axel, tmp___1);
        }
      }
#line 56
      axel->conf[0].buffer_size = axel->conf[0].max_speed;
    }
#line 58
    axel->delay_time = (int )((((float )1000000 / (float )axel->conf[0].max_speed) * (float )axel->conf[0].buffer_size) * (float )axel->conf[0].num_connections);
  }
#line 60
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 61
    if (1024 > axel->conf[0].buffer_size) {
#line 61
      tmp___2 = 1024;
    } else {
#line 61
      tmp___2 = axel->conf[0].buffer_size;
    }
    {
#line 61
    tmp___3 = malloc((size_t )tmp___2);
#line 61
    buffer = (char *)tmp___3;
    }
  }
#line 63
  if (count == 0) {
    {
#line 65
    tmp___4 = malloc(sizeof(url_t ));
#line 65
    axel->url = (url_t *)tmp___4;
#line 66
    (axel->url)->next = (void *)axel->url;
#line 67
    strncpy((char */* __restrict  */)((axel->url)->text), (char const   */* __restrict  */)((char *)url),
            (size_t )1024);
    }
  } else {
    {
#line 71
    res = (search_t *)url;
#line 72
    tmp___6 = malloc(sizeof(url_t ));
#line 72
    tmp___5 = (url_t *)tmp___6;
#line 72
    axel->url = tmp___5;
#line 72
    u = tmp___5;
#line 73
    i = 0;
    }
    {
#line 73
    while (1) {
      while_continue: /* CIL Label */ ;
#line 73
      if (! (i < count)) {
#line 73
        goto while_break;
      }
      {
#line 75
      strncpy((char */* __restrict  */)(u->text), (char const   */* __restrict  */)((res + i)->url),
              (size_t )1024);
      }
#line 76
      if (i < count - 1) {
        {
#line 78
        u->next = malloc(sizeof(url_t ));
#line 79
        u = (url_t *)u->next;
        }
      } else {
#line 83
        u->next = (void *)axel->url;
      }
#line 73
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 88
  (axel->conn + 0)->conf = axel->conf;
#line 89
  tmp___8 = conn_set(axel->conn + 0, (axel->url)->text);
  }
#line 89
  if (! tmp___8) {
    {
#line 91
    tmp___7 = gettext("Could not parse URL.\n");
#line 91
    axel_message(axel, tmp___7);
#line 92
    axel->ready = -1;
    }
#line 93
    return (axel);
  }
  {
#line 96
  (axel->conn + 0)->local_if = (axel->conf[0].interfaces)->text;
#line 97
  axel->conf[0].interfaces = (if_t *)(axel->conf[0].interfaces)->next;
#line 99
  strncpy((char */* __restrict  */)(axel->filename), (char const   */* __restrict  */)((axel->conn + 0)->file),
          (size_t )1024);
#line 100
  http_decode(axel->filename);
  }
#line 101
  if ((int )axel->filename[0] == 0) {
    {
#line 102
    strncpy((char */* __restrict  */)(axel->filename), (char const   */* __restrict  */)(axel->conf[0].default_filename),
            (size_t )1024);
    }
  }
  {
#line 103
  s = strchr((char const   *)(axel->filename), '?');
  }
#line 103
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 103
    if (axel->conf[0].strip_cgi_parameters) {
#line 104
      *s = (char)0;
    }
  }
  {
#line 106
  tmp___9 = conn_init(axel->conn + 0);
  }
#line 106
  if (! tmp___9) {
    {
#line 108
    axel_message(axel, (axel->conn + 0)->message);
#line 109
    axel->ready = -1;
    }
#line 110
    return (axel);
  }
  {
#line 115
  tmp___10 = conn_info(axel->conn + 0);
  }
#line 115
  if (! tmp___10) {
    {
#line 117
    axel_message(axel, (axel->conn + 0)->message);
#line 118
    axel->ready = -1;
    }
#line 119
    return (axel);
  }
  {
#line 121
  s = conn_url(axel->conn);
#line 122
  strncpy((char */* __restrict  */)((axel->url)->text), (char const   */* __restrict  */)s,
          (size_t )1024);
#line 123
  tmp___12 = (axel->conn + 0)->size;
#line 123
  axel->size = tmp___12;
  }
#line 123
  if (tmp___12 != 2147483647LL) {
#line 125
    if (axel->conf[0].verbose > 0) {
      {
#line 126
      tmp___11 = gettext("File size: %lld bytes");
#line 126
      axel_message(axel, tmp___11, axel->size);
      }
    }
  }
  {
#line 130
  tmp___13 = strchr((char const   *)(axel->filename), '*');
  }
#line 130
  if (tmp___13) {
    {
#line 131
    strncpy((char */* __restrict  */)(axel->filename), (char const   */* __restrict  */)((axel->conn + 0)->file),
            (size_t )1024);
    }
  } else {
    {
#line 130
    tmp___14 = strchr((char const   *)(axel->filename), '?');
    }
#line 130
    if (tmp___14) {
      {
#line 131
      strncpy((char */* __restrict  */)(axel->filename), (char const   */* __restrict  */)((axel->conn + 0)->file),
              (size_t )1024);
      }
    }
  }
#line 133
  return (axel);
}
}
#line 137 "/home/june/collector/temp/axel-2.4/axel.c"
int axel_open(axel_t *axel ) 
{ 
  int i ;
  int fd ;
  long long j ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  long long tmp___9 ;
  __off64_t tmp___10 ;

  {
#line 142
  if (axel->conf[0].verbose > 0) {
    {
#line 143
    tmp = gettext("Opening output file %s");
#line 143
    axel_message(axel, tmp, axel->filename);
    }
  }
  {
#line 144
  snprintf((char */* __restrict  */)buffer, (size_t )1024, (char const   */* __restrict  */)"%s.st",
           axel->filename);
#line 146
  axel->outfd = -1;
  }
#line 150
  if (! (axel->conn + 0)->supported) {
    {
#line 152
    tmp___0 = gettext("Server unsupported, starting from scratch with one connection.");
#line 152
    axel_message(axel, tmp___0);
#line 154
    axel->conf[0].num_connections = 1;
#line 155
    tmp___1 = realloc((void *)axel->conn, sizeof(conn_t ));
#line 155
    axel->conn = (conn_t *)tmp___1;
#line 156
    axel_divide(axel);
    }
  } else {
    {
#line 158
    fd = open((char const   *)buffer, 0);
    }
#line 158
    if (fd != -1) {
      {
#line 160
      read(fd, (void *)(& axel->conf[0].num_connections), sizeof(axel->conf[0].num_connections));
#line 162
      tmp___2 = realloc((void *)axel->conn, sizeof(conn_t ) * (unsigned long )axel->conf[0].num_connections);
#line 162
      axel->conn = (conn_t *)tmp___2;
#line 163
      memset((void *)(axel->conn + 1), 0, sizeof(conn_t ) * (unsigned long )(axel->conf[0].num_connections - 1));
#line 165
      axel_divide(axel);
#line 167
      read(fd, (void *)(& axel->bytes_done), sizeof(axel->bytes_done));
#line 168
      i = 0;
      }
      {
#line 168
      while (1) {
        while_continue: /* CIL Label */ ;
#line 168
        if (! (i < axel->conf[0].num_connections)) {
#line 168
          goto while_break;
        }
        {
#line 169
        read(fd, (void *)(& (axel->conn + i)->currentbyte), sizeof((axel->conn + i)->currentbyte));
#line 168
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 171
      tmp___3 = gettext("State file found: %lld bytes downloaded, %lld to go.");
#line 171
      axel_message(axel, tmp___3, axel->bytes_done, axel->size - axel->bytes_done);
#line 174
      close(fd);
#line 176
      tmp___5 = open((char const   *)(axel->filename), 1, 438);
#line 176
      axel->outfd = tmp___5;
      }
#line 176
      if (tmp___5 == -1) {
        {
#line 178
        tmp___4 = gettext("Error opening local file");
#line 178
        axel_message(axel, tmp___4);
        }
#line 179
        return (0);
      }
    }
  }
#line 184
  if (axel->outfd == -1) {
    {
#line 186
    axel_divide(axel);
#line 188
    tmp___7 = open((char const   *)(axel->filename), 65, 438);
#line 188
    axel->outfd = tmp___7;
    }
#line 188
    if (tmp___7 == -1) {
      {
#line 190
      tmp___6 = gettext("Error opening local file");
#line 190
      axel_message(axel, tmp___6);
      }
#line 191
      return (0);
    }
    {
#line 197
    tmp___10 = lseek(axel->outfd, (__off64_t )axel->size, 0);
    }
#line 197
    if (tmp___10 == -1L) {
#line 197
      if (axel->conf[0].num_connections > 1) {
        {
#line 202
        tmp___8 = gettext("Crappy filesystem/OS.. Working around. :-(");
#line 202
        axel_message(axel, tmp___8);
#line 203
        lseek(axel->outfd, (__off64_t )0, 0);
#line 204
        memset((void *)buffer, 0, (size_t )axel->conf[0].buffer_size);
#line 205
        j = axel->size;
        }
        {
#line 206
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 206
          if (! (j > 0LL)) {
#line 206
            goto while_break___0;
          }
#line 208
          if (j < (long long )axel->conf[0].buffer_size) {
#line 208
            tmp___9 = j;
          } else {
#line 208
            tmp___9 = (long long )axel->conf[0].buffer_size;
          }
          {
#line 208
          write(axel->outfd, (void const   *)buffer, (size_t )tmp___9);
#line 209
          j -= (long long )axel->conf[0].buffer_size;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 214
  return (1);
}
}
#line 218 "/home/june/collector/temp/axel-2.4/axel.c"
void axel_start(axel_t *axel ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;

  {
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (i < axel->conf[0].num_connections)) {
#line 224
      goto while_break;
    }
    {
#line 226
    conn_set(axel->conn + i, (axel->url)->text);
#line 227
    axel->url = (url_t *)(axel->url)->next;
#line 228
    (axel->conn + i)->local_if = (axel->conf[0].interfaces)->text;
#line 229
    axel->conf[0].interfaces = (if_t *)(axel->conf[0].interfaces)->next;
#line 230
    (axel->conn + i)->conf = axel->conf;
    }
#line 231
    if (i) {
#line 231
      (axel->conn + i)->supported = 1;
    }
#line 224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  if (axel->conf[0].verbose > 0) {
    {
#line 235
    tmp = gettext("Starting download");
#line 235
    axel_message(axel, tmp);
    }
  }
#line 237
  i = 0;
  {
#line 237
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 237
    if (! (i < axel->conf[0].num_connections)) {
#line 237
      goto while_break___0;
    }
#line 238
    if ((axel->conn + i)->currentbyte <= (axel->conn + i)->lastbyte) {
#line 240
      if (axel->conf[0].verbose >= 2) {
        {
#line 242
        tmp___0 = gettext("Connection %i downloading from %s:%i using interface %s");
#line 242
        axel_message(axel, tmp___0, i, (axel->conn + i)->host, (axel->conn + i)->port,
                     (axel->conn + i)->local_if);
        }
      }
      {
#line 246
      (axel->conn + i)->state = 1;
#line 247
      tmp___3 = pthread_create((pthread_t */* __restrict  */)((axel->conn + i)->setup_thread),
                               (pthread_attr_t const   */* __restrict  */)((void *)0),
                               & setup_thread, (void */* __restrict  */)(axel->conn + i));
      }
#line 247
      if (tmp___3 != 0) {
        {
#line 249
        tmp___1 = gettext("pthread error!!!");
#line 249
        axel_message(axel, tmp___1);
#line 250
        axel->ready = -1;
        }
      } else {
        {
#line 254
        tmp___2 = gettime();
#line 254
        (axel->conn + i)->last_transfer = (int )tmp___2;
        }
      }
    }
#line 237
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 259
  axel->start_time = gettime();
#line 260
  axel->ready = 0;
  }
#line 261
  return;
}
}
#line 264 "/home/june/collector/temp/axel-2.4/axel.c"
void axel_do(axel_t *axel ) 
{ 
  fd_set fds[1] ;
  int hifd ;
  int i ;
  long long remaining ;
  long long size ;
  struct timeval timeval[1] ;
  double tmp ;
  double tmp___0 ;
  int __d0 ;
  int __d1 ;
  int tmp___1 ;
  double tmp___2 ;
  ssize_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  ssize_t tmp___9 ;
  char *tmp___10 ;
  double tmp___11 ;
  char *tmp___12 ;
  double tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;

  {
  {
#line 272
  tmp___0 = gettime();
  }
#line 272
  if (tmp___0 > (double )axel->next_state) {
    {
#line 274
    save_state(axel);
#line 275
    tmp = gettime();
#line 275
    axel->next_state = (int )(tmp + (double )axel->conf[0].save_state_interval);
    }
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds[0].__fds_bits[0]): "memory");
#line 279
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  hifd = 0;
#line 281
  i = 0;
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 281
    if (! (i < axel->conf[0].num_connections)) {
#line 281
      goto while_break___0;
    }
#line 283
    if ((axel->conn + i)->enabled) {
#line 284
      fds[0].__fds_bits[(axel->conn + i)->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << (axel->conn + i)->fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 285
    if (hifd > (axel->conn + i)->fd) {
#line 285
      hifd = hifd;
    } else {
#line 285
      hifd = (axel->conn + i)->fd;
    }
#line 281
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 287
  if (hifd == 0) {
    {
#line 290
    usleep((__useconds_t )100000);
    }
#line 291
    goto conn_check;
  } else {
    {
#line 295
    timeval[0].tv_sec = (__time_t )0;
#line 296
    timeval[0].tv_usec = (__suseconds_t )100000;
#line 299
    tmp___1 = select(hifd + 1, (fd_set */* __restrict  */)(fds), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(timeval));
    }
#line 299
    if (tmp___1 == -1) {
#line 301
      axel->ready = -1;
#line 302
      return;
    }
  }
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 307
    if (! (i < axel->conf[0].num_connections)) {
#line 307
      goto while_break___1;
    }
#line 308
    if ((axel->conn + i)->enabled) {
#line 309
      if ((fds[0].__fds_bits[(axel->conn + i)->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << (axel->conn + i)->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 311
        tmp___2 = gettime();
#line 311
        (axel->conn + i)->last_transfer = (int )tmp___2;
#line 312
        tmp___3 = read((axel->conn + i)->fd, (void *)buffer, (size_t )axel->conf[0].buffer_size);
#line 312
        size = (long long )tmp___3;
        }
#line 313
        if (size == -1LL) {
#line 315
          if (axel->conf[0].verbose) {
            {
#line 317
            tmp___4 = gettext("Error on connection %i! Connection closed");
#line 317
            axel_message(axel, tmp___4, i);
            }
          }
          {
#line 320
          (axel->conn + i)->enabled = 0;
#line 321
          conn_disconnect(axel->conn + i);
          }
#line 322
          goto __Cont;
        } else
#line 324
        if (size == 0LL) {
#line 326
          if (axel->conf[0].verbose) {
#line 329
            if ((axel->conn + i)->currentbyte < (axel->conn + i)->lastbyte) {
#line 329
              if (axel->size != 2147483647LL) {
                {
#line 331
                tmp___5 = gettext("Connection %i unexpectedly closed");
#line 331
                axel_message(axel, tmp___5, i);
                }
              } else {
                {
#line 335
                tmp___6 = gettext("Connection %i finished");
#line 335
                axel_message(axel, tmp___6, i);
                }
              }
            } else {
              {
#line 335
              tmp___6 = gettext("Connection %i finished");
#line 335
              axel_message(axel, tmp___6, i);
              }
            }
          }
#line 338
          if (! (axel->conn + 0)->supported) {
#line 340
            axel->ready = 1;
          }
          {
#line 342
          (axel->conn + i)->enabled = 0;
#line 343
          conn_disconnect(axel->conn + i);
          }
#line 344
          goto __Cont;
        }
#line 347
        remaining = ((axel->conn + i)->lastbyte - (axel->conn + i)->currentbyte) + 1LL;
#line 348
        if (remaining < size) {
#line 350
          if (axel->conf[0].verbose) {
            {
#line 352
            tmp___7 = gettext("Connection %i finished");
#line 352
            axel_message(axel, tmp___7, i);
            }
          }
          {
#line 354
          (axel->conn + i)->enabled = 0;
#line 355
          conn_disconnect(axel->conn + i);
#line 356
          size = remaining;
          }
        }
        {
#line 360
        lseek(axel->outfd, (__off64_t )(axel->conn + i)->currentbyte, 0);
#line 361
        tmp___9 = write(axel->outfd, (void const   *)buffer, (size_t )size);
        }
#line 361
        if ((long long )tmp___9 != size) {
          {
#line 364
          tmp___8 = gettext("Write error!");
#line 364
          axel_message(axel, tmp___8);
#line 365
          axel->ready = -1;
          }
#line 366
          return;
        }
#line 368
        (axel->conn + i)->currentbyte += size;
#line 369
        axel->bytes_done += size;
      } else {
        {
#line 373
        tmp___11 = gettime();
        }
#line 373
        if (tmp___11 > (double )((axel->conn + i)->last_transfer + axel->conf[0].connection_timeout)) {
#line 375
          if (axel->conf[0].verbose) {
            {
#line 376
            tmp___10 = gettext("Connection %i timed out");
#line 376
            axel_message(axel, tmp___10, i);
            }
          }
          {
#line 377
          conn_disconnect(axel->conn + i);
#line 378
          (axel->conn + i)->enabled = 0;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 307
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 382
  if (axel->ready) {
#line 383
    return;
  }
  conn_check: 
#line 387
  i = 0;
  {
#line 387
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 387
    if (! (i < axel->conf[0].num_connections)) {
#line 387
      goto while_break___2;
    }
#line 389
    if (! (axel->conn + i)->enabled) {
#line 389
      if ((axel->conn + i)->currentbyte < (axel->conn + i)->lastbyte) {
#line 391
        if ((axel->conn + i)->state == 0) {
          {
#line 394
          pthread_join((axel->conn + i)->setup_thread[0], (void **)((void *)0));
#line 396
          conn_set(axel->conn + i, (axel->url)->text);
#line 397
          axel->url = (url_t *)(axel->url)->next;
          }
#line 400
          if (axel->conf[0].verbose >= 2) {
            {
#line 401
            tmp___12 = gettext("Connection %i downloading from %s:%i using interface %s");
#line 401
            axel_message(axel, tmp___12, i, (axel->conn + i)->host, (axel->conn + i)->port,
                         (axel->conn + i)->local_if);
            }
          }
          {
#line 404
          (axel->conn + i)->state = 1;
#line 405
          tmp___15 = pthread_create((pthread_t */* __restrict  */)((axel->conn + i)->setup_thread),
                                    (pthread_attr_t const   */* __restrict  */)((void *)0),
                                    & setup_thread, (void */* __restrict  */)(axel->conn + i));
          }
#line 405
          if (tmp___15 == 0) {
            {
#line 407
            tmp___13 = gettime();
#line 407
            (axel->conn + i)->last_transfer = (int )tmp___13;
            }
          } else {
            {
#line 411
            tmp___14 = gettext("pthread error!!!");
#line 411
            axel_message(axel, tmp___14);
#line 412
            axel->ready = -1;
            }
          }
        } else {
          {
#line 417
          tmp___16 = gettime();
          }
#line 417
          if (tmp___16 > (double )((axel->conn + i)->last_transfer + axel->conf[0].reconnect_delay)) {
            {
#line 419
            pthread_cancel((axel->conn + i)->setup_thread[0]);
#line 420
            (axel->conn + i)->state = 0;
            }
          }
        }
      }
    }
#line 387
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 427
  tmp___17 = gettime();
#line 427
  axel->bytes_per_second = (int )((double )(axel->bytes_done - axel->start_byte) / (tmp___17 - axel->start_time));
#line 428
  axel->finish_time = (int )(axel->start_time + (double )(axel->size - axel->start_byte) / (double )axel->bytes_per_second);
  }
#line 432
  if (axel->conf[0].max_speed > 0) {
#line 434
    if ((double )((float )axel->bytes_per_second / (float )axel->conf[0].max_speed) > 1.05) {
#line 435
      axel->delay_time += 10000;
    } else
#line 436
    if ((double )((float )axel->bytes_per_second / (float )axel->conf[0].max_speed) < 0.95) {
#line 436
      if (axel->delay_time >= 10000) {
#line 437
        axel->delay_time -= 10000;
      } else {
#line 436
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 438
    if ((double )((float )axel->bytes_per_second / (float )axel->conf[0].max_speed) < 0.95) {
#line 439
      axel->delay_time = 0;
    }
    {
#line 440
    usleep((__useconds_t )axel->delay_time);
    }
  }
#line 444
  if (axel->bytes_done == axel->size) {
#line 445
    axel->ready = 1;
  }
#line 446
  return;
}
}
#line 449 "/home/june/collector/temp/axel-2.4/axel.c"
void axel_close(axel_t *axel ) 
{ 
  int i ;
  message_t *m ;

  {
#line 455
  i = 0;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    if (! (i < axel->conf[0].num_connections)) {
#line 455
      goto while_break;
    }
#line 457
    if ((axel->conn + i)->setup_thread[0] != 0UL) {
      {
#line 458
      pthread_cancel((axel->conn + i)->setup_thread[0]);
      }
    }
#line 455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  if (axel->ready == 1) {
    {
#line 463
    snprintf((char */* __restrict  */)buffer, (size_t )1024, (char const   */* __restrict  */)"%s.st",
             axel->filename);
#line 464
    unlink((char const   *)buffer);
    }
  } else
#line 467
  if (axel->bytes_done > 0LL) {
    {
#line 469
    save_state(axel);
    }
  }
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 473
    if (! axel->message) {
#line 473
      goto while_break___0;
    }
    {
#line 475
    m = axel->message;
#line 476
    axel->message = (message_t *)(axel->message)->next;
#line 477
    free((void *)m);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 481
  close(axel->outfd);
#line 482
  i = 0;
  }
  {
#line 482
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 482
    if (! (i < axel->conf[0].num_connections)) {
#line 482
      goto while_break___1;
    }
    {
#line 483
    conn_disconnect(axel->conn + i);
#line 482
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 485
  free((void *)axel->conn);
#line 486
  free((void *)axel);
  }
#line 487
  return;
}
}
#line 490 "/home/june/collector/temp/axel-2.4/axel.c"
double gettime(void) 
{ 
  struct timeval time___0[1] ;

  {
  {
#line 494
  gettimeofday((struct timeval */* __restrict  */)(time___0), (__timezone_ptr_t )0);
  }
#line 495
  return ((double )time___0[0].tv_sec + (double )time___0[0].tv_usec / (double )1000000);
}
}
#line 499 "/home/june/collector/temp/axel-2.4/axel.c"
static void save_state(axel_t *axel ) 
{ 
  int fd ;
  int i ;
  char fn[1028] ;

  {
#line 506
  if (! (axel->conn + 0)->supported) {
#line 507
    return;
  }
  {
#line 509
  snprintf((char */* __restrict  */)(fn), (size_t )1024, (char const   */* __restrict  */)"%s.st",
           axel->filename);
#line 510
  fd = open((char const   *)(fn), 577, 438);
  }
#line 510
  if (fd == -1) {
#line 512
    return;
  }
  {
#line 514
  write(fd, (void const   *)(& axel->conf[0].num_connections), sizeof(axel->conf[0].num_connections));
#line 515
  write(fd, (void const   *)(& axel->bytes_done), sizeof(axel->bytes_done));
#line 516
  i = 0;
  }
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (i < axel->conf[0].num_connections)) {
#line 516
      goto while_break;
    }
    {
#line 518
    write(fd, (void const   *)(& (axel->conn + i)->currentbyte), sizeof((axel->conn + i)->currentbyte));
#line 516
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 520
  close(fd);
  }
#line 521
  return;
}
}
#line 524 "/home/june/collector/temp/axel-2.4/axel.c"
static void *setup_thread(void *c ) 
{ 
  conn_t *conn ;
  int oldstate ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 526
  conn = (conn_t *)c;
#line 530
  pthread_setcancelstate(0, & oldstate);
#line 531
  pthread_setcanceltype(1, & oldstate);
#line 533
  tmp___2 = conn_setup(conn);
  }
#line 533
  if (tmp___2) {
    {
#line 535
    tmp = gettime();
#line 535
    conn->last_transfer = (int )tmp;
#line 536
    tmp___1 = conn_exec(conn);
    }
#line 536
    if (tmp___1) {
      {
#line 538
      tmp___0 = gettime();
#line 538
      conn->last_transfer = (int )tmp___0;
#line 539
      conn->enabled = 1;
#line 540
      conn->state = 0;
      }
#line 541
      return ((void *)0);
    }
  }
  {
#line 545
  conn_disconnect(conn);
#line 546
  conn->state = 0;
  }
#line 547
  return ((void *)0);
}
}
#line 551 "/home/june/collector/temp/axel-2.4/axel.c"
static void axel_message(axel_t *axel , char *format  , ...) 
{ 
  message_t *m ;
  void *tmp ;
  message_t *n ;
  va_list params ;

  {
  {
#line 553
  tmp = malloc(sizeof(message_t ));
#line 553
  m = (message_t *)tmp;
#line 553
  n = axel->message;
#line 556
  memset((void *)m, 0, sizeof(message_t ));
#line 557
  __builtin_va_start(params, format);
#line 558
  vsnprintf((char */* __restrict  */)(m->text), (size_t )1024, (char const   */* __restrict  */)format,
            params);
#line 559
  __builtin_va_end(params);
  }
#line 561
  if ((unsigned long )axel->message == (unsigned long )((void *)0)) {
#line 563
    axel->message = m;
  } else {
    {
#line 567
    while (1) {
      while_continue: /* CIL Label */ ;
#line 567
      if (! ((unsigned long )n->next != (unsigned long )((void *)0))) {
#line 567
        goto while_break;
      }
#line 568
      n = (message_t *)n->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 569
    n->next = (void *)m;
  }
#line 571
  return;
}
}
#line 574 "/home/june/collector/temp/axel-2.4/axel.c"
static void axel_divide(axel_t *axel ) 
{ 
  int i ;

  {
#line 578
  (axel->conn + 0)->currentbyte = 0LL;
#line 579
  (axel->conn + 0)->lastbyte = axel->size / (long long )axel->conf[0].num_connections - 1LL;
#line 580
  i = 1;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (i < axel->conf[0].num_connections)) {
#line 580
      goto while_break;
    }
#line 585
    (axel->conn + i)->currentbyte = (axel->conn + (i - 1))->lastbyte + 1LL;
#line 586
    (axel->conn + i)->lastbyte = (axel->conn + i)->currentbyte + axel->size / (long long )axel->conf[0].num_connections;
#line 580
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 588
  (axel->conn + (axel->conf[0].num_connections - 1))->lastbyte = axel->size - 1LL;
#line 592
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 40 "/home/june/collector/temp/axel-2.4/ftp.h"
int ftp_connect(ftp_t *conn , char *host , int port , char *user , char *pass ) ;
#line 41
void ftp_disconnect(ftp_t *conn ) ;
#line 42
int ftp_wait(ftp_t *conn ) ;
#line 43
int ftp_command(ftp_t *conn , char *format  , ...) ;
#line 44
int ftp_cwd(ftp_t *conn , char *cwd ) ;
#line 45
int ftp_data(ftp_t *conn ) ;
#line 46
long long ftp_size(ftp_t *conn , char *file , int maxredir ) ;
#line 28 "/home/june/collector/temp/axel-2.4/ftp.c"
int ftp_connect(ftp_t *conn , char *host , int port , char *user , char *pass ) 
{ 
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 30
  conn->data_fd = -1;
#line 31
  tmp = malloc((size_t )1024);
#line 31
  conn->message = (char *)tmp;
#line 33
  tmp___1 = tcp_connect(host, port, conn->local_if);
#line 33
  conn->fd = tmp___1;
  }
#line 33
  if (tmp___1 == -1) {
    {
#line 35
    tmp___0 = gettext("Unable to connect to server %s:%i\n");
#line 35
    sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp___0,
            host, port);
    }
#line 36
    return (0);
  }
  {
#line 39
  tmp___2 = ftp_wait(conn);
  }
#line 39
  if (tmp___2 / 100 != 2) {
#line 40
    return (0);
  }
  {
#line 42
  ftp_command(conn, (char *)"USER %s", user);
#line 43
  tmp___4 = ftp_wait(conn);
  }
#line 43
  if (tmp___4 / 100 != 2) {
#line 45
    if (conn->status / 100 == 3) {
      {
#line 47
      ftp_command(conn, (char *)"PASS %s", pass);
#line 48
      tmp___3 = ftp_wait(conn);
      }
#line 48
      if (tmp___3 / 100 != 2) {
#line 49
        return (0);
      }
    } else {
#line 53
      return (0);
    }
  }
  {
#line 58
  ftp_command(conn, (char *)"TYPE I");
#line 59
  tmp___5 = ftp_wait(conn);
  }
#line 59
  if (tmp___5 / 100 != 2) {
#line 60
    return (0);
  }
#line 62
  return (1);
}
}
#line 65 "/home/june/collector/temp/axel-2.4/ftp.c"
void ftp_disconnect(ftp_t *conn ) 
{ 
  int tmp ;

  {
#line 67
  if (conn->fd > 0) {
    {
#line 68
    close(conn->fd);
    }
  }
#line 69
  if (conn->data_fd > 0) {
    {
#line 70
    close(conn->data_fd);
    }
  }
#line 71
  if (conn->message) {
    {
#line 73
    free((void *)conn->message);
#line 74
    conn->message = (char *)((void *)0);
    }
  }
#line 77
  conn->cwd[0] = (char)0;
#line 78
  tmp = -1;
#line 78
  conn->data_fd = tmp;
#line 78
  conn->fd = tmp;
#line 79
  return;
}
}
#line 82 "/home/june/collector/temp/axel-2.4/ftp.c"
int ftp_cwd(ftp_t *conn , char *cwd ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 85
  tmp = strncmp((char const   *)(conn->cwd), (char const   *)cwd, (size_t )1024);
  }
#line 85
  if (tmp == 0) {
#line 86
    return (1);
  }
  {
#line 88
  ftp_command(conn, (char *)"CWD %s", cwd);
#line 89
  tmp___1 = ftp_wait(conn);
  }
#line 89
  if (tmp___1 / 100 != 2) {
    {
#line 91
    tmp___0 = gettext("Can\'t change directory to %s\n");
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            cwd);
    }
#line 92
    return (0);
  }
  {
#line 95
  strncpy((char */* __restrict  */)(conn->cwd), (char const   */* __restrict  */)cwd,
          (size_t )1024);
  }
#line 97
  return (1);
}
}
#line 101 "/home/june/collector/temp/axel-2.4/ftp.c"
long long ftp_size(ftp_t *conn , char *file , int maxredir ) 
{ 
  long long i ;
  long long j ;
  long long size ;
  char *reply ;
  char *s ;
  char fn[1024] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  ssize_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  long long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 103
  size = 1024LL;
#line 107
  tmp___1 = strchr((char const   *)file, '*');
  }
#line 107
  if (! tmp___1) {
    {
#line 107
    tmp___2 = strchr((char const   *)file, '?');
    }
#line 107
    if (! tmp___2) {
      {
#line 109
      ftp_command(conn, (char *)"SIZE %s", file);
#line 110
      tmp___0 = ftp_wait(conn);
      }
#line 110
      if (tmp___0 / 100 == 2) {
        {
#line 112
        sscanf((char const   */* __restrict  */)conn->message, (char const   */* __restrict  */)"%*i %lld",
               & i);
        }
#line 113
        return (i);
      } else
#line 115
      if (conn->status / 10 != 50) {
        {
#line 117
        tmp = gettext("File not found.\n");
#line 117
        sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp);
        }
#line 118
        return (-1LL);
      }
    }
  }
#line 122
  if (maxredir == 0) {
    {
#line 124
    tmp___3 = gettext("Too many redirects.\n");
#line 124
    sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp___3);
    }
#line 125
    return (-1LL);
  }
  {
#line 128
  tmp___4 = ftp_data(conn);
  }
#line 128
  if (! tmp___4) {
#line 129
    return (-1LL);
  }
  {
#line 131
  ftp_command(conn, (char *)"LIST %s", file);
#line 132
  tmp___5 = ftp_wait(conn);
  }
#line 132
  if (tmp___5 / 100 != 1) {
#line 133
    return (-1LL);
  }
  {
#line 136
  tmp___6 = malloc((size_t )size);
#line 136
  reply = (char *)tmp___6;
#line 137
  memset((void *)reply, 0, (size_t )size);
#line 138
  *reply = (char )'\n';
#line 139
  i = 1LL;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    tmp___8 = read(conn->data_fd, (void *)(reply + i), (size_t )((size - i) - 3LL));
#line 140
    j = (long long )tmp___8;
    }
#line 140
    if (! (j > 0LL)) {
#line 140
      goto while_break;
    }
#line 142
    i += j;
#line 143
    *(reply + i) = (char)0;
#line 144
    if (size - i <= 10LL) {
      {
#line 146
      size *= 2LL;
#line 147
      tmp___7 = realloc((void *)reply, (size_t )size);
#line 147
      reply = (char *)tmp___7;
#line 148
      memset((void *)(reply + size / 2LL), 0, (size_t )(size / 2LL));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  close(conn->data_fd);
#line 152
  conn->data_fd = -1;
#line 154
  tmp___9 = ftp_wait(conn);
  }
#line 154
  if (tmp___9 / 100 != 2) {
    {
#line 156
    free((void *)reply);
    }
#line 157
    return (-1LL);
  }
#line 165
  j = 0LL;
#line 166
  i = 1LL;
  {
#line 166
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 166
    if (*(reply + i)) {
#line 166
      if (! *(reply + (i + 1LL))) {
#line 166
        goto while_break___0;
      }
    } else {
#line 166
      goto while_break___0;
    }
#line 167
    if ((int )*(reply + i) == 45) {
#line 168
      j ++;
    } else
#line 167
    if ((int )*(reply + i) == 108) {
#line 168
      j ++;
    } else {
      {
#line 170
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 170
        if ((int )*(reply + i) != 10) {
#line 170
          if (! *(reply + i)) {
#line 170
            goto while_break___1;
          }
        } else {
#line 170
          goto while_break___1;
        }
#line 171
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 166
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  if (j != 1LL) {
#line 176
    if (j == 0LL) {
      {
#line 177
      tmp___10 = gettext("File not found.\n");
#line 177
      sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp___10);
      }
    } else {
      {
#line 179
      tmp___11 = gettext("Multiple matches for this URL.\n");
#line 179
      sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp___11);
      }
    }
    {
#line 180
    free((void *)reply);
    }
#line 181
    return (-1LL);
  }
  {
#line 185
  s = strstr((char const   *)reply, "\nl");
  }
#line 185
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 188
    sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%*s %*i %*s %*s %*i %*s %*i %*s %100s",
           fn);
#line 189
    strcpy((char */* __restrict  */)file, (char const   */* __restrict  */)(fn));
#line 192
    tmp___12 = strstr((char const   *)s, "->");
#line 192
    strncpy((char */* __restrict  */)(fn), (char const   */* __restrict  */)(tmp___12 + 3),
            (size_t )1024);
#line 193
    free((void *)reply);
#line 194
    reply = strchr((char const   *)(fn), '\r');
    }
#line 194
    if ((unsigned long )reply != (unsigned long )((void *)0)) {
#line 195
      *reply = (char)0;
    }
    {
#line 196
    reply = strchr((char const   *)(fn), '\n');
    }
#line 196
    if ((unsigned long )reply != (unsigned long )((void *)0)) {
#line 197
      *reply = (char)0;
    }
    {
#line 198
    tmp___13 = ftp_size(conn, fn, maxredir - 1);
    }
#line 198
    return (tmp___13);
  } else {
    {
#line 204
    s = strstr((char const   *)reply, "\n-");
#line 205
    tmp___14 = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%*s %*i %*s %*s %lld %*s %*i %*s %100s",
                      & size, fn);
#line 205
    i = (long long )tmp___14;
    }
#line 206
    if (i < 2LL) {
      {
#line 208
      tmp___15 = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%*s %*i %lld %*i %*s %*i %*i %100s",
                        & size, fn);
#line 208
      i = (long long )tmp___15;
      }
#line 209
      if (i < 2LL) {
#line 211
        return (-2LL);
      }
    }
    {
#line 214
    strcpy((char */* __restrict  */)file, (char const   */* __restrict  */)(fn));
#line 216
    free((void *)reply);
    }
#line 217
    return (size);
  }
}
}
#line 222 "/home/june/collector/temp/axel-2.4/ftp.c"
int ftp_data(ftp_t *conn ) 
{ 
  int i ;
  int info[6] ;
  char host[1024] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 228
  if (conn->data_fd > 0) {
#line 229
    return (0);
  }
  {
#line 233
  ftp_command(conn, (char *)"PASV");
#line 234
  tmp = ftp_wait(conn);
  }
#line 234
  if (tmp / 100 != 2) {
#line 235
    return (0);
  }
#line 236
  host[0] = (char)0;
#line 237
  i = 0;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! *(conn->message + i)) {
#line 237
      goto while_break;
    }
    {
#line 239
    tmp___0 = sscanf((char const   */* __restrict  */)(conn->message + i), (char const   */* __restrict  */)"%i,%i,%i,%i,%i,%i",
                     & info[0], & info[1], & info[2], & info[3], & info[4], & info[5]);
    }
#line 239
    if (tmp___0 == 6) {
      {
#line 243
      sprintf((char */* __restrict  */)(host), (char const   */* __restrict  */)"%i.%i.%i.%i",
              info[0], info[1], info[2], info[3]);
      }
#line 245
      goto while_break;
    }
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  if (! host[0]) {
    {
#line 250
    tmp___1 = gettext("Error opening passive data connection.\n");
#line 250
    sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp___1);
    }
#line 251
    return (0);
  }
  {
#line 253
  tmp___3 = tcp_connect(host, info[4] * 256 + info[5], conn->local_if);
#line 253
  conn->data_fd = tmp___3;
  }
#line 253
  if (tmp___3 == -1) {
    {
#line 256
    tmp___2 = gettext("Error opening passive data connection.\n");
#line 256
    sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp___2);
    }
#line 257
    return (0);
  }
#line 260
  return (1);
}
}
#line 270 "/home/june/collector/temp/axel-2.4/ftp.c"
int ftp_command(ftp_t *conn , char *format  , ...) 
{ 
  va_list params ;
  char cmd[1024] ;
  char *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 275
  __builtin_va_start(params, format);
#line 276
  vsnprintf((char */* __restrict  */)(cmd), (size_t )1021, (char const   */* __restrict  */)format,
            params);
#line 277
  strcat((char */* __restrict  */)(cmd), (char const   */* __restrict  */)"\r\n");
#line 278
  __builtin_va_end(params);
#line 284
  tmp___0 = strlen((char const   *)(cmd));
#line 284
  tmp___1 = write(conn->fd, (void const   *)(cmd), tmp___0);
#line 284
  tmp___2 = strlen((char const   *)(cmd));
  }
#line 284
  if ((size_t )tmp___1 != tmp___2) {
    {
#line 286
    tmp = gettext("Error writing command %s\n");
#line 286
    sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp,
            format);
    }
#line 287
    return (0);
  } else {
#line 291
    return (1);
  }
}
}
#line 297 "/home/june/collector/temp/axel-2.4/ftp.c"
int ftp_wait(ftp_t *conn ) 
{ 
  int size ;
  int r ;
  int complete ;
  int i ;
  int j ;
  char *s ;
  void *tmp ;
  ssize_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 299
  size = 1024;
#line 299
  r = 0;
#line 302
  tmp = realloc((void *)conn->message, (size_t )size);
#line 302
  conn->message = (char *)tmp;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 306
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 308
      tmp___0 = read(conn->fd, (void *)(conn->message + r), (size_t )1);
#line 308
      i = (int )tmp___0;
#line 308
      r += i;
      }
#line 309
      if (i <= 0) {
        {
#line 311
        tmp___1 = gettext("Connection gone.\n");
#line 311
        sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp___1);
        }
#line 312
        return (-1);
      }
#line 314
      if (r + 10 >= size) {
        {
#line 316
        size += 1024;
#line 317
        tmp___2 = realloc((void *)conn->message, (size_t )size);
#line 317
        conn->message = (char *)tmp___2;
        }
      }
#line 306
      if (! ((int )*(conn->message + (r - 1)) != 10)) {
#line 306
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 321
    *(conn->message + r) = (char)0;
#line 322
    sscanf((char const   */* __restrict  */)conn->message, (char const   */* __restrict  */)"%i",
           & conn->status);
    }
#line 323
    if ((int )*(conn->message + 3) == 32) {
#line 324
      complete = 1;
    } else {
#line 326
      complete = 0;
    }
#line 328
    i = 0;
    {
#line 328
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 328
      if (! *(conn->message + i)) {
#line 328
        goto while_break___1;
      }
#line 328
      if ((int )*(conn->message + i) == 10) {
#line 330
        if (complete == 1) {
#line 332
          complete = 2;
#line 333
          goto while_break___1;
        }
#line 335
        if ((int )*(conn->message + (i + 4)) == 32) {
          {
#line 337
          j = -1;
#line 338
          sscanf((char const   */* __restrict  */)(conn->message + (i + 1)), (char const   */* __restrict  */)"%3i",
                 & j);
          }
#line 339
          if (j == conn->status) {
#line 340
            complete = 1;
          }
        }
      }
#line 328
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 304
    if (! (complete != 2)) {
#line 304
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 350
  s = strchr((char const   *)conn->message, '\n');
  }
#line 350
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 351
    *s = (char)0;
  }
  {
#line 352
  s = strchr((char const   *)conn->message, '\r');
  }
#line 352
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 353
    *s = (char)0;
  }
  {
#line 354
  tmp___6 = strlen((char const   *)conn->message);
  }
#line 354
  if (tmp___6 + 1UL > 1024UL) {
    {
#line 354
    tmp___4 = strlen((char const   *)conn->message);
#line 354
    tmp___5 = tmp___4 + 1UL;
    }
  } else {
#line 354
    tmp___5 = (size_t )1024;
  }
  {
#line 354
  tmp___7 = realloc((void *)conn->message, tmp___5);
#line 354
  conn->message = (char *)tmp___7;
  }
#line 356
  return (conn->status);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 431
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 580
extern int putchar(int __c ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 55 "/home/june/collector/temp/axel-2.4/conf.h"
int conf_init(conf_t *conf ) ;
#line 35 "/home/june/collector/temp/axel-2.4/search.h"
int search_makelist(search_t *results , char *url ) ;
#line 36
int search_getspeeds(search_t *results , int count ) ;
#line 37
void search_sortlist(search_t *results , int count ) ;
#line 28 "/home/june/collector/temp/axel-2.4/text.c"
static void stop(int signal___0 ) ;
#line 29
static char *size_human(long long value ) ;
#line 30
static char *time_human(int value ) ;
#line 31
static void print_commas(long long bytes_done ) ;
#line 32
static void print_alternate_output(axel_t *axel ) ;
#line 33
static void print_help(void) ;
#line 34
static void print_version(void) ;
#line 35
static void print_messages(axel_t *axel ) ;
#line 37 "/home/june/collector/temp/axel-2.4/text.c"
int run  =    1;
#line 42 "/home/june/collector/temp/axel-2.4/text.c"
static struct option axel_options[13]  = 
#line 42
  {      {"max-speed", 1, (int *)((void *)0), 's'}, 
        {"num-connections", 1, (int *)((void *)0), 'n'}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"search", 2, (int *)((void *)0), 'S'}, 
        {"no-proxy", 0, (int *)((void *)0), 'N'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"alternate", 0, (int *)((void *)0), 'a'}, 
        {"header", 1, (int *)((void *)0), 'H'}, 
        {"user-agent", 1, (int *)((void *)0), 'U'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 62 "/home/june/collector/temp/axel-2.4/text.c"
static char string___0[1024]  ;
#line 65 "/home/june/collector/temp/axel-2.4/text.c"
int main(int argc , char **argv ) 
{ 
  char fn[1024] ;
  unsigned int tmp ;
  int do_search ;
  search_t *search ;
  conf_t conf[1] ;
  axel_t *axel ;
  int i ;
  int j ;
  int cur_head ;
  char *s ;
  int tmp___0 ;
  int option ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  void *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  void *tmp___19 ;
  struct stat buf ;
  size_t fnlen ;
  size_t tmp___20 ;
  size_t axelfnlen ;
  size_t tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  long long prev ;
  long long done ;
  long long tmp___35 ;
  long long tmp___36 ;
  char *tmp___37 ;
  double tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;

  {
#line 67
  fn[0] = (char )'\000';
#line 67
  tmp = 1U;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (tmp >= 1024U) {
#line 67
      goto while_break;
    }
#line 67
    fn[tmp] = (char)0;
#line 67
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  do_search = 0;
#line 72
  cur_head = 0;
#line 76
  setlocale(6, "");
#line 77
  bindtextdomain("axel", "/usr/local/share/locale");
#line 78
  textdomain("axel");
#line 81
  tmp___0 = conf_init(conf);
  }
#line 81
  if (! tmp___0) {
#line 83
    return (1);
  }
#line 86
  opterr = 0;
#line 88
  j = -1;
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 93
    option = getopt_long(argc, (char * const  *)argv, "s:n:o:S::NqvhVaH:U:", (struct option  const  *)(axel_options),
                         (int *)((void *)0));
    }
#line 94
    if (option == -1) {
#line 95
      goto while_break___0;
    }
    {
#line 99
    if (option == 85) {
#line 99
      goto case_85;
    }
#line 102
    if (option == 72) {
#line 102
      goto case_72;
    }
#line 105
    if (option == 115) {
#line 105
      goto case_115;
    }
#line 112
    if (option == 110) {
#line 112
      goto case_110;
    }
#line 119
    if (option == 111) {
#line 119
      goto case_111;
    }
#line 122
    if (option == 83) {
#line 122
      goto case_83;
    }
#line 131
    if (option == 97) {
#line 131
      goto case_97;
    }
#line 134
    if (option == 78) {
#line 134
      goto case_78;
    }
#line 137
    if (option == 104) {
#line 137
      goto case_104;
    }
#line 140
    if (option == 118) {
#line 140
      goto case_118;
    }
#line 146
    if (option == 86) {
#line 146
      goto case_86;
    }
#line 149
    if (option == 113) {
#line 149
      goto case_113;
    }
#line 158
    goto switch_default;
    case_85: /* CIL Label */ 
    {
#line 100
    strncpy((char */* __restrict  */)(conf[0].user_agent), (char const   */* __restrict  */)optarg,
            (size_t )1024);
    }
#line 101
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 103
    tmp___1 = cur_head;
#line 103
    cur_head ++;
#line 103
    strncpy((char */* __restrict  */)(conf[0].add_header[tmp___1]), (char const   */* __restrict  */)optarg,
            (size_t )1024);
    }
#line 104
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 106
    tmp___2 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & conf[0].max_speed);
    }
#line 106
    if (! tmp___2) {
      {
#line 108
      print_help();
      }
#line 109
      return (1);
    }
#line 111
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 113
    tmp___3 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                     & conf[0].num_connections);
    }
#line 113
    if (! tmp___3) {
      {
#line 115
      print_help();
      }
#line 116
      return (1);
    }
#line 118
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 120
    strncpy((char */* __restrict  */)(fn), (char const   */* __restrict  */)optarg,
            (size_t )1024);
    }
#line 121
    goto switch_break;
    case_83: /* CIL Label */ 
#line 123
    do_search = 1;
#line 124
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
      {
#line 125
      tmp___4 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i",
                       & conf[0].search_top);
      }
#line 125
      if (! tmp___4) {
        {
#line 127
        print_help();
        }
#line 128
        return (1);
      }
    }
#line 130
    goto switch_break;
    case_97: /* CIL Label */ 
#line 132
    conf[0].alternate_output = 1;
#line 133
    goto switch_break;
    case_78: /* CIL Label */ 
#line 135
    conf[0].http_proxy[0] = (char)0;
#line 136
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 138
    print_help();
    }
#line 139
    return (0);
    case_118: /* CIL Label */ 
#line 141
    if (j == -1) {
#line 142
      j = 1;
    } else {
#line 144
      j ++;
    }
#line 145
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 147
    print_version();
    }
#line 148
    return (0);
    case_113: /* CIL Label */ 
    {
#line 150
    close(1);
#line 151
    conf[0].verbose = -1;
#line 152
    tmp___6 = open("/dev/null", 1);
    }
#line 152
    if (tmp___6 != 1) {
      {
#line 154
      tmp___5 = gettext("Can\'t redirect stdout to /dev/null.\n");
#line 154
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5);
      }
#line 155
      return (1);
    }
#line 157
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 159
    print_help();
    }
#line 160
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 163
  conf[0].add_header_count = cur_head;
#line 164
  if (j > -1) {
#line 165
    conf[0].verbose = j;
  }
#line 167
  if (argc - optind == 0) {
    {
#line 169
    print_help();
    }
#line 170
    return (1);
  } else {
    {
#line 172
    tmp___12 = strcmp((char const   *)*(argv + optind), "-");
    }
#line 172
    if (tmp___12 == 0) {
      {
#line 174
      tmp___7 = malloc((size_t )1024);
#line 174
      s = (char *)tmp___7;
#line 175
      tmp___9 = scanf((char const   */* __restrict  */)"%1024[^\n]s", s);
      }
#line 175
      if (tmp___9 != 1) {
        {
#line 176
        tmp___8 = gettext("Error when trying to read URL (Too long?).\n");
#line 176
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8);
        }
#line 177
        return (1);
      }
    } else {
      {
#line 182
      s = *(argv + optind);
#line 183
      tmp___11 = strlen((char const   *)s);
      }
#line 183
      if (tmp___11 > 1024UL) {
        {
#line 185
        tmp___10 = gettext("Can\'t handle URLs of length over %d\n");
#line 185
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
                1024);
        }
#line 186
        return (1);
      }
    }
  }
  {
#line 190
  tmp___13 = gettext("Initializing download: %s\n");
#line 190
  printf((char const   */* __restrict  */)tmp___13, s);
  }
#line 191
  if (do_search) {
    {
#line 193
    tmp___14 = malloc(sizeof(search_t ) * (unsigned long )(conf[0].search_amount + 1));
#line 193
    search = (search_t *)tmp___14;
#line 194
    memset((void *)search, 0, sizeof(search_t ) * (unsigned long )(conf[0].search_amount + 1));
#line 195
    (search + 0)->conf = conf;
    }
#line 196
    if (conf[0].verbose) {
      {
#line 197
      tmp___15 = gettext("Doing search...\n");
#line 197
      printf((char const   */* __restrict  */)tmp___15);
      }
    }
    {
#line 198
    i = search_makelist(search, s);
    }
#line 199
    if (i < 0) {
      {
#line 201
      tmp___16 = gettext("File not found\n");
#line 201
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16);
      }
#line 202
      return (1);
    }
#line 204
    if (conf[0].verbose) {
      {
#line 205
      tmp___17 = gettext("Testing speeds, this can take a while...\n");
#line 205
      printf((char const   */* __restrict  */)tmp___17);
      }
    }
    {
#line 206
    j = search_getspeeds(search, i);
#line 207
    search_sortlist(search, i);
    }
#line 208
    if (conf[0].verbose) {
      {
#line 210
      tmp___18 = gettext("%i usable servers found, will use these URLs:\n");
#line 210
      printf((char const   */* __restrict  */)tmp___18, j);
      }
#line 211
      if (j < conf[0].search_top) {
#line 211
        j = j;
      } else {
#line 211
        j = conf[0].search_top;
      }
      {
#line 212
      printf((char const   */* __restrict  */)"%-60s %15s\n", "URL", "Speed");
#line 213
      i = 0;
      }
      {
#line 213
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 213
        if (! (i < j)) {
#line 213
          goto while_break___1;
        }
        {
#line 214
        printf((char const   */* __restrict  */)"%-70.70s %5i\n", (search + i)->url,
               (search + i)->speed);
#line 213
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 215
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 217
    axel = axel_new(conf, j, (void *)search);
#line 218
    free((void *)search);
    }
#line 219
    if (axel->ready == -1) {
      {
#line 221
      print_messages(axel);
#line 222
      axel_close(axel);
      }
#line 223
      return (1);
    }
  } else
#line 226
  if (argc - optind == 1) {
    {
#line 228
    axel = axel_new(conf, 0, (void *)s);
    }
#line 229
    if (axel->ready == -1) {
      {
#line 231
      print_messages(axel);
#line 232
      axel_close(axel);
      }
#line 233
      return (1);
    }
  } else {
    {
#line 238
    tmp___19 = malloc(sizeof(search_t ) * (unsigned long )(argc - optind));
#line 238
    search = (search_t *)tmp___19;
#line 239
    memset((void *)search, 0, sizeof(search_t ) * (unsigned long )(argc - optind));
#line 240
    i = 0;
    }
    {
#line 240
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 240
      if (! (i < argc - optind)) {
#line 240
        goto while_break___2;
      }
      {
#line 241
      strncpy((char */* __restrict  */)((search + i)->url), (char const   */* __restrict  */)*(argv + (optind + i)),
              (size_t )1024);
#line 240
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 242
    axel = axel_new(conf, argc - optind, (void *)search);
#line 243
    free((void *)search);
    }
#line 244
    if (axel->ready == -1) {
      {
#line 246
      print_messages(axel);
#line 247
      axel_close(axel);
      }
#line 248
      return (1);
    }
  }
  {
#line 251
  print_messages(axel);
  }
#line 252
  if ((unsigned long )s != (unsigned long )*(argv + optind)) {
    {
#line 254
    free((void *)s);
    }
  }
#line 257
  if (fn[0]) {
    {
#line 261
    tmp___23 = stat((char const   */* __restrict  */)(fn), (struct stat */* __restrict  */)(& buf));
    }
#line 261
    if (tmp___23 == 0) {
#line 263
      if ((buf.st_mode & 61440U) == 16384U) {
        {
#line 265
        tmp___20 = strlen((char const   *)(fn));
#line 265
        fnlen = tmp___20;
#line 266
        tmp___21 = strlen((char const   *)(axel->filename));
#line 266
        axelfnlen = tmp___21;
        }
#line 268
        if (((fnlen + 1UL) + axelfnlen) + 1UL > 1024UL) {
          {
#line 269
          tmp___22 = gettext("Filename too long!\n");
#line 269
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22);
          }
#line 270
          return (1);
        }
        {
#line 273
        fn[fnlen] = (char )'/';
#line 274
        memcpy((void */* __restrict  */)((fn + fnlen) + 1), (void const   */* __restrict  */)(axel->filename),
               axelfnlen);
#line 275
        fn[(fnlen + 1UL) + axelfnlen] = (char )'\000';
        }
      }
    }
    {
#line 278
    sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)"%s.st",
            fn);
#line 279
    tmp___26 = access((char const   *)(fn), 0);
    }
#line 279
    if (tmp___26 == 0) {
      {
#line 279
      tmp___25 = access((char const   *)(string___0), 0);
      }
#line 279
      if (tmp___25 != 0) {
        {
#line 281
        tmp___24 = gettext("No state file, cannot resume!\n");
#line 281
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24);
        }
#line 282
        return (1);
      }
    }
    {
#line 284
    tmp___29 = access((char const   *)(string___0), 0);
    }
#line 284
    if (tmp___29 == 0) {
      {
#line 284
      tmp___28 = access((char const   *)(fn), 0);
      }
#line 284
      if (tmp___28 != 0) {
        {
#line 286
        tmp___27 = gettext("State file found, but no downloaded data. Starting from scratch.\n");
#line 286
        printf((char const   */* __restrict  */)tmp___27);
#line 287
        unlink((char const   *)(string___0));
        }
      }
    }
    {
#line 289
    strcpy((char */* __restrict  */)(axel->filename), (char const   */* __restrict  */)(fn));
    }
  } else {
    {
#line 294
    i = 0;
#line 295
    tmp___30 = strlen((char const   *)(axel->filename));
#line 295
    s = axel->filename + tmp___30;
    }
    {
#line 296
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 298
      sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)"%s.st",
              axel->filename);
#line 299
      tmp___33 = access((char const   *)(axel->filename), 0);
      }
#line 299
      if (tmp___33 == 0) {
#line 301
        if ((axel->conn + 0)->supported) {
          {
#line 303
          tmp___31 = access((char const   *)(string___0), 0);
          }
#line 303
          if (tmp___31 == 0) {
#line 304
            goto while_break___3;
          }
        }
      } else {
        {
#line 309
        tmp___32 = access((char const   *)(string___0), 0);
        }
#line 309
        if (tmp___32) {
#line 310
          goto while_break___3;
        }
      }
      {
#line 312
      sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)".%i",
              i);
#line 313
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 317
  tmp___34 = axel_open(axel);
  }
#line 317
  if (! tmp___34) {
    {
#line 319
    print_messages(axel);
    }
#line 320
    return (1);
  }
  {
#line 322
  print_messages(axel);
#line 323
  axel_start(axel);
#line 324
  print_messages(axel);
  }
#line 326
  if (conf[0].alternate_output) {
    {
#line 328
    putchar('\n');
    }
  } else
#line 332
  if (axel->bytes_done > 0LL) {
    {
#line 334
    putchar('\n');
#line 335
    print_commas(axel->bytes_done);
    }
  }
  {
#line 338
  axel->start_byte = axel->bytes_done;
#line 341
  signal(2, & stop);
#line 342
  signal(15, & stop);
  }
  {
#line 344
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 344
    if (! axel->ready) {
#line 344
      if (! run) {
#line 344
        goto while_break___4;
      }
    } else {
#line 344
      goto while_break___4;
    }
    {
#line 348
    prev = axel->bytes_done;
#line 349
    axel_do(axel);
    }
#line 351
    if (conf[0].alternate_output) {
#line 353
      if (! axel->message) {
#line 353
        if (prev != axel->bytes_done) {
          {
#line 354
          print_alternate_output(axel);
          }
        }
      }
    } else {
#line 359
      done = axel->bytes_done / 1024LL - prev / 1024LL;
#line 360
      if (done) {
#line 360
        if (conf[0].verbose > -1) {
#line 362
          i = 0;
          {
#line 362
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 362
            if (! ((long long )i < done)) {
#line 362
              goto while_break___5;
            }
#line 364
            i = (int )((long long )i + prev / 1024LL);
#line 365
            if (i % 50 == 0) {
#line 367
              if (prev >= 1024LL) {
                {
#line 368
                printf((char const   */* __restrict  */)"  [%6.1fKB/s]", (double )axel->bytes_per_second / (double )1024);
                }
              }
#line 369
              if (axel->size < 10240000LL) {
#line 370
                if (100LL < (long long )(102400 * i) / axel->size) {
#line 370
                  tmp___35 = 100LL;
                } else {
#line 370
                  tmp___35 = (long long )(102400 * i) / axel->size;
                }
                {
#line 370
                printf((char const   */* __restrict  */)"\n[%3lld%%]  ", tmp___35);
                }
              } else {
#line 372
                if (100LL < (long long )i / (axel->size / 102400LL)) {
#line 372
                  tmp___36 = 100LL;
                } else {
#line 372
                  tmp___36 = (long long )i / (axel->size / 102400LL);
                }
                {
#line 372
                printf((char const   */* __restrict  */)"\n[%3lld%%]  ", tmp___36);
                }
              }
            } else
#line 374
            if (i % 10 == 0) {
              {
#line 376
              putchar(' ');
              }
            }
            {
#line 378
            putchar('.');
#line 379
            i = (int )((long long )i - prev / 1024LL);
#line 362
            i ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 381
          fflush(stdout);
          }
        }
      }
    }
#line 385
    if (axel->message) {
#line 387
      if (conf[0].alternate_output == 1) {
        {
#line 390
        putchar('\r');
#line 391
        i = 0;
        }
        {
#line 391
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 391
          if (! (i < 79)) {
#line 391
            goto while_break___6;
          }
          {
#line 392
          putchar(' ');
#line 391
          i ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 393
        putchar('\r');
        }
      } else {
        {
#line 397
        putchar('\n');
        }
      }
      {
#line 399
      print_messages(axel);
      }
#line 400
      if (! axel->ready) {
#line 402
        if (conf[0].alternate_output != 1) {
          {
#line 403
          print_commas(axel->bytes_done);
          }
        } else {
          {
#line 405
          print_alternate_output(axel);
          }
        }
      }
    } else
#line 408
    if (axel->ready) {
      {
#line 410
      putchar('\n');
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 414
  tmp___37 = size_human(axel->bytes_done - axel->start_byte);
#line 414
  strcpy((char */* __restrict  */)(string___0 + 512), (char const   */* __restrict  */)tmp___37);
#line 417
  tmp___38 = gettime();
#line 417
  tmp___39 = time_human((int )(tmp___38 - axel->start_time));
#line 417
  tmp___40 = gettext("\nDownloaded %s in %s. (%.2f KB/s)\n");
#line 417
  printf((char const   */* __restrict  */)tmp___40, string___0 + 512, tmp___39, (double )axel->bytes_per_second / (double )1024);
  }
#line 422
  if (axel->ready) {
#line 422
    i = 0;
  } else {
#line 422
    i = 2;
  }
  {
#line 424
  axel_close(axel);
  }
#line 426
  return (i);
}
}
#line 430 "/home/june/collector/temp/axel-2.4/text.c"
static void stop(int signal___0 ) 
{ 


  {
#line 432
  run = 0;
#line 433
  return;
}
}
#line 436 "/home/june/collector/temp/axel-2.4/text.c"
static char *size_human(long long value ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 438
  if (value == 1LL) {
    {
#line 439
    tmp = gettext("%lld byte");
#line 439
    sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)tmp,
            value);
    }
  } else
#line 440
  if (value < 1024LL) {
    {
#line 441
    tmp___0 = gettext("%lld bytes");
#line 441
    sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)tmp___0,
            value);
    }
  } else
#line 442
  if (value < 10485760LL) {
    {
#line 443
    tmp___1 = gettext("%.1f kilobytes");
#line 443
    sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)tmp___1,
            (double )((float )value / (float )1024));
    }
  } else {
    {
#line 445
    tmp___2 = gettext("%.1f megabytes");
#line 445
    sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)tmp___2,
            (double )((float )value / (float )1048576));
    }
  }
#line 447
  return (string___0);
}
}
#line 451 "/home/june/collector/temp/axel-2.4/text.c"
static char *time_human(int value ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 453
  if (value == 1) {
    {
#line 454
    tmp = gettext("%i second");
#line 454
    sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)tmp,
            value);
    }
  } else
#line 455
  if (value < 60) {
    {
#line 456
    tmp___0 = gettext("%i seconds");
#line 456
    sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)tmp___0,
            value);
    }
  } else
#line 457
  if (value < 3600) {
    {
#line 458
    tmp___1 = gettext("%i:%02i seconds");
#line 458
    sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)tmp___1,
            value / 60, value % 60);
    }
  } else {
    {
#line 460
    tmp___2 = gettext("%i:%02i:%02i seconds");
#line 460
    sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)tmp___2,
            value / 3600, (value / 60) % 60, value % 60);
    }
  }
#line 462
  return (string___0);
}
}
#line 467 "/home/june/collector/temp/axel-2.4/text.c"
static void print_commas(long long bytes_done ) 
{ 
  int i ;
  int j ;

  {
  {
#line 471
  printf((char const   */* __restrict  */)"       ");
#line 472
  j = (int )((bytes_done / 1024LL) % 50LL);
  }
#line 473
  if (j == 0) {
#line 473
    j = 50;
  }
#line 474
  i = 0;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! (i < j)) {
#line 474
      goto while_break;
    }
#line 476
    if (i % 10 == 0) {
      {
#line 477
      putchar(' ');
      }
    }
    {
#line 478
    putchar(',');
#line 474
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 480
  fflush(stdout);
  }
#line 481
  return;
}
}
#line 483 "/home/june/collector/temp/axel-2.4/text.c"
static void print_alternate_output(axel_t *axel ) 
{ 
  long long done ;
  long long total ;
  int i ;
  int j ;
  double now ;
  double tmp ;
  long tmp___0 ;
  int seconds ;
  int minutes ;
  int hours ;
  int days ;

  {
  {
#line 485
  done = axel->bytes_done;
#line 486
  total = axel->size;
#line 487
  j = 0;
#line 488
  tmp = gettime();
#line 488
  now = tmp;
  }
#line 490
  if (100L < (long )(((double )done * 100.) / (double )total + .5)) {
#line 490
    tmp___0 = 100L;
  } else {
#line 490
    tmp___0 = (long )(((double )done * 100.) / (double )total + .5);
  }
  {
#line 490
  printf((char const   */* __restrict  */)"\r[%3ld%%] [", tmp___0);
#line 492
  i = 0;
  }
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! (i < axel->conf[0].num_connections)) {
#line 492
      goto while_break;
    }
    {
#line 494
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 494
      if (! ((double )j < ((double )(axel->conn + i)->currentbyte / (double )(total + 1LL)) * (double )50 - (double )1)) {
#line 494
        goto while_break___0;
      }
      {
#line 495
      putchar('.');
#line 494
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 497
    if ((axel->conn + i)->currentbyte < (axel->conn + i)->lastbyte) {
#line 499
      if (now <= (double )((axel->conn + i)->last_transfer + axel->conf[0].connection_timeout / 2)) {
        {
#line 500
        putchar(i + 48);
        }
      } else {
        {
#line 502
        putchar('#');
        }
      }
    } else {
      {
#line 504
      putchar('.');
      }
    }
#line 506
    j ++;
    {
#line 508
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 508
      if (! ((double )j < ((double )(axel->conn + i)->lastbyte / (double )(total + 1LL)) * (double )50)) {
#line 508
        goto while_break___1;
      }
      {
#line 509
      putchar(' ');
#line 508
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 492
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  if (axel->bytes_per_second > 1048576) {
    {
#line 513
    printf((char const   */* __restrict  */)"] [%6.1fMB/s]", (double )axel->bytes_per_second / (double )1048576);
    }
  } else
#line 514
  if (axel->bytes_per_second > 1024) {
    {
#line 515
    printf((char const   */* __restrict  */)"] [%6.1fKB/s]", (double )axel->bytes_per_second / (double )1024);
    }
  } else {
    {
#line 517
    printf((char const   */* __restrict  */)"] [%6.1fB/s]", (double )axel->bytes_per_second);
    }
  }
#line 519
  if (done < total) {
#line 522
    seconds = (int )((double )axel->finish_time - now);
#line 523
    minutes = seconds / 60;
#line 523
    seconds -= minutes * 60;
#line 524
    hours = minutes / 60;
#line 524
    minutes -= hours * 60;
#line 525
    days = hours / 24;
#line 525
    hours -= days * 24;
#line 526
    if (days) {
      {
#line 527
      printf((char const   */* __restrict  */)" [%2dd%2d]", days, hours);
      }
    } else
#line 528
    if (hours) {
      {
#line 529
      printf((char const   */* __restrict  */)" [%2dh%02d]", hours, minutes);
      }
    } else {
      {
#line 531
      printf((char const   */* __restrict  */)" [%02d:%02d]", minutes, seconds);
      }
    }
  }
  {
#line 534
  fflush(stdout);
  }
#line 535
  return;
}
}
#line 537 "/home/june/collector/temp/axel-2.4/text.c"
static void print_help(void) 
{ 
  char *tmp ;

  {
  {
#line 557
  tmp = gettext("Usage: axel [options] url1 [url2] [url...]\n\n--max-speed=x\t\t-s x\tSpecify maximum speed (bytes per second)\n--num-connections=x\t-n x\tSpecify maximum number of connections\n--output=f\t\t-o f\tSpecify local output file\n--search[=x]\t\t-S [x]\tSearch for mirrors and download from x servers\n--header=x\t\t-H x\tAdd header string\n--user-agent=x\t\t-U x\tSet user agent\n--no-proxy\t\t-N\tJust don\'t use any proxy server\n--quiet\t\t\t-q\tLeave stdout alone\n--verbose\t\t-v\tMore status information\n--alternate\t\t-a\tAlternate progress indicator\n--help\t\t\t-h\tThis information\n--version\t\t-V\tVersion information\n\nVisit http://axel.alioth.debian.org/ to report bugs\n");
#line 557
  printf((char const   */* __restrict  */)tmp);
  }
#line 574
  return;
}
}
#line 576 "/home/june/collector/temp/axel-2.4/text.c"
static void print_version(void) 
{ 
  char *tmp ;

  {
  {
#line 578
  tmp = gettext("Axel version %s (%s)\n");
#line 578
  printf((char const   */* __restrict  */)tmp, "2.4", "Linux");
#line 579
  printf((char const   */* __restrict  */)"\nCopyright 2001-2002 Wilmer van der Gaast.\n");
  }
#line 580
  return;
}
}
#line 583 "/home/june/collector/temp/axel-2.4/text.c"
static void print_messages(axel_t *axel ) 
{ 
  message_t *m ;

  {
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! axel->message) {
#line 587
      goto while_break;
    }
    {
#line 589
    printf((char const   */* __restrict  */)"%s\n", (axel->message)->text);
#line 590
    m = axel->message;
#line 591
    axel->message = (message_t *)(axel->message)->next;
#line 592
    free((void *)m);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  return;
}
}
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 290 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 43 "/home/june/collector/temp/axel-2.4/http.h"
int http_connect(http_t *conn , int proto , char *proxy , char *host , int port ,
                 char *user , char *pass ) ;
#line 44
void http_disconnect(http_t *conn ) ;
#line 45
void http_get(http_t *conn , char *lurl ) ;
#line 46
void http_addheader(http_t *conn , char *format  , ...) ;
#line 47
int http_exec(http_t *conn ) ;
#line 48
char *http_header(http_t *conn , char *header ) ;
#line 49
long long http_size(http_t *conn ) ;
#line 50
void http_encode(char *s ) ;
#line 28 "/home/june/collector/temp/axel-2.4/conn.c"
char string[1024]  ;
#line 31 "/home/june/collector/temp/axel-2.4/conn.c"
int conn_set(conn_t *conn , char *set_url ) 
{ 
  char url[1024] ;
  char *i ;
  char *j ;
  char tmp ;
  char *tmp___0 ;
  struct servent *serv ;
  uint16_t tmp___1 ;

  {
  {
#line 37
  i = strstr((char const   *)set_url, "://");
  }
#line 37
  if ((unsigned long )i == (unsigned long )((void *)0)) {
    {
#line 39
    conn->proto = 1;
#line 40
    strncpy((char */* __restrict  */)(url), (char const   */* __restrict  */)set_url,
            (size_t )1024);
    }
  } else {
#line 44
    if ((int )*(set_url + 0) == 102) {
#line 45
      conn->proto = 1;
    } else
#line 46
    if ((int )*(set_url + 0) == 104) {
#line 47
      conn->proto = 2;
    } else {
#line 50
      return (0);
    }
    {
#line 52
    strncpy((char */* __restrict  */)(url), (char const   */* __restrict  */)(i + 3),
            (size_t )1024);
    }
  }
  {
#line 56
  i = strchr((char const   *)(url), '/');
  }
#line 56
  if ((unsigned long )i == (unsigned long )((void *)0)) {
    {
#line 58
    strcpy((char */* __restrict  */)(conn->dir), (char const   */* __restrict  */)"/");
    }
  } else {
    {
#line 62
    *i = (char)0;
#line 63
    snprintf((char */* __restrict  */)(conn->dir), (size_t )1024, (char const   */* __restrict  */)"/%s",
             i + 1);
    }
#line 64
    if (conn->proto == 2) {
      {
#line 65
      http_encode(conn->dir);
      }
    }
  }
  {
#line 67
  strncpy((char */* __restrict  */)(conn->host), (char const   */* __restrict  */)(url),
          (size_t )1024);
#line 68
  j = strchr((char const   *)(conn->dir), '?');
  }
#line 69
  if ((unsigned long )j != (unsigned long )((void *)0)) {
#line 70
    *j = (char)0;
  }
  {
#line 71
  i = strrchr((char const   *)(conn->dir), '/');
#line 72
  *i = (char)0;
  }
#line 73
  if ((unsigned long )j != (unsigned long )((void *)0)) {
#line 74
    *j = (char )'?';
  }
#line 75
  if ((unsigned long )i == (unsigned long )((void *)0)) {
    {
#line 77
    strncpy((char */* __restrict  */)(conn->file), (char const   */* __restrict  */)(conn->dir),
            (size_t )1024);
#line 78
    strcpy((char */* __restrict  */)(conn->dir), (char const   */* __restrict  */)"/");
    }
  } else {
    {
#line 82
    strncpy((char */* __restrict  */)(conn->file), (char const   */* __restrict  */)(i + 1),
            (size_t )1024);
#line 83
    strcat((char */* __restrict  */)(conn->dir), (char const   */* __restrict  */)"/");
    }
  }
  {
#line 87
  tmp___0 = strrchr((char const   *)(conn->host), '@');
  }
#line 87
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 89
    strncpy((char */* __restrict  */)(conn->user), (char const   */* __restrict  */)(conn->host),
            (size_t )1024);
#line 90
    i = strrchr((char const   *)(conn->user), '@');
#line 91
    *i = (char)0;
#line 92
    strncpy((char */* __restrict  */)(conn->host), (char const   */* __restrict  */)(i + 1),
            (size_t )1024);
#line 93
    conn->pass[0] = (char)0;
    }
  } else
#line 98
  if (conn->proto == 1) {
    {
#line 102
    strcpy((char */* __restrict  */)(conn->user), (char const   */* __restrict  */)"anonymous");
#line 103
    strcpy((char */* __restrict  */)(conn->pass), (char const   */* __restrict  */)"mailto:axel-devel@lists.alioth.debian.org");
    }
  } else {
#line 107
    tmp = (char)0;
#line 107
    conn->pass[0] = tmp;
#line 107
    conn->user[0] = tmp;
  }
  {
#line 112
  i = strchr((char const   *)(conn->user), ':');
  }
#line 112
  if ((unsigned long )i != (unsigned long )((void *)0)) {
    {
#line 114
    *i = (char)0;
#line 115
    strncpy((char */* __restrict  */)(conn->pass), (char const   */* __restrict  */)(i + 1),
            (size_t )1024);
    }
  }
  {
#line 118
  i = strchr((char const   *)(conn->host), ':');
  }
#line 118
  if ((unsigned long )i != (unsigned long )((void *)0)) {
    {
#line 120
    *i = (char)0;
#line 121
    sscanf((char const   */* __restrict  */)(i + 1), (char const   */* __restrict  */)"%i",
           & conn->port);
    }
  } else {
#line 129
    if (conn->proto == 1) {
      {
#line 130
      serv = getservbyname("ftp", "tcp");
      }
    } else {
      {
#line 132
      serv = getservbyname("www", "tcp");
      }
    }
#line 134
    if (serv) {
      {
#line 135
      tmp___1 = ntohs((uint16_t )serv->s_port);
#line 135
      conn->port = (int )tmp___1;
      }
    } else
#line 138
    if (conn->proto == 2) {
#line 139
      conn->port = 80;
    } else {
#line 141
      conn->port = 21;
    }
  }
#line 144
  return (conn->port > 0);
}
}
#line 148 "/home/june/collector/temp/axel-2.4/conn.c"
char *conn_url(conn_t *conn ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 150
  if (conn->proto == 1) {
    {
#line 151
    strcpy((char */* __restrict  */)(string), (char const   */* __restrict  */)"ftp://");
    }
  } else {
    {
#line 153
    strcpy((char */* __restrict  */)(string), (char const   */* __restrict  */)"http://");
    }
  }
#line 155
  if ((int )conn->user[0] != 0) {
    {
#line 155
    tmp___0 = strcmp((char const   *)(conn->user), "anonymous");
    }
#line 155
    if (tmp___0 != 0) {
      {
#line 156
      tmp = strlen((char const   *)(string));
#line 156
      sprintf((char */* __restrict  */)(string + tmp), (char const   */* __restrict  */)"%s:%s@",
              conn->user, conn->pass);
      }
    }
  }
  {
#line 159
  tmp___1 = strlen((char const   *)(string));
#line 159
  sprintf((char */* __restrict  */)(string + tmp___1), (char const   */* __restrict  */)"%s:%i%s%s",
          conn->host, conn->port, conn->dir, conn->file);
  }
#line 162
  return (string);
}
}
#line 166 "/home/june/collector/temp/axel-2.4/conn.c"
void conn_disconnect(conn_t *conn ) 
{ 


  {
#line 168
  if (conn->proto == 1) {
#line 168
    if (! conn->proxy) {
      {
#line 169
      ftp_disconnect(conn->ftp);
      }
    } else {
      {
#line 171
      http_disconnect(conn->http);
      }
    }
  } else {
    {
#line 171
    http_disconnect(conn->http);
    }
  }
#line 172
  conn->fd = -1;
#line 173
  return;
}
}
#line 175 "/home/june/collector/temp/axel-2.4/conn.c"
int conn_init(conn_t *conn ) 
{ 
  char *proxy ;
  char *host ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 177
  proxy = (conn->conf)->http_proxy;
#line 177
  host = (conn->conf)->no_proxy;
#line 180
  if ((int )(conn->conf)->http_proxy[0] == 0) {
#line 182
    proxy = (char *)((void *)0);
  } else
#line 184
  if ((int )(conn->conf)->no_proxy[0] != 0) {
#line 186
    i = 0;
    {
#line 186
    while (1) {
      while_continue: /* CIL Label */ ;
#line 187
      if ((int )(conn->conf)->no_proxy[i] == 0) {
        {
#line 189
        tmp = strstr((char const   *)(conn->host), (char const   *)host);
        }
#line 189
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 190
          proxy = (char *)((void *)0);
        }
#line 191
        host = & (conn->conf)->no_proxy[i + 1];
#line 192
        if ((int )(conn->conf)->no_proxy[i + 1] == 0) {
#line 193
          goto while_break;
        }
      }
#line 186
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 197
  conn->proxy = (unsigned long )proxy != (unsigned long )((void *)0);
#line 199
  if (conn->proto == 1) {
#line 199
    if (! conn->proxy) {
      {
#line 201
      conn->ftp[0].local_if = conn->local_if;
#line 202
      conn->ftp[0].ftp_mode = 1;
#line 203
      tmp___0 = ftp_connect(conn->ftp, conn->host, conn->port, conn->user, conn->pass);
      }
#line 203
      if (! tmp___0) {
        {
#line 205
        conn->message = conn->ftp[0].message;
#line 206
        conn_disconnect(conn);
        }
#line 207
        return (0);
      }
      {
#line 209
      conn->message = conn->ftp[0].message;
#line 210
      tmp___1 = ftp_cwd(conn->ftp, conn->dir);
      }
#line 210
      if (! tmp___1) {
        {
#line 212
        conn_disconnect(conn);
        }
#line 213
        return (0);
      }
    } else {
#line 199
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 218
    conn->http[0].local_if = conn->local_if;
#line 219
    tmp___2 = http_connect(conn->http, conn->proto, proxy, conn->host, conn->port,
                           conn->user, conn->pass);
    }
#line 219
    if (! tmp___2) {
      {
#line 221
      conn->message = conn->http[0].headers;
#line 222
      conn_disconnect(conn);
      }
#line 223
      return (0);
    }
#line 225
    conn->message = conn->http[0].headers;
#line 226
    conn->fd = conn->http[0].fd;
  }
#line 228
  return (1);
}
}
#line 231 "/home/june/collector/temp/axel-2.4/conn.c"
int conn_setup(conn_t *conn ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char s[1024] ;
  int i ;

  {
#line 233
  if (conn->ftp[0].fd <= 0) {
#line 233
    if (conn->http[0].fd <= 0) {
      {
#line 234
      tmp = conn_init(conn);
      }
#line 234
      if (! tmp) {
#line 235
        return (0);
      }
    }
  }
#line 237
  if (conn->proto == 1) {
#line 237
    if (! conn->proxy) {
      {
#line 239
      tmp___0 = ftp_data(conn->ftp);
      }
#line 239
      if (! tmp___0) {
#line 240
        return (0);
      }
#line 241
      conn->fd = conn->ftp[0].data_fd;
#line 243
      if (conn->currentbyte) {
        {
#line 245
        ftp_command(conn->ftp, (char *)"REST %lld", conn->currentbyte);
#line 246
        tmp___1 = ftp_wait(conn->ftp);
        }
#line 246
        if (tmp___1 / 100 != 3) {
#line 246
          if (conn->ftp[0].status / 100 != 2) {
#line 248
            return (0);
          }
        }
      }
    } else {
#line 237
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 256
    snprintf((char */* __restrict  */)(s), (size_t )1024, (char const   */* __restrict  */)"%s%s",
             conn->dir, conn->file);
#line 257
    conn->http[0].firstbyte = conn->currentbyte;
#line 258
    conn->http[0].lastbyte = conn->lastbyte;
#line 259
    http_get(conn->http, s);
#line 260
    http_addheader(conn->http, (char *)"User-Agent: %s", (conn->conf)->user_agent);
#line 261
    i = 0;
    }
    {
#line 261
    while (1) {
      while_continue: /* CIL Label */ ;
#line 261
      if (! (i < (conn->conf)->add_header_count)) {
#line 261
        goto while_break;
      }
      {
#line 262
      http_addheader(conn->http, (char *)"%s", (conn->conf)->add_header[i]);
#line 261
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 264
  return (1);
}
}
#line 267 "/home/june/collector/temp/axel-2.4/conn.c"
int conn_exec(conn_t *conn ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 269
  if (conn->proto == 1) {
#line 269
    if (! conn->proxy) {
      {
#line 271
      tmp = ftp_command(conn->ftp, (char *)"RETR %s", conn->file);
      }
#line 271
      if (! tmp) {
#line 272
        return (0);
      }
      {
#line 273
      tmp___0 = ftp_wait(conn->ftp);
      }
#line 273
      return (tmp___0 / 100 == 1);
    } else {
#line 269
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 277
    tmp___1 = http_exec(conn->http);
    }
#line 277
    if (! tmp___1) {
#line 278
      return (0);
    }
#line 279
    return (conn->http[0].status / 100 == 2);
  }
}
}
#line 284 "/home/june/collector/temp/axel-2.4/conn.c"
int conn_info(conn_t *conn ) 
{ 
  int tmp ;
  int tmp___0 ;
  char s[1024] ;
  char *t ;
  long long i ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 287
  if (conn->proto == 1) {
#line 287
    if (! conn->proxy) {
      {
#line 289
      ftp_command(conn->ftp, (char *)"REST %lld", 1);
#line 290
      tmp = ftp_wait(conn->ftp);
      }
#line 290
      if (tmp / 100 == 3) {
        {
#line 293
        conn->supported = 1;
#line 294
        ftp_command(conn->ftp, (char *)"REST %lld", 0);
#line 295
        ftp_wait(conn->ftp);
        }
      } else
#line 290
      if (conn->ftp[0].status / 100 == 2) {
        {
#line 293
        conn->supported = 1;
#line 294
        ftp_command(conn->ftp, (char *)"REST %lld", 0);
#line 295
        ftp_wait(conn->ftp);
        }
      } else {
#line 299
        conn->supported = 0;
      }
      {
#line 302
      tmp___0 = ftp_cwd(conn->ftp, conn->dir);
      }
#line 302
      if (! tmp___0) {
#line 303
        return (0);
      }
      {
#line 304
      conn->size = ftp_size(conn->ftp, conn->file, 5);
      }
#line 305
      if (conn->size < 0LL) {
#line 306
        conn->supported = 0;
      }
#line 307
      if (conn->size == -1LL) {
#line 308
        return (0);
      } else
#line 309
      if (conn->size == -2LL) {
#line 310
        conn->size = 2147483647LL;
      }
    } else {
#line 287
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 315
    i = 0LL;
    {
#line 317
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 319
      conn->currentbyte = 1LL;
#line 320
      tmp___1 = conn_setup(conn);
      }
#line 320
      if (! tmp___1) {
#line 321
        return (0);
      }
      {
#line 322
      conn_exec(conn);
#line 323
      conn_disconnect(conn);
      }
#line 325
      if (conn->http[0].status / 100 != 3) {
#line 326
        goto while_break;
      }
      {
#line 327
      t = http_header(conn->http, (char *)"location:");
      }
#line 327
      if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 328
        return (0);
      }
      {
#line 329
      sscanf((char const   */* __restrict  */)t, (char const   */* __restrict  */)"%255s",
             s);
#line 330
      tmp___3 = strstr((char const   *)(s), "://");
      }
#line 330
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
        {
#line 332
        tmp___2 = conn_url(conn);
#line 332
        sprintf((char */* __restrict  */)(conn->http[0].headers), (char const   */* __restrict  */)"%s%s",
                tmp___2, s);
#line 334
        strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)(conn->http[0].headers),
                (size_t )1024);
        }
      } else
#line 336
      if ((int )s[0] == 47) {
        {
#line 338
        sprintf((char */* __restrict  */)(conn->http[0].headers), (char const   */* __restrict  */)"http://%s:%i%s",
                conn->host, conn->port, s);
#line 340
        strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)(conn->http[0].headers),
                (size_t )1024);
        }
      }
      {
#line 342
      conn_set(conn, s);
#line 343
      i ++;
      }
#line 317
      if (conn->http[0].status / 100 == 3) {
#line 317
        if (! (i < 5LL)) {
#line 317
          goto while_break;
        }
      } else {
#line 317
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 347
    if (i == 5LL) {
      {
#line 349
      tmp___4 = gettext("Too many redirects.\n");
#line 349
      sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp___4);
      }
#line 350
      return (0);
    }
    {
#line 353
    conn->size = http_size(conn->http);
    }
#line 354
    if (conn->http[0].status == 206) {
#line 354
      if (conn->size >= 0LL) {
#line 356
        conn->supported = 1;
#line 357
        (conn->size) ++;
      } else {
#line 354
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 359
    if (conn->http[0].status == 200) {
#line 361
      conn->supported = 0;
#line 362
      conn->size = 2147483647LL;
    } else
#line 359
    if (conn->http[0].status == 206) {
#line 361
      conn->supported = 0;
#line 362
      conn->size = 2147483647LL;
    } else {
      {
#line 366
      t = strchr((char const   *)conn->message, '\n');
      }
#line 367
      if ((unsigned long )t == (unsigned long )((void *)0)) {
        {
#line 368
        tmp___5 = gettext("Unknown HTTP error.\n");
#line 368
        sprintf((char */* __restrict  */)conn->message, (char const   */* __restrict  */)tmp___5);
        }
      } else {
#line 370
        *t = (char)0;
      }
#line 371
      return (0);
    }
  }
#line 375
  return (1);
}
}
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 28 "/home/june/collector/temp/axel-2.4/http.c"
int http_connect(http_t *conn , int proto , char *proxy , char *host , int port ,
                 char *user , char *pass ) 
{ 
  char base64_encode[64] ;
  char auth[1024] ;
  conn_t tconn[1] ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 30
  base64_encode[0] = (char )'A';
#line 30
  base64_encode[1] = (char )'B';
#line 30
  base64_encode[2] = (char )'C';
#line 30
  base64_encode[3] = (char )'D';
#line 30
  base64_encode[4] = (char )'E';
#line 30
  base64_encode[5] = (char )'F';
#line 30
  base64_encode[6] = (char )'G';
#line 30
  base64_encode[7] = (char )'H';
#line 30
  base64_encode[8] = (char )'I';
#line 30
  base64_encode[9] = (char )'J';
#line 30
  base64_encode[10] = (char )'K';
#line 30
  base64_encode[11] = (char )'L';
#line 30
  base64_encode[12] = (char )'M';
#line 30
  base64_encode[13] = (char )'N';
#line 30
  base64_encode[14] = (char )'O';
#line 30
  base64_encode[15] = (char )'P';
#line 30
  base64_encode[16] = (char )'Q';
#line 30
  base64_encode[17] = (char )'R';
#line 30
  base64_encode[18] = (char )'S';
#line 30
  base64_encode[19] = (char )'T';
#line 30
  base64_encode[20] = (char )'U';
#line 30
  base64_encode[21] = (char )'V';
#line 30
  base64_encode[22] = (char )'W';
#line 30
  base64_encode[23] = (char )'X';
#line 30
  base64_encode[24] = (char )'Y';
#line 30
  base64_encode[25] = (char )'Z';
#line 30
  base64_encode[26] = (char )'a';
#line 30
  base64_encode[27] = (char )'b';
#line 30
  base64_encode[28] = (char )'c';
#line 30
  base64_encode[29] = (char )'d';
#line 30
  base64_encode[30] = (char )'e';
#line 30
  base64_encode[31] = (char )'f';
#line 30
  base64_encode[32] = (char )'g';
#line 30
  base64_encode[33] = (char )'h';
#line 30
  base64_encode[34] = (char )'i';
#line 30
  base64_encode[35] = (char )'j';
#line 30
  base64_encode[36] = (char )'k';
#line 30
  base64_encode[37] = (char )'l';
#line 30
  base64_encode[38] = (char )'m';
#line 30
  base64_encode[39] = (char )'n';
#line 30
  base64_encode[40] = (char )'o';
#line 30
  base64_encode[41] = (char )'p';
#line 30
  base64_encode[42] = (char )'q';
#line 30
  base64_encode[43] = (char )'r';
#line 30
  base64_encode[44] = (char )'s';
#line 30
  base64_encode[45] = (char )'t';
#line 30
  base64_encode[46] = (char )'u';
#line 30
  base64_encode[47] = (char )'v';
#line 30
  base64_encode[48] = (char )'w';
#line 30
  base64_encode[49] = (char )'x';
#line 30
  base64_encode[50] = (char )'y';
#line 30
  base64_encode[51] = (char )'z';
#line 30
  base64_encode[52] = (char )'0';
#line 30
  base64_encode[53] = (char )'1';
#line 30
  base64_encode[54] = (char )'2';
#line 30
  base64_encode[55] = (char )'3';
#line 30
  base64_encode[56] = (char )'4';
#line 30
  base64_encode[57] = (char )'5';
#line 30
  base64_encode[58] = (char )'6';
#line 30
  base64_encode[59] = (char )'7';
#line 30
  base64_encode[60] = (char )'8';
#line 30
  base64_encode[61] = (char )'9';
#line 30
  base64_encode[62] = (char )'+';
#line 30
  base64_encode[63] = (char )'/';
#line 36
  strncpy((char */* __restrict  */)(conn->host), (char const   */* __restrict  */)host,
          (size_t )1024);
#line 37
  conn->proto = proto;
  }
#line 39
  if ((unsigned long )proxy != (unsigned long )((void *)0)) {
#line 39
    if ((int )*proxy != 0) {
      {
#line 41
      sprintf((char */* __restrict  */)(conn->host), (char const   */* __restrict  */)"%s:%i",
              host, port);
#line 42
      tmp___0 = conn_set(tconn, proxy);
      }
#line 42
      if (! tmp___0) {
        {
#line 45
        tmp = gettext("Invalid proxy string: %s\n");
#line 45
        sprintf((char */* __restrict  */)(conn->headers), (char const   */* __restrict  */)tmp,
                proxy);
        }
#line 46
        return (0);
      }
#line 48
      host = tconn[0].host;
#line 49
      port = tconn[0].port;
#line 50
      conn->proxy = 1;
    } else {
#line 54
      conn->proxy = 0;
    }
  }
  {
#line 57
  tmp___2 = tcp_connect(host, port, conn->local_if);
#line 57
  conn->fd = tmp___2;
  }
#line 57
  if (tmp___2 == -1) {
    {
#line 60
    tmp___1 = gettext("Unable to connect to server %s:%i\n");
#line 60
    sprintf((char */* __restrict  */)(conn->headers), (char const   */* __restrict  */)tmp___1,
            host, port);
    }
#line 61
    return (0);
  }
#line 64
  if ((int )*user == 0) {
#line 66
    conn->auth[0] = (char)0;
  } else {
    {
#line 70
    memset((void *)(auth), 0, (size_t )1024);
#line 71
    snprintf((char */* __restrict  */)(auth), (size_t )1024, (char const   */* __restrict  */)"%s:%s",
             user, pass);
#line 72
    i = 0;
    }
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (! auth[i * 3]) {
#line 72
        goto while_break;
      }
#line 74
      conn->auth[i * 4] = base64_encode[(int )auth[i * 3] >> 2];
#line 75
      conn->auth[i * 4 + 1] = base64_encode[(((int )auth[i * 3] & 3) << 4) | ((int )auth[i * 3 + 1] >> 4)];
#line 76
      conn->auth[i * 4 + 2] = base64_encode[(((int )auth[i * 3 + 1] & 15) << 2) | ((int )auth[i * 3 + 2] >> 6)];
#line 77
      conn->auth[i * 4 + 3] = base64_encode[(int )auth[i * 3 + 2] & 63];
#line 78
      if ((int )auth[i * 3 + 2] == 0) {
#line 78
        conn->auth[i * 4 + 3] = (char )'=';
      }
#line 79
      if ((int )auth[i * 3 + 1] == 0) {
#line 79
        conn->auth[i * 4 + 2] = (char )'=';
      }
#line 72
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 83
  return (1);
}
}
#line 86 "/home/june/collector/temp/axel-2.4/http.c"
void http_disconnect(http_t *conn ) 
{ 


  {
#line 88
  if (conn->fd > 0) {
    {
#line 89
    close(conn->fd);
    }
  }
#line 90
  conn->fd = -1;
#line 91
  return;
}
}
#line 93 "/home/june/collector/temp/axel-2.4/http.c"
void http_get(http_t *conn , char *lurl ) 
{ 
  char const   *tmp ;

  {
#line 95
  conn->request[0] = (char)0;
#line 96
  if (conn->proxy) {
#line 98
    if (conn->proto == 2) {
#line 98
      tmp = "http";
    } else {
#line 98
      tmp = "ftp";
    }
    {
#line 98
    http_addheader(conn, (char *)"GET %s://%s%s HTTP/1.0", tmp, conn->host, lurl);
    }
  } else {
    {
#line 103
    http_addheader(conn, (char *)"GET %s HTTP/1.0", lurl);
#line 104
    http_addheader(conn, (char *)"Host: %s", conn->host);
    }
  }
#line 106
  if (conn->auth[0]) {
    {
#line 107
    http_addheader(conn, (char *)"Authorization: Basic %s", conn->auth);
    }
  }
#line 108
  if (conn->firstbyte) {
#line 110
    if (conn->lastbyte) {
      {
#line 111
      http_addheader(conn, (char *)"Range: bytes=%lld-%lld", conn->firstbyte, conn->lastbyte);
      }
    } else {
      {
#line 113
      http_addheader(conn, (char *)"Range: bytes=%lld-", conn->firstbyte);
      }
    }
  }
#line 115
  return;
}
}
#line 117 "/home/june/collector/temp/axel-2.4/http.c"
void http_addheader(http_t *conn , char *format  , ...) 
{ 
  char s[1024] ;
  va_list params ;
  size_t tmp ;

  {
  {
#line 122
  __builtin_va_start(params, format);
#line 123
  vsnprintf((char */* __restrict  */)(s), (size_t )1021, (char const   */* __restrict  */)format,
            params);
#line 124
  strcat((char */* __restrict  */)(s), (char const   */* __restrict  */)"\r\n");
#line 125
  __builtin_va_end(params);
#line 127
  tmp = strlen((char const   *)(conn->request));
#line 127
  strncat((char */* __restrict  */)(conn->request), (char const   */* __restrict  */)(s),
          (2048UL - tmp) - 1UL);
  }
#line 128
  return;
}
}
#line 130 "/home/june/collector/temp/axel-2.4/http.c"
int http_exec(http_t *conn ) 
{ 
  int i ;
  char s[2] ;
  char *s2 ;
  size_t tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 132
  i = 0;
#line 133
  s[0] = (char )' ';
#line 133
  s[1] = (char )'\000';
#line 139
  http_addheader(conn, (char *)"");
#line 140
  tmp = strlen((char const   *)(conn->request));
#line 140
  write(conn->fd, (void const   *)(conn->request), tmp);
#line 142
  conn->headers[0] = (char)0;
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 147
    tmp___1 = read(conn->fd, (void *)(s), (size_t )1);
    }
#line 147
    if (tmp___1 <= 0L) {
      {
#line 150
      tmp___0 = gettext("Connection gone.\n");
#line 150
      sprintf((char */* __restrict  */)(conn->headers), (char const   */* __restrict  */)tmp___0);
      }
#line 151
      return (0);
    }
#line 153
    if ((int )s[0] == 13) {
#line 155
      goto while_continue;
    } else
#line 157
    if ((int )s[0] == 10) {
#line 159
      if (i == 0) {
#line 160
        goto while_break;
      }
#line 161
      i = 0;
    } else {
#line 165
      i ++;
    }
    {
#line 167
    strncat((char */* __restrict  */)(conn->headers), (char const   */* __restrict  */)(s),
            (size_t )2048);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  sscanf((char const   */* __restrict  */)(conn->headers), (char const   */* __restrict  */)"%*s %3i",
         & conn->status);
#line 175
  s2 = strchr((char const   *)(conn->headers), '\n');
#line 175
  *s2 = (char)0;
#line 176
  strcpy((char */* __restrict  */)(conn->request), (char const   */* __restrict  */)(conn->headers));
#line 177
  *s2 = (char )'\n';
  }
#line 179
  return (1);
}
}
#line 182 "/home/june/collector/temp/axel-2.4/http.c"
char *http_header(http_t *conn , char *header ) 
{ 
  char s[32] ;
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 187
  i = 1;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! conn->headers[i]) {
#line 187
      goto while_break;
    }
#line 188
    if ((int )conn->headers[i - 1] == 10) {
      {
#line 190
      sscanf((char const   */* __restrict  */)(& conn->headers[i]), (char const   */* __restrict  */)"%31s",
             s);
#line 191
      tmp___0 = strcasecmp((char const   *)(s), (char const   *)header);
      }
#line 191
      if (tmp___0 == 0) {
        {
#line 192
        tmp = strlen((char const   *)header);
        }
#line 192
        return (& conn->headers[(size_t )i + tmp]);
      }
    }
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return ((char *)((void *)0));
}
}
#line 198 "/home/june/collector/temp/axel-2.4/http.c"
long long http_size(http_t *conn ) 
{ 
  char *i ;
  long long j ;

  {
  {
#line 203
  i = http_header(conn, (char *)"Content-Length:");
  }
#line 203
  if ((unsigned long )i == (unsigned long )((void *)0)) {
#line 204
    return (-2LL);
  }
  {
#line 206
  sscanf((char const   */* __restrict  */)i, (char const   */* __restrict  */)"%lld",
         & j);
  }
#line 207
  return (j);
}
}
#line 211 "/home/june/collector/temp/axel-2.4/http.c"
void http_decode(char *s ) 
{ 
  char t[1024] ;
  int i ;
  int j ;
  int k ;
  int tmp ;

  {
#line 216
  j = 0;
#line 216
  i = j;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! *(s + i)) {
#line 216
      goto while_break;
    }
#line 218
    t[j] = *(s + i);
#line 219
    if ((int )*(s + i) == 37) {
      {
#line 220
      tmp = sscanf((char const   */* __restrict  */)((s + i) + 1), (char const   */* __restrict  */)"%2x",
                   & k);
      }
#line 220
      if (tmp) {
#line 222
        t[j] = (char )k;
#line 223
        i += 2;
      }
    }
#line 216
    i ++;
#line 216
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  t[j] = (char)0;
#line 228
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)(t));
  }
#line 229
  return;
}
}
#line 231 "/home/june/collector/temp/axel-2.4/http.c"
void http_encode(char *s ) 
{ 
  char t[1024] ;
  int i ;
  int j ;

  {
#line 236
  j = 0;
#line 236
  i = j;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! *(s + i)) {
#line 236
      goto while_break;
    }
#line 239
    if (j >= 1023) {
#line 240
      goto while_break;
    }
#line 243
    t[j] = *(s + i);
#line 244
    if ((int )*(s + i) == 32) {
#line 247
      if (j >= 1021) {
#line 248
        goto while_break;
      }
      {
#line 251
      strcpy((char */* __restrict  */)(t + j), (char const   */* __restrict  */)"%20");
#line 252
      j += 2;
      }
    }
#line 236
    i ++;
#line 236
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  t[j] = (char)0;
#line 257
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)(t));
  }
#line 258
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 54 "/home/june/collector/temp/axel-2.4/conf.h"
int conf_loadfile(conf_t *conf , char *file ) ;
#line 42 "/home/june/collector/temp/axel-2.4/conf.c"
int parse_interfaces(conf_t *conf , char *s ) ;
#line 44 "/home/june/collector/temp/axel-2.4/conf.c"
int conf_loadfile(conf_t *conf , char *file ) 
{ 
  int i ;
  int line ;
  FILE *fp ;
  char s[1024] ;
  char key[1024] ;
  char value[1024] ;
  int st ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  {
#line 46
  line = 0;
#line 50
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 51
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 52
    return (1);
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 54
    tmp___25 = feof(fp);
    }
#line 54
    if (tmp___25) {
#line 54
      goto while_break;
    }
    {
#line 58
    line ++;
#line 60
    s[0] = (char)0;
#line 61
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%100[^\n#]s",
           s);
#line 62
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%*[^\n]s");
#line 63
    fgetc(fp);
#line 64
    tmp = strchr((char const   *)(s), '=');
    }
#line 64
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 65
      goto while_continue;
    }
    {
#line 66
    sscanf((char const   */* __restrict  */)(s), (char const   */* __restrict  */)"%[^= \t]s",
           key);
#line 67
    i = 0;
    }
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 67
      if (! s[i]) {
#line 67
        goto while_break___0;
      }
#line 68
      if ((int )s[i] == 61) {
#line 70
        i ++;
        {
#line 70
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 70
          tmp___0 = __ctype_b_loc();
          }
#line 70
          if ((int const   )*(*tmp___0 + (int )s[i]) & 8192) {
#line 70
            if (! s[i]) {
#line 70
              goto while_break___1;
            }
          } else {
#line 70
            goto while_break___1;
          }
#line 70
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 71
        goto while_break___0;
      }
#line 67
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 73
    strcpy((char */* __restrict  */)(value), (char const   */* __restrict  */)(& s[i]));
#line 74
    tmp___1 = strlen((char const   *)(value));
#line 74
    i = (int )(tmp___1 - 1UL);
    }
    {
#line 74
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 74
      tmp___2 = __ctype_b_loc();
      }
#line 74
      if (! ((int const   )*(*tmp___2 + (int )value[i]) & 8192)) {
#line 74
        goto while_break___2;
      }
#line 75
      value[i] = (char)0;
#line 74
      i --;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 77
    st = 0;
#line 80
    tmp___3 = strcmp((char const   *)(key), "default_filename");
    }
#line 80
    if (tmp___3 == 0) {
      {
#line 80
      st = 1;
#line 80
      strcpy((char */* __restrict  */)(conf->default_filename), (char const   */* __restrict  */)(value));
      }
    }
    {
#line 81
    tmp___4 = strcmp((char const   *)(key), "http_proxy");
    }
#line 81
    if (tmp___4 == 0) {
      {
#line 81
      st = 1;
#line 81
      strcpy((char */* __restrict  */)(conf->http_proxy), (char const   */* __restrict  */)(value));
      }
    }
    {
#line 82
    tmp___5 = strcmp((char const   *)(key), "no_proxy");
    }
#line 82
    if (tmp___5 == 0) {
      {
#line 82
      st = 1;
#line 82
      strcpy((char */* __restrict  */)(conf->no_proxy), (char const   */* __restrict  */)(value));
      }
    }
    {
#line 83
    tmp___6 = strcmp((char const   *)(key), "strip_cgi_parameters");
    }
#line 83
    if (tmp___6 == 0) {
      {
#line 83
      st = 1;
#line 83
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->strip_cgi_parameters);
      }
    }
    {
#line 84
    tmp___7 = strcmp((char const   *)(key), "save_state_interval");
    }
#line 84
    if (tmp___7 == 0) {
      {
#line 84
      st = 1;
#line 84
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->save_state_interval);
      }
    }
    {
#line 85
    tmp___8 = strcmp((char const   *)(key), "connection_timeout");
    }
#line 85
    if (tmp___8 == 0) {
      {
#line 85
      st = 1;
#line 85
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->connection_timeout);
      }
    }
    {
#line 86
    tmp___9 = strcmp((char const   *)(key), "reconnect_delay");
    }
#line 86
    if (tmp___9 == 0) {
      {
#line 86
      st = 1;
#line 86
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->reconnect_delay);
      }
    }
    {
#line 87
    tmp___10 = strcmp((char const   *)(key), "num_connections");
    }
#line 87
    if (tmp___10 == 0) {
      {
#line 87
      st = 1;
#line 87
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->num_connections);
      }
    }
    {
#line 88
    tmp___11 = strcmp((char const   *)(key), "buffer_size");
    }
#line 88
    if (tmp___11 == 0) {
      {
#line 88
      st = 1;
#line 88
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->buffer_size);
      }
    }
    {
#line 89
    tmp___12 = strcmp((char const   *)(key), "max_speed");
    }
#line 89
    if (tmp___12 == 0) {
      {
#line 89
      st = 1;
#line 89
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->max_speed);
      }
    }
    {
#line 90
    tmp___13 = strcmp((char const   *)(key), "verbose");
    }
#line 90
    if (tmp___13 == 0) {
      {
#line 90
      st = 1;
#line 90
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->verbose);
      }
    }
    {
#line 91
    tmp___14 = strcmp((char const   *)(key), "alternate_output");
    }
#line 91
    if (tmp___14 == 0) {
      {
#line 91
      st = 1;
#line 91
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->alternate_output);
      }
    }
    {
#line 93
    tmp___15 = strcmp((char const   *)(key), "search_timeout");
    }
#line 93
    if (tmp___15 == 0) {
      {
#line 93
      st = 1;
#line 93
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->search_timeout);
      }
    }
    {
#line 94
    tmp___16 = strcmp((char const   *)(key), "search_threads");
    }
#line 94
    if (tmp___16 == 0) {
      {
#line 94
      st = 1;
#line 94
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->search_threads);
      }
    }
    {
#line 95
    tmp___17 = strcmp((char const   *)(key), "search_amount");
    }
#line 95
    if (tmp___17 == 0) {
      {
#line 95
      st = 1;
#line 95
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->search_amount);
      }
    }
    {
#line 96
    tmp___18 = strcmp((char const   *)(key), "search_top");
    }
#line 96
    if (tmp___18 == 0) {
      {
#line 96
      st = 1;
#line 96
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->search_top);
      }
    }
    {
#line 99
    tmp___19 = strcmp((char const   *)(key), "speed_type");
    }
#line 99
    if (tmp___19 == 0) {
#line 100
      st = 1;
    }
    {
#line 102
    tmp___20 = strcmp((char const   *)(key), "interfaces");
    }
#line 102
    if (tmp___20 == 0) {
      {
#line 103
      st = parse_interfaces(conf, value);
      }
    }
#line 105
    if (! st) {
      {
#line 107
      tmp___21 = gettext("Error in %s line %i.\n");
#line 107
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
              file, line);
      }
#line 108
      return (0);
    }
    {
#line 110
    tmp___22 = strcmp((char const   *)(key), "add_header_count");
    }
#line 110
    if (tmp___22 == 0) {
      {
#line 110
      st = 1;
#line 110
      sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
             & conf->add_header_count);
      }
    }
#line 111
    i = 0;
    {
#line 111
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 111
      if (! (i < conf->add_header_count)) {
#line 111
        goto while_break___3;
      }
      {
#line 112
      tmp___23 = strcmp((char const   *)(key), "add_header[i]");
      }
#line 112
      if (tmp___23 == 0) {
        {
#line 112
        st = 1;
#line 112
        strcpy((char */* __restrict  */)(conf->add_header[i]), (char const   */* __restrict  */)(value));
        }
      }
#line 111
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 113
    tmp___24 = strcmp((char const   *)(key), "user_agent");
    }
#line 113
    if (tmp___24 == 0) {
      {
#line 113
      st = 1;
#line 113
      strcpy((char */* __restrict  */)(conf->user_agent), (char const   */* __restrict  */)(value));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  fclose(fp);
  }
#line 117
  return (1);
}
}
#line 120 "/home/june/collector/temp/axel-2.4/conf.c"
int conf_init(conf_t *conf ) 
{ 
  char s[1024] ;
  char *s2 ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 126
  memset((void *)conf, 0, sizeof(conf_t ));
#line 127
  strcpy((char */* __restrict  */)(conf->default_filename), (char const   */* __restrict  */)"default");
#line 128
  conf->http_proxy[0] = (char)0;
#line 129
  conf->no_proxy[0] = (char)0;
#line 130
  conf->strip_cgi_parameters = 1;
#line 131
  conf->save_state_interval = 10;
#line 132
  conf->connection_timeout = 45;
#line 133
  conf->reconnect_delay = 20;
#line 134
  conf->num_connections = 4;
#line 135
  conf->buffer_size = 5120;
#line 136
  conf->max_speed = 0;
#line 137
  conf->verbose = 1;
#line 138
  conf->alternate_output = 0;
#line 140
  conf->search_timeout = 10;
#line 141
  conf->search_threads = 3;
#line 142
  conf->search_amount = 15;
#line 143
  conf->search_top = 3;
#line 144
  conf->add_header_count = 0;
#line 145
  strncpy((char */* __restrict  */)(conf->user_agent), (char const   */* __restrict  */)"Axel 2.4 (Linux)",
          (size_t )1024);
#line 147
  tmp = malloc(sizeof(if_t ));
#line 147
  conf->interfaces = (if_t *)tmp;
#line 148
  memset((void *)conf->interfaces, 0, sizeof(if_t ));
#line 149
  (conf->interfaces)->next = (void *)conf->interfaces;
#line 151
  s2 = getenv("http_proxy");
  }
#line 151
  if ((unsigned long )s2 != (unsigned long )((void *)0)) {
    {
#line 152
    strncpy((char */* __restrict  */)(conf->http_proxy), (char const   */* __restrict  */)s2,
            (size_t )1024);
    }
  } else {
    {
#line 153
    s2 = getenv("HTTP_PROXY");
    }
#line 153
    if ((unsigned long )s2 != (unsigned long )((void *)0)) {
      {
#line 154
      strncpy((char */* __restrict  */)(conf->http_proxy), (char const   */* __restrict  */)s2,
              (size_t )1024);
      }
    }
  }
  {
#line 156
  tmp___0 = conf_loadfile(conf, (char *)"/usr/local/etc/axelrc");
  }
#line 156
  if (! tmp___0) {
#line 157
    return (0);
  }
  {
#line 159
  s2 = getenv("HOME");
  }
#line 159
  if ((unsigned long )s2 != (unsigned long )((void *)0)) {
    {
#line 161
    sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s/%s",
            s2, ".axelrc");
#line 162
    tmp___1 = conf_loadfile(conf, s);
    }
#line 162
    if (! tmp___1) {
#line 163
      return (0);
    }
  }
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! conf->no_proxy[i]) {
#line 167
      goto while_break;
    }
#line 168
    if ((int )conf->no_proxy[i] == 44) {
#line 169
      conf->no_proxy[i] = (char)0;
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  conf->no_proxy[i + 1] = (char)0;
#line 172
  return (1);
}
}
#line 175 "/home/june/collector/temp/axel-2.4/conf.c"
int parse_interfaces(conf_t *conf , char *s ) 
{ 
  char *s2 ;
  if_t *iface ;
  if_t *i ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 180
  iface = (if_t *)(conf->interfaces)->next;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! ((unsigned long )iface != (unsigned long )conf->interfaces)) {
#line 181
      goto while_break;
    }
    {
#line 185
    i = (if_t *)iface->next;
#line 186
    free((void *)iface);
#line 187
    iface = i;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  free((void *)conf->interfaces);
  }
#line 191
  if (! *s) {
    {
#line 193
    tmp = malloc(sizeof(if_t ));
#line 193
    conf->interfaces = (if_t *)tmp;
#line 194
    memset((void *)conf->interfaces, 0, sizeof(if_t ));
#line 195
    (conf->interfaces)->next = (void *)conf->interfaces;
    }
#line 196
    return (1);
  }
  {
#line 199
  tmp___0 = strlen((char const   *)s);
#line 199
  *(s + (tmp___0 + 1UL)) = (char)0;
#line 200
  tmp___1 = malloc(sizeof(if_t ));
#line 200
  iface = (if_t *)tmp___1;
#line 200
  conf->interfaces = iface;
  }
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 203
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 203
      if ((int )*s == 32) {
#line 203
        goto _L;
      } else
#line 203
      if ((int )*s == 9) {
        _L: /* CIL Label */ 
#line 203
        if (! *s) {
#line 203
          goto while_break___1;
        }
      } else {
#line 203
        goto while_break___1;
      }
#line 203
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 204
    s2 = s;
    {
#line 204
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 204
      if ((int )*s2 != 32) {
#line 204
        if ((int )*s2 != 9) {
#line 204
          if (! *s2) {
#line 204
            goto while_break___2;
          }
        } else {
#line 204
          goto while_break___2;
        }
      } else {
#line 204
        goto while_break___2;
      }
#line 204
      s2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 205
    *s2 = (char)0;
#line 206
    if ((int )*s < 48) {
      {
#line 207
      get_if_ip(s, iface->text);
      }
    } else
#line 206
    if ((int )*s > 57) {
      {
#line 207
      get_if_ip(s, iface->text);
      }
    } else {
      {
#line 209
      strcpy((char */* __restrict  */)(iface->text), (char const   */* __restrict  */)s);
      }
    }
#line 210
    s = s2 + 1;
#line 211
    if (*s) {
      {
#line 213
      iface->next = malloc(sizeof(if_t ));
#line 214
      iface = (if_t *)iface->next;
      }
    } else {
#line 218
      iface->next = (void *)conf->interfaces;
#line 219
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  return (1);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 28 "/home/june/collector/temp/axel-2.4/search.c"
static char *strrstr(char *haystack , char *needle ) ;
#line 29
static void *search_speedtest(void *r ) ;
#line 30
static int search_sortlist_qsort(void const   *a , void const   *b ) ;
#line 66 "/home/june/collector/temp/axel-2.4/search.c"
int search_makelist(search_t *results , char *url ) 
{ 
  int i ;
  int size ;
  int j ;
  char *s ;
  char *s1 ;
  char *s2 ;
  char *s3 ;
  conn_t conn[1] ;
  double t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  ssize_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 68
  size = 8192;
#line 68
  j = 0;
#line 73
  memset((void *)(conn), 0, sizeof(conn_t ));
#line 75
  conn[0].conf = results->conf;
#line 76
  t = gettime();
#line 77
  tmp = conn_set(conn, url);
  }
#line 77
  if (! tmp) {
#line 78
    return (-1);
  }
  {
#line 79
  tmp___0 = conn_init(conn);
  }
#line 79
  if (! tmp___0) {
#line 80
    return (-1);
  }
  {
#line 81
  tmp___1 = conn_info(conn);
  }
#line 81
  if (! tmp___1) {
#line 82
    return (-1);
  }
  {
#line 84
  strcpy((char */* __restrict  */)((results + 0)->url), (char const   */* __restrict  */)url);
#line 85
  tmp___2 = gettime();
#line 85
  (results + 0)->speed = (int )((double )1 + (double )1000 * (tmp___2 - t));
#line 86
  (results + 0)->size = (int )conn[0].size;
#line 88
  tmp___3 = malloc((size_t )size);
#line 88
  s = (char *)tmp___3;
#line 90
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"http://www.filesearching.com/cgi-bin/s?q=%s&w=a&l=en&t=f&e=on&m=%i&o=n&s1=%lld&s2=%lld&x=15&y=15",
          conn[0].file, (results->conf)->search_amount, conn[0].size, conn[0].size);
#line 95
  conn_disconnect(conn);
#line 96
  memset((void *)(conn), 0, sizeof(conn_t ));
#line 97
  conn[0].conf = results->conf;
#line 99
  tmp___4 = conn_set(conn, s);
  }
#line 99
  if (! tmp___4) {
    {
#line 101
    free((void *)s);
    }
#line 102
    return (1);
  }
  {
#line 104
  tmp___5 = conn_setup(conn);
  }
#line 104
  if (! tmp___5) {
    {
#line 106
    free((void *)s);
    }
#line 107
    return (1);
  }
  {
#line 109
  tmp___6 = conn_exec(conn);
  }
#line 109
  if (! tmp___6) {
    {
#line 111
    free((void *)s);
    }
#line 112
    return (1);
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 115
    tmp___8 = read(conn[0].fd, (void *)(s + j), (size_t )(size - j));
#line 115
    i = (int )tmp___8;
    }
#line 115
    if (! (i > 0)) {
#line 115
      goto while_break;
    }
#line 117
    j += i;
#line 118
    if (j + 10 >= size) {
      {
#line 120
      size *= 2;
#line 121
      tmp___7 = realloc((void *)s, (size_t )size);
#line 121
      s = (char *)tmp___7;
#line 122
      memset((void *)(s + size / 2), 0, (size_t )(size / 2));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  conn_disconnect(conn);
#line 128
  s1 = strstr((char const   *)s, "<pre class=list");
#line 129
  tmp___9 = strchr((char const   *)s1, '\n');
#line 129
  s1 = tmp___9 + 1;
#line 130
  tmp___10 = strstr((char const   *)s1, "</pre>");
  }
#line 130
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
    {
#line 133
    free((void *)s);
    }
#line 134
    return (1);
  }
#line 136
  i = 1;
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 136
    tmp___13 = strncmp((char const   *)s1, "</pre>", (size_t )6);
    }
#line 136
    if (tmp___13) {
#line 136
      if (i < (results->conf)->search_amount) {
#line 136
        if (! *s1) {
#line 136
          goto while_break___0;
        }
      } else {
#line 136
        goto while_break___0;
      }
    } else {
#line 136
      goto while_break___0;
    }
    {
#line 138
    s3 = strchr((char const   *)s1, '\n');
#line 138
    *s3 = (char)0;
#line 139
    tmp___11 = strrstr(s1, (char *)"<a href=");
#line 139
    s2 = tmp___11 + 8;
#line 140
    *s3 = (char )'\n';
#line 141
    s3 = strchr((char const   *)s2, ' ');
#line 141
    *s3 = (char)0;
#line 142
    tmp___12 = strcmp((char const   *)((results + 0)->url), (char const   *)s2);
    }
#line 142
    if (tmp___12) {
      {
#line 144
      strncpy((char */* __restrict  */)((results + i)->url), (char const   */* __restrict  */)s2,
              (size_t )1024);
#line 145
      (results + i)->size = (results + 0)->size;
#line 146
      (results + i)->conf = results->conf;
      }
    } else {
#line 151
      i --;
    }
#line 153
    s1 = s3;
    {
#line 153
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 153
      if (! ((int )*s1 != 10)) {
#line 153
        goto while_break___1;
      }
#line 153
      s1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 154
    s1 ++;
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 157
  free((void *)s);
  }
#line 159
  return (i);
}
}
#line 166 "/home/june/collector/temp/axel-2.4/search.c"
int search_getspeeds(search_t *results , int count ) 
{ 
  int i ;
  int running ;
  int done ;
  int correct ;
  int tmp ;
  double tmp___0 ;

  {
#line 168
  running = 0;
#line 168
  done = 0;
#line 168
  correct = 0;
#line 170
  i = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < count)) {
#line 170
      goto while_break;
    }
#line 170
    if ((results + i)->speed) {
#line 172
      (results + i)->speed_start_time = (double )0;
#line 173
      done ++;
#line 174
      if ((results + i)->speed > 0) {
#line 175
        correct ++;
      }
    }
#line 170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (done < count)) {
#line 178
      goto while_break___0;
    }
#line 180
    i = 0;
    {
#line 180
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 180
      if (! (i < count)) {
#line 180
        goto while_break___1;
      }
#line 182
      if (running < (results->conf)->search_threads) {
#line 182
        if (! (results + i)->speed) {
          {
#line 184
          (results + i)->speed = -1;
#line 185
          (results + i)->speed_start_time = gettime();
#line 186
          tmp = pthread_create((pthread_t */* __restrict  */)((results + i)->speed_thread),
                               (pthread_attr_t const   */* __restrict  */)((void *)0),
                               & search_speedtest, (void */* __restrict  */)(results + i));
          }
#line 186
          if (tmp == 0) {
#line 189
            running ++;
#line 190
            goto while_break___1;
          } else {
#line 194
            return (0);
          }
        } else {
#line 182
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 197
      if ((results + i)->speed == -1) {
        {
#line 197
        tmp___0 = gettime();
        }
#line 197
        if (tmp___0 > (results + i)->speed_start_time + (double )(results->conf)->search_timeout) {
          {
#line 200
          pthread_cancel((results + i)->speed_thread[0]);
#line 201
          (results + i)->speed = -3;
#line 202
          running --;
#line 203
          done ++;
          }
#line 204
          goto while_break___1;
        } else {
#line 197
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 206
      if ((results + i)->speed > 0) {
#line 206
        if ((results + i)->speed_start_time) {
#line 208
          (results + i)->speed_start_time = (double )0;
#line 209
          running --;
#line 210
          correct ++;
#line 211
          done ++;
#line 212
          goto while_break___1;
        } else {
#line 206
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 214
      if ((results + i)->speed == -2) {
#line 216
        (results + i)->speed = -3;
#line 217
        running --;
#line 218
        done ++;
#line 219
        goto while_break___1;
      }
#line 180
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 222
    if (i == count) {
      {
#line 224
      usleep((__useconds_t )100000);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 228
  return (correct);
}
}
#line 231 "/home/june/collector/temp/axel-2.4/search.c"
static void *search_speedtest(void *r ) 
{ 
  search_t *results ;
  conn_t conn[1] ;
  int oldstate ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 233
  results = (search_t *)r;
#line 238
  pthread_setcancelstate(0, & oldstate);
#line 239
  pthread_setcanceltype(1, & oldstate);
#line 241
  memset((void *)(conn), 0, sizeof(conn_t ));
#line 242
  conn[0].conf = results->conf;
#line 243
  tmp___2 = conn_set(conn, results->url);
  }
#line 243
  if (tmp___2) {
    {
#line 245
    tmp___1 = conn_init(conn);
    }
#line 245
    if (tmp___1) {
      {
#line 247
      tmp___0 = conn_info(conn);
      }
#line 247
      if (tmp___0) {
#line 249
        if (conn[0].size == (long long )results->size) {
          {
#line 251
          tmp = gettime();
#line 251
          results->speed = (int )((double )1 + (double )1000 * (tmp - results->speed_start_time));
          }
        } else {
#line 253
          results->speed = -2;
        }
      } else {
#line 248
        results->speed = -2;
      }
    } else {
#line 246
      results->speed = -2;
    }
  } else {
#line 244
    results->speed = -2;
  }
  {
#line 255
  conn_disconnect(conn);
  }
#line 257
  return ((void *)0);
}
}
#line 260 "/home/june/collector/temp/axel-2.4/search.c"
static char *strrstr(char *haystack , char *needle ) 
{ 
  int i ;
  int j ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 264
  tmp = strlen((char const   *)haystack);
#line 264
  tmp___0 = strlen((char const   *)needle);
#line 264
  i = (int )(tmp - tmp___0);
  }
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! (i > 0)) {
#line 264
      goto while_break;
    }
#line 266
    j = 0;
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (*(needle + j)) {
#line 266
        if (! ((int )*(haystack + (i + j)) == (int )*(needle + j))) {
#line 266
          goto while_break___0;
        }
      } else {
#line 266
        goto while_break___0;
      }
#line 266
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 267
    if (! *(needle + j)) {
#line 268
      return (haystack + i);
    }
#line 264
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  return ((char *)((void *)0));
}
}
#line 274 "/home/june/collector/temp/axel-2.4/search.c"
void search_sortlist(search_t *results , int count ) 
{ 


  {
  {
#line 276
  qsort((void *)results, (size_t )count, sizeof(search_t ), & search_sortlist_qsort);
  }
#line 277
  return;
}
}
#line 279 "/home/june/collector/temp/axel-2.4/search.c"
static int search_sortlist_qsort(void const   *a , void const   *b ) 
{ 


  {
#line 281
  if (((search_t *)a)->speed < 0) {
#line 281
    if (((search_t *)b)->speed > 0) {
#line 282
      return (1);
    }
  }
#line 283
  if (((search_t *)a)->speed > 0) {
#line 283
    if (((search_t *)b)->speed < 0) {
#line 284
      return (-1);
    }
  }
#line 285
  if (((search_t *)a)->speed < ((search_t *)b)->speed) {
#line 286
    return (-1);
  } else {
#line 288
    return (((search_t *)a)->speed > ((search_t *)b)->speed);
  }
}
}
