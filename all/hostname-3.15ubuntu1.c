/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_20 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_20 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 29 "/usr/include/ifaddrs.h"
union __anonunion_ifa_ifu_21 {
   struct sockaddr *ifu_broadaddr ;
   struct sockaddr *ifu_dstaddr ;
};
#line 29 "/usr/include/ifaddrs.h"
struct ifaddrs {
   struct ifaddrs *ifa_next ;
   char *ifa_name ;
   unsigned int ifa_flags ;
   struct sockaddr *ifa_addr ;
   struct sockaddr *ifa_netmask ;
   union __anonunion_ifa_ifu_21 ifa_ifu ;
   void *ifa_data ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
enum type_t {
    DEFAULT = 0,
    DNS = 1,
    FQDN = 2,
    SHORT = 3,
    ALIAS = 4,
    IP = 5,
    NIS = 6,
    NIS_DEF = 7,
    ALL_FQDNS = 8,
    ALL_IPS = 9
} ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 66 "/usr/include/ifaddrs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getifaddrs)(struct ifaddrs **__ifap ) ;
#line 69
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeifaddrs)(struct ifaddrs *__ifa ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 886
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sethostname)(char const   *__name ,
                                                                                                  size_t __len ) ;
#line 897
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) getdomainname)(char *__name ,
                                                                                                    size_t __len ) ;
#line 899
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) setdomainname)(char const   *__name ,
                                                                                                    size_t __len ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 277
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchrnul)(char const   *__s ,
                                                                                                  int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 517
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 95
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) hstrerror)(int __err_num ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/err.h"
extern  __attribute__((__noreturn__)) void ( /* format attribute */  err)(int __status ,
                                                                          char const   *__format 
                                                                          , ...) ;
#line 50
extern  __attribute__((__noreturn__)) void ( /* format attribute */  errx)(int __status ,
                                                                           char const   *__format 
                                                                           , ...) ;
#line 63 "/usr/include/rpcsvc/ypclnt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) yp_get_default_domain)(char ** ) ;
#line 74
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) yperr_string)(int const    ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
char *progname  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
char *localnisdomain(void) 
{ 
  char *buf ;
  int myerror ;
  char const   *tmp ;

  {
  {
#line 61
  buf = (char *)0;
#line 62
  myerror = 0;
#line 64
  myerror = yp_get_default_domain(& buf);
  }
#line 67
  if (myerror) {
    {
#line 68
    tmp = yperr_string((int const   )myerror);
#line 68
    printf((char const   */* __restrict  */)"%s: %s\n", progname, tmp);
#line 69
    exit(1);
    }
  }
#line 72
  return (buf);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
char *localdomain(void) 
{ 
  char *buf ;
  size_t buf_len ;
  int myerror ;
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;

  {
#line 84
  buf = (char *)0;
#line 85
  buf_len = (size_t )0;
#line 86
  myerror = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    tmp = __errno_location();
#line 89
    *tmp = 0;
    }
#line 91
    if (buf) {
      {
#line 92
      buf_len += buf_len;
#line 93
      tmp___0 = realloc((void *)buf, buf_len);
#line 93
      buf = (char *)tmp___0;
      }
#line 93
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
        {
#line 94
        err(1, (char const   *)((void *)0));
        }
      }
    } else {
      {
#line 96
      buf_len = (size_t )128;
#line 97
      tmp___1 = malloc(buf_len);
#line 97
      buf = (char *)tmp___1;
      }
#line 97
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
        {
#line 98
        err(1, (char const   *)((void *)0));
        }
      }
    }
    {
#line 88
    myerror = getdomainname(buf, buf_len);
    }
#line 88
    if (myerror == 0) {
      {
#line 88
      tmp___2 = memchr((void const   *)buf, '\000', buf_len);
      }
#line 88
      if (tmp___2) {
#line 88
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 88
      tmp___3 = __errno_location();
      }
#line 88
      if (! (*tmp___3 == 36)) {
#line 88
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (myerror) {
    {
#line 105
    err(1, (char const   *)((void *)0));
    }
  }
#line 107
  return (buf);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
char *localhost(void) 
{ 
  char *buf ;
  size_t buf_len ;
  int myerror ;
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;

  {
#line 119
  buf = (char *)0;
#line 120
  buf_len = (size_t )0;
#line 121
  myerror = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 124
    tmp = __errno_location();
#line 124
    *tmp = 0;
    }
#line 126
    if (buf) {
      {
#line 127
      buf_len += buf_len;
#line 128
      tmp___0 = realloc((void *)buf, buf_len);
#line 128
      buf = (char *)tmp___0;
      }
#line 128
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
        {
#line 129
        err(1, (char const   *)((void *)0));
        }
      }
    } else {
      {
#line 131
      buf_len = (size_t )128;
#line 132
      tmp___1 = malloc(buf_len);
#line 132
      buf = (char *)tmp___1;
      }
#line 132
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
        {
#line 133
        err(1, (char const   *)((void *)0));
        }
      }
    }
    {
#line 123
    myerror = gethostname(buf, buf_len);
    }
#line 123
    if (myerror == 0) {
      {
#line 123
      tmp___2 = memchr((void const   *)buf, '\000', buf_len);
      }
#line 123
      if (tmp___2) {
#line 123
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 123
      tmp___3 = __errno_location();
      }
#line 123
      if (! (*tmp___3 == 36)) {
#line 123
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (myerror) {
    {
#line 140
    err(1, (char const   *)((void *)0));
    }
  }
#line 142
  return (buf);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
void usage(FILE *stream ) 
{ 


  {
  {
#line 148
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Usage: hostname [-b] {hostname|-F file}         set host name (from file)\n       hostname [-a|-A|-d|-f|-i|-I|-s|-y]       display formatted name\n       hostname                                 display host name\n\n       {yp,nis,}domainname {nisdomain|-F file}  set NIS domain name (from file)\n       {yp,nis,}domainname                      display NIS domain name\n\n       dnsdomainname                            display dns domain name\n\n       hostname -V|--version|-h|--help          print info and exit\n\nProgram name:\n       {yp,nis,}domainname=hostname -y\n       dnsdomainname=hostname -d\n\nProgram options:\n    -a, --alias            alias names\n    -A, --all-fqdns        all long host names (FQDNs)\n    -b, --boot             set default hostname if none available\n    -d, --domain           DNS domain name\n    -f, --fqdn, --long     long host name (FQDN)\n    -F, --file             read host name or NIS domain name from given file\n    -i, --ip-address       addresses for the host name\n    -I, --all-ip-addresses all addresses for the host\n    -s, --short            short host name\n    -y, --yp, --nis        NIS/YP domain name\n\nDescription:\n   This command can get or set the host name or the NIS domain name. You can\n   also get the DNS domain or the FQDN (fully qualified domain name).\n   Unless you are using bind or NIS for host lookups you can change the\n   FQDN (Fully Qualified Domain Name) and the DNS domain name (which is\n   part of the FQDN) in the /etc/hosts file.\n");
#line 182
  exit(-1);
  }
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
int check_name(char *name ) 
{ 
  int i ;
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 192
  tmp = strlen((char const   *)name);
#line 192
  len = (int )tmp;
  }
#line 195
  if (! len) {
#line 196
    return (0);
  } else {
    {
#line 195
    tmp___0 = __ctype_b_loc();
    }
#line 195
    if ((int const   )*(*tmp___0 + (int )*(name + 0)) & 8) {
      {
#line 195
      tmp___1 = __ctype_b_loc();
      }
#line 195
      if (! ((int const   )*(*tmp___1 + (int )*(name + (len - 1))) & 8)) {
#line 196
        return (0);
      }
    } else {
#line 196
      return (0);
    }
  }
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i < len)) {
#line 198
      goto while_break;
    }
    {
#line 199
    tmp___2 = __ctype_b_loc();
    }
#line 199
    if (! ((int const   )*(*tmp___2 + (int )*(name + i)) & 8)) {
#line 199
      if ((int )*(name + i) != 45) {
#line 199
        if ((int )*(name + i) != 46) {
#line 200
          return (0);
        }
      }
    }
#line 201
    if ((int )*(name + i) == 45) {
#line 201
      if ((int )*(name + (i - 1)) == 46) {
#line 202
        return (0);
      } else
#line 201
      if ((int )*(name + (i + 1)) == 46) {
#line 202
        return (0);
      }
    }
#line 203
    if ((int )*(name + i) == 46) {
#line 203
      if ((int )*(name + (i - 1)) == 46) {
#line 204
        return (0);
      }
    }
#line 198
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return (1);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
void set_name(enum type_t type , char *name ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
  {
#line 216
  if ((unsigned int )type == 0U) {
#line 216
    goto case_0;
  }
#line 236
  if ((unsigned int )type == 7U) {
#line 236
    goto case_7;
  }
#line 236
  if ((unsigned int )type == 6U) {
#line 236
    goto case_7;
  }
#line 245
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 219
    tmp = __ctype_b_loc();
    }
#line 219
    if (! ((int const   )*(*tmp + (int )*name) & 8192)) {
#line 219
      goto while_break;
    }
#line 219
    name ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  tmp___0 = strlen((char const   *)name);
#line 220
  i = (int )(tmp___0 - 1UL);
  }
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 220
    if (i >= 0) {
      {
#line 220
      tmp___1 = __ctype_b_loc();
      }
#line 220
      if (! ((int const   )*(*tmp___1 + (int )*(name + i)) & 8192)) {
#line 220
        goto while_break___0;
      }
    } else {
#line 220
      goto while_break___0;
    }
#line 220
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 221
  *(name + (i + 1)) = (char )'\000';
#line 224
  tmp___2 = check_name(name);
  }
#line 224
  if (! tmp___2) {
    {
#line 225
    errx(1, "the specified hostname is invalid");
    }
  }
  {
#line 227
  tmp___5 = strlen((char const   *)name);
#line 227
  tmp___6 = sethostname((char const   *)name, tmp___5);
  }
#line 227
  if (tmp___6) {
    {
#line 228
    tmp___4 = __errno_location();
    }
#line 228
    if (*tmp___4 == 1) {
      {
#line 229
      errx(1, "you must be root to change the host name");
      }
    } else {
      {
#line 230
      tmp___3 = __errno_location();
      }
#line 230
      if (*tmp___3 == 22) {
        {
#line 231
        errx(1, "name too long");
        }
      }
    }
  }
#line 233
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 237
  tmp___9 = strlen((char const   *)name);
#line 237
  tmp___10 = setdomainname((char const   *)name, tmp___9);
  }
#line 237
  if (tmp___10) {
    {
#line 238
    tmp___8 = __errno_location();
    }
#line 238
    if (*tmp___8 == 1) {
      {
#line 239
      errx(1, "you must be root to change the domain name");
      }
    } else {
      {
#line 240
      tmp___7 = __errno_location();
      }
#line 240
      if (*tmp___7 == 22) {
        {
#line 241
        errx(1, "name too long");
        }
      }
    }
  }
#line 243
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 250
  usage(stderr);
  }
  switch_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
void show_name(enum type_t type ) 
{ 
  struct addrinfo *res ;
  struct addrinfo hints ;
  struct ifaddrs *ifa ;
  struct ifaddrs *ifap ;
  char *p ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char buf[46] ;
  int flags ;
  int ret___0 ;
  int family ;
  int addrlen ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  struct sockaddr_in6 *sin6 ;
  struct in6_addr  const  *__a ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  struct hostent *hp ;
  int i ;
  int *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char buf___0[46] ;
  int ret___1 ;
  struct addrinfo *walk ;
  char const   *tmp___13 ;

  {
  {
#line 266
  if ((unsigned int )type == 0U) {
#line 266
    goto case_0;
  }
#line 269
  if ((unsigned int )type == 3U) {
#line 269
    goto case_3;
  }
#line 274
  if ((unsigned int )type == 6U) {
#line 274
    goto case_6;
  }
#line 277
  if ((unsigned int )type == 7U) {
#line 277
    goto case_7;
  }
#line 281
  if ((unsigned int )type == 8U) {
#line 281
    goto case_8;
  }
#line 281
  if ((unsigned int )type == 9U) {
#line 281
    goto case_8;
  }
#line 333
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 267
  tmp = localhost();
#line 267
  printf((char const   */* __restrict  */)"%s\n", tmp);
  }
#line 268
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 270
  p = localhost();
#line 271
  tmp___0 = strchrnul((char const   *)p, '.');
#line 271
  *tmp___0 = (char )'\000';
#line 272
  printf((char const   */* __restrict  */)"%s\n", p);
  }
#line 273
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 275
  tmp___1 = localdomain();
#line 275
  printf((char const   */* __restrict  */)"%s\n", tmp___1);
  }
#line 276
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 278
  tmp___2 = localnisdomain();
#line 278
  printf((char const   */* __restrict  */)"%s\n", tmp___2);
  }
#line 279
  goto switch_break;
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 286
  if ((unsigned int )type == 9U) {
#line 286
    flags = 1;
  } else {
#line 286
    flags = 8;
  }
  {
#line 288
  tmp___5 = getifaddrs(& ifa);
  }
#line 288
  if (tmp___5 != 0) {
    {
#line 289
    tmp___3 = __errno_location();
#line 289
    tmp___4 = strerror(*tmp___3);
#line 289
    errx(1, "%s", tmp___4);
    }
  }
#line 290
  ifap = ifa;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! ((unsigned long )ifap != (unsigned long )((void *)0))) {
#line 290
      goto while_break;
    }
#line 292
    if ((unsigned long )ifap->ifa_addr == (unsigned long )((void *)0)) {
#line 293
      goto __Cont;
    }
#line 295
    if (ifap->ifa_flags & 8U) {
#line 296
      goto __Cont;
    }
#line 298
    if (! (ifap->ifa_flags & 1U)) {
#line 299
      goto __Cont;
    }
#line 302
    family = (int )(ifap->ifa_addr)->sa_family;
#line 303
    if (family != 2) {
#line 303
      if (family != 10) {
#line 304
        goto __Cont;
      }
    }
#line 306
    if (family == 2) {
#line 306
      addrlen = (int )sizeof(struct sockaddr_in );
    } else {
#line 306
      addrlen = (int )sizeof(struct sockaddr_in6 );
    }
#line 310
    if (family == 10) {
      {
#line 313
      sin6 = (struct sockaddr_in6 *)ifap->ifa_addr;
#line 314
      __a = (struct in6_addr  const  *)(& sin6->sin6_addr);
#line 314
      tmp___6 = htonl(4290772992U);
#line 314
      tmp___7 = htonl(4269801472U);
      }
#line 314
      if ((__a->__in6_u.__u6_addr32[0] & tmp___6) == tmp___7) {
#line 316
        goto __Cont;
      } else
#line 314
      if ((int const   )*((uint8_t const   *)(& sin6->sin6_addr) + 0) == 255) {
#line 314
        if (((int const   )*((uint8_t const   *)(& sin6->sin6_addr) + 1) & 15) == 2) {
#line 316
          goto __Cont;
        }
      }
    }
    {
#line 319
    ret___0 = getnameinfo((struct sockaddr  const  */* __restrict  */)ifap->ifa_addr,
                          (socklen_t )addrlen, (char */* __restrict  */)(buf), (socklen_t )sizeof(buf),
                          (char */* __restrict  */)((void *)0), (socklen_t )0, flags);
    }
#line 323
    if (ret___0 != 0) {
#line 324
      if ((unsigned int )type != 8U) {
#line 324
        if (ret___0 != -2) {
          {
#line 325
          tmp___8 = gai_strerror(ret___0);
#line 325
          errx(1, "%s", tmp___8);
          }
        }
      }
    } else {
      {
#line 327
      printf((char const   */* __restrict  */)"%s ", buf);
      }
    }
    __Cont: /* CIL Label */ 
#line 290
    ifap = ifap->ifa_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 329
  printf((char const   */* __restrict  */)"\n");
#line 330
  freeifaddrs(ifa);
  }
#line 331
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 334
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 335
  hints.ai_socktype = 2;
#line 336
  hints.ai_flags = 2;
#line 338
  p = localhost();
#line 339
  ret = getaddrinfo((char const   */* __restrict  */)p, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 339
  if (ret != 0) {
    {
#line 340
    tmp___9 = gai_strerror(ret);
#line 340
    errx(1, "%s", tmp___9);
    }
  }
  {
#line 342
  p = strchr((char const   *)res->ai_canonname, '.');
  }
  {
#line 345
  if ((unsigned int )type == 4U) {
#line 345
    goto case_4;
  }
#line 361
  if ((unsigned int )type == 5U) {
#line 361
    goto case_5;
  }
#line 382
  if ((unsigned int )type == 1U) {
#line 382
    goto case_1;
  }
#line 387
  if ((unsigned int )type == 2U) {
#line 387
    goto case_2;
  }
#line 391
  goto switch_default___0;
  case_4: /* CIL Label */ 
  {
#line 349
  tmp___12 = localhost();
#line 349
  hp = gethostbyname((char const   *)tmp___12);
  }
#line 349
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    {
#line 350
    tmp___10 = __h_errno_location();
#line 350
    tmp___11 = hstrerror(*tmp___10);
#line 350
    errx(1, "%s", tmp___11);
    }
  }
#line 352
  i = 0;
  {
#line 352
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 352
    if (! *(hp->h_aliases + i)) {
#line 352
      goto while_break___0;
    }
#line 353
    if (i > 0) {
      {
#line 354
      printf((char const   */* __restrict  */)" ");
      }
    }
    {
#line 355
    printf((char const   */* __restrict  */)"%s", *(hp->h_aliases + i));
#line 352
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 357
  printf((char const   */* __restrict  */)"\n");
  }
#line 358
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 367
  walk = res;
  {
#line 367
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 367
    if (! ((unsigned long )walk != (unsigned long )((void *)0))) {
#line 367
      goto while_break___1;
    }
    {
#line 368
    ret___1 = getnameinfo((struct sockaddr  const  */* __restrict  */)walk->ai_addr,
                          walk->ai_addrlen, (char */* __restrict  */)(buf___0), (socklen_t )sizeof(buf___0),
                          (char */* __restrict  */)((void *)0), (socklen_t )0, 1);
    }
#line 368
    if (ret___1 != 0) {
      {
#line 371
      tmp___13 = gai_strerror(ret___1);
#line 371
      errx(1, "%s", tmp___13);
      }
    }
#line 373
    if ((unsigned long )walk != (unsigned long )res) {
      {
#line 374
      printf((char const   */* __restrict  */)" ");
      }
    }
    {
#line 376
    printf((char const   */* __restrict  */)"%s", buf___0);
#line 367
    walk = walk->ai_next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 378
  printf((char const   */* __restrict  */)"\n");
  }
#line 379
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 383
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 384
    p ++;
#line 384
    printf((char const   */* __restrict  */)"%s\n", p);
    }
  }
#line 385
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 388
  printf((char const   */* __restrict  */)"%s\n", res->ai_canonname);
  }
#line 389
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 392
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 394
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 396
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
char *read_file(char *filename , int boot ) 
{ 
  struct stat st ;
  FILE *fp ;
  char *buf ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *p ;
  char *tmp___2 ;

  {
  {
#line 405
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 405
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 406
    if (boot) {
#line 407
      return ((char *)((void *)0));
    } else {
      {
#line 409
      err(1, (char const   *)((void *)0));
      }
    }
  }
  {
#line 412
  tmp = fileno(fp);
#line 412
  tmp___0 = fstat(tmp, & st);
  }
#line 412
  if (tmp___0 == -1) {
    {
#line 414
    err(1, (char const   *)((void *)0));
    }
  } else {
    {
#line 412
    tmp___1 = malloc((size_t )(st.st_size + 1L));
#line 412
    buf = (char *)tmp___1;
    }
#line 412
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 414
      err(1, (char const   *)((void *)0));
      }
    }
  }
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 416
    tmp___2 = fgets((char */* __restrict  */)buf, (int )(st.st_size + 1L), (FILE */* __restrict  */)fp);
    }
#line 416
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 416
      goto while_break;
    }
#line 419
    if ((int )*(buf + 0) == 10) {
#line 420
      goto while_continue;
    } else
#line 419
    if ((int )*(buf + 0) == 35) {
#line 420
      goto while_continue;
    }
    {
#line 422
    p = strchr((char const   *)buf, '\n');
    }
#line 422
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 423
      *p = (char )'\000';
    }
#line 424
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  fclose(fp);
  }
#line 428
  return (buf);
}
}
#line 439
int main(int argc , char **argv ) ;
#line 439 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
static struct option  const  long_options[15]  = 
#line 439
  {      {"domain", 0, (int *)0, 'd'}, 
        {"boot", 0, (int *)0, 'b'}, 
        {"file", 1, (int *)0, 'F'}, 
        {"fqdn", 0, (int *)0, 'f'}, 
        {"all-fqdns", 0, (int *)0, 'A'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"long", 0, (int *)0, 'f'}, 
        {"short", 0, (int *)0, 's'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"alias", 0, (int *)0, 'a'}, 
        {"ip-address", 0, (int *)0, 'i'}, 
        {"all-ip-addresses", 0, (int *)0, 'I'}, 
        {"nis", 0, (int *)0, 'y'}, 
        {"yp", 0, (int *)0, 'y'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 431 "/home/june/repo/benchmarks/collector/temp/hostname-3.15ubuntu1/hostname.c"
int main(int argc , char **argv ) 
{ 
  char *file ;
  char *name ;
  enum type_t type ;
  int boot ;
  int o ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 434
  file = (char *)((void *)0);
#line 434
  name = (char *)((void *)0);
#line 435
  type = (enum type_t )0;
#line 436
  boot = 0;
#line 459
  tmp___1 = rindex((char const   *)*(argv + 0), '/');
  }
#line 459
  if (tmp___1) {
    {
#line 459
    tmp___0 = rindex((char const   *)*(argv + 0), '/');
#line 459
    progname = tmp___0 + 1;
    }
  } else {
#line 459
    progname = *(argv + 0);
  }
  {
#line 460
  tmp___5 = strcmp((char const   *)progname, "dnsdomainname");
  }
#line 460
  if (tmp___5) {
    {
#line 462
    tmp___4 = strcmp((char const   *)progname, "domainname");
    }
#line 462
    if (tmp___4) {
      {
#line 464
      tmp___3 = strcmp((char const   *)progname, "ypdomainname");
      }
#line 464
      if (tmp___3) {
        {
#line 466
        tmp___2 = strcmp((char const   *)progname, "nisdomainname");
        }
#line 466
        if (! tmp___2) {
#line 467
          type = (enum type_t )7;
        }
      } else {
#line 465
        type = (enum type_t )7;
      }
    } else {
#line 463
      type = (enum type_t )6;
    }
  } else {
#line 461
    type = (enum type_t )1;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 469
    o = getopt_long(argc, (char * const  *)argv, "aAdfbF:h?iIsVy", long_options, (int *)((void *)0));
    }
#line 469
    if (! (o != -1)) {
#line 469
      goto while_break;
    }
    {
#line 471
    if (o == 100) {
#line 471
      goto case_100;
    }
#line 474
    if (o == 97) {
#line 474
      goto case_97;
    }
#line 477
    if (o == 102) {
#line 477
      goto case_102;
    }
#line 480
    if (o == 65) {
#line 480
      goto case_65;
    }
#line 483
    if (o == 105) {
#line 483
      goto case_105;
    }
#line 486
    if (o == 73) {
#line 486
      goto case_73;
    }
#line 489
    if (o == 115) {
#line 489
      goto case_115;
    }
#line 492
    if (o == 121) {
#line 492
      goto case_121;
    }
#line 495
    if (o == 98) {
#line 495
      goto case_98;
    }
#line 498
    if (o == 70) {
#line 498
      goto case_70;
    }
#line 501
    if (o == 86) {
#line 501
      goto case_86;
    }
#line 505
    if (o == 104) {
#line 505
      goto case_104;
    }
#line 505
    if (o == 63) {
#line 505
      goto case_104;
    }
#line 508
    goto switch_default;
    case_100: /* CIL Label */ 
#line 472
    type = (enum type_t )1;
#line 473
    goto switch_break;
    case_97: /* CIL Label */ 
#line 475
    type = (enum type_t )4;
#line 476
    goto switch_break;
    case_102: /* CIL Label */ 
#line 478
    type = (enum type_t )2;
#line 479
    goto switch_break;
    case_65: /* CIL Label */ 
#line 481
    type = (enum type_t )8;
#line 482
    goto switch_break;
    case_105: /* CIL Label */ 
#line 484
    type = (enum type_t )5;
#line 485
    goto switch_break;
    case_73: /* CIL Label */ 
#line 487
    type = (enum type_t )9;
#line 488
    goto switch_break;
    case_115: /* CIL Label */ 
#line 490
    type = (enum type_t )3;
#line 491
    goto switch_break;
    case_121: /* CIL Label */ 
#line 493
    type = (enum type_t )7;
#line 494
    goto switch_break;
    case_98: /* CIL Label */ 
#line 496
    boot = 1;
#line 497
    goto switch_break;
    case_70: /* CIL Label */ 
#line 499
    file = optarg;
#line 500
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 502
    printf((char const   */* __restrict  */)"hostname %s\n", "3.15");
    }
#line 503
    return (0);
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 506
    usage(stdout);
    }
#line 507
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 509
    usage(stderr);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  if (file) {
    {
#line 518
    name = read_file(file, boot);
    }
#line 519
    if (boot) {
#line 519
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 519
        goto _L;
      } else
#line 519
      if ((int )*(name + 0) == 0) {
        _L: /* CIL Label */ 
        {
#line 520
        free((void *)name);
#line 522
        name = localhost();
        }
#line 523
        if ((int )*(name + 0) == 0) {
          {
#line 524
          strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)"localhost");
          }
        } else {
          {
#line 523
          tmp___6 = strcmp((char const   *)name, "(none)");
          }
#line 523
          if (! tmp___6) {
            {
#line 524
            strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)"localhost");
            }
          }
        }
      }
    }
  }
#line 529
  if (optind < argc) {
#line 534
    if (name) {
      {
#line 535
      usage(stderr);
      }
    }
    {
#line 537
    name = strdup((char const   *)*(argv + optind));
    }
#line 537
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 538
      err(1, (char const   *)((void *)0));
      }
    }
#line 539
    optind ++;
  }
#line 543
  if (optind < argc) {
    {
#line 544
    usage(stderr);
    }
  }
#line 546
  if (name) {
    {
#line 547
    set_name(type, name);
#line 548
    free((void *)name);
    }
  } else {
    {
#line 550
    show_name(type);
    }
  }
#line 552
  return (0);
}
}
