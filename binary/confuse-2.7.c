/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 68 "../src/confuse.h"
enum cfg_type_t {
    CFGT_NONE = 0,
    CFGT_INT = 1,
    CFGT_FLOAT = 2,
    CFGT_STR = 3,
    CFGT_BOOL = 4,
    CFGT_SEC = 5,
    CFGT_FUNC = 6,
    CFGT_PTR = 7
} ;
#line 78 "../src/confuse.h"
typedef enum cfg_type_t cfg_type_t;
#line 99
union cfg_value_t;
#line 99 "../src/confuse.h"
typedef union cfg_value_t cfg_value_t;
#line 100
struct cfg_opt_t;
#line 100 "../src/confuse.h"
typedef struct cfg_opt_t cfg_opt_t;
#line 101
struct cfg_t;
#line 101 "../src/confuse.h"
typedef struct cfg_t cfg_t;
#line 102
struct cfg_defvalue_t;
#line 102 "../src/confuse.h"
typedef struct cfg_defvalue_t cfg_defvalue_t;
#line 103 "../src/confuse.h"
typedef int cfg_flag_t;
#line 205
enum __anonenum_cfg_bool_t_6 {
    cfg_false = 0,
    cfg_true = 1
} ;
#line 205 "../src/confuse.h"
typedef enum __anonenum_cfg_bool_t_6 cfg_bool_t;
#line 214 "../src/confuse.h"
struct cfg_t {
   cfg_flag_t flags ;
   char *name ;
   cfg_opt_t *opts ;
   char *title ;
   char *filename ;
   int line ;
   void (*errfunc)(cfg_t *cfg , char const   *fmt , va_list ap ) ;
};
#line 231 "../src/confuse.h"
union cfg_value_t {
   long number ;
   double fpnumber ;
   cfg_bool_t boolean ;
   char *string ;
   cfg_t *section ;
   void *ptr ;
};
#line 243 "../src/confuse.h"
struct cfg_defvalue_t {
   long number ;
   double fpnumber ;
   cfg_bool_t boolean ;
   char *string ;
   char *parsed ;
};
#line 257 "../src/confuse.h"
struct cfg_opt_t {
   char *name ;
   cfg_type_t type ;
   unsigned int nvalues ;
   cfg_value_t **values ;
   cfg_flag_t flags ;
   cfg_opt_t *subopts ;
   cfg_defvalue_t def ;
   int (*func)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ) ;
   void *simple_value ;
   int (*parsecb)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ) ;
   int (*validcb)(cfg_t *cfg , cfg_opt_t *opt ) ;
   void (*pf)(cfg_opt_t *opt , unsigned int index , FILE *fp ) ;
   void (*freecb)(void *value ) ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 71 "lexer.c"
typedef short flex_int16_t;
#line 72 "lexer.c"
typedef int flex_int32_t;
#line 172
struct yy_buffer_state;
#line 172 "lexer.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 203 "lexer.c"
typedef size_t yy_size_t;
#line 208 "lexer.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 357 "lexer.c"
typedef unsigned char YY_CHAR;
#line 361 "lexer.c"
typedef int yy_state_type;
#line 45 "lexer.l"
typedef char *YYSTYPE;
#line 59 "lexer.l"
struct __anonstruct_cfg_include_stack_26 {
   YY_BUFFER_STATE state ;
   char *filename ;
   unsigned int line ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 153 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.h"
typedef void (*cfg_print_func_t)(cfg_opt_t *opt , unsigned int index , FILE *fp );
#line 192 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.h"
typedef int (*cfg_validate_callback_t)(cfg_t *cfg , cfg_opt_t *opt );
#line 208 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.h"
typedef void (*cfg_errfunc_t)(cfg_t *cfg , char const   *fmt , va_list ap );
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 538 "../src/confuse.h"
cfg_t *cfg_init(cfg_opt_t *opts , cfg_flag_t flags ) ;
#line 553
int cfg_parse(cfg_t *cfg___0 , char const   *filename ) ;
#line 575
int cfg_parse_buf(cfg_t *cfg___0 , char const   *buf ) ;
#line 587
void cfg_free(cfg_t *cfg___0 ) ;
#line 625
long cfg_getint(cfg_t *cfg___0 , char const   *name ) ;
#line 677
char *cfg_getstr(cfg_t *cfg___0 , char const   *name ) ;
#line 736
cfg_t *cfg_getnsec(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) ;
#line 791
unsigned int cfg_size(cfg_t *cfg___0 , char const   *name ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/reread.c"
cfg_t *cfg  =    (cfg_t *)0;
#line 7 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/reread.c"
char const   *config_filename  =    "./reread.conf";
#line 9 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/reread.c"
void read_config(void) 
{ 
  cfg_opt_t arg_opts[2] ;
  cfg_opt_t opts[4] ;
  int ret ;
  char *buf ;

  {
  {
#line 11
  arg_opts[0].name = (char *)"value";
#line 11
  arg_opts[0].type = (cfg_type_t )3;
#line 11
  arg_opts[0].nvalues = 0U;
#line 11
  arg_opts[0].values = (cfg_value_t **)0;
#line 11
  arg_opts[0].flags = 0;
#line 11
  arg_opts[0].subopts = (cfg_opt_t *)0;
#line 11
  arg_opts[0].def.number = 0L;
#line 11
  arg_opts[0].def.fpnumber = (double )0;
#line 11
  arg_opts[0].def.boolean = (cfg_bool_t )0;
#line 11
  arg_opts[0].def.string = (char *)"default";
#line 11
  arg_opts[0].def.parsed = (char *)0;
#line 11
  arg_opts[0].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 11
  arg_opts[0].simple_value = (void *)0;
#line 11
  arg_opts[0].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value ,
                                 void *result ))0;
#line 11
  arg_opts[0].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 11
  arg_opts[0].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 11
  arg_opts[0].freecb = (void (*)(void *value ))0;
#line 11
  arg_opts[1].name = (char *)0;
#line 11
  arg_opts[1].type = (cfg_type_t )0;
#line 11
  arg_opts[1].nvalues = 0U;
#line 11
  arg_opts[1].values = (cfg_value_t **)0;
#line 11
  arg_opts[1].flags = 0;
#line 11
  arg_opts[1].subopts = (cfg_opt_t *)0;
#line 11
  arg_opts[1].def.number = 0L;
#line 11
  arg_opts[1].def.fpnumber = (double )0;
#line 11
  arg_opts[1].def.boolean = (cfg_bool_t )0;
#line 11
  arg_opts[1].def.string = (char *)0;
#line 11
  arg_opts[1].def.parsed = (char *)0;
#line 11
  arg_opts[1].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 11
  arg_opts[1].simple_value = (void *)0;
#line 11
  arg_opts[1].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value ,
                                 void *result ))0;
#line 11
  arg_opts[1].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 11
  arg_opts[1].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 11
  arg_opts[1].freecb = (void (*)(void *value ))0;
#line 15
  opts[0].name = (char *)"delay";
#line 15
  opts[0].type = (cfg_type_t )1;
#line 15
  opts[0].nvalues = 0U;
#line 15
  opts[0].values = (cfg_value_t **)0;
#line 15
  opts[0].flags = 0;
#line 15
  opts[0].subopts = (cfg_opt_t *)0;
#line 15
  opts[0].def.number = 3L;
#line 15
  opts[0].def.fpnumber = (double )0;
#line 15
  opts[0].def.boolean = (cfg_bool_t )0;
#line 15
  opts[0].def.string = (char *)0;
#line 15
  opts[0].def.parsed = (char *)0;
#line 15
  opts[0].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 15
  opts[0].simple_value = (void *)0;
#line 15
  opts[0].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 15
  opts[0].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 15
  opts[0].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 15
  opts[0].freecb = (void (*)(void *value ))0;
#line 15
  opts[1].name = (char *)"message";
#line 15
  opts[1].type = (cfg_type_t )3;
#line 15
  opts[1].nvalues = 0U;
#line 15
  opts[1].values = (cfg_value_t **)0;
#line 15
  opts[1].flags = 0;
#line 15
  opts[1].subopts = (cfg_opt_t *)0;
#line 15
  opts[1].def.number = 0L;
#line 15
  opts[1].def.fpnumber = (double )0;
#line 15
  opts[1].def.boolean = (cfg_bool_t )0;
#line 15
  opts[1].def.string = (char *)"This is a message";
#line 15
  opts[1].def.parsed = (char *)0;
#line 15
  opts[1].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 15
  opts[1].simple_value = (void *)0;
#line 15
  opts[1].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 15
  opts[1].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 15
  opts[1].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 15
  opts[1].freecb = (void (*)(void *value ))0;
#line 15
  opts[2].name = (char *)"argument";
#line 15
  opts[2].type = (cfg_type_t )5;
#line 15
  opts[2].nvalues = 0U;
#line 15
  opts[2].values = (cfg_value_t **)0;
#line 15
  opts[2].flags = 9;
#line 15
  opts[2].subopts = arg_opts;
#line 15
  opts[2].def.number = 0L;
#line 15
  opts[2].def.fpnumber = (double )0;
#line 15
  opts[2].def.boolean = (cfg_bool_t )0;
#line 15
  opts[2].def.string = (char *)0;
#line 15
  opts[2].def.parsed = (char *)0;
#line 15
  opts[2].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 15
  opts[2].simple_value = (void *)0;
#line 15
  opts[2].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 15
  opts[2].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 15
  opts[2].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 15
  opts[2].freecb = (void (*)(void *value ))0;
#line 15
  opts[3].name = (char *)0;
#line 15
  opts[3].type = (cfg_type_t )0;
#line 15
  opts[3].nvalues = 0U;
#line 15
  opts[3].values = (cfg_value_t **)0;
#line 15
  opts[3].flags = 0;
#line 15
  opts[3].subopts = (cfg_opt_t *)0;
#line 15
  opts[3].def.number = 0L;
#line 15
  opts[3].def.fpnumber = (double )0;
#line 15
  opts[3].def.boolean = (cfg_bool_t )0;
#line 15
  opts[3].def.string = (char *)0;
#line 15
  opts[3].def.parsed = (char *)0;
#line 15
  opts[3].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 15
  opts[3].simple_value = (void *)0;
#line 15
  opts[3].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 15
  opts[3].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 15
  opts[3].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 15
  opts[3].freecb = (void (*)(void *value ))0;
#line 23
  buf = (char *)" delay = 3\n# message = \"asdfasfasfd tersf\"\n argument one { value = 1 }\n argument two { value=foo}\n";
#line 29
  cfg_free(cfg);
#line 31
  cfg = cfg_init(opts, 0);
#line 32
  ret = cfg_parse_buf(cfg, (char const   *)buf);
#line 33
  ret = cfg_parse(cfg, config_filename);
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/reread.c"
void sighandler(int sig ) 
{ 


  {
  {
#line 38
  read_config();
#line 39
  signal(1, & sighandler);
  }
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/reread.c"
static int loop  =    1;
#line 44 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/reread.c"
void usr1handler(int sig ) 
{ 


  {
#line 46
  loop = 0;
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/reread.c"
int main(void) 
{ 
  unsigned int i ;
  char *tmp ;
  cfg_t *arg ;
  cfg_t *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 53
  read_config();
#line 54
  signal(1, & sighandler);
#line 55
  signal(10, & usr1handler);
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! loop) {
#line 57
      goto while_break;
    }
    {
#line 59
    tmp = cfg_getstr(cfg, "message");
#line 59
    printf((char const   */* __restrict  */)"Message: %s", tmp);
#line 60
    i = 0U;
    }
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 60
      tmp___2 = cfg_size(cfg, "argument");
      }
#line 60
      if (! (i < tmp___2)) {
#line 60
        goto while_break___0;
      }
      {
#line 62
      tmp___0 = cfg_getnsec(cfg, "argument", i);
#line 62
      arg = tmp___0;
#line 63
      tmp___1 = cfg_getstr(arg, "value");
#line 63
      printf((char const   */* __restrict  */)", %s", tmp___1);
#line 60
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 65
    printf((char const   */* __restrict  */)"\n");
#line 67
    tmp___3 = cfg_getint(cfg, "delay");
#line 67
    sleep((unsigned int )tmp___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  cfg_free(cfg);
#line 71
  cfg = (cfg_t *)0;
  }
#line 73
  return (0);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 175 "lexer.c"
int cfg_yyleng  ;
#line 177
FILE *cfg_yyin ;
#line 177
FILE *cfg_yyout ;
#line 272 "lexer.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 273 "lexer.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 274 "lexer.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 292 "lexer.c"
static char yy_hold_char  ;
#line 293 "lexer.c"
static int yy_n_chars  ;
#line 297 "lexer.c"
static char *yy_c_buf_p  =    (char *)0;
#line 298 "lexer.c"
static int yy_init  =    0;
#line 299 "lexer.c"
static int yy_start  =    0;
#line 304 "lexer.c"
static int yy_did_buffer_switch_on_eof  ;
#line 306
void cfg_yyrestart(FILE *input_file ) ;
#line 307
void cfg_yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 308
YY_BUFFER_STATE cfg_yy_create_buffer(FILE *file , int size ) ;
#line 309
void cfg_yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 310
void cfg_yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 311
void cfg_yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 312
void cfg_yypop_buffer_state(void) ;
#line 314
static void cfg_yyensure_buffer_stack(void) ;
#line 315
static void cfg_yy_load_buffer_state(void) ;
#line 316
static void cfg_yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 320
YY_BUFFER_STATE cfg_yy_scan_buffer(char *base , yy_size_t size ) ;
#line 321
YY_BUFFER_STATE cfg_yy_scan_string(char const   *yystr ) ;
#line 322
YY_BUFFER_STATE cfg_yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 324
void *cfg_yyalloc(yy_size_t size ) ;
#line 325
void *cfg_yyrealloc(void *ptr , yy_size_t size ) ;
#line 326
void cfg_yyfree(void *ptr ) ;
#line 359 "lexer.c"
FILE *cfg_yyin  =    (FILE *)0;
#line 359 "lexer.c"
FILE *cfg_yyout  =    (FILE *)0;
#line 363
int cfg_yylineno ;
#line 365 "lexer.c"
int cfg_yylineno  =    1;
#line 367 "lexer.c"
char *cfg_yytext  ;
#line 370
static yy_state_type yy_get_previous_state(void) ;
#line 371
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 372
static int yy_get_next_buffer(void) ;
#line 373
static void yy_fatal_error(char const   *msg ) ;
#line 394 "lexer.c"
static flex_int16_t const   yy_accept[85]  = 
#line 394
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )12, 
        (flex_int16_t const   )12,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )45,      (flex_int16_t const   )42,      (flex_int16_t const   )1, 
        (flex_int16_t const   )2,      (flex_int16_t const   )43,      (flex_int16_t const   )16,      (flex_int16_t const   )3, 
        (flex_int16_t const   )42,      (flex_int16_t const   )34,      (flex_int16_t const   )6,      (flex_int16_t const   )7, 
        (flex_int16_t const   )43,      (flex_int16_t const   )10,      (flex_int16_t const   )42,      (flex_int16_t const   )8, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )12,      (flex_int16_t const   )14, 
        (flex_int16_t const   )13,      (flex_int16_t const   )33,      (flex_int16_t const   )19,      (flex_int16_t const   )17, 
        (flex_int16_t const   )33,      (flex_int16_t const   )44,      (flex_int16_t const   )40,      (flex_int16_t const   )36, 
        (flex_int16_t const   )35,      (flex_int16_t const   )44,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )1,      (flex_int16_t const   )3,      (flex_int16_t const   )0,      (flex_int16_t const   )9, 
        (flex_int16_t const   )42,      (flex_int16_t const   )11,      (flex_int16_t const   )3,      (flex_int16_t const   )12, 
        (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )15,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )32,      (flex_int16_t const   )20,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )28,      (flex_int16_t const   )26,      (flex_int16_t const   )29, 
        (flex_int16_t const   )27,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )30, 
        (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )40,      (flex_int16_t const   )39, 
        (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )0,      (flex_int16_t const   )41, 
        (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )33,      (flex_int16_t const   )0, 
        (flex_int16_t const   )18,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )23, 
        (flex_int16_t const   )3,      (flex_int16_t const   )18,      (flex_int16_t const   )21,      (flex_int16_t const   )23, 
        (flex_int16_t const   )0};
#line 407 "lexer.c"
static flex_int32_t const   yy_ec[256]  = 
#line 407
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )7,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )14, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )17,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )18, 
        (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )19,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )18, 
        (flex_int32_t const   )18,      (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )24,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )25,      (flex_int32_t const   )1, 
        (flex_int32_t const   )26,      (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )1, 
        (flex_int32_t const   )28,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )29, 
        (flex_int32_t const   )1,      (flex_int32_t const   )30,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 439 "lexer.c"
static flex_int32_t const   yy_meta[31]  = 
#line 439
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )2,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )6, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )2,      (flex_int32_t const   )7,      (flex_int32_t const   )8, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )2};
#line 446 "lexer.c"
static flex_int16_t const   yy_base[102]  = 
#line 446
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )38, 
        (flex_int16_t const   )39,      (flex_int16_t const   )131,      (flex_int16_t const   )116,      (flex_int16_t const   )127, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )0, 
        (flex_int16_t const   )30,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )111,      (flex_int16_t const   )293,      (flex_int16_t const   )34,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )0,      (flex_int16_t const   )293, 
        (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )98,      (flex_int16_t const   )57,      (flex_int16_t const   )0,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )67,      (flex_int16_t const   )107,      (flex_int16_t const   )41, 
        (flex_int16_t const   )116,      (flex_int16_t const   )0,      (flex_int16_t const   )59,      (flex_int16_t const   )293, 
        (flex_int16_t const   )62,      (flex_int16_t const   )293,      (flex_int16_t const   )86,      (flex_int16_t const   )0, 
        (flex_int16_t const   )42,      (flex_int16_t const   )50,      (flex_int16_t const   )293,      (flex_int16_t const   )0, 
        (flex_int16_t const   )114,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )47, 
        (flex_int16_t const   )50,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )44,      (flex_int16_t const   )293, 
        (flex_int16_t const   )144,      (flex_int16_t const   )0,      (flex_int16_t const   )117,      (flex_int16_t const   )41, 
        (flex_int16_t const   )0,      (flex_int16_t const   )52,      (flex_int16_t const   )108,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )293,      (flex_int16_t const   )110,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )174,      (flex_int16_t const   )182,      (flex_int16_t const   )190, 
        (flex_int16_t const   )198,      (flex_int16_t const   )206,      (flex_int16_t const   )214,      (flex_int16_t const   )222, 
        (flex_int16_t const   )230,      (flex_int16_t const   )238,      (flex_int16_t const   )245,      (flex_int16_t const   )253, 
        (flex_int16_t const   )260,      (flex_int16_t const   )268,      (flex_int16_t const   )276,      (flex_int16_t const   )62, 
        (flex_int16_t const   )284,      (flex_int16_t const   )36};
#line 462 "lexer.c"
static flex_int16_t const   yy_def[102]  = 
#line 462
  {      (flex_int16_t const   )0,      (flex_int16_t const   )84,      (flex_int16_t const   )1,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )84,      (flex_int16_t const   )88,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )89, 
        (flex_int16_t const   )88,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )90,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )91,      (flex_int16_t const   )84, 
        (flex_int16_t const   )92,      (flex_int16_t const   )93,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )96,      (flex_int16_t const   )88,      (flex_int16_t const   )90, 
        (flex_int16_t const   )84,      (flex_int16_t const   )89,      (flex_int16_t const   )97,      (flex_int16_t const   )84, 
        (flex_int16_t const   )88,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )91, 
        (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )84,      (flex_int16_t const   )93, 
        (flex_int16_t const   )98,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )99,      (flex_int16_t const   )95,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )97,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )46,      (flex_int16_t const   )98,      (flex_int16_t const   )100, 
        (flex_int16_t const   )93,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )101, 
        (flex_int16_t const   )72,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )0,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84};
#line 478 "lexer.c"
static flex_int16_t const   yy_nxt[324]  = 
#line 478
  {      (flex_int16_t const   )0,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )12, 
        (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )17,      (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )13, 
        (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )23,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )30,      (flex_int16_t const   )30,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )28, 
        (flex_int16_t const   )28,      (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )83, 
        (flex_int16_t const   )39,      (flex_int16_t const   )45,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )46,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )49, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )50,      (flex_int16_t const   )39, 
        (flex_int16_t const   )84,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )42, 
        (flex_int16_t const   )54,      (flex_int16_t const   )49,      (flex_int16_t const   )77,      (flex_int16_t const   )78, 
        (flex_int16_t const   )50,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )82, 
        (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )68,      (flex_int16_t const   )81, 
        (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )71,      (flex_int16_t const   )69, 
        (flex_int16_t const   )39,      (flex_int16_t const   )57,      (flex_int16_t const   )58,      (flex_int16_t const   )59, 
        (flex_int16_t const   )60,      (flex_int16_t const   )61,      (flex_int16_t const   )62,      (flex_int16_t const   )63, 
        (flex_int16_t const   )64,      (flex_int16_t const   )65,      (flex_int16_t const   )69,      (flex_int16_t const   )72, 
        (flex_int16_t const   )41,      (flex_int16_t const   )71,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )72,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )41, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )75,      (flex_int16_t const   )40,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )39,      (flex_int16_t const   )75,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )52, 
        (flex_int16_t const   )43,      (flex_int16_t const   )40,      (flex_int16_t const   )39,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )75,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )75,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )76,      (flex_int16_t const   )80,      (flex_int16_t const   )41,      (flex_int16_t const   )76, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )80, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )73,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )41,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )38, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )84,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )44, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )47, 
        (flex_int16_t const   )47,      (flex_int16_t const   )84,      (flex_int16_t const   )47,      (flex_int16_t const   )47, 
        (flex_int16_t const   )84,      (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )84,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )51, 
        (flex_int16_t const   )51,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )51, 
        (flex_int16_t const   )51,      (flex_int16_t const   )51,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )66,      (flex_int16_t const   )66, 
        (flex_int16_t const   )84,      (flex_int16_t const   )66,      (flex_int16_t const   )84,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70, 
        (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70, 
        (flex_int16_t const   )70,      (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )9,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84};
#line 518 "lexer.c"
static flex_int16_t const   yy_chk[324]  = 
#line 518
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )5, 
        (flex_int16_t const   )6,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )101, 
        (flex_int16_t const   )16,      (flex_int16_t const   )22,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )22,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )28, 
        (flex_int16_t const   )39,      (flex_int16_t const   )48,      (flex_int16_t const   )28,      (flex_int16_t const   )39, 
        (flex_int16_t const   )48,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )16, 
        (flex_int16_t const   )33,      (flex_int16_t const   )49,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )49,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )99,      (flex_int16_t const   )37,      (flex_int16_t const   )75, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )70,      (flex_int16_t const   )37, 
        (flex_int16_t const   )44,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )37,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )52,      (flex_int16_t const   )40,      (flex_int16_t const   )52, 
        (flex_int16_t const   )74,      (flex_int16_t const   )38,      (flex_int16_t const   )74,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )32, 
        (flex_int16_t const   )20,      (flex_int16_t const   )11,      (flex_int16_t const   )10,      (flex_int16_t const   )9, 
        (flex_int16_t const   )0,      (flex_int16_t const   )52,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )74,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )52,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )74, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )86, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )88, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )89, 
        (flex_int16_t const   )89,      (flex_int16_t const   )0,      (flex_int16_t const   )89,      (flex_int16_t const   )89, 
        (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )90, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )91, 
        (flex_int16_t const   )91,      (flex_int16_t const   )0,      (flex_int16_t const   )91,      (flex_int16_t const   )91, 
        (flex_int16_t const   )0,      (flex_int16_t const   )91,      (flex_int16_t const   )91,      (flex_int16_t const   )92, 
        (flex_int16_t const   )92,      (flex_int16_t const   )0,      (flex_int16_t const   )92,      (flex_int16_t const   )92, 
        (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )94, 
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94, 
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )95, 
        (flex_int16_t const   )0,      (flex_int16_t const   )95,      (flex_int16_t const   )0,      (flex_int16_t const   )95, 
        (flex_int16_t const   )95,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96, 
        (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96, 
        (flex_int16_t const   )96,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )97,      (flex_int16_t const   )98,      (flex_int16_t const   )98,      (flex_int16_t const   )98, 
        (flex_int16_t const   )98,      (flex_int16_t const   )98,      (flex_int16_t const   )98,      (flex_int16_t const   )98, 
        (flex_int16_t const   )98,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84};
#line 558 "lexer.c"
static yy_state_type yy_last_accepting_state  ;
#line 559 "lexer.c"
static char *yy_last_accepting_cpos  ;
#line 561
int cfg_yy_flex_debug ;
#line 562 "lexer.c"
int cfg_yy_flex_debug  =    0;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 598 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.h"
void cfg_error(cfg_t *cfg___0 , char const   *fmt  , ...) ;
#line 831
char *cfg_tilde_expand(char const   *filename ) ;
#line 44 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dgettext)(char const   *__domainname ,
                                                                                 char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 46 "lexer.l"
char *cfg_yylval ;
#line 52 "lexer.l"
char *cfg_qstring  =    (char *)((void *)0);
#line 53 "lexer.l"
static unsigned int qstring_index  =    0U;
#line 54 "lexer.l"
static unsigned int qstring_len  =    0U;
#line 55
static void qputc(char ch ) ;
#line 59 "lexer.l"
struct __anonstruct_cfg_include_stack_26 cfg_include_stack[10]  ;
#line 64 "lexer.l"
int cfg_include_stack_ptr  =    0;
#line 66 "lexer.l"
static YY_BUFFER_STATE pre_string_scan_state  =    (YY_BUFFER_STATE )0;
#line 67 "lexer.l"
static YY_BUFFER_STATE string_scan_state  =    (YY_BUFFER_STATE )0;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 665 "lexer.c"
static int yy_init_globals(void) ;
#line 670
int cfg_yylex_destroy(void) ;
#line 672
int cfg_yyget_debug(void) ;
#line 674
void cfg_yyset_debug(int bdebug ) ;
#line 680
FILE *cfg_yyget_in(void) ;
#line 682
void cfg_yyset_in(FILE *in_str ) ;
#line 684
FILE *cfg_yyget_out(void) ;
#line 686
void cfg_yyset_out(FILE *out_str ) ;
#line 688
int cfg_yyget_leng(void) ;
#line 690
char *cfg_yyget_text(void) ;
#line 692
int cfg_yyget_lineno(void) ;
#line 694
void cfg_yyset_lineno(int line_number ) ;
#line 708
static void yyunput(int c , char *yy_bp ) ;
#line 825 "lexer.c"
int cfg_yylex(cfg_t *cfg___0 ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  char *var ;
  char *e ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned int result ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int result___0 ;
  char *yptr ;
  char *tmp___4 ;
  char *cp ;
  char *tmp___5 ;
  char *tmp___6 ;
  YY_BUFFER_STATE tmp___7 ;
  char *var___0 ;
  char *e___0 ;
  size_t tmp___8 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___9 ;

  {
#line 836
  if (! yy_init) {
#line 838
    yy_init = 1;
#line 844
    if (! yy_start) {
#line 845
      yy_start = 1;
    }
#line 847
    if (! cfg_yyin) {
#line 848
      cfg_yyin = stdin;
    }
#line 850
    if (! cfg_yyout) {
#line 851
      cfg_yyout = stdout;
    }
#line 853
    if (yy_buffer_stack) {
#line 853
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 853
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 853
    if (! tmp) {
      {
#line 854
      cfg_yyensure_buffer_stack();
#line 855
      *(yy_buffer_stack + yy_buffer_stack_top) = cfg_yy_create_buffer(cfg_yyin, 16384);
      }
    }
    {
#line 859
    cfg_yy_load_buffer_state();
    }
  }
  {
#line 862
  while (1) {
    while_continue: /* CIL Label */ ;
#line 864
    yy_cp = yy_c_buf_p;
#line 867
    *yy_cp = yy_hold_char;
#line 872
    yy_bp = yy_cp;
#line 874
    yy_current_state = yy_start;
    yy_match: 
    {
#line 876
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 878
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 879
      if (yy_accept[yy_current_state]) {
#line 881
        yy_last_accepting_state = yy_current_state;
#line 882
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 884
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 884
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 884
          goto while_break___1;
        }
#line 886
        yy_current_state = (int )yy_def[yy_current_state];
#line 887
        if (yy_current_state >= 85) {
#line 888
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 890
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 891
      yy_cp ++;
#line 876
      if (! ((int const   )yy_base[yy_current_state] != 293)) {
#line 876
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 896
    yy_act = (int )yy_accept[yy_current_state];
#line 897
    if (yy_act == 0) {
#line 899
      yy_cp = yy_last_accepting_cpos;
#line 900
      yy_current_state = yy_last_accepting_state;
#line 901
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 904
    cfg_yytext = yy_bp;
#line 904
    cfg_yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 904
    yy_hold_char = *yy_cp;
#line 904
    *yy_cp = (char )'\000';
#line 904
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 910
    if (yy_act == 0) {
#line 910
      goto case_0;
    }
#line 917
    if (yy_act == 1) {
#line 917
      goto case_1;
    }
#line 83
    if (yy_act == 2) {
#line 83 "lexer.l"
      goto case_2;
    }
#line 85
    if (yy_act == 3) {
#line 85
      goto case_3;
    }
#line 89
    if (yy_act == 4) {
#line 89
      goto case_4;
    }
#line 91
    if (yy_act == 5) {
#line 91
      goto case_5;
    }
#line 92
    if (yy_act == 6) {
#line 92
      goto case_6;
    }
#line 93
    if (yy_act == 7) {
#line 93
      goto case_7;
    }
#line 94
    if (yy_act == 8) {
#line 94
      goto case_8;
    }
#line 95
    if (yy_act == 9) {
#line 95
      goto case_9;
    }
#line 96
    if (yy_act == 10) {
#line 96
      goto case_10;
    }
#line 99
    if (yy_act == 11) {
#line 99
      goto case_11;
    }
#line 101
    if (yy_act == 12) {
#line 101
      goto case_12;
    }
#line 102
    if (yy_act == 13) {
#line 102
      goto case_13;
    }
#line 103
    if (yy_act == 14) {
#line 103
      goto case_14;
    }
#line 104
    if (yy_act == 15) {
#line 104
      goto case_15;
    }
#line 107
    if (yy_act == 16) {
#line 107
      goto case_16;
    }
#line 112
    if (yy_act == 17) {
#line 112
      goto case_17;
    }
#line 118
    if (yy_act == 18) {
#line 118
      goto case_18;
    }
#line 133
    if (yy_act == 19) {
#line 133
      goto case_19;
    }
#line 137
    if (yy_act == 20) {
#line 137
      goto case_20;
    }
#line 141
    if (yy_act == 21) {
#line 141
      goto case_21;
    }
#line 150
    if (yy_act == 22) {
#line 150
      goto case_22;
    }
#line 154
    if (yy_act == 23) {
#line 154
      goto case_23;
    }
#line 159
    if (yy_act == 24) {
#line 159
      goto case_24;
    }
#line 162
    if (yy_act == 25) {
#line 162
      goto case_25;
    }
#line 165
    if (yy_act == 26) {
#line 165
      goto case_26;
    }
#line 168
    if (yy_act == 27) {
#line 168
      goto case_27;
    }
#line 171
    if (yy_act == 28) {
#line 171
      goto case_28;
    }
#line 174
    if (yy_act == 29) {
#line 174
      goto case_29;
    }
#line 177
    if (yy_act == 30) {
#line 177
      goto case_30;
    }
#line 180
    if (yy_act == 31) {
#line 180
      goto case_31;
    }
#line 183
    if (yy_act == 32) {
#line 183
      goto case_32;
    }
#line 186
    if (yy_act == 33) {
#line 186
      goto case_33;
    }
#line 193
    if (yy_act == 34) {
#line 193
      goto case_34;
    }
#line 198
    if (yy_act == 35) {
#line 198
      goto case_35;
    }
#line 204
    if (yy_act == 36) {
#line 204
      goto case_36;
    }
#line 208
    if (yy_act == 37) {
#line 208
      goto case_37;
    }
#line 212
    if (yy_act == 38) {
#line 212
      goto case_38;
    }
#line 215
    if (yy_act == 39) {
#line 215
      goto case_39;
    }
#line 219
    if (yy_act == 40) {
#line 219
      goto case_40;
    }
#line 225
    if (yy_act == 49) {
#line 225
      goto case_49;
    }
#line 231
    if (yy_act == 48) {
#line 231
      goto case_48;
    }
#line 231
    if (yy_act == 47) {
#line 231
      goto case_48;
    }
#line 231
    if (yy_act == 46) {
#line 231
      goto case_48;
    }
#line 247
    if (yy_act == 41) {
#line 247
      goto case_41;
    }
#line 270
    if (yy_act == 42) {
#line 270
      goto case_42;
    }
#line 275
    if (yy_act == 43) {
#line 275
      goto case_43;
    }
#line 277
    if (yy_act == 44) {
#line 277
      goto case_44;
    }
#line 1297
    if (yy_act == 45) {
#line 1297 "lexer.c"
      goto case_45;
    }
#line 1419
    goto switch_default;
    case_0: /* CIL Label */ 
#line 912
    *yy_cp = yy_hold_char;
#line 913
    yy_cp = yy_last_accepting_cpos;
#line 914
    yy_current_state = yy_last_accepting_state;
#line 915
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 82 "lexer.l"
    goto switch_break;
    case_2: /* CIL Label */ 
#line 83
    (cfg___0->line) ++;
#line 84
    goto switch_break;
    case_3: /* CIL Label */ 
#line 86
    goto switch_break;
    case_4: /* CIL Label */ 
#line 89
    cfg_yylval = cfg_yytext;
#line 89
    return ('{');
#line 90
    goto switch_break;
    case_5: /* CIL Label */ 
#line 90
    cfg_yylval = cfg_yytext;
#line 90
    return ('}');
#line 91
    goto switch_break;
    case_6: /* CIL Label */ 
#line 91
    cfg_yylval = cfg_yytext;
#line 91
    return ('(');
#line 92
    goto switch_break;
    case_7: /* CIL Label */ 
#line 92
    cfg_yylval = cfg_yytext;
#line 92
    return (')');
#line 93
    goto switch_break;
    case_8: /* CIL Label */ 
#line 93
    cfg_yylval = cfg_yytext;
#line 93
    return ('=');
#line 94
    goto switch_break;
    case_9: /* CIL Label */ 
#line 94
    cfg_yylval = cfg_yytext;
#line 94
    return ('+');
#line 95
    goto switch_break;
    case_10: /* CIL Label */ 
#line 95
    cfg_yylval = cfg_yytext;
#line 95
    return (',');
#line 96
    goto switch_break;
    case_11: /* CIL Label */ 
#line 99
    yy_start = 3;
#line 100
    goto switch_break;
    case_12: /* CIL Label */ 
#line 101
    goto switch_break;
    case_13: /* CIL Label */ 
#line 102
    goto switch_break;
    case_14: /* CIL Label */ 
#line 102
    (cfg___0->line) ++;
#line 103
    goto switch_break;
    case_15: /* CIL Label */ 
#line 103
    yy_start = 1;
#line 104
    goto switch_break;
    case_16: /* CIL Label */ 
#line 108
    qstring_index = 0U;
#line 109
    yy_start = 5;
#line 111
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 112
    yy_start = 1;
#line 113
    qputc((char )'\000');
#line 114
    cfg_yylval = cfg_qstring;
    }
#line 115
    return (3);
#line 117
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 120
    tmp___0 = strlen((char const   *)cfg_yytext);
#line 120
    *(cfg_yytext + (tmp___0 - 1UL)) = (char)0;
#line 121
    e = strchr((char const   *)(cfg_yytext + 2), ':');
    }
#line 122
    if (e) {
#line 122
      if ((int )*(e + 1) == 45) {
#line 123
        *e = (char)0;
      } else {
#line 125
        e = (char *)0;
      }
    } else {
#line 125
      e = (char *)0;
    }
    {
#line 126
    var = getenv((char const   *)(cfg_yytext + 2));
    }
#line 127
    if (! var) {
#line 127
      if (e) {
#line 128
        var = e + 2;
      }
    }
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 129
      if (var) {
#line 129
        if (! *var) {
#line 129
          goto while_break___2;
        }
      } else {
#line 129
        goto while_break___2;
      }
      {
#line 130
      tmp___1 = var;
#line 130
      var ++;
#line 130
      qputc(*tmp___1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 132
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 133
    qputc((char )'\n');
#line 134
    (cfg___0->line) ++;
    }
#line 136
    goto switch_break;
    case_20: /* CIL Label */ 
#line 138
    (cfg___0->line) ++;
#line 140
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 142
    sscanf((char const   */* __restrict  */)(cfg_yytext + 1), (char const   */* __restrict  */)"%o",
           & result);
    }
#line 143
    if (result > 255U) {
      {
#line 144
      tmp___2 = dgettext("confuse", "invalid octal number \'%s\'");
#line 144
      cfg_error(cfg___0, (char const   *)tmp___2, cfg_yytext);
      }
#line 145
      return (0);
    }
    {
#line 147
    qputc((char )result);
    }
#line 149
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 150
    tmp___3 = dgettext("confuse", "bad escape sequence \'%s\'");
#line 150
    cfg_error(cfg___0, (char const   *)tmp___3, cfg_yytext);
    }
#line 151
    return (0);
#line 153
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 155
    sscanf((char const   */* __restrict  */)(cfg_yytext + 2), (char const   */* __restrict  */)"%x",
           & result___0);
#line 156
    qputc((char )result___0);
    }
#line 158
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 159
    qputc((char )'\n');
    }
#line 161
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 162
    qputc((char )'\r');
    }
#line 164
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 165
    qputc((char )'\b');
    }
#line 167
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 168
    qputc((char )'\f');
    }
#line 170
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 171
    qputc((char )'\a');
    }
#line 173
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 174
    qputc((char )'\033');
    }
#line 176
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 177
    qputc((char )'\t');
    }
#line 179
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 180
    qputc((char )'\v');
    }
#line 182
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 183
    qputc(*(cfg_yytext + 1));
    }
#line 185
    goto switch_break;
    case_33: /* CIL Label */ 
#line 186
    yptr = cfg_yytext;
    {
#line 187
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 187
      if (! *yptr) {
#line 187
        goto while_break___3;
      }
      {
#line 188
      tmp___4 = yptr;
#line 188
      yptr ++;
#line 188
      qputc(*tmp___4);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 191
    goto switch_break;
    case_34: /* CIL Label */ 
#line 194
    qstring_index = 0U;
#line 195
    yy_start = 7;
#line 197
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 198
    yy_start = 1;
#line 199
    qputc((char )'\000');
#line 200
    cfg_yylval = cfg_qstring;
    }
#line 201
    return (3);
#line 203
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 204
    qputc((char )'\n');
#line 205
    (cfg___0->line) ++;
    }
#line 207
    goto switch_break;
    case_37: /* CIL Label */ 
#line 209
    (cfg___0->line) ++;
#line 211
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 212
    qputc(*(cfg_yytext + 1));
    }
#line 214
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 215
    qputc(*(cfg_yytext + 0));
#line 216
    qputc(*(cfg_yytext + 1));
    }
#line 218
    goto switch_break;
    case_40: /* CIL Label */ 
#line 219
    cp = cfg_yytext;
    {
#line 220
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 220
      if (! ((int )*cp != 0)) {
#line 220
        goto while_break___4;
      }
      {
#line 221
      tmp___5 = cp;
#line 221
      cp ++;
#line 221
      qputc(*tmp___5);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 224
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 225
    tmp___6 = dgettext("confuse", "unterminated string constant");
#line 225
    cfg_error(cfg___0, (char const   *)tmp___6);
    }
#line 226
    return (0);
#line 228
    goto switch_break;
    case_48: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 230
    if (cfg_include_stack_ptr <= 0) {
#line 232
      return (-1);
    } else {
#line 236
      if (yy_buffer_stack) {
#line 236
        tmp___7 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 236
        tmp___7 = (YY_BUFFER_STATE )((void *)0);
      }
      {
#line 236
      cfg_yy_delete_buffer(tmp___7);
#line 237
      fclose(cfg_yyin);
#line 238
      cfg_yyin = (FILE *)0;
#line 239
      cfg_include_stack_ptr --;
#line 240
      cfg_yy_switch_to_buffer(cfg_include_stack[cfg_include_stack_ptr].state);
#line 241
      free((void *)cfg___0->filename);
#line 242
      cfg___0->filename = cfg_include_stack[cfg_include_stack_ptr].filename;
#line 243
      cfg___0->line = (int )cfg_include_stack[cfg_include_stack_ptr].line;
      }
    }
#line 246
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 251
    tmp___8 = strlen((char const   *)cfg_yytext);
#line 251
    *(cfg_yytext + (tmp___8 - 1UL)) = (char)0;
#line 252
    e___0 = strchr((char const   *)(cfg_yytext + 2), ':');
    }
#line 253
    if (e___0) {
#line 253
      if ((int )*(e___0 + 1) == 45) {
#line 254
        *e___0 = (char)0;
      } else {
#line 256
        e___0 = (char *)0;
      }
    } else {
#line 256
      e___0 = (char *)0;
    }
    {
#line 257
    var___0 = getenv((char const   *)(cfg_yytext + 2));
    }
#line 258
    if (! var___0) {
#line 258
      if (e___0) {
#line 259
        var___0 = e___0 + 2;
      }
    }
#line 260
    if (! var___0) {
#line 261
      var___0 = (char *)"";
    }
#line 262
    cfg_yylval = var___0;
#line 263
    return (3);
#line 265
    goto switch_break;
    case_42: /* CIL Label */ 
#line 271
    cfg_yylval = cfg_yytext;
#line 272
    return (3);
#line 274
    goto switch_break;
    case_43: /* CIL Label */ 
#line 276
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 277
    fwrite((void const   */* __restrict  */)cfg_yytext, (size_t )cfg_yyleng, (size_t )1,
           (FILE */* __restrict  */)cfg_yyout);
    }
#line 278
    goto switch_break;
    case_45: /* CIL Label */ 
#line 1300 "lexer.c"
    yy_amount_of_matched_text = (int )(yy_cp - cfg_yytext) - 1;
#line 1303
    *yy_cp = yy_hold_char;
#line 1306
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1317
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1318
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = cfg_yyin;
#line 1319
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1329
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1333
      yy_c_buf_p = cfg_yytext + yy_amount_of_matched_text;
#line 1335
      yy_current_state = yy_get_previous_state();
#line 1346
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1348
      yy_bp = cfg_yytext + 0;
      }
#line 1350
      if (yy_next_state) {
#line 1353
        yy_c_buf_p ++;
#line 1353
        yy_cp = yy_c_buf_p;
#line 1354
        yy_current_state = yy_next_state;
#line 1355
        goto yy_match;
      } else {
#line 1360
        yy_cp = yy_c_buf_p;
#line 1361
        goto yy_find_action;
      }
    } else {
      {
#line 1365
      tmp___9 = yy_get_next_buffer();
      }
      {
#line 1367
      if (tmp___9 == 1) {
#line 1367
        goto case_1___0;
      }
#line 1396
      if (tmp___9 == 0) {
#line 1396
        goto case_0___0;
      }
#line 1406
      if (tmp___9 == 2) {
#line 1406
        goto case_2___0;
      }
#line 1365
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1369
      yy_did_buffer_switch_on_eof = 0;
#line 1382
      yy_c_buf_p = cfg_yytext + 0;
#line 1384
      yy_act = (45 + (yy_start - 1) / 2) + 1;
#line 1385
      goto do_action;
#line 1393
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1397
      yy_c_buf_p = cfg_yytext + yy_amount_of_matched_text;
#line 1400
      yy_current_state = yy_get_previous_state();
#line 1402
      yy_cp = yy_c_buf_p;
#line 1403
      yy_bp = cfg_yytext + 0;
      }
#line 1404
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1407
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1410
      yy_current_state = yy_get_previous_state();
#line 1412
      yy_cp = yy_c_buf_p;
#line 1413
      yy_bp = cfg_yytext + 0;
      }
#line 1414
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1416
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1420
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1433 "lexer.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;

  {
#line 1435
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1436
  source = cfg_yytext;
#line 1440
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1441
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1444
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1446
    if (yy_c_buf_p - cfg_yytext == 1L) {
#line 1451
      return (1);
    } else {
#line 1459
      return (2);
    }
  }
#line 1466
  number_to_move = (int )(yy_c_buf_p - cfg_yytext) - 1;
#line 1468
  i = 0;
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1468
    if (! (i < number_to_move)) {
#line 1468
      goto while_break;
    }
#line 1469
    tmp = dest;
#line 1469
    dest ++;
#line 1469
    tmp___0 = source;
#line 1469
    source ++;
#line 1469
    *tmp = *tmp___0;
#line 1468
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1471
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1475
    yy_n_chars = 0;
#line 1475
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1479
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1482
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1482
      if (! (num_to_read <= 0)) {
#line 1482
        goto while_break___0;
      }
#line 1486
      if (yy_buffer_stack) {
#line 1486
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1486
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1486
      b = tmp___1;
#line 1488
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1491
      if (b->yy_is_our_buffer) {
#line 1493
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1495
        if (new_size <= 0) {
#line 1496
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1498
          b->yy_buf_size *= 2UL;
        }
        {
#line 1500
        tmp___2 = cfg_yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1500
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1506
        b->yy_ch_buf = (char *)0;
      }
#line 1508
      if (! b->yy_ch_buf) {
        {
#line 1509
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1512
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1514
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1519
    if (num_to_read > 8192) {
#line 1520
      num_to_read = 8192;
    }
#line 1523
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1523
      c = '*';
#line 1523
      n = 0;
      {
#line 1523
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1523
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 1523
          c = _IO_getc(cfg_yyin);
          }
#line 1523
          if (c != -1) {
#line 1523
            if (! (c != 10)) {
#line 1523
              goto while_break___1;
            }
          } else {
#line 1523
            goto while_break___1;
          }
        } else {
#line 1523
          goto while_break___1;
        }
#line 1523
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1523
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1523
      if (c == 10) {
#line 1523
        tmp___3 = n;
#line 1523
        n ++;
#line 1523
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1523
      if (c == -1) {
        {
#line 1523
        tmp___4 = ferror(cfg_yyin);
        }
#line 1523
        if (tmp___4) {
          {
#line 1523
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1523
      yy_n_chars = n;
    } else {
      {
#line 1523
      tmp___5 = __errno_location();
#line 1523
      *tmp___5 = 0;
      }
      {
#line 1523
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1523
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)cfg_yyin);
#line 1523
        yy_n_chars = (int )tmp___8;
        }
#line 1523
        if (yy_n_chars == 0) {
          {
#line 1523
          tmp___9 = ferror(cfg_yyin);
          }
#line 1523
          if (! tmp___9) {
#line 1523
            goto while_break___2;
          }
        } else {
#line 1523
          goto while_break___2;
        }
        {
#line 1523
        tmp___6 = __errno_location();
        }
#line 1523
        if (*tmp___6 != 4) {
          {
#line 1523
          yy_fatal_error("input in flex scanner failed");
          }
#line 1523
          goto while_break___2;
        }
        {
#line 1523
        tmp___7 = __errno_location();
#line 1523
        *tmp___7 = 0;
#line 1523
        clearerr(cfg_yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1526
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1529
  if (yy_n_chars == 0) {
#line 1531
    if (number_to_move == 0) {
      {
#line 1533
      ret_val = 1;
#line 1534
      cfg_yyrestart(cfg_yyin);
      }
    } else {
#line 1539
      ret_val = 2;
#line 1540
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1546
    ret_val = 0;
  }
#line 1548
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1550
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1551
    tmp___10 = cfg_yyrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                             new_size___0);
#line 1551
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 1552
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1553
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1556
  yy_n_chars += number_to_move;
#line 1557
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1558
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1560
  cfg_yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1562
  return (ret_val);
}
}
#line 1567 "lexer.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1572
  yy_current_state = yy_start;
#line 1574
  yy_cp = cfg_yytext + 0;
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1574
      goto while_break;
    }
#line 1576
    if (*yy_cp) {
#line 1576
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1576
      tmp = (flex_int32_t const   )1;
    }
#line 1576
    yy_c = (YY_CHAR )tmp;
#line 1577
    if (yy_accept[yy_current_state]) {
#line 1579
      yy_last_accepting_state = yy_current_state;
#line 1580
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1582
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1582
        goto while_break___0;
      }
#line 1584
      yy_current_state = (int )yy_def[yy_current_state];
#line 1585
      if (yy_current_state >= 85) {
#line 1586
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1588
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1574
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1591
  return (yy_current_state);
}
}
#line 1599 "lexer.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1602
  yy_cp = yy_c_buf_p;
#line 1604
  yy_c = (YY_CHAR )1;
#line 1605
  if (yy_accept[yy_current_state]) {
#line 1607
    yy_last_accepting_state = yy_current_state;
#line 1608
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1610
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1610
      goto while_break;
    }
#line 1612
    yy_current_state = (int )yy_def[yy_current_state];
#line 1613
    if (yy_current_state >= 85) {
#line 1614
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1616
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1617
  yy_is_jam = yy_current_state == 84;
#line 1619
  if (yy_is_jam) {
#line 1619
    tmp = 0;
  } else {
#line 1619
    tmp = yy_current_state;
  }
#line 1619
  return (tmp);
}
}
#line 1622 "lexer.c"
static void yyunput(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register int number_to_move ;
  register char *dest ;
  register char *source ;

  {
#line 1626
  yy_cp = yy_c_buf_p;
#line 1629
  *yy_cp = yy_hold_char;
#line 1631
  if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
#line 1634
    number_to_move = yy_n_chars + 2;
#line 1635
    dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size + 2UL);
#line 1637
    source = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move;
    {
#line 1640
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1640
      if (! ((unsigned long )source > (unsigned long )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf)) {
#line 1640
        goto while_break;
      }
#line 1641
      dest --;
#line 1641
      source --;
#line 1641
      *dest = *source;
    }
    while_break: /* CIL Label */ ;
    }
#line 1643
    yy_cp += (int )(dest - source);
#line 1644
    yy_bp += (int )(dest - source);
#line 1645
    yy_n_chars = (int )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size;
#line 1645
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
#line 1648
    if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
      {
#line 1649
      yy_fatal_error("flex scanner push-back overflow");
      }
    }
  }
#line 1652
  yy_cp --;
#line 1652
  *yy_cp = (char )c;
#line 1654
  cfg_yytext = yy_bp;
#line 1655
  yy_hold_char = *yy_cp;
#line 1656
  yy_c_buf_p = yy_cp;
#line 1657
  return;
}
}
#line 1738 "lexer.c"
void cfg_yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1741
  if (yy_buffer_stack) {
#line 1741
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1741
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1741
  if (! tmp) {
    {
#line 1742
    cfg_yyensure_buffer_stack();
#line 1743
    *(yy_buffer_stack + yy_buffer_stack_top) = cfg_yy_create_buffer(cfg_yyin, 16384);
    }
  }
#line 1747
  if (yy_buffer_stack) {
#line 1747
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1747
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1747
  cfg_yy_init_buffer(tmp___0, input_file);
#line 1748
  cfg_yy_load_buffer_state();
  }
#line 1749
  return;
}
}
#line 1755 "lexer.c"
void cfg_yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1763
  cfg_yyensure_buffer_stack();
  }
#line 1764
  if (yy_buffer_stack) {
#line 1764
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1764
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1764
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1765
    return;
  }
#line 1767
  if (yy_buffer_stack) {
#line 1767
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1767
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1767
  if (tmp___0) {
#line 1770
    *yy_c_buf_p = yy_hold_char;
#line 1771
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1772
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1775
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1776
  cfg_yy_load_buffer_state();
#line 1783
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1784
  return;
}
}
#line 1786 "lexer.c"
static void cfg_yy_load_buffer_state(void) 
{ 


  {
#line 1788
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1789
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1789
  cfg_yytext = yy_c_buf_p;
#line 1790
  cfg_yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1791
  yy_hold_char = *yy_c_buf_p;
#line 1792
  return;
}
}
#line 1800 "lexer.c"
YY_BUFFER_STATE cfg_yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1804
  tmp = cfg_yyalloc(sizeof(struct yy_buffer_state ));
#line 1804
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1805
  if (! b) {
    {
#line 1806
    yy_fatal_error("out of dynamic memory in cfg_yy_create_buffer()");
    }
  }
  {
#line 1808
  b->yy_buf_size = (yy_size_t )size;
#line 1813
  tmp___0 = cfg_yyalloc(b->yy_buf_size + 2UL);
#line 1813
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1814
  if (! b->yy_ch_buf) {
    {
#line 1815
    yy_fatal_error("out of dynamic memory in cfg_yy_create_buffer()");
    }
  }
  {
#line 1817
  b->yy_is_our_buffer = 1;
#line 1819
  cfg_yy_init_buffer(b, file);
  }
#line 1821
  return (b);
}
}
#line 1828 "lexer.c"
void cfg_yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1831
  if (! b) {
#line 1832
    return;
  }
#line 1834
  if (yy_buffer_stack) {
#line 1834
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1834
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1834
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1835
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1837
  if (b->yy_is_our_buffer) {
    {
#line 1838
    cfg_yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1840
  cfg_yyfree((void *)b);
  }
#line 1841
  return;
}
}
#line 1861 "lexer.c"
static void cfg_yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1864
  tmp = __errno_location();
#line 1864
  oerrno = *tmp;
#line 1866
  cfg_yy_flush_buffer(b);
#line 1868
  b->yy_input_file = file;
#line 1869
  b->yy_fill_buffer = 1;
  }
#line 1875
  if (yy_buffer_stack) {
#line 1875
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1875
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1875
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1876
    b->yy_bs_lineno = 1;
#line 1877
    b->yy_bs_column = 0;
  }
#line 1880
  if (file) {
    {
#line 1880
    tmp___1 = fileno(file);
#line 1880
    tmp___2 = isatty(tmp___1);
#line 1880
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1880
    b->yy_is_interactive = 0;
  }
  {
#line 1882
  tmp___3 = __errno_location();
#line 1882
  *tmp___3 = oerrno;
  }
#line 1883
  return;
}
}
#line 1889 "lexer.c"
void cfg_yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1891
  if (! b) {
#line 1892
    return;
  }
#line 1894
  b->yy_n_chars = 0;
#line 1900
  *(b->yy_ch_buf + 0) = (char)0;
#line 1901
  *(b->yy_ch_buf + 1) = (char)0;
#line 1903
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1905
  b->yy_at_bol = 1;
#line 1906
  b->yy_buffer_status = 0;
#line 1908
  if (yy_buffer_stack) {
#line 1908
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1908
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1908
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1909
    cfg_yy_load_buffer_state();
    }
  }
#line 1910
  return;
}
}
#line 1918 "lexer.c"
void cfg_yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1920
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1921
    return;
  }
  {
#line 1923
  cfg_yyensure_buffer_stack();
  }
#line 1926
  if (yy_buffer_stack) {
#line 1926
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1926
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1926
  if (tmp) {
#line 1929
    *yy_c_buf_p = yy_hold_char;
#line 1930
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1931
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1935
  if (yy_buffer_stack) {
#line 1935
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1935
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1935
  if (tmp___0) {
#line 1936
    yy_buffer_stack_top ++;
  }
  {
#line 1937
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1940
  cfg_yy_load_buffer_state();
#line 1941
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1942
  return;
}
}
#line 1948 "lexer.c"
void cfg_yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1950
  if (yy_buffer_stack) {
#line 1950
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1950
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1950
  if (! tmp) {
#line 1951
    return;
  }
#line 1953
  if (yy_buffer_stack) {
#line 1953
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1953
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1953
  cfg_yy_delete_buffer(tmp___0);
#line 1954
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1955
  if (yy_buffer_stack_top > 0UL) {
#line 1956
    yy_buffer_stack_top --;
  }
#line 1958
  if (yy_buffer_stack) {
#line 1958
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1958
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1958
  if (tmp___1) {
    {
#line 1959
    cfg_yy_load_buffer_state();
#line 1960
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1962
  return;
}
}
#line 1967 "lexer.c"
static void cfg_yyensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1971
  if (! yy_buffer_stack) {
    {
#line 1977
    num_to_alloc = 1;
#line 1978
    tmp = cfg_yyalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1978
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 1981
    if (! yy_buffer_stack) {
      {
#line 1982
      yy_fatal_error("out of dynamic memory in cfg_yyensure_buffer_stack()");
      }
    }
    {
#line 1984
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1986
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1987
    yy_buffer_stack_top = (size_t )0;
    }
#line 1988
    return;
  }
#line 1991
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 1994
    grow_size = 8;
#line 1996
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1997
    tmp___0 = cfg_yyrealloc((void *)yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1997
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2001
    if (! yy_buffer_stack) {
      {
#line 2002
      yy_fatal_error("out of dynamic memory in cfg_yyensure_buffer_stack()");
      }
    }
    {
#line 2005
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2006
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2008
  return;
}
}
#line 2016 "lexer.c"
YY_BUFFER_STATE cfg_yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2020
  if (size < 2UL) {
#line 2024
    return ((YY_BUFFER_STATE )0);
  } else
#line 2020
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2024
    return ((YY_BUFFER_STATE )0);
  } else
#line 2020
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2024
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2026
  tmp = cfg_yyalloc(sizeof(struct yy_buffer_state ));
#line 2026
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2027
  if (! b) {
    {
#line 2028
    yy_fatal_error("out of dynamic memory in cfg_yy_scan_buffer()");
    }
  }
  {
#line 2030
  b->yy_buf_size = size - 2UL;
#line 2031
  tmp___0 = base;
#line 2031
  b->yy_ch_buf = tmp___0;
#line 2031
  b->yy_buf_pos = tmp___0;
#line 2032
  b->yy_is_our_buffer = 0;
#line 2033
  b->yy_input_file = (FILE *)0;
#line 2034
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2035
  b->yy_is_interactive = 0;
#line 2036
  b->yy_at_bol = 1;
#line 2037
  b->yy_fill_buffer = 0;
#line 2038
  b->yy_buffer_status = 0;
#line 2040
  cfg_yy_switch_to_buffer(b);
  }
#line 2042
  return (b);
}
}
#line 2053 "lexer.c"
YY_BUFFER_STATE cfg_yy_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2056
  tmp = strlen(yystr);
#line 2056
  tmp___0 = cfg_yy_scan_bytes(yystr, (int )tmp);
  }
#line 2056
  return (tmp___0);
}
}
#line 2066 "lexer.c"
YY_BUFFER_STATE cfg_yy_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2074
  n = (yy_size_t )(_yybytes_len + 2);
#line 2075
  tmp = cfg_yyalloc(n);
#line 2075
  buf = (char *)tmp;
  }
#line 2076
  if (! buf) {
    {
#line 2077
    yy_fatal_error("out of dynamic memory in cfg_yy_scan_bytes()");
    }
  }
#line 2079
  i = 0;
  {
#line 2079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2079
    if (! (i < _yybytes_len)) {
#line 2079
      goto while_break;
    }
#line 2080
    *(buf + i) = (char )*(yybytes + i);
#line 2079
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2082
  tmp___0 = (char)0;
#line 2082
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2082
  *(buf + _yybytes_len) = tmp___0;
#line 2084
  b = cfg_yy_scan_buffer(buf, n);
  }
#line 2085
  if (! b) {
    {
#line 2086
    yy_fatal_error("bad buffer in cfg_yy_scan_bytes()");
    }
  }
#line 2091
  b->yy_is_our_buffer = 1;
#line 2093
  return (b);
}
}
#line 2100 "lexer.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 2102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2103
  exit(2);
  }
}
}
#line 2128 "lexer.c"
int cfg_yyget_lineno(void) 
{ 


  {
#line 2131
  return (cfg_yylineno);
}
}
#line 2137 "lexer.c"
FILE *cfg_yyget_in(void) 
{ 


  {
#line 2139
  return (cfg_yyin);
}
}
#line 2145 "lexer.c"
FILE *cfg_yyget_out(void) 
{ 


  {
#line 2147
  return (cfg_yyout);
}
}
#line 2153 "lexer.c"
int cfg_yyget_leng(void) 
{ 


  {
#line 2155
  return (cfg_yyleng);
}
}
#line 2162 "lexer.c"
char *cfg_yyget_text(void) 
{ 


  {
#line 2164
  return (cfg_yytext);
}
}
#line 2171 "lexer.c"
void cfg_yyset_lineno(int line_number ) 
{ 


  {
#line 2174
  cfg_yylineno = line_number;
#line 2175
  return;
}
}
#line 2183 "lexer.c"
void cfg_yyset_in(FILE *in_str ) 
{ 


  {
#line 2185
  cfg_yyin = in_str;
#line 2186
  return;
}
}
#line 2188 "lexer.c"
void cfg_yyset_out(FILE *out_str ) 
{ 


  {
#line 2190
  cfg_yyout = out_str;
#line 2191
  return;
}
}
#line 2193 "lexer.c"
int cfg_yyget_debug(void) 
{ 


  {
#line 2195
  return (cfg_yy_flex_debug);
}
}
#line 2198 "lexer.c"
void cfg_yyset_debug(int bdebug ) 
{ 


  {
#line 2200
  cfg_yy_flex_debug = bdebug;
#line 2201
  return;
}
}
#line 2203 "lexer.c"
static int yy_init_globals(void) 
{ 


  {
#line 2209
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2210
  yy_buffer_stack_top = (size_t )0;
#line 2211
  yy_buffer_stack_max = (size_t )0;
#line 2212
  yy_c_buf_p = (char *)0;
#line 2213
  yy_init = 0;
#line 2214
  yy_start = 0;
#line 2221
  cfg_yyin = (FILE *)0;
#line 2222
  cfg_yyout = (FILE *)0;
#line 2228
  return (0);
}
}
#line 2232 "lexer.c"
int cfg_yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2236
    if (yy_buffer_stack) {
#line 2236
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2236
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2236
    if (! tmp___0) {
#line 2236
      goto while_break;
    }
#line 2237
    if (yy_buffer_stack) {
#line 2237
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2237
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2237
    cfg_yy_delete_buffer(tmp);
#line 2238
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2239
    cfg_yypop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2243
  cfg_yyfree((void *)yy_buffer_stack);
#line 2244
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2248
  yy_init_globals();
  }
#line 2250
  return (0);
}
}
#line 2277 "lexer.c"
void *cfg_yyalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2279
  tmp = malloc(size);
  }
#line 2279
  return (tmp);
}
}
#line 2282 "lexer.c"
void *cfg_yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2291
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2291
  return (tmp);
}
}
#line 2294 "lexer.c"
void cfg_yyfree(void *ptr ) 
{ 


  {
  {
#line 2296
  free((void *)((char *)ptr));
  }
#line 2297
  return;
}
}
#line 280 "lexer.l"
void cfg_dummy_function(void) 
{ 


  {
  {
#line 285
  yyunput(0, (char *)0);
  }
#line 286
  return;
}
}
#line 288 "lexer.l"
int cfg_lexer_include(cfg_t *cfg___0 , char const   *filename ) 
{ 
  char *xfilename ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  YY_BUFFER_STATE tmp___2 ;

  {
#line 292
  if (cfg_include_stack_ptr >= 10) {
    {
#line 293
    tmp = dgettext("confuse", "includes nested too deeply");
#line 293
    cfg_error(cfg___0, (char const   *)tmp);
    }
#line 294
    return (1);
  }
#line 297
  if (yy_buffer_stack) {
#line 297
    cfg_include_stack[cfg_include_stack_ptr].state = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 297
    cfg_include_stack[cfg_include_stack_ptr].state = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 298
  cfg_include_stack[cfg_include_stack_ptr].filename = cfg___0->filename;
#line 299
  cfg_include_stack[cfg_include_stack_ptr].line = (unsigned int )cfg___0->line;
#line 300
  cfg_include_stack_ptr ++;
#line 302
  xfilename = cfg_tilde_expand(filename);
#line 304
  cfg_yyin = fopen((char const   */* __restrict  */)xfilename, (char const   */* __restrict  */)"r");
  }
#line 306
  if (! cfg_yyin) {
    {
#line 307
    tmp___0 = __errno_location();
#line 307
    tmp___1 = strerror(*tmp___0);
#line 307
    cfg_error(cfg___0, "%s: %s", xfilename, tmp___1);
#line 308
    free((void *)xfilename);
    }
#line 309
    return (1);
  }
  {
#line 312
  cfg___0->filename = xfilename;
#line 313
  cfg___0->line = 1;
#line 315
  tmp___2 = cfg_yy_create_buffer(cfg_yyin, 16384);
#line 315
  cfg_yy_switch_to_buffer(tmp___2);
  }
#line 316
  return (0);
}
}
#line 322 "lexer.l"
static void qputc(char ch ) 
{ 
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 324
  if (qstring_index >= qstring_len) {
    {
#line 325
    qstring_len += 32U;
#line 326
    tmp = realloc((void *)cfg_qstring, (size_t )qstring_len);
#line 326
    cfg_qstring = (char *)tmp;
    }
#line 327
    if (! cfg_qstring) {
      {
#line 327
      __assert_fail("cfg_qstring", "lexer.l", 327U, "qputc");
      }
    }
    {
#line 328
    memset((void *)(cfg_qstring + qstring_index), 0, (size_t )32);
    }
  }
#line 330
  tmp___0 = qstring_index;
#line 330
  qstring_index ++;
#line 330
  *(cfg_qstring + tmp___0) = ch;
#line 331
  return;
}
}
#line 333 "lexer.l"
void cfg_scan_string_begin(char const   *buf ) 
{ 


  {
#line 335
  if (yy_buffer_stack) {
#line 335
    pre_string_scan_state = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 335
    pre_string_scan_state = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 339
  string_scan_state = cfg_yy_scan_string(buf);
  }
#line 340
  return;
}
}
#line 342 "lexer.l"
void cfg_scan_string_end(void) 
{ 


  {
  {
#line 346
  cfg_yy_delete_buffer(string_scan_state);
  }
#line 347
  if (pre_string_scan_state) {
    {
#line 348
    cfg_yy_switch_to_buffer(pre_string_scan_state);
    }
  }
  {
#line 349
  free((void *)cfg_qstring);
#line 350
  cfg_qstring = (char *)0;
#line 351
  qstring_len = 0U;
#line 351
  qstring_index = qstring_len;
#line 352
  string_scan_state = (YY_BUFFER_STATE )0;
  }
#line 353
  return;
}
}
#line 355 "lexer.l"
static YY_BUFFER_STATE pre_fp_scan_state  ;
#line 356 "lexer.l"
static YY_BUFFER_STATE fp_scan_state  ;
#line 358 "lexer.l"
void cfg_scan_fp_begin(FILE *fp ) 
{ 


  {
#line 360
  if (yy_buffer_stack) {
#line 360
    pre_fp_scan_state = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 360
    pre_fp_scan_state = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 361
  fp_scan_state = cfg_yy_create_buffer(fp, 16384);
#line 362
  cfg_yy_switch_to_buffer(fp_scan_state);
  }
#line 363
  return;
}
}
#line 365 "lexer.l"
void cfg_scan_fp_end(void) 
{ 


  {
  {
#line 369
  cfg_yy_delete_buffer(fp_scan_state);
  }
#line 370
  if (pre_fp_scan_state) {
    {
#line 371
    cfg_yy_switch_to_buffer(pre_fp_scan_state);
    }
  }
  {
#line 372
  free((void *)cfg_qstring);
#line 373
  cfg_qstring = (char *)0;
#line 374
  qstring_len = 0U;
#line 374
  qstring_index = qstring_len;
  }
#line 375
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 275 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.h"
char const   confuse_copyright[53] ;
#line 276
char const   confuse_version[4] ;
#line 277
char const   confuse_author[35] ;
#line 565
int cfg_parse_fp(cfg_t *cfg___0 , FILE *fp ) ;
#line 582
void cfg_free_value(cfg_opt_t *opt ) ;
#line 592
cfg_errfunc_t cfg_set_error_function(cfg_t *cfg___0 , void (*errfunc)(cfg_t *cfg ,
                                                                      char const   *fmt ,
                                                                      va_list ap ) ) ;
#line 605
long cfg_opt_getnint(cfg_opt_t *opt , unsigned int index___0 ) ;
#line 613
long cfg_getnint(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) ;
#line 632
double cfg_opt_getnfloat(cfg_opt_t *opt , unsigned int index___0 ) ;
#line 640
double cfg_getnfloat(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) ;
#line 651
double cfg_getfloat(cfg_t *cfg___0 , char const   *name ) ;
#line 658
char *cfg_opt_getnstr(cfg_opt_t *opt , unsigned int index___0 ) ;
#line 666
char *cfg_getnstr(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) ;
#line 684
cfg_bool_t cfg_opt_getnbool(cfg_opt_t *opt , unsigned int index___0 ) ;
#line 693
cfg_bool_t cfg_getnbool(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) ;
#line 704
cfg_bool_t cfg_getbool(cfg_t *cfg___0 , char const   *name ) ;
#line 707
void *cfg_opt_getnptr(cfg_opt_t *opt , unsigned int index___0 ) ;
#line 708
void *cfg_getnptr(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) ;
#line 718
void *cfg_getptr(cfg_t *cfg___0 , char const   *name ) ;
#line 726
cfg_t *cfg_opt_getnsec(cfg_opt_t *opt , unsigned int index___0 ) ;
#line 746
cfg_t *cfg_opt_gettsec(cfg_opt_t *opt , char const   *title ) ;
#line 757
cfg_t *cfg_gettsec(cfg_t *cfg___0 , char const   *name , char const   *title ) ;
#line 770
cfg_t *cfg_getsec(cfg_t *cfg___0 , char const   *name ) ;
#line 777
unsigned int cfg_opt_size(cfg_opt_t *opt ) ;
#line 799
char const   *cfg_title(cfg_t *cfg___0 ) ;
#line 807
char const   *cfg_name(cfg_t *cfg___0 ) ;
#line 815
char const   *cfg_opt_name(cfg_opt_t *opt ) ;
#line 822
int cfg_include(cfg_t *cfg___0 , cfg_opt_t *opt , int argc , char const   **argv ) ;
#line 840
int cfg_parse_boolean(char const   *s ) ;
#line 850
cfg_opt_t *cfg_getopt(cfg_t *cfg___0 , char const   *name ) ;
#line 860
cfg_value_t *cfg_setopt(cfg_t *cfg___0 , cfg_opt_t *opt , char *value ) ;
#line 870
void cfg_opt_setnint(cfg_opt_t *opt , long value , unsigned int index___0 ) ;
#line 880
void cfg_setint(cfg_t *cfg___0 , char const   *name , long value ) ;
#line 892
void cfg_setnint(cfg_t *cfg___0 , char const   *name , long value , unsigned int index___0 ) ;
#line 903
void cfg_opt_setnfloat(cfg_opt_t *opt , double value , unsigned int index___0 ) ;
#line 913
void cfg_setfloat(cfg_t *cfg___0 , char const   *name , double value ) ;
#line 925
void cfg_setnfloat(cfg_t *cfg___0 , char const   *name , double value , unsigned int index___0 ) ;
#line 936
void cfg_opt_setnbool(cfg_opt_t *opt , cfg_bool_t value , unsigned int index___0 ) ;
#line 946
void cfg_setbool(cfg_t *cfg___0 , char const   *name , cfg_bool_t value ) ;
#line 958
void cfg_setnbool(cfg_t *cfg___0 , char const   *name , cfg_bool_t value , unsigned int index___0 ) ;
#line 970
void cfg_opt_setnstr(cfg_opt_t *opt , char const   *value , unsigned int index___0 ) ;
#line 981
void cfg_setstr(cfg_t *cfg___0 , char const   *name , char const   *value ) ;
#line 994
void cfg_setnstr(cfg_t *cfg___0 , char const   *name , char const   *value , unsigned int index___0 ) ;
#line 1007
void cfg_setlist(cfg_t *cfg___0 , char const   *name , unsigned int nvalues  , ...) ;
#line 1010
int cfg_numopts(cfg_opt_t *opts ) ;
#line 1022
void cfg_addlist(cfg_t *cfg___0 , char const   *name , unsigned int nvalues  , ...) ;
#line 1037
void cfg_opt_nprint_var(cfg_opt_t *opt , unsigned int index___0 , FILE *fp ) ;
#line 1044
void cfg_opt_print_indent(cfg_opt_t *opt , FILE *fp , int indent ) ;
#line 1056
void cfg_opt_print(cfg_opt_t *opt , FILE *fp ) ;
#line 1062
void cfg_print_indent(cfg_t *cfg___0 , FILE *fp , int indent ) ;
#line 1077
void cfg_print(cfg_t *cfg___0 , FILE *fp ) ;
#line 1086
cfg_print_func_t cfg_opt_set_print_func(cfg_opt_t *opt , void (*pf)(cfg_opt_t *opt ,
                                                                    unsigned int index ,
                                                                    FILE *fp ) ) ;
#line 1097
cfg_print_func_t cfg_set_print_func(cfg_t *cfg___0 , char const   *name , void (*pf)(cfg_opt_t *opt ,
                                                                                     unsigned int index ,
                                                                                     FILE *fp ) ) ;
#line 1108
cfg_validate_callback_t cfg_set_validate_func(cfg_t *cfg___0 , char const   *name ,
                                              int (*vf)(cfg_t *cfg , cfg_opt_t *opt ) ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 86 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char *cfg_yylval  =    (char *)0;
#line 59 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char const   confuse_version[4]  = {      (char const   )'2',      (char const   )'.',      (char const   )'7',      (char const   )'\000'};
#line 60 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char const   confuse_copyright[53]  = 
#line 60
  {      (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'C', 
        (char const   )'o',      (char const   )'n',      (char const   )'f',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'2', 
        (char const   )'.',      (char const   )'7',      (char const   )' ',      (char const   )'b', 
        (char const   )'y',      (char const   )' ',      (char const   )'M',      (char const   )'a', 
        (char const   )'r',      (char const   )'t',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'H',      (char const   )'e',      (char const   )'d', 
        (char const   )'e',      (char const   )'n',      (char const   )'f',      (char const   )'a', 
        (char const   )'l',      (char const   )'k',      (char const   )' ',      (char const   )'<', 
        (char const   )'m',      (char const   )'a',      (char const   )'r',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'@',      (char const   )'b', 
        (char const   )'z',      (char const   )'e',      (char const   )'r',      (char const   )'o', 
        (char const   )'.',      (char const   )'s',      (char const   )'e',      (char const   )'>', 
        (char const   )'\000'};
#line 61 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char const   confuse_author[35]  = 
#line 61
  {      (char const   )'M',      (char const   )'a',      (char const   )'r',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'H', 
        (char const   )'e',      (char const   )'d',      (char const   )'e',      (char const   )'n', 
        (char const   )'f',      (char const   )'a',      (char const   )'l',      (char const   )'k', 
        (char const   )' ',      (char const   )'<',      (char const   )'m',      (char const   )'a', 
        (char const   )'r',      (char const   )'t',      (char const   )'i',      (char const   )'n', 
        (char const   )'@',      (char const   )'b',      (char const   )'z',      (char const   )'e', 
        (char const   )'r',      (char const   )'o',      (char const   )'.',      (char const   )'s', 
        (char const   )'e',      (char const   )'>',      (char const   )'\000'};
#line 63
static int cfg_parse_internal(cfg_t *cfg___0 , int level , int force_state , cfg_opt_t *force_opt ) ;
#line 131 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_opt_t *cfg_getopt(cfg_t *cfg___0 , char const   *name ) 
{ 
  unsigned int i ;
  cfg_t *sec ;
  char *secname ;
  size_t len ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 134
  sec = cfg___0;
#line 136
  if (cfg___0) {
#line 136
    if (cfg___0->name) {
#line 136
      if (! name) {
        {
#line 136
        __assert_fail("cfg && cfg->name && name", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                      136U, "cfg_getopt");
        }
      }
    } else {
      {
#line 136
      __assert_fail("cfg && cfg->name && name", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    136U, "cfg_getopt");
      }
    }
  } else {
    {
#line 136
    __assert_fail("cfg && cfg->name && name", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  136U, "cfg_getopt");
    }
  }
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (name) {
#line 138
      if (! *name) {
#line 138
        goto while_break;
      }
    } else {
#line 138
      goto while_break;
    }
    {
#line 141
    tmp = strcspn(name, "|");
#line 141
    len = tmp;
    }
#line 142
    if ((int const   )*(name + len) == 0) {
#line 144
      goto while_break;
    }
#line 145
    if (len) {
      {
#line 147
      secname = strndup(name, len);
#line 148
      sec = cfg_getsec(sec, (char const   *)secname);
      }
#line 149
      if ((unsigned long )sec == (unsigned long )((cfg_t *)0)) {
        {
#line 150
        tmp___0 = dgettext("confuse", "no such option \'%s\'");
#line 150
        cfg_error(cfg___0, (char const   *)tmp___0, secname);
        }
      }
      {
#line 151
      free((void *)secname);
      }
#line 152
      if ((unsigned long )sec == (unsigned long )((cfg_t *)0)) {
#line 153
        return ((cfg_opt_t *)0);
      }
    }
    {
#line 155
    name += len;
#line 156
    tmp___1 = strspn(name, "|");
#line 156
    name += tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  i = 0U;
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 159
    if (! (sec->opts + i)->name) {
#line 159
      goto while_break___0;
    }
#line 161
    if ((4 & sec->flags) == 4) {
      {
#line 163
      tmp___2 = strcasecmp((char const   *)(sec->opts + i)->name, name);
      }
#line 163
      if (tmp___2 == 0) {
#line 164
        return (sec->opts + i);
      }
    } else {
      {
#line 168
      tmp___3 = strcmp((char const   *)(sec->opts + i)->name, name);
      }
#line 168
      if (tmp___3 == 0) {
#line 169
        return (sec->opts + i);
      }
    }
#line 159
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 172
  tmp___4 = dgettext("confuse", "no such option \'%s\'");
#line 172
  cfg_error(cfg___0, (char const   *)tmp___4, name);
  }
#line 173
  return ((cfg_opt_t *)0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char const   *cfg_title(cfg_t *cfg___0 ) 
{ 


  {
#line 178
  if (cfg___0) {
#line 179
    return ((char const   *)cfg___0->title);
  }
#line 180
  return ((char const   *)0);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char const   *cfg_name(cfg_t *cfg___0 ) 
{ 


  {
#line 185
  if (cfg___0) {
#line 186
    return ((char const   *)cfg___0->name);
  }
#line 187
  return ((char const   *)0);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char const   *cfg_opt_name(cfg_opt_t *opt ) 
{ 


  {
#line 192
  if (opt) {
#line 193
    return ((char const   *)opt->name);
  }
#line 194
  return ((char const   *)0);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
unsigned int cfg_opt_size(cfg_opt_t *opt ) 
{ 


  {
#line 199
  if (opt) {
#line 200
    return (opt->nvalues);
  }
#line 201
  return (0U);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
unsigned int cfg_size(cfg_t *cfg___0 , char const   *name ) 
{ 
  cfg_opt_t *tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 206
  tmp = cfg_getopt(cfg___0, name);
#line 206
  tmp___0 = cfg_opt_size(tmp);
  }
#line 206
  return (tmp___0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
long cfg_opt_getnint(cfg_opt_t *opt , unsigned int index___0 ) 
{ 


  {
#line 211
  if (opt) {
#line 211
    if (! ((unsigned int )opt->type == 1U)) {
      {
#line 211
      __assert_fail("opt && opt->type == CFGT_INT", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    211U, "cfg_opt_getnint");
      }
    }
  } else {
    {
#line 211
    __assert_fail("opt && opt->type == CFGT_INT", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  211U, "cfg_opt_getnint");
    }
  }
#line 212
  if (opt->values) {
#line 212
    if (index___0 < opt->nvalues) {
#line 213
      return ((*(opt->values + index___0))->number);
    } else {
#line 212
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 214
  if (opt->simple_value) {
#line 215
    return (*((long *)opt->simple_value));
  } else {
#line 217
    return (0L);
  }
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
long cfg_getnint(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;
  long tmp___0 ;

  {
  {
#line 223
  tmp = cfg_getopt(cfg___0, name);
#line 223
  tmp___0 = cfg_opt_getnint(tmp, index___0);
  }
#line 223
  return (tmp___0);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
long cfg_getint(cfg_t *cfg___0 , char const   *name ) 
{ 
  long tmp ;

  {
  {
#line 228
  tmp = cfg_getnint(cfg___0, name, 0U);
  }
#line 228
  return (tmp);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
double cfg_opt_getnfloat(cfg_opt_t *opt , unsigned int index___0 ) 
{ 


  {
#line 233
  if (opt) {
#line 233
    if (! ((unsigned int )opt->type == 2U)) {
      {
#line 233
      __assert_fail("opt && opt->type == CFGT_FLOAT", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    233U, "cfg_opt_getnfloat");
      }
    }
  } else {
    {
#line 233
    __assert_fail("opt && opt->type == CFGT_FLOAT", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  233U, "cfg_opt_getnfloat");
    }
  }
#line 234
  if (opt->values) {
#line 234
    if (index___0 < opt->nvalues) {
#line 235
      return ((*(opt->values + index___0))->fpnumber);
    } else {
#line 234
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 236
  if (opt->simple_value) {
#line 237
    return (*((double *)opt->simple_value));
  } else {
#line 239
    return ((double )0);
  }
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
double cfg_getnfloat(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;
  double tmp___0 ;

  {
  {
#line 245
  tmp = cfg_getopt(cfg___0, name);
#line 245
  tmp___0 = cfg_opt_getnfloat(tmp, index___0);
  }
#line 245
  return (tmp___0);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
double cfg_getfloat(cfg_t *cfg___0 , char const   *name ) 
{ 
  double tmp ;

  {
  {
#line 250
  tmp = cfg_getnfloat(cfg___0, name, 0U);
  }
#line 250
  return (tmp);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_bool_t cfg_opt_getnbool(cfg_opt_t *opt , unsigned int index___0 ) 
{ 


  {
#line 255
  if (opt) {
#line 255
    if (! ((unsigned int )opt->type == 4U)) {
      {
#line 255
      __assert_fail("opt && opt->type == CFGT_BOOL", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    255U, "cfg_opt_getnbool");
      }
    }
  } else {
    {
#line 255
    __assert_fail("opt && opt->type == CFGT_BOOL", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  255U, "cfg_opt_getnbool");
    }
  }
#line 256
  if (opt->values) {
#line 256
    if (index___0 < opt->nvalues) {
#line 257
      return ((*(opt->values + index___0))->boolean);
    } else {
#line 256
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 258
  if (opt->simple_value) {
#line 259
    return (*((cfg_bool_t *)opt->simple_value));
  } else {
#line 261
    return ((cfg_bool_t )0);
  }
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_bool_t cfg_getnbool(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;
  cfg_bool_t tmp___0 ;

  {
  {
#line 267
  tmp = cfg_getopt(cfg___0, name);
#line 267
  tmp___0 = cfg_opt_getnbool(tmp, index___0);
  }
#line 267
  return (tmp___0);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_bool_t cfg_getbool(cfg_t *cfg___0 , char const   *name ) 
{ 
  cfg_bool_t tmp ;

  {
  {
#line 272
  tmp = cfg_getnbool(cfg___0, name, 0U);
  }
#line 272
  return (tmp);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char *cfg_opt_getnstr(cfg_opt_t *opt , unsigned int index___0 ) 
{ 


  {
#line 277
  if (opt) {
#line 277
    if (! ((unsigned int )opt->type == 3U)) {
      {
#line 277
      __assert_fail("opt && opt->type == CFGT_STR", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    277U, "cfg_opt_getnstr");
      }
    }
  } else {
    {
#line 277
    __assert_fail("opt && opt->type == CFGT_STR", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  277U, "cfg_opt_getnstr");
    }
  }
#line 278
  if (opt->values) {
#line 278
    if (index___0 < opt->nvalues) {
#line 279
      return ((*(opt->values + index___0))->string);
    } else {
#line 278
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 280
  if (opt->simple_value) {
#line 281
    return (*((char **)opt->simple_value));
  } else {
#line 283
    return ((char *)0);
  }
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char *cfg_getnstr(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;
  char *tmp___0 ;

  {
  {
#line 288
  tmp = cfg_getopt(cfg___0, name);
#line 288
  tmp___0 = cfg_opt_getnstr(tmp, index___0);
  }
#line 288
  return (tmp___0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char *cfg_getstr(cfg_t *cfg___0 , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 293
  tmp = cfg_getnstr(cfg___0, name, 0U);
  }
#line 293
  return (tmp);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void *cfg_opt_getnptr(cfg_opt_t *opt , unsigned int index___0 ) 
{ 


  {
#line 298
  if (opt) {
#line 298
    if (! ((unsigned int )opt->type == 7U)) {
      {
#line 298
      __assert_fail("opt && opt->type == CFGT_PTR", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    298U, "cfg_opt_getnptr");
      }
    }
  } else {
    {
#line 298
    __assert_fail("opt && opt->type == CFGT_PTR", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  298U, "cfg_opt_getnptr");
    }
  }
#line 299
  if (opt->values) {
#line 299
    if (index___0 < opt->nvalues) {
#line 300
      return ((*(opt->values + index___0))->ptr);
    } else {
#line 299
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 301
  if (opt->simple_value) {
#line 302
    return (*((void **)opt->simple_value));
  } else {
#line 304
    return ((void *)0);
  }
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void *cfg_getnptr(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;
  void *tmp___0 ;

  {
  {
#line 309
  tmp = cfg_getopt(cfg___0, name);
#line 309
  tmp___0 = cfg_opt_getnptr(tmp, index___0);
  }
#line 309
  return (tmp___0);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void *cfg_getptr(cfg_t *cfg___0 , char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 314
  tmp = cfg_getnptr(cfg___0, name, 0U);
  }
#line 314
  return (tmp);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_t *cfg_opt_getnsec(cfg_opt_t *opt , unsigned int index___0 ) 
{ 


  {
#line 319
  if (opt) {
#line 319
    if (! ((unsigned int )opt->type == 5U)) {
      {
#line 319
      __assert_fail("opt && opt->type == CFGT_SEC", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    319U, "cfg_opt_getnsec");
      }
    }
  } else {
    {
#line 319
    __assert_fail("opt && opt->type == CFGT_SEC", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  319U, "cfg_opt_getnsec");
    }
  }
#line 320
  if (opt->values) {
#line 320
    if (index___0 < opt->nvalues) {
#line 321
      return ((*(opt->values + index___0))->section);
    }
  }
#line 322
  return ((cfg_t *)0);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_t *cfg_getnsec(cfg_t *cfg___0 , char const   *name , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;
  cfg_t *tmp___0 ;

  {
  {
#line 327
  tmp = cfg_getopt(cfg___0, name);
#line 327
  tmp___0 = cfg_opt_getnsec(tmp, index___0);
  }
#line 327
  return (tmp___0);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_t *cfg_opt_gettsec(cfg_opt_t *opt , char const   *title ) 
{ 
  unsigned int i ;
  unsigned int n ;
  cfg_t *sec ;
  cfg_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 334
  if (opt) {
#line 334
    if (! title) {
      {
#line 334
      __assert_fail("opt && title", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    334U, "cfg_opt_gettsec");
      }
    }
  } else {
    {
#line 334
    __assert_fail("opt && title", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  334U, "cfg_opt_gettsec");
    }
  }
#line 335
  if (! ((8 & opt->flags) == 8)) {
#line 336
    return ((cfg_t *)0);
  }
  {
#line 337
  n = cfg_opt_size(opt);
#line 338
  i = 0U;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (i < n)) {
#line 338
      goto while_break;
    }
    {
#line 340
    tmp = cfg_opt_getnsec(opt, i);
#line 340
    sec = tmp;
    }
#line 341
    if (sec) {
#line 341
      if (! sec->title) {
        {
#line 341
        __assert_fail("sec && sec->title", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                      341U, "cfg_opt_gettsec");
        }
      }
    } else {
      {
#line 341
      __assert_fail("sec && sec->title", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    341U, "cfg_opt_gettsec");
      }
    }
#line 342
    if ((4 & opt->flags) == 4) {
      {
#line 344
      tmp___0 = strcasecmp(title, (char const   *)sec->title);
      }
#line 344
      if (tmp___0 == 0) {
#line 345
        return (sec);
      }
    } else {
      {
#line 349
      tmp___1 = strcmp(title, (char const   *)sec->title);
      }
#line 349
      if (tmp___1 == 0) {
#line 350
        return (sec);
      }
    }
#line 338
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  return ((cfg_t *)0);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_t *cfg_gettsec(cfg_t *cfg___0 , char const   *name , char const   *title ) 
{ 
  cfg_opt_t *tmp ;
  cfg_t *tmp___0 ;

  {
  {
#line 358
  tmp = cfg_getopt(cfg___0, name);
#line 358
  tmp___0 = cfg_opt_gettsec(tmp, title);
  }
#line 358
  return (tmp___0);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_t *cfg_getsec(cfg_t *cfg___0 , char const   *name ) 
{ 
  cfg_t *tmp ;

  {
  {
#line 363
  tmp = cfg_getnsec(cfg___0, name, 0U);
  }
#line 363
  return (tmp);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_value_t *cfg_addval(cfg_opt_t *opt ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 368
  tmp = realloc((void *)opt->values, (unsigned long )(opt->nvalues + 1U) * sizeof(cfg_value_t *));
#line 368
  opt->values = (cfg_value_t **)tmp;
  }
#line 370
  if (! opt->values) {
    {
#line 370
    __assert_fail("opt->values", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  370U, "cfg_addval");
    }
  }
  {
#line 371
  tmp___0 = malloc(sizeof(cfg_value_t ));
#line 371
  *(opt->values + opt->nvalues) = (cfg_value_t *)tmp___0;
#line 372
  memset((void *)*(opt->values + opt->nvalues), 0, sizeof(cfg_value_t ));
#line 373
  tmp___1 = opt->nvalues;
#line 373
  (opt->nvalues) ++;
  }
#line 373
  return (*(opt->values + tmp___1));
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
int cfg_numopts(cfg_opt_t *opts ) 
{ 
  int n ;

  {
#line 380
  n = 0;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! (opts + n)->name) {
#line 380
      goto while_break;
    }
#line 380
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return (n);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_opt_t *cfg_dupopt_array(cfg_opt_t *opts ) 
{ 
  int i ;
  cfg_opt_t *dupopts ;
  int n ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 389
  tmp = cfg_numopts(opts);
#line 389
  n = tmp;
#line 391
  tmp___0 = calloc((size_t )(n + 1), sizeof(cfg_opt_t ));
#line 391
  dupopts = (cfg_opt_t *)tmp___0;
#line 392
  memcpy((void */* __restrict  */)dupopts, (void const   */* __restrict  */)opts,
         (unsigned long )n * sizeof(cfg_opt_t ));
#line 394
  i = 0;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i < n)) {
#line 394
      goto while_break;
    }
    {
#line 396
    (dupopts + i)->name = strdup((char const   *)(opts + i)->name);
    }
#line 397
    if ((unsigned int )(opts + i)->type == 5U) {
#line 397
      if ((opts + i)->subopts) {
        {
#line 398
        (dupopts + i)->subopts = cfg_dupopt_array((opts + i)->subopts);
        }
      }
    }
#line 400
    if ((2 & (opts + i)->flags) == 2) {
#line 400
      goto _L;
    } else
#line 400
    if ((unsigned int )(opts + i)->type == 6U) {
      _L: /* CIL Label */ 
#line 401
      if ((opts + i)->def.parsed) {
        {
#line 401
        tmp___1 = strdup((char const   *)(opts + i)->def.parsed);
#line 401
        (dupopts + i)->def.parsed = tmp___1;
        }
      } else {
#line 401
        (dupopts + i)->def.parsed = (char *)0;
      }
    } else
#line 402
    if ((unsigned int )(opts + i)->type == 3U) {
#line 403
      if ((opts + i)->def.string) {
        {
#line 403
        tmp___2 = strdup((char const   *)(opts + i)->def.string);
#line 403
        (dupopts + i)->def.string = tmp___2;
        }
      } else {
#line 403
        (dupopts + i)->def.string = (char *)0;
      }
    }
#line 394
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return (dupopts);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
int cfg_parse_boolean(char const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 411
  tmp___2 = strcasecmp(s, "true");
  }
#line 411
  if (tmp___2 == 0) {
#line 414
    return (1);
  } else {
    {
#line 411
    tmp___3 = strcasecmp(s, "on");
    }
#line 411
    if (tmp___3 == 0) {
#line 414
      return (1);
    } else {
      {
#line 411
      tmp___4 = strcasecmp(s, "yes");
      }
#line 411
      if (tmp___4 == 0) {
#line 414
        return (1);
      } else {
        {
#line 415
        tmp = strcasecmp(s, "false");
        }
#line 415
        if (tmp == 0) {
#line 418
          return (0);
        } else {
          {
#line 415
          tmp___0 = strcasecmp(s, "off");
          }
#line 415
          if (tmp___0 == 0) {
#line 418
            return (0);
          } else {
            {
#line 415
            tmp___1 = strcasecmp(s, "no");
            }
#line 415
            if (tmp___1 == 0) {
#line 418
              return (0);
            }
          }
        }
      }
    }
  }
#line 419
  return (-1);
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_init_defaults(cfg_t *cfg___0 ) 
{ 
  int i ;
  int xstate ;
  int ret ;

  {
#line 426
  i = 0;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! (cfg___0->opts + i)->name) {
#line 426
      goto while_break;
    }
#line 429
    if ((cfg___0->opts + i)->simple_value) {
#line 430
      goto __Cont;
    } else
#line 429
    if ((16 & (cfg___0->opts + i)->flags) == 16) {
#line 430
      goto __Cont;
    }
#line 432
    if ((unsigned int )(cfg___0->opts + i)->type != 5U) {
#line 434
      (cfg___0->opts + i)->flags |= 128;
#line 436
      if ((2 & (cfg___0->opts + i)->flags) == 2) {
#line 436
        goto _L;
      } else
#line 436
      if ((cfg___0->opts + i)->def.parsed) {
        _L: /* CIL Label */ 
#line 444
        if ((unsigned long )(cfg___0->opts + i)->def.parsed == (unsigned long )((char *)0)) {
#line 446
          goto __Cont;
        } else
#line 444
        if ((int )*((cfg___0->opts + i)->def.parsed + 0) == 0) {
#line 446
          goto __Cont;
        }
#line 452
        if ((2 & (cfg___0->opts + i)->flags) == 2) {
#line 454
          xstate = 3;
        } else
#line 455
        if ((unsigned int )(cfg___0->opts + i)->type == 6U) {
#line 456
          xstate = 0;
        } else {
#line 458
          xstate = 2;
        }
        {
#line 460
        cfg_scan_string_begin((char const   *)(cfg___0->opts + i)->def.parsed);
        }
        {
#line 461
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 463
          ret = cfg_parse_internal(cfg___0, 1, xstate, cfg___0->opts + i);
#line 464
          xstate = -1;
          }
#line 461
          if (! (ret == 0)) {
#line 461
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 466
        cfg_scan_string_end();
        }
#line 467
        if (ret == 1) {
          {
#line 476
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parse error in default value \'%s\' for option \'%s\'\n",
                  (cfg___0->opts + i)->def.parsed, (cfg___0->opts + i)->name);
#line 479
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Check your initialization macros and the libConfuse documentation\n");
#line 481
          abort();
          }
        }
      } else {
        {
#line 488
        if ((unsigned int )(cfg___0->opts + i)->type == 1U) {
#line 488
          goto case_1;
        }
#line 492
        if ((unsigned int )(cfg___0->opts + i)->type == 2U) {
#line 492
          goto case_2;
        }
#line 496
        if ((unsigned int )(cfg___0->opts + i)->type == 4U) {
#line 496
          goto case_4;
        }
#line 500
        if ((unsigned int )(cfg___0->opts + i)->type == 3U) {
#line 500
          goto case_3;
        }
#line 505
        if ((unsigned int )(cfg___0->opts + i)->type == 7U) {
#line 505
          goto case_7;
        }
#line 505
        if ((unsigned int )(cfg___0->opts + i)->type == 6U) {
#line 505
          goto case_7;
        }
#line 507
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 489
        cfg_opt_setnint(cfg___0->opts + i, (cfg___0->opts + i)->def.number, 0U);
        }
#line 491
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 493
        cfg_opt_setnfloat(cfg___0->opts + i, (cfg___0->opts + i)->def.fpnumber, 0U);
        }
#line 495
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 497
        cfg_opt_setnbool(cfg___0->opts + i, (cfg___0->opts + i)->def.boolean, 0U);
        }
#line 499
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 501
        cfg_opt_setnstr(cfg___0->opts + i, (char const   *)(cfg___0->opts + i)->def.string,
                        0U);
        }
#line 503
        goto switch_break;
        case_7: /* CIL Label */ 
        case_6: /* CIL Label */ 
#line 506
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 508
        cfg_error(cfg___0, "internal error in cfg_init_defaults(%s)", (cfg___0->opts + i)->name);
        }
#line 511
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 520
      (cfg___0->opts + i)->flags |= 64;
    } else
#line 522
    if (! ((1 & (cfg___0->opts + i)->flags) == 1)) {
      {
#line 524
      cfg_setopt(cfg___0, cfg___0->opts + i, (char *)0);
#line 525
      (cfg___0->opts + i)->flags |= 128;
      }
    }
    __Cont: /* CIL Label */ 
#line 426
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  return;
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_value_t *cfg_setopt(cfg_t *cfg___0 , cfg_opt_t *opt , char *value ) 
{ 
  cfg_value_t *val ;
  int b ;
  char *s ;
  double f ;
  long i ;
  void *p ;
  char *endptr ;
  unsigned int i___0 ;
  cfg_t *sec ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 533
  val = (cfg_value_t *)0;
#line 541
  if (cfg___0) {
#line 541
    if (! opt) {
      {
#line 541
      __assert_fail("cfg && opt", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    541U, "cfg_setopt");
      }
    }
  } else {
    {
#line 541
    __assert_fail("cfg && opt", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  541U, "cfg_setopt");
    }
  }
#line 543
  if (opt->simple_value) {
#line 545
    if (! ((unsigned int )opt->type != 5U)) {
      {
#line 545
      __assert_fail("opt->type != CFGT_SEC", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    545U, "cfg_setopt");
      }
    }
#line 546
    val = (cfg_value_t *)opt->simple_value;
  } else {
#line 550
    if ((64 & opt->flags) == 64) {
      {
#line 552
      cfg_free_value(opt);
#line 553
      opt->flags &= -65;
      }
    }
#line 556
    if (opt->nvalues == 0U) {
#line 556
      goto _L;
    } else
#line 556
    if ((1 & opt->flags) == 1) {
#line 556
      goto _L;
    } else
#line 556
    if ((2 & opt->flags) == 2) {
      _L: /* CIL Label */ 
#line 559
      val = (cfg_value_t *)0;
#line 560
      if ((unsigned int )opt->type == 5U) {
#line 560
        if ((8 & opt->flags) == 8) {
#line 569
          if (! (opt->nvalues == 0U)) {
#line 569
            if (! value) {
              {
#line 569
              __assert_fail("opt->nvalues == 0 || value", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                            569U, "cfg_setopt");
              }
            }
          }
#line 571
          i___0 = 0U;
          {
#line 571
          while (1) {
            while_continue: /* CIL Label */ ;
#line 571
            if (i___0 < opt->nvalues) {
#line 571
              if (! ((unsigned long )val == (unsigned long )((void *)0))) {
#line 571
                goto while_break;
              }
            } else {
#line 571
              goto while_break;
            }
#line 573
            sec = (*(opt->values + i___0))->section;
#line 574
            if ((4 & cfg___0->flags) == 4) {
              {
#line 576
              tmp = strcasecmp((char const   *)value, (char const   *)sec->title);
              }
#line 576
              if (tmp == 0) {
#line 577
                val = *(opt->values + i___0);
              }
            } else {
              {
#line 581
              tmp___0 = strcmp((char const   *)value, (char const   *)sec->title);
              }
#line 581
              if (tmp___0 == 0) {
#line 582
                val = *(opt->values + i___0);
              }
            }
#line 571
            i___0 ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 585
          if (val) {
#line 585
            if ((32 & opt->flags) == 32) {
              {
#line 587
              tmp___1 = dgettext("confuse", "found duplicate title \'%s\'");
#line 587
              cfg_error(cfg___0, (char const   *)tmp___1, value);
              }
#line 588
              return ((cfg_value_t *)0);
            }
          }
        }
      }
#line 591
      if ((unsigned long )val == (unsigned long )((void *)0)) {
        {
#line 592
        val = cfg_addval(opt);
        }
      }
    } else {
#line 595
      val = *(opt->values + 0);
    }
  }
  {
#line 600
  if ((unsigned int )opt->type == 1U) {
#line 600
    goto case_1;
  }
#line 626
  if ((unsigned int )opt->type == 2U) {
#line 626
    goto case_2;
  }
#line 653
  if ((unsigned int )opt->type == 3U) {
#line 653
    goto case_3;
  }
#line 666
  if ((unsigned int )opt->type == 5U) {
#line 666
    goto case_5;
  }
#line 684
  if ((unsigned int )opt->type == 4U) {
#line 684
    goto case_4;
  }
#line 703
  if ((unsigned int )opt->type == 7U) {
#line 703
    goto case_7;
  }
#line 710
  goto switch_default;
  case_1: /* CIL Label */ 
#line 601
  if (opt->parsecb) {
    {
#line 603
    tmp___2 = (*(opt->parsecb))(cfg___0, opt, (char const   *)value, (void *)(& i));
    }
#line 603
    if (tmp___2 != 0) {
#line 604
      return ((cfg_value_t *)0);
    }
#line 605
    val->number = i;
  } else {
    {
#line 609
    val->number = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                         0);
    }
#line 610
    if ((int )*endptr != 0) {
      {
#line 612
      tmp___3 = dgettext("confuse", "invalid integer value for option \'%s\'");
#line 612
      cfg_error(cfg___0, (char const   *)tmp___3, opt->name);
      }
#line 614
      return ((cfg_value_t *)0);
    }
    {
#line 616
    tmp___5 = __errno_location();
    }
#line 616
    if (*tmp___5 == 34) {
      {
#line 618
      tmp___4 = dgettext("confuse", "integer value for option \'%s\' is out of range");
#line 618
      cfg_error(cfg___0, (char const   *)tmp___4, opt->name);
      }
#line 621
      return ((cfg_value_t *)0);
    }
  }
#line 624
  goto switch_break;
  case_2: /* CIL Label */ 
#line 627
  if (opt->parsecb) {
    {
#line 629
    tmp___6 = (*(opt->parsecb))(cfg___0, opt, (char const   *)value, (void *)(& f));
    }
#line 629
    if (tmp___6 != 0) {
#line 630
      return ((cfg_value_t *)0);
    }
#line 631
    val->fpnumber = f;
  } else {
    {
#line 635
    val->fpnumber = strtod((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr));
    }
#line 636
    if ((int )*endptr != 0) {
      {
#line 638
      tmp___7 = dgettext("confuse", "invalid floating point value for option \'%s\'");
#line 638
      cfg_error(cfg___0, (char const   *)tmp___7, opt->name);
      }
#line 641
      return ((cfg_value_t *)0);
    }
    {
#line 643
    tmp___9 = __errno_location();
    }
#line 643
    if (*tmp___9 == 34) {
      {
#line 645
      tmp___8 = dgettext("confuse", "floating point value for option \'%s\' is out of range");
#line 645
      cfg_error(cfg___0, (char const   *)tmp___8, opt->name);
      }
#line 648
      return ((cfg_value_t *)0);
    }
  }
#line 651
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 654
  free((void *)val->string);
  }
#line 655
  if (opt->parsecb) {
    {
#line 657
    s = (char *)0;
#line 658
    tmp___10 = (*(opt->parsecb))(cfg___0, opt, (char const   *)value, (void *)(& s));
    }
#line 658
    if (tmp___10 != 0) {
#line 659
      return ((cfg_value_t *)0);
    }
    {
#line 660
    val->string = strdup((char const   *)s);
    }
  } else {
    {
#line 663
    val->string = strdup((char const   *)value);
    }
  }
#line 664
  goto switch_break;
  case_5: /* CIL Label */ 
#line 667
  if ((1 & opt->flags) == 1) {
#line 667
    goto _L___0;
  } else
#line 667
  if ((unsigned long )val->section == (unsigned long )((cfg_t *)0)) {
    _L___0: /* CIL Label */ 
    {
#line 669
    cfg_free(val->section);
#line 670
    tmp___11 = calloc((size_t )1, sizeof(cfg_t ));
#line 670
    val->section = (cfg_t *)tmp___11;
    }
#line 671
    if (! val->section) {
      {
#line 671
      __assert_fail("val->section", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    671U, "cfg_setopt");
      }
    }
    {
#line 672
    (val->section)->name = strdup((char const   *)opt->name);
#line 673
    (val->section)->opts = cfg_dupopt_array(opt->subopts);
#line 674
    (val->section)->flags = cfg___0->flags;
    }
#line 675
    if (cfg___0->filename) {
      {
#line 675
      tmp___12 = strdup((char const   *)cfg___0->filename);
#line 675
      (val->section)->filename = tmp___12;
      }
    } else {
#line 675
      (val->section)->filename = (char *)0;
    }
#line 676
    (val->section)->line = cfg___0->line;
#line 677
    (val->section)->errfunc = cfg___0->errfunc;
#line 678
    (val->section)->title = value;
  }
#line 680
  if (! ((128 & opt->flags) == 128)) {
    {
#line 681
    cfg_init_defaults(val->section);
    }
  }
#line 682
  goto switch_break;
  case_4: /* CIL Label */ 
#line 685
  if (opt->parsecb) {
    {
#line 687
    tmp___13 = (*(opt->parsecb))(cfg___0, opt, (char const   *)value, (void *)(& b));
    }
#line 687
    if (tmp___13 != 0) {
#line 688
      return ((cfg_value_t *)0);
    }
  } else {
    {
#line 692
    b = cfg_parse_boolean((char const   *)value);
    }
#line 693
    if (b == -1) {
      {
#line 695
      tmp___14 = dgettext("confuse", "invalid boolean value for option \'%s\'");
#line 695
      cfg_error(cfg___0, (char const   *)tmp___14, opt->name);
      }
#line 697
      return ((cfg_value_t *)0);
    }
  }
#line 700
  val->boolean = (cfg_bool_t )b;
#line 701
  goto switch_break;
  case_7: /* CIL Label */ 
#line 704
  if (! opt->parsecb) {
    {
#line 704
    __assert_fail("opt->parsecb", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  704U, "cfg_setopt");
    }
  }
  {
#line 705
  tmp___15 = (*(opt->parsecb))(cfg___0, opt, (char const   *)value, (void *)(& p));
  }
#line 705
  if (tmp___15 != 0) {
#line 706
    return ((cfg_value_t *)0);
  }
#line 707
  val->ptr = p;
#line 708
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 711
  cfg_error(cfg___0, "internal error in cfg_setopt(%s, %s)", opt->name, value);
#line 713
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                713U, "cfg_setopt");
  }
#line 714
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 716
  return (val);
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_errfunc_t cfg_set_error_function(cfg_t *cfg___0 , void (*errfunc)(cfg_t *cfg ,
                                                                      char const   *fmt ,
                                                                      va_list ap ) ) 
{ 
  void (*old)(cfg_t *cfg , char const   *fmt , va_list ap ) ;

  {
#line 724
  if (! cfg___0) {
    {
#line 724
    __assert_fail("cfg", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  724U, "cfg_set_error_function");
    }
  }
#line 725
  old = cfg___0->errfunc;
#line 726
  cfg___0->errfunc = errfunc;
#line 727
  return (old);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_error(cfg_t *cfg___0 , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 734
  __builtin_va_start(ap, fmt);
  }
#line 736
  if (cfg___0) {
#line 736
    if (cfg___0->errfunc) {
      {
#line 737
      (*(cfg___0->errfunc))(cfg___0, fmt, ap);
      }
    } else {
#line 736
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 740
    if (cfg___0) {
#line 740
      if (cfg___0->filename) {
#line 740
        if (cfg___0->line) {
          {
#line 741
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
                  cfg___0->filename, cfg___0->line);
          }
        } else {
#line 740
          goto _L___0;
        }
      } else {
#line 740
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 742
    if (cfg___0) {
#line 742
      if (cfg___0->filename) {
        {
#line 743
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                cfg___0->filename);
        }
      }
    }
    {
#line 744
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             ap);
#line 745
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 748
  __builtin_va_end(ap);
  }
#line 749
  return;
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static int call_function(cfg_t *cfg___0 , cfg_opt_t *opt , cfg_opt_t *funcopt ) 
{ 
  int ret ;
  char const   **argv ;
  unsigned int i ;
  void *tmp ;

  {
  {
#line 760
  tmp = calloc((size_t )funcopt->nvalues, sizeof(char *));
#line 760
  argv = (char const   **)tmp;
#line 761
  i = 0U;
  }
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 761
    if (! (i < funcopt->nvalues)) {
#line 761
      goto while_break;
    }
#line 762
    *(argv + i) = (char const   *)(*(funcopt->values + i))->string;
#line 761
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 763
  ret = (*(opt->func))(cfg___0, opt, (int )funcopt->nvalues, argv);
#line 764
  cfg_free_value(funcopt);
#line 765
  free((void *)argv);
  }
#line 766
  return (ret);
}
}
#line 769 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static int cfg_parse_internal(cfg_t *cfg___0 , int level , int force_state , cfg_opt_t *force_opt ) 
{ 
  int state ;
  char *opttitle ;
  cfg_opt_t *opt ;
  cfg_value_t *val ;
  cfg_opt_t funcopt ;
  int num_values ;
  int rc ;
  int tok ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  cfg_value_t *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  cfg_value_t *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int ret ;
  int tmp___17 ;
  char *tmp___18 ;
  int ret___0 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
#line 772
  state = 0;
#line 773
  opttitle = (char *)0;
#line 774
  opt = (cfg_opt_t *)0;
#line 775
  val = (cfg_value_t *)0;
#line 776
  funcopt.name = (char *)0;
#line 776
  funcopt.type = (cfg_type_t )3;
#line 776
  funcopt.nvalues = 0U;
#line 776
  funcopt.values = (cfg_value_t **)0;
#line 776
  funcopt.flags = 0;
#line 776
  funcopt.subopts = (cfg_opt_t *)0;
#line 776
  funcopt.def.number = 0L;
#line 776
  funcopt.def.fpnumber = (double )0;
#line 776
  funcopt.def.boolean = (cfg_bool_t )0;
#line 776
  funcopt.def.string = (char *)0;
#line 776
  funcopt.def.parsed = (char *)0;
#line 776
  funcopt.func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 776
  funcopt.simple_value = (void *)0;
#line 776
  funcopt.parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 776
  funcopt.validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 776
  funcopt.pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 776
  funcopt.freecb = (void (*)(void *value ))0;
#line 777
  num_values = 0;
#line 780
  if (force_state != -1) {
#line 781
    state = force_state;
  }
#line 782
  if (force_opt) {
#line 783
    opt = force_opt;
  }
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 787
    tmp = cfg_yylex(cfg___0);
#line 787
    tok = tmp;
    }
#line 789
    if (tok == 0) {
#line 792
      return (1);
    }
#line 795
    if (tok == -1) {
#line 797
      if (state != 0) {
        {
#line 799
        tmp___0 = dgettext("confuse", "premature end of file");
#line 799
        cfg_error(cfg___0, (char const   *)tmp___0);
        }
#line 800
        return (1);
      }
#line 802
      return (-1);
    }
    {
#line 807
    if (state == 0) {
#line 807
      goto case_0;
    }
#line 840
    if (state == 1) {
#line 840
      goto case_1;
    }
#line 876
    if (state == 2) {
#line 876
      goto case_2;
    }
#line 906
    if (state == 3) {
#line 906
      goto case_3;
    }
#line 926
    if (state == 4) {
#line 926
      goto case_4;
    }
#line 943
    if (state == 5) {
#line 943
      goto case_5;
    }
#line 967
    if (state == 6) {
#line 967
      goto case_6;
    }
#line 979
    if (state == 7) {
#line 979
      goto case_7;
    }
#line 989
    if (state == 8) {
#line 989
      goto case_8;
    }
#line 1011
    if (state == 9) {
#line 1011
      goto case_9;
    }
#line 1029
    goto switch_default;
    case_0: /* CIL Label */ 
#line 808
    if (tok == 125) {
#line 810
      if (level == 0) {
        {
#line 812
        tmp___1 = dgettext("confuse", "unexpected closing brace");
#line 812
        cfg_error(cfg___0, (char const   *)tmp___1);
        }
#line 813
        return (1);
      }
#line 815
      return (-1);
    }
#line 817
    if (tok != 3) {
      {
#line 819
      tmp___2 = dgettext("confuse", "unexpected token \'%s\'");
#line 819
      cfg_error(cfg___0, (char const   *)tmp___2, cfg_yylval);
      }
#line 820
      return (1);
    }
    {
#line 822
    opt = cfg_getopt(cfg___0, (char const   *)cfg_yylval);
    }
#line 823
    if ((unsigned long )opt == (unsigned long )((cfg_opt_t *)0)) {
#line 824
      return (1);
    }
#line 825
    if ((unsigned int )opt->type == 5U) {
#line 827
      if ((8 & opt->flags) == 8) {
#line 828
        state = 6;
      } else {
#line 830
        state = 5;
      }
    } else
#line 832
    if ((unsigned int )opt->type == 6U) {
#line 834
      state = 7;
    } else {
#line 837
      state = 1;
    }
#line 838
    goto switch_break;
    case_1: /* CIL Label */ 
#line 841
    if (tok == 43) {
#line 843
      if (! ((2 & opt->flags) == 2)) {
        {
#line 845
        tmp___3 = dgettext("confuse", "attempt to append to non-list option \'%s\'");
#line 845
        cfg_error(cfg___0, (char const   *)tmp___3, opt->name);
        }
#line 848
        return (1);
      }
#line 854
      opt->flags &= -65;
    } else
#line 856
    if (tok == 61) {
#line 860
      opt->flags |= 64;
    } else {
      {
#line 864
      tmp___4 = dgettext("confuse", "missing equal sign after option \'%s\'");
#line 864
      cfg_error(cfg___0, (char const   *)tmp___4, opt->name);
      }
#line 866
      return (1);
    }
#line 868
    if ((2 & opt->flags) == 2) {
#line 870
      state = 3;
#line 871
      num_values = 0;
    } else {
#line 873
      state = 2;
    }
#line 874
    goto switch_break;
    case_2: /* CIL Label */ 
#line 877
    if (tok == 125) {
#line 877
      if ((2 & opt->flags) == 2) {
#line 879
        state = 0;
#line 880
        if (num_values == 0) {
#line 880
          if ((64 & opt->flags) == 64) {
            {
#line 883
            cfg_free_value(opt);
            }
          }
        }
#line 884
        goto switch_break;
      }
    }
#line 887
    if (tok != 3) {
      {
#line 889
      tmp___5 = dgettext("confuse", "unexpected token \'%s\'");
#line 889
      cfg_error(cfg___0, (char const   *)tmp___5, cfg_yylval);
      }
#line 890
      return (1);
    }
    {
#line 893
    tmp___6 = cfg_setopt(cfg___0, opt, cfg_yylval);
    }
#line 893
    if ((unsigned long )tmp___6 == (unsigned long )((cfg_value_t *)0)) {
#line 894
      return (1);
    }
#line 895
    if (opt->validcb) {
      {
#line 895
      tmp___7 = (*(opt->validcb))(cfg___0, opt);
      }
#line 895
      if (tmp___7 != 0) {
#line 896
        return (1);
      }
    }
#line 897
    if ((2 & opt->flags) == 2) {
#line 899
      num_values ++;
#line 900
      state = 4;
    } else {
#line 903
      state = 0;
    }
#line 904
    goto switch_break;
    case_3: /* CIL Label */ 
#line 907
    if (tok != 123) {
#line 909
      if (tok != 3) {
        {
#line 911
        tmp___8 = dgettext("confuse", "unexpected token \'%s\'");
#line 911
        cfg_error(cfg___0, (char const   *)tmp___8, cfg_yylval);
        }
#line 912
        return (1);
      }
      {
#line 915
      tmp___9 = cfg_setopt(cfg___0, opt, cfg_yylval);
      }
#line 915
      if ((unsigned long )tmp___9 == (unsigned long )((cfg_value_t *)0)) {
#line 916
        return (1);
      }
#line 917
      if (opt->validcb) {
        {
#line 917
        tmp___10 = (*(opt->validcb))(cfg___0, opt);
        }
#line 917
        if (tmp___10 != 0) {
#line 918
          return (1);
        }
      }
#line 919
      num_values ++;
#line 920
      state = 0;
    } else {
#line 923
      state = 2;
    }
#line 924
    goto switch_break;
    case_4: /* CIL Label */ 
#line 928
    if (tok == 44) {
#line 929
      state = 2;
    } else
#line 930
    if (tok == 125) {
#line 932
      state = 0;
#line 933
      if (opt->validcb) {
        {
#line 933
        tmp___11 = (*(opt->validcb))(cfg___0, opt);
        }
#line 933
        if (tmp___11 != 0) {
#line 934
          return (1);
        }
      }
    } else {
      {
#line 938
      tmp___12 = dgettext("confuse", "unexpected token \'%s\'");
#line 938
      cfg_error(cfg___0, (char const   *)tmp___12, cfg_yylval);
      }
#line 939
      return (1);
    }
#line 941
    goto switch_break;
    case_5: /* CIL Label */ 
#line 944
    if (tok != 123) {
      {
#line 946
      tmp___13 = dgettext("confuse", "missing opening brace for section \'%s\'");
#line 946
      cfg_error(cfg___0, (char const   *)tmp___13, opt->name);
      }
#line 948
      return (1);
    }
    {
#line 951
    val = cfg_setopt(cfg___0, opt, opttitle);
#line 952
    opttitle = (char *)0;
    }
#line 953
    if (! val) {
#line 954
      return (1);
    }
    {
#line 956
    (val->section)->line = cfg___0->line;
#line 957
    (val->section)->errfunc = cfg___0->errfunc;
#line 958
    rc = cfg_parse_internal(val->section, level + 1, -1, (cfg_opt_t *)0);
#line 959
    cfg___0->line = (val->section)->line;
    }
#line 960
    if (rc != -1) {
#line 961
      return (1);
    }
#line 962
    if (opt->validcb) {
      {
#line 962
      tmp___14 = (*(opt->validcb))(cfg___0, opt);
      }
#line 962
      if (tmp___14 != 0) {
#line 963
        return (1);
      }
    }
#line 964
    state = 0;
#line 965
    goto switch_break;
    case_6: /* CIL Label */ 
#line 968
    if (tok != 3) {
      {
#line 970
      tmp___15 = dgettext("confuse", "missing title for section \'%s\'");
#line 970
      cfg_error(cfg___0, (char const   *)tmp___15, opt->name);
      }
#line 972
      return (1);
    } else {
      {
#line 975
      opttitle = strdup((char const   *)cfg_yylval);
      }
    }
#line 976
    state = 5;
#line 977
    goto switch_break;
    case_7: /* CIL Label */ 
#line 980
    if (tok != 40) {
      {
#line 982
      tmp___16 = dgettext("confuse", "missing parenthesis for function \'%s\'");
#line 982
      cfg_error(cfg___0, (char const   *)tmp___16, opt->name);
      }
#line 984
      return (1);
    }
#line 986
    state = 8;
#line 987
    goto switch_break;
    case_8: /* CIL Label */ 
#line 990
    if (tok == 41) {
      {
#line 992
      tmp___17 = call_function(cfg___0, opt, & funcopt);
#line 992
      ret = tmp___17;
      }
#line 993
      if (ret != 0) {
#line 994
        return (1);
      }
#line 995
      state = 0;
    } else
#line 997
    if (tok == 3) {
      {
#line 999
      val = cfg_addval(& funcopt);
#line 1000
      val->string = strdup((char const   *)cfg_yylval);
#line 1001
      state = 9;
      }
    } else {
      {
#line 1005
      tmp___18 = dgettext("confuse", "syntax error in call of function \'%s\'");
#line 1005
      cfg_error(cfg___0, (char const   *)tmp___18, opt->name);
      }
#line 1007
      return (1);
    }
#line 1009
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1012
    if (tok == 41) {
      {
#line 1014
      tmp___19 = call_function(cfg___0, opt, & funcopt);
#line 1014
      ret___0 = tmp___19;
      }
#line 1015
      if (ret___0 != 0) {
#line 1016
        return (1);
      }
#line 1017
      state = 0;
    } else
#line 1019
    if (tok == 44) {
#line 1020
      state = 8;
    } else {
      {
#line 1023
      tmp___20 = dgettext("confuse", "syntax error in call of function \'%s\'");
#line 1023
      cfg_error(cfg___0, (char const   *)tmp___20, opt->name);
      }
#line 1025
      return (1);
    }
#line 1027
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1031
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1031U, "cfg_parse_internal");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1035
  return (-1);
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
int cfg_parse_fp(cfg_t *cfg___0 , FILE *fp ) 
{ 
  int ret ;

  {
#line 1041
  if (cfg___0) {
#line 1041
    if (! fp) {
      {
#line 1041
      __assert_fail("cfg && fp", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1041U, "cfg_parse_fp");
      }
    }
  } else {
    {
#line 1041
    __assert_fail("cfg && fp", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1041U, "cfg_parse_fp");
    }
  }
#line 1043
  if ((unsigned long )cfg___0->filename == (unsigned long )((char *)0)) {
    {
#line 1044
    cfg___0->filename = strdup("FILE");
    }
  }
  {
#line 1045
  cfg___0->line = 1;
#line 1047
  cfg_yyin = fp;
#line 1048
  cfg_scan_fp_begin(cfg_yyin);
#line 1049
  ret = cfg_parse_internal(cfg___0, 0, -1, (cfg_opt_t *)0);
#line 1050
  cfg_scan_fp_end();
  }
#line 1051
  if (ret == 1) {
#line 1052
    return (1);
  }
#line 1053
  return (0);
}
}
#line 1056 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
int cfg_parse(cfg_t *cfg___0 , char const   *filename ) 
{ 
  int ret ;
  FILE *fp ;

  {
#line 1061
  if (cfg___0) {
#line 1061
    if (! filename) {
      {
#line 1061
      __assert_fail("cfg && filename", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1061U, "cfg_parse");
      }
    }
  } else {
    {
#line 1061
    __assert_fail("cfg && filename", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1061U, "cfg_parse");
    }
  }
  {
#line 1063
  free((void *)cfg___0->filename);
#line 1064
  cfg___0->filename = cfg_tilde_expand(filename);
#line 1065
  fp = fopen((char const   */* __restrict  */)cfg___0->filename, (char const   */* __restrict  */)"r");
  }
#line 1066
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
#line 1067
    return (-1);
  }
  {
#line 1068
  ret = cfg_parse_fp(cfg___0, fp);
#line 1069
  fclose(fp);
  }
#line 1070
  return (ret);
}
}
#line 1073 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
int cfg_parse_buf(cfg_t *cfg___0 , char const   *buf ) 
{ 
  int ret ;

  {
#line 1077
  if (! cfg___0) {
    {
#line 1077
    __assert_fail("cfg", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1077U, "cfg_parse_buf");
    }
  }
#line 1078
  if ((unsigned long )buf == (unsigned long )((char const   *)0)) {
#line 1079
    return (0);
  }
  {
#line 1081
  free((void *)cfg___0->filename);
#line 1082
  cfg___0->filename = strdup("[buf]");
#line 1083
  cfg___0->line = 1;
#line 1085
  cfg_scan_string_begin(buf);
#line 1086
  ret = cfg_parse_internal(cfg___0, 0, -1, (cfg_opt_t *)0);
#line 1087
  cfg_scan_string_end();
  }
#line 1088
  if (ret == 1) {
#line 1089
    return (1);
  }
#line 1090
  return (0);
}
}
#line 1093 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_t *cfg_init(cfg_opt_t *opts , cfg_flag_t flags ) 
{ 
  cfg_t *cfg___0 ;
  void *tmp ;

  {
  {
#line 1097
  tmp = calloc((size_t )1, sizeof(cfg_t ));
#line 1097
  cfg___0 = (cfg_t *)tmp;
  }
#line 1098
  if (! cfg___0) {
    {
#line 1098
    __assert_fail("cfg", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1098U, "cfg_init");
    }
  }
  {
#line 1100
  cfg___0->name = strdup("root");
#line 1101
  cfg___0->opts = cfg_dupopt_array(opts);
#line 1102
  cfg___0->flags = flags;
#line 1103
  cfg___0->filename = (char *)0;
#line 1104
  cfg___0->line = 0;
#line 1105
  cfg___0->errfunc = (void (*)(cfg_t *cfg , char const   *fmt , va_list ap ))0;
#line 1107
  cfg_init_defaults(cfg___0);
#line 1110
  setlocale(5, "");
#line 1111
  setlocale(0, "");
#line 1112
  bindtextdomain("confuse", "/usr/local/share/locale");
  }
#line 1115
  return (cfg___0);
}
}
#line 1118 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
char *cfg_tilde_expand(char const   *filename ) 
{ 
  char *expanded ;
  struct passwd *passwd ;
  char const   *file ;
  __uid_t tmp ;
  char *user ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 1120
  expanded = (char *)0;
#line 1125
  if ((int const   )*(filename + 0) == 126) {
#line 1127
    passwd = (struct passwd *)0;
#line 1128
    file = (char const   *)0;
#line 1130
    if ((int const   )*(filename + 1) == 47) {
      {
#line 1133
      tmp = geteuid();
#line 1133
      passwd = getpwuid(tmp);
#line 1134
      file = filename + 1;
      }
    } else
#line 1130
    if ((int const   )*(filename + 1) == 0) {
      {
#line 1133
      tmp = geteuid();
#line 1133
      passwd = getpwuid(tmp);
#line 1134
      file = filename + 1;
      }
    } else {
      {
#line 1141
      tmp___0 = strchr(filename, '/');
#line 1141
      file = (char const   *)tmp___0;
      }
#line 1142
      if ((unsigned long )file == (unsigned long )((char const   *)0)) {
        {
#line 1143
        tmp___1 = strlen(filename);
#line 1143
        file = filename + tmp___1;
        }
      }
      {
#line 1144
      tmp___2 = malloc((size_t )(file - filename));
#line 1144
      user = (char *)tmp___2;
#line 1145
      strncpy((char */* __restrict  */)user, (char const   */* __restrict  */)(filename + 1),
              (size_t )((file - filename) - 1L));
#line 1146
      passwd = getpwnam((char const   *)user);
#line 1147
      free((void *)user);
      }
    }
#line 1150
    if (passwd) {
      {
#line 1152
      tmp___3 = strlen((char const   *)passwd->pw_dir);
#line 1152
      tmp___4 = strlen(file);
#line 1152
      tmp___5 = malloc((tmp___3 + tmp___4) + 1UL);
#line 1152
      expanded = (char *)tmp___5;
#line 1153
      strcpy((char */* __restrict  */)expanded, (char const   */* __restrict  */)passwd->pw_dir);
#line 1154
      strcat((char */* __restrict  */)expanded, (char const   */* __restrict  */)file);
      }
    }
  }
#line 1158
  if (! expanded) {
    {
#line 1159
    expanded = strdup(filename);
    }
  }
#line 1160
  return (expanded);
}
}
#line 1163 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_free_value(cfg_opt_t *opt ) 
{ 
  unsigned int i ;

  {
#line 1167
  if ((unsigned long )opt == (unsigned long )((cfg_opt_t *)0)) {
#line 1168
    return;
  }
#line 1170
  if (opt->values) {
#line 1172
    i = 0U;
    {
#line 1172
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1172
      if (! (i < opt->nvalues)) {
#line 1172
        goto while_break;
      }
#line 1174
      if ((unsigned int )opt->type == 3U) {
        {
#line 1175
        free((void *)(*(opt->values + i))->string);
        }
      } else
#line 1176
      if ((unsigned int )opt->type == 5U) {
        {
#line 1177
        cfg_free((*(opt->values + i))->section);
        }
      } else
#line 1178
      if ((unsigned int )opt->type == 7U) {
#line 1178
        if (opt->freecb) {
#line 1178
          if ((*(opt->values + i))->ptr) {
            {
#line 1179
            (*(opt->freecb))((*(opt->values + i))->ptr);
            }
          }
        }
      }
      {
#line 1180
      free((void *)*(opt->values + i));
#line 1172
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1182
    free((void *)opt->values);
    }
  }
#line 1184
  opt->values = (cfg_value_t **)0;
#line 1185
  opt->nvalues = 0U;
#line 1186
  return;
}
}
#line 1188 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_free_opt_array(cfg_opt_t *opts ) 
{ 
  int i ;

  {
#line 1192
  i = 0;
  {
#line 1192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1192
    if (! (opts + i)->name) {
#line 1192
      goto while_break;
    }
    {
#line 1194
    free((void *)(opts + i)->name);
    }
#line 1195
    if ((unsigned int )(opts + i)->type == 6U) {
      {
#line 1196
      free((void *)(opts + i)->def.parsed);
      }
    } else
#line 1195
    if ((2 & (opts + i)->flags) == 2) {
      {
#line 1196
      free((void *)(opts + i)->def.parsed);
      }
    } else
#line 1197
    if ((unsigned int )(opts + i)->type == 3U) {
      {
#line 1198
      free((void *)(opts + i)->def.string);
      }
    } else
#line 1199
    if ((unsigned int )(opts + i)->type == 5U) {
      {
#line 1200
      cfg_free_opt_array((opts + i)->subopts);
      }
    }
#line 1192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1202
  free((void *)opts);
  }
#line 1203
  return;
}
}
#line 1205 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_free(cfg_t *cfg___0 ) 
{ 
  int i ;

  {
#line 1209
  if ((unsigned long )cfg___0 == (unsigned long )((cfg_t *)0)) {
#line 1210
    return;
  }
#line 1212
  i = 0;
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1212
    if (! (cfg___0->opts + i)->name) {
#line 1212
      goto while_break;
    }
    {
#line 1213
    cfg_free_value(cfg___0->opts + i);
#line 1212
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1215
  cfg_free_opt_array(cfg___0->opts);
#line 1217
  free((void *)cfg___0->name);
#line 1218
  free((void *)cfg___0->title);
#line 1219
  free((void *)cfg___0->filename);
#line 1221
  free((void *)cfg___0);
  }
#line 1222
  return;
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
int cfg_include(cfg_t *cfg___0 , cfg_opt_t *opt , int argc , char const   **argv ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 1227
  opt = (cfg_opt_t *)((void *)0);
#line 1228
  if (argc != 1) {
    {
#line 1230
    tmp = dgettext("confuse", "wrong number of arguments to cfg_include()");
#line 1230
    cfg_error(cfg___0, (char const   *)tmp);
    }
#line 1231
    return (1);
  }
  {
#line 1233
  tmp___0 = cfg_lexer_include(cfg___0, *(argv + 0));
  }
#line 1233
  return (tmp___0);
}
}
#line 1236 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_value_t *cfg_opt_getval(cfg_opt_t *opt , unsigned int index___0 ) 
{ 
  cfg_value_t *val ;

  {
#line 1238
  val = (cfg_value_t *)0;
#line 1240
  if (! (index___0 == 0U)) {
#line 1240
    if (! ((2 & opt->flags) == 2)) {
      {
#line 1240
      __assert_fail("index == 0 || (((2) & (opt->flags)) == (2))", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1240U, "cfg_opt_getval");
      }
    }
  }
#line 1242
  if (opt->simple_value) {
#line 1243
    val = (cfg_value_t *)opt->simple_value;
  } else {
#line 1246
    if ((64 & opt->flags) == 64) {
      {
#line 1248
      cfg_free_value(opt);
#line 1249
      opt->flags &= -65;
      }
    }
#line 1252
    if (index___0 >= opt->nvalues) {
      {
#line 1253
      val = cfg_addval(opt);
      }
    } else {
#line 1255
      val = *(opt->values + index___0);
    }
  }
#line 1257
  return (val);
}
}
#line 1260 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_opt_setnint(cfg_opt_t *opt , long value , unsigned int index___0 ) 
{ 
  cfg_value_t *val ;

  {
#line 1264
  if (opt) {
#line 1264
    if (! ((unsigned int )opt->type == 1U)) {
      {
#line 1264
      __assert_fail("opt && opt->type == CFGT_INT", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1264U, "cfg_opt_setnint");
      }
    }
  } else {
    {
#line 1264
    __assert_fail("opt && opt->type == CFGT_INT", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1264U, "cfg_opt_setnint");
    }
  }
  {
#line 1265
  val = cfg_opt_getval(opt, index___0);
#line 1266
  val->number = value;
  }
#line 1267
  return;
}
}
#line 1269 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_setnint(cfg_t *cfg___0 , char const   *name , long value , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;

  {
  {
#line 1272
  tmp = cfg_getopt(cfg___0, name);
#line 1272
  cfg_opt_setnint(tmp, value, index___0);
  }
#line 1273
  return;
}
}
#line 1275 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_setint(cfg_t *cfg___0 , char const   *name , long value ) 
{ 


  {
  {
#line 1277
  cfg_setnint(cfg___0, name, value, 0U);
  }
#line 1278
  return;
}
}
#line 1280 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_opt_setnfloat(cfg_opt_t *opt , double value , unsigned int index___0 ) 
{ 
  cfg_value_t *val ;

  {
#line 1284
  if (opt) {
#line 1284
    if (! ((unsigned int )opt->type == 2U)) {
      {
#line 1284
      __assert_fail("opt && opt->type == CFGT_FLOAT", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1284U, "cfg_opt_setnfloat");
      }
    }
  } else {
    {
#line 1284
    __assert_fail("opt && opt->type == CFGT_FLOAT", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1284U, "cfg_opt_setnfloat");
    }
  }
  {
#line 1285
  val = cfg_opt_getval(opt, index___0);
#line 1286
  val->fpnumber = value;
  }
#line 1287
  return;
}
}
#line 1289 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_setnfloat(cfg_t *cfg___0 , char const   *name , double value , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;

  {
  {
#line 1292
  tmp = cfg_getopt(cfg___0, name);
#line 1292
  cfg_opt_setnfloat(tmp, value, index___0);
  }
#line 1293
  return;
}
}
#line 1295 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_setfloat(cfg_t *cfg___0 , char const   *name , double value ) 
{ 


  {
  {
#line 1297
  cfg_setnfloat(cfg___0, name, value, 0U);
  }
#line 1298
  return;
}
}
#line 1300 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_opt_setnbool(cfg_opt_t *opt , cfg_bool_t value , unsigned int index___0 ) 
{ 
  cfg_value_t *val ;

  {
#line 1304
  if (opt) {
#line 1304
    if (! ((unsigned int )opt->type == 4U)) {
      {
#line 1304
      __assert_fail("opt && opt->type == CFGT_BOOL", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1304U, "cfg_opt_setnbool");
      }
    }
  } else {
    {
#line 1304
    __assert_fail("opt && opt->type == CFGT_BOOL", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1304U, "cfg_opt_setnbool");
    }
  }
  {
#line 1305
  val = cfg_opt_getval(opt, index___0);
#line 1306
  val->boolean = value;
  }
#line 1307
  return;
}
}
#line 1309 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_setnbool(cfg_t *cfg___0 , char const   *name , cfg_bool_t value , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;

  {
  {
#line 1312
  tmp = cfg_getopt(cfg___0, name);
#line 1312
  cfg_opt_setnbool(tmp, value, index___0);
  }
#line 1313
  return;
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_setbool(cfg_t *cfg___0 , char const   *name , cfg_bool_t value ) 
{ 


  {
  {
#line 1317
  cfg_setnbool(cfg___0, name, value, 0U);
  }
#line 1318
  return;
}
}
#line 1320 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_opt_setnstr(cfg_opt_t *opt , char const   *value , unsigned int index___0 ) 
{ 
  cfg_value_t *val ;
  char *tmp ;

  {
#line 1324
  if (opt) {
#line 1324
    if (! ((unsigned int )opt->type == 3U)) {
      {
#line 1324
      __assert_fail("opt && opt->type == CFGT_STR", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1324U, "cfg_opt_setnstr");
      }
    }
  } else {
    {
#line 1324
    __assert_fail("opt && opt->type == CFGT_STR", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1324U, "cfg_opt_setnstr");
    }
  }
  {
#line 1325
  val = cfg_opt_getval(opt, index___0);
#line 1326
  free((void *)val->string);
  }
#line 1327
  if (value) {
    {
#line 1327
    tmp = strdup(value);
#line 1327
    val->string = tmp;
    }
  } else {
#line 1327
    val->string = (char *)0;
  }
#line 1328
  return;
}
}
#line 1330 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_setnstr(cfg_t *cfg___0 , char const   *name , char const   *value , unsigned int index___0 ) 
{ 
  cfg_opt_t *tmp ;

  {
  {
#line 1333
  tmp = cfg_getopt(cfg___0, name);
#line 1333
  cfg_opt_setnstr(tmp, value, index___0);
  }
#line 1334
  return;
}
}
#line 1336 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_setstr(cfg_t *cfg___0 , char const   *name , char const   *value ) 
{ 


  {
  {
#line 1338
  cfg_setnstr(cfg___0, name, value, 0U);
  }
#line 1339
  return;
}
}
#line 1341 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_addlist_internal(cfg_opt_t *opt , unsigned int nvalues , va_list ap ) 
{ 
  unsigned int i ;
  int tmp___0 ;
  double tmp___2 ;
  cfg_bool_t tmp___4 ;
  char *tmp___6 ;

  {
#line 1346
  i = 0U;
  {
#line 1346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1346
    if (! (i < nvalues)) {
#line 1346
      goto while_break;
    }
    {
#line 1350
    if ((unsigned int )opt->type == 1U) {
#line 1350
      goto case_1;
    }
#line 1353
    if ((unsigned int )opt->type == 2U) {
#line 1353
      goto case_2;
    }
#line 1357
    if ((unsigned int )opt->type == 4U) {
#line 1357
      goto case_4;
    }
#line 1361
    if ((unsigned int )opt->type == 3U) {
#line 1361
      goto case_3;
    }
#line 1366
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1351
    tmp___0 = __builtin_va_arg(ap, int );
#line 1351
    cfg_opt_setnint(opt, (long )tmp___0, opt->nvalues);
    }
#line 1352
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1354
    tmp___2 = __builtin_va_arg(ap, double );
#line 1354
    cfg_opt_setnfloat(opt, tmp___2, opt->nvalues);
    }
#line 1356
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1358
    tmp___4 = __builtin_va_arg(ap, cfg_bool_t );
#line 1358
    cfg_opt_setnbool(opt, tmp___4, opt->nvalues);
    }
#line 1360
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1362
    tmp___6 = __builtin_va_arg(ap, char *);
#line 1362
    cfg_opt_setnstr(opt, (char const   *)tmp___6, opt->nvalues);
    }
#line 1363
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1367
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1370
  return;
}
}
#line 1372 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_setlist(cfg_t *cfg___0 , char const   *name , unsigned int nvalues  , ...) 
{ 
  va_list ap ;
  cfg_opt_t *opt ;
  cfg_opt_t *tmp ;

  {
  {
#line 1376
  tmp = cfg_getopt(cfg___0, name);
#line 1376
  opt = tmp;
  }
#line 1378
  if (opt) {
#line 1378
    if (! ((2 & opt->flags) == 2)) {
      {
#line 1378
      __assert_fail("opt && (((2) & (opt->flags)) == (2))", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1378U, "cfg_setlist");
      }
    }
  } else {
    {
#line 1378
    __assert_fail("opt && (((2) & (opt->flags)) == (2))", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1378U, "cfg_setlist");
    }
  }
  {
#line 1380
  cfg_free_value(opt);
#line 1381
  __builtin_va_start(ap, nvalues);
#line 1382
  cfg_addlist_internal(opt, nvalues, ap);
#line 1383
  __builtin_va_end(ap);
  }
#line 1384
  return;
}
}
#line 1386 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_addlist(cfg_t *cfg___0 , char const   *name , unsigned int nvalues  , ...) 
{ 
  va_list ap ;
  cfg_opt_t *opt ;
  cfg_opt_t *tmp ;

  {
  {
#line 1390
  tmp = cfg_getopt(cfg___0, name);
#line 1390
  opt = tmp;
  }
#line 1392
  if (opt) {
#line 1392
    if (! ((2 & opt->flags) == 2)) {
      {
#line 1392
      __assert_fail("opt && (((2) & (opt->flags)) == (2))", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1392U, "cfg_addlist");
      }
    }
  } else {
    {
#line 1392
    __assert_fail("opt && (((2) & (opt->flags)) == (2))", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1392U, "cfg_addlist");
    }
  }
  {
#line 1394
  __builtin_va_start(ap, nvalues);
#line 1395
  cfg_addlist_internal(opt, nvalues, ap);
#line 1396
  __builtin_va_end(ap);
  }
#line 1397
  return;
}
}
#line 1399 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_opt_nprint_var(cfg_opt_t *opt , unsigned int index___0 , FILE *fp ) 
{ 
  char const   *str ;
  long tmp ;
  double tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___3 ;
  cfg_bool_t tmp___4 ;

  {
#line 1403
  if (opt) {
#line 1403
    if (! fp) {
      {
#line 1403
      __assert_fail("opt && fp", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1403U, "cfg_opt_nprint_var");
      }
    }
  } else {
    {
#line 1403
    __assert_fail("opt && fp", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1403U, "cfg_opt_nprint_var");
    }
  }
  {
#line 1406
  if ((unsigned int )opt->type == 1U) {
#line 1406
    goto case_1;
  }
#line 1409
  if ((unsigned int )opt->type == 2U) {
#line 1409
    goto case_2;
  }
#line 1412
  if ((unsigned int )opt->type == 3U) {
#line 1412
    goto case_3;
  }
#line 1427
  if ((unsigned int )opt->type == 4U) {
#line 1427
    goto case_4;
  }
#line 1433
  if ((unsigned int )opt->type == 7U) {
#line 1433
    goto case_7;
  }
#line 1433
  if ((unsigned int )opt->type == 6U) {
#line 1433
    goto case_7;
  }
#line 1433
  if ((unsigned int )opt->type == 5U) {
#line 1433
    goto case_7;
  }
#line 1433
  if ((unsigned int )opt->type == 0U) {
#line 1433
    goto case_7;
  }
#line 1404
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1407
  tmp = cfg_opt_getnint(opt, index___0);
#line 1407
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%ld", tmp);
  }
#line 1408
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1410
  tmp___0 = cfg_opt_getnfloat(opt, index___0);
#line 1410
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lf", tmp___0);
  }
#line 1411
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1413
  tmp___1 = cfg_opt_getnstr(opt, index___0);
#line 1413
  str = (char const   *)tmp___1;
#line 1414
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\"");
  }
  {
#line 1415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1415
    if (str) {
#line 1415
      if (! *str) {
#line 1415
        goto while_break;
      }
    } else {
#line 1415
      goto while_break;
    }
#line 1417
    if ((int const   )*str == 34) {
      {
#line 1418
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\\\"");
      }
    } else
#line 1419
    if ((int const   )*str == 92) {
      {
#line 1420
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\\\\");
      }
    } else {
      {
#line 1422
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%c",
              (int const   )*str);
      }
    }
#line 1423
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1425
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\"");
  }
#line 1426
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1428
  tmp___4 = cfg_opt_getnbool(opt, index___0);
  }
#line 1428
  if (tmp___4) {
#line 1428
    tmp___3 = "true";
  } else {
#line 1428
    tmp___3 = "false";
  }
  {
#line 1428
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", tmp___3);
  }
#line 1429
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 1434
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1436
  return;
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_indent(FILE *fp , int indent ) 
{ 
  int tmp ;

  {
  {
#line 1440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1440
    tmp = indent;
#line 1440
    indent --;
#line 1440
    if (! tmp) {
#line 1440
      goto while_break;
    }
    {
#line 1441
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1442
  return;
}
}
#line 1444 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_opt_print_indent(cfg_opt_t *opt , FILE *fp , int indent ) 
{ 
  cfg_t *sec ;
  unsigned int i ;
  char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned int i___0 ;
  unsigned int tmp___1 ;

  {
#line 1446
  if (opt) {
#line 1446
    if (! fp) {
      {
#line 1446
      __assert_fail("opt && fp", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1446U, "cfg_opt_print_indent");
      }
    }
  } else {
    {
#line 1446
    __assert_fail("opt && fp", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1446U, "cfg_opt_print_indent");
    }
  }
#line 1448
  if ((unsigned int )opt->type == 5U) {
#line 1453
    i = 0U;
    {
#line 1453
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1453
      tmp___0 = cfg_opt_size(opt);
      }
#line 1453
      if (! (i < tmp___0)) {
#line 1453
        goto while_break;
      }
      {
#line 1455
      sec = cfg_opt_getnsec(opt, i);
#line 1456
      cfg_indent(fp, indent);
      }
#line 1457
      if ((8 & opt->flags) == 8) {
        {
#line 1458
        tmp = cfg_title(sec);
#line 1458
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s \"%s\" {\n",
                opt->name, tmp);
        }
      } else {
        {
#line 1460
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s {\n",
                opt->name);
        }
      }
      {
#line 1461
      cfg_print_indent(sec, fp, indent + 1);
#line 1462
      cfg_indent(fp, indent);
#line 1463
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"}\n");
#line 1453
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1466
  if ((unsigned int )opt->type != 6U) {
#line 1466
    if ((unsigned int )opt->type != 0U) {
#line 1468
      if ((2 & opt->flags) == 2) {
        {
#line 1472
        cfg_indent(fp, indent);
#line 1473
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s = {",
                opt->name);
        }
#line 1475
        if (opt->nvalues) {
#line 1477
          if (opt->pf) {
            {
#line 1478
            (*(opt->pf))(opt, 0U, fp);
            }
          } else {
            {
#line 1480
            cfg_opt_nprint_var(opt, 0U, fp);
            }
          }
#line 1481
          i___0 = 1U;
          {
#line 1481
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1481
            if (! (i___0 < opt->nvalues)) {
#line 1481
              goto while_break___0;
            }
            {
#line 1483
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)", ");
            }
#line 1484
            if (opt->pf) {
              {
#line 1485
              (*(opt->pf))(opt, i___0, fp);
              }
            } else {
              {
#line 1487
              cfg_opt_nprint_var(opt, i___0, fp);
              }
            }
#line 1481
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 1491
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"}");
        }
      } else {
        {
#line 1495
        cfg_indent(fp, indent);
        }
#line 1497
        if (opt->simple_value) {
#line 1499
          if ((unsigned int )opt->type == 3U) {
#line 1499
            if ((unsigned long )*((char **)opt->simple_value) == (unsigned long )((char *)0)) {
              {
#line 1500
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# ");
              }
            }
          }
        } else {
          {
#line 1504
          tmp___1 = cfg_opt_size(opt);
          }
#line 1504
          if (tmp___1 == 0U) {
            {
#line 1507
            fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# ");
            }
          } else
#line 1504
          if ((unsigned int )opt->type == 3U) {
#line 1504
            if ((unsigned long )(*(opt->values + 0))->string == (unsigned long )((char *)0)) {
              {
#line 1507
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# ");
              }
            } else
#line 1504
            if ((int )*((*(opt->values + 0))->string + 0) == 0) {
              {
#line 1507
              fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# ");
              }
            }
          }
        }
        {
#line 1509
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s = ",
                opt->name);
        }
#line 1510
        if (opt->pf) {
          {
#line 1511
          (*(opt->pf))(opt, 0U, fp);
          }
        } else {
          {
#line 1513
          cfg_opt_nprint_var(opt, 0U, fp);
          }
        }
      }
      {
#line 1516
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
      }
    } else {
#line 1466
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1518
  if (opt->pf) {
    {
#line 1520
    cfg_indent(fp, indent);
#line 1521
    (*(opt->pf))(opt, 0U, fp);
#line 1522
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
    }
  }
#line 1524
  return;
}
}
#line 1526 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_opt_print(cfg_opt_t *opt , FILE *fp ) 
{ 


  {
  {
#line 1528
  cfg_opt_print_indent(opt, fp, 0);
  }
#line 1529
  return;
}
}
#line 1531 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_print_indent(cfg_t *cfg___0 , FILE *fp , int indent ) 
{ 
  int i ;

  {
#line 1535
  i = 0;
  {
#line 1535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1535
    if (! (cfg___0->opts + i)->name) {
#line 1535
      goto while_break;
    }
    {
#line 1536
    cfg_opt_print_indent(cfg___0->opts + i, fp, indent);
#line 1535
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1537
  return;
}
}
#line 1539 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
void cfg_print(cfg_t *cfg___0 , FILE *fp ) 
{ 


  {
  {
#line 1541
  cfg_print_indent(cfg___0, fp, 0);
  }
#line 1542
  return;
}
}
#line 1544 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_print_func_t cfg_opt_set_print_func(cfg_opt_t *opt , void (*pf)(cfg_opt_t *opt ,
                                                                    unsigned int index ,
                                                                    FILE *fp ) ) 
{ 
  void (*oldpf)(cfg_opt_t *opt , unsigned int index , FILE *fp ) ;

  {
#line 1549
  if (! opt) {
    {
#line 1549
    __assert_fail("opt", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1549U, "cfg_opt_set_print_func");
    }
  }
#line 1550
  oldpf = opt->pf;
#line 1551
  opt->pf = pf;
#line 1553
  return (oldpf);
}
}
#line 1556 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_print_func_t cfg_set_print_func(cfg_t *cfg___0 , char const   *name , void (*pf)(cfg_opt_t *opt ,
                                                                                     unsigned int index ,
                                                                                     FILE *fp ) ) 
{ 
  cfg_opt_t *tmp ;
  cfg_print_func_t tmp___0 ;

  {
  {
#line 1559
  tmp = cfg_getopt(cfg___0, name);
#line 1559
  tmp___0 = cfg_opt_set_print_func(tmp, pf);
  }
#line 1559
  return (tmp___0);
}
}
#line 1562 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_opt_t *cfg_getopt_array(cfg_opt_t *rootopts , int cfg_flags , char const   *name ) 
{ 
  unsigned int i ;
  cfg_opt_t *opts ;
  cfg_t *seccfg ;
  char *secname ;
  size_t len ;
  size_t tmp ;
  cfg_opt_t *secopt ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1565
  opts = rootopts;
#line 1567
  if (rootopts) {
#line 1567
    if (! name) {
      {
#line 1567
      __assert_fail("rootopts && name", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1567U, "cfg_getopt_array");
      }
    }
  } else {
    {
#line 1567
    __assert_fail("rootopts && name", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1567U, "cfg_getopt_array");
    }
  }
  {
#line 1569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1569
    if (name) {
#line 1569
      if (! *name) {
#line 1569
        goto while_break;
      }
    } else {
#line 1569
      goto while_break;
    }
    {
#line 1573
    tmp = strcspn(name, "|");
#line 1573
    len = tmp;
    }
#line 1574
    if ((int const   )*(name + len) == 0) {
#line 1576
      goto while_break;
    }
#line 1577
    if (len) {
      {
#line 1580
      secname = strndup(name, len);
#line 1581
      secopt = cfg_getopt_array(opts, cfg_flags, (char const   *)secname);
#line 1582
      free((void *)secname);
      }
#line 1583
      if ((unsigned long )secopt == (unsigned long )((cfg_opt_t *)0)) {
#line 1586
        return ((cfg_opt_t *)0);
      }
#line 1588
      if ((unsigned int )secopt->type != 5U) {
#line 1591
        return ((cfg_opt_t *)0);
      }
#line 1594
      if (! ((1 & secopt->flags) == 1)) {
        {
#line 1594
        seccfg = cfg_opt_getnsec(secopt, 0U);
        }
#line 1594
        if ((unsigned long )seccfg != (unsigned long )((cfg_t *)0)) {
#line 1597
          opts = seccfg->opts;
        } else {
#line 1600
          opts = secopt->subopts;
        }
      } else {
#line 1600
        opts = secopt->subopts;
      }
#line 1601
      if ((unsigned long )opts == (unsigned long )((cfg_opt_t *)0)) {
#line 1604
        return ((cfg_opt_t *)0);
      }
    }
    {
#line 1607
    name += len;
#line 1608
    tmp___0 = strspn(name, "|");
#line 1608
    name += tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1611
  i = 0U;
  {
#line 1611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1611
    if (! (opts + i)->name) {
#line 1611
      goto while_break___0;
    }
#line 1613
    if ((4 & cfg_flags) == 4) {
      {
#line 1615
      tmp___1 = strcasecmp((char const   *)(opts + i)->name, name);
      }
#line 1615
      if (tmp___1 == 0) {
#line 1616
        return (opts + i);
      }
    } else {
      {
#line 1620
      tmp___2 = strcmp((char const   *)(opts + i)->name, name);
      }
#line 1620
      if (tmp___2 == 0) {
#line 1621
        return (opts + i);
      }
    }
#line 1611
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1624
  return ((cfg_opt_t *)0);
}
}
#line 1627 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
cfg_validate_callback_t cfg_set_validate_func(cfg_t *cfg___0 , char const   *name ,
                                              int (*vf)(cfg_t *cfg , cfg_opt_t *opt ) ) 
{ 
  cfg_opt_t *opt ;
  cfg_opt_t *tmp ;
  int (*oldvf)(cfg_t *cfg , cfg_opt_t *opt ) ;

  {
  {
#line 1631
  tmp = cfg_getopt_array(cfg___0->opts, cfg___0->flags, name);
#line 1631
  opt = tmp;
  }
#line 1633
  if (! opt) {
    {
#line 1633
    __assert_fail("opt", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1633U, "cfg_set_validate_func");
    }
  }
#line 1634
  oldvf = opt->validcb;
#line 1635
  opt->validcb = vf;
#line 1636
  return (oldvf);
}
}
#line 272 "lexer.c"
static size_t yy_buffer_stack_top___0  =    (size_t )0;
#line 273 "lexer.c"
static size_t yy_buffer_stack_max___0  =    (size_t )0;
#line 274 "lexer.c"
static YY_BUFFER_STATE *yy_buffer_stack___0  =    (YY_BUFFER_STATE *)0;
#line 292 "lexer.c"
static char yy_hold_char___0  ;
#line 293 "lexer.c"
static int yy_n_chars___0  ;
#line 297 "lexer.c"
static char *yy_c_buf_p___0  =    (char *)0;
#line 298 "lexer.c"
static int yy_init___0  =    0;
#line 299 "lexer.c"
static int yy_start___0  =    0;
#line 304 "lexer.c"
static int yy_did_buffer_switch_on_eof___0  ;
#line 314
static void cfg_yyensure_buffer_stack___0(void) ;
#line 315
static void cfg_yy_load_buffer_state___0(void) ;
#line 316
static void cfg_yy_init_buffer___0(YY_BUFFER_STATE b , FILE *file ) ;
#line 370
static yy_state_type yy_get_previous_state___0(void) ;
#line 371
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) ;
#line 372
static int yy_get_next_buffer___0(void) ;
#line 373
static void yy_fatal_error___0(char const   *msg ) ;
#line 394 "lexer.c"
static flex_int16_t const   yy_accept___0[85]  = 
#line 394
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )12, 
        (flex_int16_t const   )12,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )45,      (flex_int16_t const   )42,      (flex_int16_t const   )1, 
        (flex_int16_t const   )2,      (flex_int16_t const   )43,      (flex_int16_t const   )16,      (flex_int16_t const   )3, 
        (flex_int16_t const   )42,      (flex_int16_t const   )34,      (flex_int16_t const   )6,      (flex_int16_t const   )7, 
        (flex_int16_t const   )43,      (flex_int16_t const   )10,      (flex_int16_t const   )42,      (flex_int16_t const   )8, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )12,      (flex_int16_t const   )14, 
        (flex_int16_t const   )13,      (flex_int16_t const   )33,      (flex_int16_t const   )19,      (flex_int16_t const   )17, 
        (flex_int16_t const   )33,      (flex_int16_t const   )44,      (flex_int16_t const   )40,      (flex_int16_t const   )36, 
        (flex_int16_t const   )35,      (flex_int16_t const   )44,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )1,      (flex_int16_t const   )3,      (flex_int16_t const   )0,      (flex_int16_t const   )9, 
        (flex_int16_t const   )42,      (flex_int16_t const   )11,      (flex_int16_t const   )3,      (flex_int16_t const   )12, 
        (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )15,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )32,      (flex_int16_t const   )20,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )28,      (flex_int16_t const   )26,      (flex_int16_t const   )29, 
        (flex_int16_t const   )27,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )30, 
        (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )40,      (flex_int16_t const   )39, 
        (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )0,      (flex_int16_t const   )41, 
        (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )33,      (flex_int16_t const   )0, 
        (flex_int16_t const   )18,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )23, 
        (flex_int16_t const   )3,      (flex_int16_t const   )18,      (flex_int16_t const   )21,      (flex_int16_t const   )23, 
        (flex_int16_t const   )0};
#line 407 "lexer.c"
static flex_int32_t const   yy_ec___0[256]  = 
#line 407
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )7,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )14, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )17,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )18, 
        (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )19,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )18, 
        (flex_int32_t const   )18,      (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )24,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )25,      (flex_int32_t const   )1, 
        (flex_int32_t const   )26,      (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )1, 
        (flex_int32_t const   )28,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )29, 
        (flex_int32_t const   )1,      (flex_int32_t const   )30,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 439 "lexer.c"
static flex_int32_t const   yy_meta___0[31]  = 
#line 439
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )2,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )6, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )2,      (flex_int32_t const   )7,      (flex_int32_t const   )8, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )2};
#line 446 "lexer.c"
static flex_int16_t const   yy_base___0[102]  = 
#line 446
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )38, 
        (flex_int16_t const   )39,      (flex_int16_t const   )131,      (flex_int16_t const   )116,      (flex_int16_t const   )127, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )0, 
        (flex_int16_t const   )30,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )111,      (flex_int16_t const   )293,      (flex_int16_t const   )34,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )0,      (flex_int16_t const   )293, 
        (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )98,      (flex_int16_t const   )57,      (flex_int16_t const   )0,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )67,      (flex_int16_t const   )107,      (flex_int16_t const   )41, 
        (flex_int16_t const   )116,      (flex_int16_t const   )0,      (flex_int16_t const   )59,      (flex_int16_t const   )293, 
        (flex_int16_t const   )62,      (flex_int16_t const   )293,      (flex_int16_t const   )86,      (flex_int16_t const   )0, 
        (flex_int16_t const   )42,      (flex_int16_t const   )50,      (flex_int16_t const   )293,      (flex_int16_t const   )0, 
        (flex_int16_t const   )114,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )47, 
        (flex_int16_t const   )50,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )44,      (flex_int16_t const   )293, 
        (flex_int16_t const   )144,      (flex_int16_t const   )0,      (flex_int16_t const   )117,      (flex_int16_t const   )41, 
        (flex_int16_t const   )0,      (flex_int16_t const   )52,      (flex_int16_t const   )108,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )293,      (flex_int16_t const   )110,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )174,      (flex_int16_t const   )182,      (flex_int16_t const   )190, 
        (flex_int16_t const   )198,      (flex_int16_t const   )206,      (flex_int16_t const   )214,      (flex_int16_t const   )222, 
        (flex_int16_t const   )230,      (flex_int16_t const   )238,      (flex_int16_t const   )245,      (flex_int16_t const   )253, 
        (flex_int16_t const   )260,      (flex_int16_t const   )268,      (flex_int16_t const   )276,      (flex_int16_t const   )62, 
        (flex_int16_t const   )284,      (flex_int16_t const   )36};
#line 462 "lexer.c"
static flex_int16_t const   yy_def___0[102]  = 
#line 462
  {      (flex_int16_t const   )0,      (flex_int16_t const   )84,      (flex_int16_t const   )1,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )84,      (flex_int16_t const   )88,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )89, 
        (flex_int16_t const   )88,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )90,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )91,      (flex_int16_t const   )84, 
        (flex_int16_t const   )92,      (flex_int16_t const   )93,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )96,      (flex_int16_t const   )88,      (flex_int16_t const   )90, 
        (flex_int16_t const   )84,      (flex_int16_t const   )89,      (flex_int16_t const   )97,      (flex_int16_t const   )84, 
        (flex_int16_t const   )88,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )91, 
        (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )84,      (flex_int16_t const   )93, 
        (flex_int16_t const   )98,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )99,      (flex_int16_t const   )95,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )97,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )46,      (flex_int16_t const   )98,      (flex_int16_t const   )100, 
        (flex_int16_t const   )93,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )101, 
        (flex_int16_t const   )72,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )0,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84};
#line 478 "lexer.c"
static flex_int16_t const   yy_nxt___0[324]  = 
#line 478
  {      (flex_int16_t const   )0,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )12, 
        (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )17,      (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )13, 
        (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )23,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )30,      (flex_int16_t const   )30,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )28, 
        (flex_int16_t const   )28,      (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )83, 
        (flex_int16_t const   )39,      (flex_int16_t const   )45,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )46,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )49, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )50,      (flex_int16_t const   )39, 
        (flex_int16_t const   )84,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )42, 
        (flex_int16_t const   )54,      (flex_int16_t const   )49,      (flex_int16_t const   )77,      (flex_int16_t const   )78, 
        (flex_int16_t const   )50,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )82, 
        (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )68,      (flex_int16_t const   )81, 
        (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )71,      (flex_int16_t const   )69, 
        (flex_int16_t const   )39,      (flex_int16_t const   )57,      (flex_int16_t const   )58,      (flex_int16_t const   )59, 
        (flex_int16_t const   )60,      (flex_int16_t const   )61,      (flex_int16_t const   )62,      (flex_int16_t const   )63, 
        (flex_int16_t const   )64,      (flex_int16_t const   )65,      (flex_int16_t const   )69,      (flex_int16_t const   )72, 
        (flex_int16_t const   )41,      (flex_int16_t const   )71,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )72,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )41, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )75,      (flex_int16_t const   )40,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )39,      (flex_int16_t const   )75,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )52, 
        (flex_int16_t const   )43,      (flex_int16_t const   )40,      (flex_int16_t const   )39,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )75,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )75,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )76,      (flex_int16_t const   )80,      (flex_int16_t const   )41,      (flex_int16_t const   )76, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )80, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )73,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )41,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )38, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )84,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )44, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )47, 
        (flex_int16_t const   )47,      (flex_int16_t const   )84,      (flex_int16_t const   )47,      (flex_int16_t const   )47, 
        (flex_int16_t const   )84,      (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )84,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )51, 
        (flex_int16_t const   )51,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )51, 
        (flex_int16_t const   )51,      (flex_int16_t const   )51,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )66,      (flex_int16_t const   )66, 
        (flex_int16_t const   )84,      (flex_int16_t const   )66,      (flex_int16_t const   )84,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70, 
        (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70, 
        (flex_int16_t const   )70,      (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )9,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84};
#line 518 "lexer.c"
static flex_int16_t const   yy_chk___0[324]  = 
#line 518
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )5, 
        (flex_int16_t const   )6,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )101, 
        (flex_int16_t const   )16,      (flex_int16_t const   )22,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )22,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )28, 
        (flex_int16_t const   )39,      (flex_int16_t const   )48,      (flex_int16_t const   )28,      (flex_int16_t const   )39, 
        (flex_int16_t const   )48,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )16, 
        (flex_int16_t const   )33,      (flex_int16_t const   )49,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )49,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )99,      (flex_int16_t const   )37,      (flex_int16_t const   )75, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )70,      (flex_int16_t const   )37, 
        (flex_int16_t const   )44,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )37,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )52,      (flex_int16_t const   )40,      (flex_int16_t const   )52, 
        (flex_int16_t const   )74,      (flex_int16_t const   )38,      (flex_int16_t const   )74,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )32, 
        (flex_int16_t const   )20,      (flex_int16_t const   )11,      (flex_int16_t const   )10,      (flex_int16_t const   )9, 
        (flex_int16_t const   )0,      (flex_int16_t const   )52,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )74,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )52,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )74, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )86, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )88, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )89, 
        (flex_int16_t const   )89,      (flex_int16_t const   )0,      (flex_int16_t const   )89,      (flex_int16_t const   )89, 
        (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )90, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )91, 
        (flex_int16_t const   )91,      (flex_int16_t const   )0,      (flex_int16_t const   )91,      (flex_int16_t const   )91, 
        (flex_int16_t const   )0,      (flex_int16_t const   )91,      (flex_int16_t const   )91,      (flex_int16_t const   )92, 
        (flex_int16_t const   )92,      (flex_int16_t const   )0,      (flex_int16_t const   )92,      (flex_int16_t const   )92, 
        (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )94, 
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94, 
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )95, 
        (flex_int16_t const   )0,      (flex_int16_t const   )95,      (flex_int16_t const   )0,      (flex_int16_t const   )95, 
        (flex_int16_t const   )95,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96, 
        (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96, 
        (flex_int16_t const   )96,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )97,      (flex_int16_t const   )98,      (flex_int16_t const   )98,      (flex_int16_t const   )98, 
        (flex_int16_t const   )98,      (flex_int16_t const   )98,      (flex_int16_t const   )98,      (flex_int16_t const   )98, 
        (flex_int16_t const   )98,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84};
#line 558 "lexer.c"
static yy_state_type yy_last_accepting_state___0  ;
#line 559 "lexer.c"
static char *yy_last_accepting_cpos___0  ;
#line 53 "lexer.l"
static unsigned int qstring_index___0  =    0U;
#line 54 "lexer.l"
static unsigned int qstring_len___0  =    0U;
#line 55
static void qputc___0(char ch ) ;
#line 66 "lexer.l"
static YY_BUFFER_STATE pre_string_scan_state___0  =    (YY_BUFFER_STATE )0;
#line 67 "lexer.l"
static YY_BUFFER_STATE string_scan_state___0  =    (YY_BUFFER_STATE )0;
#line 665 "lexer.c"
static int yy_init_globals___0(void) ;
#line 708
static void yyunput___0(int c , char *yy_bp ) ;
#line 1433 "lexer.c"
static int yy_get_next_buffer___0(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;

  {
#line 1435
  dest = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf;
#line 1436
  source = cfg_yytext;
#line 1440
  if ((unsigned long )yy_c_buf_p___0 > (unsigned long )((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + (yy_n_chars___0 + 1))) {
    {
#line 1441
    yy_fatal_error___0("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1444
  if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_fill_buffer == 0) {
#line 1446
    if (yy_c_buf_p___0 - cfg_yytext == 1L) {
#line 1451
      return (1);
    } else {
#line 1459
      return (2);
    }
  }
#line 1466
  number_to_move = (int )(yy_c_buf_p___0 - cfg_yytext) - 1;
#line 1468
  i = 0;
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1468
    if (! (i < number_to_move)) {
#line 1468
      goto while_break;
    }
#line 1469
    tmp = dest;
#line 1469
    dest ++;
#line 1469
    tmp___0 = source;
#line 1469
    source ++;
#line 1469
    *tmp = *tmp___0;
#line 1468
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1471
  if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status == 2) {
#line 1475
    yy_n_chars___0 = 0;
#line 1475
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  } else {
#line 1479
    num_to_read = (int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1482
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1482
      if (! (num_to_read <= 0)) {
#line 1482
        goto while_break___0;
      }
#line 1486
      if (yy_buffer_stack___0) {
#line 1486
        tmp___1 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
      } else {
#line 1486
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1486
      b = tmp___1;
#line 1488
      yy_c_buf_p_offset = (int )(yy_c_buf_p___0 - b->yy_ch_buf);
#line 1491
      if (b->yy_is_our_buffer) {
#line 1493
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1495
        if (new_size <= 0) {
#line 1496
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1498
          b->yy_buf_size *= 2UL;
        }
        {
#line 1500
        tmp___2 = cfg_yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1500
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1506
        b->yy_ch_buf = (char *)0;
      }
#line 1508
      if (! b->yy_ch_buf) {
        {
#line 1509
        yy_fatal_error___0("fatal error - scanner input buffer overflow");
        }
      }
#line 1512
      yy_c_buf_p___0 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1514
      num_to_read = (int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1519
    if (num_to_read > 8192) {
#line 1520
      num_to_read = 8192;
    }
#line 1523
    if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_is_interactive) {
#line 1523
      c = '*';
#line 1523
      n = 0;
      {
#line 1523
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1523
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 1523
          c = _IO_getc(cfg_yyin);
          }
#line 1523
          if (c != -1) {
#line 1523
            if (! (c != 10)) {
#line 1523
              goto while_break___1;
            }
          } else {
#line 1523
            goto while_break___1;
          }
        } else {
#line 1523
          goto while_break___1;
        }
#line 1523
        *(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1523
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1523
      if (c == 10) {
#line 1523
        tmp___3 = n;
#line 1523
        n ++;
#line 1523
        *(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1523
      if (c == -1) {
        {
#line 1523
        tmp___4 = ferror(cfg_yyin);
        }
#line 1523
        if (tmp___4) {
          {
#line 1523
          yy_fatal_error___0("input in flex scanner failed");
          }
        }
      }
#line 1523
      yy_n_chars___0 = n;
    } else {
      {
#line 1523
      tmp___5 = __errno_location();
#line 1523
      *tmp___5 = 0;
      }
      {
#line 1523
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1523
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)cfg_yyin);
#line 1523
        yy_n_chars___0 = (int )tmp___8;
        }
#line 1523
        if (yy_n_chars___0 == 0) {
          {
#line 1523
          tmp___9 = ferror(cfg_yyin);
          }
#line 1523
          if (! tmp___9) {
#line 1523
            goto while_break___2;
          }
        } else {
#line 1523
          goto while_break___2;
        }
        {
#line 1523
        tmp___6 = __errno_location();
        }
#line 1523
        if (*tmp___6 != 4) {
          {
#line 1523
          yy_fatal_error___0("input in flex scanner failed");
          }
#line 1523
          goto while_break___2;
        }
        {
#line 1523
        tmp___7 = __errno_location();
#line 1523
        *tmp___7 = 0;
#line 1523
        clearerr(cfg_yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1526
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  }
#line 1529
  if (yy_n_chars___0 == 0) {
#line 1531
    if (number_to_move == 0) {
      {
#line 1533
      ret_val = 1;
#line 1534
      cfg_yyrestart(cfg_yyin);
      }
    } else {
#line 1539
      ret_val = 2;
#line 1540
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status = 2;
    }
  } else {
#line 1546
    ret_val = 0;
  }
#line 1548
  if ((yy_size_t )(yy_n_chars___0 + number_to_move) > (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size) {
    {
#line 1550
    new_size___0 = (yy_size_t )((yy_n_chars___0 + number_to_move) + (yy_n_chars___0 >> 1));
#line 1551
    tmp___10 = cfg_yyrealloc((void *)(*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf,
                             new_size___0);
#line 1551
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf = (char *)tmp___10;
    }
#line 1552
    if (! (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf) {
      {
#line 1553
      yy_fatal_error___0("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1556
  yy_n_chars___0 += number_to_move;
#line 1557
  *((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0) = (char)0;
#line 1558
  *((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + (yy_n_chars___0 + 1)) = (char)0;
#line 1560
  cfg_yytext = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + 0;
#line 1562
  return (ret_val);
}
}
#line 1567 "lexer.c"
static yy_state_type yy_get_previous_state___0(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1572
  yy_current_state = yy_start___0;
#line 1574
  yy_cp = cfg_yytext + 0;
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p___0)) {
#line 1574
      goto while_break;
    }
#line 1576
    if (*yy_cp) {
#line 1576
      tmp = yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1576
      tmp = (flex_int32_t const   )1;
    }
#line 1576
    yy_c = (YY_CHAR )tmp;
#line 1577
    if (yy_accept___0[yy_current_state]) {
#line 1579
      yy_last_accepting_state___0 = yy_current_state;
#line 1580
      yy_last_accepting_cpos___0 = yy_cp;
    }
    {
#line 1582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1582
      if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1582
        goto while_break___0;
      }
#line 1584
      yy_current_state = (int )yy_def___0[yy_current_state];
#line 1585
      if (yy_current_state >= 85) {
#line 1586
        yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1588
    yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1574
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1591
  return (yy_current_state);
}
}
#line 1599 "lexer.c"
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1602
  yy_cp = yy_c_buf_p___0;
#line 1604
  yy_c = (YY_CHAR )1;
#line 1605
  if (yy_accept___0[yy_current_state]) {
#line 1607
    yy_last_accepting_state___0 = yy_current_state;
#line 1608
    yy_last_accepting_cpos___0 = yy_cp;
  }
  {
#line 1610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1610
    if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1610
      goto while_break;
    }
#line 1612
    yy_current_state = (int )yy_def___0[yy_current_state];
#line 1613
    if (yy_current_state >= 85) {
#line 1614
      yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1616
  yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1617
  yy_is_jam = yy_current_state == 84;
#line 1619
  if (yy_is_jam) {
#line 1619
    tmp = 0;
  } else {
#line 1619
    tmp = yy_current_state;
  }
#line 1619
  return (tmp);
}
}
#line 1622 "lexer.c"
static void yyunput___0(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register int number_to_move ;
  register char *dest ;
  register char *source ;

  {
#line 1626
  yy_cp = yy_c_buf_p___0;
#line 1629
  *yy_cp = yy_hold_char___0;
#line 1631
  if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + 2)) {
#line 1634
    number_to_move = yy_n_chars___0 + 2;
#line 1635
    dest = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size + 2UL);
#line 1637
    source = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move;
    {
#line 1640
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1640
      if (! ((unsigned long )source > (unsigned long )(*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf)) {
#line 1640
        goto while_break;
      }
#line 1641
      dest --;
#line 1641
      source --;
#line 1641
      *dest = *source;
    }
    while_break: /* CIL Label */ ;
    }
#line 1643
    yy_cp += (int )(dest - source);
#line 1644
    yy_bp += (int )(dest - source);
#line 1645
    yy_n_chars___0 = (int )(*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size;
#line 1645
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
#line 1648
    if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + 2)) {
      {
#line 1649
      yy_fatal_error___0("flex scanner push-back overflow");
      }
    }
  }
#line 1652
  yy_cp --;
#line 1652
  *yy_cp = (char )c;
#line 1654
  cfg_yytext = yy_bp;
#line 1655
  yy_hold_char___0 = *yy_cp;
#line 1656
  yy_c_buf_p___0 = yy_cp;
#line 1657
  return;
}
}
#line 1786 "lexer.c"
static void cfg_yy_load_buffer_state___0(void) 
{ 


  {
#line 1788
  yy_n_chars___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars;
#line 1789
  yy_c_buf_p___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos;
#line 1789
  cfg_yytext = yy_c_buf_p___0;
#line 1790
  cfg_yyin = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_input_file;
#line 1791
  yy_hold_char___0 = *yy_c_buf_p___0;
#line 1792
  return;
}
}
#line 1861 "lexer.c"
static void cfg_yy_init_buffer___0(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1864
  tmp = __errno_location();
#line 1864
  oerrno = *tmp;
#line 1866
  cfg_yy_flush_buffer(b);
#line 1868
  b->yy_input_file = file;
#line 1869
  b->yy_fill_buffer = 1;
  }
#line 1875
  if (yy_buffer_stack___0) {
#line 1875
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1875
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1875
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1876
    b->yy_bs_lineno = 1;
#line 1877
    b->yy_bs_column = 0;
  }
#line 1880
  if (file) {
    {
#line 1880
    tmp___1 = fileno(file);
#line 1880
    tmp___2 = isatty(tmp___1);
#line 1880
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1880
    b->yy_is_interactive = 0;
  }
  {
#line 1882
  tmp___3 = __errno_location();
#line 1882
  *tmp___3 = oerrno;
  }
#line 1883
  return;
}
}
#line 1967 "lexer.c"
static void cfg_yyensure_buffer_stack___0(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1971
  if (! yy_buffer_stack___0) {
    {
#line 1977
    num_to_alloc = 1;
#line 1978
    tmp = cfg_yyalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1978
    yy_buffer_stack___0 = (struct yy_buffer_state **)tmp;
    }
#line 1981
    if (! yy_buffer_stack___0) {
      {
#line 1982
      yy_fatal_error___0("out of dynamic memory in cfg_yyensure_buffer_stack()");
      }
    }
    {
#line 1984
    memset((void *)yy_buffer_stack___0, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1986
    yy_buffer_stack_max___0 = (size_t )num_to_alloc;
#line 1987
    yy_buffer_stack_top___0 = (size_t )0;
    }
#line 1988
    return;
  }
#line 1991
  if (yy_buffer_stack_top___0 >= yy_buffer_stack_max___0 - 1UL) {
    {
#line 1994
    grow_size = 8;
#line 1996
    num_to_alloc = (int )(yy_buffer_stack_max___0 + (size_t )grow_size);
#line 1997
    tmp___0 = cfg_yyrealloc((void *)yy_buffer_stack___0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1997
    yy_buffer_stack___0 = (struct yy_buffer_state **)tmp___0;
    }
#line 2001
    if (! yy_buffer_stack___0) {
      {
#line 2002
      yy_fatal_error___0("out of dynamic memory in cfg_yyensure_buffer_stack()");
      }
    }
    {
#line 2005
    memset((void *)(yy_buffer_stack___0 + yy_buffer_stack_max___0), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2006
    yy_buffer_stack_max___0 = (size_t )num_to_alloc;
    }
  }
#line 2008
  return;
}
}
#line 2100 "lexer.c"
static void yy_fatal_error___0(char const   *msg ) 
{ 


  {
  {
#line 2102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2103
  exit(2);
  }
}
}
#line 2203 "lexer.c"
static int yy_init_globals___0(void) 
{ 


  {
#line 2209
  yy_buffer_stack___0 = (YY_BUFFER_STATE *)0;
#line 2210
  yy_buffer_stack_top___0 = (size_t )0;
#line 2211
  yy_buffer_stack_max___0 = (size_t )0;
#line 2212
  yy_c_buf_p___0 = (char *)0;
#line 2213
  yy_init___0 = 0;
#line 2214
  yy_start___0 = 0;
#line 2221
  cfg_yyin = (FILE *)0;
#line 2222
  cfg_yyout = (FILE *)0;
#line 2228
  return (0);
}
}
#line 322 "lexer.l"
static void qputc___0(char ch ) 
{ 
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 324
  if (qstring_index___0 >= qstring_len___0) {
    {
#line 325
    qstring_len___0 += 32U;
#line 326
    tmp = realloc((void *)cfg_qstring, (size_t )qstring_len___0);
#line 326
    cfg_qstring = (char *)tmp;
    }
#line 327
    if (! cfg_qstring) {
      {
#line 327
      __assert_fail("cfg_qstring", "lexer.l", 327U, "qputc");
      }
    }
    {
#line 328
    memset((void *)(cfg_qstring + qstring_index___0), 0, (size_t )32);
    }
  }
#line 330
  tmp___0 = qstring_index___0;
#line 330
  qstring_index___0 ++;
#line 330
  *(cfg_qstring + tmp___0) = ch;
#line 331
  return;
}
}
#line 355 "lexer.l"
static YY_BUFFER_STATE pre_fp_scan_state___0  ;
#line 356 "lexer.l"
static YY_BUFFER_STATE fp_scan_state___0  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static int cfg_parse_internal___0(cfg_t *cfg___0 , int level , int force_state , cfg_opt_t *force_opt ) ;
#line 366 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_value_t *cfg_addval___0(cfg_opt_t *opt ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 368
  tmp = realloc((void *)opt->values, (unsigned long )(opt->nvalues + 1U) * sizeof(cfg_value_t *));
#line 368
  opt->values = (cfg_value_t **)tmp;
  }
#line 370
  if (! opt->values) {
    {
#line 370
    __assert_fail("opt->values", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  370U, "cfg_addval");
    }
  }
  {
#line 371
  tmp___0 = malloc(sizeof(cfg_value_t ));
#line 371
  *(opt->values + opt->nvalues) = (cfg_value_t *)tmp___0;
#line 372
  memset((void *)*(opt->values + opt->nvalues), 0, sizeof(cfg_value_t ));
#line 373
  tmp___1 = opt->nvalues;
#line 373
  (opt->nvalues) ++;
  }
#line 373
  return (*(opt->values + tmp___1));
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_opt_t *cfg_dupopt_array___0(cfg_opt_t *opts ) 
{ 
  int i ;
  cfg_opt_t *dupopts ;
  int n ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 389
  tmp = cfg_numopts(opts);
#line 389
  n = tmp;
#line 391
  tmp___0 = calloc((size_t )(n + 1), sizeof(cfg_opt_t ));
#line 391
  dupopts = (cfg_opt_t *)tmp___0;
#line 392
  memcpy((void */* __restrict  */)dupopts, (void const   */* __restrict  */)opts,
         (unsigned long )n * sizeof(cfg_opt_t ));
#line 394
  i = 0;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i < n)) {
#line 394
      goto while_break;
    }
    {
#line 396
    (dupopts + i)->name = strdup((char const   *)(opts + i)->name);
    }
#line 397
    if ((unsigned int )(opts + i)->type == 5U) {
#line 397
      if ((opts + i)->subopts) {
        {
#line 398
        (dupopts + i)->subopts = cfg_dupopt_array___0((opts + i)->subopts);
        }
      }
    }
#line 400
    if ((2 & (opts + i)->flags) == 2) {
#line 400
      goto _L;
    } else
#line 400
    if ((unsigned int )(opts + i)->type == 6U) {
      _L: /* CIL Label */ 
#line 401
      if ((opts + i)->def.parsed) {
        {
#line 401
        tmp___1 = strdup((char const   *)(opts + i)->def.parsed);
#line 401
        (dupopts + i)->def.parsed = tmp___1;
        }
      } else {
#line 401
        (dupopts + i)->def.parsed = (char *)0;
      }
    } else
#line 402
    if ((unsigned int )(opts + i)->type == 3U) {
#line 403
      if ((opts + i)->def.string) {
        {
#line 403
        tmp___2 = strdup((char const   *)(opts + i)->def.string);
#line 403
        (dupopts + i)->def.string = tmp___2;
        }
      } else {
#line 403
        (dupopts + i)->def.string = (char *)0;
      }
    }
#line 394
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return (dupopts);
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_init_defaults___0(cfg_t *cfg___0 ) 
{ 
  int i ;
  int xstate ;
  int ret ;

  {
#line 426
  i = 0;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! (cfg___0->opts + i)->name) {
#line 426
      goto while_break;
    }
#line 429
    if ((cfg___0->opts + i)->simple_value) {
#line 430
      goto __Cont;
    } else
#line 429
    if ((16 & (cfg___0->opts + i)->flags) == 16) {
#line 430
      goto __Cont;
    }
#line 432
    if ((unsigned int )(cfg___0->opts + i)->type != 5U) {
#line 434
      (cfg___0->opts + i)->flags |= 128;
#line 436
      if ((2 & (cfg___0->opts + i)->flags) == 2) {
#line 436
        goto _L;
      } else
#line 436
      if ((cfg___0->opts + i)->def.parsed) {
        _L: /* CIL Label */ 
#line 444
        if ((unsigned long )(cfg___0->opts + i)->def.parsed == (unsigned long )((char *)0)) {
#line 446
          goto __Cont;
        } else
#line 444
        if ((int )*((cfg___0->opts + i)->def.parsed + 0) == 0) {
#line 446
          goto __Cont;
        }
#line 452
        if ((2 & (cfg___0->opts + i)->flags) == 2) {
#line 454
          xstate = 3;
        } else
#line 455
        if ((unsigned int )(cfg___0->opts + i)->type == 6U) {
#line 456
          xstate = 0;
        } else {
#line 458
          xstate = 2;
        }
        {
#line 460
        cfg_scan_string_begin((char const   *)(cfg___0->opts + i)->def.parsed);
        }
        {
#line 461
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 463
          ret = cfg_parse_internal___0(cfg___0, 1, xstate, cfg___0->opts + i);
#line 464
          xstate = -1;
          }
#line 461
          if (! (ret == 0)) {
#line 461
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 466
        cfg_scan_string_end();
        }
#line 467
        if (ret == 1) {
          {
#line 476
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parse error in default value \'%s\' for option \'%s\'\n",
                  (cfg___0->opts + i)->def.parsed, (cfg___0->opts + i)->name);
#line 479
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Check your initialization macros and the libConfuse documentation\n");
#line 481
          abort();
          }
        }
      } else {
        {
#line 488
        if ((unsigned int )(cfg___0->opts + i)->type == 1U) {
#line 488
          goto case_1;
        }
#line 492
        if ((unsigned int )(cfg___0->opts + i)->type == 2U) {
#line 492
          goto case_2;
        }
#line 496
        if ((unsigned int )(cfg___0->opts + i)->type == 4U) {
#line 496
          goto case_4;
        }
#line 500
        if ((unsigned int )(cfg___0->opts + i)->type == 3U) {
#line 500
          goto case_3;
        }
#line 505
        if ((unsigned int )(cfg___0->opts + i)->type == 7U) {
#line 505
          goto case_7;
        }
#line 505
        if ((unsigned int )(cfg___0->opts + i)->type == 6U) {
#line 505
          goto case_7;
        }
#line 507
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 489
        cfg_opt_setnint(cfg___0->opts + i, (cfg___0->opts + i)->def.number, 0U);
        }
#line 491
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 493
        cfg_opt_setnfloat(cfg___0->opts + i, (cfg___0->opts + i)->def.fpnumber, 0U);
        }
#line 495
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 497
        cfg_opt_setnbool(cfg___0->opts + i, (cfg___0->opts + i)->def.boolean, 0U);
        }
#line 499
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 501
        cfg_opt_setnstr(cfg___0->opts + i, (char const   *)(cfg___0->opts + i)->def.string,
                        0U);
        }
#line 503
        goto switch_break;
        case_7: /* CIL Label */ 
        case_6: /* CIL Label */ 
#line 506
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 508
        cfg_error(cfg___0, "internal error in cfg_init_defaults(%s)", (cfg___0->opts + i)->name);
        }
#line 511
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 520
      (cfg___0->opts + i)->flags |= 64;
    } else
#line 522
    if (! ((1 & (cfg___0->opts + i)->flags) == 1)) {
      {
#line 524
      cfg_setopt(cfg___0, cfg___0->opts + i, (char *)0);
#line 525
      (cfg___0->opts + i)->flags |= 128;
      }
    }
    __Cont: /* CIL Label */ 
#line 426
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  return;
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static int call_function___0(cfg_t *cfg___0 , cfg_opt_t *opt , cfg_opt_t *funcopt ) 
{ 
  int ret ;
  char const   **argv ;
  unsigned int i ;
  void *tmp ;

  {
  {
#line 760
  tmp = calloc((size_t )funcopt->nvalues, sizeof(char *));
#line 760
  argv = (char const   **)tmp;
#line 761
  i = 0U;
  }
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 761
    if (! (i < funcopt->nvalues)) {
#line 761
      goto while_break;
    }
#line 762
    *(argv + i) = (char const   *)(*(funcopt->values + i))->string;
#line 761
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 763
  ret = (*(opt->func))(cfg___0, opt, (int )funcopt->nvalues, argv);
#line 764
  cfg_free_value(funcopt);
#line 765
  free((void *)argv);
  }
#line 766
  return (ret);
}
}
#line 769 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static int cfg_parse_internal___0(cfg_t *cfg___0 , int level , int force_state , cfg_opt_t *force_opt ) 
{ 
  int state ;
  char *opttitle ;
  cfg_opt_t *opt ;
  cfg_value_t *val ;
  cfg_opt_t funcopt ;
  int num_values ;
  int rc ;
  int tok ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  cfg_value_t *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  cfg_value_t *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int ret ;
  int tmp___17 ;
  char *tmp___18 ;
  int ret___0 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
#line 772
  state = 0;
#line 773
  opttitle = (char *)0;
#line 774
  opt = (cfg_opt_t *)0;
#line 775
  val = (cfg_value_t *)0;
#line 776
  funcopt.name = (char *)0;
#line 776
  funcopt.type = (cfg_type_t )3;
#line 776
  funcopt.nvalues = 0U;
#line 776
  funcopt.values = (cfg_value_t **)0;
#line 776
  funcopt.flags = 0;
#line 776
  funcopt.subopts = (cfg_opt_t *)0;
#line 776
  funcopt.def.number = 0L;
#line 776
  funcopt.def.fpnumber = (double )0;
#line 776
  funcopt.def.boolean = (cfg_bool_t )0;
#line 776
  funcopt.def.string = (char *)0;
#line 776
  funcopt.def.parsed = (char *)0;
#line 776
  funcopt.func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 776
  funcopt.simple_value = (void *)0;
#line 776
  funcopt.parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 776
  funcopt.validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 776
  funcopt.pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 776
  funcopt.freecb = (void (*)(void *value ))0;
#line 777
  num_values = 0;
#line 780
  if (force_state != -1) {
#line 781
    state = force_state;
  }
#line 782
  if (force_opt) {
#line 783
    opt = force_opt;
  }
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 787
    tmp = cfg_yylex(cfg___0);
#line 787
    tok = tmp;
    }
#line 789
    if (tok == 0) {
#line 792
      return (1);
    }
#line 795
    if (tok == -1) {
#line 797
      if (state != 0) {
        {
#line 799
        tmp___0 = dgettext("confuse", "premature end of file");
#line 799
        cfg_error(cfg___0, (char const   *)tmp___0);
        }
#line 800
        return (1);
      }
#line 802
      return (-1);
    }
    {
#line 807
    if (state == 0) {
#line 807
      goto case_0;
    }
#line 840
    if (state == 1) {
#line 840
      goto case_1;
    }
#line 876
    if (state == 2) {
#line 876
      goto case_2;
    }
#line 906
    if (state == 3) {
#line 906
      goto case_3;
    }
#line 926
    if (state == 4) {
#line 926
      goto case_4;
    }
#line 943
    if (state == 5) {
#line 943
      goto case_5;
    }
#line 967
    if (state == 6) {
#line 967
      goto case_6;
    }
#line 979
    if (state == 7) {
#line 979
      goto case_7;
    }
#line 989
    if (state == 8) {
#line 989
      goto case_8;
    }
#line 1011
    if (state == 9) {
#line 1011
      goto case_9;
    }
#line 1029
    goto switch_default;
    case_0: /* CIL Label */ 
#line 808
    if (tok == 125) {
#line 810
      if (level == 0) {
        {
#line 812
        tmp___1 = dgettext("confuse", "unexpected closing brace");
#line 812
        cfg_error(cfg___0, (char const   *)tmp___1);
        }
#line 813
        return (1);
      }
#line 815
      return (-1);
    }
#line 817
    if (tok != 3) {
      {
#line 819
      tmp___2 = dgettext("confuse", "unexpected token \'%s\'");
#line 819
      cfg_error(cfg___0, (char const   *)tmp___2, cfg_yylval);
      }
#line 820
      return (1);
    }
    {
#line 822
    opt = cfg_getopt(cfg___0, (char const   *)cfg_yylval);
    }
#line 823
    if ((unsigned long )opt == (unsigned long )((cfg_opt_t *)0)) {
#line 824
      return (1);
    }
#line 825
    if ((unsigned int )opt->type == 5U) {
#line 827
      if ((8 & opt->flags) == 8) {
#line 828
        state = 6;
      } else {
#line 830
        state = 5;
      }
    } else
#line 832
    if ((unsigned int )opt->type == 6U) {
#line 834
      state = 7;
    } else {
#line 837
      state = 1;
    }
#line 838
    goto switch_break;
    case_1: /* CIL Label */ 
#line 841
    if (tok == 43) {
#line 843
      if (! ((2 & opt->flags) == 2)) {
        {
#line 845
        tmp___3 = dgettext("confuse", "attempt to append to non-list option \'%s\'");
#line 845
        cfg_error(cfg___0, (char const   *)tmp___3, opt->name);
        }
#line 848
        return (1);
      }
#line 854
      opt->flags &= -65;
    } else
#line 856
    if (tok == 61) {
#line 860
      opt->flags |= 64;
    } else {
      {
#line 864
      tmp___4 = dgettext("confuse", "missing equal sign after option \'%s\'");
#line 864
      cfg_error(cfg___0, (char const   *)tmp___4, opt->name);
      }
#line 866
      return (1);
    }
#line 868
    if ((2 & opt->flags) == 2) {
#line 870
      state = 3;
#line 871
      num_values = 0;
    } else {
#line 873
      state = 2;
    }
#line 874
    goto switch_break;
    case_2: /* CIL Label */ 
#line 877
    if (tok == 125) {
#line 877
      if ((2 & opt->flags) == 2) {
#line 879
        state = 0;
#line 880
        if (num_values == 0) {
#line 880
          if ((64 & opt->flags) == 64) {
            {
#line 883
            cfg_free_value(opt);
            }
          }
        }
#line 884
        goto switch_break;
      }
    }
#line 887
    if (tok != 3) {
      {
#line 889
      tmp___5 = dgettext("confuse", "unexpected token \'%s\'");
#line 889
      cfg_error(cfg___0, (char const   *)tmp___5, cfg_yylval);
      }
#line 890
      return (1);
    }
    {
#line 893
    tmp___6 = cfg_setopt(cfg___0, opt, cfg_yylval);
    }
#line 893
    if ((unsigned long )tmp___6 == (unsigned long )((cfg_value_t *)0)) {
#line 894
      return (1);
    }
#line 895
    if (opt->validcb) {
      {
#line 895
      tmp___7 = (*(opt->validcb))(cfg___0, opt);
      }
#line 895
      if (tmp___7 != 0) {
#line 896
        return (1);
      }
    }
#line 897
    if ((2 & opt->flags) == 2) {
#line 899
      num_values ++;
#line 900
      state = 4;
    } else {
#line 903
      state = 0;
    }
#line 904
    goto switch_break;
    case_3: /* CIL Label */ 
#line 907
    if (tok != 123) {
#line 909
      if (tok != 3) {
        {
#line 911
        tmp___8 = dgettext("confuse", "unexpected token \'%s\'");
#line 911
        cfg_error(cfg___0, (char const   *)tmp___8, cfg_yylval);
        }
#line 912
        return (1);
      }
      {
#line 915
      tmp___9 = cfg_setopt(cfg___0, opt, cfg_yylval);
      }
#line 915
      if ((unsigned long )tmp___9 == (unsigned long )((cfg_value_t *)0)) {
#line 916
        return (1);
      }
#line 917
      if (opt->validcb) {
        {
#line 917
        tmp___10 = (*(opt->validcb))(cfg___0, opt);
        }
#line 917
        if (tmp___10 != 0) {
#line 918
          return (1);
        }
      }
#line 919
      num_values ++;
#line 920
      state = 0;
    } else {
#line 923
      state = 2;
    }
#line 924
    goto switch_break;
    case_4: /* CIL Label */ 
#line 928
    if (tok == 44) {
#line 929
      state = 2;
    } else
#line 930
    if (tok == 125) {
#line 932
      state = 0;
#line 933
      if (opt->validcb) {
        {
#line 933
        tmp___11 = (*(opt->validcb))(cfg___0, opt);
        }
#line 933
        if (tmp___11 != 0) {
#line 934
          return (1);
        }
      }
    } else {
      {
#line 938
      tmp___12 = dgettext("confuse", "unexpected token \'%s\'");
#line 938
      cfg_error(cfg___0, (char const   *)tmp___12, cfg_yylval);
      }
#line 939
      return (1);
    }
#line 941
    goto switch_break;
    case_5: /* CIL Label */ 
#line 944
    if (tok != 123) {
      {
#line 946
      tmp___13 = dgettext("confuse", "missing opening brace for section \'%s\'");
#line 946
      cfg_error(cfg___0, (char const   *)tmp___13, opt->name);
      }
#line 948
      return (1);
    }
    {
#line 951
    val = cfg_setopt(cfg___0, opt, opttitle);
#line 952
    opttitle = (char *)0;
    }
#line 953
    if (! val) {
#line 954
      return (1);
    }
    {
#line 956
    (val->section)->line = cfg___0->line;
#line 957
    (val->section)->errfunc = cfg___0->errfunc;
#line 958
    rc = cfg_parse_internal___0(val->section, level + 1, -1, (cfg_opt_t *)0);
#line 959
    cfg___0->line = (val->section)->line;
    }
#line 960
    if (rc != -1) {
#line 961
      return (1);
    }
#line 962
    if (opt->validcb) {
      {
#line 962
      tmp___14 = (*(opt->validcb))(cfg___0, opt);
      }
#line 962
      if (tmp___14 != 0) {
#line 963
        return (1);
      }
    }
#line 964
    state = 0;
#line 965
    goto switch_break;
    case_6: /* CIL Label */ 
#line 968
    if (tok != 3) {
      {
#line 970
      tmp___15 = dgettext("confuse", "missing title for section \'%s\'");
#line 970
      cfg_error(cfg___0, (char const   *)tmp___15, opt->name);
      }
#line 972
      return (1);
    } else {
      {
#line 975
      opttitle = strdup((char const   *)cfg_yylval);
      }
    }
#line 976
    state = 5;
#line 977
    goto switch_break;
    case_7: /* CIL Label */ 
#line 980
    if (tok != 40) {
      {
#line 982
      tmp___16 = dgettext("confuse", "missing parenthesis for function \'%s\'");
#line 982
      cfg_error(cfg___0, (char const   *)tmp___16, opt->name);
      }
#line 984
      return (1);
    }
#line 986
    state = 8;
#line 987
    goto switch_break;
    case_8: /* CIL Label */ 
#line 990
    if (tok == 41) {
      {
#line 992
      tmp___17 = call_function___0(cfg___0, opt, & funcopt);
#line 992
      ret = tmp___17;
      }
#line 993
      if (ret != 0) {
#line 994
        return (1);
      }
#line 995
      state = 0;
    } else
#line 997
    if (tok == 3) {
      {
#line 999
      val = cfg_addval___0(& funcopt);
#line 1000
      val->string = strdup((char const   *)cfg_yylval);
#line 1001
      state = 9;
      }
    } else {
      {
#line 1005
      tmp___18 = dgettext("confuse", "syntax error in call of function \'%s\'");
#line 1005
      cfg_error(cfg___0, (char const   *)tmp___18, opt->name);
      }
#line 1007
      return (1);
    }
#line 1009
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1012
    if (tok == 41) {
      {
#line 1014
      tmp___19 = call_function___0(cfg___0, opt, & funcopt);
#line 1014
      ret___0 = tmp___19;
      }
#line 1015
      if (ret___0 != 0) {
#line 1016
        return (1);
      }
#line 1017
      state = 0;
    } else
#line 1019
    if (tok == 44) {
#line 1020
      state = 8;
    } else {
      {
#line 1023
      tmp___20 = dgettext("confuse", "syntax error in call of function \'%s\'");
#line 1023
      cfg_error(cfg___0, (char const   *)tmp___20, opt->name);
      }
#line 1025
      return (1);
    }
#line 1027
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1031
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1031U, "cfg_parse_internal");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1035
  return (-1);
}
}
#line 1188 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_free_opt_array___0(cfg_opt_t *opts ) 
{ 
  int i ;

  {
#line 1192
  i = 0;
  {
#line 1192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1192
    if (! (opts + i)->name) {
#line 1192
      goto while_break;
    }
    {
#line 1194
    free((void *)(opts + i)->name);
    }
#line 1195
    if ((unsigned int )(opts + i)->type == 6U) {
      {
#line 1196
      free((void *)(opts + i)->def.parsed);
      }
    } else
#line 1195
    if ((2 & (opts + i)->flags) == 2) {
      {
#line 1196
      free((void *)(opts + i)->def.parsed);
      }
    } else
#line 1197
    if ((unsigned int )(opts + i)->type == 3U) {
      {
#line 1198
      free((void *)(opts + i)->def.string);
      }
    } else
#line 1199
    if ((unsigned int )(opts + i)->type == 5U) {
      {
#line 1200
      cfg_free_opt_array___0((opts + i)->subopts);
      }
    }
#line 1192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1202
  free((void *)opts);
  }
#line 1203
  return;
}
}
#line 1236 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_value_t *cfg_opt_getval___0(cfg_opt_t *opt , unsigned int index___0 ) 
{ 
  cfg_value_t *val ;

  {
#line 1238
  val = (cfg_value_t *)0;
#line 1240
  if (! (index___0 == 0U)) {
#line 1240
    if (! ((2 & opt->flags) == 2)) {
      {
#line 1240
      __assert_fail("index == 0 || (((2) & (opt->flags)) == (2))", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1240U, "cfg_opt_getval");
      }
    }
  }
#line 1242
  if (opt->simple_value) {
#line 1243
    val = (cfg_value_t *)opt->simple_value;
  } else {
#line 1246
    if ((64 & opt->flags) == 64) {
      {
#line 1248
      cfg_free_value(opt);
#line 1249
      opt->flags &= -65;
      }
    }
#line 1252
    if (index___0 >= opt->nvalues) {
      {
#line 1253
      val = cfg_addval___0(opt);
      }
    } else {
#line 1255
      val = *(opt->values + index___0);
    }
  }
#line 1257
  return (val);
}
}
#line 1341 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_addlist_internal___0(cfg_opt_t *opt , unsigned int nvalues , va_list ap ) 
{ 
  unsigned int i ;
  int tmp___0 ;
  double tmp___2 ;
  cfg_bool_t tmp___4 ;
  char *tmp___6 ;

  {
#line 1346
  i = 0U;
  {
#line 1346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1346
    if (! (i < nvalues)) {
#line 1346
      goto while_break;
    }
    {
#line 1350
    if ((unsigned int )opt->type == 1U) {
#line 1350
      goto case_1;
    }
#line 1353
    if ((unsigned int )opt->type == 2U) {
#line 1353
      goto case_2;
    }
#line 1357
    if ((unsigned int )opt->type == 4U) {
#line 1357
      goto case_4;
    }
#line 1361
    if ((unsigned int )opt->type == 3U) {
#line 1361
      goto case_3;
    }
#line 1366
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1351
    tmp___0 = __builtin_va_arg(ap, int );
#line 1351
    cfg_opt_setnint(opt, (long )tmp___0, opt->nvalues);
    }
#line 1352
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1354
    tmp___2 = __builtin_va_arg(ap, double );
#line 1354
    cfg_opt_setnfloat(opt, tmp___2, opt->nvalues);
    }
#line 1356
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1358
    tmp___4 = __builtin_va_arg(ap, cfg_bool_t );
#line 1358
    cfg_opt_setnbool(opt, tmp___4, opt->nvalues);
    }
#line 1360
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1362
    tmp___6 = __builtin_va_arg(ap, char *);
#line 1362
    cfg_opt_setnstr(opt, (char const   *)tmp___6, opt->nvalues);
    }
#line 1363
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1367
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1370
  return;
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_indent___0(FILE *fp , int indent ) 
{ 
  int tmp ;

  {
  {
#line 1440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1440
    tmp = indent;
#line 1440
    indent --;
#line 1440
    if (! tmp) {
#line 1440
      goto while_break;
    }
    {
#line 1441
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1442
  return;
}
}
#line 1562 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_opt_t *cfg_getopt_array___0(cfg_opt_t *rootopts , int cfg_flags , char const   *name ) 
{ 
  unsigned int i ;
  cfg_opt_t *opts ;
  cfg_t *seccfg ;
  char *secname ;
  size_t len ;
  size_t tmp ;
  cfg_opt_t *secopt ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1565
  opts = rootopts;
#line 1567
  if (rootopts) {
#line 1567
    if (! name) {
      {
#line 1567
      __assert_fail("rootopts && name", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1567U, "cfg_getopt_array");
      }
    }
  } else {
    {
#line 1567
    __assert_fail("rootopts && name", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1567U, "cfg_getopt_array");
    }
  }
  {
#line 1569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1569
    if (name) {
#line 1569
      if (! *name) {
#line 1569
        goto while_break;
      }
    } else {
#line 1569
      goto while_break;
    }
    {
#line 1573
    tmp = strcspn(name, "|");
#line 1573
    len = tmp;
    }
#line 1574
    if ((int const   )*(name + len) == 0) {
#line 1576
      goto while_break;
    }
#line 1577
    if (len) {
      {
#line 1580
      secname = strndup(name, len);
#line 1581
      secopt = cfg_getopt_array___0(opts, cfg_flags, (char const   *)secname);
#line 1582
      free((void *)secname);
      }
#line 1583
      if ((unsigned long )secopt == (unsigned long )((cfg_opt_t *)0)) {
#line 1586
        return ((cfg_opt_t *)0);
      }
#line 1588
      if ((unsigned int )secopt->type != 5U) {
#line 1591
        return ((cfg_opt_t *)0);
      }
#line 1594
      if (! ((1 & secopt->flags) == 1)) {
        {
#line 1594
        seccfg = cfg_opt_getnsec(secopt, 0U);
        }
#line 1594
        if ((unsigned long )seccfg != (unsigned long )((cfg_t *)0)) {
#line 1597
          opts = seccfg->opts;
        } else {
#line 1600
          opts = secopt->subopts;
        }
      } else {
#line 1600
        opts = secopt->subopts;
      }
#line 1601
      if ((unsigned long )opts == (unsigned long )((cfg_opt_t *)0)) {
#line 1604
        return ((cfg_opt_t *)0);
      }
    }
    {
#line 1607
    name += len;
#line 1608
    tmp___0 = strspn(name, "|");
#line 1608
    name += tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1611
  i = 0U;
  {
#line 1611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1611
    if (! (opts + i)->name) {
#line 1611
      goto while_break___0;
    }
#line 1613
    if ((4 & cfg_flags) == 4) {
      {
#line 1615
      tmp___1 = strcasecmp((char const   *)(opts + i)->name, name);
      }
#line 1615
      if (tmp___1 == 0) {
#line 1616
        return (opts + i);
      }
    } else {
      {
#line 1620
      tmp___2 = strcmp((char const   *)(opts + i)->name, name);
      }
#line 1620
      if (tmp___2 == 0) {
#line 1621
        return (opts + i);
      }
    }
#line 1611
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1624
  return ((cfg_opt_t *)0);
}
}
#line 272 "lexer.c"
static size_t yy_buffer_stack_top___1  =    (size_t )0;
#line 273 "lexer.c"
static size_t yy_buffer_stack_max___1  =    (size_t )0;
#line 274 "lexer.c"
static YY_BUFFER_STATE *yy_buffer_stack___1  =    (YY_BUFFER_STATE *)0;
#line 292 "lexer.c"
static char yy_hold_char___1  ;
#line 293 "lexer.c"
static int yy_n_chars___1  ;
#line 297 "lexer.c"
static char *yy_c_buf_p___1  =    (char *)0;
#line 298 "lexer.c"
static int yy_init___1  =    0;
#line 299 "lexer.c"
static int yy_start___1  =    0;
#line 304 "lexer.c"
static int yy_did_buffer_switch_on_eof___1  ;
#line 314
static void cfg_yyensure_buffer_stack___1(void) ;
#line 315
static void cfg_yy_load_buffer_state___1(void) ;
#line 316
static void cfg_yy_init_buffer___1(YY_BUFFER_STATE b , FILE *file ) ;
#line 370
static yy_state_type yy_get_previous_state___1(void) ;
#line 371
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state ) ;
#line 372
static int yy_get_next_buffer___1(void) ;
#line 373
static void yy_fatal_error___1(char const   *msg ) ;
#line 394 "lexer.c"
static flex_int16_t const   yy_accept___1[85]  = 
#line 394
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )12, 
        (flex_int16_t const   )12,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )45,      (flex_int16_t const   )42,      (flex_int16_t const   )1, 
        (flex_int16_t const   )2,      (flex_int16_t const   )43,      (flex_int16_t const   )16,      (flex_int16_t const   )3, 
        (flex_int16_t const   )42,      (flex_int16_t const   )34,      (flex_int16_t const   )6,      (flex_int16_t const   )7, 
        (flex_int16_t const   )43,      (flex_int16_t const   )10,      (flex_int16_t const   )42,      (flex_int16_t const   )8, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )12,      (flex_int16_t const   )14, 
        (flex_int16_t const   )13,      (flex_int16_t const   )33,      (flex_int16_t const   )19,      (flex_int16_t const   )17, 
        (flex_int16_t const   )33,      (flex_int16_t const   )44,      (flex_int16_t const   )40,      (flex_int16_t const   )36, 
        (flex_int16_t const   )35,      (flex_int16_t const   )44,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )1,      (flex_int16_t const   )3,      (flex_int16_t const   )0,      (flex_int16_t const   )9, 
        (flex_int16_t const   )42,      (flex_int16_t const   )11,      (flex_int16_t const   )3,      (flex_int16_t const   )12, 
        (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )15,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )32,      (flex_int16_t const   )20,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )28,      (flex_int16_t const   )26,      (flex_int16_t const   )29, 
        (flex_int16_t const   )27,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )30, 
        (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )40,      (flex_int16_t const   )39, 
        (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )0,      (flex_int16_t const   )41, 
        (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )33,      (flex_int16_t const   )0, 
        (flex_int16_t const   )18,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )23, 
        (flex_int16_t const   )3,      (flex_int16_t const   )18,      (flex_int16_t const   )21,      (flex_int16_t const   )23, 
        (flex_int16_t const   )0};
#line 407 "lexer.c"
static flex_int32_t const   yy_ec___1[256]  = 
#line 407
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )7,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )14, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )16,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )17,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )18, 
        (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )19,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )18, 
        (flex_int32_t const   )18,      (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )24,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )25,      (flex_int32_t const   )1, 
        (flex_int32_t const   )26,      (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )1, 
        (flex_int32_t const   )28,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )29, 
        (flex_int32_t const   )1,      (flex_int32_t const   )30,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 439 "lexer.c"
static flex_int32_t const   yy_meta___1[31]  = 
#line 439
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )2,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )6, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )2,      (flex_int32_t const   )7,      (flex_int32_t const   )8, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )2};
#line 446 "lexer.c"
static flex_int16_t const   yy_base___1[102]  = 
#line 446
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )38, 
        (flex_int16_t const   )39,      (flex_int16_t const   )131,      (flex_int16_t const   )116,      (flex_int16_t const   )127, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )0, 
        (flex_int16_t const   )30,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )111,      (flex_int16_t const   )293,      (flex_int16_t const   )34,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )0,      (flex_int16_t const   )293, 
        (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )98,      (flex_int16_t const   )57,      (flex_int16_t const   )0,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )67,      (flex_int16_t const   )107,      (flex_int16_t const   )41, 
        (flex_int16_t const   )116,      (flex_int16_t const   )0,      (flex_int16_t const   )59,      (flex_int16_t const   )293, 
        (flex_int16_t const   )62,      (flex_int16_t const   )293,      (flex_int16_t const   )86,      (flex_int16_t const   )0, 
        (flex_int16_t const   )42,      (flex_int16_t const   )50,      (flex_int16_t const   )293,      (flex_int16_t const   )0, 
        (flex_int16_t const   )114,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )47, 
        (flex_int16_t const   )50,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )44,      (flex_int16_t const   )293, 
        (flex_int16_t const   )144,      (flex_int16_t const   )0,      (flex_int16_t const   )117,      (flex_int16_t const   )41, 
        (flex_int16_t const   )0,      (flex_int16_t const   )52,      (flex_int16_t const   )108,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )293,      (flex_int16_t const   )110,      (flex_int16_t const   )293, 
        (flex_int16_t const   )293,      (flex_int16_t const   )174,      (flex_int16_t const   )182,      (flex_int16_t const   )190, 
        (flex_int16_t const   )198,      (flex_int16_t const   )206,      (flex_int16_t const   )214,      (flex_int16_t const   )222, 
        (flex_int16_t const   )230,      (flex_int16_t const   )238,      (flex_int16_t const   )245,      (flex_int16_t const   )253, 
        (flex_int16_t const   )260,      (flex_int16_t const   )268,      (flex_int16_t const   )276,      (flex_int16_t const   )62, 
        (flex_int16_t const   )284,      (flex_int16_t const   )36};
#line 462 "lexer.c"
static flex_int16_t const   yy_def___1[102]  = 
#line 462
  {      (flex_int16_t const   )0,      (flex_int16_t const   )84,      (flex_int16_t const   )1,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )84,      (flex_int16_t const   )88,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )89, 
        (flex_int16_t const   )88,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )90,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )91,      (flex_int16_t const   )84, 
        (flex_int16_t const   )92,      (flex_int16_t const   )93,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )96,      (flex_int16_t const   )88,      (flex_int16_t const   )90, 
        (flex_int16_t const   )84,      (flex_int16_t const   )89,      (flex_int16_t const   )97,      (flex_int16_t const   )84, 
        (flex_int16_t const   )88,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )91, 
        (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )84,      (flex_int16_t const   )93, 
        (flex_int16_t const   )98,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )99,      (flex_int16_t const   )95,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )97,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )46,      (flex_int16_t const   )98,      (flex_int16_t const   )100, 
        (flex_int16_t const   )93,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )101, 
        (flex_int16_t const   )72,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )0,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84};
#line 478 "lexer.c"
static flex_int16_t const   yy_nxt___1[324]  = 
#line 478
  {      (flex_int16_t const   )0,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )12, 
        (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )17,      (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )13, 
        (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )23,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )30,      (flex_int16_t const   )30,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )28, 
        (flex_int16_t const   )28,      (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )83, 
        (flex_int16_t const   )39,      (flex_int16_t const   )45,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )46,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )49, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )50,      (flex_int16_t const   )39, 
        (flex_int16_t const   )84,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )42, 
        (flex_int16_t const   )54,      (flex_int16_t const   )49,      (flex_int16_t const   )77,      (flex_int16_t const   )78, 
        (flex_int16_t const   )50,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )82, 
        (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )68,      (flex_int16_t const   )81, 
        (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )71,      (flex_int16_t const   )69, 
        (flex_int16_t const   )39,      (flex_int16_t const   )57,      (flex_int16_t const   )58,      (flex_int16_t const   )59, 
        (flex_int16_t const   )60,      (flex_int16_t const   )61,      (flex_int16_t const   )62,      (flex_int16_t const   )63, 
        (flex_int16_t const   )64,      (flex_int16_t const   )65,      (flex_int16_t const   )69,      (flex_int16_t const   )72, 
        (flex_int16_t const   )41,      (flex_int16_t const   )71,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )72,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )41, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )75,      (flex_int16_t const   )40,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )39,      (flex_int16_t const   )75,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )52, 
        (flex_int16_t const   )43,      (flex_int16_t const   )40,      (flex_int16_t const   )39,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )75,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )75,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )76,      (flex_int16_t const   )80,      (flex_int16_t const   )41,      (flex_int16_t const   )76, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )80, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )73,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )41,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80, 
        (flex_int16_t const   )80,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34, 
        (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )34,      (flex_int16_t const   )38, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )84,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )44, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )47, 
        (flex_int16_t const   )47,      (flex_int16_t const   )84,      (flex_int16_t const   )47,      (flex_int16_t const   )47, 
        (flex_int16_t const   )84,      (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )84,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )51, 
        (flex_int16_t const   )51,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )51, 
        (flex_int16_t const   )51,      (flex_int16_t const   )51,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )66,      (flex_int16_t const   )66, 
        (flex_int16_t const   )84,      (flex_int16_t const   )66,      (flex_int16_t const   )84,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70, 
        (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70, 
        (flex_int16_t const   )70,      (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )9,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84};
#line 518 "lexer.c"
static flex_int16_t const   yy_chk___1[324]  = 
#line 518
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )5, 
        (flex_int16_t const   )6,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )101, 
        (flex_int16_t const   )16,      (flex_int16_t const   )22,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )22,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )28, 
        (flex_int16_t const   )39,      (flex_int16_t const   )48,      (flex_int16_t const   )28,      (flex_int16_t const   )39, 
        (flex_int16_t const   )48,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )16, 
        (flex_int16_t const   )33,      (flex_int16_t const   )49,      (flex_int16_t const   )55,      (flex_int16_t const   )55, 
        (flex_int16_t const   )49,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )99,      (flex_int16_t const   )37,      (flex_int16_t const   )75, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )70,      (flex_int16_t const   )37, 
        (flex_int16_t const   )44,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )37,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )52,      (flex_int16_t const   )40,      (flex_int16_t const   )52, 
        (flex_int16_t const   )74,      (flex_int16_t const   )38,      (flex_int16_t const   )74,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )32, 
        (flex_int16_t const   )20,      (flex_int16_t const   )11,      (flex_int16_t const   )10,      (flex_int16_t const   )9, 
        (flex_int16_t const   )0,      (flex_int16_t const   )52,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )74,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )52,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )74, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )86, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )88, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )89, 
        (flex_int16_t const   )89,      (flex_int16_t const   )0,      (flex_int16_t const   )89,      (flex_int16_t const   )89, 
        (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )90, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )91, 
        (flex_int16_t const   )91,      (flex_int16_t const   )0,      (flex_int16_t const   )91,      (flex_int16_t const   )91, 
        (flex_int16_t const   )0,      (flex_int16_t const   )91,      (flex_int16_t const   )91,      (flex_int16_t const   )92, 
        (flex_int16_t const   )92,      (flex_int16_t const   )0,      (flex_int16_t const   )92,      (flex_int16_t const   )92, 
        (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )93, 
        (flex_int16_t const   )93,      (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )94, 
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94, 
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )95, 
        (flex_int16_t const   )0,      (flex_int16_t const   )95,      (flex_int16_t const   )0,      (flex_int16_t const   )95, 
        (flex_int16_t const   )95,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96, 
        (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96, 
        (flex_int16_t const   )96,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )97,      (flex_int16_t const   )98,      (flex_int16_t const   )98,      (flex_int16_t const   )98, 
        (flex_int16_t const   )98,      (flex_int16_t const   )98,      (flex_int16_t const   )98,      (flex_int16_t const   )98, 
        (flex_int16_t const   )98,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )100, 
        (flex_int16_t const   )100,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84};
#line 558 "lexer.c"
static yy_state_type yy_last_accepting_state___1  ;
#line 559 "lexer.c"
static char *yy_last_accepting_cpos___1  ;
#line 53 "lexer.l"
static unsigned int qstring_index___1  =    0U;
#line 54 "lexer.l"
static unsigned int qstring_len___1  =    0U;
#line 55
static void qputc___1(char ch ) ;
#line 66 "lexer.l"
static YY_BUFFER_STATE pre_string_scan_state___1  =    (YY_BUFFER_STATE )0;
#line 67 "lexer.l"
static YY_BUFFER_STATE string_scan_state___1  =    (YY_BUFFER_STATE )0;
#line 665 "lexer.c"
static int yy_init_globals___1(void) ;
#line 708
static void yyunput___1(int c , char *yy_bp ) ;
#line 1433 "lexer.c"
static int yy_get_next_buffer___1(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  int n ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;

  {
#line 1435
  dest = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf;
#line 1436
  source = cfg_yytext;
#line 1440
  if ((unsigned long )yy_c_buf_p___1 > (unsigned long )((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + (yy_n_chars___1 + 1))) {
    {
#line 1441
    yy_fatal_error___1("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1444
  if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_fill_buffer == 0) {
#line 1446
    if (yy_c_buf_p___1 - cfg_yytext == 1L) {
#line 1451
      return (1);
    } else {
#line 1459
      return (2);
    }
  }
#line 1466
  number_to_move = (int )(yy_c_buf_p___1 - cfg_yytext) - 1;
#line 1468
  i = 0;
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1468
    if (! (i < number_to_move)) {
#line 1468
      goto while_break;
    }
#line 1469
    tmp = dest;
#line 1469
    dest ++;
#line 1469
    tmp___0 = source;
#line 1469
    source ++;
#line 1469
    *tmp = *tmp___0;
#line 1468
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1471
  if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status == 2) {
#line 1475
    yy_n_chars___1 = 0;
#line 1475
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  } else {
#line 1479
    num_to_read = (int )(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1482
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1482
      if (! (num_to_read <= 0)) {
#line 1482
        goto while_break___0;
      }
#line 1486
      if (yy_buffer_stack___1) {
#line 1486
        tmp___1 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
      } else {
#line 1486
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1486
      b = tmp___1;
#line 1488
      yy_c_buf_p_offset = (int )(yy_c_buf_p___1 - b->yy_ch_buf);
#line 1491
      if (b->yy_is_our_buffer) {
#line 1493
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1495
        if (new_size <= 0) {
#line 1496
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1498
          b->yy_buf_size *= 2UL;
        }
        {
#line 1500
        tmp___2 = cfg_yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1500
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1506
        b->yy_ch_buf = (char *)0;
      }
#line 1508
      if (! b->yy_ch_buf) {
        {
#line 1509
        yy_fatal_error___1("fatal error - scanner input buffer overflow");
        }
      }
#line 1512
      yy_c_buf_p___1 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1514
      num_to_read = (int )(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1519
    if (num_to_read > 8192) {
#line 1520
      num_to_read = 8192;
    }
#line 1523
    if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_is_interactive) {
#line 1523
      c = '*';
#line 1523
      n = 0;
      {
#line 1523
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1523
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 1523
          c = _IO_getc(cfg_yyin);
          }
#line 1523
          if (c != -1) {
#line 1523
            if (! (c != 10)) {
#line 1523
              goto while_break___1;
            }
          } else {
#line 1523
            goto while_break___1;
          }
        } else {
#line 1523
          goto while_break___1;
        }
#line 1523
        *(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1523
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1523
      if (c == 10) {
#line 1523
        tmp___3 = n;
#line 1523
        n ++;
#line 1523
        *(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1523
      if (c == -1) {
        {
#line 1523
        tmp___4 = ferror(cfg_yyin);
        }
#line 1523
        if (tmp___4) {
          {
#line 1523
          yy_fatal_error___1("input in flex scanner failed");
          }
        }
      }
#line 1523
      yy_n_chars___1 = n;
    } else {
      {
#line 1523
      tmp___5 = __errno_location();
#line 1523
      *tmp___5 = 0;
      }
      {
#line 1523
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1523
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)cfg_yyin);
#line 1523
        yy_n_chars___1 = (int )tmp___8;
        }
#line 1523
        if (yy_n_chars___1 == 0) {
          {
#line 1523
          tmp___9 = ferror(cfg_yyin);
          }
#line 1523
          if (! tmp___9) {
#line 1523
            goto while_break___2;
          }
        } else {
#line 1523
          goto while_break___2;
        }
        {
#line 1523
        tmp___6 = __errno_location();
        }
#line 1523
        if (*tmp___6 != 4) {
          {
#line 1523
          yy_fatal_error___1("input in flex scanner failed");
          }
#line 1523
          goto while_break___2;
        }
        {
#line 1523
        tmp___7 = __errno_location();
#line 1523
        *tmp___7 = 0;
#line 1523
        clearerr(cfg_yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1526
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  }
#line 1529
  if (yy_n_chars___1 == 0) {
#line 1531
    if (number_to_move == 0) {
      {
#line 1533
      ret_val = 1;
#line 1534
      cfg_yyrestart(cfg_yyin);
      }
    } else {
#line 1539
      ret_val = 2;
#line 1540
      (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status = 2;
    }
  } else {
#line 1546
    ret_val = 0;
  }
#line 1548
  if ((yy_size_t )(yy_n_chars___1 + number_to_move) > (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size) {
    {
#line 1550
    new_size___0 = (yy_size_t )((yy_n_chars___1 + number_to_move) + (yy_n_chars___1 >> 1));
#line 1551
    tmp___10 = cfg_yyrealloc((void *)(*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf,
                             new_size___0);
#line 1551
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf = (char *)tmp___10;
    }
#line 1552
    if (! (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf) {
      {
#line 1553
      yy_fatal_error___1("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1556
  yy_n_chars___1 += number_to_move;
#line 1557
  *((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + yy_n_chars___1) = (char)0;
#line 1558
  *((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + (yy_n_chars___1 + 1)) = (char)0;
#line 1560
  cfg_yytext = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + 0;
#line 1562
  return (ret_val);
}
}
#line 1567 "lexer.c"
static yy_state_type yy_get_previous_state___1(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1572
  yy_current_state = yy_start___1;
#line 1574
  yy_cp = cfg_yytext + 0;
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p___1)) {
#line 1574
      goto while_break;
    }
#line 1576
    if (*yy_cp) {
#line 1576
      tmp = yy_ec___1[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1576
      tmp = (flex_int32_t const   )1;
    }
#line 1576
    yy_c = (YY_CHAR )tmp;
#line 1577
    if (yy_accept___1[yy_current_state]) {
#line 1579
      yy_last_accepting_state___1 = yy_current_state;
#line 1580
      yy_last_accepting_cpos___1 = yy_cp;
    }
    {
#line 1582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1582
      if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1582
        goto while_break___0;
      }
#line 1584
      yy_current_state = (int )yy_def___1[yy_current_state];
#line 1585
      if (yy_current_state >= 85) {
#line 1586
        yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1588
    yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1574
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1591
  return (yy_current_state);
}
}
#line 1599 "lexer.c"
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1602
  yy_cp = yy_c_buf_p___1;
#line 1604
  yy_c = (YY_CHAR )1;
#line 1605
  if (yy_accept___1[yy_current_state]) {
#line 1607
    yy_last_accepting_state___1 = yy_current_state;
#line 1608
    yy_last_accepting_cpos___1 = yy_cp;
  }
  {
#line 1610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1610
    if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1610
      goto while_break;
    }
#line 1612
    yy_current_state = (int )yy_def___1[yy_current_state];
#line 1613
    if (yy_current_state >= 85) {
#line 1614
      yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1616
  yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1617
  yy_is_jam = yy_current_state == 84;
#line 1619
  if (yy_is_jam) {
#line 1619
    tmp = 0;
  } else {
#line 1619
    tmp = yy_current_state;
  }
#line 1619
  return (tmp);
}
}
#line 1622 "lexer.c"
static void yyunput___1(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register int number_to_move ;
  register char *dest ;
  register char *source ;

  {
#line 1626
  yy_cp = yy_c_buf_p___1;
#line 1629
  *yy_cp = yy_hold_char___1;
#line 1631
  if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + 2)) {
#line 1634
    number_to_move = yy_n_chars___1 + 2;
#line 1635
    dest = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size + 2UL);
#line 1637
    source = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move;
    {
#line 1640
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1640
      if (! ((unsigned long )source > (unsigned long )(*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf)) {
#line 1640
        goto while_break;
      }
#line 1641
      dest --;
#line 1641
      source --;
#line 1641
      *dest = *source;
    }
    while_break: /* CIL Label */ ;
    }
#line 1643
    yy_cp += (int )(dest - source);
#line 1644
    yy_bp += (int )(dest - source);
#line 1645
    yy_n_chars___1 = (int )(*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size;
#line 1645
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
#line 1648
    if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + 2)) {
      {
#line 1649
      yy_fatal_error___1("flex scanner push-back overflow");
      }
    }
  }
#line 1652
  yy_cp --;
#line 1652
  *yy_cp = (char )c;
#line 1654
  cfg_yytext = yy_bp;
#line 1655
  yy_hold_char___1 = *yy_cp;
#line 1656
  yy_c_buf_p___1 = yy_cp;
#line 1657
  return;
}
}
#line 1786 "lexer.c"
static void cfg_yy_load_buffer_state___1(void) 
{ 


  {
#line 1788
  yy_n_chars___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars;
#line 1789
  yy_c_buf_p___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_pos;
#line 1789
  cfg_yytext = yy_c_buf_p___1;
#line 1790
  cfg_yyin = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_input_file;
#line 1791
  yy_hold_char___1 = *yy_c_buf_p___1;
#line 1792
  return;
}
}
#line 1861 "lexer.c"
static void cfg_yy_init_buffer___1(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1864
  tmp = __errno_location();
#line 1864
  oerrno = *tmp;
#line 1866
  cfg_yy_flush_buffer(b);
#line 1868
  b->yy_input_file = file;
#line 1869
  b->yy_fill_buffer = 1;
  }
#line 1875
  if (yy_buffer_stack___1) {
#line 1875
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1875
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1875
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1876
    b->yy_bs_lineno = 1;
#line 1877
    b->yy_bs_column = 0;
  }
#line 1880
  if (file) {
    {
#line 1880
    tmp___1 = fileno(file);
#line 1880
    tmp___2 = isatty(tmp___1);
#line 1880
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1880
    b->yy_is_interactive = 0;
  }
  {
#line 1882
  tmp___3 = __errno_location();
#line 1882
  *tmp___3 = oerrno;
  }
#line 1883
  return;
}
}
#line 1967 "lexer.c"
static void cfg_yyensure_buffer_stack___1(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1971
  if (! yy_buffer_stack___1) {
    {
#line 1977
    num_to_alloc = 1;
#line 1978
    tmp = cfg_yyalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1978
    yy_buffer_stack___1 = (struct yy_buffer_state **)tmp;
    }
#line 1981
    if (! yy_buffer_stack___1) {
      {
#line 1982
      yy_fatal_error___1("out of dynamic memory in cfg_yyensure_buffer_stack()");
      }
    }
    {
#line 1984
    memset((void *)yy_buffer_stack___1, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1986
    yy_buffer_stack_max___1 = (size_t )num_to_alloc;
#line 1987
    yy_buffer_stack_top___1 = (size_t )0;
    }
#line 1988
    return;
  }
#line 1991
  if (yy_buffer_stack_top___1 >= yy_buffer_stack_max___1 - 1UL) {
    {
#line 1994
    grow_size = 8;
#line 1996
    num_to_alloc = (int )(yy_buffer_stack_max___1 + (size_t )grow_size);
#line 1997
    tmp___0 = cfg_yyrealloc((void *)yy_buffer_stack___1, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1997
    yy_buffer_stack___1 = (struct yy_buffer_state **)tmp___0;
    }
#line 2001
    if (! yy_buffer_stack___1) {
      {
#line 2002
      yy_fatal_error___1("out of dynamic memory in cfg_yyensure_buffer_stack()");
      }
    }
    {
#line 2005
    memset((void *)(yy_buffer_stack___1 + yy_buffer_stack_max___1), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2006
    yy_buffer_stack_max___1 = (size_t )num_to_alloc;
    }
  }
#line 2008
  return;
}
}
#line 2100 "lexer.c"
static void yy_fatal_error___1(char const   *msg ) 
{ 


  {
  {
#line 2102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2103
  exit(2);
  }
}
}
#line 2203 "lexer.c"
static int yy_init_globals___1(void) 
{ 


  {
#line 2209
  yy_buffer_stack___1 = (YY_BUFFER_STATE *)0;
#line 2210
  yy_buffer_stack_top___1 = (size_t )0;
#line 2211
  yy_buffer_stack_max___1 = (size_t )0;
#line 2212
  yy_c_buf_p___1 = (char *)0;
#line 2213
  yy_init___1 = 0;
#line 2214
  yy_start___1 = 0;
#line 2221
  cfg_yyin = (FILE *)0;
#line 2222
  cfg_yyout = (FILE *)0;
#line 2228
  return (0);
}
}
#line 322 "lexer.l"
static void qputc___1(char ch ) 
{ 
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 324
  if (qstring_index___1 >= qstring_len___1) {
    {
#line 325
    qstring_len___1 += 32U;
#line 326
    tmp = realloc((void *)cfg_qstring, (size_t )qstring_len___1);
#line 326
    cfg_qstring = (char *)tmp;
    }
#line 327
    if (! cfg_qstring) {
      {
#line 327
      __assert_fail("cfg_qstring", "lexer.l", 327U, "qputc");
      }
    }
    {
#line 328
    memset((void *)(cfg_qstring + qstring_index___1), 0, (size_t )32);
    }
  }
#line 330
  tmp___0 = qstring_index___1;
#line 330
  qstring_index___1 ++;
#line 330
  *(cfg_qstring + tmp___0) = ch;
#line 331
  return;
}
}
#line 355 "lexer.l"
static YY_BUFFER_STATE pre_fp_scan_state___1  ;
#line 356 "lexer.l"
static YY_BUFFER_STATE fp_scan_state___1  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/ftpconf.c"
int conf_alias(cfg_t *cfg___0 , cfg_opt_t *opt , int argc , char const   **argv ) 
{ 
  char const   *tmp ;

  {
#line 18
  if (argc < 2) {
    {
#line 20
    tmp = cfg_opt_name(opt);
#line 20
    cfg_error(cfg___0, "function \'%s\' requires 2 arguments", tmp);
    }
#line 21
    return (-1);
  }
  {
#line 23
  printf((char const   */* __restrict  */)"got alias \'%s\' = \'%s\'\n", *(argv + 0),
         *(argv + 1));
  }
#line 24
  return (0);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/ftpconf.c"
int conf_parse_acb(cfg_t *cfg___0 , cfg_opt_t *opt , char const   *value , void *result ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 30
  tmp___2 = strcmp(value, "yes");
  }
#line 30
  if (tmp___2 == 0) {
#line 31
    *((int *)result) = 1;
  } else {
    {
#line 32
    tmp___1 = strcmp(value, "no");
    }
#line 32
    if (tmp___1 == 0) {
#line 33
      *((int *)result) = 2;
    } else {
      {
#line 34
      tmp___0 = strcmp(value, "ask");
      }
#line 34
      if (tmp___0 == 0) {
#line 35
        *((int *)result) = 3;
      } else {
        {
#line 38
        tmp = cfg_opt_name(opt);
#line 38
        cfg_error(cfg___0, "invalid value for option \'%s\': %s", tmp, value);
        }
#line 40
        return (-1);
      }
    }
  }
#line 42
  return (0);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/ftpconf.c"
int conf_validate_port(cfg_t *cfg___0 , cfg_opt_t *opt ) 
{ 
  int value ;
  long tmp ;
  char const   *tmp___0 ;

  {
  {
#line 48
  tmp = cfg_opt_getnint(opt, 0U);
#line 48
  value = (int )tmp;
  }
#line 49
  if (value <= 0) {
    {
#line 51
    tmp___0 = cfg_name(cfg___0);
#line 51
    cfg_error(cfg___0, "invalid port %d in section \'%s\'", value, tmp___0);
    }
#line 52
    return (-1);
  }
#line 54
  return (0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/ftpconf.c"
int conf_validate_bookmark(cfg_t *cfg___0 , cfg_opt_t *opt ) 
{ 
  cfg_t *bookmark ;
  unsigned int tmp ;
  cfg_t *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 60
  tmp = cfg_opt_size(opt);
#line 60
  tmp___0 = cfg_opt_getnsec(opt, tmp - 1U);
#line 60
  bookmark = tmp___0;
#line 61
  tmp___1 = cfg_size(bookmark, "host");
  }
#line 61
  if (tmp___1 == 0U) {
    {
#line 63
    cfg_error(cfg___0, "missing required option \'host\' in bookmark");
    }
#line 64
    return (-1);
  }
#line 66
  return (0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/examples/ftpconf.c"
cfg_t *parse_conf(char const   *filename ) 
{ 
  cfg_opt_t bookmark_opts[6] ;
  cfg_opt_t opts[8] ;
  cfg_t *cfg___0 ;
  cfg_t *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 71
  bookmark_opts[0].name = (char *)"host";
#line 71
  bookmark_opts[0].type = (cfg_type_t )3;
#line 71
  bookmark_opts[0].nvalues = 0U;
#line 71
  bookmark_opts[0].values = (cfg_value_t **)0;
#line 71
  bookmark_opts[0].flags = 16;
#line 71
  bookmark_opts[0].subopts = (cfg_opt_t *)0;
#line 71
  bookmark_opts[0].def.number = 0L;
#line 71
  bookmark_opts[0].def.fpnumber = (double )0;
#line 71
  bookmark_opts[0].def.boolean = (cfg_bool_t )0;
#line 71
  bookmark_opts[0].def.string = (char *)0;
#line 71
  bookmark_opts[0].def.parsed = (char *)0;
#line 71
  bookmark_opts[0].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 71
  bookmark_opts[0].simple_value = (void *)0;
#line 71
  bookmark_opts[0].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value ,
                                      void *result ))0;
#line 71
  bookmark_opts[0].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 71
  bookmark_opts[0].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 71
  bookmark_opts[0].freecb = (void (*)(void *value ))0;
#line 71
  bookmark_opts[1].name = (char *)"port";
#line 71
  bookmark_opts[1].type = (cfg_type_t )1;
#line 71
  bookmark_opts[1].nvalues = 0U;
#line 71
  bookmark_opts[1].values = (cfg_value_t **)0;
#line 71
  bookmark_opts[1].flags = 0;
#line 71
  bookmark_opts[1].subopts = (cfg_opt_t *)0;
#line 71
  bookmark_opts[1].def.number = 21L;
#line 71
  bookmark_opts[1].def.fpnumber = (double )0;
#line 71
  bookmark_opts[1].def.boolean = (cfg_bool_t )0;
#line 71
  bookmark_opts[1].def.string = (char *)0;
#line 71
  bookmark_opts[1].def.parsed = (char *)0;
#line 71
  bookmark_opts[1].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 71
  bookmark_opts[1].simple_value = (void *)0;
#line 71
  bookmark_opts[1].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value ,
                                      void *result ))0;
#line 71
  bookmark_opts[1].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 71
  bookmark_opts[1].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 71
  bookmark_opts[1].freecb = (void (*)(void *value ))0;
#line 71
  bookmark_opts[2].name = (char *)"login";
#line 71
  bookmark_opts[2].type = (cfg_type_t )3;
#line 71
  bookmark_opts[2].nvalues = 0U;
#line 71
  bookmark_opts[2].values = (cfg_value_t **)0;
#line 71
  bookmark_opts[2].flags = 0;
#line 71
  bookmark_opts[2].subopts = (cfg_opt_t *)0;
#line 71
  bookmark_opts[2].def.number = 0L;
#line 71
  bookmark_opts[2].def.fpnumber = (double )0;
#line 71
  bookmark_opts[2].def.boolean = (cfg_bool_t )0;
#line 71
  bookmark_opts[2].def.string = (char *)"anonymous";
#line 71
  bookmark_opts[2].def.parsed = (char *)0;
#line 71
  bookmark_opts[2].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 71
  bookmark_opts[2].simple_value = (void *)0;
#line 71
  bookmark_opts[2].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value ,
                                      void *result ))0;
#line 71
  bookmark_opts[2].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 71
  bookmark_opts[2].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 71
  bookmark_opts[2].freecb = (void (*)(void *value ))0;
#line 71
  bookmark_opts[3].name = (char *)"password";
#line 71
  bookmark_opts[3].type = (cfg_type_t )3;
#line 71
  bookmark_opts[3].nvalues = 0U;
#line 71
  bookmark_opts[3].values = (cfg_value_t **)0;
#line 71
  bookmark_opts[3].flags = 0;
#line 71
  bookmark_opts[3].subopts = (cfg_opt_t *)0;
#line 71
  bookmark_opts[3].def.number = 0L;
#line 71
  bookmark_opts[3].def.fpnumber = (double )0;
#line 71
  bookmark_opts[3].def.boolean = (cfg_bool_t )0;
#line 71
  bookmark_opts[3].def.string = (char *)"anonymous@";
#line 71
  bookmark_opts[3].def.parsed = (char *)0;
#line 71
  bookmark_opts[3].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 71
  bookmark_opts[3].simple_value = (void *)0;
#line 71
  bookmark_opts[3].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value ,
                                      void *result ))0;
#line 71
  bookmark_opts[3].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 71
  bookmark_opts[3].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 71
  bookmark_opts[3].freecb = (void (*)(void *value ))0;
#line 71
  bookmark_opts[4].name = (char *)"directory";
#line 71
  bookmark_opts[4].type = (cfg_type_t )3;
#line 71
  bookmark_opts[4].nvalues = 0U;
#line 71
  bookmark_opts[4].values = (cfg_value_t **)0;
#line 71
  bookmark_opts[4].flags = 0;
#line 71
  bookmark_opts[4].subopts = (cfg_opt_t *)0;
#line 71
  bookmark_opts[4].def.number = 0L;
#line 71
  bookmark_opts[4].def.fpnumber = (double )0;
#line 71
  bookmark_opts[4].def.boolean = (cfg_bool_t )0;
#line 71
  bookmark_opts[4].def.string = (char *)0;
#line 71
  bookmark_opts[4].def.parsed = (char *)0;
#line 71
  bookmark_opts[4].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 71
  bookmark_opts[4].simple_value = (void *)0;
#line 71
  bookmark_opts[4].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value ,
                                      void *result ))0;
#line 71
  bookmark_opts[4].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 71
  bookmark_opts[4].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 71
  bookmark_opts[4].freecb = (void (*)(void *value ))0;
#line 71
  bookmark_opts[5].name = (char *)0;
#line 71
  bookmark_opts[5].type = (cfg_type_t )0;
#line 71
  bookmark_opts[5].nvalues = 0U;
#line 71
  bookmark_opts[5].values = (cfg_value_t **)0;
#line 71
  bookmark_opts[5].flags = 0;
#line 71
  bookmark_opts[5].subopts = (cfg_opt_t *)0;
#line 71
  bookmark_opts[5].def.number = 0L;
#line 71
  bookmark_opts[5].def.fpnumber = (double )0;
#line 71
  bookmark_opts[5].def.boolean = (cfg_bool_t )0;
#line 71
  bookmark_opts[5].def.string = (char *)0;
#line 71
  bookmark_opts[5].def.parsed = (char *)0;
#line 71
  bookmark_opts[5].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 71
  bookmark_opts[5].simple_value = (void *)0;
#line 71
  bookmark_opts[5].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value ,
                                      void *result ))0;
#line 71
  bookmark_opts[5].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 71
  bookmark_opts[5].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 71
  bookmark_opts[5].freecb = (void (*)(void *value ))0;
#line 80
  opts[0].name = (char *)"bookmark";
#line 80
  opts[0].type = (cfg_type_t )5;
#line 80
  opts[0].nvalues = 0U;
#line 80
  opts[0].values = (cfg_value_t **)0;
#line 80
  opts[0].flags = 9;
#line 80
  opts[0].subopts = bookmark_opts;
#line 80
  opts[0].def.number = 0L;
#line 80
  opts[0].def.fpnumber = (double )0;
#line 80
  opts[0].def.boolean = (cfg_bool_t )0;
#line 80
  opts[0].def.string = (char *)0;
#line 80
  opts[0].def.parsed = (char *)0;
#line 80
  opts[0].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 80
  opts[0].simple_value = (void *)0;
#line 80
  opts[0].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 80
  opts[0].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 80
  opts[0].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 80
  opts[0].freecb = (void (*)(void *value ))0;
#line 80
  opts[1].name = (char *)"passive-mode";
#line 80
  opts[1].type = (cfg_type_t )4;
#line 80
  opts[1].nvalues = 0U;
#line 80
  opts[1].values = (cfg_value_t **)0;
#line 80
  opts[1].flags = 0;
#line 80
  opts[1].subopts = (cfg_opt_t *)0;
#line 80
  opts[1].def.number = 0L;
#line 80
  opts[1].def.fpnumber = (double )0;
#line 80
  opts[1].def.boolean = (cfg_bool_t )0;
#line 80
  opts[1].def.string = (char *)0;
#line 80
  opts[1].def.parsed = (char *)0;
#line 80
  opts[1].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 80
  opts[1].simple_value = (void *)0;
#line 80
  opts[1].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 80
  opts[1].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 80
  opts[1].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 80
  opts[1].freecb = (void (*)(void *value ))0;
#line 80
  opts[2].name = (char *)"remote-completion";
#line 80
  opts[2].type = (cfg_type_t )4;
#line 80
  opts[2].nvalues = 0U;
#line 80
  opts[2].values = (cfg_value_t **)0;
#line 80
  opts[2].flags = 0;
#line 80
  opts[2].subopts = (cfg_opt_t *)0;
#line 80
  opts[2].def.number = 0L;
#line 80
  opts[2].def.fpnumber = (double )0;
#line 80
  opts[2].def.boolean = (cfg_bool_t )1;
#line 80
  opts[2].def.string = (char *)0;
#line 80
  opts[2].def.parsed = (char *)0;
#line 80
  opts[2].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 80
  opts[2].simple_value = (void *)0;
#line 80
  opts[2].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 80
  opts[2].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 80
  opts[2].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 80
  opts[2].freecb = (void (*)(void *value ))0;
#line 80
  opts[3].name = (char *)"alias";
#line 80
  opts[3].type = (cfg_type_t )6;
#line 80
  opts[3].nvalues = 0U;
#line 80
  opts[3].values = (cfg_value_t **)0;
#line 80
  opts[3].flags = 0;
#line 80
  opts[3].subopts = (cfg_opt_t *)0;
#line 80
  opts[3].def.number = 0L;
#line 80
  opts[3].def.fpnumber = (double )0;
#line 80
  opts[3].def.boolean = (cfg_bool_t )0;
#line 80
  opts[3].def.string = (char *)0;
#line 80
  opts[3].def.parsed = (char *)0;
#line 80
  opts[3].func = & conf_alias;
#line 80
  opts[3].simple_value = (void *)0;
#line 80
  opts[3].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 80
  opts[3].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 80
  opts[3].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 80
  opts[3].freecb = (void (*)(void *value ))0;
#line 80
  opts[4].name = (char *)"xterm-terminals";
#line 80
  opts[4].type = (cfg_type_t )3;
#line 80
  opts[4].nvalues = 0U;
#line 80
  opts[4].values = (cfg_value_t **)0;
#line 80
  opts[4].flags = 2;
#line 80
  opts[4].subopts = (cfg_opt_t *)0;
#line 80
  opts[4].def.number = 0L;
#line 80
  opts[4].def.fpnumber = (double )0;
#line 80
  opts[4].def.boolean = (cfg_bool_t )0;
#line 80
  opts[4].def.string = (char *)0;
#line 80
  opts[4].def.parsed = (char *)"{xterm, rxvt}";
#line 80
  opts[4].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 80
  opts[4].simple_value = (void *)0;
#line 80
  opts[4].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 80
  opts[4].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 80
  opts[4].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 80
  opts[4].freecb = (void (*)(void *value ))0;
#line 80
  opts[5].name = (char *)"auto-create-bookmark";
#line 80
  opts[5].type = (cfg_type_t )1;
#line 80
  opts[5].nvalues = 0U;
#line 80
  opts[5].values = (cfg_value_t **)0;
#line 80
  opts[5].flags = 0;
#line 80
  opts[5].subopts = (cfg_opt_t *)0;
#line 80
  opts[5].def.number = 1L;
#line 80
  opts[5].def.fpnumber = (double )0;
#line 80
  opts[5].def.boolean = (cfg_bool_t )0;
#line 80
  opts[5].def.string = (char *)0;
#line 80
  opts[5].def.parsed = (char *)0;
#line 80
  opts[5].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 80
  opts[5].simple_value = (void *)0;
#line 80
  opts[5].parsecb = & conf_parse_acb;
#line 80
  opts[5].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 80
  opts[5].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 80
  opts[5].freecb = (void (*)(void *value ))0;
#line 80
  opts[6].name = (char *)"include-file";
#line 80
  opts[6].type = (cfg_type_t )6;
#line 80
  opts[6].nvalues = 0U;
#line 80
  opts[6].values = (cfg_value_t **)0;
#line 80
  opts[6].flags = 0;
#line 80
  opts[6].subopts = (cfg_opt_t *)0;
#line 80
  opts[6].def.number = 0L;
#line 80
  opts[6].def.fpnumber = (double )0;
#line 80
  opts[6].def.boolean = (cfg_bool_t )0;
#line 80
  opts[6].def.string = (char *)0;
#line 80
  opts[6].def.parsed = (char *)0;
#line 80
  opts[6].func = & cfg_include;
#line 80
  opts[6].simple_value = (void *)0;
#line 80
  opts[6].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 80
  opts[6].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 80
  opts[6].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 80
  opts[6].freecb = (void (*)(void *value ))0;
#line 80
  opts[7].name = (char *)0;
#line 80
  opts[7].type = (cfg_type_t )0;
#line 80
  opts[7].nvalues = 0U;
#line 80
  opts[7].values = (cfg_value_t **)0;
#line 80
  opts[7].flags = 0;
#line 80
  opts[7].subopts = (cfg_opt_t *)0;
#line 80
  opts[7].def.number = 0L;
#line 80
  opts[7].def.fpnumber = (double )0;
#line 80
  opts[7].def.boolean = (cfg_bool_t )0;
#line 80
  opts[7].def.string = (char *)0;
#line 80
  opts[7].def.parsed = (char *)0;
#line 80
  opts[7].func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 80
  opts[7].simple_value = (void *)0;
#line 80
  opts[7].parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 80
  opts[7].validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 80
  opts[7].pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 80
  opts[7].freecb = (void (*)(void *value ))0;
#line 91
  tmp = cfg_init(opts, 0);
#line 91
  cfg___0 = tmp;
#line 92
  cfg_set_validate_func(cfg___0, "bookmark|port", & conf_validate_port);
#line 93
  cfg_set_validate_func(cfg___0, "bookmark", & conf_validate_bookmark);
#line 95
  tmp___0 = cfg_parse(cfg___0, filename);
  }
  {
#line 97
  if (tmp___0 == -1) {
#line 97
    goto case_neg_1;
  }
#line 101
  if (tmp___0 == 0) {
#line 101
    goto case_0;
  }
#line 103
  if (tmp___0 == 1) {
#line 103
    goto case_1;
  }
#line 95
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 98
  tmp___1 = __errno_location();
#line 98
  tmp___2 = strerror(*tmp___1);
#line 98
  printf((char const   */* __restrict  */)"warning: configuration file \'%s\' could not be read: %s\n",
         filename, tmp___2);
#line 100
  printf((char const   */* __restrict  */)"continuing with default values...\n\n");
  }
  case_0: /* CIL Label */ 
#line 102
  goto switch_break;
  case_1: /* CIL Label */ 
#line 104
  return ((cfg_t *)0);
  switch_break: /* CIL Label */ ;
  }
#line 107
  return (cfg___0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static int cfg_parse_internal___1(cfg_t *cfg___0 , int level , int force_state , cfg_opt_t *force_opt ) ;
#line 366 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_value_t *cfg_addval___1(cfg_opt_t *opt ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 368
  tmp = realloc((void *)opt->values, (unsigned long )(opt->nvalues + 1U) * sizeof(cfg_value_t *));
#line 368
  opt->values = (cfg_value_t **)tmp;
  }
#line 370
  if (! opt->values) {
    {
#line 370
    __assert_fail("opt->values", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  370U, "cfg_addval");
    }
  }
  {
#line 371
  tmp___0 = malloc(sizeof(cfg_value_t ));
#line 371
  *(opt->values + opt->nvalues) = (cfg_value_t *)tmp___0;
#line 372
  memset((void *)*(opt->values + opt->nvalues), 0, sizeof(cfg_value_t ));
#line 373
  tmp___1 = opt->nvalues;
#line 373
  (opt->nvalues) ++;
  }
#line 373
  return (*(opt->values + tmp___1));
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_opt_t *cfg_dupopt_array___1(cfg_opt_t *opts ) 
{ 
  int i ;
  cfg_opt_t *dupopts ;
  int n ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 389
  tmp = cfg_numopts(opts);
#line 389
  n = tmp;
#line 391
  tmp___0 = calloc((size_t )(n + 1), sizeof(cfg_opt_t ));
#line 391
  dupopts = (cfg_opt_t *)tmp___0;
#line 392
  memcpy((void */* __restrict  */)dupopts, (void const   */* __restrict  */)opts,
         (unsigned long )n * sizeof(cfg_opt_t ));
#line 394
  i = 0;
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i < n)) {
#line 394
      goto while_break;
    }
    {
#line 396
    (dupopts + i)->name = strdup((char const   *)(opts + i)->name);
    }
#line 397
    if ((unsigned int )(opts + i)->type == 5U) {
#line 397
      if ((opts + i)->subopts) {
        {
#line 398
        (dupopts + i)->subopts = cfg_dupopt_array___1((opts + i)->subopts);
        }
      }
    }
#line 400
    if ((2 & (opts + i)->flags) == 2) {
#line 400
      goto _L;
    } else
#line 400
    if ((unsigned int )(opts + i)->type == 6U) {
      _L: /* CIL Label */ 
#line 401
      if ((opts + i)->def.parsed) {
        {
#line 401
        tmp___1 = strdup((char const   *)(opts + i)->def.parsed);
#line 401
        (dupopts + i)->def.parsed = tmp___1;
        }
      } else {
#line 401
        (dupopts + i)->def.parsed = (char *)0;
      }
    } else
#line 402
    if ((unsigned int )(opts + i)->type == 3U) {
#line 403
      if ((opts + i)->def.string) {
        {
#line 403
        tmp___2 = strdup((char const   *)(opts + i)->def.string);
#line 403
        (dupopts + i)->def.string = tmp___2;
        }
      } else {
#line 403
        (dupopts + i)->def.string = (char *)0;
      }
    }
#line 394
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return (dupopts);
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_init_defaults___1(cfg_t *cfg___0 ) 
{ 
  int i ;
  int xstate ;
  int ret ;

  {
#line 426
  i = 0;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! (cfg___0->opts + i)->name) {
#line 426
      goto while_break;
    }
#line 429
    if ((cfg___0->opts + i)->simple_value) {
#line 430
      goto __Cont;
    } else
#line 429
    if ((16 & (cfg___0->opts + i)->flags) == 16) {
#line 430
      goto __Cont;
    }
#line 432
    if ((unsigned int )(cfg___0->opts + i)->type != 5U) {
#line 434
      (cfg___0->opts + i)->flags |= 128;
#line 436
      if ((2 & (cfg___0->opts + i)->flags) == 2) {
#line 436
        goto _L;
      } else
#line 436
      if ((cfg___0->opts + i)->def.parsed) {
        _L: /* CIL Label */ 
#line 444
        if ((unsigned long )(cfg___0->opts + i)->def.parsed == (unsigned long )((char *)0)) {
#line 446
          goto __Cont;
        } else
#line 444
        if ((int )*((cfg___0->opts + i)->def.parsed + 0) == 0) {
#line 446
          goto __Cont;
        }
#line 452
        if ((2 & (cfg___0->opts + i)->flags) == 2) {
#line 454
          xstate = 3;
        } else
#line 455
        if ((unsigned int )(cfg___0->opts + i)->type == 6U) {
#line 456
          xstate = 0;
        } else {
#line 458
          xstate = 2;
        }
        {
#line 460
        cfg_scan_string_begin((char const   *)(cfg___0->opts + i)->def.parsed);
        }
        {
#line 461
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 463
          ret = cfg_parse_internal___1(cfg___0, 1, xstate, cfg___0->opts + i);
#line 464
          xstate = -1;
          }
#line 461
          if (! (ret == 0)) {
#line 461
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 466
        cfg_scan_string_end();
        }
#line 467
        if (ret == 1) {
          {
#line 476
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parse error in default value \'%s\' for option \'%s\'\n",
                  (cfg___0->opts + i)->def.parsed, (cfg___0->opts + i)->name);
#line 479
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Check your initialization macros and the libConfuse documentation\n");
#line 481
          abort();
          }
        }
      } else {
        {
#line 488
        if ((unsigned int )(cfg___0->opts + i)->type == 1U) {
#line 488
          goto case_1;
        }
#line 492
        if ((unsigned int )(cfg___0->opts + i)->type == 2U) {
#line 492
          goto case_2;
        }
#line 496
        if ((unsigned int )(cfg___0->opts + i)->type == 4U) {
#line 496
          goto case_4;
        }
#line 500
        if ((unsigned int )(cfg___0->opts + i)->type == 3U) {
#line 500
          goto case_3;
        }
#line 505
        if ((unsigned int )(cfg___0->opts + i)->type == 7U) {
#line 505
          goto case_7;
        }
#line 505
        if ((unsigned int )(cfg___0->opts + i)->type == 6U) {
#line 505
          goto case_7;
        }
#line 507
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 489
        cfg_opt_setnint(cfg___0->opts + i, (cfg___0->opts + i)->def.number, 0U);
        }
#line 491
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 493
        cfg_opt_setnfloat(cfg___0->opts + i, (cfg___0->opts + i)->def.fpnumber, 0U);
        }
#line 495
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 497
        cfg_opt_setnbool(cfg___0->opts + i, (cfg___0->opts + i)->def.boolean, 0U);
        }
#line 499
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 501
        cfg_opt_setnstr(cfg___0->opts + i, (char const   *)(cfg___0->opts + i)->def.string,
                        0U);
        }
#line 503
        goto switch_break;
        case_7: /* CIL Label */ 
        case_6: /* CIL Label */ 
#line 506
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 508
        cfg_error(cfg___0, "internal error in cfg_init_defaults(%s)", (cfg___0->opts + i)->name);
        }
#line 511
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 520
      (cfg___0->opts + i)->flags |= 64;
    } else
#line 522
    if (! ((1 & (cfg___0->opts + i)->flags) == 1)) {
      {
#line 524
      cfg_setopt(cfg___0, cfg___0->opts + i, (char *)0);
#line 525
      (cfg___0->opts + i)->flags |= 128;
      }
    }
    __Cont: /* CIL Label */ 
#line 426
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  return;
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static int call_function___1(cfg_t *cfg___0 , cfg_opt_t *opt , cfg_opt_t *funcopt ) 
{ 
  int ret ;
  char const   **argv ;
  unsigned int i ;
  void *tmp ;

  {
  {
#line 760
  tmp = calloc((size_t )funcopt->nvalues, sizeof(char *));
#line 760
  argv = (char const   **)tmp;
#line 761
  i = 0U;
  }
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 761
    if (! (i < funcopt->nvalues)) {
#line 761
      goto while_break;
    }
#line 762
    *(argv + i) = (char const   *)(*(funcopt->values + i))->string;
#line 761
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 763
  ret = (*(opt->func))(cfg___0, opt, (int )funcopt->nvalues, argv);
#line 764
  cfg_free_value(funcopt);
#line 765
  free((void *)argv);
  }
#line 766
  return (ret);
}
}
#line 769 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static int cfg_parse_internal___1(cfg_t *cfg___0 , int level , int force_state , cfg_opt_t *force_opt ) 
{ 
  int state ;
  char *opttitle ;
  cfg_opt_t *opt ;
  cfg_value_t *val ;
  cfg_opt_t funcopt ;
  int num_values ;
  int rc ;
  int tok ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  cfg_value_t *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  cfg_value_t *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int ret ;
  int tmp___17 ;
  char *tmp___18 ;
  int ret___0 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
#line 772
  state = 0;
#line 773
  opttitle = (char *)0;
#line 774
  opt = (cfg_opt_t *)0;
#line 775
  val = (cfg_value_t *)0;
#line 776
  funcopt.name = (char *)0;
#line 776
  funcopt.type = (cfg_type_t )3;
#line 776
  funcopt.nvalues = 0U;
#line 776
  funcopt.values = (cfg_value_t **)0;
#line 776
  funcopt.flags = 0;
#line 776
  funcopt.subopts = (cfg_opt_t *)0;
#line 776
  funcopt.def.number = 0L;
#line 776
  funcopt.def.fpnumber = (double )0;
#line 776
  funcopt.def.boolean = (cfg_bool_t )0;
#line 776
  funcopt.def.string = (char *)0;
#line 776
  funcopt.def.parsed = (char *)0;
#line 776
  funcopt.func = (int (*)(cfg_t *cfg , cfg_opt_t *opt , int argc , char const   **argv ))0;
#line 776
  funcopt.simple_value = (void *)0;
#line 776
  funcopt.parsecb = (int (*)(cfg_t *cfg , cfg_opt_t *opt , char const   *value , void *result ))0;
#line 776
  funcopt.validcb = (int (*)(cfg_t *cfg , cfg_opt_t *opt ))0;
#line 776
  funcopt.pf = (void (*)(cfg_opt_t *opt , unsigned int index , FILE *fp ))0;
#line 776
  funcopt.freecb = (void (*)(void *value ))0;
#line 777
  num_values = 0;
#line 780
  if (force_state != -1) {
#line 781
    state = force_state;
  }
#line 782
  if (force_opt) {
#line 783
    opt = force_opt;
  }
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 787
    tmp = cfg_yylex(cfg___0);
#line 787
    tok = tmp;
    }
#line 789
    if (tok == 0) {
#line 792
      return (1);
    }
#line 795
    if (tok == -1) {
#line 797
      if (state != 0) {
        {
#line 799
        tmp___0 = dgettext("confuse", "premature end of file");
#line 799
        cfg_error(cfg___0, (char const   *)tmp___0);
        }
#line 800
        return (1);
      }
#line 802
      return (-1);
    }
    {
#line 807
    if (state == 0) {
#line 807
      goto case_0;
    }
#line 840
    if (state == 1) {
#line 840
      goto case_1;
    }
#line 876
    if (state == 2) {
#line 876
      goto case_2;
    }
#line 906
    if (state == 3) {
#line 906
      goto case_3;
    }
#line 926
    if (state == 4) {
#line 926
      goto case_4;
    }
#line 943
    if (state == 5) {
#line 943
      goto case_5;
    }
#line 967
    if (state == 6) {
#line 967
      goto case_6;
    }
#line 979
    if (state == 7) {
#line 979
      goto case_7;
    }
#line 989
    if (state == 8) {
#line 989
      goto case_8;
    }
#line 1011
    if (state == 9) {
#line 1011
      goto case_9;
    }
#line 1029
    goto switch_default;
    case_0: /* CIL Label */ 
#line 808
    if (tok == 125) {
#line 810
      if (level == 0) {
        {
#line 812
        tmp___1 = dgettext("confuse", "unexpected closing brace");
#line 812
        cfg_error(cfg___0, (char const   *)tmp___1);
        }
#line 813
        return (1);
      }
#line 815
      return (-1);
    }
#line 817
    if (tok != 3) {
      {
#line 819
      tmp___2 = dgettext("confuse", "unexpected token \'%s\'");
#line 819
      cfg_error(cfg___0, (char const   *)tmp___2, cfg_yylval);
      }
#line 820
      return (1);
    }
    {
#line 822
    opt = cfg_getopt(cfg___0, (char const   *)cfg_yylval);
    }
#line 823
    if ((unsigned long )opt == (unsigned long )((cfg_opt_t *)0)) {
#line 824
      return (1);
    }
#line 825
    if ((unsigned int )opt->type == 5U) {
#line 827
      if ((8 & opt->flags) == 8) {
#line 828
        state = 6;
      } else {
#line 830
        state = 5;
      }
    } else
#line 832
    if ((unsigned int )opt->type == 6U) {
#line 834
      state = 7;
    } else {
#line 837
      state = 1;
    }
#line 838
    goto switch_break;
    case_1: /* CIL Label */ 
#line 841
    if (tok == 43) {
#line 843
      if (! ((2 & opt->flags) == 2)) {
        {
#line 845
        tmp___3 = dgettext("confuse", "attempt to append to non-list option \'%s\'");
#line 845
        cfg_error(cfg___0, (char const   *)tmp___3, opt->name);
        }
#line 848
        return (1);
      }
#line 854
      opt->flags &= -65;
    } else
#line 856
    if (tok == 61) {
#line 860
      opt->flags |= 64;
    } else {
      {
#line 864
      tmp___4 = dgettext("confuse", "missing equal sign after option \'%s\'");
#line 864
      cfg_error(cfg___0, (char const   *)tmp___4, opt->name);
      }
#line 866
      return (1);
    }
#line 868
    if ((2 & opt->flags) == 2) {
#line 870
      state = 3;
#line 871
      num_values = 0;
    } else {
#line 873
      state = 2;
    }
#line 874
    goto switch_break;
    case_2: /* CIL Label */ 
#line 877
    if (tok == 125) {
#line 877
      if ((2 & opt->flags) == 2) {
#line 879
        state = 0;
#line 880
        if (num_values == 0) {
#line 880
          if ((64 & opt->flags) == 64) {
            {
#line 883
            cfg_free_value(opt);
            }
          }
        }
#line 884
        goto switch_break;
      }
    }
#line 887
    if (tok != 3) {
      {
#line 889
      tmp___5 = dgettext("confuse", "unexpected token \'%s\'");
#line 889
      cfg_error(cfg___0, (char const   *)tmp___5, cfg_yylval);
      }
#line 890
      return (1);
    }
    {
#line 893
    tmp___6 = cfg_setopt(cfg___0, opt, cfg_yylval);
    }
#line 893
    if ((unsigned long )tmp___6 == (unsigned long )((cfg_value_t *)0)) {
#line 894
      return (1);
    }
#line 895
    if (opt->validcb) {
      {
#line 895
      tmp___7 = (*(opt->validcb))(cfg___0, opt);
      }
#line 895
      if (tmp___7 != 0) {
#line 896
        return (1);
      }
    }
#line 897
    if ((2 & opt->flags) == 2) {
#line 899
      num_values ++;
#line 900
      state = 4;
    } else {
#line 903
      state = 0;
    }
#line 904
    goto switch_break;
    case_3: /* CIL Label */ 
#line 907
    if (tok != 123) {
#line 909
      if (tok != 3) {
        {
#line 911
        tmp___8 = dgettext("confuse", "unexpected token \'%s\'");
#line 911
        cfg_error(cfg___0, (char const   *)tmp___8, cfg_yylval);
        }
#line 912
        return (1);
      }
      {
#line 915
      tmp___9 = cfg_setopt(cfg___0, opt, cfg_yylval);
      }
#line 915
      if ((unsigned long )tmp___9 == (unsigned long )((cfg_value_t *)0)) {
#line 916
        return (1);
      }
#line 917
      if (opt->validcb) {
        {
#line 917
        tmp___10 = (*(opt->validcb))(cfg___0, opt);
        }
#line 917
        if (tmp___10 != 0) {
#line 918
          return (1);
        }
      }
#line 919
      num_values ++;
#line 920
      state = 0;
    } else {
#line 923
      state = 2;
    }
#line 924
    goto switch_break;
    case_4: /* CIL Label */ 
#line 928
    if (tok == 44) {
#line 929
      state = 2;
    } else
#line 930
    if (tok == 125) {
#line 932
      state = 0;
#line 933
      if (opt->validcb) {
        {
#line 933
        tmp___11 = (*(opt->validcb))(cfg___0, opt);
        }
#line 933
        if (tmp___11 != 0) {
#line 934
          return (1);
        }
      }
    } else {
      {
#line 938
      tmp___12 = dgettext("confuse", "unexpected token \'%s\'");
#line 938
      cfg_error(cfg___0, (char const   *)tmp___12, cfg_yylval);
      }
#line 939
      return (1);
    }
#line 941
    goto switch_break;
    case_5: /* CIL Label */ 
#line 944
    if (tok != 123) {
      {
#line 946
      tmp___13 = dgettext("confuse", "missing opening brace for section \'%s\'");
#line 946
      cfg_error(cfg___0, (char const   *)tmp___13, opt->name);
      }
#line 948
      return (1);
    }
    {
#line 951
    val = cfg_setopt(cfg___0, opt, opttitle);
#line 952
    opttitle = (char *)0;
    }
#line 953
    if (! val) {
#line 954
      return (1);
    }
    {
#line 956
    (val->section)->line = cfg___0->line;
#line 957
    (val->section)->errfunc = cfg___0->errfunc;
#line 958
    rc = cfg_parse_internal___1(val->section, level + 1, -1, (cfg_opt_t *)0);
#line 959
    cfg___0->line = (val->section)->line;
    }
#line 960
    if (rc != -1) {
#line 961
      return (1);
    }
#line 962
    if (opt->validcb) {
      {
#line 962
      tmp___14 = (*(opt->validcb))(cfg___0, opt);
      }
#line 962
      if (tmp___14 != 0) {
#line 963
        return (1);
      }
    }
#line 964
    state = 0;
#line 965
    goto switch_break;
    case_6: /* CIL Label */ 
#line 968
    if (tok != 3) {
      {
#line 970
      tmp___15 = dgettext("confuse", "missing title for section \'%s\'");
#line 970
      cfg_error(cfg___0, (char const   *)tmp___15, opt->name);
      }
#line 972
      return (1);
    } else {
      {
#line 975
      opttitle = strdup((char const   *)cfg_yylval);
      }
    }
#line 976
    state = 5;
#line 977
    goto switch_break;
    case_7: /* CIL Label */ 
#line 980
    if (tok != 40) {
      {
#line 982
      tmp___16 = dgettext("confuse", "missing parenthesis for function \'%s\'");
#line 982
      cfg_error(cfg___0, (char const   *)tmp___16, opt->name);
      }
#line 984
      return (1);
    }
#line 986
    state = 8;
#line 987
    goto switch_break;
    case_8: /* CIL Label */ 
#line 990
    if (tok == 41) {
      {
#line 992
      tmp___17 = call_function___1(cfg___0, opt, & funcopt);
#line 992
      ret = tmp___17;
      }
#line 993
      if (ret != 0) {
#line 994
        return (1);
      }
#line 995
      state = 0;
    } else
#line 997
    if (tok == 3) {
      {
#line 999
      val = cfg_addval___1(& funcopt);
#line 1000
      val->string = strdup((char const   *)cfg_yylval);
#line 1001
      state = 9;
      }
    } else {
      {
#line 1005
      tmp___18 = dgettext("confuse", "syntax error in call of function \'%s\'");
#line 1005
      cfg_error(cfg___0, (char const   *)tmp___18, opt->name);
      }
#line 1007
      return (1);
    }
#line 1009
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1012
    if (tok == 41) {
      {
#line 1014
      tmp___19 = call_function___1(cfg___0, opt, & funcopt);
#line 1014
      ret___0 = tmp___19;
      }
#line 1015
      if (ret___0 != 0) {
#line 1016
        return (1);
      }
#line 1017
      state = 0;
    } else
#line 1019
    if (tok == 44) {
#line 1020
      state = 8;
    } else {
      {
#line 1023
      tmp___20 = dgettext("confuse", "syntax error in call of function \'%s\'");
#line 1023
      cfg_error(cfg___0, (char const   *)tmp___20, opt->name);
      }
#line 1025
      return (1);
    }
#line 1027
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1031
    __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1031U, "cfg_parse_internal");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1035
  return (-1);
}
}
#line 1188 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_free_opt_array___1(cfg_opt_t *opts ) 
{ 
  int i ;

  {
#line 1192
  i = 0;
  {
#line 1192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1192
    if (! (opts + i)->name) {
#line 1192
      goto while_break;
    }
    {
#line 1194
    free((void *)(opts + i)->name);
    }
#line 1195
    if ((unsigned int )(opts + i)->type == 6U) {
      {
#line 1196
      free((void *)(opts + i)->def.parsed);
      }
    } else
#line 1195
    if ((2 & (opts + i)->flags) == 2) {
      {
#line 1196
      free((void *)(opts + i)->def.parsed);
      }
    } else
#line 1197
    if ((unsigned int )(opts + i)->type == 3U) {
      {
#line 1198
      free((void *)(opts + i)->def.string);
      }
    } else
#line 1199
    if ((unsigned int )(opts + i)->type == 5U) {
      {
#line 1200
      cfg_free_opt_array___1((opts + i)->subopts);
      }
    }
#line 1192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1202
  free((void *)opts);
  }
#line 1203
  return;
}
}
#line 1236 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_value_t *cfg_opt_getval___1(cfg_opt_t *opt , unsigned int index___0 ) 
{ 
  cfg_value_t *val ;

  {
#line 1238
  val = (cfg_value_t *)0;
#line 1240
  if (! (index___0 == 0U)) {
#line 1240
    if (! ((2 & opt->flags) == 2)) {
      {
#line 1240
      __assert_fail("index == 0 || (((2) & (opt->flags)) == (2))", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1240U, "cfg_opt_getval");
      }
    }
  }
#line 1242
  if (opt->simple_value) {
#line 1243
    val = (cfg_value_t *)opt->simple_value;
  } else {
#line 1246
    if ((64 & opt->flags) == 64) {
      {
#line 1248
      cfg_free_value(opt);
#line 1249
      opt->flags &= -65;
      }
    }
#line 1252
    if (index___0 >= opt->nvalues) {
      {
#line 1253
      val = cfg_addval___1(opt);
      }
    } else {
#line 1255
      val = *(opt->values + index___0);
    }
  }
#line 1257
  return (val);
}
}
#line 1341 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_addlist_internal___1(cfg_opt_t *opt , unsigned int nvalues , va_list ap ) 
{ 
  unsigned int i ;
  int tmp___0 ;
  double tmp___2 ;
  cfg_bool_t tmp___4 ;
  char *tmp___6 ;

  {
#line 1346
  i = 0U;
  {
#line 1346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1346
    if (! (i < nvalues)) {
#line 1346
      goto while_break;
    }
    {
#line 1350
    if ((unsigned int )opt->type == 1U) {
#line 1350
      goto case_1;
    }
#line 1353
    if ((unsigned int )opt->type == 2U) {
#line 1353
      goto case_2;
    }
#line 1357
    if ((unsigned int )opt->type == 4U) {
#line 1357
      goto case_4;
    }
#line 1361
    if ((unsigned int )opt->type == 3U) {
#line 1361
      goto case_3;
    }
#line 1366
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1351
    tmp___0 = __builtin_va_arg(ap, int );
#line 1351
    cfg_opt_setnint(opt, (long )tmp___0, opt->nvalues);
    }
#line 1352
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1354
    tmp___2 = __builtin_va_arg(ap, double );
#line 1354
    cfg_opt_setnfloat(opt, tmp___2, opt->nvalues);
    }
#line 1356
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1358
    tmp___4 = __builtin_va_arg(ap, cfg_bool_t );
#line 1358
    cfg_opt_setnbool(opt, tmp___4, opt->nvalues);
    }
#line 1360
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1362
    tmp___6 = __builtin_va_arg(ap, char *);
#line 1362
    cfg_opt_setnstr(opt, (char const   *)tmp___6, opt->nvalues);
    }
#line 1363
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1367
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1370
  return;
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static void cfg_indent___1(FILE *fp , int indent ) 
{ 
  int tmp ;

  {
  {
#line 1440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1440
    tmp = indent;
#line 1440
    indent --;
#line 1440
    if (! tmp) {
#line 1440
      goto while_break;
    }
    {
#line 1441
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1442
  return;
}
}
#line 1562 "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c"
static cfg_opt_t *cfg_getopt_array___1(cfg_opt_t *rootopts , int cfg_flags , char const   *name ) 
{ 
  unsigned int i ;
  cfg_opt_t *opts ;
  cfg_t *seccfg ;
  char *secname ;
  size_t len ;
  size_t tmp ;
  cfg_opt_t *secopt ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1565
  opts = rootopts;
#line 1567
  if (rootopts) {
#line 1567
    if (! name) {
      {
#line 1567
      __assert_fail("rootopts && name", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                    1567U, "cfg_getopt_array");
      }
    }
  } else {
    {
#line 1567
    __assert_fail("rootopts && name", "/home/june/repo/benchmarks/collector/temp/confuse-2.7/src/confuse.c",
                  1567U, "cfg_getopt_array");
    }
  }
  {
#line 1569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1569
    if (name) {
#line 1569
      if (! *name) {
#line 1569
        goto while_break;
      }
    } else {
#line 1569
      goto while_break;
    }
    {
#line 1573
    tmp = strcspn(name, "|");
#line 1573
    len = tmp;
    }
#line 1574
    if ((int const   )*(name + len) == 0) {
#line 1576
      goto while_break;
    }
#line 1577
    if (len) {
      {
#line 1580
      secname = strndup(name, len);
#line 1581
      secopt = cfg_getopt_array___1(opts, cfg_flags, (char const   *)secname);
#line 1582
      free((void *)secname);
      }
#line 1583
      if ((unsigned long )secopt == (unsigned long )((cfg_opt_t *)0)) {
#line 1586
        return ((cfg_opt_t *)0);
      }
#line 1588
      if ((unsigned int )secopt->type != 5U) {
#line 1591
        return ((cfg_opt_t *)0);
      }
#line 1594
      if (! ((1 & secopt->flags) == 1)) {
        {
#line 1594
        seccfg = cfg_opt_getnsec(secopt, 0U);
        }
#line 1594
        if ((unsigned long )seccfg != (unsigned long )((cfg_t *)0)) {
#line 1597
          opts = seccfg->opts;
        } else {
#line 1600
          opts = secopt->subopts;
        }
      } else {
#line 1600
        opts = secopt->subopts;
      }
#line 1601
      if ((unsigned long )opts == (unsigned long )((cfg_opt_t *)0)) {
#line 1604
        return ((cfg_opt_t *)0);
      }
    }
    {
#line 1607
    name += len;
#line 1608
    tmp___0 = strspn(name, "|");
#line 1608
    name += tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1611
  i = 0U;
  {
#line 1611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1611
    if (! (opts + i)->name) {
#line 1611
      goto while_break___0;
    }
#line 1613
    if ((4 & cfg_flags) == 4) {
      {
#line 1615
      tmp___1 = strcasecmp((char const   *)(opts + i)->name, name);
      }
#line 1615
      if (tmp___1 == 0) {
#line 1616
        return (opts + i);
      }
    } else {
      {
#line 1620
      tmp___2 = strcmp((char const   *)(opts + i)->name, name);
      }
#line 1620
      if (tmp___2 == 0) {
#line 1621
        return (opts + i);
      }
    }
#line 1611
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1624
  return ((cfg_opt_t *)0);
}
}
