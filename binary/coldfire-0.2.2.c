/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 21 "../tracer/tracer.h"
struct _TRACER_Info {
   char *Name ;
   char Enabled ;
};
#line 32
enum _TRACER_Channels {
    TRACER_ea = 0,
    TRACER_exception = 1,
    TRACER_handlers = 2,
    TRACER_i = 3,
    TRACER_i_add = 4,
    TRACER_i_adda = 5,
    TRACER_i_addi = 6,
    TRACER_i_addq = 7,
    TRACER_i_addx = 8,
    TRACER_i_and = 9,
    TRACER_i_andi = 10,
    TRACER_i_asx = 11,
    TRACER_i_bcc = 12,
    TRACER_i_btst = 13,
    TRACER_i_clr = 14,
    TRACER_i_cmp = 15,
    TRACER_i_cmpa = 16,
    TRACER_i_cmpi = 17,
    TRACER_i_dc = 18,
    TRACER_i_div = 19,
    TRACER_i_eor = 20,
    TRACER_i_eori = 21,
    TRACER_i_ext = 22,
    TRACER_i_halt = 23,
    TRACER_i_illegal = 24,
    TRACER_i_jmp = 25,
    TRACER_i_jsr = 26,
    TRACER_i_lea = 27,
    TRACER_i_link = 28,
    TRACER_i_lsx = 29,
    TRACER_i_move = 30,
    TRACER_i_movec = 31,
    TRACER_i_movem = 32,
    TRACER_i_moveq = 33,
    TRACER_i_movexr = 34,
    TRACER_i_mulu_l = 35,
    TRACER_i_mul_w = 36,
    TRACER_i_neg = 37,
    TRACER_i_negx = 38,
    TRACER_i_nop = 39,
    TRACER_i_not = 40,
    TRACER_i_or = 41,
    TRACER_i_ori = 42,
    TRACER_i_pea = 43,
    TRACER_i_rte = 44,
    TRACER_i_rts = 45,
    TRACER_isa = 46,
    TRACER_i_scc = 47,
    TRACER_i_stop = 48,
    TRACER_i_sub = 49,
    TRACER_i_suba = 50,
    TRACER_i_subi = 51,
    TRACER_i_subq = 52,
    TRACER_i_subx = 53,
    TRACER_i_swap = 54,
    TRACER_i_trap = 55,
    TRACER_i_trapf = 56,
    TRACER_i_tst = 57,
    TRACER_i_unlk = 58,
    TRACER_main = 59,
    TRACER_memory = 60,
    TRACER_misc = 61,
    TRACER_monitor = 62,
    TRACER_network = 63,
    TRACER_ram = 64,
    TRACER_run = 65,
    TRACER_serial = 66,
    TRACER_sim = 67,
    TRACER_timer = 68,
    TRACER_Last = 69
} ;
#line 10 "../addressing.h"
struct _Address {
   short Size ;
   char Mode ;
   char Register ;
   unsigned long Address ;
   unsigned long Data ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
struct _PEA_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 10 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
union _PEA_instr {
   struct _PEA_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
typedef union _PEA_instr PEA_Instr;
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
struct _LINK_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
union _LINK_instr {
   struct _LINK_bits Bits ;
   unsigned long Code ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
typedef union _LINK_instr LINK_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
struct _ADDA_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code2 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
union _ADDA_instr {
   struct _ADDA_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
typedef union _ADDA_instr ADDA_Instr;
#line 15 "../memory.h"
struct _memory_core {
   unsigned long pc ;
   unsigned long pc_instruction_begin ;
   unsigned long sr ;
   unsigned long mbar ;
   unsigned long rambar ;
   unsigned long rombar ;
   unsigned long vbr ;
   unsigned long cacr ;
   unsigned long d[8] ;
   unsigned long a[8] ;
};
#line 31 "../memory.h"
struct _SR {
   unsigned int C : 1 ;
   unsigned int V : 1 ;
   unsigned int Z : 1 ;
   unsigned int N : 1 ;
   unsigned int X : 1 ;
   unsigned int Unused : 3 ;
   unsigned int InterruptPriorityMask : 3 ;
   unsigned int Unused2 : 1 ;
   unsigned int M : 1 ;
   unsigned int S : 1 ;
   unsigned int Unused3 : 1 ;
   unsigned int T : 1 ;
   unsigned int pad : 16 ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
struct _MOVEC_bits {
   unsigned int ControlRegister : 12 ;
   unsigned int Register : 3 ;
   unsigned int AD : 1 ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
union _MOVEC_instr {
   struct _MOVEC_bits Bits ;
   unsigned long Code ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
typedef union _MOVEC_instr MOVEC_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
struct _HALT_bits {
   unsigned int Code : 16 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
union _HALT_instr {
   struct _HALT_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
typedef union _HALT_instr HALT_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
struct _TST_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Size : 2 ;
   unsigned int Code1 : 8 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
union _TST_instr {
   struct _TST_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
typedef union _TST_instr TST_Instr;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
struct _ADDX_bits {
   unsigned int RegisterDy : 3 ;
   unsigned int Code1 : 6 ;
   unsigned int RegisterDx : 3 ;
   unsigned int Code2 : 4 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
union _ADDX_instr {
   struct _ADDX_bits Bits ;
   unsigned long Code ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
typedef union _ADDX_instr ADDX_Instr;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
struct _MUL_W_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 2 ;
   unsigned int US : 1 ;
   unsigned int Register : 3 ;
   unsigned int Code2 : 4 ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
union _MUL_W_instr {
   struct _MUL_W_bits Bits ;
   unsigned long Code ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
typedef union _MUL_W_instr MUL_W_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
struct _SUBX_bits {
   unsigned int RegisterDy : 3 ;
   unsigned int Code1 : 6 ;
   unsigned int RegisterDx : 3 ;
   unsigned int Code2 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
union _SUBX_instr {
   struct _SUBX_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
typedef union _SUBX_instr SUBX_Instr;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
struct _STOP_bits {
   unsigned int Code1 : 16 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
union _STOP_instr {
   struct _STOP_bits Bits ;
   unsigned long Code ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
typedef union _STOP_instr STOP_Instr;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
struct _MOVE_bits {
   unsigned int SourceRegister : 3 ;
   unsigned int SourceMode : 3 ;
   unsigned int DestMode : 3 ;
   unsigned int DestRegister : 3 ;
   unsigned int Size : 2 ;
   unsigned int Code1 : 2 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
union _MOVE_instr {
   struct _MOVE_bits Bits ;
   unsigned long Code ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
typedef union _MOVE_instr MOVE_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
struct _OR_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int OPMode : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code1 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
union _OR_instr {
   struct _OR_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
typedef union _OR_instr OR_Instr;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
struct _CMPI_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
union _CMPI_instr {
   struct _CMPI_bits Bits ;
   unsigned long Code ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
typedef union _CMPI_instr CMPI_Instr;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
struct _EXT_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 3 ;
   unsigned int OPMode : 3 ;
   unsigned int Code2 : 7 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
union _EXT_instr {
   struct _EXT_bits Bits ;
   unsigned long Code ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
typedef union _EXT_instr EXT_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
struct _LEA_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code2 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
union _LEA_instr {
   struct _LEA_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
typedef union _LEA_instr LEA_Instr;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
struct _SCC_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 5 ;
   unsigned int Condition : 4 ;
   unsigned int Code2 : 4 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
union _SCC_instr {
   struct _SCC_bits Bits ;
   unsigned long Code ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
typedef union _SCC_instr SCC_Instr;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
struct _EOR_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int OPMode : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code1 : 4 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
union _EOR_instr {
   struct _EOR_bits Bits ;
   unsigned long Code ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
typedef union _EOR_instr EOR_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
struct _ASX_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 2 ;
   unsigned int IR : 1 ;
   unsigned int Code2 : 2 ;
   unsigned int DR : 1 ;
   unsigned int CountReg : 3 ;
   unsigned int Code3 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
union _ASX_instr {
   struct _ASX_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
typedef union _ASX_instr ASX_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
struct _CLR_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Size : 2 ;
   unsigned int Code1 : 8 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
union _CLR_instr {
   struct _CLR_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
typedef union _CLR_instr CLR_Instr;
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
struct _MULU_L_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 10 ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
union _MULU_L_instr {
   struct _MULU_L_bits Bits ;
   unsigned long Code ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
typedef union _MULU_L_instr MULU_L_Instr;
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
struct _AND_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int OPMode : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code1 : 4 ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
union _AND_instr {
   struct _AND_bits Bits ;
   unsigned long Code ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
typedef union _AND_instr AND_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
struct _MOVEQ_bits {
   int Data : 8 ;
   unsigned int Code1 : 1 ;
   unsigned int Register : 3 ;
   unsigned int Code2 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
union _MOVEQ_instr {
   struct _MOVEQ_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
typedef union _MOVEQ_instr MOVEQ_Instr;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
struct _ORI_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
union _ORI_instr {
   struct _ORI_bits Bits ;
   unsigned long Code ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
typedef union _ORI_instr ORI_Instr;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
struct _SUBI_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
union _SUBI_instr {
   struct _SUBI_bits Bits ;
   unsigned long Code ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
typedef union _SUBI_instr SUBI_Instr;
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
struct _MOVEM_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 4 ;
   unsigned int Direction : 1 ;
   unsigned int Code2 : 5 ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
union _MOVEM_instr {
   struct _MOVEM_bits Bits ;
   unsigned long Code ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
typedef union _MOVEM_instr MOVEM_Instr;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
struct _CMPA_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code2 : 4 ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
union _CMPA_instr {
   struct _CMPA_bits Bits ;
   unsigned long Code ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
typedef union _CMPA_instr CMPA_Instr;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
struct _ADD_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int OPMode : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code1 : 4 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
union _ADD_instr {
   struct _ADD_bits Bits ;
   unsigned long Code ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
typedef union _ADD_instr ADD_Instr;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
struct _ANDI_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
union _ANDI_instr {
   struct _ANDI_bits Bits ;
   unsigned long Code ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
typedef union _ANDI_instr ANDI_Instr;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
struct _SUB_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int OPMode : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code1 : 4 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
union _SUB_instr {
   struct _SUB_bits Bits ;
   unsigned long Code ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
typedef union _SUB_instr SUB_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
struct _SWAP_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
union _SWAP_instr {
   struct _SWAP_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
typedef union _SWAP_instr SWAP_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
struct _TRAP_bits {
   unsigned int Vector : 4 ;
   unsigned int Code1 : 12 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
union _TRAP_instr {
   struct _TRAP_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
typedef union _TRAP_instr TRAP_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
struct _ADDQ_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 3 ;
   unsigned int Data : 3 ;
   unsigned int Code2 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
union _ADDQ_instr {
   struct _ADDQ_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
typedef union _ADDQ_instr ADDQ_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
struct _JSR_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 10 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
union _JSR_instr {
   struct _JSR_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
typedef union _JSR_instr JSR_Instr;
#line 38 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
struct _BTST_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int OP : 2 ;
   unsigned int Dynamic : 1 ;
   unsigned int Register : 3 ;
   unsigned int Code2 : 4 ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
union _BTST_instr {
   struct _BTST_bits Bits ;
   unsigned long Code ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
typedef union _BTST_instr BTST_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
struct _LSX_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 2 ;
   unsigned int IR : 1 ;
   unsigned int Code2 : 2 ;
   unsigned int DR : 1 ;
   unsigned int CountReg : 3 ;
   unsigned int Code3 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
union _LSX_instr {
   struct _LSX_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
typedef union _LSX_instr LSX_Instr;
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
struct _CMP_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code2 : 4 ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
union _CMP_instr {
   struct _CMP_bits Bits ;
   unsigned long Code ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
typedef union _CMP_instr CMP_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
struct _ADDI_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
union _ADDI_instr {
   struct _ADDI_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
typedef union _ADDI_instr ADDI_Instr;
#line 41 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
struct _MOVEXR_bits {
   unsigned int Register : 3 ;
   unsigned int Mode : 3 ;
   unsigned int Code1 : 3 ;
   unsigned int Reg : 1 ;
   unsigned int To : 1 ;
   unsigned int Code2 : 5 ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
union _MOVEXR_instr {
   struct _MOVEXR_bits Bits ;
   unsigned long Code ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
typedef union _MOVEXR_instr MOVEXR_Instr;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
struct _BCC_bits {
   int Displacement : 8 ;
   unsigned int Condition : 4 ;
   unsigned int Code1 : 4 ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
union _BCC_instr {
   struct _BCC_bits Bits ;
   unsigned long Code ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
typedef union _BCC_instr BCC_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
struct _NEGX_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
union _NEGX_instr {
   struct _NEGX_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
typedef union _NEGX_instr NEGX_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
struct _UNLK_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
union _UNLK_instr {
   struct _UNLK_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
typedef union _UNLK_instr UNLK_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
struct _SUBQ_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 3 ;
   unsigned int Data : 3 ;
   unsigned int Code2 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
union _SUBQ_instr {
   struct _SUBQ_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
typedef union _SUBQ_instr SUBQ_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
struct _NOT_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
union _NOT_instr {
   struct _NOT_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
typedef union _NOT_instr NOT_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
struct _EORI_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
union _EORI_instr {
   struct _EORI_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
typedef union _EORI_instr EORI_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
struct _JMP_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 10 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
union _JMP_instr {
   struct _JMP_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
typedef union _JMP_instr JMP_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
struct _SUBA_bits {
   unsigned int EARegister : 3 ;
   unsigned int EAMode : 3 ;
   unsigned int Code1 : 3 ;
   unsigned int Register : 3 ;
   unsigned int Code2 : 4 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
union _SUBA_instr {
   struct _SUBA_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
typedef union _SUBA_instr SUBA_Instr;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
struct _TRAPF_bits {
   unsigned int OpMode : 3 ;
   unsigned int Code1 : 13 ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
union _TRAPF_instr {
   struct _TRAPF_bits Bits ;
   unsigned long Code ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
typedef union _TRAPF_instr TRAPF_Instr;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
struct _NEG_bits {
   unsigned int Register : 3 ;
   unsigned int Code1 : 13 ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
union _NEG_instr {
   struct _NEG_bits Bits ;
   unsigned long Code ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
typedef union _NEG_instr NEG_Instr;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 26 "../tracer/tracer.h"
struct _TRACER_Info TRACER_Info[70] ;
#line 28
int tracer_printf(char *msg  , ...) ;
#line 89 "../memory.h"
extern char Memory_RetrFromPC(unsigned long *Result , short Size ) ;
#line 21 "../addressing.h"
extern long Addressing_Print(short Size , char Mode , char Register , char *Str ) ;
#line 23
extern char EA_GetFromPC(struct _Address *Addr , short Size , char Mode , char Register ) ;
#line 25
extern char EA_GetEA(unsigned long *Result , struct _Address *Addr ) ;
#line 29
extern void Stack_Push(short Size , unsigned long Value ) ;
#line 47 "../i_5206/i_5206.h"
long pea_5206_register(void) ;
#line 158 "../coldfire.h"
extern void cycle(unsigned long number ) ;
#line 159
extern int cycle_EA(short reg , short mode ) ;
#line 176
extern void instruction_register(unsigned short code , unsigned short mask , void (*execute)(void) ,
                                 long (*disassemble)(char * , char * , char * ) ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
int PEATime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
  {      -1,      2,      -1,      -1, 
        2,      3,      2,      -1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
static enum _TRACER_Channels  const  TRACER_default  =    (enum _TRACER_Channels  const  )43;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
static void execute(void) 
{ 
  struct _Address Source ;
  unsigned long SValue ;
  PEA_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 39
  if (TRACER_Info[TRACER_default].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default].Name, "execute");
#line 39
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 40
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 40
  if (! tmp) {
#line 40
    return;
  }
  {
#line 41
  EA_GetEA(& SValue, & Source);
  }
#line 42
  if (TRACER_Info[TRACER_default].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default].Name, "execute");
#line 42
    tracer_printf((char *)"Pusing 0x%08lx to the stack\n", SValue);
    }
  }
  {
#line 43
  Stack_Push((short)32, SValue);
  }
#line 45
  if (TRACER_Info[TRACER_default].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default].Name, "execute");
#line 45
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 47
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 47
  cycle((unsigned long )PEATime[tmp___0]);
  }
#line 49
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
static long disassemble(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  PEA_Instr Instr ;

  {
  {
#line 55
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 56
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"PEA");
#line 57
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 58
  *(Arg2 + 0) = (char)0;
  }
#line 59
  return (0L);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
long pea_5206_register(void) 
{ 


  {
  {
#line 64
  instruction_register((unsigned short)18496, (unsigned short)65472, & execute, & disassemble);
  }
#line 65
  return (1L);
}
}
#line 24 "../addressing.h"
extern char EA_GetValue(unsigned long *Result , struct _Address *Addr ) ;
#line 27
extern void EA_PutValue(struct _Address *Addr , unsigned long Value ) ;
#line 32 "../i_5206/i_5206.h"
long link_5206_register(void) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
int LINKTime  =    2;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
static enum _TRACER_Channels  const  TRACER_default___0  =    (enum _TRACER_Channels  const  )28;
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
static void execute___0(void) 
{ 
  unsigned long Displacement ;
  struct _Address ARegister ;
  struct _Address Stack ;
  unsigned long StackValue ;
  LINK_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 40
  Memory_RetrFromPC(& Displacement, (short)16);
#line 41
  Displacement = (unsigned long )((short )Displacement);
  }
#line 43
  if (TRACER_Info[TRACER_default___0].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___0].Name, "execute");
#line 43
    tracer_printf((char *)"Retrieving ARegister\n");
    }
  }
  {
#line 45
  tmp = EA_GetFromPC(& ARegister, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 45
  if (! tmp) {
#line 45
    return;
  }
#line 46
  if (TRACER_Info[TRACER_default___0].Enabled) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___0].Name, "execute");
#line 46
    tracer_printf((char *)"Pushing ARegister onto stack\n");
    }
  }
  {
#line 47
  EA_GetValue(& StackValue, & ARegister);
#line 48
  Stack_Push((short)32, StackValue);
  }
#line 51
  if (TRACER_Info[TRACER_default___0].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___0].Name, "execute");
#line 51
    tracer_printf((char *)"Retrieving Stack Pointer\n");
    }
  }
  {
#line 52
  tmp___0 = EA_GetFromPC(& Stack, (short)32, (char)1, (char)7);
  }
#line 52
  if (! tmp___0) {
#line 52
    return;
  }
  {
#line 53
  EA_GetValue(& StackValue, & Stack);
  }
#line 54
  if (TRACER_Info[TRACER_default___0].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___0].Name, "execute");
#line 54
    tracer_printf((char *)"Storing Stack Pointer=0x%08lx in the ARegister\n", StackValue);
    }
  }
  {
#line 55
  EA_PutValue(& ARegister, StackValue);
  }
#line 60
  if (TRACER_Info[TRACER_default___0].Enabled) {
    {
#line 60
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___0].Name, "execute");
#line 60
    tracer_printf((char *)"Displacing Stack Pointer by 0x%04lx to 0x%08lx\n", Displacement,
                  StackValue + Displacement);
    }
  }
  {
#line 61
  EA_PutValue(& Stack, StackValue + Displacement);
  }
#line 63
  if (TRACER_Info[TRACER_default___0].Enabled) {
    {
#line 63
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___0].Name, "execute");
#line 63
    tracer_printf((char *)"Done");
    }
  }
  {
#line 65
  cycle((unsigned long )LINKTime);
  }
#line 67
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
static long disassemble___0(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  LINK_Instr Instr ;
  unsigned long Displacement ;

  {
  {
#line 74
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 75
  Memory_RetrFromPC(& Displacement, (short)16);
#line 77
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"LINK");
#line 78
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg1);
#line 80
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"#%hd",
          (int )((short )Displacement));
  }
#line 82
  return (0L);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
long link_5206_register(void) 
{ 


  {
  {
#line 87
  instruction_register((unsigned short)20048, (unsigned short)65528, & execute___0,
                       & disassemble___0);
  }
#line 88
  return (1L);
}
}
#line 10 "../i_5206/i_5206.h"
long adda_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
int ADDATime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
  {      -1,      3,      3,      3, 
        3,      4,      3,      -1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
static enum _TRACER_Channels  const  TRACER_default___1  =    (enum _TRACER_Channels  const  )5;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
static void execute___1(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ADDA_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___1].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___1].Name, "execute");
#line 40
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 41
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 41
  if (! tmp) {
#line 41
    return;
  }
#line 42
  if (TRACER_Info[TRACER_default___1].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___1].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp___0) {
#line 43
    return;
  }
  {
#line 45
  EA_GetValue(& SValue, & Source);
#line 46
  EA_GetValue(& DValue, & Destination);
#line 48
  Result = SValue + DValue;
  }
#line 50
  if (TRACER_Info[TRACER_default___1].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___1].Name, "execute");
#line 50
    tracer_printf((char *)"0x%08lx + 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 54
  if (TRACER_Info[TRACER_default___1].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___1].Name, "execute");
#line 54
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 55
  EA_PutValue(& Destination, Result);
#line 57
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 57
  cycle((unsigned long )ADDATime[tmp___1]);
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
static long disassemble___1(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADDA_Instr Instr ;

  {
  {
#line 63
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 64
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADDA.L");
#line 65
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 66
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg2);
  }
#line 67
  return (0L);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
long adda_5206_register(void) 
{ 


  {
  {
#line 72
  instruction_register((unsigned short)53696, (unsigned short)61888, & execute___1,
                       & disassemble___1);
  }
#line 73
  return (1L);
}
}
#line 29 "../memory.h"
extern struct _memory_core memory_core ;
#line 63
extern struct _SR *SRBits ;
#line 35 "../i_5206/i_5206.h"
long movec_5206_register(void) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
int MOVECTime  =    9;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
static enum _TRACER_Channels  const  TRACER_default___2  =    (enum _TRACER_Channels  const  )31;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
static void execute___2(void) 
{ 
  struct _Address Source ;
  unsigned long SValue ;
  MOVEC_Instr Instr ;
  char tmp ;

  {
  {
#line 41
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 43
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 45
  if (TRACER_Info[TRACER_default___2].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 45
    tracer_printf((char *)"Retrieving source (A...\n");
    }
  }
  {
#line 46
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.AD, (char )Instr.Bits.Register);
  }
#line 46
  if (! tmp) {
#line 46
    return;
  }
  {
#line 48
  EA_GetValue(& SValue, & Source);
  }
#line 50
  if (SRBits->S) {
    {
#line 53
    if (Instr.Bits.ControlRegister == 2U) {
#line 53
      goto case_2;
    }
#line 56
    if (Instr.Bits.ControlRegister == 4U) {
#line 56
      goto case_4;
    }
#line 59
    if (Instr.Bits.ControlRegister == 5U) {
#line 59
      goto case_5;
    }
#line 62
    if (Instr.Bits.ControlRegister == 2049U) {
#line 62
      goto case_2049;
    }
#line 66
    if (Instr.Bits.ControlRegister == 2063U) {
#line 66
      goto case_2063;
    }
#line 70
    if (Instr.Bits.ControlRegister == 3072U) {
#line 70
      goto case_3072;
    }
#line 74
    if (Instr.Bits.ControlRegister == 3076U) {
#line 74
      goto case_3076;
    }
#line 78
    if (Instr.Bits.ControlRegister == 3087U) {
#line 78
      goto case_3087;
    }
#line 82
    goto switch_default;
    case_2: /* CIL Label */ 
#line 54
    memory_core.cacr = SValue;
#line 55
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 57
    tracer_printf((char *)"Storing 0x%08lx in the ACR0 is unimplemented!\n", SValue);
    }
#line 58
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 60
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 60
    tracer_printf((char *)"Storing 0x%08lx in the ACR1 is unimplemented!\n", SValue);
    }
#line 61
    goto switch_break;
    case_2049: /* CIL Label */ 
#line 63
    if (TRACER_Info[TRACER_default___2].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 63
      tracer_printf((char *)"Storing 0x%08lx in the VBR\n", SValue);
      }
    }
#line 64
    memory_core.vbr = SValue;
#line 65
    goto switch_break;
    case_2063: /* CIL Label */ 
#line 67
    if (TRACER_Info[TRACER_default___2].Enabled) {
      {
#line 67
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 67
      tracer_printf((char *)"Storing 0x%08lx in the PC\n", SValue);
      }
    }
#line 68
    memory_core.pc = SValue;
#line 69
    goto switch_break;
    case_3072: /* CIL Label */ 
#line 71
    memory_core.rombar = SValue & 4294966272UL;
#line 72
    if (TRACER_Info[TRACER_default___2].Enabled) {
      {
#line 72
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 72
      tracer_printf((char *)"Storing 0x%08lx in the ROMBAR\n", memory_core.rombar);
      }
    }
#line 73
    goto switch_break;
    case_3076: /* CIL Label */ 
#line 75
    memory_core.rambar = SValue & 4294966272UL;
#line 76
    if (TRACER_Info[TRACER_default___2].Enabled) {
      {
#line 76
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 76
      tracer_printf((char *)"Storing 0x%08lx in the RAMBAR\n", memory_core.rambar);
      }
    }
#line 77
    goto switch_break;
    case_3087: /* CIL Label */ 
#line 79
    memory_core.mbar = SValue & 4294966272UL;
#line 80
    if (TRACER_Info[TRACER_default___2].Enabled) {
      {
#line 80
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 80
      tracer_printf((char *)"Storing 0x%08lx in the MBAR\n", memory_core.mbar);
      }
    }
#line 81
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 83
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 83
    tracer_printf((char *)"Unimplemented Control register 0x%x\n", Instr.Bits.ControlRegister);
    }
#line 84
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 90
  if (TRACER_Info[TRACER_default___2].Enabled) {
    {
#line 90
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 90
    tracer_printf((char *)"Attempt to write to SR while in user state\n");
    }
  }
#line 94
  if (TRACER_Info[TRACER_default___2].Enabled) {
    {
#line 94
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___2].Name, "execute");
#line 94
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 96
  cycle((unsigned long )MOVECTime);
  }
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
static long disassemble___2(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVEC_Instr Instr ;

  {
  {
#line 104
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 105
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 107
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVEC");
#line 109
  Addressing_Print((short)32, (char )Instr.Bits.AD, (char )Instr.Bits.Register, Arg1);
  }
  {
#line 111
  if (Instr.Bits.ControlRegister == 2U) {
#line 111
    goto case_2;
  }
#line 114
  if (Instr.Bits.ControlRegister == 4U) {
#line 114
    goto case_4;
  }
#line 117
  if (Instr.Bits.ControlRegister == 5U) {
#line 117
    goto case_5;
  }
#line 120
  if (Instr.Bits.ControlRegister == 2049U) {
#line 120
    goto case_2049;
  }
#line 123
  if (Instr.Bits.ControlRegister == 2063U) {
#line 123
    goto case_2063;
  }
#line 126
  if (Instr.Bits.ControlRegister == 3072U) {
#line 126
    goto case_3072;
  }
#line 129
  if (Instr.Bits.ControlRegister == 3076U) {
#line 129
    goto case_3076;
  }
#line 132
  if (Instr.Bits.ControlRegister == 3087U) {
#line 132
    goto case_3087;
  }
#line 135
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 112
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"CACR");
  }
#line 113
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 115
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"ACR0");
  }
#line 116
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 118
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"ACR1");
  }
#line 119
  goto switch_break;
  case_2049: /* CIL Label */ 
  {
#line 121
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"VBR");
  }
#line 122
  goto switch_break;
  case_2063: /* CIL Label */ 
  {
#line 124
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"PC");
  }
#line 125
  goto switch_break;
  case_3072: /* CIL Label */ 
  {
#line 127
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"ROMBAR");
  }
#line 128
  goto switch_break;
  case_3076: /* CIL Label */ 
  {
#line 130
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"RAMBAR");
  }
#line 131
  goto switch_break;
  case_3087: /* CIL Label */ 
  {
#line 133
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"MBAR");
  }
#line 134
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 136
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"???");
  }
#line 137
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 140
  return (0L);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
long movec_5206_register(void) 
{ 


  {
  {
#line 145
  instruction_register((unsigned short)20091, (unsigned short)65535, & execute___2,
                       & disassemble___2);
  }
#line 146
  return (1L);
}
}
#line 27 "../i_5206/i_5206.h"
long halt_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
int HALTTime  =    7;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
static enum _TRACER_Channels  const  TRACER_default___3  =    (enum _TRACER_Channels  const  )23;
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
static void execute___3(void) 
{ 
  HALT_Instr Instr ;

  {
  {
#line 32
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 34
  if (SRBits->S) {
    {
#line 36
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___3].Name, "execute");
#line 36
    tracer_printf((char *)"Halting the processor:\n");
    }
#line 37
    return;
  } else
#line 40
  if (TRACER_Info[TRACER_default___3].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___3].Name, "execute");
#line 40
    tracer_printf((char *)"Attempt to HALT while in user state\n");
    }
  }
#line 44
  if (TRACER_Info[TRACER_default___3].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___3].Name, "execute");
#line 44
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 45
  cycle((unsigned long )HALTTime);
  }
#line 46
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
static long disassemble___3(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  HALT_Instr Instr ;

  {
  {
#line 52
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 54
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"HALT");
#line 56
  *(Arg1 + 0) = (char)0;
#line 57
  *(Arg2 + 0) = (char)0;
  }
#line 59
  return (0L);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
long halt_5206_register(void) 
{ 


  {
  {
#line 64
  instruction_register((unsigned short)19144, (unsigned short)65535, & execute___3,
                       & disassemble___3);
  }
#line 65
  return (1L);
}
}
#line 60 "../i_5206/i_5206.h"
long tst_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
int TSTTime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
  {      1,      3,      3,      3, 
        3,      4,      3,      1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
static enum _TRACER_Channels  const  TRACER_default___4  =    (enum _TRACER_Channels  const  )57;
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
short const   TST_SizeBits[4]  = {      (short const   )8,      (short const   )16,      (short const   )32,      (short const   )0};
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
char const   TST_SizeStr[4]  = {      (char const   )'B',      (char const   )'W',      (char const   )'L',      (char const   )'?'};
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
static void execute___4(void) 
{ 
  struct _Address Source ;
  unsigned long SValue ;
  TST_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (Instr.Bits.Size == 3U) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___4].Name, "execute");
#line 43
    tracer_printf((char *)"Invalid size=3");
    }
#line 44
    return;
  }
#line 46
  if (TRACER_Info[TRACER_default___4].Enabled) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___4].Name, "execute");
#line 46
    tracer_printf((char *)"Size = %d=n", Instr.Bits.Size);
    }
  }
#line 47
  if (TRACER_Info[TRACER_default___4].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___4].Name, "execute");
#line 47
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 48
  tmp = EA_GetFromPC(& Source, (short )TST_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.EAMode,
                     (char )Instr.Bits.EARegister);
  }
#line 48
  if (! tmp) {
#line 49
    return;
  }
  {
#line 50
  EA_GetValue(& SValue, & Source);
  }
#line 52
  if (TRACER_Info[TRACER_default___4].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___4].Name, "execute");
#line 52
    tracer_printf((char *)"Testing 0x%08lx\n", SValue);
    }
  }
#line 61
  SRBits->N = (unsigned int )((long )SValue < 0L);
#line 62
  SRBits->Z = (unsigned int )(SValue == 0UL);
#line 63
  SRBits->V = 0U;
#line 64
  SRBits->C = 0U;
#line 66
  if (TRACER_Info[TRACER_default___4].Enabled) {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___4].Name, "execute");
#line 66
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 68
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 68
  cycle((unsigned long )TSTTime[tmp___0]);
  }
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
static long disassemble___4(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  TST_Instr Instr ;

  {
  {
#line 76
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 78
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TST.%c",
          (int const   )TST_SizeStr[(short )Instr.Bits.Size]);
#line 80
  Addressing_Print((short )TST_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.EAMode,
                   (char )Instr.Bits.EARegister, Arg1);
#line 83
  *(Arg2 + 0) = (char)0;
  }
#line 84
  return (0L);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
long tst_5206_register(void) 
{ 


  {
  {
#line 90
  instruction_register((unsigned short)18944, (unsigned short)65472, & execute___4,
                       & disassemble___4);
#line 91
  instruction_register((unsigned short)19008, (unsigned short)65472, & execute___4,
                       & disassemble___4);
#line 92
  instruction_register((unsigned short)19072, (unsigned short)65472, & execute___4,
                       & disassemble___4);
  }
#line 93
  return (1L);
}
}
#line 48 "../i_5206/i_5206.h"
long rte_5206_register(void) ;
#line 164 "../coldfire.h"
extern void exception_restore_from_stack_frame(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rte.c"
int RTETime  =    8;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rte.c"
static enum _TRACER_Channels  const  TRACER_default___5  =    (enum _TRACER_Channels  const  )44;
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rte.c"
static void execute___5(void) 
{ 
  unsigned long dummy ;

  {
  {
#line 33
  Memory_RetrFromPC(& dummy, (short)16);
#line 35
  exception_restore_from_stack_frame();
  }
#line 37
  if (TRACER_Info[TRACER_default___5].Enabled) {
    {
#line 37
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___5].Name, "execute");
#line 37
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 39
  cycle((unsigned long )RTETime);
  }
#line 41
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rte.c"
static long disassemble___5(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 47
  Memory_RetrFromPC(& dummy, (short)16);
#line 48
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"RTE");
#line 49
  *(Arg1 + 0) = (char)0;
#line 50
  *(Arg2 + 0) = (char)0;
  }
#line 51
  return (0L);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rte.c"
long rte_5206_register(void) 
{ 


  {
  {
#line 57
  instruction_register((unsigned short)20083, (unsigned short)65535, & execute___5,
                       & disassemble___5);
  }
#line 58
  return (1L);
}
}
#line 13 "../i_5206/i_5206.h"
long addx_5206_register(void) ;
#line 172 "../coldfire.h"
extern void SR_Set(short Instr , long Source , long Destination , long Result ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
int ADDXTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
static enum _TRACER_Channels  const  TRACER_default___6  =    (enum _TRACER_Channels  const  )8;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
static void execute___6(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  long Extend ;
  ADDX_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 38
  Extend = (long )SRBits->X;
#line 41
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 43
  if (TRACER_Info[TRACER_default___6].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___6].Name, "execute");
#line 43
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 44
  tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.RegisterDy);
  }
#line 44
  if (! tmp) {
#line 44
    return;
  }
#line 45
  if (TRACER_Info[TRACER_default___6].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___6].Name, "execute");
#line 45
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 46
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.RegisterDx);
  }
#line 46
  if (! tmp___0) {
#line 46
    return;
  }
  {
#line 47
  EA_GetValue(& SValue, & Source);
#line 48
  EA_GetValue(& DValue, & Destination);
#line 50
  Result = (SValue + DValue) + (unsigned long )Extend;
  }
#line 52
  if (TRACER_Info[TRACER_default___6].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___6].Name, "execute");
#line 52
    tracer_printf((char *)"0x%08lx + 0x%08lx + %d = 0x%08lx\n", SValue, DValue, Extend,
                  Result);
    }
  }
  {
#line 54
  SR_Set((short)4, (long )SValue, (long )DValue, (long )Result);
  }
#line 56
  if (TRACER_Info[TRACER_default___6].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___6].Name, "execute");
#line 56
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 57
  EA_PutValue(& Destination, Result);
#line 59
  cycle((unsigned long )ADDXTime);
  }
#line 61
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
static long disassemble___6(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADDX_Instr Instr ;

  {
  {
#line 67
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 69
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADDX.L");
#line 70
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.RegisterDy, Arg1);
#line 71
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.RegisterDx, Arg2);
  }
#line 72
  return (0L);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
long addx_5206_register(void) 
{ 


  {
  {
#line 77
  instruction_register((unsigned short)53632, (unsigned short)61944, & execute___6,
                       & disassemble___6);
  }
#line 78
  return (1L);
}
}
#line 40 "../i_5206/i_5206.h"
long mul_w_5206_register(void) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
int MULWTime[8]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
  {      9,      11,      11,      11, 
        11,      12,      11,      9};
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
static enum _TRACER_Channels  const  TRACER_default___7  =    (enum _TRACER_Channels  const  )36;
#line 42 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
static void execute___7(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  MUL_W_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 47
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 49
  if (Instr.Bits.EAMode == 1U) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___7].Name, "execute");
#line 50
    tracer_printf((char *)"May Not specify Address Register (Ay) for MUL.W");
    }
#line 51
    return;
  }
#line 54
  if (TRACER_Info[TRACER_default___7].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___7].Name, "execute");
#line 54
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 55
  tmp = EA_GetFromPC(& Source, (short)16, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 55
  if (! tmp) {
#line 55
    return;
  }
  {
#line 56
  EA_GetValue(& SValue, & Source);
  }
#line 57
  if (TRACER_Info[TRACER_default___7].Enabled) {
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___7].Name, "execute");
#line 57
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 58
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 58
  if (! tmp___0) {
#line 58
    return;
  }
  {
#line 59
  EA_GetValue(& DValue, & Destination);
  }
#line 61
  if (Instr.Bits.US == 0U) {
#line 62
    Result = (unsigned long )((int )((unsigned short )(SValue & 65535UL)) * (int )((unsigned short )(DValue & 65535UL)));
  } else {
#line 64
    Result = (unsigned long )((int )((short )(SValue & 65535UL)) * (int )((short )(DValue & 65535UL)));
  }
#line 67
  if (TRACER_Info[TRACER_default___7].Enabled) {
    {
#line 67
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___7].Name, "execute");
#line 67
    tracer_printf((char *)"0x%04lx * 0x%04lx = 0x%04lx\n", SValue & 65535UL, DValue & 65535UL,
                  Result);
    }
  }
#line 70
  memory_core.sr &= 65280UL;
#line 71
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 72
  SRBits->Z = (unsigned int )(Result == 0UL);
#line 74
  if (TRACER_Info[TRACER_default___7].Enabled) {
    {
#line 74
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___7].Name, "execute");
#line 74
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 75
  EA_PutValue(& Destination, Result);
  }
#line 76
  if (TRACER_Info[TRACER_default___7].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___7].Name, "execute");
#line 76
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 78
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 78
  cycle((unsigned long )MULWTime[tmp___1]);
  }
#line 80
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
static long disassemble___7(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MUL_W_Instr Instr ;

  {
  {
#line 86
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 87
  if (Instr.Bits.US == 0U) {
    {
#line 88
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MULU.W");
    }
  } else {
    {
#line 90
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MULS.W");
    }
  }
  {
#line 91
  Addressing_Print((short)16, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 92
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 93
  return (0L);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
long mul_w_5206_register(void) 
{ 


  {
  {
#line 98
  instruction_register((unsigned short)49344, (unsigned short)61632, & execute___7,
                       & disassemble___7);
  }
#line 99
  return (2L);
}
}
#line 23 "../i_5206/i_5206.h"
long dc_5206_register(void) ;
#line 163 "../coldfire.h"
extern long exception_do_exception(short vector ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_dc.c"
static enum _TRACER_Channels  const  TRACER_default___8  =    (enum _TRACER_Channels  const  )18;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_dc.c"
static void execute___8(void) 
{ 
  unsigned long dummy ;

  {
#line 30
  if (TRACER_Info[TRACER_default___8].Enabled) {
    {
#line 30
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___8].Name, "execute");
#line 30
    tracer_printf((char *)"Called\n");
    }
  }
  {
#line 32
  Memory_RetrFromPC(& dummy, (short)16);
  }
#line 33
  if (TRACER_Info[TRACER_default___8].Enabled) {
    {
#line 33
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___8].Name, "execute");
#line 33
    tracer_printf((char *)"Value=0x%04x, doing exception vector 4\n", dummy);
    }
  }
  {
#line 35
  exception_do_exception((short)4);
  }
#line 36
  if (TRACER_Info[TRACER_default___8].Enabled) {
    {
#line 36
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___8].Name, "execute");
#line 36
    tracer_printf((char *)"Done\n");
    }
  }
#line 37
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_dc.c"
static long disassemble___8(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 43
  Memory_RetrFromPC(& dummy, (short)16);
#line 44
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"DC.W");
#line 45
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"0x%04lx",
          dummy);
#line 46
  *(Arg2 + 0) = (char)0;
  }
#line 47
  return (0L);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_dc.c"
long dc_5206_register(void) 
{ 


  {
  {
#line 53
  instruction_register((unsigned short)0, (unsigned short)0, & execute___8, & disassemble___8);
  }
#line 54
  return (0L);
}
}
#line 56 "../i_5206/i_5206.h"
long subx_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
int SUBXTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
static enum _TRACER_Channels  const  TRACER_default___9  =    (enum _TRACER_Channels  const  )53;
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
static void execute___9(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUBX_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___9].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___9].Name, "execute");
#line 40
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 41
  tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.RegisterDy);
  }
#line 41
  if (! tmp) {
#line 41
    return;
  }
#line 42
  if (TRACER_Info[TRACER_default___9].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___9].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.RegisterDx);
  }
#line 43
  if (! tmp___0) {
#line 43
    return;
  }
  {
#line 44
  EA_GetValue(& SValue, & Source);
#line 45
  EA_GetValue(& DValue, & Destination);
#line 47
  Result = (DValue - SValue) - (unsigned long )((long )SRBits->X);
  }
#line 49
  if (TRACER_Info[TRACER_default___9].Enabled) {
    {
#line 49
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___9].Name, "execute");
#line 49
    tracer_printf((char *)"0x%08lx - 0x%08lx - %d = 0x%08lx\n", DValue, SValue, (long )SRBits->X,
                  Result);
    }
  }
  {
#line 51
  SR_Set((short)54, (long )SValue, (long )DValue, (long )Result);
  }
#line 53
  if (TRACER_Info[TRACER_default___9].Enabled) {
    {
#line 53
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___9].Name, "execute");
#line 53
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 54
  EA_PutValue(& Destination, Result);
#line 56
  cycle((unsigned long )SUBXTime);
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
static long disassemble___9(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUBX_Instr Instr ;

  {
  {
#line 64
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 66
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUBX.L");
#line 67
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.RegisterDy, Arg1);
#line 68
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.RegisterDx, Arg2);
  }
#line 69
  return (0L);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
long subx_5206_register(void) 
{ 


  {
  {
#line 74
  instruction_register((unsigned short)37248, (unsigned short)61944, & execute___9,
                       & disassemble___9);
  }
#line 75
  return (1L);
}
}
#line 51 "../i_5206/i_5206.h"
long stop_5206_register(void) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
int STOPTime  =    3;
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
static enum _TRACER_Channels  const  TRACER_default___10  =    (enum _TRACER_Channels  const  )48;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
static void execute___10(void) 
{ 
  struct _Address Source ;
  unsigned long Result ;
  unsigned long SValue ;
  STOP_Instr Instr ;
  char tmp ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 37
  if (TRACER_Info[TRACER_default___10].Enabled) {
    {
#line 37
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___10].Name, "execute");
#line 37
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 38
  tmp = EA_GetFromPC(& Source, (short)16, (char)7, (char)4);
  }
#line 38
  if (! tmp) {
#line 38
    return;
  }
  {
#line 39
  EA_GetValue(& SValue, & Source);
#line 41
  Result = SValue;
  }
#line 43
  if (TRACER_Info[TRACER_default___10].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___10].Name, "execute");
#line 43
    tracer_printf((char *)"#0x%08lx\n", Result);
    }
  }
#line 45
  if (TRACER_Info[TRACER_default___10].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___10].Name, "execute");
#line 45
    tracer_printf((char *)"Storing Result:\n");
    }
  }
#line 48
  memory_core.sr = Result;
#line 50
  if (TRACER_Info[TRACER_default___10].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___10].Name, "execute");
#line 50
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 52
  cycle((unsigned long )STOPTime);
  }
#line 54
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
static long disassemble___10(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  STOP_Instr Instr ;
  unsigned long SValue ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 62
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"STOP");
#line 63
  Memory_RetrFromPC(& SValue, (short)16);
#line 64
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#$%08lx",
          SValue);
#line 65
  *(Arg2 + 0) = (char)0;
  }
#line 67
  return (0L);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
long stop_5206_register(void) 
{ 


  {
  {
#line 72
  instruction_register((unsigned short)20082, (unsigned short)65535, & execute___10,
                       & disassemble___10);
  }
#line 73
  return (1L);
}
}
#line 34 "../i_5206/i_5206.h"
long move_5206_register(void) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
static enum _TRACER_Channels  const  TRACER_default___11  =    (enum _TRACER_Channels  const  )30;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
short const   MOVE_SizeBits[4]  = {      (short const   )0,      (short const   )8,      (short const   )32,      (short const   )16};
#line 36 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
char const   MOVE_SizeStr[4]  = {      (char const   )'?',      (char const   )'B',      (char const   )'L',      (char const   )'W'};
#line 38 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
int MOVE816Time[12][7]  = 
#line 38
  { {        1,        1,        1,        1, 
            1,        2,        1}, 
   {        1,        1,        1,        1, 
            1,        2,        1}, 
   {        3,        3,        3,        3, 
            3,        4,        3}, 
   {        3,        3,        3,        3, 
            3,        4,        3}, 
   {        3,        3,        3,        3, 
            3,        4,        3}, 
   {        3,        3,        3,        3, 
            3,        -1,        -1}, 
   {        4,        4,        4,        4, 
            -1,        -1,        -1}, 
   {        3,        3,        3,        3, 
            -1,        -1,        -1}, 
   {        3,        3,        3,        3, 
            -1,        -1,        -1}, 
   {        3,        3,        3,        3, 
            3,        -1,        -1}, 
   {        4,        4,        4,        4, 
            -1,        -1,        -1}, 
   {        1,        3,        3,        3, 
            -1,        -1,        -1}};
#line 52 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
int MOVE32Time[12][7]  = 
#line 52
  { {        1,        1,        1,        1, 
            1,        2,        1}, 
   {        1,        1,        1,        1, 
            1,        2,        1}, 
   {        2,        2,        2,        2, 
            2,        3,        2}, 
   {        2,        2,        2,        2, 
            2,        3,        2}, 
   {        2,        2,        2,        2, 
            2,        3,        2}, 
   {        2,        2,        2,        2, 
            2,        -1,        -1}, 
   {        3,        3,        3,        3, 
            -1,        -1,        -1}, 
   {        2,        2,        2,        2, 
            -1,        -1,        -1}, 
   {        2,        2,        2,        2, 
            -1,        -1,        -1}, 
   {        2,        2,        2,        2, 
            2,        -1,        -1}, 
   {        3,        3,        3,        3, 
            -1,        -1,        -1}, 
   {        1,        2,        2,        2, 
            -1,        -1,        -1}};
#line 67 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
static void execute___11(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long SValue ;
  int cycle_source_ea ;
  int cycle_destination_ea ;
  MOVE_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 71
  cycle_source_ea = 0;
#line 71
  cycle_destination_ea = 0;
#line 74
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 76
  if (Instr.Bits.Size == 0U) {
    {
#line 77
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___11].Name, "execute");
#line 77
    tracer_printf((char *)"Invalid size in instruction, size=0\n");
    }
#line 78
    return;
  }
#line 81
  if (TRACER_Info[TRACER_default___11].Enabled) {
    {
#line 81
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___11].Name, "execute");
#line 81
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 82
  tmp = EA_GetFromPC(& Source, (short )MOVE_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.SourceMode,
                     (char )Instr.Bits.SourceRegister);
  }
#line 82
  if (! tmp) {
#line 83
    return;
  }
  {
#line 84
  EA_GetValue(& SValue, & Source);
  }
#line 86
  if (TRACER_Info[TRACER_default___11].Enabled) {
    {
#line 86
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___11].Name, "execute");
#line 86
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 87
  tmp___0 = EA_GetFromPC(& Destination, (short )MOVE_SizeBits[(short )Instr.Bits.Size],
                         (char )Instr.Bits.DestMode, (char )Instr.Bits.DestRegister);
  }
#line 87
  if (! tmp___0) {
#line 88
    return;
  }
#line 90
  if (TRACER_Info[TRACER_default___11].Enabled) {
    {
#line 90
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___11].Name, "execute");
#line 90
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 91
  EA_PutValue(& Destination, SValue);
  }
#line 99
  if (Instr.Bits.DestMode != 1U) {
#line 101
    memory_core.sr &= 65520UL;
#line 102
    SRBits->N = (unsigned int )((long )SValue < 0L);
#line 103
    SRBits->Z = (unsigned int )(SValue == 0UL);
  }
  {
#line 110
  cycle_source_ea = cycle_EA((short )Instr.Bits.SourceRegister, (short )Instr.Bits.SourceMode);
#line 111
  cycle_destination_ea = cycle_EA((short )Instr.Bits.DestRegister, (short )Instr.Bits.DestMode);
  }
#line 113
  if (Instr.Bits.Size == 2U) {
    {
#line 114
    cycle((unsigned long )MOVE32Time[cycle_source_ea][cycle_destination_ea]);
    }
  } else {
    {
#line 116
    cycle((unsigned long )MOVE816Time[cycle_source_ea][cycle_destination_ea]);
    }
  }
#line 118
  if (TRACER_Info[TRACER_default___11].Enabled) {
    {
#line 118
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___11].Name, "execute");
#line 118
    tracer_printf((char *)"Done\n");
    }
  }
#line 120
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
static long disassemble___11(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVE_Instr Instr ;

  {
  {
#line 126
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 130
  if (Instr.Bits.DestMode == 1U) {
#line 130
    if (Instr.Bits.Size >= 2U) {
      {
#line 131
      sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVEA.%c",
              (int const   )MOVE_SizeStr[(short )Instr.Bits.Size]);
      }
    } else {
      {
#line 133
      sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVE.%c",
              (int const   )MOVE_SizeStr[(short )Instr.Bits.Size]);
      }
    }
  } else {
    {
#line 133
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVE.%c",
            (int const   )MOVE_SizeStr[(short )Instr.Bits.Size]);
    }
  }
  {
#line 135
  Addressing_Print((short )MOVE_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.SourceMode,
                   (char )Instr.Bits.SourceRegister, Arg1);
#line 138
  Addressing_Print((short )MOVE_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.DestMode,
                   (char )Instr.Bits.DestRegister, Arg2);
  }
#line 140
  return (0L);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
long move_5206_register(void) 
{ 


  {
  {
#line 147
  instruction_register((unsigned short)4096, (unsigned short)61440, & execute___11,
                       & disassemble___11);
#line 148
  instruction_register((unsigned short)8192, (unsigned short)61440, & execute___11,
                       & disassemble___11);
#line 149
  instruction_register((unsigned short)12288, (unsigned short)61440, & execute___11,
                       & disassemble___11);
#line 150
  instruction_register((unsigned short)12288, (unsigned short)61440, & execute___11,
                       & disassemble___11);
  }
#line 151
  return (1L);
}
}
#line 45 "../i_5206/i_5206.h"
long or_5206_register(void) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
int ORTime[2][8]  = { {        1,        3,        3,        3, 
            3,        4,        3,        1}, 
   {        -1,        3,        3,        3, 
            3,        4,        3,        -1}};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
static enum _TRACER_Channels  const  TRACER_default___12  =    (enum _TRACER_Channels  const  )41;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
static void execute___12(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  OR_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (Instr.Bits.OPMode == 2U) {
#line 41
    if (TRACER_Info[TRACER_default___12].Enabled) {
      {
#line 41
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 41
      tracer_printf((char *)"<EA>y | Dx -> Dx\n");
      }
    }
#line 42
    if (Instr.Bits.EAMode == 1U) {
      {
#line 43
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 43
      tracer_printf((char *)"May not specify Ax for source");
      }
#line 44
      return;
    }
#line 46
    if (TRACER_Info[TRACER_default___12].Enabled) {
      {
#line 46
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 46
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 47
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 47
    if (! tmp) {
#line 47
      return;
    }
#line 48
    if (TRACER_Info[TRACER_default___12].Enabled) {
      {
#line 48
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 48
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 49
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 49
    if (! tmp___0) {
#line 49
      return;
    }
  } else
#line 50
  if (Instr.Bits.OPMode == 6U) {
#line 51
    if (Instr.Bits.EAMode == 0U) {
      {
#line 52
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 52
      tracer_printf((char *)"May not specify Dx for destination when source is Dx");
      }
#line 53
      return;
    } else
#line 54
    if (Instr.Bits.EAMode == 1U) {
      {
#line 55
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 55
      tracer_printf((char *)"May not specify Ax for destination when source is Dx");
      }
#line 56
      return;
    } else
#line 57
    if (Instr.Bits.EAMode == 7U) {
#line 57
      if (Instr.Bits.EARegister == 4U) {
        {
#line 58
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name,
                      "execute");
#line 58
        tracer_printf((char *)"May not specify Immediate Addressing for destination");
        }
#line 59
        return;
      }
    }
#line 61
    if (TRACER_Info[TRACER_default___12].Enabled) {
      {
#line 61
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 61
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 62
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 62
    if (! tmp___1) {
#line 62
      return;
    }
#line 63
    if (TRACER_Info[TRACER_default___12].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 63
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 64
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 64
    if (! tmp___2) {
#line 64
      return;
    }
  } else {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 66
    tracer_printf((char *)"Unknown OPMode %d", Instr.Bits.OPMode);
    }
#line 67
    return;
  }
  {
#line 70
  EA_GetValue(& SValue, & Source);
#line 71
  EA_GetValue(& DValue, & Destination);
#line 73
  Result = SValue | DValue;
  }
#line 74
  if (TRACER_Info[TRACER_default___12].Enabled) {
    {
#line 74
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 74
    tracer_printf((char *)"0x%08lx | 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 76
  if (TRACER_Info[TRACER_default___12].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 76
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 77
  EA_PutValue(& Destination, Result);
#line 85
  memory_core.sr &= 65520UL;
#line 86
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 87
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 89
  if (TRACER_Info[TRACER_default___12].Enabled) {
    {
#line 89
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___12].Name, "execute");
#line 89
    tracer_printf((char *)"Done\n");
    }
  }
#line 91
  if (Instr.Bits.OPMode == 2U) {
    {
#line 92
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 92
    cycle((unsigned long )ORTime[0][tmp___3]);
    }
  } else {
    {
#line 93
    tmp___4 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 93
    cycle((unsigned long )ORTime[1][tmp___4]);
    }
  }
#line 96
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
static long disassemble___12(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  OR_Instr Instr ;

  {
  {
#line 102
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 103
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"OR.L");
  }
#line 104
  if (Instr.Bits.OPMode == 2U) {
    {
#line 105
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 106
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 108
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 109
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 111
  return (0L);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
long or_5206_register(void) 
{ 


  {
  {
#line 116
  instruction_register((unsigned short)32768, (unsigned short)61440, & execute___12,
                       & disassemble___12);
  }
#line 117
  return (1L);
}
}
#line 22 "../i_5206/i_5206.h"
long cmpi_5206_register(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
int CMPITime  =    1;
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
static enum _TRACER_Channels  const  TRACER_default___13  =    (enum _TRACER_Channels  const  )17;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
static void execute___13(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  CMPI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___13].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___13].Name, "execute");
#line 41
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
#line 43
  if (TRACER_Info[TRACER_default___13].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___13].Name, "execute");
#line 43
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 44
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 44
  if (! tmp___0) {
#line 44
    return;
  }
  {
#line 46
  EA_GetValue(& SValue, & Source);
#line 47
  EA_GetValue(& DValue, & Destination);
#line 49
  Result = DValue - SValue;
  }
#line 51
  if (TRACER_Info[TRACER_default___13].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___13].Name, "execute");
#line 51
    tracer_printf((char *)"Comparing 0x%08lx with 0x%08lx\n", SValue, DValue);
    }
  }
  {
#line 54
  SR_Set((short)19, (long )SValue, (long )DValue, (long )Result);
#line 56
  cycle((unsigned long )CMPITime);
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
static long disassemble___13(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  CMPI_Instr Instr ;

  {
  {
#line 64
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 65
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"CMPI.L");
#line 66
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 67
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 68
  return (0L);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
long cmpi_5206_register(void) 
{ 


  {
  {
#line 73
  instruction_register((unsigned short)3200, (unsigned short)65528, & execute___13,
                       & disassemble___13);
  }
#line 74
  return (1L);
}
}
#line 26 "../i_5206/i_5206.h"
long ext_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
int EXTTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
static enum _TRACER_Channels  const  TRACER_default___14  =    (enum _TRACER_Channels  const  )22;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
static void execute___14(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long SValue ;
  unsigned long Result ;
  EXT_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___14].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___14].Name, "execute");
#line 41
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
  {
#line 43
  EA_GetValue(& SValue, & Source);
  }
#line 45
  if (Instr.Bits.OPMode == 2U) {
#line 46
    if (TRACER_Info[TRACER_default___14].Enabled) {
      {
#line 46
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___14].Name, "execute");
#line 46
      tracer_printf((char *)"Destination: (Byte -> Word)\n");
      }
    }
    {
#line 47
    tmp___0 = EA_GetFromPC(& Destination, (short)16, (char)0, (char )Instr.Bits.Register);
    }
#line 47
    if (! tmp___0) {
#line 47
      return;
    }
#line 48
    Result = (unsigned long )((char )SValue);
  } else
#line 49
  if (Instr.Bits.OPMode == 3U) {
#line 50
    if (TRACER_Info[TRACER_default___14].Enabled) {
      {
#line 50
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___14].Name, "execute");
#line 50
      tracer_printf((char *)"Destination: (Word -> Long)\n");
      }
    }
    {
#line 51
    tmp___1 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 51
    if (! tmp___1) {
#line 51
      return;
    }
    {
#line 52
    Result = (unsigned long )((short )SValue);
#line 53
    EA_PutValue(& Destination, (unsigned long )((short )SValue));
    }
  } else
#line 54
  if (Instr.Bits.OPMode == 7U) {
#line 55
    if (TRACER_Info[TRACER_default___14].Enabled) {
      {
#line 55
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___14].Name, "execute");
#line 55
      tracer_printf((char *)"Destination: (Byte -> Long)\n");
      }
    }
    {
#line 56
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 56
    if (! tmp___2) {
#line 56
      return;
    }
#line 57
    Result = (unsigned long )((char )SValue);
  } else {
    {
#line 59
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___14].Name, "execute");
#line 59
    tracer_printf((char *)"Unknown opmode %d\n", Instr.Bits.OPMode);
    }
#line 60
    return;
  }
  {
#line 63
  EA_PutValue(& Destination, Result);
#line 72
  memory_core.sr &= 65520UL;
#line 73
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 74
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 75
  if (TRACER_Info[TRACER_default___14].Enabled) {
    {
#line 75
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___14].Name, "execute");
#line 75
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 77
  cycle((unsigned long )EXTTime);
  }
#line 79
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
static long disassemble___14(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  EXT_Instr Instr ;

  {
  {
#line 85
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 87
  if (Instr.Bits.OPMode == 2U) {
    {
#line 88
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EXT.W");
    }
  } else
#line 89
  if (Instr.Bits.OPMode == 3U) {
    {
#line 90
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EXT.L");
    }
  } else
#line 91
  if (Instr.Bits.OPMode == 7U) {
    {
#line 92
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EXTB.L");
    }
  } else {
    {
#line 94
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___14].Name, "disassemble");
#line 94
    tracer_printf((char *)"Unknown opmode\n");
    }
  }
  {
#line 97
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 98
  *(Arg2 + 0) = (char)0;
  }
#line 99
  return (0L);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
long ext_5206_register(void) 
{ 


  {
  {
#line 104
  instruction_register((unsigned short)18432, (unsigned short)65080, & execute___14,
                       & disassemble___14);
#line 105
  instruction_register((unsigned short)18432, (unsigned short)65080, & execute___14,
                       & disassemble___14);
  }
#line 106
  return (2L);
}
}
#line 31 "../i_5206/i_5206.h"
long lea_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
int LEATime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
  {      -1,      1,      -1,      -1, 
        1,      2,      1,      -1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
static enum _TRACER_Channels  const  TRACER_default___15  =    (enum _TRACER_Channels  const  )27;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
static void execute___15(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long SValue ;
  LEA_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___15].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___15].Name, "execute");
#line 40
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 41
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 41
  if (! tmp) {
#line 41
    return;
  }
#line 42
  if (TRACER_Info[TRACER_default___15].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___15].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp___0) {
#line 43
    return;
  }
  {
#line 45
  EA_GetEA(& SValue, & Source);
  }
#line 47
  if (TRACER_Info[TRACER_default___15].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___15].Name, "execute");
#line 47
    tracer_printf((char *)"Loading 0x%08lx into A%d\n", SValue, Instr.Bits.Register);
    }
  }
#line 51
  if (TRACER_Info[TRACER_default___15].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___15].Name, "execute");
#line 51
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 52
  EA_PutValue(& Destination, SValue);
  }
#line 54
  if (TRACER_Info[TRACER_default___15].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___15].Name, "execute");
#line 54
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 56
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 56
  cycle((unsigned long )LEATime[tmp___1]);
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
static long disassemble___15(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  LEA_Instr Instr ;

  {
  {
#line 64
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 65
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"LEA");
#line 66
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 67
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg2);
  }
#line 68
  return (0L);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
long lea_5206_register(void) 
{ 


  {
  {
#line 73
  instruction_register((unsigned short)16832, (unsigned short)61888, & execute___15,
                       & disassemble___15);
  }
#line 74
  return (1L);
}
}
#line 50 "../i_5206/i_5206.h"
long scc_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
char const   *code_mnemonic[16]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
  {      "T",      "F",      "HI",      "LS", 
        "CC",      "CS",      "NE",      "EQ", 
        "VC",      "VS",      "PL",      "MI", 
        "GE",      "LT",      "GT",      "LE"};
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
static enum _TRACER_Channels  const  TRACER_default___16  =    (enum _TRACER_Channels  const  )47;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
int SCCTime  =    1;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
static void execute___16(void) 
{ 
  struct _Address Destination ;
  SCC_Instr Instr ;
  unsigned char Result ;
  char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 39
  Result = (unsigned char)0;
#line 41
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 43
  tmp = EA_GetFromPC(& Destination, (short)8, (char)0, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp) {
#line 43
    return;
  }
  {
#line 45
  cycle((unsigned long )SCCTime);
  }
  {
#line 48
  if (Instr.Bits.Condition == 0U) {
#line 48
    goto case_0;
  }
#line 51
  if (Instr.Bits.Condition == 1U) {
#line 51
    goto case_1;
  }
#line 53
  if (Instr.Bits.Condition == 2U) {
#line 53
    goto case_2;
  }
#line 58
  if (Instr.Bits.Condition == 3U) {
#line 58
    goto case_3;
  }
#line 61
  if (Instr.Bits.Condition == 4U) {
#line 61
    goto case_4;
  }
#line 64
  if (Instr.Bits.Condition == 5U) {
#line 64
    goto case_5;
  }
#line 67
  if (Instr.Bits.Condition == 6U) {
#line 67
    goto case_6;
  }
#line 71
  if (Instr.Bits.Condition == 7U) {
#line 71
    goto case_7;
  }
#line 75
  if (Instr.Bits.Condition == 8U) {
#line 75
    goto case_8;
  }
#line 78
  if (Instr.Bits.Condition == 9U) {
#line 78
    goto case_9;
  }
#line 81
  if (Instr.Bits.Condition == 10U) {
#line 81
    goto case_10;
  }
#line 84
  if (Instr.Bits.Condition == 11U) {
#line 84
    goto case_11;
  }
#line 87
  if (Instr.Bits.Condition == 12U) {
#line 87
    goto case_12;
  }
#line 91
  if (Instr.Bits.Condition == 13U) {
#line 91
    goto case_13;
  }
#line 95
  if (Instr.Bits.Condition == 14U) {
#line 95
    goto case_14;
  }
#line 99
  if (Instr.Bits.Condition == 15U) {
#line 99
    goto case_15;
  }
#line 103
  goto switch_default;
  case_0: /* CIL Label */ 
#line 49
  Result = (unsigned char)1;
#line 50
  goto switch_break;
  case_1: /* CIL Label */ 
#line 52
  goto switch_break;
  case_2: /* CIL Label */ 
#line 56
  if (SRBits->C) {
#line 56
    tmp___0 = 1;
  } else
#line 56
  if (! SRBits->Z) {
#line 56
    tmp___0 = 1;
  } else {
#line 56
    tmp___0 = 0;
  }
#line 56
  Result = (unsigned char )tmp___0;
#line 57
  goto switch_break;
  case_3: /* CIL Label */ 
#line 59
  if (SRBits->C) {
#line 59
    tmp___1 = 1;
  } else
#line 59
  if (SRBits->Z) {
#line 59
    tmp___1 = 1;
  } else {
#line 59
    tmp___1 = 0;
  }
#line 59
  Result = (unsigned char )tmp___1;
#line 60
  goto switch_break;
  case_4: /* CIL Label */ 
#line 62
  Result = (unsigned char )(! SRBits->C);
#line 63
  goto switch_break;
  case_5: /* CIL Label */ 
#line 65
  Result = (unsigned char )SRBits->C;
#line 66
  goto switch_break;
  case_6: /* CIL Label */ 
#line 69
  Result = (unsigned char )(! SRBits->Z);
#line 70
  goto switch_break;
  case_7: /* CIL Label */ 
#line 73
  Result = (unsigned char )SRBits->Z;
#line 74
  goto switch_break;
  case_8: /* CIL Label */ 
#line 76
  Result = (unsigned char )(! SRBits->V);
#line 77
  goto switch_break;
  case_9: /* CIL Label */ 
#line 79
  Result = (unsigned char )SRBits->V;
#line 80
  goto switch_break;
  case_10: /* CIL Label */ 
#line 82
  Result = (unsigned char )(! SRBits->N);
#line 83
  goto switch_break;
  case_11: /* CIL Label */ 
#line 85
  Result = (unsigned char )SRBits->N;
#line 86
  goto switch_break;
  case_12: /* CIL Label */ 
#line 88
  if (SRBits->N) {
#line 88
    if (SRBits->V) {
#line 88
      tmp___2 = 1;
    } else {
#line 88
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 88
  if (! SRBits->N) {
#line 88
    if (! SRBits->V) {
#line 88
      tmp___2 = 1;
    } else {
#line 88
      tmp___2 = 0;
    }
  } else {
#line 88
    tmp___2 = 0;
  }
#line 88
  Result = (unsigned char )tmp___2;
#line 90
  goto switch_break;
  case_13: /* CIL Label */ 
#line 92
  if (SRBits->N) {
#line 92
    if (! SRBits->V) {
#line 92
      tmp___3 = 1;
    } else {
#line 92
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 92
  if (! SRBits->N) {
#line 92
    if (SRBits->V) {
#line 92
      tmp___3 = 1;
    } else {
#line 92
      tmp___3 = 0;
    }
  } else {
#line 92
    tmp___3 = 0;
  }
#line 92
  Result = (unsigned char )tmp___3;
#line 94
  goto switch_break;
  case_14: /* CIL Label */ 
#line 96
  if (SRBits->N) {
#line 96
    if (SRBits->V) {
#line 96
      if (! SRBits->Z) {
#line 96
        tmp___4 = 1;
      } else {
#line 96
        goto _L___2;
      }
    } else {
#line 96
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 96
  if (! SRBits->N) {
#line 96
    if (! SRBits->V) {
#line 96
      if (! SRBits->Z) {
#line 96
        tmp___4 = 1;
      } else {
#line 96
        tmp___4 = 0;
      }
    } else {
#line 96
      tmp___4 = 0;
    }
  } else {
#line 96
    tmp___4 = 0;
  }
#line 96
  Result = (unsigned char )tmp___4;
#line 98
  goto switch_break;
  case_15: /* CIL Label */ 
#line 100
  if (SRBits->Z) {
#line 100
    tmp___5 = 1;
  } else
#line 100
  if (SRBits->N) {
#line 100
    if (! SRBits->V) {
#line 100
      tmp___5 = 1;
    } else {
#line 100
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 100
  if (! SRBits->N) {
#line 100
    if (SRBits->V) {
#line 100
      tmp___5 = 1;
    } else {
#line 100
      tmp___5 = 0;
    }
  } else {
#line 100
    tmp___5 = 0;
  }
#line 100
  Result = (unsigned char )tmp___5;
#line 102
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 104
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___16].Name, "execute");
#line 104
  tracer_printf((char *)"Unknown Condition Code 0x%02x\n", Instr.Bits.Condition);
  }
#line 105
  return;
  switch_break: /* CIL Label */ ;
  }
#line 107
  if (TRACER_Info[TRACER_default___16].Enabled) {
    {
#line 107
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___16].Name, "execute");
#line 107
    tracer_printf((char *)"S%s: Result=%d\n", code_mnemonic[(int )Instr.Bits.Condition],
                  (int )Result);
    }
  }
#line 109
  if (Result) {
#line 109
    Result = (unsigned char)255;
  }
#line 111
  if (TRACER_Info[TRACER_default___16].Enabled) {
    {
#line 111
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___16].Name, "execute");
#line 111
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 112
  EA_PutValue(& Destination, (unsigned long )Result);
  }
#line 115
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
static long disassemble___16(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SCC_Instr Instr ;

  {
  {
#line 123
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 124
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"S%s",
          code_mnemonic[(int )Instr.Bits.Condition]);
#line 125
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"D%d", Instr.Bits.Register);
#line 126
  *(Arg2 + 0) = (char)0;
  }
#line 127
  return (0L);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
long scc_5206_register(void) 
{ 


  {
  {
#line 132
  instruction_register((unsigned short)20672, (unsigned short)61688, & execute___16,
                       & disassemble___16);
  }
#line 133
  return (1L);
}
}
#line 24 "../i_5206/i_5206.h"
long eor_5206_register(void) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
int EORTime[8]  = 
#line 23 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
  {      1,      3,      3,      3, 
        3,      4,      3,      -1};
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
static enum _TRACER_Channels  const  TRACER_default___17  =    (enum _TRACER_Channels  const  )20;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
static void execute___17(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  EOR_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (Instr.Bits.OPMode == 2U) {
#line 42
    if (TRACER_Info[TRACER_default___17].Enabled) {
      {
#line 42
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 42
      tracer_printf((char *)"<EA>y ^ Dx -> Dx\n");
      }
    }
#line 43
    if (Instr.Bits.EAMode == 1U) {
      {
#line 44
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 44
      tracer_printf((char *)"May not specify Ax for source");
      }
#line 45
      return;
    }
#line 47
    if (TRACER_Info[TRACER_default___17].Enabled) {
      {
#line 47
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 47
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 48
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 48
    if (! tmp) {
#line 48
      return;
    }
#line 49
    if (TRACER_Info[TRACER_default___17].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 49
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 50
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 50
    if (! tmp___0) {
#line 50
      return;
    }
  } else
#line 51
  if (Instr.Bits.OPMode == 6U) {
#line 59
    if (Instr.Bits.EAMode == 7U) {
#line 59
      if (Instr.Bits.EARegister == 4U) {
        {
#line 60
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name,
                      "execute");
#line 60
        tracer_printf((char *)"May not specify Immediate Addressing for destination");
        }
#line 61
        return;
      }
    }
#line 63
    if (TRACER_Info[TRACER_default___17].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 63
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 64
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 64
    if (! tmp___1) {
#line 64
      return;
    }
#line 65
    if (TRACER_Info[TRACER_default___17].Enabled) {
      {
#line 65
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 65
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 66
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 66
    if (! tmp___2) {
#line 66
      return;
    }
  } else {
    {
#line 68
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 68
    tracer_printf((char *)"Unknown OPMode %d", Instr.Bits.OPMode);
    }
#line 69
    return;
  }
  {
#line 72
  EA_GetValue(& SValue, & Source);
#line 73
  EA_GetValue(& DValue, & Destination);
#line 75
  Result = SValue ^ DValue;
  }
#line 76
  if (TRACER_Info[TRACER_default___17].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 76
    tracer_printf((char *)"0x%08lx ^ 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 78
  if (TRACER_Info[TRACER_default___17].Enabled) {
    {
#line 78
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 78
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 79
  EA_PutValue(& Destination, Result);
#line 87
  memory_core.sr &= 65520UL;
#line 88
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 89
  SRBits->Z = (unsigned int )(Result == 0UL);
#line 91
  tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 91
  cycle((unsigned long )EORTime[tmp___3]);
  }
#line 93
  if (TRACER_Info[TRACER_default___17].Enabled) {
    {
#line 93
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___17].Name, "execute");
#line 93
    tracer_printf((char *)"Done\n");
    }
  }
#line 94
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
static long disassemble___17(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  EOR_Instr Instr ;

  {
  {
#line 100
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 101
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EOR.L");
  }
#line 102
  if (Instr.Bits.OPMode == 2U) {
    {
#line 103
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 104
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 106
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 107
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 109
  return (0L);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
long eor_5206_register(void) 
{ 


  {
  {
#line 114
  instruction_register((unsigned short)45440, (unsigned short)61888, & execute___17,
                       & disassemble___17);
  }
#line 115
  return (1L);
}
}
#line 16 "../i_5206/i_5206.h"
long asx_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
int ASXTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
static enum _TRACER_Channels  const  TRACER_default___18  =    (enum _TRACER_Channels  const  )11;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
static void execute___18(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ASX_Instr Instr ;
  int x ;
  char tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 42
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 44
  if (TRACER_Info[TRACER_default___18].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___18].Name, "execute");
#line 44
    tracer_printf((char *)"Source:\n");
    }
  }
#line 45
  if (Instr.Bits.IR == 0U) {
#line 47
    SValue = (unsigned long )Instr.Bits.CountReg;
#line 48
    if (SValue == 0UL) {
#line 48
      SValue = 8UL;
    }
#line 49
    if (TRACER_Info[TRACER_default___18].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___18].Name, "execute");
#line 49
      tracer_printf((char *)"Shift by count in instruction word = %d\n", SValue);
      }
    }
  } else {
    {
#line 51
    tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.CountReg);
    }
#line 51
    if (! tmp) {
#line 51
      return;
    }
    {
#line 53
    EA_GetValue(& SValue, & Source);
#line 54
    SValue &= 63UL;
    }
#line 55
    if (TRACER_Info[TRACER_default___18].Enabled) {
      {
#line 55
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___18].Name, "execute");
#line 55
      tracer_printf((char *)"Shift by count in D%d = \n", Instr.Bits.CountReg, SValue);
      }
    }
  }
#line 57
  if (TRACER_Info[TRACER_default___18].Enabled) {
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___18].Name, "execute");
#line 57
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 58
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 58
  if (! tmp___0) {
#line 58
    return;
  }
  {
#line 59
  EA_GetValue(& DValue, & Destination);
#line 61
  Result = DValue;
  }
#line 62
  if (Instr.Bits.DR == 0U) {
#line 64
    if (TRACER_Info[TRACER_default___18].Enabled) {
      {
#line 64
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___18].Name, "execute");
#line 64
      tracer_printf((char *)"Shift Right\n");
      }
    }
#line 66
    x = 0;
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
#line 66
      if (! ((unsigned long )x < SValue)) {
#line 66
        goto while_break;
      }
#line 67
      SRBits->C = (unsigned int )(Result & 1UL);
#line 68
      SRBits->X = (unsigned int )(Result & 1UL);
#line 69
      Result >>= 1;
#line 70
      if (Result & 1073741824UL) {
#line 71
        Result |= 2147483648UL;
      }
#line 66
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 76
    if (TRACER_Info[TRACER_default___18].Enabled) {
      {
#line 76
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___18].Name, "execute");
#line 76
      tracer_printf((char *)"Shift Left\n");
      }
    }
#line 77
    x = 0;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! ((unsigned long )x < SValue)) {
#line 77
        goto while_break___0;
      }
#line 78
      if (Result & 2147483648UL) {
#line 78
        SRBits->C = 1U;
      } else {
#line 78
        SRBits->C = 0U;
      }
#line 79
      if (Result & 2147483648UL) {
#line 79
        SRBits->X = 1U;
      } else {
#line 79
        SRBits->X = 0U;
      }
#line 80
      Result <<= 1;
#line 77
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 83
  if ((long )Result < 0L) {
#line 83
    SRBits->N = 1U;
  } else {
#line 83
    SRBits->N = 0U;
  }
#line 84
  if (Result == 0UL) {
#line 84
    SRBits->Z = 1U;
  } else {
#line 84
    SRBits->Z = 0U;
  }
#line 85
  SRBits->V = 0U;
#line 87
  if (TRACER_Info[TRACER_default___18].Enabled) {
    {
#line 87
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___18].Name, "execute");
    }
#line 87
    if (Instr.Bits.DR == 0U) {
#line 87
      tmp___1 = ">>";
    } else {
#line 87
      tmp___1 = "<<";
    }
    {
#line 87
    tracer_printf((char *)"0x%08lx %s 0x%02lx = 0x%08lx\n", DValue, tmp___1, SValue,
                  Result);
    }
  }
#line 90
  if (TRACER_Info[TRACER_default___18].Enabled) {
    {
#line 90
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___18].Name, "execute");
#line 90
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 91
  EA_PutValue(& Destination, Result);
#line 93
  cycle((unsigned long )ASXTime);
  }
#line 95
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
static long disassemble___18(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ASX_Instr Instr ;
  long SValue ;

  {
  {
#line 101
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 103
  if (Instr.Bits.DR == 0U) {
    {
#line 105
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ASR.L");
    }
  } else {
    {
#line 108
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ASL.L");
    }
  }
#line 110
  if (Instr.Bits.IR == 0U) {
#line 112
    SValue = (long )Instr.Bits.CountReg;
#line 113
    if (SValue == 0L) {
#line 113
      SValue = 8L;
    }
    {
#line 114
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02ld",
            SValue);
    }
  } else {
    {
#line 116
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"D%d",
            Instr.Bits.CountReg);
    }
  }
  {
#line 118
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 119
  return (0L);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
long asx_5206_register(void) 
{ 


  {
  {
#line 124
  instruction_register((unsigned short)57472, (unsigned short)61656, & execute___18,
                       & disassemble___18);
  }
#line 125
  return (2L);
}
}
#line 19 "../i_5206/i_5206.h"
long clr_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
int CLRTime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
  {      1,      1,      1,      1, 
        1,      2,      1,      -1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
static enum _TRACER_Channels  const  TRACER_default___19  =    (enum _TRACER_Channels  const  )14;
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
short const   CLR_SizeBits[4]  = {      (short const   )8,      (short const   )16,      (short const   )32,      (short const   )0};
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
char const   CLR_SizeStr[4]  = {      (char const   )'B',      (char const   )'W',      (char const   )'L',      (char const   )'?'};
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
static void execute___19(void) 
{ 
  struct _Address Destination ;
  CLR_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 43
  if (Instr.Bits.Size == 3U) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___19].Name, "execute");
#line 44
    tracer_printf((char *)"Invalid size=3", memory_core.pc);
    }
#line 45
    return;
  }
#line 48
  if (TRACER_Info[TRACER_default___19].Enabled) {
    {
#line 48
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___19].Name, "execute");
#line 48
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 49
  tmp = EA_GetFromPC(& Destination, (short )CLR_SizeBits[(short )Instr.Bits.Size],
                     (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 49
  if (! tmp) {
#line 49
    return;
  }
#line 50
  if (TRACER_Info[TRACER_default___19].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___19].Name, "execute");
#line 50
    tracer_printf((char *)"Clearing:\n");
    }
  }
  {
#line 51
  EA_PutValue(& Destination, 0UL);
#line 59
  SRBits->N = 0U;
#line 60
  SRBits->Z = 1U;
#line 61
  SRBits->V = 0U;
#line 62
  SRBits->C = 0U;
#line 63
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 63
  cycle((unsigned long )CLRTime[tmp___0]);
  }
#line 64
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
static long disassemble___19(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  CLR_Instr Instr ;

  {
  {
#line 70
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 72
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"CLR.%c",
          (int const   )CLR_SizeStr[(short )Instr.Bits.Size]);
#line 74
  Addressing_Print((short )CLR_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.EAMode,
                   (char )Instr.Bits.EARegister, Arg1);
#line 75
  *(Arg2 + 0) = (char)0;
  }
#line 77
  return (0L);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
long clr_5206_register(void) 
{ 


  {
  {
#line 82
  instruction_register((unsigned short)16896, (unsigned short)65280, & execute___19,
                       & disassemble___19);
  }
#line 83
  return (1L);
}
}
#line 39 "../i_5206/i_5206.h"
long mulu_l_5206_register(void) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
int MULLTime[8]  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
  {      18,      20,      20,      20, 
        20,      -1,      -1,      -1};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
static enum _TRACER_Channels  const  TRACER_default___20  =    (enum _TRACER_Channels  const  )35;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
static void execute___20(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  char Register ;
  unsigned long Instr2 ;
  MULU_L_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 41
  Memory_RetrFromPC(& Instr2, (short)16);
#line 42
  Register = (char )((Instr2 & 28672UL) >> 12);
  }
#line 45
  if (Instr.Bits.EAMode == 1U) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___20].Name, "execute");
#line 46
    tracer_printf((char *)"May Not specify Address Register (Ay) for MULU.L");
    }
#line 47
    return;
  } else
#line 48
  if (Instr.Bits.EAMode == 7U) {
    {
#line 49
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___20].Name, "execute");
#line 49
    tracer_printf((char *)"May Not specify Direct Addressing for MULU.L");
    }
#line 50
    return;
  }
#line 52
  if (TRACER_Info[TRACER_default___20].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___20].Name, "execute");
#line 52
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 53
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 53
  if (! tmp) {
#line 53
    return;
  }
#line 54
  if (TRACER_Info[TRACER_default___20].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___20].Name, "execute");
#line 54
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 55
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, Register);
  }
#line 55
  if (! tmp___0) {
#line 55
    return;
  }
  {
#line 57
  EA_GetValue(& SValue, & Source);
#line 58
  EA_GetValue(& DValue, & Destination);
  }
#line 63
  if (Instr2 & 2048UL) {
#line 65
    Result = (unsigned long )((long )SValue * (long )DValue);
  } else {
#line 68
    Result = SValue * DValue;
  }
#line 71
  if (TRACER_Info[TRACER_default___20].Enabled) {
    {
#line 71
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___20].Name, "execute");
#line 71
    tracer_printf((char *)"0x%08lx * 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 74
  memory_core.sr &= 65520UL;
#line 75
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 76
  SRBits->Z = (unsigned int )(Result == 0UL);
#line 78
  if (TRACER_Info[TRACER_default___20].Enabled) {
    {
#line 78
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___20].Name, "execute");
#line 78
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 79
  EA_PutValue(& Destination, Result);
  }
#line 81
  if (TRACER_Info[TRACER_default___20].Enabled) {
    {
#line 81
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___20].Name, "execute");
#line 81
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 83
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 83
  cycle((unsigned long )MULLTime[tmp___1]);
  }
#line 85
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
static long disassemble___20(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long Instr2 ;
  char Register ;
  MULU_L_Instr Instr ;
  int tmp ;

  {
  {
#line 93
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 94
  Memory_RetrFromPC(& Instr2, (short)16);
#line 95
  Register = (char )((Instr2 & 28672UL) >> 12);
  }
#line 97
  if (Instr2 & 2048UL) {
#line 97
    tmp = 'S';
  } else {
#line 97
    tmp = 'U';
  }
  {
#line 97
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MUL%c.L",
          tmp);
#line 98
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 99
  Addressing_Print((short)32, (char)0, Register, Arg2);
  }
#line 100
  return (0L);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
long mulu_l_5206_register(void) 
{ 


  {
  {
#line 105
  instruction_register((unsigned short)19456, (unsigned short)65472, & execute___20,
                       & disassemble___20);
  }
#line 106
  return (2L);
}
}
#line 14 "../i_5206/i_5206.h"
long and_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
int ANDTime[2][8]  = { {        1,        3,        3,        3, 
            3,        4,        3,        1}, 
   {        -1,        3,        3,        3, 
            3,        4,        3,        -1}};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
static enum _TRACER_Channels  const  TRACER_default___21  =    (enum _TRACER_Channels  const  )9;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
static void execute___21(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  AND_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (Instr.Bits.OPMode == 2U) {
#line 43
    if (TRACER_Info[TRACER_default___21].Enabled) {
      {
#line 43
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 43
      tracer_printf((char *)"<EA>y & Dx -> Dx\n");
      }
    }
#line 44
    if (Instr.Bits.EAMode == 1U) {
      {
#line 45
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 45
      tracer_printf((char *)"May not specify Ax for source");
      }
#line 46
      return;
    }
#line 48
    if (TRACER_Info[TRACER_default___21].Enabled) {
      {
#line 48
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 48
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 49
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 49
    if (! tmp) {
#line 49
      return;
    }
#line 50
    if (TRACER_Info[TRACER_default___21].Enabled) {
      {
#line 50
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 50
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 51
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 51
    if (! tmp___0) {
#line 51
      return;
    }
  } else
#line 52
  if (Instr.Bits.OPMode == 6U) {
#line 53
    if (Instr.Bits.EAMode == 0U) {
      {
#line 54
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 54
      tracer_printf((char *)"May not specify Dx for destination when source is Dx");
      }
#line 55
      return;
    } else
#line 56
    if (Instr.Bits.EAMode == 1U) {
      {
#line 57
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 57
      tracer_printf((char *)"May not specify Ax for destination when source is Dx");
      }
#line 58
      return;
    } else
#line 59
    if (Instr.Bits.EAMode == 7U) {
#line 59
      if (Instr.Bits.EARegister == 4U) {
        {
#line 60
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name,
                      "execute");
#line 60
        tracer_printf((char *)"May not specify Immediate Addressing for destination");
        }
#line 61
        return;
      }
    }
#line 63
    if (TRACER_Info[TRACER_default___21].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 63
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 64
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 64
    if (! tmp___1) {
#line 64
      return;
    }
#line 65
    if (TRACER_Info[TRACER_default___21].Enabled) {
      {
#line 65
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 65
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 66
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 66
    if (! tmp___2) {
#line 66
      return;
    }
  } else {
    {
#line 68
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 68
    tracer_printf((char *)"Unknown OPMode %d", Instr.Bits.OPMode);
    }
#line 69
    return;
  }
  {
#line 72
  EA_GetValue(& SValue, & Source);
#line 73
  EA_GetValue(& DValue, & Destination);
#line 75
  Result = SValue & DValue;
  }
#line 76
  if (TRACER_Info[TRACER_default___21].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 76
    tracer_printf((char *)"0x%08lx & 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 78
  if (TRACER_Info[TRACER_default___21].Enabled) {
    {
#line 78
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 78
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 79
  EA_PutValue(& Destination, Result);
#line 88
  memory_core.sr &= 65520UL;
#line 89
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 90
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 92
  if (TRACER_Info[TRACER_default___21].Enabled) {
    {
#line 92
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___21].Name, "execute");
#line 92
    tracer_printf((char *)"Done\n");
    }
  }
#line 94
  if (Instr.Bits.OPMode == 2U) {
    {
#line 95
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 95
    cycle((unsigned long )ANDTime[0][tmp___3]);
    }
  } else {
    {
#line 96
    tmp___4 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 96
    cycle((unsigned long )ANDTime[1][tmp___4]);
    }
  }
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
static long disassemble___21(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  AND_Instr Instr ;

  {
  {
#line 104
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 105
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"AND.L");
  }
#line 106
  if (Instr.Bits.OPMode == 2U) {
    {
#line 107
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 108
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 110
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 111
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 113
  return (0L);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
long and_5206_register(void) 
{ 


  {
  {
#line 118
  instruction_register((unsigned short)49152, (unsigned short)61440, & execute___21,
                       & disassemble___21);
  }
#line 119
  return (1L);
}
}
#line 37 "../i_5206/i_5206.h"
long moveq_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
int MOVEQTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
static enum _TRACER_Channels  const  TRACER_default___22  =    (enum _TRACER_Channels  const  )33;
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
static void execute___22(void) 
{ 
  struct _Address Destination ;
  unsigned long SValue ;
  MOVEQ_Instr Instr ;
  char tmp ;

  {
  {
#line 37
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 39
  if (TRACER_Info[TRACER_default___22].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___22].Name, "execute");
#line 39
    tracer_printf((char *)"Source: (from Instruction word) = 0x%02x\n", Instr.Bits.Data);
    }
  }
#line 40
  SValue = (unsigned long )Instr.Bits.Data;
#line 42
  if (TRACER_Info[TRACER_default___22].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___22].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp) {
#line 43
    return;
  }
#line 45
  if (TRACER_Info[TRACER_default___22].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___22].Name, "execute");
#line 45
    tracer_printf((char *)"Storing result:\n");
    }
  }
  {
#line 46
  EA_PutValue(& Destination, SValue);
#line 54
  memory_core.sr &= 65520UL;
#line 55
  SRBits->N = (unsigned int )((long )SValue < 0L);
#line 56
  SRBits->Z = (unsigned int )(SValue == 0UL);
  }
#line 58
  if (TRACER_Info[TRACER_default___22].Enabled) {
    {
#line 58
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___22].Name, "execute");
#line 58
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 60
  cycle((unsigned long )MOVEQTime);
  }
#line 62
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
static long disassemble___22(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVEQ_Instr Instr ;

  {
  {
#line 68
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 70
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVEQ");
#line 72
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02X",
          (int )((char )Instr.Bits.Data) & 255);
#line 73
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 74
  return (0L);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
long moveq_5206_register(void) 
{ 


  {
  {
#line 79
  instruction_register((unsigned short)28672, (unsigned short)61696, & execute___22,
                       & disassemble___22);
  }
#line 80
  return (1L);
}
}
#line 46 "../i_5206/i_5206.h"
long ori_5206_register(void) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
int ORITime  =    1;
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
static enum _TRACER_Channels  const  TRACER_default___23  =    (enum _TRACER_Channels  const  )42;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
static void execute___23(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ORI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___23].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___23].Name, "execute");
#line 38
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 39
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
#line 40
  if (TRACER_Info[TRACER_default___23].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___23].Name, "execute");
#line 40
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 41
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 41
  if (! tmp___0) {
#line 41
    return;
  }
  {
#line 43
  EA_GetValue(& SValue, & Source);
#line 44
  EA_GetValue(& DValue, & Destination);
#line 46
  Result = SValue | DValue;
  }
#line 48
  if (TRACER_Info[TRACER_default___23].Enabled) {
    {
#line 48
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___23].Name, "execute");
#line 48
    tracer_printf((char *)"0x%08lx | 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 50
  if (TRACER_Info[TRACER_default___23].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___23].Name, "execute");
#line 50
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 51
  EA_PutValue(& Destination, Result);
#line 59
  memory_core.sr &= 65520UL;
#line 60
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 61
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 63
  if (TRACER_Info[TRACER_default___23].Enabled) {
    {
#line 63
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___23].Name, "execute");
#line 63
    tracer_printf((char *)"Done");
    }
  }
  {
#line 65
  cycle((unsigned long )ORITime);
  }
#line 67
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
static long disassemble___23(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ORI_Instr Instr ;

  {
  {
#line 73
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 74
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ORI.L");
#line 75
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 76
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 77
  return (0L);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
long ori_5206_register(void) 
{ 


  {
  {
#line 82
  instruction_register((unsigned short)128, (unsigned short)65528, & execute___23,
                       & disassemble___23);
  }
#line 83
  return (1L);
}
}
#line 54 "../i_5206/i_5206.h"
long subi_5206_register(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
int SUBITime  =    1;
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
static enum _TRACER_Channels  const  TRACER_default___24  =    (enum _TRACER_Channels  const  )51;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
static void execute___24(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUBI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___24].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___24].Name, "execute");
#line 41
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
#line 43
  if (TRACER_Info[TRACER_default___24].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___24].Name, "execute");
#line 43
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 44
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 44
  if (! tmp___0) {
#line 44
    return;
  }
  {
#line 46
  EA_GetValue(& SValue, & Source);
#line 47
  EA_GetValue(& DValue, & Destination);
#line 49
  Result = DValue - SValue;
  }
#line 51
  if (TRACER_Info[TRACER_default___24].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___24].Name, "execute");
#line 51
    tracer_printf((char *)"0x%08lx - 0x%08lx = 0x%08lx\n", DValue, SValue, Result);
    }
  }
  {
#line 54
  SR_Set((short)52, (long )SValue, (long )DValue, (long )Result);
  }
#line 56
  if (TRACER_Info[TRACER_default___24].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___24].Name, "execute");
#line 56
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 57
  EA_PutValue(& Destination, Result);
  }
#line 59
  if (TRACER_Info[TRACER_default___24].Enabled) {
    {
#line 59
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___24].Name, "execute");
#line 59
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 61
  cycle((unsigned long )SUBITime);
  }
#line 63
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
static long disassemble___24(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUBI_Instr Instr ;

  {
  {
#line 69
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 70
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUBI.L");
#line 71
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 72
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 73
  return (0L);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
long subi_5206_register(void) 
{ 


  {
  {
#line 78
  instruction_register((unsigned short)1152, (unsigned short)65528, & execute___24,
                       & disassemble___24);
  }
#line 79
  return (1L);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 77 "../memory.h"
extern char Memory_Retr(unsigned long *Result , short Size , long Offset ) ;
#line 83
extern char Memory_Stor(short Size , long Offset , unsigned long Value ) ;
#line 36 "../i_5206/i_5206.h"
long movem_5206_register(void) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
int MOVEMTime  =    1;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
static void execute___25(void) 
{ 
  struct _Address Address ;
  unsigned long AddressValue ;
  MOVEM_Instr Instr ;
  unsigned long RegisterListMask ;
  short move_count ;
  long x ;
  char tmp ;

  {
  {
#line 42
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 43
  Memory_RetrFromPC(& RegisterListMask, (short)16);
  }
#line 48
  if (Instr.Bits.EAMode != 2U) {
#line 48
    if (Instr.Bits.EAMode != 5U) {
      {
#line 49
      printf((char const   */* __restrict  */)"MOVEM: EAMode 0x%02x is not allowed\n",
             Instr.Bits.EAMode);
      }
#line 50
      return;
    }
  }
  {
#line 55
  tmp = EA_GetFromPC(& Address, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 55
  if (! tmp) {
#line 55
    return;
  }
  {
#line 56
  EA_GetEA(& AddressValue, & Address);
#line 58
  move_count = (short)0;
  }
#line 59
  if (Instr.Bits.Direction == 0U) {
#line 61
    x = 0L;
    {
#line 61
    while (1) {
      while_continue: /* CIL Label */ ;
#line 61
      if (! (x < 8L)) {
#line 61
        goto while_break;
      }
#line 62
      if (RegisterListMask & 1UL) {
        {
#line 64
        Memory_Stor((short)32, (long )(AddressValue + (unsigned long )((int )move_count * 4)),
                    memory_core.d[x]);
#line 65
        move_count = (short )((int )move_count + 1);
        }
      }
#line 61
      x ++;
#line 61
      RegisterListMask >>= 1;
    }
    while_break: /* CIL Label */ ;
    }
#line 68
    x = 8L;
    {
#line 68
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 68
      if (! (x < 16L)) {
#line 68
        goto while_break___0;
      }
#line 69
      if (RegisterListMask & 1UL) {
        {
#line 71
        Memory_Stor((short)32, (long )(AddressValue + (unsigned long )((int )move_count * 4)),
                    memory_core.a[x - 8L]);
#line 72
        move_count = (short )((int )move_count + 1);
        }
      }
#line 68
      x ++;
#line 68
      RegisterListMask >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 78
    x = 0L;
    {
#line 78
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 78
      if (! (x < 8L)) {
#line 78
        goto while_break___1;
      }
#line 79
      if (RegisterListMask & 1UL) {
        {
#line 81
        Memory_Retr(& memory_core.d[x], (short)32, (long )(AddressValue + (unsigned long )((int )move_count * 4)));
#line 82
        move_count = (short )((int )move_count + 1);
        }
      }
#line 78
      x ++;
#line 78
      RegisterListMask >>= 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 85
    x = 8L;
    {
#line 85
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 85
      if (! (x < 16L)) {
#line 85
        goto while_break___2;
      }
#line 86
      if (RegisterListMask & 1UL) {
        {
#line 88
        Memory_Retr(& memory_core.a[x - 8L], (short)32, (long )(AddressValue + (unsigned long )((int )move_count * 4)));
#line 89
        move_count = (short )((int )move_count + 1);
        }
      }
#line 85
      x ++;
#line 85
      RegisterListMask >>= 1;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 95
  cycle((unsigned long )(MOVEMTime + (int )move_count));
  }
#line 96
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
static int movem_print(char *buffer , char reg , unsigned long reg_list ) 
{ 
  int x ;
  char n_printed ;
  char one_printed ;
  char *orignal_buffer ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 102
  n_printed = (char)0;
#line 103
  one_printed = (char)0;
#line 104
  orignal_buffer = buffer;
#line 109
  x = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (x < 9)) {
#line 109
      goto while_break;
    }
#line 110
    if (reg_list & 1UL) {
#line 111
      if (! n_printed) {
#line 114
        if (one_printed) {
          {
#line 115
          tmp = sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)",");
#line 115
          buffer += tmp;
          }
        }
        {
#line 116
        tmp___0 = sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%c%d",
                          (int )reg, x);
#line 116
        buffer += tmp___0;
#line 117
        one_printed = (char)1;
        }
      }
#line 119
      n_printed = (char )((int )n_printed + 1);
    } else
#line 121
    if ((int )n_printed > 1) {
      {
#line 122
      tmp___1 = sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"-%c%d",
                        (int )reg, x - 1);
#line 122
      buffer += tmp___1;
#line 123
      n_printed = (char)0;
      }
    }
#line 109
    x ++;
#line 109
    reg_list >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return ((int )(buffer - orignal_buffer));
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
static long disassemble___25(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVEM_Instr Instr ;
  char *regStr ;
  short size ;
  unsigned long RegisterListMask ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 137
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 138
  Memory_RetrFromPC(& RegisterListMask, (short)16);
#line 140
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVEM.L");
  }
#line 142
  if (Instr.Bits.Direction == 0U) {
    {
#line 144
    regStr = Arg1;
#line 145
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  } else {
    {
#line 147
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 148
    regStr = Arg2;
    }
  }
  {
#line 150
  *(regStr + 0) = (char)0;
#line 155
  tmp = movem_print(regStr, (char )'D', RegisterListMask & 255UL);
#line 155
  size = (short )tmp;
  }
#line 156
  if (size) {
#line 156
    if (RegisterListMask & 65280UL) {
      {
#line 157
      regStr += (int )size;
#line 158
      tmp___0 = sprintf((char */* __restrict  */)regStr, (char const   */* __restrict  */)"/");
#line 158
      regStr += tmp___0;
      }
    }
  }
  {
#line 160
  movem_print(regStr, (char )'A', (RegisterListMask & 65280UL) >> 8);
  }
#line 162
  return (0L);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
long movem_5206_register(void) 
{ 


  {
  {
#line 167
  instruction_register((unsigned short)18624, (unsigned short)64448, & execute___25,
                       & disassemble___25);
  }
#line 168
  return (1L);
}
}
#line 21 "../i_5206/i_5206.h"
long cmpa_5206_register(void) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
int CMPATime[8]  = 
#line 21 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
  {      1,      3,      3,      3, 
        3,      4,      3,      1};
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
static enum _TRACER_Channels  const  TRACER_default___25  =    (enum _TRACER_Channels  const  )16;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
static void execute___26(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  CMPA_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___25].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___25].Name, "execute");
#line 38
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 39
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
#line 40
  if (TRACER_Info[TRACER_default___25].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___25].Name, "execute");
#line 40
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 41
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 41
  if (! tmp___0) {
#line 41
    return;
  }
  {
#line 43
  EA_GetValue(& SValue, & Source);
#line 44
  EA_GetValue(& DValue, & Destination);
#line 46
  Result = DValue - SValue;
  }
#line 48
  if (TRACER_Info[TRACER_default___25].Enabled) {
    {
#line 48
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___25].Name, "execute");
#line 48
    tracer_printf((char *)"Comparing 0x%08lx with 0x%08lx\n", SValue, DValue);
    }
  }
  {
#line 51
  SR_Set((short)18, (long )SValue, (long )DValue, (long )Result);
  }
#line 53
  if (TRACER_Info[TRACER_default___25].Enabled) {
    {
#line 53
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___25].Name, "execute");
#line 53
    tracer_printf((char *)"Done");
    }
  }
  {
#line 54
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 54
  cycle((unsigned long )CMPATime[tmp___1]);
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
static long disassemble___26(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  CMPA_Instr Instr ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 62
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"CMPA.L");
#line 63
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 64
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg2);
  }
#line 65
  return (0L);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
long cmpa_5206_register(void) 
{ 


  {
  {
#line 70
  instruction_register((unsigned short)45504, (unsigned short)61888, & execute___26,
                       & disassemble___26);
  }
#line 71
  return (1L);
}
}
#line 9 "../i_5206/i_5206.h"
long add_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
int ADDTime[2][8]  = { {        1,        3,        3,        3, 
            3,        4,        3,        1}, 
   {        -1,        3,        3,        3, 
            3,        4,        3,        -1}};
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
static enum _TRACER_Channels  const  TRACER_default___26  =    (enum _TRACER_Channels  const  )4;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
static void execute___27(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ADD_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (Instr.Bits.OPMode == 2U) {
#line 43
    if (TRACER_Info[TRACER_default___26].Enabled) {
      {
#line 43
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 43
      tracer_printf((char *)"<EA>y + Dx -> Dx\n");
      }
    }
#line 44
    if (TRACER_Info[TRACER_default___26].Enabled) {
      {
#line 44
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 44
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 45
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 45
    if (! tmp) {
#line 45
      return;
    }
#line 46
    if (TRACER_Info[TRACER_default___26].Enabled) {
      {
#line 46
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 46
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 47
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 47
    if (! tmp___0) {
#line 47
      return;
    }
  } else {
#line 49
    if (TRACER_Info[TRACER_default___26].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 49
      tracer_printf((char *)"Dy + <EA>x -> <EA>x\n");
      }
    }
#line 50
    if (Instr.Bits.EAMode == 0U) {
      {
#line 51
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 51
      tracer_printf((char *)"May not specify Dx for destination when source is Dx");
      }
#line 52
      return;
    } else
#line 53
    if (Instr.Bits.EAMode == 1U) {
      {
#line 54
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 54
      tracer_printf((char *)"May not specify Ax for destination when source is Dx");
      }
#line 55
      return;
    }
#line 57
    if (TRACER_Info[TRACER_default___26].Enabled) {
      {
#line 57
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 57
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 58
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 58
    if (! tmp___1) {
#line 58
      return;
    }
#line 59
    if (TRACER_Info[TRACER_default___26].Enabled) {
      {
#line 59
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 59
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 60
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 60
    if (! tmp___2) {
#line 60
      return;
    }
  }
  {
#line 62
  EA_GetValue(& SValue, & Source);
#line 63
  EA_GetValue(& DValue, & Destination);
#line 65
  Result = SValue + DValue;
  }
#line 67
  if (TRACER_Info[TRACER_default___26].Enabled) {
    {
#line 67
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 67
    tracer_printf((char *)"0x%08lx + 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
  {
#line 69
  SR_Set((short)0, (long )SValue, (long )DValue, (long )Result);
  }
#line 71
  if (TRACER_Info[TRACER_default___26].Enabled) {
    {
#line 71
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___26].Name, "execute");
#line 71
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 72
  EA_PutValue(& Destination, Result);
  }
#line 74
  if (Instr.Bits.OPMode == 2U) {
    {
#line 75
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 75
    cycle((unsigned long )ADDTime[0][tmp___3]);
    }
  } else {
    {
#line 77
    tmp___4 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 77
    cycle((unsigned long )ADDTime[1][tmp___4]);
    }
  }
#line 79
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
static long disassemble___27(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADD_Instr Instr ;

  {
  {
#line 85
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 87
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADD.L");
  }
#line 88
  if (Instr.Bits.OPMode == 2U) {
    {
#line 89
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 90
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 92
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 93
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 95
  return (0L);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
long add_5206_register(void) 
{ 


  {
  {
#line 101
  instruction_register((unsigned short)53248, (unsigned short)61440, & execute___27,
                       & disassemble___27);
  }
#line 102
  return (1L);
}
}
#line 15 "../i_5206/i_5206.h"
long andi_5206_register(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
int ANDITime  =    1;
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
static enum _TRACER_Channels  const  TRACER_default___27  =    (enum _TRACER_Channels  const  )10;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
static void execute___28(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ANDI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___27].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___27].Name, "execute");
#line 41
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
#line 43
  if (TRACER_Info[TRACER_default___27].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___27].Name, "execute");
#line 43
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 44
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 44
  if (! tmp___0) {
#line 44
    return;
  }
  {
#line 46
  EA_GetValue(& SValue, & Source);
#line 47
  EA_GetValue(& DValue, & Destination);
#line 49
  Result = SValue & DValue;
  }
#line 50
  if (TRACER_Info[TRACER_default___27].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___27].Name, "execute");
#line 50
    tracer_printf((char *)"0x%08lx & 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 52
  if (TRACER_Info[TRACER_default___27].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___27].Name, "execute");
#line 52
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 53
  EA_PutValue(& Destination, Result);
#line 62
  memory_core.sr &= 65520UL;
#line 63
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 64
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 66
  if (TRACER_Info[TRACER_default___27].Enabled) {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___27].Name, "execute");
#line 66
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 68
  cycle((unsigned long )ANDITime);
  }
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
static long disassemble___28(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ANDI_Instr Instr ;

  {
  {
#line 76
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 77
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ANDI.L");
#line 78
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 79
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 80
  return (0L);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
long andi_5206_register(void) 
{ 


  {
  {
#line 85
  instruction_register((unsigned short)640, (unsigned short)65528, & execute___28,
                       & disassemble___28);
  }
#line 86
  return (1L);
}
}
#line 52 "../i_5206/i_5206.h"
long sub_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
int SUBTime[2][8]  = { {        1,        3,        3,        3, 
            3,        4,        3,        1}, 
   {        -1,        3,        3,        3, 
            3,        4,        3,        -1}};
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
static enum _TRACER_Channels  const  TRACER_default___28  =    (enum _TRACER_Channels  const  )49;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
static void execute___29(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUB_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (Instr.Bits.OPMode == 2U) {
#line 43
    if (TRACER_Info[TRACER_default___28].Enabled) {
      {
#line 43
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 43
      tracer_printf((char *)"<EA>y + Dx -> Dx\n");
      }
    }
#line 44
    if (TRACER_Info[TRACER_default___28].Enabled) {
      {
#line 44
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 44
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 45
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 45
    if (! tmp) {
#line 45
      return;
    }
#line 46
    if (TRACER_Info[TRACER_default___28].Enabled) {
      {
#line 46
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 46
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 47
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 47
    if (! tmp___0) {
#line 47
      return;
    }
  } else
#line 48
  if (Instr.Bits.OPMode == 6U) {
#line 49
    if (TRACER_Info[TRACER_default___28].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 49
      tracer_printf((char *)"Dy + <EA>x -> <EA>x\n");
      }
    }
#line 50
    if (Instr.Bits.EAMode == 0U) {
      {
#line 51
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 51
      tracer_printf((char *)"May not specify Dx for destination when source is Dx");
      }
#line 52
      return;
    } else
#line 53
    if (Instr.Bits.EAMode == 1U) {
      {
#line 54
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 54
      tracer_printf((char *)"May not specify Ax for destination when source is Dx");
      }
#line 55
      return;
    }
#line 57
    if (TRACER_Info[TRACER_default___28].Enabled) {
      {
#line 57
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 57
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 58
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 58
    if (! tmp___1) {
#line 58
      return;
    }
#line 59
    if (TRACER_Info[TRACER_default___28].Enabled) {
      {
#line 59
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 59
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 60
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 60
    if (! tmp___2) {
#line 60
      return;
    }
  } else {
    {
#line 62
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 62
    tracer_printf((char *)"Unknown opcode %x\n", Instr.Bits.OPMode);
    }
#line 63
    return;
  }
  {
#line 65
  EA_GetValue(& SValue, & Source);
#line 66
  EA_GetValue(& DValue, & Destination);
#line 68
  Result = DValue - SValue;
  }
#line 70
  if (TRACER_Info[TRACER_default___28].Enabled) {
    {
#line 70
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 70
    tracer_printf((char *)"0x%08lx - 0x%08lx = 0x%08lx\n", DValue, SValue, Result);
    }
  }
  {
#line 73
  SR_Set((short)50, (long )SValue, (long )DValue, (long )Result);
  }
#line 75
  if (TRACER_Info[TRACER_default___28].Enabled) {
    {
#line 75
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 75
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 76
  EA_PutValue(& Destination, Result);
  }
#line 78
  if (TRACER_Info[TRACER_default___28].Enabled) {
    {
#line 78
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___28].Name, "execute");
#line 78
    tracer_printf((char *)"Done\n");
    }
  }
#line 80
  if (Instr.Bits.OPMode == 2U) {
    {
#line 81
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 81
    cycle((unsigned long )SUBTime[0][tmp___3]);
    }
  } else {
    {
#line 82
    tmp___4 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 82
    cycle((unsigned long )SUBTime[1][tmp___4]);
    }
  }
#line 84
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
static long disassemble___29(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUB_Instr Instr ;

  {
  {
#line 90
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 91
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUB.L");
  }
#line 92
  if (Instr.Bits.OPMode == 2U) {
    {
#line 93
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 94
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 96
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 97
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 99
  return (0L);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
long sub_5206_register(void) 
{ 


  {
  {
#line 104
  instruction_register((unsigned short)36864, (unsigned short)61440, & execute___29,
                       & disassemble___29);
  }
#line 105
  return (1L);
}
}
#line 57 "../i_5206/i_5206.h"
long swap_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
int SWAPTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
static enum _TRACER_Channels  const  TRACER_default___29  =    (enum _TRACER_Channels  const  )54;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
static void execute___30(void) 
{ 
  struct _Address Destination ;
  unsigned long DValue ;
  unsigned long Tmp ;
  SWAP_Instr Instr ;
  char tmp ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___29].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___29].Name, "execute");
#line 38
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 39
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
  {
#line 40
  EA_GetValue(& DValue, & Destination);
#line 41
  Tmp = (DValue << 16) & 4294901760UL;
#line 42
  Tmp += (DValue >> 16) & 65535UL;
  }
#line 44
  if (TRACER_Info[TRACER_default___29].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___29].Name, "execute");
#line 44
    tracer_printf((char *)"Storing result:\n");
    }
  }
  {
#line 45
  EA_PutValue(& Destination, Tmp);
  }
#line 53
  if ((long )Tmp < 0L) {
#line 53
    SRBits->N = 1U;
  } else {
#line 53
    SRBits->N = 0U;
  }
#line 54
  if (Tmp == 0UL) {
#line 54
    SRBits->Z = 1U;
  } else {
#line 54
    SRBits->Z = 0U;
  }
  {
#line 55
  SRBits->V = 0U;
#line 56
  SRBits->C = 0U;
#line 58
  cycle((unsigned long )SWAPTime);
  }
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
static long disassemble___30(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SWAP_Instr Instr ;

  {
  {
#line 66
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 68
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SWAP");
#line 70
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 71
  *(Arg2 + 0) = (char)0;
  }
#line 73
  return (0L);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
long swap_5206_register(void) 
{ 


  {
  {
#line 78
  instruction_register((unsigned short)18496, (unsigned short)65528, & execute___30,
                       & disassemble___30);
  }
#line 79
  return (1L);
}
}
#line 58 "../i_5206/i_5206.h"
long trap_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
int TRAPTime  =    15;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
static enum _TRACER_Channels  const  TRACER_default___30  =    (enum _TRACER_Channels  const  )55;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
static void execute___31(void) 
{ 
  TRAP_Instr Instr ;

  {
  {
#line 34
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 36
  if (TRACER_Info[TRACER_default___30].Enabled) {
    {
#line 36
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___30].Name, "execute");
#line 36
    tracer_printf((char *)"Vector=0x%02x\n", Instr.Bits.Vector);
    }
  }
  {
#line 41
  exception_do_exception((short )(32U + Instr.Bits.Vector));
  }
#line 42
  if (TRACER_Info[TRACER_default___30].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___30].Name, "execute");
#line 42
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 44
  cycle((unsigned long )TRAPTime);
  }
#line 46
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
static long disassemble___31(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  TRAP_Instr Instr ;

  {
  {
#line 52
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 53
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TRAP");
#line 54
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02X",
          Instr.Bits.Vector);
#line 55
  *(Arg2 + 0) = (char)0;
  }
#line 56
  return (0L);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
long trap_5206_register(void) 
{ 


  {
  {
#line 61
  instruction_register((unsigned short)20032, (unsigned short)65520, & execute___31,
                       & disassemble___31);
  }
#line 62
  return (1L);
}
}
#line 12 "../i_5206/i_5206.h"
long addq_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
int ADDQTime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
  {      1,      3,      3,      3, 
        3,      4,      3,      -1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
static enum _TRACER_Channels  const  TRACER_default___31  =    (enum _TRACER_Channels  const  )7;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
static void execute___32(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ADDQ_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___31].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___31].Name, "execute");
#line 40
    tracer_printf((char *)"Source: (pulling from immediate data=%d where {0=8})\n",
                  Instr.Bits.Data);
    }
  }
#line 43
  SValue = (unsigned long )Instr.Bits.Data;
#line 44
  if (SValue == 0UL) {
#line 44
    SValue = 8UL;
  }
#line 46
  if (TRACER_Info[TRACER_default___31].Enabled) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___31].Name, "execute");
#line 46
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 47
  tmp = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 47
  if (! tmp) {
#line 47
    return;
  }
  {
#line 48
  EA_GetValue(& DValue, & Destination);
  }
#line 50
  if (Instr.Bits.EAMode == 7U) {
    {
#line 52
    if (Instr.Bits.EARegister == 2U) {
#line 52
      goto case_2;
    }
#line 55
    if (Instr.Bits.EARegister == 3U) {
#line 55
      goto case_3;
    }
#line 58
    if (Instr.Bits.EARegister == 4U) {
#line 58
      goto case_4;
    }
#line 51
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 53
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___31].Name, "execute");
#line 53
    tracer_printf((char *)"(d_16,PC) addressing mode invalid.");
    }
#line 54
    return;
    case_3: /* CIL Label */ 
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___31].Name, "execute");
#line 56
    tracer_printf((char *)"(d_8,PC,Xn) addressing mode invalid.");
    }
#line 57
    return;
    case_4: /* CIL Label */ 
    {
#line 59
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___31].Name, "execute");
#line 59
    tracer_printf((char *)"#<data> addressing mode invalid.");
    }
#line 60
    return;
    switch_break: /* CIL Label */ ;
    }
  }
#line 64
  Result = SValue + DValue;
#line 66
  if (TRACER_Info[TRACER_default___31].Enabled) {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___31].Name, "execute");
#line 66
    tracer_printf((char *)"0x%08lx + 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 71
  if (Instr.Bits.EAMode != 1U) {
    {
#line 72
    SR_Set((short)3, (long )SValue, (long )DValue, (long )Result);
    }
  }
#line 76
  if (TRACER_Info[TRACER_default___31].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___31].Name, "execute");
#line 76
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 77
  EA_PutValue(& Destination, Result);
#line 78
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 78
  cycle((unsigned long )ADDQTime[tmp___0]);
  }
#line 79
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
static long disassemble___32(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADDQ_Instr Instr ;
  unsigned int tmp ;

  {
  {
#line 85
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 86
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADDQ.L");
  }
#line 87
  if (Instr.Bits.Data == 0U) {
#line 87
    tmp = 8U;
  } else {
#line 87
    tmp = Instr.Bits.Data;
  }
  {
#line 87
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02X",
          tmp);
#line 88
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg2);
  }
#line 89
  return (0L);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
long addq_5206_register(void) 
{ 


  {
  {
#line 94
  instruction_register((unsigned short)20608, (unsigned short)61888, & execute___32,
                       & disassemble___32);
  }
#line 95
  return (1L);
}
}
#line 30 "../i_5206/i_5206.h"
long jsr_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
int JSRTime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
  {      -1,      3,      -1,      -1, 
        3,      4,      3,      -1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
static enum _TRACER_Channels  const  TRACER_default___32  =    (enum _TRACER_Channels  const  )26;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
static void execute___33(void) 
{ 
  struct _Address Destination ;
  unsigned long DValue ;
  JSR_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___32].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___32].Name, "execute");
#line 38
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 39
  tmp = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
  {
#line 40
  EA_GetEA(& DValue, & Destination);
  }
#line 42
  if (TRACER_Info[TRACER_default___32].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___32].Name, "execute");
#line 42
    tracer_printf((char *)"Saving PC to the stack\n");
    }
  }
  {
#line 43
  Stack_Push((short)32, memory_core.pc);
  }
#line 45
  if (TRACER_Info[TRACER_default___32].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___32].Name, "execute");
#line 45
    tracer_printf((char *)"New PC=0x%08lx\n", DValue);
    }
  }
#line 47
  memory_core.pc = DValue;
#line 51
  if (TRACER_Info[TRACER_default___32].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___32].Name, "execute");
#line 51
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 53
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 53
  cycle((unsigned long )JSRTime[tmp___0]);
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
static long disassemble___33(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  JSR_Instr Instr ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 62
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"JSR");
#line 63
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 64
  *(Arg2 + 0) = (char)0;
  }
#line 65
  return (0L);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
long jsr_5206_register(void) 
{ 


  {
  {
#line 71
  instruction_register((unsigned short)20096, (unsigned short)65472, & execute___33,
                       & disassemble___33);
  }
#line 72
  return (1L);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 18 "../i_5206/i_5206.h"
long btst_5206_register(void) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
static enum _TRACER_Channels  const  TRACER_default___33  =    (enum _TRACER_Channels  const  )13;
#line 46 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
int BTSTTime[2][8]  = { {        1,        3,        3,        3, 
            3,        -1,        -1,        1}, 
   {        2,        3,        3,        3, 
            3,        4,        3,        -1}};
#line 50 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
static void execute___34(void) 
{ 
  struct _Address Destination ;
  struct _Address BitNum ;
  unsigned long DValue ;
  unsigned long BitNumValue ;
  long mask ;
  BTST_Instr Instr ;
  char size ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 64
  if (Instr.Bits.EAMode == 0U) {
#line 64
    size = (char)32;
  } else {
#line 64
    size = (char)8;
  }
#line 66
  if (TRACER_Info[TRACER_default___33].Enabled) {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___33].Name, "execute");
#line 66
    tracer_printf((char *)"pc=0x%08lx\n", memory_core.pc);
    }
  }
#line 75
  if (Instr.Bits.Dynamic == 1U) {
    {
#line 77
    tmp = EA_GetFromPC(& BitNum, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 77
    if (! tmp) {
#line 77
      return;
    }
  } else {
    {
#line 83
    tmp___0 = EA_GetFromPC(& BitNum, (short)8, (char)7, (char)4);
    }
#line 83
    if (! tmp___0) {
#line 83
      return;
    }
  }
  {
#line 85
  EA_GetValue(& BitNumValue, & BitNum);
#line 86
  BitNumValue %= (unsigned long )size;
  }
#line 89
  if (TRACER_Info[TRACER_default___33].Enabled) {
    {
#line 89
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___33].Name, "execute");
#line 89
    tracer_printf((char *)"Destination (size=%d):\n", (int )size);
    }
  }
  {
#line 90
  tmp___1 = EA_GetFromPC(& Destination, (short )size, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 90
  if (! tmp___1) {
#line 90
    return;
  }
  {
#line 91
  EA_GetValue(& DValue, & Destination);
#line 93
  mask = (long )(1 << BitNumValue);
  }
#line 95
  if (TRACER_Info[TRACER_default___33].Enabled) {
    {
#line 95
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___33].Name, "execute");
#line 95
    tracer_printf((char *)"Destination value is 0x%08lx, testing bit %d (mask=0x%08lx\n",
                  DValue, BitNumValue, mask);
    }
  }
#line 101
  if (DValue & (unsigned long )mask) {
#line 101
    SRBits->Z = 0U;
  } else {
#line 101
    SRBits->Z = 1U;
  }
  {
#line 104
  if (Instr.Bits.OP == 0U) {
#line 104
    goto case_0;
  }
#line 108
  if (Instr.Bits.OP == 1U) {
#line 108
    goto case_1;
  }
#line 112
  if (Instr.Bits.OP == 2U) {
#line 112
    goto case_2;
  }
#line 116
  if (Instr.Bits.OP == 3U) {
#line 116
    goto case_3;
  }
#line 103
  goto switch_break;
  case_0: /* CIL Label */ 
#line 106
  if (TRACER_Info[TRACER_default___33].Enabled) {
    {
#line 106
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___33].Name, "execute");
#line 106
    tracer_printf((char *)"Done\n");
    }
  }
#line 107
  return;
  case_1: /* CIL Label */ 
#line 110
  DValue = (DValue & (unsigned long )(~ mask)) | (DValue ^ (unsigned long )mask);
#line 111
  goto switch_break;
  case_2: /* CIL Label */ 
#line 114
  DValue &= (unsigned long )(~ mask);
#line 115
  goto switch_break;
  case_3: /* CIL Label */ 
#line 118
  DValue |= (unsigned long )mask;
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 121
  EA_PutValue(& Destination, DValue);
  }
#line 123
  if (Instr.Bits.Dynamic == 1U) {
    {
#line 124
    tmp___2 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 124
    cycle((unsigned long )BTSTTime[0][tmp___2]);
    }
  } else {
    {
#line 125
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 125
    cycle((unsigned long )BTSTTime[1][tmp___3]);
    }
  }
#line 127
  if (TRACER_Info[TRACER_default___33].Enabled) {
    {
#line 127
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___33].Name, "execute");
#line 127
    tracer_printf((char *)"Done\n");
    }
  }
#line 128
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
static long disassemble___34(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  BTST_Instr Instr ;
  char size ;
  int tmp ;

  {
#line 134
  if (Instr.Bits.EAMode == 0U) {
#line 134
    tmp = 32;
  } else {
#line 134
    tmp = 8;
  }
  {
#line 134
  size = (char )tmp;
#line 136
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
  {
#line 139
  if (Instr.Bits.OP == 0U) {
#line 139
    goto case_0;
  }
#line 143
  if (Instr.Bits.OP == 1U) {
#line 143
    goto case_1;
  }
#line 146
  if (Instr.Bits.OP == 2U) {
#line 146
    goto case_2;
  }
#line 149
  if (Instr.Bits.OP == 3U) {
#line 149
    goto case_3;
  }
#line 138
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 141
  strcpy((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BTST");
  }
#line 142
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 144
  strcpy((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BCHG");
  }
#line 145
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 147
  strcpy((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BCLR");
  }
#line 148
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 150
  strcpy((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BSET");
  }
#line 151
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 154
  if (Instr.Bits.Dynamic == 1U) {
    {
#line 155
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
    }
  } else {
    {
#line 157
    Addressing_Print((short)8, (char)7, (char)4, Arg1);
    }
  }
  {
#line 159
  Addressing_Print((short )size, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg2);
  }
#line 160
  return (0L);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
long btst_5206_register(void) 
{ 


  {
  {
#line 167
  instruction_register((unsigned short)256, (unsigned short)61696, & execute___34,
                       & disassemble___34);
#line 169
  instruction_register((unsigned short)2048, (unsigned short)65280, & execute___34,
                       & disassemble___34);
  }
#line 170
  return (4L);
}
}
#line 33 "../i_5206/i_5206.h"
long lsx_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
int LSXTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
static enum _TRACER_Channels  const  TRACER_default___34  =    (enum _TRACER_Channels  const  )29;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
static void execute___35(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  LSX_Instr Instr ;
  long last_bit ;
  char tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 42
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 44
  if (TRACER_Info[TRACER_default___34].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___34].Name, "execute");
#line 44
    tracer_printf((char *)"Source:\n");
    }
  }
#line 45
  if (Instr.Bits.IR == 0U) {
#line 47
    SValue = (unsigned long )Instr.Bits.CountReg;
#line 48
    if (SValue == 0UL) {
#line 48
      SValue = 8UL;
    }
#line 49
    if (TRACER_Info[TRACER_default___34].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___34].Name, "execute");
#line 49
      tracer_printf((char *)"Shift by count in instruction word = %d\n", SValue);
      }
    }
  } else {
    {
#line 51
    tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.CountReg);
    }
#line 51
    if (! tmp) {
#line 51
      return;
    }
    {
#line 53
    EA_GetValue(& SValue, & Source);
#line 54
    SValue &= 63UL;
    }
#line 55
    if (TRACER_Info[TRACER_default___34].Enabled) {
      {
#line 55
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___34].Name, "execute");
#line 55
      tracer_printf((char *)"Shift by count in D%d = \n", Instr.Bits.CountReg, SValue);
      }
    }
  }
#line 57
  if (TRACER_Info[TRACER_default___34].Enabled) {
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___34].Name, "execute");
#line 57
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 58
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 58
  if (! tmp___0) {
#line 58
    return;
  }
  {
#line 59
  EA_GetValue(& DValue, & Destination);
  }
#line 62
  if (SValue == 0UL) {
#line 63
    if (TRACER_Info[TRACER_default___34].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___34].Name, "execute");
#line 63
      tracer_printf((char *)"No Shift");
      }
    }
#line 64
    SRBits->C = 0U;
#line 65
    Result = DValue;
  } else {
#line 67
    last_bit = 0L;
#line 68
    if (Instr.Bits.DR == 0U) {
#line 70
      if (TRACER_Info[TRACER_default___34].Enabled) {
        {
#line 70
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___34].Name,
                      "execute");
#line 70
        tracer_printf((char *)"Shift Right\n");
        }
      }
#line 74
      if (SValue <= 32UL) {
#line 75
        last_bit = (long )(DValue & (unsigned long )(1 << (SValue - 1UL)));
      }
#line 81
      if (SValue >= 32UL) {
#line 81
        Result = 0UL;
      } else {
#line 81
        Result = DValue >> SValue;
      }
    } else {
#line 85
      if (TRACER_Info[TRACER_default___34].Enabled) {
        {
#line 85
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___34].Name,
                      "execute");
#line 85
        tracer_printf((char *)"Shift Left\n");
        }
      }
#line 86
      if (SValue <= 32UL) {
#line 87
        last_bit = (long )(DValue & (unsigned long )(2147483648U >> (SValue - 1UL)));
      }
#line 89
      if (SValue >= 32UL) {
#line 89
        Result = 0UL;
      } else {
#line 89
        Result = DValue << SValue;
      }
    }
#line 91
    if (last_bit) {
#line 91
      SRBits->C = 1U;
    } else {
#line 91
      SRBits->C = 0U;
    }
#line 92
    if (last_bit) {
#line 92
      SRBits->X = 1U;
    } else {
#line 92
      SRBits->X = 0U;
    }
  }
#line 94
  if (TRACER_Info[TRACER_default___34].Enabled) {
    {
#line 94
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___34].Name, "execute");
    }
#line 94
    if (Instr.Bits.DR == 0U) {
#line 94
      tmp___1 = ">>";
    } else {
#line 94
      tmp___1 = "<<";
    }
    {
#line 94
    tracer_printf((char *)"0x%08lx %s 0x%02lx = 0x%08lx\n", DValue, tmp___1, SValue,
                  Result);
    }
  }
#line 104
  if ((long )Result < 0L) {
#line 104
    SRBits->N = 1U;
  } else {
#line 104
    SRBits->N = 0U;
  }
#line 105
  if (Result == 0UL) {
#line 105
    SRBits->Z = 1U;
  } else {
#line 105
    SRBits->Z = 0U;
  }
#line 107
  if (TRACER_Info[TRACER_default___34].Enabled) {
    {
#line 107
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___34].Name, "execute");
#line 107
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 108
  EA_PutValue(& Destination, Result);
#line 110
  cycle((unsigned long )LSXTime);
  }
#line 112
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
static long disassemble___35(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  LSX_Instr Instr ;
  long SValue ;

  {
  {
#line 118
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 120
  if (Instr.Bits.DR == 0U) {
    {
#line 122
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"LSR.L");
    }
  } else {
    {
#line 125
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"LSL.L");
    }
  }
#line 127
  if (Instr.Bits.IR == 0U) {
#line 129
    SValue = (long )Instr.Bits.CountReg;
#line 130
    if (SValue == 0L) {
#line 130
      SValue = 8L;
    }
    {
#line 131
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02lX",
            SValue);
    }
  } else {
    {
#line 133
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"D%d",
            Instr.Bits.CountReg);
    }
  }
  {
#line 135
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 136
  return (0L);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
long lsx_5206_register(void) 
{ 


  {
  {
#line 141
  instruction_register((unsigned short)57480, (unsigned short)61656, & execute___35,
                       & disassemble___35);
#line 142
  instruction_register((unsigned short)57480, (unsigned short)61656, & execute___35,
                       & disassemble___35);
  }
#line 143
  return (2L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
static enum _TRACER_Channels  const  TRACER_default___35  =    (enum _TRACER_Channels  const  )8;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
static void execute___36(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  long Extend ;
  ADDX_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 38
  Extend = (long )SRBits->X;
#line 41
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 43
  if (TRACER_Info[TRACER_default___35].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___35].Name, "execute");
#line 43
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 44
  tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.RegisterDy);
  }
#line 44
  if (! tmp) {
#line 44
    return;
  }
#line 45
  if (TRACER_Info[TRACER_default___35].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___35].Name, "execute");
#line 45
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 46
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.RegisterDx);
  }
#line 46
  if (! tmp___0) {
#line 46
    return;
  }
  {
#line 47
  EA_GetValue(& SValue, & Source);
#line 48
  EA_GetValue(& DValue, & Destination);
#line 50
  Result = (SValue + DValue) + (unsigned long )Extend;
  }
#line 52
  if (TRACER_Info[TRACER_default___35].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___35].Name, "execute");
#line 52
    tracer_printf((char *)"0x%08lx + 0x%08lx + %d = 0x%08lx\n", SValue, DValue, Extend,
                  Result);
    }
  }
  {
#line 54
  SR_Set((short)4, (long )SValue, (long )DValue, (long )Result);
  }
#line 56
  if (TRACER_Info[TRACER_default___35].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___35].Name, "execute");
#line 56
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 57
  EA_PutValue(& Destination, Result);
#line 59
  cycle((unsigned long )ADDXTime);
  }
#line 61
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addx.c"
static long disassemble___36(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADDX_Instr Instr ;

  {
  {
#line 67
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 69
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADDX.L");
#line 70
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.RegisterDy, Arg1);
#line 71
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.RegisterDx, Arg2);
  }
#line 72
  return (0L);
}
}
#line 20 "../i_5206/i_5206.h"
long cmp_5206_register(void) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
int CMPTime[8]  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
  {      1,      3,      3,      3, 
        3,      4,      3,      1};
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
static enum _TRACER_Channels  const  TRACER_default___36  =    (enum _TRACER_Channels  const  )15;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
static void execute___37(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  CMP_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (TRACER_Info[TRACER_default___36].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___36].Name, "execute");
#line 42
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 43
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 43
  if (! tmp) {
#line 43
    return;
  }
#line 44
  if (TRACER_Info[TRACER_default___36].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___36].Name, "execute");
#line 44
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 45
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 45
  if (! tmp___0) {
#line 45
    return;
  }
  {
#line 47
  EA_GetValue(& SValue, & Source);
#line 48
  EA_GetValue(& DValue, & Destination);
  }
#line 50
  if (TRACER_Info[TRACER_default___36].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___36].Name, "execute");
#line 50
    tracer_printf((char *)"Comparing 0x%08lx and 0x%08lx\n", SValue, DValue);
    }
  }
  {
#line 52
  Result = DValue - SValue;
#line 54
  SR_Set((short)17, (long )SValue, (long )DValue, (long )Result);
  }
#line 56
  if (TRACER_Info[TRACER_default___36].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___36].Name, "execute");
#line 56
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 57
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 57
  cycle((unsigned long )CMPTime[tmp___1]);
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
static long disassemble___37(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  CMP_Instr Instr ;

  {
  {
#line 64
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 65
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"CMP.L");
#line 66
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 67
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 68
  return (0L);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
long cmp_5206_register(void) 
{ 


  {
  {
#line 73
  instruction_register((unsigned short)45184, (unsigned short)61888, & execute___37,
                       & disassemble___37);
  }
#line 74
  return (1L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
static enum _TRACER_Channels  const  TRACER_default___37  =    (enum _TRACER_Channels  const  )7;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
static void execute___38(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ADDQ_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___37].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___37].Name, "execute");
#line 40
    tracer_printf((char *)"Source: (pulling from immediate data=%d where {0=8})\n",
                  Instr.Bits.Data);
    }
  }
#line 43
  SValue = (unsigned long )Instr.Bits.Data;
#line 44
  if (SValue == 0UL) {
#line 44
    SValue = 8UL;
  }
#line 46
  if (TRACER_Info[TRACER_default___37].Enabled) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___37].Name, "execute");
#line 46
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 47
  tmp = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 47
  if (! tmp) {
#line 47
    return;
  }
  {
#line 48
  EA_GetValue(& DValue, & Destination);
  }
#line 50
  if (Instr.Bits.EAMode == 7U) {
    {
#line 52
    if (Instr.Bits.EARegister == 2U) {
#line 52
      goto case_2;
    }
#line 55
    if (Instr.Bits.EARegister == 3U) {
#line 55
      goto case_3;
    }
#line 58
    if (Instr.Bits.EARegister == 4U) {
#line 58
      goto case_4;
    }
#line 51
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 53
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___37].Name, "execute");
#line 53
    tracer_printf((char *)"(d_16,PC) addressing mode invalid.");
    }
#line 54
    return;
    case_3: /* CIL Label */ 
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___37].Name, "execute");
#line 56
    tracer_printf((char *)"(d_8,PC,Xn) addressing mode invalid.");
    }
#line 57
    return;
    case_4: /* CIL Label */ 
    {
#line 59
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___37].Name, "execute");
#line 59
    tracer_printf((char *)"#<data> addressing mode invalid.");
    }
#line 60
    return;
    switch_break: /* CIL Label */ ;
    }
  }
#line 64
  Result = SValue + DValue;
#line 66
  if (TRACER_Info[TRACER_default___37].Enabled) {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___37].Name, "execute");
#line 66
    tracer_printf((char *)"0x%08lx + 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 71
  if (Instr.Bits.EAMode != 1U) {
    {
#line 72
    SR_Set((short)3, (long )SValue, (long )DValue, (long )Result);
    }
  }
#line 76
  if (TRACER_Info[TRACER_default___37].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___37].Name, "execute");
#line 76
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 77
  EA_PutValue(& Destination, Result);
#line 78
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 78
  cycle((unsigned long )ADDQTime[tmp___0]);
  }
#line 79
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addq.c"
static long disassemble___38(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADDQ_Instr Instr ;
  unsigned int tmp ;

  {
  {
#line 85
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 86
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADDQ.L");
  }
#line 87
  if (Instr.Bits.Data == 0U) {
#line 87
    tmp = 8U;
  } else {
#line 87
    tmp = Instr.Bits.Data;
  }
  {
#line 87
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02X",
          tmp);
#line 88
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg2);
  }
#line 89
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
static enum _TRACER_Channels  const  TRACER_default___38  =    (enum _TRACER_Channels  const  )22;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
static void execute___39(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long SValue ;
  unsigned long Result ;
  EXT_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___38].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___38].Name, "execute");
#line 41
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
  {
#line 43
  EA_GetValue(& SValue, & Source);
  }
#line 45
  if (Instr.Bits.OPMode == 2U) {
#line 46
    if (TRACER_Info[TRACER_default___38].Enabled) {
      {
#line 46
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___38].Name, "execute");
#line 46
      tracer_printf((char *)"Destination: (Byte -> Word)\n");
      }
    }
    {
#line 47
    tmp___0 = EA_GetFromPC(& Destination, (short)16, (char)0, (char )Instr.Bits.Register);
    }
#line 47
    if (! tmp___0) {
#line 47
      return;
    }
#line 48
    Result = (unsigned long )((char )SValue);
  } else
#line 49
  if (Instr.Bits.OPMode == 3U) {
#line 50
    if (TRACER_Info[TRACER_default___38].Enabled) {
      {
#line 50
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___38].Name, "execute");
#line 50
      tracer_printf((char *)"Destination: (Word -> Long)\n");
      }
    }
    {
#line 51
    tmp___1 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 51
    if (! tmp___1) {
#line 51
      return;
    }
    {
#line 52
    Result = (unsigned long )((short )SValue);
#line 53
    EA_PutValue(& Destination, (unsigned long )((short )SValue));
    }
  } else
#line 54
  if (Instr.Bits.OPMode == 7U) {
#line 55
    if (TRACER_Info[TRACER_default___38].Enabled) {
      {
#line 55
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___38].Name, "execute");
#line 55
      tracer_printf((char *)"Destination: (Byte -> Long)\n");
      }
    }
    {
#line 56
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 56
    if (! tmp___2) {
#line 56
      return;
    }
#line 57
    Result = (unsigned long )((char )SValue);
  } else {
    {
#line 59
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___38].Name, "execute");
#line 59
    tracer_printf((char *)"Unknown opmode %d\n", Instr.Bits.OPMode);
    }
#line 60
    return;
  }
  {
#line 63
  EA_PutValue(& Destination, Result);
#line 72
  memory_core.sr &= 65520UL;
#line 73
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 74
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 75
  if (TRACER_Info[TRACER_default___38].Enabled) {
    {
#line 75
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___38].Name, "execute");
#line 75
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 77
  cycle((unsigned long )EXTTime);
  }
#line 79
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ext.c"
static long disassemble___39(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  EXT_Instr Instr ;

  {
  {
#line 85
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 87
  if (Instr.Bits.OPMode == 2U) {
    {
#line 88
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EXT.W");
    }
  } else
#line 89
  if (Instr.Bits.OPMode == 3U) {
    {
#line 90
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EXT.L");
    }
  } else
#line 91
  if (Instr.Bits.OPMode == 7U) {
    {
#line 92
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EXTB.L");
    }
  } else {
    {
#line 94
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___38].Name, "disassemble");
#line 94
    tracer_printf((char *)"Unknown opmode\n");
    }
  }
  {
#line 97
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 98
  *(Arg2 + 0) = (char)0;
  }
#line 99
  return (0L);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
static enum _TRACER_Channels  const  TRACER_default___39  =    (enum _TRACER_Channels  const  )10;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
static void execute___40(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ANDI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___39].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___39].Name, "execute");
#line 41
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
#line 43
  if (TRACER_Info[TRACER_default___39].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___39].Name, "execute");
#line 43
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 44
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 44
  if (! tmp___0) {
#line 44
    return;
  }
  {
#line 46
  EA_GetValue(& SValue, & Source);
#line 47
  EA_GetValue(& DValue, & Destination);
#line 49
  Result = SValue & DValue;
  }
#line 50
  if (TRACER_Info[TRACER_default___39].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___39].Name, "execute");
#line 50
    tracer_printf((char *)"0x%08lx & 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 52
  if (TRACER_Info[TRACER_default___39].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___39].Name, "execute");
#line 52
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 53
  EA_PutValue(& Destination, Result);
#line 62
  memory_core.sr &= 65520UL;
#line 63
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 64
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 66
  if (TRACER_Info[TRACER_default___39].Enabled) {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___39].Name, "execute");
#line 66
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 68
  cycle((unsigned long )ANDITime);
  }
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_andi.c"
static long disassemble___40(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ANDI_Instr Instr ;

  {
  {
#line 76
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 77
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ANDI.L");
#line 78
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 79
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 80
  return (0L);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
static enum _TRACER_Channels  const  TRACER_default___40  =    (enum _TRACER_Channels  const  )36;
#line 42 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
static void execute___41(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  MUL_W_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 47
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 49
  if (Instr.Bits.EAMode == 1U) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___40].Name, "execute");
#line 50
    tracer_printf((char *)"May Not specify Address Register (Ay) for MUL.W");
    }
#line 51
    return;
  }
#line 54
  if (TRACER_Info[TRACER_default___40].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___40].Name, "execute");
#line 54
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 55
  tmp = EA_GetFromPC(& Source, (short)16, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 55
  if (! tmp) {
#line 55
    return;
  }
  {
#line 56
  EA_GetValue(& SValue, & Source);
  }
#line 57
  if (TRACER_Info[TRACER_default___40].Enabled) {
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___40].Name, "execute");
#line 57
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 58
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 58
  if (! tmp___0) {
#line 58
    return;
  }
  {
#line 59
  EA_GetValue(& DValue, & Destination);
  }
#line 61
  if (Instr.Bits.US == 0U) {
#line 62
    Result = (unsigned long )((int )((unsigned short )(SValue & 65535UL)) * (int )((unsigned short )(DValue & 65535UL)));
  } else {
#line 64
    Result = (unsigned long )((int )((short )(SValue & 65535UL)) * (int )((short )(DValue & 65535UL)));
  }
#line 67
  if (TRACER_Info[TRACER_default___40].Enabled) {
    {
#line 67
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___40].Name, "execute");
#line 67
    tracer_printf((char *)"0x%04lx * 0x%04lx = 0x%04lx\n", SValue & 65535UL, DValue & 65535UL,
                  Result);
    }
  }
#line 70
  memory_core.sr &= 65280UL;
#line 71
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 72
  SRBits->Z = (unsigned int )(Result == 0UL);
#line 74
  if (TRACER_Info[TRACER_default___40].Enabled) {
    {
#line 74
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___40].Name, "execute");
#line 74
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 75
  EA_PutValue(& Destination, Result);
  }
#line 76
  if (TRACER_Info[TRACER_default___40].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___40].Name, "execute");
#line 76
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 78
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 78
  cycle((unsigned long )MULWTime[tmp___1]);
  }
#line 80
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_w.c"
static long disassemble___41(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MUL_W_Instr Instr ;

  {
  {
#line 86
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 87
  if (Instr.Bits.US == 0U) {
    {
#line 88
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MULU.W");
    }
  } else {
    {
#line 90
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MULS.W");
    }
  }
  {
#line 91
  Addressing_Print((short)16, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 92
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 93
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
static enum _TRACER_Channels  const  TRACER_default___41  =    (enum _TRACER_Channels  const  )23;
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
static void execute___42(void) 
{ 
  HALT_Instr Instr ;

  {
  {
#line 32
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 34
  if (SRBits->S) {
    {
#line 36
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___41].Name, "execute");
#line 36
    tracer_printf((char *)"Halting the processor:\n");
    }
#line 37
    return;
  } else
#line 40
  if (TRACER_Info[TRACER_default___41].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___41].Name, "execute");
#line 40
    tracer_printf((char *)"Attempt to HALT while in user state\n");
    }
  }
#line 44
  if (TRACER_Info[TRACER_default___41].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___41].Name, "execute");
#line 44
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 45
  cycle((unsigned long )HALTTime);
  }
#line 46
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_halt.c"
static long disassemble___42(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  HALT_Instr Instr ;

  {
  {
#line 52
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 54
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"HALT");
#line 56
  *(Arg1 + 0) = (char)0;
#line 57
  *(Arg2 + 0) = (char)0;
  }
#line 59
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
static enum _TRACER_Channels  const  TRACER_default___42  =    (enum _TRACER_Channels  const  )43;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
static void execute___43(void) 
{ 
  struct _Address Source ;
  unsigned long SValue ;
  PEA_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 39
  if (TRACER_Info[TRACER_default___42].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___42].Name, "execute");
#line 39
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 40
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 40
  if (! tmp) {
#line 40
    return;
  }
  {
#line 41
  EA_GetEA(& SValue, & Source);
  }
#line 42
  if (TRACER_Info[TRACER_default___42].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___42].Name, "execute");
#line 42
    tracer_printf((char *)"Pusing 0x%08lx to the stack\n", SValue);
    }
  }
  {
#line 43
  Stack_Push((short)32, SValue);
  }
#line 45
  if (TRACER_Info[TRACER_default___42].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___42].Name, "execute");
#line 45
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 47
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 47
  cycle((unsigned long )PEATime[tmp___0]);
  }
#line 49
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_pea.c"
static long disassemble___43(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  PEA_Instr Instr ;

  {
  {
#line 55
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 56
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"PEA");
#line 57
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 58
  *(Arg2 + 0) = (char)0;
  }
#line 59
  return (0L);
}
}
#line 30 "../addressing.h"
extern unsigned long Stack_Pop(short Size ) ;
#line 49 "../i_5206/i_5206.h"
long rts_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rts.c"
int RTSTime  =    5;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rts.c"
static enum _TRACER_Channels  const  TRACER_default___43  =    (enum _TRACER_Channels  const  )45;
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rts.c"
static void execute___44(void) 
{ 
  unsigned long dummy ;

  {
  {
#line 33
  Memory_RetrFromPC(& dummy, (short)16);
#line 36
  memory_core.pc = Stack_Pop((short)32);
  }
#line 38
  if (TRACER_Info[TRACER_default___43].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___43].Name, "execute");
#line 38
    tracer_printf((char *)"Set PC=0x%08lx\n", memory_core.pc);
    }
  }
#line 39
  if (TRACER_Info[TRACER_default___43].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___43].Name, "execute");
#line 39
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 41
  cycle((unsigned long )RTSTime);
  }
#line 43
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rts.c"
static long disassemble___44(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 49
  Memory_RetrFromPC(& dummy, (short)16);
#line 50
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"RTS");
#line 51
  *(Arg1 + 0) = (char)0;
#line 52
  *(Arg2 + 0) = (char)0;
  }
#line 53
  return (0L);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rts.c"
long rts_5206_register(void) 
{ 


  {
  {
#line 59
  instruction_register((unsigned short)20085, (unsigned short)65535, & execute___44,
                       & disassemble___44);
  }
#line 60
  return (1L);
}
}
#line 11 "../i_5206/i_5206.h"
long addi_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
int ADDITime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
static enum _TRACER_Channels  const  TRACER_default___44  =    (enum _TRACER_Channels  const  )6;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
static void execute___45(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ADDI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 37
  if (TRACER_Info[TRACER_default___44].Enabled) {
    {
#line 37
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___44].Name, "execute");
#line 37
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 38
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 38
  if (! tmp) {
#line 38
    return;
  }
#line 39
  if (TRACER_Info[TRACER_default___44].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___44].Name, "execute");
#line 39
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 40
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 40
  if (! tmp___0) {
#line 40
    return;
  }
  {
#line 42
  EA_GetValue(& SValue, & Source);
#line 43
  EA_GetValue(& DValue, & Destination);
#line 45
  Result = SValue + DValue;
  }
#line 47
  if (TRACER_Info[TRACER_default___44].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___44].Name, "execute");
#line 47
    tracer_printf((char *)"0x%08lx + 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
  {
#line 50
  SR_Set((short)2, (long )SValue, (long )DValue, (long )Result);
  }
#line 52
  if (TRACER_Info[TRACER_default___44].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___44].Name, "execute");
#line 52
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 53
  EA_PutValue(& Destination, Result);
  }
#line 55
  if (TRACER_Info[TRACER_default___44].Enabled) {
    {
#line 55
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___44].Name, "execute");
#line 55
    tracer_printf((char *)"Done");
    }
  }
  {
#line 57
  cycle((unsigned long )ADDITime);
  }
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
static long disassemble___45(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADDI_Instr Instr ;

  {
  {
#line 65
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 66
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADDI.L");
#line 67
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 68
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 69
  return (0L);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
long addi_5206_register(void) 
{ 


  {
  {
#line 74
  instruction_register((unsigned short)1664, (unsigned short)65528, & execute___45,
                       & disassemble___45);
  }
#line 75
  return (1L);
}
}
#line 38 "../i_5206/i_5206.h"
long movexr_5206_register(void) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
static enum _TRACER_Channels  const  TRACER_default___45  =    (enum _TRACER_Channels  const  )34;
#line 49 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
int MOVE2SRTime  =    1;
#line 50 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
int MOVEXRTime  =    1;
#line 52 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
static void execute___46(void) 
{ 
  struct _Address Source ;
  unsigned long SValue ;
  char CCR ;
  MOVEXR_Instr Instr ;
  char tmp ;
  char const   *tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 58
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 60
  CCR = (char )(Instr.Bits.To ^ Instr.Bits.Reg);
  }
#line 62
  if (TRACER_Info[TRACER_default___45].Enabled) {
    {
#line 62
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___45].Name, "execute");
#line 62
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 63
  tmp = EA_GetFromPC(& Source, (short)16, (char )Instr.Bits.Mode, (char )Instr.Bits.Register);
  }
#line 63
  if (! tmp) {
#line 63
    return;
  }
#line 65
  if (TRACER_Info[TRACER_default___45].Enabled) {
    {
#line 65
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___45].Name, "execute");
#line 65
    tracer_printf((char *)"CCR=%d, Supervisor State=%d\n", (int )CCR, SRBits->S);
    }
  }
#line 67
  if ((int )CCR == 0) {
#line 67
    if (! SRBits->S) {
#line 69
      if (TRACER_Info[TRACER_default___45].Enabled) {
        {
#line 69
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___45].Name,
                      "execute");
        }
#line 69
        if (Instr.Bits.To) {
#line 69
          tmp___0 = "write";
        } else {
#line 69
          tmp___0 = "read";
        }
        {
#line 69
        tracer_printf((char *)"Attempt to %s SR while in user state.\n", tmp___0);
        }
      }
      {
#line 70
      exception_do_exception((short)8);
      }
#line 71
      return;
    }
  }
#line 74
  if (Instr.Bits.To) {
    {
#line 75
    EA_GetValue(& SValue, & Source);
    }
#line 76
    if ((int )CCR == 0) {
#line 77
      memory_core.sr = SValue;
#line 78
      if (Instr.Bits.Mode == 7U) {
#line 78
        if (Instr.Bits.Register == 4U) {
          {
#line 79
          cycle((unsigned long )(MOVE2SRTime + 6));
          }
        } else {
          {
#line 81
          cycle((unsigned long )MOVE2SRTime);
          }
        }
      } else {
        {
#line 81
        cycle((unsigned long )MOVE2SRTime);
        }
      }
    } else {
      {
#line 83
      memory_core.sr = (memory_core.sr & 4294967040UL) | (SValue & 255UL);
#line 85
      cycle((unsigned long )MOVEXRTime);
      }
    }
  } else {
#line 88
    if ((int )CCR == 0) {
#line 88
      tmp___1 = memory_core.sr;
    } else {
#line 88
      tmp___1 = memory_core.sr & 255UL;
    }
    {
#line 88
    SValue = tmp___1;
#line 91
    EA_PutValue(& Source, SValue);
#line 92
    cycle((unsigned long )MOVEXRTime);
    }
  }
#line 96
  if (TRACER_Info[TRACER_default___45].Enabled) {
    {
#line 96
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___45].Name, "execute");
#line 96
    tracer_printf((char *)"Done\n");
    }
  }
#line 97
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
static long disassemble___46(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVEXR_Instr Instr ;
  char CCR ;
  char *ptr ;

  {
  {
#line 105
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 107
  CCR = (char )(Instr.Bits.To ^ Instr.Bits.Reg);
#line 109
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVE");
  }
#line 111
  if (Instr.Bits.To) {
#line 113
    ptr = Arg1;
#line 114
    Arg1 = Arg2;
#line 115
    Arg2 = ptr;
  }
#line 118
  if (CCR) {
    {
#line 119
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"CCR");
    }
  } else {
    {
#line 121
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"SR");
    }
  }
  {
#line 122
  Addressing_Print((short)16, (char )Instr.Bits.Mode, (char )Instr.Bits.Register,
                   Arg2);
  }
#line 124
  return (0L);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
long movexr_5206_register(void) 
{ 


  {
  {
#line 129
  instruction_register((unsigned short)16576, (unsigned short)63936, & execute___46,
                       & disassemble___46);
#line 130
  instruction_register((unsigned short)16576, (unsigned short)63936, & execute___46,
                       & disassemble___46);
  }
#line 131
  return (1L);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
static enum _TRACER_Channels  const  TRACER_default___46  =    (enum _TRACER_Channels  const  )30;
#line 67 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
static void execute___47(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long SValue ;
  int cycle_source_ea ;
  int cycle_destination_ea ;
  MOVE_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 71
  cycle_source_ea = 0;
#line 71
  cycle_destination_ea = 0;
#line 74
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 76
  if (Instr.Bits.Size == 0U) {
    {
#line 77
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___46].Name, "execute");
#line 77
    tracer_printf((char *)"Invalid size in instruction, size=0\n");
    }
#line 78
    return;
  }
#line 81
  if (TRACER_Info[TRACER_default___46].Enabled) {
    {
#line 81
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___46].Name, "execute");
#line 81
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 82
  tmp = EA_GetFromPC(& Source, (short )MOVE_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.SourceMode,
                     (char )Instr.Bits.SourceRegister);
  }
#line 82
  if (! tmp) {
#line 83
    return;
  }
  {
#line 84
  EA_GetValue(& SValue, & Source);
  }
#line 86
  if (TRACER_Info[TRACER_default___46].Enabled) {
    {
#line 86
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___46].Name, "execute");
#line 86
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 87
  tmp___0 = EA_GetFromPC(& Destination, (short )MOVE_SizeBits[(short )Instr.Bits.Size],
                         (char )Instr.Bits.DestMode, (char )Instr.Bits.DestRegister);
  }
#line 87
  if (! tmp___0) {
#line 88
    return;
  }
#line 90
  if (TRACER_Info[TRACER_default___46].Enabled) {
    {
#line 90
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___46].Name, "execute");
#line 90
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 91
  EA_PutValue(& Destination, SValue);
  }
#line 99
  if (Instr.Bits.DestMode != 1U) {
#line 101
    memory_core.sr &= 65520UL;
#line 102
    SRBits->N = (unsigned int )((long )SValue < 0L);
#line 103
    SRBits->Z = (unsigned int )(SValue == 0UL);
  }
  {
#line 110
  cycle_source_ea = cycle_EA((short )Instr.Bits.SourceRegister, (short )Instr.Bits.SourceMode);
#line 111
  cycle_destination_ea = cycle_EA((short )Instr.Bits.DestRegister, (short )Instr.Bits.DestMode);
  }
#line 113
  if (Instr.Bits.Size == 2U) {
    {
#line 114
    cycle((unsigned long )MOVE32Time[cycle_source_ea][cycle_destination_ea]);
    }
  } else {
    {
#line 116
    cycle((unsigned long )MOVE816Time[cycle_source_ea][cycle_destination_ea]);
    }
  }
#line 118
  if (TRACER_Info[TRACER_default___46].Enabled) {
    {
#line 118
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___46].Name, "execute");
#line 118
    tracer_printf((char *)"Done\n");
    }
  }
#line 120
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_move.c"
static long disassemble___47(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVE_Instr Instr ;

  {
  {
#line 126
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 130
  if (Instr.Bits.DestMode == 1U) {
#line 130
    if (Instr.Bits.Size >= 2U) {
      {
#line 131
      sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVEA.%c",
              (int const   )MOVE_SizeStr[(short )Instr.Bits.Size]);
      }
    } else {
      {
#line 133
      sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVE.%c",
              (int const   )MOVE_SizeStr[(short )Instr.Bits.Size]);
      }
    }
  } else {
    {
#line 133
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVE.%c",
            (int const   )MOVE_SizeStr[(short )Instr.Bits.Size]);
    }
  }
  {
#line 135
  Addressing_Print((short )MOVE_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.SourceMode,
                   (char )Instr.Bits.SourceRegister, Arg1);
#line 138
  Addressing_Print((short )MOVE_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.DestMode,
                   (char )Instr.Bits.DestRegister, Arg2);
  }
#line 140
  return (0L);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
static enum _TRACER_Channels  const  TRACER_default___47  =    (enum _TRACER_Channels  const  )28;
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
static void execute___48(void) 
{ 
  unsigned long Displacement ;
  struct _Address ARegister ;
  struct _Address Stack ;
  unsigned long StackValue ;
  LINK_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 40
  Memory_RetrFromPC(& Displacement, (short)16);
#line 41
  Displacement = (unsigned long )((short )Displacement);
  }
#line 43
  if (TRACER_Info[TRACER_default___47].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___47].Name, "execute");
#line 43
    tracer_printf((char *)"Retrieving ARegister\n");
    }
  }
  {
#line 45
  tmp = EA_GetFromPC(& ARegister, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 45
  if (! tmp) {
#line 45
    return;
  }
#line 46
  if (TRACER_Info[TRACER_default___47].Enabled) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___47].Name, "execute");
#line 46
    tracer_printf((char *)"Pushing ARegister onto stack\n");
    }
  }
  {
#line 47
  EA_GetValue(& StackValue, & ARegister);
#line 48
  Stack_Push((short)32, StackValue);
  }
#line 51
  if (TRACER_Info[TRACER_default___47].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___47].Name, "execute");
#line 51
    tracer_printf((char *)"Retrieving Stack Pointer\n");
    }
  }
  {
#line 52
  tmp___0 = EA_GetFromPC(& Stack, (short)32, (char)1, (char)7);
  }
#line 52
  if (! tmp___0) {
#line 52
    return;
  }
  {
#line 53
  EA_GetValue(& StackValue, & Stack);
  }
#line 54
  if (TRACER_Info[TRACER_default___47].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___47].Name, "execute");
#line 54
    tracer_printf((char *)"Storing Stack Pointer=0x%08lx in the ARegister\n", StackValue);
    }
  }
  {
#line 55
  EA_PutValue(& ARegister, StackValue);
  }
#line 60
  if (TRACER_Info[TRACER_default___47].Enabled) {
    {
#line 60
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___47].Name, "execute");
#line 60
    tracer_printf((char *)"Displacing Stack Pointer by 0x%04lx to 0x%08lx\n", Displacement,
                  StackValue + Displacement);
    }
  }
  {
#line 61
  EA_PutValue(& Stack, StackValue + Displacement);
  }
#line 63
  if (TRACER_Info[TRACER_default___47].Enabled) {
    {
#line 63
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___47].Name, "execute");
#line 63
    tracer_printf((char *)"Done");
    }
  }
  {
#line 65
  cycle((unsigned long )LINKTime);
  }
#line 67
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_link.c"
static long disassemble___48(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  LINK_Instr Instr ;
  unsigned long Displacement ;

  {
  {
#line 74
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 75
  Memory_RetrFromPC(& Displacement, (short)16);
#line 77
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"LINK");
#line 78
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg1);
#line 80
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"#%hd",
          (int )((short )Displacement));
  }
#line 82
  return (0L);
}
}
#line 17 "../i_5206/i_5206.h"
long bcc_5206_register(void) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
int BRATime  =    2;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
int BSRTime  =    3;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
int BCCTime[4]  = {      3,      1,      2,      3};
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
static enum _TRACER_Channels  const  TRACER_default___48  =    (enum _TRACER_Channels  const  )12;
#line 36 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
static void execute___49(void) 
{ 
  unsigned long Displacement ;
  unsigned long ReferencePC ;
  BCC_Instr Instr ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 42
  ReferencePC = memory_core.pc + 2UL;
#line 45
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 46
  Displacement = (unsigned long )Instr.Bits.Displacement;
  }
#line 47
  if (Displacement == 0UL) {
    {
#line 48
    Memory_RetrFromPC(& Displacement, (short)16);
#line 49
    Displacement = (unsigned long )((short )Displacement);
    }
  }
#line 51
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 51
    tracer_printf((char *)"BCC: called, Displacement=%ld\n", Displacement);
    }
  }
  {
#line 54
  if (Instr.Bits.Condition == 0U) {
#line 54
    goto case_0;
  }
#line 59
  if (Instr.Bits.Condition == 1U) {
#line 59
    goto case_1;
  }
#line 65
  if (Instr.Bits.Condition == 2U) {
#line 65
    goto case_2;
  }
#line 73
  if (Instr.Bits.Condition == 3U) {
#line 73
    goto case_3;
  }
#line 81
  if (Instr.Bits.Condition == 4U) {
#line 81
    goto case_4;
  }
#line 89
  if (Instr.Bits.Condition == 5U) {
#line 89
    goto case_5;
  }
#line 97
  if (Instr.Bits.Condition == 6U) {
#line 97
    goto case_6;
  }
#line 105
  if (Instr.Bits.Condition == 7U) {
#line 105
    goto case_7;
  }
#line 113
  if (Instr.Bits.Condition == 8U) {
#line 113
    goto case_8;
  }
#line 120
  if (Instr.Bits.Condition == 9U) {
#line 120
    goto case_9;
  }
#line 128
  if (Instr.Bits.Condition == 10U) {
#line 128
    goto case_10;
  }
#line 134
  if (Instr.Bits.Condition == 11U) {
#line 134
    goto case_11;
  }
#line 140
  if (Instr.Bits.Condition == 12U) {
#line 140
    goto case_12;
  }
#line 146
  if (Instr.Bits.Condition == 13U) {
#line 146
    goto case_13;
  }
#line 153
  if (Instr.Bits.Condition == 14U) {
#line 153
    goto case_14;
  }
#line 160
  if (Instr.Bits.Condition == 15U) {
#line 160
    goto case_15;
  }
#line 168
  goto switch_default;
  case_0: /* CIL Label */ 
#line 56
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 56
    tracer_printf((char *)"BCC: BRA %hx\n", Displacement);
    }
  }
  {
#line 57
  cycle((unsigned long )BRATime);
  }
#line 58
  goto i_bcc_do_branch;
  case_1: /* CIL Label */ 
#line 61
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 61
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 61
    tracer_printf((char *)"BCC: BSR %hx\n", Displacement);
    }
  }
  {
#line 62
  Stack_Push((short)32, memory_core.pc);
#line 63
  cycle((unsigned long )BSRTime);
  }
#line 64
  goto i_bcc_do_branch;
  case_2: /* CIL Label */ 
#line 67
  if (! SRBits->C) {
#line 67
    if (! SRBits->Z) {
#line 68
      if (TRACER_Info[TRACER_default___48].Enabled) {
        {
#line 68
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name,
                      "execute");
#line 68
        tracer_printf((char *)"BHI: Branching %hx\n", Displacement);
        }
      }
#line 69
      goto i_bcc_branch_taken;
    }
  }
#line 71
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 71
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 71
    tracer_printf((char *)"BHI: NOT Branching\n");
    }
  }
#line 72
  goto i_bcc_branch_not_taken;
  case_3: /* CIL Label */ 
#line 75
  if (SRBits->C) {
#line 75
    goto _L;
  } else
#line 75
  if (SRBits->Z) {
    _L: /* CIL Label */ 
#line 76
    if (TRACER_Info[TRACER_default___48].Enabled) {
      {
#line 76
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 76
      tracer_printf((char *)"BLS: Branching %hx\n", Displacement);
      }
    }
#line 77
    goto i_bcc_branch_taken;
  }
#line 79
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 79
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 79
    tracer_printf((char *)"BLS: NOT Branching\n");
    }
  }
#line 80
  goto i_bcc_branch_not_taken;
  case_4: /* CIL Label */ 
#line 83
  if (! SRBits->C) {
#line 84
    if (TRACER_Info[TRACER_default___48].Enabled) {
      {
#line 84
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 84
      tracer_printf((char *)"BCC: Branching %hx\n", Displacement);
      }
    }
#line 85
    goto i_bcc_branch_taken;
  }
#line 87
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 87
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 87
    tracer_printf((char *)"BCC: NOT Branching\n");
    }
  }
#line 88
  goto i_bcc_branch_not_taken;
  case_5: /* CIL Label */ 
#line 91
  if (SRBits->C) {
#line 92
    if (TRACER_Info[TRACER_default___48].Enabled) {
      {
#line 92
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 92
      tracer_printf((char *)"BCS: Branching %hx\n", Displacement);
      }
    }
#line 93
    goto i_bcc_branch_taken;
  }
#line 95
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 95
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 95
    tracer_printf((char *)"BCS: NOT Branching\n");
    }
  }
#line 96
  goto i_bcc_branch_not_taken;
  case_6: /* CIL Label */ 
#line 99
  if (! SRBits->Z) {
#line 100
    if (TRACER_Info[TRACER_default___48].Enabled) {
      {
#line 100
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 100
      tracer_printf((char *)"BNE: Branching %hx\n", Displacement);
      }
    }
#line 101
    goto i_bcc_branch_taken;
  }
#line 103
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 103
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 103
    tracer_printf((char *)"BNE: NOT Branching\n");
    }
  }
#line 104
  goto i_bcc_branch_not_taken;
  case_7: /* CIL Label */ 
#line 107
  if (SRBits->Z) {
#line 108
    if (TRACER_Info[TRACER_default___48].Enabled) {
      {
#line 108
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 108
      tracer_printf((char *)"BEQ: Branching %hx\n", Displacement);
      }
    }
#line 109
    goto i_bcc_branch_taken;
  }
#line 111
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 111
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 111
    tracer_printf((char *)"BEQ: NOT branching\n");
    }
  }
#line 112
  goto i_bcc_branch_not_taken;
  case_8: /* CIL Label */ 
#line 114
  if (! SRBits->V) {
#line 115
    if (TRACER_Info[TRACER_default___48].Enabled) {
      {
#line 115
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 115
      tracer_printf((char *)"BVC: Branching %hx\n", Displacement);
      }
    }
#line 116
    goto i_bcc_branch_taken;
  }
#line 118
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 118
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 118
    tracer_printf((char *)"BVC: NOT branching\n");
    }
  }
#line 119
  goto i_bcc_branch_not_taken;
  case_9: /* CIL Label */ 
#line 121
  if (SRBits->V) {
#line 122
    if (TRACER_Info[TRACER_default___48].Enabled) {
      {
#line 122
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 122
      tracer_printf((char *)"BVS: Branching %hx\n", Displacement);
      }
    }
#line 123
    goto i_bcc_branch_taken;
  }
#line 125
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 125
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 125
    tracer_printf((char *)"BVS: NOT branching\n");
    }
  }
#line 126
  goto i_bcc_branch_not_taken;
  case_10: /* CIL Label */ 
#line 129
  if (! SRBits->N) {
#line 130
    if (TRACER_Info[TRACER_default___48].Enabled) {
      {
#line 130
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 130
      tracer_printf((char *)"BPL: Branching %hx\n", Displacement);
      }
    }
#line 131
    goto i_bcc_branch_taken;
  }
#line 133
  goto i_bcc_branch_not_taken;
  case_11: /* CIL Label */ 
#line 135
  if (SRBits->N) {
#line 136
    if (TRACER_Info[TRACER_default___48].Enabled) {
      {
#line 136
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 136
      tracer_printf((char *)"BMI: Branching %hx\n", Displacement);
      }
    }
#line 137
    goto i_bcc_branch_taken;
  }
#line 139
  goto i_bcc_branch_not_taken;
  case_12: /* CIL Label */ 
#line 141
  if (SRBits->N) {
#line 141
    if (SRBits->V) {
#line 141
      goto _L___0;
    } else {
#line 141
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 141
  if (! SRBits->N) {
#line 141
    if (! SRBits->V) {
      _L___0: /* CIL Label */ 
#line 142
      if (TRACER_Info[TRACER_default___48].Enabled) {
        {
#line 142
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name,
                      "execute");
#line 142
        tracer_printf((char *)"BGE: Branching %hx\n", Displacement);
        }
      }
#line 143
      goto i_bcc_branch_taken;
    }
  }
#line 145
  goto i_bcc_branch_not_taken;
  case_13: /* CIL Label */ 
#line 147
  if (SRBits->N) {
#line 147
    if (! SRBits->V) {
#line 147
      goto _L___2;
    } else {
#line 147
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 147
  if (! SRBits->N) {
#line 147
    if (SRBits->V) {
      _L___2: /* CIL Label */ 
#line 148
      if (TRACER_Info[TRACER_default___48].Enabled) {
        {
#line 148
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name,
                      "execute");
#line 148
        tracer_printf((char *)"BLT: Branching %hx\n", Displacement);
        }
      }
#line 149
      goto i_bcc_branch_taken;
    }
  }
#line 151
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 151
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 151
    tracer_printf((char *)"BLT: NOT branching\n");
    }
  }
#line 152
  goto i_bcc_branch_not_taken;
  case_14: /* CIL Label */ 
#line 154
  if (SRBits->N) {
#line 154
    if (SRBits->V) {
#line 154
      if (! SRBits->Z) {
#line 154
        goto _L___4;
      } else {
#line 154
        goto _L___6;
      }
    } else {
#line 154
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 154
  if (! SRBits->N) {
#line 154
    if (! SRBits->V) {
#line 154
      if (! SRBits->Z) {
        _L___4: /* CIL Label */ 
#line 155
        if (TRACER_Info[TRACER_default___48].Enabled) {
          {
#line 155
          tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name,
                        "execute");
#line 155
          tracer_printf((char *)"BGT: Branching %hx\n", Displacement);
          }
        }
#line 156
        goto i_bcc_branch_taken;
      }
    }
  }
#line 158
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 158
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 158
    tracer_printf((char *)"BGT: NOT branching\n");
    }
  }
#line 159
  goto i_bcc_branch_not_taken;
  case_15: /* CIL Label */ 
#line 161
  if (SRBits->Z) {
#line 161
    goto _L___7;
  } else
#line 161
  if (SRBits->N) {
#line 161
    if (! SRBits->V) {
#line 161
      goto _L___7;
    } else {
#line 161
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 161
  if (! SRBits->N) {
#line 161
    if (SRBits->V) {
      _L___7: /* CIL Label */ 
#line 162
      if (TRACER_Info[TRACER_default___48].Enabled) {
        {
#line 162
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name,
                      "execute");
#line 162
        tracer_printf((char *)"BLE: Branching %hx\n", Displacement);
        }
      }
#line 163
      goto i_bcc_branch_taken;
    }
  }
#line 165
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 165
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 165
    tracer_printf((char *)"BLE: NOT branching\n");
    }
  }
#line 166
  goto i_bcc_branch_not_taken;
  switch_default: /* CIL Label */ 
  {
#line 169
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 169
  tracer_printf((char *)"Unknown Condition Code 0x%02x\n", Instr.Bits.Condition);
  }
#line 170
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 172
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 172
  tracer_printf((char *)"This should NOT happen!\n");
  }
#line 173
  return;
  i_bcc_branch_taken: 
#line 176
  if (Displacement > 0UL) {
#line 176
    tmp = 2;
  } else {
#line 176
    tmp = 0;
  }
  {
#line 176
  cycle((unsigned long )BCCTime[tmp]);
  }
  i_bcc_do_branch: 
#line 178
  memory_core.pc = ReferencePC + Displacement;
#line 179
  if (TRACER_Info[TRACER_default___48].Enabled) {
    {
#line 179
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___48].Name, "execute");
#line 179
    tracer_printf((char *)"BCC: New PC = %lx\n", memory_core.pc);
    }
  }
#line 180
  return;
  i_bcc_branch_not_taken: 
#line 183
  if (Displacement > 0UL) {
#line 183
    tmp___0 = 3;
  } else {
#line 183
    tmp___0 = 1;
  }
  {
#line 183
  cycle((unsigned long )BCCTime[tmp___0]);
  }
#line 184
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
static long disassemble___49(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long ReferencePC ;
  unsigned long Displacement ;
  BCC_Instr Instr ;

  {
  {
#line 190
  ReferencePC = memory_core.pc + 2UL;
#line 193
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 194
  Displacement = (unsigned long )Instr.Bits.Displacement;
  }
  {
#line 196
  if (Instr.Bits.Condition == 0U) {
#line 196
    goto case_0;
  }
#line 199
  if (Instr.Bits.Condition == 1U) {
#line 199
    goto case_1;
  }
#line 202
  if (Instr.Bits.Condition == 2U) {
#line 202
    goto case_2;
  }
#line 205
  if (Instr.Bits.Condition == 3U) {
#line 205
    goto case_3;
  }
#line 208
  if (Instr.Bits.Condition == 4U) {
#line 208
    goto case_4;
  }
#line 211
  if (Instr.Bits.Condition == 5U) {
#line 211
    goto case_5;
  }
#line 214
  if (Instr.Bits.Condition == 6U) {
#line 214
    goto case_6;
  }
#line 217
  if (Instr.Bits.Condition == 7U) {
#line 217
    goto case_7;
  }
#line 220
  if (Instr.Bits.Condition == 8U) {
#line 220
    goto case_8;
  }
#line 223
  if (Instr.Bits.Condition == 9U) {
#line 223
    goto case_9;
  }
#line 226
  if (Instr.Bits.Condition == 10U) {
#line 226
    goto case_10;
  }
#line 229
  if (Instr.Bits.Condition == 11U) {
#line 229
    goto case_11;
  }
#line 232
  if (Instr.Bits.Condition == 12U) {
#line 232
    goto case_12;
  }
#line 235
  if (Instr.Bits.Condition == 13U) {
#line 235
    goto case_13;
  }
#line 238
  if (Instr.Bits.Condition == 14U) {
#line 238
    goto case_14;
  }
#line 241
  if (Instr.Bits.Condition == 15U) {
#line 241
    goto case_15;
  }
#line 195
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 197
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BRA");
  }
#line 198
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 200
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BSR");
  }
#line 201
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 203
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BHI");
  }
#line 204
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 206
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BLS");
  }
#line 207
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 209
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BCC");
  }
#line 210
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 212
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BCS");
  }
#line 213
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 215
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BNE");
  }
#line 216
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 218
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BEQ");
  }
#line 219
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 221
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BVC");
  }
#line 222
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 224
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BVS");
  }
#line 225
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 227
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BPL");
  }
#line 228
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 230
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BMI");
  }
#line 231
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 233
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BGE");
  }
#line 234
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 236
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BLT");
  }
#line 237
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 239
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BGT");
  }
#line 240
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 242
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BLE");
  }
#line 243
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 246
  if (Displacement == 0UL) {
    {
#line 247
    Memory_RetrFromPC(& Displacement, (short)16);
#line 248
    Displacement = (unsigned long )((short )Displacement);
    }
  }
  {
#line 253
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"0x%08lX",
          ReferencePC + Displacement);
#line 254
  *(Arg2 + 0) = (char)0;
  }
#line 255
  return (0L);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
long bcc_5206_register(void) 
{ 


  {
  {
#line 260
  instruction_register((unsigned short)24576, (unsigned short)61440, & execute___49,
                       & disassemble___49);
  }
#line 261
  return (3L);
}
}
#line 28 "../i_5206/i_5206.h"
long illegal_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_illegal.c"
static enum _TRACER_Channels  const  TRACER_default___49  =    (enum _TRACER_Channels  const  )24;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_illegal.c"
static void execute___50(void) 
{ 
  unsigned long dummy ;

  {
  {
#line 31
  Memory_RetrFromPC(& dummy, (short)16);
  }
#line 32
  if (TRACER_Info[TRACER_default___49].Enabled) {
    {
#line 32
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___49].Name, "execute");
#line 32
    tracer_printf((char *)"Generaing illegal instruction exception...\n");
    }
  }
  {
#line 33
  exception_do_exception((short)4);
  }
#line 34
  if (TRACER_Info[TRACER_default___49].Enabled) {
    {
#line 34
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___49].Name, "execute");
#line 34
    tracer_printf((char *)"Done.\n");
    }
  }
#line 36
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_illegal.c"
static long disassemble___50(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 42
  Memory_RetrFromPC(& dummy, (short)16);
#line 43
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ILLEGAL");
#line 44
  *(Arg1 + 0) = (char)0;
#line 45
  *(Arg2 + 0) = (char)0;
  }
#line 46
  return (0L);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_illegal.c"
long illegal_5206_register(void) 
{ 


  {
  {
#line 52
  instruction_register((unsigned short)19196, (unsigned short)65535, & execute___50,
                       & disassemble___50);
  }
#line 53
  return (1L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
static enum _TRACER_Channels  const  TRACER_default___50  =    (enum _TRACER_Channels  const  )53;
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
static void execute___51(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUBX_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___50].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___50].Name, "execute");
#line 40
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 41
  tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.RegisterDy);
  }
#line 41
  if (! tmp) {
#line 41
    return;
  }
#line 42
  if (TRACER_Info[TRACER_default___50].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___50].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.RegisterDx);
  }
#line 43
  if (! tmp___0) {
#line 43
    return;
  }
  {
#line 44
  EA_GetValue(& SValue, & Source);
#line 45
  EA_GetValue(& DValue, & Destination);
#line 47
  Result = (DValue - SValue) - (unsigned long )((long )SRBits->X);
  }
#line 49
  if (TRACER_Info[TRACER_default___50].Enabled) {
    {
#line 49
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___50].Name, "execute");
#line 49
    tracer_printf((char *)"0x%08lx - 0x%08lx - %d = 0x%08lx\n", DValue, SValue, (long )SRBits->X,
                  Result);
    }
  }
  {
#line 51
  SR_Set((short)54, (long )SValue, (long )DValue, (long )Result);
  }
#line 53
  if (TRACER_Info[TRACER_default___50].Enabled) {
    {
#line 53
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___50].Name, "execute");
#line 53
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 54
  EA_PutValue(& Destination, Result);
#line 56
  cycle((unsigned long )SUBXTime);
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subx.c"
static long disassemble___51(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUBX_Instr Instr ;

  {
  {
#line 64
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 66
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUBX.L");
#line 67
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.RegisterDy, Arg1);
#line 68
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.RegisterDx, Arg2);
  }
#line 69
  return (0L);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
static enum _TRACER_Channels  const  TRACER_default___51  =    (enum _TRACER_Channels  const  )51;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
static void execute___52(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUBI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___51].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___51].Name, "execute");
#line 41
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
#line 43
  if (TRACER_Info[TRACER_default___51].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___51].Name, "execute");
#line 43
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 44
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 44
  if (! tmp___0) {
#line 44
    return;
  }
  {
#line 46
  EA_GetValue(& SValue, & Source);
#line 47
  EA_GetValue(& DValue, & Destination);
#line 49
  Result = DValue - SValue;
  }
#line 51
  if (TRACER_Info[TRACER_default___51].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___51].Name, "execute");
#line 51
    tracer_printf((char *)"0x%08lx - 0x%08lx = 0x%08lx\n", DValue, SValue, Result);
    }
  }
  {
#line 54
  SR_Set((short)52, (long )SValue, (long )DValue, (long )Result);
  }
#line 56
  if (TRACER_Info[TRACER_default___51].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___51].Name, "execute");
#line 56
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 57
  EA_PutValue(& Destination, Result);
  }
#line 59
  if (TRACER_Info[TRACER_default___51].Enabled) {
    {
#line 59
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___51].Name, "execute");
#line 59
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 61
  cycle((unsigned long )SUBITime);
  }
#line 63
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subi.c"
static long disassemble___52(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUBI_Instr Instr ;

  {
  {
#line 69
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 70
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUBI.L");
#line 71
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 72
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 73
  return (0L);
}
}
#line 42 "../i_5206/i_5206.h"
long negx_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
int NEGXTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
static enum _TRACER_Channels  const  TRACER_default___52  =    (enum _TRACER_Channels  const  )38;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
static void execute___53(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long DValue ;
  NEGX_Instr Instr ;
  char tmp ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___52].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___52].Name, "execute");
#line 38
    tracer_printf((char *)"Source: is 0\n");
    }
  }
#line 39
  if (TRACER_Info[TRACER_default___52].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___52].Name, "execute");
#line 39
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 40
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 40
  if (! tmp) {
#line 40
    return;
  }
  {
#line 41
  EA_GetValue(& DValue, & Destination);
#line 43
  Result = (0UL - DValue) - (unsigned long )SRBits->X;
  }
#line 45
  if (TRACER_Info[TRACER_default___52].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___52].Name, "execute");
#line 45
    tracer_printf((char *)"-0x%08lx - %d = 0x%08lx\n", DValue, (unsigned long )SRBits->X,
                  Result);
    }
  }
  {
#line 48
  SR_Set((short)42, 0L, (long )DValue, (long )Result);
  }
#line 50
  if (TRACER_Info[TRACER_default___52].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___52].Name, "execute");
#line 50
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 51
  EA_PutValue(& Destination, Result);
#line 53
  cycle((unsigned long )NEGXTime);
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
static long disassemble___53(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  NEGX_Instr Instr ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 63
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"NEGX.L");
#line 64
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 65
  *(Arg2 + 0) = (char)0;
  }
#line 66
  return (0L);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
long negx_5206_register(void) 
{ 


  {
  {
#line 71
  instruction_register((unsigned short)16512, (unsigned short)65528, & execute___53,
                       & disassemble___53);
  }
#line 72
  return (1L);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
static enum _TRACER_Channels  const  TRACER_default___53  =    (enum _TRACER_Channels  const  )13;
#line 50 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
static void execute___54(void) 
{ 
  struct _Address Destination ;
  struct _Address BitNum ;
  unsigned long DValue ;
  unsigned long BitNumValue ;
  long mask ;
  BTST_Instr Instr ;
  char size ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 64
  if (Instr.Bits.EAMode == 0U) {
#line 64
    size = (char)32;
  } else {
#line 64
    size = (char)8;
  }
#line 66
  if (TRACER_Info[TRACER_default___53].Enabled) {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___53].Name, "execute");
#line 66
    tracer_printf((char *)"pc=0x%08lx\n", memory_core.pc);
    }
  }
#line 75
  if (Instr.Bits.Dynamic == 1U) {
    {
#line 77
    tmp = EA_GetFromPC(& BitNum, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 77
    if (! tmp) {
#line 77
      return;
    }
  } else {
    {
#line 83
    tmp___0 = EA_GetFromPC(& BitNum, (short)8, (char)7, (char)4);
    }
#line 83
    if (! tmp___0) {
#line 83
      return;
    }
  }
  {
#line 85
  EA_GetValue(& BitNumValue, & BitNum);
#line 86
  BitNumValue %= (unsigned long )size;
  }
#line 89
  if (TRACER_Info[TRACER_default___53].Enabled) {
    {
#line 89
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___53].Name, "execute");
#line 89
    tracer_printf((char *)"Destination (size=%d):\n", (int )size);
    }
  }
  {
#line 90
  tmp___1 = EA_GetFromPC(& Destination, (short )size, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 90
  if (! tmp___1) {
#line 90
    return;
  }
  {
#line 91
  EA_GetValue(& DValue, & Destination);
#line 93
  mask = (long )(1 << BitNumValue);
  }
#line 95
  if (TRACER_Info[TRACER_default___53].Enabled) {
    {
#line 95
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___53].Name, "execute");
#line 95
    tracer_printf((char *)"Destination value is 0x%08lx, testing bit %d (mask=0x%08lx\n",
                  DValue, BitNumValue, mask);
    }
  }
#line 101
  if (DValue & (unsigned long )mask) {
#line 101
    SRBits->Z = 0U;
  } else {
#line 101
    SRBits->Z = 1U;
  }
  {
#line 104
  if (Instr.Bits.OP == 0U) {
#line 104
    goto case_0;
  }
#line 108
  if (Instr.Bits.OP == 1U) {
#line 108
    goto case_1;
  }
#line 112
  if (Instr.Bits.OP == 2U) {
#line 112
    goto case_2;
  }
#line 116
  if (Instr.Bits.OP == 3U) {
#line 116
    goto case_3;
  }
#line 103
  goto switch_break;
  case_0: /* CIL Label */ 
#line 106
  if (TRACER_Info[TRACER_default___53].Enabled) {
    {
#line 106
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___53].Name, "execute");
#line 106
    tracer_printf((char *)"Done\n");
    }
  }
#line 107
  return;
  case_1: /* CIL Label */ 
#line 110
  DValue = (DValue & (unsigned long )(~ mask)) | (DValue ^ (unsigned long )mask);
#line 111
  goto switch_break;
  case_2: /* CIL Label */ 
#line 114
  DValue &= (unsigned long )(~ mask);
#line 115
  goto switch_break;
  case_3: /* CIL Label */ 
#line 118
  DValue |= (unsigned long )mask;
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 121
  EA_PutValue(& Destination, DValue);
  }
#line 123
  if (Instr.Bits.Dynamic == 1U) {
    {
#line 124
    tmp___2 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 124
    cycle((unsigned long )BTSTTime[0][tmp___2]);
    }
  } else {
    {
#line 125
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 125
    cycle((unsigned long )BTSTTime[1][tmp___3]);
    }
  }
#line 127
  if (TRACER_Info[TRACER_default___53].Enabled) {
    {
#line 127
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___53].Name, "execute");
#line 127
    tracer_printf((char *)"Done\n");
    }
  }
#line 128
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_btst.c"
static long disassemble___54(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  BTST_Instr Instr ;
  char size ;
  int tmp ;

  {
#line 134
  if (Instr.Bits.EAMode == 0U) {
#line 134
    tmp = 32;
  } else {
#line 134
    tmp = 8;
  }
  {
#line 134
  size = (char )tmp;
#line 136
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
  {
#line 139
  if (Instr.Bits.OP == 0U) {
#line 139
    goto case_0;
  }
#line 143
  if (Instr.Bits.OP == 1U) {
#line 143
    goto case_1;
  }
#line 146
  if (Instr.Bits.OP == 2U) {
#line 146
    goto case_2;
  }
#line 149
  if (Instr.Bits.OP == 3U) {
#line 149
    goto case_3;
  }
#line 138
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 141
  strcpy((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BTST");
  }
#line 142
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 144
  strcpy((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BCHG");
  }
#line 145
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 147
  strcpy((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BCLR");
  }
#line 148
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 150
  strcpy((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BSET");
  }
#line 151
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 154
  if (Instr.Bits.Dynamic == 1U) {
    {
#line 155
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
    }
  } else {
    {
#line 157
    Addressing_Print((short)8, (char)7, (char)4, Arg1);
    }
  }
  {
#line 159
  Addressing_Print((short )size, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg2);
  }
#line 160
  return (0L);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
static enum _TRACER_Channels  const  TRACER_default___54  =    (enum _TRACER_Channels  const  )47;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
static void execute___55(void) 
{ 
  struct _Address Destination ;
  SCC_Instr Instr ;
  unsigned char Result ;
  char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 39
  Result = (unsigned char)0;
#line 41
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 43
  tmp = EA_GetFromPC(& Destination, (short)8, (char)0, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp) {
#line 43
    return;
  }
  {
#line 45
  cycle((unsigned long )SCCTime);
  }
  {
#line 48
  if (Instr.Bits.Condition == 0U) {
#line 48
    goto case_0;
  }
#line 51
  if (Instr.Bits.Condition == 1U) {
#line 51
    goto case_1;
  }
#line 53
  if (Instr.Bits.Condition == 2U) {
#line 53
    goto case_2;
  }
#line 58
  if (Instr.Bits.Condition == 3U) {
#line 58
    goto case_3;
  }
#line 61
  if (Instr.Bits.Condition == 4U) {
#line 61
    goto case_4;
  }
#line 64
  if (Instr.Bits.Condition == 5U) {
#line 64
    goto case_5;
  }
#line 67
  if (Instr.Bits.Condition == 6U) {
#line 67
    goto case_6;
  }
#line 71
  if (Instr.Bits.Condition == 7U) {
#line 71
    goto case_7;
  }
#line 75
  if (Instr.Bits.Condition == 8U) {
#line 75
    goto case_8;
  }
#line 78
  if (Instr.Bits.Condition == 9U) {
#line 78
    goto case_9;
  }
#line 81
  if (Instr.Bits.Condition == 10U) {
#line 81
    goto case_10;
  }
#line 84
  if (Instr.Bits.Condition == 11U) {
#line 84
    goto case_11;
  }
#line 87
  if (Instr.Bits.Condition == 12U) {
#line 87
    goto case_12;
  }
#line 91
  if (Instr.Bits.Condition == 13U) {
#line 91
    goto case_13;
  }
#line 95
  if (Instr.Bits.Condition == 14U) {
#line 95
    goto case_14;
  }
#line 99
  if (Instr.Bits.Condition == 15U) {
#line 99
    goto case_15;
  }
#line 103
  goto switch_default;
  case_0: /* CIL Label */ 
#line 49
  Result = (unsigned char)1;
#line 50
  goto switch_break;
  case_1: /* CIL Label */ 
#line 52
  goto switch_break;
  case_2: /* CIL Label */ 
#line 56
  if (SRBits->C) {
#line 56
    tmp___0 = 1;
  } else
#line 56
  if (! SRBits->Z) {
#line 56
    tmp___0 = 1;
  } else {
#line 56
    tmp___0 = 0;
  }
#line 56
  Result = (unsigned char )tmp___0;
#line 57
  goto switch_break;
  case_3: /* CIL Label */ 
#line 59
  if (SRBits->C) {
#line 59
    tmp___1 = 1;
  } else
#line 59
  if (SRBits->Z) {
#line 59
    tmp___1 = 1;
  } else {
#line 59
    tmp___1 = 0;
  }
#line 59
  Result = (unsigned char )tmp___1;
#line 60
  goto switch_break;
  case_4: /* CIL Label */ 
#line 62
  Result = (unsigned char )(! SRBits->C);
#line 63
  goto switch_break;
  case_5: /* CIL Label */ 
#line 65
  Result = (unsigned char )SRBits->C;
#line 66
  goto switch_break;
  case_6: /* CIL Label */ 
#line 69
  Result = (unsigned char )(! SRBits->Z);
#line 70
  goto switch_break;
  case_7: /* CIL Label */ 
#line 73
  Result = (unsigned char )SRBits->Z;
#line 74
  goto switch_break;
  case_8: /* CIL Label */ 
#line 76
  Result = (unsigned char )(! SRBits->V);
#line 77
  goto switch_break;
  case_9: /* CIL Label */ 
#line 79
  Result = (unsigned char )SRBits->V;
#line 80
  goto switch_break;
  case_10: /* CIL Label */ 
#line 82
  Result = (unsigned char )(! SRBits->N);
#line 83
  goto switch_break;
  case_11: /* CIL Label */ 
#line 85
  Result = (unsigned char )SRBits->N;
#line 86
  goto switch_break;
  case_12: /* CIL Label */ 
#line 88
  if (SRBits->N) {
#line 88
    if (SRBits->V) {
#line 88
      tmp___2 = 1;
    } else {
#line 88
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 88
  if (! SRBits->N) {
#line 88
    if (! SRBits->V) {
#line 88
      tmp___2 = 1;
    } else {
#line 88
      tmp___2 = 0;
    }
  } else {
#line 88
    tmp___2 = 0;
  }
#line 88
  Result = (unsigned char )tmp___2;
#line 90
  goto switch_break;
  case_13: /* CIL Label */ 
#line 92
  if (SRBits->N) {
#line 92
    if (! SRBits->V) {
#line 92
      tmp___3 = 1;
    } else {
#line 92
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 92
  if (! SRBits->N) {
#line 92
    if (SRBits->V) {
#line 92
      tmp___3 = 1;
    } else {
#line 92
      tmp___3 = 0;
    }
  } else {
#line 92
    tmp___3 = 0;
  }
#line 92
  Result = (unsigned char )tmp___3;
#line 94
  goto switch_break;
  case_14: /* CIL Label */ 
#line 96
  if (SRBits->N) {
#line 96
    if (SRBits->V) {
#line 96
      if (! SRBits->Z) {
#line 96
        tmp___4 = 1;
      } else {
#line 96
        goto _L___2;
      }
    } else {
#line 96
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 96
  if (! SRBits->N) {
#line 96
    if (! SRBits->V) {
#line 96
      if (! SRBits->Z) {
#line 96
        tmp___4 = 1;
      } else {
#line 96
        tmp___4 = 0;
      }
    } else {
#line 96
      tmp___4 = 0;
    }
  } else {
#line 96
    tmp___4 = 0;
  }
#line 96
  Result = (unsigned char )tmp___4;
#line 98
  goto switch_break;
  case_15: /* CIL Label */ 
#line 100
  if (SRBits->Z) {
#line 100
    tmp___5 = 1;
  } else
#line 100
  if (SRBits->N) {
#line 100
    if (! SRBits->V) {
#line 100
      tmp___5 = 1;
    } else {
#line 100
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 100
  if (! SRBits->N) {
#line 100
    if (SRBits->V) {
#line 100
      tmp___5 = 1;
    } else {
#line 100
      tmp___5 = 0;
    }
  } else {
#line 100
    tmp___5 = 0;
  }
#line 100
  Result = (unsigned char )tmp___5;
#line 102
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 104
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___54].Name, "execute");
#line 104
  tracer_printf((char *)"Unknown Condition Code 0x%02x\n", Instr.Bits.Condition);
  }
#line 105
  return;
  switch_break: /* CIL Label */ ;
  }
#line 107
  if (TRACER_Info[TRACER_default___54].Enabled) {
    {
#line 107
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___54].Name, "execute");
#line 107
    tracer_printf((char *)"S%s: Result=%d\n", code_mnemonic[(int )Instr.Bits.Condition],
                  (int )Result);
    }
  }
#line 109
  if (Result) {
#line 109
    Result = (unsigned char)255;
  }
#line 111
  if (TRACER_Info[TRACER_default___54].Enabled) {
    {
#line 111
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___54].Name, "execute");
#line 111
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 112
  EA_PutValue(& Destination, (unsigned long )Result);
  }
#line 115
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_scc.c"
static long disassemble___55(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SCC_Instr Instr ;

  {
  {
#line 123
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 124
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"S%s",
          code_mnemonic[(int )Instr.Bits.Condition]);
#line 125
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"D%d", Instr.Bits.Register);
#line 126
  *(Arg2 + 0) = (char)0;
  }
#line 127
  return (0L);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
static enum _TRACER_Channels  const  TRACER_default___55  =    (enum _TRACER_Channels  const  )42;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
static void execute___56(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ORI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___55].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___55].Name, "execute");
#line 38
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 39
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
#line 40
  if (TRACER_Info[TRACER_default___55].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___55].Name, "execute");
#line 40
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 41
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 41
  if (! tmp___0) {
#line 41
    return;
  }
  {
#line 43
  EA_GetValue(& SValue, & Source);
#line 44
  EA_GetValue(& DValue, & Destination);
#line 46
  Result = SValue | DValue;
  }
#line 48
  if (TRACER_Info[TRACER_default___55].Enabled) {
    {
#line 48
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___55].Name, "execute");
#line 48
    tracer_printf((char *)"0x%08lx | 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 50
  if (TRACER_Info[TRACER_default___55].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___55].Name, "execute");
#line 50
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 51
  EA_PutValue(& Destination, Result);
#line 59
  memory_core.sr &= 65520UL;
#line 60
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 61
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 63
  if (TRACER_Info[TRACER_default___55].Enabled) {
    {
#line 63
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___55].Name, "execute");
#line 63
    tracer_printf((char *)"Done");
    }
  }
  {
#line 65
  cycle((unsigned long )ORITime);
  }
#line 67
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_ori.c"
static long disassemble___56(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ORI_Instr Instr ;

  {
  {
#line 73
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 74
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ORI.L");
#line 75
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 76
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 77
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
static enum _TRACER_Channels  const  TRACER_default___56  =    (enum _TRACER_Channels  const  )11;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
static void execute___57(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ASX_Instr Instr ;
  int x ;
  char tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 42
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 44
  if (TRACER_Info[TRACER_default___56].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___56].Name, "execute");
#line 44
    tracer_printf((char *)"Source:\n");
    }
  }
#line 45
  if (Instr.Bits.IR == 0U) {
#line 47
    SValue = (unsigned long )Instr.Bits.CountReg;
#line 48
    if (SValue == 0UL) {
#line 48
      SValue = 8UL;
    }
#line 49
    if (TRACER_Info[TRACER_default___56].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___56].Name, "execute");
#line 49
      tracer_printf((char *)"Shift by count in instruction word = %d\n", SValue);
      }
    }
  } else {
    {
#line 51
    tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.CountReg);
    }
#line 51
    if (! tmp) {
#line 51
      return;
    }
    {
#line 53
    EA_GetValue(& SValue, & Source);
#line 54
    SValue &= 63UL;
    }
#line 55
    if (TRACER_Info[TRACER_default___56].Enabled) {
      {
#line 55
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___56].Name, "execute");
#line 55
      tracer_printf((char *)"Shift by count in D%d = \n", Instr.Bits.CountReg, SValue);
      }
    }
  }
#line 57
  if (TRACER_Info[TRACER_default___56].Enabled) {
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___56].Name, "execute");
#line 57
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 58
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 58
  if (! tmp___0) {
#line 58
    return;
  }
  {
#line 59
  EA_GetValue(& DValue, & Destination);
#line 61
  Result = DValue;
  }
#line 62
  if (Instr.Bits.DR == 0U) {
#line 64
    if (TRACER_Info[TRACER_default___56].Enabled) {
      {
#line 64
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___56].Name, "execute");
#line 64
      tracer_printf((char *)"Shift Right\n");
      }
    }
#line 66
    x = 0;
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
#line 66
      if (! ((unsigned long )x < SValue)) {
#line 66
        goto while_break;
      }
#line 67
      SRBits->C = (unsigned int )(Result & 1UL);
#line 68
      SRBits->X = (unsigned int )(Result & 1UL);
#line 69
      Result >>= 1;
#line 70
      if (Result & 1073741824UL) {
#line 71
        Result |= 2147483648UL;
      }
#line 66
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 76
    if (TRACER_Info[TRACER_default___56].Enabled) {
      {
#line 76
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___56].Name, "execute");
#line 76
      tracer_printf((char *)"Shift Left\n");
      }
    }
#line 77
    x = 0;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! ((unsigned long )x < SValue)) {
#line 77
        goto while_break___0;
      }
#line 78
      if (Result & 2147483648UL) {
#line 78
        SRBits->C = 1U;
      } else {
#line 78
        SRBits->C = 0U;
      }
#line 79
      if (Result & 2147483648UL) {
#line 79
        SRBits->X = 1U;
      } else {
#line 79
        SRBits->X = 0U;
      }
#line 80
      Result <<= 1;
#line 77
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 83
  if ((long )Result < 0L) {
#line 83
    SRBits->N = 1U;
  } else {
#line 83
    SRBits->N = 0U;
  }
#line 84
  if (Result == 0UL) {
#line 84
    SRBits->Z = 1U;
  } else {
#line 84
    SRBits->Z = 0U;
  }
#line 85
  SRBits->V = 0U;
#line 87
  if (TRACER_Info[TRACER_default___56].Enabled) {
    {
#line 87
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___56].Name, "execute");
    }
#line 87
    if (Instr.Bits.DR == 0U) {
#line 87
      tmp___1 = ">>";
    } else {
#line 87
      tmp___1 = "<<";
    }
    {
#line 87
    tracer_printf((char *)"0x%08lx %s 0x%02lx = 0x%08lx\n", DValue, tmp___1, SValue,
                  Result);
    }
  }
#line 90
  if (TRACER_Info[TRACER_default___56].Enabled) {
    {
#line 90
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___56].Name, "execute");
#line 90
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 91
  EA_PutValue(& Destination, Result);
#line 93
  cycle((unsigned long )ASXTime);
  }
#line 95
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_asx.c"
static long disassemble___57(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ASX_Instr Instr ;
  long SValue ;

  {
  {
#line 101
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 103
  if (Instr.Bits.DR == 0U) {
    {
#line 105
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ASR.L");
    }
  } else {
    {
#line 108
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ASL.L");
    }
  }
#line 110
  if (Instr.Bits.IR == 0U) {
#line 112
    SValue = (long )Instr.Bits.CountReg;
#line 113
    if (SValue == 0L) {
#line 113
      SValue = 8L;
    }
    {
#line 114
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02ld",
            SValue);
    }
  } else {
    {
#line 116
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"D%d",
            Instr.Bits.CountReg);
    }
  }
  {
#line 118
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 119
  return (0L);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_dc.c"
static enum _TRACER_Channels  const  TRACER_default___57  =    (enum _TRACER_Channels  const  )18;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_dc.c"
static void execute___58(void) 
{ 
  unsigned long dummy ;

  {
#line 30
  if (TRACER_Info[TRACER_default___57].Enabled) {
    {
#line 30
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___57].Name, "execute");
#line 30
    tracer_printf((char *)"Called\n");
    }
  }
  {
#line 32
  Memory_RetrFromPC(& dummy, (short)16);
  }
#line 33
  if (TRACER_Info[TRACER_default___57].Enabled) {
    {
#line 33
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___57].Name, "execute");
#line 33
    tracer_printf((char *)"Value=0x%04x, doing exception vector 4\n", dummy);
    }
  }
  {
#line 35
  exception_do_exception((short)4);
  }
#line 36
  if (TRACER_Info[TRACER_default___57].Enabled) {
    {
#line 36
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___57].Name, "execute");
#line 36
    tracer_printf((char *)"Done\n");
    }
  }
#line 37
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_dc.c"
static long disassemble___58(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 43
  Memory_RetrFromPC(& dummy, (short)16);
#line 44
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"DC.W");
#line 45
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"0x%04lx",
          dummy);
#line 46
  *(Arg2 + 0) = (char)0;
  }
#line 47
  return (0L);
}
}
#line 61 "../i_5206/i_5206.h"
long unlk_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
int UNLKTime  =    2;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
static enum _TRACER_Channels  const  TRACER_default___58  =    (enum _TRACER_Channels  const  )58;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
static void execute___59(void) 
{ 
  struct _Address ARegister ;
  struct _Address Stack ;
  unsigned long Result ;
  UNLK_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 37
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 39
  tmp = EA_GetFromPC(& ARegister, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
  {
#line 40
  tmp___0 = EA_GetFromPC(& Stack, (short)32, (char)1, (char)7);
  }
#line 40
  if (! tmp___0) {
#line 40
    return;
  }
#line 43
  if (TRACER_Info[TRACER_default___58].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___58].Name, "execute");
#line 43
    tracer_printf((char *)"Loading Stack Pointer from A%d:\n", Instr.Bits.Register);
    }
  }
  {
#line 44
  EA_GetValue(& Result, & ARegister);
#line 45
  EA_PutValue(& Stack, Result);
  }
#line 46
  if (TRACER_Info[TRACER_default___58].Enabled) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___58].Name, "execute");
#line 46
    tracer_printf((char *)"New Stack Pointer is 0x%08lx\n", Result);
    }
  }
#line 50
  if (TRACER_Info[TRACER_default___58].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___58].Name, "execute");
#line 50
    tracer_printf((char *)"Popping old Aregister value from the stack\n");
    }
  }
  {
#line 51
  Result = Stack_Pop((short)32);
  }
#line 52
  if (TRACER_Info[TRACER_default___58].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___58].Name, "execute");
#line 52
    tracer_printf((char *)"   Value=0x%08lx, storing it...\n", Result);
    }
  }
  {
#line 53
  EA_PutValue(& ARegister, Result);
  }
#line 55
  if (TRACER_Info[TRACER_default___58].Enabled) {
    {
#line 55
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___58].Name, "execute");
#line 55
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 57
  cycle((unsigned long )UNLKTime);
  }
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
static long disassemble___59(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  UNLK_Instr Instr ;

  {
  {
#line 65
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 67
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"UNLK");
#line 68
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg1);
#line 69
  *(Arg2 + 0) = (char)0;
  }
#line 71
  return (0L);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
long unlk_5206_register(void) 
{ 


  {
  {
#line 76
  instruction_register((unsigned short)20056, (unsigned short)65528, & execute___59,
                       & disassemble___59);
  }
#line 77
  return (1L);
}
}
#line 43 "../i_5206/i_5206.h"
long nop_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_nop.c"
int NOPTime  =    3;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_nop.c"
static enum _TRACER_Channels  const  TRACER_default___59  =    (enum _TRACER_Channels  const  )39;
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_nop.c"
static void execute___60(void) 
{ 
  unsigned long dummy ;

  {
  {
#line 33
  Memory_RetrFromPC(& dummy, (short)16);
  }
#line 35
  if (TRACER_Info[TRACER_default___59].Enabled) {
    {
#line 35
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___59].Name, "execute");
#line 35
    tracer_printf((char *)"Doing nothing :) ...\n");
    }
  }
#line 36
  if (TRACER_Info[TRACER_default___59].Enabled) {
    {
#line 36
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___59].Name, "execute");
#line 36
    tracer_printf((char *)"Done.\n");
    }
  }
  {
#line 38
  cycle((unsigned long )NOPTime);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_nop.c"
static long disassemble___60(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 46
  Memory_RetrFromPC(& dummy, (short)16);
#line 47
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"NOP");
#line 48
  *(Arg1 + 0) = (char)0;
#line 49
  *(Arg2 + 0) = (char)0;
  }
#line 50
  return (0L);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_nop.c"
long nop_5206_register(void) 
{ 


  {
  {
#line 56
  instruction_register((unsigned short)20081, (unsigned short)65535, & execute___60,
                       & disassemble___60);
  }
#line 57
  return (1L);
}
}
#line 55 "../i_5206/i_5206.h"
long subq_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
int SUBQTime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
  {      1,      3,      3,      3, 
        3,      4,      3,      -1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
static enum _TRACER_Channels  const  TRACER_default___60  =    (enum _TRACER_Channels  const  )52;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
static void execute___61(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUBQ_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 43
  if (TRACER_Info[TRACER_default___60].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___60].Name, "execute");
#line 43
    tracer_printf((char *)"Source: (Retrieving from instruction word) = 0x%02x where (0=8)\n",
                  Instr.Bits.Data);
    }
  }
#line 44
  SValue = (unsigned long )Instr.Bits.Data;
#line 45
  if (SValue == 0UL) {
#line 45
    SValue = 8UL;
  }
#line 47
  if (TRACER_Info[TRACER_default___60].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___60].Name, "execute");
#line 47
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 48
  tmp = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 48
  if (! tmp) {
#line 48
    return;
  }
#line 50
  if (Instr.Bits.EAMode == 7U) {
    {
#line 52
    if (Instr.Bits.EARegister == 2U) {
#line 52
      goto case_2;
    }
#line 55
    if (Instr.Bits.EARegister == 3U) {
#line 55
      goto case_3;
    }
#line 58
    if (Instr.Bits.EARegister == 4U) {
#line 58
      goto case_4;
    }
#line 51
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 53
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___60].Name, "execute");
#line 53
    tracer_printf((char *)"(d_16,PC) addressing mode invalid.");
    }
#line 54
    return;
    case_3: /* CIL Label */ 
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___60].Name, "execute");
#line 56
    tracer_printf((char *)"(d_8,PC,Xn) addressing mode invalid.");
    }
#line 57
    return;
    case_4: /* CIL Label */ 
    {
#line 59
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___60].Name, "execute");
#line 59
    tracer_printf((char *)"#<data> addressing mode invalid.");
    }
#line 60
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 64
  EA_GetValue(& DValue, & Destination);
#line 66
  Result = DValue - SValue;
  }
#line 68
  if (TRACER_Info[TRACER_default___60].Enabled) {
    {
#line 68
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___60].Name, "execute");
#line 68
    tracer_printf((char *)"0x%08lx - 0x%08lx = 0x%08lx\n", DValue, SValue, Result);
    }
  }
#line 72
  if (Instr.Bits.EAMode != 1U) {
    {
#line 73
    SR_Set((short)53, (long )SValue, (long )DValue, (long )Result);
    }
  }
#line 77
  if (TRACER_Info[TRACER_default___60].Enabled) {
    {
#line 77
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___60].Name, "execute");
#line 77
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 78
  EA_PutValue(& Destination, Result);
  }
#line 80
  if (TRACER_Info[TRACER_default___60].Enabled) {
    {
#line 80
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___60].Name, "execute");
#line 80
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 82
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 82
  cycle((unsigned long )SUBQTime[tmp___0]);
  }
#line 84
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
static long disassemble___61(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUBQ_Instr Instr ;
  unsigned int tmp ;

  {
  {
#line 90
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 91
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUBQ.L");
  }
#line 92
  if ((char )(Instr.Bits.Data == 0U)) {
#line 92
    tmp = 8U;
  } else {
#line 92
    tmp = Instr.Bits.Data;
  }
  {
#line 92
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02X",
          tmp);
#line 93
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg2);
  }
#line 94
  return (0L);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
long subq_5206_register(void) 
{ 


  {
  {
#line 99
  instruction_register((unsigned short)20864, (unsigned short)61888, & execute___61,
                       & disassemble___61);
  }
#line 100
  return (1L);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
static enum _TRACER_Channels  const  TRACER_default___61  =    (enum _TRACER_Channels  const  )9;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
static void execute___62(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  AND_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (Instr.Bits.OPMode == 2U) {
#line 43
    if (TRACER_Info[TRACER_default___61].Enabled) {
      {
#line 43
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 43
      tracer_printf((char *)"<EA>y & Dx -> Dx\n");
      }
    }
#line 44
    if (Instr.Bits.EAMode == 1U) {
      {
#line 45
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 45
      tracer_printf((char *)"May not specify Ax for source");
      }
#line 46
      return;
    }
#line 48
    if (TRACER_Info[TRACER_default___61].Enabled) {
      {
#line 48
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 48
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 49
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 49
    if (! tmp) {
#line 49
      return;
    }
#line 50
    if (TRACER_Info[TRACER_default___61].Enabled) {
      {
#line 50
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 50
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 51
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 51
    if (! tmp___0) {
#line 51
      return;
    }
  } else
#line 52
  if (Instr.Bits.OPMode == 6U) {
#line 53
    if (Instr.Bits.EAMode == 0U) {
      {
#line 54
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 54
      tracer_printf((char *)"May not specify Dx for destination when source is Dx");
      }
#line 55
      return;
    } else
#line 56
    if (Instr.Bits.EAMode == 1U) {
      {
#line 57
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 57
      tracer_printf((char *)"May not specify Ax for destination when source is Dx");
      }
#line 58
      return;
    } else
#line 59
    if (Instr.Bits.EAMode == 7U) {
#line 59
      if (Instr.Bits.EARegister == 4U) {
        {
#line 60
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name,
                      "execute");
#line 60
        tracer_printf((char *)"May not specify Immediate Addressing for destination");
        }
#line 61
        return;
      }
    }
#line 63
    if (TRACER_Info[TRACER_default___61].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 63
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 64
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 64
    if (! tmp___1) {
#line 64
      return;
    }
#line 65
    if (TRACER_Info[TRACER_default___61].Enabled) {
      {
#line 65
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 65
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 66
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 66
    if (! tmp___2) {
#line 66
      return;
    }
  } else {
    {
#line 68
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 68
    tracer_printf((char *)"Unknown OPMode %d", Instr.Bits.OPMode);
    }
#line 69
    return;
  }
  {
#line 72
  EA_GetValue(& SValue, & Source);
#line 73
  EA_GetValue(& DValue, & Destination);
#line 75
  Result = SValue & DValue;
  }
#line 76
  if (TRACER_Info[TRACER_default___61].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 76
    tracer_printf((char *)"0x%08lx & 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 78
  if (TRACER_Info[TRACER_default___61].Enabled) {
    {
#line 78
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 78
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 79
  EA_PutValue(& Destination, Result);
#line 88
  memory_core.sr &= 65520UL;
#line 89
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 90
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 92
  if (TRACER_Info[TRACER_default___61].Enabled) {
    {
#line 92
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___61].Name, "execute");
#line 92
    tracer_printf((char *)"Done\n");
    }
  }
#line 94
  if (Instr.Bits.OPMode == 2U) {
    {
#line 95
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 95
    cycle((unsigned long )ANDTime[0][tmp___3]);
    }
  } else {
    {
#line 96
    tmp___4 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 96
    cycle((unsigned long )ANDTime[1][tmp___4]);
    }
  }
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_and.c"
static long disassemble___62(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  AND_Instr Instr ;

  {
  {
#line 104
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 105
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"AND.L");
  }
#line 106
  if (Instr.Bits.OPMode == 2U) {
    {
#line 107
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 108
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 110
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 111
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 113
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
static enum _TRACER_Channels  const  TRACER_default___62  =    (enum _TRACER_Channels  const  )57;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
static void execute___63(void) 
{ 
  struct _Address Source ;
  unsigned long SValue ;
  TST_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (Instr.Bits.Size == 3U) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___62].Name, "execute");
#line 43
    tracer_printf((char *)"Invalid size=3");
    }
#line 44
    return;
  }
#line 46
  if (TRACER_Info[TRACER_default___62].Enabled) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___62].Name, "execute");
#line 46
    tracer_printf((char *)"Size = %d=n", Instr.Bits.Size);
    }
  }
#line 47
  if (TRACER_Info[TRACER_default___62].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___62].Name, "execute");
#line 47
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 48
  tmp = EA_GetFromPC(& Source, (short )TST_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.EAMode,
                     (char )Instr.Bits.EARegister);
  }
#line 48
  if (! tmp) {
#line 49
    return;
  }
  {
#line 50
  EA_GetValue(& SValue, & Source);
  }
#line 52
  if (TRACER_Info[TRACER_default___62].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___62].Name, "execute");
#line 52
    tracer_printf((char *)"Testing 0x%08lx\n", SValue);
    }
  }
#line 61
  SRBits->N = (unsigned int )((long )SValue < 0L);
#line 62
  SRBits->Z = (unsigned int )(SValue == 0UL);
#line 63
  SRBits->V = 0U;
#line 64
  SRBits->C = 0U;
#line 66
  if (TRACER_Info[TRACER_default___62].Enabled) {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___62].Name, "execute");
#line 66
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 68
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 68
  cycle((unsigned long )TSTTime[tmp___0]);
  }
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_tst.c"
static long disassemble___63(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  TST_Instr Instr ;

  {
  {
#line 76
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 78
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TST.%c",
          (int const   )TST_SizeStr[(short )Instr.Bits.Size]);
#line 80
  Addressing_Print((short )TST_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.EAMode,
                   (char )Instr.Bits.EARegister, Arg1);
#line 83
  *(Arg2 + 0) = (char)0;
  }
#line 84
  return (0L);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
static enum _TRACER_Channels  const  TRACER_default___63  =    (enum _TRACER_Channels  const  )16;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
static void execute___64(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  CMPA_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___63].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___63].Name, "execute");
#line 38
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 39
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
#line 40
  if (TRACER_Info[TRACER_default___63].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___63].Name, "execute");
#line 40
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 41
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 41
  if (! tmp___0) {
#line 41
    return;
  }
  {
#line 43
  EA_GetValue(& SValue, & Source);
#line 44
  EA_GetValue(& DValue, & Destination);
#line 46
  Result = DValue - SValue;
  }
#line 48
  if (TRACER_Info[TRACER_default___63].Enabled) {
    {
#line 48
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___63].Name, "execute");
#line 48
    tracer_printf((char *)"Comparing 0x%08lx with 0x%08lx\n", SValue, DValue);
    }
  }
  {
#line 51
  SR_Set((short)18, (long )SValue, (long )DValue, (long )Result);
  }
#line 53
  if (TRACER_Info[TRACER_default___63].Enabled) {
    {
#line 53
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___63].Name, "execute");
#line 53
    tracer_printf((char *)"Done");
    }
  }
  {
#line 54
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 54
  cycle((unsigned long )CMPATime[tmp___1]);
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpa.c"
static long disassemble___64(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  CMPA_Instr Instr ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 62
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"CMPA.L");
#line 63
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 64
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg2);
  }
#line 65
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
static enum _TRACER_Channels  const  TRACER_default___64  =    (enum _TRACER_Channels  const  )26;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
static void execute___65(void) 
{ 
  struct _Address Destination ;
  unsigned long DValue ;
  JSR_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___64].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___64].Name, "execute");
#line 38
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 39
  tmp = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
  {
#line 40
  EA_GetEA(& DValue, & Destination);
  }
#line 42
  if (TRACER_Info[TRACER_default___64].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___64].Name, "execute");
#line 42
    tracer_printf((char *)"Saving PC to the stack\n");
    }
  }
  {
#line 43
  Stack_Push((short)32, memory_core.pc);
  }
#line 45
  if (TRACER_Info[TRACER_default___64].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___64].Name, "execute");
#line 45
    tracer_printf((char *)"New PC=0x%08lx\n", DValue);
    }
  }
#line 47
  memory_core.pc = DValue;
#line 51
  if (TRACER_Info[TRACER_default___64].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___64].Name, "execute");
#line 51
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 53
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 53
  cycle((unsigned long )JSRTime[tmp___0]);
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jsr.c"
static long disassemble___65(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  JSR_Instr Instr ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 62
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"JSR");
#line 63
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 64
  *(Arg2 + 0) = (char)0;
  }
#line 65
  return (0L);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
static void execute___66(void) 
{ 
  struct _Address Address ;
  unsigned long AddressValue ;
  MOVEM_Instr Instr ;
  unsigned long RegisterListMask ;
  short move_count ;
  long x ;
  char tmp ;

  {
  {
#line 42
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 43
  Memory_RetrFromPC(& RegisterListMask, (short)16);
  }
#line 48
  if (Instr.Bits.EAMode != 2U) {
#line 48
    if (Instr.Bits.EAMode != 5U) {
      {
#line 49
      printf((char const   */* __restrict  */)"MOVEM: EAMode 0x%02x is not allowed\n",
             Instr.Bits.EAMode);
      }
#line 50
      return;
    }
  }
  {
#line 55
  tmp = EA_GetFromPC(& Address, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 55
  if (! tmp) {
#line 55
    return;
  }
  {
#line 56
  EA_GetEA(& AddressValue, & Address);
#line 58
  move_count = (short)0;
  }
#line 59
  if (Instr.Bits.Direction == 0U) {
#line 61
    x = 0L;
    {
#line 61
    while (1) {
      while_continue: /* CIL Label */ ;
#line 61
      if (! (x < 8L)) {
#line 61
        goto while_break;
      }
#line 62
      if (RegisterListMask & 1UL) {
        {
#line 64
        Memory_Stor((short)32, (long )(AddressValue + (unsigned long )((int )move_count * 4)),
                    memory_core.d[x]);
#line 65
        move_count = (short )((int )move_count + 1);
        }
      }
#line 61
      x ++;
#line 61
      RegisterListMask >>= 1;
    }
    while_break: /* CIL Label */ ;
    }
#line 68
    x = 8L;
    {
#line 68
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 68
      if (! (x < 16L)) {
#line 68
        goto while_break___0;
      }
#line 69
      if (RegisterListMask & 1UL) {
        {
#line 71
        Memory_Stor((short)32, (long )(AddressValue + (unsigned long )((int )move_count * 4)),
                    memory_core.a[x - 8L]);
#line 72
        move_count = (short )((int )move_count + 1);
        }
      }
#line 68
      x ++;
#line 68
      RegisterListMask >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 78
    x = 0L;
    {
#line 78
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 78
      if (! (x < 8L)) {
#line 78
        goto while_break___1;
      }
#line 79
      if (RegisterListMask & 1UL) {
        {
#line 81
        Memory_Retr(& memory_core.d[x], (short)32, (long )(AddressValue + (unsigned long )((int )move_count * 4)));
#line 82
        move_count = (short )((int )move_count + 1);
        }
      }
#line 78
      x ++;
#line 78
      RegisterListMask >>= 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 85
    x = 8L;
    {
#line 85
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 85
      if (! (x < 16L)) {
#line 85
        goto while_break___2;
      }
#line 86
      if (RegisterListMask & 1UL) {
        {
#line 88
        Memory_Retr(& memory_core.a[x - 8L], (short)32, (long )(AddressValue + (unsigned long )((int )move_count * 4)));
#line 89
        move_count = (short )((int )move_count + 1);
        }
      }
#line 85
      x ++;
#line 85
      RegisterListMask >>= 1;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 95
  cycle((unsigned long )(MOVEMTime + (int )move_count));
  }
#line 96
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
static int movem_print___0(char *buffer , char reg , unsigned long reg_list ) 
{ 
  int x ;
  char n_printed ;
  char one_printed ;
  char *orignal_buffer ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 102
  n_printed = (char)0;
#line 103
  one_printed = (char)0;
#line 104
  orignal_buffer = buffer;
#line 109
  x = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (x < 9)) {
#line 109
      goto while_break;
    }
#line 110
    if (reg_list & 1UL) {
#line 111
      if (! n_printed) {
#line 114
        if (one_printed) {
          {
#line 115
          tmp = sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)",");
#line 115
          buffer += tmp;
          }
        }
        {
#line 116
        tmp___0 = sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%c%d",
                          (int )reg, x);
#line 116
        buffer += tmp___0;
#line 117
        one_printed = (char)1;
        }
      }
#line 119
      n_printed = (char )((int )n_printed + 1);
    } else
#line 121
    if ((int )n_printed > 1) {
      {
#line 122
      tmp___1 = sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"-%c%d",
                        (int )reg, x - 1);
#line 122
      buffer += tmp___1;
#line 123
      n_printed = (char)0;
      }
    }
#line 109
    x ++;
#line 109
    reg_list >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return ((int )(buffer - orignal_buffer));
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movem.c"
static long disassemble___66(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVEM_Instr Instr ;
  char *regStr ;
  short size ;
  unsigned long RegisterListMask ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 137
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 138
  Memory_RetrFromPC(& RegisterListMask, (short)16);
#line 140
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVEM.L");
  }
#line 142
  if (Instr.Bits.Direction == 0U) {
    {
#line 144
    regStr = Arg1;
#line 145
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  } else {
    {
#line 147
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 148
    regStr = Arg2;
    }
  }
  {
#line 150
  *(regStr + 0) = (char)0;
#line 155
  tmp = movem_print___0(regStr, (char )'D', RegisterListMask & 255UL);
#line 155
  size = (short )tmp;
  }
#line 156
  if (size) {
#line 156
    if (RegisterListMask & 65280UL) {
      {
#line 157
      regStr += (int )size;
#line 158
      tmp___0 = sprintf((char */* __restrict  */)regStr, (char const   */* __restrict  */)"/");
#line 158
      regStr += tmp___0;
      }
    }
  }
  {
#line 160
  movem_print___0(regStr, (char )'A', (RegisterListMask & 65280UL) >> 8);
  }
#line 162
  return (0L);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
static enum _TRACER_Channels  const  TRACER_default___65  =    (enum _TRACER_Channels  const  )35;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
static void execute___67(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  char Register ;
  unsigned long Instr2 ;
  MULU_L_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 41
  Memory_RetrFromPC(& Instr2, (short)16);
#line 42
  Register = (char )((Instr2 & 28672UL) >> 12);
  }
#line 45
  if (Instr.Bits.EAMode == 1U) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___65].Name, "execute");
#line 46
    tracer_printf((char *)"May Not specify Address Register (Ay) for MULU.L");
    }
#line 47
    return;
  } else
#line 48
  if (Instr.Bits.EAMode == 7U) {
    {
#line 49
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___65].Name, "execute");
#line 49
    tracer_printf((char *)"May Not specify Direct Addressing for MULU.L");
    }
#line 50
    return;
  }
#line 52
  if (TRACER_Info[TRACER_default___65].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___65].Name, "execute");
#line 52
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 53
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 53
  if (! tmp) {
#line 53
    return;
  }
#line 54
  if (TRACER_Info[TRACER_default___65].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___65].Name, "execute");
#line 54
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 55
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, Register);
  }
#line 55
  if (! tmp___0) {
#line 55
    return;
  }
  {
#line 57
  EA_GetValue(& SValue, & Source);
#line 58
  EA_GetValue(& DValue, & Destination);
  }
#line 63
  if (Instr2 & 2048UL) {
#line 65
    Result = (unsigned long )((long )SValue * (long )DValue);
  } else {
#line 68
    Result = SValue * DValue;
  }
#line 71
  if (TRACER_Info[TRACER_default___65].Enabled) {
    {
#line 71
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___65].Name, "execute");
#line 71
    tracer_printf((char *)"0x%08lx * 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 74
  memory_core.sr &= 65520UL;
#line 75
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 76
  SRBits->Z = (unsigned int )(Result == 0UL);
#line 78
  if (TRACER_Info[TRACER_default___65].Enabled) {
    {
#line 78
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___65].Name, "execute");
#line 78
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 79
  EA_PutValue(& Destination, Result);
  }
#line 81
  if (TRACER_Info[TRACER_default___65].Enabled) {
    {
#line 81
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___65].Name, "execute");
#line 81
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 83
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 83
  cycle((unsigned long )MULLTime[tmp___1]);
  }
#line 85
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_mulu_l.c"
static long disassemble___67(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long Instr2 ;
  char Register ;
  MULU_L_Instr Instr ;
  int tmp ;

  {
  {
#line 93
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 94
  Memory_RetrFromPC(& Instr2, (short)16);
#line 95
  Register = (char )((Instr2 & 28672UL) >> 12);
  }
#line 97
  if (Instr2 & 2048UL) {
#line 97
    tmp = 'S';
  } else {
#line 97
    tmp = 'U';
  }
  {
#line 97
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MUL%c.L",
          tmp);
#line 98
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 99
  Addressing_Print((short)32, (char)0, Register, Arg2);
  }
#line 100
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
static enum _TRACER_Channels  const  TRACER_default___66  =    (enum _TRACER_Channels  const  )33;
#line 32 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
static void execute___68(void) 
{ 
  struct _Address Destination ;
  unsigned long SValue ;
  MOVEQ_Instr Instr ;
  char tmp ;

  {
  {
#line 37
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 39
  if (TRACER_Info[TRACER_default___66].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___66].Name, "execute");
#line 39
    tracer_printf((char *)"Source: (from Instruction word) = 0x%02x\n", Instr.Bits.Data);
    }
  }
#line 40
  SValue = (unsigned long )Instr.Bits.Data;
#line 42
  if (TRACER_Info[TRACER_default___66].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___66].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp) {
#line 43
    return;
  }
#line 45
  if (TRACER_Info[TRACER_default___66].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___66].Name, "execute");
#line 45
    tracer_printf((char *)"Storing result:\n");
    }
  }
  {
#line 46
  EA_PutValue(& Destination, SValue);
#line 54
  memory_core.sr &= 65520UL;
#line 55
  SRBits->N = (unsigned int )((long )SValue < 0L);
#line 56
  SRBits->Z = (unsigned int )(SValue == 0UL);
  }
#line 58
  if (TRACER_Info[TRACER_default___66].Enabled) {
    {
#line 58
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___66].Name, "execute");
#line 58
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 60
  cycle((unsigned long )MOVEQTime);
  }
#line 62
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_moveq.c"
static long disassemble___68(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVEQ_Instr Instr ;

  {
  {
#line 68
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 70
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVEQ");
#line 72
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02X",
          (int )((char )Instr.Bits.Data) & 255);
#line 73
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 74
  return (0L);
}
}
#line 44 "../i_5206/i_5206.h"
long not_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
int NOTTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
static enum _TRACER_Channels  const  TRACER_default___67  =    (enum _TRACER_Channels  const  )40;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
static void execute___69(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long DValue ;
  NOT_Instr Instr ;
  char tmp ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 37
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 37
  if (! tmp) {
#line 37
    return;
  }
  {
#line 38
  EA_GetValue(& DValue, & Destination);
#line 40
  Result = ~ DValue;
  }
#line 41
  if (TRACER_Info[TRACER_default___67].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___67].Name, "execute");
#line 41
    tracer_printf((char *)"~0x%08lx = 0x%08lx\n", DValue, Result);
    }
  }
#line 44
  memory_core.sr &= 65520UL;
#line 45
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 46
  SRBits->Z = (unsigned int )(Result == 0UL);
#line 48
  if (TRACER_Info[TRACER_default___67].Enabled) {
    {
#line 48
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___67].Name, "execute");
#line 48
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 49
  EA_PutValue(& Destination, Result);
  }
#line 51
  if (TRACER_Info[TRACER_default___67].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___67].Name, "execute");
#line 51
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 53
  cycle((unsigned long )NOTTime);
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
static long disassemble___69(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  NOT_Instr Instr ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 62
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"NOT.L");
#line 63
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 64
  *(Arg2 + 0) = (char)0;
  }
#line 65
  return (0L);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
long not_5206_register(void) 
{ 


  {
  {
#line 71
  instruction_register((unsigned short)18048, (unsigned short)65528, & execute___69,
                       & disassemble___69);
  }
#line 72
  return (1L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rte.c"
static enum _TRACER_Channels  const  TRACER_default___68  =    (enum _TRACER_Channels  const  )44;
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rte.c"
static void execute___70(void) 
{ 
  unsigned long dummy ;

  {
  {
#line 33
  Memory_RetrFromPC(& dummy, (short)16);
#line 35
  exception_restore_from_stack_frame();
  }
#line 37
  if (TRACER_Info[TRACER_default___68].Enabled) {
    {
#line 37
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___68].Name, "execute");
#line 37
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 39
  cycle((unsigned long )RTETime);
  }
#line 41
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rte.c"
static long disassemble___70(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 47
  Memory_RetrFromPC(& dummy, (short)16);
#line 48
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"RTE");
#line 49
  *(Arg1 + 0) = (char)0;
#line 50
  *(Arg2 + 0) = (char)0;
  }
#line 51
  return (0L);
}
}
#line 25 "../i_5206/i_5206.h"
long eori_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
int EORITime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
static enum _TRACER_Channels  const  TRACER_default___69  =    (enum _TRACER_Channels  const  )21;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
static void execute___71(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  EORI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 37
  if (TRACER_Info[TRACER_default___69].Enabled) {
    {
#line 37
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___69].Name, "execute");
#line 37
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 38
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 38
  if (! tmp) {
#line 38
    return;
  }
#line 39
  if (TRACER_Info[TRACER_default___69].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___69].Name, "execute");
#line 39
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 40
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 40
  if (! tmp___0) {
#line 40
    return;
  }
  {
#line 42
  EA_GetValue(& SValue, & Source);
#line 43
  EA_GetValue(& DValue, & Destination);
#line 45
  Result = SValue ^ DValue;
  }
#line 47
  if (TRACER_Info[TRACER_default___69].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___69].Name, "execute");
#line 47
    tracer_printf((char *)"0x%08lx ^ 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 49
  if (TRACER_Info[TRACER_default___69].Enabled) {
    {
#line 49
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___69].Name, "execute");
#line 49
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 50
  EA_PutValue(& Destination, Result);
#line 58
  memory_core.sr &= 65520UL;
#line 59
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 60
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 61
  if (TRACER_Info[TRACER_default___69].Enabled) {
    {
#line 61
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___69].Name, "execute");
#line 61
    tracer_printf((char *)"Done");
    }
  }
  {
#line 63
  cycle((unsigned long )EORITime);
  }
#line 65
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
static long disassemble___71(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  EORI_Instr Instr ;

  {
  {
#line 71
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 72
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EORI.L");
#line 73
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 74
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 75
  return (0L);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
long eori_5206_register(void) 
{ 


  {
  {
#line 80
  instruction_register((unsigned short)2688, (unsigned short)65528, & execute___71,
                       & disassemble___71);
  }
#line 81
  return (1L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
static enum _TRACER_Channels  const  TRACER_default___70  =    (enum _TRACER_Channels  const  )55;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
static void execute___72(void) 
{ 
  TRAP_Instr Instr ;

  {
  {
#line 34
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 36
  if (TRACER_Info[TRACER_default___70].Enabled) {
    {
#line 36
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___70].Name, "execute");
#line 36
    tracer_printf((char *)"Vector=0x%02x\n", Instr.Bits.Vector);
    }
  }
  {
#line 41
  exception_do_exception((short )(32U + Instr.Bits.Vector));
  }
#line 42
  if (TRACER_Info[TRACER_default___70].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___70].Name, "execute");
#line 42
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 44
  cycle((unsigned long )TRAPTime);
  }
#line 46
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trap.c"
static long disassemble___72(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  TRAP_Instr Instr ;

  {
  {
#line 52
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 53
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TRAP");
#line 54
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02X",
          Instr.Bits.Vector);
#line 55
  *(Arg2 + 0) = (char)0;
  }
#line 56
  return (0L);
}
}
#line 29 "../i_5206/i_5206.h"
long jmp_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
int JMPTime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
  {      -1,      3,      -1,      -1, 
        3,      4,      3,      -1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
static enum _TRACER_Channels  const  TRACER_default___71  =    (enum _TRACER_Channels  const  )25;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
static void execute___73(void) 
{ 
  struct _Address Destination ;
  unsigned long DValue ;
  JMP_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___71].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___71].Name, "execute");
#line 38
    tracer_printf((char *)"Called...\n");
    }
  }
#line 40
  if (TRACER_Info[TRACER_default___71].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___71].Name, "execute");
#line 40
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
  {
#line 43
  EA_GetEA(& DValue, & Destination);
  }
#line 45
  if (TRACER_Info[TRACER_default___71].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___71].Name, "execute");
#line 45
    tracer_printf((char *)"New PC=0x%08lx\n", DValue);
    }
  }
#line 49
  memory_core.pc = DValue;
#line 50
  if (TRACER_Info[TRACER_default___71].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___71].Name, "execute");
#line 50
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 52
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 52
  cycle((unsigned long )JMPTime[tmp___0]);
  }
#line 54
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
static long disassemble___73(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  JMP_Instr Instr ;

  {
  {
#line 60
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 61
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"JMP");
#line 62
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 63
  *(Arg2 + 0) = (char)0;
  }
#line 64
  return (0L);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
long jmp_5206_register(void) 
{ 


  {
  {
#line 69
  instruction_register((unsigned short)20160, (unsigned short)65472, & execute___73,
                       & disassemble___73);
  }
#line 70
  return (1L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
static enum _TRACER_Channels  const  TRACER_default___72  =    (enum _TRACER_Channels  const  )41;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
static void execute___74(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  OR_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (Instr.Bits.OPMode == 2U) {
#line 41
    if (TRACER_Info[TRACER_default___72].Enabled) {
      {
#line 41
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 41
      tracer_printf((char *)"<EA>y | Dx -> Dx\n");
      }
    }
#line 42
    if (Instr.Bits.EAMode == 1U) {
      {
#line 43
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 43
      tracer_printf((char *)"May not specify Ax for source");
      }
#line 44
      return;
    }
#line 46
    if (TRACER_Info[TRACER_default___72].Enabled) {
      {
#line 46
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 46
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 47
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 47
    if (! tmp) {
#line 47
      return;
    }
#line 48
    if (TRACER_Info[TRACER_default___72].Enabled) {
      {
#line 48
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 48
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 49
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 49
    if (! tmp___0) {
#line 49
      return;
    }
  } else
#line 50
  if (Instr.Bits.OPMode == 6U) {
#line 51
    if (Instr.Bits.EAMode == 0U) {
      {
#line 52
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 52
      tracer_printf((char *)"May not specify Dx for destination when source is Dx");
      }
#line 53
      return;
    } else
#line 54
    if (Instr.Bits.EAMode == 1U) {
      {
#line 55
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 55
      tracer_printf((char *)"May not specify Ax for destination when source is Dx");
      }
#line 56
      return;
    } else
#line 57
    if (Instr.Bits.EAMode == 7U) {
#line 57
      if (Instr.Bits.EARegister == 4U) {
        {
#line 58
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name,
                      "execute");
#line 58
        tracer_printf((char *)"May not specify Immediate Addressing for destination");
        }
#line 59
        return;
      }
    }
#line 61
    if (TRACER_Info[TRACER_default___72].Enabled) {
      {
#line 61
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 61
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 62
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 62
    if (! tmp___1) {
#line 62
      return;
    }
#line 63
    if (TRACER_Info[TRACER_default___72].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 63
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 64
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 64
    if (! tmp___2) {
#line 64
      return;
    }
  } else {
    {
#line 66
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 66
    tracer_printf((char *)"Unknown OPMode %d", Instr.Bits.OPMode);
    }
#line 67
    return;
  }
  {
#line 70
  EA_GetValue(& SValue, & Source);
#line 71
  EA_GetValue(& DValue, & Destination);
#line 73
  Result = SValue | DValue;
  }
#line 74
  if (TRACER_Info[TRACER_default___72].Enabled) {
    {
#line 74
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 74
    tracer_printf((char *)"0x%08lx | 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 76
  if (TRACER_Info[TRACER_default___72].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 76
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 77
  EA_PutValue(& Destination, Result);
#line 85
  memory_core.sr &= 65520UL;
#line 86
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 87
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 89
  if (TRACER_Info[TRACER_default___72].Enabled) {
    {
#line 89
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___72].Name, "execute");
#line 89
    tracer_printf((char *)"Done\n");
    }
  }
#line 91
  if (Instr.Bits.OPMode == 2U) {
    {
#line 92
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 92
    cycle((unsigned long )ORTime[0][tmp___3]);
    }
  } else {
    {
#line 93
    tmp___4 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 93
    cycle((unsigned long )ORTime[1][tmp___4]);
    }
  }
#line 96
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_or.c"
static long disassemble___74(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  OR_Instr Instr ;

  {
  {
#line 102
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 103
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"OR.L");
  }
#line 104
  if (Instr.Bits.OPMode == 2U) {
    {
#line 105
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 106
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 108
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 109
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 111
  return (0L);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
static enum _TRACER_Channels  const  TRACER_default___73  =    (enum _TRACER_Channels  const  )48;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
static void execute___75(void) 
{ 
  struct _Address Source ;
  unsigned long Result ;
  unsigned long SValue ;
  STOP_Instr Instr ;
  char tmp ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 37
  if (TRACER_Info[TRACER_default___73].Enabled) {
    {
#line 37
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___73].Name, "execute");
#line 37
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 38
  tmp = EA_GetFromPC(& Source, (short)16, (char)7, (char)4);
  }
#line 38
  if (! tmp) {
#line 38
    return;
  }
  {
#line 39
  EA_GetValue(& SValue, & Source);
#line 41
  Result = SValue;
  }
#line 43
  if (TRACER_Info[TRACER_default___73].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___73].Name, "execute");
#line 43
    tracer_printf((char *)"#0x%08lx\n", Result);
    }
  }
#line 45
  if (TRACER_Info[TRACER_default___73].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___73].Name, "execute");
#line 45
    tracer_printf((char *)"Storing Result:\n");
    }
  }
#line 48
  memory_core.sr = Result;
#line 50
  if (TRACER_Info[TRACER_default___73].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___73].Name, "execute");
#line 50
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 52
  cycle((unsigned long )STOPTime);
  }
#line 54
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_stop.c"
static long disassemble___75(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  STOP_Instr Instr ;
  unsigned long SValue ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 62
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"STOP");
#line 63
  Memory_RetrFromPC(& SValue, (short)16);
#line 64
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#$%08lx",
          SValue);
#line 65
  *(Arg2 + 0) = (char)0;
  }
#line 67
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
static enum _TRACER_Channels  const  TRACER_default___74  =    (enum _TRACER_Channels  const  )5;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
static void execute___76(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ADDA_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___74].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___74].Name, "execute");
#line 40
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 41
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 41
  if (! tmp) {
#line 41
    return;
  }
#line 42
  if (TRACER_Info[TRACER_default___74].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___74].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp___0) {
#line 43
    return;
  }
  {
#line 45
  EA_GetValue(& SValue, & Source);
#line 46
  EA_GetValue(& DValue, & Destination);
#line 48
  Result = SValue + DValue;
  }
#line 50
  if (TRACER_Info[TRACER_default___74].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___74].Name, "execute");
#line 50
    tracer_printf((char *)"0x%08lx + 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 54
  if (TRACER_Info[TRACER_default___74].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___74].Name, "execute");
#line 54
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 55
  EA_PutValue(& Destination, Result);
#line 57
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 57
  cycle((unsigned long )ADDATime[tmp___1]);
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_adda.c"
static long disassemble___76(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADDA_Instr Instr ;

  {
  {
#line 63
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 64
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADDA.L");
#line 65
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 66
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg2);
  }
#line 67
  return (0L);
}
}
#line 53 "../i_5206/i_5206.h"
long suba_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
int SUBATime[8]  = 
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
  {      -1,      3,      3,      3, 
        3,      4,      3,      -1};
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
static enum _TRACER_Channels  const  TRACER_default___75  =    (enum _TRACER_Channels  const  )50;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
static void execute___77(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUBA_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___75].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___75].Name, "execute");
#line 40
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 41
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 41
  if (! tmp) {
#line 41
    return;
  }
#line 42
  if (TRACER_Info[TRACER_default___75].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___75].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp___0) {
#line 43
    return;
  }
  {
#line 45
  EA_GetValue(& SValue, & Source);
#line 46
  EA_GetValue(& DValue, & Destination);
#line 48
  Result = DValue - SValue;
  }
#line 50
  if (TRACER_Info[TRACER_default___75].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___75].Name, "execute");
#line 50
    tracer_printf((char *)"0x%08lx - 0x%08lx = 0x%08lx\n", DValue, SValue, Result);
    }
  }
#line 54
  if (TRACER_Info[TRACER_default___75].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___75].Name, "execute");
#line 54
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 55
  EA_PutValue(& Destination, Result);
  }
#line 57
  if (TRACER_Info[TRACER_default___75].Enabled) {
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___75].Name, "execute");
#line 57
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 59
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 59
  cycle((unsigned long )SUBATime[tmp___1]);
  }
#line 61
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
static long disassemble___77(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUBA_Instr Instr ;

  {
  {
#line 67
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 68
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUBA.L");
#line 69
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 70
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg2);
  }
#line 71
  return (0L);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
long suba_5206_register(void) 
{ 


  {
  {
#line 76
  instruction_register((unsigned short)37312, (unsigned short)61888, & execute___77,
                       & disassemble___77);
  }
#line 77
  return (1L);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
static enum _TRACER_Channels  const  TRACER_default___76  =    (enum _TRACER_Channels  const  )17;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
static void execute___78(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  CMPI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___76].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___76].Name, "execute");
#line 41
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
#line 43
  if (TRACER_Info[TRACER_default___76].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___76].Name, "execute");
#line 43
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 44
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 44
  if (! tmp___0) {
#line 44
    return;
  }
  {
#line 46
  EA_GetValue(& SValue, & Source);
#line 47
  EA_GetValue(& DValue, & Destination);
#line 49
  Result = DValue - SValue;
  }
#line 51
  if (TRACER_Info[TRACER_default___76].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___76].Name, "execute");
#line 51
    tracer_printf((char *)"Comparing 0x%08lx with 0x%08lx\n", SValue, DValue);
    }
  }
  {
#line 54
  SR_Set((short)19, (long )SValue, (long )DValue, (long )Result);
#line 56
  cycle((unsigned long )CMPITime);
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmpi.c"
static long disassemble___78(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  CMPI_Instr Instr ;

  {
  {
#line 64
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 65
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"CMPI.L");
#line 66
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 67
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 68
  return (0L);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
static enum _TRACER_Channels  const  TRACER_default___77  =    (enum _TRACER_Channels  const  )49;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
static void execute___79(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUB_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (Instr.Bits.OPMode == 2U) {
#line 43
    if (TRACER_Info[TRACER_default___77].Enabled) {
      {
#line 43
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 43
      tracer_printf((char *)"<EA>y + Dx -> Dx\n");
      }
    }
#line 44
    if (TRACER_Info[TRACER_default___77].Enabled) {
      {
#line 44
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 44
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 45
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 45
    if (! tmp) {
#line 45
      return;
    }
#line 46
    if (TRACER_Info[TRACER_default___77].Enabled) {
      {
#line 46
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 46
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 47
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 47
    if (! tmp___0) {
#line 47
      return;
    }
  } else
#line 48
  if (Instr.Bits.OPMode == 6U) {
#line 49
    if (TRACER_Info[TRACER_default___77].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 49
      tracer_printf((char *)"Dy + <EA>x -> <EA>x\n");
      }
    }
#line 50
    if (Instr.Bits.EAMode == 0U) {
      {
#line 51
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 51
      tracer_printf((char *)"May not specify Dx for destination when source is Dx");
      }
#line 52
      return;
    } else
#line 53
    if (Instr.Bits.EAMode == 1U) {
      {
#line 54
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 54
      tracer_printf((char *)"May not specify Ax for destination when source is Dx");
      }
#line 55
      return;
    }
#line 57
    if (TRACER_Info[TRACER_default___77].Enabled) {
      {
#line 57
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 57
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 58
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 58
    if (! tmp___1) {
#line 58
      return;
    }
#line 59
    if (TRACER_Info[TRACER_default___77].Enabled) {
      {
#line 59
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 59
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 60
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 60
    if (! tmp___2) {
#line 60
      return;
    }
  } else {
    {
#line 62
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 62
    tracer_printf((char *)"Unknown opcode %x\n", Instr.Bits.OPMode);
    }
#line 63
    return;
  }
  {
#line 65
  EA_GetValue(& SValue, & Source);
#line 66
  EA_GetValue(& DValue, & Destination);
#line 68
  Result = DValue - SValue;
  }
#line 70
  if (TRACER_Info[TRACER_default___77].Enabled) {
    {
#line 70
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 70
    tracer_printf((char *)"0x%08lx - 0x%08lx = 0x%08lx\n", DValue, SValue, Result);
    }
  }
  {
#line 73
  SR_Set((short)50, (long )SValue, (long )DValue, (long )Result);
  }
#line 75
  if (TRACER_Info[TRACER_default___77].Enabled) {
    {
#line 75
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 75
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 76
  EA_PutValue(& Destination, Result);
  }
#line 78
  if (TRACER_Info[TRACER_default___77].Enabled) {
    {
#line 78
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___77].Name, "execute");
#line 78
    tracer_printf((char *)"Done\n");
    }
  }
#line 80
  if (Instr.Bits.OPMode == 2U) {
    {
#line 81
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 81
    cycle((unsigned long )SUBTime[0][tmp___3]);
    }
  } else {
    {
#line 82
    tmp___4 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 82
    cycle((unsigned long )SUBTime[1][tmp___4]);
    }
  }
#line 84
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_sub.c"
static long disassemble___79(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUB_Instr Instr ;

  {
  {
#line 90
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 91
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUB.L");
  }
#line 92
  if (Instr.Bits.OPMode == 2U) {
    {
#line 93
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 94
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 96
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 97
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 99
  return (0L);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
static enum _TRACER_Channels  const  TRACER_default___78  =    (enum _TRACER_Channels  const  )4;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
static void execute___80(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ADD_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (Instr.Bits.OPMode == 2U) {
#line 43
    if (TRACER_Info[TRACER_default___78].Enabled) {
      {
#line 43
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 43
      tracer_printf((char *)"<EA>y + Dx -> Dx\n");
      }
    }
#line 44
    if (TRACER_Info[TRACER_default___78].Enabled) {
      {
#line 44
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 44
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 45
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 45
    if (! tmp) {
#line 45
      return;
    }
#line 46
    if (TRACER_Info[TRACER_default___78].Enabled) {
      {
#line 46
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 46
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 47
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 47
    if (! tmp___0) {
#line 47
      return;
    }
  } else {
#line 49
    if (TRACER_Info[TRACER_default___78].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 49
      tracer_printf((char *)"Dy + <EA>x -> <EA>x\n");
      }
    }
#line 50
    if (Instr.Bits.EAMode == 0U) {
      {
#line 51
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 51
      tracer_printf((char *)"May not specify Dx for destination when source is Dx");
      }
#line 52
      return;
    } else
#line 53
    if (Instr.Bits.EAMode == 1U) {
      {
#line 54
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 54
      tracer_printf((char *)"May not specify Ax for destination when source is Dx");
      }
#line 55
      return;
    }
#line 57
    if (TRACER_Info[TRACER_default___78].Enabled) {
      {
#line 57
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 57
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 58
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 58
    if (! tmp___1) {
#line 58
      return;
    }
#line 59
    if (TRACER_Info[TRACER_default___78].Enabled) {
      {
#line 59
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 59
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 60
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 60
    if (! tmp___2) {
#line 60
      return;
    }
  }
  {
#line 62
  EA_GetValue(& SValue, & Source);
#line 63
  EA_GetValue(& DValue, & Destination);
#line 65
  Result = SValue + DValue;
  }
#line 67
  if (TRACER_Info[TRACER_default___78].Enabled) {
    {
#line 67
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 67
    tracer_printf((char *)"0x%08lx + 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
  {
#line 69
  SR_Set((short)0, (long )SValue, (long )DValue, (long )Result);
  }
#line 71
  if (TRACER_Info[TRACER_default___78].Enabled) {
    {
#line 71
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___78].Name, "execute");
#line 71
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 72
  EA_PutValue(& Destination, Result);
  }
#line 74
  if (Instr.Bits.OPMode == 2U) {
    {
#line 75
    tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 75
    cycle((unsigned long )ADDTime[0][tmp___3]);
    }
  } else {
    {
#line 77
    tmp___4 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 77
    cycle((unsigned long )ADDTime[1][tmp___4]);
    }
  }
#line 79
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_add.c"
static long disassemble___80(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADD_Instr Instr ;

  {
  {
#line 85
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 87
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADD.L");
  }
#line 88
  if (Instr.Bits.OPMode == 2U) {
    {
#line 89
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 90
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 92
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 93
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 95
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
static enum _TRACER_Channels  const  TRACER_default___79  =    (enum _TRACER_Channels  const  )14;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
static void execute___81(void) 
{ 
  struct _Address Destination ;
  CLR_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 43
  if (Instr.Bits.Size == 3U) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___79].Name, "execute");
#line 44
    tracer_printf((char *)"Invalid size=3", memory_core.pc);
    }
#line 45
    return;
  }
#line 48
  if (TRACER_Info[TRACER_default___79].Enabled) {
    {
#line 48
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___79].Name, "execute");
#line 48
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 49
  tmp = EA_GetFromPC(& Destination, (short )CLR_SizeBits[(short )Instr.Bits.Size],
                     (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 49
  if (! tmp) {
#line 49
    return;
  }
#line 50
  if (TRACER_Info[TRACER_default___79].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___79].Name, "execute");
#line 50
    tracer_printf((char *)"Clearing:\n");
    }
  }
  {
#line 51
  EA_PutValue(& Destination, 0UL);
#line 59
  SRBits->N = 0U;
#line 60
  SRBits->Z = 1U;
#line 61
  SRBits->V = 0U;
#line 62
  SRBits->C = 0U;
#line 63
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 63
  cycle((unsigned long )CLRTime[tmp___0]);
  }
#line 64
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_clr.c"
static long disassemble___81(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  CLR_Instr Instr ;

  {
  {
#line 70
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 72
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"CLR.%c",
          (int const   )CLR_SizeStr[(short )Instr.Bits.Size]);
#line 74
  Addressing_Print((short )CLR_SizeBits[(short )Instr.Bits.Size], (char )Instr.Bits.EAMode,
                   (char )Instr.Bits.EARegister, Arg1);
#line 75
  *(Arg2 + 0) = (char)0;
  }
#line 77
  return (0L);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
static enum _TRACER_Channels  const  TRACER_default___80  =    (enum _TRACER_Channels  const  )31;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
static void execute___82(void) 
{ 
  struct _Address Source ;
  unsigned long SValue ;
  MOVEC_Instr Instr ;
  char tmp ;

  {
  {
#line 41
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 43
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 45
  if (TRACER_Info[TRACER_default___80].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 45
    tracer_printf((char *)"Retrieving source (A...\n");
    }
  }
  {
#line 46
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.AD, (char )Instr.Bits.Register);
  }
#line 46
  if (! tmp) {
#line 46
    return;
  }
  {
#line 48
  EA_GetValue(& SValue, & Source);
  }
#line 50
  if (SRBits->S) {
    {
#line 53
    if (Instr.Bits.ControlRegister == 2U) {
#line 53
      goto case_2;
    }
#line 56
    if (Instr.Bits.ControlRegister == 4U) {
#line 56
      goto case_4;
    }
#line 59
    if (Instr.Bits.ControlRegister == 5U) {
#line 59
      goto case_5;
    }
#line 62
    if (Instr.Bits.ControlRegister == 2049U) {
#line 62
      goto case_2049;
    }
#line 66
    if (Instr.Bits.ControlRegister == 2063U) {
#line 66
      goto case_2063;
    }
#line 70
    if (Instr.Bits.ControlRegister == 3072U) {
#line 70
      goto case_3072;
    }
#line 74
    if (Instr.Bits.ControlRegister == 3076U) {
#line 74
      goto case_3076;
    }
#line 78
    if (Instr.Bits.ControlRegister == 3087U) {
#line 78
      goto case_3087;
    }
#line 82
    goto switch_default;
    case_2: /* CIL Label */ 
#line 54
    memory_core.cacr = SValue;
#line 55
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 57
    tracer_printf((char *)"Storing 0x%08lx in the ACR0 is unimplemented!\n", SValue);
    }
#line 58
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 60
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 60
    tracer_printf((char *)"Storing 0x%08lx in the ACR1 is unimplemented!\n", SValue);
    }
#line 61
    goto switch_break;
    case_2049: /* CIL Label */ 
#line 63
    if (TRACER_Info[TRACER_default___80].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 63
      tracer_printf((char *)"Storing 0x%08lx in the VBR\n", SValue);
      }
    }
#line 64
    memory_core.vbr = SValue;
#line 65
    goto switch_break;
    case_2063: /* CIL Label */ 
#line 67
    if (TRACER_Info[TRACER_default___80].Enabled) {
      {
#line 67
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 67
      tracer_printf((char *)"Storing 0x%08lx in the PC\n", SValue);
      }
    }
#line 68
    memory_core.pc = SValue;
#line 69
    goto switch_break;
    case_3072: /* CIL Label */ 
#line 71
    memory_core.rombar = SValue & 4294966272UL;
#line 72
    if (TRACER_Info[TRACER_default___80].Enabled) {
      {
#line 72
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 72
      tracer_printf((char *)"Storing 0x%08lx in the ROMBAR\n", memory_core.rombar);
      }
    }
#line 73
    goto switch_break;
    case_3076: /* CIL Label */ 
#line 75
    memory_core.rambar = SValue & 4294966272UL;
#line 76
    if (TRACER_Info[TRACER_default___80].Enabled) {
      {
#line 76
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 76
      tracer_printf((char *)"Storing 0x%08lx in the RAMBAR\n", memory_core.rambar);
      }
    }
#line 77
    goto switch_break;
    case_3087: /* CIL Label */ 
#line 79
    memory_core.mbar = SValue & 4294966272UL;
#line 80
    if (TRACER_Info[TRACER_default___80].Enabled) {
      {
#line 80
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 80
      tracer_printf((char *)"Storing 0x%08lx in the MBAR\n", memory_core.mbar);
      }
    }
#line 81
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 83
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 83
    tracer_printf((char *)"Unimplemented Control register 0x%x\n", Instr.Bits.ControlRegister);
    }
#line 84
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 90
  if (TRACER_Info[TRACER_default___80].Enabled) {
    {
#line 90
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 90
    tracer_printf((char *)"Attempt to write to SR while in user state\n");
    }
  }
#line 94
  if (TRACER_Info[TRACER_default___80].Enabled) {
    {
#line 94
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___80].Name, "execute");
#line 94
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 96
  cycle((unsigned long )MOVECTime);
  }
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movec.c"
static long disassemble___82(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVEC_Instr Instr ;

  {
  {
#line 104
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 105
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 107
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVEC");
#line 109
  Addressing_Print((short)32, (char )Instr.Bits.AD, (char )Instr.Bits.Register, Arg1);
  }
  {
#line 111
  if (Instr.Bits.ControlRegister == 2U) {
#line 111
    goto case_2;
  }
#line 114
  if (Instr.Bits.ControlRegister == 4U) {
#line 114
    goto case_4;
  }
#line 117
  if (Instr.Bits.ControlRegister == 5U) {
#line 117
    goto case_5;
  }
#line 120
  if (Instr.Bits.ControlRegister == 2049U) {
#line 120
    goto case_2049;
  }
#line 123
  if (Instr.Bits.ControlRegister == 2063U) {
#line 123
    goto case_2063;
  }
#line 126
  if (Instr.Bits.ControlRegister == 3072U) {
#line 126
    goto case_3072;
  }
#line 129
  if (Instr.Bits.ControlRegister == 3076U) {
#line 129
    goto case_3076;
  }
#line 132
  if (Instr.Bits.ControlRegister == 3087U) {
#line 132
    goto case_3087;
  }
#line 135
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 112
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"CACR");
  }
#line 113
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 115
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"ACR0");
  }
#line 116
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 118
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"ACR1");
  }
#line 119
  goto switch_break;
  case_2049: /* CIL Label */ 
  {
#line 121
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"VBR");
  }
#line 122
  goto switch_break;
  case_2063: /* CIL Label */ 
  {
#line 124
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"PC");
  }
#line 125
  goto switch_break;
  case_3072: /* CIL Label */ 
  {
#line 127
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"ROMBAR");
  }
#line 128
  goto switch_break;
  case_3076: /* CIL Label */ 
  {
#line 130
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"RAMBAR");
  }
#line 131
  goto switch_break;
  case_3087: /* CIL Label */ 
  {
#line 133
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"MBAR");
  }
#line 134
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 136
  sprintf((char */* __restrict  */)Arg2, (char const   */* __restrict  */)"???");
  }
#line 137
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 140
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
static enum _TRACER_Channels  const  TRACER_default___81  =    (enum _TRACER_Channels  const  )27;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
static void execute___83(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long SValue ;
  LEA_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___81].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___81].Name, "execute");
#line 40
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 41
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 41
  if (! tmp) {
#line 41
    return;
  }
#line 42
  if (TRACER_Info[TRACER_default___81].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___81].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp___0) {
#line 43
    return;
  }
  {
#line 45
  EA_GetEA(& SValue, & Source);
  }
#line 47
  if (TRACER_Info[TRACER_default___81].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___81].Name, "execute");
#line 47
    tracer_printf((char *)"Loading 0x%08lx into A%d\n", SValue, Instr.Bits.Register);
    }
  }
#line 51
  if (TRACER_Info[TRACER_default___81].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___81].Name, "execute");
#line 51
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 52
  EA_PutValue(& Destination, SValue);
  }
#line 54
  if (TRACER_Info[TRACER_default___81].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___81].Name, "execute");
#line 54
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 56
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 56
  cycle((unsigned long )LEATime[tmp___1]);
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lea.c"
static long disassemble___83(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  LEA_Instr Instr ;

  {
  {
#line 64
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 65
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"LEA");
#line 66
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 67
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg2);
  }
#line 68
  return (0L);
}
}
#line 59 "../i_5206/i_5206.h"
long trapf_5206_register(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
int TRAPFTime  =    1;
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
static enum _TRACER_Channels  const  TRACER_default___82  =    (enum _TRACER_Channels  const  )56;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
static void execute___84(void) 
{ 
  TRAPF_Instr Instr ;
  unsigned long dummy ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___82].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___82].Name, "execute");
#line 41
    tracer_printf((char *)"OpMode=0x%02x\n", Instr.Bits.OpMode);
    }
  }
  {
#line 44
  if (Instr.Bits.OpMode == 2U) {
#line 44
    goto case_2;
  }
#line 47
  if (Instr.Bits.OpMode == 3U) {
#line 47
    goto case_3;
  }
#line 50
  if (Instr.Bits.OpMode == 4U) {
#line 50
    goto case_4;
  }
#line 52
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 45
  Memory_RetrFromPC(& dummy, (short)16);
  }
#line 46
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 48
  Memory_RetrFromPC(& dummy, (short)32);
  }
#line 49
  goto switch_break;
  case_4: /* CIL Label */ 
#line 51
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 53
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___82].Name, "execute");
#line 53
  tracer_printf((char *)"Invalid OpMode=%d\n", Instr.Bits.OpMode);
  }
#line 54
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 56
  if (TRACER_Info[TRACER_default___82].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___82].Name, "execute");
#line 56
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 58
  cycle((unsigned long )TRAPFTime);
  }
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
static long disassemble___84(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  TRAPF_Instr Instr ;

  {
  {
#line 66
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
  {
#line 68
  if (Instr.Bits.OpMode == 2U) {
#line 68
    goto case_2;
  }
#line 72
  if (Instr.Bits.OpMode == 3U) {
#line 72
    goto case_3;
  }
#line 76
  if (Instr.Bits.OpMode == 4U) {
#line 76
    goto case_4;
  }
#line 79
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 69
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TRAPF.W");
#line 70
  Addressing_Print((short)16, (char)7, (char)4, Arg1);
  }
#line 71
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 73
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TRAPF.L");
#line 74
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
  }
#line 75
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 77
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TRAPF");
  }
#line 78
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 80
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___82].Name, "disassemble");
#line 80
  tracer_printf((char *)"Invalid OpMode=%d\n", Instr.Bits.OpMode);
  }
#line 81
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 84
  *(Arg2 + 0) = (char)0;
#line 85
  return (0L);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
long trapf_5206_register(void) 
{ 


  {
  {
#line 90
  instruction_register((unsigned short)20984, (unsigned short)65528, & execute___84,
                       & disassemble___84);
  }
#line 91
  return (1L);
}
}
#line 41 "../i_5206/i_5206.h"
long neg_5206_register(void) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
int NEGTime  =    1;
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
static enum _TRACER_Channels  const  TRACER_default___83  =    (enum _TRACER_Channels  const  )37;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
static void execute___85(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long DValue ;
  NEG_Instr Instr ;
  char tmp ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 37
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 37
  if (! tmp) {
#line 37
    return;
  }
  {
#line 38
  EA_GetValue(& DValue, & Destination);
#line 40
  Result = 0UL - DValue;
  }
#line 42
  if (TRACER_Info[TRACER_default___83].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___83].Name, "execute");
#line 42
    tracer_printf((char *)"~0x%08lx = 0x%08lx\n", DValue, Result);
    }
  }
  {
#line 45
  SR_Set((short)41, 0L, (long )DValue, (long )Result);
  }
#line 47
  if (TRACER_Info[TRACER_default___83].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___83].Name, "execute");
#line 47
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 48
  EA_PutValue(& Destination, Result);
  }
#line 50
  if (TRACER_Info[TRACER_default___83].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___83].Name, "execute");
#line 50
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 52
  cycle((unsigned long )NEGTime);
  }
#line 54
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
static long disassemble___85(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  NEG_Instr Instr ;

  {
  {
#line 60
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 61
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"NEG.L");
#line 62
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 63
  *(Arg2 + 0) = (char)0;
  }
#line 64
  return (0L);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
long neg_5206_register(void) 
{ 


  {
  {
#line 69
  instruction_register((unsigned short)17536, (unsigned short)65528, & execute___85,
                       & disassemble___85);
  }
#line 70
  return (1L);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
static enum _TRACER_Channels  const  TRACER_default___84  =    (enum _TRACER_Channels  const  )20;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
static void execute___86(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  EOR_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (Instr.Bits.OPMode == 2U) {
#line 42
    if (TRACER_Info[TRACER_default___84].Enabled) {
      {
#line 42
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 42
      tracer_printf((char *)"<EA>y ^ Dx -> Dx\n");
      }
    }
#line 43
    if (Instr.Bits.EAMode == 1U) {
      {
#line 44
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 44
      tracer_printf((char *)"May not specify Ax for source");
      }
#line 45
      return;
    }
#line 47
    if (TRACER_Info[TRACER_default___84].Enabled) {
      {
#line 47
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 47
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 48
    tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 48
    if (! tmp) {
#line 48
      return;
    }
#line 49
    if (TRACER_Info[TRACER_default___84].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 49
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 50
    tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 50
    if (! tmp___0) {
#line 50
      return;
    }
  } else
#line 51
  if (Instr.Bits.OPMode == 6U) {
#line 59
    if (Instr.Bits.EAMode == 7U) {
#line 59
      if (Instr.Bits.EARegister == 4U) {
        {
#line 60
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name,
                      "execute");
#line 60
        tracer_printf((char *)"May not specify Immediate Addressing for destination");
        }
#line 61
        return;
      }
    }
#line 63
    if (TRACER_Info[TRACER_default___84].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 63
      tracer_printf((char *)"Source:\n");
      }
    }
    {
#line 64
    tmp___1 = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.Register);
    }
#line 64
    if (! tmp___1) {
#line 64
      return;
    }
#line 65
    if (TRACER_Info[TRACER_default___84].Enabled) {
      {
#line 65
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 65
      tracer_printf((char *)"Destination:\n");
      }
    }
    {
#line 66
    tmp___2 = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
    }
#line 66
    if (! tmp___2) {
#line 66
      return;
    }
  } else {
    {
#line 68
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 68
    tracer_printf((char *)"Unknown OPMode %d", Instr.Bits.OPMode);
    }
#line 69
    return;
  }
  {
#line 72
  EA_GetValue(& SValue, & Source);
#line 73
  EA_GetValue(& DValue, & Destination);
#line 75
  Result = SValue ^ DValue;
  }
#line 76
  if (TRACER_Info[TRACER_default___84].Enabled) {
    {
#line 76
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 76
    tracer_printf((char *)"0x%08lx ^ 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 78
  if (TRACER_Info[TRACER_default___84].Enabled) {
    {
#line 78
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 78
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 79
  EA_PutValue(& Destination, Result);
#line 87
  memory_core.sr &= 65520UL;
#line 88
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 89
  SRBits->Z = (unsigned int )(Result == 0UL);
#line 91
  tmp___3 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 91
  cycle((unsigned long )EORTime[tmp___3]);
  }
#line 93
  if (TRACER_Info[TRACER_default___84].Enabled) {
    {
#line 93
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___84].Name, "execute");
#line 93
    tracer_printf((char *)"Done\n");
    }
  }
#line 94
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eor.c"
static long disassemble___86(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  EOR_Instr Instr ;

  {
  {
#line 100
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 101
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EOR.L");
  }
#line 102
  if (Instr.Bits.OPMode == 2U) {
    {
#line 103
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg1);
#line 104
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
    }
  } else {
    {
#line 106
    Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 107
    Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                     Arg2);
    }
  }
#line 109
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
static enum _TRACER_Channels  const  TRACER_default___85  =    (enum _TRACER_Channels  const  )54;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
static void execute___87(void) 
{ 
  struct _Address Destination ;
  unsigned long DValue ;
  unsigned long Tmp ;
  SWAP_Instr Instr ;
  char tmp ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___85].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___85].Name, "execute");
#line 38
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 39
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
  {
#line 40
  EA_GetValue(& DValue, & Destination);
#line 41
  Tmp = (DValue << 16) & 4294901760UL;
#line 42
  Tmp += (DValue >> 16) & 65535UL;
  }
#line 44
  if (TRACER_Info[TRACER_default___85].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___85].Name, "execute");
#line 44
    tracer_printf((char *)"Storing result:\n");
    }
  }
  {
#line 45
  EA_PutValue(& Destination, Tmp);
  }
#line 53
  if ((long )Tmp < 0L) {
#line 53
    SRBits->N = 1U;
  } else {
#line 53
    SRBits->N = 0U;
  }
#line 54
  if (Tmp == 0UL) {
#line 54
    SRBits->Z = 1U;
  } else {
#line 54
    SRBits->Z = 0U;
  }
  {
#line 55
  SRBits->V = 0U;
#line 56
  SRBits->C = 0U;
#line 58
  cycle((unsigned long )SWAPTime);
  }
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_swap.c"
static long disassemble___87(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SWAP_Instr Instr ;

  {
  {
#line 66
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 68
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SWAP");
#line 70
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 71
  *(Arg2 + 0) = (char)0;
  }
#line 73
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
static enum _TRACER_Channels  const  TRACER_default___86  =    (enum _TRACER_Channels  const  )37;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
static void execute___88(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long DValue ;
  NEG_Instr Instr ;
  char tmp ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 37
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 37
  if (! tmp) {
#line 37
    return;
  }
  {
#line 38
  EA_GetValue(& DValue, & Destination);
#line 40
  Result = 0UL - DValue;
  }
#line 42
  if (TRACER_Info[TRACER_default___86].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___86].Name, "execute");
#line 42
    tracer_printf((char *)"~0x%08lx = 0x%08lx\n", DValue, Result);
    }
  }
  {
#line 45
  SR_Set((short)41, 0L, (long )DValue, (long )Result);
  }
#line 47
  if (TRACER_Info[TRACER_default___86].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___86].Name, "execute");
#line 47
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 48
  EA_PutValue(& Destination, Result);
  }
#line 50
  if (TRACER_Info[TRACER_default___86].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___86].Name, "execute");
#line 50
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 52
  cycle((unsigned long )NEGTime);
  }
#line 54
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_neg.c"
static long disassemble___88(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  NEG_Instr Instr ;

  {
  {
#line 60
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 61
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"NEG.L");
#line 62
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 63
  *(Arg2 + 0) = (char)0;
  }
#line 64
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
static enum _TRACER_Channels  const  TRACER_default___87  =    (enum _TRACER_Channels  const  )6;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
static void execute___89(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  ADDI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 37
  if (TRACER_Info[TRACER_default___87].Enabled) {
    {
#line 37
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___87].Name, "execute");
#line 37
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 38
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 38
  if (! tmp) {
#line 38
    return;
  }
#line 39
  if (TRACER_Info[TRACER_default___87].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___87].Name, "execute");
#line 39
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 40
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 40
  if (! tmp___0) {
#line 40
    return;
  }
  {
#line 42
  EA_GetValue(& SValue, & Source);
#line 43
  EA_GetValue(& DValue, & Destination);
#line 45
  Result = SValue + DValue;
  }
#line 47
  if (TRACER_Info[TRACER_default___87].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___87].Name, "execute");
#line 47
    tracer_printf((char *)"0x%08lx + 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
  {
#line 50
  SR_Set((short)2, (long )SValue, (long )DValue, (long )Result);
  }
#line 52
  if (TRACER_Info[TRACER_default___87].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___87].Name, "execute");
#line 52
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 53
  EA_PutValue(& Destination, Result);
  }
#line 55
  if (TRACER_Info[TRACER_default___87].Enabled) {
    {
#line 55
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___87].Name, "execute");
#line 55
    tracer_printf((char *)"Done");
    }
  }
  {
#line 57
  cycle((unsigned long )ADDITime);
  }
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_addi.c"
static long disassemble___89(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  ADDI_Instr Instr ;

  {
  {
#line 65
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 66
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ADDI.L");
#line 67
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 68
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 69
  return (0L);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
static enum _TRACER_Channels  const  TRACER_default___88  =    (enum _TRACER_Channels  const  )56;
#line 34 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
static void execute___90(void) 
{ 
  TRAPF_Instr Instr ;
  unsigned long dummy ;

  {
  {
#line 39
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 41
  if (TRACER_Info[TRACER_default___88].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___88].Name, "execute");
#line 41
    tracer_printf((char *)"OpMode=0x%02x\n", Instr.Bits.OpMode);
    }
  }
  {
#line 44
  if (Instr.Bits.OpMode == 2U) {
#line 44
    goto case_2;
  }
#line 47
  if (Instr.Bits.OpMode == 3U) {
#line 47
    goto case_3;
  }
#line 50
  if (Instr.Bits.OpMode == 4U) {
#line 50
    goto case_4;
  }
#line 52
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 45
  Memory_RetrFromPC(& dummy, (short)16);
  }
#line 46
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 48
  Memory_RetrFromPC(& dummy, (short)32);
  }
#line 49
  goto switch_break;
  case_4: /* CIL Label */ 
#line 51
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 53
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___88].Name, "execute");
#line 53
  tracer_printf((char *)"Invalid OpMode=%d\n", Instr.Bits.OpMode);
  }
#line 54
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 56
  if (TRACER_Info[TRACER_default___88].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___88].Name, "execute");
#line 56
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 58
  cycle((unsigned long )TRAPFTime);
  }
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_trapf.c"
static long disassemble___90(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  TRAPF_Instr Instr ;

  {
  {
#line 66
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
  {
#line 68
  if (Instr.Bits.OpMode == 2U) {
#line 68
    goto case_2;
  }
#line 72
  if (Instr.Bits.OpMode == 3U) {
#line 72
    goto case_3;
  }
#line 76
  if (Instr.Bits.OpMode == 4U) {
#line 76
    goto case_4;
  }
#line 79
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 69
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TRAPF.W");
#line 70
  Addressing_Print((short)16, (char)7, (char)4, Arg1);
  }
#line 71
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 73
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TRAPF.L");
#line 74
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
  }
#line 75
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 77
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"TRAPF");
  }
#line 78
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 80
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___88].Name, "disassemble");
#line 80
  tracer_printf((char *)"Invalid OpMode=%d\n", Instr.Bits.OpMode);
  }
#line 81
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 84
  *(Arg2 + 0) = (char)0;
#line 85
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rts.c"
static enum _TRACER_Channels  const  TRACER_default___89  =    (enum _TRACER_Channels  const  )45;
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rts.c"
static void execute___91(void) 
{ 
  unsigned long dummy ;

  {
  {
#line 33
  Memory_RetrFromPC(& dummy, (short)16);
#line 36
  memory_core.pc = Stack_Pop((short)32);
  }
#line 38
  if (TRACER_Info[TRACER_default___89].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___89].Name, "execute");
#line 38
    tracer_printf((char *)"Set PC=0x%08lx\n", memory_core.pc);
    }
  }
#line 39
  if (TRACER_Info[TRACER_default___89].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___89].Name, "execute");
#line 39
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 41
  cycle((unsigned long )RTSTime);
  }
#line 43
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_rts.c"
static long disassemble___91(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 49
  Memory_RetrFromPC(& dummy, (short)16);
#line 50
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"RTS");
#line 51
  *(Arg1 + 0) = (char)0;
#line 52
  *(Arg2 + 0) = (char)0;
  }
#line 53
  return (0L);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
static enum _TRACER_Channels  const  TRACER_default___90  =    (enum _TRACER_Channels  const  )15;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
static void execute___92(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  CMP_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 40
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 42
  if (TRACER_Info[TRACER_default___90].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___90].Name, "execute");
#line 42
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 43
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 43
  if (! tmp) {
#line 43
    return;
  }
#line 44
  if (TRACER_Info[TRACER_default___90].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___90].Name, "execute");
#line 44
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 45
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 45
  if (! tmp___0) {
#line 45
    return;
  }
  {
#line 47
  EA_GetValue(& SValue, & Source);
#line 48
  EA_GetValue(& DValue, & Destination);
  }
#line 50
  if (TRACER_Info[TRACER_default___90].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___90].Name, "execute");
#line 50
    tracer_printf((char *)"Comparing 0x%08lx and 0x%08lx\n", SValue, DValue);
    }
  }
  {
#line 52
  Result = DValue - SValue;
#line 54
  SR_Set((short)17, (long )SValue, (long )DValue, (long )Result);
  }
#line 56
  if (TRACER_Info[TRACER_default___90].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___90].Name, "execute");
#line 56
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 57
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 57
  cycle((unsigned long )CMPTime[tmp___1]);
  }
#line 58
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_cmp.c"
static long disassemble___92(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  CMP_Instr Instr ;

  {
  {
#line 64
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 65
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"CMP.L");
#line 66
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 67
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 68
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
static enum _TRACER_Channels  const  TRACER_default___91  =    (enum _TRACER_Channels  const  )52;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
static void execute___93(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUBQ_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 43
  if (TRACER_Info[TRACER_default___91].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___91].Name, "execute");
#line 43
    tracer_printf((char *)"Source: (Retrieving from instruction word) = 0x%02x where (0=8)\n",
                  Instr.Bits.Data);
    }
  }
#line 44
  SValue = (unsigned long )Instr.Bits.Data;
#line 45
  if (SValue == 0UL) {
#line 45
    SValue = 8UL;
  }
#line 47
  if (TRACER_Info[TRACER_default___91].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___91].Name, "execute");
#line 47
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 48
  tmp = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 48
  if (! tmp) {
#line 48
    return;
  }
#line 50
  if (Instr.Bits.EAMode == 7U) {
    {
#line 52
    if (Instr.Bits.EARegister == 2U) {
#line 52
      goto case_2;
    }
#line 55
    if (Instr.Bits.EARegister == 3U) {
#line 55
      goto case_3;
    }
#line 58
    if (Instr.Bits.EARegister == 4U) {
#line 58
      goto case_4;
    }
#line 51
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 53
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___91].Name, "execute");
#line 53
    tracer_printf((char *)"(d_16,PC) addressing mode invalid.");
    }
#line 54
    return;
    case_3: /* CIL Label */ 
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___91].Name, "execute");
#line 56
    tracer_printf((char *)"(d_8,PC,Xn) addressing mode invalid.");
    }
#line 57
    return;
    case_4: /* CIL Label */ 
    {
#line 59
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___91].Name, "execute");
#line 59
    tracer_printf((char *)"#<data> addressing mode invalid.");
    }
#line 60
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 64
  EA_GetValue(& DValue, & Destination);
#line 66
  Result = DValue - SValue;
  }
#line 68
  if (TRACER_Info[TRACER_default___91].Enabled) {
    {
#line 68
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___91].Name, "execute");
#line 68
    tracer_printf((char *)"0x%08lx - 0x%08lx = 0x%08lx\n", DValue, SValue, Result);
    }
  }
#line 72
  if (Instr.Bits.EAMode != 1U) {
    {
#line 73
    SR_Set((short)53, (long )SValue, (long )DValue, (long )Result);
    }
  }
#line 77
  if (TRACER_Info[TRACER_default___91].Enabled) {
    {
#line 77
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___91].Name, "execute");
#line 77
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 78
  EA_PutValue(& Destination, Result);
  }
#line 80
  if (TRACER_Info[TRACER_default___91].Enabled) {
    {
#line 80
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___91].Name, "execute");
#line 80
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 82
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 82
  cycle((unsigned long )SUBQTime[tmp___0]);
  }
#line 84
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_subq.c"
static long disassemble___93(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUBQ_Instr Instr ;
  unsigned int tmp ;

  {
  {
#line 90
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 91
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUBQ.L");
  }
#line 92
  if ((char )(Instr.Bits.Data == 0U)) {
#line 92
    tmp = 8U;
  } else {
#line 92
    tmp = Instr.Bits.Data;
  }
  {
#line 92
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02X",
          tmp);
#line 93
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg2);
  }
#line 94
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
static enum _TRACER_Channels  const  TRACER_default___92  =    (enum _TRACER_Channels  const  )58;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
static void execute___94(void) 
{ 
  struct _Address ARegister ;
  struct _Address Stack ;
  unsigned long Result ;
  UNLK_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 37
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 39
  tmp = EA_GetFromPC(& ARegister, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 39
  if (! tmp) {
#line 39
    return;
  }
  {
#line 40
  tmp___0 = EA_GetFromPC(& Stack, (short)32, (char)1, (char)7);
  }
#line 40
  if (! tmp___0) {
#line 40
    return;
  }
#line 43
  if (TRACER_Info[TRACER_default___92].Enabled) {
    {
#line 43
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___92].Name, "execute");
#line 43
    tracer_printf((char *)"Loading Stack Pointer from A%d:\n", Instr.Bits.Register);
    }
  }
  {
#line 44
  EA_GetValue(& Result, & ARegister);
#line 45
  EA_PutValue(& Stack, Result);
  }
#line 46
  if (TRACER_Info[TRACER_default___92].Enabled) {
    {
#line 46
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___92].Name, "execute");
#line 46
    tracer_printf((char *)"New Stack Pointer is 0x%08lx\n", Result);
    }
  }
#line 50
  if (TRACER_Info[TRACER_default___92].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___92].Name, "execute");
#line 50
    tracer_printf((char *)"Popping old Aregister value from the stack\n");
    }
  }
  {
#line 51
  Result = Stack_Pop((short)32);
  }
#line 52
  if (TRACER_Info[TRACER_default___92].Enabled) {
    {
#line 52
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___92].Name, "execute");
#line 52
    tracer_printf((char *)"   Value=0x%08lx, storing it...\n", Result);
    }
  }
  {
#line 53
  EA_PutValue(& ARegister, Result);
  }
#line 55
  if (TRACER_Info[TRACER_default___92].Enabled) {
    {
#line 55
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___92].Name, "execute");
#line 55
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 57
  cycle((unsigned long )UNLKTime);
  }
#line 59
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_unlk.c"
static long disassemble___94(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  UNLK_Instr Instr ;

  {
  {
#line 65
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 67
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"UNLK");
#line 68
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg1);
#line 69
  *(Arg2 + 0) = (char)0;
  }
#line 71
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
static enum _TRACER_Channels  const  TRACER_default___93  =    (enum _TRACER_Channels  const  )50;
#line 33 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
static void execute___95(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  SUBA_Instr Instr ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 38
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 40
  if (TRACER_Info[TRACER_default___93].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___93].Name, "execute");
#line 40
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 41
  tmp = EA_GetFromPC(& Source, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 41
  if (! tmp) {
#line 41
    return;
  }
#line 42
  if (TRACER_Info[TRACER_default___93].Enabled) {
    {
#line 42
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___93].Name, "execute");
#line 42
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 43
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)1, (char )Instr.Bits.Register);
  }
#line 43
  if (! tmp___0) {
#line 43
    return;
  }
  {
#line 45
  EA_GetValue(& SValue, & Source);
#line 46
  EA_GetValue(& DValue, & Destination);
#line 48
  Result = DValue - SValue;
  }
#line 50
  if (TRACER_Info[TRACER_default___93].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___93].Name, "execute");
#line 50
    tracer_printf((char *)"0x%08lx - 0x%08lx = 0x%08lx\n", DValue, SValue, Result);
    }
  }
#line 54
  if (TRACER_Info[TRACER_default___93].Enabled) {
    {
#line 54
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___93].Name, "execute");
#line 54
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 55
  EA_PutValue(& Destination, Result);
  }
#line 57
  if (TRACER_Info[TRACER_default___93].Enabled) {
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___93].Name, "execute");
#line 57
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 59
  tmp___1 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 59
  cycle((unsigned long )SUBATime[tmp___1]);
  }
#line 61
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_suba.c"
static long disassemble___95(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  SUBA_Instr Instr ;

  {
  {
#line 67
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 68
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"SUBA.L");
#line 69
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 70
  Addressing_Print((short)32, (char)1, (char )Instr.Bits.Register, Arg2);
  }
#line 71
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
static enum _TRACER_Channels  const  TRACER_default___94  =    (enum _TRACER_Channels  const  )25;
#line 31 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
static void execute___96(void) 
{ 
  struct _Address Destination ;
  unsigned long DValue ;
  JMP_Instr Instr ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___94].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___94].Name, "execute");
#line 38
    tracer_printf((char *)"Called...\n");
    }
  }
#line 40
  if (TRACER_Info[TRACER_default___94].Enabled) {
    {
#line 40
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___94].Name, "execute");
#line 40
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 42
  tmp = EA_GetFromPC(& Destination, (short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister);
  }
#line 42
  if (! tmp) {
#line 42
    return;
  }
  {
#line 43
  EA_GetEA(& DValue, & Destination);
  }
#line 45
  if (TRACER_Info[TRACER_default___94].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___94].Name, "execute");
#line 45
    tracer_printf((char *)"New PC=0x%08lx\n", DValue);
    }
  }
#line 49
  memory_core.pc = DValue;
#line 50
  if (TRACER_Info[TRACER_default___94].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___94].Name, "execute");
#line 50
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 52
  tmp___0 = cycle_EA((short )Instr.Bits.EARegister, (short )Instr.Bits.EAMode);
#line 52
  cycle((unsigned long )JMPTime[tmp___0]);
  }
#line 54
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_jmp.c"
static long disassemble___96(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  JMP_Instr Instr ;

  {
  {
#line 60
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 61
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"JMP");
#line 62
  Addressing_Print((short)32, (char )Instr.Bits.EAMode, (char )Instr.Bits.EARegister,
                   Arg1);
#line 63
  *(Arg2 + 0) = (char)0;
  }
#line 64
  return (0L);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
static enum _TRACER_Channels  const  TRACER_default___95  =    (enum _TRACER_Channels  const  )34;
#line 52 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
static void execute___97(void) 
{ 
  struct _Address Source ;
  unsigned long SValue ;
  char CCR ;
  MOVEXR_Instr Instr ;
  char tmp ;
  char const   *tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 58
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 60
  CCR = (char )(Instr.Bits.To ^ Instr.Bits.Reg);
  }
#line 62
  if (TRACER_Info[TRACER_default___95].Enabled) {
    {
#line 62
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___95].Name, "execute");
#line 62
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 63
  tmp = EA_GetFromPC(& Source, (short)16, (char )Instr.Bits.Mode, (char )Instr.Bits.Register);
  }
#line 63
  if (! tmp) {
#line 63
    return;
  }
#line 65
  if (TRACER_Info[TRACER_default___95].Enabled) {
    {
#line 65
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___95].Name, "execute");
#line 65
    tracer_printf((char *)"CCR=%d, Supervisor State=%d\n", (int )CCR, SRBits->S);
    }
  }
#line 67
  if ((int )CCR == 0) {
#line 67
    if (! SRBits->S) {
#line 69
      if (TRACER_Info[TRACER_default___95].Enabled) {
        {
#line 69
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___95].Name,
                      "execute");
        }
#line 69
        if (Instr.Bits.To) {
#line 69
          tmp___0 = "write";
        } else {
#line 69
          tmp___0 = "read";
        }
        {
#line 69
        tracer_printf((char *)"Attempt to %s SR while in user state.\n", tmp___0);
        }
      }
      {
#line 70
      exception_do_exception((short)8);
      }
#line 71
      return;
    }
  }
#line 74
  if (Instr.Bits.To) {
    {
#line 75
    EA_GetValue(& SValue, & Source);
    }
#line 76
    if ((int )CCR == 0) {
#line 77
      memory_core.sr = SValue;
#line 78
      if (Instr.Bits.Mode == 7U) {
#line 78
        if (Instr.Bits.Register == 4U) {
          {
#line 79
          cycle((unsigned long )(MOVE2SRTime + 6));
          }
        } else {
          {
#line 81
          cycle((unsigned long )MOVE2SRTime);
          }
        }
      } else {
        {
#line 81
        cycle((unsigned long )MOVE2SRTime);
        }
      }
    } else {
      {
#line 83
      memory_core.sr = (memory_core.sr & 4294967040UL) | (SValue & 255UL);
#line 85
      cycle((unsigned long )MOVEXRTime);
      }
    }
  } else {
#line 88
    if ((int )CCR == 0) {
#line 88
      tmp___1 = memory_core.sr;
    } else {
#line 88
      tmp___1 = memory_core.sr & 255UL;
    }
    {
#line 88
    SValue = tmp___1;
#line 91
    EA_PutValue(& Source, SValue);
#line 92
    cycle((unsigned long )MOVEXRTime);
    }
  }
#line 96
  if (TRACER_Info[TRACER_default___95].Enabled) {
    {
#line 96
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___95].Name, "execute");
#line 96
    tracer_printf((char *)"Done\n");
    }
  }
#line 97
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_movexr.c"
static long disassemble___97(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  MOVEXR_Instr Instr ;
  char CCR ;
  char *ptr ;

  {
  {
#line 105
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 107
  CCR = (char )(Instr.Bits.To ^ Instr.Bits.Reg);
#line 109
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"MOVE");
  }
#line 111
  if (Instr.Bits.To) {
#line 113
    ptr = Arg1;
#line 114
    Arg1 = Arg2;
#line 115
    Arg2 = ptr;
  }
#line 118
  if (CCR) {
    {
#line 119
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"CCR");
    }
  } else {
    {
#line 121
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"SR");
    }
  }
  {
#line 122
  Addressing_Print((short)16, (char )Instr.Bits.Mode, (char )Instr.Bits.Register,
                   Arg2);
  }
#line 124
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_nop.c"
static enum _TRACER_Channels  const  TRACER_default___96  =    (enum _TRACER_Channels  const  )39;
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_nop.c"
static void execute___98(void) 
{ 
  unsigned long dummy ;

  {
  {
#line 33
  Memory_RetrFromPC(& dummy, (short)16);
  }
#line 35
  if (TRACER_Info[TRACER_default___96].Enabled) {
    {
#line 35
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___96].Name, "execute");
#line 35
    tracer_printf((char *)"Doing nothing :) ...\n");
    }
  }
#line 36
  if (TRACER_Info[TRACER_default___96].Enabled) {
    {
#line 36
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___96].Name, "execute");
#line 36
    tracer_printf((char *)"Done.\n");
    }
  }
  {
#line 38
  cycle((unsigned long )NOPTime);
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_nop.c"
static long disassemble___98(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 46
  Memory_RetrFromPC(& dummy, (short)16);
#line 47
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"NOP");
#line 48
  *(Arg1 + 0) = (char)0;
#line 49
  *(Arg2 + 0) = (char)0;
  }
#line 50
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
static enum _TRACER_Channels  const  TRACER_default___97  =    (enum _TRACER_Channels  const  )38;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
static void execute___99(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long DValue ;
  NEGX_Instr Instr ;
  char tmp ;

  {
  {
#line 36
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 38
  if (TRACER_Info[TRACER_default___97].Enabled) {
    {
#line 38
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___97].Name, "execute");
#line 38
    tracer_printf((char *)"Source: is 0\n");
    }
  }
#line 39
  if (TRACER_Info[TRACER_default___97].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___97].Name, "execute");
#line 39
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 40
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 40
  if (! tmp) {
#line 40
    return;
  }
  {
#line 41
  EA_GetValue(& DValue, & Destination);
#line 43
  Result = (0UL - DValue) - (unsigned long )SRBits->X;
  }
#line 45
  if (TRACER_Info[TRACER_default___97].Enabled) {
    {
#line 45
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___97].Name, "execute");
#line 45
    tracer_printf((char *)"-0x%08lx - %d = 0x%08lx\n", DValue, (unsigned long )SRBits->X,
                  Result);
    }
  }
  {
#line 48
  SR_Set((short)42, 0L, (long )DValue, (long )Result);
  }
#line 50
  if (TRACER_Info[TRACER_default___97].Enabled) {
    {
#line 50
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___97].Name, "execute");
#line 50
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 51
  EA_PutValue(& Destination, Result);
#line 53
  cycle((unsigned long )NEGXTime);
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_negx.c"
static long disassemble___99(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  NEGX_Instr Instr ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 63
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"NEGX.L");
#line 64
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 65
  *(Arg2 + 0) = (char)0;
  }
#line 66
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
static enum _TRACER_Channels  const  TRACER_default___98  =    (enum _TRACER_Channels  const  )29;
#line 35 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
static void execute___100(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  LSX_Instr Instr ;
  long last_bit ;
  char tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 42
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 44
  if (TRACER_Info[TRACER_default___98].Enabled) {
    {
#line 44
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___98].Name, "execute");
#line 44
    tracer_printf((char *)"Source:\n");
    }
  }
#line 45
  if (Instr.Bits.IR == 0U) {
#line 47
    SValue = (unsigned long )Instr.Bits.CountReg;
#line 48
    if (SValue == 0UL) {
#line 48
      SValue = 8UL;
    }
#line 49
    if (TRACER_Info[TRACER_default___98].Enabled) {
      {
#line 49
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___98].Name, "execute");
#line 49
      tracer_printf((char *)"Shift by count in instruction word = %d\n", SValue);
      }
    }
  } else {
    {
#line 51
    tmp = EA_GetFromPC(& Source, (short)32, (char)0, (char )Instr.Bits.CountReg);
    }
#line 51
    if (! tmp) {
#line 51
      return;
    }
    {
#line 53
    EA_GetValue(& SValue, & Source);
#line 54
    SValue &= 63UL;
    }
#line 55
    if (TRACER_Info[TRACER_default___98].Enabled) {
      {
#line 55
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___98].Name, "execute");
#line 55
      tracer_printf((char *)"Shift by count in D%d = \n", Instr.Bits.CountReg, SValue);
      }
    }
  }
#line 57
  if (TRACER_Info[TRACER_default___98].Enabled) {
    {
#line 57
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___98].Name, "execute");
#line 57
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 58
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 58
  if (! tmp___0) {
#line 58
    return;
  }
  {
#line 59
  EA_GetValue(& DValue, & Destination);
  }
#line 62
  if (SValue == 0UL) {
#line 63
    if (TRACER_Info[TRACER_default___98].Enabled) {
      {
#line 63
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___98].Name, "execute");
#line 63
      tracer_printf((char *)"No Shift");
      }
    }
#line 64
    SRBits->C = 0U;
#line 65
    Result = DValue;
  } else {
#line 67
    last_bit = 0L;
#line 68
    if (Instr.Bits.DR == 0U) {
#line 70
      if (TRACER_Info[TRACER_default___98].Enabled) {
        {
#line 70
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___98].Name,
                      "execute");
#line 70
        tracer_printf((char *)"Shift Right\n");
        }
      }
#line 74
      if (SValue <= 32UL) {
#line 75
        last_bit = (long )(DValue & (unsigned long )(1 << (SValue - 1UL)));
      }
#line 81
      if (SValue >= 32UL) {
#line 81
        Result = 0UL;
      } else {
#line 81
        Result = DValue >> SValue;
      }
    } else {
#line 85
      if (TRACER_Info[TRACER_default___98].Enabled) {
        {
#line 85
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___98].Name,
                      "execute");
#line 85
        tracer_printf((char *)"Shift Left\n");
        }
      }
#line 86
      if (SValue <= 32UL) {
#line 87
        last_bit = (long )(DValue & (unsigned long )(2147483648U >> (SValue - 1UL)));
      }
#line 89
      if (SValue >= 32UL) {
#line 89
        Result = 0UL;
      } else {
#line 89
        Result = DValue << SValue;
      }
    }
#line 91
    if (last_bit) {
#line 91
      SRBits->C = 1U;
    } else {
#line 91
      SRBits->C = 0U;
    }
#line 92
    if (last_bit) {
#line 92
      SRBits->X = 1U;
    } else {
#line 92
      SRBits->X = 0U;
    }
  }
#line 94
  if (TRACER_Info[TRACER_default___98].Enabled) {
    {
#line 94
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___98].Name, "execute");
    }
#line 94
    if (Instr.Bits.DR == 0U) {
#line 94
      tmp___1 = ">>";
    } else {
#line 94
      tmp___1 = "<<";
    }
    {
#line 94
    tracer_printf((char *)"0x%08lx %s 0x%02lx = 0x%08lx\n", DValue, tmp___1, SValue,
                  Result);
    }
  }
#line 104
  if ((long )Result < 0L) {
#line 104
    SRBits->N = 1U;
  } else {
#line 104
    SRBits->N = 0U;
  }
#line 105
  if (Result == 0UL) {
#line 105
    SRBits->Z = 1U;
  } else {
#line 105
    SRBits->Z = 0U;
  }
#line 107
  if (TRACER_Info[TRACER_default___98].Enabled) {
    {
#line 107
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___98].Name, "execute");
#line 107
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 108
  EA_PutValue(& Destination, Result);
#line 110
  cycle((unsigned long )LSXTime);
  }
#line 112
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_lsx.c"
static long disassemble___100(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  LSX_Instr Instr ;
  long SValue ;

  {
  {
#line 118
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 120
  if (Instr.Bits.DR == 0U) {
    {
#line 122
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"LSR.L");
    }
  } else {
    {
#line 125
    sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"LSL.L");
    }
  }
#line 127
  if (Instr.Bits.IR == 0U) {
#line 129
    SValue = (long )Instr.Bits.CountReg;
#line 130
    if (SValue == 0L) {
#line 130
      SValue = 8L;
    }
    {
#line 131
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"#0x%02lX",
            SValue);
    }
  } else {
    {
#line 133
    sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"D%d",
            Instr.Bits.CountReg);
    }
  }
  {
#line 135
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 136
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
static enum _TRACER_Channels  const  TRACER_default___99  =    (enum _TRACER_Channels  const  )21;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
static void execute___101(void) 
{ 
  struct _Address Source ;
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long SValue ;
  unsigned long DValue ;
  EORI_Instr Instr ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
  }
#line 37
  if (TRACER_Info[TRACER_default___99].Enabled) {
    {
#line 37
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___99].Name, "execute");
#line 37
    tracer_printf((char *)"Source:\n");
    }
  }
  {
#line 38
  tmp = EA_GetFromPC(& Source, (short)32, (char)7, (char)4);
  }
#line 38
  if (! tmp) {
#line 38
    return;
  }
#line 39
  if (TRACER_Info[TRACER_default___99].Enabled) {
    {
#line 39
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___99].Name, "execute");
#line 39
    tracer_printf((char *)"Destination:\n");
    }
  }
  {
#line 40
  tmp___0 = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 40
  if (! tmp___0) {
#line 40
    return;
  }
  {
#line 42
  EA_GetValue(& SValue, & Source);
#line 43
  EA_GetValue(& DValue, & Destination);
#line 45
  Result = SValue ^ DValue;
  }
#line 47
  if (TRACER_Info[TRACER_default___99].Enabled) {
    {
#line 47
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___99].Name, "execute");
#line 47
    tracer_printf((char *)"0x%08lx ^ 0x%08lx = 0x%08lx\n", SValue, DValue, Result);
    }
  }
#line 49
  if (TRACER_Info[TRACER_default___99].Enabled) {
    {
#line 49
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___99].Name, "execute");
#line 49
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 50
  EA_PutValue(& Destination, Result);
#line 58
  memory_core.sr &= 65520UL;
#line 59
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 60
  SRBits->Z = (unsigned int )(Result == 0UL);
  }
#line 61
  if (TRACER_Info[TRACER_default___99].Enabled) {
    {
#line 61
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___99].Name, "execute");
#line 61
    tracer_printf((char *)"Done");
    }
  }
  {
#line 63
  cycle((unsigned long )EORITime);
  }
#line 65
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_eori.c"
static long disassemble___101(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  EORI_Instr Instr ;

  {
  {
#line 71
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 72
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"EORI.L");
#line 73
  Addressing_Print((short)32, (char)7, (char)4, Arg1);
#line 74
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg2);
  }
#line 75
  return (0L);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_illegal.c"
static enum _TRACER_Channels  const  TRACER_default___100  =    (enum _TRACER_Channels  const  )24;
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_illegal.c"
static void execute___102(void) 
{ 
  unsigned long dummy ;

  {
  {
#line 31
  Memory_RetrFromPC(& dummy, (short)16);
  }
#line 32
  if (TRACER_Info[TRACER_default___100].Enabled) {
    {
#line 32
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___100].Name, "execute");
#line 32
    tracer_printf((char *)"Generaing illegal instruction exception...\n");
    }
  }
  {
#line 33
  exception_do_exception((short)4);
  }
#line 34
  if (TRACER_Info[TRACER_default___100].Enabled) {
    {
#line 34
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___100].Name, "execute");
#line 34
    tracer_printf((char *)"Done.\n");
    }
  }
#line 36
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_illegal.c"
static long disassemble___102(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long dummy ;

  {
  {
#line 42
  Memory_RetrFromPC(& dummy, (short)16);
#line 43
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"ILLEGAL");
#line 44
  *(Arg1 + 0) = (char)0;
#line 45
  *(Arg2 + 0) = (char)0;
  }
#line 46
  return (0L);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
static enum _TRACER_Channels  const  TRACER_default___101  =    (enum _TRACER_Channels  const  )12;
#line 36 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
static void execute___103(void) 
{ 
  unsigned long Displacement ;
  unsigned long ReferencePC ;
  BCC_Instr Instr ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 42
  ReferencePC = memory_core.pc + 2UL;
#line 45
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 46
  Displacement = (unsigned long )Instr.Bits.Displacement;
  }
#line 47
  if (Displacement == 0UL) {
    {
#line 48
    Memory_RetrFromPC(& Displacement, (short)16);
#line 49
    Displacement = (unsigned long )((short )Displacement);
    }
  }
#line 51
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 51
    tracer_printf((char *)"BCC: called, Displacement=%ld\n", Displacement);
    }
  }
  {
#line 54
  if (Instr.Bits.Condition == 0U) {
#line 54
    goto case_0;
  }
#line 59
  if (Instr.Bits.Condition == 1U) {
#line 59
    goto case_1;
  }
#line 65
  if (Instr.Bits.Condition == 2U) {
#line 65
    goto case_2;
  }
#line 73
  if (Instr.Bits.Condition == 3U) {
#line 73
    goto case_3;
  }
#line 81
  if (Instr.Bits.Condition == 4U) {
#line 81
    goto case_4;
  }
#line 89
  if (Instr.Bits.Condition == 5U) {
#line 89
    goto case_5;
  }
#line 97
  if (Instr.Bits.Condition == 6U) {
#line 97
    goto case_6;
  }
#line 105
  if (Instr.Bits.Condition == 7U) {
#line 105
    goto case_7;
  }
#line 113
  if (Instr.Bits.Condition == 8U) {
#line 113
    goto case_8;
  }
#line 120
  if (Instr.Bits.Condition == 9U) {
#line 120
    goto case_9;
  }
#line 128
  if (Instr.Bits.Condition == 10U) {
#line 128
    goto case_10;
  }
#line 134
  if (Instr.Bits.Condition == 11U) {
#line 134
    goto case_11;
  }
#line 140
  if (Instr.Bits.Condition == 12U) {
#line 140
    goto case_12;
  }
#line 146
  if (Instr.Bits.Condition == 13U) {
#line 146
    goto case_13;
  }
#line 153
  if (Instr.Bits.Condition == 14U) {
#line 153
    goto case_14;
  }
#line 160
  if (Instr.Bits.Condition == 15U) {
#line 160
    goto case_15;
  }
#line 168
  goto switch_default;
  case_0: /* CIL Label */ 
#line 56
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 56
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 56
    tracer_printf((char *)"BCC: BRA %hx\n", Displacement);
    }
  }
  {
#line 57
  cycle((unsigned long )BRATime);
  }
#line 58
  goto i_bcc_do_branch;
  case_1: /* CIL Label */ 
#line 61
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 61
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 61
    tracer_printf((char *)"BCC: BSR %hx\n", Displacement);
    }
  }
  {
#line 62
  Stack_Push((short)32, memory_core.pc);
#line 63
  cycle((unsigned long )BSRTime);
  }
#line 64
  goto i_bcc_do_branch;
  case_2: /* CIL Label */ 
#line 67
  if (! SRBits->C) {
#line 67
    if (! SRBits->Z) {
#line 68
      if (TRACER_Info[TRACER_default___101].Enabled) {
        {
#line 68
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name,
                      "execute");
#line 68
        tracer_printf((char *)"BHI: Branching %hx\n", Displacement);
        }
      }
#line 69
      goto i_bcc_branch_taken;
    }
  }
#line 71
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 71
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 71
    tracer_printf((char *)"BHI: NOT Branching\n");
    }
  }
#line 72
  goto i_bcc_branch_not_taken;
  case_3: /* CIL Label */ 
#line 75
  if (SRBits->C) {
#line 75
    goto _L;
  } else
#line 75
  if (SRBits->Z) {
    _L: /* CIL Label */ 
#line 76
    if (TRACER_Info[TRACER_default___101].Enabled) {
      {
#line 76
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 76
      tracer_printf((char *)"BLS: Branching %hx\n", Displacement);
      }
    }
#line 77
    goto i_bcc_branch_taken;
  }
#line 79
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 79
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 79
    tracer_printf((char *)"BLS: NOT Branching\n");
    }
  }
#line 80
  goto i_bcc_branch_not_taken;
  case_4: /* CIL Label */ 
#line 83
  if (! SRBits->C) {
#line 84
    if (TRACER_Info[TRACER_default___101].Enabled) {
      {
#line 84
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 84
      tracer_printf((char *)"BCC: Branching %hx\n", Displacement);
      }
    }
#line 85
    goto i_bcc_branch_taken;
  }
#line 87
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 87
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 87
    tracer_printf((char *)"BCC: NOT Branching\n");
    }
  }
#line 88
  goto i_bcc_branch_not_taken;
  case_5: /* CIL Label */ 
#line 91
  if (SRBits->C) {
#line 92
    if (TRACER_Info[TRACER_default___101].Enabled) {
      {
#line 92
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 92
      tracer_printf((char *)"BCS: Branching %hx\n", Displacement);
      }
    }
#line 93
    goto i_bcc_branch_taken;
  }
#line 95
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 95
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 95
    tracer_printf((char *)"BCS: NOT Branching\n");
    }
  }
#line 96
  goto i_bcc_branch_not_taken;
  case_6: /* CIL Label */ 
#line 99
  if (! SRBits->Z) {
#line 100
    if (TRACER_Info[TRACER_default___101].Enabled) {
      {
#line 100
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 100
      tracer_printf((char *)"BNE: Branching %hx\n", Displacement);
      }
    }
#line 101
    goto i_bcc_branch_taken;
  }
#line 103
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 103
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 103
    tracer_printf((char *)"BNE: NOT Branching\n");
    }
  }
#line 104
  goto i_bcc_branch_not_taken;
  case_7: /* CIL Label */ 
#line 107
  if (SRBits->Z) {
#line 108
    if (TRACER_Info[TRACER_default___101].Enabled) {
      {
#line 108
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 108
      tracer_printf((char *)"BEQ: Branching %hx\n", Displacement);
      }
    }
#line 109
    goto i_bcc_branch_taken;
  }
#line 111
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 111
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 111
    tracer_printf((char *)"BEQ: NOT branching\n");
    }
  }
#line 112
  goto i_bcc_branch_not_taken;
  case_8: /* CIL Label */ 
#line 114
  if (! SRBits->V) {
#line 115
    if (TRACER_Info[TRACER_default___101].Enabled) {
      {
#line 115
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 115
      tracer_printf((char *)"BVC: Branching %hx\n", Displacement);
      }
    }
#line 116
    goto i_bcc_branch_taken;
  }
#line 118
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 118
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 118
    tracer_printf((char *)"BVC: NOT branching\n");
    }
  }
#line 119
  goto i_bcc_branch_not_taken;
  case_9: /* CIL Label */ 
#line 121
  if (SRBits->V) {
#line 122
    if (TRACER_Info[TRACER_default___101].Enabled) {
      {
#line 122
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 122
      tracer_printf((char *)"BVS: Branching %hx\n", Displacement);
      }
    }
#line 123
    goto i_bcc_branch_taken;
  }
#line 125
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 125
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 125
    tracer_printf((char *)"BVS: NOT branching\n");
    }
  }
#line 126
  goto i_bcc_branch_not_taken;
  case_10: /* CIL Label */ 
#line 129
  if (! SRBits->N) {
#line 130
    if (TRACER_Info[TRACER_default___101].Enabled) {
      {
#line 130
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 130
      tracer_printf((char *)"BPL: Branching %hx\n", Displacement);
      }
    }
#line 131
    goto i_bcc_branch_taken;
  }
#line 133
  goto i_bcc_branch_not_taken;
  case_11: /* CIL Label */ 
#line 135
  if (SRBits->N) {
#line 136
    if (TRACER_Info[TRACER_default___101].Enabled) {
      {
#line 136
      tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 136
      tracer_printf((char *)"BMI: Branching %hx\n", Displacement);
      }
    }
#line 137
    goto i_bcc_branch_taken;
  }
#line 139
  goto i_bcc_branch_not_taken;
  case_12: /* CIL Label */ 
#line 141
  if (SRBits->N) {
#line 141
    if (SRBits->V) {
#line 141
      goto _L___0;
    } else {
#line 141
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 141
  if (! SRBits->N) {
#line 141
    if (! SRBits->V) {
      _L___0: /* CIL Label */ 
#line 142
      if (TRACER_Info[TRACER_default___101].Enabled) {
        {
#line 142
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name,
                      "execute");
#line 142
        tracer_printf((char *)"BGE: Branching %hx\n", Displacement);
        }
      }
#line 143
      goto i_bcc_branch_taken;
    }
  }
#line 145
  goto i_bcc_branch_not_taken;
  case_13: /* CIL Label */ 
#line 147
  if (SRBits->N) {
#line 147
    if (! SRBits->V) {
#line 147
      goto _L___2;
    } else {
#line 147
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 147
  if (! SRBits->N) {
#line 147
    if (SRBits->V) {
      _L___2: /* CIL Label */ 
#line 148
      if (TRACER_Info[TRACER_default___101].Enabled) {
        {
#line 148
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name,
                      "execute");
#line 148
        tracer_printf((char *)"BLT: Branching %hx\n", Displacement);
        }
      }
#line 149
      goto i_bcc_branch_taken;
    }
  }
#line 151
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 151
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 151
    tracer_printf((char *)"BLT: NOT branching\n");
    }
  }
#line 152
  goto i_bcc_branch_not_taken;
  case_14: /* CIL Label */ 
#line 154
  if (SRBits->N) {
#line 154
    if (SRBits->V) {
#line 154
      if (! SRBits->Z) {
#line 154
        goto _L___4;
      } else {
#line 154
        goto _L___6;
      }
    } else {
#line 154
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 154
  if (! SRBits->N) {
#line 154
    if (! SRBits->V) {
#line 154
      if (! SRBits->Z) {
        _L___4: /* CIL Label */ 
#line 155
        if (TRACER_Info[TRACER_default___101].Enabled) {
          {
#line 155
          tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name,
                        "execute");
#line 155
          tracer_printf((char *)"BGT: Branching %hx\n", Displacement);
          }
        }
#line 156
        goto i_bcc_branch_taken;
      }
    }
  }
#line 158
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 158
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 158
    tracer_printf((char *)"BGT: NOT branching\n");
    }
  }
#line 159
  goto i_bcc_branch_not_taken;
  case_15: /* CIL Label */ 
#line 161
  if (SRBits->Z) {
#line 161
    goto _L___7;
  } else
#line 161
  if (SRBits->N) {
#line 161
    if (! SRBits->V) {
#line 161
      goto _L___7;
    } else {
#line 161
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 161
  if (! SRBits->N) {
#line 161
    if (SRBits->V) {
      _L___7: /* CIL Label */ 
#line 162
      if (TRACER_Info[TRACER_default___101].Enabled) {
        {
#line 162
        tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name,
                      "execute");
#line 162
        tracer_printf((char *)"BLE: Branching %hx\n", Displacement);
        }
      }
#line 163
      goto i_bcc_branch_taken;
    }
  }
#line 165
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 165
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 165
    tracer_printf((char *)"BLE: NOT branching\n");
    }
  }
#line 166
  goto i_bcc_branch_not_taken;
  switch_default: /* CIL Label */ 
  {
#line 169
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 169
  tracer_printf((char *)"Unknown Condition Code 0x%02x\n", Instr.Bits.Condition);
  }
#line 170
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 172
  tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 172
  tracer_printf((char *)"This should NOT happen!\n");
  }
#line 173
  return;
  i_bcc_branch_taken: 
#line 176
  if (Displacement > 0UL) {
#line 176
    tmp = 2;
  } else {
#line 176
    tmp = 0;
  }
  {
#line 176
  cycle((unsigned long )BCCTime[tmp]);
  }
  i_bcc_do_branch: 
#line 178
  memory_core.pc = ReferencePC + Displacement;
#line 179
  if (TRACER_Info[TRACER_default___101].Enabled) {
    {
#line 179
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___101].Name, "execute");
#line 179
    tracer_printf((char *)"BCC: New PC = %lx\n", memory_core.pc);
    }
  }
#line 180
  return;
  i_bcc_branch_not_taken: 
#line 183
  if (Displacement > 0UL) {
#line 183
    tmp___0 = 3;
  } else {
#line 183
    tmp___0 = 1;
  }
  {
#line 183
  cycle((unsigned long )BCCTime[tmp___0]);
  }
#line 184
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_bcc.c"
static long disassemble___103(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  unsigned long ReferencePC ;
  unsigned long Displacement ;
  BCC_Instr Instr ;

  {
  {
#line 190
  ReferencePC = memory_core.pc + 2UL;
#line 193
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 194
  Displacement = (unsigned long )Instr.Bits.Displacement;
  }
  {
#line 196
  if (Instr.Bits.Condition == 0U) {
#line 196
    goto case_0;
  }
#line 199
  if (Instr.Bits.Condition == 1U) {
#line 199
    goto case_1;
  }
#line 202
  if (Instr.Bits.Condition == 2U) {
#line 202
    goto case_2;
  }
#line 205
  if (Instr.Bits.Condition == 3U) {
#line 205
    goto case_3;
  }
#line 208
  if (Instr.Bits.Condition == 4U) {
#line 208
    goto case_4;
  }
#line 211
  if (Instr.Bits.Condition == 5U) {
#line 211
    goto case_5;
  }
#line 214
  if (Instr.Bits.Condition == 6U) {
#line 214
    goto case_6;
  }
#line 217
  if (Instr.Bits.Condition == 7U) {
#line 217
    goto case_7;
  }
#line 220
  if (Instr.Bits.Condition == 8U) {
#line 220
    goto case_8;
  }
#line 223
  if (Instr.Bits.Condition == 9U) {
#line 223
    goto case_9;
  }
#line 226
  if (Instr.Bits.Condition == 10U) {
#line 226
    goto case_10;
  }
#line 229
  if (Instr.Bits.Condition == 11U) {
#line 229
    goto case_11;
  }
#line 232
  if (Instr.Bits.Condition == 12U) {
#line 232
    goto case_12;
  }
#line 235
  if (Instr.Bits.Condition == 13U) {
#line 235
    goto case_13;
  }
#line 238
  if (Instr.Bits.Condition == 14U) {
#line 238
    goto case_14;
  }
#line 241
  if (Instr.Bits.Condition == 15U) {
#line 241
    goto case_15;
  }
#line 195
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 197
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BRA");
  }
#line 198
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 200
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BSR");
  }
#line 201
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 203
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BHI");
  }
#line 204
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 206
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BLS");
  }
#line 207
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 209
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BCC");
  }
#line 210
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 212
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BCS");
  }
#line 213
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 215
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BNE");
  }
#line 216
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 218
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BEQ");
  }
#line 219
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 221
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BVC");
  }
#line 222
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 224
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BVS");
  }
#line 225
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 227
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BPL");
  }
#line 228
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 230
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BMI");
  }
#line 231
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 233
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BGE");
  }
#line 234
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 236
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BLT");
  }
#line 237
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 239
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BGT");
  }
#line 240
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 242
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"BLE");
  }
#line 243
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 246
  if (Displacement == 0UL) {
    {
#line 247
    Memory_RetrFromPC(& Displacement, (short)16);
#line 248
    Displacement = (unsigned long )((short )Displacement);
    }
  }
  {
#line 253
  sprintf((char */* __restrict  */)Arg1, (char const   */* __restrict  */)"0x%08lX",
          ReferencePC + Displacement);
#line 254
  *(Arg2 + 0) = (char)0;
  }
#line 255
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
static enum _TRACER_Channels  const  TRACER_default___102  =    (enum _TRACER_Channels  const  )40;
#line 30 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
static void execute___104(void) 
{ 
  struct _Address Destination ;
  unsigned long Result ;
  unsigned long DValue ;
  NOT_Instr Instr ;
  char tmp ;

  {
  {
#line 35
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 37
  tmp = EA_GetFromPC(& Destination, (short)32, (char)0, (char )Instr.Bits.Register);
  }
#line 37
  if (! tmp) {
#line 37
    return;
  }
  {
#line 38
  EA_GetValue(& DValue, & Destination);
#line 40
  Result = ~ DValue;
  }
#line 41
  if (TRACER_Info[TRACER_default___102].Enabled) {
    {
#line 41
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___102].Name, "execute");
#line 41
    tracer_printf((char *)"~0x%08lx = 0x%08lx\n", DValue, Result);
    }
  }
#line 44
  memory_core.sr &= 65520UL;
#line 45
  SRBits->N = (unsigned int )((long )Result < 0L);
#line 46
  SRBits->Z = (unsigned int )(Result == 0UL);
#line 48
  if (TRACER_Info[TRACER_default___102].Enabled) {
    {
#line 48
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___102].Name, "execute");
#line 48
    tracer_printf((char *)"Storing Result:\n");
    }
  }
  {
#line 49
  EA_PutValue(& Destination, Result);
  }
#line 51
  if (TRACER_Info[TRACER_default___102].Enabled) {
    {
#line 51
    tracer_printf((char *)"%s:%s(): ", TRACER_Info[TRACER_default___102].Name, "execute");
#line 51
    tracer_printf((char *)"Done\n");
    }
  }
  {
#line 53
  cycle((unsigned long )NOTTime);
  }
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/i_5206/i_not.c"
static long disassemble___104(char *Instruction , char *Arg1 , char *Arg2 ) 
{ 
  NOT_Instr Instr ;

  {
  {
#line 61
  Memory_RetrFromPC(& Instr.Code, (short)16);
#line 62
  sprintf((char */* __restrict  */)Instruction, (char const   */* __restrict  */)"NOT.L");
#line 63
  Addressing_Print((short)32, (char)0, (char )Instr.Bits.Register, Arg1);
#line 64
  *(Arg2 + 0) = (char)0;
  }
#line 65
  return (0L);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 377 "/usr/include/stdio.h"
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/tracer/tracer.h"
int tracer_setuptrace(char *str ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/tracer/main.c"
struct _TRACER_Info TRACER_Info[70]  = 
#line 21 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/tracer/main.c"
  {      {(char *)"ea", (char)0}, 
        {(char *)"exception", (char)0}, 
        {(char *)"handlers", (char)0}, 
        {(char *)"i", (char)0}, 
        {(char *)"i_add", (char)0}, 
        {(char *)"i_adda", (char)0}, 
        {(char *)"i_addi", (char)0}, 
        {(char *)"i_addq", (char)0}, 
        {(char *)"i_addx", (char)0}, 
        {(char *)"i_and", (char)0}, 
        {(char *)"i_andi", (char)0}, 
        {(char *)"i_asx", (char)0}, 
        {(char *)"i_bcc", (char)0}, 
        {(char *)"i_btst", (char)0}, 
        {(char *)"i_clr", (char)0}, 
        {(char *)"i_cmp", (char)0}, 
        {(char *)"i_cmpa", (char)0}, 
        {(char *)"i_cmpi", (char)0}, 
        {(char *)"i_dc", (char)0}, 
        {(char *)"i_div", (char)0}, 
        {(char *)"i_eor", (char)0}, 
        {(char *)"i_eori", (char)0}, 
        {(char *)"i_ext", (char)0}, 
        {(char *)"i_halt", (char)0}, 
        {(char *)"i_illegal", (char)0}, 
        {(char *)"i_jmp", (char)0}, 
        {(char *)"i_jsr", (char)0}, 
        {(char *)"i_lea", (char)0}, 
        {(char *)"i_link", (char)0}, 
        {(char *)"i_lsx", (char)0}, 
        {(char *)"i_move", (char)0}, 
        {(char *)"i_movec", (char)0}, 
        {(char *)"i_movem", (char)0}, 
        {(char *)"i_moveq", (char)0}, 
        {(char *)"i_movexr", (char)0}, 
        {(char *)"i_mulu_l", (char)0}, 
        {(char *)"i_mul_w", (char)0}, 
        {(char *)"i_neg", (char)0}, 
        {(char *)"i_negx", (char)0}, 
        {(char *)"i_nop", (char)0}, 
        {(char *)"i_not", (char)0}, 
        {(char *)"i_or", (char)0}, 
        {(char *)"i_ori", (char)0}, 
        {(char *)"i_pea", (char)0}, 
        {(char *)"i_rte", (char)0}, 
        {(char *)"i_rts", (char)0}, 
        {(char *)"isa", (char)0}, 
        {(char *)"i_scc", (char)0}, 
        {(char *)"i_stop", (char)0}, 
        {(char *)"i_sub", (char)0}, 
        {(char *)"i_suba", (char)0}, 
        {(char *)"i_subi", (char)0}, 
        {(char *)"i_subq", (char)0}, 
        {(char *)"i_subx", (char)0}, 
        {(char *)"i_swap", (char)0}, 
        {(char *)"i_trap", (char)0}, 
        {(char *)"i_trapf", (char)0}, 
        {(char *)"i_tst", (char)0}, 
        {(char *)"i_unlk", (char)0}, 
        {(char *)"main", (char)0}, 
        {(char *)"memory", (char)0}, 
        {(char *)"misc", (char)0}, 
        {(char *)"monitor", (char)0}, 
        {(char *)"network", (char)0}, 
        {(char *)"ram", (char)0}, 
        {(char *)"run", (char)0}, 
        {(char *)"serial", (char)0}, 
        {(char *)"sim", (char)0}, 
        {(char *)"timer", (char)0}, 
        {(char *)((void *)0), (char)0}};
#line 27 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/tracer/main.c"
int tracer_indent  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/tracer/main.c"
int tracer_printf(char *msg  , ...) 
{ 
  va_list Args ;
  int x ;

  {
  {
#line 42
  __builtin_va_start(Args, msg);
#line 43
  x = vprintf((char const   */* __restrict  */)msg, Args);
#line 44
  __builtin_va_end(Args);
  }
#line 48
  return (x);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/coldfire-0.2.2/tracer/main.c"
int tracer_setuptrace(char *str ) 
{ 
  char *s ;
  char *original_s ;
  char *ptr ;
  int x ;
  char enable ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 57
  if (! str) {
#line 57
    return (0);
  }
  {
#line 59
  tmp = strlen((char const   *)str);
#line 59
  tmp___0 = malloc(tmp + 1UL);
#line 59
  s = (char *)tmp___0;
#line 60
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)str);
#line 61
  original_s = s;
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    enable = (char)1;
#line 65
    ptr = strchr((char const   *)s, ',');
    }
#line 66
    if (ptr) {
#line 66
      *ptr = (char)0;
    }
#line 68
    if ((int )*(s + 0) == 45) {
#line 69
      enable = (char)0;
#line 70
      s ++;
    }
#line 73
    x = 0;
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      if (! ((unsigned long )TRACER_Info[x].Name != (unsigned long )((void *)0))) {
#line 73
        goto while_break___0;
      }
      {
#line 74
      tmp___1 = strcmp((char const   *)TRACER_Info[x].Name, (char const   *)s);
      }
#line 74
      if (tmp___1 == 0) {
#line 76
        TRACER_Info[x].Enabled = enable;
      } else {
        {
#line 74
        tmp___2 = strcmp("all", (char const   *)s);
        }
#line 74
        if (tmp___2 == 0) {
#line 76
          TRACER_Info[x].Enabled = enable;
        }
      }
#line 73
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 81
    if (! ptr) {
#line 81
      goto while_break;
    }
#line 82
    s = ptr + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  printf((char const   */* __restrict  */)"Tracing [");
#line 85
  x = 0;
  }
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 85
    if (! ((unsigned long )TRACER_Info[x].Name != (unsigned long )((void *)0))) {
#line 85
      goto while_break___1;
    }
#line 86
    if (TRACER_Info[x].Enabled) {
      {
#line 87
      printf((char const   */* __restrict  */)" %s ", TRACER_Info[x].Name);
      }
    }
#line 85
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 90
  printf((char const   */* __restrict  */)"]\n");
#line 91
  free((void *)original_s);
  }
#line 92
  return (1);
}
}
