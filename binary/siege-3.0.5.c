/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_18 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_17 {
   struct __anonstruct___data_18 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_17 pthread_cond_t;
#line 24 "../include/joedog/boolean.h"
enum __anonenum_BOOLEAN_66 {
    boolean_false = 0,
    boolean_true = 1
} ;
#line 24 "../include/joedog/boolean.h"
typedef enum __anonenum_BOOLEAN_66 BOOLEAN;
#line 32 "./url.h"
struct URL_T;
#line 32 "./url.h"
typedef struct URL_T *URL;
#line 43 "./url.h"
typedef int METHOD;
#line 58
enum __anonenum_SCHEME_69 {
    UNSUPPORTED = 0,
    HTTP = 1,
    HTTPS = 2,
    FTP = 3,
    PROXY = 4
} ;
#line 58 "./url.h"
typedef enum __anonenum_SCHEME_69 SCHEME;
#line 30 "./auth.h"
struct AUTH_T;
#line 30 "./auth.h"
typedef struct AUTH_T *AUTH;
#line 33
struct DIGEST_CRED;
#line 33 "./auth.h"
typedef struct DIGEST_CRED DCRED;
#line 34
struct DIGEST_CHLG;
#line 34 "./auth.h"
typedef struct DIGEST_CHLG DCHLG;
#line 35
enum __anonenum_TYPE_70 {
    BASIC = 0,
    DIGEST = 1
} ;
#line 35 "./auth.h"
typedef enum __anonenum_TYPE_70 TYPE;
#line 29 "./array.h"
struct ARRAY_T;
#line 29 "./array.h"
typedef struct ARRAY_T *ARRAY;
#line 40 "../include/joedog/joedog.h"
enum __anonenum_LEVEL_71 {
    DEBUG = 0,
    WARNING = 1,
    ERROR = 2,
    FATAL = 3
} ;
#line 40 "../include/joedog/joedog.h"
typedef enum __anonenum_LEVEL_71 LEVEL;
#line 152 "./setup.h"
struct CONFIG {
   BOOLEAN logging ;
   BOOLEAN shlog ;
   char *url ;
   char logfile[128] ;
   BOOLEAN verbose ;
   BOOLEAN quiet ;
   BOOLEAN csv ;
   BOOLEAN fullurl ;
   BOOLEAN display ;
   BOOLEAN config ;
   int cusers ;
   int delay ;
   int timeout ;
   BOOLEAN bench ;
   BOOLEAN internet ;
   BOOLEAN timestamp ;
   int time ;
   int secs ;
   int reps ;
   char file[128] ;
   int length ;
   BOOLEAN debug ;
   BOOLEAN chunked ;
   BOOLEAN unique ;
   BOOLEAN get ;
   BOOLEAN mark ;
   char *markstr ;
   int protocol ;
   BOOLEAN cookies ;
   char uagent[256] ;
   char encoding[256] ;
   char conttype[256] ;
   char *username ;
   char *password ;
   int bids ;
   AUTH auth ;
   BOOLEAN keepalive ;
   int signaled ;
   char extra[2048] ;
   BOOLEAN login ;
   char *loginurl ;
   ARRAY lurl ;
   int failures ;
   int failed ;
   BOOLEAN escape ;
   BOOLEAN expire ;
   BOOLEAN follow ;
   BOOLEAN zero_ok ;
   BOOLEAN spinner ;
   BOOLEAN cache ;
   char rc[256] ;
   int ssl_timeout ;
   char *ssl_cert ;
   char *ssl_key ;
   char *ssl_ciphers ;
   METHOD method ;
   pthread_cond_t cond ;
   pthread_mutex_t lock ;
};
#line 54 "./sock.h"
enum __anonenum_S_STATUS_80 {
    S_CONNECTING = 1,
    S_READING = 2,
    S_WRITING = 4,
    S_DONE = 8
} ;
#line 54 "./sock.h"
typedef enum __anonenum_S_STATUS_80 S_STATUS;
#line 62
enum __anonenum_SDSET_81 {
    UNDEF = 0,
    READ = 1,
    WRITE = 2,
    RDWR = 3
} ;
#line 62 "./sock.h"
typedef enum __anonenum_SDSET_81 SDSET;
#line 73
enum __anonenum_TE_82 {
    NONE = 0,
    CHUNKED = 1,
    TRAILER = 2
} ;
#line 73 "./sock.h"
typedef enum __anonenum_TE_82 TE;
#line 81 "./sock.h"
struct __anonstruct_content_84 {
   TE transfer ;
   size_t length ;
};
#line 81 "./sock.h"
struct __anonstruct_connection_85 {
   int max ;
   int timeout ;
   int reuse ;
   int status ;
   int keepalive ;
   int tested ;
};
#line 81 "./sock.h"
struct __anonstruct_type_87 {
   TYPE www ;
   TYPE proxy ;
};
#line 81 "./sock.h"
struct __anonstruct_auth_86 {
   DCHLG *wchlg ;
   DCRED *wcred ;
   int www ;
   DCHLG *pchlg ;
   DCRED *pcred ;
   int proxy ;
   struct __anonstruct_type_87 type ;
};
#line 81 "./sock.h"
struct __anonstruct_ftp_88 {
   int code ;
   char host[64] ;
   int port ;
   size_t size ;
   BOOLEAN pasv ;
};
#line 81 "./sock.h"
struct __anonstruct_CONN_83 {
   int sock ;
   S_STATUS status ;
   BOOLEAN encrypt ;
   SCHEME scheme ;
   struct __anonstruct_content_84 content ;
   struct __anonstruct_connection_85 connection ;
   struct __anonstruct_auth_86 auth ;
   BOOLEAN nossl ;
   size_t inbuffer ;
   int pos_ini ;
   char buffer[4096] ;
   char chkbuf[1024] ;
   fd_set *ws ;
   fd_set *rs ;
   SDSET state ;
   struct __anonstruct_ftp_88 ftp ;
};
#line 81 "./sock.h"
typedef struct __anonstruct_CONN_83 CONN;
#line 49 "./http.h"
struct __anonstruct_realm_91 {
   char *www ;
   char *proxy ;
};
#line 49 "./http.h"
struct __anonstruct_challenge_92 {
   char *www ;
   char *proxy ;
};
#line 49 "./http.h"
struct __anonstruct_type_93 {
   TYPE www ;
   TYPE proxy ;
};
#line 49 "./http.h"
struct __anonstruct_auth_90 {
   int www ;
   int proxy ;
   struct __anonstruct_realm_91 realm ;
   struct __anonstruct_challenge_92 challenge ;
   struct __anonstruct_type_93 type ;
};
#line 49 "./http.h"
struct headers {
   char head[64] ;
   int code ;
   unsigned long length ;
   char cookie[8192] ;
   char *redirect ;
   struct __anonstruct_auth_90 auth ;
   int keepalive ;
};
#line 49 "./http.h"
typedef struct headers HEADERS;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 534 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_37 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 534 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_36 {
   struct __anonstruct___cancel_jmp_buf_37 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 534 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_36  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 753
struct __jmp_buf_tag;
#line 34 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 51 "./client.h"
struct __anonstruct_bids_82 {
   int www ;
   int proxy ;
};
#line 51 "./client.h"
struct __anonstruct_type_83 {
   TYPE www ;
   TYPE proxy ;
};
#line 51 "./client.h"
struct __anonstruct_auth_81 {
   DCHLG *wchlg ;
   DCRED *wcred ;
   int www ;
   DCHLG *pchlg ;
   DCRED *pcred ;
   int proxy ;
   struct __anonstruct_bids_82 bids ;
   struct __anonstruct_type_83 type ;
};
#line 51 "./client.h"
struct __anonstruct_CLIENT_80 {
   int id ;
   unsigned long hits ;
   unsigned long bytes ;
   unsigned int code ;
   unsigned int fail ;
   unsigned int ok200 ;
   ARRAY urls ;
   struct __anonstruct_auth_81 auth ;
   int status ;
   float time ;
   unsigned int rand_r_SEED ;
   float himark ;
   float lomark ;
};
#line 51 "./client.h"
typedef struct __anonstruct_CLIENT_80 CLIENT;
#line 49 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
enum assume {
    DATE_MDAY = 0,
    DATE_YEAR = 1,
    DATE_TIME = 2
} ;
#line 67 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
struct tzinfo {
   char const   *name ;
   int offset ;
};
#line 28 "./creds.h"
struct CREDS_T;
#line 28 "./creds.h"
typedef struct CREDS_T *CREDS;
#line 30 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
struct CREDS_T {
   SCHEME scheme ;
   char *username ;
   char *password ;
   char *realm ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
typedef void *array;
#line 32 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
struct ARRAY_T {
   int index ;
   int length ;
   array *data ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_16 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_16 pthread_mutexattr_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_19 {
   char __size[4] ;
   int __align ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_19 pthread_condattr_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 30 "./crew.h"
struct work {
   void (*routine)() ;
   void *arg ;
   struct work *next ;
};
#line 30 "./crew.h"
typedef struct work WORK;
#line 37
struct CREW_T;
#line 37 "./crew.h"
typedef struct CREW_T *CREW;
#line 32 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
struct CREW_T {
   int size ;
   int maxsize ;
   int cursize ;
   int total ;
   WORK *head ;
   WORK *tail ;
   BOOLEAN block ;
   BOOLEAN closed ;
   BOOLEAN shutdown ;
   pthread_t *threads ;
   pthread_mutex_t lock ;
   pthread_cond_t not_empty ;
   pthread_cond_t not_full ;
   pthread_cond_t empty ;
};
#line 44 "./data.h"
struct DATA_T;
#line 44 "./data.h"
typedef struct DATA_T *DATA;
#line 44 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
struct DATA_T {
   float total ;
   float available ;
   float failed ;
   float lowest ;
   float highest ;
   float elapsed ;
   clock_t start ;
   clock_t stop ;
   struct tms t_start ;
   struct tms t_stop ;
   unsigned int code ;
   unsigned int count ;
   unsigned int ok200 ;
   unsigned int fail ;
   unsigned long long bytes ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.h"
typedef unsigned int md5_uint32;
#line 81 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.h"
struct md5_ctx {
   md5_uint32 A ;
   md5_uint32 B ;
   md5_uint32 C ;
   md5_uint32 D ;
   md5_uint32 total[2] ;
   md5_uint32 buflen ;
   char buffer[128] ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/load.c"
struct ContentType {
   char *ext ;
   BOOLEAN ascii ;
   char *type ;
};
#line 38 "./cookie.h"
struct CNODE {
   int index ;
   pthread_t threadID ;
   char *name ;
   char *value ;
   char *path ;
   char *domain ;
   time_t expires ;
   char *expirestr ;
   char *version ;
   char *max ;
   int secure ;
   struct CNODE *next ;
};
#line 38 "./cookie.h"
typedef struct CNODE CNODE;
#line 54 "./cookie.h"
struct __anonstruct_COOKIE_73 {
   CNODE *first ;
   pthread_mutex_t mutex ;
};
#line 54 "./cookie.h"
typedef struct __anonstruct_COOKIE_73 COOKIE;
#line 29 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c"
struct __anonstruct_PARSED_COOKIE_74 {
   char *name ;
   char *value ;
   char *domain ;
   char *path ;
   time_t expires ;
   int secure ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c"
typedef struct __anonstruct_PARSED_COOKIE_74 PARSED_COOKIE;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 35 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
struct __anonstruct_basic_73 {
   char *encode ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
struct __anonstruct_digest_74 {
   char *encode ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
struct __anonstruct_proxy_75 {
   BOOLEAN required ;
   char *hostname ;
   int port ;
   char *encode ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
struct AUTH_T {
   ARRAY creds ;
   BOOLEAN okay ;
   struct __anonstruct_basic_73 basic ;
   struct __anonstruct_digest_74 digest ;
   struct __anonstruct_proxy_75 proxy ;
   pthread_mutex_t lock ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
struct DIGEST_CRED {
   char *username ;
   char *password ;
   char *cnonce_value ;
   char *h_a1 ;
   char nc[9] ;
   unsigned int nc_value ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
struct DIGEST_CHLG {
   char *realm ;
   char *domain ;
   char *nonce ;
   char *opaque ;
   char *stale ;
   char *algorithm ;
   char *qop ;
};
#line 72
enum __anonenum_KEY_HEADER_E_76 {
    REALM = 0,
    DOMAIN = 1,
    NONCE = 2,
    OPAQUE = 3,
    STALE = 4,
    ALGORITHM = 5,
    QOP = 6,
    UNKNOWN = 7
} ;
#line 72 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
typedef enum __anonenum_KEY_HEADER_E_76 KEY_HEADER_E;
#line 414 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
struct __anonstruct_KEYPARSER_77 {
   char const   *keyname ;
   KEY_HEADER_E keyval ;
};
#line 414 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
typedef struct __anonstruct_KEYPARSER_77 KEYPARSER;
#line 227 "./setup.h"
struct __anonstruct_LINES_72 {
   int index ;
   char **line ;
};
#line 227 "./setup.h"
typedef struct __anonstruct_LINES_72 LINES;
#line 32 "./hash.h"
struct HASH_T;
#line 32 "./hash.h"
typedef struct HASH_T *HASH;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_36 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_36 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 34 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
struct URL_T {
   int ID ;
   char *url ;
   SCHEME scheme ;
   METHOD method ;
   char *username ;
   char *password ;
   char *hostname ;
   int port ;
   char *path ;
   char *file ;
   char *params ;
   BOOLEAN hasparams ;
   char *query ;
   char *frag ;
   char *request ;
   size_t postlen ;
   char *postdata ;
   char *posttemp ;
   char *conttype ;
   time_t expires ;
   time_t modified ;
   BOOLEAN cached ;
   char *etag ;
   char *realm ;
};
#line 948
enum copy_method {
    CM_DECODE = 0,
    CM_ENCODE = 1,
    CM_PASSTHROUGH = 2
} ;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
struct NODE {
   char *key ;
   char *value ;
   struct NODE *next ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
typedef struct NODE NODE;
#line 40 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
struct HASH_T {
   int size ;
   int entries ;
   int index ;
   NODE **table ;
};
#line 85 "../include/joedog/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 286 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 74 "./url.h"
void url_set_last_modified(URL this , char *date ) ;
#line 75
void url_set_etag(URL this , char *etag ) ;
#line 82
char *url_get_method_name(URL this ) ;
#line 98
char *url_get_hostname(URL this ) ;
#line 101
int url_get_port(URL this ) ;
#line 108
char *url_get_request(URL this ) ;
#line 131
size_t url_get_postlen(URL this ) ;
#line 132
char *url_get_postdata(URL this ) ;
#line 134
char *url_get_conttype(URL this ) ;
#line 135
char *url_get_if_modified_since(URL this ) ;
#line 136
char *url_get_etag(URL this ) ;
#line 138
void url_set_realm(URL this , char *realm ) ;
#line 41 "./auth.h"
char *auth_get_basic_header(AUTH this , SCHEME scheme ) ;
#line 43
char *auth_get_digest_header(AUTH this , SCHEME scheme , DCHLG *chlg , DCRED *cred ,
                             char const   *method , char const   *uri ) ;
#line 45
BOOLEAN auth_get_proxy_required(AUTH this ) ;
#line 50 "../include/joedog/joedog.h"
void NOTIFY(LEVEL L , char const   *fmt  , ...) ;
#line 57
void *xmalloc(size_t size ) ;
#line 58
void *xcalloc(size_t num , size_t size ) ;
#line 59
char *xstrdup(char const   *str ) ;
#line 61
void xfree(void *ptr ) ;
#line 239 "./setup.h"
struct CONFIG my ;
#line 137 "./sock.h"
int socket_write(CONN *C , void const   *buf , size_t len ) ;
#line 138
ssize_t socket_read(CONN *C , void *vbuf , size_t len ) ;
#line 139
ssize_t socket_readline(CONN *C , char *ptr , size_t maxlen ) ;
#line 60 "./cookie.h"
int add_cookie(pthread_t id , char *host , char *cookiestr ) ;
#line 64
char *get_cookie_header(pthread_t id , char *host , char *newton ) ;
#line 77 "./http.h"
BOOLEAN http_get(CONN *C , URL U ) ;
#line 78
BOOLEAN http_post(CONN *C , URL U ) ;
#line 79
void http_free_headers(HEADERS *h ) ;
#line 80
HEADERS *http_read_headers(CONN *C , URL U ) ;
#line 81
ssize_t http_read(CONN *C ) ;
#line 82
BOOLEAN https_tunnel_request(CONN *C , char *host , int port ) ;
#line 83
int https_tunnel_response(CONN *C ) ;
#line 35 "./util.h"
void echo(char const   *fmt  , ...) ;
#line 43
char const   *strncasestr(char const   *str1 , char const   *str2 , size_t len ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
static char *__parse_pair(char **str ) ;
#line 36
static char *__dequote(char *str ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
BOOLEAN https_tunnel_request(CONN *C , char *host , int port ) 
{ 
  size_t rlen ;
  size_t n ;
  char request[256] ;
  int tmp ;
  BOOLEAN tmp___0 ;

  {
#line 48
  if ((unsigned int )C->encrypt == 1U) {
    {
#line 48
    tmp___0 = auth_get_proxy_required(my.auth);
    }
#line 48
    if (tmp___0) {
      {
#line 49
      snprintf((char */* __restrict  */)(request), sizeof(request), (char const   */* __restrict  */)"CONNECT %s:%d HTTP/1.0\r\nUser-agent: Proxy-User\r\n\r\n",
               host, port);
#line 56
      rlen = strlen((char const   *)(request));
#line 57
      echo("%s", request);
#line 58
      tmp = socket_write(C, (void const   *)(request), rlen);
#line 58
      n = (size_t )tmp;
      }
#line 58
      if (n != rlen) {
        {
#line 59
        NOTIFY((LEVEL )2, "HTTP: unable to write to socket.");
        }
#line 60
        return ((BOOLEAN )0);
      }
    } else {
#line 63
      return ((BOOLEAN )0);
    }
  } else {
#line 63
    return ((BOOLEAN )0);
  }
#line 65
  return ((BOOLEAN )1);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
int https_tunnel_response(CONN *C ) 
{ 
  int x ;
  int n ;
  char c ;
  char line[256] ;
  int code ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 74
  code = 100;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    x = 0;
#line 78
    memset((void *)(& line), '\000', sizeof(line));
    }
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp = read(C->sock, (void *)(& c), (size_t )1);
#line 79
      n = (int )tmp;
      }
#line 79
      if (! (n == 1)) {
#line 79
        goto while_break___0;
      }
      {
#line 80
      line[x] = c;
#line 81
      echo("%c", (int )c);
      }
#line 82
      if ((int )line[0] == 10) {
#line 83
        return (code);
      } else
#line 82
      if ((int )line[1] == 10) {
#line 83
        return (code);
      }
#line 85
      if ((int )line[x] == 10) {
#line 85
        goto while_break___0;
      }
#line 86
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 88
    line[x] = (char)0;
#line 89
    tmp___0 = strncasecmp((char const   *)(line), "http", (size_t )4);
    }
#line 89
    if (tmp___0 == 0) {
      {
#line 90
      code = atoi((char const   *)(line + 9));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
BOOLEAN http_get(CONN *C , URL U ) 
{ 
  size_t rlen ;
  size_t mlen ;
  char protocol[16] ;
  char keepalive[16] ;
  char hoststr[512] ;
  char authwww[512] ;
  char authpxy[512] ;
  char accept___0[14] ;
  char encoding[512] ;
  char *request ;
  char portstr[16] ;
  char fullpath[4096] ;
  char cookie___0[8200] ;
  time_t now ;
  char *ifmod ;
  char *tmp ;
  char *ifnon ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  BOOLEAN tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  pthread_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  char const   *tmp___26 ;
  size_t tmp___27 ;
  char const   *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  char const   *tmp___31 ;
  size_t tmp___32 ;
  char const   *tmp___33 ;
  size_t tmp___34 ;
  char const   *tmp___36 ;
  int tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  void *tmp___42 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  char const   *tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___49 ;
  size_t tmp___50 ;
  char const   *tmp___51 ;
  char const   *tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *tmp___55 ;
  int tmp___56 ;

  {
  {
#line 105
  accept___0[0] = (char )'A';
#line 105
  accept___0[1] = (char )'c';
#line 105
  accept___0[2] = (char )'c';
#line 105
  accept___0[3] = (char )'e';
#line 105
  accept___0[4] = (char )'p';
#line 105
  accept___0[5] = (char )'t';
#line 105
  accept___0[6] = (char )':';
#line 105
  accept___0[7] = (char )' ';
#line 105
  accept___0[8] = (char )'*';
#line 105
  accept___0[9] = (char )'/';
#line 105
  accept___0[10] = (char )'*';
#line 105
  accept___0[11] = (char )'\r';
#line 105
  accept___0[12] = (char )'\n';
#line 105
  accept___0[13] = (char )'\000';
#line 112
  tmp = url_get_if_modified_since(U);
#line 112
  ifmod = tmp;
#line 113
  tmp___0 = url_get_etag(U);
#line 113
  ifnon = tmp___0;
#line 115
  now = time((time_t *)((void *)0));
#line 117
  memset((void *)(hoststr), '\000', sizeof(hoststr));
#line 118
  memset((void *)(cookie___0), '\000', sizeof(cookie___0));
#line 119
  memset((void *)(portstr), '\000', sizeof(portstr));
#line 122
  tmp___6 = auth_get_proxy_required(my.auth);
  }
#line 122
  if (tmp___6) {
    {
#line 123
    tmp___1 = url_get_request(U);
#line 123
    tmp___2 = url_get_port(U);
#line 123
    tmp___3 = url_get_hostname(U);
    }
#line 123
    if ((unsigned int )C->encrypt == 0U) {
#line 123
      tmp___4 = "http";
    } else {
#line 123
      tmp___4 = "https";
    }
    {
#line 123
    sprintf((char */* __restrict  */)(fullpath), (char const   */* __restrict  */)"%s://%s:%d%s",
            tmp___4, tmp___3, tmp___2, tmp___1);
    }
  } else {
    {
#line 128
    tmp___5 = url_get_request(U);
#line 128
    sprintf((char */* __restrict  */)(fullpath), (char const   */* __restrict  */)"%s",
            tmp___5);
    }
  }
  {
#line 130
  tmp___8 = url_get_port(U);
  }
#line 130
  if (tmp___8 == 80) {
#line 130
    if ((unsigned int )C->encrypt == 0U) {
#line 131
      portstr[0] = (char )'\000';
    } else {
#line 130
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 130
    tmp___9 = url_get_port(U);
    }
#line 130
    if (tmp___9 == 443) {
#line 130
      if ((unsigned int )C->encrypt == 0U) {
#line 131
        portstr[0] = (char )'\000';
      } else {
        {
#line 133
        tmp___7 = url_get_port(U);
#line 133
        snprintf((char */* __restrict  */)(portstr), sizeof(portstr), (char const   */* __restrict  */)":%d",
                 tmp___7);
        }
      }
    } else {
      {
#line 133
      tmp___7 = url_get_port(U);
#line 133
      snprintf((char */* __restrict  */)(portstr), sizeof(portstr), (char const   */* __restrict  */)":%d",
               tmp___7);
      }
    }
  }
#line 140
  if (my.protocol == 0) {
    {
#line 141
    snprintf((char */* __restrict  */)(protocol), sizeof(protocol), (char const   */* __restrict  */)"HTTP/1.0");
    }
  } else
#line 140
  if ((unsigned int )my.get == 1U) {
    {
#line 141
    snprintf((char */* __restrict  */)(protocol), sizeof(protocol), (char const   */* __restrict  */)"HTTP/1.0");
    }
  } else {
    {
#line 143
    snprintf((char */* __restrict  */)(protocol), sizeof(protocol), (char const   */* __restrict  */)"HTTP/1.1");
    }
  }
#line 145
  if (C->connection.keepalive == 1) {
    {
#line 146
    snprintf((char */* __restrict  */)(keepalive), sizeof(keepalive), (char const   */* __restrict  */)"keep-alive");
    }
  } else {
    {
#line 148
    snprintf((char */* __restrict  */)(keepalive), sizeof(keepalive), (char const   */* __restrict  */)"close");
    }
  }
  {
#line 151
  tmp___10 = url_get_hostname(U);
#line 151
  tmp___11 = pthread_self();
#line 151
  get_cookie_header(tmp___11, tmp___10, cookie___0);
  }
#line 152
  if (C->auth.www) {
#line 153
    if ((unsigned int )C->auth.type.www == 1U) {
      {
#line 154
      tmp___12 = url_get_method_name(U);
#line 154
      tmp___13 = auth_get_digest_header(my.auth, (SCHEME )1, C->auth.wchlg, C->auth.wcred,
                                        (char const   *)tmp___12, (char const   *)(fullpath));
#line 154
      snprintf((char */* __restrict  */)(authwww), sizeof(authwww), (char const   */* __restrict  */)"%s",
               tmp___13);
      }
    } else {
      {
#line 159
      tmp___14 = auth_get_basic_header(my.auth, (SCHEME )1);
#line 159
      snprintf((char */* __restrict  */)(authwww), sizeof(authwww), (char const   */* __restrict  */)"%s",
               tmp___14);
      }
    }
  }
#line 162
  if (C->auth.proxy) {
#line 163
    if ((unsigned int )C->auth.type.proxy == 1U) {
      {
#line 164
      tmp___15 = url_get_method_name(U);
#line 164
      tmp___16 = auth_get_digest_header(my.auth, (SCHEME )1, C->auth.wchlg, C->auth.wcred,
                                        (char const   *)tmp___15, (char const   *)(fullpath));
#line 164
      snprintf((char */* __restrict  */)(authwww), sizeof(authwww), (char const   */* __restrict  */)"%s",
               tmp___16);
      }
    } else {
      {
#line 169
      tmp___17 = auth_get_basic_header(my.auth, (SCHEME )4);
#line 169
      snprintf((char */* __restrict  */)(authpxy), sizeof(authpxy), (char const   */* __restrict  */)"%s",
               tmp___17);
      }
    }
  }
  {
#line 174
  tmp___20 = (char *)strncasestr((char const   *)(my.extra), "host:", sizeof(my.extra));
  }
#line 174
  if ((unsigned long )tmp___20 == (unsigned long )((void *)0)) {
    {
#line 175
    tmp___18 = url_get_hostname(U);
#line 175
    tmp___19 = snprintf((char */* __restrict  */)(hoststr), sizeof(hoststr), (char const   */* __restrict  */)"Host: %s\r\n",
                        tmp___18);
#line 175
    rlen = (size_t )tmp___19;
    }
  }
  {
#line 178
  tmp___21 = url_get_method_name(U);
#line 178
  tmp___22 = strlen((char const   *)tmp___21);
#line 178
  tmp___23 = strlen((char const   *)(fullpath));
#line 178
  tmp___24 = strlen((char const   *)(protocol));
#line 178
  tmp___25 = strlen((char const   *)(hoststr));
  }
#line 178
  if (C->auth.www == 1) {
#line 178
    tmp___26 = (char const   *)(authwww);
  } else {
#line 178
    tmp___26 = "";
  }
  {
#line 178
  tmp___27 = strlen(tmp___26);
  }
#line 178
  if (C->auth.proxy == 1) {
#line 178
    tmp___28 = (char const   *)(authpxy);
  } else {
#line 178
    tmp___28 = "";
  }
  {
#line 178
  tmp___29 = strlen(tmp___28);
#line 178
  tmp___30 = strlen((char const   *)(cookie___0));
  }
#line 178
  if ((unsigned long )ifmod != (unsigned long )((void *)0)) {
#line 178
    tmp___31 = (char const   *)ifmod;
  } else {
#line 178
    tmp___31 = "";
  }
  {
#line 178
  tmp___32 = strlen(tmp___31);
  }
#line 178
  if ((unsigned long )ifnon != (unsigned long )((void *)0)) {
#line 178
    tmp___33 = (char const   *)ifnon;
  } else {
#line 178
    tmp___33 = "";
  }
  {
#line 178
  tmp___34 = strlen(tmp___33);
#line 178
  tmp___37 = strncasecmp((char const   *)(my.extra), "Accept:", (size_t )7);
  }
#line 178
  if (tmp___37 == 0) {
#line 178
    tmp___36 = "";
  } else {
#line 178
    tmp___36 = (char const   *)(accept___0);
  }
  {
#line 178
  tmp___38 = strlen(tmp___36);
#line 178
  tmp___39 = strlen((char const   *)(my.uagent));
#line 178
  tmp___40 = strlen((char const   *)(my.extra));
#line 178
  tmp___41 = strlen((char const   *)(keepalive));
#line 178
  mlen = (((((((((((((tmp___22 + tmp___23) + tmp___24) + tmp___25) + tmp___27) + tmp___29) + tmp___30) + tmp___32) + tmp___34) + tmp___38) + sizeof(encoding)) + tmp___39) + tmp___40) + tmp___41) + 128UL;
#line 193
  tmp___42 = xmalloc(mlen);
#line 193
  request = (char *)tmp___42;
#line 194
  memset((void *)request, '\000', mlen);
#line 195
  memset((void *)(encoding), '\000', sizeof(encoding));
  }
#line 196
  if (! my.get) {
    {
#line 197
    snprintf((char */* __restrict  */)(encoding), sizeof(encoding), (char const   */* __restrict  */)"Accept-Encoding: %s\r\n",
             my.encoding);
    }
  }
  {
#line 203
  tmp___45 = strncasecmp((char const   *)(my.extra), "Accept:", (size_t )7);
  }
#line 203
  if (tmp___45 == 0) {
#line 203
    tmp___44 = "";
  } else {
#line 203
    tmp___44 = (char const   *)(accept___0);
  }
#line 203
  if ((unsigned long )ifnon != (unsigned long )((void *)0)) {
#line 203
    tmp___46 = (char const   *)ifnon;
  } else {
#line 203
    tmp___46 = "";
  }
#line 203
  if ((unsigned long )ifmod != (unsigned long )((void *)0)) {
#line 203
    tmp___47 = (char const   *)ifmod;
  } else {
#line 203
    tmp___47 = "";
  }
  {
#line 203
  tmp___50 = strlen((char const   *)(cookie___0));
  }
#line 203
  if (tmp___50 > 8UL) {
#line 203
    tmp___49 = (char const   *)(cookie___0);
  } else {
#line 203
    tmp___49 = "";
  }
#line 203
  if (C->auth.proxy == 1) {
#line 203
    tmp___51 = (char const   *)(authpxy);
  } else {
#line 203
    tmp___51 = "";
  }
#line 203
  if (C->auth.www == 1) {
#line 203
    tmp___52 = (char const   *)(authwww);
  } else {
#line 203
    tmp___52 = "";
  }
  {
#line 203
  tmp___53 = url_get_method_name(U);
#line 203
  tmp___54 = snprintf((char */* __restrict  */)request, mlen, (char const   */* __restrict  */)"%s %s %s\r\n%s%s%s%s%s%s%s%sUser-Agent: %s\r\n%sConnection: %s\r\n\r\n",
                      tmp___53, fullpath, protocol, hoststr, tmp___52, tmp___51, tmp___49,
                      tmp___47, tmp___46, tmp___44, encoding, my.uagent, my.extra,
                      keepalive);
#line 203
  rlen = (size_t )tmp___54;
  }
#line 231
  if (my.debug) {
#line 231
    goto _L___0;
  } else
#line 231
  if (my.get) {
    _L___0: /* CIL Label */ 
#line 231
    if (! my.quiet) {
      {
#line 231
      printf((char const   */* __restrict  */)"%s\n", request);
#line 231
      fflush(stdout);
      }
    }
  }
#line 233
  if (rlen == 0UL) {
    {
#line 234
    tmp___55 = url_get_method_name(U);
#line 234
    NOTIFY((LEVEL )3, "HTTP %s: request buffer overrun!", tmp___55);
    }
  } else
#line 233
  if (rlen > mlen) {
    {
#line 234
    tmp___55 = url_get_method_name(U);
#line 234
    NOTIFY((LEVEL )3, "HTTP %s: request buffer overrun!", tmp___55);
    }
  }
  {
#line 237
  tmp___56 = socket_write(C, (void const   *)request, rlen);
  }
#line 237
  if (tmp___56 < 0) {
    {
#line 238
    xfree((void *)ifmod);
#line 239
    xfree((void *)ifnon);
    }
#line 240
    return ((BOOLEAN )0);
  }
  {
#line 243
  xfree((void *)ifmod);
#line 244
  xfree((void *)ifnon);
#line 245
  xfree((void *)request);
  }
#line 246
  return ((BOOLEAN )1);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
BOOLEAN http_post(CONN *C , URL U ) 
{ 
  size_t rlen ;
  size_t mlen ;
  char hoststr[128] ;
  char authwww[128] ;
  char authpxy[128] ;
  char accept___0[14] ;
  char encoding[512] ;
  char *request ;
  char portstr[16] ;
  char protocol[16] ;
  char keepalive[16] ;
  char cookie___0[8192] ;
  char fullpath[4096] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  pthread_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  char const   *tmp___24 ;
  size_t tmp___25 ;
  char const   *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  void *tmp___39 ;
  size_t tmp___40 ;
  char *tmp___41 ;
  char const   *tmp___43 ;
  int tmp___44 ;
  char const   *tmp___46 ;
  size_t tmp___47 ;
  char const   *tmp___48 ;
  char const   *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  size_t tmp___52 ;
  char *tmp___53 ;
  size_t tmp___54 ;
  size_t tmp___55 ;
  char *tmp___56 ;
  int tmp___57 ;

  {
  {
#line 257
  accept___0[0] = (char )'A';
#line 257
  accept___0[1] = (char )'c';
#line 257
  accept___0[2] = (char )'c';
#line 257
  accept___0[3] = (char )'e';
#line 257
  accept___0[4] = (char )'p';
#line 257
  accept___0[5] = (char )'t';
#line 257
  accept___0[6] = (char )':';
#line 257
  accept___0[7] = (char )' ';
#line 257
  accept___0[8] = (char )'*';
#line 257
  accept___0[9] = (char )'/';
#line 257
  accept___0[10] = (char )'*';
#line 257
  accept___0[11] = (char )'\r';
#line 257
  accept___0[12] = (char )'\n';
#line 257
  accept___0[13] = (char )'\000';
#line 266
  memset((void *)(hoststr), '\000', sizeof(hoststr));
#line 267
  memset((void *)(cookie___0), '\000', sizeof(cookie___0));
#line 268
  memset((void *)(portstr), '\000', sizeof(portstr));
#line 269
  memset((void *)(protocol), '\000', sizeof(portstr));
#line 270
  memset((void *)(keepalive), '\000', sizeof(portstr));
#line 272
  tmp___4 = auth_get_proxy_required(my.auth);
  }
#line 272
  if (tmp___4) {
    {
#line 273
    tmp = url_get_request(U);
#line 273
    tmp___0 = url_get_port(U);
#line 273
    tmp___1 = url_get_hostname(U);
    }
#line 273
    if ((unsigned int )C->encrypt == 0U) {
#line 273
      tmp___2 = "http";
    } else {
#line 273
      tmp___2 = "https";
    }
    {
#line 273
    sprintf((char */* __restrict  */)(fullpath), (char const   */* __restrict  */)"%s://%s:%d%s",
            tmp___2, tmp___1, tmp___0, tmp);
    }
  } else {
    {
#line 279
    tmp___3 = url_get_request(U);
#line 279
    sprintf((char */* __restrict  */)(fullpath), (char const   */* __restrict  */)"%s",
            tmp___3);
    }
  }
  {
#line 282
  tmp___6 = url_get_port(U);
  }
#line 282
  if (tmp___6 == 80) {
#line 282
    if ((unsigned int )C->encrypt == 0U) {
#line 283
      portstr[0] = (char )'\000';
    } else {
#line 282
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 282
    tmp___7 = url_get_port(U);
    }
#line 282
    if (tmp___7 == 443) {
#line 282
      if ((unsigned int )C->encrypt == 1U) {
#line 283
        portstr[0] = (char )'\000';
      } else {
        {
#line 285
        tmp___5 = url_get_port(U);
#line 285
        snprintf((char */* __restrict  */)(portstr), sizeof(portstr), (char const   */* __restrict  */)":%d",
                 tmp___5);
        }
      }
    } else {
      {
#line 285
      tmp___5 = url_get_port(U);
#line 285
      snprintf((char */* __restrict  */)(portstr), sizeof(portstr), (char const   */* __restrict  */)":%d",
               tmp___5);
      }
    }
  }
#line 292
  if (my.protocol == 0) {
    {
#line 293
    snprintf((char */* __restrict  */)(protocol), sizeof(protocol), (char const   */* __restrict  */)"HTTP/1.0");
    }
  } else
#line 292
  if ((unsigned int )my.get == 1U) {
    {
#line 293
    snprintf((char */* __restrict  */)(protocol), sizeof(protocol), (char const   */* __restrict  */)"HTTP/1.0");
    }
  } else {
    {
#line 295
    snprintf((char */* __restrict  */)(protocol), sizeof(protocol), (char const   */* __restrict  */)"HTTP/1.1");
    }
  }
#line 297
  if (C->connection.keepalive == 1) {
    {
#line 298
    snprintf((char */* __restrict  */)(keepalive), sizeof(keepalive), (char const   */* __restrict  */)"keep-alive");
    }
  } else {
    {
#line 300
    snprintf((char */* __restrict  */)(keepalive), sizeof(keepalive), (char const   */* __restrict  */)"close");
    }
  }
  {
#line 303
  tmp___8 = url_get_hostname(U);
#line 303
  tmp___9 = pthread_self();
#line 303
  get_cookie_header(tmp___9, tmp___8, cookie___0);
  }
#line 304
  if (C->auth.www) {
#line 305
    if ((unsigned int )C->auth.type.www == 1U) {
      {
#line 306
      tmp___10 = url_get_method_name(U);
#line 306
      tmp___11 = auth_get_digest_header(my.auth, (SCHEME )1, C->auth.wchlg, C->auth.wcred,
                                        (char const   *)tmp___10, (char const   *)(fullpath));
#line 306
      snprintf((char */* __restrict  */)(authwww), sizeof(authwww), (char const   */* __restrict  */)"%s",
               tmp___11);
      }
    } else {
      {
#line 311
      tmp___12 = auth_get_basic_header(my.auth, (SCHEME )1);
#line 311
      snprintf((char */* __restrict  */)(authwww), sizeof(authwww), (char const   */* __restrict  */)"%s",
               tmp___12);
      }
    }
  }
#line 314
  if (C->auth.proxy) {
#line 315
    if ((unsigned int )C->auth.type.proxy == 1U) {
      {
#line 316
      tmp___13 = url_get_method_name(U);
#line 316
      tmp___14 = auth_get_digest_header(my.auth, (SCHEME )1, C->auth.wchlg, C->auth.wcred,
                                        (char const   *)tmp___13, (char const   *)(fullpath));
#line 316
      snprintf((char */* __restrict  */)(authwww), sizeof(authwww), (char const   */* __restrict  */)"%s",
               tmp___14);
      }
    } else {
      {
#line 321
      tmp___15 = auth_get_basic_header(my.auth, (SCHEME )4);
#line 321
      snprintf((char */* __restrict  */)(authpxy), sizeof(authpxy), (char const   */* __restrict  */)"%s",
               tmp___15);
      }
    }
  }
  {
#line 326
  tmp___18 = (char *)strncasestr((char const   *)(my.extra), "host:", sizeof(my.extra));
  }
#line 326
  if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
    {
#line 327
    tmp___16 = url_get_hostname(U);
#line 327
    tmp___17 = snprintf((char */* __restrict  */)(hoststr), sizeof(hoststr), (char const   */* __restrict  */)"Host: %s\r\n",
                        tmp___16);
#line 327
    rlen = (size_t )tmp___17;
    }
  }
  {
#line 330
  tmp___19 = url_get_method_name(U);
#line 330
  tmp___20 = strlen((char const   *)tmp___19);
#line 330
  tmp___21 = strlen((char const   *)(fullpath));
#line 330
  tmp___22 = strlen((char const   *)(protocol));
#line 330
  tmp___23 = strlen((char const   *)(hoststr));
  }
#line 330
  if (C->auth.www == 1) {
#line 330
    tmp___24 = (char const   *)(authwww);
  } else {
#line 330
    tmp___24 = "";
  }
  {
#line 330
  tmp___25 = strlen(tmp___24);
  }
#line 330
  if (C->auth.proxy == 1) {
#line 330
    tmp___26 = (char const   *)(authpxy);
  } else {
#line 330
    tmp___26 = "";
  }
  {
#line 330
  tmp___27 = strlen(tmp___26);
#line 330
  tmp___28 = strlen((char const   *)(cookie___0));
#line 330
  tmp___31 = strncasecmp((char const   *)(my.extra), "Accept:", (size_t )7);
  }
#line 330
  if (tmp___31 == 0) {
#line 330
    tmp___30 = "";
  } else {
#line 330
    tmp___30 = (char const   *)(accept___0);
  }
  {
#line 330
  tmp___32 = strlen(tmp___30);
#line 330
  tmp___33 = strlen((char const   *)(my.uagent));
#line 330
  tmp___34 = url_get_conttype(U);
#line 330
  tmp___35 = strlen((char const   *)tmp___34);
#line 330
  tmp___36 = strlen((char const   *)(my.extra));
#line 330
  tmp___37 = strlen((char const   *)(keepalive));
#line 330
  tmp___38 = url_get_postlen(U);
#line 330
  mlen = (((((((((((((tmp___20 + tmp___21) + tmp___22) + tmp___23) + tmp___25) + tmp___27) + tmp___28) + tmp___32) + sizeof(encoding)) + tmp___33) + tmp___35) + tmp___36) + tmp___37) + tmp___38) + 128UL;
#line 345
  tmp___39 = xmalloc(mlen);
#line 345
  request = (char *)tmp___39;
#line 346
  memset((void *)request, '\000', mlen);
#line 347
  memset((void *)(encoding), '\000', sizeof(encoding));
  }
#line 348
  if (! my.get) {
    {
#line 349
    snprintf((char */* __restrict  */)(encoding), sizeof(encoding), (char const   */* __restrict  */)"Accept-Encoding: %s\r\n",
             my.encoding);
    }
  }
  {
#line 356
  tmp___40 = url_get_postlen(U);
#line 356
  tmp___41 = url_get_conttype(U);
#line 356
  tmp___44 = strncasecmp((char const   *)(my.extra), "Accept:", (size_t )7);
  }
#line 356
  if (tmp___44 == 0) {
#line 356
    tmp___43 = "";
  } else {
#line 356
    tmp___43 = (char const   *)(accept___0);
  }
  {
#line 356
  tmp___47 = strlen((char const   *)(cookie___0));
  }
#line 356
  if (tmp___47 > 8UL) {
#line 356
    tmp___46 = (char const   *)(cookie___0);
  } else {
#line 356
    tmp___46 = "";
  }
#line 356
  if (C->auth.proxy == 1) {
#line 356
    tmp___48 = (char const   *)(authpxy);
  } else {
#line 356
    tmp___48 = "";
  }
#line 356
  if (C->auth.www == 1) {
#line 356
    tmp___49 = (char const   *)(authwww);
  } else {
#line 356
    tmp___49 = "";
  }
  {
#line 356
  tmp___50 = url_get_method_name(U);
#line 356
  tmp___51 = snprintf((char */* __restrict  */)request, mlen, (char const   */* __restrict  */)"%s %s %s\r\n%s%s%s%s%s%sUser-Agent: %s\r\n%sConnection: %s\r\nContent-type: %s\r\nContent-length: %ld\r\n\r\n",
                      tmp___50, fullpath, protocol, hoststr, tmp___49, tmp___48, tmp___46,
                      tmp___43, encoding, my.uagent, my.extra, keepalive, tmp___41,
                      (long )tmp___40);
#line 356
  rlen = (size_t )tmp___51;
  }
#line 377
  if (rlen < mlen) {
    {
#line 378
    tmp___52 = url_get_postlen(U);
#line 378
    tmp___53 = url_get_postdata(U);
#line 378
    memcpy((void */* __restrict  */)(request + rlen), (void const   */* __restrict  */)tmp___53,
           tmp___52);
#line 379
    tmp___54 = url_get_postlen(U);
#line 379
    *(request + (rlen + tmp___54)) = (char)0;
    }
  }
  {
#line 381
  tmp___55 = url_get_postlen(U);
#line 381
  rlen += tmp___55;
  }
#line 383
  if (my.get) {
    {
#line 383
    printf((char const   */* __restrict  */)"%s\n\n", request);
    }
  } else
#line 383
  if (my.debug) {
    {
#line 383
    printf((char const   */* __restrict  */)"%s\n\n", request);
    }
  }
#line 385
  if (rlen == 0UL) {
    {
#line 386
    tmp___56 = url_get_method_name(U);
#line 386
    NOTIFY((LEVEL )3, "HTTP %s: request buffer overrun! Unable to continue...", tmp___56);
    }
  } else
#line 385
  if (rlen > mlen) {
    {
#line 386
    tmp___56 = url_get_method_name(U);
#line 386
    NOTIFY((LEVEL )3, "HTTP %s: request buffer overrun! Unable to continue...", tmp___56);
    }
  }
  {
#line 389
  tmp___57 = socket_write(C, (void const   *)request, rlen);
  }
#line 389
  if (tmp___57 < 0) {
#line 390
    return ((BOOLEAN )0);
  }
  {
#line 393
  xfree((void *)request);
  }
#line 394
  return ((BOOLEAN )1);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
void http_free_headers(HEADERS *h ) 
{ 


  {
  {
#line 400
  xfree((void *)h->redirect);
#line 401
  xfree((void *)h->auth.realm.proxy);
#line 402
  xfree((void *)h->auth.realm.www);
#line 403
  xfree((void *)h);
  }
#line 404
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
HEADERS *http_read_headers(CONN *C , URL U ) 
{ 
  int x ;
  int n ;
  char c ;
  HEADERS *h ;
  char line[8192] ;
  void *tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  pthread_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *option ;
  char *value ;
  char *newline ;
  unsigned short const   **tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t len ;
  size_t tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  char *date ;
  size_t len___0 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  char *etag ;
  size_t len___1 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *option___0 ;
  char *value___0 ;
  char *newline___0 ;
  int tmp___28 ;
  unsigned short const   **tmp___29 ;
  char *tmp___30 ;
  unsigned short const   **tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  char *option___1 ;
  char *value___1 ;
  char *newline___1 ;
  int tmp___37 ;
  unsigned short const   **tmp___38 ;
  char *tmp___39 ;
  unsigned short const   **tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;

  {
  {
#line 420
  tmp = xcalloc(sizeof(HEADERS ), (size_t )1);
#line 420
  h = (HEADERS *)tmp;
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 423
    x = 0;
#line 424
    memset((void *)(& line), '\000', (size_t )8192);
    }
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 425
      tmp___0 = socket_read(C, (void *)(& c), (size_t )1);
#line 425
      n = (int )tmp___0;
      }
#line 425
      if (! (n == 1)) {
#line 425
        goto while_break___0;
      }
#line 426
      if (x < 8191) {
#line 427
        line[x] = c;
      } else {
#line 429
        line[x] = (char )'\n';
      }
      {
#line 430
      echo("%c", (int )c);
      }
#line 431
      if ((int )line[0] == 10) {
#line 432
        return (h);
      } else
#line 431
      if ((int )line[1] == 10) {
#line 432
        return (h);
      }
#line 434
      if ((int )line[x] == 10) {
#line 434
        goto while_break___0;
      }
#line 435
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 437
    line[x] = (char)0;
#line 439
    if (x > 0) {
#line 439
      if ((int )line[x - 1] == 13) {
#line 439
        line[x - 1] = (char)0;
      }
    }
    {
#line 440
    tmp___1 = strncasecmp((char const   *)(line), "http", (size_t )4);
    }
#line 440
    if (tmp___1 == 0) {
      {
#line 441
      strncpy((char */* __restrict  */)(h->head), (char const   */* __restrict  */)(line),
              (size_t )8);
#line 442
      h->code = atoi((char const   *)(line + 9));
      }
    }
    {
#line 444
    tmp___3 = strncasecmp((char const   *)(line), "content-length: ", (size_t )16);
    }
#line 444
    if (tmp___3 == 0) {
      {
#line 445
      tmp___2 = atoi((char const   *)(line + 16));
#line 445
      C->content.length = (size_t )tmp___2;
      }
    }
    {
#line 447
    tmp___7 = strncasecmp((char const   *)(line), "set-cookie: ", (size_t )12);
    }
#line 447
    if (tmp___7 == 0) {
#line 448
      if (my.cookies) {
        {
#line 449
        memset((void *)(h->cookie), '\000', sizeof(h->cookie));
#line 450
        tmp___4 = strlen((char const   *)(line));
#line 450
        strncpy((char */* __restrict  */)(h->cookie), (char const   */* __restrict  */)(line + 12),
                tmp___4);
#line 451
        tmp___5 = url_get_hostname(U);
#line 451
        tmp___6 = pthread_self();
#line 451
        add_cookie(tmp___6, tmp___5, h->cookie);
        }
      }
    }
    {
#line 454
    tmp___10 = strncasecmp((char const   *)(line), "connection: ", (size_t )12);
    }
#line 454
    if (tmp___10 == 0) {
      {
#line 455
      tmp___9 = strncasecmp((char const   *)(line + 12), "keep-alive", (size_t )10);
      }
#line 455
      if (tmp___9 == 0) {
#line 456
        h->keepalive = 1;
      } else {
        {
#line 457
        tmp___8 = strncasecmp((char const   *)(line + 12), "close", (size_t )5);
        }
#line 457
        if (tmp___8 == 0) {
#line 458
          h->keepalive = 0;
        }
      }
    }
    {
#line 461
    tmp___17 = strncasecmp((char const   *)(line), "keep-alive: ", (size_t )12);
    }
#line 461
    if (tmp___17 == 0) {
#line 462
      tmp___11 = (char *)"";
#line 463
      option = (char *)"";
#line 463
      value = (char *)"";
#line 464
      newline = line;
      {
#line 465
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 465
        tmp___11 = __parse_pair(& newline);
        }
#line 465
        if (! ((unsigned long )tmp___11 != (unsigned long )((void *)0))) {
#line 465
          goto while_break___1;
        }
#line 466
        option = tmp___11;
        {
#line 467
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 467
          if (*tmp___11) {
            {
#line 467
            tmp___12 = __ctype_b_loc();
            }
#line 467
            if ((int const   )*(*tmp___12 + (int )((unsigned char )((int )*tmp___11))) & 8192) {
#line 467
              goto while_break___2;
            } else
#line 467
            if (61 == (int )*tmp___11) {
#line 467
              goto while_break___2;
            } else
#line 467
            if (58 == (int )*tmp___11) {
#line 467
              goto while_break___2;
            }
          } else {
#line 467
            goto while_break___2;
          }
#line 468
          tmp___11 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 469
        tmp___13 = tmp___11;
#line 469
        tmp___11 ++;
#line 469
        *tmp___13 = (char)0;
        {
#line 470
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 470
          tmp___14 = __ctype_b_loc();
          }
#line 470
          if (! ((int const   )*(*tmp___14 + (int )((unsigned char )((int )*tmp___11))) & 8192)) {
#line 470
            if (! (61 == (int )*tmp___11)) {
#line 470
              if (! (58 == (int )*tmp___11)) {
#line 470
                goto while_break___3;
              }
            }
          }
#line 471
          tmp___11 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 472
        value = tmp___11;
        {
#line 473
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 473
          if (! *tmp___11) {
#line 473
            goto while_break___4;
          }
#line 474
          tmp___11 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 475
        tmp___15 = strncasecmp((char const   *)option, "timeout", (size_t )7);
        }
#line 475
        if (! tmp___15) {
#line 476
          if ((unsigned long )value != (unsigned long )((void *)0)) {
            {
#line 477
            C->connection.timeout = atoi((char const   *)value);
            }
          } else {
#line 479
            C->connection.timeout = 15;
          }
        }
        {
#line 482
        tmp___16 = strncasecmp((char const   *)option, "max", (size_t )3);
        }
#line 482
        if (! tmp___16) {
#line 483
          if ((unsigned long )value != (unsigned long )((void *)0)) {
            {
#line 484
            C->connection.max = atoi((char const   *)value);
            }
          } else {
#line 486
            C->connection.max = 0;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 491
    tmp___20 = strncasecmp((char const   *)(line), "location: ", (size_t )10);
    }
#line 491
    if (tmp___20 == 0) {
      {
#line 492
      tmp___18 = strlen((char const   *)(line));
#line 492
      len = tmp___18;
#line 493
      tmp___19 = xmalloc(len);
#line 493
      h->redirect = (char *)tmp___19;
#line 494
      memcpy((void */* __restrict  */)h->redirect, (void const   */* __restrict  */)(line + 10),
             len - 10UL);
#line 495
      *(h->redirect + (len - 10UL)) = (char)0;
      }
    }
    {
#line 497
    tmp___23 = strncasecmp((char const   *)(line), "last-modified: ", (size_t )15);
    }
#line 497
    if (tmp___23 == 0) {
      {
#line 499
      tmp___21 = strlen((char const   *)(line));
#line 499
      len___0 = tmp___21;
      }
#line 500
      if (my.cache) {
        {
#line 501
        tmp___22 = xmalloc(len___0);
#line 501
        date = (char *)tmp___22;
#line 502
        memcpy((void */* __restrict  */)date, (void const   */* __restrict  */)(line + 15),
               len___0 - 14UL);
#line 503
        url_set_last_modified(U, date);
#line 504
        xfree((void *)date);
        }
      }
    }
    {
#line 507
    tmp___26 = strncasecmp((char const   *)(line), "etag: ", (size_t )6);
    }
#line 507
    if (tmp___26 == 0) {
      {
#line 509
      tmp___24 = strlen((char const   *)(line));
#line 509
      len___1 = tmp___24;
      }
#line 510
      if (my.cache) {
        {
#line 511
        tmp___25 = xmalloc(len___1);
#line 511
        etag = (char *)tmp___25;
#line 512
        memcpy((void */* __restrict  */)etag, (void const   */* __restrict  */)(line + 6),
               len___1 - 5UL);
#line 513
        *(etag + (len___1 - 1UL)) = (char )'\000';
#line 514
        url_set_etag(U, etag);
#line 515
        xfree((void *)etag);
        }
      }
    }
    {
#line 518
    tmp___35 = strncasecmp((char const   *)(line), "www-authenticate: ", (size_t )18);
    }
#line 518
    if (tmp___35 == 0) {
      {
#line 519
      tmp___27 = (char *)"";
#line 520
      option___0 = (char *)"";
#line 520
      value___0 = (char *)"";
#line 521
      newline___0 = line;
#line 522
      tmp___28 = strncasecmp((char const   *)(line + 18), "digest", (size_t )6);
      }
#line 522
      if (tmp___28 == 0) {
        {
#line 523
        newline___0 += 24;
#line 524
        h->auth.type.www = (TYPE )1;
#line 525
        h->auth.challenge.www = xstrdup((char const   *)(line + 18));
        }
      } else {
#line 527
        newline___0 += 23;
#line 528
        h->auth.type.www = (TYPE )0;
      }
      {
#line 530
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 530
        tmp___27 = __parse_pair(& newline___0);
        }
#line 530
        if (! ((unsigned long )tmp___27 != (unsigned long )((void *)0))) {
#line 530
          goto while_break___5;
        }
#line 531
        option___0 = tmp___27;
        {
#line 532
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 532
          if (*tmp___27) {
            {
#line 532
            tmp___29 = __ctype_b_loc();
            }
#line 532
            if ((int const   )*(*tmp___29 + (int )((unsigned char )((int )*tmp___27))) & 8192) {
#line 532
              goto while_break___6;
            } else
#line 532
            if (61 == (int )*tmp___27) {
#line 532
              goto while_break___6;
            } else
#line 532
            if (58 == (int )*tmp___27) {
#line 532
              goto while_break___6;
            }
          } else {
#line 532
            goto while_break___6;
          }
#line 533
          tmp___27 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 534
        tmp___30 = tmp___27;
#line 534
        tmp___27 ++;
#line 534
        *tmp___30 = (char)0;
        {
#line 535
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 535
          tmp___31 = __ctype_b_loc();
          }
#line 535
          if (! ((int const   )*(*tmp___31 + (int )((unsigned char )((int )*tmp___27))) & 8192)) {
#line 535
            if (! (61 == (int )*tmp___27)) {
#line 535
              if (! (58 == (int )*tmp___27)) {
#line 535
                goto while_break___7;
              }
            }
          }
#line 536
          tmp___27 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 537
        value___0 = tmp___27;
        {
#line 538
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 538
          if (! *tmp___27) {
#line 538
            goto while_break___8;
          }
#line 539
          tmp___27 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 540
        tmp___34 = strncasecmp((char const   *)option___0, "realm", (size_t )5);
        }
#line 540
        if (! tmp___34) {
#line 541
          if ((unsigned long )value___0 != (unsigned long )((void *)0)) {
            {
#line 542
            tmp___32 = __dequote(value___0);
#line 542
            h->auth.realm.www = xstrdup((char const   *)tmp___32);
#line 543
            tmp___33 = __dequote(value___0);
#line 543
            url_set_realm(U, tmp___33);
            }
          } else {
            {
#line 545
            h->auth.realm.www = xstrdup("");
            }
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 550
    tmp___43 = strncasecmp((char const   *)(line), "proxy-authenticate: ", (size_t )20);
    }
#line 550
    if (tmp___43 == 0) {
      {
#line 551
      tmp___36 = (char *)"";
#line 552
      option___1 = (char *)"";
#line 552
      value___1 = (char *)"";
#line 553
      newline___1 = line;
#line 554
      tmp___37 = strncasecmp((char const   *)(line + 20), "digest", (size_t )6);
      }
#line 554
      if (tmp___37 == 0) {
        {
#line 555
        newline___1 += 26;
#line 556
        h->auth.type.proxy = (TYPE )1;
#line 557
        h->auth.challenge.proxy = xstrdup((char const   *)(line + 20));
        }
      } else {
#line 559
        newline___1 += 25;
#line 560
        h->auth.type.proxy = (TYPE )0;
      }
      {
#line 562
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 562
        tmp___36 = __parse_pair(& newline___1);
        }
#line 562
        if (! ((unsigned long )tmp___36 != (unsigned long )((void *)0))) {
#line 562
          goto while_break___9;
        }
#line 563
        option___1 = tmp___36;
        {
#line 564
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 564
          if (*tmp___36) {
            {
#line 564
            tmp___38 = __ctype_b_loc();
            }
#line 564
            if ((int const   )*(*tmp___38 + (int )((unsigned char )((int )*tmp___36))) & 8192) {
#line 564
              goto while_break___10;
            } else
#line 564
            if (61 == (int )*tmp___36) {
#line 564
              goto while_break___10;
            } else
#line 564
            if (58 == (int )*tmp___36) {
#line 564
              goto while_break___10;
            }
          } else {
#line 564
            goto while_break___10;
          }
#line 565
          tmp___36 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 566
        tmp___39 = tmp___36;
#line 566
        tmp___36 ++;
#line 566
        *tmp___39 = (char)0;
        {
#line 567
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 567
          tmp___40 = __ctype_b_loc();
          }
#line 567
          if (! ((int const   )*(*tmp___40 + (int )((unsigned char )((int )*tmp___36))) & 8192)) {
#line 567
            if (! (61 == (int )*tmp___36)) {
#line 567
              if (! (58 == (int )*tmp___36)) {
#line 567
                goto while_break___11;
              }
            }
          }
#line 568
          tmp___36 ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 569
        value___1 = tmp___36;
        {
#line 570
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 570
          if (! *tmp___36) {
#line 570
            goto while_break___12;
          }
#line 571
          tmp___36 ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 572
        tmp___42 = strncasecmp((char const   *)option___1, "realm", (size_t )5);
        }
#line 572
        if (! tmp___42) {
#line 573
          if ((unsigned long )value___1 != (unsigned long )((void *)0)) {
            {
#line 574
            tmp___41 = __dequote(value___1);
#line 574
            h->auth.realm.proxy = xstrdup((char const   *)tmp___41);
            }
          } else {
            {
#line 576
            h->auth.realm.proxy = xstrdup("");
            }
          }
        }
      }
      while_break___9: /* CIL Label */ ;
      }
    }
    {
#line 581
    tmp___46 = strncasecmp((char const   *)(line), "transfer-encoding: ", (size_t )19);
    }
#line 581
    if (tmp___46 == 0) {
      {
#line 582
      tmp___45 = strncasecmp((char const   *)(line + 20), "chunked", (size_t )7);
      }
#line 582
      if (tmp___45) {
#line 583
        C->content.transfer = (TE )1;
      } else {
        {
#line 584
        tmp___44 = strncasecmp((char const   *)(line + 20), "trailer", (size_t )7);
        }
#line 584
        if (tmp___44) {
#line 585
          C->content.transfer = (TE )2;
        } else {
#line 587
          C->content.transfer = (TE )0;
        }
      }
    }
    {
#line 590
    tmp___47 = strncasecmp((char const   *)(line), "expires: ", (size_t )9);
#line 593
    tmp___48 = strncasecmp((char const   *)(line), "cache-control: ", (size_t )15);
    }
#line 596
    if (n <= 0) {
      {
#line 597
      echo("read error: %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c",
           597);
#line 598
      http_free_headers(h);
      }
#line 599
      return ((HEADERS *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  return (h);
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
int http_chunk_size(CONN *C ) 
{ 
  int n ;
  char *end ;
  size_t length ;
  ssize_t tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 613
  memset((void *)(C->chkbuf), '\000', sizeof(C->chkbuf));
#line 614
  tmp = socket_readline(C, C->chkbuf, sizeof(C->chkbuf));
#line 614
  n = (int )tmp;
  }
#line 614
  if (n < 1) {
    {
#line 615
    NOTIFY((LEVEL )1, "HTTP: unable to determine chunk size");
    }
#line 616
    return (-1);
  }
#line 619
  if ((int )C->chkbuf[0] == 10) {
#line 620
    return (-1);
  } else {
    {
#line 619
    tmp___0 = strlen((char const   *)(C->chkbuf));
    }
#line 619
    if (tmp___0 == 0UL) {
#line 620
      return (-1);
    } else
#line 619
    if ((int )C->chkbuf[0] == 13) {
#line 620
      return (-1);
    }
  }
  {
#line 623
  tmp___1 = __errno_location();
#line 623
  *tmp___1 = 0;
#line 624
  tmp___2 = __ctype_b_loc();
  }
#line 624
  if (! ((int const   )*(*tmp___2 + (int )((unsigned int )C->chkbuf[0])) & 4096)) {
#line 625
    return (-1);
  }
  {
#line 626
  length = strtoul((char const   */* __restrict  */)(C->chkbuf), (char **/* __restrict  */)(& end),
                   16);
#line 627
  tmp___3 = __errno_location();
  }
#line 627
  if (*tmp___3 == 34) {
    {
#line 628
    NOTIFY((LEVEL )1, "HTTP: invalid chunk line %s\n", C->chkbuf);
    }
#line 629
    return (0);
  } else
#line 627
  if ((unsigned long )end == (unsigned long )(C->chkbuf)) {
    {
#line 628
    NOTIFY((LEVEL )1, "HTTP: invalid chunk line %s\n", C->chkbuf);
    }
#line 629
    return (0);
  } else {
#line 631
    return ((int )length);
  }
#line 633
  return (-1);
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
static char body[10240]  ;
#line 639 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
ssize_t http_read(CONN *C ) 
{ 
  int n ;
  char c ;
  int chunk ;
  size_t bytes ;
  size_t length ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  int tries ;
  int n___0 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 642
  n = 0;
#line 644
  chunk = 0;
#line 645
  bytes = (size_t )0;
#line 646
  length = (size_t )0;
#line 649
  if ((unsigned long )C == (unsigned long )((void *)0)) {
    {
#line 649
    NOTIFY((LEVEL )3, "Connection is NULL! Unable to proceed");
    }
  }
#line 651
  if (my.get) {
#line 651
    goto _L___0;
  } else
#line 651
  if (my.debug) {
    _L___0: /* CIL Label */ 
#line 653
    if (C->content.length > 0UL) {
#line 654
      if (C->content.length < 10240UL) {
#line 654
        length = C->content.length;
      } else {
#line 654
        length = (size_t )10240;
      }
      {
#line 655
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 656
        tmp = socket_read(C, (void *)(& c), (size_t )1);
#line 656
        n = (int )tmp;
        }
#line 656
        if (n == 0) {
#line 657
          goto while_break;
        }
        {
#line 658
        echo("%c", (int )c);
#line 659
        bytes += (size_t )n;
        }
#line 660
        if (C->content.length - bytes < 10240UL) {
#line 660
          length = C->content.length - bytes;
        } else {
#line 660
          length = (size_t )10240;
        }
#line 655
        if (! (bytes < C->content.length)) {
#line 655
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 663
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 667
        tmp___0 = socket_read(C, (void *)(& c), (size_t )1);
#line 667
        n = (int )tmp___0;
        }
#line 667
        if (n == 0) {
#line 668
          goto while_break___0;
        }
        {
#line 669
        echo("%c", (int )c);
#line 670
        bytes += (size_t )n;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 675
  if (C->content.length > 0UL) {
#line 676
    if (C->content.length < 10240UL) {
#line 676
      length = C->content.length;
    } else {
#line 676
      length = (size_t )10240;
    }
    {
#line 677
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 678
      memset((void *)(body), '\000', sizeof(body));
#line 679
      tmp___1 = socket_read(C, (void *)(body), length);
#line 679
      n = (int )tmp___1;
      }
#line 679
      if (n == 0) {
#line 680
        goto while_break___1;
      }
#line 681
      bytes += (size_t )n;
#line 682
      if (C->content.length - bytes < 10240UL) {
#line 682
        length = C->content.length - bytes;
      } else {
#line 682
        length = (size_t )10240;
      }
#line 677
      if (! (bytes < C->content.length)) {
#line 677
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 684
  if (my.chunked) {
#line 684
    if ((unsigned int )C->content.transfer == 1U) {
#line 685
      tries = 0;
      {
#line 686
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 686
        if (! (tries < 128)) {
#line 686
          goto while_break___2;
        }
        {
#line 687
        chunk = http_chunk_size(C);
        }
#line 688
        if (chunk == 0) {
#line 689
          goto while_break___2;
        } else
#line 690
        if (chunk < 0) {
#line 691
          tries ++;
#line 692
          goto while_continue___2;
        }
        {
#line 694
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 696
          memset((void *)(body), '\000', (size_t )10240);
          }
#line 697
          if (chunk > 10240) {
#line 697
            tmp___2 = 10240;
          } else {
#line 697
            tmp___2 = chunk;
          }
          {
#line 697
          tmp___3 = socket_read(C, (void *)(body), (size_t )tmp___2);
#line 697
          n___0 = (int )tmp___3;
#line 698
          chunk -= n___0;
#line 699
          bytes += (size_t )n___0;
          }
#line 694
          if (! (chunk > 0)) {
#line 694
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 684
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 703
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 704
      memset((void *)(body), '\000', sizeof(body));
#line 705
      tmp___4 = socket_read(C, (void *)(body), sizeof(body));
#line 705
      n = (int )tmp___4;
      }
#line 705
      if (n == 0) {
#line 706
        goto while_break___4;
      }
#line 707
      bytes += (size_t )n;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 713
  echo("\n");
  }
#line 715
  return ((ssize_t )bytes);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
static char *__parse_pair(char **str ) 
{ 
  int okay___0 ;
  char *p ;
  char *pair ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 729
  okay___0 = 0;
#line 730
  p = *str;
#line 731
  pair = (char *)((void *)0);
#line 733
  if (! str) {
#line 733
    return ((char *)((void *)0));
  } else
#line 733
  if (! *str) {
#line 733
    return ((char *)((void *)0));
  }
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    if (*p) {
#line 737
      if (! ((int )*p != 32)) {
#line 737
        goto while_break;
      }
    } else {
#line 737
      goto while_break;
    }
#line 738
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  tmp = p;
#line 739
  p ++;
#line 739
  *tmp = (char)0;
#line 740
  if (! *p) {
#line 741
    *str = p;
#line 742
    return ((char *)((void *)0));
  }
#line 745
  pair = p;
  {
#line 746
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 746
    if (*p) {
#line 746
      if ((int )*p != 59) {
#line 746
        if (! ((int )*p != 44)) {
#line 746
          goto while_break___0;
        }
      } else {
#line 746
        goto while_break___0;
      }
    } else {
#line 746
      goto while_break___0;
    }
#line 747
    if (! *p) {
#line 748
      *str = p;
#line 749
      return ((char *)((void *)0));
    }
#line 751
    if ((int )*p == 61) {
#line 751
      okay___0 = 1;
    }
#line 752
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 754
  tmp___0 = p;
#line 754
  p ++;
#line 754
  *tmp___0 = (char)0;
#line 755
  *str = p;
#line 757
  if (okay___0) {
#line 758
    return (pair);
  } else {
#line 760
    return ((char *)((void *)0));
  }
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
char *__rquote(char *str ) 
{ 
  char *ptr ;
  int len ;
  size_t tmp ;

  {
  {
#line 769
  tmp = strlen((char const   *)str);
#line 769
  len = (int )tmp;
#line 770
  ptr = (str + len) - 1;
  }
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if ((unsigned long )ptr >= (unsigned long )str) {
#line 770
      if (! ((int )*ptr == 34)) {
#line 770
        if (! ((int )*ptr == 39)) {
#line 770
          goto while_break;
        }
      }
    } else {
#line 770
      goto while_break;
    }
#line 770
    ptr --;
  }
  while_break: /* CIL Label */ ;
  }
#line 772
  *(ptr + 1) = (char )'\000';
#line 774
  return (str);
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
char *__lquote(char *str ) 
{ 
  char *ptr ;
  int len ;
  size_t tmp ;

  {
#line 783
  ptr = str;
  {
#line 783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 783
    if (*ptr) {
#line 783
      if (! ((int )*ptr == 34)) {
#line 783
        if (! ((int )*ptr == 39)) {
#line 783
          goto while_break;
        }
      }
    } else {
#line 783
      goto while_break;
    }
#line 783
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  tmp = strlen((char const   *)ptr);
#line 785
  len = (int )tmp;
#line 786
  memmove((void *)str, (void const   *)ptr, (size_t )(len + 1));
  }
#line 788
  return (str);
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/http.c"
static char *__dequote(char *str ) 
{ 
  char *ptr ;

  {
  {
#line 795
  ptr = __rquote(str);
#line 796
  str = __lquote(ptr);
  }
#line 797
  return (str);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/base64.h"
int base64_encode(void const   *data , int size , char **str ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/base64.c"
static char base64[65]  = 
#line 46 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/base64.c"
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'\000'};
#line 48 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/base64.c"
static int pos(char c ) 
{ 
  char *p ;

  {
#line 51
  p = base64;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! *p) {
#line 51
      goto while_break;
    }
#line 52
    if ((int )*p == (int )c) {
#line 53
      return ((int )(p - base64));
    }
#line 51
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return (-1);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/base64.c"
int base64_encode(void const   *data , int size , char **str ) 
{ 
  char *s ;
  char *p ;
  int i ;
  int c ;
  unsigned char const   *q ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 65
  tmp = malloc((size_t )((size * 4) / 3 + 4));
#line 65
  s = (char *)tmp;
#line 65
  p = s;
  }
#line 66
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 67
    return (-1);
  }
#line 68
  q = (unsigned char const   *)data;
#line 69
  i = 0;
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < size)) {
#line 70
      goto while_break;
    }
#line 71
    tmp___0 = i;
#line 71
    i ++;
#line 71
    c = (int )*(q + tmp___0);
#line 72
    c *= 256;
#line 73
    if (i < size) {
#line 74
      c += (int )*(q + i);
    }
#line 75
    i ++;
#line 76
    c *= 256;
#line 77
    if (i < size) {
#line 78
      c += (int )*(q + i);
    }
#line 79
    i ++;
#line 80
    *(p + 0) = base64[(c & 16515072) >> 18];
#line 81
    *(p + 1) = base64[(c & 258048) >> 12];
#line 82
    *(p + 2) = base64[(c & 4032) >> 6];
#line 83
    *(p + 3) = base64[c & 63];
#line 84
    if (i > size) {
#line 85
      *(p + 3) = (char )'=';
    }
#line 86
    if (i > size + 1) {
#line 87
      *(p + 2) = (char )'=';
    }
#line 88
    p += 4;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  *p = (char)0;
#line 91
  *str = s;
#line 92
  tmp___1 = strlen((char const   *)s);
  }
#line 92
  return ((int )tmp___1);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/base64.c"
int base64_decode(char const   *str , void *data ) 
{ 
  char const   *p ;
  unsigned char *q ;
  int c ;
  int x ;
  int done ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 102
  done = 0;
#line 103
  q = (unsigned char *)data;
#line 104
  p = str;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (*p) {
#line 104
      if (! (! done)) {
#line 104
        goto while_break;
      }
    } else {
#line 104
      goto while_break;
    }
    {
#line 105
    x = pos((char )*(p + 0));
    }
#line 106
    if (x >= 0) {
#line 107
      c = x;
    } else {
#line 109
      done = 3;
#line 110
      goto while_break;
    }
    {
#line 112
    c *= 64;
#line 114
    x = pos((char )*(p + 1));
    }
#line 115
    if (x >= 0) {
#line 116
      c += x;
    } else {
#line 118
      return (-1);
    }
#line 119
    c *= 64;
#line 121
    if ((int const   )*(p + 2) == 61) {
#line 122
      done ++;
    } else {
      {
#line 124
      x = pos((char )*(p + 2));
      }
#line 125
      if (x >= 0) {
#line 126
        c += x;
      } else {
#line 128
        return (-1);
      }
    }
#line 130
    c *= 64;
#line 132
    if ((int const   )*(p + 3) == 61) {
#line 133
      done ++;
    } else {
#line 135
      if (done) {
#line 136
        return (-1);
      }
      {
#line 137
      x = pos((char )*(p + 3));
      }
#line 138
      if (x >= 0) {
#line 139
        c += x;
      } else {
#line 141
        return (-1);
      }
    }
#line 143
    if (done < 3) {
#line 144
      tmp = q;
#line 144
      q ++;
#line 144
      *tmp = (unsigned char )((c & 16711680) >> 16);
    }
#line 146
    if (done < 2) {
#line 147
      tmp___0 = q;
#line 147
      q ++;
#line 147
      *tmp___0 = (unsigned char )((c & 65280) >> 8);
    }
#line 148
    if (done < 1) {
#line 149
      tmp___1 = q;
#line 149
      q ++;
#line 149
      *tmp___1 = (unsigned char )(c & 255);
    }
#line 104
    p += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return ((int )(q - (unsigned char *)data));
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 517 "/usr/include/pthread.h"
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 521
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 529
extern void pthread_testcancel(void) ;
#line 691
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 703
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 744
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 754
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 48 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer ) ;
#line 68 "./url.h"
URL new_url(char *str ) ;
#line 69
URL url_destroy(URL this ) ;
#line 72
void url_set_ID(URL this , int ID ) ;
#line 73
void url_set_hostname(URL this , char *hostname ) ;
#line 76
void url_set_conttype(URL this , char *type ) ;
#line 77
void url_set_postdata(URL this , char *postdata , size_t postlen ) ;
#line 78
void url_set_method(URL this , METHOD method ) ;
#line 80
int url_get_ID(URL this ) ;
#line 81
METHOD url_get_method(URL this ) ;
#line 85
char *url_get_absolute(URL this ) ;
#line 88
SCHEME url_get_scheme(URL this ) ;
#line 89
char *url_get_scheme_name(URL this ) ;
#line 92
char *url_get_username(URL this ) ;
#line 95
char *url_get_password(URL this ) ;
#line 125
char *url_get_display(URL this ) ;
#line 139
void url_set_username(URL this , char *username ) ;
#line 140
void url_set_password(URL this , char *password ) ;
#line 42 "./auth.h"
BOOLEAN auth_set_basic_header(AUTH this , SCHEME scheme , char *realm ) ;
#line 44
BOOLEAN auth_set_digest_header(AUTH this , DCHLG **chlg , DCRED **cred , size_t *rand___0 ,
                               char *realm , char *str ) ;
#line 47
char *auth_get_proxy_host(AUTH this ) ;
#line 49
int auth_get_proxy_port(AUTH this ) ;
#line 51
char *auth_get_ftp_username(AUTH this , char *realm ) ;
#line 52
char *auth_get_ftp_password(AUTH this , char *realm ) ;
#line 36 "./array.h"
void *array_get(ARRAY this , int index___0 ) ;
#line 51 "../include/joedog/joedog.h"
void DISPLAY(int color , char const   *fmt  , ...) ;
#line 70
float elapsed_time(clock_t time___0 ) ;
#line 138
int empty(char const   *s ) ;
#line 83 "./client.h"
void *start_routine(CLIENT *client ) ;
#line 135 "./sock.h"
int new_socket(CONN *C , char const   *hostparam , int portparam ) ;
#line 140
void socket_close(CONN *C ) ;
#line 52 "./ssl.h"
BOOLEAN SSL_initialize(CONN *C ) ;
#line 29 "./ftp.h"
BOOLEAN ftp_login(CONN *C , URL U ) ;
#line 32
BOOLEAN ftp_size(CONN *C , URL U ) ;
#line 34
BOOLEAN ftp_pasv(CONN *C ) ;
#line 36
BOOLEAN ftp_stor(CONN *C , URL U ) ;
#line 37
BOOLEAN ftp_retr(CONN *C , URL U ) ;
#line 38
size_t ftp_get(CONN *D , URL U , size_t size ) ;
#line 39
size_t ftp_put(CONN *D , URL U ) ;
#line 40
BOOLEAN ftp_quit(CONN *C ) ;
#line 62 "./cookie.h"
int delete_all_cookies(pthread_t id ) ;
#line 29 "./util.h"
void pthread_sleep_np(unsigned int secs ) ;
#line 31
int pthread_rand_np(unsigned int *ctx ) ;
#line 36
void debug(char const   *fmt  , ...) ;
#line 31 "./date.h"
char *timestamp(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
static BOOLEAN __request(CONN *C , URL U , CLIENT *client ) ;
#line 46
static BOOLEAN __http(CONN *C , URL U , CLIENT *client ) ;
#line 47
static BOOLEAN __ftp(CONN *C , URL U , CLIENT *client ) ;
#line 48
static BOOLEAN __init_connection(CONN *C , URL U , CLIENT *client ) ;
#line 49
static void __increment_failures(void) ;
#line 50
static int __select_color(int code ) ;
#line 51
static URL __normalize(URL req , char *location ) ;
#line 58
void clean_up(void) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
float himark  =    (float )0;
#line 68 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
float lomark  =    (float )-1;
#line 82 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
void *start_routine(CLIENT *client ) 
{ 
  int x ;
  int y ;
  int ret ;
  CONN *C ;
  int type ;
  int state ;
  void *tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  URL tmp___2 ;
  void *tmp___3 ;
  URL tmp___4 ;
  int tmp___5 ;
  pthread_t tmp___6 ;
  URL tmp___7 ;
  void *tmp___8 ;
  BOOLEAN tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 87
  C = (CONN *)((void *)0);
#line 94
  tmp = xcalloc(sizeof(CONN ), (size_t )1);
#line 94
  C = (CONN *)tmp;
#line 95
  C->sock = -1;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    __cancel_routine = (void (*)(void * ))((void *)(& clean_up));
#line 106
    __cancel_arg = (void *)C;
#line 106
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
#line 106
    __not_first_call = tmp___0;
#line 106
    tmp___1 = __builtin_expect((long )__not_first_call, 0L);
    }
#line 106
    if (tmp___1) {
      {
#line 106
      (*__cancel_routine)(__cancel_arg);
#line 106
      __pthread_unwind_next(& __cancel_buf);
      }
    }
    {
#line 106
    __pthread_register_cancel(& __cancel_buf);
    }
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 119
      pthread_setcanceltype(1, & type);
#line 121
      pthread_setcancelstate(0, & state);
      }
#line 123
      if ((unsigned int )my.login == 1U) {
        {
#line 124
        tmp___3 = array_get(my.lurl, 0);
#line 124
        tmp___4 = new_url((char *)tmp___3);
#line 124
        tmp___2 = tmp___4;
#line 125
        url_set_ID(tmp___2, 0);
#line 126
        __request(C, tmp___2, client);
        }
      }
#line 130
      y = client->id * (my.length / my.cusers);
#line 131
      x = 0;
      {
#line 131
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 131
        if (! (x < my.reps)) {
#line 131
          goto while_break___1;
        }
#line 132
        if (my.secs > 0) {
#line 132
          if (my.reps <= 0) {
#line 132
            x = 0;
          } else
#line 132
          if (my.reps == 10301062) {
#line 132
            x = 0;
          } else {
#line 132
            x = x;
          }
        } else {
#line 132
          x = x;
        }
#line 133
        if ((unsigned int )my.internet == 1U) {
          {
#line 134
          tmp___5 = pthread_rand_np(& client->rand_r_SEED);
#line 134
          y = (int )((unsigned int )(((double )tmp___5 / ((double )2147483647 + (double )1)) * (double )my.length + .5));
          }
#line 136
          if (y >= my.length) {
#line 136
            y = my.length - 1;
          } else {
#line 136
            y = y;
          }
#line 137
          if (y < 0) {
#line 137
            y = 0;
          } else {
#line 137
            y = y;
          }
        } else
#line 144
        if (y >= my.length) {
#line 145
          y = 0;
#line 146
          if (my.expire) {
            {
#line 147
            tmp___6 = pthread_self();
#line 147
            delete_all_cookies(tmp___6);
            }
          }
        }
#line 151
        if (y >= my.length) {
          {
#line 152
          printf((char const   */* __restrict  */)"y out of bounds: %d >= %d", y,
                 my.length);
#line 153
          y = 0;
          }
        } else
#line 151
        if (y < 0) {
          {
#line 152
          printf((char const   */* __restrict  */)"y out of bounds: %d >= %d", y,
                 my.length);
#line 153
          y = 0;
          }
        }
        {
#line 155
        tmp___8 = array_get(client->urls, y);
#line 155
        tmp___7 = (URL )tmp___8;
        }
#line 156
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
          {
#line 156
          tmp___10 = url_get_hostname(tmp___7);
          }
#line 156
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
            {
#line 157
            client->auth.bids.www = 0;
#line 158
            tmp___9 = __request(C, tmp___7, client);
#line 158
            ret = (int )tmp___9;
            }
#line 158
            if (ret == 0) {
              {
#line 159
              __increment_failures();
              }
            }
          }
        }
#line 163
        if (my.failures > 0) {
#line 163
          if (my.failed >= my.failures) {
#line 164
            goto while_break___1;
          }
        }
#line 131
        x ++;
#line 131
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 173
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 173
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 106
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 173
    __pthread_unregister_cancel(& __cancel_buf);
    }
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  if (C->sock >= 0) {
    {
#line 176
    C->connection.reuse = 0;
#line 177
    socket_close(C);
    }
  }
  {
#line 179
  xfree((void *)C);
#line 180
  C = (CONN *)((void *)0);
  }
#line 182
  return ((void *)0);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
static BOOLEAN __request(CONN *C , URL U , CLIENT *client ) 
{ 
  BOOLEAN tmp ;
  BOOLEAN tmp___0 ;

  {
  {
#line 187
  C->scheme = url_get_scheme(U);
  }
  {
#line 190
  if ((unsigned int )C->scheme == 3U) {
#line 190
    goto case_3;
  }
#line 194
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 191
  tmp = __ftp(C, U, client);
  }
#line 191
  return (tmp);
  switch_default: /* CIL Label */ 
  {
#line 195
  tmp___0 = __http(C, U, client);
  }
#line 195
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
static BOOLEAN __http(CONN *C , URL U , CLIENT *client ) 
{ 
  unsigned long bytes ;
  int code ;
  int fail ;
  float etime ;
  clock_t start ;
  clock_t stop ;
  struct tms t_start ;
  struct tms t_stop ;
  HEADERS *head ;
  struct tm keepsake ;
  time_t now ;
  struct tm *tmp ;
  size_t len ;
  char fmtime[65] ;
  URL redirect_url ;
  struct tm *tmp___0 ;
  SCHEME tmp___1 ;
  int tmp___2 ;
  BOOLEAN tmp___3 ;
  BOOLEAN tmp___4 ;
  BOOLEAN tmp___5 ;
  METHOD tmp___6 ;
  METHOD tmp___7 ;
  ssize_t tmp___8 ;
  int color ;
  int tmp___9 ;
  char *time_str ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  METHOD tmp___28 ;
  size_t tmp___29 ;
  char *tmp___30 ;
  METHOD tmp___31 ;
  BOOLEAN tmp___32 ;
  BOOLEAN b ;
  BOOLEAN tmp___33 ;
  int tmp___34 ;
  BOOLEAN b___0 ;
  BOOLEAN tmp___35 ;
  int tmp___36 ;

  {
#line 208
  bytes = 0UL;
#line 221
  redirect_url = (URL )((void *)0);
#line 223
  if (my.csv) {
    {
#line 224
    now = time((time_t *)((void *)0));
#line 226
    tmp___0 = localtime_r((time_t const   */* __restrict  */)(& now), (struct tm */* __restrict  */)(& keepsake));
#line 226
    tmp = tmp___0;
    }
#line 230
    if (tmp) {
      {
#line 230
      len = strftime((char */* __restrict  */)(fmtime), (size_t )64, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
                     (struct tm  const  */* __restrict  */)tmp);
      }
    } else {
      {
#line 231
      snprintf((char */* __restrict  */)(fmtime), (size_t )64, (char const   */* __restrict  */)"n/a");
      }
    }
  }
  {
#line 234
  tmp___1 = url_get_scheme(U);
  }
#line 234
  if ((unsigned int )tmp___1 == 0U) {
#line 235
    if (my.verbose) {
#line 235
      if (! my.get) {
        {
#line 236
        NOTIFY((LEVEL )2, "%s %d %6.2f secs: %7d bytes ==> %s\n", "UNSPPRTD", 501,
               0.00, 0, "PROTOCOL NOT SUPPORTED BY SIEGE");
        }
      }
    }
#line 242
    return ((BOOLEAN )0);
  }
#line 245
  if (my.delay) {
    {
#line 246
    tmp___2 = pthread_rand_np(& client->rand_r_SEED);
#line 246
    pthread_sleep_np((unsigned int )(((double )tmp___2 / ((double )2147483647 + (double )1)) * (double )my.delay + .5));
    }
  }
  {
#line 253
  start = times(& t_start);
#line 255
  tmp___3 = __init_connection(C, U, client);
  }
#line 255
  if (! tmp___3) {
#line 255
    return ((BOOLEAN )0);
  }
  {
#line 260
  tmp___6 = url_get_method(U);
  }
#line 260
  if ((unsigned int )tmp___6 == 2U) {
#line 260
    goto _L;
  } else {
    {
#line 260
    tmp___7 = url_get_method(U);
    }
#line 260
    if ((unsigned int )tmp___7 == 1U) {
      _L: /* CIL Label */ 
      {
#line 261
      tmp___4 = http_get(C, U);
      }
#line 261
      if ((unsigned int )tmp___4 == 0U) {
        {
#line 262
        C->connection.reuse = 0;
#line 263
        socket_close(C);
        }
#line 264
        return ((BOOLEAN )0);
      }
    } else {
      {
#line 267
      tmp___5 = http_post(C, U);
      }
#line 267
      if ((unsigned int )tmp___5 == 0U) {
        {
#line 268
        C->connection.reuse = 0;
#line 269
        socket_close(C);
        }
#line 270
        return ((BOOLEAN )0);
      }
    }
  }
  {
#line 277
  head = http_read_headers(C, U);
  }
#line 277
  if ((unsigned long )head == (unsigned long )((void *)0)) {
    {
#line 278
    C->connection.reuse = 0;
#line 279
    socket_close(C);
#line 280
    echo("%s:%d NULL headers", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
         280);
    }
#line 281
    return ((BOOLEAN )0);
  }
  {
#line 284
  tmp___8 = http_read(C);
#line 284
  bytes = (unsigned long )tmp___8;
  }
#line 286
  if (! my.zero_ok) {
#line 286
    if (bytes < 1UL) {
      {
#line 287
      C->connection.reuse = 0;
#line 288
      socket_close(C);
#line 289
      http_free_headers(head);
#line 290
      echo("%s:%d zero bytes back from server", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
           290);
      }
#line 291
      return ((BOOLEAN )0);
    }
  }
  {
#line 293
  stop = times(& t_stop);
#line 294
  etime = elapsed_time(stop - start);
  }
#line 295
  if (head->code < 400) {
#line 295
    code = 1;
  } else
#line 295
  if (head->code == 401) {
#line 295
    code = 1;
  } else
#line 295
  if (head->code == 407) {
#line 295
    code = 1;
  } else {
#line 295
    code = 0;
  }
#line 296
  if (head->code >= 400) {
#line 296
    if (head->code != 401) {
#line 296
      if (head->code != 407) {
#line 296
        fail = 1;
      } else {
#line 296
        fail = 0;
      }
    } else {
#line 296
      fail = 0;
    }
  } else {
#line 296
    fail = 0;
  }
#line 300
  client->bytes += bytes;
#line 301
  client->time += etime;
#line 302
  client->code += (unsigned int )code;
#line 303
  client->fail += (unsigned int )fail;
#line 304
  if (head->code == 200) {
#line 305
    (client->ok200) ++;
  }
#line 311
  if (etime > himark) {
#line 312
    himark = etime;
  }
#line 314
  if (lomark < (float )0) {
#line 315
    lomark = etime;
  } else
#line 314
  if (etime < lomark) {
#line 315
    lomark = etime;
  }
#line 317
  client->himark = himark;
#line 318
  client->lomark = lomark;
#line 323
  if (my.verbose) {
#line 323
    if (! my.get) {
#line 323
      if (! my.debug) {
        {
#line 324
        tmp___9 = __select_color(head->code);
#line 324
        color = tmp___9;
        }
#line 325
        if ((unsigned int )my.timestamp == 1U) {
          {
#line 325
          tmp___10 = timestamp();
#line 325
          tmp___11 = (char const   *)tmp___10;
          }
        } else {
#line 325
          tmp___11 = "";
        }
#line 325
        time_str = (char *)tmp___11;
#line 326
        if (my.csv) {
#line 327
          if (my.display) {
            {
#line 328
            tmp___12 = url_get_ID(U);
#line 328
            tmp___13 = url_get_display(U);
            }
#line 328
            if (my.mark) {
#line 328
              tmp___14 = ",";
            } else {
#line 328
              tmp___14 = "";
            }
#line 328
            if (my.mark) {
#line 328
              tmp___15 = (char const   *)my.markstr;
            } else {
#line 328
              tmp___15 = "";
            }
            {
#line 328
            DISPLAY(color, "%s%s%s%4d,%s,%d,%6.2f,%7lu,%s,%d,%s", time_str, tmp___15,
                    tmp___14, client->id, head->head, head->code, (double )etime,
                    bytes, tmp___13, tmp___12, fmtime);
            }
          } else {
            {
#line 333
            tmp___16 = url_get_ID(U);
#line 333
            tmp___17 = url_get_display(U);
            }
#line 333
            if (my.mark) {
#line 333
              tmp___18 = ",";
            } else {
#line 333
              tmp___18 = "";
            }
#line 333
            if (my.mark) {
#line 333
              tmp___19 = (char const   *)my.markstr;
            } else {
#line 333
              tmp___19 = "";
            }
            {
#line 333
            DISPLAY(color, "%s%s%s%s,%d,%6.2f,%7lu,%s,%d,%s", time_str, tmp___19,
                    tmp___18, head->head, head->code, (double )etime, bytes, tmp___17,
                    tmp___16, fmtime);
            }
          }
        } else
#line 338
        if (my.display) {
          {
#line 339
          tmp___20 = url_get_display(U);
#line 339
          tmp___21 = url_get_method_name(U);
#line 339
          DISPLAY(color, "%s%4d: %s %d %6.2f secs: %7lu bytes ==> %-4s %s", client->id,
                  time_str, head->head, head->code, (double )etime, bytes, tmp___21,
                  tmp___20);
          }
        } else {
          {
#line 345
          tmp___22 = url_get_display(U);
#line 345
          tmp___23 = url_get_method_name(U);
#line 345
          DISPLAY(color, "%s%s %d %6.2f secs: %7lu bytes ==> %-4s %s", time_str, head->head,
                  head->code, (double )etime, bytes, tmp___23, tmp___22);
          }
        }
#line 351
        if (my.timestamp) {
          {
#line 351
          xfree((void *)time_str);
          }
        }
      }
    }
  }
#line 357
  if (! my.keepalive) {
    {
#line 358
    socket_close(C);
    }
  }
  {
#line 367
  if (head->code == 307) {
#line 367
    goto case_307;
  }
#line 367
  if (head->code == 302) {
#line 367
    goto case_307;
  }
#line 367
  if (head->code == 301) {
#line 367
    goto case_307;
  }
#line 395
  if (head->code == 401) {
#line 395
    goto case_401;
  }
#line 423
  if (head->code == 407) {
#line 423
    goto case_407;
  }
#line 459
  if (head->code == 509) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 508) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 507) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 506) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 505) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 504) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 503) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 502) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 501) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 500) {
#line 459
    goto case_509;
  }
#line 459
  if (head->code == 408) {
#line 459
    goto case_509;
  }
#line 461
  goto switch_default;
  case_307: /* CIL Label */ 
  case_302: /* CIL Label */ 
  case_301: /* CIL Label */ 
#line 368
  if (my.follow) {
#line 368
    if (*(head->redirect + 0)) {
      {
#line 375
      redirect_url = __normalize(U, head->redirect);
#line 377
      tmp___25 = url_get_hostname(redirect_url);
#line 377
      tmp___26 = empty((char const   *)tmp___25);
      }
#line 377
      if (tmp___26) {
        {
#line 378
        tmp___24 = url_get_hostname(U);
#line 378
        url_set_hostname(redirect_url, tmp___24);
        }
      }
#line 380
      if (head->code == 307) {
        {
#line 381
        tmp___27 = url_get_conttype(U);
#line 381
        url_set_conttype(redirect_url, tmp___27);
#line 382
        tmp___28 = url_get_method(U);
#line 382
        url_set_method(redirect_url, tmp___28);
#line 384
        tmp___31 = url_get_method(redirect_url);
        }
#line 384
        if ((unsigned int )tmp___31 == 3U) {
          {
#line 385
          tmp___29 = url_get_postlen(U);
#line 385
          tmp___30 = url_get_postdata(U);
#line 385
          url_set_postdata(redirect_url, tmp___30, tmp___29);
          }
        }
      }
      {
#line 388
      tmp___32 = __request(C, redirect_url, client);
      }
#line 388
      if ((unsigned int )tmp___32 == 0U) {
        {
#line 389
        redirect_url = url_destroy(redirect_url);
        }
#line 390
        return ((BOOLEAN )0);
      }
    }
  }
  {
#line 393
  redirect_url = url_destroy(redirect_url);
  }
#line 394
  goto switch_break;
  case_401: /* CIL Label */ 
#line 399
  if (client->auth.www == 0) {
#line 399
    client->auth.www = 1;
  } else {
#line 399
    client->auth.www = client->auth.www;
  }
#line 400
  tmp___34 = client->auth.bids.www;
#line 400
  (client->auth.bids.www) ++;
#line 400
  if (tmp___34 < my.bids - 1) {
#line 402
    if ((unsigned int )head->auth.type.www == 1U) {
      {
#line 403
      client->auth.type.www = (TYPE )1;
#line 404
      b = auth_set_digest_header(my.auth, & client->auth.wchlg, & client->auth.wcred,
                                 (size_t *)(& client->rand_r_SEED), head->auth.realm.www,
                                 head->auth.challenge.www);
      }
#line 408
      if ((unsigned int )b == 0U) {
        {
#line 409
        NOTIFY((LEVEL )2, "unable to set digest header");
        }
#line 410
        return ((BOOLEAN )0);
      }
    }
#line 413
    if ((unsigned int )head->auth.type.www == 0U) {
      {
#line 414
      client->auth.type.www = (TYPE )0;
#line 415
      auth_set_basic_header(my.auth, (SCHEME )1, head->auth.realm.www);
      }
    }
    {
#line 417
    tmp___33 = __request(C, U, client);
    }
#line 417
    if ((unsigned int )tmp___33 == 0U) {
      {
#line 418
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR from http_request\n");
      }
#line 419
      return ((BOOLEAN )0);
    }
  }
#line 422
  goto switch_break;
  case_407: /* CIL Label */ 
#line 427
  if (client->auth.proxy == 0) {
#line 427
    client->auth.proxy = 1;
  } else {
#line 427
    client->auth.proxy = client->auth.proxy;
  }
#line 428
  tmp___36 = client->auth.bids.proxy;
#line 428
  (client->auth.bids.proxy) ++;
#line 428
  if (tmp___36 < my.bids - 1) {
#line 429
    if ((unsigned int )head->auth.type.proxy == 1U) {
      {
#line 431
      client->auth.type.proxy = (TYPE )1;
#line 432
      b___0 = auth_set_digest_header(my.auth, & client->auth.pchlg, & client->auth.pcred,
                                     (size_t *)(& client->rand_r_SEED), head->auth.realm.proxy,
                                     head->auth.challenge.proxy);
      }
#line 436
      if ((unsigned int )b___0 == 0U) {
        {
#line 437
        NOTIFY((LEVEL )2, "unable to set digest header");
        }
#line 438
        return ((BOOLEAN )0);
      }
    }
#line 441
    if ((unsigned int )head->auth.type.proxy == 0U) {
      {
#line 442
      client->auth.type.proxy = (TYPE )0;
#line 443
      auth_set_basic_header(my.auth, (SCHEME )4, head->auth.realm.proxy);
      }
    }
    {
#line 445
    tmp___35 = __request(C, U, client);
    }
#line 445
    if ((unsigned int )tmp___35 == 0U) {
#line 446
      return ((BOOLEAN )0);
    }
  }
#line 448
  goto switch_break;
  case_509: /* CIL Label */ 
  case_508: /* CIL Label */ 
  case_507: /* CIL Label */ 
  case_506: /* CIL Label */ 
  case_505: /* CIL Label */ 
  case_504: /* CIL Label */ 
  case_503: /* CIL Label */ 
  case_502: /* CIL Label */ 
  case_501: /* CIL Label */ 
  case_500: /* CIL Label */ 
  case_408: /* CIL Label */ 
#line 460
  return ((BOOLEAN )0);
  switch_default: /* CIL Label */ 
#line 462
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 465
  (client->hits) ++;
#line 466
  http_free_headers(head);
  }
#line 468
  return ((BOOLEAN )1);
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
static BOOLEAN __ftp(CONN *C , URL U , CLIENT *client ) 
{ 
  int pass ;
  int fail ;
  int code ;
  float etime ;
  CONN *D ;
  size_t bytes ;
  clock_t start ;
  clock_t stop ;
  struct tms t_start ;
  struct tms t_stop ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  BOOLEAN tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int color ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  BOOLEAN tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  BOOLEAN tmp___22 ;
  BOOLEAN tmp___23 ;
  METHOD tmp___24 ;
  METHOD tmp___25 ;
  int color___0 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;

  {
  {
#line 482
  code = 0;
#line 484
  D = (CONN *)((void *)0);
#line 485
  bytes = (size_t )0;
#line 489
  tmp = xcalloc(sizeof(CONN ), (size_t )1);
#line 489
  D = (CONN *)tmp;
#line 490
  D->sock = -1;
#line 492
  tmp___2 = __init_connection(C, U, client);
  }
#line 492
  if (! tmp___2) {
    {
#line 493
    tmp___0 = url_get_port(U);
#line 493
    tmp___1 = url_get_hostname(U);
#line 493
    NOTIFY((LEVEL )2, "%s:%d connection failed %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
           495, tmp___1, tmp___0);
#line 497
    xfree((void *)D);
    }
#line 498
    return ((BOOLEAN )0);
  }
  {
#line 501
  start = times(& t_start);
  }
#line 502
  if (C->sock < 0) {
    {
#line 503
    tmp___3 = url_get_port(U);
#line 503
    tmp___4 = url_get_hostname(U);
#line 503
    NOTIFY((LEVEL )2, "%s:%d connection failed %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
           505, tmp___4, tmp___3);
#line 507
    socket_close(C);
#line 508
    xfree((void *)D);
    }
#line 509
    return ((BOOLEAN )0);
  }
  {
#line 512
  tmp___7 = url_get_username(U);
  }
#line 512
  if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
    {
#line 513
    tmp___5 = url_get_hostname(U);
#line 513
    tmp___6 = auth_get_ftp_username(my.auth, tmp___5);
#line 513
    url_set_username(U, tmp___6);
    }
  } else {
    {
#line 512
    tmp___8 = url_get_username(U);
#line 512
    tmp___9 = strlen((char const   *)tmp___8);
    }
#line 512
    if (tmp___9 < 1UL) {
      {
#line 513
      tmp___5 = url_get_hostname(U);
#line 513
      tmp___6 = auth_get_ftp_username(my.auth, tmp___5);
#line 513
      url_set_username(U, tmp___6);
      }
    }
  }
  {
#line 516
  tmp___12 = url_get_password(U);
  }
#line 516
  if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
    {
#line 517
    tmp___10 = url_get_hostname(U);
#line 517
    tmp___11 = auth_get_ftp_password(my.auth, tmp___10);
#line 517
    url_set_password(U, tmp___11);
    }
  } else {
    {
#line 516
    tmp___13 = url_get_password(U);
#line 516
    tmp___14 = strlen((char const   *)tmp___13);
    }
#line 516
    if (tmp___14 < 1UL) {
      {
#line 517
      tmp___10 = url_get_hostname(U);
#line 517
      tmp___11 = auth_get_ftp_password(my.auth, tmp___10);
#line 517
      url_set_password(U, tmp___11);
      }
    }
  }
  {
#line 520
  tmp___18 = ftp_login(C, U);
  }
#line 520
  if ((unsigned int )tmp___18 == 0U) {
#line 521
    if (my.verbose) {
      {
#line 522
      tmp___15 = __select_color(C->ftp.code);
#line 522
      color = tmp___15;
#line 523
      tmp___16 = url_get_request(U);
#line 523
      tmp___17 = url_get_method_name(U);
#line 523
      DISPLAY(color, "FTP/%d %6.2f secs: %7lu bytes ==> %-6s %s", C->ftp.code, 0.0,
              bytes, tmp___17, tmp___16);
      }
    }
    {
#line 528
    xfree((void *)D);
#line 529
    (client->fail) ++;
    }
#line 530
    return ((BOOLEAN )0);
  }
  {
#line 533
  ftp_pasv(C);
  }
#line 534
  if ((unsigned int )C->ftp.pasv == 1U) {
    {
#line 535
    debug("Connecting to: %s:%d", C->ftp.host, C->ftp.port);
#line 536
    D->sock = new_socket(D, (char const   *)(C->ftp.host), C->ftp.port);
    }
#line 537
    if (D->sock < 0) {
      {
#line 538
      tmp___19 = __errno_location();
#line 538
      tmp___20 = strerror(*tmp___19);
#line 538
      tmp___21 = __errno_location();
#line 538
      debug("%s:%d connection failed. error %d(%s)", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
            539, *tmp___21, tmp___20);
#line 541
      (client->fail) ++;
#line 542
      socket_close(D);
#line 543
      xfree((void *)D);
      }
#line 544
      return ((BOOLEAN )0);
    }
  }
  {
#line 547
  tmp___24 = url_get_method(U);
  }
#line 547
  if ((unsigned int )tmp___24 == 3U) {
    {
#line 548
    ftp_stor(C, U);
#line 549
    bytes = ftp_put(D, U);
#line 550
    code = C->ftp.code;
    }
  } else {
    {
#line 547
    tmp___25 = url_get_method(U);
    }
#line 547
    if ((unsigned int )tmp___25 == 4U) {
      {
#line 548
      ftp_stor(C, U);
#line 549
      bytes = ftp_put(D, U);
#line 550
      code = C->ftp.code;
      }
    } else {
      {
#line 552
      tmp___23 = ftp_size(C, U);
      }
#line 552
      if ((unsigned int )tmp___23 == 1U) {
        {
#line 553
        tmp___22 = ftp_retr(C, U);
        }
#line 553
        if ((unsigned int )tmp___22 == 1U) {
          {
#line 554
          bytes = ftp_get(D, U, C->ftp.size);
          }
        }
      }
#line 557
      code = C->ftp.code;
    }
  }
  {
#line 559
  socket_close(D);
#line 560
  ftp_quit(C);
  }
#line 562
  if (bytes == C->ftp.size) {
#line 562
    pass = 1;
  } else {
#line 562
    pass = 0;
  }
#line 563
  if (pass == 0) {
#line 563
    fail = 1;
  } else {
#line 563
    fail = 0;
  }
  {
#line 564
  stop = times(& t_stop);
#line 565
  etime = elapsed_time(stop - start);
#line 566
  client->bytes += bytes;
#line 567
  client->time += etime;
#line 568
  client->code += (unsigned int )pass;
#line 569
  client->fail += (unsigned int )fail;
  }
#line 574
  if (etime > himark) {
#line 575
    himark = etime;
  }
#line 577
  if (lomark < (float )0) {
#line 578
    lomark = etime;
  } else
#line 577
  if (etime < lomark) {
#line 578
    lomark = etime;
  }
#line 580
  client->himark = himark;
#line 581
  client->lomark = lomark;
#line 583
  if (my.verbose) {
    {
#line 584
    tmp___26 = __select_color(code);
#line 584
    color___0 = tmp___26;
#line 585
    tmp___27 = url_get_request(U);
#line 585
    tmp___28 = url_get_method_name(U);
#line 585
    DISPLAY(color___0, "FTP/%d %6.2f secs: %7lu bytes ==> %-6s %s", code, (double )etime,
            bytes, tmp___28, tmp___27);
    }
  }
  {
#line 590
  (client->hits) ++;
#line 591
  xfree((void *)D);
  }
#line 592
  return ((BOOLEAN )1);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
void clean_up(void) 
{ 


  {
#line 617
  return;
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
static BOOLEAN __init_connection(CONN *C , URL U , CLIENT *client ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  BOOLEAN tmp___3 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  BOOLEAN tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  BOOLEAN tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  BOOLEAN tmp___25 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  BOOLEAN tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  BOOLEAN tmp___33 ;
  BOOLEAN tmp___34 ;

  {
#line 624
  C->pos_ini = 0;
#line 625
  C->inbuffer = (size_t )0;
#line 626
  C->content.transfer = (TE )0;
#line 627
  C->content.length = (size_t )0;
#line 628
  if (C->connection.max == 1) {
#line 628
    C->connection.keepalive = 0;
  } else {
#line 628
    C->connection.keepalive = (int )my.keepalive;
  }
#line 629
  if (C->connection.max == 1) {
#line 629
    C->connection.reuse = 0;
  } else {
#line 629
    C->connection.reuse = (int )my.keepalive;
  }
#line 630
  if (C->connection.tested == 0) {
#line 630
    C->connection.tested = 1;
  } else {
#line 630
    C->connection.tested = C->connection.tested;
  }
  {
#line 631
  C->auth.www = client->auth.www;
#line 632
  C->auth.wchlg = client->auth.wchlg;
#line 633
  C->auth.wcred = client->auth.wcred;
#line 634
  C->auth.proxy = client->auth.proxy;
#line 635
  C->auth.pchlg = client->auth.pchlg;
#line 636
  C->auth.pcred = client->auth.pcred;
#line 637
  C->auth.type.www = client->auth.type.www;
#line 638
  C->auth.type.proxy = client->auth.type.proxy;
#line 639
  memset((void *)(C->buffer), 0, sizeof(C->buffer));
#line 641
  tmp___3 = auth_get_proxy_required(my.auth);
  }
#line 641
  if (tmp___3) {
    {
#line 641
    tmp___0 = auth_get_proxy_port(my.auth);
#line 641
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 641
    tmp___1 = url_get_port(U);
#line 641
    tmp___2 = tmp___1;
    }
  }
  {
#line 641
  tmp___8 = auth_get_proxy_required(my.auth);
  }
#line 641
  if (tmp___8) {
    {
#line 641
    tmp___5 = auth_get_proxy_host(my.auth);
#line 641
    tmp___7 = tmp___5;
    }
  } else {
    {
#line 641
    tmp___6 = url_get_hostname(U);
#line 641
    tmp___7 = tmp___6;
    }
  }
  {
#line 641
  debug("%s:%d attempting connection to %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
        643, tmp___7, tmp___2);
  }
#line 648
  if (! C->connection.reuse) {
#line 648
    goto _L;
  } else
#line 648
  if (C->connection.status == 0) {
    _L: /* CIL Label */ 
    {
#line 649
    tmp___17 = auth_get_proxy_required(my.auth);
    }
#line 649
    if (tmp___17) {
      {
#line 650
      tmp___9 = auth_get_proxy_port(my.auth);
#line 650
      tmp___10 = auth_get_proxy_host(my.auth);
#line 650
      debug("%s:%d creating new socket:     %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
            652, tmp___10, tmp___9);
#line 654
      tmp___11 = auth_get_proxy_port(my.auth);
#line 654
      tmp___12 = auth_get_proxy_host(my.auth);
#line 654
      C->sock = new_socket(C, (char const   *)tmp___12, tmp___11);
      }
    } else {
      {
#line 656
      tmp___13 = url_get_port(U);
#line 656
      tmp___14 = url_get_hostname(U);
#line 656
      debug("%s:%d creating new socket:     %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
            658, tmp___14, tmp___13);
#line 660
      tmp___15 = url_get_port(U);
#line 660
      tmp___16 = url_get_hostname(U);
#line 660
      C->sock = new_socket(C, (char const   *)tmp___16, tmp___15);
      }
    }
  }
#line 664
  if (my.keepalive) {
#line 665
    C->connection.reuse = 1;
  }
#line 668
  if (C->sock < 0) {
    {
#line 669
    tmp___18 = __errno_location();
#line 669
    tmp___19 = strerror(*tmp___18);
#line 669
    tmp___20 = __errno_location();
#line 669
    debug("%s:%d connection failed. error %d(%s)", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
          670, *tmp___20, tmp___19);
#line 672
    socket_close(C);
    }
#line 673
    return ((BOOLEAN )0);
  }
  {
#line 676
  tmp___25 = auth_get_proxy_required(my.auth);
  }
#line 676
  if (tmp___25) {
    {
#line 676
    tmp___22 = auth_get_proxy_port(my.auth);
#line 676
    tmp___24 = tmp___22;
    }
  } else {
    {
#line 676
    tmp___23 = url_get_port(U);
#line 676
    tmp___24 = tmp___23;
    }
  }
  {
#line 676
  tmp___30 = auth_get_proxy_required(my.auth);
  }
#line 676
  if (tmp___30) {
    {
#line 676
    tmp___27 = auth_get_proxy_host(my.auth);
#line 676
    tmp___29 = tmp___27;
    }
  } else {
    {
#line 676
    tmp___28 = url_get_hostname(U);
#line 676
    tmp___29 = tmp___28;
    }
  }
  {
#line 676
  debug("%s:%d good socket connection:  %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c",
        678, tmp___29, tmp___24);
  }
#line 683
  if ((unsigned int )C->encrypt == 1U) {
    {
#line 684
    tmp___33 = auth_get_proxy_required(my.auth);
    }
#line 684
    if (tmp___33) {
      {
#line 685
      tmp___31 = url_get_port(U);
#line 685
      tmp___32 = url_get_hostname(U);
#line 685
      https_tunnel_request(C, tmp___32, tmp___31);
#line 686
      https_tunnel_response(C);
      }
    }
    {
#line 688
    C->encrypt = (BOOLEAN )1;
#line 689
    tmp___34 = SSL_initialize(C);
    }
#line 689
    if ((unsigned int )tmp___34 == 0U) {
#line 690
      return ((BOOLEAN )0);
    }
  }
#line 693
  return ((BOOLEAN )1);
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
static void __increment_failures(void) 
{ 


  {
  {
#line 699
  pthread_mutex_lock(& my.lock);
#line 700
  (my.failed) ++;
#line 701
  pthread_mutex_unlock(& my.lock);
#line 702
  pthread_testcancel();
  }
#line 703
  return;
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
static int __select_color(int code ) 
{ 


  {
  {
#line 718
  if (code == 226) {
#line 718
    goto case_226;
  }
#line 718
  if (code == 206) {
#line 718
    goto case_226;
  }
#line 718
  if (code == 205) {
#line 718
    goto case_226;
  }
#line 718
  if (code == 204) {
#line 718
    goto case_226;
  }
#line 718
  if (code == 203) {
#line 718
    goto case_226;
  }
#line 718
  if (code == 202) {
#line 718
    goto case_226;
  }
#line 718
  if (code == 201) {
#line 718
    goto case_226;
  }
#line 718
  if (code == 200) {
#line 718
    goto case_226;
  }
#line 718
  if (code == 150) {
#line 718
    goto case_226;
  }
#line 727
  if (code == 307) {
#line 727
    goto case_307;
  }
#line 727
  if (code == 306) {
#line 727
    goto case_307;
  }
#line 727
  if (code == 305) {
#line 727
    goto case_307;
  }
#line 727
  if (code == 304) {
#line 727
    goto case_307;
  }
#line 727
  if (code == 303) {
#line 727
    goto case_307;
  }
#line 727
  if (code == 302) {
#line 727
    goto case_307;
  }
#line 727
  if (code == 301) {
#line 727
    goto case_307;
  }
#line 727
  if (code == 300) {
#line 727
    goto case_307;
  }
#line 746
  if (code == 417) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 416) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 415) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 414) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 413) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 412) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 411) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 410) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 409) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 408) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 407) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 406) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 405) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 404) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 403) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 402) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 401) {
#line 746
    goto case_417;
  }
#line 746
  if (code == 400) {
#line 746
    goto case_417;
  }
#line 754
  goto switch_default;
  case_226: /* CIL Label */ 
  case_206: /* CIL Label */ 
  case_205: /* CIL Label */ 
  case_204: /* CIL Label */ 
  case_203: /* CIL Label */ 
  case_202: /* CIL Label */ 
  case_201: /* CIL Label */ 
  case_200: /* CIL Label */ 
  case_150: /* CIL Label */ 
#line 719
  return (4);
  case_307: /* CIL Label */ 
  case_306: /* CIL Label */ 
  case_305: /* CIL Label */ 
  case_304: /* CIL Label */ 
  case_303: /* CIL Label */ 
  case_302: /* CIL Label */ 
  case_301: /* CIL Label */ 
  case_300: /* CIL Label */ 
#line 728
  return (6);
  case_417: /* CIL Label */ 
  case_416: /* CIL Label */ 
  case_415: /* CIL Label */ 
  case_414: /* CIL Label */ 
  case_413: /* CIL Label */ 
  case_412: /* CIL Label */ 
  case_411: /* CIL Label */ 
  case_410: /* CIL Label */ 
  case_409: /* CIL Label */ 
  case_408: /* CIL Label */ 
  case_407: /* CIL Label */ 
  case_406: /* CIL Label */ 
  case_405: /* CIL Label */ 
  case_404: /* CIL Label */ 
  case_403: /* CIL Label */ 
  case_402: /* CIL Label */ 
  case_401: /* CIL Label */ 
  case_400: /* CIL Label */ 
#line 747
  return (5);
  switch_default: /* CIL Label */ 
#line 755
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 757
  return (1);
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/client.c"
static URL __normalize(URL req , char *location ) 
{ 
  URL ret ;
  char *url ;
  size_t len ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 765
  tmp = url_get_absolute(req);
#line 765
  tmp___0 = strlen((char const   *)tmp);
#line 765
  tmp___1 = strlen((char const   *)location);
#line 765
  len = (tmp___0 + tmp___1) + 32UL;
#line 766
  tmp___4 = strchr((char const   *)location, ':');
  }
#line 766
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
#line 768
    ret = new_url(location);
#line 770
    tmp___2 = url_get_hostname(ret);
#line 770
    tmp___3 = strchr((char const   *)tmp___2, '.');
    }
#line 770
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 771
      return (ret);
    }
  }
  {
#line 774
  tmp___7 = strchr((char const   *)location, '.');
  }
#line 774
  if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
    {
#line 776
    ret = new_url(location);
#line 778
    tmp___5 = url_get_hostname(ret);
#line 778
    tmp___6 = strchr((char const   *)tmp___5, '.');
    }
#line 778
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 779
      return (ret);
    }
  }
  {
#line 787
  tmp___8 = malloc(len);
#line 787
  url = (char *)tmp___8;
#line 788
  memset((void *)url, '\000', len);
  }
#line 790
  if ((int )*(location + 0) == 47) {
    {
#line 791
    tmp___9 = url_get_port(req);
#line 791
    tmp___10 = url_get_hostname(req);
#line 791
    tmp___11 = url_get_scheme_name(req);
#line 791
    snprintf((char */* __restrict  */)url, len, (char const   */* __restrict  */)"%s://%s:%d%s",
             tmp___11, tmp___10, tmp___9, location);
    }
  } else {
    {
#line 793
    tmp___12 = url_get_port(req);
#line 793
    tmp___13 = url_get_hostname(req);
#line 793
    tmp___14 = url_get_scheme_name(req);
#line 793
    snprintf((char */* __restrict  */)url, len, (char const   */* __restrict  */)"%s://%s:%d/%s",
             tmp___14, tmp___13, tmp___12, location);
    }
  }
  {
#line 795
  ret = new_url(url);
#line 796
  free((void *)url);
  }
#line 797
  return (ret);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 28 "./date.h"
time_t adjust(time_t tvalue , int secs ) ;
#line 29
time_t strtotime(char const   *string ) ;
#line 30
char *timetostr(time_t const   *T ) ;
#line 33 "./util.h"
BOOLEAN strmatch(char *option , char *param ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
char const   * const  wday[7]  = {      (char const   */* const  */)"Mon",      (char const   */* const  */)"Tue",      (char const   */* const  */)"Wed",      (char const   */* const  */)"Thu", 
        (char const   */* const  */)"Fri",      (char const   */* const  */)"Sat",      (char const   */* const  */)"Sun"};
#line 59 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
char const   * const  weekday[7]  = {      (char const   */* const  */)"Sunday",      (char const   */* const  */)"Monday",      (char const   */* const  */)"Tuesday",      (char const   */* const  */)"Wednesday", 
        (char const   */* const  */)"Thursday",      (char const   */* const  */)"Friday",      (char const   */* const  */)"Saturday"};
#line 63 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
char const   * const  month[12]  = 
#line 63
  {      (char const   */* const  */)"Jan",      (char const   */* const  */)"Feb",      (char const   */* const  */)"Mar",      (char const   */* const  */)"Apr", 
        (char const   */* const  */)"May",      (char const   */* const  */)"Jun",      (char const   */* const  */)"Jul",      (char const   */* const  */)"Aug", 
        (char const   */* const  */)"Sep",      (char const   */* const  */)"Oct",      (char const   */* const  */)"Nov",      (char const   */* const  */)"Dec"};
#line 73 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
static struct tzinfo  const  tz[43]  = 
#line 73
  {      {"GMT", 0}, 
        {"UTC", 0}, 
        {"WET", 0}, 
        {"BST", -60}, 
        {"WAT", 60}, 
        {"AST", 240}, 
        {"ADT", 180}, 
        {"EST", 300}, 
        {"EDT", 240}, 
        {"CST", 360}, 
        {"CDT", 300}, 
        {"MST", 420}, 
        {"MDT", 360}, 
        {"PST", 480}, 
        {"PDT", 420}, 
        {"YST", 540}, 
        {"YDT", 480}, 
        {"HST", 600}, 
        {"HDT", 540}, 
        {"CAT", 600}, 
        {"AHST", 600}, 
        {"NT", 660}, 
        {"IDLW", 720}, 
        {"CET", -60}, 
        {"MET", -60}, 
        {"MEWT", -60}, 
        {"MEST", -120}, 
        {"CEST", -120}, 
        {"MESZ", -120}, 
        {"FWT", -60}, 
        {"FST", -120}, 
        {"EET", -120}, 
        {"WAST", -420}, 
        {"WADT", -480}, 
        {"CCT", -480}, 
        {"JST", -540}, 
        {"EAST", -600}, 
        {"EADT", -660}, 
        {"GST", -600}, 
        {"NZT", -720}, 
        {"NZST", -720}, 
        {"NZDT", -780}, 
        {"IDLE", -720}};
#line 119 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
char *timetostr(time_t const   *T ) 
{ 
  char *line ;
  struct tm *tm ;
  void *tmp ;

  {
  {
#line 125
  tm = gmtime(T);
#line 126
  tmp = xmalloc((size_t )64);
#line 126
  line = (char *)tmp;
#line 128
  snprintf((char */* __restrict  */)line, (size_t )64, (char const   */* __restrict  */)"If-Modified-Since: %s, %d %s %d %d:%d:%d GMT\r\n",
           wday[tm->tm_wday], tm->tm_mday, month[tm->tm_mon], tm->tm_year, tm->tm_hour,
           tm->tm_min, tm->tm_sec);
  }
#line 140
  return (line);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
char *timestamp(void) 
{ 
  char *line ;
  time_t ltime ;
  struct tm *tm ;
  void *tmp ;

  {
  {
#line 150
  ltime = time((time_t *)((void *)0));
#line 151
  tm = localtime((time_t const   *)(& ltime));
#line 152
  tmp = xmalloc((size_t )64);
#line 152
  line = (char *)tmp;
#line 154
  strftime((char */* __restrict  */)line, (size_t )64, (char const   */* __restrict  */)"[%a, %F %T] ",
           (struct tm  const  */* __restrict  */)tm);
  }
#line 155
  return (line);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
time_t adjust(time_t tvalue , int secs ) 
{ 
  struct tm *tp ;
  time_t ret ;

  {
#line 164
  ret = (time_t )(tvalue != -1L);
#line 164
  if (ret) {
    {
#line 165
    tp = localtime((time_t const   *)(& tvalue));
    }
#line 166
    if (secs > 2147483647 - tp->tm_sec) {
#line 167
      ret = (time_t )-1;
    } else {
      {
#line 169
      tp->tm_sec += secs;
#line 170
      ret = mktime(tp);
      }
    }
  }
#line 173
  return (ret);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
static int checkday(char *check , size_t len ) 
{ 
  int i ;
  char const   * const  *what ;
  BOOLEAN found ;
  BOOLEAN tmp ;
  int tmp___0 ;

  {
#line 184
  found = (BOOLEAN )0;
#line 185
  if (len > 3UL) {
#line 186
    what = & weekday[0];
  } else {
#line 188
    what = & wday[0];
  }
#line 189
  i = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (i < 7)) {
#line 189
      goto while_break;
    }
    {
#line 190
    tmp = strmatch(check, (char *)*(what + 0));
    }
#line 190
    if (tmp) {
#line 191
      found = (BOOLEAN )1;
#line 192
      goto while_break;
    }
#line 194
    what ++;
#line 189
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if (found) {
#line 196
    tmp___0 = i;
  } else {
#line 196
    tmp___0 = -1;
  }
#line 196
  return (tmp___0);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
static int checkmonth(char *check ) 
{ 
  int i ;
  char const   * const  *what ;
  BOOLEAN found ;
  BOOLEAN tmp ;
  int tmp___0 ;

  {
#line 207
  found = (BOOLEAN )0;
#line 209
  what = & month[0];
#line 210
  i = 0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < 12)) {
#line 210
      goto while_break;
    }
    {
#line 211
    tmp = strmatch(check, (char *)*(what + 0));
    }
#line 211
    if (tmp) {
#line 212
      found = (BOOLEAN )1;
#line 213
      goto while_break;
    }
#line 215
    what ++;
#line 210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  if (found) {
#line 217
    tmp___0 = i;
  } else {
#line 217
    tmp___0 = -1;
  }
#line 217
  return (tmp___0);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
static int checktz(char *check ) 
{ 
  unsigned int i ;
  struct tzinfo  const  *what ;
  BOOLEAN found ;
  BOOLEAN tmp ;
  int tmp___0 ;

  {
#line 228
  found = (BOOLEAN )0;
#line 230
  what = tz;
#line 231
  i = 0U;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! ((unsigned long )i < sizeof(tz) / sizeof(tz[0]))) {
#line 231
      goto while_break;
    }
    {
#line 232
    tmp = strmatch(check, (char *)what->name);
    }
#line 232
    if (tmp) {
#line 233
      found = (BOOLEAN )1;
#line 234
      goto while_break;
    }
#line 236
    what ++;
#line 231
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  if (found) {
#line 238
    tmp___0 = what->offset * 60;
  } else {
#line 238
    tmp___0 = (int const   )-1;
  }
#line 238
  return ((int )tmp___0);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
static void skip(char const   **date ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (*(*date)) {
      {
#line 246
      tmp = __ctype_b_loc();
      }
#line 246
      if ((int const   )*(*tmp + (int )((unsigned char )*(*date))) & 8) {
#line 246
        goto while_break;
      }
    } else {
#line 246
      goto while_break;
    }
#line 247
    (*date) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/date.c"
time_t strtotime(char const   *string ) 
{ 
  int sec ;
  int min ;
  int hour ;
  int mday ;
  int mon ;
  int year ;
  int wday___0 ;
  int tzoff ;
  int part ;
  time_t t ;
  time_t now ;
  struct tm tm ;
  char const   *date ;
  char const   *indate ;
  enum assume dignext ;
  BOOLEAN found ;
  char buf[32] ;
  unsigned int tmp ;
  size_t len ;
  int val ;
  char *end ;
  long tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  struct tm *gmt ;
  long delta ;
  time_t t2 ;
  struct tm gmt2 ;
  int tmp___4 ;

  {
#line 252
  sec = -1;
#line 253
  min = -1;
#line 254
  hour = -1;
#line 255
  mday = -1;
#line 256
  mon = -1;
#line 257
  year = -1;
#line 258
  wday___0 = -1;
#line 259
  tzoff = -1;
#line 260
  part = 0;
#line 261
  t = (time_t )0;
#line 262
  now = (time_t )0;
#line 265
  indate = string;
#line 266
  dignext = (enum assume )0;
#line 267
  found = (BOOLEAN )0;
#line 272
  if (string) {
#line 272
    if (! *string) {
#line 273
      return ((time_t )0);
    }
  } else {
#line 273
    return ((time_t )0);
  }
#line 275
  date = string;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (*date) {
#line 283
      if (! (part < 6)) {
#line 283
        goto while_break;
      }
    } else {
#line 283
      goto while_break;
    }
    {
#line 284
    found = (BOOLEAN )0;
#line 286
    skip(& date);
#line 288
    tmp___3 = __ctype_b_loc();
    }
#line 288
    if ((int const   )*(*tmp___3 + (int )((unsigned char )*date)) & 1024) {
#line 290
      buf[0] = (char )'\000';
#line 290
      tmp = 1U;
      {
#line 290
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 290
        if (tmp >= 32U) {
#line 290
          goto while_break___0;
        }
#line 290
        buf[tmp] = (char)0;
#line 290
        tmp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 292
      sscanf((char const   */* __restrict  */)date, (char const   */* __restrict  */)"%31[A-Za-z]",
             buf);
#line 293
      len = strlen((char const   *)(buf));
      }
#line 295
      if (wday___0 == -1) {
        {
#line 296
        wday___0 = checkday(buf, len);
        }
#line 297
        if (wday___0 != -1) {
#line 298
          found = (BOOLEAN )1;
        }
      }
#line 300
      if (! found) {
#line 300
        if (mon == -1) {
          {
#line 301
          mon = checkmonth(buf);
          }
#line 302
          if (mon != -1) {
#line 303
            found = (BOOLEAN )1;
          }
        }
      }
#line 306
      if (! found) {
#line 306
        if (tzoff == -1) {
          {
#line 308
          tzoff = checktz(buf);
          }
#line 309
          if (tzoff != -1) {
#line 310
            found = (BOOLEAN )1;
          }
        }
      }
#line 313
      if (! found) {
#line 314
        return ((time_t )-1);
      }
#line 316
      date += len;
    } else {
      {
#line 317
      tmp___2 = __ctype_b_loc();
      }
#line 317
      if ((int const   )*(*tmp___2 + (int )((unsigned char )*date)) & 2048) {
#line 321
        if (sec == -1) {
          {
#line 321
          tmp___1 = sscanf((char const   */* __restrict  */)date, (char const   */* __restrict  */)"%02d:%02d:%02d",
                           & hour, & min, & sec);
          }
#line 321
          if (3 == tmp___1) {
#line 324
            date += 8;
#line 325
            found = (BOOLEAN )1;
          } else {
#line 321
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 328
          tmp___0 = strtol((char const   */* __restrict  */)date, (char **/* __restrict  */)(& end),
                           10);
#line 328
          val = (int )tmp___0;
          }
#line 330
          if (tzoff == -1) {
#line 330
            if (end - (char *)date == 4L) {
#line 330
              if (val < 1300) {
#line 330
                if ((unsigned long )indate < (unsigned long )date) {
#line 330
                  if ((int const   )*(date + -1) == 43) {
#line 330
                    goto _L;
                  } else
#line 330
                  if ((int const   )*(date + -1) == 45) {
                    _L: /* CIL Label */ 
#line 337
                    found = (BOOLEAN )1;
#line 338
                    tzoff = ((val / 100) * 60 + val % 100) * 60;
#line 342
                    if ((int const   )*(date + -1) == 43) {
#line 342
                      tzoff = - tzoff;
                    } else {
#line 342
                      tzoff = tzoff;
                    }
                  }
                }
              }
            }
          }
#line 345
          if (end - (char *)date == 8L) {
#line 345
            if (year == -1) {
#line 345
              if (mon == -1) {
#line 345
                if (mday == -1) {
#line 347
                  found = (BOOLEAN )1;
#line 348
                  year = val / 10000;
#line 349
                  mon = (val % 10000) / 100 - 1;
#line 350
                  mday = val % 100;
                }
              }
            }
          }
#line 353
          if (! found) {
#line 353
            if ((unsigned int )dignext == 0U) {
#line 353
              if (mday == -1) {
#line 354
                if (val > 0) {
#line 354
                  if (val < 32) {
#line 355
                    mday = val;
#line 356
                    found = (BOOLEAN )1;
                  }
                }
#line 358
                dignext = (enum assume )1;
              }
            }
          }
#line 361
          if (! found) {
#line 361
            if ((unsigned int )dignext == 1U) {
#line 361
              if (year == -1) {
#line 362
                year = val;
#line 363
                found = (BOOLEAN )1;
#line 364
                if (year < 1900) {
#line 365
                  if (year > 70) {
#line 366
                    year += 1900;
                  } else {
#line 368
                    year += 2000;
                  }
                }
#line 370
                if (mday == -1) {
#line 371
                  dignext = (enum assume )0;
                }
              }
            }
          }
#line 374
          if (! found) {
#line 375
            return ((time_t )-1);
          }
#line 377
          date = (char const   *)end;
        }
      }
    }
#line 380
    part ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  if (-1 == sec) {
#line 384
    hour = 0;
#line 384
    min = hour;
#line 384
    sec = min;
  }
#line 386
  if (-1 == mday) {
#line 390
    return ((time_t )-1);
  } else
#line 386
  if (-1 == mon) {
#line 390
    return ((time_t )-1);
  } else
#line 386
  if (-1 == year) {
#line 390
    return ((time_t )-1);
  }
#line 393
  if (year > 2037) {
#line 394
    return ((time_t )2147483647);
  }
  {
#line 396
  tm.tm_sec = sec;
#line 397
  tm.tm_min = min;
#line 398
  tm.tm_hour = hour;
#line 399
  tm.tm_mday = mday;
#line 400
  tm.tm_mon = mon;
#line 401
  tm.tm_year = year - 1900;
#line 402
  tm.tm_wday = 0;
#line 403
  tm.tm_yday = 0;
#line 404
  tm.tm_isdst = 0;
#line 406
  t = mktime(& tm);
  }
#line 409
  if (-1 != (int )t) {
    {
#line 428
    gmt = gmtime((time_t const   *)(& t));
    }
#line 429
    if (! gmt) {
#line 430
      return ((time_t )-1);
    }
    {
#line 431
    gmt2 = *gmt;
#line 432
    t2 = mktime(& gmt2);
    }
#line 437
    if (tzoff != -1) {
#line 437
      tmp___4 = tzoff;
    } else {
#line 437
      tmp___4 = 0;
    }
#line 437
    delta = (time_t )tmp___4 + (t - t2);
#line 439
    if (delta > 0L) {
#line 439
      if (t + delta < t) {
#line 440
        return ((time_t )-1);
      }
    }
#line 442
    t += delta;
  }
  {
#line 444
  now = time((time_t *)((void *)0));
  }
#line 445
  return (t);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 29 "./creds.h"
size_t CREDSIZE ;
#line 31
CREDS new_creds(SCHEME scheme , char *str ) ;
#line 32
CREDS creds_destroy(CREDS this ) ;
#line 33
SCHEME creds_get_scheme(CREDS this ) ;
#line 34
char *creds_get_username(CREDS this ) ;
#line 35
char *creds_get_password(CREDS this ) ;
#line 36
char *creds_get_realm(CREDS this ) ;
#line 37
void creds_set_username(CREDS this , char *username ) ;
#line 38
void creds_set_password(CREDS this , char *password ) ;
#line 39
void creds_set_realm(CREDS this , char *realm ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
size_t CREDSIZE  =    sizeof(struct CREDS_T );
#line 39
static void __parse_input(CREDS this , char *str ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
CREDS new_creds(SCHEME scheme , char *str ) 
{ 
  CREDS this ;
  void *tmp ;

  {
  {
#line 47
  tmp = calloc(sizeof(struct CREDS_T ), (size_t )1);
#line 47
  this = (CREDS )tmp;
#line 48
  this->scheme = scheme;
#line 49
  __parse_input(this, str);
  }
#line 50
  return (this);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
CREDS creds_destroy(CREDS this ) 
{ 


  {
  {
#line 56
  free((void *)this->username);
#line 57
  free((void *)this->password);
#line 58
  free((void *)this->realm);
#line 59
  free((void *)this);
  }
#line 60
  return ((CREDS )((void *)0));
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
SCHEME creds_get_scheme(CREDS this ) 
{ 


  {
#line 66
  return (this->scheme);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
char *creds_get_username(CREDS this ) 
{ 


  {
#line 72
  return (this->username);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
char *creds_get_password(CREDS this ) 
{ 


  {
#line 78
  return (this->password);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
char *creds_get_realm(CREDS this ) 
{ 


  {
#line 84
  return (this->realm);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
void creds_set_username(CREDS this , char *username ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 90
  tmp = strlen((char const   *)username);
#line 90
  len = tmp;
#line 92
  tmp___0 = malloc(len + 1UL);
#line 92
  this->username = (char *)tmp___0;
#line 93
  memset((void *)this->username, '\000', len + 1UL);
#line 94
  memcpy((void */* __restrict  */)this->username, (void const   */* __restrict  */)username,
         len);
  }
#line 95
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
void creds_set_password(CREDS this , char *password ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 101
  tmp = strlen((char const   *)password);
#line 101
  len = tmp;
#line 103
  tmp___0 = malloc(len + 1UL);
#line 103
  this->password = (char *)tmp___0;
#line 104
  memset((void *)this->password, '\000', len + 1UL);
#line 105
  memcpy((void */* __restrict  */)this->password, (void const   */* __restrict  */)password,
         len);
  }
#line 106
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
void creds_set_realm(CREDS this , char *realm ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 112
  tmp = strlen((char const   *)realm);
#line 112
  len = tmp;
#line 114
  tmp___0 = malloc(len + 1UL);
#line 114
  this->realm = (char *)tmp___0;
#line 115
  memset((void *)this->realm, '\000', len + 1UL);
#line 116
  memcpy((void */* __restrict  */)this->realm, (void const   */* __restrict  */)realm,
         len);
  }
#line 117
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/creds.c"
static void __parse_input(CREDS this , char *str ) 
{ 
  char *usr ;
  char *pwd ;
  char *rlm ;
  char *tmp ;
  char any[5] ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 128
  any[0] = (char )'a';
#line 128
  any[1] = (char )'n';
#line 128
  any[2] = (char )'y';
#line 128
  any[3] = (char )'\000';
#line 128
  any[4] = (char )'\000';
#line 130
  tmp = str;
#line 130
  usr = tmp;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (*tmp) {
#line 131
      if ((int )*tmp != 58) {
#line 131
        if (! ((int )*tmp != 0)) {
#line 131
          goto while_break;
        }
      } else {
#line 131
        goto while_break;
      }
    } else {
#line 131
      goto while_break;
    }
#line 132
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  tmp___0 = tmp;
#line 134
  tmp ++;
#line 134
  *tmp___0 = (char)0;
#line 135
  pwd = tmp;
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (*tmp) {
#line 136
      if ((int )*tmp != 58) {
#line 136
        if (! ((int )*tmp != 0)) {
#line 136
          goto while_break___0;
        }
      } else {
#line 136
        goto while_break___0;
      }
    } else {
#line 136
      goto while_break___0;
    }
#line 137
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  if (0 != (int )*tmp) {
#line 140
    tmp___1 = tmp;
#line 140
    tmp ++;
#line 140
    *tmp___1 = (char)0;
#line 141
    rlm = tmp;
  } else {
#line 143
    rlm = (char *)((void *)0);
  }
  {
#line 146
  creds_set_username(this, usr);
#line 147
  creds_set_password(this, pwd);
  }
#line 148
  if ((unsigned long )rlm == (unsigned long )((void *)0)) {
#line 148
    tmp___2 = any;
  } else {
#line 148
    tmp___2 = rlm;
  }
  {
#line 148
  creds_set_realm(this, tmp___2);
  }
#line 149
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 30 "./array.h"
size_t ARRAYSIZE ;
#line 32
ARRAY new_array(void) ;
#line 33
ARRAY array_destroy(ARRAY this ) ;
#line 34
void array_push(ARRAY this , void *thing ) ;
#line 35
void array_npush(ARRAY this , void *thing , size_t len ) ;
#line 37
void *array_next(ARRAY this ) ;
#line 38
void *array_prev(ARRAY this ) ;
#line 39
size_t array_length(ARRAY this ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
size_t ARRAYSIZE  =    sizeof(struct ARRAY_T );
#line 42 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
ARRAY new_array(void) 
{ 
  ARRAY this ;
  void *tmp ;

  {
  {
#line 46
  tmp = xcalloc(sizeof(struct ARRAY_T ), (size_t )1);
#line 46
  this = (ARRAY )tmp;
#line 47
  this->index = -1;
#line 48
  this->length = 0;
  }
#line 49
  return (this);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
ARRAY array_destroy(ARRAY this ) 
{ 
  int i ;

  {
#line 57
  i = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < this->length)) {
#line 57
      goto while_break;
    }
    {
#line 58
    xfree(*(this->data + i));
#line 57
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  xfree((void *)this->data);
#line 61
  this = (ARRAY )((void *)0);
  }
#line 62
  return (this);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
void array_push(ARRAY this , void *thing ) 
{ 
  int len ;
  size_t tmp ;

  {
#line 68
  len = 0;
#line 70
  if ((unsigned long )thing == (unsigned long )((void *)0)) {
#line 70
    return;
  }
  {
#line 72
  tmp = strlen((char const   *)thing);
#line 72
  len = (int )(tmp + 1UL);
#line 73
  array_npush(this, thing, (size_t )len);
  }
#line 74
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
void array_npush(ARRAY this , void *thing , size_t len ) 
{ 
  array arr ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 81
  if ((unsigned long )thing == (unsigned long )((void *)0)) {
#line 81
    return;
  }
#line 82
  if (this->length == 0) {
    {
#line 83
    tmp = xmalloc(sizeof(array ));
#line 83
    this->data = (array *)tmp;
    }
  } else {
    {
#line 85
    tmp___0 = realloc((void *)this->data, (unsigned long )(this->length + 1) * sizeof(array ));
#line 85
    this->data = (array *)tmp___0;
    }
  }
  {
#line 87
  arr = xmalloc(len + 1UL);
#line 88
  memset(arr, 0, len);
#line 89
  memcpy((void */* __restrict  */)arr, (void const   */* __restrict  */)thing, len);
#line 90
  *(this->data + this->length) = arr;
#line 91
  (this->length) ++;
  }
#line 92
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
void *array_get(ARRAY this , int index___0 ) 
{ 


  {
#line 98
  if (index___0 > this->length) {
#line 98
    return ((void *)0);
  }
#line 100
  return (*(this->data + index___0));
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
void *array_next(ARRAY this ) 
{ 


  {
#line 106
  (this->index) ++;
#line 107
  return (*(this->data + this->index % this->length));
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
void *array_prev(ARRAY this ) 
{ 


  {
#line 113
  (this->index) --;
#line 114
  return (*(this->data + (this->index + (this->length - 1)) % this->length));
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/array.c"
size_t array_length(ARRAY this ) 
{ 


  {
#line 120
  return ((size_t )this->length);
}
}
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 253
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 261
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 524
extern int pthread_cancel(pthread_t __th ) ;
#line 760
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 979
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 988
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 992
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
#line 1000
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 1011
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 39 "./crew.h"
CREW new_crew(int size , int maxsize , BOOLEAN block ) ;
#line 40
BOOLEAN crew_add(CREW crew , void (*routine)() , void *arg ) ;
#line 41
BOOLEAN crew_cancel(CREW this ) ;
#line 42
BOOLEAN crew_join(CREW crew , BOOLEAN finish , void **payload ) ;
#line 43
void crew_destroy(CREW crew ) ;
#line 45
void crew_set_shutdown(CREW this , BOOLEAN shutdown___0 ) ;
#line 47
int crew_get_size(CREW this ) ;
#line 48
int crew_get_total(CREW this ) ;
#line 49
BOOLEAN crew_get_shutdown(CREW this ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
static void *crew_thread(void *crew ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
CREW new_crew(int size , int maxsize , BOOLEAN block ) 
{ 
  int x ;
  int c ;
  CREW this ;
  void *tmp ;
  pthread_t *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 57
  tmp = calloc(sizeof(*this), (size_t )1);
#line 57
  this = (CREW )tmp;
  }
#line 57
  if ((unsigned long )this == (unsigned long )((void *)0)) {
#line 58
    return ((CREW )((void *)0));
  }
  {
#line 60
  tmp___1 = malloc(sizeof(pthread_t ) * (unsigned long )size);
#line 60
  tmp___0 = (pthread_t *)tmp___1;
#line 60
  this->threads = tmp___0;
  }
#line 60
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 61
    return ((CREW )((void *)0));
  }
  {
#line 63
  this->size = size;
#line 64
  this->maxsize = maxsize;
#line 65
  this->cursize = 0;
#line 66
  this->total = 0;
#line 67
  this->block = block;
#line 68
  this->head = (WORK *)((void *)0);
#line 69
  this->tail = (WORK *)((void *)0);
#line 70
  this->closed = (BOOLEAN )0;
#line 71
  this->shutdown = (BOOLEAN )0;
#line 73
  c = pthread_mutex_init(& this->lock, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 73
  if (c != 0) {
#line 74
    return ((CREW )((void *)0));
  }
  {
#line 75
  c = pthread_cond_init((pthread_cond_t */* __restrict  */)(& this->not_empty), (pthread_condattr_t const   */* __restrict  */)((void *)0));
  }
#line 75
  if (c != 0) {
#line 76
    return ((CREW )((void *)0));
  }
  {
#line 77
  c = pthread_cond_init((pthread_cond_t */* __restrict  */)(& this->not_full), (pthread_condattr_t const   */* __restrict  */)((void *)0));
  }
#line 77
  if (c != 0) {
#line 78
    return ((CREW )((void *)0));
  }
  {
#line 79
  c = pthread_cond_init((pthread_cond_t */* __restrict  */)(& this->empty), (pthread_condattr_t const   */* __restrict  */)((void *)0));
  }
#line 79
  if (c != 0) {
#line 80
    return ((CREW )((void *)0));
  }
#line 82
  x = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (x != size)) {
#line 82
      goto while_break;
    }
    {
#line 83
    c = pthread_create((pthread_t */* __restrict  */)(this->threads + x), (pthread_attr_t const   */* __restrict  */)((void *)0),
                       & crew_thread, (void */* __restrict  */)((void *)this));
    }
#line 83
    if (c != 0) {
#line 84
      return ((CREW )((void *)0));
    }
#line 82
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return (this);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
static void *crew_thread(void *crew ) 
{ 
  int c ;
  WORK *workptr ;
  CREW this ;
  WORK *tmp ;

  {
#line 95
  this = (CREW )crew;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    c = pthread_mutex_lock(& this->lock);
    }
#line 98
    if (c != 0) {
      {
#line 99
      NOTIFY((LEVEL )3, "mutex lock");
      }
    }
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 101
      if (this->cursize == 0) {
#line 101
        if (! (! this->shutdown)) {
#line 101
          goto while_break___0;
        }
      } else {
#line 101
        goto while_break___0;
      }
      {
#line 102
      c = pthread_cond_wait((pthread_cond_t */* __restrict  */)(& this->not_empty),
                            (pthread_mutex_t */* __restrict  */)(& this->lock));
      }
#line 102
      if (c != 0) {
        {
#line 103
        NOTIFY((LEVEL )3, "pthread wait");
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 106
    if ((unsigned int )this->shutdown == 1U) {
      {
#line 107
      c = pthread_mutex_unlock(& this->lock);
      }
#line 107
      if (c != 0) {
        {
#line 108
        NOTIFY((LEVEL )3, "mutex unlock");
        }
      }
      {
#line 110
      pthread_exit((void *)0);
      }
    }
#line 112
    workptr = this->head;
#line 113
    (this->cursize) --;
#line 114
    if (this->cursize == 0) {
#line 115
      tmp = (WORK *)((void *)0);
#line 115
      this->tail = tmp;
#line 115
      this->head = tmp;
    } else {
#line 118
      this->head = workptr->next;
    }
#line 120
    if (this->block) {
#line 120
      if (this->cursize == this->maxsize - 1) {
        {
#line 121
        c = pthread_cond_broadcast(& this->not_full);
        }
#line 121
        if (c != 0) {
          {
#line 122
          NOTIFY((LEVEL )3, "pthread broadcast");
          }
        }
      }
    }
#line 125
    if (this->cursize == 0) {
      {
#line 126
      c = pthread_cond_signal(& this->empty);
      }
#line 126
      if (c != 0) {
        {
#line 127
        NOTIFY((LEVEL )3, "pthread signal");
        }
      }
    }
    {
#line 130
    c = pthread_mutex_unlock(& this->lock);
    }
#line 130
    if (c != 0) {
      {
#line 131
      NOTIFY((LEVEL )3, "pthread unlock");
      }
    }
    {
#line 134
    (*(workptr->routine))(workptr->arg);
#line 136
    xfree((void *)workptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return ((void *)0);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
BOOLEAN crew_add(CREW crew , void (*routine)() , void *arg ) 
{ 
  int c ;
  WORK *workptr ;
  void *tmp ;
  WORK *tmp___0 ;

  {
  {
#line 148
  c = pthread_mutex_lock(& crew->lock);
  }
#line 148
  if (c != 0) {
    {
#line 149
    NOTIFY((LEVEL )3, "pthread lock");
    }
  }
#line 151
  if (crew->cursize == crew->maxsize) {
#line 151
    if (! crew->block) {
      {
#line 152
      c = pthread_mutex_unlock(& crew->lock);
      }
#line 152
      if (c != 0) {
        {
#line 153
        NOTIFY((LEVEL )3, "pthread unlock");
        }
      }
#line 155
      return ((BOOLEAN )0);
    }
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (crew->cursize == crew->maxsize) {
#line 158
      if (crew->shutdown) {
#line 158
        goto while_break;
      } else
#line 158
      if (crew->closed) {
#line 158
        goto while_break;
      }
    } else {
#line 158
      goto while_break;
    }
    {
#line 159
    c = pthread_cond_wait((pthread_cond_t */* __restrict  */)(& crew->not_full), (pthread_mutex_t */* __restrict  */)(& crew->lock));
    }
#line 159
    if (c != 0) {
      {
#line 160
      NOTIFY((LEVEL )3, "pthread wait");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  if (crew->shutdown) {
#line 163
    goto _L;
  } else
#line 163
  if (crew->closed) {
    _L: /* CIL Label */ 
    {
#line 164
    c = pthread_mutex_unlock(& crew->lock);
    }
#line 164
    if (c != 0) {
      {
#line 165
      NOTIFY((LEVEL )3, "pthread unlock");
      }
    }
#line 167
    return ((BOOLEAN )0);
  }
  {
#line 169
  tmp = malloc(sizeof(WORK ));
#line 169
  workptr = (WORK *)tmp;
  }
#line 169
  if ((unsigned long )workptr == (unsigned long )((void *)0)) {
    {
#line 170
    NOTIFY((LEVEL )3, "out of memory");
    }
  }
#line 172
  workptr->routine = routine;
#line 173
  workptr->arg = arg;
#line 174
  workptr->next = (struct work *)((void *)0);
#line 176
  if (crew->cursize == 0) {
    {
#line 177
    tmp___0 = workptr;
#line 177
    crew->head = tmp___0;
#line 177
    crew->tail = tmp___0;
#line 178
    c = pthread_cond_broadcast(& crew->not_empty);
    }
#line 178
    if (c != 0) {
      {
#line 179
      NOTIFY((LEVEL )3, "pthread signal");
      }
    }
  } else {
#line 182
    (crew->tail)->next = workptr;
#line 183
    crew->tail = workptr;
  }
  {
#line 186
  (crew->cursize) ++;
#line 187
  (crew->total) ++;
#line 188
  c = pthread_mutex_unlock(& crew->lock);
  }
#line 188
  if (c != 0) {
    {
#line 189
    NOTIFY((LEVEL )3, "pthread unlock");
    }
  }
#line 192
  return ((BOOLEAN )1);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
BOOLEAN crew_cancel(CREW this ) 
{ 
  int x ;
  int size ;

  {
  {
#line 204
  size = this->size;
#line 206
  crew_set_shutdown(this, (BOOLEAN )1);
#line 207
  x = 0;
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (x < size)) {
#line 207
      goto while_break;
    }
    {
#line 211
    pthread_cancel(*(this->threads + x));
#line 207
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((BOOLEAN )1);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
BOOLEAN crew_join(CREW crew , BOOLEAN finish , void **payload ) 
{ 
  int x ;
  int c ;
  int rc ;
  struct timespec ts ;
  struct timeval tp ;

  {
  {
#line 223
  c = pthread_mutex_lock(& crew->lock);
  }
#line 223
  if (c != 0) {
    {
#line 224
    NOTIFY((LEVEL )3, "pthread lock");
    }
  }
#line 227
  if (crew->closed) {
#line 227
    goto _L;
  } else
#line 227
  if (crew->shutdown) {
    _L: /* CIL Label */ 
    {
#line 228
    c = pthread_mutex_unlock(& crew->lock);
    }
#line 228
    if (c != 0) {
      {
#line 229
      NOTIFY((LEVEL )3, "pthread unlock");
      }
    }
#line 231
    return ((BOOLEAN )0);
  }
#line 234
  crew->closed = (BOOLEAN )1;
#line 236
  if ((unsigned int )finish == 1U) {
    {
#line 237
    while (1) {
      while_continue: /* CIL Label */ ;
#line 237
      if (crew->cursize != 0) {
#line 237
        if (! (! crew->shutdown)) {
#line 237
          goto while_break;
        }
      } else {
#line 237
        goto while_break;
      }
      {
#line 242
      rc = gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
      }
#line 243
      if (rc != 0) {
        {
#line 244
        perror("gettimeofday");
        }
      }
      {
#line 245
      ts.tv_sec = tp.tv_sec + 60L;
#line 246
      ts.tv_nsec = tp.tv_usec * 1000L;
#line 247
      rc = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& crew->empty),
                                  (pthread_mutex_t */* __restrict  */)(& crew->lock),
                                  (struct timespec  const  */* __restrict  */)(& ts));
      }
#line 248
      if (rc == 110) {
        {
#line 249
        pthread_mutex_unlock(& crew->lock);
        }
      }
#line 252
      if (rc != 0) {
        {
#line 253
        NOTIFY((LEVEL )3, "pthread wait");
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 258
  crew->shutdown = (BOOLEAN )1;
#line 260
  c = pthread_mutex_unlock(& crew->lock);
  }
#line 260
  if (c != 0) {
    {
#line 261
    NOTIFY((LEVEL )3, "pthread_mutex_unlock");
    }
  }
  {
#line 264
  c = pthread_cond_broadcast(& crew->not_empty);
  }
#line 264
  if (c != 0) {
    {
#line 265
    NOTIFY((LEVEL )3, "pthread broadcast");
    }
  }
  {
#line 268
  c = pthread_cond_broadcast(& crew->not_full);
  }
#line 268
  if (c != 0) {
    {
#line 269
    NOTIFY((LEVEL )3, "pthread broadcast");
    }
  }
#line 272
  x = 0;
  {
#line 272
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 272
    if (! (x < crew->size)) {
#line 272
      goto while_break___0;
    }
    {
#line 273
    c = pthread_join(*(crew->threads + x), payload);
    }
#line 273
    if (c != 0) {
      {
#line 274
      NOTIFY((LEVEL )3, "pthread_join");
      }
    }
#line 272
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 278
  return ((BOOLEAN )1);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
void crew_destroy(CREW crew ) 
{ 
  WORK *workptr ;

  {
  {
#line 284
  xfree((void *)crew->threads);
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((unsigned long )crew->head != (unsigned long )((void *)0))) {
#line 285
      goto while_break;
    }
    {
#line 286
    workptr = crew->head;
#line 287
    crew->head = (crew->head)->next;
#line 288
    xfree((void *)workptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 291
  xfree((void *)crew);
  }
#line 292
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
void crew_set_shutdown(CREW this , BOOLEAN shutdown___0 ) 
{ 


  {
  {
#line 301
  this->shutdown = shutdown___0;
#line 304
  pthread_cond_broadcast(& this->not_empty);
#line 305
  pthread_cond_broadcast(& this->not_full);
#line 306
  pthread_cond_broadcast(& this->empty);
  }
#line 307
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
int crew_get_size(CREW this ) 
{ 


  {
#line 313
  return (this->size);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
int crew_get_total(CREW this ) 
{ 


  {
#line 319
  return (this->total);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/crew.c"
BOOLEAN crew_get_shutdown(CREW this ) 
{ 


  {
#line 325
  return (this->shutdown);
}
}
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 47 "./data.h"
DATA new_data(void) ;
#line 48
void data_destroy(DATA this ) ;
#line 51
void data_set_start(DATA this ) ;
#line 52
void data_set_stop(DATA this ) ;
#line 53
void data_set_highest(DATA this , float highest ) ;
#line 54
void data_set_lowest(DATA this , float lowest ) ;
#line 55
void data_increment_bytes(DATA this , unsigned long bytes ) ;
#line 56
void data_increment_count(DATA this , unsigned long count ) ;
#line 57
void data_increment_total(DATA this , float total ) ;
#line 58
void data_increment_code(DATA this , int code ) ;
#line 59
void data_increment_fail(DATA this , int fail ) ;
#line 60
void data_increment_ok200(DATA this , int ok200 ) ;
#line 63
float data_get_total(DATA this ) ;
#line 64
float data_get_bytes(DATA this ) ;
#line 65
float data_get_megabytes(DATA this ) ;
#line 66
float data_get_highest(DATA this ) ;
#line 67
float data_get_lowest(DATA this ) ;
#line 68
float data_get_elapsed(DATA this ) ;
#line 69
float data_get_availability(DATA this ) ;
#line 70
float data_get_response_time(DATA this ) ;
#line 71
float data_get_transaction_rate(DATA this ) ;
#line 72
float data_get_throughput(DATA this ) ;
#line 73
float data_get_concurrency(DATA this ) ;
#line 74
unsigned int data_get_count(DATA this ) ;
#line 75
unsigned int data_get_code(DATA this ) ;
#line 76
unsigned int data_get_fail(DATA this ) ;
#line 77
unsigned int data_get_ok200(DATA this ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
DATA new_data(void) 
{ 
  DATA this ;
  void *tmp ;

  {
  {
#line 68
  tmp = calloc(sizeof(*this), (size_t )1);
#line 68
  this = (DATA )tmp;
#line 69
  this->total = (float )0.0;
#line 70
  this->available = (float )0.0;
#line 71
  this->count = (unsigned int )0.0;
#line 72
  this->ok200 = 0U;
#line 73
  this->failed = (float )0.0;
#line 74
  this->lowest = (float )-1;
#line 75
  this->highest = (float )0.0;
#line 76
  this->elapsed = (float )0.0;
#line 77
  this->bytes = (unsigned long long )0.0;
  }
#line 78
  return (this);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_destroy(DATA this ) 
{ 


  {
  {
#line 84
  xfree((void *)this);
  }
#line 85
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_increment_bytes(DATA this , unsigned long bytes ) 
{ 


  {
#line 91
  this->bytes += (unsigned long long )bytes;
#line 92
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_increment_count(DATA this , unsigned long count ) 
{ 


  {
#line 98
  this->count = (unsigned int )((unsigned long )this->count + count);
#line 99
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_increment_total(DATA this , float total ) 
{ 


  {
#line 105
  this->total += total;
#line 106
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_increment_code(DATA this , int code ) 
{ 


  {
#line 112
  this->code += (unsigned int )code;
#line 113
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_increment_fail(DATA this , int fail ) 
{ 


  {
#line 119
  this->fail += (unsigned int )fail;
#line 120
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_increment_ok200(DATA this , int ok200 ) 
{ 


  {
#line 126
  this->ok200 += (unsigned int )ok200;
#line 127
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_set_start(DATA this ) 
{ 


  {
  {
#line 133
  this->start = times(& this->t_start);
  }
#line 134
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_set_stop(DATA this ) 
{ 


  {
  {
#line 140
  this->stop = times(& this->t_stop);
  }
#line 141
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_set_highest(DATA this , float highest ) 
{ 


  {
#line 147
  if (this->highest < highest) {
#line 148
    this->highest = highest;
  }
#line 150
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
void data_set_lowest(DATA this , float lowest ) 
{ 


  {
#line 156
  if (this->lowest <= (float )0) {
#line 157
    this->lowest = lowest;
  } else
#line 156
  if (this->lowest > lowest) {
#line 157
    this->lowest = lowest;
  }
#line 159
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
unsigned int data_get_count(DATA this ) 
{ 


  {
#line 165
  return (this->count);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
unsigned int data_get_code(DATA this ) 
{ 


  {
#line 171
  return (this->code);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
unsigned int data_get_fail(DATA this ) 
{ 


  {
#line 177
  return (this->fail);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
unsigned int data_get_ok200(DATA this ) 
{ 


  {
#line 183
  return (this->ok200);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_total(DATA this ) 
{ 


  {
#line 189
  return (this->total);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_bytes(DATA this ) 
{ 


  {
#line 195
  return ((float )this->bytes);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_highest(DATA this ) 
{ 


  {
#line 201
  return (this->highest);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_lowest(DATA this ) 
{ 


  {
#line 207
  if (this->code) {
#line 208
    return (this->lowest);
  } else {
#line 210
    return ((float )this->code);
  }
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_megabytes(DATA this ) 
{ 


  {
#line 217
  return ((float )((double )((float )this->bytes) / (1024.0 * 1024.0)));
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_elapsed(DATA this ) 
{ 
  long tps ;
  clock_t time___0 ;

  {
  {
#line 226
  time___0 = this->stop - this->start;
#line 227
  tps = sysconf(2);
#line 228
  this->elapsed = (float )time___0 / (float )tps;
  }
#line 229
  return (this->elapsed);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_availability(DATA this ) 
{ 


  {
#line 235
  if (this->count == 0U) {
#line 235
    this->available = (float )0;
  } else {
#line 235
    this->available = ((float )this->count / ((float )this->count + this->failed)) * (float )100;
  }
#line 236
  return (this->available);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_response_time(DATA this ) 
{ 


  {
#line 242
  if (this->total == (float )0) {
#line 243
    return ((float )0);
  } else
#line 242
  if (this->count == 0U) {
#line 243
    return ((float )0);
  }
#line 244
  return (this->total / (float )this->count);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_transaction_rate(DATA this ) 
{ 


  {
#line 250
  if (this->count == 0U) {
#line 251
    return ((float )0);
  } else
#line 250
  if (this->elapsed == (float )0) {
#line 251
    return ((float )0);
  }
#line 252
  return ((float )this->count / this->elapsed);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_throughput(DATA this ) 
{ 


  {
#line 258
  if (this->elapsed == (float )0) {
#line 259
    return ((float )0);
  }
#line 260
  return ((float )((double )this->bytes / (((double )this->elapsed * 1024.0) * 1024.0)));
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/data.c"
float data_get_concurrency(DATA this ) 
{ 


  {
#line 266
  if (this->elapsed == (float )0) {
#line 267
    return ((float )0);
  }
#line 269
  return (this->total / this->elapsed);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.h"
void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 106
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 113
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 123
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 132
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 138
int md5_stream(FILE *stream , void *resblock ) ;
#line 144
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 62 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ 
  md5_uint32 tmp ;

  {
#line 66
  ctx->A = (md5_uint32 )1732584193;
#line 67
  ctx->B = 4023233417U;
#line 68
  ctx->C = 2562383102U;
#line 69
  ctx->D = (md5_uint32 )271733878;
#line 71
  tmp = (md5_uint32 )0;
#line 71
  ctx->total[1] = tmp;
#line 71
  ctx->total[0] = tmp;
#line 72
  ctx->buflen = (md5_uint32 )0;
#line 73
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 


  {
#line 85
  *((md5_uint32 *)resbuf + 0) = (md5_uint32 )ctx->A;
#line 86
  *((md5_uint32 *)resbuf + 1) = (md5_uint32 )ctx->B;
#line 87
  *((md5_uint32 *)resbuf + 2) = (md5_uint32 )ctx->C;
#line 88
  *((md5_uint32 *)resbuf + 3) = (md5_uint32 )ctx->D;
#line 90
  return (resbuf);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ 
  md5_uint32 bytes ;
  size_t pad ;
  void *tmp ;

  {
#line 104
  bytes = ctx->buflen;
#line 108
  ctx->total[0] += bytes;
#line 109
  if (ctx->total[0] < bytes) {
#line 110
    (ctx->total[1]) ++;
  }
#line 112
  if (bytes >= 56U) {
#line 112
    pad = (size_t )(120U - bytes);
  } else {
#line 112
    pad = (size_t )(56U - bytes);
  }
  {
#line 113
  memcpy((void */* __restrict  */)(& ctx->buffer[bytes]), (void const   */* __restrict  */)(fillbuf),
         pad);
#line 116
  *((md5_uint32 *)(& ctx->buffer[(size_t )bytes + pad])) = ctx->total[0] << 3;
#line 117
  *((md5_uint32 *)(& ctx->buffer[((size_t )bytes + pad) + 4UL])) = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 121
  md5_process_block((void const   *)(ctx->buffer), ((size_t )bytes + pad) + 8UL, ctx);
#line 123
  tmp = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  }
#line 123
  return (tmp);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.c"
int md5_stream(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;

  {
  {
#line 141
  md5_init_ctx(& ctx);
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    sum = (size_t )0;
    {
#line 153
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 155
      n = fread((void */* __restrict  */)(buffer + sum), (size_t )1, 4096UL - sum,
                (FILE */* __restrict  */)stream);
#line 157
      sum += n;
      }
#line 153
      if (sum < 4096UL) {
#line 153
        if (! (n != 0UL)) {
#line 153
          goto while_break___0;
        }
      } else {
#line 153
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 160
    if (n == 0UL) {
      {
#line 160
      tmp = ferror(stream);
      }
#line 160
      if (tmp) {
#line 161
        return (1);
      }
    }
#line 164
    if (n == 0UL) {
#line 165
      goto while_break;
    }
    {
#line 170
    md5_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  if (sum > 0UL) {
    {
#line 175
    md5_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 178
  md5_finish_ctx(& ctx, resblock);
  }
#line 179
  return (0);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.c"
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp ;

  {
  {
#line 195
  md5_init_ctx(& ctx);
#line 198
  md5_process_bytes((void const   *)buffer, len, & ctx);
#line 201
  tmp = md5_finish_ctx(& ctx, resblock);
  }
#line 201
  return (tmp);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.c"
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;

  {
#line 213
  if (ctx->buflen != 0U) {
#line 215
    left_over = (size_t )ctx->buflen;
#line 216
    if (128UL - left_over > len) {
#line 216
      tmp = len;
    } else {
#line 216
      tmp = 128UL - left_over;
    }
    {
#line 216
    add = tmp;
#line 218
    memcpy((void */* __restrict  */)(& ctx->buffer[left_over]), (void const   */* __restrict  */)buffer,
           add);
#line 219
    ctx->buflen = (md5_uint32 )((size_t )ctx->buflen + add);
    }
#line 221
    if (left_over + add > 64UL) {
      {
#line 223
      md5_process_block((void const   *)(ctx->buffer), (left_over + add) & 0xffffffffffffffc0UL,
                        ctx);
#line 225
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[(left_over + add) & 0xffffffffffffffc0UL]),
             (left_over + add) & 63UL);
#line 227
      ctx->buflen = (md5_uint32 )((left_over + add) & 63UL);
      }
    }
#line 230
    buffer = (void const   *)((char const   *)buffer + add);
#line 231
    len -= add;
  }
#line 235
  if (len > 64UL) {
    {
#line 237
    md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 238
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 239
    len &= 63UL;
    }
  }
#line 243
  if (len > 0UL) {
    {
#line 245
    memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
           len);
#line 246
    ctx->buflen = (md5_uint32 )len;
    }
  }
#line 248
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/md5.c"
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  md5_uint32 correct_words[16] ;
  md5_uint32 const   *words ;
  size_t nwords ;
  md5_uint32 const   *endp ;
  md5_uint32 A ;
  md5_uint32 B ;
  md5_uint32 C ;
  md5_uint32 D ;
  md5_uint32 *cwp ;
  md5_uint32 A_save ;
  md5_uint32 B_save ;
  md5_uint32 C_save ;
  md5_uint32 D_save ;
  md5_uint32 *tmp ;
  md5_uint32 tmp___0 ;
  md5_uint32 *tmp___1 ;
  md5_uint32 tmp___2 ;
  md5_uint32 *tmp___3 ;
  md5_uint32 tmp___4 ;
  md5_uint32 *tmp___5 ;
  md5_uint32 tmp___6 ;
  md5_uint32 *tmp___7 ;
  md5_uint32 tmp___8 ;
  md5_uint32 *tmp___9 ;
  md5_uint32 tmp___10 ;
  md5_uint32 *tmp___11 ;
  md5_uint32 tmp___12 ;
  md5_uint32 *tmp___13 ;
  md5_uint32 tmp___14 ;
  md5_uint32 *tmp___15 ;
  md5_uint32 tmp___16 ;
  md5_uint32 *tmp___17 ;
  md5_uint32 tmp___18 ;
  md5_uint32 *tmp___19 ;
  md5_uint32 tmp___20 ;
  md5_uint32 *tmp___21 ;
  md5_uint32 tmp___22 ;
  md5_uint32 *tmp___23 ;
  md5_uint32 tmp___24 ;
  md5_uint32 *tmp___25 ;
  md5_uint32 tmp___26 ;
  md5_uint32 *tmp___27 ;
  md5_uint32 tmp___28 ;
  md5_uint32 *tmp___29 ;
  md5_uint32 tmp___30 ;

  {
#line 270
  words = (md5_uint32 const   *)buffer;
#line 271
  nwords = len / sizeof(md5_uint32 );
#line 272
  endp = words + nwords;
#line 273
  A = ctx->A;
#line 274
  B = ctx->B;
#line 275
  C = ctx->C;
#line 276
  D = ctx->D;
#line 281
  ctx->total[0] = (md5_uint32 )((size_t )ctx->total[0] + len);
#line 282
  if ((size_t )ctx->total[0] < len) {
#line 283
    (ctx->total[1]) ++;
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 287
      goto while_break;
    }
#line 289
    cwp = correct_words;
#line 290
    A_save = A;
#line 291
    B_save = B;
#line 292
    C_save = C;
#line 293
    D_save = D;
    {
#line 320
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 320
      tmp = cwp;
#line 320
      cwp ++;
#line 320
      tmp___0 = (md5_uint32 )*words;
#line 320
      *tmp = tmp___0;
#line 320
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
#line 320
      words ++;
#line 320
      A = (A << 7) | (A >> 25);
#line 320
      A += B;
#line 320
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 321
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 321
      tmp___1 = cwp;
#line 321
      cwp ++;
#line 321
      tmp___2 = (md5_uint32 )*words;
#line 321
      *tmp___1 = tmp___2;
#line 321
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
#line 321
      words ++;
#line 321
      D = (D << 12) | (D >> 20);
#line 321
      D += A;
#line 321
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 322
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 322
      tmp___3 = cwp;
#line 322
      cwp ++;
#line 322
      tmp___4 = (md5_uint32 )*words;
#line 322
      *tmp___3 = tmp___4;
#line 322
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
#line 322
      words ++;
#line 322
      C = (C << 17) | (C >> 15);
#line 322
      C += D;
#line 322
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 323
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 323
      tmp___5 = cwp;
#line 323
      cwp ++;
#line 323
      tmp___6 = (md5_uint32 )*words;
#line 323
      *tmp___5 = tmp___6;
#line 323
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
#line 323
      words ++;
#line 323
      B = (B << 22) | (B >> 10);
#line 323
      B += C;
#line 323
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 324
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 324
      tmp___7 = cwp;
#line 324
      cwp ++;
#line 324
      tmp___8 = (md5_uint32 )*words;
#line 324
      *tmp___7 = tmp___8;
#line 324
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
#line 324
      words ++;
#line 324
      A = (A << 7) | (A >> 25);
#line 324
      A += B;
#line 324
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 325
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 325
      tmp___9 = cwp;
#line 325
      cwp ++;
#line 325
      tmp___10 = (md5_uint32 )*words;
#line 325
      *tmp___9 = tmp___10;
#line 325
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
#line 325
      words ++;
#line 325
      D = (D << 12) | (D >> 20);
#line 325
      D += A;
#line 325
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 326
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 326
      tmp___11 = cwp;
#line 326
      cwp ++;
#line 326
      tmp___12 = (md5_uint32 )*words;
#line 326
      *tmp___11 = tmp___12;
#line 326
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
#line 326
      words ++;
#line 326
      C = (C << 17) | (C >> 15);
#line 326
      C += D;
#line 326
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 327
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 327
      tmp___13 = cwp;
#line 327
      cwp ++;
#line 327
      tmp___14 = (md5_uint32 )*words;
#line 327
      *tmp___13 = tmp___14;
#line 327
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
#line 327
      words ++;
#line 327
      B = (B << 22) | (B >> 10);
#line 327
      B += C;
#line 327
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 328
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 328
      tmp___15 = cwp;
#line 328
      cwp ++;
#line 328
      tmp___16 = (md5_uint32 )*words;
#line 328
      *tmp___15 = tmp___16;
#line 328
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
#line 328
      words ++;
#line 328
      A = (A << 7) | (A >> 25);
#line 328
      A += B;
#line 328
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 329
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 329
      tmp___17 = cwp;
#line 329
      cwp ++;
#line 329
      tmp___18 = (md5_uint32 )*words;
#line 329
      *tmp___17 = tmp___18;
#line 329
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
#line 329
      words ++;
#line 329
      D = (D << 12) | (D >> 20);
#line 329
      D += A;
#line 329
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 330
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 330
      tmp___19 = cwp;
#line 330
      cwp ++;
#line 330
      tmp___20 = (md5_uint32 )*words;
#line 330
      *tmp___19 = tmp___20;
#line 330
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
#line 330
      words ++;
#line 330
      C = (C << 17) | (C >> 15);
#line 330
      C += D;
#line 330
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 331
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 331
      tmp___21 = cwp;
#line 331
      cwp ++;
#line 331
      tmp___22 = (md5_uint32 )*words;
#line 331
      *tmp___21 = tmp___22;
#line 331
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
#line 331
      words ++;
#line 331
      B = (B << 22) | (B >> 10);
#line 331
      B += C;
#line 331
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 332
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 332
      tmp___23 = cwp;
#line 332
      cwp ++;
#line 332
      tmp___24 = (md5_uint32 )*words;
#line 332
      *tmp___23 = tmp___24;
#line 332
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
#line 332
      words ++;
#line 332
      A = (A << 7) | (A >> 25);
#line 332
      A += B;
#line 332
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 333
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 333
      tmp___25 = cwp;
#line 333
      cwp ++;
#line 333
      tmp___26 = (md5_uint32 )*words;
#line 333
      *tmp___25 = tmp___26;
#line 333
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
#line 333
      words ++;
#line 333
      D = (D << 12) | (D >> 20);
#line 333
      D += A;
#line 333
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 334
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 334
      tmp___27 = cwp;
#line 334
      cwp ++;
#line 334
      tmp___28 = (md5_uint32 )*words;
#line 334
      *tmp___27 = tmp___28;
#line 334
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
#line 334
      words ++;
#line 334
      C = (C << 17) | (C >> 15);
#line 334
      C += D;
#line 334
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 335
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 335
      tmp___29 = cwp;
#line 335
      cwp ++;
#line 335
      tmp___30 = (md5_uint32 )*words;
#line 335
      *tmp___29 = tmp___30;
#line 335
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
#line 335
      words ++;
#line 335
      B = (B << 22) | (B >> 10);
#line 335
      B += C;
#line 335
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 351
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 351
      A = (A << 5) | (A >> 27);
#line 351
      A += B;
#line 351
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 352
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 352
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 352
      D = (D << 9) | (D >> 23);
#line 352
      D += A;
#line 352
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 353
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 353
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 353
      C = (C << 14) | (C >> 18);
#line 353
      C += D;
#line 353
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 354
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 354
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 354
      B = (B << 20) | (B >> 12);
#line 354
      B += C;
#line 354
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 355
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 355
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 355
      A = (A << 5) | (A >> 27);
#line 355
      A += B;
#line 355
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 356
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 356
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 356
      D = (D << 9) | (D >> 23);
#line 356
      D += A;
#line 356
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 357
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 357
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 357
      C = (C << 14) | (C >> 18);
#line 357
      C += D;
#line 357
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 358
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 358
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 358
      B = (B << 20) | (B >> 12);
#line 358
      B += C;
#line 358
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 359
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 359
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 359
      A = (A << 5) | (A >> 27);
#line 359
      A += B;
#line 359
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 360
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 360
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 360
      D = (D << 9) | (D >> 23);
#line 360
      D += A;
#line 360
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 361
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 361
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 361
      C = (C << 14) | (C >> 18);
#line 361
      C += D;
#line 361
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 362
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 362
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 362
      B = (B << 20) | (B >> 12);
#line 362
      B += C;
#line 362
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 363
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 363
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 363
      A = (A << 5) | (A >> 27);
#line 363
      A += B;
#line 363
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 364
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 364
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 364
      D = (D << 9) | (D >> 23);
#line 364
      D += A;
#line 364
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 365
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 365
      C = (C << 14) | (C >> 18);
#line 365
      C += D;
#line 365
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 366
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 366
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 366
      B = (B << 20) | (B >> 12);
#line 366
      B += C;
#line 366
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 369
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 369
      A = (A << 4) | (A >> 28);
#line 369
      A += B;
#line 369
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 370
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 370
      D = (D << 11) | (D >> 21);
#line 370
      D += A;
#line 370
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 371
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 371
      C = (C << 16) | (C >> 16);
#line 371
      C += D;
#line 371
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 372
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 372
      B = (B << 23) | (B >> 9);
#line 372
      B += C;
#line 372
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 373
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 373
      A = (A << 4) | (A >> 28);
#line 373
      A += B;
#line 373
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 374
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 374
      D = (D << 11) | (D >> 21);
#line 374
      D += A;
#line 374
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 375
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 375
      C = (C << 16) | (C >> 16);
#line 375
      C += D;
#line 375
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 376
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 376
      B = (B << 23) | (B >> 9);
#line 376
      B += C;
#line 376
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 377
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 377
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 377
      A = (A << 4) | (A >> 28);
#line 377
      A += B;
#line 377
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 378
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 378
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 378
      D = (D << 11) | (D >> 21);
#line 378
      D += A;
#line 378
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 379
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 379
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 379
      C = (C << 16) | (C >> 16);
#line 379
      C += D;
#line 379
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 380
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 380
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 380
      B = (B << 23) | (B >> 9);
#line 380
      B += C;
#line 380
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 381
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 381
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 381
      A = (A << 4) | (A >> 28);
#line 381
      A += B;
#line 381
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 382
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 382
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 382
      D = (D << 11) | (D >> 21);
#line 382
      D += A;
#line 382
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 383
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 383
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 383
      C = (C << 16) | (C >> 16);
#line 383
      C += D;
#line 383
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 384
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 384
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 384
      B = (B << 23) | (B >> 9);
#line 384
      B += C;
#line 384
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 387
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 387
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 387
      A = (A << 6) | (A >> 26);
#line 387
      A += B;
#line 387
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 388
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 388
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 388
      D = (D << 10) | (D >> 22);
#line 388
      D += A;
#line 388
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 389
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 389
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 389
      C = (C << 15) | (C >> 17);
#line 389
      C += D;
#line 389
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 390
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 390
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 390
      B = (B << 21) | (B >> 11);
#line 390
      B += C;
#line 390
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 391
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 391
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 391
      A = (A << 6) | (A >> 26);
#line 391
      A += B;
#line 391
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 392
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 392
      D = (D << 10) | (D >> 22);
#line 392
      D += A;
#line 392
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 393
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 393
      C = (C << 15) | (C >> 17);
#line 393
      C += D;
#line 393
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 394
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 394
      B = (B << 21) | (B >> 11);
#line 394
      B += C;
#line 394
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 395
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 395
      A = (A << 6) | (A >> 26);
#line 395
      A += B;
#line 395
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 396
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 396
      D = (D << 10) | (D >> 22);
#line 396
      D += A;
#line 396
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 397
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 397
      C = (C << 15) | (C >> 17);
#line 397
      C += D;
#line 397
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 398
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 398
      B = (B << 21) | (B >> 11);
#line 398
      B += C;
#line 398
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 399
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 399
      A = (A << 6) | (A >> 26);
#line 399
      A += B;
#line 399
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 400
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 400
      D = (D << 10) | (D >> 22);
#line 400
      D += A;
#line 400
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 401
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 401
      C = (C << 15) | (C >> 17);
#line 401
      C += D;
#line 401
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 402
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 402
      B = (B << 21) | (B >> 11);
#line 402
      B += C;
#line 402
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 405
    A += A_save;
#line 406
    B += B_save;
#line 407
    C += C_save;
#line 408
    D += D_save;
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  ctx->A = A;
#line 413
  ctx->B = B;
#line 414
  ctx->C = C;
#line 415
  ctx->D = D;
#line 416
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 107 "./url.h"
char *url_get_file(URL this ) ;
#line 121 "../include/joedog/joedog.h"
char *trim(char *str ) ;
#line 27 "./load.h"
void load_file(URL U , char *file ) ;
#line 28
void write_file(URL U , char *buf , size_t len ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/load.c"
static struct ContentType  const  tmap[162]  = 
#line 44 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/load.c"
  {      {(char *)"default", (BOOLEAN )1, (char *)"application/x-www-form-urlencoded"}, 
        {(char *)"ai",
      (BOOLEAN )0, (char *)"application/postscript"}, 
        {(char *)"aif", (BOOLEAN )0, (char *)"audio/x-aiff"}, 
        {(char *)"aifc", (BOOLEAN )0, (char *)"audio/x-aiff"}, 
        {(char *)"aiff", (BOOLEAN )0, (char *)"audio/x-aiff"}, 
        {(char *)"asc", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"au", (BOOLEAN )0, (char *)"audio/basic"}, 
        {(char *)"avi", (BOOLEAN )0, (char *)"video/x-msvideo"}, 
        {(char *)"bcpio", (BOOLEAN )0, (char *)"application/x-bcpio"}, 
        {(char *)"bin", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"c", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"cc", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"ccad", (BOOLEAN )0, (char *)"application/clariscad"}, 
        {(char *)"cdf", (BOOLEAN )0, (char *)"application/x-netcdf"}, 
        {(char *)"class", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"cpio", (BOOLEAN )0, (char *)"application/x-cpio"}, 
        {(char *)"cpt", (BOOLEAN )0, (char *)"application/mac-compactpro"}, 
        {(char *)"csh", (BOOLEAN )0, (char *)"application/x-csh"}, 
        {(char *)"css", (BOOLEAN )1, (char *)"text/css"}, 
        {(char *)"dcr", (BOOLEAN )0, (char *)"application/x-director"}, 
        {(char *)"dir", (BOOLEAN )0, (char *)"application/x-director"}, 
        {(char *)"dms", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"doc", (BOOLEAN )0, (char *)"application/msword"}, 
        {(char *)"drw", (BOOLEAN )0, (char *)"application/drafting"}, 
        {(char *)"dvi", (BOOLEAN )0, (char *)"application/x-dvi"}, 
        {(char *)"dwg", (BOOLEAN )0, (char *)"application/acad"}, 
        {(char *)"dxf", (BOOLEAN )0, (char *)"application/dxf"}, 
        {(char *)"dxr", (BOOLEAN )0, (char *)"application/x-director"}, 
        {(char *)"eps", (BOOLEAN )0, (char *)"application/postscript"}, 
        {(char *)"etx", (BOOLEAN )1, (char *)"text/x-setext"}, 
        {(char *)"exe", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"ez", (BOOLEAN )0, (char *)"application/andrew-inset"}, 
        {(char *)"f", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"f90", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"fli", (BOOLEAN )0, (char *)"video/x-fli"}, 
        {(char *)"gif", (BOOLEAN )0, (char *)"image/gif"}, 
        {(char *)"gtar", (BOOLEAN )0, (char *)"application/x-gtar"}, 
        {(char *)"gz", (BOOLEAN )0, (char *)"application/x-gzip"}, 
        {(char *)"h", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"hdf", (BOOLEAN )0, (char *)"application/x-hdf"}, 
        {(char *)"hh", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"hqx", (BOOLEAN )0, (char *)"application/mac-binhex40"}, 
        {(char *)"htm", (BOOLEAN )1, (char *)"text/html"}, 
        {(char *)"html", (BOOLEAN )1, (char *)"text/html"}, 
        {(char *)"ice", (BOOLEAN )0, (char *)"x-conference/x-cooltalk"}, 
        {(char *)"ief", (BOOLEAN )0, (char *)"image/ief"}, 
        {(char *)"iges", (BOOLEAN )0, (char *)"model/iges"}, 
        {(char *)"igs", (BOOLEAN )0, (char *)"model/iges"}, 
        {(char *)"ips", (BOOLEAN )0, (char *)"application/x-ipscript"}, 
        {(char *)"ipx", (BOOLEAN )0, (char *)"application/x-ipix"}, 
        {(char *)"jpe", (BOOLEAN )0, (char *)"image/jpeg"}, 
        {(char *)"jpeg", (BOOLEAN )0, (char *)"image/jpeg"}, 
        {(char *)"jpg", (BOOLEAN )0, (char *)"image/jpeg"}, 
        {(char *)"js", (BOOLEAN )0, (char *)"application/x-javascript"}, 
        {(char *)"json", (BOOLEAN )0, (char *)"application/json"}, 
        {(char *)"kar", (BOOLEAN )0, (char *)"audio/midi"}, 
        {(char *)"latex", (BOOLEAN )0, (char *)"application/x-latex"}, 
        {(char *)"lha", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"lsp", (BOOLEAN )0, (char *)"application/x-lisp"}, 
        {(char *)"lzh", (BOOLEAN )0, (char *)"application/octet-stream"}, 
        {(char *)"m", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"man", (BOOLEAN )0, (char *)"application/x-troff-man"}, 
        {(char *)"me", (BOOLEAN )0, (char *)"application/x-troff-me"}, 
        {(char *)"mesh", (BOOLEAN )0, (char *)"model/mesh"}, 
        {(char *)"mid", (BOOLEAN )0, (char *)"audio/midi"}, 
        {(char *)"midi", (BOOLEAN )0, (char *)"audio/midi"}, 
        {(char *)"mif", (BOOLEAN )0, (char *)"application/vnd.mif"}, 
        {(char *)"mime", (BOOLEAN )0, (char *)"www/mime"}, 
        {(char *)"mov", (BOOLEAN )0, (char *)"video/quicktime"}, 
        {(char *)"movie", (BOOLEAN )0, (char *)"video/x-sgi-movie"}, 
        {(char *)"mp2", (BOOLEAN )0, (char *)"audio/mpeg"}, 
        {(char *)"mp3", (BOOLEAN )0, (char *)"audio/mpeg"}, 
        {(char *)"mpe", (BOOLEAN )0, (char *)"video/mpeg"}, 
        {(char *)"mpeg", (BOOLEAN )0, (char *)"video/mpeg"}, 
        {(char *)"mpg", (BOOLEAN )0, (char *)"video/mpeg"}, 
        {(char *)"mpga", (BOOLEAN )0, (char *)"audio/mpeg"}, 
        {(char *)"ms", (BOOLEAN )0, (char *)"application/x-troff-ms"}, 
        {(char *)"msh", (BOOLEAN )0, (char *)"model/mesh"}, 
        {(char *)"nc", (BOOLEAN )0, (char *)"application/x-netcdf"}, 
        {(char *)"oda", (BOOLEAN )0, (char *)"application/oda"}, 
        {(char *)"pbm", (BOOLEAN )0, (char *)"image/x-portable-bitmap"}, 
        {(char *)"pdb", (BOOLEAN )0, (char *)"chemical/x-pdb"}, 
        {(char *)"pdf", (BOOLEAN )0, (char *)"application/pdf"}, 
        {(char *)"pgm", (BOOLEAN )0, (char *)"image/x-portable-graymap"}, 
        {(char *)"pgn", (BOOLEAN )0, (char *)"application/x-chess-pgn"}, 
        {(char *)"png", (BOOLEAN )0, (char *)"image/png"}, 
        {(char *)"pnm", (BOOLEAN )0, (char *)"image/x-portable-anymap"}, 
        {(char *)"pot", (BOOLEAN )0, (char *)"application/mspowerpoint"}, 
        {(char *)"ppm", (BOOLEAN )0, (char *)"image/x-portable-pixmap"}, 
        {(char *)"pps", (BOOLEAN )0, (char *)"application/mspowerpoint"}, 
        {(char *)"ppt", (BOOLEAN )0, (char *)"application/mspowerpoint"}, 
        {(char *)"ppz", (BOOLEAN )0, (char *)"application/mspowerpoint"}, 
        {(char *)"pre", (BOOLEAN )0, (char *)"application/x-freelance"}, 
        {(char *)"prt", (BOOLEAN )0, (char *)"application/pro_eng"}, 
        {(char *)"ps", (BOOLEAN )0, (char *)"application/postscript"}, 
        {(char *)"qt", (BOOLEAN )0, (char *)"video/quicktime"}, 
        {(char *)"ra", (BOOLEAN )0, (char *)"audio/x-realaudio"}, 
        {(char *)"ram", (BOOLEAN )0, (char *)"audio/x-pn-realaudio"}, 
        {(char *)"ras", (BOOLEAN )0, (char *)"image/cmu-raster"}, 
        {(char *)"rgb", (BOOLEAN )0, (char *)"image/x-rgb"}, 
        {(char *)"rm", (BOOLEAN )0, (char *)"audio/x-pn-realaudio"}, 
        {(char *)"roff", (BOOLEAN )0, (char *)"application/x-troff"}, 
        {(char *)"rpm", (BOOLEAN )0, (char *)"audio/x-pn-realaudio-plugin"}, 
        {(char *)"rtf", (BOOLEAN )0, (char *)"text/rtf"}, 
        {(char *)"rtx", (BOOLEAN )0, (char *)"text/richtext"}, 
        {(char *)"scm", (BOOLEAN )0, (char *)"application/x-lotusscreencam"}, 
        {(char *)"set", (BOOLEAN )0, (char *)"application/set"}, 
        {(char *)"sgm", (BOOLEAN )1, (char *)"text/sgml"}, 
        {(char *)"sgml", (BOOLEAN )1, (char *)"text/sgml"}, 
        {(char *)"sh", (BOOLEAN )0, (char *)"application/x-sh"}, 
        {(char *)"shar", (BOOLEAN )0, (char *)"application/x-shar"}, 
        {(char *)"silo", (BOOLEAN )0, (char *)"model/mesh"}, 
        {(char *)"sit", (BOOLEAN )0, (char *)"application/x-stuffit"}, 
        {(char *)"skd", (BOOLEAN )0, (char *)"application/x-koan"}, 
        {(char *)"skm", (BOOLEAN )0, (char *)"application/x-koan"}, 
        {(char *)"skp", (BOOLEAN )0, (char *)"application/x-koan"}, 
        {(char *)"skt", (BOOLEAN )0, (char *)"application/x-koan"}, 
        {(char *)"smi", (BOOLEAN )0, (char *)"application/smil"}, 
        {(char *)"smil", (BOOLEAN )0, (char *)"application/smil"}, 
        {(char *)"snd", (BOOLEAN )0, (char *)"audio/basic"}, 
        {(char *)"sol", (BOOLEAN )0, (char *)"application/solids"}, 
        {(char *)"spl", (BOOLEAN )0, (char *)"application/x-futuresplash"}, 
        {(char *)"src", (BOOLEAN )0, (char *)"application/x-wais-source"}, 
        {(char *)"step", (BOOLEAN )0, (char *)"application/STEP"}, 
        {(char *)"stl", (BOOLEAN )0, (char *)"application/SLA"}, 
        {(char *)"stp", (BOOLEAN )0, (char *)"application/STEP"}, 
        {(char *)"sv4cpio", (BOOLEAN )0, (char *)"application/x-sv4cpio"}, 
        {(char *)"sv4crc", (BOOLEAN )0, (char *)"application/x-sv4crc"}, 
        {(char *)"swf", (BOOLEAN )0, (char *)"application/x-shockwave-flash"}, 
        {(char *)"t", (BOOLEAN )0, (char *)"application/x-troff"}, 
        {(char *)"tar", (BOOLEAN )0, (char *)"application/x-tar"}, 
        {(char *)"tcl", (BOOLEAN )0, (char *)"application/x-tcl"}, 
        {(char *)"tex", (BOOLEAN )0, (char *)"application/x-tex"}, 
        {(char *)"texi", (BOOLEAN )0, (char *)"application/x-texinfo"}, 
        {(char *)"texinfo", (BOOLEAN )0, (char *)"application/x-texinfo"}, 
        {(char *)"tif", (BOOLEAN )0, (char *)"image/tiff"}, 
        {(char *)"tiff", (BOOLEAN )0, (char *)"image/tiff"}, 
        {(char *)"tr", (BOOLEAN )0, (char *)"application/x-troff"}, 
        {(char *)"tsi", (BOOLEAN )0, (char *)"audio/TSP-audio"}, 
        {(char *)"tsp", (BOOLEAN )0, (char *)"application/dsptype"}, 
        {(char *)"tsv", (BOOLEAN )1, (char *)"text/tab-separated-values"}, 
        {(char *)"txt", (BOOLEAN )1, (char *)"text/plain"}, 
        {(char *)"unv", (BOOLEAN )0, (char *)"application/i-deas"}, 
        {(char *)"ustar", (BOOLEAN )0, (char *)"application/x-ustar"}, 
        {(char *)"vcd", (BOOLEAN )0, (char *)"application/x-cdlink"}, 
        {(char *)"vda", (BOOLEAN )0, (char *)"application/vda"}, 
        {(char *)"viv", (BOOLEAN )0, (char *)"video/vnd.vivo"}, 
        {(char *)"vivo", (BOOLEAN )0, (char *)"video/vnd.vivo"}, 
        {(char *)"vrml", (BOOLEAN )0, (char *)"model/vrml"}, 
        {(char *)"wav", (BOOLEAN )0, (char *)"audio/x-wav"}, 
        {(char *)"wrl", (BOOLEAN )0, (char *)"model/vrml"}, 
        {(char *)"xbm", (BOOLEAN )0, (char *)"image/x-xbitmap"}, 
        {(char *)"xlc", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xll", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xlm", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xls", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xlw", (BOOLEAN )0, (char *)"application/vnd.ms-excel"}, 
        {(char *)"xml", (BOOLEAN )1, (char *)"text/xml"}, 
        {(char *)"xpm", (BOOLEAN )0, (char *)"image/x-xpixmap"}, 
        {(char *)"xwd", (BOOLEAN )0, (char *)"image/x-xwindowdump"}, 
        {(char *)"xyz", (BOOLEAN )0, (char *)"chemical/x-pdb"}, 
        {(char *)"zip", (BOOLEAN )0, (char *)"application/zip"}};
#line 209 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/load.c"
char *get_content_type(char *file ) 
{ 
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  BOOLEAN tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 214
  i = 0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (i < (int )sizeof(tmap) / (int )sizeof(tmap[0]))) {
#line 214
      goto while_break;
    }
    {
#line 215
    tmp___2 = strlen((char const   *)file);
#line 215
    tmp___3 = strlen((char const   *)tmap[i].ext);
    }
#line 215
    if (tmp___2 >= tmp___3) {
      {
#line 216
      tmp = strlen((char const   *)file);
#line 216
      tmp___0 = strlen((char const   *)tmap[i].ext);
#line 216
      tmp___1 = strmatch((file + tmp) - tmp___0, (char *)tmap[i].ext);
      }
#line 216
      if (tmp___1) {
#line 217
        return ((char *)tmap[i].type);
      }
    }
#line 214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return ((char *)tmap[0].type);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/load.c"
BOOLEAN is_ascii(char *file ) 
{ 
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  BOOLEAN tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 229
  i = 0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < (int )sizeof(tmap) / (int )sizeof(tmap[0]))) {
#line 229
      goto while_break;
    }
    {
#line 230
    tmp___2 = strlen((char const   *)file);
#line 230
    tmp___3 = strlen((char const   *)tmap[i].ext);
    }
#line 230
    if (tmp___2 >= tmp___3) {
      {
#line 231
      tmp = strlen((char const   *)file);
#line 231
      tmp___0 = strlen((char const   *)tmap[i].ext);
#line 231
      tmp___1 = strmatch((file + tmp) - tmp___0, (char *)tmap[i].ext);
      }
#line 231
      if (tmp___1) {
#line 232
        return ((BOOLEAN )tmap[i].ascii);
      }
    }
#line 229
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return ((BOOLEAN )tmap[0].ascii);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/load.c"
void load_file(URL U , char *file ) 
{ 
  FILE *fp ;
  size_t len ;
  char *buf ;
  char *filename ;
  char mode[8] ;
  char const   *tmp___0 ;
  BOOLEAN tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  BOOLEAN tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 252
  filename = trim(file);
#line 254
  memset((void *)(mode), '\000', sizeof(mode));
#line 255
  tmp___1 = is_ascii(filename);
  }
#line 255
  if (tmp___1) {
#line 255
    tmp___0 = "r";
  } else {
#line 255
    tmp___0 = "rb";
  }
  {
#line 255
  snprintf((char */* __restrict  */)(mode), sizeof(mode), (char const   */* __restrict  */)"%s",
           tmp___0);
#line 256
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)(mode));
  }
#line 257
  if (! fp) {
    {
#line 258
    NOTIFY((LEVEL )2, "unable to open file: %s", filename);
    }
#line 259
    return;
  }
  {
#line 262
  fseek(fp, 0L, 2);
#line 263
  tmp___2 = ftell(fp);
#line 263
  len = (size_t )tmp___2;
#line 264
  fseek(fp, 0L, 0);
#line 265
  tmp___3 = xmalloc(len + 1UL);
#line 265
  buf = (char *)tmp___3;
#line 267
  tmp___5 = fread((void */* __restrict  */)buf, (size_t )1, len, (FILE */* __restrict  */)fp);
  }
#line 267
  if (tmp___5 == len) {
    {
#line 268
    tmp___4 = is_ascii(filename);
    }
#line 268
    if (tmp___4) {
      {
#line 269
      trim(buf);
#line 270
      len = strlen((char const   *)buf);
      }
    }
  } else {
    {
#line 273
    NOTIFY((LEVEL )2, "unable to read file: %s", filename);
    }
  }
  {
#line 275
  fclose(fp);
  }
#line 277
  if (len > 0UL) {
    {
#line 278
    tmp___6 = get_content_type(filename);
#line 278
    url_set_conttype(U, tmp___6);
#line 279
    url_set_postdata(U, buf, len);
    }
  }
  {
#line 282
  xfree((void *)buf);
  }
#line 283
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/load.c"
void write_file(URL U , char *buf , size_t len ) 
{ 
  FILE *fp ;
  char mode[8] ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 292
  memset((void *)(mode), '\000', sizeof(mode));
#line 293
  tmp___1 = url_get_file(U);
  }
#line 293
  if (tmp___1) {
#line 293
    tmp___0 = "w";
  } else {
#line 293
    tmp___0 = "wb";
  }
  {
#line 293
  snprintf((char */* __restrict  */)(mode), sizeof(mode), (char const   */* __restrict  */)"%s",
           tmp___0);
#line 294
  tmp___2 = url_get_file(U);
#line 294
  fp = fopen((char const   */* __restrict  */)tmp___2, (char const   */* __restrict  */)(mode));
  }
#line 296
  if (fp) {
    {
#line 297
    fwrite((void const   */* __restrict  */)buf, len, (size_t )1, (FILE */* __restrict  */)fp);
    }
  } else {
    {
#line 299
    NOTIFY((LEVEL )2, "unable to write to file");
    }
  }
  {
#line 302
  fclose(fp);
  }
#line 303
  return;
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/version.c"
char const   *version_string  =    "3.0.5";
#line 8 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/version.c"
char const   *program_name  =    "siege";
#line 9 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/version.c"
char const   *author_name  =    "Jeffrey Fulmer, et al.";
#line 10 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/version.c"
char const   *email_address  =    "jeff@joedog.org";
#line 11 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/version.c"
char const   *years  =    "1999-2013";
#line 12 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/version.c"
char const   *copyright  =    "Copyright (C) 2013 by Jeffrey Fulmer, et al.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.\n";
#line 36 "./perl.h"
char *chomp(char *str ) ;
#line 42
char *rtrim(char *str ) ;
#line 48
char *ltrim(char *str ) ;
#line 60
int word_count(char pattern , char *s ) ;
#line 66
char **split(char pattern , char *s , int *n_words ) ;
#line 71
void split_free(char **split___0 , int length ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/perl.c"
char *chomp(char *str ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 45
  if (*str) {
    {
#line 45
    tmp___0 = strlen((char const   *)str);
    }
#line 45
    if ((int )*(str + (tmp___0 - 1UL)) == 10) {
      {
#line 45
      tmp = strlen((char const   *)str);
#line 45
      *(str + (tmp - 1UL)) = (char)0;
      }
    }
  }
#line 46
  return (str);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/perl.c"
char *rtrim(char *str ) 
{ 
  char *ptr ;
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 58
  tmp = strlen((char const   *)str);
#line 58
  len = (int )tmp;
#line 59
  ptr = (str + len) - 1;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if ((unsigned long )ptr >= (unsigned long )str) {
      {
#line 59
      tmp___0 = __ctype_b_loc();
      }
#line 59
      if (! ((int const   )*(*tmp___0 + (int )*ptr) & 8192)) {
#line 59
        goto while_break;
      }
    } else {
#line 59
      goto while_break;
    }
#line 59
    ptr --;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  *(ptr + 1) = (char )'\000';
#line 63
  return (str);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/perl.c"
char *ltrim(char *str ) 
{ 
  char *ptr ;
  int len ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;

  {
#line 75
  ptr = str;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (*ptr) {
      {
#line 75
      tmp = __ctype_b_loc();
      }
#line 75
      if (! ((int const   )*(*tmp + (int )*ptr) & 8192)) {
#line 75
        goto while_break;
      }
    } else {
#line 75
      goto while_break;
    }
#line 75
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  tmp___0 = strlen((char const   *)ptr);
#line 77
  len = (int )tmp___0;
#line 78
  memmove((void *)str, (void const   *)ptr, (size_t )(len + 1));
  }
#line 80
  return (str);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/perl.c"
char *trim(char *str ) 
{ 
  char *ptr ;

  {
  {
#line 90
  ptr = rtrim(str);
#line 91
  str = ltrim(ptr);
  }
#line 92
  return (str);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/perl.c"
int valid(char const   *s ) 
{ 
  int flag ;
  int i ;
  int tmp ;

  {
#line 98
  flag = 0;
#line 99
  i = 0;
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i <= 255)) {
#line 101
      goto while_break;
    }
#line 102
    if (flag) {
#line 102
      tmp = 1;
    } else
#line 102
    if ((int const   )*(s + i) == 0) {
#line 102
      tmp = 1;
    } else {
#line 102
      tmp = 0;
    }
#line 102
    flag = tmp;
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (flag) {
#line 106
    return (1);
  } else {
#line 108
    return (0);
  }
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/perl.c"
int empty(char const   *s ) 
{ 
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 115
  if (! s) {
#line 115
    return (1);
  }
  {
#line 116
  tmp = strlen(s);
  }
#line 116
  if (tmp < 1UL) {
#line 116
    return (1);
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    tmp___0 = __ctype_b_loc();
    }
#line 118
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
#line 118
      goto while_break;
    }
#line 119
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return ((int const   )*s == 0);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/perl.c"
int word_count(char pattern , char *s ) 
{ 
  int in_word_flag ;
  int count ;
  char *ptr ;

  {
#line 127
  in_word_flag = 0;
#line 128
  count = 0;
#line 131
  ptr = s;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! *ptr) {
#line 132
      goto while_break;
    }
#line 133
    if ((int )*ptr != (int )pattern) {
#line 134
      if (in_word_flag == 0) {
#line 135
        count ++;
      }
#line 136
      in_word_flag = 1;
    } else {
#line 138
      in_word_flag = 0;
    }
#line 140
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return (count);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/perl.c"
char **split(char pattern , char *s , int *n_words ) 
{ 
  char **words ;
  char *str0 ;
  char *str1 ;
  int i ;
  void *tmp ;
  size_t len ;
  void *tmp___0 ;

  {
  {
#line 152
  *n_words = word_count(pattern, s);
  }
#line 153
  if (*n_words == 0) {
#line 154
    return ((char **)((void *)0));
  }
  {
#line 156
  tmp = xmalloc((unsigned long )*n_words * sizeof(*words));
#line 156
  words = (char **)tmp;
  }
#line 157
  if (! words) {
#line 158
    return ((char **)((void *)0));
  }
#line 160
  str0 = s;
#line 161
  i = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! *str0) {
#line 162
      goto while_break;
    }
    {
#line 164
    str1 = strchr((char const   *)str0, (int )pattern);
    }
#line 165
    if ((unsigned long )str1 != (unsigned long )((void *)0)) {
#line 166
      len = (size_t )(str1 - str0);
    } else {
      {
#line 168
      len = strlen((char const   *)str0);
      }
    }
#line 179
    if (len == 0UL) {
#line 180
      i --;
    } else {
      {
#line 182
      tmp___0 = xmalloc((size_t )256);
#line 182
      *(words + i) = (char *)tmp___0;
#line 183
      memset((void *)*(words + i), '\000', (size_t )256);
#line 184
      memcpy((void */* __restrict  */)*(words + i), (void const   */* __restrict  */)str0,
             (size_t )256);
#line 185
      *(*(words + i) + len) = (char )'\000';
      }
    }
#line 188
    if ((unsigned long )str1 != (unsigned long )((void *)0)) {
#line 189
      str1 ++;
#line 189
      str0 = str1;
    } else {
#line 191
      goto while_break;
    }
#line 193
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (words);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/perl.c"
void split_free(char **split___0 , int length ) 
{ 
  int x ;
  char *tmp ;

  {
#line 202
  x = 0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (x < length)) {
#line 202
      goto while_break;
    }
#line 203
    if ((unsigned long )*(split___0 + x) != (unsigned long )((void *)0)) {
      {
#line 204
      tmp = *(split___0 + x);
#line 205
      xfree((void *)tmp);
      }
    }
#line 202
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  free((void *)split___0);
  }
#line 210
  return;
}
}
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 61 "./cookie.h"
BOOLEAN delete_cookie(pthread_t id , char *name ) ;
#line 65
void display_cookies(void) ;
#line 67 "./cookie.h"
COOKIE *cookie  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c"
void free_cookie(PARSED_COOKIE *ck ) 
{ 


  {
  {
#line 42
  xfree((void *)ck->name);
#line 43
  xfree((void *)ck->value);
#line 44
  xfree((void *)ck->domain);
#line 45
  xfree((void *)ck->path);
  }
#line 46
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c"
void parse_cookie(char *cookiestr , PARSED_COOKIE *ck ) 
{ 
  char *lval ;
  char *rval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 54
  if ((unsigned long )cookiestr == (unsigned long )((void *)0)) {
#line 54
    return;
  } else
#line 54
  if ((unsigned long )ck == (unsigned long )((void *)0)) {
#line 54
    return;
  }
#line 56
  tmp___1 = (char *)((void *)0);
#line 56
  ck->path = tmp___1;
#line 56
  tmp___0 = tmp___1;
#line 56
  ck->domain = tmp___0;
#line 56
  tmp = tmp___0;
#line 56
  ck->value = tmp;
#line 56
  ck->name = tmp;
#line 57
  tmp___2 = 0;
#line 57
  ck->secure = tmp___2;
#line 57
  ck->expires = (time_t )tmp___2;
#line 59
  lval = cookiestr;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (*cookiestr) {
#line 61
      if (! ((int )*cookiestr != 61)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
#line 62
    cookiestr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  if (! *cookiestr) {
#line 64
    return;
  }
#line 66
  tmp___3 = cookiestr;
#line 66
  cookiestr ++;
#line 66
  *tmp___3 = (char)0;
#line 68
  rval = cookiestr;
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (*cookiestr) {
#line 69
      if (! ((int )*cookiestr != 59)) {
#line 69
        goto while_break___0;
      }
    } else {
#line 69
      goto while_break___0;
    }
#line 70
    cookiestr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 72
  tmp___4 = cookiestr;
#line 72
  cookiestr ++;
#line 72
  *tmp___4 = (char)0;
#line 74
  if ((unsigned long )lval != (unsigned long )((void *)0)) {
    {
#line 74
    debug("%s:%d accepting cookie name:  %s", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c",
          74, lval);
    }
  }
#line 75
  if ((unsigned long )rval != (unsigned long )((void *)0)) {
    {
#line 75
    debug("%s:%d accepting cookie value: %s", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c",
          75, rval);
    }
  }
#line 76
  if ((unsigned long )lval != (unsigned long )((void *)0)) {
    {
#line 76
    tmp___5 = xstrdup((char const   *)lval);
#line 76
    ck->name = tmp___5;
    }
  } else {
#line 76
    ck->name = (char *)((void *)0);
  }
#line 77
  if ((unsigned long )rval != (unsigned long )((void *)0)) {
    {
#line 77
    tmp___6 = xstrdup((char const   *)rval);
#line 77
    ck->value = tmp___6;
    }
  } else {
#line 77
    ck->value = (char *)((void *)0);
  }
#line 79
  ck->expires = (time_t )0;
#line 80
  ck->expires = ~ ck->expires;
#line 81
  if (ck->expires < 0L) {
#line 82
    ck->expires = (time_t )(~ (1UL << (sizeof(ck->expires) * 8UL - 1UL)));
  }
#line 84
  if (ck->expires < 0L) {
#line 85
    ck->expires = (ck->expires >> 1) * -1L;
  }
#line 88
  if (! *cookiestr) {
#line 93
    return;
  }
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if (! *cookiestr) {
#line 96
      goto while_break___1;
    }
    {
#line 97
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 97
      tmp___7 = __ctype_b_loc();
      }
#line 97
      if (! ((int const   )*(*tmp___7 + (int )((unsigned char )*cookiestr)) & 8192)) {
#line 97
        goto while_break___2;
      }
#line 98
      cookiestr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 100
    if (! *cookiestr) {
#line 100
      goto while_break___1;
    }
#line 102
    lval = cookiestr;
    {
#line 103
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 103
      if (*cookiestr) {
#line 103
        if (! ((int )*cookiestr != 61)) {
#line 103
          goto while_break___3;
        }
      } else {
#line 103
        goto while_break___3;
      }
#line 104
      cookiestr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 106
    tmp___10 = strcasecmp((char const   *)lval, "secure");
    }
#line 106
    if (tmp___10) {
#line 110
      if (! *cookiestr) {
#line 110
        return;
      }
#line 112
      tmp___8 = cookiestr;
#line 112
      cookiestr ++;
#line 112
      *tmp___8 = (char)0;
#line 114
      rval = cookiestr;
      {
#line 115
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 115
        if (*cookiestr) {
#line 115
          if (! ((int )*cookiestr != 59)) {
#line 115
            goto while_break___4;
          }
        } else {
#line 115
          goto while_break___4;
        }
#line 116
        cookiestr ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 117
      tmp___9 = cookiestr;
#line 117
      cookiestr ++;
#line 117
      *tmp___9 = (char)0;
    } else {
#line 107
      ck->secure = 1;
#line 108
      rval = (char *)((void *)0);
    }
    {
#line 120
    tmp___15 = strcasecmp((char const   *)lval, "domain");
    }
#line 120
    if (tmp___15) {
      {
#line 122
      tmp___14 = strcasecmp((char const   *)lval, "expires");
      }
#line 122
      if (tmp___14) {
        {
#line 124
        tmp___13 = strcasecmp((char const   *)lval, "path");
        }
#line 124
        if (! tmp___13) {
#line 125
          if ((unsigned long )rval != (unsigned long )((void *)0)) {
            {
#line 125
            tmp___12 = xstrdup((char const   *)rval);
#line 125
            ck->path = tmp___12;
            }
          } else {
#line 125
            ck->path = (char *)((void *)0);
          }
        }
      } else {
        {
#line 123
        ck->expires = strtotime((char const   *)rval);
        }
      }
    } else
#line 121
    if ((unsigned long )rval != (unsigned long )((void *)0)) {
      {
#line 121
      tmp___11 = xstrdup((char const   *)rval);
#line 121
      ck->domain = tmp___11;
      }
    } else {
#line 121
      ck->domain = (char *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c"
int add_cookie(pthread_t id , char *host , char *cookiestr ) 
{ 
  char *name ;
  char *value ;
  int found ;
  CNODE *cur ;
  CNODE *pre ;
  CNODE *fresh ;
  PARSED_COOKIE ck ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 138
  found = 0;
#line 139
  fresh = (CNODE *)((void *)0);
#line 142
  parse_cookie(cookiestr, & ck);
#line 143
  name = ck.name;
#line 144
  value = ck.value;
  }
#line 146
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 146
    return (-1);
  } else
#line 146
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 146
    return (-1);
  }
  {
#line 148
  pthread_mutex_lock(& cookie->mutex);
#line 149
  pre = cookie->first;
#line 149
  cur = pre;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 149
      goto while_break;
    }
#line 150
    if (cur->threadID == id) {
      {
#line 150
      tmp = strcasecmp((char const   *)cur->name, (char const   *)name);
      }
#line 150
      if (! tmp) {
        {
#line 151
        xfree((void *)cur->value);
#line 152
        cur->value = xstrdup((char const   *)value);
#line 165
        found = 1;
        }
#line 166
        goto while_break;
      }
    }
#line 149
    pre = cur;
#line 149
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  if (! found) {
    {
#line 170
    tmp___0 = xmalloc(sizeof(CNODE ));
#line 170
    fresh = (CNODE *)tmp___0;
    }
#line 171
    if (! fresh) {
      {
#line 171
      NOTIFY((LEVEL )3, "out of memory!");
      }
    }
    {
#line 172
    fresh->threadID = id;
#line 173
    fresh->name = xstrdup((char const   *)name);
#line 174
    fresh->value = xstrdup((char const   *)value);
#line 175
    fresh->expires = ck.expires;
    }
#line 176
    if (! ck.domain) {
      {
#line 177
      fresh->domain = xstrdup((char const   *)host);
      }
    } else {
      {
#line 179
      fresh->domain = xstrdup((char const   *)ck.domain);
      }
    }
#line 180
    fresh->next = cur;
#line 181
    if ((unsigned long )cur == (unsigned long )cookie->first) {
#line 182
      cookie->first = fresh;
    } else {
#line 184
      pre->next = fresh;
    }
  }
#line 186
  if ((unsigned long )name != (unsigned long )((void *)0)) {
    {
#line 186
    xfree((void *)name);
    }
  }
#line 187
  if ((unsigned long )value != (unsigned long )((void *)0)) {
    {
#line 187
    xfree((void *)value);
    }
  }
  {
#line 189
  pthread_mutex_unlock(& cookie->mutex);
  }
#line 191
  return (0);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c"
BOOLEAN delete_cookie(pthread_t id , char *name ) 
{ 
  CNODE *cur ;
  CNODE *pre ;
  BOOLEAN res ;
  int tmp ;

  {
#line 198
  res = (BOOLEAN )0;
#line 200
  pre = cookie->first;
#line 200
  cur = pre;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 200
      goto while_break;
    }
#line 201
    if (cur->threadID == id) {
      {
#line 202
      tmp = strcasecmp((char const   *)cur->name, (char const   *)name);
      }
#line 202
      if (! tmp) {
#line 203
        pre->next = cur->next;
#line 206
        if ((unsigned long )cur == (unsigned long )cookie->first) {
#line 208
          cookie->first = cur->next;
#line 209
          pre = cookie->first;
        } else {
#line 212
          pre->next = cur->next;
        }
        {
#line 214
        res = (BOOLEAN )1;
#line 215
        echo("%s:%d cookie deleted: %ld => %s\n", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c",
             215, (long )id, name);
        }
#line 216
        goto while_break;
      }
    }
#line 200
    pre = cur;
#line 200
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (res);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c"
int delete_all_cookies(pthread_t id ) 
{ 
  CNODE *cur ;
  CNODE *pre ;

  {
  {
#line 235
  pthread_mutex_lock(& cookie->mutex);
#line 236
  pre = (CNODE *)((void *)0);
#line 236
  cur = cookie->first;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 236
      goto while_break;
    }
#line 237
    if (cur->threadID == id) {
      {
#line 238
      echo("%s:%d cookie deleted: %ld => %s\n", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c",
           238, (long )id, cur->name);
      }
#line 240
      if ((unsigned long )cur == (unsigned long )cookie->first) {
#line 242
        cookie->first = cur->next;
#line 243
        pre = cookie->first;
      } else {
#line 246
        pre->next = cur->next;
      }
      {
#line 248
      xfree((void *)cur->name);
#line 249
      xfree((void *)cur->value);
#line 250
      xfree((void *)cur->domain);
#line 251
      xfree((void *)cur);
#line 252
      cur = pre;
      }
#line 257
      if ((unsigned long )cur == (unsigned long )((void *)0)) {
#line 258
        goto while_break;
      }
    }
#line 236
    pre = cur;
#line 236
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  pthread_mutex_unlock(& cookie->mutex);
  }
#line 262
  return (0);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c"
char *get_cookie_header(pthread_t id , char *host , char *newton ) 
{ 
  int dlen ;
  int hlen ;
  CNODE *pre ;
  CNODE *cur ;
  time_t now ;
  char oreo[8192] ;
  size_t tmp ;
  char const   *domainptr ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 277
  memset((void *)(oreo), '\000', sizeof(oreo));
#line 278
  tmp = strlen((char const   *)host);
#line 278
  hlen = (int )tmp;
#line 280
  pthread_mutex_lock(& cookie->mutex);
#line 281
  now = time((time_t *)((void *)0));
#line 283
  pre = cookie->first;
#line 283
  cur = pre;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 283
      goto while_break;
    }
#line 287
    domainptr = (char const   *)cur->domain;
#line 288
    if ((int const   )*domainptr == 46) {
#line 288
      domainptr ++;
    }
#line 289
    if (domainptr) {
      {
#line 289
      tmp___0 = strlen(domainptr);
#line 289
      dlen = (int )tmp___0;
      }
    } else {
#line 289
      dlen = 0;
    }
#line 290
    if (cur->threadID == id) {
      {
#line 291
      tmp___6 = strcasecmp(domainptr, (char const   *)host);
      }
#line 291
      if (! tmp___6) {
#line 292
        if (cur->expires <= now) {
          {
#line 293
          delete_cookie(cur->threadID, cur->name);
          }
#line 294
          goto __Cont;
        }
        {
#line 296
        tmp___2 = strlen((char const   *)(oreo));
        }
#line 296
        if (tmp___2 > 0UL) {
          {
#line 297
          tmp___1 = strlen((char const   *)(oreo));
#line 297
          strncat((char */* __restrict  */)(oreo), (char const   */* __restrict  */)";",
                  (sizeof(oreo) - 10UL) - tmp___1);
          }
        }
        {
#line 298
        tmp___3 = strlen((char const   *)(oreo));
#line 298
        strncat((char */* __restrict  */)(oreo), (char const   */* __restrict  */)cur->name,
                (sizeof(oreo) - 10UL) - tmp___3);
#line 299
        tmp___4 = strlen((char const   *)(oreo));
#line 299
        strncat((char */* __restrict  */)(oreo), (char const   */* __restrict  */)"=",
                (sizeof(oreo) - 10UL) - tmp___4);
#line 300
        tmp___5 = strlen((char const   *)(oreo));
#line 300
        strncat((char */* __restrict  */)(oreo), (char const   */* __restrict  */)cur->value,
                (sizeof(oreo) - 10UL) - tmp___5);
        }
      }
#line 302
      if (dlen < hlen) {
        {
#line 302
        tmp___12 = strcasecmp((char const   *)(host + (hlen - dlen)), domainptr);
        }
#line 302
        if (! tmp___12) {
#line 303
          if (cur->expires <= now) {
            {
#line 304
            delete_cookie(cur->threadID, cur->name);
            }
#line 305
            goto __Cont;
          }
          {
#line 307
          tmp___8 = strlen((char const   *)(oreo));
          }
#line 307
          if (tmp___8 > 0UL) {
            {
#line 308
            tmp___7 = strlen((char const   *)(oreo));
#line 308
            strncat((char */* __restrict  */)(oreo), (char const   */* __restrict  */)";",
                    (sizeof(oreo) - 10UL) - tmp___7);
            }
          }
          {
#line 309
          tmp___9 = strlen((char const   *)(oreo));
#line 309
          strncat((char */* __restrict  */)(oreo), (char const   */* __restrict  */)cur->name,
                  (sizeof(oreo) - 10UL) - tmp___9);
#line 310
          tmp___10 = strlen((char const   *)(oreo));
#line 310
          strncat((char */* __restrict  */)(oreo), (char const   */* __restrict  */)"=",
                  (sizeof(oreo) - 10UL) - tmp___10);
#line 311
          tmp___11 = strlen((char const   *)(oreo));
#line 311
          strncat((char */* __restrict  */)(oreo), (char const   */* __restrict  */)cur->value,
                  (sizeof(oreo) - 10UL) - tmp___11);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 283
    pre = cur;
#line 283
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  tmp___13 = strlen((char const   *)(oreo));
  }
#line 315
  if (tmp___13 > 0UL) {
    {
#line 316
    strncpy((char */* __restrict  */)newton, (char const   */* __restrict  */)"Cookie: ",
            (size_t )8);
#line 317
    strncat((char */* __restrict  */)newton, (char const   */* __restrict  */)(oreo),
            (size_t )8192);
#line 318
    strncat((char */* __restrict  */)newton, (char const   */* __restrict  */)"\r\n",
            (size_t )2);
    }
  }
  {
#line 320
  pthread_mutex_unlock(& cookie->mutex);
  }
#line 322
  return (newton);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cookie.c"
void display_cookies(void) 
{ 
  CNODE *cur ;

  {
  {
#line 333
  pthread_mutex_lock(& cookie->mutex);
#line 335
  printf((char const   */* __restrict  */)"Linked list contains:\n");
#line 336
  cur = cookie->first;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 336
      goto while_break;
    }
    {
#line 337
    printf((char const   */* __restrict  */)"Index: %ld\tName: %s Value: %s\n", (long )cur->threadID,
           cur->name, cur->value);
#line 336
    cur = cur->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 340
  pthread_mutex_unlock(& cookie->mutex);
  }
#line 342
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 381 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand_r)(unsigned int *__seed ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 406
 __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *str ,
                                                                                          size_t len )  __attribute__((__pure__)) ;
#line 69 "../include/joedog/joedog.h"
char *substring(char *str , int start , int len ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
void pthread_usleep_np(unsigned long usec ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
void parse_time(char *p ) 
{ 
  size_t x ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 41
  x = (size_t )0;
#line 42
  my.secs = 0;
#line 42
  my.time = my.secs;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 44
    tmp = __ctype_b_loc();
    }
#line 44
    if (! ((int const   )*(*tmp + (int )((unsigned char )*(p + x))) & 2048)) {
#line 44
      goto while_break;
    }
#line 45
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  if (x == 0UL) {
#line 46
    return;
  }
  {
#line 47
  tmp___0 = substring(p, 0, (int )x);
#line 47
  my.time = atoi((char const   *)tmp___0);
  }
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 49
    tmp___2 = strlen((char const   *)p);
    }
#line 49
    if (! (x < tmp___2)) {
#line 49
      goto while_break___0;
    }
    {
#line 50
    tmp___1 = tolower((int )*(p + x));
    }
    {
#line 51
    if (tmp___1 == 115) {
#line 51
      goto case_115;
    }
#line 55
    if (tmp___1 == 109) {
#line 55
      goto case_109;
    }
#line 59
    if (tmp___1 == 104) {
#line 59
      goto case_104;
    }
#line 63
    goto switch_default;
    case_115: /* CIL Label */ 
#line 52
    my.secs = my.time;
#line 53
    my.time = 1;
#line 54
    return;
    case_109: /* CIL Label */ 
#line 56
    my.secs = my.time * 60;
#line 57
    my.time = 1;
#line 58
    return;
    case_104: /* CIL Label */ 
#line 60
    my.secs = my.time * 3600;
#line 61
    my.time = 1;
#line 62
    return;
    switch_default: /* CIL Label */ 
#line 64
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 49
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 66
  if (my.time > 0) {
#line 66
    if (my.secs <= 0) {
#line 67
      my.secs = my.time * 60;
    }
  }
#line 70
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
BOOLEAN okay(int code ) 
{ 
  int tmp ;

  {
#line 76
  if (code >= 100) {
#line 76
    if (code <= 299) {
#line 76
      tmp = 1;
    } else {
#line 76
      tmp = 0;
    }
  } else {
#line 76
    tmp = 0;
  }
#line 76
  return ((BOOLEAN )tmp);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
BOOLEAN strmatch(char *option , char *param ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 83
  tmp = strlen((char const   *)param);
#line 83
  tmp___0 = strncasecmp((char const   *)option, (char const   *)param, tmp);
  }
#line 83
  if (tmp___0) {
#line 86
    return ((BOOLEAN )0);
  } else {
    {
#line 83
    tmp___1 = strlen((char const   *)option);
#line 83
    tmp___2 = strlen((char const   *)param);
    }
#line 83
    if (tmp___1 == tmp___2) {
#line 84
      return ((BOOLEAN )1);
    } else {
#line 86
      return ((BOOLEAN )0);
    }
  }
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
char *uppercase(char *s , size_t len ) 
{ 
  unsigned char *c ;
  unsigned char *e ;
  int tmp ;

  {
#line 93
  c = (unsigned char *)s;
#line 94
  e = c + len;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! ((unsigned long )c < (unsigned long )e)) {
#line 96
      goto while_break;
    }
    {
#line 97
    tmp = toupper((int )*c);
#line 97
    *c = (unsigned char )tmp;
#line 98
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (s);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
char *lowercase(char *s , size_t len ) 
{ 
  unsigned char *c ;
  unsigned char *e ;
  int tmp ;

  {
#line 108
  c = (unsigned char *)s;
#line 109
  e = c + len;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((unsigned long )c < (unsigned long )e)) {
#line 111
      goto while_break;
    }
    {
#line 112
    tmp = tolower((int )*c);
#line 112
    *c = (unsigned char )tmp;
#line 113
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (s);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
void pthread_sleep_np(unsigned int secs ) 
{ 


  {
  {
#line 135
  sleep(secs);
  }
#line 138
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
void pthread_usleep_np(unsigned long usec ) 
{ 


  {
  {
#line 168
  usleep((__useconds_t )usec);
  }
#line 170
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
void echo(char const   *fmt  , ...) 
{ 
  char buf[256] ;
  va_list ap ;
  size_t tmp ;

  {
#line 179
  if (my.quiet) {
#line 180
    return;
  }
#line 183
  if (my.get) {
    {
#line 184
    __builtin_va_start(ap, fmt);
#line 185
    vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)fmt,
              ap);
#line 186
    printf((char const   */* __restrict  */)"%s", buf);
#line 187
    __builtin_va_end(ap);
#line 188
    fflush(stdout);
    }
#line 189
    return;
  }
#line 192
  if (my.debug) {
    {
#line 193
    __builtin_va_start(ap, fmt);
#line 194
    vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)fmt,
              ap);
#line 195
    tmp = strlen((char const   *)(buf));
    }
#line 195
    if (tmp == 1UL) {
      {
#line 196
      printf((char const   */* __restrict  */)"%s", buf);
      }
    } else {
      {
#line 198
      NOTIFY((LEVEL )0, (char const   *)(buf));
      }
    }
    {
#line 200
    __builtin_va_end(ap);
    }
  }
#line 202
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
void debug(char const   *fmt  , ...) 
{ 
  char buf[256] ;
  va_list ap ;
  size_t tmp ;

  {
#line 211
  if (my.quiet) {
#line 212
    return;
  }
#line 215
  if (my.debug) {
    {
#line 216
    __builtin_va_start(ap, fmt);
#line 217
    vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)fmt,
              ap);
#line 218
    tmp = strlen((char const   *)(buf));
    }
#line 218
    if (tmp == 1UL) {
      {
#line 219
      printf((char const   */* __restrict  */)"%s", buf);
      }
    } else {
      {
#line 221
      NOTIFY((LEVEL )0, (char const   *)(buf));
      }
    }
    {
#line 223
    __builtin_va_end(ap);
    }
  }
#line 225
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
int pthread_rand_np(unsigned int *ctx ) 
{ 
  int tmp ;

  {
  {
#line 284
  tmp = rand_r(ctx);
  }
#line 284
  return (tmp);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
int urandom(void) 
{ 
  int rand___0 ;
  int fd ;

  {
  {
#line 292
  rand___0 = -1;
#line 295
  fd = open("/dev/urandom", 0);
  }
#line 295
  if (fd >= 0) {
    {
#line 296
    read(fd, (void *)(& rand___0), sizeof(rand___0));
#line 297
    close(fd);
    }
  }
#line 299
  return (rand___0);
}
}
#line 309
 __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *str ,
                                                                                          size_t len )  __attribute__((__pure__)) ;
#line 309 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *str , size_t len ) 
{ 
  char const   *end ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 312
  tmp = memchr((void const   *)str, '\000', len);
#line 312
  end = (char const   *)tmp;
  }
#line 313
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 313
    tmp___0 = (size_t )(end - str);
  } else {
#line 313
    tmp___0 = len;
  }
#line 313
  return (tmp___0);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/util.c"
char const   *strncasestr(char const   *str1 , char const   *str2 , size_t len ) 
{ 
  size_t str1_len ;
  size_t tmp ;
  size_t str2_len ;
  size_t tmp___0 ;
  size_t i ;
  int tmp___1 ;

  {
  {
#line 321
  tmp = strnlen(str1, len);
#line 321
  str1_len = tmp;
#line 322
  tmp___0 = strlen(str2);
#line 322
  str2_len = tmp___0;
  }
#line 325
  if (str1_len < 1UL) {
#line 326
    return ((char const   *)((void *)0));
  } else
#line 325
  if (str2_len < 1UL) {
#line 326
    return ((char const   *)((void *)0));
  }
#line 329
  i = (size_t )0;
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! (i < (str1_len - str2_len) + 1UL)) {
#line 329
      goto while_break;
    }
    {
#line 330
    tmp___1 = strncasecmp(str1, str2, str2_len);
    }
#line 330
    if (tmp___1 == 0) {
#line 331
      return (str1);
    }
#line 333
    str1 ++;
#line 329
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  return ((char const   *)((void *)0));
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ssl.c"
BOOLEAN SSL_initialize(CONN *C ) 
{ 


  {
#line 140
  C->nossl = (BOOLEAN )1;
#line 141
  return ((BOOLEAN )0);
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 31 "./auth.h"
size_t AUTHSIZE ;
#line 37
AUTH new_auth(void) ;
#line 38
AUTH auth_destroy(AUTH this ) ;
#line 39
void auth_add(AUTH this , CREDS creds ) ;
#line 40
void auth_display(AUTH this , SCHEME scheme ) ;
#line 46
void auth_set_proxy_required(AUTH this , BOOLEAN required ) ;
#line 48
void auth_set_proxy_host(AUTH this , char *host ) ;
#line 50
void auth_set_proxy_port(AUTH this , int port ) ;
#line 60 "../include/joedog/joedog.h"
char *xstrcat(char const   *arg1  , ...) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
size_t AUTHSIZE  =    sizeof(struct AUTH_T );
#line 85
static BOOLEAN __basic_header(AUTH this , SCHEME scheme , CREDS creds ) ;
#line 86
static DCHLG *__digest_challenge(char const   *challenge ) ;
#line 87
static DCRED *__digest_credentials(CREDS creds , size_t *randseed ) ;
#line 88
static KEY_HEADER_E __get_keyval(char const   *key ) ;
#line 89
static char *__get_random_string(size_t length , unsigned int *randseed ) ;
#line 90
static char *__get_h_a1(DCHLG const   *chlg , DCRED *cred , char const   *nonce_value ) ;
#line 91
static char *__get_md5_str(char const   *buf ) ;
#line 92
static BOOLEAN __str_list_contains(char const   *str , char const   *pattern , size_t pattern_len ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
AUTH new_auth(void) 
{ 
  AUTH this ;
  void *tmp ;

  {
  {
#line 99
  tmp = calloc(AUTHSIZE, (size_t )1);
#line 99
  this = (AUTH )tmp;
#line 100
  this->creds = new_array();
#line 101
  this->basic.encode = xstrdup("");
#line 102
  this->digest.encode = xstrdup("");
#line 103
  this->proxy.encode = xstrdup("");
  }
#line 104
  return (this);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
AUTH auth_destroy(AUTH this ) 
{ 


  {
  {
#line 110
  this->creds = array_destroy(this->creds);
#line 111
  xfree((void *)this);
  }
#line 112
  return ((AUTH )((void *)0));
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
void auth_add(AUTH this , CREDS creds ) 
{ 


  {
  {
#line 118
  array_npush(this->creds, (void *)creds, CREDSIZE);
  }
#line 119
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
void auth_display(AUTH this , SCHEME scheme ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  SCHEME tmp___4 ;
  size_t tmp___5 ;

  {
#line 127
  i = (size_t )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    tmp___5 = array_length(this->creds);
    }
#line 127
    if (! (i < tmp___5)) {
#line 127
      goto while_break;
    }
    {
#line 128
    tmp___0 = array_get(this->creds, (int )i);
#line 128
    tmp = (CREDS )tmp___0;
#line 129
    tmp___4 = creds_get_scheme(tmp);
    }
#line 129
    if ((unsigned int )tmp___4 == (unsigned int )scheme) {
      {
#line 130
      tmp___1 = creds_get_realm(tmp);
#line 130
      tmp___2 = creds_get_password(tmp);
#line 130
      tmp___3 = creds_get_username(tmp);
#line 130
      printf((char const   */* __restrict  */)"credentials:  %s:%s:%s\n", tmp___3,
             tmp___2, tmp___1);
      }
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
char *auth_get_basic_header(AUTH this , SCHEME scheme ) 
{ 


  {
#line 138
  if ((unsigned int )scheme == 4U) {
#line 139
    return (this->proxy.encode);
  } else {
#line 141
    return (this->basic.encode);
  }
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
BOOLEAN auth_set_basic_header(AUTH this , SCHEME scheme , char *realm ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  BOOLEAN tmp___1 ;
  SCHEME tmp___2 ;
  SCHEME tmp___3 ;
  char *tmp___4 ;
  BOOLEAN tmp___5 ;
  size_t tmp___6 ;
  CREDS tmp___7 ;
  void *tmp___8 ;
  BOOLEAN tmp___9 ;
  SCHEME tmp___10 ;
  SCHEME tmp___11 ;
  char *tmp___12 ;
  BOOLEAN tmp___13 ;
  size_t tmp___14 ;

  {
#line 149
  i = (size_t )0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 149
    tmp___6 = array_length(this->creds);
    }
#line 149
    if (! (i < tmp___6)) {
#line 149
      goto while_break;
    }
    {
#line 150
    tmp___0 = array_get(this->creds, (int )i);
#line 150
    tmp = (CREDS )tmp___0;
#line 151
    tmp___4 = creds_get_realm(tmp);
#line 151
    tmp___5 = strmatch(tmp___4, realm);
    }
#line 151
    if (tmp___5) {
      {
#line 152
      tmp___2 = creds_get_scheme(tmp);
      }
#line 152
      if ((unsigned int )tmp___2 == 1U) {
        {
#line 153
        tmp___1 = __basic_header(this, scheme, tmp);
        }
#line 153
        return (tmp___1);
      } else {
        {
#line 152
        tmp___3 = creds_get_scheme(tmp);
        }
#line 152
        if ((unsigned int )tmp___3 == 2U) {
          {
#line 153
          tmp___1 = __basic_header(this, scheme, tmp);
          }
#line 153
          return (tmp___1);
        }
      }
    }
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  i = (size_t )0;
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 160
    tmp___14 = array_length(this->creds);
    }
#line 160
    if (! (i < tmp___14)) {
#line 160
      goto while_break___0;
    }
    {
#line 161
    tmp___8 = array_get(this->creds, (int )i);
#line 161
    tmp___7 = (CREDS )tmp___8;
#line 162
    tmp___12 = creds_get_realm(tmp___7);
#line 162
    tmp___13 = strmatch(tmp___12, (char *)"any");
    }
#line 162
    if (tmp___13) {
      {
#line 163
      tmp___10 = creds_get_scheme(tmp___7);
      }
#line 163
      if ((unsigned int )tmp___10 == 1U) {
        {
#line 164
        tmp___9 = __basic_header(this, scheme, tmp___7);
        }
#line 164
        return (tmp___9);
      } else {
        {
#line 163
        tmp___11 = creds_get_scheme(tmp___7);
        }
#line 163
        if ((unsigned int )tmp___11 == 2U) {
          {
#line 164
          tmp___9 = __basic_header(this, scheme, tmp___7);
          }
#line 164
          return (tmp___9);
        }
      }
    }
#line 160
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 168
  return ((BOOLEAN )0);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
char *auth_get_digest_header(AUTH this , SCHEME scheme , DCHLG *chlg , DCRED *cred ,
                             char const   *method , char const   *uri ) 
{ 
  size_t len ;
  char *cnonce ;
  char *nonce_count ;
  char *qop ;
  char *response ;
  char *request_digest ;
  char *h_a1 ;
  char *h_a2 ;
  char *opaque ;
  char *result ;
  char *tmp ;
  BOOLEAN tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 176
  cnonce = (char *)((void *)0);
#line 177
  nonce_count = (char *)((void *)0);
#line 178
  qop = (char *)((void *)0);
#line 179
  response = (char *)((void *)0);
#line 180
  request_digest = (char *)((void *)0);
#line 181
  h_a1 = (char *)((void *)0);
#line 182
  h_a2 = (char *)((void *)0);
#line 183
  opaque = (char *)((void *)0);
#line 186
  if ((unsigned long )((void *)0) != (unsigned long )chlg->qop) {
    {
#line 187
    nonce_count = xstrcat(", nc=", cred->nc, (void *)0);
#line 188
    cnonce = xstrcat(", cnonce=\"", cred->cnonce_value, "\"", (void *)0);
#line 190
    h_a1 = __get_h_a1((DCHLG const   *)chlg, cred, (char const   *)chlg->nonce);
    }
#line 190
    if ((unsigned long )((void *)0) == (unsigned long )h_a1) {
      {
#line 191
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error calling __get_h_a1\n");
      }
#line 192
      return ((char *)((void *)0));
    }
    {
#line 195
    tmp___0 = __str_list_contains((char const   *)chlg->qop, "auth", (size_t )4);
    }
#line 195
    if (tmp___0) {
      {
#line 196
      qop = xstrdup(", qop=auth");
#line 197
      tmp = xstrcat(method, ":", uri, (void *)0);
#line 198
      h_a2 = __get_md5_str((char const   *)tmp);
#line 199
      xfree((void *)tmp);
#line 201
      tmp = xstrcat((char const   *)h_a1, ":", chlg->nonce, ":", cred->nc, ":", cred->cnonce_value,
                    ":auth:", h_a2, (void *)0);
#line 202
      request_digest = __get_md5_str((char const   *)tmp);
#line 203
      xfree((void *)tmp);
#line 204
      response = xstrcat(", response=\"", request_digest, "\"", (void *)0);
      }
    } else {
      {
#line 206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error quality of protection not supported: %s\n",
              chlg->qop);
      }
#line 207
      return ((char *)((void *)0));
    }
  } else {
    {
#line 210
    h_a1 = __get_h_a1((DCHLG const   *)chlg, cred, "");
    }
#line 210
    if ((unsigned long )((void *)0) == (unsigned long )h_a1) {
      {
#line 211
      NOTIFY((LEVEL )2, "__get_h_a1\n");
      }
#line 212
      return ((char *)((void *)0));
    }
    {
#line 214
    tmp = xstrcat(method, ":", uri, (void *)0);
#line 215
    h_a2 = __get_md5_str((char const   *)tmp);
#line 216
    xfree((void *)tmp);
#line 217
    tmp = xstrcat((char const   *)h_a1, ":", chlg->nonce, ":", h_a2, (void *)0);
#line 218
    request_digest = __get_md5_str((char const   *)tmp);
#line 219
    xfree((void *)tmp);
#line 220
    response = xstrcat(" response=\"", request_digest, "\"", (void *)0);
    }
  }
#line 222
  if ((unsigned long )((void *)0) != (unsigned long )chlg->opaque) {
    {
#line 223
    opaque = xstrcat(", opaque=\"", chlg->opaque, "\"", (void *)0);
    }
  }
#line 225
  if (cnonce) {
#line 225
    tmp___1 = (char const   *)cnonce;
  } else {
#line 225
    tmp___1 = "";
  }
#line 225
  if (nonce_count) {
#line 225
    tmp___2 = (char const   *)nonce_count;
  } else {
#line 225
    tmp___2 = "";
  }
#line 225
  if (qop) {
#line 225
    tmp___3 = (char const   *)qop;
  } else {
#line 225
    tmp___3 = "";
  }
#line 225
  if (opaque) {
#line 225
    tmp___4 = (char const   *)opaque;
  } else {
#line 225
    tmp___4 = "";
  }
  {
#line 225
  result = xstrcat("Digest username=\"", cred->username, "\", realm=\"", chlg->realm,
                   "\", nonce=\"", chlg->nonce, "\", uri=\"", uri, "\", algorithm=",
                   chlg->algorithm, response, tmp___4, tmp___3, tmp___2, tmp___1,
                   (void *)0);
#line 231
  (cred->nc_value) ++;
#line 232
  snprintf((char */* __restrict  */)(cred->nc), sizeof(cred->nc), (char const   */* __restrict  */)"%.8x",
           cred->nc_value);
#line 234
  tmp___5 = strcasecmp("MD5", (char const   *)chlg->algorithm);
  }
#line 234
  if (0 == tmp___5) {
    {
#line 235
    xfree((void *)h_a1);
    }
  }
  {
#line 237
  xfree((void *)nonce_count);
#line 238
  xfree((void *)cnonce);
#line 239
  xfree((void *)qop);
#line 240
  xfree((void *)response);
#line 241
  xfree((void *)request_digest);
#line 242
  xfree((void *)h_a2);
#line 243
  xfree((void *)opaque);
#line 245
  tmp___6 = strlen((char const   *)result);
#line 245
  len = tmp___6 + 32UL;
  }
#line 247
  if ((unsigned int )scheme == 4U) {
    {
#line 248
    tmp___7 = xmalloc(len);
#line 248
    this->proxy.encode = (char *)tmp___7;
#line 249
    memset((void *)this->proxy.encode, '\000', len);
#line 250
    snprintf((char */* __restrict  */)this->proxy.encode, len, (char const   */* __restrict  */)"Proxy-Authorization: %s\r\n",
             result);
#line 251
    xfree((void *)result);
    }
#line 252
    return (this->proxy.encode);
  } else {
    {
#line 254
    tmp___8 = xmalloc(len);
#line 254
    this->digest.encode = (char *)tmp___8;
#line 255
    memset((void *)this->digest.encode, '\000', len);
#line 256
    snprintf((char */* __restrict  */)this->digest.encode, len, (char const   */* __restrict  */)"Authorization: %s\r\n",
             result);
#line 257
    xfree((void *)result);
    }
#line 258
    return (this->digest.encode);
  }
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
BOOLEAN auth_set_digest_header(AUTH this , DCHLG **chlg , DCRED **cred , size_t *rand___0 ,
                               char *realm , char *str ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  BOOLEAN tmp___2 ;
  size_t tmp___3 ;
  CREDS tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  BOOLEAN tmp___7 ;
  size_t tmp___8 ;

  {
#line 265
  i = (size_t )0;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    tmp___3 = array_length(this->creds);
    }
#line 265
    if (! (i < tmp___3)) {
#line 265
      goto while_break;
    }
    {
#line 266
    tmp___0 = array_get(this->creds, (int )i);
#line 266
    tmp = (CREDS )tmp___0;
#line 267
    tmp___1 = creds_get_realm(tmp);
#line 267
    tmp___2 = strmatch(tmp___1, realm);
    }
#line 267
    if (tmp___2) {
      {
#line 268
      *chlg = __digest_challenge((char const   *)str);
#line 269
      *cred = __digest_credentials(tmp, rand___0);
      }
#line 270
      if ((unsigned long )*cred == (unsigned long )((void *)0)) {
#line 270
        return ((BOOLEAN )0);
      } else
#line 270
      if ((unsigned long )*chlg == (unsigned long )((void *)0)) {
#line 270
        return ((BOOLEAN )0);
      }
#line 271
      return ((BOOLEAN )1);
    }
#line 265
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  i = (size_t )0;
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 277
    tmp___8 = array_length(this->creds);
    }
#line 277
    if (! (i < tmp___8)) {
#line 277
      goto while_break___0;
    }
    {
#line 278
    tmp___5 = array_get(this->creds, (int )i);
#line 278
    tmp___4 = (CREDS )tmp___5;
#line 279
    tmp___6 = creds_get_realm(tmp___4);
#line 279
    tmp___7 = strmatch(tmp___6, (char *)"any");
    }
#line 279
    if (tmp___7) {
      {
#line 280
      *chlg = __digest_challenge((char const   *)str);
#line 281
      *cred = __digest_credentials(tmp___4, rand___0);
      }
#line 282
      if ((unsigned long )*cred == (unsigned long )((void *)0)) {
#line 282
        return ((BOOLEAN )0);
      } else
#line 282
      if ((unsigned long )*chlg == (unsigned long )((void *)0)) {
#line 282
        return ((BOOLEAN )0);
      }
#line 283
      return ((BOOLEAN )1);
    }
#line 277
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 286
  return ((BOOLEAN )0);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
BOOLEAN auth_get_proxy_required(AUTH this ) 
{ 


  {
#line 292
  return (this->proxy.required);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
char *auth_get_proxy_host(AUTH this ) 
{ 


  {
#line 298
  return (this->proxy.hostname);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
int auth_get_proxy_port(AUTH this ) 
{ 


  {
#line 304
  return (this->proxy.port);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
void auth_set_proxy_required(AUTH this , BOOLEAN required ) 
{ 


  {
#line 310
  this->proxy.required = required;
#line 311
  return;
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
void auth_set_proxy_host(AUTH this , char *host ) 
{ 


  {
  {
#line 316
  this->proxy.hostname = xstrdup((char const   *)host);
#line 317
  this->proxy.required = (BOOLEAN )1;
  }
#line 318
  return;
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
void auth_set_proxy_port(AUTH this , int port ) 
{ 


  {
#line 323
  this->proxy.port = port;
#line 324
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
char *auth_get_ftp_username(AUTH this , char *realm ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  SCHEME tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  size_t tmp___5 ;
  CREDS tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  SCHEME tmp___9 ;
  char *tmp___10 ;
  BOOLEAN tmp___11 ;
  size_t tmp___12 ;

  {
#line 330
  i = (size_t )0;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 330
    tmp___5 = array_length(this->creds);
    }
#line 330
    if (! (i < tmp___5)) {
#line 330
      goto while_break;
    }
    {
#line 331
    tmp___0 = array_get(this->creds, (int )i);
#line 331
    tmp = (CREDS )tmp___0;
#line 332
    tmp___3 = creds_get_realm(tmp);
#line 332
    tmp___4 = strmatch(tmp___3, realm);
    }
#line 332
    if (tmp___4) {
      {
#line 333
      tmp___2 = creds_get_scheme(tmp);
      }
#line 333
      if ((unsigned int )tmp___2 == 3U) {
        {
#line 334
        tmp___1 = creds_get_username(tmp);
        }
#line 334
        return (tmp___1);
      }
    }
#line 330
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  i = (size_t )0;
  {
#line 341
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 341
    tmp___12 = array_length(this->creds);
    }
#line 341
    if (! (i < tmp___12)) {
#line 341
      goto while_break___0;
    }
    {
#line 342
    tmp___7 = array_get(this->creds, (int )i);
#line 342
    tmp___6 = (CREDS )tmp___7;
#line 343
    tmp___10 = creds_get_realm(tmp___6);
#line 343
    tmp___11 = strmatch(tmp___10, (char *)"any");
    }
#line 343
    if (tmp___11) {
      {
#line 344
      tmp___9 = creds_get_scheme(tmp___6);
      }
#line 344
      if ((unsigned int )tmp___9 == 3U) {
        {
#line 345
        tmp___8 = creds_get_username(tmp___6);
        }
#line 345
        return (tmp___8);
      }
    }
#line 341
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 349
  return ((char *)"");
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
char *auth_get_ftp_password(AUTH this , char *realm ) 
{ 
  size_t i ;
  CREDS tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  SCHEME tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  size_t tmp___5 ;
  CREDS tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  SCHEME tmp___9 ;
  char *tmp___10 ;
  BOOLEAN tmp___11 ;
  size_t tmp___12 ;

  {
#line 356
  i = (size_t )0;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 356
    tmp___5 = array_length(this->creds);
    }
#line 356
    if (! (i < tmp___5)) {
#line 356
      goto while_break;
    }
    {
#line 357
    tmp___0 = array_get(this->creds, (int )i);
#line 357
    tmp = (CREDS )tmp___0;
#line 358
    tmp___3 = creds_get_realm(tmp);
#line 358
    tmp___4 = strmatch(tmp___3, realm);
    }
#line 358
    if (tmp___4) {
      {
#line 359
      tmp___2 = creds_get_scheme(tmp);
      }
#line 359
      if ((unsigned int )tmp___2 == 3U) {
        {
#line 360
        tmp___1 = creds_get_password(tmp);
        }
#line 360
        return (tmp___1);
      }
    }
#line 356
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  i = (size_t )0;
  {
#line 367
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 367
    tmp___12 = array_length(this->creds);
    }
#line 367
    if (! (i < tmp___12)) {
#line 367
      goto while_break___0;
    }
    {
#line 368
    tmp___7 = array_get(this->creds, (int )i);
#line 368
    tmp___6 = (CREDS )tmp___7;
#line 369
    tmp___10 = creds_get_realm(tmp___6);
#line 369
    tmp___11 = strmatch(tmp___10, (char *)"any");
    }
#line 369
    if (tmp___11) {
      {
#line 370
      tmp___9 = creds_get_scheme(tmp___6);
      }
#line 370
      if ((unsigned int )tmp___9 == 3U) {
        {
#line 371
        tmp___8 = creds_get_password(tmp___6);
        }
#line 371
        return (tmp___8);
      }
    }
#line 367
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 375
  return ((char *)"");
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
static BOOLEAN __basic_header(AUTH this , SCHEME scheme , CREDS creds ) 
{ 
  char buf[256] ;
  char *hdr ;
  size_t len ;
  BOOLEAN ret ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 384
  ret = (BOOLEAN )1;
#line 386
  memset((void *)(buf), '\000', sizeof(buf));
#line 387
  pthread_mutex_lock(& this->lock);
#line 388
  tmp = creds_get_password(creds);
#line 388
  tmp___0 = creds_get_username(creds);
#line 388
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s:%s",
           tmp___0, tmp);
  }
#line 389
  if ((unsigned int )scheme == 4U) {
    {
#line 390
    xfree((void *)this->proxy.encode);
#line 391
    tmp___3 = strlen((char const   *)(buf));
#line 391
    tmp___4 = base64_encode((void const   *)(buf), (int )tmp___3, & hdr);
    }
#line 391
    if (tmp___4 < 0) {
#line 392
      ret = (BOOLEAN )0;
    } else {
      {
#line 394
      tmp___1 = strlen((char const   *)hdr);
#line 394
      len = tmp___1 + 32UL;
#line 395
      tmp___2 = xmalloc(len);
#line 395
      this->proxy.encode = (char *)tmp___2;
#line 396
      memset((void *)this->proxy.encode, '\000', len);
#line 397
      snprintf((char */* __restrict  */)this->proxy.encode, len, (char const   */* __restrict  */)"Proxy-Authorization: Basic %s\r\n",
               hdr);
      }
    }
  } else {
    {
#line 400
    xfree((void *)this->basic.encode);
#line 401
    tmp___7 = strlen((char const   *)(buf));
#line 401
    tmp___8 = base64_encode((void const   *)(buf), (int )tmp___7, & hdr);
    }
#line 401
    if (tmp___8 < 0) {
#line 402
      ret = (BOOLEAN )0;
    } else {
      {
#line 404
      tmp___5 = strlen((char const   *)hdr);
#line 404
      len = tmp___5 + 32UL;
#line 405
      tmp___6 = xmalloc(len);
#line 405
      this->basic.encode = (char *)tmp___6;
#line 406
      memset((void *)this->basic.encode, '\000', len);
#line 407
      snprintf((char */* __restrict  */)this->basic.encode, len, (char const   */* __restrict  */)"Authorization: Basic %s\r\n",
               hdr);
      }
    }
  }
  {
#line 410
  pthread_mutex_unlock(& this->lock);
  }
#line 411
  return (ret);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
static KEYPARSER const   keyparser[8]  = 
#line 420
  {      {"realm", (KEY_HEADER_E )0}, 
        {"domain", (KEY_HEADER_E )1}, 
        {"nonce", (KEY_HEADER_E )2}, 
        {"opaque", (KEY_HEADER_E )3}, 
        {"stale", (KEY_HEADER_E )4}, 
        {"algorithm", (KEY_HEADER_E )5}, 
        {"qop", (KEY_HEADER_E )6}, 
        {(char const   *)((void *)0), (KEY_HEADER_E )7}};
#line 433 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
static KEY_HEADER_E __get_keyval(char const   *key ) 
{ 
  int i ;
  int tmp ;

  {
#line 438
  i = 0;
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! keyparser[i].keyname) {
#line 438
      goto while_break;
    }
    {
#line 439
    tmp = strcasecmp(key, (char const   *)keyparser[i].keyname);
    }
#line 439
    if (! tmp) {
#line 440
      return ((KEY_HEADER_E )keyparser[i].keyval);
    }
#line 438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return ((KEY_HEADER_E )7);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
static char *__get_random_string(size_t length , unsigned int *randseed ) 
{ 
  unsigned char b64_alphabet[65] ;
  unsigned char *result ;
  size_t i ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 449
  b64_alphabet[0] = (unsigned char )'0';
#line 449
  b64_alphabet[1] = (unsigned char )'1';
#line 449
  b64_alphabet[2] = (unsigned char )'2';
#line 449
  b64_alphabet[3] = (unsigned char )'3';
#line 449
  b64_alphabet[4] = (unsigned char )'4';
#line 449
  b64_alphabet[5] = (unsigned char )'5';
#line 449
  b64_alphabet[6] = (unsigned char )'6';
#line 449
  b64_alphabet[7] = (unsigned char )'7';
#line 449
  b64_alphabet[8] = (unsigned char )'8';
#line 449
  b64_alphabet[9] = (unsigned char )'9';
#line 449
  b64_alphabet[10] = (unsigned char )'a';
#line 449
  b64_alphabet[11] = (unsigned char )'b';
#line 449
  b64_alphabet[12] = (unsigned char )'c';
#line 449
  b64_alphabet[13] = (unsigned char )'d';
#line 449
  b64_alphabet[14] = (unsigned char )'e';
#line 449
  b64_alphabet[15] = (unsigned char )'f';
#line 449
  b64_alphabet[16] = (unsigned char )'g';
#line 449
  b64_alphabet[17] = (unsigned char )'h';
#line 449
  b64_alphabet[18] = (unsigned char )'i';
#line 449
  b64_alphabet[19] = (unsigned char )'j';
#line 449
  b64_alphabet[20] = (unsigned char )'k';
#line 449
  b64_alphabet[21] = (unsigned char )'l';
#line 449
  b64_alphabet[22] = (unsigned char )'m';
#line 449
  b64_alphabet[23] = (unsigned char )'n';
#line 449
  b64_alphabet[24] = (unsigned char )'o';
#line 449
  b64_alphabet[25] = (unsigned char )'p';
#line 449
  b64_alphabet[26] = (unsigned char )'q';
#line 449
  b64_alphabet[27] = (unsigned char )'r';
#line 449
  b64_alphabet[28] = (unsigned char )'s';
#line 449
  b64_alphabet[29] = (unsigned char )'t';
#line 449
  b64_alphabet[30] = (unsigned char )'u';
#line 449
  b64_alphabet[31] = (unsigned char )'v';
#line 449
  b64_alphabet[32] = (unsigned char )'w';
#line 449
  b64_alphabet[33] = (unsigned char )'x';
#line 449
  b64_alphabet[34] = (unsigned char )'y';
#line 449
  b64_alphabet[35] = (unsigned char )'z';
#line 449
  b64_alphabet[36] = (unsigned char )'A';
#line 449
  b64_alphabet[37] = (unsigned char )'B';
#line 449
  b64_alphabet[38] = (unsigned char )'C';
#line 449
  b64_alphabet[39] = (unsigned char )'D';
#line 449
  b64_alphabet[40] = (unsigned char )'E';
#line 449
  b64_alphabet[41] = (unsigned char )'F';
#line 449
  b64_alphabet[42] = (unsigned char )'G';
#line 449
  b64_alphabet[43] = (unsigned char )'H';
#line 449
  b64_alphabet[44] = (unsigned char )'I';
#line 449
  b64_alphabet[45] = (unsigned char )'J';
#line 449
  b64_alphabet[46] = (unsigned char )'K';
#line 449
  b64_alphabet[47] = (unsigned char )'L';
#line 449
  b64_alphabet[48] = (unsigned char )'M';
#line 449
  b64_alphabet[49] = (unsigned char )'N';
#line 449
  b64_alphabet[50] = (unsigned char )'O';
#line 449
  b64_alphabet[51] = (unsigned char )'P';
#line 449
  b64_alphabet[52] = (unsigned char )'Q';
#line 449
  b64_alphabet[53] = (unsigned char )'R';
#line 449
  b64_alphabet[54] = (unsigned char )'S';
#line 449
  b64_alphabet[55] = (unsigned char )'T';
#line 449
  b64_alphabet[56] = (unsigned char )'U';
#line 449
  b64_alphabet[57] = (unsigned char )'V';
#line 449
  b64_alphabet[58] = (unsigned char )'W';
#line 449
  b64_alphabet[59] = (unsigned char )'X';
#line 449
  b64_alphabet[60] = (unsigned char )'Y';
#line 449
  b64_alphabet[61] = (unsigned char )'Z';
#line 449
  b64_alphabet[62] = (unsigned char )'.';
#line 449
  b64_alphabet[63] = (unsigned char )'/';
#line 449
  b64_alphabet[64] = (unsigned char )'\000';
#line 453
  tmp = xmalloc(sizeof(unsigned char ) * (length + 1UL));
#line 453
  result = (unsigned char *)tmp;
#line 455
  i = (size_t )0;
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    if (! (i < length)) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___0 = pthread_rand_np(randseed);
#line 456
    *(result + i) = (unsigned char )((int )(255.0 * ((double )tmp___0 / ((double )2147483647 + 1.0))));
#line 455
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  i = (size_t )0;
  {
#line 457
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 457
    if (! (i < length)) {
#line 457
      goto while_break___0;
    }
#line 458
    *(result + i) = b64_alphabet[(unsigned long )*(result + i) % ((sizeof(b64_alphabet) - 1UL) / sizeof(unsigned char ))];
#line 457
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 460
  *(result + length) = (unsigned char )'\000';
#line 462
  return ((char *)result);
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
static DCRED *__digest_credentials(CREDS creds , size_t *randseed ) 
{ 
  DCRED *result ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 473
  tmp = xcalloc((size_t )1, sizeof(struct DIGEST_CRED ));
#line 473
  result = (DCRED *)tmp;
#line 474
  tmp___0 = creds_get_username(creds);
#line 474
  result->username = xstrdup((char const   *)tmp___0);
#line 475
  tmp___1 = creds_get_password(creds);
#line 475
  result->password = xstrdup((char const   *)tmp___1);
#line 477
  result->cnonce_value = __get_random_string((size_t )16, (unsigned int *)randseed);
#line 478
  result->nc_value = 1U;
#line 479
  snprintf((char */* __restrict  */)(result->nc), sizeof(result->nc), (char const   */* __restrict  */)"%.8x",
           result->nc_value);
#line 480
  result->h_a1 = (char *)((void *)0);
  }
#line 482
  return (result);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
static DCHLG *__digest_challenge(char const   *challenge ) 
{ 
  DCHLG *result ;
  char *key ;
  char *val ;
  char const   *beg ;
  char const   *end ;
  KEY_HEADER_E keyval ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  void *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  void *tmp___8 ;
  unsigned short const   **tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 495
  tmp = xcalloc((size_t )1, sizeof(struct DIGEST_CHLG ));
#line 495
  result = (DCHLG *)tmp;
#line 497
  end = challenge;
#line 497
  beg = end;
  }
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 497
    tmp___0 = __ctype_b_loc();
    }
#line 497
    if ((int const   )*(*tmp___0 + (int )*end) & 8192) {
#line 497
      goto while_break;
    } else
#line 497
    if (! *end) {
#line 497
      goto while_break;
    }
#line 497
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 499
  tmp___1 = strncasecmp("Digest", beg, (size_t )(end - beg));
  }
#line 499
  if (tmp___1) {
    {
#line 500
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no Digest keyword in challenge [%s]\n",
            challenge);
    }
#line 501
    return ((DCHLG *)((void *)0));
  }
#line 504
  beg = end;
  {
#line 504
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 504
    tmp___2 = __ctype_b_loc();
    }
#line 504
    if (! ((int const   )*(*tmp___2 + (int )*beg) & 8192)) {
#line 504
      goto while_break___0;
    }
#line 504
    beg ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 506
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 506
    if (! ((int const   )*beg != 0)) {
#line 506
      goto while_break___1;
    }
    {
#line 509
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 509
      tmp___3 = __ctype_b_loc();
      }
#line 509
      if (! ((int const   )*(*tmp___3 + (int )*beg) & 8192)) {
#line 509
        goto while_break___2;
      }
#line 510
      beg ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 512
    end = beg;
    {
#line 513
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 513
      if ((int const   )*end != 61) {
#line 513
        if ((int const   )*end != 44) {
#line 513
          if ((int const   )*end != 0) {
            {
#line 513
            tmp___4 = __ctype_b_loc();
            }
#line 513
            if ((int const   )*(*tmp___4 + (int )*end) & 8192) {
#line 513
              goto while_break___3;
            }
          } else {
#line 513
            goto while_break___3;
          }
        } else {
#line 513
          goto while_break___3;
        }
      } else {
#line 513
        goto while_break___3;
      }
#line 514
      end ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 516
    tmp___5 = xmalloc((unsigned long )((end + 1) - beg) * sizeof(char ));
#line 516
    key = (char *)tmp___5;
#line 517
    memcpy((void */* __restrict  */)key, (void const   */* __restrict  */)beg, (size_t )(end - beg));
#line 518
    *(key + (end - beg)) = (char )'\000';
#line 520
    beg = end;
    }
    {
#line 521
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 521
      tmp___6 = __ctype_b_loc();
      }
#line 521
      if (! ((int const   )*(*tmp___6 + (int )*beg) & 8192)) {
#line 521
        goto while_break___4;
      }
#line 522
      beg ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 525
    val = (char *)((void *)0);
#line 526
    if ((int const   )*beg == 61) {
#line 527
      beg ++;
      {
#line 528
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 528
        tmp___7 = __ctype_b_loc();
        }
#line 528
        if (! ((int const   )*(*tmp___7 + (int )*beg) & 8192)) {
#line 528
          goto while_break___5;
        }
#line 529
        beg ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 531
      if ((int const   )*beg == 34) {
#line 532
        beg ++;
#line 533
        end = beg;
        {
#line 534
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 534
          if ((int const   )*end != 34) {
#line 534
            if (! ((int const   )*end != 0)) {
#line 534
              goto while_break___6;
            }
          } else {
#line 534
            goto while_break___6;
          }
#line 535
          if ((int const   )*end == 92) {
#line 535
            if ((int const   )*(end + 1) != 0) {
#line 536
              end ++;
            }
          }
#line 538
          end ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 540
        tmp___8 = xmalloc((unsigned long )((end + 1) - beg) * sizeof(char ));
#line 540
        val = (char *)tmp___8;
#line 541
        memcpy((void */* __restrict  */)val, (void const   */* __restrict  */)beg,
               (size_t )(end - beg));
#line 542
        *(val + (end - beg)) = (char )'\000';
#line 543
        beg = end;
        }
#line 544
        if ((int const   )*beg != 0) {
#line 545
          beg ++;
        }
      } else {
#line 549
        end = beg;
        {
#line 550
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 550
          if ((int const   )*end != 44) {
#line 550
            if ((int const   )*end != 0) {
              {
#line 550
              tmp___9 = __ctype_b_loc();
              }
#line 550
              if ((int const   )*(*tmp___9 + (int )*end) & 8192) {
#line 550
                goto while_break___7;
              }
            } else {
#line 550
              goto while_break___7;
            }
          } else {
#line 550
            goto while_break___7;
          }
#line 551
          end ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 553
        tmp___10 = xmalloc((unsigned long )((end + 1) - beg) * sizeof(char ));
#line 553
        val = (char *)tmp___10;
#line 554
        memcpy((void */* __restrict  */)val, (void const   */* __restrict  */)beg,
               (size_t )(end - beg));
#line 555
        *(val + (end - beg)) = (char )'\000';
#line 556
        beg = end;
        }
      }
    }
    {
#line 560
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 560
      if ((int const   )*beg != 44) {
#line 560
        if (! ((int const   )*beg != 0)) {
#line 560
          goto while_break___8;
        }
      } else {
#line 560
        goto while_break___8;
      }
#line 561
      beg ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 563
    if ((int const   )*beg != 0) {
#line 564
      beg ++;
    }
    {
#line 567
    keyval = __get_keyval((char const   *)key);
    }
    {
#line 569
    if ((unsigned int )keyval == 0U) {
#line 569
      goto case_0;
    }
#line 572
    if ((unsigned int )keyval == 1U) {
#line 572
      goto case_1;
    }
#line 575
    if ((unsigned int )keyval == 2U) {
#line 575
      goto case_2;
    }
#line 578
    if ((unsigned int )keyval == 3U) {
#line 578
      goto case_3;
    }
#line 581
    if ((unsigned int )keyval == 4U) {
#line 581
      goto case_4;
    }
#line 584
    if ((unsigned int )keyval == 5U) {
#line 584
      goto case_5;
    }
#line 587
    if ((unsigned int )keyval == 6U) {
#line 587
      goto case_6;
    }
#line 590
    goto switch_default;
    case_0: /* CIL Label */ 
#line 570
    result->realm = val;
#line 571
    goto switch_break;
    case_1: /* CIL Label */ 
#line 573
    result->domain = val;
#line 574
    goto switch_break;
    case_2: /* CIL Label */ 
#line 576
    result->nonce = val;
#line 577
    goto switch_break;
    case_3: /* CIL Label */ 
#line 579
    result->opaque = val;
#line 580
    goto switch_break;
    case_4: /* CIL Label */ 
#line 582
    result->stale = val;
#line 583
    goto switch_break;
    case_5: /* CIL Label */ 
#line 585
    result->algorithm = val;
#line 586
    goto switch_break;
    case_6: /* CIL Label */ 
#line 588
    result->qop = val;
#line 589
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 591
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown key [%s]\n",
            key);
#line 592
    xfree((void *)val);
    }
#line 593
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 595
    xfree((void *)key);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 598
  return (result);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
static char *__get_md5_str(char const   *buf ) 
{ 
  char const   *hex ;
  struct md5_ctx ctx ;
  unsigned char hash[16] ;
  char *r ;
  char *result ;
  size_t length ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 604
  hex = "0123456789abcdef";
#line 611
  length = strlen(buf);
#line 612
  tmp = xmalloc(33UL * sizeof(char ));
#line 612
  result = (char *)tmp;
#line 613
  md5_init_ctx(& ctx);
#line 614
  md5_process_bytes((void const   *)buf, length, & ctx);
#line 615
  md5_finish_ctx(& ctx, (void *)(hash));
#line 617
  i = 0;
#line 617
  r = result;
  }
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! (i < 16)) {
#line 617
      goto while_break;
    }
#line 618
    tmp___0 = r;
#line 618
    r ++;
#line 618
    *tmp___0 = (char )*(hex + ((int )hash[i] >> 4));
#line 619
    tmp___1 = r;
#line 619
    r ++;
#line 619
    *tmp___1 = (char )*(hex + ((int )hash[i] & 15));
#line 617
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  *r = (char )'\000';
#line 623
  return (result);
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
static char *__get_h_a1(DCHLG const   *chlg , DCRED *cred , char const   *nonce_value ) 
{ 
  char *h_usrepa ;
  char *result ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 632
  tmp___1 = strcasecmp("MD5", (char const   *)chlg->algorithm);
  }
#line 632
  if (0 == tmp___1) {
    {
#line 633
    tmp = xstrcat((char const   *)cred->username, ":", chlg->realm, ":", cred->password,
                  (void *)0);
#line 634
    h_usrepa = __get_md5_str((char const   *)tmp);
#line 635
    xfree((void *)tmp);
#line 636
    result = h_usrepa;
    }
  } else {
    {
#line 638
    tmp___0 = strcasecmp("MD5-sess", (char const   *)chlg->algorithm);
    }
#line 638
    if (0 == tmp___0) {
#line 639
      if ((unsigned long )((void *)0) == (unsigned long )cred->h_a1) {
        {
#line 640
        tmp = xstrcat((char const   *)cred->username, ":", chlg->realm, ":", cred->password,
                      (void *)0);
#line 641
        h_usrepa = __get_md5_str((char const   *)tmp);
#line 642
        xfree((void *)tmp);
#line 643
        tmp = xstrcat((char const   *)h_usrepa, ":", nonce_value, ":", cred->cnonce_value,
                      (void *)0);
#line 644
        result = __get_md5_str((char const   *)tmp);
#line 645
        xfree((void *)tmp);
#line 646
        cred->h_a1 = result;
        }
      } else {
#line 649
        return (cred->h_a1);
      }
    } else {
      {
#line 653
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid call to %s algorithm is [%s]\n",
              "__get_h_a1", chlg->algorithm);
      }
#line 654
      return ((char *)((void *)0));
    }
  }
#line 657
  return (result);
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/auth.c"
static BOOLEAN __str_list_contains(char const   *str , char const   *pattern , size_t pattern_len ) 
{ 
  char const   *ptr ;
  int tmp ;
  char *tmp___0 ;

  {
#line 665
  ptr = str;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 667
    tmp = strncmp(ptr, pattern, pattern_len);
    }
#line 667
    if (0 == tmp) {
#line 667
      if (44 == (int )*(ptr + pattern_len)) {
#line 669
        return ((BOOLEAN )1);
      } else
#line 667
      if (0 == (int )*(ptr + pattern_len)) {
#line 669
        return ((BOOLEAN )1);
      }
    }
    {
#line 672
    tmp___0 = strchr(ptr, ',');
#line 672
    ptr = (char const   *)tmp___0;
    }
#line 672
    if ((unsigned long )((void *)0) != (unsigned long )ptr) {
#line 672
      ptr ++;
    }
#line 666
    if (! ((unsigned long )((void *)0) != (unsigned long )ptr)) {
#line 666
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  return ((BOOLEAN )0);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/stralloc.c"
char *stralloc(char *str ) 
{ 
  char *retval ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 44
  tmp = strlen((char const   *)str);
#line 44
  tmp___0 = calloc(tmp + 1UL, (size_t )1);
#line 44
  retval = (char *)tmp___0;
  }
#line 45
  if (! retval) {
    {
#line 46
    NOTIFY((LEVEL )3, "Fatal memory allocation error");
    }
  }
  {
#line 48
  strcpy((char */* __restrict  */)retval, (char const   */* __restrict  */)str);
  }
#line 49
  return (retval);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 36 "./memory.h"
void *xrealloc(void *ptr , size_t size ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/memory.c"
char *xstrdup(char const   *str ) 
{ 
  register char *ret ;

  {
#line 39
  if (! str) {
    {
#line 40
    NOTIFY((LEVEL )2, "string has no value!");
    }
#line 41
    return ((char *)((void *)0));
  }
  {
#line 44
  ret = strdup(str);
  }
#line 45
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 45
    NOTIFY((LEVEL )3, "xstrdup: unable to allocate additional memory");
    }
  }
#line 54
  return (ret);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/memory.c"
char *xstrcat(char const   *arg1  , ...) 
{ 
  char const   *argptr ;
  char *resptr ;
  char *result ;
  int nargs ;
  size_t len ;
  va_list valist ;
  char const   *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 62
  nargs = 0;
#line 63
  len = (size_t )0;
#line 66
  __builtin_va_start(valist, arg1);
#line 68
  argptr = arg1;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )argptr != (unsigned long )((void *)0))) {
#line 68
      goto while_break;
    }
    {
#line 69
    tmp___0 = strlen(argptr);
#line 69
    len += tmp___0;
#line 68
    tmp = __builtin_va_arg(valist, char *);
#line 68
    argptr = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  __builtin_va_end(valist);
#line 73
  tmp___1 = xmalloc(len + 1UL);
#line 73
  result = (char *)tmp___1;
#line 74
  resptr = result;
#line 76
  __builtin_va_start(valist, arg1);
#line 78
  nargs = 0;
#line 79
  argptr = arg1;
  }
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 79
    if (! ((unsigned long )argptr != (unsigned long )((void *)0))) {
#line 79
      goto while_break___0;
    }
    {
#line 80
    len = strlen(argptr);
#line 81
    memcpy((void */* __restrict  */)resptr, (void const   */* __restrict  */)argptr,
           len);
#line 82
    resptr += len;
#line 79
    tmp___2 = __builtin_va_arg(valist, char *);
#line 79
    argptr = tmp___2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 85
  __builtin_va_end(valist);
#line 87
  *resptr = (char )'\000';
  }
#line 89
  return (result);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/memory.c"
void *xrealloc(void *ptr , size_t size ) 
{ 
  void *tmp ;

  {
#line 99
  if (ptr) {
    {
#line 100
    tmp = realloc(ptr, size);
    }
  } else {
    {
#line 102
    tmp = malloc(size);
    }
  }
#line 104
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 104
    NOTIFY((LEVEL )3, "Memory exhausted; unable to continue.");
    }
  }
#line 105
  return (tmp);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/memory.c"
void *xmalloc(size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 114
  tmp___0 = malloc(size);
#line 114
  tmp = tmp___0;
  }
#line 115
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 115
    NOTIFY((LEVEL )3, "Unable to allocate additional memory.");
    }
  }
#line 116
  return (tmp);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/memory.c"
void *xcalloc(size_t num , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 125
  tmp___0 = xmalloc(num * size);
#line 125
  tmp = tmp___0;
#line 126
  memset(tmp, 0, num * size);
  }
#line 127
  return (tmp);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/memory.c"
void xfree(void *ptr ) 
{ 


  {
#line 139
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 140
    free(ptr);
#line 140
    ptr = (void *)0;
    }
  }
#line 142
  return;
}
}
#line 531 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 143 "./setup.h"
void display_help(void) ;
#line 34 "./hash.h"
HASH new_hash(void) ;
#line 35
void hash_add(HASH this , char *key , char *value ) ;
#line 39
void hash_destroy(HASH this ) ;
#line 31 "./eval.h"
char *evaluate(HASH hash_table , char *buf ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cfg.c"
BOOLEAN is_variable_line(char *line ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cfg.c"
void parse(char *str ) 
{ 
  char *ch ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 41
  tmp = strstr((char const   *)str, "#");
#line 41
  ch = tmp;
  }
#line 42
  if (ch) {
#line 42
    *ch = (char)0;
  }
  {
#line 43
  tmp___0 = strstr((char const   *)str, "\n");
#line 43
  ch = tmp___0;
  }
#line 44
  if (ch) {
#line 44
    *ch = (char)0;
  }
#line 45
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cfg.c"
int read_cfg_file(LINES *l , char *filename ) 
{ 
  FILE *file ;
  HASH H ;
  char *line ;
  char *option ;
  char *value ;
  void *tmp ;
  int num ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  BOOLEAN tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;

  {
#line 65
  if (! l) {
    {
#line 66
    printf((char const   */* __restrict  */)"Structure not initialized!\n");
    }
#line 67
    return (-1);
  }
  {
#line 70
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 70
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 73
    NOTIFY((LEVEL )1, "unable to open file: %s", filename);
#line 74
    display_help();
#line 75
    exit(1);
    }
  }
  {
#line 78
  tmp = xmalloc((size_t )40000);
#line 78
  line = (char *)tmp;
#line 79
  H = new_hash();
#line 81
  l->index = 0;
#line 82
  memset((void *)line, 0, sizeof(line));
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 83
    tmp___13 = fgets((char */* __restrict  */)line, 40000, (FILE */* __restrict  */)file);
    }
#line 83
    if (! ((unsigned long )tmp___13 != (unsigned long )((void *)0))) {
#line 83
      goto while_break;
    }
    {
#line 84
    tmp___0 = strchr((char const   *)line, '\n');
#line 84
    p = tmp___0;
    }
#line 89
    if (p) {
#line 90
      *p = (char )'\000';
    } else {
      {
#line 97
      num = fgetc(file);
      }
#line 97
      if (num != -1) {
        {
#line 98
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 98
          num = fgetc(file);
          }
#line 98
          if (num != -1) {
#line 98
            if (! (num != 10)) {
#line 98
              goto while_break___0;
            }
          } else {
#line 98
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 99
        *(line + 0) = (char )'\000';
      }
    }
    {
#line 102
    parse(line);
#line 103
    chomp(line);
#line 104
    tmp___12 = strlen((char const   *)line);
    }
#line 104
    if (! (tmp___12 == 0UL)) {
      {
#line 105
      tmp___11 = is_variable_line(line);
      }
#line 105
      if (tmp___11) {
#line 106
        tmp___1 = line;
#line 107
        option = tmp___1;
        {
#line 108
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 108
          if (*tmp___1) {
            {
#line 108
            tmp___2 = __ctype_b_loc();
            }
#line 108
            if ((int const   )*(*tmp___2 + (int )((unsigned char )((int )*tmp___1))) & 8192) {
#line 108
              goto while_break___1;
            } else
#line 108
            if (61 == (int )*tmp___1) {
#line 108
              goto while_break___1;
            } else
#line 108
            if (58 == (int )*tmp___1) {
#line 108
              goto while_break___1;
            }
          } else {
#line 108
            goto while_break___1;
          }
#line 109
          tmp___1 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 110
        tmp___3 = tmp___1;
#line 110
        tmp___1 ++;
#line 110
        *tmp___3 = (char)0;
        {
#line 111
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 111
          tmp___4 = __ctype_b_loc();
          }
#line 111
          if (! ((int const   )*(*tmp___4 + (int )((unsigned char )((int )*tmp___1))) & 8192)) {
#line 111
            if (! (61 == (int )*tmp___1)) {
#line 111
              if (! (58 == (int )*tmp___1)) {
#line 111
                goto while_break___2;
              }
            }
          }
#line 112
          tmp___1 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 113
        value = tmp___1;
        {
#line 114
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 114
          if (! *tmp___1) {
#line 114
            goto while_break___3;
          }
#line 115
          tmp___1 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 116
        tmp___5 = tmp___1;
#line 116
        tmp___1 ++;
#line 116
        *tmp___5 = (char)0;
#line 117
        hash_add(H, option, value);
        }
      } else {
        {
#line 120
        tmp___7 = xstrdup((char const   *)line);
#line 120
        tmp___6 = tmp___7;
        }
        {
#line 121
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 121
          tmp___8 = strstr((char const   *)tmp___6, "$");
          }
#line 121
          if (! tmp___8) {
#line 121
            goto while_break___4;
          }
          {
#line 122
          tmp___6 = evaluate(H, tmp___6);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 124
        tmp___9 = realloc((void *)l->line, sizeof(char *) * (unsigned long )(l->index + 1));
#line 124
        l->line = (char **)tmp___9;
#line 125
        tmp___10 = strdup((char const   *)tmp___6);
#line 125
        *(l->line + l->index) = tmp___10;
#line 126
        (l->index) ++;
#line 128
        free((void *)tmp___6);
        }
      }
    }
    {
#line 130
    memset((void *)line, 0, sizeof(line));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  fclose(file);
#line 134
  xfree((void *)line);
#line 135
  hash_destroy(H);
  }
#line 136
  return (l->index);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cfg.c"
int read_cmd_line(LINES *l , char *url ) 
{ 
  int x ;
  char head[40000] ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 142
  x = 0;
#line 147
  if (! l) {
    {
#line 148
    printf((char const   */* __restrict  */)"Structure not initialized!\n");
    }
#line 149
    return (-1);
  }
#line 152
  l->index = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (x < 4)) {
#line 153
      goto while_break;
    }
    {
#line 154
    snprintf((char */* __restrict  */)(head), sizeof(head), (char const   */* __restrict  */)"%s",
             url);
#line 155
    parse(head);
#line 156
    chomp(head);
#line 157
    tmp___1 = strlen((char const   *)(head));
    }
#line 157
    if (! (tmp___1 == 0UL)) {
      {
#line 159
      tmp = realloc((void *)l->line, sizeof(char *) * (unsigned long )(l->index + 1));
#line 159
      l->line = (char **)tmp;
#line 160
      tmp___0 = strdup((char const   *)(head));
#line 160
      *(l->line + l->index) = tmp___0;
#line 161
      (l->index) ++;
      }
    }
#line 163
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (l->index);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/cfg.c"
BOOLEAN is_variable_line(char *line ) 
{ 
  char *pos___0 ;
  char *x ;
  char c ;

  {
  {
#line 178
  pos___0 = strstr((char const   *)line, "=");
  }
#line 179
  if ((unsigned long )pos___0 != (unsigned long )((void *)0)) {
#line 180
    x = line;
    {
#line 180
    while (1) {
      while_continue: /* CIL Label */ ;
#line 180
      if (! ((unsigned long )x < (unsigned long )pos___0)) {
#line 180
        goto while_break;
      }
#line 181
      c = *x;
#line 183
      if ((int )c < 97) {
#line 183
        goto _L___1;
      } else
#line 183
      if ((int )c > 122) {
        _L___1: /* CIL Label */ 
#line 183
        if ((int )c < 65) {
#line 183
          goto _L___0;
        } else
#line 183
        if ((int )c > 90) {
          _L___0: /* CIL Label */ 
#line 183
          if ((int )c < 48) {
#line 183
            goto _L;
          } else
#line 183
          if ((int )c > 57) {
            _L: /* CIL Label */ 
#line 183
            if ((int )c != 95) {
#line 187
              return ((BOOLEAN )0);
            }
          }
        }
      }
#line 180
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 194
    return ((BOOLEAN )0);
  }
#line 196
  return ((BOOLEAN )1);
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 270
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
#line 29 "./handler.h"
void spin_doctor(CREW crew ) ;
#line 30
void sig_handler(CREW crew ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/handler.c"
void spin_doctor(CREW crew ) 
{ 
  long x ;
  char h[4] ;
  int tmp ;

  {
#line 41
  h[0] = (char )'-';
#line 41
  h[1] = (char )'\\';
#line 41
  h[2] = (char )'|';
#line 41
  h[3] = (char )'/';
#line 43
  if ((unsigned int )my.spinner == 0U) {
#line 44
    return;
  }
#line 47
  x = 0L;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    tmp = crew_get_total(crew);
    }
#line 47
    if (! (tmp > 1)) {
#line 47
      if (! (x < 55L)) {
#line 47
        goto while_break;
      }
    }
    {
#line 48
    fflush(stderr);
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
            (int )h[x % 4L]);
#line 50
    pthread_usleep_np(20000UL);
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\b");
#line 47
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/handler.c"
void sig_handler(CREW crew ) 
{ 
  int gotsig ;
  sigset_t sigs ;
  int result ;
  pthread_t spinner ;

  {
  {
#line 59
  gotsig = 0;
#line 67
  sigemptyset(& sigs);
#line 68
  sigaddset(& sigs, 1);
#line 69
  sigaddset(& sigs, 2);
#line 70
  sigaddset(& sigs, 15);
#line 71
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sigs), (sigset_t */* __restrict  */)((void *)0));
#line 76
  sigwait((sigset_t const   */* __restrict  */)(& sigs), (int */* __restrict  */)(& gotsig));
#line 77
  my.verbose = (BOOLEAN )0;
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nLifting the server siege...");
#line 80
  crew_cancel(crew);
#line 85
  result = pthread_create((pthread_t */* __restrict  */)(& spinner), (pthread_attr_t const   */* __restrict  */)((void *)0),
                          (void *(*)(void * ))((void *)(& spin_doctor)), (void */* __restrict  */)crew);
  }
#line 85
  if (result < 0) {
    {
#line 86
    NOTIFY((LEVEL )2, "failed to create handler: %d\n", result);
    }
  }
  {
#line 95
  pthread_usleep_np(501125UL);
#line 101
  pthread_join(spinner, (void **)((void *)0));
#line 104
  pthread_exit((void *)0);
  }
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 66 "./util.h"
void itoa(int n , char *s ) ;
#line 67
void reverse(char *s ) ;
#line 68
int my_random(int max , int seed ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/util.c"
char *substring(char *str , int start , int len ) 
{ 
  int i ;
  char *ret ;
  char *res ;
  char *ptr ;
  char *end ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 45
  if (len < 1) {
#line 46
    return ((char *)((void *)0));
  } else
#line 45
  if (start < 0) {
#line 46
    return ((char *)((void *)0));
  } else {
    {
#line 45
    tmp = strlen((char const   *)str);
    }
#line 45
    if (start > (int )tmp) {
#line 46
      return ((char *)((void *)0));
    }
  }
  {
#line 48
  tmp___1 = strlen((char const   *)str);
  }
#line 48
  if (start + len > (int )tmp___1) {
    {
#line 49
    tmp___0 = strlen((char const   *)str);
#line 49
    len = (int )(tmp___0 - (size_t )start);
    }
  }
  {
#line 51
  tmp___2 = xmalloc((size_t )(len + 1));
#line 51
  ret = (char *)tmp___2;
#line 52
  res = ret;
#line 53
  ptr = str;
#line 54
  end = str;
#line 56
  i = 0;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < start)) {
#line 56
      goto while_break;
    }
#line 56
    i ++;
#line 56
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  i = 0;
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (! (i < start + len)) {
#line 57
      goto while_break___0;
    }
#line 57
    i ++;
#line 57
    end ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 58
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 58
      goto while_break___1;
    }
#line 59
    tmp___3 = res;
#line 59
    res ++;
#line 59
    tmp___4 = ptr;
#line 59
    ptr ++;
#line 59
    *tmp___3 = *tmp___4;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 61
  *res = (char)0;
#line 62
  return (ret);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/util.c"
int my_random(int max , int seed ) 
{ 
  time_t tmp ;
  int tmp___0 ;

  {
  {
#line 71
  tmp = time((time_t *)((void *)0));
#line 71
  srand((unsigned int )tmp * (unsigned int )seed);
#line 72
  tmp___0 = rand();
  }
#line 72
  return ((int )(((double )tmp___0 / ((double )2147483647 + (double )1)) * (double )max));
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/util.c"
void itoa(int n , char *s ) 
{ 
  int i ;
  int sign ;
  int tmp ;
  int tmp___0 ;

  {
#line 79
  sign = n;
#line 79
  if (sign < 0) {
#line 80
    n = - n;
  }
#line 81
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    tmp = i;
#line 83
    i ++;
#line 83
    *(s + tmp) = (char )(n % 10 + 48);
#line 82
    n /= 10;
#line 82
    if (! (n > 0)) {
#line 82
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (sign < 0) {
#line 86
    tmp___0 = i;
#line 86
    i ++;
#line 86
    *(s + tmp___0) = (char )'-';
  }
  {
#line 87
  *(s + i) = (char )'\000';
#line 89
  reverse(s);
  }
#line 90
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/util.c"
void reverse(char *s ) 
{ 
  int c ;
  int i ;
  int j ;
  size_t tmp ;

  {
  {
#line 96
  i = 0;
#line 96
  tmp = strlen((char const   *)s);
#line 96
  j = (int )(tmp - 1UL);
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i < j)) {
#line 96
      goto while_break;
    }
#line 97
    c = (int )*(s + i);
#line 98
    *(s + i) = *(s + j);
#line 99
    *(s + j) = (char )c;
#line 96
    i ++;
#line 96
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/util.c"
float elapsed_time(clock_t time___0 ) 
{ 
  long tps ;
  long tmp ;

  {
  {
#line 106
  tmp = sysconf(2);
#line 106
  tps = tmp;
  }
#line 107
  return ((float )time___0 / (float )tps);
}
}
#line 315 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 38 "./url.h"
size_t URLSIZE ;
#line 70
void url_dump(URL this ) ;
#line 104
char *url_get_path(URL this ) ;
#line 111
char *url_get_parameters(URL this ) ;
#line 114
char *url_get_query(URL this ) ;
#line 117
char *url_get_fragment(URL this ) ;
#line 133
char *url_get_posttemp(URL this ) ;
#line 137
char *url_get_realm(URL this ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
size_t URLSIZE  =    sizeof(struct URL_T );
#line 64
static void __url_parse(URL this , char *url ) ;
#line 65
static void __parse_post_data(URL this , char *datap ) ;
#line 66
static char *__url_set_absolute(URL this , char *url ) ;
#line 67
static BOOLEAN __url_has_scheme(char *url ) ;
#line 68
static BOOLEAN __url_has_credentials(char *url ) ;
#line 69
static int __url_default_port(URL this ) ;
#line 70
static char *__url_set_scheme(URL this , char *url ) ;
#line 71
static char *__url_set_password(URL this , char *str ) ;
#line 72
static char *__url_set_username(URL this , char *str ) ;
#line 73
static char *__url_set_hostname(URL this , char *str ) ;
#line 74
static char *__url_set_port(URL this , char *str ) ;
#line 75
static char *__url_set_path(URL this , char *str ) ;
#line 76
static char *__url_set_file(URL this , char *str ) ;
#line 77
static char *__url_set_parameters(URL this , char *str ) ;
#line 78
static char *__url_set_query(URL this , char *str ) ;
#line 79
static char *__url_set_fragment(URL this , char *str ) ;
#line 80
static char *__url_escape(char const   *s ) ;
#line 81
static METHOD __url_has_method(char const   *url ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
URL new_url(char *str ) 
{ 
  URL this ;
  void *tmp ;

  {
  {
#line 89
  tmp = xcalloc(sizeof(struct URL_T ), (size_t )1);
#line 89
  this = (URL )tmp;
#line 90
  this->ID = 0;
#line 91
  this->hasparams = (BOOLEAN )0;
#line 92
  __url_parse(this, str);
  }
#line 93
  return (this);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
URL url_destroy(URL this ) 
{ 


  {
#line 99
  if ((unsigned long )this != (unsigned long )((void *)0)) {
    {
#line 100
    xfree((void *)this->username);
#line 101
    xfree((void *)this->password);
#line 102
    xfree((void *)this->hostname);
#line 103
    xfree((void *)this->path);
#line 104
    xfree((void *)this->file);
#line 105
    xfree((void *)this->query);
#line 106
    xfree((void *)this->frag);
#line 107
    xfree((void *)this->request);
#line 108
    xfree((void *)this->conttype);
#line 109
    xfree((void *)this->postdata);
#line 110
    xfree((void *)this->etag);
#line 111
    xfree((void *)this);
    }
  }
#line 113
  return ((URL )((void *)0));
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_ID(URL this , int ID ) 
{ 


  {
#line 123
  this->ID = ID;
#line 124
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_hostname(URL this , char *hostname ) 
{ 
  size_t len ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 137
  tmp = empty((char const   *)hostname);
  }
#line 137
  if (tmp) {
#line 137
    return;
  }
  {
#line 139
  xfree((void *)this->hostname);
#line 140
  tmp___0 = strlen((char const   *)hostname);
#line 140
  len = tmp___0 + 1UL;
#line 141
  tmp___1 = xmalloc(len);
#line 141
  this->hostname = (char *)tmp___1;
#line 142
  memset((void *)this->hostname, 0, sizeof(this->hostname));
#line 143
  strncpy((char */* __restrict  */)this->hostname, (char const   */* __restrict  */)hostname,
          len);
  }
#line 144
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_last_modified(URL this , char *date ) 
{ 


  {
  {
#line 150
  this->modified = strtotime((char const   *)date);
  }
#line 151
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_etag(URL this , char *etag ) 
{ 
  size_t len ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 159
  tmp = empty((char const   *)etag);
  }
#line 159
  if (tmp) {
#line 159
    return;
  }
  {
#line 161
  tmp___0 = strlen((char const   *)etag);
#line 161
  len = tmp___0 + 1UL;
#line 162
  tmp___1 = xmalloc(len);
#line 162
  this->etag = (char *)tmp___1;
#line 163
  memset((void *)this->etag, 0, sizeof(this->etag));
#line 164
  strncpy((char */* __restrict  */)this->etag, (char const   */* __restrict  */)etag,
          len);
  }
#line 165
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_conttype(URL this , char *type ) 
{ 


  {
  {
#line 170
  this->conttype = xstrdup((char const   *)type);
  }
#line 171
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_method(URL this , METHOD method ) 
{ 


  {
#line 176
  this->method = method;
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_postdata(URL this , char *postdata , size_t postlen ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 182
  this->postlen = postlen;
#line 184
  tmp___0 = strlen((char const   *)postdata);
  }
#line 184
  if (tmp___0 > 0UL) {
    {
#line 185
    tmp = malloc(this->postlen);
#line 185
    this->postdata = (char *)tmp;
#line 186
    memcpy((void */* __restrict  */)this->postdata, (void const   */* __restrict  */)postdata,
           this->postlen);
#line 187
    *(this->postdata + this->postlen) = (char)0;
    }
  }
#line 189
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
int url_get_ID(URL this ) 
{ 


  {
#line 200
  return (this->ID);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_absolute(URL this ) 
{ 


  {
#line 206
  return (this->url);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
SCHEME url_get_scheme(URL this ) 
{ 


  {
#line 212
  return (this->scheme);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_display(URL this ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 218
  if (my.fullurl) {
    {
#line 219
    tmp = url_get_absolute(this);
    }
#line 219
    return (tmp);
  }
#line 221
  if ((unsigned int )this->method == 2U) {
    {
#line 222
    tmp___0 = url_get_request(this);
    }
#line 222
    return (tmp___0);
  }
  {
#line 224
  tmp___1 = url_get_absolute(this);
  }
#line 224
  return (tmp___1);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_scheme_name(URL this ) 
{ 


  {
  {
#line 231
  if ((unsigned int )this->scheme == 1U) {
#line 231
    goto case_1;
  }
#line 233
  if ((unsigned int )this->scheme == 2U) {
#line 233
    goto case_2;
  }
#line 235
  if ((unsigned int )this->scheme == 3U) {
#line 235
    goto case_3;
  }
#line 237
  if ((unsigned int )this->scheme == 4U) {
#line 237
    goto case_4;
  }
#line 240
  goto switch_default;
  case_1: /* CIL Label */ 
#line 232
  return ((char *)"http");
  case_2: /* CIL Label */ 
#line 234
  return ((char *)"https");
  case_3: /* CIL Label */ 
#line 236
  return ((char *)"ftp");
  case_4: /* CIL Label */ 
#line 238
  return ((char *)"proxy");
  switch_default: /* CIL Label */ 
#line 241
  return ((char *)"unsupported");
  switch_break: /* CIL Label */ ;
  }
#line 243
  return ((char *)"unsupported");
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_username(URL this ) 
{ 


  {
#line 249
  return (this->username);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_password(URL this ) 
{ 


  {
#line 255
  return (this->password);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_hostname(URL this ) 
{ 


  {
#line 261
  return (this->hostname);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
int url_get_port(URL this ) 
{ 


  {
#line 267
  return (this->port);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_path(URL this ) 
{ 


  {
#line 273
  return (this->path);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_file(URL this ) 
{ 


  {
#line 279
  return (this->file);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_request(URL this ) 
{ 


  {
#line 285
  return (this->request);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_parameters(URL this ) 
{ 


  {
#line 291
  return (this->params);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_query(URL this ) 
{ 


  {
#line 297
  return (this->query);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_fragment(URL this ) 
{ 


  {
#line 303
  return (this->frag);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
size_t url_get_postlen(URL this ) 
{ 


  {
#line 308
  return (this->postlen);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_postdata(URL this ) 
{ 


  {
#line 313
  return (this->postdata);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_posttemp(URL this ) 
{ 


  {
#line 318
  return (this->posttemp);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_conttype(URL this ) 
{ 


  {
#line 323
  return (this->conttype);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
METHOD url_get_method(URL this ) 
{ 


  {
#line 328
  return (this->method);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_method_name(URL this ) 
{ 


  {
  {
#line 334
  if ((unsigned int )this->method == 3U) {
#line 334
    goto case_3;
  }
#line 336
  if ((unsigned int )this->method == 4U) {
#line 336
    goto case_4;
  }
#line 338
  if ((unsigned int )this->method == 5U) {
#line 338
    goto case_5;
  }
#line 340
  if ((unsigned int )this->method == 1U) {
#line 340
    goto case_1;
  }
#line 343
  goto switch_default;
  case_3: /* CIL Label */ 
#line 335
  return ((char *)"POST");
  case_4: /* CIL Label */ 
#line 337
  return ((char *)"PUT");
  case_5: /* CIL Label */ 
#line 339
  return ((char *)"DELETE");
  case_1: /* CIL Label */ 
#line 341
  return ((char *)"HEAD");
  switch_default: /* CIL Label */ 
#line 344
  return ((char *)"GET");
  switch_break: /* CIL Label */ ;
  }
#line 346
  return ((char *)"GET");
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_if_modified_since(URL this ) 
{ 
  char *tmp ;

  {
#line 352
  if ((unsigned int )this->cached == 0U) {
#line 353
    return ((char *)((void *)0));
  }
  {
#line 356
  tmp = timetostr((time_t const   *)(& this->modified));
  }
#line 356
  return (tmp);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_etag(URL this ) 
{ 
  char *tag ;
  size_t len ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 365
  tmp = empty((char const   *)this->etag);
  }
#line 365
  if (tmp) {
#line 365
    return ((char *)((void *)0));
  }
  {
#line 367
  tmp___0 = strlen((char const   *)this->etag);
#line 367
  len = tmp___0 + 18UL;
#line 368
  tmp___1 = xmalloc(len);
#line 368
  tag = (char *)tmp___1;
#line 369
  memset((void *)tag, 0, sizeof(tag));
#line 371
  snprintf((char */* __restrict  */)tag, len, (char const   */* __restrict  */)"If-None-Match: %s\r\n",
           this->etag);
  }
#line 372
  return (tag);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
char *url_get_realm(URL this ) 
{ 
  char const   *tmp ;

  {
#line 378
  if ((unsigned long )this->realm != (unsigned long )((void *)0)) {
#line 378
    tmp = (char const   *)this->realm;
  } else {
#line 378
    tmp = "";
  }
#line 378
  return ((char *)tmp);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_realm(URL this , char *realm ) 
{ 


  {
  {
#line 384
  this->realm = xstrdup((char const   *)realm);
  }
#line 385
  return;
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_username(URL this , char *username ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 390
  tmp = strlen((char const   *)username);
#line 390
  len = tmp;
#line 392
  tmp___0 = malloc(len + 1UL);
#line 392
  this->username = (char *)tmp___0;
#line 393
  memset((void *)this->username, '\000', len + 1UL);
#line 394
  memcpy((void */* __restrict  */)this->username, (void const   */* __restrict  */)username,
         len);
  }
#line 395
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_set_password(URL this , char *password ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 401
  tmp = strlen((char const   *)password);
#line 401
  len = tmp;
#line 403
  tmp___0 = malloc(len + 1UL);
#line 403
  this->password = (char *)tmp___0;
#line 404
  memset((void *)this->password, '\000', len + 1UL);
#line 405
  memcpy((void */* __restrict  */)this->password, (void const   */* __restrict  */)password,
         len);
  }
#line 406
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
void url_dump(URL this ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 412
  printf((char const   */* __restrict  */)"URL ID:    %d\n", this->ID);
#line 413
  printf((char const   */* __restrict  */)"Abolute:   %s\n", this->url);
#line 414
  tmp = url_get_scheme_name(this);
#line 414
  printf((char const   */* __restrict  */)"Scheme:    %s\n", tmp);
#line 415
  tmp___0 = url_get_method_name(this);
#line 415
  printf((char const   */* __restrict  */)"Method:    %s\n", tmp___0);
#line 416
  tmp___1 = url_get_username(this);
#line 416
  printf((char const   */* __restrict  */)"Username:  %s\n", tmp___1);
#line 417
  tmp___2 = url_get_password(this);
#line 417
  printf((char const   */* __restrict  */)"Password:  %s\n", tmp___2);
#line 418
  tmp___3 = url_get_hostname(this);
#line 418
  printf((char const   */* __restrict  */)"Hostname:  %s\n", tmp___3);
#line 419
  tmp___4 = url_get_port(this);
#line 419
  printf((char const   */* __restrict  */)"Port:      %d\n", tmp___4);
#line 420
  tmp___5 = url_get_path(this);
#line 420
  printf((char const   */* __restrict  */)"Path:      %s\n", tmp___5);
#line 421
  tmp___6 = url_get_file(this);
#line 421
  printf((char const   */* __restrict  */)"File:      %s\n", tmp___6);
#line 422
  tmp___7 = url_get_request(this);
#line 422
  printf((char const   */* __restrict  */)"Request:   %s\n", tmp___7);
  }
#line 423
  if ((unsigned int )this->hasparams == 1U) {
    {
#line 424
    tmp___8 = url_get_parameters(this);
#line 424
    printf((char const   */* __restrict  */)"Params:   %s\n", tmp___8);
    }
  }
  {
#line 425
  tmp___9 = url_get_query(this);
#line 425
  printf((char const   */* __restrict  */)"Query:     %s\n", tmp___9);
#line 426
  tmp___10 = url_get_fragment(this);
#line 426
  printf((char const   */* __restrict  */)"Fragment:  %s\n", tmp___10);
#line 427
  tmp___11 = url_get_postlen(this);
#line 427
  printf((char const   */* __restrict  */)"Post Len:  %d\n", tmp___11);
#line 428
  tmp___12 = url_get_postdata(this);
#line 428
  printf((char const   */* __restrict  */)"Post Data: %s\n", tmp___12);
#line 429
  tmp___13 = url_get_conttype(this);
#line 429
  printf((char const   */* __restrict  */)"Cont Type: %s\n", tmp___13);
  }
#line 435
  return;
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static void __url_parse(URL this , char *url ) 
{ 
  char *ptr ;
  char *esc ;
  char *post ;
  int tmp ;
  BOOLEAN tmp___0 ;

  {
  {
#line 441
  ptr = (char *)((void *)0);
#line 442
  esc = (char *)((void *)0);
#line 450
  esc = __url_escape((char const   *)url);
  }
#line 451
  if (my.escape) {
    {
#line 452
    ptr = __url_set_absolute(this, esc);
    }
  } else {
    {
#line 454
    ptr = __url_set_absolute(this, url);
    }
  }
  {
#line 456
  ptr = __url_set_scheme(this, ptr);
#line 458
  post = strstr((char const   *)this->url, " POST");
  }
#line 459
  if (! post) {
    {
#line 460
    post = strstr((char const   *)this->url, " PUT");
    }
  }
#line 463
  if ((unsigned long )post != (unsigned long )((void *)0)) {
    {
#line 464
    tmp = strncasecmp((char const   *)post, " PUT", (size_t )4);
    }
#line 464
    if (tmp) {
#line 468
      this->method = (METHOD )3;
#line 469
      post += 5;
    } else {
#line 465
      this->method = (METHOD )4;
#line 466
      post += 4;
    }
    {
#line 471
    __parse_post_data(this, post);
    }
  } else {
#line 473
    this->method = (METHOD )2;
#line 474
    this->postdata = (char *)((void *)0);
#line 475
    this->posttemp = (char *)((void *)0);
#line 476
    this->postlen = (size_t )0;
  }
  {
#line 479
  tmp___0 = __url_has_credentials(ptr);
  }
#line 479
  if (tmp___0) {
    {
#line 480
    ptr = __url_set_username(this, ptr);
#line 481
    ptr = __url_set_password(this, ptr);
    }
  }
  {
#line 484
  ptr = __url_set_hostname(this, ptr);
#line 485
  ptr = __url_set_port(this, ptr);
#line 486
  ptr = __url_set_path(this, ptr);
#line 487
  ptr = __url_set_file(this, ptr);
#line 488
  ptr = __url_set_parameters(this, ptr);
#line 489
  ptr = __url_set_query(this, ptr);
#line 490
  ptr = __url_set_fragment(this, ptr);
  }
#line 491
  return;
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static void __parse_post_data(URL this , char *datap ) 
{ 
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 497
    tmp = __ctype_b_loc();
    }
#line 497
    if (! ((int const   )*(*tmp + (int )((unsigned int )*datap)) & 8192)) {
#line 497
      goto while_break;
    }
#line 497
    datap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  if ((int )*datap == 60) {
    {
#line 501
    datap ++;
#line 502
    load_file(this, datap);
#line 503
    tmp___0 = strlen((char const   *)datap);
#line 503
    tmp___1 = xmalloc(tmp___0 + 1UL);
#line 503
    this->file = (char *)tmp___1;
#line 504
    tmp___2 = strlen((char const   *)datap);
#line 504
    memset((void *)this->file, '\000', tmp___2 + 1UL);
#line 505
    tmp___3 = strlen((char const   *)datap);
#line 505
    memcpy((void */* __restrict  */)this->file, (void const   */* __restrict  */)datap,
           tmp___3);
    }
#line 506
    return;
  } else {
    {
#line 508
    this->postdata = xstrdup((char const   *)datap);
#line 509
    this->postlen = strlen((char const   *)this->postdata);
#line 510
    tmp___4 = empty((char const   *)(my.conttype));
    }
#line 510
    if (tmp___4) {
      {
#line 513
      this->conttype = xstrdup("application/x-www-form-urlencoded");
      }
    } else {
      {
#line 511
      this->conttype = xstrdup((char const   *)(my.conttype));
      }
    }
#line 515
    return;
  }
#line 518
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_absolute(URL this , char *url ) 
{ 
  size_t len ;
  char *slash ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  BOOLEAN tmp___3 ;

  {
  {
#line 531
  tmp = empty((char const   *)url);
  }
#line 531
  if (tmp) {
#line 531
    return ((char *)((void *)0));
  }
  {
#line 533
  tmp___0 = strlen((char const   *)url);
#line 533
  len = tmp___0 + 5UL;
#line 534
  tmp___3 = __url_has_scheme(url);
  }
#line 534
  if (tmp___3) {
    {
#line 544
    tmp___2 = xmalloc(len);
#line 544
    this->url = (char *)tmp___2;
#line 545
    memset((void *)this->url, '\000', sizeof(this->url));
#line 546
    snprintf((char */* __restrict  */)this->url, len, (char const   */* __restrict  */)"%s",
             url);
    }
  } else {
    {
#line 535
    tmp___1 = xmalloc(len + 7UL);
#line 535
    this->url = (char *)tmp___1;
#line 536
    memset((void *)this->url, '\000', sizeof(this->url));
#line 537
    slash = strstr((char const   *)url, "/");
    }
#line 538
    if (slash) {
      {
#line 539
      snprintf((char */* __restrict  */)this->url, len + 7UL, (char const   */* __restrict  */)"http://%s",
               url);
      }
    } else {
      {
#line 541
      snprintf((char */* __restrict  */)this->url, len + 7UL, (char const   */* __restrict  */)"http://%s/",
               url);
      }
    }
  }
#line 548
  return (this->url);
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static BOOLEAN __url_has_scheme(char *url ) 
{ 
  char const   *p ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 558
  p = (char const   *)url;
#line 561
  if (! *p) {
#line 562
    return ((BOOLEAN )0);
  } else {
    {
#line 561
    tmp = __ctype_b_loc();
    }
#line 561
    if (! ((int const   )*(*tmp + (int )*p) & 8)) {
#line 561
      if (! ((int const   )*p == 45)) {
#line 561
        if (! ((int const   )*p == 43)) {
#line 562
          return ((BOOLEAN )0);
        }
      }
    }
  }
#line 563
  p ++;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (*p) {
      {
#line 565
      tmp___0 = __ctype_b_loc();
      }
#line 565
      if (! ((int const   )*(*tmp___0 + (int )*p) & 8)) {
#line 565
        if (! ((int const   )*p == 45)) {
#line 565
          if (! ((int const   )*p == 43)) {
#line 565
            goto while_break;
          }
        }
      }
    } else {
#line 565
      goto while_break;
    }
#line 566
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  return ((BOOLEAN )((int const   )*p == 58));
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static BOOLEAN __url_has_credentials(char *url ) 
{ 
  char const   *p ;
  char *tmp ;

  {
  {
#line 577
  tmp = strpbrk((char const   *)url, "@/?#;");
#line 577
  p = (char const   *)tmp;
  }
#line 578
  if (! p) {
#line 579
    return ((BOOLEAN )0);
  } else
#line 578
  if ((int const   )*p != 64) {
#line 579
    return ((BOOLEAN )0);
  }
#line 580
  return ((BOOLEAN )1);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static int __url_default_port(URL this ) 
{ 


  {
  {
#line 587
  if ((unsigned int )this->scheme == 3U) {
#line 587
    goto case_3;
  }
#line 589
  if ((unsigned int )this->scheme == 1U) {
#line 589
    goto case_1;
  }
#line 591
  if ((unsigned int )this->scheme == 2U) {
#line 591
    goto case_2;
  }
#line 594
  goto switch_default;
  case_3: /* CIL Label */ 
#line 588
  return (21);
  case_1: /* CIL Label */ 
#line 590
  return (80);
  case_2: /* CIL Label */ 
#line 592
  return (443);
  switch_default: /* CIL Label */ 
#line 595
  return (80);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_scheme(URL this , char *url ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 606
  tmp = strncasecmp((char const   *)this->url, "http:", (size_t )5);
  }
#line 606
  if (! tmp) {
#line 607
    this->scheme = (SCHEME )1;
#line 608
    return (url + 7);
  }
  {
#line 610
  tmp___0 = strncasecmp((char const   *)this->url, "https:", (size_t )6);
  }
#line 610
  if (! tmp___0) {
#line 611
    this->scheme = (SCHEME )2;
#line 612
    return (url + 8);
  }
  {
#line 614
  tmp___1 = strncasecmp((char const   *)this->url, "ftp:", (size_t )4);
  }
#line 614
  if (! tmp___1) {
#line 615
    this->scheme = (SCHEME )3;
#line 616
    return (url + 6);
  }
#line 618
  this->scheme = (SCHEME )0;
#line 619
  return (url);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_username(URL this , char *str ) 
{ 
  int i ;
  char *a ;
  char *s ;
  void *tmp ;

  {
  {
#line 633
  a = strchr((char const   *)str, '@');
#line 634
  s = strchr((char const   *)str, '/');
  }
#line 636
  if (! a) {
#line 637
    return (str);
  } else
#line 636
  if (s) {
#line 636
    if ((unsigned long )a >= (unsigned long )s) {
#line 637
      return (str);
    }
  }
#line 640
  i = 0;
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (*(str + i)) {
#line 640
      if ((int )*(str + i) != 58) {
#line 640
        if ((int )*(str + i) != 64) {
#line 640
          if (! ((int )*(str + i) != 47)) {
#line 640
            goto while_break;
          }
        } else {
#line 640
          goto while_break;
        }
      } else {
#line 640
        goto while_break;
      }
    } else {
#line 640
      goto while_break;
    }
#line 640
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  if ((int )*(str + i) != 64) {
#line 642
    if ((int )*(str + i) != 58) {
#line 643
      return (str);
    }
  }
  {
#line 646
  tmp = malloc((size_t )(i + 1));
#line 646
  this->username = (char *)tmp;
#line 647
  memcpy((void */* __restrict  */)this->username, (void const   */* __restrict  */)str,
         (size_t )(i + 1));
#line 648
  *(this->username + i) = (char )'\000';
#line 649
  str += i + 1;
  }
#line 651
  return (str);
}
}
#line 658 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_password(URL this , char *str ) 
{ 
  int i ;
  char *a ;
  char *s ;
  void *tmp ;

  {
  {
#line 664
  a = strchr((char const   *)str, '@');
#line 665
  s = strchr((char const   *)str, '/');
  }
#line 667
  if (! a) {
#line 668
    return (str);
  } else
#line 667
  if (s) {
#line 667
    if ((unsigned long )a >= (unsigned long )s) {
#line 668
      return (str);
    }
  }
#line 674
  i = 0;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! ((int )*(str + i) != 64)) {
#line 674
      goto while_break;
    }
#line 674
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 675
  tmp = xmalloc((size_t )(i + 1));
#line 675
  this->password = (char *)tmp;
#line 677
  memcpy((void */* __restrict  */)this->password, (void const   */* __restrict  */)str,
         (size_t )i);
#line 678
  *(this->password + i) = (char )'\000';
#line 680
  str += i + 1;
  }
#line 682
  return (str);
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_hostname(URL this , char *str ) 
{ 
  int i ;
  void *tmp ;

  {
#line 695
  i = 0;
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (*(str + i)) {
#line 695
      if ((int )*(str + i) != 47) {
#line 695
        if (! ((int )*(str + i) != 58)) {
#line 695
          goto while_break;
        }
      } else {
#line 695
        goto while_break;
      }
    } else {
#line 695
      goto while_break;
    }
#line 695
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 697
  tmp = xmalloc((size_t )(i + 1));
#line 697
  this->hostname = (char *)tmp;
#line 698
  memcpy((void */* __restrict  */)this->hostname, (void const   */* __restrict  */)str,
         (size_t )i);
#line 700
  *(this->hostname + i) = (char )'\000';
  }
#line 703
  if ((int )*(str + i) == 58) {
#line 704
    str += i + 1;
  } else {
#line 706
    str += i;
  }
#line 708
  return (str);
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_port(URL this , char *str ) 
{ 
  char *portstr ;
  int i ;
  unsigned short const   **tmp ;
  void *tmp___0 ;

  {
  {
#line 721
  this->port = __url_default_port(this);
#line 723
  i = 0;
  }
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 723
    tmp = __ctype_b_loc();
    }
#line 723
    if (! ((int const   )*(*tmp + (int )*(str + i)) & 2048)) {
#line 723
      goto while_break;
    }
#line 723
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 725
  if (i == 0) {
#line 725
    return (str);
  }
  {
#line 728
  tmp___0 = malloc((size_t )(i + 1));
#line 728
  portstr = (char *)tmp___0;
#line 729
  memcpy((void */* __restrict  */)portstr, (void const   */* __restrict  */)str, (size_t )(i + 1));
#line 730
  *(portstr + i) = (char )'\000';
#line 732
  this->port = atoi((char const   *)portstr);
#line 733
  xfree((void *)portstr);
#line 735
  str += i;
  }
#line 736
  return (str);
}
}
#line 743 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_path(URL this , char *str ) 
{ 
  int i ;
  int j ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 749
  tmp = strlen((char const   *)str);
#line 749
  i = (int )tmp;
  }
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (i > 0) {
#line 749
      if (! ((int )*(str + i) != 47)) {
#line 749
        goto while_break;
      }
    } else {
#line 749
      goto while_break;
    }
#line 749
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 750
  j = 0;
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 750
    if (*(str + j)) {
#line 750
      if ((int )*(str + j) != 35) {
        {
#line 750
        tmp___0 = __ctype_b_loc();
        }
#line 750
        if ((int const   )*(*tmp___0 + (int )*(str + j)) & 8192) {
#line 750
          goto while_break___0;
        }
      } else {
#line 750
        goto while_break___0;
      }
    } else {
#line 750
      goto while_break___0;
    }
#line 750
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 753
  if ((int )*(str + i) != 47) {
    {
#line 754
    tmp___1 = xmalloc((size_t )2);
#line 754
    this->path = (char *)tmp___1;
#line 755
    tmp___2 = xmalloc((size_t )2);
#line 755
    this->request = (char *)tmp___2;
#line 756
    strncpy((char */* __restrict  */)this->path, (char const   */* __restrict  */)"/",
            (size_t )2);
#line 757
    strncpy((char */* __restrict  */)this->request, (char const   */* __restrict  */)"/",
            (size_t )2);
#line 758
    *(this->path + 1) = (char )'\000';
#line 759
    *(this->request + 1) = (char )'\000';
    }
  } else {
    {
#line 761
    tmp___3 = xmalloc((size_t )(i + 2));
#line 761
    this->path = (char *)tmp___3;
#line 762
    tmp___4 = xmalloc((size_t )(j + 2));
#line 762
    this->request = (char *)tmp___4;
#line 763
    memcpy((void */* __restrict  */)this->path, (void const   */* __restrict  */)str,
           (size_t )(i + 1));
#line 764
    memcpy((void */* __restrict  */)this->request, (void const   */* __restrict  */)str,
           (size_t )(j + 1));
#line 765
    *(this->path + i) = (char )'/';
#line 766
    *(this->path + (i + 1)) = (char )'\000';
    }
#line 767
    if ((int )*(this->request + j) == 35) {
#line 768
      *(this->request + j) = (char )'\000';
    } else {
#line 770
      *(this->request + (j + 1)) = (char )'\000';
    }
  }
  {
#line 773
  trim(this->request);
#line 774
  str += i + 1;
  }
#line 775
  return (str);
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_file(URL this , char *str ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
#line 787
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 787
    return ((char *)((void *)0));
  }
#line 788
  if ((unsigned long )this->file != (unsigned long )((void *)0)) {
    {
#line 788
    tmp = strlen((char const   *)this->file);
    }
#line 788
    if (tmp > 1UL) {
#line 788
      return (str);
    }
  }
#line 790
  i = 0;
  {
#line 790
  while (1) {
    while_continue: /* CIL Label */ ;
#line 790
    if (*(str + i)) {
#line 790
      if ((int )*(str + i) != 59) {
#line 790
        if ((int )*(str + i) != 63) {
          {
#line 790
          tmp___0 = __ctype_b_loc();
          }
#line 790
          if ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192) {
#line 790
            goto while_break;
          }
        } else {
#line 790
          goto while_break;
        }
      } else {
#line 790
        goto while_break;
      }
    } else {
#line 790
      goto while_break;
    }
#line 790
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 791
  tmp___1 = xmalloc((size_t )(i + 1));
#line 791
  this->file = (char *)tmp___1;
#line 792
  memset((void *)this->file, '\000', (size_t )(i + 1));
#line 793
  memcpy((void */* __restrict  */)this->file, (void const   */* __restrict  */)str,
         (size_t )i);
#line 794
  trim(this->file);
  }
#line 797
  if ((int )*(str + i) == 59) {
#line 798
    this->hasparams = (BOOLEAN )1;
#line 799
    str += i + 1;
  } else
#line 800
  if ((int )*(str + i) == 63) {
#line 801
    str += i + 1;
  } else {
#line 803
    str += i;
  }
#line 805
  return (str);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_parameters(URL this , char *str ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
#line 817
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 817
    return ((char *)((void *)0));
  }
#line 818
  if ((unsigned long )this->params != (unsigned long )((void *)0)) {
    {
#line 818
    tmp = strlen((char const   *)this->params);
    }
#line 818
    if (tmp > 1UL) {
#line 818
      return (str);
    }
  }
#line 820
  if ((unsigned int )this->hasparams == 0U) {
#line 821
    this->params = (char *)"";
#line 822
    return (str);
  }
#line 825
  i = 0;
  {
#line 825
  while (1) {
    while_continue: /* CIL Label */ ;
#line 825
    if (*(str + i)) {
#line 825
      if ((int )*(str + i) != 63) {
        {
#line 825
        tmp___0 = __ctype_b_loc();
        }
#line 825
        if ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192) {
#line 825
          goto while_break;
        }
      } else {
#line 825
        goto while_break;
      }
    } else {
#line 825
      goto while_break;
    }
#line 825
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 827
  tmp___1 = xmalloc((size_t )(i + 1));
#line 827
  this->params = (char *)tmp___1;
#line 828
  memset((void *)this->params, '\000', (size_t )(i + 1));
#line 829
  memcpy((void */* __restrict  */)this->params, (void const   */* __restrict  */)str,
         (size_t )i);
  }
#line 832
  if ((int )*(str + i) == 63) {
#line 833
    str += i + 1;
  } else {
#line 835
    str += i;
  }
#line 837
  return (str);
}
}
#line 844 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_query(URL this , char *str ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
#line 849
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    {
#line 850
    this->query = xstrcat("");
    }
#line 851
    return ((char *)((void *)0));
  }
#line 854
  if ((unsigned long )this->query != (unsigned long )((void *)0)) {
    {
#line 854
    tmp = strlen((char const   *)this->query);
    }
#line 854
    if (tmp > 1UL) {
#line 854
      return (str);
    }
  }
#line 856
  i = 0;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (*(str + i)) {
#line 856
      if ((int )*(str + i) != 35) {
        {
#line 856
        tmp___0 = __ctype_b_loc();
        }
#line 856
        if ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192) {
#line 856
          goto while_break;
        }
      } else {
#line 856
        goto while_break;
      }
    } else {
#line 856
      goto while_break;
    }
#line 856
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 858
  tmp___1 = xmalloc((size_t )(i + 1));
#line 858
  this->query = (char *)tmp___1;
#line 859
  memset((void *)this->query, '\000', (size_t )(i + 1));
#line 860
  memcpy((void */* __restrict  */)this->query, (void const   */* __restrict  */)str,
         (size_t )i);
  }
#line 863
  if ((int )*(str + i) == 35) {
#line 864
    str += i + 1;
  } else {
#line 866
    str += i;
  }
#line 868
  return (str);
}
}
#line 875 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_set_fragment(URL this , char *str ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
#line 880
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 880
    return ((char *)((void *)0));
  }
#line 881
  if ((unsigned long )this->frag != (unsigned long )((void *)0)) {
    {
#line 881
    tmp = strlen((char const   *)this->frag);
    }
#line 881
    if (tmp > 1UL) {
#line 881
      return (str);
    }
  }
#line 883
  i = 0;
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 883
    if (*(str + i)) {
      {
#line 883
      tmp___0 = __ctype_b_loc();
      }
#line 883
      if ((int const   )*(*tmp___0 + (int )*(str + i)) & 8192) {
#line 883
        goto while_break;
      }
    } else {
#line 883
      goto while_break;
    }
#line 883
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  tmp___1 = xmalloc((size_t )(i + 1));
#line 885
  this->frag = (char *)tmp___1;
#line 886
  memcpy((void */* __restrict  */)this->frag, (void const   */* __restrict  */)str,
         (size_t )i);
#line 888
  str += i + 1;
  }
#line 889
  return (str);
}
}
#line 915 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static unsigned char const   urlchr_table[256]  = 
#line 915
  {      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2};
#line 954 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
__inline static enum copy_method decide_copy_method(char const   *p ) 
{ 
  char preempt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 957
  if ((int const   )*p == 37) {
#line 958
    if (((((((((((((((((((((((((unsigned int )*(p + 1) - 48U) & 255U) * 18U) / 17U) * 52U) / 51U) * 58U) / 114U) * 13U) / 11U) * 14U) / 13U) * 35U + 35U) / 36U) * 35U) / 33U) * 34U) / 33U) * 35U) / 170U ^ 4U) - 3U) & 255U) ^ 1U) <= 2U) {
#line 958
      if (((((((((((((((((((((((((unsigned int )*(p + 2) - 48U) & 255U) * 18U) / 17U) * 52U) / 51U) * 58U) / 114U) * 13U) / 11U) * 14U) / 13U) * 35U + 35U) / 36U) * 35U) / 33U) * 34U) / 33U) * 35U) / 170U ^ 4U) - 3U) & 255U) ^ 1U) <= 2U) {
#line 963
        if ((int const   )*(p + 1) < 65) {
#line 963
          tmp___0 = (int const   )*(p + 1) - 48;
        } else {
          {
#line 963
          tmp = toupper((int )*(p + 1));
#line 963
          tmp___0 = (int const   )((tmp - 65) + 10);
          }
        }
#line 963
        if ((int const   )*(p + 2) < 65) {
#line 963
          tmp___2 = (int const   )*(p + 2) - 48;
        } else {
          {
#line 963
          tmp___1 = toupper((int )*(p + 2));
#line 963
          tmp___2 = (int const   )((tmp___1 - 65) + 10);
          }
        }
#line 963
        preempt = (char )((tmp___0 << 4) + tmp___2);
#line 964
        if ((int const   )urlchr_table[(unsigned char )preempt] & 2) {
#line 965
          return ((enum copy_method )2);
        } else
#line 964
        if ((int const   )urlchr_table[(unsigned char )preempt] & 1) {
#line 965
          return ((enum copy_method )2);
        } else {
#line 967
          return ((enum copy_method )0);
        }
      } else {
#line 969
        return ((enum copy_method )1);
      }
    } else {
#line 969
      return ((enum copy_method )1);
    }
  } else
#line 972
  if ((int const   )urlchr_table[(unsigned char )*p] & 2) {
#line 972
    if (! ((int const   )urlchr_table[(unsigned char )*p] & 1)) {
#line 973
      return ((enum copy_method )1);
    } else {
#line 975
      return ((enum copy_method )2);
    }
  } else {
#line 975
    return ((enum copy_method )2);
  }
}
}
#line 983 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char const   * const  methods[8]  = 
#line 983
  {      (char const   */* const  */)" GET",      (char const   */* const  */)" HEAD",      (char const   */* const  */)" POST",      (char const   */* const  */)" PUT", 
        (char const   */* const  */)" TRACE",      (char const   */* const  */)" DELETE",      (char const   */* const  */)" OPTIONS",      (char const   */* const  */)" CONNECT"};
#line 978 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static METHOD __url_has_method(char const   *url ) 
{ 
  unsigned int i ;
  char const   *r ;
  char *tmp ;

  {
#line 981
  i = 0U;
#line 982
  r = (char const   *)((void *)0);
#line 987
  i = 0U;
  {
#line 987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 987
    if (! ((unsigned long )i < sizeof(methods) / sizeof(methods[0]))) {
#line 987
      goto while_break;
    }
    {
#line 988
    tmp = strstr(url, (char const   *)methods[i]);
#line 988
    r = (char const   *)tmp;
    }
#line 989
    if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 989
      return ((METHOD )i);
    }
#line 987
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 992
  return ((METHOD )0);
}
}
#line 995 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/url.c"
static char *__url_escape(char const   *s ) 
{ 
  char const   *p1 ;
  char *newstr ;
  char *p2 ;
  int oldlen ;
  int newlen ;
  int encode_count ;
  int decode_count ;
  METHOD tmp ;
  enum copy_method tmp___0 ;
  void *tmp___1 ;
  enum copy_method tmp___2 ;
  unsigned char c ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;

  {
  {
#line 1002
  encode_count = 0;
#line 1003
  decode_count = 0;
#line 1010
  tmp = __url_has_method(s);
  }
#line 1010
  if ((unsigned int )tmp != 0U) {
#line 1011
    return ((char *)s);
  }
#line 1016
  p1 = s;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    if (! *p1) {
#line 1016
      goto while_break;
    }
    {
#line 1017
    tmp___0 = decide_copy_method(p1);
    }
    {
#line 1018
    if ((unsigned int )tmp___0 == 1U) {
#line 1018
      goto case_1;
    }
#line 1021
    if ((unsigned int )tmp___0 == 0U) {
#line 1021
      goto case_0;
    }
#line 1024
    if ((unsigned int )tmp___0 == 2U) {
#line 1024
      goto case_2;
    }
#line 1017
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1019
    encode_count ++;
#line 1020
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1022
    decode_count ++;
#line 1023
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1025
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1016
    p1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1029
  if (! encode_count) {
#line 1029
    if (! decode_count) {
#line 1030
      return ((char *)s);
    }
  }
  {
#line 1032
  oldlen = (int )(p1 - s);
#line 1035
  newlen = oldlen + 2 * (encode_count - decode_count);
#line 1036
  tmp___1 = xmalloc((size_t )(newlen + 1));
#line 1036
  newstr = (char *)tmp___1;
#line 1038
  p1 = s;
#line 1039
  p2 = newstr;
  }
  {
#line 1041
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1041
    if (! *p1) {
#line 1041
      goto while_break___0;
    }
    {
#line 1042
    tmp___2 = decide_copy_method(p1);
    }
    {
#line 1043
    if ((unsigned int )tmp___2 == 1U) {
#line 1043
      goto case_1___0;
    }
#line 1050
    if ((unsigned int )tmp___2 == 0U) {
#line 1050
      goto case_0___0;
    }
#line 1054
    if ((unsigned int )tmp___2 == 2U) {
#line 1054
      goto case_2___0;
    }
#line 1042
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 1044
    tmp___3 = p1;
#line 1044
    p1 ++;
#line 1044
    c = (unsigned char )*tmp___3;
#line 1045
    tmp___4 = p2;
#line 1045
    p2 ++;
#line 1045
    *tmp___4 = (char )'%';
#line 1046
    tmp___5 = p2;
#line 1046
    p2 ++;
#line 1046
    *tmp___5 = (char )*("0123456789ABCDEF" + ((int )c >> 4));
#line 1047
    tmp___6 = p2;
#line 1047
    p2 ++;
#line 1047
    *tmp___6 = (char )*("0123456789ABCDEF" + ((int )c & 15));
#line 1049
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 1051
    tmp___7 = p2;
#line 1051
    p2 ++;
#line 1051
    if ((int const   )*(p1 + 1) < 65) {
#line 1051
      tmp___9 = (int const   )*(p1 + 1) - 48;
    } else {
      {
#line 1051
      tmp___8 = toupper((int )*(p1 + 1));
#line 1051
      tmp___9 = (int const   )((tmp___8 - 65) + 10);
      }
    }
#line 1051
    if ((int const   )*(p1 + 2) < 65) {
#line 1051
      tmp___11 = (int const   )*(p1 + 2) - 48;
    } else {
      {
#line 1051
      tmp___10 = toupper((int )*(p1 + 2));
#line 1051
      tmp___11 = (int const   )((tmp___10 - 65) + 10);
      }
    }
#line 1051
    *tmp___7 = (char )((tmp___9 << 4) + tmp___11);
#line 1052
    p1 += 3;
#line 1053
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1055
    tmp___12 = p2;
#line 1055
    p2 ++;
#line 1055
    tmp___13 = p1;
#line 1055
    p1 ++;
#line 1055
    *tmp___12 = (char )*tmp___13;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1058
  *p2 = (char )'\000';
#line 1059
  return (newstr);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 179 "/usr/include/netdb.h"
extern int gethostbyname_r(char const   * __restrict  __name , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c"
static int __socket_block(int sock , BOOLEAN block ) ;
#line 64
static ssize_t __socket_write(int sock , void const   *vbuf , size_t len ) ;
#line 65
static BOOLEAN __socket_check(CONN *C , SDSET mode ) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c"
int new_socket(CONN *C , char const   *hostparam , int portparam ) 
{ 
  int conn ;
  int res ;
  int opt ;
  int herrno ;
  struct sockaddr_in cli ;
  struct hostent *hp ;
  char hn[512] ;
  int port ;
  struct hostent hent ;
  char hbf[8192] ;
  char *tmp ;
  BOOLEAN tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  pthread_t tmp___9 ;
  pthread_t tmp___10 ;
  pthread_t tmp___11 ;
  pthread_t tmp___12 ;
  pthread_t tmp___13 ;
  pthread_t tmp___14 ;
  pthread_t tmp___15 ;
  struct timeval timeout ;
  fd_set rs ;
  fd_set ws ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;

  {
#line 98
  if ((unsigned int )C->scheme == 2U) {
#line 98
    C->encrypt = (BOOLEAN )1;
  } else {
#line 98
    C->encrypt = (BOOLEAN )0;
  }
  {
#line 99
  C->state = (SDSET )0;
#line 100
  C->ftp.pasv = (BOOLEAN )1;
#line 101
  C->ftp.size = (size_t )0;
#line 103
  memset((void *)(hn), '\000', sizeof(hn));
#line 107
  tmp___0 = auth_get_proxy_required(my.auth);
  }
#line 107
  if (tmp___0) {
    {
#line 108
    tmp = auth_get_proxy_host(my.auth);
#line 108
    snprintf((char */* __restrict  */)(hn), sizeof(hn), (char const   */* __restrict  */)"%s",
             tmp);
#line 109
    port = auth_get_proxy_port(my.auth);
    }
  } else {
    {
#line 111
    snprintf((char */* __restrict  */)(hn), sizeof(hn), (char const   */* __restrict  */)"%s",
             hostparam);
#line 112
    port = portparam;
    }
  }
  {
#line 116
  tmp___2 = socket(2, 1, 0);
#line 116
  C->sock = tmp___2;
  }
#line 116
  if (tmp___2 < 0) {
    {
#line 117
    tmp___1 = __errno_location();
    }
    {
#line 118
    if (*tmp___1 == 93) {
#line 118
      goto case_93;
    }
#line 119
    if (*tmp___1 == 24) {
#line 119
      goto case_24;
    }
#line 120
    if (*tmp___1 == 23) {
#line 120
      goto case_23;
    }
#line 121
    if (*tmp___1 == 13) {
#line 121
      goto case_13;
    }
#line 122
    if (*tmp___1 == 105) {
#line 122
      goto case_105;
    }
#line 123
    goto switch_default;
    case_93: /* CIL Label */ 
    {
#line 118
    NOTIFY((LEVEL )2, "unsupported protocol %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           118);
    }
#line 118
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 119
    NOTIFY((LEVEL )2, "descriptor table full %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           119);
    }
#line 119
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 120
    NOTIFY((LEVEL )2, "file table full %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           120);
    }
#line 120
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 121
    NOTIFY((LEVEL )2, "permission denied %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           121);
    }
#line 121
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 122
    NOTIFY((LEVEL )2, "insufficient buffer %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           122);
    }
#line 122
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 123
    NOTIFY((LEVEL )2, "unknown socket error %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           123);
    }
#line 123
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 124
    socket_close(C);
    }
#line 124
    return (-1);
  }
  {
#line 126
  tmp___3 = fcntl(C->sock, 2, 2048);
  }
#line 126
  if (tmp___3 < 0) {
    {
#line 127
    NOTIFY((LEVEL )2, "unable to set close control %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           127);
    }
  }
  {
#line 132
  memset((void *)(hbf), '\000', sizeof(hbf));
#line 134
  tmp___4 = gethostbyname_r((char const   */* __restrict  */)hostparam, (struct hostent */* __restrict  */)(& hent),
                            (char */* __restrict  */)(hbf), sizeof(hbf), (struct hostent **/* __restrict  */)(& hp),
                            (int */* __restrict  */)(& herrno));
  }
#line 134
  if (tmp___4 < 0) {
#line 135
    hp = (struct hostent *)((void *)0);
  }
#line 161
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 161
    return (-1);
  }
  {
#line 162
  memset((void *)(& cli), 0, sizeof(cli));
#line 163
  memcpy((void */* __restrict  */)(& cli.sin_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
         (size_t )hp->h_length);
#line 169
  cli.sin_family = (sa_family_t )2;
#line 170
  cli.sin_port = htons((uint16_t )port);
  }
#line 172
  if (C->connection.keepalive) {
    {
#line 173
    opt = 1;
#line 174
    tmp___6 = setsockopt(C->sock, 1, 9, (void const   *)((char *)(& opt)), (socklen_t )sizeof(opt));
    }
#line 174
    if (tmp___6 < 0) {
      {
#line 175
      tmp___5 = __errno_location();
      }
      {
#line 176
      if (*tmp___5 == 9) {
#line 176
        goto case_9;
      }
#line 177
      if (*tmp___5 == 88) {
#line 177
        goto case_88;
      }
#line 178
      if (*tmp___5 == 92) {
#line 178
        goto case_92;
      }
#line 179
      if (*tmp___5 == 14) {
#line 179
        goto case_14;
      }
#line 180
      goto switch_default___0;
      case_9: /* CIL Label */ 
      {
#line 176
      NOTIFY((LEVEL )2, "invalid descriptor %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
             176);
      }
#line 176
      goto switch_break___0;
      case_88: /* CIL Label */ 
      {
#line 177
      NOTIFY((LEVEL )2, "not a socket %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
             177);
      }
#line 177
      goto switch_break___0;
      case_92: /* CIL Label */ 
      {
#line 178
      NOTIFY((LEVEL )2, "not a protocol option %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
             178);
      }
#line 178
      goto switch_break___0;
      case_14: /* CIL Label */ 
      {
#line 179
      NOTIFY((LEVEL )2, "setsockopt unknown %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
             179);
      }
#line 179
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 180
      NOTIFY((LEVEL )2, "unknown sockopt error %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
             180);
      }
#line 180
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 181
      socket_close(C);
      }
#line 181
      return (-1);
    }
  }
  {
#line 185
  tmp___7 = __socket_block(C->sock, (BOOLEAN )0);
  }
#line 185
  if (tmp___7 < 0) {
    {
#line 186
    NOTIFY((LEVEL )2, "socket: unable to set socket to non-blocking %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           186);
    }
#line 187
    return (-1);
  }
  {
#line 195
  conn = connect(C->sock, (struct sockaddr  const  *)((struct sockaddr *)(& cli)),
                 (socklen_t )sizeof(struct sockaddr_in ));
#line 196
  pthread_testcancel();
  }
#line 197
  if (conn < 0) {
    {
#line 197
    tmp___18 = __errno_location();
    }
#line 197
    if (*tmp___18 != 115) {
      {
#line 198
      tmp___8 = __errno_location();
      }
      {
#line 199
      if (*tmp___8 == 13) {
#line 199
        goto case_13___0;
      }
#line 200
      if (*tmp___8 == 99) {
#line 200
        goto case_99;
      }
#line 201
      if (*tmp___8 == 110) {
#line 201
        goto case_110;
      }
#line 202
      if (*tmp___8 == 111) {
#line 202
        goto case_111;
      }
#line 203
      if (*tmp___8 == 101) {
#line 203
        goto case_101;
      }
#line 204
      if (*tmp___8 == 106) {
#line 204
        goto case_106;
      }
#line 205
      goto switch_default___1;
      case_13___0: /* CIL Label */ 
      {
#line 199
      tmp___9 = pthread_self();
#line 199
      NOTIFY((LEVEL )2, "socket: %d EACCES", tmp___9);
      }
#line 199
      goto switch_break___1;
      case_99: /* CIL Label */ 
      {
#line 200
      tmp___10 = pthread_self();
#line 200
      NOTIFY((LEVEL )2, "socket: %d address is unavailable.", tmp___10);
      }
#line 200
      goto switch_break___1;
      case_110: /* CIL Label */ 
      {
#line 201
      tmp___11 = pthread_self();
#line 201
      NOTIFY((LEVEL )2, "socket: %d connection timed out.", tmp___11);
      }
#line 201
      goto switch_break___1;
      case_111: /* CIL Label */ 
      {
#line 202
      tmp___12 = pthread_self();
#line 202
      NOTIFY((LEVEL )2, "socket: %d connection refused.", tmp___12);
      }
#line 202
      goto switch_break___1;
      case_101: /* CIL Label */ 
      {
#line 203
      tmp___13 = pthread_self();
#line 203
      NOTIFY((LEVEL )2, "socket: %d network is unreachable.", tmp___13);
      }
#line 203
      goto switch_break___1;
      case_106: /* CIL Label */ 
      {
#line 204
      tmp___14 = pthread_self();
#line 204
      NOTIFY((LEVEL )2, "socket: %d already connected.", tmp___14);
      }
#line 204
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
      {
#line 205
      tmp___15 = pthread_self();
#line 205
      NOTIFY((LEVEL )2, "socket: %d unknown network error.", tmp___15);
      }
#line 205
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 206
      socket_close(C);
      }
#line 206
      return (-1);
    } else {
#line 197
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 211
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rs.__fds_bits[0]): "memory");
#line 211
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 212
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 212
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ws.__fds_bits[0]): "memory");
#line 212
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 213
    rs.__fds_bits[C->sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << C->sock % (8 * (int )sizeof(__fd_mask ));
#line 214
    ws.__fds_bits[C->sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << C->sock % (8 * (int )sizeof(__fd_mask ));
#line 215
    memset((void *)(& timeout), '\000', sizeof(struct timeval ));
    }
#line 216
    if (my.timeout > 0) {
#line 216
      timeout.tv_sec = (__time_t )my.timeout;
    } else {
#line 216
      timeout.tv_sec = (__time_t )30;
    }
    {
#line 217
    timeout.tv_usec = (__suseconds_t )0;
#line 218
    res = select(C->sock + 1, (fd_set */* __restrict  */)(& rs), (fd_set */* __restrict  */)(& ws),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
    }
#line 219
    if (res == -1) {
      {
#line 219
      tmp___17 = __errno_location();
      }
#line 219
      if (*tmp___17 == 4) {
        {
#line 220
        pthread_testcancel();
#line 221
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"socket: connection timed out\n");
#line 222
        socket_close(C);
        }
#line 223
        return (-1);
      } else {
#line 219
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 228
      res = connect(C->sock, (struct sockaddr  const  *)((struct sockaddr *)(& cli)),
                    (socklen_t )sizeof(struct sockaddr_in ));
      }
#line 229
      if (res < 0) {
        {
#line 229
        tmp___16 = __errno_location();
        }
#line 229
        if (*tmp___16 != 106) {
          {
#line 230
          NOTIFY((LEVEL )2, "socket: unable to connect %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
                 230);
#line 231
          socket_close(C);
          }
#line 232
          return (-1);
        }
      }
#line 234
      C->status = (S_STATUS )2;
    }
  }
  {
#line 238
  tmp___19 = __socket_block(C->sock, (BOOLEAN )1);
  }
#line 238
  if (tmp___19 < 0) {
    {
#line 239
    NOTIFY((LEVEL )2, "socket: unable to set socket to non-blocking %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           239);
    }
#line 240
    return (-1);
  }
#line 243
  C->connection.status = 1;
#line 244
  return (C->sock);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c"
static BOOLEAN __socket_check(CONN *C , SDSET mode ) 
{ 
  int res ;
  fd_set fds ;
  fd_set *rs ;
  fd_set *ws ;
  double timo ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int *tmp___0 ;
  pthread_t tmp___1 ;

  {
#line 252
  rs = (fd_set *)((void *)0);
#line 253
  ws = (fd_set *)((void *)0);
#line 257
  if ((unsigned int )C->state == (unsigned int )mode) {
#line 258
    return ((BOOLEAN )1);
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
#line 261
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  fds.__fds_bits[C->sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << C->sock % (8 * (int )sizeof(__fd_mask ));
#line 263
  if ((unsigned int )mode == 2U) {
#line 264
    ws = & fds;
  } else {
#line 266
    rs = & fds;
  }
#line 269
  if (my.timeout) {
#line 269
    timo = (double )my.timeout;
  } else {
#line 269
    timo = (double )15;
  }
#line 270
  timeout.tv_sec = (long )timo;
#line 271
  timeout.tv_usec = (__suseconds_t )((double )1000000L * (timo - (double )((long )timo)));
#line 273
  if ((unsigned int )mode == 2U) {
    {
#line 274
    __socket_block(C->sock, (BOOLEAN )0);
    }
  }
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 278
    res = select(C->sock + 1, (fd_set */* __restrict  */)rs, (fd_set */* __restrict  */)ws,
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
#line 279
    pthread_testcancel();
    }
#line 277
    if (res < 0) {
      {
#line 277
      tmp = __errno_location();
      }
#line 277
      if (! (*tmp == 4)) {
#line 277
        goto while_break___0;
      }
    } else {
#line 277
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 282
  if ((unsigned int )mode == 2U) {
    {
#line 283
    __socket_block(C->sock, (BOOLEAN )1);
    }
  }
#line 286
  if (res == 0) {
    {
#line 287
    tmp___0 = __errno_location();
#line 287
    *tmp___0 = 110;
    }
  }
#line 290
  if (res < 1) {
    {
#line 291
    tmp___1 = pthread_self();
#line 291
    NOTIFY((LEVEL )1, "socket: %d select timed out", tmp___1);
    }
  }
#line 294
  if (res <= 0) {
#line 295
    C->state = (SDSET )0;
#line 296
    return ((BOOLEAN )0);
  } else {
#line 298
    C->state = mode;
#line 299
    return ((BOOLEAN )1);
  }
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c"
static int __socket_block(int sock , BOOLEAN block ) 
{ 
  int flags ;
  int retval ;
  int *tmp ;

  {
#line 319
  return (sock);
#line 320
  if (sock == -1) {
#line 321
    return (sock);
  }
  {
#line 325
  flags = fcntl(sock, 3, 0);
  }
#line 325
  if (flags < 0) {
    {
#line 326
    tmp = __errno_location();
    }
    {
#line 327
    if (*tmp == 13) {
#line 327
      goto case_13;
    }
#line 328
    if (*tmp == 9) {
#line 328
      goto case_9;
    }
#line 329
    if (*tmp == 11) {
#line 329
      goto case_11;
    }
#line 330
    goto switch_default;
    case_13: /* CIL Label */ 
    {
#line 327
    NOTIFY((LEVEL )2, "EACCES %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           327);
    }
#line 327
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 328
    NOTIFY((LEVEL )2, "bad file descriptor %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           328);
    }
#line 328
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 329
    NOTIFY((LEVEL )2, "address is unavailable %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           329);
    }
#line 329
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 330
    NOTIFY((LEVEL )2, "unknown network error %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           330);
    }
#line 330
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 331
    return (-1);
  }
#line 334
  if (block) {
#line 335
    flags &= -2049;
  } else {
#line 337
    flags |= 2048;
#line 340
    flags |= 2048;
  }
  {
#line 344
  retval = fcntl(sock, 4, flags);
  }
#line 344
  if (retval < 0) {
    {
#line 345
    NOTIFY((LEVEL )2, "unable to set fcntl flags %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           345);
    }
#line 346
    return (-1);
  }
#line 348
  return (retval);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c"
static ssize_t __socket_write(int sock , void const   *vbuf , size_t len ) 
{ 
  size_t n ;
  ssize_t w ;
  char const   *buf ;
  int *tmp ;

  {
#line 367
  buf = (char const   *)vbuf;
#line 368
  n = len;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (n > 0UL)) {
#line 369
      goto while_break;
    }
    {
#line 370
    w = write(sock, (void const   *)buf, n);
    }
#line 370
    if (w <= 0L) {
      {
#line 371
      tmp = __errno_location();
      }
#line 371
      if (*tmp == 4) {
#line 372
        w = (ssize_t )0;
      } else {
#line 374
        return ((ssize_t )-1);
      }
    }
#line 377
    n -= (size_t )w;
#line 378
    buf += w;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return ((ssize_t )len);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c"
ssize_t socket_read(CONN *C , void *vbuf , size_t len ) 
{ 
  int type ;
  size_t n ;
  ssize_t r ;
  char *buf ;
  int ret_eof ;
  BOOLEAN tmp ;
  int lidos ;
  BOOLEAN tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 433
  ret_eof = 0;
#line 435
  pthread_setcanceltype(0, & type);
#line 437
  buf = (char *)vbuf;
#line 438
  n = len;
  }
#line 439
  if (! ((unsigned int )C->encrypt == 1U)) {
    {
#line 457
    while (1) {
      while_continue: /* CIL Label */ ;
#line 457
      if (! (n > 0UL)) {
#line 457
        goto while_break;
      }
#line 458
      if (C->inbuffer < len) {
        {
#line 459
        tmp = __socket_check(C, (SDSET )1);
        }
#line 459
        if ((unsigned int )tmp == 0U) {
#line 460
          return ((ssize_t )-1);
        }
      }
#line 463
      if (C->inbuffer < n) {
        {
#line 465
        memmove((void *)(C->buffer), (void const   *)(& C->buffer[C->pos_ini]), C->inbuffer);
#line 466
        C->pos_ini = 0;
#line 467
        tmp___0 = __socket_check(C, (SDSET )1);
        }
#line 467
        if ((unsigned int )tmp___0 == 0U) {
#line 468
          return ((ssize_t )-1);
        }
        {
#line 470
        tmp___1 = read(C->sock, (void *)(& C->buffer[C->inbuffer]), sizeof(C->buffer) - C->inbuffer);
#line 470
        lidos = (int )tmp___1;
        }
#line 471
        if (lidos == 0) {
#line 472
          ret_eof = 1;
        }
#line 473
        if (lidos < 0) {
          {
#line 474
          tmp___2 = __errno_location();
          }
#line 474
          if (*tmp___2 == 4) {
#line 475
            lidos = 0;
          } else {
            {
#line 474
            tmp___3 = __errno_location();
            }
#line 474
            if (*tmp___3 == 11) {
#line 475
              lidos = 0;
            }
          }
          {
#line 476
          tmp___6 = __errno_location();
          }
#line 476
          if (*tmp___6 == 32) {
#line 477
            return ((ssize_t )0);
          } else {
            {
#line 479
            tmp___4 = __errno_location();
#line 479
            tmp___5 = strerror(*tmp___4);
#line 479
            NOTIFY((LEVEL )2, "socket: read error %s %s:%d", tmp___5, "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
                   479);
            }
#line 480
            return ((ssize_t )0);
          }
        }
#line 483
        C->inbuffer += (size_t )lidos;
      }
#line 485
      if (C->inbuffer >= n) {
#line 486
        r = (ssize_t )n;
      } else {
#line 488
        r = (ssize_t )C->inbuffer;
      }
#line 490
      if (r == 0L) {
#line 490
        goto while_break;
      }
      {
#line 491
      memmove((void *)buf, (void const   *)(& C->buffer[C->pos_ini]), (size_t )r);
#line 492
      C->pos_ini = (int )((ssize_t )C->pos_ini + r);
#line 493
      C->inbuffer -= (size_t )r;
#line 494
      n -= (size_t )r;
#line 495
      buf += r;
      }
#line 496
      if (ret_eof) {
#line 496
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 500
  pthread_setcanceltype(type, (int *)((void *)0));
#line 501
  pthread_testcancel();
  }
#line 502
  return ((ssize_t )(len - n));
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c"
ssize_t socket_readline(CONN *C , char *ptr , size_t maxlen ) 
{ 
  int type ;
  int n ;
  int len ;
  int res ;
  char c ;
  char *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 516
  len = (int )maxlen;
#line 517
  pthread_setcanceltype(0, & type);
#line 519
  n = 1;
  }
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (! (n < len)) {
#line 519
      goto while_break;
    }
    {
#line 520
    tmp___0 = socket_read(C, (void *)(& c), (size_t )1);
#line 520
    res = (int )tmp___0;
    }
#line 520
    if (res == 1) {
#line 521
      tmp = ptr;
#line 521
      ptr ++;
#line 521
      *tmp = c;
#line 522
      if ((int )c == 10) {
#line 522
        goto while_break;
      }
    } else
#line 524
    if (res == 0) {
#line 525
      if (n == 1) {
#line 526
        return ((ssize_t )0);
      } else {
#line 528
        goto while_break;
      }
    } else {
#line 530
      return ((ssize_t )-1);
    }
#line 519
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 534
  *ptr = (char)0;
#line 536
  pthread_setcanceltype(type, (int *)((void *)0));
#line 537
  pthread_testcancel();
  }
#line 539
  return ((ssize_t )n);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c"
int socket_write(CONN *C , void const   *buf , size_t len ) 
{ 
  int type ;
  size_t bytes ;
  ssize_t tmp ;

  {
  {
#line 552
  pthread_setcanceltype(0, & type);
  }
#line 558
  if ((unsigned int )C->encrypt == 1U) {
    {
#line 575
    NOTIFY((LEVEL )2, "%s:%d protocol NOT supported", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
           575);
    }
#line 576
    return (-1);
  } else {
    {
#line 580
    tmp = __socket_write(C->sock, buf, len);
#line 580
    bytes = (size_t )tmp;
    }
#line 580
    if (bytes != len) {
      {
#line 581
      NOTIFY((LEVEL )2, "unable to write to socket %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
             581);
      }
#line 582
      return (-1);
    }
  }
  {
#line 586
  pthread_setcanceltype(type, (int *)((void *)0));
#line 587
  pthread_testcancel();
  }
#line 589
  return ((int )bytes);
}
}
#line 597 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c"
void socket_close(CONN *C ) 
{ 
  int type ;
  int ret ;
  int tmp ;

  {
#line 601
  ret = 0;
#line 606
  if ((unsigned long )C == (unsigned long )((void *)0)) {
#line 606
    return;
  }
  {
#line 609
  pthread_setcanceltype(0, & type);
  }
#line 611
  if (! ((unsigned int )C->encrypt == 1U)) {
#line 633
    if (C->connection.reuse == 0) {
#line 633
      goto _L;
    } else
#line 633
    if (C->connection.max == 1) {
      _L: /* CIL Label */ 
#line 634
      if (C->sock != -1) {
        {
#line 635
        tmp = __socket_block(C->sock, (BOOLEAN )0);
        }
#line 635
        if (tmp < 0) {
          {
#line 636
          NOTIFY((LEVEL )2, "unable to set to non-blocking %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
                 636);
          }
        }
#line 637
        if (C->connection.status > 1) {
          {
#line 637
          ret = shutdown(C->sock, 2);
          }
#line 637
          if (ret < 0) {
            {
#line 638
            NOTIFY((LEVEL )2, "unable to shutdown the socket %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
                   638);
            }
          }
        }
        {
#line 639
        ret = close(C->sock);
        }
#line 639
        if (ret < 0) {
          {
#line 640
          NOTIFY((LEVEL )2, "unable to close the socket %s:%d", "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/sock.c",
                 640);
          }
        }
      }
#line 642
      C->sock = -1;
#line 643
      C->connection.status = 0;
#line 644
      C->connection.max = 0;
#line 645
      C->connection.tested = 0;
    }
  }
  {
#line 648
  C = (CONN *)((void *)0);
#line 649
  pthread_setcanceltype(type, (int *)((void *)0));
#line 650
  pthread_testcancel();
  }
#line 652
  return;
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 36 "./hash.h"
char *hash_get(HASH this , char *key ) ;
#line 38
BOOLEAN hash_lookup(HASH this , char *key ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/eval.c"
char *evaluate(HASH hash_table , char *buf ) 
{ 
  int x ;
  int ENV ;
  int len ;
  char final[40000] ;
  char *ptr ;
  char *string ;
  char const   *scan ;
  char *result ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  BOOLEAN tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 37
  x = 0;
#line 38
  ENV = 0;
#line 39
  len = 0;
#line 45
  tmp = xrealloc((void *)buf, 40000UL * sizeof(char ));
#line 45
  result = (char *)tmp;
  }
#line 46
  if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 47
    buf = result;
  }
  {
#line 49
  tmp___0 = strchr((char const   *)buf, '$');
#line 49
  scan = (char const   *)(tmp___0 + 1);
#line 50
  tmp___1 = strlen((char const   *)buf);
#line 50
  tmp___2 = strlen(scan);
#line 50
  len = (int )((tmp___1 - tmp___2) - 1UL);
  }
#line 52
  if ((int const   )*(scan + 0) == 123) {
#line 53
    scan ++;
  } else
#line 52
  if ((int const   )*(scan + 0) == 40) {
#line 53
    scan ++;
  }
#line 55
  ptr = (char *)scan;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (*scan) {
#line 57
      if ((int const   )*scan != 125) {
#line 57
        if ((int const   )*scan != 41) {
#line 57
          if (! ((int const   )*scan != 47)) {
#line 57
            goto while_break;
          }
        } else {
#line 57
          goto while_break;
        }
      } else {
#line 57
        goto while_break;
      }
    } else {
#line 57
      goto while_break;
    }
#line 58
    scan ++;
#line 59
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if ((int const   )*(scan + 0) == 125) {
#line 63
    scan ++;
  } else
#line 62
  if ((int const   )*(scan + 0) == 41) {
#line 63
    scan ++;
  }
  {
#line 65
  string = substring(ptr, 0, x);
#line 66
  tmp___4 = hash_lookup(hash_table, string);
  }
#line 66
  if ((unsigned int )tmp___4 == 0U) {
    {
#line 67
    tmp___3 = getenv((char const   *)string);
    }
#line 67
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 68
      ENV = 1;
    } else {
#line 70
      string = (char *)'\000';
    }
  }
  {
#line 74
  memset((void *)(final), 0, sizeof(final));
#line 75
  strncpy((char */* __restrict  */)(final), (char const   */* __restrict  */)buf,
          (size_t )len);
  }
#line 76
  if ((unsigned long )string != (unsigned long )((void *)0)) {
#line 77
    if (ENV == 0) {
      {
#line 77
      tmp___5 = hash_get(hash_table, string);
#line 77
      tmp___7 = tmp___5;
      }
    } else {
      {
#line 77
      tmp___6 = getenv((char const   *)string);
#line 77
      tmp___7 = tmp___6;
      }
    }
    {
#line 77
    strcat((char */* __restrict  */)(final), (char const   */* __restrict  */)tmp___7);
    }
  }
  {
#line 78
  strcat((char */* __restrict  */)(final), (char const   */* __restrict  */)scan);
#line 79
  memset((void *)result, 0, 40000UL * sizeof(char ));
#line 80
  tmp___8 = strlen((char const   *)(final));
#line 80
  strncpy((char */* __restrict  */)result, (char const   */* __restrict  */)(final),
          tmp___8);
#line 82
  xfree((void *)string);
  }
#line 83
  return (result);
}
}
#line 26 "./init.h"
int init_config(void) ;
#line 27
int show_config(int EXIT ) ;
#line 28
int load_conf(char *filename ) ;
#line 29
void ds_module_check(void) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/init.c"
int init_config(void) 
{ 
  char *e ;
  int res ;
  struct stat buf ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 48
  tmp___2 = strcmp((char const   *)(my.rc), "");
  }
#line 48
  if (tmp___2 == 0) {
    {
#line 49
    e = getenv("SIEGERC");
    }
#line 49
    if ((unsigned long )e != (unsigned long )((void *)0)) {
      {
#line 50
      snprintf((char */* __restrict  */)(my.rc), sizeof(my.rc), (char const   */* __restrict  */)"%s",
               e);
      }
    } else {
      {
#line 52
      tmp = getenv("HOME");
#line 52
      snprintf((char */* __restrict  */)(my.rc), sizeof(my.rc), (char const   */* __restrict  */)"%s/.siegerc",
               tmp);
#line 53
      tmp___0 = stat((char const   */* __restrict  */)(my.rc), (struct stat */* __restrict  */)(& buf));
      }
#line 53
      if (tmp___0 < 0) {
        {
#line 53
        tmp___1 = __errno_location();
        }
#line 53
        if (*tmp___1 == 2) {
          {
#line 54
          snprintf((char */* __restrict  */)(my.rc), sizeof(my.rc), (char const   */* __restrict  */)"/usr/local/etc/siegerc");
          }
        }
      }
    }
  }
  {
#line 59
  my.debug = (BOOLEAN )0;
#line 60
  my.quiet = (BOOLEAN )0;
#line 61
  my.internet = (BOOLEAN )0;
#line 62
  my.config = (BOOLEAN )0;
#line 63
  my.cookies = (BOOLEAN )1;
#line 64
  my.csv = (BOOLEAN )0;
#line 65
  my.fullurl = (BOOLEAN )0;
#line 66
  my.escape = (BOOLEAN )1;
#line 67
  my.secs = -1;
#line 68
  my.reps = 10301062;
#line 69
  my.bids = 5;
#line 70
  my.login = (BOOLEAN )0;
#line 71
  my.failures = 1024;
#line 72
  my.failed = 0;
#line 73
  my.auth = new_auth();
#line 74
  auth_set_proxy_required(my.auth, (BOOLEAN )0);
#line 75
  auth_set_proxy_port(my.auth, 3128);
#line 76
  my.timeout = 30;
#line 77
  my.timestamp = (BOOLEAN )0;
#line 78
  my.chunked = (BOOLEAN )0;
#line 79
  my.unique = (BOOLEAN )1;
#line 80
  my.extra[0] = (char)0;
#line 81
  my.follow = (BOOLEAN )1;
#line 82
  my.zero_ok = (BOOLEAN )1;
#line 83
  my.signaled = 0;
#line 84
  my.ssl_timeout = 300;
#line 85
  my.ssl_cert = (char *)((void *)0);
#line 86
  my.ssl_key = (char *)((void *)0);
#line 87
  my.ssl_ciphers = (char *)((void *)0);
#line 88
  my.lurl = new_array();
#line 90
  res = pthread_mutex_init(& my.lock, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 90
  if (res != 0) {
    {
#line 91
    NOTIFY((LEVEL )3, "unable to initiate lock");
    }
  }
  {
#line 92
  res = pthread_cond_init((pthread_cond_t */* __restrict  */)(& my.cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
  }
#line 92
  if (res != 0) {
    {
#line 93
    NOTIFY((LEVEL )3, "unable to initiate condition");
    }
  }
  {
#line 95
  tmp___3 = load_conf(my.rc);
  }
#line 95
  if (tmp___3 < 0) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"****************************************************\n");
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"siege: could not open %s\n",
            my.rc);
#line 98
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"run \'siege.config\' to generate a new .siegerc file\n");
#line 99
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"****************************************************\n");
    }
#line 100
    return (-1);
  }
  {
#line 103
  tmp___4 = strlen((char const   *)(my.file));
  }
#line 103
  if (tmp___4 < 1UL) {
    {
#line 104
    snprintf((char */* __restrict  */)(my.file), sizeof(my.file), (char const   */* __restrict  */)"%s",
             "/usr/local/etc/urls.txt");
    }
  }
  {
#line 110
  tmp___5 = strlen((char const   *)(my.uagent));
  }
#line 110
  if (tmp___5 < 1UL) {
    {
#line 111
    snprintf((char */* __restrict  */)(my.uagent), sizeof(my.uagent), (char const   */* __restrict  */)"Mozilla/5.0 (%s) Siege/%s",
             "unknown-x86_64-linux-gnu", version_string);
    }
  }
  {
#line 116
  tmp___6 = strlen((char const   *)(my.conttype));
  }
#line 116
  if (tmp___6 < 1UL) {
    {
#line 117
    snprintf((char */* __restrict  */)(my.conttype), sizeof(my.conttype), (char const   */* __restrict  */)"application/x-www-form-urlencoded");
    }
  }
  {
#line 122
  tmp___7 = strlen((char const   *)(my.encoding));
  }
#line 122
  if (tmp___7 < 1UL) {
    {
#line 123
    snprintf((char */* __restrict  */)(my.encoding), sizeof(my.encoding), (char const   */* __restrict  */)"*");
    }
  }
  {
#line 127
  tmp___8 = strlen((char const   *)(my.logfile));
  }
#line 127
  if (tmp___8 < 1UL) {
    {
#line 128
    snprintf((char */* __restrict  */)(my.logfile), sizeof(my.logfile), (char const   */* __restrict  */)"%s",
             "/usr/local/var/siege.log");
    }
  }
#line 132
  return (0);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/init.c"
int show_config(int EXIT ) 
{ 
  char *method ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  BOOLEAN tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char const   *tmp___14 ;
  size_t tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;

  {
  {
#line 140
  if ((unsigned int )my.method == 2U) {
#line 140
    goto case_2;
  }
#line 144
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 141
  method = strdup("GET");
  }
#line 142
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 145
  method = strdup("HEAD");
  }
#line 146
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 149
  printf((char const   */* __restrict  */)"CURRENT  SIEGE  CONFIGURATION\n");
#line 150
  printf((char const   */* __restrict  */)"%s\n", my.uagent);
#line 151
  printf((char const   */* __restrict  */)"Edit the resource file to change the settings.\n");
#line 152
  printf((char const   */* __restrict  */)"----------------------------------------------\n");
#line 153
  printf((char const   */* __restrict  */)"version:                        %s\n",
         version_string);
  }
#line 154
  if (my.verbose) {
#line 154
    tmp = "true";
  } else {
#line 154
    tmp = "false";
  }
  {
#line 154
  printf((char const   */* __restrict  */)"verbose:                        %s\n",
         tmp);
  }
#line 155
  if (my.quiet) {
#line 155
    tmp___0 = "true";
  } else {
#line 155
    tmp___0 = "false";
  }
  {
#line 155
  printf((char const   */* __restrict  */)"quiet:                          %s\n",
         tmp___0);
  }
#line 156
  if (my.debug) {
#line 156
    tmp___1 = "true";
  } else {
#line 156
    tmp___1 = "false";
  }
  {
#line 156
  printf((char const   */* __restrict  */)"debug:                          %s\n",
         tmp___1);
  }
#line 157
  if (my.protocol) {
#line 157
    tmp___2 = "HTTP/1.1";
  } else {
#line 157
    tmp___2 = "HTTP/1.0";
  }
  {
#line 157
  printf((char const   */* __restrict  */)"protocol:                       %s\n",
         tmp___2);
#line 158
  printf((char const   */* __restrict  */)"get method:                     %s\n",
         method);
#line 159
  tmp___5 = auth_get_proxy_required(my.auth);
  }
#line 159
  if (tmp___5) {
    {
#line 160
    tmp___3 = auth_get_proxy_host(my.auth);
#line 160
    printf((char const   */* __restrict  */)"proxy-host:                     %s\n",
           tmp___3);
#line 161
    tmp___4 = auth_get_proxy_port(my.auth);
#line 161
    printf((char const   */* __restrict  */)"proxy-port:                     %d\n",
           tmp___4);
    }
  }
#line 163
  if (my.keepalive) {
#line 163
    tmp___6 = "keep-alive";
  } else {
#line 163
    tmp___6 = "close";
  }
  {
#line 163
  printf((char const   */* __restrict  */)"connection:                     %s\n",
         tmp___6);
#line 164
  printf((char const   */* __restrict  */)"concurrent users:               %d\n",
         my.cusers);
  }
#line 165
  if (my.secs > 0) {
    {
#line 166
    printf((char const   */* __restrict  */)"time to run:                    %d seconds\n",
           my.secs);
    }
  } else {
    {
#line 168
    printf((char const   */* __restrict  */)"time to run:                    n/a\n");
    }
  }
#line 169
  if (my.reps > 0) {
#line 169
    if (my.reps != 10301062) {
      {
#line 170
      printf((char const   */* __restrict  */)"repetitions:                    %d\n",
             my.reps);
      }
    } else {
      {
#line 172
      printf((char const   */* __restrict  */)"repetitions:                    n/a\n");
      }
    }
  } else {
    {
#line 172
    printf((char const   */* __restrict  */)"repetitions:                    n/a\n");
    }
  }
  {
#line 173
  printf((char const   */* __restrict  */)"socket timeout:                 %d\n",
         my.timeout);
#line 174
  printf((char const   */* __restrict  */)"accept-encoding:                %s\n",
         my.encoding);
  }
#line 175
  if (my.delay > 1) {
#line 175
    tmp___7 = "s";
  } else {
#line 175
    tmp___7 = "";
  }
  {
#line 175
  printf((char const   */* __restrict  */)"delay:                          %d sec%s\n",
         my.delay, tmp___7);
  }
#line 176
  if (my.internet) {
#line 176
    tmp___8 = "true";
  } else {
#line 176
    tmp___8 = "false";
  }
  {
#line 176
  printf((char const   */* __restrict  */)"internet simulation:            %s\n",
         tmp___8);
  }
#line 177
  if (my.bench) {
#line 177
    tmp___9 = "true";
  } else {
#line 177
    tmp___9 = "false";
  }
  {
#line 177
  printf((char const   */* __restrict  */)"benchmark mode:                 %s\n",
         tmp___9);
#line 178
  printf((char const   */* __restrict  */)"failures until abort:           %d\n",
         my.failures);
  }
#line 179
  if ((unsigned long )my.url == (unsigned long )((void *)0)) {
#line 179
    tmp___11 = "none";
  } else {
    {
#line 179
    tmp___12 = strlen((char const   *)my.url);
    }
#line 179
    if (tmp___12 < 2UL) {
#line 179
      tmp___11 = "none";
    } else {
#line 179
      tmp___11 = (char const   *)my.url;
    }
  }
  {
#line 179
  printf((char const   */* __restrict  */)"named URL:                      %s\n",
         tmp___11);
#line 180
  tmp___15 = strlen((char const   *)(my.file));
  }
#line 180
  if (tmp___15 > 1UL) {
#line 180
    tmp___14 = (char const   *)(my.file);
  } else {
#line 180
    tmp___14 = "/usr/local/etc/urls.txt";
  }
  {
#line 180
  printf((char const   */* __restrict  */)"URLs file:                      %s\n",
         tmp___14);
  }
#line 181
  if (my.logging) {
#line 181
    tmp___16 = "true";
  } else {
#line 181
    tmp___16 = "false";
  }
  {
#line 181
  printf((char const   */* __restrict  */)"logging:                        %s\n",
         tmp___16);
  }
#line 182
  if ((unsigned long )(my.logfile) == (unsigned long )((void *)0)) {
#line 182
    tmp___17 = "/usr/local/var/siege.log";
  } else {
#line 182
    tmp___17 = (char const   *)(my.logfile);
  }
  {
#line 182
  printf((char const   */* __restrict  */)"log file:                       %s\n",
         tmp___17);
#line 183
  printf((char const   */* __restrict  */)"resource file:                  %s\n",
         my.rc);
  }
#line 184
  if (my.timestamp) {
#line 184
    tmp___18 = "true";
  } else {
#line 184
    tmp___18 = "false";
  }
  {
#line 184
  printf((char const   */* __restrict  */)"timestamped output:             %s\n",
         tmp___18);
  }
#line 185
  if (my.csv) {
#line 185
    tmp___19 = "true";
  } else {
#line 185
    tmp___19 = "false";
  }
  {
#line 185
  printf((char const   */* __restrict  */)"comma separated output:         %s\n",
         tmp___19);
  }
#line 186
  if (my.follow) {
#line 186
    tmp___20 = "true";
  } else {
#line 186
    tmp___20 = "false";
  }
  {
#line 186
  printf((char const   */* __restrict  */)"allow redirects:                %s\n",
         tmp___20);
  }
#line 187
  if (my.zero_ok) {
#line 187
    tmp___21 = "true";
  } else {
#line 187
    tmp___21 = "false";
  }
  {
#line 187
  printf((char const   */* __restrict  */)"allow zero byte data:           %s\n",
         tmp___21);
  }
#line 188
  if (my.chunked) {
#line 188
    tmp___22 = "true";
  } else {
#line 188
    tmp___22 = "false";
  }
  {
#line 188
  printf((char const   */* __restrict  */)"allow chunked encoding:         %s\n",
         tmp___22);
  }
#line 189
  if (my.unique) {
#line 189
    tmp___23 = "true";
  } else {
#line 189
    tmp___23 = "false";
  }
  {
#line 189
  printf((char const   */* __restrict  */)"upload unique files:            %s\n",
         tmp___23);
#line 192
  printf((char const   */* __restrict  */)"\n");
#line 193
  xfree((void *)method);
  }
#line 194
  if (EXIT) {
    {
#line 194
    exit(0);
    }
  } else {
#line 195
    return (0);
  }
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/init.c"
static char *get_line(FILE *fp ) 
{ 
  char *ptr ;
  char *newline ;
  char tmp[256] ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 201
  ptr = (char *)((void *)0);
#line 205
  memset((void *)(tmp), 0, sizeof(tmp));
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 207
    tmp___0 = fgets((char */* __restrict  */)(tmp), (int )sizeof(tmp), (FILE */* __restrict  */)fp);
    }
#line 207
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 207
      return ((char *)((void *)0));
    }
#line 208
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
      {
#line 209
      ptr = xstrdup((char const   *)(tmp));
      }
    } else {
      {
#line 211
      tmp___1 = strlen((char const   *)ptr);
#line 211
      tmp___2 = strlen((char const   *)(tmp));
#line 211
      tmp___3 = xrealloc((void *)ptr, (tmp___1 + tmp___2) + 1UL);
#line 211
      ptr = (char *)tmp___3;
#line 212
      strcat((char */* __restrict  */)ptr, (char const   */* __restrict  */)(tmp));
      }
    }
    {
#line 214
    newline = strchr((char const   *)ptr, '\n');
    }
#line 206
    if (! ((unsigned long )newline == (unsigned long )((void *)0))) {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  *newline = (char )'\000';
#line 218
  return (ptr);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/init.c"
static char *chomp_line(FILE *fp , char **mystr , int *line_num ) 
{ 
  char *ptr ;
  char *tmp ;

  {
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    tmp = get_line(fp);
#line 226
    *mystr = tmp;
    }
#line 226
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 226
      return ((char *)((void *)0));
    }
    {
#line 227
    (*line_num) ++;
#line 228
    ptr = chomp(*mystr);
    }
#line 230
    if ((int )*ptr != 35) {
#line 230
      if ((int )*ptr != 0) {
#line 231
        return (ptr);
      } else {
        {
#line 233
        xfree((void *)ptr);
        }
      }
    } else {
      {
#line 233
      xfree((void *)ptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/init.c"
int load_conf(char *filename ) 
{ 
  FILE *fp ;
  HASH H ;
  int line_num ;
  char *line ;
  char *tmp ;
  char *option ;
  char *optionptr ;
  char *value ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  BOOLEAN tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  BOOLEAN tmp___18 ;
  CREDS tmp___19 ;
  BOOLEAN tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  CREDS tmp___27 ;
  CREDS tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  BOOLEAN tmp___39 ;
  BOOLEAN tmp___40 ;
  BOOLEAN tmp___41 ;
  BOOLEAN tmp___42 ;
  BOOLEAN tmp___43 ;
  BOOLEAN tmp___44 ;
  BOOLEAN tmp___45 ;
  BOOLEAN tmp___46 ;
  BOOLEAN tmp___47 ;
  BOOLEAN tmp___48 ;
  BOOLEAN tmp___49 ;
  BOOLEAN tmp___50 ;
  BOOLEAN tmp___51 ;
  BOOLEAN tmp___52 ;
  BOOLEAN tmp___53 ;
  BOOLEAN tmp___54 ;
  BOOLEAN tmp___55 ;
  BOOLEAN tmp___56 ;
  BOOLEAN tmp___57 ;
  BOOLEAN tmp___58 ;
  BOOLEAN tmp___59 ;
  BOOLEAN tmp___60 ;
  int tmp___61 ;
  BOOLEAN tmp___62 ;
  BOOLEAN tmp___63 ;
  BOOLEAN tmp___64 ;
  BOOLEAN tmp___65 ;
  BOOLEAN tmp___66 ;
  BOOLEAN tmp___67 ;
  BOOLEAN tmp___68 ;
  BOOLEAN tmp___69 ;
  BOOLEAN tmp___70 ;
  BOOLEAN tmp___71 ;
  BOOLEAN tmp___72 ;
  BOOLEAN tmp___73 ;
  BOOLEAN tmp___74 ;
  BOOLEAN tmp___75 ;
  BOOLEAN tmp___76 ;
  BOOLEAN tmp___77 ;
  BOOLEAN tmp___78 ;
  BOOLEAN tmp___79 ;
  BOOLEAN tmp___80 ;
  BOOLEAN tmp___81 ;
  BOOLEAN tmp___82 ;
  BOOLEAN tmp___83 ;
  BOOLEAN tmp___84 ;
  BOOLEAN tmp___85 ;

  {
  {
#line 243
  line_num = 0;
#line 250
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 250
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 251
    return (-1);
  }
  {
#line 254
  H = new_hash();
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 256
    line = chomp_line(fp, & line, & line_num);
    }
#line 256
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 256
      goto while_break;
    }
    {
#line 257
    tmp = trim(line);
#line 258
    option = xstrdup((char const   *)line);
#line 258
    optionptr = option;
    }
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 259
      if (*optionptr) {
        {
#line 259
        tmp___0 = __ctype_b_loc();
        }
#line 259
        if ((int const   )*(*tmp___0 + (int )((unsigned char )((int )*optionptr))) & 8192) {
#line 259
          goto while_break___0;
        } else
#line 259
        if (61 == (int )*optionptr) {
#line 259
          goto while_break___0;
        } else
#line 259
        if (58 == (int )*optionptr) {
#line 259
          goto while_break___0;
        }
      } else {
#line 259
        goto while_break___0;
      }
#line 260
      optionptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    tmp___1 = optionptr;
#line 262
    optionptr ++;
#line 262
    *tmp___1 = (char)0;
    {
#line 263
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 263
      tmp___2 = __ctype_b_loc();
      }
#line 263
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )((int )*optionptr))) & 8192)) {
#line 263
        if (! (61 == (int )*optionptr)) {
#line 263
          if (! (58 == (int )*optionptr)) {
#line 263
            goto while_break___1;
          }
        }
      }
#line 264
      optionptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 266
    value = xstrdup((char const   *)optionptr);
    }
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! *line) {
#line 267
        goto while_break___2;
      }
#line 268
      line ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 269
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 269
      tmp___3 = strstr((char const   *)option, "$");
      }
#line 269
      if (! tmp___3) {
#line 269
        goto while_break___3;
      }
      {
#line 270
      option = evaluate(H, option);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 272
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 272
      tmp___4 = strstr((char const   *)value, "$");
      }
#line 272
      if (! tmp___4) {
#line 272
        goto while_break___4;
      }
      {
#line 273
      value = evaluate(H, value);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 275
    tmp___85 = strmatch(option, (char *)"verbose");
    }
#line 275
    if (tmp___85) {
      {
#line 276
      tmp___5 = strncasecmp((char const   *)value, "true", (size_t )4);
      }
#line 276
      if (tmp___5) {
#line 279
        my.verbose = (BOOLEAN )0;
      } else {
#line 277
        my.verbose = (BOOLEAN )1;
      }
    } else {
      {
#line 281
      tmp___84 = strmatch(option, (char *)"quiet");
      }
#line 281
      if (tmp___84) {
        {
#line 282
        tmp___6 = strncasecmp((char const   *)value, "true", (size_t )4);
        }
#line 282
        if (tmp___6) {
#line 285
          my.quiet = (BOOLEAN )0;
        } else {
#line 283
          my.quiet = (BOOLEAN )1;
        }
      } else {
        {
#line 287
        tmp___83 = strmatch(option, (char *)"csv");
        }
#line 287
        if (tmp___83) {
          {
#line 288
          tmp___7 = strncasecmp((char const   *)value, "true", (size_t )4);
          }
#line 288
          if (tmp___7) {
#line 291
            my.csv = (BOOLEAN )0;
          } else {
#line 289
            my.csv = (BOOLEAN )1;
          }
        } else {
          {
#line 293
          tmp___82 = strmatch(option, (char *)"fullurl");
          }
#line 293
          if (tmp___82) {
            {
#line 294
            tmp___8 = strncasecmp((char const   *)value, "true", (size_t )4);
            }
#line 294
            if (tmp___8) {
#line 297
              my.fullurl = (BOOLEAN )0;
            } else {
#line 295
              my.fullurl = (BOOLEAN )1;
            }
          } else {
            {
#line 299
            tmp___81 = strmatch(option, (char *)"display-id");
            }
#line 299
            if (tmp___81) {
              {
#line 300
              tmp___9 = strncasecmp((char const   *)value, "true", (size_t )4);
              }
#line 300
              if (tmp___9) {
#line 303
                my.display = (BOOLEAN )0;
              } else {
#line 301
                my.display = (BOOLEAN )1;
              }
            } else {
              {
#line 305
              tmp___80 = strmatch(option, (char *)"logging");
              }
#line 305
              if (tmp___80) {
                {
#line 306
                tmp___10 = strncasecmp((char const   *)value, "true", (size_t )4);
                }
#line 306
                if (tmp___10) {
#line 309
                  my.logging = (BOOLEAN )0;
                } else {
#line 307
                  my.logging = (BOOLEAN )1;
                }
              } else {
                {
#line 311
                tmp___79 = strmatch(option, (char *)"show-logfile");
                }
#line 311
                if (tmp___79) {
                  {
#line 312
                  tmp___11 = strncasecmp((char const   *)value, "true", (size_t )4);
                  }
#line 312
                  if (tmp___11) {
#line 315
                    my.shlog = (BOOLEAN )0;
                  } else {
#line 313
                    my.shlog = (BOOLEAN )1;
                  }
                } else {
                  {
#line 317
                  tmp___78 = strmatch(option, (char *)"logfile");
                  }
#line 317
                  if (tmp___78) {
                    {
#line 318
                    strncpy((char */* __restrict  */)(my.logfile), (char const   */* __restrict  */)value,
                            sizeof(my.logfile));
                    }
                  } else {
                    {
#line 320
                    tmp___77 = strmatch(option, (char *)"cookies");
                    }
#line 320
                    if (tmp___77) {
                      {
#line 321
                      tmp___12 = strmatch(value, (char *)"true");
                      }
#line 321
                      if (tmp___12) {
#line 322
                        my.cookies = (BOOLEAN )1;
                      } else {
#line 324
                        my.cookies = (BOOLEAN )0;
                      }
                    } else {
                      {
#line 326
                      tmp___76 = strmatch(option, (char *)"concurrent");
                      }
#line 326
                      if (tmp___76) {
#line 327
                        if ((unsigned long )value != (unsigned long )((void *)0)) {
                          {
#line 328
                          my.cusers = atoi((char const   *)value);
                          }
                        } else {
#line 330
                          my.cusers = 10;
                        }
                      } else {
                        {
#line 333
                        tmp___75 = strmatch(option, (char *)"reps");
                        }
#line 333
                        if (tmp___75) {
#line 334
                          if ((unsigned long )value != (unsigned long )((void *)0)) {
                            {
#line 335
                            my.reps = atoi((char const   *)value);
                            }
                          } else {
#line 337
                            my.reps = 5;
                          }
                        } else {
                          {
#line 340
                          tmp___74 = strmatch(option, (char *)"time");
                          }
#line 340
                          if (tmp___74) {
                            {
#line 341
                            parse_time(value);
                            }
                          } else {
                            {
#line 343
                            tmp___73 = strmatch(option, (char *)"delay");
                            }
#line 343
                            if (tmp___73) {
#line 344
                              if ((unsigned long )value != (unsigned long )((void *)0)) {
                                {
#line 345
                                my.delay = atoi((char const   *)value);
                                }
                              } else {
#line 347
                                my.delay = 1;
                              }
                            } else {
                              {
#line 350
                              tmp___72 = strmatch(option, (char *)"timeout");
                              }
#line 350
                              if (tmp___72) {
#line 351
                                if ((unsigned long )value != (unsigned long )((void *)0)) {
                                  {
#line 352
                                  my.timeout = atoi((char const   *)value);
                                  }
                                } else {
#line 354
                                  my.timeout = 15;
                                }
                              } else {
                                {
#line 357
                                tmp___71 = strmatch(option, (char *)"timestamp");
                                }
#line 357
                                if (tmp___71) {
                                  {
#line 358
                                  tmp___13 = strncasecmp((char const   *)value, "true",
                                                         (size_t )4);
                                  }
#line 358
                                  if (tmp___13) {
#line 361
                                    my.timestamp = (BOOLEAN )0;
                                  } else {
#line 359
                                    my.timestamp = (BOOLEAN )1;
                                  }
                                } else {
                                  {
#line 363
                                  tmp___70 = strmatch(option, (char *)"internet");
                                  }
#line 363
                                  if (tmp___70) {
                                    {
#line 364
                                    tmp___14 = strncasecmp((char const   *)value,
                                                           "true", (size_t )4);
                                    }
#line 364
                                    if (tmp___14) {
#line 367
                                      my.internet = (BOOLEAN )0;
                                    } else {
#line 365
                                      my.internet = (BOOLEAN )1;
                                    }
                                  } else {
                                    {
#line 369
                                    tmp___69 = strmatch(option, (char *)"benchmark");
                                    }
#line 369
                                    if (tmp___69) {
                                      {
#line 370
                                      tmp___15 = strncasecmp((char const   *)value,
                                                             "true", (size_t )4);
                                      }
#line 370
                                      if (tmp___15) {
#line 373
                                        my.bench = (BOOLEAN )0;
                                      } else {
#line 371
                                        my.bench = (BOOLEAN )1;
                                      }
                                    } else {
                                      {
#line 375
                                      tmp___68 = strmatch(option, (char *)"cache");
                                      }
#line 375
                                      if (tmp___68) {
                                        {
#line 376
                                        tmp___16 = strncasecmp((char const   *)value,
                                                               "true", (size_t )4);
                                        }
#line 376
                                        if (tmp___16) {
#line 379
                                          my.cache = (BOOLEAN )0;
                                        } else {
#line 377
                                          my.cache = (BOOLEAN )1;
                                        }
                                      } else {
                                        {
#line 381
                                        tmp___67 = strmatch(option, (char *)"debug");
                                        }
#line 381
                                        if (tmp___67) {
                                          {
#line 382
                                          tmp___17 = strncasecmp((char const   *)value,
                                                                 "true", (size_t )4);
                                          }
#line 382
                                          if (tmp___17) {
#line 385
                                            my.debug = (BOOLEAN )0;
                                          } else {
#line 383
                                            my.debug = (BOOLEAN )1;
                                          }
                                        } else {
                                          {
#line 387
                                          tmp___66 = strmatch(option, (char *)"gmethod");
                                          }
#line 387
                                          if (tmp___66) {
                                            {
#line 388
                                            tmp___18 = strmatch(value, (char *)"GET");
                                            }
#line 388
                                            if (tmp___18) {
#line 389
                                              my.method = (METHOD )2;
                                            } else {
#line 391
                                              my.method = (METHOD )1;
                                            }
                                          } else {
                                            {
#line 394
                                            tmp___65 = strmatch(option, (char *)"file");
                                            }
#line 394
                                            if (tmp___65) {
                                              {
#line 395
                                              memset((void *)(my.file), 0, sizeof(my.file));
#line 396
                                              strncpy((char */* __restrict  */)(my.file),
                                                      (char const   */* __restrict  */)value,
                                                      sizeof(my.file));
                                              }
                                            } else {
                                              {
#line 398
                                              tmp___64 = strmatch(option, (char *)"url");
                                              }
#line 398
                                              if (tmp___64) {
                                                {
#line 399
                                                my.url = stralloc(value);
                                                }
                                              } else {
                                                {
#line 401
                                                tmp___63 = strmatch(option, (char *)"user-agent");
                                                }
#line 401
                                                if (tmp___63) {
                                                  {
#line 402
                                                  strncpy((char */* __restrict  */)(my.uagent),
                                                          (char const   */* __restrict  */)value,
                                                          sizeof(my.uagent));
                                                  }
                                                } else {
                                                  {
#line 404
                                                  tmp___62 = strmatch(option, (char *)"accept-encoding");
                                                  }
#line 404
                                                  if (tmp___62) {
                                                    {
#line 405
                                                    strncpy((char */* __restrict  */)(my.encoding),
                                                            (char const   */* __restrict  */)value,
                                                            sizeof(my.encoding));
                                                    }
                                                  } else {
                                                    {
#line 408
                                                    tmp___61 = strncasecmp((char const   *)option,
                                                                           "login",
                                                                           (size_t )5);
                                                    }
#line 408
                                                    if (tmp___61) {
                                                      {
#line 418
                                                      tmp___60 = strmatch(option,
                                                                          (char *)"attempts");
                                                      }
#line 418
                                                      if (tmp___60) {
#line 419
                                                        if ((unsigned long )value != (unsigned long )((void *)0)) {
                                                          {
#line 420
                                                          my.bids = atoi((char const   *)value);
                                                          }
                                                        } else {
#line 422
                                                          my.bids = 3;
                                                        }
                                                      } else {
                                                        {
#line 425
                                                        tmp___59 = strmatch(option,
                                                                            (char *)"username");
                                                        }
#line 425
                                                        if (tmp___59) {
                                                          {
#line 426
                                                          tmp___21 = trim(value);
#line 426
                                                          my.username = stralloc(tmp___21);
                                                          }
                                                        } else {
                                                          {
#line 428
                                                          tmp___58 = strmatch(option,
                                                                              (char *)"password");
                                                          }
#line 428
                                                          if (tmp___58) {
                                                            {
#line 429
                                                            tmp___22 = trim(value);
#line 429
                                                            my.password = stralloc(tmp___22);
                                                            }
                                                          } else {
                                                            {
#line 431
                                                            tmp___57 = strmatch(option,
                                                                                (char *)"connection");
                                                            }
#line 431
                                                            if (tmp___57) {
                                                              {
#line 432
                                                              tmp___23 = strncasecmp((char const   *)value,
                                                                                     "keep-alive",
                                                                                     (size_t )10);
                                                              }
#line 432
                                                              if (tmp___23) {
#line 435
                                                                my.keepalive = (BOOLEAN )0;
                                                              } else {
#line 433
                                                                my.keepalive = (BOOLEAN )1;
                                                              }
                                                            } else {
                                                              {
#line 437
                                                              tmp___56 = strmatch(option,
                                                                                  (char *)"protocol");
                                                              }
#line 437
                                                              if (tmp___56) {
                                                                {
#line 438
                                                                tmp___24 = strncasecmp((char const   *)value,
                                                                                       "HTTP/1.1",
                                                                                       (size_t )8);
                                                                }
#line 438
                                                                if (tmp___24) {
#line 441
                                                                  my.protocol = 0;
                                                                } else {
#line 439
                                                                  my.protocol = 1;
                                                                }
                                                              } else {
                                                                {
#line 443
                                                                tmp___55 = strmatch(option,
                                                                                    (char *)"proxy-host");
                                                                }
#line 443
                                                                if (tmp___55) {
                                                                  {
#line 444
                                                                  tmp___25 = trim(value);
#line 444
                                                                  auth_set_proxy_host(my.auth,
                                                                                      tmp___25);
                                                                  }
                                                                } else {
                                                                  {
#line 446
                                                                  tmp___54 = strmatch(option,
                                                                                      (char *)"proxy-port");
                                                                  }
#line 446
                                                                  if (tmp___54) {
#line 447
                                                                    if ((unsigned long )value != (unsigned long )((void *)0)) {
                                                                      {
#line 448
                                                                      tmp___26 = atoi((char const   *)value);
#line 448
                                                                      auth_set_proxy_port(my.auth,
                                                                                          tmp___26);
                                                                      }
                                                                    } else {
                                                                      {
#line 450
                                                                      auth_set_proxy_port(my.auth,
                                                                                          3128);
                                                                      }
                                                                    }
                                                                  } else {
                                                                    {
#line 453
                                                                    tmp___53 = strmatch(option,
                                                                                        (char *)"ftp-login");
                                                                    }
#line 453
                                                                    if (tmp___53) {
                                                                      {
#line 454
                                                                      tmp___27 = new_creds((SCHEME )3,
                                                                                           value);
#line 454
                                                                      auth_add(my.auth,
                                                                               tmp___27);
                                                                      }
                                                                    } else {
                                                                      {
#line 456
                                                                      tmp___52 = strmatch(option,
                                                                                          (char *)"proxy-login");
                                                                      }
#line 456
                                                                      if (tmp___52) {
                                                                        {
#line 457
                                                                        tmp___28 = new_creds((SCHEME )4,
                                                                                             value);
#line 457
                                                                        auth_add(my.auth,
                                                                                 tmp___28);
                                                                        }
                                                                      } else {
                                                                        {
#line 459
                                                                        tmp___51 = strmatch(option,
                                                                                            (char *)"failures");
                                                                        }
#line 459
                                                                        if (tmp___51) {
#line 460
                                                                          if ((unsigned long )value != (unsigned long )((void *)0)) {
                                                                            {
#line 461
                                                                            my.failures = atoi((char const   *)value);
                                                                            }
                                                                          } else {
#line 463
                                                                            my.failures = 30;
                                                                          }
                                                                        } else {
                                                                          {
#line 466
                                                                          tmp___50 = strmatch(option,
                                                                                              (char *)"chunked");
                                                                          }
#line 466
                                                                          if (tmp___50) {
                                                                            {
#line 467
                                                                            tmp___29 = strncasecmp((char const   *)value,
                                                                                                   "true",
                                                                                                   (size_t )4);
                                                                            }
#line 467
                                                                            if (tmp___29) {
#line 470
                                                                              my.chunked = (BOOLEAN )0;
                                                                            } else {
#line 468
                                                                              my.chunked = (BOOLEAN )1;
                                                                            }
                                                                          } else {
                                                                            {
#line 472
                                                                            tmp___49 = strmatch(option,
                                                                                                (char *)"unique");
                                                                            }
#line 472
                                                                            if (tmp___49) {
                                                                              {
#line 473
                                                                              tmp___30 = strncasecmp((char const   *)value,
                                                                                                     "true",
                                                                                                     (size_t )4);
                                                                              }
#line 473
                                                                              if (tmp___30) {
#line 476
                                                                                my.unique = (BOOLEAN )0;
                                                                              } else {
#line 474
                                                                                my.unique = (BOOLEAN )1;
                                                                              }
                                                                            } else {
                                                                              {
#line 478
                                                                              tmp___48 = strmatch(option,
                                                                                                  (char *)"header");
                                                                              }
#line 478
                                                                              if (tmp___48) {
                                                                                {
#line 479
                                                                                tmp___31 = strchr((char const   *)value,
                                                                                                  ':');
                                                                                }
#line 479
                                                                                if (! tmp___31) {
                                                                                  {
#line 479
                                                                                  NOTIFY((LEVEL )3,
                                                                                         "no \':\' in http-header");
                                                                                  }
                                                                                }
                                                                                {
#line 480
                                                                                tmp___32 = strlen((char const   *)value);
#line 480
                                                                                tmp___33 = strlen((char const   *)(my.extra));
                                                                                }
#line 480
                                                                                if ((tmp___32 + tmp___33) + 3UL > 512UL) {
                                                                                  {
#line 480
                                                                                  NOTIFY((LEVEL )3,
                                                                                         "too many headers");
                                                                                  }
                                                                                }
                                                                                {
#line 481
                                                                                strcat((char */* __restrict  */)(my.extra),
                                                                                       (char const   */* __restrict  */)value);
#line 482
                                                                                strcat((char */* __restrict  */)(my.extra),
                                                                                       (char const   */* __restrict  */)"\r\n");
                                                                                }
                                                                              } else {
                                                                                {
#line 484
                                                                                tmp___47 = strmatch(option,
                                                                                                    (char *)"expire-session");
                                                                                }
#line 484
                                                                                if (tmp___47) {
                                                                                  {
#line 485
                                                                                  tmp___34 = strncasecmp((char const   *)value,
                                                                                                         "true",
                                                                                                         (size_t )4);
                                                                                  }
#line 485
                                                                                  if (tmp___34) {
#line 488
                                                                                    my.expire = (BOOLEAN )0;
                                                                                  } else {
#line 486
                                                                                    my.expire = (BOOLEAN )1;
                                                                                  }
                                                                                } else {
                                                                                  {
#line 490
                                                                                  tmp___46 = strmatch(option,
                                                                                                      (char *)"follow-location");
                                                                                  }
#line 490
                                                                                  if (tmp___46) {
                                                                                    {
#line 491
                                                                                    tmp___35 = strncasecmp((char const   *)value,
                                                                                                           "true",
                                                                                                           (size_t )4);
                                                                                    }
#line 491
                                                                                    if (tmp___35) {
#line 494
                                                                                      my.follow = (BOOLEAN )0;
                                                                                    } else {
#line 492
                                                                                      my.follow = (BOOLEAN )1;
                                                                                    }
                                                                                  } else {
                                                                                    {
#line 496
                                                                                    tmp___45 = strmatch(option,
                                                                                                        (char *)"url-escaping");
                                                                                    }
#line 496
                                                                                    if (tmp___45) {
                                                                                      {
#line 497
                                                                                      tmp___36 = strncasecmp((char const   *)value,
                                                                                                             "true",
                                                                                                             (size_t )4);
                                                                                      }
#line 497
                                                                                      if (tmp___36) {
#line 500
                                                                                        my.escape = (BOOLEAN )0;
                                                                                      } else {
#line 498
                                                                                        my.escape = (BOOLEAN )1;
                                                                                      }
                                                                                    } else {
                                                                                      {
#line 502
                                                                                      tmp___44 = strmatch(option,
                                                                                                          (char *)"zero-data-ok");
                                                                                      }
#line 502
                                                                                      if (tmp___44) {
                                                                                        {
#line 503
                                                                                        tmp___37 = strncasecmp((char const   *)value,
                                                                                                               "true",
                                                                                                               (size_t )4);
                                                                                        }
#line 503
                                                                                        if (tmp___37) {
#line 506
                                                                                          my.zero_ok = (BOOLEAN )0;
                                                                                        } else {
#line 504
                                                                                          my.zero_ok = (BOOLEAN )1;
                                                                                        }
                                                                                      } else {
                                                                                        {
#line 508
                                                                                        tmp___43 = strmatch(option,
                                                                                                            (char *)"ssl-cert");
                                                                                        }
#line 508
                                                                                        if (tmp___43) {
                                                                                          {
#line 509
                                                                                          my.ssl_cert = stralloc(value);
                                                                                          }
                                                                                        } else {
                                                                                          {
#line 511
                                                                                          tmp___42 = strmatch(option,
                                                                                                              (char *)"ssl-key");
                                                                                          }
#line 511
                                                                                          if (tmp___42) {
                                                                                            {
#line 512
                                                                                            my.ssl_key = stralloc(value);
                                                                                            }
                                                                                          } else {
                                                                                            {
#line 514
                                                                                            tmp___41 = strmatch(option,
                                                                                                                (char *)"ssl-timeout");
                                                                                            }
#line 514
                                                                                            if (tmp___41) {
#line 515
                                                                                              if ((unsigned long )value != (unsigned long )((void *)0)) {
                                                                                                {
#line 516
                                                                                                my.ssl_timeout = atoi((char const   *)value);
                                                                                                }
                                                                                              } else {
#line 518
                                                                                                my.ssl_timeout = 15;
                                                                                              }
                                                                                            } else {
                                                                                              {
#line 521
                                                                                              tmp___40 = strmatch(option,
                                                                                                                  (char *)"ssl-ciphers");
                                                                                              }
#line 521
                                                                                              if (tmp___40) {
                                                                                                {
#line 522
                                                                                                my.ssl_ciphers = stralloc(value);
                                                                                                }
                                                                                              } else {
                                                                                                {
#line 524
                                                                                                tmp___39 = strmatch(option,
                                                                                                                    (char *)"spinner");
                                                                                                }
#line 524
                                                                                                if (tmp___39) {
                                                                                                  {
#line 525
                                                                                                  tmp___38 = strncasecmp((char const   *)value,
                                                                                                                         "true",
                                                                                                                         (size_t )4);
                                                                                                  }
#line 525
                                                                                                  if (tmp___38) {
#line 528
                                                                                                    my.spinner = (BOOLEAN )0;
                                                                                                  } else {
#line 526
                                                                                                    my.spinner = (BOOLEAN )1;
                                                                                                  }
                                                                                                } else {
                                                                                                  {
#line 530
                                                                                                  hash_add(H,
                                                                                                           option,
                                                                                                           value);
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    } else {
                                                      {
#line 409
                                                      tmp___20 = strmatch(option,
                                                                          (char *)"login-url");
                                                      }
#line 409
                                                      if (tmp___20) {
                                                        {
#line 410
                                                        my.login = (BOOLEAN )1;
#line 411
                                                        array_push(my.lurl, (void *)value);
                                                        }
                                                      } else {
                                                        {
#line 414
                                                        tmp___19 = new_creds((SCHEME )1,
                                                                             value);
#line 414
                                                        auth_add(my.auth, tmp___19);
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 532
    xfree((void *)value);
#line 533
    xfree((void *)option);
#line 534
    free((void *)tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 537
  hash_destroy(H);
#line 538
  fclose(fp);
  }
#line 539
  return (0);
}
}
#line 545 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/init.c"
void ds_module_check(void) 
{ 


  {
#line 548
  if (my.bench) {
#line 552
    my.delay = 0;
  }
#line 556
  if (my.secs > 0) {
#line 556
    if (my.reps > 0) {
#line 556
      if (my.reps != 10301062) {
        {
#line 557
        NOTIFY((LEVEL )2, "CONFIG conflict: selected time and repetition based testing");
#line 558
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"defaulting to time-based testing: %d seconds\n",
                my.secs);
#line 559
        my.reps = 10301062;
        }
      }
    }
  }
#line 562
  if (my.cusers <= 0) {
#line 563
    my.cusers = 1;
  }
#line 566
  if (my.get) {
#line 567
    my.cusers = 1;
#line 568
    my.reps = 1;
#line 569
    my.logging = (BOOLEAN )0;
#line 570
    my.bench = (BOOLEAN )1;
  }
#line 573
  if (my.quiet) {
#line 574
    my.verbose = (BOOLEAN )0;
#line 575
    my.debug = (BOOLEAN )0;
  }
#line 577
  return;
}
}
#line 37 "./hash.h"
char **hash_get_keys(HASH this ) ;
#line 40
void hash_free_keys(HASH this , char **keys ) ;
#line 41
int hash_get_entries(HASH this ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
static BOOLEAN __lookup(HASH this , char *key ) ;
#line 55
static void __resize(HASH this ) ;
#line 56
static unsigned int __genkey(int size , char *str ) ;
#line 57
static unsigned int fnv_32_buf(void *buf , size_t len , unsigned int hval ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
HASH new_hash(void) 
{ 
  HASH this ;
  int size ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 67
  size = 10240;
#line 69
  tmp = calloc(sizeof(*this), (size_t )1);
#line 69
  this = (HASH )tmp;
#line 70
  this->size = size;
#line 71
  this->entries = 0;
#line 72
  this->index = 0;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (this->size < size)) {
#line 73
      goto while_break;
    }
#line 74
    this->size <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  tmp___0 = calloc((unsigned long )this->size * sizeof(NODE *), (size_t )1);
#line 76
  this->table = (NODE **)tmp___0;
  }
#line 77
  return (this);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
void hash_reset(HASH this , ssize_t size ) 
{ 
  void *tmp ;

  {
#line 83
  this->size = 2;
#line 84
  this->entries = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! ((ssize_t )this->size < size)) {
#line 86
      goto while_break;
    }
#line 87
    this->size <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  tmp = calloc((unsigned long )this->size * sizeof(NODE *), (size_t )1);
#line 90
  this->table = (NODE **)tmp;
  }
#line 91
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
static void __resize(HASH this ) 
{ 
  NODE *tmp ;
  NODE *last_node ;
  NODE **last_table ;
  int x ;
  int hash ;
  int size ;
  unsigned int tmp___0 ;

  {
  {
#line 108
  size = this->size;
#line 109
  last_table = this->table;
#line 111
  hash_reset(this, (ssize_t )(size * 2));
#line 113
  x = 0;
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (x < size)) {
#line 114
      goto while_break;
    }
#line 115
    last_node = *(last_table + x);
    {
#line 116
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 116
      if (! ((unsigned long )last_node != (unsigned long )((void *)0))) {
#line 116
        goto while_break___0;
      }
      {
#line 117
      tmp = last_node;
#line 118
      last_node = last_node->next;
#line 119
      tmp___0 = __genkey(this->size, tmp->key);
#line 119
      hash = (int )tmp___0;
#line 120
      tmp->next = *(this->table + hash);
#line 121
      *(this->table + hash) = tmp;
#line 122
      (this->entries) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
void hash_add(HASH this , char *key , char *value ) 
{ 
  int x ;
  NODE *node ;
  BOOLEAN tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 141
  tmp = __lookup(this, key);
  }
#line 141
  if ((unsigned int )tmp == 1U) {
#line 142
    return;
  }
#line 144
  if (this->entries >= this->size / 4) {
    {
#line 145
    __resize(this);
    }
  }
  {
#line 147
  tmp___0 = __genkey(this->size, key);
#line 147
  x = (int )tmp___0;
#line 148
  tmp___1 = malloc(sizeof(NODE ));
#line 148
  node = (NODE *)tmp___1;
#line 149
  node->key = strdup((char const   *)key);
#line 150
  node->value = strdup((char const   *)value);
#line 151
  node->next = *(this->table + x);
#line 152
  *(this->table + x) = node;
#line 153
  (this->entries) ++;
  }
#line 154
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
char *hash_get(HASH this , char *key ) 
{ 
  int x ;
  NODE *node ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 167
  tmp = __genkey(this->size, key);
#line 167
  x = (int )tmp;
#line 168
  node = *(this->table + x);
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 168
      goto while_break;
    }
    {
#line 169
    tmp___0 = strcmp((char const   *)node->key, (char const   *)key);
    }
#line 169
    if (! tmp___0) {
#line 170
      return (node->value);
    }
#line 168
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return ((char *)((void *)0));
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
BOOLEAN hash_lookup(HASH this , char *key ) 
{ 
  BOOLEAN tmp ;

  {
  {
#line 180
  tmp = __lookup(this, key);
  }
#line 180
  return (tmp);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
char **hash_get_keys(HASH this ) 
{ 
  int x ;
  int i ;
  NODE *node ;
  char **keys ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 188
  i = 0;
#line 192
  tmp = malloc(sizeof(char *) * (unsigned long )this->entries);
#line 192
  keys = (char **)tmp;
#line 193
  x = 0;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (x < this->size)) {
#line 193
      goto while_break;
    }
#line 194
    node = *(this->table + x);
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 194
        goto while_break___0;
      }
      {
#line 195
      tmp___0 = malloc((size_t )128);
#line 195
      *(keys + i) = (char *)tmp___0;
#line 196
      memset((void *)*(keys + i), 0, sizeof(*(keys + i)));
#line 197
      tmp___1 = strlen((char const   *)node->key);
#line 197
      memcpy((void */* __restrict  */)*(keys + i), (void const   */* __restrict  */)node->key,
             tmp___1);
#line 198
      tmp___2 = strlen((char const   *)node->key);
#line 198
      *(*(keys + i) + tmp___2) = (char)0;
#line 199
      i ++;
#line 194
      node = node->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 193
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (keys);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
void hash_free_keys(HASH this , char **keys ) 
{ 
  int x ;
  char *tmp ;

  {
#line 209
  x = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (x < this->entries)) {
#line 209
      goto while_break;
    }
#line 210
    if ((unsigned long )*(keys + x) != (unsigned long )((void *)0)) {
      {
#line 211
      tmp = *(keys + x);
#line 212
      free((void *)tmp);
      }
    }
#line 209
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 214
  free((void *)keys);
  }
#line 216
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
void hash_destroy(HASH this ) 
{ 
  int x ;
  NODE *t1 ;
  NODE *t2 ;

  {
#line 229
  x = 0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (x < this->size)) {
#line 229
      goto while_break;
    }
#line 230
    t1 = *(this->table + x);
    {
#line 231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 231
      if (! ((unsigned long )t1 != (unsigned long )((void *)0))) {
#line 231
        goto while_break___0;
      }
#line 232
      t2 = t1->next;
#line 233
      if ((unsigned long )t1->key != (unsigned long )((void *)0)) {
        {
#line 234
        free((void *)t1->key);
        }
      }
#line 235
      if ((unsigned long )t1->value != (unsigned long )((void *)0)) {
        {
#line 236
        free((void *)t1->value);
        }
      }
      {
#line 237
      free((void *)t1);
#line 238
      t1 = t2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 240
    *(this->table + x) = (NODE *)((void *)0);
#line 229
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  if ((unsigned long )this->table != (unsigned long )((void *)0)) {
    {
#line 243
    free((void *)this->table);
#line 244
    memset((void *)this, 0, sizeof(HASH ));
    }
  }
  {
#line 246
  free((void *)this);
  }
#line 247
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
int hash_get_entries(HASH this ) 
{ 


  {
#line 253
  return (this->entries);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
static unsigned int fnv_32_buf(void *buf , size_t len , unsigned int hval ) 
{ 
  unsigned char *bp ;
  unsigned char *be ;
  unsigned char *tmp ;

  {
#line 261
  bp = (unsigned char *)buf;
#line 262
  be = bp + len;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! ((unsigned long )bp < (unsigned long )be)) {
#line 267
      goto while_break;
    }
#line 268
    tmp = bp;
#line 268
    bp ++;
#line 268
    hval ^= (u_int32_t )*tmp;
#line 269
    hval += ((((hval << 1) + (hval << 4)) + (hval << 7)) + (hval << 8)) + (hval << 24);
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  return (hval);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
static unsigned int __genkey(int size , char *str ) 
{ 
  unsigned int hash ;
  void *data ;
  size_t tmp ;

  {
  {
#line 282
  data = (void *)str;
#line 284
  tmp = strlen((char const   *)str);
#line 284
  hash = fnv_32_buf(data, tmp, 2166136261U);
#line 285
  hash %= (unsigned int )size;
  }
#line 286
  return (hash);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/hash.c"
static BOOLEAN __lookup(HASH this , char *key ) 
{ 
  int x ;
  NODE *node ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 300
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 300
    return ((BOOLEAN )0);
  }
  {
#line 301
  tmp = __genkey(this->size, key);
#line 301
  x = (int )tmp;
#line 302
  node = *(this->table + x);
  }
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 302
      goto while_break;
    }
    {
#line 303
    tmp___0 = strcmp((char const   *)node->key, (char const   *)key);
    }
#line 303
    if (! tmp___0) {
#line 304
      return ((BOOLEAN )1);
    }
#line 302
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  return ((BOOLEAN )0);
}
}
#line 298 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 362
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setscope)(pthread_attr_t *__attr ,
                                                                                                            int __scope ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 695 "/usr/include/stdio.h"
extern int puts(char const   *__s ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 144 "./setup.h"
void display_version(BOOLEAN b ) ;
#line 239 "./setup.h"
struct CONFIG my  ;
#line 28 "./timer.h"
void siege_timer(pthread_t handler ) ;
#line 28 "./log.h"
void log_transaction(DATA D ) ;
#line 30
void mark_log_file(char *message ) ;
#line 142 "../include/joedog/getopt.h"
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/main.c"
static struct option long_options[21]  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/main.c"
  {      {"version", 0, (int *)((void *)0), 'V'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"config", 0, (int *)((void *)0), 'C'}, 
        {"debug", 0, (int *)((void *)0), 'D'}, 
        {"get", 0, (int *)((void *)0), 'g'}, 
        {"concurrent", 1, (int *)((void *)0), 'c'}, 
        {"internet", 0, (int *)((void *)0), 'i'}, 
        {"benchmark", 0, (int *)((void *)0), 'b'}, 
        {"reps", 1, (int *)((void *)0), 'r'}, 
        {"time", 1, (int *)((void *)0), 't'}, 
        {"delay", 1, (int *)((void *)0), 'd'}, 
        {"log", 2, (int *)((void *)0), 'l'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"rc", 1, (int *)((void *)0), 'R'}, 
        {"mark", 1, (int *)((void *)0), 'm'}, 
        {"header", 1, (int *)((void *)0), 'H'}, 
        {"user-agent", 1, (int *)((void *)0), 'A'}, 
        {"content-type", 1, (int *)((void *)0), 'T'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 91 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/main.c"
void display_version(BOOLEAN b ) 
{ 
  char name[128] ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 101
  memset((void *)(name), 0, sizeof(name));
#line 102
  tmp = strlen((char const   *)program_name);
#line 102
  strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)program_name,
          tmp);
  }
#line 104
  if (my.debug) {
    {
#line 105
    tmp___0 = strlen((char const   *)(name));
#line 105
    tmp___1 = uppercase(name, tmp___0);
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s: debugging enabled\n\n%s\n",
            tmp___1, version_string, copyright);
    }
  } else
#line 107
  if ((unsigned int )b == 1U) {
    {
#line 108
    tmp___2 = strlen((char const   *)(name));
#line 108
    tmp___3 = uppercase(name, tmp___2);
#line 108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s\n\n%s\n",
            tmp___3, version_string, copyright);
#line 109
    exit(0);
    }
  } else {
    {
#line 111
    tmp___4 = strlen((char const   *)(name));
#line 111
    tmp___5 = uppercase(name, tmp___4);
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s\n",
            tmp___5, version_string);
    }
  }
#line 114
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/main.c"
void display_help(void) 
{ 


  {
  {
#line 126
  display_version((BOOLEAN )0);
#line 127
  printf((char const   */* __restrict  */)"Usage: %s [options]\n", program_name);
#line 128
  printf((char const   */* __restrict  */)"       %s [options] URL\n", program_name);
#line 129
  printf((char const   */* __restrict  */)"       %s -g URL\n", program_name);
#line 130
  printf((char const   */* __restrict  */)"Options:\n");
#line 131
  puts("  -V, --version             VERSION, prints the version number.");
#line 132
  puts("  -h, --help                HELP, prints this section.");
#line 133
  puts("  -C, --config              CONFIGURATION, show the current config.");
#line 134
  puts("  -v, --verbose             VERBOSE, prints notification to screen.");
#line 135
  puts("  -q, --quiet               QUIET turns verbose off and suppresses output.");
#line 136
  puts("  -g, --get                 GET, pull down HTTP headers and display the");
#line 137
  puts("                            transaction. Great for application debugging.");
#line 138
  puts("  -c, --concurrent=NUM      CONCURRENT users, default is 10");
#line 139
  puts("  -i, --internet            INTERNET user simulation, hits URLs randomly.");
#line 140
  puts("  -b, --benchmark           BENCHMARK: no delays between requests.");
#line 141
  puts("  -t, --time=NUMm           TIMED testing where \"m\" is modifier S, M, or H");
#line 142
  puts("                            ex: --time=1H, one hour test.");
#line 143
  puts("  -r, --reps=NUM            REPS, number of times to run the test.");
#line 144
  puts("  -f, --file=FILE           FILE, select a specific URLS FILE.");
#line 145
  printf((char const   */* __restrict  */)"  -R, --rc=FILE             RC, specify an %src file\n",
         program_name);
#line 146
  puts("  -l, --log[=FILE]          LOG to FILE. If FILE is not specified, the");
#line 147
  printf((char const   */* __restrict  */)"                            default is used: /var/%s.log\n",
         program_name);
#line 148
  puts("  -m, --mark=\"text\"         MARK, mark the log file with a string.");
#line 149
  puts("  -d, --delay=NUM           Time DELAY, random delay before each requst");
#line 150
  puts("                            between 1 and NUM. (NOT COUNTED IN STATS)");
#line 151
  puts("  -H, --header=\"text\"       Add a header to request (can be many)");
#line 152
  puts("  -A, --user-agent=\"text\"   Sets User-Agent in request");
#line 153
  puts("  -T, --content-type=\"text\" Sets Content-Type in request");
#line 154
  puts("");
#line 155
  puts((char const   *)copyright);
#line 159
  exit(0);
  }
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/main.c"
void parse_rc_cmdline(int argc , char **argv ) 
{ 
  int a ;

  {
  {
#line 170
  a = 0;
#line 171
  strcpy((char */* __restrict  */)(my.rc), (char const   */* __restrict  */)"");
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (a > -1)) {
#line 173
      goto while_break;
    }
    {
#line 174
    a = getopt_long(argc, (char * const  *)argv, "VhvqCDgl::ibr:t:f:d:c:m:H:R:A:T:",
                    (struct option  const  *)(long_options), (int *)0);
    }
#line 175
    if (a == 82) {
      {
#line 176
      strcpy((char */* __restrict  */)(my.rc), (char const   */* __restrict  */)optarg);
#line 177
      a = -1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  optind = 0;
#line 181
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/main.c"
void parse_cmdline(int argc , char **argv ) 
{ 
  int c ;
  int nargs ;
  size_t tmp ;
  size_t tmp___0 ;
  BOOLEAN tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 191
  c = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    c = getopt_long(argc, (char * const  *)argv, "VhvqCDgl::ibr:t:f:d:c:m:H:R:A:T:",
                    (struct option  const  *)(long_options), (int *)0);
    }
#line 193
    if (! (c != -1)) {
#line 193
      goto while_break;
    }
    {
#line 195
    if (c == 86) {
#line 195
      goto case_86;
    }
#line 198
    if (c == 104) {
#line 198
      goto case_104;
    }
#line 201
    if (c == 68) {
#line 201
      goto case_68;
    }
#line 204
    if (c == 67) {
#line 204
      goto case_67;
    }
#line 208
    if (c == 99) {
#line 208
      goto case_99;
    }
#line 211
    if (c == 105) {
#line 211
      goto case_105;
    }
#line 214
    if (c == 98) {
#line 214
      goto case_98;
    }
#line 217
    if (c == 100) {
#line 217
      goto case_100;
    }
#line 224
    if (c == 103) {
#line 224
      goto case_103;
    }
#line 227
    if (c == 108) {
#line 227
      goto case_108;
    }
#line 234
    if (c == 109) {
#line 234
      goto case_109;
    }
#line 239
    if (c == 113) {
#line 239
      goto case_113;
    }
#line 242
    if (c == 118) {
#line 242
      goto case_118;
    }
#line 245
    if (c == 114) {
#line 245
      goto case_114;
    }
#line 252
    if (c == 116) {
#line 252
      goto case_116;
    }
#line 255
    if (c == 102) {
#line 255
      goto case_102;
    }
#line 260
    if (c == 65) {
#line 260
      goto case_65;
    }
#line 263
    if (c == 84) {
#line 263
      goto case_84;
    }
#line 266
    if (c == 82) {
#line 266
      goto case_82;
    }
#line 271
    if (c == 72) {
#line 271
      goto case_72;
    }
#line 194
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 196
    display_version((BOOLEAN )1);
    }
#line 197
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 199
    display_help();
#line 200
    exit(0);
    }
    case_68: /* CIL Label */ 
#line 202
    my.debug = (BOOLEAN )1;
#line 203
    goto switch_break;
    case_67: /* CIL Label */ 
#line 205
    my.config = (BOOLEAN )1;
#line 206
    my.get = (BOOLEAN )0;
#line 207
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 209
    my.cusers = atoi((char const   *)optarg);
    }
#line 210
    goto switch_break;
    case_105: /* CIL Label */ 
#line 212
    my.internet = (BOOLEAN )1;
#line 213
    goto switch_break;
    case_98: /* CIL Label */ 
#line 215
    my.bench = (BOOLEAN )1;
#line 216
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 219
    my.delay = atoi((char const   *)optarg);
    }
#line 220
    if (my.delay < 0) {
#line 221
      my.delay = 0;
    }
#line 223
    goto switch_break;
    case_103: /* CIL Label */ 
#line 225
    my.get = (BOOLEAN )1;
#line 226
    goto switch_break;
    case_108: /* CIL Label */ 
#line 228
    my.logging = (BOOLEAN )1;
#line 229
    if (optarg) {
      {
#line 230
      tmp = strlen((char const   *)optarg);
#line 230
      my.logfile[tmp] = (char )'\000';
#line 231
      tmp___0 = strlen((char const   *)optarg);
#line 231
      strncpy((char */* __restrict  */)(my.logfile), (char const   */* __restrict  */)optarg,
              tmp___0);
      }
    }
#line 233
    goto switch_break;
    case_109: /* CIL Label */ 
#line 235
    my.mark = (BOOLEAN )1;
#line 236
    my.markstr = optarg;
#line 237
    my.logging = (BOOLEAN )1;
#line 238
    goto switch_break;
    case_113: /* CIL Label */ 
#line 240
    my.quiet = (BOOLEAN )1;
#line 241
    goto switch_break;
    case_118: /* CIL Label */ 
#line 243
    my.verbose = (BOOLEAN )1;
#line 244
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 246
    tmp___1 = strmatch(optarg, (char *)"once");
    }
#line 246
    if (tmp___1) {
#line 247
      my.reps = -1;
    } else {
      {
#line 249
      my.reps = atoi((char const   *)optarg);
      }
    }
#line 251
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 253
    parse_time(optarg);
    }
#line 254
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 256
    memset((void *)(my.file), 0, sizeof(my.file));
    }
#line 257
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 257
      goto switch_break;
    }
    {
#line 258
    tmp___2 = strlen((char const   *)optarg);
#line 258
    strncpy((char */* __restrict  */)(my.file), (char const   */* __restrict  */)optarg,
            tmp___2);
    }
#line 259
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 261
    strncpy((char */* __restrict  */)(my.uagent), (char const   */* __restrict  */)optarg,
            (size_t )255);
    }
#line 262
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 264
    strncpy((char */* __restrict  */)(my.conttype), (char const   */* __restrict  */)optarg,
            (size_t )255);
    }
#line 265
    goto switch_break;
    case_82: /* CIL Label */ 
#line 270
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 273
    tmp___3 = strchr((char const   *)optarg, ':');
    }
#line 273
    if (! tmp___3) {
      {
#line 273
      NOTIFY((LEVEL )3, "no \':\' in http-header");
      }
    }
    {
#line 274
    tmp___4 = strlen((char const   *)optarg);
#line 274
    tmp___5 = strlen((char const   *)(my.extra));
    }
#line 274
    if ((tmp___4 + tmp___5) + 3UL > 2048UL) {
      {
#line 275
      NOTIFY((LEVEL )3, "header is too large");
      }
    }
    {
#line 276
    strcat((char */* __restrict  */)(my.extra), (char const   */* __restrict  */)optarg);
#line 277
    strcat((char */* __restrict  */)(my.extra), (char const   */* __restrict  */)"\r\n");
    }
#line 279
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  nargs = argc - optind;
#line 284
  if (nargs) {
    {
#line 285
    my.url = xstrdup((char const   *)*(argv + (argc - 1)));
    }
  }
#line 286
  if (my.get) {
#line 286
    if ((unsigned long )my.url == (unsigned long )((void *)0)) {
      {
#line 287
      puts("ERROR: -g/--get requires a commandline URL");
#line 288
      exit(1);
      }
    }
  }
#line 290
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/main.c"
int main(int argc , char **argv ) 
{ 
  int x ;
  int result ;
  DATA D ;
  DATA tmp ;
  ARRAY urls ;
  ARRAY tmp___0 ;
  CREW crew ;
  LINES *lines ;
  CLIENT *client ;
  pthread_t cease ;
  pthread_t timer ;
  pthread_attr_t scope_attr ;
  void *statusp ;
  sigset_t sigs ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  URL tmp___5 ;
  URL tmp___6 ;
  METHOD tmp___7 ;
  METHOD tmp___8 ;
  URL tmp___9 ;
  URL tmp___10 ;
  int tmp___11 ;
  BOOLEAN tmp___12 ;
  BOOLEAN tmp___13 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  double tmp___26 ;
  unsigned int tmp___27 ;
  float tmp___28 ;
  float tmp___29 ;
  float tmp___30 ;
  float tmp___31 ;
  float tmp___32 ;
  float tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  float tmp___36 ;
  float tmp___37 ;

  {
  {
#line 298
  tmp = new_data();
#line 298
  D = tmp;
#line 299
  tmp___0 = new_array();
#line 299
  urls = tmp___0;
#line 309
  sigemptyset(& sigs);
#line 310
  sigaddset(& sigs, 1);
#line 311
  sigaddset(& sigs, 2);
#line 312
  sigaddset(& sigs, 14);
#line 313
  sigaddset(& sigs, 15);
#line 314
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sigs), (sigset_t */* __restrict  */)((void *)0));
#line 316
  tmp___1 = xcalloc((size_t )1, sizeof(*lines));
#line 316
  lines = (LINES *)tmp___1;
#line 317
  lines->index = 0;
#line 318
  lines->line = (char **)((void *)0);
#line 320
  memset((void *)(& my), 0, sizeof(struct CONFIG ));
#line 322
  parse_rc_cmdline(argc, argv);
#line 323
  tmp___2 = init_config();
  }
#line 323
  if (tmp___2 < 0) {
    {
#line 324
    exit(1);
    }
  }
  {
#line 326
  parse_cmdline(argc, argv);
#line 327
  ds_module_check();
  }
#line 334
  if (my.config) {
    {
#line 335
    show_config(1);
    }
  }
#line 338
  if ((unsigned long )my.url != (unsigned long )((void *)0)) {
#line 339
    my.length = 1;
  } else {
    {
#line 341
    my.length = read_cfg_file(lines, my.file);
    }
  }
#line 344
  if (my.reps < 0) {
#line 345
    my.reps = my.length;
  }
#line 348
  if (my.length == 0) {
    {
#line 349
    display_help();
    }
  }
  {
#line 353
  tmp___3 = xcalloc(sizeof(COOKIE ), (size_t )1);
#line 353
  cookie = (COOKIE *)tmp___3;
#line 354
  cookie->first = (CNODE *)((void *)0);
#line 355
  result = pthread_mutex_init(& cookie->mutex, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 355
  if (result != 0) {
    {
#line 356
    NOTIFY((LEVEL )3, "pthread_mutex_init");
    }
  }
  {
#line 360
  tmp___4 = xcalloc((size_t )my.cusers, sizeof(CLIENT ));
#line 360
  client = (CLIENT *)tmp___4;
#line 361
  crew = new_crew(my.cusers, my.cusers, (BOOLEAN )0);
  }
#line 361
  if ((unsigned long )crew == (unsigned long )((void *)0)) {
    {
#line 362
    NOTIFY((LEVEL )3, "unable to allocate memory for %d simulated browser", my.cusers);
    }
  }
#line 371
  if ((unsigned long )my.url != (unsigned long )((void *)0)) {
    {
#line 372
    tmp___6 = new_url(my.url);
#line 372
    tmp___5 = tmp___6;
#line 373
    url_set_ID(tmp___5, 0);
    }
#line 374
    if (my.get) {
      {
#line 374
      tmp___7 = url_get_method(tmp___5);
      }
#line 374
      if ((unsigned int )tmp___7 != 3U) {
        {
#line 374
        tmp___8 = url_get_method(tmp___5);
        }
#line 374
        if ((unsigned int )tmp___8 != 4U) {
          {
#line 375
          url_set_method(tmp___5, my.method);
          }
        }
      }
    }
    {
#line 377
    array_npush(urls, (void *)tmp___5, URLSIZE);
    }
  } else {
#line 379
    x = 0;
    {
#line 379
    while (1) {
      while_continue: /* CIL Label */ ;
#line 379
      if (! (x < my.length)) {
#line 379
        goto while_break;
      }
      {
#line 380
      tmp___10 = new_url(*(lines->line + x));
#line 380
      tmp___9 = tmp___10;
#line 381
      url_set_ID(tmp___9, x);
#line 382
      array_npush(urls, (void *)tmp___9, URLSIZE);
#line 379
      x ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 391
  if (! my.get) {
#line 391
    if (! my.quiet) {
      {
#line 392
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** ");
#line 393
      display_version((BOOLEAN )0);
#line 394
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Preparing %d concurrent users for battle.\n",
              my.cusers);
#line 395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The server is now under siege...");
      }
#line 396
      if (my.verbose) {
        {
#line 396
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
    }
  }
  {
#line 404
  data_set_start(D);
#line 411
  pthread_attr_init(& scope_attr);
#line 412
  pthread_attr_setscope(& scope_attr, 0);
#line 432
  result = pthread_create((pthread_t */* __restrict  */)(& cease), (pthread_attr_t const   */* __restrict  */)((void *)0),
                          (void *(*)(void * ))((void *)(& sig_handler)), (void */* __restrict  */)((void *)crew));
  }
#line 432
  if (result < 0) {
    {
#line 433
    NOTIFY((LEVEL )3, "failed to create handler: %d\n", result);
    }
  }
#line 435
  if (my.secs > 0) {
    {
#line 436
    result = pthread_create((pthread_t */* __restrict  */)(& timer), (pthread_attr_t const   */* __restrict  */)((void *)0),
                            (void *(*)(void * ))((void *)(& siege_timer)), (void */* __restrict  */)((void *)cease));
    }
#line 436
    if (result < 0) {
      {
#line 437
      NOTIFY((LEVEL )3, "failed to create handler: %d\n", result);
      }
    }
  }
#line 444
  x = 0;
  {
#line 444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 444
    if (x < my.cusers) {
      {
#line 444
      tmp___13 = crew_get_shutdown(crew);
      }
#line 444
      if (! ((unsigned int )tmp___13 != 1U)) {
#line 444
        goto while_break___0;
      }
    } else {
#line 444
      goto while_break___0;
    }
    {
#line 445
    (client + x)->id = x;
#line 446
    (client + x)->bytes = 0UL;
#line 447
    (client + x)->time = (float )0.0;
#line 448
    (client + x)->hits = 0UL;
#line 449
    (client + x)->code = 0U;
#line 450
    (client + x)->ok200 = 0U;
#line 451
    (client + x)->fail = 0U;
#line 452
    (client + x)->urls = urls;
#line 453
    (client + x)->auth.www = 0;
#line 454
    (client + x)->auth.proxy = 0;
#line 455
    (client + x)->auth.type.www = (TYPE )0;
#line 456
    (client + x)->auth.type.proxy = (TYPE )0;
#line 457
    tmp___11 = urandom();
#line 457
    (client + x)->rand_r_SEED = (unsigned int )tmp___11;
#line 458
    tmp___12 = crew_add(crew, (void (*)())((void *)(& start_routine)), (void *)(client + x));
#line 458
    result = (int )tmp___12;
    }
#line 459
    if (result == 0) {
      {
#line 460
      my.verbose = (BOOLEAN )0;
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to spawn additional threads; you may need to\n");
#line 462
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"upgrade your libraries or tune your system in order\n");
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"to exceed %d users.\n",
              my.cusers);
#line 464
      NOTIFY((LEVEL )3, "system resources exhausted");
      }
    }
#line 444
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 468
  crew_join(crew, (BOOLEAN )1, & statusp);
#line 478
  x = 0;
  }
  {
#line 478
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 478
    tmp___19 = crew_get_total(crew);
    }
#line 478
    if (tmp___19 > my.cusers) {
#line 478
      tmp___18 = my.cusers;
    } else {
      {
#line 478
      tmp___20 = crew_get_total(crew);
      }
#line 478
      if (tmp___20 == 0) {
#line 478
        tmp___18 = my.cusers;
      } else {
        {
#line 478
        tmp___17 = crew_get_total(crew);
#line 478
        tmp___18 = tmp___17;
        }
      }
    }
#line 478
    if (! (x < tmp___18)) {
#line 478
      goto while_break___1;
    }
    {
#line 480
    data_increment_count(D, (client + x)->hits);
#line 481
    data_increment_bytes(D, (client + x)->bytes);
#line 482
    data_increment_total(D, (client + x)->time);
#line 483
    data_increment_code(D, (int )(client + x)->code);
#line 484
    data_increment_ok200(D, (int )(client + x)->ok200);
#line 485
    data_increment_fail(D, (int )(client + x)->fail);
#line 486
    data_set_highest(D, (client + x)->himark);
#line 487
    data_set_lowest(D, (client + x)->lomark);
#line 488
    tmp___14 = urandom();
#line 488
    (client + x)->rand_r_SEED = (unsigned int )tmp___14;
#line 478
    x ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 494
  data_set_stop(D);
#line 499
  crew_destroy(crew);
#line 501
  x = 0;
  }
  {
#line 501
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 501
    if (! (x < my.cusers)) {
#line 501
      goto while_break___2;
    }
#line 501
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 508
  array_destroy(my.lurl);
#line 509
  xfree((void *)client);
  }
#line 511
  if (my.get) {
    {
#line 512
    tmp___21 = data_get_ok200(D);
    }
#line 512
    if (tmp___21 > 0U) {
      {
#line 513
      exit(0);
      }
    } else {
#line 515
      if (! my.quiet) {
        {
#line 515
        echo("[done]\n");
        }
      }
      {
#line 516
      exit(1);
      }
    }
  }
  {
#line 524
  pthread_usleep_np(10000UL);
  }
#line 525
  if (my.verbose) {
    {
#line 526
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done.\n");
    }
  } else {
    {
#line 528
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\b      done.\n");
    }
  }
#line 533
  if (my.failures > 0) {
#line 533
    if (my.failed >= my.failures) {
      {
#line 534
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s aborted due to excessive socket failure; you\n",
              program_name);
#line 535
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can change the failure threshold in $HOME/.%src\n",
              program_name);
      }
    }
  }
  {
#line 537
  tmp___22 = data_get_count(D);
#line 537
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nTransactions:\t\t%12u hits\n",
          tmp___22);
#line 538
  tmp___27 = data_get_count(D);
  }
#line 538
  if (tmp___27 == 0U) {
#line 538
    tmp___26 = (double )0;
  } else {
    {
#line 538
    tmp___24 = data_get_count(D);
#line 538
    tmp___25 = data_get_count(D);
#line 538
    tmp___26 = ((double )tmp___24 / (double )(tmp___25 + (unsigned int )my.failed)) * (double )100;
    }
  }
  {
#line 538
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Availability:\t\t%12.2f %%\n",
          tmp___26);
#line 543
  tmp___28 = data_get_elapsed(D);
#line 543
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Elapsed time:\t\t%12.2f secs\n",
          (double )tmp___28);
#line 544
  tmp___29 = data_get_megabytes(D);
#line 544
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Data transferred:\t%12.2f MB\n",
          (double )tmp___29);
#line 545
  tmp___30 = data_get_response_time(D);
#line 545
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response time:\t\t%12.2f secs\n",
          (double )tmp___30);
#line 546
  tmp___31 = data_get_transaction_rate(D);
#line 546
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Transaction rate:\t%12.2f trans/sec\n",
          (double )tmp___31);
#line 547
  tmp___32 = data_get_throughput(D);
#line 547
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Throughput:\t\t%12.2f MB/sec\n",
          (double )tmp___32);
#line 548
  tmp___33 = data_get_concurrency(D);
#line 548
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Concurrency:\t\t%12.2f\n",
          (double )tmp___33);
#line 549
  tmp___34 = data_get_code(D);
#line 549
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successful transactions:%12u\n",
          tmp___34);
  }
#line 550
  if (my.debug) {
    {
#line 551
    tmp___35 = data_get_ok200(D);
#line 551
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HTTP OK received:\t%12u\n",
            tmp___35);
    }
  }
  {
#line 553
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed transactions:\t%12u\n",
          my.failed);
#line 554
  tmp___36 = data_get_highest(D);
#line 554
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Longest transaction:\t%12.2f\n",
          (double )tmp___36);
#line 555
  tmp___37 = data_get_lowest(D);
#line 555
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shortest transaction:\t%12.2f\n",
          (double )tmp___37);
#line 556
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" \n");
  }
#line 557
  if (my.mark) {
    {
#line 557
    mark_log_file(my.markstr);
    }
  }
#line 558
  if (my.logging) {
    {
#line 558
    log_transaction(D);
    }
  }
  {
#line 560
  data_destroy(D);
  }
#line 561
  if ((unsigned long )my.url == (unsigned long )((void *)0)) {
#line 562
    x = 0;
    {
#line 562
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 562
      if (! (x < my.length)) {
#line 562
        goto while_break___3;
      }
      {
#line 563
      xfree((void *)*(lines->line + x));
#line 562
      x ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 564
    xfree((void *)lines->line);
#line 565
    xfree((void *)lines);
    }
  } else {
    {
#line 567
    xfree((void *)lines->line);
#line 568
    xfree((void *)lines);
    }
  }
  {
#line 571
  pthread_mutex_destroy(& cookie->mutex);
#line 578
  xfree((void *)cookie);
#line 579
  xfree((void *)my.url);
#line 581
  exit(0);
  }
}
}
#line 379 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 33 "./notify.h"
void OPENLOG(char *program ) ;
#line 34
void CLOSELOG(void) ;
#line 35
void SYSLOG(LEVEL L , char const   *fmt  , ...) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/notify.c"
static void __message(METHOD M , LEVEL L , char const   *fmt , va_list ap ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/notify.c"
void OPENLOG(char *program ) 
{ 


  {
  {
#line 66
  openlog((char const   *)program, 1, 3 << 3);
  }
#line 67
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/notify.c"
void CLOSELOG(void) 
{ 


  {
  {
#line 73
  closelog();
  }
#line 74
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/notify.c"
static void __message(METHOD M , LEVEL L , char const   *fmt , va_list ap ) 
{ 
  char buf[40000] ;
  char msg[41024] ;
  LEVEL level ;
  char pmode[64] ;
  char lmode[64] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 82
  level = (LEVEL )1;
#line 85
  memset((void *)(lmode), '\000', (size_t )64);
#line 86
  memset((void *)(pmode), '\000', (size_t )64);
#line 88
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)fmt, ap);
#line 89
  tmp___1 = __errno_location();
  }
#line 89
  if (*tmp___1 == 0) {
    {
#line 90
    snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s\n",
             buf);
    }
  } else {
    {
#line 89
    tmp___2 = __errno_location();
    }
#line 89
    if (*tmp___2 == 38) {
      {
#line 90
      snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s\n",
               buf);
      }
    } else
#line 89
    if ((unsigned int )L == 0U) {
      {
#line 90
      snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s\n",
               buf);
      }
    } else {
      {
#line 92
      tmp = __errno_location();
#line 92
      tmp___0 = strerror(*tmp);
#line 92
      snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%s: %s\n",
               buf, tmp___0);
      }
    }
  }
  {
#line 96
  if ((unsigned int )L == 0U) {
#line 96
    goto case_0;
  }
#line 101
  if ((unsigned int )L == 1U) {
#line 101
    goto case_1;
  }
#line 106
  if ((unsigned int )L == 2U) {
#line 106
    goto case_2;
  }
#line 111
  if ((unsigned int )L == 3U) {
#line 111
    goto case_3;
  }
#line 95
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 97
  sprintf((char */* __restrict  */)(pmode), (char const   */* __restrict  */)"[%c[%d;%dmdebug%c[%dm]",
          27, 1, 34, 27, 0);
#line 98
  strcpy((char */* __restrict  */)(lmode), (char const   */* __restrict  */)"[debug]");
#line 99
  level = (LEVEL )4;
  }
#line 100
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 102
  sprintf((char */* __restrict  */)(pmode), (char const   */* __restrict  */)"[%c[%d;%dmalert%c[%dm]",
          27, 1, 32, 27, 0);
#line 103
  strcpy((char */* __restrict  */)(lmode), (char const   */* __restrict  */)"[alert] ");
#line 104
  level = (LEVEL )4;
  }
#line 105
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 107
  sprintf((char */* __restrict  */)(pmode), (char const   */* __restrict  */)"[%c[%d;%dmerror%c[%dm]",
          27, 1, 33, 27, 0);
#line 108
  strcpy((char */* __restrict  */)(lmode), (char const   */* __restrict  */)"[error]");
#line 109
  level = (LEVEL )3;
  }
#line 110
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 112
  sprintf((char */* __restrict  */)(pmode), (char const   */* __restrict  */)"[%c[%d;%dmfatal%c[%dm]",
          27, 1, 31, 27, 0);
#line 113
  strcpy((char */* __restrict  */)(lmode), (char const   */* __restrict  */)"[fatal]");
#line 114
  level = (LEVEL )2;
  }
#line 115
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 118
  if ((unsigned int )M == 1U) {
    {
#line 119
    syslog((int )level, "%s %s", lmode, msg);
    }
  } else {
    {
#line 121
    fflush(stdout);
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s",
            pmode, msg);
    }
  }
#line 124
  if ((unsigned int )L == 3U) {
    {
#line 124
    exit(1);
    }
  }
#line 125
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/notify.c"
void SYSLOG(LEVEL L , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 132
  __builtin_va_start(ap, fmt);
#line 134
  __message((METHOD )1, L, fmt, ap);
#line 135
  __builtin_va_end(ap);
  }
#line 137
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/notify.c"
void NOTIFY(LEVEL L , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 144
  __builtin_va_start(ap, fmt);
#line 146
  __message((METHOD )2, L, fmt, ap);
#line 147
  __builtin_va_end(ap);
  }
#line 149
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/notify.c"
void __display(int color , char const   *fmt , va_list ap ) 
{ 
  char buf[40000] ;
  char msg[41024] ;

  {
  {
#line 158
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)fmt, ap);
#line 159
  snprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)"%c[%d;%dm%s%c[%dm\n",
           27, 0, color + 30, buf, 27, 0);
#line 160
  printf((char const   */* __restrict  */)"%s", msg);
  }
#line 161
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/lib/joedog/notify.c"
void DISPLAY(int color , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 168
  __builtin_va_start(ap, fmt);
#line 169
  __display(color, fmt, ap);
#line 170
  __builtin_va_end(ap);
  }
#line 171
  return;
}
}
#line 30 "./ftp.h"
BOOLEAN ftp_ascii(CONN *C ) ;
#line 31
BOOLEAN ftp_binary(CONN *C ) ;
#line 33
BOOLEAN ftp_cwd(CONN *C , URL U ) ;
#line 35
BOOLEAN ftp_list(CONN *C , CONN *D , URL U ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
static int __request___0(CONN *C , char *fmt  , ...) ;
#line 32
static int __response(CONN *C ) ;
#line 33
static int __response_code(char const   *buf ) ;
#line 34
static BOOLEAN __in_range(int code , int lower , int upper ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_login(CONN *C , URL U ) 
{ 
  int code ;
  char tmp[128] ;
  BOOLEAN tmp___0 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  BOOLEAN tmp___5 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  BOOLEAN tmp___10 ;

  {
  {
#line 39
  code = 120;
#line 42
  code = __response(C);
#line 43
  tmp___0 = okay(code);
  }
#line 43
  if (! tmp___0) {
    {
#line 44
    NOTIFY((LEVEL )2, "FTP: Server responded: %d", code);
    }
#line 45
    return ((BOOLEAN )0);
  }
  {
#line 48
  tmp___4 = url_get_username(U);
  }
#line 48
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 48
    tmp___3 = "anonymous";
  } else {
    {
#line 48
    tmp___2 = url_get_username(U);
#line 48
    tmp___3 = (char const   *)tmp___2;
    }
  }
  {
#line 48
  snprintf((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)"%s",
           tmp___3);
#line 49
  code = __request___0(C, (char *)"USER %s", tmp);
  }
#line 50
  if (code != 331) {
    {
#line 51
    tmp___5 = okay(code);
    }
#line 51
    if (tmp___5) {
#line 51
      return ((BOOLEAN )1);
    }
  }
  {
#line 54
  memset((void *)(tmp), '\000', sizeof(tmp));
#line 55
  tmp___9 = url_get_password(U);
  }
#line 55
  if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
#line 55
    tmp___8 = "siege@joedog.org";
  } else {
    {
#line 55
    tmp___7 = url_get_password(U);
#line 55
    tmp___8 = (char const   *)tmp___7;
    }
  }
  {
#line 55
  snprintf((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)"%s",
           tmp___8);
#line 56
  code = __request___0(C, (char *)"PASS %s", tmp);
#line 57
  tmp___10 = __in_range(code, 200, 299);
  }
#line 57
  return (tmp___10);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_pasv(CONN *C ) 
{ 
  int i ;
  int code ;
  char *ptr ;
  unsigned char addr[6] ;
  BOOLEAN tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 67
  code = __request___0(C, (char *)"PASV");
#line 68
  tmp = okay(code);
  }
#line 68
  if (! tmp) {
#line 68
    return ((BOOLEAN )0);
  }
#line 70
  ptr = C->chkbuf;
#line 71
  ptr += 4;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (*ptr) {
      {
#line 71
      tmp___0 = __ctype_b_loc();
      }
#line 71
      if ((int const   )*(*tmp___0 + (int )*ptr) & 2048) {
#line 71
        goto while_break;
      }
    } else {
#line 71
      goto while_break;
    }
#line 71
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (! *ptr) {
#line 73
    return ((BOOLEAN )0);
  }
#line 75
  i = 0;
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 75
    if (! (i < 6)) {
#line 75
      goto while_break___0;
    }
#line 76
    addr[i] = (unsigned char)0;
    {
#line 77
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 77
      tmp___1 = __ctype_b_loc();
      }
#line 77
      if (! ((int const   )*(*tmp___1 + (int )*ptr) & 2048)) {
#line 77
        goto while_break___1;
      }
#line 78
      addr[i] = (unsigned char )(((int )*ptr - 48) + 10 * (int )addr[i]);
#line 77
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 80
    if ((int )*ptr == 44) {
#line 80
      ptr ++;
    } else
#line 81
    if (i < 5) {
#line 81
      return ((BOOLEAN )0);
    }
#line 75
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 83
  snprintf((char */* __restrict  */)(C->ftp.host), sizeof(C->ftp.host), (char const   */* __restrict  */)"%d.%d.%d.%d",
           (int )addr[0], (int )addr[1], (int )addr[2], (int )addr[3]);
#line 84
  C->ftp.port = ((int )addr[4] << 8) + (int )addr[5];
  }
#line 86
  return ((BOOLEAN )1);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_cwd(CONN *C , URL U ) 
{ 
  int code ;
  char *tmp ;
  BOOLEAN tmp___0 ;

  {
  {
#line 94
  tmp = url_get_path(U);
#line 94
  code = __request___0(C, (char *)"CWD %s", tmp);
#line 95
  tmp___0 = okay(code);
  }
#line 95
  return (tmp___0);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_ascii(CONN *C ) 
{ 
  BOOLEAN tmp ;

  {
  {
#line 101
  C->ftp.code = __request___0(C, (char *)"TYPE A");
#line 102
  tmp = okay(C->ftp.code);
  }
#line 102
  return (tmp);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_binary(CONN *C ) 
{ 
  BOOLEAN tmp ;

  {
  {
#line 108
  C->ftp.code = __request___0(C, (char *)"TYPE I");
#line 109
  tmp = okay(C->ftp.code);
  }
#line 109
  return (tmp);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_quit(CONN *C ) 
{ 
  BOOLEAN tmp ;

  {
  {
#line 115
  C->ftp.code = __request___0(C, (char *)"QUIT");
#line 116
  tmp = okay(C->ftp.code);
  }
#line 116
  return (tmp);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_size(CONN *C , URL U ) 
{ 
  int size ;
  int resp ;
  BOOLEAN tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  BOOLEAN tmp___3 ;

  {
  {
#line 125
  tmp = ftp_binary(C);
  }
#line 125
  if ((unsigned int )tmp != 1U) {
#line 125
    return ((BOOLEAN )0);
  }
  {
#line 127
  tmp___0 = url_get_file(U);
#line 127
  tmp___1 = url_get_path(U);
#line 127
  C->ftp.code = __request___0(C, (char *)"SIZE %s%s", tmp___1, tmp___0);
#line 128
  tmp___3 = okay(C->ftp.code);
  }
#line 128
  if (tmp___3) {
    {
#line 131
    tmp___2 = sscanf((char const   */* __restrict  */)(C->chkbuf), (char const   */* __restrict  */)"%d %d",
                     & resp, & size);
    }
#line 131
    if (tmp___2 == 2) {
#line 132
      C->ftp.size = (size_t )size;
#line 133
      return ((BOOLEAN )1);
    } else {
#line 135
      return ((BOOLEAN )0);
    }
  } else {
#line 129
    return ((BOOLEAN )0);
  }
#line 138
  return ((BOOLEAN )1);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_stor(CONN *C , URL U ) 
{ 
  size_t len ;
  char *file ;
  size_t id ;
  pthread_t tmp ;
  int num ;
  char **parts ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  BOOLEAN tmp___6 ;

  {
  {
#line 146
  tmp = pthread_self();
#line 146
  id = tmp;
#line 147
  num = 2;
  }
#line 150
  if ((double )id < 0.0) {
#line 151
    id = - id;
  }
  {
#line 154
  tmp___0 = url_get_file(U);
#line 154
  tmp___1 = strlen((char const   *)tmp___0);
#line 154
  len = tmp___1 + 16UL;
#line 155
  tmp___2 = url_get_file(U);
#line 155
  parts = split((char )'.', tmp___2, & num);
#line 157
  tmp___3 = xmalloc(len);
#line 157
  file = (char *)tmp___3;
#line 158
  memset((void *)file, '\000', len);
  }
#line 159
  if ((unsigned long )*(parts + 1) == (unsigned long )((void *)0)) {
#line 159
    tmp___4 = "";
  } else {
#line 159
    tmp___4 = (char const   *)*(parts + 1);
  }
  {
#line 159
  snprintf((char */* __restrict  */)file, len, (char const   */* __restrict  */)"%s-%u.%s",
           *(parts + 0), id, tmp___4);
  }
#line 160
  if (my.unique) {
    {
#line 161
    C->ftp.code = __request___0(C, (char *)"STOR %s", file);
    }
  } else {
    {
#line 163
    tmp___5 = url_get_file(U);
#line 163
    C->ftp.code = __request___0(C, (char *)"STOR %s", tmp___5);
    }
  }
  {
#line 165
  xfree((void *)file);
#line 166
  split_free(parts, num);
#line 167
  tmp___6 = okay(C->ftp.code);
  }
#line 167
  return (tmp___6);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_retr(CONN *C , URL U ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  BOOLEAN tmp___1 ;

  {
  {
#line 174
  tmp = url_get_file(U);
#line 174
  tmp___0 = url_get_path(U);
#line 174
  C->ftp.code = __request___0(C, (char *)"RETR %s%s", tmp___0, tmp);
#line 175
  tmp___1 = okay(C->ftp.code);
  }
#line 175
  return (tmp___1);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
size_t ftp_put(CONN *D , URL U ) 
{ 
  size_t n ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 182
  tmp = url_get_postlen(U);
#line 182
  tmp___0 = url_get_postdata(U);
#line 182
  tmp___1 = socket_write(D, (void const   *)tmp___0, tmp);
#line 182
  n = (size_t )tmp___1;
#line 182
  tmp___2 = url_get_postlen(U);
  }
#line 182
  if (n != tmp___2) {
    {
#line 183
    NOTIFY((LEVEL )2, "HTTP: unable to write to socket.");
    }
#line 184
    return ((size_t )-1);
  }
  {
#line 187
  tmp___3 = url_get_postlen(U);
  }
#line 187
  return (tmp___3);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
size_t ftp_get(CONN *D , URL U , size_t size ) 
{ 
  int n ;
  char c ;
  size_t bytes ;
  char *file ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 195
  bytes = (size_t )0;
#line 198
  tmp = xmalloc(size);
#line 198
  file = (char *)tmp;
#line 199
  memset((void *)file, '\000', size);
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 202
    tmp___0 = socket_read(D, (void *)(& c), (size_t )1);
#line 202
    n = (int )tmp___0;
    }
#line 202
    if (n == 0) {
#line 203
      goto while_break;
    }
#line 204
    *(file + bytes) = c;
#line 205
    bytes += (size_t )n;
#line 201
    if (! (bytes < size)) {
#line 201
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  if (my.get) {
    {
#line 209
    write_file(U, file, size);
    }
  }
  {
#line 211
  xfree((void *)file);
  }
#line 213
  return (bytes);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
BOOLEAN ftp_list(CONN *C , CONN *D , URL U ) 
{ 
  int n ;
  char c ;
  int bytes ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 223
  tmp___3 = url_get_file(U);
  }
#line 223
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 223
    tmp___0 = url_get_path(U);
#line 223
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 223
    tmp___1 = url_get_file(U);
#line 223
    tmp___2 = tmp___1;
    }
  }
  {
#line 223
  C->ftp.code = __request___0(C, (char *)"LIST %s", tmp___2);
  }
#line 225
  if (C->ftp.code == 150) {
#line 226
    if (D->sock < 1) {
      {
#line 227
      NOTIFY((LEVEL )2, "unable to read from socket: %s:%d", C->ftp.host, C->ftp.port);
      }
#line 228
      return ((BOOLEAN )0);
    }
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 231
      tmp___4 = socket_read(D, (void *)(& c), (size_t )1);
#line 231
      n = (int )tmp___4;
      }
#line 231
      if (n == 0) {
#line 232
        goto while_break;
      }
#line 233
      if (my.verbose) {
        {
#line 233
        printf((char const   */* __restrict  */)"%c", (int )c);
        }
      }
#line 234
      bytes += n;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 237
  return ((BOOLEAN )1);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
static int __request___0(CONN *C , char *fmt  , ...) 
{ 
  int code ;
  char buf[1024] ;
  char cmd[1032] ;
  size_t len ;
  size_t n ;
  va_list ap ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 243
  code = 0;
#line 249
  memset((void *)(buf), '\000', sizeof(buf));
#line 250
  memset((void *)(cmd), '\000', sizeof(cmd));
#line 252
  __builtin_va_start(ap, fmt);
#line 253
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)fmt,
            ap);
#line 254
  tmp = snprintf((char */* __restrict  */)(cmd), sizeof(cmd), (char const   */* __restrict  */)"%s\r\n",
                 buf);
#line 254
  len = (size_t )tmp;
#line 256
  tmp___0 = socket_write(C, (void const   *)(cmd), len);
#line 256
  n = (size_t )tmp___0;
  }
#line 256
  if (n != len) {
    {
#line 257
    NOTIFY((LEVEL )2, "FTP: unable to write to socket.");
#line 258
    code = 500;
    }
  }
  {
#line 260
  __builtin_va_end(ap);
#line 261
  tmp___1 = chomp(cmd);
#line 261
  debug((char const   *)tmp___1);
  }
#line 263
  if (code == 500) {
#line 264
    C->ftp.code = 500;
#line 265
    return (C->ftp.code);
  } else {
    {
#line 267
    C->ftp.code = __response(C);
    }
#line 268
    return (C->ftp.code);
  }
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
static int __response(CONN *C ) 
{ 
  int n ;
  char c ;
  int code ;
  BOOLEAN cont ;
  int x ;
  ssize_t tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
#line 278
  code = 120;
#line 279
  cont = (BOOLEAN )1;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! cont) {
#line 281
      goto while_break;
    }
    {
#line 284
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 285
      x = 0;
#line 286
      memset((void *)(C->chkbuf), '\000', sizeof(C->chkbuf));
      }
      {
#line 287
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 287
        tmp = socket_read(C, (void *)(& c), (size_t )1);
#line 287
        n = (int )tmp;
        }
#line 287
        if (! (n == 1)) {
#line 287
          goto while_break___1;
        }
        {
#line 288
        echo("%c", (int )c);
#line 289
        C->chkbuf[x] = c;
        }
#line 290
        if ((int )C->chkbuf[x] == 10) {
#line 290
          goto while_break___1;
        }
#line 291
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 293
      tmp___0 = __ctype_b_loc();
      }
#line 293
      if ((int const   )*(*tmp___0 + (int )C->chkbuf[0]) & 2048) {
#line 293
        if ((int )C->chkbuf[3] != 45) {
#line 293
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 295
    code = __response_code((char const   *)(C->chkbuf));
    }
#line 296
    if ((int )C->chkbuf[3] == 32) {
#line 297
      cont = (BOOLEAN )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  if (code > 499) {
#line 300
    if (! my.quiet) {
      {
#line 301
      tmp___1 = chomp(C->chkbuf);
#line 301
      printf((char const   */* __restrict  */)"%s\n", tmp___1);
      }
    }
  }
#line 303
  return (code);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
static int __response_code(char const   *buf ) 
{ 
  int ret ;
  char code[4] ;

  {
  {
#line 311
  memset((void *)(code), '\000', sizeof(code));
#line 312
  strncpy((char */* __restrict  */)(code), (char const   */* __restrict  */)buf, (size_t )3);
#line 313
  code[3] = (char )'\000';
#line 314
  ret = atoi((char const   *)(code));
  }
#line 315
  return (ret);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/ftp.c"
static BOOLEAN __in_range(int code , int lower , int upper ) 
{ 
  int tmp ;

  {
#line 321
  if (code >= lower) {
#line 321
    if (code <= upper) {
#line 321
      tmp = 1;
    } else {
#line 321
      tmp = 0;
    }
  } else {
#line 321
    tmp = 0;
  }
#line 321
  return ((BOOLEAN )tmp);
}
}
#line 35 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_kill)(pthread_t __threadid ,
                                                                                   int __signo ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/timer.c"
void siege_timer(pthread_t handler ) 
{ 
  int err ;
  time_t now ;
  struct timespec timeout ;
  pthread_mutex_t timer_mutex ;
  pthread_cond_t timer_cond ;
  time_t tmp ;

  {
  {
#line 35
  timer_mutex.__data.__lock = 0;
#line 35
  timer_mutex.__data.__count = 0U;
#line 35
  timer_mutex.__data.__owner = 0;
#line 35
  timer_mutex.__data.__nusers = 0U;
#line 35
  timer_mutex.__data.__kind = 0;
#line 35
  timer_mutex.__data.__spins = (short)0;
#line 35
  timer_mutex.__data.__elision = (short)0;
#line 35
  timer_mutex.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 35
  timer_mutex.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 36
  timer_cond.__data.__lock = 0;
#line 36
  timer_cond.__data.__futex = 0U;
#line 36
  timer_cond.__data.__total_seq = 0ULL;
#line 36
  timer_cond.__data.__wakeup_seq = 0ULL;
#line 36
  timer_cond.__data.__woken_seq = 0ULL;
#line 36
  timer_cond.__data.__mutex = (void *)0;
#line 36
  timer_cond.__data.__nwaiters = 0U;
#line 36
  timer_cond.__data.__broadcast_seq = 0U;
#line 38
  tmp = time(& now);
  }
#line 38
  if (tmp < 0L) {
    {
#line 39
    NOTIFY((LEVEL )3, "unable to set the siege timer!");
    }
  }
  {
#line 41
  timeout.tv_sec = now + (time_t )my.secs;
#line 42
  timeout.tv_nsec = (__syscall_slong_t )0;
#line 44
  pthread_mutex_lock(& timer_mutex);
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 46
    err = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& timer_cond),
                                 (pthread_mutex_t */* __restrict  */)(& timer_mutex),
                                 (struct timespec  const  */* __restrict  */)(& timeout));
    }
#line 47
    if (err == 110) {
#line 49
      if (my.debug) {
        {
#line 49
        printf((char const   */* __restrict  */)"TIMED OUT!!\n");
#line 49
        fflush(stdout);
        }
      }
      {
#line 51
      my.verbose = (BOOLEAN )0;
#line 52
      pthread_kill(handler, 15);
      }
#line 53
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  pthread_mutex_unlock(& timer_mutex);
  }
#line 59
  return;
}
}
#line 29 "./log.h"
void write_to_log(int count , float elapsed , int bytes , float ttime , int code ,
                  int failed ) ;
#line 31
BOOLEAN file_exists(char *file ) ;
#line 32
BOOLEAN create_logfile(char const   *file ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/log.c"
void log_transaction(DATA D ) 
{ 
  unsigned int tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 39
  tmp = data_get_code(D);
#line 39
  tmp___0 = data_get_total(D);
#line 39
  tmp___1 = data_get_megabytes(D);
#line 39
  tmp___2 = data_get_elapsed(D);
#line 39
  tmp___3 = data_get_count(D);
#line 39
  write_to_log((int )tmp___3, tmp___2, (int )tmp___1, tmp___0, (int )tmp, my.failed);
  }
#line 47
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/log.c"
void write_to_log(int count , float elapsed , int bytes , float ttime , int code ,
                  int failed ) 
{ 
  int fd ;
  char entry[512] ;
  struct tm keepsake ;
  struct tm *tmp ;
  time_t now ;
  size_t len ;
  char date[65] ;
  struct tm *tmp___0 ;
  BOOLEAN tmp___1 ;
  BOOLEAN tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 63
  now = time((time_t *)((void *)0));
#line 65
  tmp___0 = localtime_r((time_t const   */* __restrict  */)(& now), (struct tm */* __restrict  */)(& keepsake));
#line 65
  tmp = tmp___0;
#line 70
  setlocale(2, "C");
#line 71
  len = strftime((char */* __restrict  */)(date), sizeof(date), (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
                 (struct tm  const  */* __restrict  */)tmp);
  }
#line 74
  if (my.shlog) {
    {
#line 75
    printf((char const   */* __restrict  */)"FILE: %s\n", my.logfile);
#line 76
    puts("You can disable this annoying message by editing");
#line 77
    puts("the .siegerc file in your home directory; change");
#line 78
    puts("the directive \'show-logfile\' to false.");
    }
  }
  {
#line 81
  tmp___2 = file_exists(my.logfile);
  }
#line 81
  if (! tmp___2) {
    {
#line 82
    tmp___1 = create_logfile((char const   *)(my.logfile));
    }
#line 82
    if (! tmp___1) {
      {
#line 83
      NOTIFY((LEVEL )2, "unable to create log file");
      }
#line 84
      return;
    }
  }
  {
#line 89
  snprintf((char */* __restrict  */)(entry), sizeof(entry), (char const   */* __restrict  */)"%s,%7d,%11.2f,%12u,%11.2f,%12.2f,%12.2f,%12.2f,%8d,%8d\n",
           date, count, (double )elapsed, bytes, (double )(ttime / (float )count),
           (double )((float )count / elapsed), (double )((float )bytes / elapsed),
           (double )(ttime / elapsed), code, failed);
#line 97
  fd = open((char const   *)(my.logfile), 1025, 420);
  }
#line 97
  if (fd < 0) {
    {
#line 98
    NOTIFY((LEVEL )2, "Unable to write to file");
    }
#line 99
    return;
  }
  {
#line 102
  tmp___3 = strlen((char const   *)(entry));
#line 102
  write(fd, (void const   *)(entry), tmp___3);
#line 103
  close(fd);
  }
#line 105
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/log.c"
void mark_log_file(char *message ) 
{ 
  int fd ;
  char entry[512] ;
  BOOLEAN tmp ;
  BOOLEAN tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 118
  tmp___0 = file_exists(my.logfile);
  }
#line 118
  if (! tmp___0) {
    {
#line 119
    tmp = create_logfile((char const   *)(my.logfile));
    }
#line 119
    if (! tmp) {
      {
#line 120
      NOTIFY((LEVEL )2, "unable to create log file");
      }
#line 121
      return;
    }
  }
  {
#line 126
  snprintf((char */* __restrict  */)(entry), sizeof(entry), (char const   */* __restrict  */)"**** %s ****\n",
           message);
#line 128
  fd = open((char const   *)(my.logfile), 1025, 420);
  }
#line 128
  if (fd < 0) {
    {
#line 129
    NOTIFY((LEVEL )2, "Unable to write to file");
    }
  }
  {
#line 132
  tmp___1 = strlen((char const   *)(entry));
#line 132
  write(fd, (void const   *)(entry), tmp___1);
#line 133
  close(fd);
  }
#line 135
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/log.c"
BOOLEAN file_exists(char *file ) 
{ 
  int fd ;

  {
  {
#line 147
  fd = open((char const   *)file, 0);
  }
#line 147
  if (fd < 0) {
    {
#line 149
    close(fd);
    }
#line 150
    return ((BOOLEAN )0);
  } else {
    {
#line 153
    close(fd);
    }
#line 154
    return ((BOOLEAN )1);
  }
#line 157
  return ((BOOLEAN )0);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/siege-3.0.5/src/log.c"
BOOLEAN create_logfile(char const   *file ) 
{ 
  int fd ;
  char *head ;
  size_t tmp ;

  {
  {
#line 171
  head = (char *)"      Date & Time,  Trans,  Elap Time,  Data Trans,  Resp Time,  Trans Rate,  Throughput,  Concurrent,    OKAY,   Failed\n";
#line 174
  fd = open(file, 65, 420);
  }
#line 174
  if (fd < 0) {
#line 175
    return ((BOOLEAN )0);
  }
  {
#line 179
  tmp = strlen((char const   *)head);
#line 179
  write(fd, (void const   *)head, tmp);
#line 180
  close(fd);
  }
#line 182
  return ((BOOLEAN )1);
}
}
