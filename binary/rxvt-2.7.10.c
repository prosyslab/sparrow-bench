/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_56 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_56 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_57 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_57 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_58 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_58 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_59 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_59 ScreenFormat;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_61 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_61 XWindowAttributes;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_65 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_65 XColor;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_74 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_74 *_XPrivDisplay;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_105 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_105 XErrorEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_109 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_109 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_110 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_110 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_111 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_111 XFontStruct;
#line 1106
struct _XOC;
#line 1106 "/usr/include/X11/Xlib.h"
typedef struct _XOC *XFontSet;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_134 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_133 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_134 min_aspect ;
   struct __anonstruct_min_aspect_134 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_133 XSizeHints;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 122 "/usr/include/X11/Intrinsic.h"
typedef unsigned long Pixel;
#line 69 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
struct rxvt_vars;
#line 70
struct rxvt_hidden;
#line 75 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
struct __anonstruct_row_col_t_162 {
   int32_t row ;
   int32_t col ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef struct __anonstruct_row_col_t_162 row_col_t;
#line 80 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef unsigned char text_t;
#line 98 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
struct __anonstruct_TermWin_t_163 {
   u_int16_t width ;
   u_int16_t height ;
   u_int16_t fwidth ;
   u_int16_t fheight ;
   u_int16_t fascent ;
   u_int16_t fdescent ;
   u_int16_t propfont ;
   u_int16_t fontdiff ;
   u_int16_t ncol ;
   u_int16_t nrow ;
   u_int16_t focus ;
   u_int16_t mapped ;
   u_int16_t int_bwidth ;
   u_int16_t ext_bwidth ;
   u_int16_t lineSpace ;
   u_int16_t saveLines ;
   u_int16_t nscrolled ;
   u_int16_t view_start ;
   Window parent[6] ;
   Window vt ;
   GC gc ;
   XFontStruct *font ;
   XFontStruct *boldFont ;
   XFontStruct *boldFont_loaded ;
   XFontStruct *mfont ;
   XFontSet fontset ;
   Pixmap pixmap ;
};
#line 98 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef struct __anonstruct_TermWin_t_163 TermWin_t;
#line 157 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
struct __anonstruct_screen_t_164 {
   text_t **text ;
   int16_t *tlen ;
   u_int16_t **rend ;
   row_col_t cur ;
   u_int16_t tscroll ;
   u_int16_t bscroll ;
   u_int16_t charset ;
   unsigned int flags ;
   row_col_t s_cur ;
   u_int16_t s_charset ;
   char s_charset_char ;
   u_int16_t s_rstyle ;
};
#line 157 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef struct __anonstruct_screen_t_164 screen_t;
#line 172
enum __anonenum_op_166 {
    SELECTION_CLEAR = 0,
    SELECTION_INIT = 1,
    SELECTION_BEGIN = 2,
    SELECTION_CONT = 3,
    SELECTION_DONE = 4
} ;
#line 172 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
struct __anonstruct_selection_t_165 {
   unsigned char *text ;
   u_int32_t len ;
   enum __anonenum_op_166 op ;
   short screen ;
   short clicks ;
   row_col_t beg ;
   row_col_t mark ;
   row_col_t end ;
};
#line 172 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef struct __anonstruct_selection_t_165 selection_t;
#line 189
enum __anonenum_sstyle_t_167 {
    OLD_SELECT = 0,
    OLD_WORD_SELECT = 1,
    NEW_SELECT = 2
} ;
#line 189 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef enum __anonenum_sstyle_t_167 sstyle_t;
#line 237
enum __anonenum_ENC_METHOD_168 {
    EUCJ = 0,
    SJIS = 1,
    BIG5 = 2,
    CNS = 3,
    GB = 4,
    EUCKR = 5,
    NOENC = 6
} ;
#line 237 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef enum __anonenum_ENC_METHOD_168 ENC_METHOD;
#line 251 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
struct __anonstruct_menuBar_t_170 {
   short state ;
   Window win ;
};
#line 251 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef struct __anonstruct_menuBar_t_170 menuBar_t;
#line 256 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
struct __anonstruct_scrollBar_t_171 {
   char state ;
   char init ;
   short beg ;
   short end ;
   short top ;
   short bot ;
   short style ;
   short width ;
   Window win ;
   int (*update)(struct rxvt_vars * , int  , int  , int  , int  ) ;
};
#line 256 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef struct __anonstruct_scrollBar_t_171 scrollBar_t;
#line 269 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
struct rxvt_vars {
   struct rxvt_hidden *h ;
   TermWin_t TermWin ;
   scrollBar_t scrollBar ;
   menuBar_t menuBar ;
   Display *Xdisplay ;
   unsigned long Options ;
   XSizeHints szHint ;
   Colormap Xcmap ;
   Pixel *PixColors ;
   short numPixColors ;
   Cursor TermWin_cursor ;
   int Xdepth ;
   int sb_shadow ;
   int Xfd ;
   int cmd_fd ;
   int tty_fd ;
   int num_fds ;
   int numlock_state ;
   text_t **drawn_text ;
   u_int16_t **drawn_rend ;
   text_t **buf_text ;
   u_int16_t **buf_rend ;
   char *tabs ;
   screen_t screen ;
   screen_t swap ;
   selection_t selection ;
   sstyle_t selection_style ;
   ENC_METHOD encoding_method ;
};
#line 269 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
typedef struct rxvt_vars rxvt_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvt.h"
typedef struct termios ttymode_t;
#line 115 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvt.h"
struct mouse_event {
   int clicks ;
   Time time ;
   unsigned int state ;
   unsigned int button ;
};
#line 864 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvt.h"
struct rxvt_hidden {
   unsigned char want_refresh : 1 ;
   unsigned char want_full_refresh : 1 ;
   unsigned char am_transparent : 1 ;
   unsigned char am_pixmap_trans : 1 ;
   unsigned char current_screen : 1 ;
   unsigned char hate_those_clicks : 1 ;
   unsigned char num_scr_allow : 1 ;
   unsigned char bypass_keystate : 1 ;
   unsigned char chstat : 1 ;
   unsigned char lost_multi : 1 ;
   unsigned char multi_byte : 1 ;
   unsigned char parsed_geometry : 1 ;
   unsigned char refresh_type ;
   unsigned char meta_char ;
   unsigned char scrollbar_align ;
   unsigned char selection_wait ;
   unsigned char selection_type ;
   short rvideo ;
   int16_t num_scr ;
   u_int16_t prev_ncol ;
   u_int16_t prev_nrow ;
   u_int16_t rstyle ;
   u_int32_t pixcolor_set[1] ;
   int csrO ;
   int refresh_count ;
   int refresh_limit ;
   int fnum ;
   int last_bot ;
   int last_top ;
   int last_state ;
   int scrollbar_len ;
   int currmaxcol ;
   int window_vt_x ;
   int window_vt_y ;
   int window_sb_x ;
   int allowedxerror ;
   unsigned int ModMetaMask ;
   unsigned int ModNumLockMask ;
   unsigned int old_width ;
   unsigned int old_height ;
   unsigned int colorfgbg ;
   unsigned int ttymode ;
   unsigned long PrivateModes ;
   unsigned long SavedModes ;
   Atom xa[9] ;
   Time selection_time ;
   Time selection_request_time ;
   pid_t cmd_pid ;
   gid_t ttygid ;
   uid_t euid ;
   gid_t egid ;
   Cursor cursor_leftptr ;
   char const   *ttydev ;
   char const   *key_backspace ;
   char const   *key_delete ;
   struct mouse_event MEvent ;
   XComposeStatus compose ;
   ttymode_t tio ;
   row_col_t oldcursor ;
   struct timeval timeout[1] ;
   char *env_windowid ;
   char *env_display ;
   char *env_term ;
   char *env_colorfgbg ;
   char *buffer ;
   char *locale ;
   char charsets[4] ;
   unsigned char *v_buffer ;
   unsigned char *v_bufstr ;
   unsigned char *v_bufptr ;
   unsigned char *v_bufend ;
   char *newfont[7] ;
   unsigned char const   *Keysym_map[256] ;
   char const   *rs[60] ;
   unsigned char *cmdbuf_ptr ;
   unsigned char *cmdbuf_endp ;
   unsigned char cmdbuf_base[8192] ;
   unsigned char kbuf[512] ;
};
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_55 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_55 XGCValues;
#line 487 "/usr/include/X11/Xlib.h"
struct __anonstruct_XModifierKeymap_73 {
   int max_keypermod ;
   KeyCode *modifiermap ;
};
#line 487 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XModifierKeymap_73 XModifierKeymap;
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_135 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_135 XWMHints;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_136 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_136 XTextProperty;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_139 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_139 XClassHint;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_75 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_76 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_77 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_78 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_79 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_80 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_81 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_82 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_83 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_84 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_85 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_86 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_87 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_88 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_89 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_90 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_91 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_92 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_93 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_94 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_95 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_96 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_97 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_98 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_99 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_100 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_101 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_103 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_103 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_102 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_104 XMappingEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_106 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_107 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_107 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_108 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_108 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 174 "/usr/include/X11/Xutil.h"
enum __anonenum_XICCEncodingStyle_137 {
    XStringStyle = 0,
    XCompoundTextStyle = 1,
    XTextStyle = 2,
    XStdICCTextStyle = 3,
    XUTF8StringStyle = 4
} ;
#line 174 "/usr/include/X11/Xutil.h"
typedef enum __anonenum_XICCEncodingStyle_137 XICCEncodingStyle;
#line 307 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvt.h"
enum page_dirn {
    UP = 0,
    DN = 1,
    NO_DIR = 2
} ;
#line 3343 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
enum __anonenum_closeto_179 {
    LEFT = 0,
    RIGHT = 1
} ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 2667 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
struct __anonstruct_argtopriv_180 {
   int const   argval ;
   unsigned long const   bit ;
};
#line 84 "/usr/include/X11/Xresource.h"
typedef int XrmQuark;
#line 84 "/usr/include/X11/Xresource.h"
typedef int *XrmQuarkList;
#line 87 "/usr/include/X11/Xresource.h"
typedef char *XrmString;
#line 117
enum __anonenum_XrmBinding_142 {
    XrmBindTightly = 0,
    XrmBindLoosely = 1
} ;
#line 117 "/usr/include/X11/Xresource.h"
typedef enum __anonenum_XrmBinding_142 *XrmBindingList;
#line 156 "/usr/include/X11/Xresource.h"
typedef XrmQuark XrmRepresentation;
#line 160 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmValue_143 {
   unsigned int size ;
   XPointer addr ;
};
#line 160 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmValue_143 XrmValue;
#line 175 "/usr/include/X11/Xresource.h"
typedef struct _XrmHashBucketRec *XrmDatabase;
#line 76 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
struct __anonstruct_optList_178 {
   unsigned long const   flag ;
   int const   doff ;
   char const   *kw ;
   char const   *opt ;
   char const   *arg ;
   char const   *desc ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 36 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.h"
enum enc_label {
    ENC_SJIS = 0,
    ENC_EUCJ = 1,
    ENC_GB = 2,
    ENC_BIG5 = 3,
    ENC_EUCKR = 4,
    ENC_ISO8859_1 = 5,
    ENC_ISO8859_2 = 6,
    ENC_ISO8859_3 = 7,
    ENC_ISO8859_4 = 8,
    ENC_ISO8859_5 = 9,
    ENC_ISO8859_6 = 10,
    ENC_ISO8859_7 = 11,
    ENC_ISO8859_8 = 12,
    ENC_ISO8859_9 = 13,
    ENC_ISO8859_10 = 14,
    ENC_ISO8859_11 = 15,
    ENC_ISO8859_12 = 16,
    ENC_ISO8859_13 = 17,
    ENC_ISO8859_14 = 18,
    ENC_ISO8859_15 = 19,
    ENC_KOI8R = 20,
    ENC_KOI8U = 21,
    ENC_DUMMY = 22
} ;
#line 54 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.h"
struct name2encoding {
   char const   *name ;
   enum enc_label  const  encoding ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.h"
struct defaultfont {
   enum enc_label  const  enc_label ;
   char const   *encoding_method ;
   char const   *font[7] ;
   char const   *mfont[7] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2465
extern int XFetchName(Display * , Window  , char ** ) ;
#line 2528
extern int XFree(void * ) ;
#line 2554
extern int XFreeFont(Display * , XFontStruct * ) ;
#line 2644
extern int XGetIconName(Display * , Window  , char ** ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2837
extern int XMoveResizeWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ) ;
#line 2862
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 2975
extern int XQueryColors(Display * , Colormap  , XColor * , int  ) ;
#line 3072
extern int XRecolorCursor(Display * , Cursor  , XColor * , XColor * ) ;
#line 3111
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 3227
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3257
extern int XSetIconName(Display * , Window  , char const   * ) ;
#line 3345
extern int XSetWindowBackground(Display * , Window  , unsigned long  ) ;
#line 3407
extern int XStoreName(Display * , Window  , char const   * ) ;
#line 659 "/usr/include/X11/Xutil.h"
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 312 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
rxvt_t *rxvt_init(int argc , char const   * const  *argv ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.extpro"
int rxvt_init_vars(rxvt_t *r ) ;
#line 2
void rxvt_init_secondary(rxvt_t *r ) ;
#line 3
char const   **rxvt_init_resources(rxvt_t *r , int argc , char const   * const  *argv ) ;
#line 4
void rxvt_init_env(rxvt_t *r ) ;
#line 5
void rxvt_init_xlocale(rxvt_t *r ) ;
#line 6
void rxvt_init_command(rxvt_t *r , char const   * const  *argv ) ;
#line 7
void rxvt_Create_Windows(rxvt_t *r , int argc , char const   * const  *argv ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.extpro"
void rxvt_Child_signal(int sig ) ;
#line 2
void rxvt_Exit_signal(int sig ) ;
#line 3
void rxvt_clean_exit(void) ;
#line 4
void *rxvt_malloc(size_t size ) ;
#line 5
void *rxvt_calloc(size_t number , size_t size ) ;
#line 6
void *rxvt_realloc(void *ptr , size_t size ) ;
#line 9
void rxvt_window_calc(rxvt_t *r , unsigned int width , unsigned int height ) ;
#line 10
void rxvt_tt_winsize(int fd , unsigned short col , unsigned short row ) ;
#line 11
void rxvt_change_font(rxvt_t *r , int init , char const   *fontname ) ;
#line 12
void rxvt_set_title(rxvt_t *r , char const   *str ) ;
#line 13
void rxvt_set_iconName(rxvt_t *r , char const   *str ) ;
#line 14
void rxvt_set_window_color(rxvt_t *r , int idx , char const   *color ) ;
#line 15
void rxvt_recolour_cursor(rxvt_t *r ) ;
#line 16
int rxvt_rXParseAllocColor(rxvt_t *r , XColor *screen_in_out , char const   *colour ) ;
#line 17
int rxvt_rXAllocColor(rxvt_t *r , XColor *screen_in_out , char const   *colour ) ;
#line 18
void rxvt_resize_all_windows(rxvt_t *r , unsigned int width , unsigned int height ,
                             int ignoreparent ) ;
#line 19
void rxvt_set_widthheight(rxvt_t *r , unsigned int width , unsigned int height ) ;
#line 24
rxvt_t *rxvt_get_r(void) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.extpro"
void rxvt_print_error(char const   *fmt  , ...) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.extpro"
void rxvt_scr_reset(rxvt_t *r ) ;
#line 5
int rxvt_scr_change_screen(rxvt_t *r , int scrn ) ;
#line 36
void rxvt_scr_touch(rxvt_t *r , int refresh ) ;
#line 42
void rxvt_scr_clear(rxvt_t *r ) ;
#line 44
void rxvt_selection_check(rxvt_t *r , int check_more ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/scrollbar.extpro"
void rxvt_Resize_scrollBar(rxvt_t *r ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.intpro"
int rxvt_xerror_handler(Display const   *display , XErrorEvent const   *event ) ;
#line 2
void rxvt_privileges(rxvt_t *r , int mode ) ;
#line 3
void rxvt_font_up_down(rxvt_t *r , int n , int direction ) ;
#line 5
void rxvt_set_colorfgbg(rxvt_t *r ) ;
#line 12
void rxvt_set_r(rxvt_t *r ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
rxvt_t *rxvt_init(int argc , char const   * const  *argv ) 
{ 
  char const   **cmd_argv ;
  rxvt_t *r ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 56
  tmp = rxvt_calloc((size_t )1, sizeof(rxvt_t ));
#line 56
  r = (rxvt_t *)tmp;
#line 57
  rxvt_set_r(r);
#line 58
  tmp___0 = rxvt_init_vars(r);
  }
#line 58
  if (tmp___0 < 0) {
    {
#line 59
    free((void *)r);
    }
#line 60
    return ((rxvt_t *)((void *)0));
  }
  {
#line 70
  rxvt_privileges(r, 's');
#line 71
  rxvt_privileges(r, 0);
#line 73
  rxvt_init_secondary(r);
#line 75
  cmd_argv = rxvt_init_resources(r, argc, argv);
#line 85
  rxvt_Create_Windows(r, argc, argv);
#line 87
  rxvt_init_xlocale(r);
#line 89
  rxvt_scr_reset(r);
#line 96
  XSetErrorHandler((int (*)(Display * , XErrorEvent * ))(& rxvt_xerror_handler));
#line 113
  XMapWindow(r->Xdisplay, r->TermWin.vt);
#line 114
  XMapWindow(r->Xdisplay, r->TermWin.parent[0]);
#line 116
  rxvt_init_env(r);
#line 117
  rxvt_init_command(r, (char const   * const  *)cmd_argv);
  }
#line 118
  return (r);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_Child_signal(int sig ) 
{ 
  int pid ;
  int save_errno ;
  int *tmp ;
  rxvt_t *r ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 132
  tmp = __errno_location();
#line 132
  save_errno = *tmp;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 136
    tmp___0 = __errno_location();
#line 136
    *tmp___0 = 0;
#line 135
    pid = waitpid(-1, (int *)((void *)0), 1);
    }
#line 135
    if (pid == -1) {
      {
#line 135
      tmp___1 = __errno_location();
      }
#line 135
      if (! (*tmp___1 == 4)) {
#line 135
        goto while_break;
      }
    } else {
#line 135
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  r = rxvt_get_r();
  }
#line 140
  if (pid == (r->h)->cmd_pid) {
    {
#line 141
    exit(0);
    }
  }
  {
#line 143
  tmp___2 = __errno_location();
#line 143
  *tmp___2 = save_errno;
#line 144
  signal(17, & rxvt_Child_signal);
  }
#line 145
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_Exit_signal(int sig ) 
{ 
  __pid_t tmp ;

  {
  {
#line 154
  signal(sig, (void (*)(int  ))0);
#line 158
  rxvt_clean_exit();
#line 159
  tmp = getpid();
#line 159
  kill(tmp, sig);
  }
#line 160
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
int rxvt_xerror_handler(Display const   *display , XErrorEvent const   *event ) 
{ 
  rxvt_t *r ;
  rxvt_t *tmp ;

  {
  {
#line 167
  tmp = rxvt_get_r();
#line 167
  r = tmp;
  }
#line 169
  if ((r->h)->allowedxerror == -1) {
#line 170
    (r->h)->allowedxerror = (int )event->error_code;
#line 171
    return (0);
  }
  {
#line 173
  rxvt_print_error("XError: Request: %d . %d, Error: %d", (int const   )event->request_code,
                   (int const   )event->minor_code, (int const   )event->error_code);
#line 177
  exit(1);
  }
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_clean_exit(void) 
{ 
  rxvt_t *r ;
  rxvt_t *tmp ;

  {
  {
#line 190
  tmp = rxvt_get_r();
#line 190
  r = tmp;
  }
#line 203
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void *rxvt_malloc(size_t size ) 
{ 
  void *p ;

  {
  {
#line 214
  p = malloc(size);
  }
#line 215
  if (p) {
#line 216
    return (p);
  }
  {
#line 218
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rxvt: memory allocation failure.  Aborting");
#line 219
  rxvt_clean_exit();
#line 220
  exit(1);
  }
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void *rxvt_calloc(size_t number , size_t size ) 
{ 
  void *p ;

  {
  {
#line 230
  p = calloc(number, size);
  }
#line 231
  if (p) {
#line 232
    return (p);
  }
  {
#line 234
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rxvt: memory allocation failure.  Aborting");
#line 235
  rxvt_clean_exit();
#line 236
  exit(1);
  }
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void *rxvt_realloc(void *ptr , size_t size ) 
{ 
  void *p ;

  {
#line 246
  if (ptr) {
    {
#line 247
    p = realloc(ptr, size);
    }
  } else {
    {
#line 249
    p = malloc(size);
    }
  }
#line 250
  if (p) {
#line 251
    return (p);
  }
  {
#line 253
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rxvt: memory allocation failure.  Aborting");
#line 254
  rxvt_clean_exit();
#line 255
  exit(1);
  }
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_privileges(rxvt_t *r , int mode ) 
{ 
  __uid_t tmp ;
  __gid_t tmp___0 ;

  {
  {
#line 275
  if (mode == 0) {
#line 275
    goto case_0;
  }
#line 283
  if (mode == 115) {
#line 283
    goto case_115;
  }
#line 287
  if (mode == 114) {
#line 287
    goto case_114;
  }
#line 274
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 280
  tmp = getuid();
#line 280
  seteuid(tmp);
#line 281
  tmp___0 = getgid();
#line 281
  setegid(tmp___0);
  }
#line 282
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 284
  (r->h)->euid = geteuid();
#line 285
  (r->h)->egid = getegid();
  }
#line 286
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 288
  seteuid((r->h)->euid);
#line 289
  setegid((r->h)->egid);
  }
#line 290
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 305
  return;
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_window_calc(rxvt_t *r , unsigned int width , unsigned int height ) 
{ 
  short recalc_x ;
  short recalc_y ;
  int x ;
  int y ;
  int sb_w ;
  int mb_h ;
  int flags ;
  unsigned int w ;
  unsigned int h ;
  unsigned int max_width ;
  unsigned int max_height ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 399
  r->szHint.flags = (((1L << 4) | (1L << 6)) | (1L << 8)) | (1L << 9);
#line 400
  r->szHint.win_gravity = 1;
#line 403
  recalc_y = (short)0;
#line 403
  recalc_x = recalc_y;
#line 404
  flags = 0;
#line 405
  if (! (r->h)->parsed_geometry) {
#line 406
    (r->h)->parsed_geometry = (unsigned char)1;
#line 407
    if ((r->h)->rs[3]) {
      {
#line 408
      flags = XParseGeometry((r->h)->rs[3], & x, & y, & w, & h);
      }
    }
#line 409
    if (flags & 4) {
#line 410
      if (w <= 0U) {
#line 410
        tmp___0 = 0U;
      } else {
#line 410
        if (w < (unsigned int )(65535 >> 1)) {
#line 410
          tmp = w;
        } else {
#line 410
          tmp = (unsigned int )(65535 >> 1);
        }
#line 410
        tmp___0 = tmp;
      }
#line 410
      r->TermWin.ncol = (u_int16_t )((int16_t )tmp___0);
#line 411
      r->szHint.flags |= 1L << 1;
    }
#line 413
    if (flags & 8) {
#line 414
      if (h <= 0U) {
#line 414
        tmp___2 = 0U;
      } else {
#line 414
        if (h < (unsigned int )(65535 >> 1)) {
#line 414
          tmp___1 = h;
        } else {
#line 414
          tmp___1 = (unsigned int )(65535 >> 1);
        }
#line 414
        tmp___2 = tmp___1;
      }
#line 414
      r->TermWin.nrow = (u_int16_t )((int16_t )tmp___2);
#line 415
      r->szHint.flags |= 1L << 1;
    }
#line 417
    if (flags & 1) {
#line 418
      r->szHint.x = x;
#line 419
      r->szHint.flags |= 1L;
#line 420
      if (flags & 16) {
#line 421
        recalc_x = (short)1;
#line 422
        r->szHint.win_gravity = 3;
      }
    }
#line 425
    if (flags & 2) {
#line 426
      r->szHint.y = y;
#line 427
      r->szHint.flags |= 1L;
#line 428
      if (flags & 32) {
#line 429
        recalc_y = (short)1;
#line 430
        if (r->szHint.win_gravity == 3) {
#line 431
          r->szHint.win_gravity = 9;
        } else {
#line 433
          r->szHint.win_gravity = 7;
        }
      }
    }
  }
#line 438
  r->TermWin.width = (u_int16_t )((int )r->TermWin.ncol * (int )r->TermWin.fwidth);
#line 439
  r->TermWin.height = (u_int16_t )((int )r->TermWin.nrow * (int )r->TermWin.fheight);
#line 440
  max_width = (unsigned int )(1000 * (int )r->TermWin.fwidth);
#line 441
  max_height = (unsigned int )(1000 * (int )r->TermWin.fheight);
#line 443
  tmp___3 = 2 * (int )r->TermWin.int_bwidth;
#line 443
  r->szHint.base_height = tmp___3;
#line 443
  r->szHint.base_width = tmp___3;
#line 445
  mb_h = 0;
#line 445
  sb_w = mb_h;
#line 446
  tmp___4 = 0;
#line 446
  (r->h)->window_vt_y = tmp___4;
#line 446
  (r->h)->window_vt_x = tmp___4;
#line 447
  if (r->scrollBar.state) {
#line 448
    sb_w = 0;
#line 449
    r->szHint.base_width += sb_w;
#line 450
    if (! (r->Options & (1UL << 8))) {
#line 451
      (r->h)->window_vt_x = sb_w;
    }
  }
#line 453
  if (r->menuBar.state) {
#line 454
    mb_h = 0;
#line 455
    r->szHint.base_height += mb_h;
#line 456
    (r->h)->window_vt_y = mb_h;
  }
#line 458
  r->szHint.width_inc = (int )r->TermWin.fwidth;
#line 459
  r->szHint.height_inc = (int )r->TermWin.fheight;
#line 460
  r->szHint.min_width = r->szHint.base_width + r->szHint.width_inc;
#line 461
  r->szHint.min_height = r->szHint.base_height + r->szHint.height_inc;
#line 463
  if (width) {
#line 463
    if (width - (unsigned int )r->szHint.base_width < max_width) {
#line 464
      r->szHint.width = (int )width;
#line 465
      r->TermWin.width = (u_int16_t )(width - (unsigned int )r->szHint.base_width);
    } else {
#line 463
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 467
    if (max_width < (unsigned int )r->TermWin.width) {
#line 467
      r->TermWin.width = (u_int16_t )max_width;
    }
#line 468
    r->szHint.width = r->szHint.base_width + (int )r->TermWin.width;
  }
#line 470
  if (height) {
#line 470
    if (height - (unsigned int )r->szHint.base_height < max_height) {
#line 471
      r->szHint.height = (int )height;
#line 472
      r->TermWin.height = (u_int16_t )(height - (unsigned int )r->szHint.base_height);
    } else {
#line 470
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 474
    if (max_height < (unsigned int )r->TermWin.height) {
#line 474
      r->TermWin.height = (u_int16_t )max_height;
    }
#line 475
    r->szHint.height = r->szHint.base_height + (int )r->TermWin.height;
  }
#line 477
  if (r->scrollBar.state) {
#line 477
    if (r->Options & (1UL << 8)) {
#line 478
      (r->h)->window_sb_x = r->szHint.width - sb_w;
    }
  }
#line 480
  if (recalc_x) {
#line 481
    r->szHint.x += ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->width - r->szHint.width) - 2 * (int )r->TermWin.ext_bwidth;
  }
#line 483
  if (recalc_y) {
#line 484
    r->szHint.y += ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->height - r->szHint.height) - 2 * (int )r->TermWin.ext_bwidth;
  }
#line 487
  r->TermWin.ncol = (u_int16_t )((int )r->TermWin.width / (int )r->TermWin.fwidth);
#line 488
  r->TermWin.nrow = (u_int16_t )((int )r->TermWin.height / (int )r->TermWin.fheight);
#line 489
  return;
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_tt_winsize(int fd , unsigned short col , unsigned short row ) 
{ 
  struct winsize ws ;

  {
#line 503
  if (fd < 0) {
#line 504
    return;
  }
  {
#line 505
  ws.ws_col = col;
#line 506
  ws.ws_row = row;
#line 507
  ws.ws_ypixel = (unsigned short)0;
#line 507
  ws.ws_xpixel = ws.ws_ypixel;
#line 508
  ioctl(fd, 21524UL, & ws);
  }
#line 509
  return;
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_change_font(rxvt_t *r , int init , char const   *fontname ) 
{ 
  char const   *msg ;
  int fh ;
  int fw ;
  int recheckfonts ;
  int pf ;
  int idx ;
  XFontStruct *xfont ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *name ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
#line 523
  msg = "can\'t load font \"%s\"";
#line 526
  idx = 0;
#line 537
  if (! init) {
#line 538
    pf = (r->h)->fnum;
    {
#line 540
    if ((int const   )*(fontname + 0) == 0) {
#line 540
      goto case_0;
    }
#line 546
    if ((int const   )*(fontname + 0) == 35) {
#line 546
      goto case_35;
    }
#line 568
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 541
    (r->h)->fnum = 2;
#line 542
    fontname = (char const   *)((void *)0);
#line 543
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 547
    idx = atoi(fontname + 1);
    }
    {
#line 549
    if ((int const   )*(fontname + 1) == 43) {
#line 549
      goto case_43;
    }
#line 553
    if ((int const   )*(fontname + 1) == 45) {
#line 553
      goto case_45;
    }
#line 557
    goto switch_default;
    case_43: /* CIL Label */ 
#line 550
    if (idx) {
#line 550
      tmp = idx;
    } else {
#line 550
      tmp = 1;
    }
    {
#line 550
    rxvt_font_up_down(r, tmp, 1);
    }
#line 551
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 554
    if (idx) {
#line 554
      tmp___0 = idx;
    } else {
#line 554
      tmp___0 = 1;
    }
    {
#line 554
    rxvt_font_up_down(r, tmp___0, -1);
    }
#line 555
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 558
    if ((int const   )*(fontname + 1) != 0) {
      {
#line 558
      tmp___1 = __ctype_b_loc();
      }
#line 558
      if (! ((int const   )*(*tmp___1 + (int )*(fontname + 1)) & 2048)) {
#line 559
        return;
      }
    }
#line 560
    if (idx < 0) {
#line 561
      return;
    } else
#line 560
    if (idx >= 7) {
#line 561
      return;
    }
#line 562
    if (idx == 0) {
#line 562
      (r->h)->fnum = 2;
    } else {
#line 562
      if (idx <= 2) {
#line 562
        tmp___2 = idx - 1;
      } else {
#line 562
        tmp___2 = idx;
      }
#line 562
      (r->h)->fnum = tmp___2;
    }
#line 563
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 565
    fontname = (char const   *)((void *)0);
#line 566
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 569
    if ((unsigned long )fontname == (unsigned long )((void *)0)) {
#line 570
      return;
    } else {
#line 573
      idx = 0;
      {
#line 573
      while (1) {
        while_continue: /* CIL Label */ ;
#line 573
        if (! (idx < 7)) {
#line 573
          goto while_break;
        }
#line 574
        if ((unsigned long )(r->h)->rs[30 + idx] == (unsigned long )((void *)0)) {

        }
#line 573
        idx ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 575
    tmp___4 = strcmp((r->h)->rs[30 + idx], fontname);
    }
#line 575
    if (! tmp___4) {
#line 576
      if (idx == 0) {
#line 576
        (r->h)->fnum = 2;
      } else {
#line 576
        if (idx <= 2) {
#line 576
          tmp___3 = idx - 1;
        } else {
#line 576
          tmp___3 = idx;
        }
#line 576
        (r->h)->fnum = tmp___3;
      }
#line 577
      fontname = (char const   *)((void *)0);
#line 578
      goto switch_break;
    }
#line 580
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 583
    if ((r->h)->fnum == 2) {
#line 583
      idx = 0;
    } else {
#line 583
      if ((r->h)->fnum < 2) {
#line 583
        tmp___5 = (r->h)->fnum + 1;
      } else {
#line 583
        tmp___5 = (r->h)->fnum;
      }
#line 583
      idx = tmp___5;
    }
#line 585
    if (pf == (r->h)->fnum) {
#line 586
      return;
    }
#line 588
    if ((unsigned long )fontname != (unsigned long )((void *)0)) {
      {
#line 591
      xfont = XLoadQueryFont(r->Xdisplay, fontname);
      }
#line 592
      if (! xfont) {
#line 593
        return;
      }
      {
#line 595
      tmp___6 = strlen(fontname + 1);
#line 595
      tmp___7 = rxvt_malloc(tmp___6 * sizeof(char ));
#line 595
      name = (char *)tmp___7;
      }
#line 597
      if ((unsigned long )name == (unsigned long )((void *)0)) {
        {
#line 598
        XFreeFont(r->Xdisplay, xfont);
        }
#line 599
        return;
      }
      {
#line 601
      strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)fontname);
      }
#line 602
      if ((unsigned long )(r->h)->newfont[idx] != (unsigned long )((void *)0)) {
        {
#line 603
        free((void *)(r->h)->newfont[idx]);
        }
      }
#line 604
      (r->h)->newfont[idx] = name;
#line 605
      (r->h)->rs[30 + idx] = (char const   *)(r->h)->newfont[idx];
    }
  }
#line 608
  if (r->TermWin.font) {
    {
#line 609
    XFreeFont(r->Xdisplay, r->TermWin.font);
    }
  }
  {
#line 612
  xfont = XLoadQueryFont(r->Xdisplay, (r->h)->rs[30 + idx]);
  }
#line 613
  if (! xfont) {
    {
#line 614
    rxvt_print_error(msg, (r->h)->rs[30 + idx]);
#line 615
    (r->h)->rs[30 + idx] = "fixed";
#line 616
    xfont = XLoadQueryFont(r->Xdisplay, "fixed");
    }
#line 617
    if (! xfont) {
      {
#line 618
      rxvt_print_error(msg, "fixed");
      }
#line 619
      goto Abort;
    }
  }
#line 622
  r->TermWin.font = xfont;
#line 626
  if (init) {
#line 626
    if ((unsigned long )(r->h)->rs[39] != (unsigned long )((void *)0)) {
      {
#line 627
      r->TermWin.boldFont_loaded = XLoadQueryFont(r->Xdisplay, (r->h)->rs[39]);
      }
    }
  }
#line 632
  if (! init) {
    {
#line 633
    XSetFont(r->Xdisplay, r->TermWin.gc, (r->TermWin.font)->fid);
    }
  }
#line 636
  fw = (int )(r->TermWin.font)->max_bounds.width;
#line 637
  fh = ((r->TermWin.font)->ascent + (r->TermWin.font)->descent) + (int )r->TermWin.lineSpace;
#line 639
  if (fw == (int )(r->TermWin.font)->min_bounds.width) {
#line 640
    r->TermWin.propfont = (u_int16_t )((int )r->TermWin.propfont & -2);
  } else {
#line 642
    r->TermWin.propfont = (u_int16_t )((int )r->TermWin.propfont | 1);
  }
#line 643
  if (fw == (int )r->TermWin.fwidth) {
#line 643
    if (fh == (int )r->TermWin.fheight) {
#line 643
      tmp___8 = 0;
    } else {
#line 643
      tmp___8 = 1;
    }
  } else {
#line 643
    tmp___8 = 1;
  }
#line 643
  recheckfonts = tmp___8;
#line 644
  r->TermWin.fwidth = (u_int16_t )fw;
#line 645
  r->TermWin.fheight = (u_int16_t )fh;
#line 646
  r->TermWin.fascent = (u_int16_t )(r->TermWin.font)->ascent;
#line 647
  r->TermWin.fdescent = (u_int16_t )(r->TermWin.font)->descent;
#line 648
  r->TermWin.fontdiff = (u_int16_t )0;
#line 652
  if (recheckfonts) {
#line 653
    r->TermWin.boldFont = (XFontStruct *)((void *)0);
#line 654
    if ((unsigned long )r->TermWin.boldFont_loaded != (unsigned long )((void *)0)) {
#line 655
      fw = (int )(r->TermWin.boldFont_loaded)->max_bounds.width;
#line 656
      fh = (r->TermWin.boldFont_loaded)->ascent + (r->TermWin.boldFont_loaded)->descent;
#line 658
      if (fw <= (int )r->TermWin.fwidth) {
#line 658
        if (fh <= (int )r->TermWin.fheight) {
#line 659
          r->TermWin.boldFont = r->TermWin.boldFont_loaded;
        }
      }
#line 660
      if (fw == (int )r->TermWin.fwidth) {
#line 661
        r->TermWin.propfont = (u_int16_t )((int )r->TermWin.propfont & ~ (1 << 1));
      } else {
#line 663
        r->TermWin.propfont = (u_int16_t )((int )r->TermWin.propfont | (1 << 1));
      }
    }
  }
  {
#line 745
  rxvt_set_colorfgbg(r);
  }
#line 747
  if (! init) {
    {
#line 748
    rxvt_resize_all_windows(r, 0U, 0U, 0);
#line 749
    rxvt_scr_touch(r, 1);
    }
  }
#line 751
  return;
  Abort: 
  {
#line 753
  rxvt_print_error("aborting");
#line 754
  exit(1);
  }
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_font_up_down(rxvt_t *r , int n , int direction ) 
{ 
  char const   *p ;
  int initial ;
  int j ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 764
  j = 0;
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    if (! (j < n)) {
#line 764
      goto while_break;
    }
#line 765
    initial = (r->h)->fnum;
    {
#line 766
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 767
      (r->h)->fnum += direction;
#line 768
      if ((r->h)->fnum == 7) {
#line 769
        (r->h)->fnum = initial;
#line 770
        return;
      } else
#line 768
      if ((r->h)->fnum == -1) {
#line 769
        (r->h)->fnum = initial;
#line 770
        return;
      }
#line 772
      if ((r->h)->fnum == 2) {
#line 772
        tmp___0 = 0;
      } else {
#line 772
        if ((r->h)->fnum < 2) {
#line 772
          tmp = (r->h)->fnum + 1;
        } else {
#line 772
          tmp = (r->h)->fnum;
        }
#line 772
        tmp___0 = tmp;
      }
#line 772
      p = (r->h)->rs[30 + tmp___0];
#line 773
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 773
        tmp___1 = strlen(p);
        }
#line 773
        if (tmp___1 > 1UL) {
#line 774
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 764
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 777
  return;
}
}
#line 804 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_set_title(rxvt_t *r , char const   *str ) 
{ 
  char *name ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 812
  tmp = XFetchName(r->Xdisplay, r->TermWin.parent[0], & name);
  }
#line 812
  if (tmp == 0) {
#line 813
    name = (char *)((void *)0);
  }
#line 814
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 815
    XStoreName(r->Xdisplay, r->TermWin.parent[0], str);
    }
  } else {
    {
#line 814
    tmp___0 = strcmp((char const   *)name, str);
    }
#line 814
    if (tmp___0) {
      {
#line 815
      XStoreName(r->Xdisplay, r->TermWin.parent[0], str);
      }
    }
  }
#line 816
  if (name) {
    {
#line 817
    XFree((void *)name);
    }
  }
#line 819
  return;
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_set_iconName(rxvt_t *r , char const   *str ) 
{ 
  char *name ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 830
  tmp = XGetIconName(r->Xdisplay, r->TermWin.parent[0], & name);
  }
#line 830
  if (tmp) {
#line 831
    name = (char *)((void *)0);
  }
#line 832
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 833
    XSetIconName(r->Xdisplay, r->TermWin.parent[0], str);
    }
  } else {
    {
#line 832
    tmp___0 = strcmp((char const   *)name, str);
    }
#line 832
    if (tmp___0) {
      {
#line 833
      XSetIconName(r->Xdisplay, r->TermWin.parent[0], str);
      }
    }
  }
#line 834
  if (name) {
    {
#line 835
    XFree((void *)name);
    }
  }
#line 837
  return;
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_set_window_color(rxvt_t *r , int idx , char const   *color ) 
{ 
  XColor xcol ;
  int i ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 847
  if ((unsigned long )color == (unsigned long )((void *)0)) {
#line 848
    return;
  } else
#line 847
  if ((int const   )*color == 0) {
#line 848
    return;
  }
  {
#line 851
  tmp = __ctype_b_loc();
  }
#line 851
  if ((int const   )*(*tmp + (int )*color) & 2048) {
    {
#line 852
    i = atoi(color);
    }
#line 853
    if (i >= 8) {
#line 853
      if (i <= 15) {
#line 854
        i -= 8;
#line 856
        *(r->PixColors + idx) = *(r->PixColors + (10 + i));
#line 857
        (r->h)->pixcolor_set[idx / 32] |= (unsigned int )(1 << idx % 32);
#line 858
        goto Done;
      }
    }
#line 861
    if (i >= 0) {
#line 861
      if (i <= 7) {
#line 862
        *(r->PixColors + idx) = *(r->PixColors + (2 + i));
#line 863
        (r->h)->pixcolor_set[idx / 32] |= (unsigned int )(1 << idx % 32);
#line 864
        goto Done;
      }
    }
  }
  {
#line 867
  tmp___0 = rxvt_rXParseAllocColor(r, & xcol, color);
  }
#line 867
  if (! tmp___0) {
#line 868
    return;
  }
#line 886
  *(r->PixColors + idx) = xcol.pixel;
#line 887
  (r->h)->pixcolor_set[idx / 32] |= (unsigned int )(1 << idx % 32);
  Done: 
#line 892
  if (idx == 1) {
#line 892
    if (! (r->Options & (1UL << 13))) {
      {
#line 893
      XSetWindowBackground(r->Xdisplay, r->TermWin.vt, *(r->PixColors + 1));
      }
    }
  }
  {
#line 898
  rxvt_set_colorfgbg(r);
#line 899
  rxvt_recolour_cursor(r);
#line 901
  rxvt_scr_touch(r, 0);
  }
#line 902
  return;
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_recolour_cursor(rxvt_t *r ) 
{ 
  XColor xcol[2] ;

  {
  {
#line 914
  xcol[0].pixel = *(r->PixColors + 20);
#line 915
  xcol[1].pixel = *(r->PixColors + 1);
#line 916
  XQueryColors(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
               xcol, 2);
#line 917
  XRecolorCursor(r->Xdisplay, r->TermWin_cursor, & xcol[0], & xcol[1]);
  }
#line 918
  return;
}
}
#line 925 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_set_colorfgbg(rxvt_t *r ) 
{ 
  unsigned int i ;
  char const   *xpmb ;
  char fstr[sizeof("default") + 1UL] ;
  char bstr[sizeof("default") + 1UL] ;
  void *tmp ;

  {
  {
#line 929
  xpmb = "\000";
#line 932
  tmp = rxvt_malloc(sizeof("COLORFGBG=default;default;bg") + 1UL);
#line 932
  (r->h)->env_colorfgbg = (char *)tmp;
#line 934
  strcpy((char */* __restrict  */)(fstr), (char const   */* __restrict  */)"default");
#line 935
  strcpy((char */* __restrict  */)(bstr), (char const   */* __restrict  */)"default");
#line 936
  i = 2U;
  }
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 936
    if (! (i <= 17U)) {
#line 936
      goto while_break;
    }
#line 937
    if (*(r->PixColors + 0) == *(r->PixColors + i)) {
      {
#line 938
      sprintf((char */* __restrict  */)(fstr), (char const   */* __restrict  */)"%d",
              i - 2U);
      }
#line 939
      goto while_break;
    }
#line 936
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 941
  i = 2U;
  {
#line 941
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 941
    if (! (i <= 17U)) {
#line 941
      goto while_break___0;
    }
#line 942
    if (*(r->PixColors + 1) == *(r->PixColors + i)) {
      {
#line 943
      sprintf((char */* __restrict  */)(bstr), (char const   */* __restrict  */)"%d",
              i - 2U);
      }
#line 947
      goto while_break___0;
    }
#line 941
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 949
  sprintf((char */* __restrict  */)(r->h)->env_colorfgbg, (char const   */* __restrict  */)"COLORFGBG=%s;%s%s",
          fstr, xpmb, bstr);
#line 950
  putenv((r->h)->env_colorfgbg);
#line 953
  (r->h)->colorfgbg = (unsigned int )(1 << 5);
#line 954
  i = 2U;
  }
  {
#line 954
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 954
    if (! (i <= 9U)) {
#line 954
      goto while_break___1;
    }
#line 955
    if (*(r->PixColors + 0) == *(r->PixColors + i)) {
#line 955
      if (*(r->PixColors + 0) == *(r->PixColors + 22)) {
#line 964
        (r->h)->colorfgbg = ((r->h)->colorfgbg & 4294967264U) | i;
      }
    }
#line 965
    if (*(r->PixColors + 1) == *(r->PixColors + i)) {
#line 966
      (r->h)->colorfgbg = ((r->h)->colorfgbg & 4294966303U) | (i << 5);
    }
#line 954
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 969
  return;
}
}
#line 978 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
int rxvt_rXParseAllocColor(rxvt_t *r , XColor *screen_in_out , char const   *colour ) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 981
  res = 0;
#line 983
  tmp = XParseColor(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                    colour, screen_in_out);
  }
#line 983
  if (tmp) {
    {
#line 986
    res = rxvt_rXAllocColor(r, screen_in_out, colour);
    }
  } else {
    {
#line 984
    rxvt_print_error("can\'t determine colour: %s", colour);
    }
  }
#line 987
  return (res);
}
}
#line 991 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
int rxvt_rXAllocColor(rxvt_t *r , XColor *screen_in_out , char const   *colour ) 
{ 
  int res ;
  int i ;
  int numcol ;
  int best_pixel ;
  unsigned long best_diff ;
  unsigned long diff ;
  XColor *colors ;
  void *tmp ;

  {
  {
#line 996
  res = XAllocColor(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                    screen_in_out);
  }
#line 996
  if (res) {
#line 997
    return (res);
  }
#line 1000
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth >= 4) {
#line 1000
    if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 8) {
      {
#line 1002
      best_pixel = 0;
#line 1008
      best_diff = 0UL;
#line 1009
      numcol = 1 << (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth;
#line 1010
      tmp = rxvt_malloc((unsigned long )numcol * sizeof(XColor ));
#line 1010
      colors = (XColor *)tmp;
      }
#line 1010
      if (colors) {
#line 1011
        i = 0;
        {
#line 1011
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1011
          if (! (i < numcol)) {
#line 1011
            goto while_break;
          }
#line 1012
          (colors + i)->pixel = (unsigned long )i;
#line 1011
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1014
        XQueryColors(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                     colors, numcol);
#line 1015
        i = 0;
        }
        {
#line 1015
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1015
          if (! (i < numcol)) {
#line 1015
            goto while_break___0;
          }
#line 1016
          diff = (unsigned long )((((int )screen_in_out->red - (int )(colors + i)->red) * ((int )screen_in_out->red - (int )(colors + i)->red) + ((int )screen_in_out->green - (int )(colors + i)->green) * ((int )screen_in_out->green - (int )(colors + i)->green)) + ((int )screen_in_out->blue - (int )(colors + i)->blue) * ((int )screen_in_out->blue - (int )(colors + i)->blue));
#line 1019
          if (i == 0) {
#line 1020
            best_pixel = (int )(colors + i)->pixel;
#line 1021
            best_diff = diff;
          } else
#line 1019
          if (diff < best_diff) {
#line 1020
            best_pixel = (int )(colors + i)->pixel;
#line 1021
            best_diff = diff;
          }
#line 1015
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1024
        *screen_in_out = *(colors + best_pixel);
#line 1025
        free((void *)colors);
#line 1026
        res = XAllocColor(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                          screen_in_out);
        }
      }
    }
  }
#line 1029
  if (res == 0) {
    {
#line 1030
    rxvt_print_error("can\'t allocate colour: %s", colour);
    }
  }
#line 1031
  return (res);
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_resize_all_windows(rxvt_t *r , unsigned int width , unsigned int height ,
                             int ignoreparent ) 
{ 
  int fix_screen ;
  int tmp ;
  int curr_screen ;
  u_int16_t old_ncol ;
  int tmp___0 ;

  {
  {
#line 1047
  rxvt_window_calc(r, width, height);
#line 1048
  XSetWMNormalHints(r->Xdisplay, r->TermWin.parent[0], & r->szHint);
  }
#line 1049
  if (! ignoreparent) {
    {
#line 1091
    XResizeWindow(r->Xdisplay, r->TermWin.parent[0], (unsigned int )r->szHint.width,
                  (unsigned int )r->szHint.height);
    }
  }
#line 1096
  if ((int )r->TermWin.ncol != (int )(r->h)->prev_ncol) {
#line 1096
    tmp = 1;
  } else
#line 1096
  if ((int )r->TermWin.nrow != (int )(r->h)->prev_nrow) {
#line 1096
    tmp = 1;
  } else {
#line 1096
    tmp = 0;
  }
#line 1096
  fix_screen = tmp;
#line 1098
  if (fix_screen) {
#line 1098
    goto _L;
  } else
#line 1098
  if (width != (r->h)->old_width) {
#line 1098
    goto _L;
  } else
#line 1098
  if (height != (r->h)->old_height) {
    _L: /* CIL Label */ 
#line 1099
    if (r->scrollBar.state) {
      {
#line 1100
      XMoveResizeWindow(r->Xdisplay, r->scrollBar.win, (r->h)->window_sb_x, 0, 0U,
                        (unsigned int )r->szHint.height);
#line 1102
      rxvt_Resize_scrollBar(r);
      }
    }
#line 1104
    if (r->menuBar.state) {
      {
#line 1105
      XMoveResizeWindow(r->Xdisplay, r->menuBar.win, (r->h)->window_vt_x, 0, (unsigned int )((int32_t )r->TermWin.width + 2 * (int32_t )r->TermWin.int_bwidth),
                        0U);
      }
    }
    {
#line 1107
    XMoveResizeWindow(r->Xdisplay, r->TermWin.vt, (r->h)->window_vt_x, (r->h)->window_vt_y,
                      (unsigned int )((int32_t )r->TermWin.width + 2 * (int32_t )r->TermWin.int_bwidth),
                      (unsigned int )((int32_t )r->TermWin.height + 2 * (int32_t )r->TermWin.int_bwidth));
#line 1115
    rxvt_scr_clear(r);
    }
  }
#line 1119
  if (fix_screen) {
#line 1119
    goto _L___0;
  } else
#line 1119
  if ((r->h)->old_height == 0U) {
    _L___0: /* CIL Label */ 
#line 1120
    curr_screen = -1;
#line 1121
    old_ncol = (r->h)->prev_ncol;
#line 1124
    if ((r->h)->old_height) {
      {
#line 1125
      curr_screen = rxvt_scr_change_screen(r, 0);
      }
    }
    {
#line 1126
    rxvt_scr_reset(r);
    }
#line 1127
    if (curr_screen >= 0) {
      {
#line 1128
      rxvt_scr_change_screen(r, curr_screen);
      }
#line 1129
      if ((int )old_ncol != (int )r->TermWin.ncol) {
#line 1129
        tmp___0 = 4;
      } else {
#line 1129
        tmp___0 = 0;
      }
      {
#line 1129
      rxvt_selection_check(r, tmp___0);
      }
    }
  }
#line 1133
  (r->h)->old_width = (unsigned int )r->szHint.width;
#line 1134
  (r->h)->old_height = (unsigned int )r->szHint.height;
#line 1139
  return;
}
}
#line 1146 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_set_widthheight(rxvt_t *r , unsigned int width , unsigned int height ) 
{ 
  XWindowAttributes wattr ;

  {
#line 1151
  if (width == 0U) {
#line 1151
    goto _L;
  } else
#line 1151
  if (height == 0U) {
    _L: /* CIL Label */ 
    {
#line 1152
    XGetWindowAttributes(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                         & wattr);
    }
#line 1153
    if (width == 0U) {
#line 1154
      width = (unsigned int )(wattr.width - r->szHint.base_width);
    }
#line 1155
    if (height == 0U) {
#line 1156
      height = (unsigned int )(wattr.height - r->szHint.base_height);
    }
  }
#line 1158
  if (width != (unsigned int )r->TermWin.width) {
    {
#line 1159
    width += (unsigned int )r->szHint.base_width;
#line 1160
    height += (unsigned int )r->szHint.base_height;
#line 1161
    rxvt_resize_all_windows(r, width, height, 0);
    }
  } else
#line 1158
  if (height != (unsigned int )r->TermWin.height) {
    {
#line 1159
    width += (unsigned int )r->szHint.base_width;
#line 1160
    height += (unsigned int )r->szHint.base_height;
#line 1161
    rxvt_resize_all_windows(r, width, height, 0);
    }
  }
#line 1163
  return;
}
}
#line 1544 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
static rxvt_t *_rxvt_vars  =    (rxvt_t *)((void *)0);
#line 1547 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
rxvt_t *rxvt_get_r(void) 
{ 


  {
#line 1550
  return (_rxvt_vars);
}
}
#line 1553 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/main.c"
void rxvt_set_r(rxvt_t *r ) 
{ 


  {
#line 1556
  _rxvt_vars = r;
#line 1557
  return;
}
}
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 1435 "/usr/include/X11/Xlib.h"
extern XModifierKeymap *XGetModifierMapping(Display * ) ;
#line 1495
extern Display *XOpenDisplay(char const   * ) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1588
extern Cursor XCreateFontCursor(Display * , unsigned int  ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 1698
extern KeySym __attribute__((__deprecated__))  XKeycodeToKeysym(Display * , KeyCode  ,
                                                                int  ) ;
#line 1827
extern char *XDisplayString(Display * ) ;
#line 1900
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 2183
extern int XConnectionNumber(Display * ) ;
#line 2243
extern int XDefineCursor(Display * , Window  , Cursor  ) ;
#line 2578
extern int XFreeModifiermap(XModifierKeymap * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 665 "/usr/include/X11/Xutil.h"
extern void XSetWMProperties(Display * , Window  , XTextProperty * , XTextProperty * ,
                             char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 54 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.extpro"
void rxvt_xterm_seq(rxvt_t *r , int op , char const   *str , unsigned char resp ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.extpro"
void rxvt_set_defaultfont(rxvt_t *r , char const   **rs ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.extpro"
char *rxvt_r_basename(char const   *str ) ;
#line 5
char *rxvt_Str_trim(char *str ) ;
#line 6
int rxvt_Str_escaped(char *str ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/ptytty.extpro"
int rxvt_get_pty(int *fd_tty , char const   **ttydev ) ;
#line 2
int rxvt_get_tty(char const   *ttydev ) ;
#line 3
int rxvt_control_tty(int fd_tty , char const   *ttydev ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.extpro"
void rxvt_get_options(rxvt_t *r , int argc , char const   * const  *argv ) ;
#line 3
void rxvt_extract_resources(rxvt_t *r , Display *display , char const   *name ) ;
#line 124 "/usr/include/locale.h"
extern char *setlocale(int __category , char const   *__locale ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.intpro"
void rxvt_Get_Colours(rxvt_t *r ) ;
#line 3
void rxvt_color_aliases(rxvt_t *r , int idx ) ;
#line 4
void rxvt_get_ourmods(rxvt_t *r ) ;
#line 5
int rxvt_run_command(rxvt_t *r , char const   * const  *argv ) ;
#line 6
int rxvt_run_child(rxvt_t *r , char const   * const  *argv ) ;
#line 7
void rxvt_get_ttymode(ttymode_t *tio ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
char const   * const  def_colorName[25]  = 
#line 40 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
  {      (char const   */* const  */)"Black",      (char const   */* const  */)"White",      (char const   */* const  */)"Black",      (char const   */* const  */)"Red3", 
        (char const   */* const  */)"Green3",      (char const   */* const  */)"Yellow3",      (char const   */* const  */)"Blue3",      (char const   */* const  */)"Magenta3", 
        (char const   */* const  */)"Cyan3",      (char const   */* const  */)"Grey90",      (char const   */* const  */)"Grey30",      (char const   */* const  */)"Red", 
        (char const   */* const  */)"Green",      (char const   */* const  */)"Yellow",      (char const   */* const  */)"Blue",      (char const   */* const  */)"Magenta", 
        (char const   */* const  */)"Cyan",      (char const   */* const  */)"White",      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0)};
#line 333 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
char const   * const  xa_names[9]  = 
#line 333
  {      (char const   */* const  */)"COMPOUND_TEXT",      (char const   */* const  */)"MULTIPLE",      (char const   */* const  */)"TARGETS",      (char const   */* const  */)"TEXT", 
        (char const   */* const  */)"TIMESTAMP",      (char const   */* const  */)"VT_SELECTION",      (char const   */* const  */)"INCR",      (char const   */* const  */)"WM_DELETE_WINDOW", 
        (char const   */* const  */)"CLIPBOARD"};
#line 367 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
int rxvt_init_vars(rxvt_t *r ) 
{ 
  struct rxvt_hidden *h ;
  struct rxvt_hidden *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  u_int16_t tmp___5 ;
  int32_t tmp___6 ;
  int tmp___7 ;

  {
  {
#line 373
  memset((void *)r, 0, sizeof(rxvt_t ));
#line 375
  tmp___0 = rxvt_calloc((size_t )1, sizeof(struct rxvt_hidden ));
#line 375
  tmp = (struct rxvt_hidden *)tmp___0;
#line 375
  r->h = tmp;
#line 375
  h = tmp;
#line 377
  tmp___1 = rxvt_malloc(sizeof(Pixel ) * 25UL);
#line 377
  r->PixColors = (Pixel *)tmp___1;
  }
#line 378
  if ((unsigned long )r->h == (unsigned long )((void *)0)) {
#line 379
    return (-1);
  } else
#line 378
  if ((unsigned long )r->PixColors == (unsigned long )((void *)0)) {
#line 379
    return (-1);
  }
#line 419
  h->MEvent.time = (Time )0L;
#line 420
  h->MEvent.button = 0U;
#line 421
  r->Options = ((1UL << 7) | (1UL << 11)) | (1UL << 18);
#line 422
  h->want_refresh = (unsigned char)1;
#line 423
  h->cmd_pid = -1;
#line 424
  tmp___3 = -1;
#line 424
  r->Xfd = tmp___3;
#line 424
  tmp___2 = tmp___3;
#line 424
  r->tty_fd = tmp___2;
#line 424
  r->cmd_fd = tmp___2;
#line 425
  tmp___4 = (((1UL << 5) | (1UL << 7)) | (1UL << 10)) | (1UL << 11);
#line 425
  h->SavedModes = tmp___4;
#line 425
  h->PrivateModes = tmp___4;
#line 426
  r->TermWin.focus = (u_int16_t )1;
#line 427
  r->TermWin.ncol = (u_int16_t )80;
#line 428
  r->TermWin.nrow = (u_int16_t )24;
#line 429
  r->TermWin.int_bwidth = (u_int16_t )2;
#line 430
  r->TermWin.ext_bwidth = (u_int16_t )0;
#line 431
  r->TermWin.lineSpace = (u_int16_t )0;
#line 432
  r->TermWin.saveLines = (u_int16_t )64;
#line 433
  r->numPixColors = (short)25;
#line 435
  r->selection_style = (sstyle_t )2;
#line 440
  h->colorfgbg = (unsigned int )(1 << 5);
#line 449
  h->refresh_limit = 1;
#line 450
  h->refresh_type = (unsigned char )(1 << 1);
#line 451
  tmp___5 = (u_int16_t )0;
#line 451
  h->prev_ncol = tmp___5;
#line 451
  h->prev_nrow = tmp___5;
#line 458
  tmp___6 = -1;
#line 458
  h->oldcursor.col = tmp___6;
#line 458
  h->oldcursor.row = tmp___6;
#line 464
  tmp___7 = -1;
#line 464
  h->last_state = tmp___7;
#line 464
  h->last_bot = tmp___7;
#line 471
  return (0);
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
void rxvt_init_secondary(rxvt_t *r ) 
{ 


  {
  {
#line 487
  (r->h)->ttymode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
#line 488
  (r->h)->ttygid = getgid();
#line 491
  (r->h)->locale = setlocale(0, "");
  }
#line 493
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
char const   **rxvt_init_resources(rxvt_t *r , int argc , char const   * const  *argv ) 
{ 
  int i ;
  int r_argc ;
  char *val ;
  char const   **cmd_argv ;
  char const   **r_argv ;
  char const   **rs ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  Display *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *swapittmp ;

  {
#line 508
  r_argc = 0;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! (r_argc < argc)) {
#line 508
      goto while_break;
    }
    {
#line 509
    tmp = strcmp((char const   *)*(argv + r_argc), "-e");
    }
#line 509
    if (tmp) {
      {
#line 509
      tmp___0 = strcmp((char const   *)*(argv + r_argc), "-exec");
      }
#line 509
      if (! tmp___0) {
#line 510
        goto while_break;
      }
    } else {
#line 510
      goto while_break;
    }
#line 508
    r_argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  tmp___1 = rxvt_malloc(sizeof(char *) * (unsigned long )(r_argc + 1));
#line 511
  r_argv = (char const   **)tmp___1;
#line 513
  i = 0;
  }
  {
#line 513
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 513
    if (! (i < r_argc)) {
#line 513
      goto while_break___0;
    }
#line 514
    *(r_argv + i) = (char const   *)*(argv + i);
#line 513
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 515
  *(r_argv + i) = (char const   *)((void *)0);
#line 516
  if (r_argc == argc) {
#line 517
    cmd_argv = (char const   **)((void *)0);
  } else {
    {
#line 519
    tmp___2 = rxvt_malloc(sizeof(char *) * (unsigned long )(argc - r_argc));
#line 519
    cmd_argv = (char const   **)tmp___2;
#line 521
    i = 0;
    }
    {
#line 521
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 521
      if (! (i < (argc - r_argc) - 1)) {
#line 521
        goto while_break___1;
      }
#line 522
      *(cmd_argv + i) = (char const   *)*(argv + ((i + r_argc) + 1));
#line 521
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 523
    *(cmd_argv + i) = (char const   *)((void *)0);
  }
#line 527
  rs = (r->h)->rs;
#line 528
  i = 0;
  {
#line 528
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 528
    if (! (i < 60)) {
#line 528
      goto while_break___2;
    }
#line 529
    tmp___3 = i;
#line 529
    i ++;
#line 529
    *(rs + tmp___3) = (char const   *)((void *)0);
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 531
  tmp___4 = rxvt_r_basename((char const   *)*(argv + 0));
#line 531
  *(rs + 37) = (char const   *)tmp___4;
#line 535
  tmp___5 = getenv("DISPLAY");
#line 535
  *(rs + 0) = (char const   *)tmp___5;
#line 537
  rxvt_get_options(r, r_argc, (char const   * const  *)r_argv);
#line 538
  free((void *)r_argv);
  }
#line 550
  if ((unsigned long )r->Xdisplay == (unsigned long )((void *)0)) {
    {
#line 550
    tmp___7 = XOpenDisplay(*(rs + 0));
#line 550
    r->Xdisplay = tmp___7;
    }
#line 550
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 552
      if (*(rs + 0)) {
#line 552
        tmp___6 = *(rs + 0);
      } else {
#line 552
        tmp___6 = "as no -display option given and DISPLAY not set";
      }
      {
#line 552
      rxvt_print_error("can\'t open display %s", tmp___6);
#line 555
      exit(1);
      }
    }
  }
#line 557
  if ((unsigned long )*(rs + 0) == (unsigned long )((void *)0)) {
    {
#line 558
    tmp___8 = XDisplayString(r->Xdisplay);
#line 558
    *(rs + 0) = (char const   *)tmp___8;
    }
  }
  {
#line 560
  rxvt_extract_resources(r, r->Xdisplay, *(rs + 37));
  }
#line 565
  if (cmd_argv) {
#line 565
    if (*(cmd_argv + 0)) {
#line 566
      if (! *(rs + 38)) {
        {
#line 567
        tmp___9 = rxvt_r_basename(*(cmd_argv + 0));
#line 567
        *(rs + 38) = (char const   *)tmp___9;
        }
      }
#line 568
      if (! *(rs + 2)) {
#line 569
        *(rs + 2) = *(rs + 38);
      }
    } else {
#line 565
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 571
    if (! *(rs + 38)) {
#line 572
      *(rs + 38) = *(rs + 37);
    }
#line 573
    if (! *(rs + 2)) {
#line 574
      *(rs + 2) = *(rs + 37);
    }
  }
#line 576
  if (*(rs + 46)) {
    {
#line 576
    i = atoi(*(rs + 46));
    }
#line 576
    if (i >= 0) {
#line 577
      if (i <= 0) {
#line 577
        tmp___11 = 0;
      } else {
#line 577
        if (i < 65535 >> 1) {
#line 577
          tmp___10 = i;
        } else {
#line 577
          tmp___10 = 65535 >> 1;
        }
#line 577
        tmp___11 = tmp___10;
      }
#line 577
      r->TermWin.saveLines = (u_int16_t )((int16_t )tmp___11);
    }
  }
#line 590
  if (! r->TermWin.saveLines) {
#line 591
    r->Options &= ~ (1UL << 7);
  }
#line 594
  if (! *(rs + 54)) {
#line 595
    *(rs + 54) = "lpr";
  }
#line 597
  if (! *(rs + 56)) {
#line 598
    *(rs + 56) = "\"&\'()*,;<=>?@[\\]^`{|}~";
  }
#line 600
  if (! *(rs + 51)) {
#line 604
    (r->h)->key_backspace = "DEC";
  } else {
    {
#line 607
    val = strdup(*(rs + 51));
#line 608
    rxvt_Str_trim(val);
#line 609
    rxvt_Str_escaped(val);
#line 610
    (r->h)->key_backspace = (char const   *)val;
    }
  }
#line 614
  if (! *(rs + 52)) {
#line 618
    (r->h)->key_delete = "\033[3~";
  } else {
    {
#line 621
    val = strdup(*(rs + 52));
#line 622
    rxvt_Str_trim(val);
#line 623
    rxvt_Str_escaped(val);
#line 624
    (r->h)->key_delete = (char const   *)val;
    }
  }
#line 627
  if (*(rs + 58)) {
    {
#line 628
    rxvt_Str_trim((char *)*(rs + 58));
#line 629
    rxvt_Str_escaped((char *)*(rs + 58));
    }
  }
#line 632
  if (*(rs + 53)) {
    {
#line 633
    tmp___12 = strncasecmp(*(rs + 53), "oldword", (size_t )7);
    }
#line 633
    if (tmp___12 == 0) {
#line 634
      r->selection_style = (sstyle_t )1;
    }
  }
  {
#line 652
  rxvt_set_defaultfont(r, rs);
#line 664
  i = 0;
  }
  {
#line 664
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 664
    if (! (i < 25)) {
#line 664
      goto while_break___3;
    }
#line 665
    if (! *(rs + (5 + i))) {
#line 666
      *(rs + (5 + i)) = (char const   *)def_colorName[i];
    }
#line 664
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 670
  if (r->Options & (1UL << 5)) {
    {
#line 671
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 671
      swapittmp = *(rs + 5);
#line 671
      *(rs + 5) = *(rs + 6);
#line 671
      *(rs + 6) = swapittmp;
#line 671
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 675
  rxvt_color_aliases(r, 0);
#line 676
  rxvt_color_aliases(r, 1);
#line 678
  rxvt_color_aliases(r, 18);
#line 679
  rxvt_color_aliases(r, 19);
#line 681
  rxvt_color_aliases(r, 20);
#line 682
  rxvt_color_aliases(r, 21);
#line 684
  rxvt_color_aliases(r, 22);
#line 685
  rxvt_color_aliases(r, 23);
#line 686
  rxvt_color_aliases(r, 24);
  }
#line 689
  return (cmd_argv);
}
}
#line 694 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
void rxvt_init_env(rxvt_t *r ) 
{ 
  int i ;
  unsigned int u ;
  char *val ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 716
  val = XDisplayString(r->Xdisplay);
  }
#line 717
  if ((unsigned long )(r->h)->rs[0] == (unsigned long )((void *)0)) {
#line 718
    (r->h)->rs[0] = (char const   *)val;
  }
  {
#line 720
  tmp = strlen((char const   *)val);
#line 720
  i = (int )tmp;
#line 721
  tmp___0 = rxvt_malloc((unsigned long )(i + 9) * sizeof(char ));
#line 721
  (r->h)->env_display = (char *)tmp___0;
#line 723
  sprintf((char */* __restrict  */)(r->h)->env_display, (char const   */* __restrict  */)"DISPLAY=%s",
          val);
#line 727
  i = 0;
#line 727
  u = (unsigned int )r->TermWin.parent[0];
  }
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 727
    if (! u) {
#line 727
      goto while_break;
    }
#line 727
    u /= 10U;
#line 727
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  if (1 > i) {
#line 728
    i = 1;
  }
  {
#line 729
  tmp___1 = rxvt_malloc((unsigned long )(i + 10) * sizeof(char ));
#line 729
  (r->h)->env_windowid = (char *)tmp___1;
#line 731
  sprintf((char */* __restrict  */)(r->h)->env_windowid, (char const   */* __restrict  */)"WINDOWID=%u",
          (unsigned int )r->TermWin.parent[0]);
#line 741
  putenv((r->h)->env_display);
#line 742
  putenv((r->h)->env_windowid);
  }
#line 746
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
    {
#line 747
    putenv((char *)"COLORTERM=rxvt-mono");
    }
  } else {
    {
#line 749
    putenv((char *)"COLORTERM=rxvt");
    }
  }
#line 750
  if ((unsigned long )(r->h)->rs[1] != (unsigned long )((void *)0)) {
    {
#line 751
    tmp___2 = strlen((r->h)->rs[1]);
#line 751
    tmp___3 = rxvt_malloc((tmp___2 + 6UL) * sizeof(char ));
#line 751
    (r->h)->env_term = (char *)tmp___3;
#line 753
    sprintf((char */* __restrict  */)(r->h)->env_term, (char const   */* __restrict  */)"TERM=%s",
            (r->h)->rs[1]);
#line 754
    putenv((r->h)->env_term);
    }
  } else
#line 762
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
    {
#line 763
    putenv((char *)"TERM=xterm-m");
    }
  } else {
    {
#line 766
    putenv((char *)"TERM=xterm");
    }
  }
  {
#line 771
  unsetenv("LINES");
#line 772
  unsetenv("COLUMNS");
#line 773
  unsetenv("TERMCAP");
  }
#line 775
  return;
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
void rxvt_init_xlocale(rxvt_t *r ) 
{ 


  {
#line 812
  return;
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
void rxvt_init_command(rxvt_t *r , char const   * const  *argv ) 
{ 
  int i ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 825
  i = 0;
  {
#line 825
  while (1) {
    while_continue: /* CIL Label */ ;
#line 825
    if (! (i < 9)) {
#line 825
      goto while_break;
    }
    {
#line 826
    (r->h)->xa[i] = XInternAtom(r->Xdisplay, (char const   *)xa_names[i], 0);
#line 825
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 829
  XSetWMProtocols(r->Xdisplay, r->TermWin.parent[0], & (r->h)->xa[7], 1);
#line 839
  tmp = sysconf(4);
#line 839
  r->num_fds = (int )tmp;
  }
#line 845
  if (r->Options & (1UL << 10)) {
#line 845
    (r->h)->meta_char = (unsigned char)128;
  } else {
#line 845
    (r->h)->meta_char = (unsigned char)27;
  }
  {
#line 847
  rxvt_get_ourmods(r);
  }
#line 848
  if (! (r->Options & (1UL << 11))) {
#line 849
    (r->h)->PrivateModes |= 1UL << 16;
  }
#line 850
  if (r->Options & (1UL << 12)) {
#line 851
    (r->h)->PrivateModes |= 1UL << 17;
  }
#line 852
  if (! (r->Options & (1UL << 18))) {
#line 853
    (r->h)->PrivateModes |= 1UL << 18;
  }
  {
#line 855
  tmp___0 = strcmp((r->h)->key_backspace, "DEC");
  }
#line 855
  if (tmp___0 == 0) {
#line 856
    (r->h)->PrivateModes |= 1UL << 8;
  }
#line 859
  if (r->scrollBar.state) {
#line 860
    (r->h)->PrivateModes |= 1UL << 14;
#line 861
    (r->h)->SavedModes |= 1UL << 14;
  }
#line 863
  if (r->menuBar.state) {
#line 864
    (r->h)->PrivateModes |= 1UL << 15;
#line 865
    (r->h)->SavedModes |= 1UL << 15;
  }
  {
#line 869
  r->Xfd = XConnectionNumber(r->Xdisplay);
#line 871
  tmp___1 = rxvt_run_command(r, argv);
#line 871
  r->cmd_fd = tmp___1;
  }
#line 871
  if (tmp___1 < 0) {
    {
#line 872
    rxvt_print_error("aborting");
#line 873
    exit(1);
    }
  }
#line 875
  return;
}
}
#line 879 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
void rxvt_Get_Colours(rxvt_t *r ) 
{ 
  int i ;
  XColor xcol ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 884
  i = 0;
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 884
    if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
#line 884
      tmp___1 = 2;
    } else {
#line 884
      tmp___1 = 25;
    }
#line 884
    if (! (i < tmp___1)) {
#line 884
      goto while_break;
    }
#line 887
    if (! (r->h)->rs[5 + i]) {
#line 888
      goto __Cont;
    }
    {
#line 890
    tmp___0 = rxvt_rXParseAllocColor(r, & xcol, (r->h)->rs[5 + i]);
    }
#line 890
    if (! tmp___0) {
#line 892
      if (i < 2) {
#line 892
        if (r->Options & (1UL << 5)) {
#line 893
          (r->h)->rs[5 + i] = (char const   *)def_colorName[! i];
        } else {
#line 896
          (r->h)->rs[5 + i] = (char const   *)def_colorName[i];
        }
      } else {
#line 896
        (r->h)->rs[5 + i] = (char const   *)def_colorName[i];
      }
#line 897
      if (! (r->h)->rs[5 + i]) {
#line 898
        goto __Cont;
      }
      {
#line 899
      tmp = rxvt_rXParseAllocColor(r, & xcol, (r->h)->rs[5 + i]);
      }
#line 899
      if (! tmp) {
        {
#line 902
        if (i == 1) {
#line 902
          goto case_1;
        }
#line 902
        if (i == 0) {
#line 902
          goto case_1;
        }
#line 909
        if (i == 19) {
#line 909
          goto case_19;
        }
#line 913
        if (i == 20) {
#line 913
          goto case_20;
        }
#line 916
        goto switch_default;
        case_1: /* CIL Label */ 
        case_0: /* CIL Label */ 
        {
#line 904
        rxvt_print_error("aborting");
#line 905
        exit(1);
        }
#line 907
        goto switch_break;
        case_19: /* CIL Label */ 
#line 910
        xcol.pixel = *(r->PixColors + 0);
#line 911
        goto switch_break;
        case_20: /* CIL Label */ 
#line 914
        xcol.pixel = *(r->PixColors + 0);
#line 915
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 917
        xcol.pixel = *(r->PixColors + 1);
#line 918
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 922
    *(r->PixColors + i) = xcol.pixel;
#line 923
    (r->h)->pixcolor_set[i / 32] |= (unsigned int )(1 << i % 32);
    __Cont: /* CIL Label */ 
#line 884
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
#line 927
    *(r->PixColors + 20) = *(r->PixColors + 0);
  } else
#line 926
  if (! (r->h)->rs[25]) {
#line 927
    *(r->PixColors + 20) = *(r->PixColors + 0);
  }
#line 928
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
#line 929
    *(r->PixColors + 21) = *(r->PixColors + 0);
  } else
#line 928
  if (! (r->h)->rs[26]) {
#line 929
    *(r->PixColors + 21) = *(r->PixColors + 0);
  }
#line 980
  return;
}
}
#line 985 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
void rxvt_color_aliases(rxvt_t *r , int idx ) 
{ 
  int i ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 988
  if ((r->h)->rs[5 + idx]) {
    {
#line 988
    tmp___0 = __ctype_b_loc();
    }
#line 988
    if ((int const   )*(*tmp___0 + (int )*((r->h)->rs[5 + idx])) & 2048) {
      {
#line 989
      tmp = atoi((r->h)->rs[5 + idx]);
#line 989
      i = tmp;
      }
#line 991
      if (i >= 8) {
#line 991
        if (i <= 15) {
#line 992
          i -= 8;
#line 994
          (r->h)->rs[5 + idx] = (r->h)->rs[15 + i];
#line 995
          return;
        }
      }
#line 998
      if (i >= 0) {
#line 998
        if (i <= 7) {
#line 999
          (r->h)->rs[5 + idx] = (r->h)->rs[7 + i];
        }
      }
    }
  }
#line 1001
  return;
}
}
#line 1009 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
void rxvt_get_ourmods(rxvt_t *r ) 
{ 
  int i ;
  int j ;
  int k ;
  int requestedmeta ;
  int realmeta ;
  int realalt ;
  char const   *cm ;
  char const   *rsmod ;
  XModifierKeymap *map ;
  KeyCode *kc ;
  unsigned int modmasks[5] ;
  int tmp ;
  int tmp___0 ;
  KeySym __attribute__((__deprecated__))  tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1017
  modmasks[0] = (unsigned int )(1 << 3);
#line 1017
  modmasks[1] = (unsigned int )(1 << 4);
#line 1017
  modmasks[2] = (unsigned int )(1 << 5);
#line 1017
  modmasks[3] = (unsigned int )(1 << 6);
#line 1017
  modmasks[4] = (unsigned int )(1 << 7);
#line 1020
  realalt = 0;
#line 1020
  realmeta = realalt;
#line 1020
  requestedmeta = realmeta;
#line 1021
  rsmod = (r->h)->rs[57];
#line 1022
  if (rsmod) {
    {
#line 1022
    tmp = strcasecmp(rsmod, "mod1");
    }
#line 1022
    if (tmp >= 0) {
      {
#line 1022
      tmp___0 = strcasecmp(rsmod, "mod5");
      }
#line 1022
      if (tmp___0 <= 0) {
#line 1024
        requestedmeta = (int )((int const   )*(rsmod + 3) - 48);
      }
    }
  }
  {
#line 1026
  map = XGetModifierMapping(r->Xdisplay);
#line 1027
  kc = map->modifiermap;
#line 1028
  i = 1;
  }
  {
#line 1028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (! (i < 6)) {
#line 1028
      goto while_break;
    }
#line 1029
    k = (i + 2) * map->max_keypermod;
#line 1030
    j = map->max_keypermod;
    {
#line 1030
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1030
      tmp___4 = j;
#line 1030
      j --;
#line 1030
      if (! tmp___4) {
#line 1030
        goto while_break___0;
      }
#line 1031
      if ((int )*(kc + k) == 0) {
#line 1032
        goto while_break___0;
      }
      {
#line 1033
      tmp___1 = XKeycodeToKeysym(r->Xdisplay, *(kc + k), 0);
      }
      {
#line 1034
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65407) {
#line 1034
        goto case_65407;
      }
#line 1040
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65512) {
#line 1040
        goto case_65512;
      }
#line 1040
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65511) {
#line 1040
        goto case_65512;
      }
#line 1045
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65514) {
#line 1045
        goto case_65514;
      }
#line 1045
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65513) {
#line 1045
        goto case_65514;
      }
#line 1050
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65516) {
#line 1050
        goto case_65516;
      }
#line 1050
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65515) {
#line 1050
        goto case_65516;
      }
#line 1054
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65518) {
#line 1054
        goto case_65518;
      }
#line 1054
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65517) {
#line 1054
        goto case_65518;
      }
#line 1037
      goto switch_default;
      case_65407: /* CIL Label */ 
#line 1035
      (r->h)->ModNumLockMask = modmasks[i - 1];
      switch_default: /* CIL Label */ 
#line 1038
      goto __Cont;
      case_65512: /* CIL Label */ 
      case_65511: /* CIL Label */ 
#line 1041
      cm = "meta";
#line 1042
      realmeta = i;
#line 1043
      goto switch_break;
      case_65514: /* CIL Label */ 
      case_65513: /* CIL Label */ 
#line 1046
      cm = "alt";
#line 1047
      realalt = i;
#line 1048
      goto switch_break;
      case_65516: /* CIL Label */ 
      case_65515: /* CIL Label */ 
#line 1051
      cm = "super";
#line 1052
      goto switch_break;
      case_65518: /* CIL Label */ 
      case_65517: /* CIL Label */ 
#line 1055
      cm = "hyper";
#line 1056
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1058
      if (rsmod) {
        {
#line 1058
        tmp___2 = strlen(cm);
#line 1058
        tmp___3 = strncasecmp(rsmod, cm, tmp___2);
        }
#line 1058
        if (tmp___3 == 0) {
#line 1059
          requestedmeta = i;
        }
      }
      __Cont: /* CIL Label */ 
#line 1030
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1028
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1062
  XFreeModifiermap(map);
  }
#line 1063
  if (requestedmeta) {
#line 1063
    i = requestedmeta;
  } else {
#line 1063
    if (realmeta) {
#line 1063
      tmp___6 = realmeta;
    } else {
#line 1063
      if (realalt) {
#line 1063
        tmp___5 = realalt;
      } else {
#line 1063
        tmp___5 = 0;
      }
#line 1063
      tmp___6 = tmp___5;
    }
#line 1063
    i = tmp___6;
  }
#line 1066
  if (i) {
#line 1067
    (r->h)->ModMetaMask = modmasks[i - 1];
  }
#line 1068
  return;
}
}
#line 1073 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
void rxvt_Create_Windows(rxvt_t *r , int argc , char const   * const  *argv ) 
{ 
  XClassHint classHint ;
  XWMHints wmHint ;
  XGCValues gcvalue ;

  {
  {
#line 1111
  rxvt_Get_Colours(r);
#line 1113
  rxvt_change_font(r, 1, (char const   *)((void *)0));
#line 1114
  rxvt_window_calc(r, 0U, 0U);
#line 1115
  (r->h)->old_width = (unsigned int )r->szHint.width;
#line 1116
  (r->h)->old_height = (unsigned int )r->szHint.height;
#line 1135
  r->TermWin.parent[0] = XCreateSimpleWindow(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                                             r->szHint.x, r->szHint.y, (unsigned int )r->szHint.width,
                                             (unsigned int )r->szHint.height, (unsigned int )r->TermWin.ext_bwidth,
                                             *(r->PixColors + 21), *(r->PixColors + 0));
#line 1143
  rxvt_xterm_seq(r, 2, (r->h)->rs[38], (unsigned char)156);
#line 1144
  rxvt_xterm_seq(r, 1, (r->h)->rs[2], (unsigned char)156);
#line 1146
  classHint.res_name = (char *)(r->h)->rs[37];
#line 1147
  classHint.res_class = (char *)"XTerm";
#line 1149
  wmHint.flags = (1L | (1L << 1)) | (1L << 6);
#line 1150
  wmHint.input = 1;
  }
#line 1151
  if (r->Options & (1UL << 2)) {
#line 1151
    wmHint.initial_state = 3;
  } else {
#line 1151
    wmHint.initial_state = 1;
  }
  {
#line 1153
  wmHint.window_group = r->TermWin.parent[0];
#line 1155
  XSetWMProperties(r->Xdisplay, r->TermWin.parent[0], (XTextProperty *)((void *)0),
                   (XTextProperty *)((void *)0), (char **)argv, argc, & r->szHint,
                   & wmHint, & classHint);
#line 1157
  XSelectInput(r->Xdisplay, r->TermWin.parent[0], ((1L | (1L << 21)) | (1L << 16)) | (1L << 17));
#line 1166
  r->TermWin_cursor = XCreateFontCursor(r->Xdisplay, 152U);
#line 1167
  rxvt_recolour_cursor(r);
#line 1175
  r->TermWin.vt = XCreateSimpleWindow(r->Xdisplay, r->TermWin.parent[0], (r->h)->window_vt_x,
                                      (r->h)->window_vt_y, (unsigned int )((int32_t )r->TermWin.width + 2 * (int32_t )r->TermWin.int_bwidth),
                                      (unsigned int )((int32_t )r->TermWin.height + 2 * (int32_t )r->TermWin.int_bwidth),
                                      0U, *(r->PixColors + 0), *(r->PixColors + 1));
#line 1185
  XDefineCursor(r->Xdisplay, r->TermWin.vt, r->TermWin_cursor);
#line 1186
  XSelectInput(r->Xdisplay, r->TermWin.vt, (((((1L << 15) | (1L << 2)) | (1L << 3)) | (1L << 22)) | (1L << 8)) | (1L << 10));
#line 1224
  gcvalue.font = (r->TermWin.font)->fid;
#line 1225
  gcvalue.foreground = *(r->PixColors + 0);
#line 1226
  gcvalue.background = *(r->PixColors + 1);
#line 1227
  gcvalue.graphics_exposures = 1;
#line 1228
  r->TermWin.gc = XCreateGC(r->Xdisplay, r->TermWin.vt, (unsigned long )((((1L << 2) | (1L << 3)) | (1L << 14)) | (1L << 16)),
                            & gcvalue);
  }
#line 1244
  return;
}
}
#line 1253 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
int rxvt_run_command(rxvt_t *r , char const   * const  *argv ) 
{ 
  int i ;
  int cfd ;
  int tmp ;
  int tmp___0 ;
  pid_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1262
  i = open("/dev/null", 0);
  }
#line 1262
  if (i < 0) {
    {
#line 1264
    dup2(2, 0);
    }
  } else
#line 1265
  if (i > 0) {
    {
#line 1266
    dup2(i, 0);
#line 1267
    close(i);
    }
  }
  {
#line 1269
  dup2(2, 1);
#line 1270
  i = 3;
  }
  {
#line 1270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1270
    if (! (i < r->num_fds)) {
#line 1270
      goto while_break;
    }
#line 1271
    if (i == r->Xfd) {
#line 1276
      goto __Cont;
    }
    {
#line 1277
    close(i);
    }
    __Cont: /* CIL Label */ 
#line 1270
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1279
  if (r->Xfd < 3) {
#line 1279
    goto _L;
  } else
#line 1279
  if (r->Xfd > 1024) {
    _L: /* CIL Label */ 
    {
#line 1279
    tmp = dup2(r->Xfd, 3);
    }
#line 1279
    if (tmp != -1) {
      {
#line 1284
      close(r->Xfd);
#line 1285
      r->Xfd = 3;
      }
    }
  }
  {
#line 1289
  cfd = rxvt_get_pty(& r->tty_fd, & (r->h)->ttydev);
  }
#line 1289
  if (cfd < 0) {
    {
#line 1290
    rxvt_print_error("can\'t open pseudo-tty");
    }
#line 1291
    return (-1);
  }
#line 1294
  if (r->Xfd > 1024) {
    {
#line 1295
    rxvt_print_error("fd too high: %d max", 1024);
#line 1296
    rxvt_clean_exit();
#line 1297
    exit(1);
    }
  } else
#line 1294
  if (cfd > 1024) {
    {
#line 1295
    rxvt_print_error("fd too high: %d max", 1024);
#line 1296
    rxvt_clean_exit();
#line 1297
    exit(1);
    }
  }
  {
#line 1300
  fcntl(cfd, 4, 2048);
  }
#line 1303
  if (r->tty_fd < 0) {
    {
#line 1305
    tmp___0 = rxvt_get_tty((r->h)->ttydev);
#line 1305
    r->tty_fd = tmp___0;
    }
#line 1305
    if (tmp___0 < 0) {
      {
#line 1306
      close(cfd);
#line 1307
      rxvt_print_error("can\'t open slave tty %s", (r->h)->ttydev);
      }
#line 1308
      return (-1);
    }
  }
  {
#line 1311
  rxvt_get_ttymode(& (r->h)->tio);
#line 1315
  atexit(& rxvt_clean_exit);
#line 1322
  signal(1, & rxvt_Exit_signal);
#line 1324
  signal(2, & rxvt_Exit_signal);
#line 1326
  signal(3, & rxvt_Exit_signal);
#line 1327
  signal(15, & rxvt_Exit_signal);
#line 1328
  signal(17, & rxvt_Child_signal);
#line 1334
  rxvt_tt_winsize(0, r->TermWin.ncol, r->TermWin.nrow);
#line 1338
  tmp___1 = fork();
#line 1338
  (r->h)->cmd_pid = tmp___1;
  }
  {
#line 1339
  if (tmp___1 == -1) {
#line 1339
    goto case_neg_1;
  }
#line 1342
  if (tmp___1 == 0) {
#line 1342
    goto case_0;
  }
#line 1362
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 1340
  rxvt_print_error("can\'t fork");
  }
#line 1341
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 1343
  close(cfd);
#line 1344
  close(r->Xfd);
#line 1348
  tmp___2 = rxvt_control_tty(r->tty_fd, (r->h)->ttydev);
  }
#line 1348
  if (tmp___2 < 0) {
    {
#line 1349
    rxvt_print_error("could not obtain control of tty");
    }
  } else {
    {
#line 1352
    dup2(r->tty_fd, 0);
#line 1353
    dup2(r->tty_fd, 1);
#line 1354
    dup2(r->tty_fd, 2);
    }
#line 1355
    if (r->tty_fd > 2) {
      {
#line 1356
      close(r->tty_fd);
      }
    }
    {
#line 1357
    rxvt_run_child(r, argv);
    }
  }
  {
#line 1360
  exit(1);
  }
  switch_default: /* CIL Label */ 
  {
#line 1363
  close(r->tty_fd);
  }
#line 1364
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1377
  if (2 > cfd) {
#line 1377
    r->num_fds = 2;
  } else {
#line 1377
    r->num_fds = cfd;
  }
#line 1378
  if (r->Xfd > r->num_fds) {
#line 1378
    r->num_fds = r->Xfd;
  }
#line 1382
  (r->num_fds) ++;
#line 1385
  return (cfd);
}
}
#line 1396 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
int rxvt_run_child(rxvt_t *r , char const   * const  *argv ) 
{ 
  char *login ;
  unsigned int on ;
  char const   *argv0 ;
  char const   *shell ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1401
  cfsetospeed(& (r->h)->tio, (speed_t )15);
#line 1401
  cfsetispeed(& (r->h)->tio, (speed_t )15);
#line 1401
  tcsetattr(0, 0, (struct termios  const  *)(& (r->h)->tio));
  }
#line 1403
  if (r->Options & 1UL) {
    {
#line 1405
    on = 1U;
#line 1407
    ioctl(0, 21533UL, & on);
    }
  }
  {
#line 1420
  signal(2, (void (*)(int  ))0);
#line 1421
  signal(3, (void (*)(int  ))0);
#line 1422
  signal(17, (void (*)(int  ))0);
#line 1428
  signal(20, (void (*)(int  ))1);
#line 1429
  signal(21, (void (*)(int  ))1);
#line 1430
  signal(22, (void (*)(int  ))1);
  }
#line 1435
  if ((unsigned long )argv != (unsigned long )((void *)0)) {
    {
#line 1442
    execvp((char const   *)*(argv + 0), (char * const  *)argv);
    }
  } else {
    {
#line 1447
    tmp = getenv("SHELL");
#line 1447
    shell = (char const   *)tmp;
    }
#line 1447
    if ((unsigned long )shell == (unsigned long )((void *)0)) {
#line 1448
      shell = "/bin/sh";
    } else
#line 1447
    if ((int const   )*shell == 0) {
#line 1448
      shell = "/bin/sh";
    }
    {
#line 1450
    tmp___0 = rxvt_r_basename(shell);
#line 1450
    argv0 = (char const   *)tmp___0;
    }
#line 1451
    if (r->Options & (1UL << 1)) {
      {
#line 1452
      tmp___1 = strlen(argv0);
#line 1452
      tmp___2 = rxvt_malloc((tmp___1 + 2UL) * sizeof(char ));
#line 1452
      login = (char *)tmp___2;
#line 1454
      *(login + 0) = (char )'-';
#line 1455
      strcpy((char */* __restrict  */)(login + 1), (char const   */* __restrict  */)argv0);
#line 1456
      argv0 = (char const   *)login;
      }
    }
    {
#line 1458
    execlp(shell, argv0, (void *)0);
    }
  }
#line 1503
  return (-1);
}
}
#line 1511 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/init.c"
void rxvt_get_ttymode(ttymode_t *tio ) 
{ 
  int tmp ;

  {
  {
#line 1518
  tmp = tcgetattr(0, tio);
  }
#line 1518
  if (tmp < 0) {
#line 1520
    tio->c_cc[0] = (cc_t )3;
#line 1521
    tio->c_cc[1] = (cc_t )28;
#line 1522
    tio->c_cc[2] = (cc_t )127;
#line 1523
    tio->c_cc[3] = (cc_t )21;
#line 1524
    tio->c_cc[8] = (cc_t )17;
#line 1525
    tio->c_cc[9] = (cc_t )19;
#line 1526
    tio->c_cc[10] = (cc_t )26;
#line 1531
    tio->c_cc[12] = (cc_t )18;
#line 1534
    tio->c_cc[13] = (cc_t )15;
#line 1537
    tio->c_cc[14] = (cc_t )23;
#line 1540
    tio->c_cc[15] = (cc_t )22;
  }
#line 1543
  tio->c_cc[4] = (cc_t )4;
#line 1544
  tio->c_cc[11] = (cc_t )'\000';
#line 1546
  tio->c_cc[16] = (cc_t )'\000';
#line 1549
  tio->c_cc[7] = (cc_t )'\000';
#line 1555
  tio->c_cc[6] = (cc_t )1;
#line 1558
  tio->c_cc[5] = (cc_t )0;
#line 1562
  tio->c_iflag = (tcflag_t )9478;
#line 1569
  tio->c_oflag = (tcflag_t )5;
#line 1572
  tio->c_cflag = (tcflag_t )176;
#line 1575
  tio->c_lflag = (tcflag_t )35387;
#line 1696
  return;
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/ptytty.c"
extern char *ptsname() ;
#line 105
extern int ( /* missing proto */  getpt)() ;
#line 110
extern int ( /* missing proto */  grantpt)() ;
#line 110
extern int ( /* missing proto */  unlockpt)() ;
#line 69 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/ptytty.c"
int rxvt_get_pty(int *fd_tty , char const   **ttydev ) 
{ 
  int pfd ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *c1 ;
  char const   *c2 ;
  char pty_name[11] ;
  char tty_name[11] ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 105
  pfd = getpt();
  }
#line 109
  if (pfd >= 0) {
    {
#line 110
    tmp___0 = grantpt(pfd);
    }
#line 110
    if (tmp___0 == 0) {
      {
#line 110
      tmp___1 = unlockpt(pfd);
      }
#line 110
      if (tmp___1 == 0) {
        {
#line 112
        tmp = ptsname(pfd);
#line 112
        *ttydev = (char const   *)tmp;
        }
#line 113
        return (pfd);
      }
    }
    {
#line 115
    close(pfd);
    }
  }
#line 164
  pty_name[0] = (char )'/';
#line 164
  pty_name[1] = (char )'d';
#line 164
  pty_name[2] = (char )'e';
#line 164
  pty_name[3] = (char )'v';
#line 164
  pty_name[4] = (char )'/';
#line 164
  pty_name[5] = (char )'p';
#line 164
  pty_name[6] = (char )'t';
#line 164
  pty_name[7] = (char )'y';
#line 164
  pty_name[8] = (char )'?';
#line 164
  pty_name[9] = (char )'?';
#line 164
  pty_name[10] = (char )'\000';
#line 165
  tty_name[0] = (char )'/';
#line 165
  tty_name[1] = (char )'d';
#line 165
  tty_name[2] = (char )'e';
#line 165
  tty_name[3] = (char )'v';
#line 165
  tty_name[4] = (char )'/';
#line 165
  tty_name[5] = (char )'t';
#line 165
  tty_name[6] = (char )'t';
#line 165
  tty_name[7] = (char )'y';
#line 165
  tty_name[8] = (char )'?';
#line 165
  tty_name[9] = (char )'?';
#line 165
  tty_name[10] = (char )'\000';
#line 173
  c1 = "?";
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! *c1) {
#line 173
      goto while_break;
    }
#line 174
    tty_name[sizeof(pty_name) - 3UL] = (char )*c1;
#line 174
    pty_name[sizeof(pty_name) - 3UL] = tty_name[sizeof(pty_name) - 3UL];
#line 176
    c2 = "?";
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 176
      if (! *c2) {
#line 176
        goto while_break___0;
      }
      {
#line 177
      tty_name[sizeof(pty_name) - 2UL] = (char )*c2;
#line 177
      pty_name[sizeof(pty_name) - 2UL] = tty_name[sizeof(pty_name) - 2UL];
#line 179
      pfd = open((char const   *)(pty_name), 258, 0);
      }
#line 179
      if (pfd >= 0) {
        {
#line 180
        tmp___3 = access((char const   *)(tty_name), 6);
        }
#line 180
        if (tmp___3 == 0) {
          {
#line 181
          tmp___2 = strdup((char const   *)(tty_name));
#line 181
          *ttydev = (char const   *)tmp___2;
          }
#line 182
          return (pfd);
        }
        {
#line 184
        close(pfd);
        }
      }
#line 176
      c2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 173
    c1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return (-1);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/ptytty.c"
int rxvt_get_tty(char const   *ttydev ) 
{ 
  int tmp ;

  {
  {
#line 201
  tmp = open(ttydev, 258, 0);
  }
#line 201
  return (tmp);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/ptytty.c"
int rxvt_control_tty(int fd_tty , char const   *ttydev ) 
{ 
  int fd ;

  {
  {
#line 218
  setsid();
#line 221
  setpgid(0, 0);
#line 227
  fd = open("/dev/tty", 258);
  }
#line 229
  if (fd >= 0) {
    {
#line 230
    ioctl(fd, 21538UL, (void *)0);
#line 231
    close(fd);
    }
  }
  {
#line 235
  fd = open("/dev/tty", 258);
  }
#line 237
  if (fd >= 0) {
    {
#line 238
    close(fd);
    }
  }
  {
#line 270
  fd = ioctl(fd_tty, 21518UL, (void *)0);
#line 282
  fd = open("/dev/tty", 1);
  }
#line 284
  if (fd < 0) {
#line 285
    return (-1);
  }
  {
#line 286
  close(fd);
  }
#line 291
  return (0);
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 1644 "/usr/include/X11/Xlib.h"
extern Window XGetSelectionOwner(Display * , Atom  ) ;
#line 2022
extern int XBell(Display * , int  ) ;
#line 2050
extern int XChangeGC(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2157
extern int XClearArea(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                      int  ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2187
extern int XConvertSelection(Display * , Atom  , Atom  , Atom  , Window  , Time  ) ;
#line 2196
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2249
extern int XDeleteProperty(Display * , Window  , Atom  ) ;
#line 2334
extern int XDrawImageString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                            int  ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2390
extern int XDrawRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2688
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 3304
extern int XSetSelectionOwner(Display * , Atom  , Window  , Time  ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.extpro"
FILE *rxvt_popen_printer(rxvt_t *r ) ;
#line 5
int rxvt_pclose_printer(FILE *stream ) ;
#line 7
void rxvt_tt_printf(rxvt_t *r , char const   *fmt  , ...) ;
#line 8
void rxvt_tt_write(rxvt_t *r , unsigned char const   *d , unsigned int len ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.extpro"
void rxvt_scr_release(rxvt_t *r ) ;
#line 3
void rxvt_scr_poweron(rxvt_t *r ) ;
#line 4
void rxvt_scr_cursor(rxvt_t *r , int mode ) ;
#line 6
void rxvt_scr_color(rxvt_t *r , unsigned int color , int fgbg ) ;
#line 7
void rxvt_scr_rendition(rxvt_t *r , int set , int style ) ;
#line 8
int rxvt_scroll_text(rxvt_t *r , int row1 , int row2 , int count , int spec ) ;
#line 9
void rxvt_scr_add_lines(rxvt_t *r , unsigned char const   *str , int nlines , int len ) ;
#line 10
void rxvt_scr_backspace(rxvt_t *r ) ;
#line 11
void rxvt_scr_tab(rxvt_t *r , int count ) ;
#line 14
void rxvt_scr_gotorc(rxvt_t *r , int row , int col , int relative ) ;
#line 15
void rxvt_scr_index(rxvt_t *r , enum page_dirn direction ) ;
#line 16
void rxvt_scr_erase_line(rxvt_t *r , int mode ) ;
#line 17
void rxvt_scr_erase_screen(rxvt_t *r , int mode ) ;
#line 18
void rxvt_scr_E(rxvt_t *r ) ;
#line 19
void rxvt_scr_insdel_lines(rxvt_t *r , int count , int insdel ) ;
#line 20
void rxvt_scr_insdel_chars(rxvt_t *r , int count , int insdel ) ;
#line 21
void rxvt_scr_scroll_region(rxvt_t *r , int top , int bot ) ;
#line 22
void rxvt_scr_cursor_visible(rxvt_t *r , int mode ) ;
#line 23
void rxvt_scr_autowrap(rxvt_t *r , int mode ) ;
#line 24
void rxvt_scr_relative_origin(rxvt_t *r , int mode ) ;
#line 25
void rxvt_scr_insert_mode(rxvt_t *r , int mode ) ;
#line 26
void rxvt_scr_set_tab(rxvt_t *r , int mode ) ;
#line 27
void rxvt_scr_rvideo_mode(rxvt_t *r , int mode ) ;
#line 28
void rxvt_scr_report_position(rxvt_t *r ) ;
#line 29
void rxvt_scr_charset_choose(rxvt_t *r , int set ) ;
#line 30
void rxvt_scr_charset_set(rxvt_t *r , int set , unsigned int ch ) ;
#line 35
void rxvt_scr_expose(rxvt_t *r , int x , int y , int width , int height , int refresh ) ;
#line 37
int rxvt_scr_move_to(rxvt_t *r , int y , int len ) ;
#line 38
int rxvt_scr_page(rxvt_t *r , enum page_dirn direction , int nlines ) ;
#line 39
void rxvt_scr_bell(rxvt_t *r ) ;
#line 40
void rxvt_scr_printscreen(rxvt_t *r , int fullhist ) ;
#line 41
void rxvt_scr_refresh(rxvt_t *r , unsigned char refresh_type ) ;
#line 45
int rxvt_selection_paste(rxvt_t *r , Window win , Atom prop , int delete_prop ) ;
#line 46
void rxvt_selection_property(rxvt_t *r , Window win , Atom prop ) ;
#line 47
void rxvt_selection_request(rxvt_t *r , Time tm , int x , int y ) ;
#line 48
void rxvt_selection_clear(rxvt_t *r ) ;
#line 49
void rxvt_selection_make(rxvt_t *r , Time tm ) ;
#line 50
void rxvt_selection_click(rxvt_t *r , int clicks , int x , int y ) ;
#line 51
void rxvt_selection_extend(rxvt_t *r , int x , int y , int flag ) ;
#line 52
void rxvt_selection_rotate(rxvt_t *r , int x , int y ) ;
#line 53
void rxvt_selection_send(rxvt_t *r , XSelectionRequestEvent const   *rq ) ;
#line 54
void rxvt_pixel_position(rxvt_t *r , int *x , int *y ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.intpro"
void rxvt_blank_line(text_t *et , u_int16_t *er , unsigned int width , u_int16_t efs ) ;
#line 2
void rxvt_blank_screen_mem(rxvt_t *r , text_t **tp , u_int16_t **rp , unsigned int row ,
                           u_int16_t efs ) ;
#line 3
void rxvt_scr_reset_realloc(rxvt_t *r ) ;
#line 4
void rxvt_set_font_style(rxvt_t *r ) ;
#line 7
int rxvt_scr_changeview(rxvt_t *r , u_int16_t oldviewstart ) ;
#line 8
void rxvt_scr_reverse_selection(rxvt_t *r ) ;
#line 9
void rxvt_PasteIt(rxvt_t *r , unsigned char const   *data , unsigned int nitems ) ;
#line 10
int rxvt_selection_request_other(rxvt_t *r , Atom target , int selnum ) ;
#line 11
void rxvt_selection_start_colrow(rxvt_t *r , int col , int row ) ;
#line 12
void rxvt_selection_delimit_word(rxvt_t *r , enum page_dirn dirn , row_col_t const   *mark ,
                                 row_col_t *ret ) ;
#line 14
void rxvt_selection_extend_colrow(rxvt_t *r , int32_t col , int32_t row , int button3 ,
                                  int buttonpress , int clickchange ) ;
#line 126 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_blank_line(text_t *et , u_int16_t *er , unsigned int width , u_int16_t efs ) 
{ 
  u_int16_t *tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 129
  memset((void *)et, ' ', (size_t )width);
#line 130
  efs = (u_int16_t )((unsigned int )efs & 4294951935U);
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    tmp___0 = width;
#line 131
    width --;
#line 131
    if (! tmp___0) {
#line 131
      goto while_break;
    }
#line 132
    tmp = er;
#line 132
    er ++;
#line 132
    *tmp = efs;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_blank_screen_mem(rxvt_t *r , text_t **tp , u_int16_t **rp , unsigned int row ,
                           u_int16_t efs ) 
{ 
  int width ;
  u_int16_t *er ;
  void *tmp ;
  void *tmp___0 ;
  u_int16_t *tmp___1 ;
  int tmp___2 ;

  {
#line 141
  width = (int )r->TermWin.ncol;
#line 145
  if (*(tp + row)) {
#line 145
    if (! *(rp + row)) {
#line 145
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 145
  if ((unsigned long )*(tp + row) == (unsigned long )((void *)0)) {
#line 145
    if (! ((unsigned long )*(rp + row) == (unsigned long )((void *)0))) {
      {
#line 145
      __assert_fail("(tp[row] && rp[row]) || (tp[row] == ((void *)0) && rp[row] == ((void *)0))",
                    "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                    145U, "rxvt_blank_screen_mem");
      }
    }
  } else {
    {
#line 145
    __assert_fail("(tp[row] && rp[row]) || (tp[row] == ((void *)0) && rp[row] == ((void *)0))",
                  "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                  145U, "rxvt_blank_screen_mem");
    }
  }
#line 147
  if ((unsigned long )*(tp + row) == (unsigned long )((void *)0)) {
    {
#line 148
    tmp = rxvt_malloc(sizeof(text_t ) * (unsigned long )width);
#line 148
    *(tp + row) = (text_t *)tmp;
#line 149
    tmp___0 = rxvt_malloc(sizeof(u_int16_t ) * (unsigned long )width);
#line 149
    *(rp + row) = (u_int16_t *)tmp___0;
    }
  }
  {
#line 151
  memset((void *)*(tp + row), ' ', (size_t )width);
#line 152
  efs = (u_int16_t )((unsigned int )efs & 4294951935U);
#line 153
  er = *(rp + row);
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    tmp___2 = width;
#line 153
    width --;
#line 153
    if (! tmp___2) {
#line 153
      goto while_break;
    }
#line 154
    tmp___1 = er;
#line 154
    er ++;
#line 154
    *tmp___1 = efs;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_reset(rxvt_t *r ) 
{ 
  unsigned int ncol ;
  unsigned int nrow ;
  unsigned int prev_ncol ;
  unsigned int prev_nrow ;
  unsigned int total_rows ;
  unsigned int prev_total_rows ;
  unsigned int p ;
  unsigned int q ;
  int k ;
  u_int16_t setrstyle ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int16_t tmp___9 ;
  int32_t tmp___10 ;
  int32_t tmp___11 ;
  int32_t tmp___12 ;
  int32_t tmp___13 ;
  int32_t tmp___14 ;
  int32_t tmp___15 ;
  int32_t tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;

  {
#line 172
  r->TermWin.view_start = (u_int16_t )0;
#line 174
  (r->h)->num_scr = (int16_t )0;
#line 176
  prev_ncol = (unsigned int )(r->h)->prev_ncol;
#line 177
  prev_nrow = (unsigned int )(r->h)->prev_nrow;
#line 178
  if ((int )r->TermWin.ncol == 0) {
#line 179
    r->TermWin.ncol = (u_int16_t )80;
  }
#line 180
  if ((int )r->TermWin.nrow == 0) {
#line 181
    r->TermWin.nrow = (u_int16_t )24;
  }
#line 182
  ncol = (unsigned int )r->TermWin.ncol;
#line 183
  nrow = (unsigned int )r->TermWin.nrow;
#line 184
  if (ncol == prev_ncol) {
#line 184
    if (nrow == prev_nrow) {
#line 185
      return;
    }
  }
#line 187
  (r->h)->want_refresh = (unsigned char)1;
#line 189
  total_rows = nrow + (unsigned int )r->TermWin.saveLines;
#line 190
  prev_total_rows = prev_nrow + (unsigned int )r->TermWin.saveLines;
#line 192
  r->screen.tscroll = (u_int16_t )0;
#line 193
  r->screen.bscroll = (u_int16_t )(nrow - 1U);
#line 195
  if (prev_nrow == 0U) {
    {
#line 200
    tmp = rxvt_calloc((size_t )total_rows, sizeof(text_t *));
#line 200
    r->screen.text = (text_t **)tmp;
#line 201
    tmp___0 = rxvt_calloc((size_t )total_rows, sizeof(text_t *));
#line 201
    r->buf_text = (text_t **)tmp___0;
#line 202
    tmp___1 = rxvt_calloc((size_t )nrow, sizeof(text_t *));
#line 202
    r->drawn_text = (text_t **)tmp___1;
#line 203
    tmp___2 = rxvt_calloc((size_t )nrow, sizeof(text_t *));
#line 203
    r->swap.text = (text_t **)tmp___2;
#line 205
    tmp___3 = rxvt_calloc((size_t )total_rows, sizeof(int16_t ));
#line 205
    r->screen.tlen = (int16_t *)tmp___3;
#line 206
    tmp___4 = rxvt_calloc((size_t )nrow, sizeof(int16_t ));
#line 206
    r->swap.tlen = (int16_t *)tmp___4;
#line 208
    tmp___5 = rxvt_calloc((size_t )total_rows, sizeof(u_int16_t *));
#line 208
    r->screen.rend = (u_int16_t **)tmp___5;
#line 209
    tmp___6 = rxvt_calloc((size_t )total_rows, sizeof(u_int16_t *));
#line 209
    r->buf_rend = (u_int16_t **)tmp___6;
#line 210
    tmp___7 = rxvt_calloc((size_t )nrow, sizeof(u_int16_t *));
#line 210
    r->drawn_rend = (u_int16_t **)tmp___7;
#line 211
    tmp___8 = rxvt_calloc((size_t )nrow, sizeof(u_int16_t *));
#line 211
    r->swap.rend = (u_int16_t **)tmp___8;
#line 213
    p = 0U;
    }
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
#line 213
      if (! (p < nrow)) {
#line 213
        goto while_break;
      }
      {
#line 214
      q = p + (unsigned int )r->TermWin.saveLines;
#line 215
      rxvt_blank_screen_mem(r, r->screen.text, r->screen.rend, q, (u_int16_t )(1 << 5));
#line 217
      rxvt_blank_screen_mem(r, r->swap.text, r->swap.rend, p, (u_int16_t )(1 << 5));
#line 219
      tmp___9 = (int16_t )0;
#line 219
      *(r->swap.tlen + p) = tmp___9;
#line 219
      *(r->screen.tlen + q) = tmp___9;
#line 220
      rxvt_blank_screen_mem(r, r->drawn_text, r->drawn_rend, p, (u_int16_t )(1 << 5));
#line 213
      p ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 223
    memset((void *)((r->h)->charsets), 'B', sizeof((r->h)->charsets));
#line 224
    r->TermWin.nscrolled = (u_int16_t )0;
#line 225
    (r->h)->rstyle = (u_int16_t )(1 << 5);
#line 226
    r->screen.flags = (unsigned int )((1 << 1) | (1 << 2));
#line 227
    tmp___10 = 0;
#line 227
    r->screen.cur.col = tmp___10;
#line 227
    r->screen.cur.row = tmp___10;
#line 228
    r->screen.charset = (u_int16_t )0;
#line 229
    (r->h)->current_screen = (unsigned char)0;
#line 230
    rxvt_scr_cursor(r, 's');
#line 232
    r->swap.flags = (unsigned int )((1 << 1) | (1 << 2));
#line 233
    tmp___11 = 0;
#line 233
    r->swap.cur.col = tmp___11;
#line 233
    r->swap.cur.row = tmp___11;
#line 234
    r->swap.charset = (u_int16_t )0;
#line 235
    (r->h)->current_screen = (unsigned char)1;
#line 236
    rxvt_scr_cursor(r, 's');
#line 237
    (r->h)->current_screen = (unsigned char)0;
#line 239
    r->selection.text = (unsigned char *)((void *)0);
#line 240
    r->selection.len = (u_int32_t )0;
#line 241
    r->selection.op = (enum __anonenum_op_166 )0;
#line 242
    r->selection.screen = (short)0;
#line 243
    r->selection.clicks = (short)0;
#line 244
    tmp___16 = 0;
#line 244
    r->selection.end.col = tmp___16;
#line 244
    tmp___15 = tmp___16;
#line 244
    r->selection.end.row = tmp___15;
#line 244
    tmp___14 = tmp___15;
#line 244
    r->selection.mark.col = tmp___14;
#line 244
    tmp___13 = tmp___14;
#line 244
    r->selection.mark.row = tmp___13;
#line 244
    tmp___12 = tmp___13;
#line 244
    r->selection.beg.col = tmp___12;
#line 244
    r->selection.beg.row = tmp___12;
#line 245
    (r->h)->rvideo = (short)0;
    }
  } else {
#line 256
    setrstyle = (u_int16_t )(1 << 5);
#line 258
    if (nrow < prev_nrow) {
#line 260
      if ((unsigned int )r->TermWin.nscrolled < prev_nrow - nrow) {
#line 260
        k = (int )r->TermWin.nscrolled;
      } else {
#line 260
        k = (int )(prev_nrow - nrow);
      }
      {
#line 261
      rxvt_scroll_text(r, 0, (int )prev_nrow - 1, k, 1);
#line 262
      p = nrow;
      }
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (p < prev_nrow)) {
#line 262
          goto while_break___0;
        }
#line 263
        q = p + (unsigned int )r->TermWin.saveLines;
#line 264
        if (*(r->screen.text + q)) {
#line 266
          if (! *(r->screen.rend + q)) {
            {
#line 266
            __assert_fail("r->screen.rend[q]", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                          266U, "rxvt_scr_reset");
            }
          }
          {
#line 268
          free((void *)*(r->screen.text + q));
#line 269
          free((void *)*(r->screen.rend + q));
          }
        }
#line 271
        if (*(r->swap.text + p)) {
#line 273
          if (! *(r->swap.rend + p)) {
            {
#line 273
            __assert_fail("r->swap.rend[p]", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                          273U, "rxvt_scr_reset");
            }
          }
          {
#line 275
          free((void *)*(r->swap.text + p));
#line 276
          free((void *)*(r->swap.rend + p));
          }
        }
#line 279
        if (*(r->drawn_text + p)) {
#line 279
          if (! *(r->drawn_rend + p)) {
            {
#line 279
            __assert_fail("r->drawn_text[p] && r->drawn_rend[p]", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                          279U, "rxvt_scr_reset");
            }
          }
        } else {
          {
#line 279
          __assert_fail("r->drawn_text[p] && r->drawn_rend[p]", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                        279U, "rxvt_scr_reset");
          }
        }
        {
#line 281
        free((void *)*(r->drawn_text + p));
#line 282
        free((void *)*(r->drawn_rend + p));
#line 262
        p ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 285
      if ((int32_t )nrow - 1 < r->screen.cur.row) {
#line 285
        r->screen.cur.row = (int32_t )nrow - 1;
      }
#line 286
      if ((int32_t )nrow - 1 < r->swap.cur.row) {
#line 286
        r->swap.cur.row = (int32_t )nrow - 1;
      }
      {
#line 288
      rxvt_scr_reset_realloc(r);
      }
    } else
#line 290
    if (nrow > prev_nrow) {
      {
#line 292
      rxvt_scr_reset_realloc(r);
      }
#line 294
      if ((unsigned int )r->TermWin.nscrolled < nrow - prev_nrow) {
#line 294
        k = (int )r->TermWin.nscrolled;
      } else {
#line 294
        k = (int )(nrow - prev_nrow);
      }
#line 295
      p = prev_total_rows;
      {
#line 295
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 295
        if (! (p < total_rows)) {
#line 295
          goto while_break___1;
        }
#line 296
        *(r->screen.tlen + p) = (int16_t )0;
#line 297
        *(r->screen.text + p) = (text_t *)((void *)0);
#line 298
        *(r->screen.rend + p) = (u_int16_t *)((void *)0);
#line 295
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 300
      p = prev_total_rows;
      {
#line 300
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 300
        if (! (p < total_rows - (unsigned int )k)) {
#line 300
          goto while_break___2;
        }
        {
#line 301
        rxvt_blank_screen_mem(r, r->screen.text, r->screen.rend, p, setrstyle);
#line 300
        p ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 303
      p = prev_nrow;
      {
#line 303
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 303
        if (! (p < nrow)) {
#line 303
          goto while_break___3;
        }
        {
#line 304
        *(r->swap.tlen + p) = (int16_t )0;
#line 305
        *(r->swap.text + p) = (text_t *)((void *)0);
#line 306
        *(r->swap.rend + p) = (u_int16_t *)((void *)0);
#line 307
        *(r->drawn_text + p) = (text_t *)((void *)0);
#line 308
        *(r->drawn_rend + p) = (u_int16_t *)((void *)0);
#line 309
        rxvt_blank_screen_mem(r, r->swap.text, r->swap.rend, p, setrstyle);
#line 311
        rxvt_blank_screen_mem(r, r->drawn_text, r->drawn_rend, p, setrstyle);
#line 303
        p ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 314
      if (k > 0) {
        {
#line 315
        rxvt_scroll_text(r, 0, (int )nrow - 1, - k, 1);
#line 316
        r->screen.cur.row += k;
#line 317
        r->screen.s_cur.row += k;
#line 318
        r->TermWin.nscrolled = (u_int16_t )((int )r->TermWin.nscrolled - k);
        }
      }
#line 321
      if (! (r->screen.cur.row < (int32_t )r->TermWin.nrow)) {
        {
#line 321
        __assert_fail("r->screen.cur.row < r->TermWin.nrow", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                      321U, "rxvt_scr_reset");
        }
      }
#line 322
      if (! (r->swap.cur.row < (int32_t )r->TermWin.nrow)) {
        {
#line 322
        __assert_fail("r->swap.cur.row < r->TermWin.nrow", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                      322U, "rxvt_scr_reset");
        }
      }
    }
#line 329
    if (ncol != prev_ncol) {
#line 330
      p = 0U;
      {
#line 330
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 330
        if (! (p < total_rows)) {
#line 330
          goto while_break___4;
        }
#line 331
        if (*(r->screen.text + p)) {
          {
#line 332
          tmp___17 = rxvt_realloc((void *)*(r->screen.text + p), (unsigned long )ncol * sizeof(text_t ));
#line 332
          *(r->screen.text + p) = (text_t *)tmp___17;
#line 334
          tmp___18 = rxvt_realloc((void *)*(r->screen.rend + p), (unsigned long )ncol * sizeof(u_int16_t ));
#line 334
          *(r->screen.rend + p) = (u_int16_t *)tmp___18;
          }
#line 336
          if ((int )((int16_t )ncol) < (int )*(r->screen.tlen + p)) {
#line 336
            *(r->screen.tlen + p) = (int16_t )ncol;
          }
#line 337
          if (ncol > prev_ncol) {
            {
#line 338
            rxvt_blank_line(*(r->screen.text + p) + prev_ncol, *(r->screen.rend + p) + prev_ncol,
                            ncol - prev_ncol, setrstyle);
            }
          }
        }
#line 330
        p ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 344
      p = 0U;
      {
#line 344
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 344
        if (! (p < nrow)) {
#line 344
          goto while_break___5;
        }
        {
#line 345
        tmp___19 = rxvt_realloc((void *)*(r->drawn_text + p), (unsigned long )ncol * sizeof(text_t ));
#line 345
        *(r->drawn_text + p) = (text_t *)tmp___19;
#line 347
        tmp___20 = rxvt_realloc((void *)*(r->drawn_rend + p), (unsigned long )ncol * sizeof(u_int16_t ));
#line 347
        *(r->drawn_rend + p) = (u_int16_t *)tmp___20;
        }
#line 349
        if (*(r->swap.text + p)) {
          {
#line 350
          tmp___21 = rxvt_realloc((void *)*(r->swap.text + p), (unsigned long )ncol * sizeof(text_t ));
#line 350
          *(r->swap.text + p) = (text_t *)tmp___21;
#line 352
          tmp___22 = rxvt_realloc((void *)*(r->swap.rend + p), (unsigned long )ncol * sizeof(u_int16_t ));
#line 352
          *(r->swap.rend + p) = (u_int16_t *)tmp___22;
          }
#line 354
          if ((int )((int16_t )ncol) < (int )*(r->swap.tlen + p)) {
#line 354
            *(r->swap.tlen + p) = (int16_t )ncol;
          }
#line 355
          if (ncol > prev_ncol) {
            {
#line 356
            rxvt_blank_line(*(r->swap.text + p) + prev_ncol, *(r->swap.rend + p) + prev_ncol,
                            ncol - prev_ncol, setrstyle);
            }
          }
        }
#line 360
        if (ncol > prev_ncol) {
          {
#line 361
          rxvt_blank_line(*(r->drawn_text + p) + prev_ncol, *(r->drawn_rend + p) + prev_ncol,
                          ncol - prev_ncol, setrstyle);
          }
        }
#line 344
        p ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 365
      if ((int )((int16_t )ncol) - 1 < r->screen.cur.col) {
#line 365
        r->screen.cur.col = (int )((int16_t )ncol) - 1;
      }
#line 366
      if ((int )((int16_t )ncol) - 1 < r->swap.cur.col) {
#line 366
        r->swap.cur.col = (int )((int16_t )ncol) - 1;
      }
    }
#line 368
    if (r->tabs) {
      {
#line 369
      free((void *)r->tabs);
      }
    }
  }
  {
#line 372
  tmp___23 = rxvt_malloc((unsigned long )ncol * sizeof(char ));
#line 372
  r->tabs = (char *)tmp___23;
#line 374
  p = 0U;
  }
  {
#line 374
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 374
    if (! (p < ncol)) {
#line 374
      goto while_break___6;
    }
#line 375
    if (p % 8U == 0U) {
#line 375
      *(r->tabs + p) = (char)1;
    } else {
#line 375
      *(r->tabs + p) = (char)0;
    }
#line 374
    p ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 377
  (r->h)->prev_nrow = (u_int16_t )nrow;
#line 378
  (r->h)->prev_ncol = (u_int16_t )ncol;
#line 380
  rxvt_tt_winsize(r->cmd_fd, r->TermWin.ncol, r->TermWin.nrow);
  }
#line 381
  return;
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_reset_realloc(rxvt_t *r ) 
{ 
  u_int16_t total_rows ;
  u_int16_t nrow ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 389
  nrow = r->TermWin.nrow;
#line 390
  total_rows = (u_int16_t )((int )nrow + (int )r->TermWin.saveLines);
#line 392
  tmp = rxvt_realloc((void *)r->screen.text, (unsigned long )total_rows * sizeof(text_t *));
#line 392
  r->screen.text = (text_t **)tmp;
#line 393
  tmp___0 = rxvt_realloc((void *)r->buf_text, (unsigned long )total_rows * sizeof(text_t *));
#line 393
  r->buf_text = (text_t **)tmp___0;
#line 394
  tmp___1 = rxvt_realloc((void *)r->drawn_text, (unsigned long )nrow * sizeof(text_t *));
#line 394
  r->drawn_text = (text_t **)tmp___1;
#line 395
  tmp___2 = rxvt_realloc((void *)r->swap.text, (unsigned long )nrow * sizeof(text_t *));
#line 395
  r->swap.text = (text_t **)tmp___2;
#line 397
  tmp___3 = rxvt_realloc((void *)r->screen.tlen, (unsigned long )total_rows * sizeof(int16_t ));
#line 397
  r->screen.tlen = (int16_t *)tmp___3;
#line 398
  tmp___4 = rxvt_realloc((void *)r->swap.tlen, (unsigned long )total_rows * sizeof(int16_t ));
#line 398
  r->swap.tlen = (int16_t *)tmp___4;
#line 400
  tmp___5 = rxvt_realloc((void *)r->screen.rend, (unsigned long )total_rows * sizeof(u_int16_t *));
#line 400
  r->screen.rend = (u_int16_t **)tmp___5;
#line 401
  tmp___6 = rxvt_realloc((void *)r->buf_rend, (unsigned long )total_rows * sizeof(u_int16_t *));
#line 401
  r->buf_rend = (u_int16_t **)tmp___6;
#line 402
  tmp___7 = rxvt_realloc((void *)r->drawn_rend, (unsigned long )nrow * sizeof(u_int16_t *));
#line 402
  r->drawn_rend = (u_int16_t **)tmp___7;
#line 403
  tmp___8 = rxvt_realloc((void *)r->swap.rend, (unsigned long )nrow * sizeof(u_int16_t *));
#line 403
  r->swap.rend = (u_int16_t **)tmp___8;
  }
#line 405
  return;
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_release(rxvt_t *r ) 
{ 
  u_int16_t total_rows ;
  int i ;
  text_t **tmp ;
  text_t **tmp___0 ;
  u_int16_t **tmp___1 ;
  u_int16_t **tmp___2 ;
  int16_t *tmp___3 ;

  {
#line 418
  total_rows = (u_int16_t )((int )r->TermWin.nrow + (int )r->TermWin.saveLines);
#line 419
  i = 0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (i < (int )total_rows)) {
#line 419
      goto while_break;
    }
#line 420
    if (*(r->screen.text + i)) {
      {
#line 421
      free((void *)*(r->screen.text + i));
      }
#line 423
      if (! *(r->screen.rend + i)) {
        {
#line 423
        __assert_fail("r->screen.rend[i]", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                      423U, "rxvt_scr_release");
        }
      }
      {
#line 425
      free((void *)*(r->screen.rend + i));
      }
    }
#line 419
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  i = 0;
  {
#line 428
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 428
    if (! (i < (int )r->TermWin.nrow)) {
#line 428
      goto while_break___0;
    }
    {
#line 429
    free((void *)*(r->drawn_text + i));
#line 430
    free((void *)*(r->drawn_rend + i));
#line 431
    free((void *)*(r->swap.text + i));
#line 432
    free((void *)*(r->swap.rend + i));
#line 428
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 434
  free((void *)r->screen.text);
#line 435
  free((void *)r->screen.tlen);
#line 436
  free((void *)r->screen.rend);
#line 437
  free((void *)r->drawn_text);
#line 438
  free((void *)r->drawn_rend);
#line 439
  free((void *)r->swap.text);
#line 440
  free((void *)r->swap.tlen);
#line 441
  free((void *)r->swap.rend);
#line 442
  free((void *)r->buf_text);
#line 443
  free((void *)r->buf_rend);
#line 444
  free((void *)r->tabs);
#line 447
  tmp___0 = (text_t **)((void *)0);
#line 447
  r->swap.text = tmp___0;
#line 447
  tmp = tmp___0;
#line 447
  r->drawn_text = tmp;
#line 447
  r->screen.text = tmp;
#line 448
  tmp___2 = (u_int16_t **)((void *)0);
#line 448
  r->swap.rend = tmp___2;
#line 448
  tmp___1 = tmp___2;
#line 448
  r->drawn_rend = tmp___1;
#line 448
  r->screen.rend = tmp___1;
#line 449
  tmp___3 = (int16_t *)((void *)0);
#line 449
  r->swap.tlen = tmp___3;
#line 449
  r->screen.tlen = tmp___3;
#line 450
  r->buf_text = (text_t **)((void *)0);
#line 451
  r->buf_rend = (u_int16_t **)((void *)0);
#line 452
  r->tabs = (char *)((void *)0);
  }
#line 453
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_poweron(rxvt_t *r ) 
{ 
  u_int16_t tmp ;

  {
  {
#line 465
  rxvt_scr_release(r);
#line 466
  tmp = (u_int16_t )0;
#line 466
  (r->h)->prev_ncol = tmp;
#line 466
  (r->h)->prev_nrow = tmp;
#line 467
  rxvt_scr_reset(r);
#line 469
  rxvt_scr_clear(r);
#line 470
  rxvt_scr_refresh(r, (unsigned char )(1 << 1));
  }
#line 472
  return;
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_cursor(rxvt_t *r , int mode ) 
{ 
  screen_t *s ;

  {
#line 491
  if ((int )(r->h)->current_screen == 1) {
#line 492
    s = & r->swap;
  } else {
#line 495
    s = & r->screen;
  }
  {
#line 497
  if (mode == 115) {
#line 497
    goto case_115;
  }
#line 504
  if (mode == 114) {
#line 504
    goto case_114;
  }
#line 496
  goto switch_break;
  case_115: /* CIL Label */ 
#line 498
  s->s_cur.row = s->cur.row;
#line 499
  s->s_cur.col = s->cur.col;
#line 500
  s->s_rstyle = (r->h)->rstyle;
#line 501
  s->s_charset = s->charset;
#line 502
  s->s_charset_char = (r->h)->charsets[s->charset];
#line 503
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 505
  (r->h)->want_refresh = (unsigned char)1;
#line 506
  s->cur.row = s->s_cur.row;
#line 507
  s->cur.col = s->s_cur.col;
#line 508
  s->flags &= (unsigned int )(~ (1 << 4));
#line 509
  (r->h)->rstyle = s->s_rstyle;
#line 510
  s->charset = s->s_charset;
#line 511
  (r->h)->charsets[s->charset] = s->s_charset_char;
#line 512
  rxvt_set_font_style(r);
  }
#line 513
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 516
  if ((int )r->TermWin.nrow - 1 < s->cur.row) {
#line 516
    s->cur.row = (int )r->TermWin.nrow - 1;
  }
#line 517
  if ((int )r->TermWin.ncol - 1 < s->cur.col) {
#line 517
    s->cur.col = (int )r->TermWin.ncol - 1;
  }
#line 519
  if (! (s->cur.row >= 0)) {
    {
#line 519
    __assert_fail("s->cur.row >= 0", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                  519U, "rxvt_scr_cursor");
    }
  }
#line 520
  if (! (s->cur.col >= 0)) {
    {
#line 520
    __assert_fail("s->cur.col >= 0", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                  520U, "rxvt_scr_cursor");
    }
  }
#line 525
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
int rxvt_scr_change_screen(rxvt_t *r , int scrn ) 
{ 
  int i ;
  int offset ;
  int swapittmp ;
  text_t *swapittmp___0 ;
  int16_t swapittmp___1 ;
  u_int16_t *swapittmp___2 ;
  int tmp ;
  int16_t swapittmp___3 ;
  int16_t swapittmp___4 ;
  int16_t swapittmp___5 ;
  int swapittmp___6 ;

  {
#line 542
  (r->h)->want_refresh = (unsigned char)1;
#line 546
  r->TermWin.view_start = (u_int16_t )0;
#line 549
  if ((int )(r->h)->current_screen == scrn) {
#line 550
    return ((int )(r->h)->current_screen);
  }
  {
#line 552
  rxvt_selection_check(r, 2);
  }
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    swapittmp = (int )(r->h)->current_screen;
#line 554
    (r->h)->current_screen = (unsigned char )scrn;
#line 554
    scrn = swapittmp;
#line 554
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  (r->h)->num_scr = (int16_t )0;
#line 557
  offset = (int )r->TermWin.saveLines;
#line 558
  i = (int )(r->h)->prev_nrow;
  {
#line 558
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 558
    tmp = i;
#line 558
    i --;
#line 558
    if (! tmp) {
#line 558
      goto while_break___0;
    }
    {
#line 559
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 559
      swapittmp___0 = *(r->screen.text + (i + offset));
#line 559
      *(r->screen.text + (i + offset)) = *(r->swap.text + i);
#line 559
      *(r->swap.text + i) = swapittmp___0;
#line 559
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 560
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 560
      swapittmp___1 = *(r->screen.tlen + (i + offset));
#line 560
      *(r->screen.tlen + (i + offset)) = *(r->swap.tlen + i);
#line 560
      *(r->swap.tlen + i) = swapittmp___1;
#line 560
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 561
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 561
      swapittmp___2 = *(r->screen.rend + (i + offset));
#line 561
      *(r->screen.rend + (i + offset)) = *(r->swap.rend + i);
#line 561
      *(r->swap.rend + i) = swapittmp___2;
#line 561
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 563
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 563
    swapittmp___3 = (int16_t )r->screen.cur.row;
#line 563
    r->screen.cur.row = r->swap.cur.row;
#line 563
    r->swap.cur.row = (int32_t )swapittmp___3;
#line 563
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 564
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 564
    swapittmp___4 = (int16_t )r->screen.cur.col;
#line 564
    r->screen.cur.col = r->swap.cur.col;
#line 564
    r->swap.cur.col = (int32_t )swapittmp___4;
#line 564
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 566
  if (r->screen.cur.row >= 0) {
#line 566
    if (! (r->screen.cur.row < (int32_t )(r->h)->prev_nrow)) {
      {
#line 566
      __assert_fail("(r->screen.cur.row >= 0) && (r->screen.cur.row < r->h->prev_nrow)",
                    "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                    566U, "rxvt_scr_change_screen");
      }
    }
  } else {
    {
#line 566
    __assert_fail("(r->screen.cur.row >= 0) && (r->screen.cur.row < r->h->prev_nrow)",
                  "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                  566U, "rxvt_scr_change_screen");
    }
  }
#line 567
  if (r->screen.cur.col >= 0) {
#line 567
    if (! (r->screen.cur.col < (int32_t )(r->h)->prev_ncol)) {
      {
#line 567
      __assert_fail("(r->screen.cur.col >= 0) && (r->screen.cur.col < r->h->prev_ncol)",
                    "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                    567U, "rxvt_scr_change_screen");
      }
    }
  } else {
    {
#line 567
    __assert_fail("(r->screen.cur.col >= 0) && (r->screen.cur.col < r->h->prev_ncol)",
                  "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                  567U, "rxvt_scr_change_screen");
    }
  }
  {
#line 574
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 574
    swapittmp___5 = (int16_t )r->screen.charset;
#line 574
    r->screen.charset = r->swap.charset;
#line 574
    r->swap.charset = (u_int16_t )swapittmp___5;
#line 574
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 575
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 575
    swapittmp___6 = (int )r->screen.flags;
#line 575
    r->screen.flags = r->swap.flags;
#line 575
    r->swap.flags = (unsigned int )swapittmp___6;
#line 575
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 576
  r->screen.flags |= (unsigned int )(1 << 1);
#line 577
  r->swap.flags |= (unsigned int )(1 << 1);
#line 591
  return (scrn);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_color(rxvt_t *r , unsigned int color , int fgbg ) 
{ 


  {
#line 602
  color &= 31U;
#line 603
  if (fgbg == 0) {
#line 604
    (r->h)->rstyle = (u_int16_t )(((unsigned int )(r->h)->rstyle & 4294967264U) | color);
  } else {
#line 606
    (r->h)->rstyle = (u_int16_t )(((unsigned int )(r->h)->rstyle & 4294966303U) | (color << 5));
  }
#line 607
  return;
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_rendition(rxvt_t *r , int set , int style ) 
{ 


  {
#line 617
  if (set) {
#line 618
    (r->h)->rstyle = (u_int16_t )((int )(r->h)->rstyle | style);
  } else
#line 619
  if (style == -1) {
#line 620
    (r->h)->rstyle = (u_int16_t )((unsigned int )(1 << 5) | ((unsigned int )(r->h)->rstyle & 49152U));
  } else {
#line 622
    (r->h)->rstyle = (u_int16_t )((int )(r->h)->rstyle & ~ style);
  }
#line 623
  return;
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
int rxvt_scroll_text(rxvt_t *r , int row1 , int row2 , int count , int spec ) 
{ 
  int i ;
  int j ;
  long nscrolled ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int tmp___4 ;

  {
#line 639
  if (count == 0) {
#line 640
    return (0);
  } else
#line 639
  if (row1 > row2) {
#line 640
    return (0);
  }
#line 642
  (r->h)->want_refresh = (unsigned char)1;
#line 645
  if (count > 0) {
#line 645
    if (row1 == 0) {
#line 645
      if ((int )(r->h)->current_screen == 0) {
#line 646
        nscrolled = (long )r->TermWin.nscrolled + (long )count;
#line 647
        if (nscrolled > (long )r->TermWin.saveLines) {
#line 648
          r->TermWin.nscrolled = r->TermWin.saveLines;
        } else {
#line 650
          r->TermWin.nscrolled = (u_int16_t )nscrolled;
        }
#line 651
        if (r->Options & (1UL << 17)) {
#line 651
          if ((int )r->TermWin.view_start != 0) {
#line 651
            if ((int )r->TermWin.view_start != (int )r->TermWin.saveLines) {
              {
#line 654
              rxvt_scr_page(r, (enum page_dirn )0, count);
              }
            }
          }
        }
      } else {
#line 645
        goto _L___0;
      }
    } else {
#line 645
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 655
  if (! spec) {
#line 656
    row1 += (int )r->TermWin.saveLines;
  }
#line 657
  row2 += (int )r->TermWin.saveLines;
#line 659
  if (r->selection.op) {
#line 659
    if ((int )(r->h)->current_screen == (int )r->selection.screen) {
#line 660
      i = r->selection.beg.row + (int32_t )r->TermWin.saveLines;
#line 661
      j = r->selection.end.row + (int32_t )r->TermWin.saveLines;
#line 662
      if (i < row1) {
#line 662
        if (j > row1) {
#line 662
          goto _L___1;
        } else {
#line 662
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 662
      if (i < row2) {
#line 662
        if (j > row2) {
#line 662
          goto _L___1;
        } else {
#line 662
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 662
      if (i - count < row1) {
#line 662
        if (i >= row1) {
#line 662
          goto _L___1;
        } else {
#line 662
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 662
      if (i - count > row2) {
#line 662
        if (i <= row2) {
#line 662
          goto _L___1;
        } else {
#line 662
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 662
      if (j - count < row1) {
#line 662
        if (j >= row1) {
#line 662
          goto _L___1;
        } else {
#line 662
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 662
      if (j - count > row2) {
#line 662
        if (j <= row2) {
          _L___1: /* CIL Label */ 
#line 668
          tmp___3 = 0;
#line 668
          r->selection.end.col = tmp___3;
#line 668
          tmp___2 = tmp___3;
#line 668
          r->selection.end.row = tmp___2;
#line 668
          tmp___1 = tmp___2;
#line 668
          r->selection.mark.col = tmp___1;
#line 668
          tmp___0 = tmp___1;
#line 668
          r->selection.mark.row = tmp___0;
#line 668
          tmp = tmp___0;
#line 668
          r->selection.beg.col = tmp;
#line 668
          r->selection.beg.row = tmp;
#line 669
          r->selection.op = (enum __anonenum_op_166 )0;
        } else {
#line 662
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 670
      if (j >= row1) {
#line 670
        if (j <= row2) {
#line 672
          r->selection.beg.row -= count;
#line 673
          r->selection.end.row -= count;
#line 674
          r->selection.mark.row -= count;
        }
      }
    }
  }
  {
#line 677
  rxvt_selection_check(r, 0);
#line 679
  (r->h)->num_scr = (int16_t )((int )(r->h)->num_scr + count);
#line 680
  j = count;
  }
#line 681
  if (count < 0) {
#line 682
    count = - count;
  }
#line 683
  i = (row2 - row1) + 1;
#line 684
  if (i < count) {
#line 684
    count = i;
  }
#line 686
  if (j > 0) {
#line 690
    i = 0;
#line 690
    j = row1;
    {
#line 690
    while (1) {
      while_continue: /* CIL Label */ ;
#line 690
      if (! (i < count)) {
#line 690
        goto while_break;
      }
#line 691
      *(r->buf_text + i) = *(r->screen.text + j);
#line 692
      *(r->buf_rend + i) = *(r->screen.rend + j);
#line 690
      i ++;
#line 690
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 695
    j = row1;
#line 695
    i = j + count;
    {
#line 695
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 695
      if (! (i <= row2)) {
#line 695
        goto while_break___0;
      }
#line 696
      *(r->screen.tlen + j) = *(r->screen.tlen + i);
#line 697
      *(r->screen.text + j) = *(r->screen.text + i);
#line 698
      *(r->screen.rend + j) = *(r->screen.rend + i);
#line 695
      i ++;
#line 695
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 700
    j = (row2 - count) + 1;
#line 700
    i = count;
  } else {
#line 705
    i = 0;
#line 705
    j = row2;
    {
#line 705
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 705
      if (! (i < count)) {
#line 705
        goto while_break___1;
      }
#line 706
      *(r->buf_text + i) = *(r->screen.text + j);
#line 707
      *(r->buf_rend + i) = *(r->screen.rend + j);
#line 705
      i ++;
#line 705
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 710
    j = row2;
#line 710
    i = j - count;
    {
#line 710
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 710
      if (! (i >= row1)) {
#line 710
        goto while_break___2;
      }
#line 711
      *(r->screen.tlen + j) = *(r->screen.tlen + i);
#line 712
      *(r->screen.text + j) = *(r->screen.text + i);
#line 713
      *(r->screen.rend + j) = *(r->screen.rend + i);
#line 710
      i --;
#line 710
      j --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 715
    j = row1;
#line 715
    i = count;
#line 716
    count = - count;
  }
  {
#line 720
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 720
    tmp___4 = i;
#line 720
    i --;
#line 720
    if (! tmp___4) {
#line 720
      goto while_break___3;
    }
#line 721
    *(r->screen.tlen + j) = (int16_t )0;
#line 722
    *(r->screen.text + j) = *(r->buf_text + i);
#line 723
    *(r->screen.rend + j) = *(r->buf_rend + i);
#line 724
    if (! spec) {
      {
#line 725
      rxvt_blank_screen_mem(r, r->screen.text, r->screen.rend, (unsigned int )j, (r->h)->rstyle);
      }
    }
#line 720
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 731
  return (count);
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_add_lines(rxvt_t *r , unsigned char const   *str , int nlines , int len ) 
{ 
  unsigned char checksel ;
  unsigned char clearsel ;
  char c ;
  int i ;
  int row ;
  int last_col ;
  text_t *stp ;
  u_int16_t *srp ;
  struct rxvt_hidden *h ;
  int tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;

  {
#line 747
  h = r->h;
#line 749
  if (len <= 0) {
#line 750
    return;
  }
#line 752
  h->want_refresh = (unsigned char)1;
#line 753
  last_col = (int )r->TermWin.ncol;
#line 756
  if ((r->Options & (1UL << 11)) == 1UL << 11) {
#line 756
    r->TermWin.view_start = (u_int16_t )0;
  }
#line 757
  if (nlines > 0) {
#line 758
    nlines += r->screen.cur.row - (int32_t )r->screen.bscroll;
#line 759
    if (nlines > 0) {
#line 759
      if ((int )r->screen.tscroll == 0) {
#line 759
        if ((int )r->screen.bscroll == (int )r->TermWin.nrow - 1) {
          {
#line 763
          rxvt_scroll_text(r, (int )r->screen.tscroll, (int )r->screen.bscroll, nlines,
                           0);
#line 765
          r->screen.cur.row -= nlines;
          }
        }
      }
    }
  }
#line 769
  if (! (r->screen.cur.col < last_col)) {
    {
#line 769
    __assert_fail("r->screen.cur.col < last_col", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                  769U, "rxvt_scr_add_lines");
    }
  }
#line 770
  if (r->screen.cur.row < (int32_t )r->TermWin.nrow) {
#line 770
    if (! (r->screen.cur.row >= - ((int32_t )r->TermWin.nscrolled))) {
      {
#line 770
      __assert_fail("(r->screen.cur.row < r->TermWin.nrow) && (r->screen.cur.row >= -(int32_t)r->TermWin.nscrolled)",
                    "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                    771U, "rxvt_scr_add_lines");
      }
    }
  } else {
    {
#line 770
    __assert_fail("(r->screen.cur.row < r->TermWin.nrow) && (r->screen.cur.row >= -(int32_t)r->TermWin.nscrolled)",
                  "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                  771U, "rxvt_scr_add_lines");
    }
  }
#line 777
  row = r->screen.cur.row + (int32_t )r->TermWin.saveLines;
#line 779
  if (r->selection.op) {
#line 779
    if ((int )h->current_screen == (int )r->selection.screen) {
#line 779
      checksel = (unsigned char)1;
    } else {
#line 779
      checksel = (unsigned char)0;
    }
  } else {
#line 779
    checksel = (unsigned char)0;
  }
#line 781
  clearsel = (unsigned char)0;
#line 783
  stp = *(r->screen.text + row);
#line 784
  srp = *(r->screen.rend + row);
#line 793
  i = 0;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! (i < len)) {
#line 793
      goto while_break;
    }
#line 794
    tmp = i;
#line 794
    i ++;
#line 794
    c = (char )*(str + tmp);
    {
#line 796
    if ((int )c == 9) {
#line 796
      goto case_9;
    }
#line 799
    if ((int )c == 10) {
#line 799
      goto case_10;
    }
#line 811
    if ((int )c == 13) {
#line 811
      goto case_13;
    }
#line 818
    goto switch_default;
    case_9: /* CIL Label */ 
    {
#line 797
    rxvt_scr_tab(r, 1);
    }
#line 798
    goto __Cont;
    case_10: /* CIL Label */ 
#line 800
    if ((int )*(r->screen.tlen + row) != -1) {
#line 801
      if (r->screen.cur.col > (int32_t )*(r->screen.tlen + row)) {
#line 801
        *(r->screen.tlen + row) = (int16_t )r->screen.cur.col;
      }
    }
#line 802
    r->screen.flags &= (unsigned int )(~ (1 << 4));
#line 803
    if (r->screen.cur.row == (int32_t )r->screen.bscroll) {
      {
#line 804
      rxvt_scroll_text(r, (int )r->screen.tscroll, (int )r->screen.bscroll, 1, 0);
      }
    } else
#line 805
    if (r->screen.cur.row < (int )r->TermWin.nrow - 1) {
#line 806
      (r->screen.cur.row) ++;
#line 806
      row = r->screen.cur.row + (int32_t )r->TermWin.saveLines;
    }
#line 807
    stp = *(r->screen.text + row);
#line 808
    srp = *(r->screen.rend + row);
#line 810
    goto __Cont;
    case_13: /* CIL Label */ 
#line 812
    if ((int )*(r->screen.tlen + row) != -1) {
#line 813
      if (r->screen.cur.col > (int32_t )*(r->screen.tlen + row)) {
#line 813
        *(r->screen.tlen + row) = (int16_t )r->screen.cur.col;
      }
    }
#line 814
    r->screen.flags &= (unsigned int )(~ (1 << 4));
#line 815
    r->screen.cur.col = 0;
#line 817
    goto __Cont;
    switch_default: /* CIL Label */ 
#line 841
    if ((int )c == 127) {
#line 842
      goto __Cont;
    }
#line 843
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 846
    if (checksel) {
#line 846
      if (! (r->screen.cur.row < r->selection.beg.row)) {
#line 846
        if (r->screen.cur.row == r->selection.beg.row) {
#line 846
          if (! (r->screen.cur.col < r->selection.beg.col)) {
#line 846
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 846
        if (r->screen.cur.row < r->selection.end.row) {
#line 849
          checksel = (unsigned char)0;
#line 850
          clearsel = (unsigned char)1;
        } else
#line 846
        if (r->screen.cur.row == r->selection.end.row) {
#line 846
          if (r->screen.cur.col < r->selection.end.col) {
#line 849
            checksel = (unsigned char)0;
#line 850
            clearsel = (unsigned char)1;
          }
        }
      }
    }
#line 852
    if (r->screen.flags & (unsigned int )(1 << 4)) {
#line 853
      *(r->screen.tlen + row) = (int16_t )-1;
#line 854
      if (r->screen.cur.row == (int32_t )r->screen.bscroll) {
        {
#line 855
        rxvt_scroll_text(r, (int )r->screen.tscroll, (int )r->screen.bscroll, 1, 0);
        }
      } else
#line 856
      if (r->screen.cur.row < (int )r->TermWin.nrow - 1) {
#line 857
        (r->screen.cur.row) ++;
#line 857
        row = r->screen.cur.row + (int32_t )r->TermWin.saveLines;
      }
#line 858
      stp = *(r->screen.text + row);
#line 859
      srp = *(r->screen.rend + row);
#line 860
      r->screen.cur.col = 0;
#line 861
      r->screen.flags &= (unsigned int )(~ (1 << 4));
    }
#line 863
    if (r->screen.flags & (unsigned int )(1 << 3)) {
      {
#line 864
      rxvt_scr_insdel_chars(r, 1, -1);
      }
    }
#line 877
    *(stp + r->screen.cur.col) = (text_t )c;
#line 878
    *(srp + r->screen.cur.col) = h->rstyle;
#line 879
    if (r->screen.cur.col < last_col - 1) {
#line 880
      (r->screen.cur.col) ++;
    } else {
#line 882
      *(r->screen.tlen + row) = (int16_t )last_col;
#line 883
      if (r->screen.flags & (unsigned int )(1 << 2)) {
#line 884
        r->screen.flags |= (unsigned int )(1 << 4);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 887
  if ((int )*(r->screen.tlen + row) != -1) {
#line 888
    if (r->screen.cur.col > (int32_t )*(r->screen.tlen + row)) {
#line 888
      *(r->screen.tlen + row) = (int16_t )r->screen.cur.col;
    }
  }
#line 895
  if (clearsel) {
#line 896
    tmp___2 = 0;
#line 896
    r->selection.end.col = tmp___2;
#line 896
    tmp___1 = tmp___2;
#line 896
    r->selection.end.row = tmp___1;
#line 896
    tmp___0 = tmp___1;
#line 896
    r->selection.beg.col = tmp___0;
#line 896
    r->selection.beg.row = tmp___0;
  }
#line 899
  if (! (r->screen.cur.row >= 0)) {
    {
#line 899
    __assert_fail("r->screen.cur.row >= 0", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                  899U, "rxvt_scr_add_lines");
    }
  }
#line 903
  return;
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_backspace(rxvt_t *r ) 
{ 


  {
#line 915
  (r->h)->want_refresh = (unsigned char)1;
#line 916
  if (! (r->screen.cur.col == 0)) {
#line 924
    if ((r->screen.flags & (unsigned int )(1 << 4)) == 0U) {
      {
#line 925
      rxvt_scr_gotorc(r, 0, -1, 3);
      }
    }
  }
#line 926
  r->screen.flags &= (unsigned int )(~ (1 << 4));
#line 927
  return;
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_tab(rxvt_t *r , int count ) 
{ 
  int i ;
  int x ;

  {
#line 942
  (r->h)->want_refresh = (unsigned char)1;
#line 944
  x = r->screen.cur.col;
#line 944
  i = x;
#line 945
  if (count == 0) {
#line 946
    return;
  } else
#line 947
  if (count > 0) {
    {
#line 948
    while (1) {
      while_continue: /* CIL Label */ ;
#line 948
      i ++;
#line 948
      if (! (i < (int )r->TermWin.ncol)) {
#line 948
        goto while_break;
      }
#line 949
      if (*(r->tabs + i)) {
#line 950
        x = i;
#line 951
        count --;
#line 951
        if (! count) {
#line 952
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 954
    if (count) {
#line 955
      x = (int )r->TermWin.ncol - 1;
    }
  } else {
    {
#line 957
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 957
      i --;
#line 957
      if (! (i >= 0)) {
#line 957
        goto while_break___0;
      }
#line 958
      if (*(r->tabs + i)) {
#line 959
        x = i;
#line 960
        count ++;
#line 960
        if (! count) {
#line 961
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 963
    if (count) {
#line 964
      x = 0;
    }
  }
#line 966
  if (x != r->screen.cur.col) {
    {
#line 967
    rxvt_scr_gotorc(r, 0, x, 2);
    }
  }
#line 968
  return;
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_gotorc(rxvt_t *r , int row , int col , int relative ) 
{ 


  {
#line 1028
  (r->h)->want_refresh = (unsigned char)1;
#line 1029
  if ((r->Options & (1UL << 11)) == 1UL << 11) {
#line 1029
    r->TermWin.view_start = (u_int16_t )0;
  }
#line 1036
  if (relative & 1) {
#line 1036
    r->screen.cur.col += col;
  } else {
#line 1036
    r->screen.cur.col = col;
  }
#line 1038
  if (0 > r->screen.cur.col) {
#line 1038
    r->screen.cur.col = 0;
  }
#line 1039
  if ((int )r->TermWin.ncol - 1 < r->screen.cur.col) {
#line 1039
    r->screen.cur.col = (int )r->TermWin.ncol - 1;
  }
#line 1041
  r->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1042
  if (relative & 2) {
#line 1043
    if (row > 0) {
#line 1044
      if (r->screen.cur.row <= (int32_t )r->screen.bscroll) {
#line 1044
        if (r->screen.cur.row + row > (int32_t )r->screen.bscroll) {
#line 1046
          r->screen.cur.row = (int32_t )r->screen.bscroll;
        } else {
#line 1048
          r->screen.cur.row += row;
        }
      } else {
#line 1048
        r->screen.cur.row += row;
      }
    } else
#line 1049
    if (row < 0) {
#line 1050
      if (r->screen.cur.row >= (int32_t )r->screen.tscroll) {
#line 1050
        if (r->screen.cur.row + row < (int32_t )r->screen.tscroll) {
#line 1052
          r->screen.cur.row = (int32_t )r->screen.tscroll;
        } else {
#line 1054
          r->screen.cur.row += row;
        }
      } else {
#line 1054
        r->screen.cur.row += row;
      }
    }
  } else
#line 1057
  if (r->screen.flags & 1U) {
#line 1058
    r->screen.cur.row = row + (int )r->screen.tscroll;
#line 1059
    if ((int )r->screen.bscroll < r->screen.cur.row) {
#line 1059
      r->screen.cur.row = (int32_t )r->screen.bscroll;
    }
  } else {
#line 1061
    r->screen.cur.row = row;
  }
#line 1063
  if (0 > r->screen.cur.row) {
#line 1063
    r->screen.cur.row = 0;
  }
#line 1064
  if ((int )r->TermWin.nrow - 1 < r->screen.cur.row) {
#line 1064
    r->screen.cur.row = (int )r->TermWin.nrow - 1;
  }
#line 1065
  return;
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_index(rxvt_t *r , enum page_dirn direction ) 
{ 
  int dirn ;

  {
#line 1077
  (r->h)->want_refresh = (unsigned char)1;
#line 1078
  if ((unsigned int )direction == 0U) {
#line 1078
    dirn = 1;
  } else {
#line 1078
    dirn = -1;
  }
#line 1081
  if ((r->Options & (1UL << 11)) == 1UL << 11) {
#line 1081
    r->TermWin.view_start = (u_int16_t )0;
  }
#line 1086
  r->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1087
  if (r->screen.cur.row == (int32_t )r->screen.bscroll) {
#line 1087
    if ((unsigned int )direction == 0U) {
      {
#line 1089
      rxvt_scroll_text(r, (int )r->screen.tscroll, (int )r->screen.bscroll, dirn,
                       0);
      }
    } else {
#line 1087
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1087
  if (r->screen.cur.row == (int32_t )r->screen.tscroll) {
#line 1087
    if ((unsigned int )direction == 1U) {
      {
#line 1089
      rxvt_scroll_text(r, (int )r->screen.tscroll, (int )r->screen.bscroll, dirn,
                       0);
      }
    } else {
#line 1091
      r->screen.cur.row += dirn;
    }
  } else {
#line 1091
    r->screen.cur.row += dirn;
  }
#line 1092
  if (0 > r->screen.cur.row) {
#line 1092
    r->screen.cur.row = 0;
  }
#line 1093
  if ((int )r->TermWin.nrow - 1 < r->screen.cur.row) {
#line 1093
    r->screen.cur.row = (int )r->TermWin.nrow - 1;
  }
  {
#line 1094
  rxvt_selection_check(r, 0);
  }
#line 1095
  return;
}
}
#line 1105 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_erase_line(rxvt_t *r , int mode ) 
{ 
  unsigned int row ;
  unsigned int col ;
  unsigned int num ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;
  int32_t tmp___5 ;
  int32_t tmp___6 ;
  int32_t tmp___7 ;

  {
#line 1110
  (r->h)->want_refresh = (unsigned char)1;
#line 1112
  if ((r->Options & (1UL << 11)) == 1UL << 11) {
#line 1112
    r->TermWin.view_start = (u_int16_t )0;
  }
  {
#line 1116
  rxvt_selection_check(r, 1);
#line 1118
  r->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1120
  row = (unsigned int )((int )r->TermWin.saveLines + r->screen.cur.row);
  }
  {
#line 1122
  if (mode == 0) {
#line 1122
    goto case_0;
  }
#line 1130
  if (mode == 1) {
#line 1130
    goto case_1;
  }
#line 1137
  if (mode == 2) {
#line 1137
    goto case_2;
  }
#line 1145
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1123
  col = (unsigned int )r->screen.cur.col;
#line 1124
  num = (unsigned int )r->TermWin.ncol - col;
#line 1125
  if ((int )((int16_t )col) < (int )*(r->screen.tlen + row)) {
#line 1125
    *(r->screen.tlen + row) = (int16_t )col;
  }
#line 1126
  if (r->selection.beg.row == r->screen.cur.row) {
#line 1126
    if (r->selection.beg.col >= r->screen.cur.col) {
#line 1126
      goto _L;
    } else {
#line 1126
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1126
  if (r->selection.end.row == r->screen.cur.row) {
#line 1126
    if (r->selection.end.col >= r->screen.cur.col) {
      _L: /* CIL Label */ 
#line 1128
      tmp___1 = 0;
#line 1128
      r->selection.end.col = tmp___1;
#line 1128
      tmp___0 = tmp___1;
#line 1128
      r->selection.end.row = tmp___0;
#line 1128
      tmp = tmp___0;
#line 1128
      r->selection.beg.col = tmp;
#line 1128
      r->selection.beg.row = tmp;
    }
  }
#line 1129
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1131
  col = 0U;
#line 1132
  num = (unsigned int )(r->screen.cur.col + 1);
#line 1133
  if (r->selection.beg.row == r->screen.cur.row) {
#line 1133
    if (r->selection.beg.col <= r->screen.cur.col) {
#line 1133
      goto _L___1;
    } else {
#line 1133
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1133
  if (r->selection.end.row == r->screen.cur.row) {
#line 1133
    if (r->selection.end.col <= r->screen.cur.col) {
      _L___1: /* CIL Label */ 
#line 1135
      tmp___4 = 0;
#line 1135
      r->selection.end.col = tmp___4;
#line 1135
      tmp___3 = tmp___4;
#line 1135
      r->selection.end.row = tmp___3;
#line 1135
      tmp___2 = tmp___3;
#line 1135
      r->selection.beg.col = tmp___2;
#line 1135
      r->selection.beg.row = tmp___2;
    }
  }
#line 1136
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1138
  col = 0U;
#line 1139
  num = (unsigned int )r->TermWin.ncol;
#line 1140
  *(r->screen.tlen + row) = (int16_t )0;
#line 1141
  if (r->selection.beg.row <= r->screen.cur.row) {
#line 1141
    if (r->selection.end.row >= r->screen.cur.row) {
#line 1143
      tmp___7 = 0;
#line 1143
      r->selection.end.col = tmp___7;
#line 1143
      tmp___6 = tmp___7;
#line 1143
      r->selection.end.row = tmp___6;
#line 1143
      tmp___5 = tmp___6;
#line 1143
      r->selection.beg.col = tmp___5;
#line 1143
      r->selection.beg.row = tmp___5;
    }
  }
#line 1144
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1146
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1148
  if (*(r->screen.text + row)) {
    {
#line 1149
    rxvt_blank_line(*(r->screen.text + row) + col, *(r->screen.rend + row) + col,
                    num, (r->h)->rstyle);
    }
  } else {
    {
#line 1152
    rxvt_blank_screen_mem(r, r->screen.text, r->screen.rend, row, (r->h)->rstyle);
    }
  }
#line 1154
  return;
}
}
#line 1164 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_erase_screen(rxvt_t *r , int mode ) 
{ 
  int num ;
  int32_t row ;
  int32_t row_offset ;
  u_int16_t ren ;
  XGCValues gcvalue ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 1172
  (r->h)->want_refresh = (unsigned char)1;
#line 1174
  if ((r->Options & (1UL << 11)) == 1UL << 11) {
#line 1174
    r->TermWin.view_start = (u_int16_t )0;
  }
#line 1176
  row_offset = (int32_t )r->TermWin.saveLines;
  {
#line 1179
  if (mode == 0) {
#line 1179
    goto case_0;
  }
#line 1185
  if (mode == 1) {
#line 1185
    goto case_1;
  }
#line 1191
  if (mode == 2) {
#line 1191
    goto case_2;
  }
#line 1197
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1180
  rxvt_selection_check(r, 1);
#line 1181
  rxvt_scr_erase_line(r, 0);
#line 1182
  row = r->screen.cur.row + 1;
#line 1183
  num = (int )r->TermWin.nrow - row;
  }
#line 1184
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1186
  rxvt_selection_check(r, 3);
#line 1187
  rxvt_scr_erase_line(r, 1);
#line 1188
  row = 0;
#line 1189
  num = r->screen.cur.row;
  }
#line 1190
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1192
  rxvt_selection_check(r, 3);
#line 1194
  row = 0;
#line 1195
  num = (int )r->TermWin.nrow;
  }
#line 1196
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1198
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1200
  (r->h)->refresh_type = (unsigned char )((int )(r->h)->refresh_type | (1 << 3));
#line 1201
  if (r->selection.op) {
#line 1201
    if ((int )(r->h)->current_screen == (int )r->selection.screen) {
#line 1201
      if (r->selection.beg.row >= row) {
#line 1201
        if (r->selection.beg.row <= row + num) {
#line 1201
          goto _L;
        } else {
#line 1201
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1201
      if (r->selection.end.row >= row) {
#line 1201
        if (r->selection.end.row <= row + num) {
          _L: /* CIL Label */ 
#line 1205
          tmp___1 = 0;
#line 1205
          r->selection.end.col = tmp___1;
#line 1205
          tmp___0 = tmp___1;
#line 1205
          r->selection.end.row = tmp___0;
#line 1205
          tmp = tmp___0;
#line 1205
          r->selection.beg.col = tmp;
#line 1205
          r->selection.beg.row = tmp;
        }
      }
    }
  }
#line 1206
  if (row >= (int32_t )r->TermWin.nrow) {
#line 1207
    return;
  }
#line 1208
  if ((int )r->TermWin.nrow - row < num) {
#line 1208
    num = (int )r->TermWin.nrow - row;
  }
#line 1209
  if ((unsigned int )(r->h)->rstyle & 12288U) {
#line 1210
    ren = (u_int16_t )(~ 0);
  } else
#line 1211
  if (((unsigned int )(r->h)->rstyle & 992U) >> 5 == 1U) {
#line 1212
    ren = (u_int16_t )(1 << 5);
#line 1213
    if (r->TermWin.mapped) {
      {
#line 1213
      XClearArea(r->Xdisplay, r->TermWin.vt, (int )r->TermWin.int_bwidth, row * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth,
                 (unsigned int )r->TermWin.width, (unsigned int )(num * (int32_t )r->TermWin.fheight),
                 0);
      }
    }
  } else {
#line 1215
    ren = (u_int16_t )((unsigned int )(r->h)->rstyle & 1023U);
#line 1216
    if (((unsigned int )(r->h)->rstyle & 2048U) == 0U) {
#line 1216
      tmp___2 = ((unsigned int )(r->h)->rstyle & 992U) >> 5;
    } else
#line 1216
    if (((unsigned int )(r->h)->rstyle & 992U) >> 5 < 2U) {
#line 1216
      tmp___2 = ((unsigned int )(r->h)->rstyle & 992U) >> 5;
    } else
#line 1216
    if (((unsigned int )(r->h)->rstyle & 992U) >> 5 >= 10U) {
#line 1216
      tmp___2 = ((unsigned int )(r->h)->rstyle & 992U) >> 5;
    } else {
#line 1216
      tmp___2 = (((unsigned int )(r->h)->rstyle & 992U) >> 5) + 8U;
    }
    {
#line 1216
    gcvalue.foreground = *(r->PixColors + tmp___2);
#line 1217
    XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )(1L << 2), & gcvalue);
#line 1218
    XFillRectangle(r->Xdisplay, r->TermWin.vt, r->TermWin.gc, (int )r->TermWin.int_bwidth,
                   row * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth,
                   (unsigned int )r->TermWin.width, (unsigned int )(num * (int32_t )r->TermWin.fheight));
#line 1219
    gcvalue.foreground = *(r->PixColors + 0);
#line 1220
    XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )(1L << 2), & gcvalue);
    }
  }
  {
#line 1222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1222
    tmp___3 = num;
#line 1222
    num --;
#line 1222
    if (! tmp___3) {
#line 1222
      goto while_break;
    }
    {
#line 1223
    rxvt_blank_screen_mem(r, r->screen.text, r->screen.rend, (unsigned int )(row + row_offset),
                          (r->h)->rstyle);
#line 1225
    *(r->screen.tlen + (row + row_offset)) = (int16_t )0;
#line 1226
    rxvt_blank_line(*(r->drawn_text + row), *(r->drawn_rend + row), (unsigned int )r->TermWin.ncol,
                    ren);
#line 1222
    row ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  return;
}
}
#line 1237 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_E(rxvt_t *r ) 
{ 
  int i ;
  int j ;
  int k ;
  u_int16_t *r1 ;
  u_int16_t fs ;
  u_int16_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1243
  (r->h)->want_refresh = (unsigned char)1;
#line 1244
  (r->h)->num_scr_allow = (unsigned char)0;
#line 1245
  if ((r->Options & (1UL << 11)) == 1UL << 11) {
#line 1245
    r->TermWin.view_start = (u_int16_t )0;
  }
  {
#line 1247
  rxvt_selection_check(r, 3);
#line 1249
  fs = (r->h)->rstyle;
#line 1250
  k = (int )r->TermWin.saveLines;
#line 1250
  i = (int )r->TermWin.nrow;
  }
  {
#line 1250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1250
    tmp___1 = i;
#line 1250
    i --;
#line 1250
    if (! tmp___1) {
#line 1250
      goto while_break;
    }
    {
#line 1251
    *(r->screen.tlen + k) = (int16_t )r->TermWin.ncol;
#line 1252
    memset((void *)*(r->screen.text + k), 'E', (size_t )r->TermWin.ncol);
#line 1253
    r1 = *(r->screen.rend + k);
#line 1253
    j = (int )r->TermWin.ncol;
    }
    {
#line 1253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1253
      tmp___0 = j;
#line 1253
      j --;
#line 1253
      if (! tmp___0) {
#line 1253
        goto while_break___0;
      }
#line 1254
      tmp = r1;
#line 1254
      r1 ++;
#line 1254
      *tmp = fs;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1250
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1256
  return;
}
}
#line 1263 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_insdel_lines(rxvt_t *r , int count , int insdel ) 
{ 
  int end ;

  {
#line 1268
  if ((r->Options & (1UL << 11)) == 1UL << 11) {
#line 1268
    r->TermWin.view_start = (u_int16_t )0;
  }
  {
#line 1272
  rxvt_selection_check(r, 1);
  }
#line 1274
  if (r->screen.cur.row > (int32_t )r->screen.bscroll) {
#line 1275
    return;
  }
#line 1277
  end = ((int )r->screen.bscroll - r->screen.cur.row) + 1;
#line 1278
  if (count > end) {
#line 1279
    if (insdel == 1) {
#line 1280
      return;
    } else
#line 1281
    if (insdel == -1) {
#line 1282
      count = end;
    }
  }
  {
#line 1284
  r->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1286
  rxvt_scroll_text(r, r->screen.cur.row, (int )r->screen.bscroll, insdel * count,
                   0);
  }
#line 1288
  return;
}
}
#line 1295 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_insdel_chars(rxvt_t *r , int count , int insdel ) 
{ 
  int col ;
  int row ;
  u_int16_t tr ;
  text_t *stp ;
  u_int16_t *srp ;
  int16_t *slp ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;

  {
#line 1304
  (r->h)->want_refresh = (unsigned char)1;
#line 1305
  if ((r->Options & (1UL << 11)) == 1UL << 11) {
#line 1305
    r->TermWin.view_start = (u_int16_t )0;
  }
#line 1312
  if (count <= 0) {
#line 1313
    return;
  }
  {
#line 1315
  rxvt_selection_check(r, 1);
  }
#line 1316
  if ((int )r->TermWin.ncol - r->screen.cur.col < count) {
#line 1316
    count = (int )r->TermWin.ncol - r->screen.cur.col;
  }
#line 1318
  row = r->screen.cur.row + (int32_t )r->TermWin.saveLines;
#line 1319
  r->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1321
  stp = *(r->screen.text + row);
#line 1322
  srp = *(r->screen.rend + row);
#line 1323
  slp = r->screen.tlen + row;
  {
#line 1325
  if (insdel == -1) {
#line 1325
    goto case_neg_1;
  }
#line 1349
  if (insdel == 2) {
#line 1349
    goto case_2;
  }
#line 1356
  if (insdel == 1) {
#line 1356
    goto case_1;
  }
#line 1324
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 1326
  col = (int )r->TermWin.ncol - 1;
  {
#line 1326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1326
    if (! (col - count >= r->screen.cur.col)) {
#line 1326
      goto while_break;
    }
#line 1328
    *(stp + col) = *(stp + (col - count));
#line 1329
    *(srp + col) = *(srp + (col - count));
#line 1326
    col --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1331
  if ((int )*slp != -1) {
#line 1332
    *slp = (int16_t )((int )*slp + count);
#line 1333
    if ((int )r->TermWin.ncol < (int )*slp) {
#line 1333
      *slp = (int16_t )r->TermWin.ncol;
    }
  }
#line 1335
  if (r->selection.op) {
#line 1335
    if ((int )(r->h)->current_screen == (int )r->selection.screen) {
#line 1335
      if (r->selection.beg.row == r->screen.cur.row) {
#line 1335
        if (r->selection.beg.col >= r->screen.cur.col) {
#line 1337
          if (r->selection.end.row != r->screen.cur.row) {
#line 1337
            goto _L;
          } else
#line 1337
          if (r->selection.end.col + count >= (int32_t )r->TermWin.ncol) {
            _L: /* CIL Label */ 
#line 1339
            tmp___1 = 0;
#line 1339
            r->selection.end.col = tmp___1;
#line 1339
            tmp___0 = tmp___1;
#line 1339
            r->selection.end.row = tmp___0;
#line 1339
            tmp = tmp___0;
#line 1339
            r->selection.beg.col = tmp;
#line 1339
            r->selection.beg.row = tmp;
          } else {
#line 1341
            r->selection.beg.col += count;
#line 1342
            r->selection.mark.col += count;
#line 1343
            r->selection.end.col += count;
          }
        }
      }
    }
  }
  {
#line 1346
  rxvt_blank_line(stp + r->screen.cur.col, srp + r->screen.cur.col, (unsigned int )count,
                  (r->h)->rstyle);
  }
#line 1348
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1350
  r->screen.cur.col += count;
#line 1351
  rxvt_selection_check(r, 1);
#line 1352
  r->screen.cur.col -= count;
#line 1353
  rxvt_blank_line(stp + r->screen.cur.col, srp + r->screen.cur.col, (unsigned int )count,
                  (r->h)->rstyle);
  }
#line 1355
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1357
  tr = (u_int16_t )((unsigned int )*(srp + ((int )r->TermWin.ncol - 1)) & 16383U);
#line 1359
  col = r->screen.cur.col;
  {
#line 1359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1359
    if (! (col + count < (int )r->TermWin.ncol)) {
#line 1359
      goto while_break___0;
    }
#line 1360
    *(stp + col) = *(stp + (col + count));
#line 1361
    *(srp + col) = *(srp + (col + count));
#line 1359
    col ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1363
  rxvt_blank_line(stp + ((int )r->TermWin.ncol - count), srp + ((int )r->TermWin.ncol - count),
                  (unsigned int )count, tr);
  }
#line 1366
  if ((int )*slp == -1) {
#line 1367
    *slp = (int16_t )r->TermWin.ncol;
  }
#line 1368
  *slp = (int16_t )((int )*slp - count);
#line 1369
  if (0 > (int )*slp) {
#line 1369
    *slp = (int16_t )0;
  }
#line 1370
  if (r->selection.op) {
#line 1370
    if ((int )(r->h)->current_screen == (int )r->selection.screen) {
#line 1370
      if (r->selection.beg.row == r->screen.cur.row) {
#line 1370
        if (r->selection.beg.col >= r->screen.cur.col) {
#line 1372
          if (r->selection.end.row != r->screen.cur.row) {
#line 1372
            goto _L___0;
          } else
#line 1372
          if (r->screen.cur.col >= r->selection.beg.col - count) {
#line 1372
            goto _L___0;
          } else
#line 1372
          if (r->selection.end.col >= (int32_t )r->TermWin.ncol) {
            _L___0: /* CIL Label */ 
#line 1375
            tmp___4 = 0;
#line 1375
            r->selection.end.col = tmp___4;
#line 1375
            tmp___3 = tmp___4;
#line 1375
            r->selection.end.row = tmp___3;
#line 1375
            tmp___2 = tmp___3;
#line 1375
            r->selection.beg.col = tmp___2;
#line 1375
            r->selection.beg.row = tmp___2;
          } else {
#line 1378
            r->selection.beg.col -= count;
#line 1379
            r->selection.mark.col -= count;
#line 1380
            r->selection.end.col -= count;
          }
        }
      }
    }
  }
#line 1383
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1395
  return;
}
}
#line 1403 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_scroll_region(rxvt_t *r , int top , int bot ) 
{ 


  {
#line 1406
  if (0 > top) {
#line 1406
    top = 0;
  }
#line 1407
  if ((int )r->TermWin.nrow - 1 < bot) {
#line 1407
    bot = (int )r->TermWin.nrow - 1;
  }
#line 1408
  if (top > bot) {
#line 1409
    return;
  }
  {
#line 1410
  r->screen.tscroll = (u_int16_t )top;
#line 1411
  r->screen.bscroll = (u_int16_t )bot;
#line 1412
  rxvt_scr_gotorc(r, 0, 0, 0);
  }
#line 1413
  return;
}
}
#line 1422 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_cursor_visible(rxvt_t *r , int mode ) 
{ 


  {
#line 1425
  (r->h)->want_refresh = (unsigned char)1;
#line 1426
  if (mode) {
#line 1427
    r->screen.flags |= (unsigned int )(1 << 1);
  } else {
#line 1429
    r->screen.flags &= (unsigned int )(~ (1 << 1));
  }
#line 1430
  return;
}
}
#line 1439 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_autowrap(rxvt_t *r , int mode ) 
{ 


  {
#line 1442
  if (mode) {
#line 1443
    r->screen.flags |= (unsigned int )(1 << 2);
  } else {
#line 1445
    r->screen.flags &= (unsigned int )(~ ((1 << 2) | (1 << 4)));
  }
#line 1446
  return;
}
}
#line 1459 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_relative_origin(rxvt_t *r , int mode ) 
{ 


  {
#line 1462
  if (mode) {
#line 1463
    r->screen.flags |= 1U;
  } else {
#line 1465
    r->screen.flags &= 4294967294U;
  }
  {
#line 1466
  rxvt_scr_gotorc(r, 0, 0, 0);
  }
#line 1467
  return;
}
}
#line 1476 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_insert_mode(rxvt_t *r , int mode ) 
{ 


  {
#line 1479
  if (mode) {
#line 1480
    r->screen.flags |= (unsigned int )(1 << 3);
  } else {
#line 1482
    r->screen.flags &= (unsigned int )(~ (1 << 3));
  }
#line 1483
  return;
}
}
#line 1493 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_set_tab(rxvt_t *r , int mode ) 
{ 


  {
#line 1496
  if (mode < 0) {
    {
#line 1497
    memset((void *)r->tabs, 0, (unsigned long )r->TermWin.ncol * sizeof(char ));
    }
  } else
#line 1498
  if (r->screen.cur.col < (int32_t )r->TermWin.ncol) {
#line 1499
    if (mode) {
#line 1499
      *(r->tabs + r->screen.cur.col) = (char)1;
    } else {
#line 1499
      *(r->tabs + r->screen.cur.col) = (char)0;
    }
  }
#line 1500
  return;
}
}
#line 1509 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_rvideo_mode(rxvt_t *r , int mode ) 
{ 
  XGCValues gcvalue ;
  Pixel swapittmp ;

  {
#line 1514
  if ((int )(r->h)->rvideo != mode) {
#line 1515
    (r->h)->rvideo = (short )mode;
    {
#line 1516
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1516
      swapittmp = *(r->PixColors + 0);
#line 1516
      *(r->PixColors + 0) = *(r->PixColors + 1);
#line 1516
      *(r->PixColors + 1) = swapittmp;
#line 1516
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1523
    XSetWindowBackground(r->Xdisplay, r->TermWin.vt, *(r->PixColors + 1));
#line 1526
    gcvalue.foreground = *(r->PixColors + 0);
#line 1527
    gcvalue.background = *(r->PixColors + 1);
#line 1528
    XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )((1L << 3) | (1L << 2)),
              & gcvalue);
#line 1530
    rxvt_scr_clear(r);
#line 1531
    rxvt_scr_touch(r, 1);
    }
  }
#line 1533
  return;
}
}
#line 1541 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_report_position(rxvt_t *r ) 
{ 


  {
  {
#line 1544
  rxvt_tt_printf(r, "\033[%d;%dR", r->screen.cur.row + 1, r->screen.cur.col + 1);
  }
#line 1546
  return;
}
}
#line 1556 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_set_font_style(rxvt_t *r ) 
{ 


  {
#line 1559
  (r->h)->rstyle = (u_int16_t )((unsigned int )(r->h)->rstyle & 4294918143U);
  {
#line 1561
  if ((int )(r->h)->charsets[r->screen.charset] == 48) {
#line 1561
    goto case_48;
  }
#line 1564
  if ((int )(r->h)->charsets[r->screen.charset] == 65) {
#line 1564
    goto case_65;
  }
#line 1567
  if ((int )(r->h)->charsets[r->screen.charset] == 66) {
#line 1567
    goto case_66;
  }
#line 1569
  if ((int )(r->h)->charsets[r->screen.charset] == 60) {
#line 1569
    goto case_60;
  }
#line 1571
  if ((int )(r->h)->charsets[r->screen.charset] == 53) {
#line 1571
    goto case_53;
  }
#line 1573
  if ((int )(r->h)->charsets[r->screen.charset] == 67) {
#line 1573
    goto case_67;
  }
#line 1575
  if ((int )(r->h)->charsets[r->screen.charset] == 75) {
#line 1575
    goto case_75;
  }
#line 1560
  goto switch_break;
  case_48: /* CIL Label */ 
#line 1562
  (r->h)->rstyle = (u_int16_t )((unsigned int )(r->h)->rstyle | 16384U);
#line 1563
  goto switch_break;
  case_65: /* CIL Label */ 
#line 1565
  (r->h)->rstyle = (u_int16_t )((unsigned int )(r->h)->rstyle | 32768U);
#line 1566
  goto switch_break;
  case_66: /* CIL Label */ 
#line 1568
  goto switch_break;
  case_60: /* CIL Label */ 
#line 1570
  goto switch_break;
  case_53: /* CIL Label */ 
#line 1572
  goto switch_break;
  case_67: /* CIL Label */ 
#line 1574
  goto switch_break;
  case_75: /* CIL Label */ 
#line 1576
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1578
  return;
}
}
#line 1589 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_charset_choose(rxvt_t *r , int set ) 
{ 


  {
  {
#line 1592
  r->screen.charset = (u_int16_t )set;
#line 1593
  rxvt_set_font_style(r);
  }
#line 1594
  return;
}
}
#line 1606 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_charset_set(rxvt_t *r , int set , unsigned int ch ) 
{ 


  {
  {
#line 1613
  (r->h)->charsets[set] = (char )((unsigned char )ch);
#line 1614
  rxvt_set_font_style(r);
  }
#line 1615
  return;
}
}
#line 1714 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_expose(rxvt_t *r , int x , int y , int width , int height , int refresh ) 
{ 
  int i ;
  row_col_t rc[2] ;

  {
#line 1720
  if ((unsigned long )r->drawn_text == (unsigned long )((void *)0)) {
#line 1721
    return;
  }
#line 1724
  if (x > (int )r->TermWin.int_bwidth) {
#line 1724
    x = x;
  } else {
#line 1724
    x = (int )r->TermWin.int_bwidth;
  }
#line 1725
  if (x < (int )r->TermWin.width) {
#line 1725
    x = x;
  } else {
#line 1725
    x = (int )r->TermWin.width;
  }
#line 1726
  if (y > (int )r->TermWin.int_bwidth) {
#line 1726
    y = y;
  } else {
#line 1726
    y = (int )r->TermWin.int_bwidth;
  }
#line 1727
  if (y < (int )r->TermWin.height) {
#line 1727
    y = y;
  } else {
#line 1727
    y = (int )r->TermWin.height;
  }
#line 1731
  rc[0].col = (x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth;
#line 1732
  rc[0].row = (y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight;
#line 1734
  rc[1].col = (((x + width) + (int )r->TermWin.fwidth) - 1) / (int32_t )r->TermWin.fwidth;
#line 1735
  rc[1].row = ((((y + height) + (int )r->TermWin.fheight) - 1) - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight;
#line 1738
  i = 0;
  {
#line 1738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1738
    if (! (i < 2)) {
#line 1738
      goto while_break;
    }
#line 1739
    if ((int )r->TermWin.ncol - 1 < rc[i].col) {
#line 1739
      rc[i].col = (int )r->TermWin.ncol - 1;
    }
#line 1740
    if ((int )r->TermWin.nrow - 1 < rc[i].row) {
#line 1740
      rc[i].row = (int )r->TermWin.nrow - 1;
    }
#line 1738
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1745
  i = rc[0].row;
  {
#line 1745
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1745
    if (! (i <= rc[1].row)) {
#line 1745
      goto while_break___0;
    }
    {
#line 1746
    memset((void *)(*(r->drawn_text + i) + rc[0].col), 0, (size_t )((rc[1].col - rc[0].col) + 1));
#line 1745
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1749
  if (refresh) {
    {
#line 1750
    rxvt_scr_refresh(r, (unsigned char )((1 << 1) | (1 << 3)));
    }
  }
#line 1751
  return;
}
}
#line 1758 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_touch(rxvt_t *r , int refresh ) 
{ 


  {
  {
#line 1761
  rxvt_scr_expose(r, 0, 0, (int )r->TermWin.width, (int )r->TermWin.height, refresh);
  }
#line 1762
  return;
}
}
#line 1770 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
int rxvt_scr_move_to(rxvt_t *r , int y , int len ) 
{ 
  long p ;
  u_int16_t oldviewstart ;
  long tmp ;
  int tmp___0 ;

  {
#line 1773
  p = 0L;
#line 1776
  oldviewstart = r->TermWin.view_start;
#line 1777
  if (y < len) {
#line 1778
    p = (long )((((int )r->TermWin.nrow + (int )r->TermWin.nscrolled) * (len - y)) / len);
#line 1779
    p -= (long )((int )r->TermWin.nrow - 1);
#line 1780
    if (p > 0L) {
#line 1780
      p = p;
    } else {
#line 1780
      p = 0L;
    }
  }
#line 1782
  if (p < (long )r->TermWin.nscrolled) {
#line 1782
    tmp = p;
  } else {
#line 1782
    tmp = (long )r->TermWin.nscrolled;
  }
  {
#line 1782
  r->TermWin.view_start = (u_int16_t )tmp;
#line 1785
  tmp___0 = rxvt_scr_changeview(r, oldviewstart);
  }
#line 1785
  return (tmp___0);
}
}
#line 1794 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
int rxvt_scr_page(rxvt_t *r , enum page_dirn direction , int nlines ) 
{ 
  int n ;
  u_int16_t oldviewstart ;
  int tmp ;

  {
#line 1802
  if (nlines >= 0) {
#line 1802
    if (! (nlines <= (int )r->TermWin.nrow)) {
      {
#line 1802
      __assert_fail("(nlines >= 0) && (nlines <= r->TermWin.nrow)", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                    1802U, "rxvt_scr_page");
      }
    }
  } else {
    {
#line 1802
    __assert_fail("(nlines >= 0) && (nlines <= r->TermWin.nrow)", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c",
                  1802U, "rxvt_scr_page");
    }
  }
#line 1804
  oldviewstart = r->TermWin.view_start;
#line 1805
  if ((unsigned int )direction == 0U) {
#line 1806
    n = (int )r->TermWin.view_start + nlines;
#line 1807
    if (n < (int )r->TermWin.nscrolled) {
#line 1807
      r->TermWin.view_start = (u_int16_t )n;
    } else {
#line 1807
      r->TermWin.view_start = r->TermWin.nscrolled;
    }
  } else {
#line 1809
    n = (int )r->TermWin.view_start - nlines;
#line 1810
    if (n > 0) {
#line 1810
      r->TermWin.view_start = (u_int16_t )n;
    } else {
#line 1810
      r->TermWin.view_start = (u_int16_t )0;
    }
  }
  {
#line 1812
  tmp = rxvt_scr_changeview(r, oldviewstart);
  }
#line 1812
  return (tmp);
}
}
#line 1816 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
int rxvt_scr_changeview(rxvt_t *r , u_int16_t oldviewstart ) 
{ 


  {
#line 1819
  if ((int )r->TermWin.view_start != (int )oldviewstart) {
#line 1820
    (r->h)->want_refresh = (unsigned char)1;
#line 1823
    (r->h)->num_scr = (int16_t )((int )(r->h)->num_scr - ((int )r->TermWin.view_start - (int )oldviewstart));
  }
#line 1825
  return ((int )r->TermWin.view_start - (int )oldviewstart);
}
}
#line 1830 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_bell(rxvt_t *r ) 
{ 


  {
#line 1836
  if (r->Options & (1UL << 4)) {
    {
#line 1838
    XMapWindow(r->Xdisplay, r->TermWin.parent[0]);
    }
  }
#line 1840
  if (r->Options & (1UL << 3)) {
    {
#line 1841
    rxvt_scr_rvideo_mode(r, ! (r->h)->rvideo);
#line 1842
    rxvt_scr_rvideo_mode(r, ! (r->h)->rvideo);
    }
  } else {
    {
#line 1844
    XBell(r->Xdisplay, 0);
    }
  }
#line 1846
  return;
}
}
#line 1851 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_printscreen(rxvt_t *r , int fullhist ) 
{ 
  int i ;
  int r1 ;
  int nrows ;
  int row_offset ;
  text_t *t ;
  FILE *fd ;
  unsigned short const   **tmp ;

  {
  {
#line 1859
  fd = rxvt_popen_printer(r);
  }
#line 1859
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 1860
    return;
  }
#line 1861
  nrows = (int )r->TermWin.nrow;
#line 1862
  row_offset = (int )r->TermWin.saveLines;
#line 1863
  if (! fullhist) {
#line 1864
    row_offset -= (int )r->TermWin.view_start;
  } else {
#line 1866
    nrows += (int )r->TermWin.nscrolled;
#line 1867
    row_offset -= (int )r->TermWin.nscrolled;
  }
#line 1870
  r1 = 0;
  {
#line 1870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1870
    if (! (r1 < nrows)) {
#line 1870
      goto while_break;
    }
#line 1871
    t = *(r->screen.text + (r1 + row_offset));
#line 1872
    i = (int )r->TermWin.ncol - 1;
    {
#line 1872
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1872
      if (! (i >= 0)) {
#line 1872
        goto while_break___0;
      }
      {
#line 1873
      tmp = __ctype_b_loc();
      }
#line 1873
      if (! ((int const   )*(*tmp + (int )*(t + i)) & 8192)) {
#line 1874
        goto while_break___0;
      }
#line 1872
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1875
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%.*s\n",
            i + 1, t);
#line 1870
    r1 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1877
  rxvt_pclose_printer(fd);
  }
#line 1879
  return;
}
}
#line 1986 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
static int draw_string(rxvt_t *r , Display *display , Drawable d , GC gc , int x ,
                       int y , char *str , int len ) 
{ 


  {
  {
#line 1996
  XDrawString(display, d, gc, x, y, (char const   *)str, len);
  }
#line 1997
  return (0);
}
}
#line 1999 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
static int draw_image_string(rxvt_t *r , Display *display , Drawable d , GC gc , int x ,
                             int y , char *str , int len ) 
{ 


  {
  {
#line 2009
  XDrawImageString(display, d, gc, x, y, (char const   *)str, len);
  }
#line 2010
  return (0);
}
}
#line 2013 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_refresh(rxvt_t *r , unsigned char refresh_type ) 
{ 
  unsigned char clearfirst ;
  unsigned char clearlast ;
  unsigned char must_clear ;
  unsigned char bfont ;
  unsigned char rvid ;
  unsigned char wbyte ;
  char morecur ;
  unsigned char fore ;
  unsigned char back ;
  int16_t col ;
  int16_t row ;
  int16_t ocrow ;
  int16_t len ;
  int16_t wlen ;
  int i ;
  int row_offset ;
  u_int16_t cc1 ;
  XGCValues gcvalue ;
  u_int16_t *drp ;
  u_int16_t *srp ;
  text_t *dtp ;
  text_t *stp ;
  char *buffer ;
  struct rxvt_hidden *h ;
  int (*draw_string_func)() ;
  int (*draw_image_string_func)() ;
  void *tmp ;
  unsigned char setoldcursor ;
  u_int16_t ccol1 ;
  u_int16_t ccol2 ;
  int16_t nits ;
  int j ;
  u_int16_t *drp2 ;
  text_t *dtp2 ;
  int tmp___0 ;
  int16_t tmp___1 ;
  text_t *tmp___2 ;
  text_t *tmp___3 ;
  u_int16_t *tmp___4 ;
  u_int16_t *tmp___5 ;
  int16_t tmp___6 ;
  int swapittmp ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned char clear_next ;
  int j___0 ;
  int xpixel ;
  int ypixel ;
  int ypixelc ;
  unsigned long gcmask ;
  XFontStruct const   *wf ;
  unsigned char is_font_char ;
  unsigned char is_same_char ;
  text_t t ;
  int tmp___9 ;
  unsigned char fontdiff ;
  unsigned char fprop ;
  u_int16_t rend ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  int16_t tmp___12 ;
  text_t tmp___13 ;
  int16_t tmp___14 ;
  int tmp___15 ;
  unsigned char swapittmp___0 ;
  int tmp___16 ;
  unsigned long gctmp ;
  unsigned long gcmask___0 ;
  int tmp___17 ;

  {
#line 2024
  morecur = (char)0;
#line 2045
  h = r->h;
#line 2046
  draw_string_func = (int (*)())(& draw_string);
#line 2047
  draw_image_string_func = (int (*)())(& draw_image_string);
#line 2049
  if ((int )refresh_type == 0) {
#line 2050
    return;
  } else
#line 2049
  if (! r->TermWin.mapped) {
#line 2050
    return;
  }
#line 2055
  wbyte = (unsigned char)0;
#line 2055
  must_clear = wbyte;
#line 2055
  clearlast = must_clear;
#line 2055
  clearfirst = clearlast;
#line 2057
  bfont = (unsigned char)0;
#line 2060
  if (h->currmaxcol < (int )r->TermWin.ncol) {
    {
#line 2061
    h->currmaxcol = (int )r->TermWin.ncol;
#line 2062
    tmp = rxvt_realloc((void *)h->buffer, sizeof(char ) * (unsigned long )(h->currmaxcol + 1));
#line 2062
    h->buffer = (char *)tmp;
    }
  }
  {
#line 2064
  buffer = h->buffer;
#line 2065
  h->refresh_count = 0;
#line 2067
  row_offset = (int )r->TermWin.saveLines - (int )r->TermWin.view_start;
#line 2071
  XSetFont(r->Xdisplay, r->TermWin.gc, (r->TermWin.font)->fid);
  }
#line 2073
  if ((int )refresh_type & (1 << 3)) {
#line 2074
    clearlast = (unsigned char)1;
#line 2074
    clearfirst = clearlast;
#line 2075
    h->refresh_type = (unsigned char )((int )h->refresh_type & ~ (1 << 3));
  }
  {
#line 2083
  ocrow = (int16_t )h->oldcursor.row;
#line 2086
  gcvalue.foreground = *(r->PixColors + 0);
#line 2087
  gcvalue.background = *(r->PixColors + 1);
#line 2092
  rxvt_scr_reverse_selection(r);
  }
#line 2102
  if (r->screen.flags & (unsigned int )(1 << 1)) {
#line 2102
    if (r->TermWin.focus) {
#line 2103
      srp = *(r->screen.rend + (r->screen.cur.row + (int32_t )r->TermWin.saveLines)) + r->screen.cur.col;
#line 2105
      *srp = (u_int16_t )((unsigned int )*srp ^ 4096U);
#line 2107
      cc1 = (u_int16_t )((unsigned int )*srp & 1023U);
#line 2108
      if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 2108
        if (h->pixcolor_set[0] & (unsigned int )(1 << 18)) {
#line 2109
          ccol1 = (u_int16_t )18;
        } else {
#line 2108
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2112
      if (((unsigned int )h->rstyle & 1024U) == 0U) {
#line 2112
        ccol1 = (u_int16_t )((unsigned int )h->rstyle & 31U);
      } else
#line 2112
      if (((unsigned int )h->rstyle & 31U) < 2U) {
#line 2112
        ccol1 = (u_int16_t )((unsigned int )h->rstyle & 31U);
      } else
#line 2112
      if (((unsigned int )h->rstyle & 31U) >= 10U) {
#line 2112
        ccol1 = (u_int16_t )((unsigned int )h->rstyle & 31U);
      } else {
#line 2112
        ccol1 = (u_int16_t )(((unsigned int )h->rstyle & 31U) + 8U);
      }
#line 2116
      if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 2116
        if (h->pixcolor_set[0] & (unsigned int )(1 << 18)) {
#line 2117
          ccol2 = (u_int16_t )19;
        } else {
#line 2116
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2120
      if (((unsigned int )h->rstyle & 2048U) == 0U) {
#line 2120
        ccol2 = (u_int16_t )(((unsigned int )h->rstyle & 992U) >> 5);
      } else
#line 2120
      if (((unsigned int )h->rstyle & 992U) >> 5 < 2U) {
#line 2120
        ccol2 = (u_int16_t )(((unsigned int )h->rstyle & 992U) >> 5);
      } else
#line 2120
      if (((unsigned int )h->rstyle & 992U) >> 5 >= 10U) {
#line 2120
        ccol2 = (u_int16_t )(((unsigned int )h->rstyle & 992U) >> 5);
      } else {
#line 2120
        ccol2 = (u_int16_t )((((unsigned int )h->rstyle & 992U) >> 5) + 8U);
      }
#line 2124
      *srp = (u_int16_t )(((unsigned int )*srp & 4294967264U) | (unsigned int )ccol1);
#line 2125
      *srp = (u_int16_t )(((unsigned int )*srp & 4294966303U) | (unsigned int )((int )ccol2 << 5));
    }
  }
#line 2148
  setoldcursor = (unsigned char)0;
#line 2149
  if ((int )ocrow != -1) {
#line 2150
    if (r->screen.cur.row + (int32_t )r->TermWin.view_start != (int32_t )ocrow) {
#line 2150
      goto _L___1;
    } else
#line 2150
    if (r->screen.cur.col != h->oldcursor.col) {
      _L___1: /* CIL Label */ 
#line 2152
      if ((int )ocrow < (int )r->TermWin.nrow) {
#line 2152
        if (h->oldcursor.col < (int32_t )r->TermWin.ncol) {
#line 2154
          *(*(r->drawn_rend + ocrow) + h->oldcursor.col) = (u_int16_t )((unsigned int )*(*(r->drawn_rend + ocrow) + h->oldcursor.col) ^ 12288U);
        }
      }
#line 2163
      if (r->TermWin.focus) {
#line 2165
        h->oldcursor.row = -1;
      } else
#line 2163
      if (! (r->screen.flags & (unsigned int )(1 << 1))) {
#line 2165
        h->oldcursor.row = -1;
      } else {
#line 2167
        setoldcursor = (unsigned char)1;
      }
    }
  } else
#line 2169
  if (! r->TermWin.focus) {
#line 2170
    setoldcursor = (unsigned char)1;
  }
#line 2171
  if (setoldcursor) {
#line 2172
    if (r->screen.cur.row + (int32_t )r->TermWin.view_start >= (int32_t )r->TermWin.nrow) {
#line 2173
      h->oldcursor.row = -1;
    } else {
#line 2175
      h->oldcursor.row = r->screen.cur.row + (int32_t )r->TermWin.view_start;
#line 2176
      h->oldcursor.col = r->screen.cur.col;
    }
  }
#line 2189
  i = (int )h->num_scr;
#line 2190
  if ((int )refresh_type == 1) {
#line 2190
    if (h->num_scr_allow) {
#line 2190
      if (i) {
        {
#line 2190
        tmp___8 = abs(i);
        }
#line 2190
        if (tmp___8 < (int )r->TermWin.nrow) {
#line 2190
          if (! must_clear) {
#line 2197
            j = (int )r->TermWin.nrow;
#line 2198
            len = (int16_t )-1;
#line 2198
            wlen = len;
#line 2199
            if (i > 0) {
#line 2199
              row = (int16_t )0;
            } else {
#line 2199
              row = (int16_t )(j - 1);
            }
            {
#line 2200
            while (1) {
              while_continue: /* CIL Label */ ;
#line 2200
              tmp___7 = j;
#line 2200
              j --;
#line 2200
              if (! (tmp___7 >= 0)) {
#line 2200
                goto while_break;
              }
#line 2201
              if ((int )row + i >= 0) {
#line 2201
                if ((int )row + i < (int )r->TermWin.nrow) {
#line 2201
                  if ((int )row + i != (int )ocrow) {
#line 2202
                    stp = *(r->screen.text + ((int )row + row_offset));
#line 2203
                    srp = *(r->screen.rend + ((int )row + row_offset));
#line 2204
                    dtp = *(r->drawn_text + row);
#line 2205
                    dtp2 = *(r->drawn_text + ((int )row + i));
#line 2206
                    drp = *(r->drawn_rend + row);
#line 2207
                    drp2 = *(r->drawn_rend + ((int )row + i));
#line 2208
                    nits = (int16_t )0;
#line 2208
                    col = (int16_t )r->TermWin.ncol;
                    {
#line 2208
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 2208
                      tmp___1 = col;
#line 2208
                      col = (int16_t )((int )col - 1);
#line 2208
                      if (! tmp___1) {
#line 2208
                        goto while_break___0;
                      }
#line 2209
                      if ((int )*(stp + col) != (int )*(dtp2 + col)) {
#line 2210
                        nits = (int16_t )((int )nits - 1);
                      } else
#line 2209
                      if ((int )*(srp + col) != (int )*(drp2 + col)) {
#line 2210
                        nits = (int16_t )((int )nits - 1);
                      } else
#line 2211
                      if ((int )*(stp + col) != (int )*(dtp + col)) {
#line 2212
                        nits = (int16_t )((int )nits + 1);
                      } else
#line 2211
                      if ((int )*(srp + col) != (int )*(drp + col)) {
#line 2212
                        nits = (int16_t )((int )nits + 1);
                      }
                    }
                    while_break___0: /* CIL Label */ ;
                    }
#line 2213
                    if ((int )nits > 8) {
#line 2214
                      col = (int16_t )r->TermWin.ncol;
                      {
#line 2214
                      while (1) {
                        while_continue___1: /* CIL Label */ ;
#line 2214
                        tmp___6 = col;
#line 2214
                        col = (int16_t )((int )col - 1);
#line 2214
                        if (! tmp___6) {
#line 2214
                          goto while_break___1;
                        }
#line 2215
                        tmp___2 = dtp;
#line 2215
                        dtp ++;
#line 2215
                        tmp___3 = dtp2;
#line 2215
                        dtp2 ++;
#line 2215
                        *tmp___2 = *tmp___3;
#line 2216
                        tmp___4 = drp;
#line 2216
                        drp ++;
#line 2216
                        tmp___5 = drp2;
#line 2216
                        drp2 ++;
#line 2216
                        *tmp___4 = *tmp___5;
                      }
                      while_break___1: /* CIL Label */ ;
                      }
#line 2218
                      if ((int )len == -1) {
#line 2219
                        len = row;
                      }
#line 2220
                      wlen = row;
#line 2221
                      goto __Cont;
                    }
                  }
                }
              }
#line 2224
              if ((int )len != -1) {
#line 2226
                if ((int )wlen < (int )len) {
                  {
#line 2227
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 2227
                    swapittmp = (int )wlen;
#line 2227
                    wlen = len;
#line 2227
                    len = (int16_t )swapittmp;
#line 2227
                    goto while_break___2;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
                }
                {
#line 2229
                XCopyArea(r->Xdisplay, r->TermWin.vt, r->TermWin.vt, r->TermWin.gc,
                          0, ((int )len + i) * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth,
                          (unsigned int )((int32_t )r->TermWin.width + 2 * (int32_t )r->TermWin.int_bwidth),
                          (unsigned int )((((int )wlen - (int )len) + 1) * (int32_t )r->TermWin.fheight),
                          0, (int32_t )len * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth);
#line 2234
                len = (int16_t )-1;
                }
              }
              __Cont: /* CIL Label */ 
#line 2200
              if (i > 0) {
#line 2200
                tmp___0 = 1;
              } else {
#line 2200
                tmp___0 = -1;
              }
#line 2200
              row = (int16_t )((int )row + tmp___0);
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 2244
  row = (int16_t )0;
  {
#line 2244
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2244
    if (! ((int )row < (int )r->TermWin.nrow)) {
#line 2244
      goto while_break___3;
    }
#line 2245
    clear_next = (unsigned char)0;
#line 2253
    stp = *(r->screen.text + ((int )row + row_offset));
#line 2254
    srp = *(r->screen.rend + ((int )row + row_offset));
#line 2255
    dtp = *(r->drawn_text + row);
#line 2256
    drp = *(r->drawn_rend + row);
#line 2268
    col = (int16_t )0;
    {
#line 2268
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2268
      if (! ((int )col < (int )r->TermWin.ncol)) {
#line 2268
        goto while_break___4;
      }
#line 2272
      t = *(dtp + col);
#line 2273
      if ((int )t == (int )*(stp + col)) {
#line 2273
        if ((int )*(drp + col) == (int )*(srp + col)) {
#line 2273
          tmp___9 = 1;
        } else {
#line 2273
          tmp___9 = 0;
        }
      } else {
#line 2273
        tmp___9 = 0;
      }
#line 2273
      is_same_char = (unsigned char )tmp___9;
#line 2274
      if (! clear_next) {
#line 2274
        if (is_same_char) {
#line 2278
          goto __Cont___0;
        } else
#line 2274
        if ((int )t == 0) {
#line 2278
          goto __Cont___0;
        } else
#line 2274
        if ((int )t == 32) {
#line 2278
          goto __Cont___0;
        }
      }
#line 2280
      if (clear_next) {
#line 2281
        clear_next = (unsigned char)0;
#line 2282
        *(dtp + col) = (text_t )0;
#line 2283
        if (is_same_char) {
#line 2284
          goto __Cont___0;
        }
      }
#line 2286
      if ((unsigned int )*(drp + col) & 3072U) {
#line 2286
        j___0 = 1;
      } else {
#line 2286
        j___0 = 0;
      }
#line 2288
      if (j___0) {
#line 2288
        if (r->TermWin.boldFont) {
#line 2288
          wf = (XFontStruct const   *)r->TermWin.boldFont;
        } else {
#line 2288
          wf = (XFontStruct const   *)r->TermWin.font;
        }
      } else {
#line 2288
        wf = (XFontStruct const   *)r->TermWin.font;
      }
#line 2295
      if (wf->per_char) {
#line 2295
        if ((unsigned int const   )t >= wf->min_char_or_byte2) {
#line 2295
          if ((unsigned int const   )t <= wf->max_char_or_byte2) {
#line 2295
            is_font_char = (unsigned char)1;
          } else {
#line 2295
            is_font_char = (unsigned char)0;
          }
        } else {
#line 2295
          is_font_char = (unsigned char)0;
        }
      } else {
#line 2295
        is_font_char = (unsigned char)0;
      }
#line 2296
      if (! is_font_char) {
#line 2296
        goto _L___2;
      } else
#line 2296
      if ((int )(wf->per_char + ((unsigned int const   )t - wf->min_char_or_byte2))->lbearing < 0) {
        _L___2: /* CIL Label */ 
#line 2297
        if ((int )col == 0) {
#line 2298
          clearfirst = (unsigned char)1;
        } else {
#line 2300
          *(dtp + ((int )col - 1)) = (text_t )0;
        }
      }
#line 2302
      if (! is_font_char) {
#line 2302
        goto _L___3;
      } else
#line 2302
      if ((int )(wf->per_char + ((unsigned int const   )t - wf->min_char_or_byte2))->width < (int )(wf->per_char + ((unsigned int const   )t - wf->min_char_or_byte2))->rbearing + j___0) {
        _L___3: /* CIL Label */ 
#line 2304
        if ((int )col == (int )r->TermWin.ncol - 1) {
#line 2305
          clearlast = (unsigned char)1;
        } else {
#line 2307
          clear_next = (unsigned char)1;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 2268
      col = (int16_t )((int )col + 1);
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2315
    ypixelc = (int32_t )row * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth;
#line 2316
    ypixel = ypixelc + (int )r->TermWin.fascent;
#line 2318
    col = (int16_t )0;
    {
#line 2318
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2318
      if (! ((int )col < (int )r->TermWin.ncol)) {
#line 2318
        goto while_break___5;
      }
#line 2324
      rend = *(srp + col);
#line 2325
      if ((int )*(stp + col) == (int )*(dtp + col)) {
#line 2325
        if ((int )rend == (int )*(drp + col)) {
#line 2330
          goto __Cont___1;
        } else
#line 2325
        if ((int )*(stp + col) == 32) {
#line 2325
          if ((unsigned int )rend & 4096U) {
#line 2325
            tmp___10 = ((unsigned int )rend & 60416U) | (((unsigned int )rend & 31U) << 5);
          } else {
#line 2325
            tmp___10 = (unsigned int )rend & 65504U;
          }
#line 2325
          if ((unsigned int )*(drp + col) & 4096U) {
#line 2325
            tmp___11 = ((unsigned int )*(drp + col) & 60416U) | (((unsigned int )*(drp + col) & 31U) << 5);
          } else {
#line 2325
            tmp___11 = (unsigned int )*(drp + col) & 65504U;
          }
#line 2325
          if (tmp___10 == tmp___11) {
#line 2330
            goto __Cont___1;
          }
        }
      }
#line 2343
      fontdiff = (unsigned char )r->TermWin.fontdiff;
#line 2344
      len = (int16_t )0;
#line 2345
      tmp___12 = len;
#line 2345
      len = (int16_t )((int )len + 1);
#line 2345
      tmp___13 = *(stp + col);
#line 2345
      *(dtp + col) = tmp___13;
#line 2345
      *(buffer + tmp___12) = (char )tmp___13;
#line 2346
      *(drp + col) = rend;
#line 2347
      xpixel = (int32_t )col * (int32_t )r->TermWin.fwidth + (int32_t )r->TermWin.int_bwidth;
#line 2353
      if ((unsigned int )rend & 3072U) {
#line 2353
        if ((unsigned long )r->TermWin.boldFont != (unsigned long )((void *)0)) {
#line 2354
          fprop = (unsigned char )((int )r->TermWin.propfont & (1 << 1));
        } else {
#line 2357
          fprop = (unsigned char )((int )r->TermWin.propfont & 1);
        }
      } else {
#line 2357
        fprop = (unsigned char )((int )r->TermWin.propfont & 1);
      }
#line 2422
      if (! fprop) {
#line 2424
        i = 0;
        {
#line 2424
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2424
          col = (int16_t )((int )col + 1);
#line 2424
          if (! ((int )col < (int )r->TermWin.ncol - 1)) {
#line 2424
            goto while_break___6;
          }
#line 2425
          if ((int )rend != (int )*(srp + col)) {
#line 2426
            goto while_break___6;
          }
#line 2427
          tmp___14 = len;
#line 2427
          len = (int16_t )((int )len + 1);
#line 2427
          *(buffer + tmp___14) = (char )*(stp + col);
#line 2428
          if ((int )*(stp + col) != (int )*(dtp + col)) {
#line 2428
            goto _L___4;
          } else
#line 2428
          if ((int )*(srp + col) != (int )*(drp + col)) {
            _L___4: /* CIL Label */ 
#line 2429
            if (must_clear) {
#line 2429
              tmp___15 = i;
#line 2429
              i ++;
#line 2429
              if (tmp___15 > (int )len / 2) {
#line 2430
                goto while_break___6;
              }
            }
#line 2431
            *(dtp + col) = *(stp + col);
#line 2432
            *(drp + col) = *(srp + col);
#line 2433
            i = 0;
          } else
#line 2434
          if (must_clear) {
#line 2435
            goto while_break___6;
          } else
#line 2434
          if ((int )*(stp + col) != 32) {
#line 2434
            i ++;
#line 2434
            if (i > 32) {
#line 2435
              goto while_break___6;
            }
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 2437
        col = (int16_t )((int )col - 1);
#line 2438
        len = (int16_t )((int )len - i);
      }
#line 2440
      wlen = len;
#line 2442
      *(buffer + len) = (char )'\000';
#line 2447
      if (((unsigned int )rend & 1024U) == 0U) {
#line 2447
        fore = (unsigned char )((unsigned int )rend & 31U);
      } else
#line 2447
      if (((unsigned int )rend & 31U) < 2U) {
#line 2447
        fore = (unsigned char )((unsigned int )rend & 31U);
      } else
#line 2447
      if (((unsigned int )rend & 31U) >= 10U) {
#line 2447
        fore = (unsigned char )((unsigned int )rend & 31U);
      } else {
#line 2447
        fore = (unsigned char )(((unsigned int )rend & 31U) + 8U);
      }
#line 2448
      if (((unsigned int )rend & 2048U) == 0U) {
#line 2448
        back = (unsigned char )(((unsigned int )rend & 992U) >> 5);
      } else
#line 2448
      if (((unsigned int )rend & 992U) >> 5 < 2U) {
#line 2448
        back = (unsigned char )(((unsigned int )rend & 992U) >> 5);
      } else
#line 2448
      if (((unsigned int )rend & 992U) >> 5 >= 10U) {
#line 2448
        back = (unsigned char )(((unsigned int )rend & 992U) >> 5);
      } else {
#line 2448
        back = (unsigned char )((((unsigned int )rend & 992U) >> 5) + 8U);
      }
#line 2449
      rend = (u_int16_t )((unsigned int )rend & 64512U);
      {
#line 2452
      if (((unsigned int )rend & 49152U) == 16384U) {
#line 2452
        goto case_16384;
      }
#line 2459
      if (((unsigned int )rend & 49152U) == 32768U) {
#line 2459
        goto case_32768;
      }
#line 2451
      goto switch_break;
      case_16384: /* CIL Label */ 
#line 2453
      i = 0;
      {
#line 2453
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2453
        if (! (i < (int )len)) {
#line 2453
          goto while_break___7;
        }
#line 2454
        if ((int )*(buffer + i) == 95) {
#line 2455
          *(buffer + i) = (char)127;
        } else
#line 2456
        if ((int )*(buffer + i) > 95) {
#line 2456
          if ((int )*(buffer + i) < 127) {
#line 2457
            *(buffer + i) = (char )((int )*(buffer + i) - 95);
          }
        }
#line 2453
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 2458
      goto switch_break;
      case_32768: /* CIL Label */ 
#line 2460
      i = 0;
      {
#line 2460
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2460
        if (! (i < (int )len)) {
#line 2460
          goto while_break___8;
        }
#line 2461
        if ((int )*(buffer + i) == 35) {
#line 2462
          *(buffer + i) = (char)30;
        }
#line 2460
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2463
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2466
      if ((unsigned int )rend & 4096U) {
#line 2466
        rvid = (unsigned char)1;
      } else {
#line 2466
        rvid = (unsigned char)0;
      }
#line 2477
      if (rvid) {
        {
#line 2481
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2481
          swapittmp___0 = fore;
#line 2481
          fore = back;
#line 2481
          back = swapittmp___0;
#line 2481
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 2484
        if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 2484
          if (h->pixcolor_set[0] & (unsigned int )(1 << 24)) {
#line 2484
            if (*(r->PixColors + fore) != *(r->PixColors + 24)) {
#line 2486
              back = (unsigned char)24;
            }
          }
        }
      }
#line 2489
      gcmask = 0UL;
#line 2490
      if ((int )back != 1) {
#line 2491
        gcvalue.background = *(r->PixColors + back);
#line 2492
        gcmask = (unsigned long )(1L << 3);
      }
#line 2494
      if ((int )fore != 0) {
#line 2495
        gcvalue.foreground = *(r->PixColors + fore);
#line 2496
        gcmask |= (unsigned long )(1L << 2);
      } else
#line 2499
      if ((unsigned int )rend & 1024U) {
#line 2500
        if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 2500
          if (h->pixcolor_set[0] & (unsigned int )(1 << 22)) {
#line 2500
            if (*(r->PixColors + fore) != *(r->PixColors + 22)) {
#line 2500
              if (*(r->PixColors + back) != *(r->PixColors + 22)) {
#line 2503
                gcvalue.foreground = *(r->PixColors + 22);
#line 2504
                gcmask |= (unsigned long )(1L << 2);
              }
            }
          }
        }
      } else
#line 2509
      if ((unsigned int )rend & 8192U) {
#line 2510
        if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 2510
          if (h->pixcolor_set[0] & (unsigned int )(1 << 23)) {
#line 2510
            if (*(r->PixColors + fore) != *(r->PixColors + 23)) {
#line 2510
              if (*(r->PixColors + back) != *(r->PixColors + 23)) {
#line 2513
                gcvalue.foreground = *(r->PixColors + 23);
#line 2514
                gcmask |= (unsigned long )(1L << 2);
#line 2515
                rend = (u_int16_t )((unsigned int )rend & 4294959103U);
              }
            }
          }
        }
      }
#line 2519
      if (gcmask) {
        {
#line 2520
        XChangeGC(r->Xdisplay, r->TermWin.gc, gcmask, & gcvalue);
        }
      }
#line 2522
      if (! wbyte) {
#line 2522
        if ((unsigned int )rend & 3072U) {
#line 2522
          if ((unsigned long )r->TermWin.boldFont != (unsigned long )((void *)0)) {
            {
#line 2524
            bfont = (unsigned char)1;
#line 2525
            XSetFont(r->Xdisplay, r->TermWin.gc, (r->TermWin.boldFont)->fid);
            }
#line 2526
            if ((int )r->TermWin.propfont & (1 << 1)) {
#line 2526
              tmp___16 = 1;
            } else {
#line 2526
              tmp___16 = 0;
            }
#line 2526
            fontdiff = (unsigned char )((int )fontdiff | tmp___16);
#line 2527
            rend = (u_int16_t )((unsigned int )rend & 4294966271U);
          } else {
#line 2522
            goto _L___6;
          }
        } else {
#line 2522
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 2528
      if (bfont) {
#line 2529
        bfont = (unsigned char)0;
#line 2530
        if (! wbyte) {
          {
#line 2531
          XSetFont(r->Xdisplay, r->TermWin.gc, (r->TermWin.font)->fid);
          }
        }
      }
#line 2537
      if ((int )back == 1) {
#line 2537
        if (must_clear) {
#line 2538
          if (r->TermWin.mapped) {
            {
#line 2538
            XClearArea(r->Xdisplay, r->TermWin.vt, xpixel, ypixelc, (unsigned int )((int32_t )len * (int32_t )r->TermWin.fwidth),
                       (unsigned int )((int32_t )r->TermWin.fheight), 0);
            }
          }
#line 2539
          i = 0;
          {
#line 2539
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 2539
            if (! (i < (int )len)) {
#line 2539
              goto while_break___10;
            }
#line 2540
            if ((int )*(buffer + i) != 32) {
              {
#line 2541
              draw_string(r, r->Xdisplay, r->TermWin.vt, r->TermWin.gc, xpixel, ypixel,
                          buffer, (int )wlen);
              }
#line 2542
              goto while_break___10;
            }
#line 2539
            i ++;
          }
          while_break___10: /* CIL Label */ ;
          }
        } else {
#line 2537
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 2544
      if (fprop) {
#line 2544
        goto _L___7;
      } else
#line 2544
      if (fontdiff) {
        _L___7: /* CIL Label */ 
        {
#line 2547
        gctmp = gcvalue.foreground;
#line 2548
        gcvalue.foreground = gcvalue.background;
#line 2549
        XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )(1L << 2), & gcvalue);
#line 2550
        XFillRectangle(r->Xdisplay, r->TermWin.vt, r->TermWin.gc, xpixel, ypixelc,
                       (unsigned int )((int32_t )len * (int32_t )r->TermWin.fwidth),
                       (unsigned int )((int32_t )r->TermWin.fheight - (int32_t )r->TermWin.lineSpace));
#line 2554
        gcvalue.foreground = gctmp;
#line 2555
        XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )(1L << 2), & gcvalue);
#line 2556
        (*draw_string_func)(r, r->Xdisplay, r->TermWin.vt, r->TermWin.gc, xpixel,
                            ypixel, buffer, (int )wlen);
        }
      } else {
        {
#line 2558
        (*draw_image_string_func)(r, r->Xdisplay, r->TermWin.vt, r->TermWin.gc, xpixel,
                                  ypixel, buffer, (int )wlen);
        }
      }
#line 2565
      if ((unsigned int )rend & 3072U) {
        {
#line 2566
        draw_string(r, r->Xdisplay, r->TermWin.vt, r->TermWin.gc, xpixel + 1, ypixel,
                    buffer, (int )wlen);
        }
      }
#line 2568
      if ((unsigned int )rend & 8192U) {
#line 2568
        if ((r->TermWin.font)->descent > 1) {
          {
#line 2569
          XDrawLine(r->Xdisplay, r->TermWin.vt, r->TermWin.gc, xpixel, ypixel + 1,
                    (xpixel + (int32_t )len * (int32_t )r->TermWin.fwidth) - 1, ypixel + 1);
          }
        }
      }
#line 2572
      if (gcmask) {
        {
#line 2573
        gcvalue.foreground = *(r->PixColors + 0);
#line 2574
        gcvalue.background = *(r->PixColors + 1);
#line 2575
        XChangeGC(r->Xdisplay, r->TermWin.gc, gcmask, & gcvalue);
        }
      }
      __Cont___1: /* CIL Label */ 
#line 2318
      col = (int16_t )((int )col + 1);
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2244
    row = (int16_t )((int )row + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2583
  if (r->screen.flags & (unsigned int )(1 << 1)) {
#line 2584
    if (r->TermWin.focus) {
#line 2585
      srp = *(r->screen.rend + (r->screen.cur.row + (int32_t )r->TermWin.saveLines)) + r->screen.cur.col;
#line 2587
      *srp = (u_int16_t )((unsigned int )*srp ^ 4096U);
#line 2589
      *srp = (u_int16_t )(((unsigned int )*srp & 4294966272U) | (unsigned int )cc1);
    } else
#line 2600
    if (h->oldcursor.row >= 0) {
#line 2604
      gcmask___0 = 0UL;
#line 2605
      if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 2605
        if (h->pixcolor_set[0] & (unsigned int )(1 << 18)) {
          {
#line 2606
          gcvalue.foreground = *(r->PixColors + 18);
#line 2607
          gcmask___0 = (unsigned long )(1L << 2);
#line 2608
          XChangeGC(r->Xdisplay, r->TermWin.gc, gcmask___0, & gcvalue);
#line 2609
          gcvalue.foreground = *(r->PixColors + 0);
          }
        }
      }
#line 2612
      if (morecur) {
#line 2612
        tmp___17 = 1;
      } else {
#line 2612
        tmp___17 = 0;
      }
      {
#line 2612
      XDrawRectangle(r->Xdisplay, r->TermWin.vt, r->TermWin.gc, (h->oldcursor.col + (int32_t )morecur) * (int32_t )r->TermWin.fwidth + (int32_t )r->TermWin.int_bwidth,
                     h->oldcursor.row * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth,
                     (unsigned int )((1 + tmp___17) * (int32_t )r->TermWin.fwidth - 1),
                     (unsigned int )(((int32_t )r->TermWin.fheight - (int32_t )r->TermWin.lineSpace) - 1));
      }
#line 2620
      if (gcmask___0) {
        {
#line 2621
        XChangeGC(r->Xdisplay, r->TermWin.gc, gcmask___0, & gcvalue);
        }
      }
    }
  }
  {
#line 2628
  rxvt_scr_reverse_selection(r);
  }
#line 2633
  if (clearfirst) {
#line 2633
    if (r->TermWin.int_bwidth) {
      {
#line 2638
      XClearArea(r->Xdisplay, r->TermWin.vt, 0, 0, (unsigned int )r->TermWin.int_bwidth,
                 (unsigned int )((int32_t )r->TermWin.height + 2 * (int32_t )r->TermWin.int_bwidth),
                 0);
      }
    }
  }
#line 2641
  if (clearlast) {
#line 2641
    if (r->TermWin.int_bwidth) {
      {
#line 2646
      XClearArea(r->Xdisplay, r->TermWin.vt, (int )r->TermWin.width + (int )r->TermWin.int_bwidth,
                 0, (unsigned int )r->TermWin.int_bwidth, (unsigned int )((int32_t )r->TermWin.height + 2 * (int32_t )r->TermWin.int_bwidth),
                 0);
      }
    }
  }
#line 2650
  if ((int )refresh_type & (1 << 2)) {
    {
#line 2651
    XSync(r->Xdisplay, 0);
    }
  }
#line 2653
  h->num_scr = (int16_t )0;
#line 2654
  h->num_scr_allow = (unsigned char)1;
#line 2655
  h->want_refresh = (unsigned char)0;
#line 2656
  return;
}
}
#line 2660 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_clear(rxvt_t *r ) 
{ 


  {
#line 2663
  if (! r->TermWin.mapped) {
#line 2664
    return;
  }
  {
#line 2665
  (r->h)->num_scr_allow = (unsigned char)0;
#line 2666
  (r->h)->want_refresh = (unsigned char)1;
#line 2680
  XClearWindow(r->Xdisplay, r->TermWin.vt);
  }
#line 2681
  return;
}
}
#line 2685 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_scr_reverse_selection(rxvt_t *r ) 
{ 
  int i ;
  int col ;
  int row ;
  int end_row ;
  u_int16_t *srp ;

  {
#line 2691
  if (r->selection.op) {
#line 2691
    if ((int )(r->h)->current_screen == (int )r->selection.screen) {
#line 2692
      end_row = (int )r->TermWin.saveLines - (int )r->TermWin.view_start;
#line 2693
      i = r->selection.beg.row + (int32_t )r->TermWin.saveLines;
#line 2694
      row = r->selection.end.row + (int32_t )r->TermWin.saveLines;
#line 2695
      if (i >= end_row) {
#line 2696
        col = r->selection.beg.col;
      } else {
#line 2698
        col = 0;
#line 2699
        i = end_row;
      }
#line 2701
      end_row += (int )r->TermWin.nrow;
      {
#line 2702
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2702
        if (i < row) {
#line 2702
          if (! (i < end_row)) {
#line 2702
            goto while_break;
          }
        } else {
#line 2702
          goto while_break;
        }
#line 2703
        srp = *(r->screen.rend + i);
        {
#line 2703
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2703
          if (! (col < (int )r->TermWin.ncol)) {
#line 2703
            goto while_break___0;
          }
#line 2705
          *(srp + col) = (u_int16_t )((unsigned int )*(srp + col) ^ 4096U);
#line 2703
          col ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2702
        i ++;
#line 2702
        col = 0;
      }
      while_break: /* CIL Label */ ;
      }
#line 2709
      if (i == row) {
#line 2709
        if (i < end_row) {
#line 2710
          srp = *(r->screen.rend + i);
          {
#line 2710
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2710
            if (! (col < r->selection.end.col)) {
#line 2710
              goto while_break___1;
            }
#line 2712
            *(srp + col) = (u_int16_t )((unsigned int )*(srp + col) ^ 4096U);
#line 2710
            col ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 2717
  return;
}
}
#line 2758 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_check(rxvt_t *r , int check_more ) 
{ 
  row_col_t pos ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;

  {
#line 2763
  if (! r->selection.op) {
#line 2764
    return;
  }
#line 2766
  pos.col = 0;
#line 2766
  pos.row = pos.col;
#line 2767
  if (r->selection.beg.row < - ((int32_t )r->TermWin.nscrolled)) {
#line 2767
    goto _L___0;
  } else
#line 2767
  if (r->selection.beg.row >= (int32_t )r->TermWin.nrow) {
#line 2767
    goto _L___0;
  } else
#line 2767
  if (r->selection.mark.row < - ((int32_t )r->TermWin.nscrolled)) {
#line 2767
    goto _L___0;
  } else
#line 2767
  if (r->selection.mark.row >= (int32_t )r->TermWin.nrow) {
#line 2767
    goto _L___0;
  } else
#line 2767
  if (r->selection.end.row < - ((int32_t )r->TermWin.nscrolled)) {
#line 2767
    goto _L___0;
  } else
#line 2767
  if (r->selection.end.row >= (int32_t )r->TermWin.nrow) {
#line 2767
    goto _L___0;
  } else
#line 2767
  if (check_more == 1) {
#line 2767
    if ((int )(r->h)->current_screen == (int )r->selection.screen) {
#line 2767
      if (r->screen.cur.row < r->selection.beg.row) {
#line 2767
        goto _L___8;
      } else
#line 2767
      if (r->screen.cur.row == r->selection.beg.row) {
#line 2767
        if (r->screen.cur.col < r->selection.beg.col) {
#line 2767
          goto _L___8;
        } else {
#line 2767
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 2767
      if (r->screen.cur.row < r->selection.end.row) {
#line 2767
        goto _L___0;
      } else
#line 2767
      if (r->screen.cur.row == r->selection.end.row) {
#line 2767
        if (r->screen.cur.col < r->selection.end.col) {
#line 2767
          goto _L___0;
        } else {
#line 2767
          goto _L___8;
        }
      } else {
#line 2767
        goto _L___8;
      }
    } else {
#line 2767
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 2767
  if (check_more == 2) {
#line 2767
    if (r->selection.beg.row < pos.row) {
#line 2767
      goto _L___4;
    } else
#line 2767
    if (r->selection.beg.row == pos.row) {
#line 2767
      if (r->selection.beg.col < pos.col) {
        _L___4: /* CIL Label */ 
#line 2767
        if (r->selection.end.row > pos.row) {
#line 2767
          goto _L___0;
        } else
#line 2767
        if (r->selection.end.row == pos.row) {
#line 2767
          if (r->selection.end.col > pos.col) {
#line 2767
            goto _L___0;
          } else {
#line 2767
            goto _L___3;
          }
        } else {
#line 2767
          goto _L___3;
        }
      } else {
#line 2767
        goto _L___3;
      }
    } else {
#line 2767
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2767
  if (check_more == 3) {
#line 2767
    if (r->selection.end.row > pos.row) {
#line 2767
      goto _L___0;
    } else
#line 2767
    if (r->selection.end.row == pos.row) {
#line 2767
      if (r->selection.end.col > pos.col) {
#line 2767
        goto _L___0;
      } else {
#line 2767
        goto _L___1;
      }
    } else {
#line 2767
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2767
  if (check_more == 4) {
#line 2767
    if (r->selection.beg.row != r->selection.end.row) {
#line 2767
      goto _L___0;
    } else
#line 2767
    if (r->selection.end.col > (int32_t )r->TermWin.ncol) {
      _L___0: /* CIL Label */ 
#line 2785
      tmp___1 = 0;
#line 2785
      r->selection.end.col = tmp___1;
#line 2785
      tmp___0 = tmp___1;
#line 2785
      r->selection.end.row = tmp___0;
#line 2785
      tmp = tmp___0;
#line 2785
      r->selection.beg.col = tmp;
#line 2785
      r->selection.beg.row = tmp;
    }
  }
#line 2786
  return;
}
}
#line 2793 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_PasteIt(rxvt_t *r , unsigned char const   *data , unsigned int nitems ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int n ;
  unsigned char *ds ;
  void *tmp ;

  {
  {
#line 2797
  tmp = rxvt_malloc((size_t )16384);
#line 2797
  ds = (unsigned char *)tmp;
#line 2800
  i = 0U;
  }
  {
#line 2800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2800
    if (! (i < nitems)) {
#line 2800
      goto while_break;
    }
#line 2801
    if (nitems - i < 16384U) {
#line 2801
      n = nitems - i;
    } else {
#line 2801
      n = 16384U;
    }
    {
#line 2802
    memcpy((void */* __restrict  */)((void *)ds), (void const   */* __restrict  */)((void const   *)(data + i)),
           (size_t )n);
#line 2803
    j = 0U;
    }
    {
#line 2803
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2803
      if (! (j < n)) {
#line 2803
        goto while_break___0;
      }
#line 2804
      if ((int )*(ds + j) == 10) {
#line 2805
        *(ds + j) = (unsigned char )'\r';
      }
#line 2803
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2806
    rxvt_tt_write(r, (unsigned char const   *)ds, (unsigned int )((int )n));
#line 2800
    i += 16384U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2808
  free((void *)ds);
  }
#line 2809
  return;
}
}
#line 2817 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
int rxvt_selection_paste(rxvt_t *r , Window win , Atom prop , int delete_prop ) 
{ 
  long nread ;
  unsigned long bytes_after ;
  XTextProperty ct ;
  int tmp ;

  {
#line 2820
  nread = 0L;
#line 2830
  if (prop == 0UL) {
#line 2840
    return (0);
  }
  {
#line 2842
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2843
    tmp = XGetWindowProperty(r->Xdisplay, win, prop, nread / 4L, 4096L, delete_prop,
                             (Atom )0L, & ct.encoding, & ct.format, & ct.nitems, & bytes_after,
                             & ct.value);
    }
#line 2843
    if (tmp != 0) {
#line 2848
      goto while_break;
    }
#line 2849
    if (ct.encoding == 0UL) {
#line 2851
      goto while_break;
    }
#line 2853
    if ((unsigned long )ct.value == (unsigned long )((void *)0)) {
#line 2855
      goto __Cont;
    }
#line 2857
    if (ct.nitems == 0UL) {
#line 2859
      if ((int )(r->h)->selection_wait == 1) {
#line 2859
        if (nread == 0L) {
          {
#line 2865
          rxvt_selection_paste(r, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                               (Atom )9, 0);
          }
        }
      }
#line 2867
      nread = -1L;
#line 2868
      goto while_break;
    }
    {
#line 2870
    nread = (long )((unsigned long )nread + ct.nitems);
#line 2878
    rxvt_PasteIt(r, (unsigned char const   *)ct.value, (unsigned int )ct.nitems);
    }
#line 2879
    if (bytes_after == 0UL) {
#line 2880
      goto while_break;
    }
    {
#line 2881
    XFree((void *)ct.value);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2883
  if (ct.value) {
    {
#line 2884
    XFree((void *)ct.value);
    }
  }
#line 2885
  if ((int )(r->h)->selection_wait == 1) {
#line 2886
    (r->h)->selection_wait = (unsigned char)0;
  }
#line 2888
  return ((int )nread);
}
}
#line 2895 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_property(rxvt_t *r , Window win , Atom prop ) 
{ 
  int reget_time ;
  int a ;
  int afmt ;
  Atom atype ;
  unsigned long bytes_after ;
  unsigned long nitems ;
  unsigned char *s ;
  int tmp ;

  {
#line 2898
  reget_time = 0;
#line 2900
  if (prop == 0UL) {
#line 2901
    return;
  }
#line 2903
  if ((int )(r->h)->selection_wait == 1) {
    {
#line 2907
    s = (unsigned char *)((void *)0);
#line 2909
    a = XGetWindowProperty(r->Xdisplay, win, prop, 0L, 1L, 0, (r->h)->xa[6], & atype,
                           & afmt, & nitems, & bytes_after, & s);
    }
#line 2912
    if (s) {
      {
#line 2913
      XFree((void *)s);
      }
    }
#line 2914
    if (a != 0) {
#line 2915
      return;
    }
#line 2917
    if (atype == (r->h)->xa[6]) {
      {
#line 2919
      XDeleteProperty(r->Xdisplay, win, prop);
#line 2920
      XFlush(r->Xdisplay);
#line 2921
      reget_time = 1;
#line 2922
      (r->h)->selection_wait = (unsigned char)2;
      }
    }
  } else
#line 2925
  if ((int )(r->h)->selection_wait == 2) {
    {
#line 2926
    reget_time = 1;
#line 2927
    tmp = rxvt_selection_paste(r, win, prop, 1);
    }
#line 2927
    if (tmp == -1) {
#line 2929
      (r->h)->selection_wait = (unsigned char)0;
#line 2930
      (r->h)->timeout[0].tv_sec = (__time_t )0;
    }
  }
#line 2933
  if (reget_time) {
    {
#line 2934
    gettimeofday((struct timeval */* __restrict  */)(& (r->h)->timeout[0]), (__timezone_ptr_t )((void *)0));
#line 2935
    (r->h)->timeout[0].tv_sec += 10L;
    }
  }
#line 2937
  return;
}
}
#line 2949 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_request(rxvt_t *r , Time tm , int x , int y ) 
{ 
  int i ;
  int tmp ;

  {
#line 2953
  if (x < 0) {
#line 2954
    return;
  } else
#line 2953
  if (x >= (int )r->TermWin.width) {
#line 2954
    return;
  } else
#line 2953
  if (y < 0) {
#line 2954
    return;
  } else
#line 2953
  if (y >= (int )r->TermWin.height) {
#line 2954
    return;
  }
#line 2956
  if ((unsigned long )r->selection.text != (unsigned long )((void *)0)) {
    {
#line 2958
    rxvt_PasteIt(r, (unsigned char const   *)r->selection.text, r->selection.len);
    }
#line 2959
    return;
  } else {
#line 2963
    (r->h)->selection_request_time = tm;
#line 2964
    (r->h)->selection_wait = (unsigned char)1;
#line 2965
    i = 1;
    {
#line 2965
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2965
      if (! (i <= 3)) {
#line 2965
        goto while_break;
      }
      {
#line 2969
      (r->h)->selection_type = (unsigned char)0;
#line 2971
      tmp = rxvt_selection_request_other(r, (Atom )31, i);
      }
#line 2971
      if (tmp) {
#line 2978
        return;
      }
#line 2965
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2981
  (r->h)->selection_wait = (unsigned char)0;
#line 2983
  rxvt_selection_paste(r, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                       (Atom )9, 0);
  }
#line 2984
  return;
}
}
#line 2987 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
int rxvt_selection_request_other(rxvt_t *r , Atom target , int selnum ) 
{ 
  Atom sel ;
  Window tmp ;

  {
#line 2995
  (r->h)->selection_type = (unsigned char )((int )(r->h)->selection_type | selnum);
#line 2996
  if (selnum == 1) {
#line 2997
    sel = (Atom )1;
  } else
#line 2998
  if (selnum == 2) {
#line 2999
    sel = (Atom )2;
  } else {
#line 3001
    sel = (r->h)->xa[8];
  }
  {
#line 3002
  tmp = XGetSelectionOwner(r->Xdisplay, sel);
  }
#line 3002
  if (tmp != 0UL) {
    {
#line 3004
    XConvertSelection(r->Xdisplay, sel, target, (r->h)->xa[5], r->TermWin.vt, (r->h)->selection_request_time);
    }
#line 3006
    return (1);
  }
#line 3008
  return (0);
}
}
#line 3017 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_clear(rxvt_t *r ) 
{ 
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;

  {
#line 3022
  (r->h)->want_refresh = (unsigned char)1;
#line 3023
  if (r->selection.text) {
    {
#line 3024
    free((void *)r->selection.text);
    }
  }
#line 3025
  r->selection.text = (unsigned char *)((void *)0);
#line 3026
  r->selection.len = (u_int32_t )0;
#line 3027
  tmp___1 = 0;
#line 3027
  r->selection.end.col = tmp___1;
#line 3027
  tmp___0 = tmp___1;
#line 3027
  r->selection.end.row = tmp___0;
#line 3027
  tmp = tmp___0;
#line 3027
  r->selection.beg.col = tmp;
#line 3027
  r->selection.beg.row = tmp;
#line 3028
  return;
}
}
#line 3036 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_make(rxvt_t *r , Time tm ) 
{ 
  int i ;
  int col ;
  int end_col ;
  int row ;
  int end_row ;
  unsigned char *new_selection_text ;
  char *str ;
  text_t *t ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  text_t *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  text_t *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  Window tmp___10 ;

  {
  {
#line 3046
  if ((unsigned int )r->selection.op == 3U) {
#line 3046
    goto case_3;
  }
#line 3048
  if ((unsigned int )r->selection.op == 1U) {
#line 3048
    goto case_1;
  }
#line 3051
  if ((unsigned int )r->selection.op == 2U) {
#line 3051
    goto case_2;
  }
#line 3054
  goto switch_default;
  case_3: /* CIL Label */ 
#line 3047
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3049
  tmp___1 = 0;
#line 3049
  r->selection.end.col = tmp___1;
#line 3049
  tmp___0 = tmp___1;
#line 3049
  r->selection.end.row = tmp___0;
#line 3049
  tmp = tmp___0;
#line 3049
  r->selection.beg.col = tmp;
#line 3049
  r->selection.beg.row = tmp;
  case_2: /* CIL Label */ 
#line 3052
  r->selection.op = (enum __anonenum_op_166 )4;
  switch_default: /* CIL Label */ 
#line 3055
  return;
  switch_break: /* CIL Label */ ;
  }
#line 3057
  r->selection.op = (enum __anonenum_op_166 )4;
#line 3059
  if ((int )r->selection.clicks == 4) {
#line 3060
    return;
  }
  {
#line 3062
  i = ((r->selection.end.row - r->selection.beg.row) + 1) * ((int )r->TermWin.ncol + 1) + 1;
#line 3064
  tmp___2 = rxvt_malloc((unsigned long )i * sizeof(char ));
#line 3064
  str = (char *)tmp___2;
#line 3066
  new_selection_text = (unsigned char *)str;
#line 3068
  col = r->selection.beg.col;
  }
#line 3069
  if (0 > col) {
#line 3069
    col = 0;
  }
#line 3070
  row = r->selection.beg.row + (int32_t )r->TermWin.saveLines;
#line 3071
  end_row = r->selection.end.row + (int32_t )r->TermWin.saveLines;
  {
#line 3075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3075
    if (! (row < end_row)) {
#line 3075
      goto while_break;
    }
#line 3076
    t = *(r->screen.text + row) + col;
#line 3077
    end_col = (int )*(r->screen.tlen + row);
#line 3077
    if (end_col == -1) {
#line 3078
      end_col = (int )r->TermWin.ncol;
    }
    {
#line 3079
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3079
      if (! (col < end_col)) {
#line 3079
        goto while_break___0;
      }
#line 3080
      tmp___3 = str;
#line 3080
      str ++;
#line 3080
      tmp___4 = t;
#line 3080
      t ++;
#line 3080
      *tmp___3 = (char )*tmp___4;
#line 3079
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3081
    if ((int )*(r->screen.tlen + row) != -1) {
#line 3082
      tmp___5 = str;
#line 3082
      str ++;
#line 3082
      *tmp___5 = (char )'\n';
    }
#line 3075
    row ++;
#line 3075
    col = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 3087
  t = *(r->screen.text + row) + col;
#line 3088
  end_col = (int )*(r->screen.tlen + row);
#line 3089
  if (end_col == -1) {
#line 3090
    end_col = r->selection.end.col;
  } else
#line 3089
  if (r->selection.end.col <= end_col) {
#line 3090
    end_col = r->selection.end.col;
  }
#line 3091
  if ((int )r->TermWin.ncol < end_col) {
#line 3091
    end_col = (int )r->TermWin.ncol;
  }
  {
#line 3092
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3092
    if (! (col < end_col)) {
#line 3092
      goto while_break___1;
    }
#line 3093
    tmp___6 = str;
#line 3093
    str ++;
#line 3093
    tmp___7 = t;
#line 3093
    t ++;
#line 3093
    *tmp___6 = (char )*tmp___7;
#line 3092
    col ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3100
  if ((unsigned int )r->selection_style != 0U) {
#line 3101
    if (end_col != r->selection.end.col) {
#line 3102
      tmp___8 = str;
#line 3102
      str ++;
#line 3102
      *tmp___8 = (char )'\n';
    }
  }
  {
#line 3104
  *str = (char )'\000';
#line 3105
  tmp___9 = strlen((char const   *)((char *)new_selection_text));
#line 3105
  i = (int )tmp___9;
  }
#line 3105
  if (i == 0) {
    {
#line 3106
    free((void *)new_selection_text);
    }
#line 3107
    return;
  }
#line 3109
  r->selection.len = (u_int32_t )i;
#line 3110
  if (r->selection.text) {
    {
#line 3111
    free((void *)r->selection.text);
    }
  }
  {
#line 3112
  r->selection.text = new_selection_text;
#line 3114
  XSetSelectionOwner(r->Xdisplay, (Atom )1, r->TermWin.vt, tm);
#line 3115
  tmp___10 = XGetSelectionOwner(r->Xdisplay, (Atom )1);
  }
#line 3115
  if (tmp___10 != r->TermWin.vt) {
    {
#line 3116
    rxvt_print_error("can\'t get primary selection");
    }
  }
  {
#line 3117
  XChangeProperty(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                  (Atom )9, (Atom )31, 8, 0, (unsigned char const   *)r->selection.text,
                  (int )r->selection.len);
#line 3119
  (r->h)->selection_time = tm;
  }
#line 3121
  return;
}
}
#line 3129 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_click(rxvt_t *r , int clicks , int x , int y ) 
{ 


  {
  {
#line 3134
  clicks = (clicks - 1) % 3 + 1;
#line 3135
  r->selection.clicks = (short )clicks;
#line 3137
  rxvt_selection_start_colrow(r, (x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth,
                              (y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight);
  }
#line 3138
  if (clicks == 2) {
    {
#line 3139
    rxvt_selection_extend_colrow(r, r->selection.mark.col, r->selection.mark.row + (int32_t )r->TermWin.view_start,
                                 0, 1, 0);
    }
  } else
#line 3138
  if (clicks == 3) {
    {
#line 3139
    rxvt_selection_extend_colrow(r, r->selection.mark.col, r->selection.mark.row + (int32_t )r->TermWin.view_start,
                                 0, 1, 0);
    }
  }
#line 3145
  return;
}
}
#line 3152 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_start_colrow(rxvt_t *r , int col , int row ) 
{ 
  int32_t tmp ;
  int32_t tmp___0 ;

  {
#line 3155
  (r->h)->want_refresh = (unsigned char)1;
#line 3156
  r->selection.mark.col = col;
#line 3157
  r->selection.mark.row = row - (int )r->TermWin.view_start;
#line 3158
  if (- ((int32_t )r->TermWin.nscrolled) > r->selection.mark.row) {
#line 3158
    r->selection.mark.row = - ((int32_t )r->TermWin.nscrolled);
  }
#line 3159
  if ((int )r->TermWin.nrow - 1 < r->selection.mark.row) {
#line 3159
    r->selection.mark.row = (int )r->TermWin.nrow - 1;
  }
#line 3160
  if (0 > r->selection.mark.col) {
#line 3160
    r->selection.mark.col = 0;
  }
#line 3161
  if ((int )r->TermWin.ncol - 1 < r->selection.mark.col) {
#line 3161
    r->selection.mark.col = (int )r->TermWin.ncol - 1;
  }
#line 3163
  if (r->selection.op) {
#line 3164
    tmp = r->selection.mark.row;
#line 3164
    r->selection.end.row = tmp;
#line 3164
    r->selection.beg.row = tmp;
#line 3165
    tmp___0 = r->selection.mark.col;
#line 3165
    r->selection.end.col = tmp___0;
#line 3165
    r->selection.beg.col = tmp___0;
  }
#line 3167
  r->selection.op = (enum __anonenum_op_166 )1;
#line 3168
  r->selection.screen = (short )(r->h)->current_screen;
#line 3169
  return;
}
}
#line 3187 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_delimit_word(rxvt_t *r , enum page_dirn dirn , row_col_t const   *mark ,
                                 row_col_t *ret ) 
{ 
  int col ;
  int row ;
  int dirnadd ;
  int tcol ;
  int trow ;
  int w1 ;
  int w2 ;
  row_col_t bound ;
  text_t *stp ;
  u_int16_t *srp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 3195
  if ((unsigned int )dirn == 0U) {
#line 3196
    bound.row = ((int )r->TermWin.saveLines - (int )r->TermWin.nscrolled) - 1;
#line 3197
    bound.col = 0;
#line 3198
    dirnadd = -1;
  } else {
#line 3200
    bound.row = (int )r->TermWin.saveLines + (int )r->TermWin.nrow;
#line 3201
    bound.col = (int )r->TermWin.ncol - 1;
#line 3202
    dirnadd = 1;
  }
#line 3204
  row = (int )(mark->row + (int32_t const   )r->TermWin.saveLines);
#line 3205
  col = (int )mark->col;
#line 3206
  if (0 > col) {
#line 3206
    col = 0;
  }
#line 3208
  stp = *(r->screen.text + row) + col;
#line 3209
  if ((int )*stp == 32) {
#line 3209
    w1 = 2;
  } else
#line 3209
  if ((int )*stp == 9) {
#line 3209
    w1 = 2;
  } else {
    {
#line 3209
    tmp = strchr((r->h)->rs[56], (int )*stp);
#line 3209
    w1 = (unsigned long )tmp != (unsigned long )((void *)0);
    }
  }
#line 3211
  if ((unsigned int )r->selection_style != 2U) {
#line 3212
    if (w1 == 1) {
#line 3213
      stp += dirnadd;
#line 3214
      if ((int )*stp == 32) {
#line 3214
        tmp___1 = 2;
      } else
#line 3214
      if ((int )*stp == 9) {
#line 3214
        tmp___1 = 2;
      } else {
        {
#line 3214
        tmp___0 = strchr((r->h)->rs[56], (int )*stp);
#line 3214
        tmp___1 = (unsigned long )tmp___0 != (unsigned long )((void *)0);
        }
      }
#line 3214
      if (tmp___1 == 1) {
#line 3215
        goto Old_Word_Selection_You_Die;
      }
#line 3216
      col += dirnadd;
    }
#line 3218
    w1 = 0;
  }
#line 3220
  srp = *(r->screen.rend + row) + col;
#line 3221
  w2 = 1;
  {
#line 3223
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3224
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3224
      if (! (col != bound.col)) {
#line 3224
        goto while_break___0;
      }
#line 3225
      stp += dirnadd;
#line 3226
      if ((int )*stp == 32) {
#line 3226
        tmp___3 = 2;
      } else
#line 3226
      if ((int )*stp == 9) {
#line 3226
        tmp___3 = 2;
      } else {
        {
#line 3226
        tmp___2 = strchr((r->h)->rs[56], (int )*stp);
#line 3226
        tmp___3 = (unsigned long )tmp___2 != (unsigned long )((void *)0);
        }
      }
#line 3226
      if (tmp___3 != w1) {
#line 3227
        goto while_break___0;
      }
#line 3228
      srp += dirnadd;
#line 3229
      if (1 != w2) {
#line 3230
        goto while_break___0;
      }
#line 3224
      col += dirnadd;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3232
    if (col == bound.col) {
#line 3232
      if (row != bound.row) {
#line 3233
        if ((unsigned int )dirn == 0U) {
#line 3233
          tmp___6 = 1;
        } else {
#line 3233
          tmp___6 = 0;
        }
#line 3233
        if ((int )*(r->screen.tlen + (row - tmp___6)) == -1) {
#line 3234
          trow = row + dirnadd;
#line 3235
          if ((unsigned int )dirn == 0U) {
#line 3235
            tcol = (int )r->TermWin.ncol - 1;
          } else {
#line 3235
            tcol = 0;
          }
#line 3236
          if ((unsigned long )*(r->screen.text + trow) == (unsigned long )((void *)0)) {
#line 3237
            goto while_break;
          }
#line 3238
          stp = *(r->screen.text + trow) + tcol;
#line 3239
          srp = *(r->screen.rend + trow) + tcol;
#line 3240
          if ((int )*stp == 32) {
#line 3240
            tmp___5 = 2;
          } else
#line 3240
          if ((int )*stp == 9) {
#line 3240
            tmp___5 = 2;
          } else {
            {
#line 3240
            tmp___4 = strchr((r->h)->rs[56], (int )*stp);
#line 3240
            tmp___5 = (unsigned long )tmp___4 != (unsigned long )((void *)0);
            }
          }
#line 3240
          if (tmp___5 != w1) {
#line 3241
            goto while_break;
          } else
#line 3240
          if (1 != w2) {
#line 3241
            goto while_break;
          }
#line 3242
          row = trow;
#line 3243
          col = tcol;
#line 3244
          goto __Cont;
        }
      }
    }
#line 3247
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  Old_Word_Selection_You_Die: ;
#line 3252
  if ((unsigned int )dirn == 1U) {
#line 3253
    col ++;
  }
#line 3256
  ret->row = row - (int )r->TermWin.saveLines;
#line 3257
  ret->col = col;
#line 3258
  return;
}
}
#line 3269 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_extend(rxvt_t *r , int x , int y , int flag ) 
{ 
  int col ;
  int row ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int tmp___1 ;

  {
#line 3274
  col = (x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth;
#line 3275
  row = (y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight;
#line 3276
  if (0 > row) {
#line 3276
    row = 0;
  }
#line 3277
  if ((int )r->TermWin.nrow - 1 < row) {
#line 3277
    row = (int )r->TermWin.nrow - 1;
  }
#line 3278
  if (0 > col) {
#line 3278
    col = 0;
  }
#line 3279
  if ((int )r->TermWin.ncol < col) {
#line 3279
    col = (int )r->TermWin.ncol;
  }
#line 3287
  if ((unsigned int )r->selection_style != 0U) {
#line 3288
    if ((int )r->selection.clicks % 3 == 1) {
#line 3288
      if (! flag) {
#line 3288
        if (col == r->selection.mark.col) {
#line 3288
          if (row == r->selection.mark.row + (int32_t )r->TermWin.view_start) {
#line 3292
            tmp = 0;
#line 3292
            r->selection.end.row = tmp;
#line 3292
            r->selection.beg.row = tmp;
#line 3293
            tmp___0 = 0;
#line 3293
            r->selection.end.col = tmp___0;
#line 3293
            r->selection.beg.col = tmp___0;
#line 3294
            r->selection.clicks = (short)4;
#line 3295
            (r->h)->want_refresh = (unsigned char)1;
#line 3297
            return;
          }
        }
      }
    }
  }
#line 3301
  if ((int )r->selection.clicks == 4) {
#line 3302
    r->selection.clicks = (short)1;
  }
#line 3303
  if (flag == 1) {
#line 3303
    tmp___1 = 1;
  } else {
#line 3303
    tmp___1 = 0;
  }
  {
#line 3303
  rxvt_selection_extend_colrow(r, col, row, ! (! flag), tmp___1, 0);
  }
#line 3306
  return;
}
}
#line 3337 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_extend_colrow(rxvt_t *r , int32_t col , int32_t row , int button3 ,
                                  int buttonpress , int clickchange ) 
{ 
  int16_t ncol ;
  int end_col ;
  row_col_t pos ;
  enum __anonenum_closeto_179 closeto ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;

  {
#line 3340
  ncol = (int16_t )r->TermWin.ncol;
#line 3343
  closeto = (enum __anonenum_closeto_179 )1;
#line 3350
  (r->h)->want_refresh = (unsigned char)1;
  {
#line 3352
  if ((unsigned int )r->selection.op == 1U) {
#line 3352
    goto case_1;
  }
#line 3356
  if ((unsigned int )r->selection.op == 2U) {
#line 3356
    goto case_2;
  }
#line 3361
  if ((unsigned int )r->selection.op == 4U) {
#line 3361
    goto case_4;
  }
#line 3364
  if ((unsigned int )r->selection.op == 3U) {
#line 3364
    goto case_3;
  }
#line 3366
  if ((unsigned int )r->selection.op == 0U) {
#line 3366
    goto case_0;
  }
#line 3369
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3353
  tmp___1 = 0;
#line 3353
  r->selection.end.col = tmp___1;
#line 3353
  tmp___0 = tmp___1;
#line 3353
  r->selection.end.row = tmp___0;
#line 3353
  tmp = tmp___0;
#line 3353
  r->selection.beg.col = tmp;
#line 3353
  r->selection.beg.row = tmp;
#line 3354
  r->selection.op = (enum __anonenum_op_166 )2;
  case_2: /* CIL Label */ 
#line 3357
  if (row != r->selection.mark.row) {
#line 3359
    r->selection.op = (enum __anonenum_op_166 )3;
  } else
#line 3357
  if (col != r->selection.mark.col) {
#line 3359
    r->selection.op = (enum __anonenum_op_166 )3;
  } else
#line 3357
  if (! button3) {
#line 3357
    if (buttonpress) {
#line 3359
      r->selection.op = (enum __anonenum_op_166 )3;
    }
  }
#line 3360
  goto switch_break;
  case_4: /* CIL Label */ 
#line 3362
  r->selection.op = (enum __anonenum_op_166 )3;
  case_3: /* CIL Label */ 
#line 3365
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 3367
  rxvt_selection_start_colrow(r, col, row);
  }
  switch_default: /* CIL Label */ 
#line 3370
  return;
  switch_break: /* CIL Label */ ;
  }
#line 3372
  if (r->selection.beg.col == r->selection.end.col) {
#line 3372
    if (r->selection.beg.col != r->selection.mark.col) {
#line 3372
      if (r->selection.beg.row == r->selection.end.row) {
#line 3372
        if (r->selection.beg.row != r->selection.mark.row) {
#line 3376
          tmp___2 = r->selection.mark.col;
#line 3376
          r->selection.end.col = tmp___2;
#line 3376
          r->selection.beg.col = tmp___2;
#line 3377
          tmp___3 = r->selection.mark.row;
#line 3377
          r->selection.end.row = tmp___3;
#line 3377
          r->selection.beg.row = tmp___3;
        }
      }
    }
  }
#line 3381
  pos.col = col;
#line 3382
  pos.row = row;
#line 3384
  pos.row -= (int32_t )r->TermWin.view_start;
#line 3450
  if (button3) {
#line 3450
    if (buttonpress) {
#line 3454
      if (pos.row < r->selection.beg.row) {
#line 3460
        closeto = (enum __anonenum_closeto_179 )0;
      } else
#line 3454
      if (pos.row == r->selection.beg.row) {
#line 3454
        if (pos.col < r->selection.beg.col) {
#line 3460
          closeto = (enum __anonenum_closeto_179 )0;
        } else {
#line 3454
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 3454
      if (! (pos.row > r->selection.end.row)) {
#line 3454
        if (pos.row == r->selection.end.row) {
#line 3454
          if (! (pos.col > r->selection.end.col)) {
#line 3454
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 3454
        if ((pos.col - r->selection.beg.col) + (pos.row - r->selection.beg.row) * (int32_t )ncol < (r->selection.end.col - pos.col) + (r->selection.end.row - pos.row) * (int32_t )ncol) {
#line 3460
          closeto = (enum __anonenum_closeto_179 )0;
        }
      }
#line 3461
      if ((unsigned int )closeto == 0U) {
#line 3462
        r->selection.beg.row = pos.row;
#line 3463
        r->selection.beg.col = pos.col;
#line 3464
        r->selection.mark.row = r->selection.end.row;
#line 3465
        r->selection.mark.col = r->selection.end.col - ((int )r->selection.clicks == 2);
      } else {
#line 3468
        r->selection.end.row = pos.row;
#line 3469
        r->selection.end.col = pos.col;
#line 3470
        r->selection.mark.row = r->selection.beg.row;
#line 3471
        r->selection.mark.col = r->selection.beg.col;
      }
    } else {
#line 3450
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 3474
  if (r->selection.mark.row > pos.row) {
#line 3474
    goto _L___1;
  } else
#line 3474
  if (r->selection.mark.row == pos.row) {
#line 3474
    if (r->selection.mark.col > pos.col) {
      _L___1: /* CIL Label */ 
#line 3475
      if (r->selection.mark.row == r->selection.end.row) {
#line 3475
        if (r->selection.mark.col == r->selection.end.col) {
#line 3475
          if (clickchange) {
#line 3475
            if ((int )r->selection.clicks == 2) {
#line 3478
              (r->selection.mark.col) --;
            }
          }
        }
      }
#line 3479
      r->selection.beg.row = pos.row;
#line 3480
      r->selection.beg.col = pos.col;
#line 3481
      r->selection.end.row = r->selection.mark.row;
#line 3482
      r->selection.end.col = r->selection.mark.col + ((int )r->selection.clicks == 2);
    } else {
#line 3485
      r->selection.beg.row = r->selection.mark.row;
#line 3486
      r->selection.beg.col = r->selection.mark.col;
#line 3487
      r->selection.end.row = pos.row;
#line 3488
      r->selection.end.col = pos.col;
    }
  } else {
#line 3485
    r->selection.beg.row = r->selection.mark.row;
#line 3486
    r->selection.beg.col = r->selection.mark.col;
#line 3487
    r->selection.end.row = pos.row;
#line 3488
    r->selection.end.col = pos.col;
  }
#line 3492
  if ((int )r->selection.clicks == 1) {
#line 3493
    end_col = (int )*(r->screen.tlen + (r->selection.beg.row + (int32_t )r->TermWin.saveLines));
#line 3494
    if (end_col != -1) {
#line 3494
      if (r->selection.beg.col > end_col) {
#line 3496
        r->selection.beg.col = (int32_t )ncol;
      }
    }
#line 3504
    end_col = (int )*(r->screen.tlen + (r->selection.end.row + (int32_t )r->TermWin.saveLines));
#line 3505
    if (end_col != -1) {
#line 3505
      if (r->selection.end.col > end_col) {
#line 3506
        r->selection.end.col = (int32_t )ncol;
      }
    }
  } else
#line 3511
  if ((int )r->selection.clicks == 2) {
#line 3512
    if (r->selection.end.row > r->selection.beg.row) {
#line 3513
      (r->selection.end.col) --;
    } else
#line 3512
    if (r->selection.end.row == r->selection.beg.row) {
#line 3512
      if (r->selection.end.col > r->selection.beg.col) {
#line 3513
        (r->selection.end.col) --;
      }
    }
    {
#line 3514
    rxvt_selection_delimit_word(r, (enum page_dirn )0, (row_col_t const   *)(& r->selection.beg),
                                & r->selection.beg);
#line 3516
    rxvt_selection_delimit_word(r, (enum page_dirn )1, (row_col_t const   *)(& r->selection.end),
                                & r->selection.end);
    }
  } else
#line 3518
  if ((int )r->selection.clicks == 3) {
#line 3540
    if (r->selection.mark.row > r->selection.beg.row) {
#line 3541
      (r->selection.mark.col) ++;
    } else
#line 3540
    if (r->selection.mark.row == r->selection.beg.row) {
#line 3540
      if (r->selection.mark.col > r->selection.beg.col) {
#line 3541
        (r->selection.mark.col) ++;
      }
    }
#line 3542
    r->selection.beg.col = 0;
#line 3543
    r->selection.end.col = (int32_t )ncol;
  }
#line 3546
  if (button3) {
#line 3546
    if (buttonpress) {
#line 3547
      if ((unsigned int )closeto == 0U) {
#line 3548
        r->selection.mark.row = r->selection.end.row;
#line 3549
        r->selection.mark.col = r->selection.end.col - ((int )r->selection.clicks == 2);
      } else {
#line 3552
        r->selection.mark.row = r->selection.beg.row;
#line 3553
        r->selection.mark.col = r->selection.beg.col;
      }
    }
  }
#line 3558
  return;
}
}
#line 3600 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_rotate(rxvt_t *r , int x , int y ) 
{ 


  {
  {
#line 3603
  r->selection.clicks = (short )((int )r->selection.clicks % 3 + 1);
#line 3604
  rxvt_selection_extend_colrow(r, (x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth,
                               (y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight,
                               1, 0, 1);
  }
#line 3605
  return;
}
}
#line 3613 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_selection_send(rxvt_t *r , XSelectionRequestEvent const   *rq ) 
{ 
  XSelectionEvent ev ;
  Atom target_list[3] ;
  Atom target ;
  XTextProperty ct ;
  XICCEncodingStyle style ;
  char *cl[2] ;
  char dummy[1] ;
  int selectlen ;

  {
#line 3627
  ev.type = 31;
#line 3628
  ev.property = (Atom )0L;
#line 3629
  ev.display = (Display *)rq->display;
#line 3630
  ev.requestor = (Window )rq->requestor;
#line 3631
  ev.selection = (Atom )rq->selection;
#line 3632
  ev.target = (Atom )rq->target;
#line 3633
  ev.time = (Time )rq->time;
#line 3635
  if (rq->target == (Atom const   )(r->h)->xa[2]) {
    {
#line 3636
    target_list[0] = (r->h)->xa[2];
#line 3637
    target_list[1] = (Atom )31;
#line 3638
    target_list[2] = (r->h)->xa[3];
#line 3642
    XChangeProperty(r->Xdisplay, (Window )rq->requestor, (Atom )rq->property, (Atom )4,
                    32, 0, (unsigned char const   *)((unsigned char *)(target_list)),
                    (int )(sizeof(target_list) / sizeof(target_list[0])));
#line 3645
    ev.property = (Atom )rq->property;
    }
  } else
#line 3646
  if (! (rq->target == (Atom const   )(r->h)->xa[1])) {
#line 3648
    if (rq->target == (Atom const   )(r->h)->xa[4]) {
#line 3648
      if (r->selection.text) {
        {
#line 3649
        XChangeProperty(r->Xdisplay, (Window )rq->requestor, (Atom )rq->property,
                        (Atom )19, (int )(8UL * sizeof(Time )), 0, (unsigned char const   *)((unsigned char *)(& (r->h)->selection_time)),
                        1);
#line 3652
        ev.property = (Atom )rq->property;
        }
      } else {
#line 3648
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3653
    if (rq->target == 31UL) {
#line 3653
      goto _L;
    } else
#line 3653
    if (rq->target == (Atom const   )(r->h)->xa[0]) {
#line 3653
      goto _L;
    } else
#line 3653
    if (rq->target == (Atom const   )(r->h)->xa[3]) {
      _L: /* CIL Label */ 
#line 3669
      target = (Atom )31;
#line 3670
      style = (XICCEncodingStyle )0;
#line 3672
      if (r->selection.text) {
#line 3673
        cl[0] = (char *)r->selection.text;
#line 3674
        selectlen = (int )r->selection.len;
      } else {
#line 3676
        cl[0] = dummy;
#line 3677
        dummy[0] = (char )'\000';
#line 3678
        selectlen = 0;
      }
      {
#line 3687
      ct.value = (unsigned char *)cl[0];
#line 3688
      ct.nitems = (unsigned long )selectlen;
#line 3690
      XChangeProperty(r->Xdisplay, (Window )rq->requestor, (Atom )rq->property, target,
                      8, 0, (unsigned char const   *)ct.value, (int )ct.nitems);
#line 3693
      ev.property = (Atom )rq->property;
      }
    }
  }
  {
#line 3699
  XSendEvent(r->Xdisplay, (Window )rq->requestor, 0, 0L, (XEvent *)(& ev));
  }
#line 3700
  return;
}
}
#line 3710 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/screen.c"
void rxvt_pixel_position(rxvt_t *r , int *x , int *y ) 
{ 


  {
#line 3713
  *x = (*x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth;
#line 3715
  *y = (*y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight;
#line 3717
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.extpro"
int rxvt_Str_match(char const   *s1 , char const   *s2 ) ;
#line 4
char const   *rxvt_Str_skip_space(char const   *str ) ;
#line 7
char **rxvt_splitcommastring(char const   *cs ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.c"
char *rxvt_r_basename(char const   *str ) 
{ 
  char *base ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 34
  tmp = strrchr(str, '/');
#line 34
  base = tmp;
  }
#line 36
  if (base) {
#line 36
    tmp___0 = (char const   *)(base + 1);
  } else {
#line 36
    tmp___0 = str;
  }
#line 36
  return ((char *)tmp___0);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.c"
void rxvt_print_error(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;

  {
  {
#line 48
  __builtin_va_start(arg_ptr, fmt);
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rxvt: ");
#line 50
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           arg_ptr);
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 52
  __builtin_va_end(arg_ptr);
  }
#line 53
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.c"
int rxvt_Str_match(char const   *s1 , char const   *s2 ) 
{ 
  int n ;
  size_t tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 67
  tmp = strlen(s2);
#line 67
  n = (int )tmp;
#line 69
  tmp___2 = strncmp(s1, s2, (size_t )n);
  }
#line 69
  if (tmp___2 == 0) {
#line 69
    tmp___1 = n;
  } else {
#line 69
    tmp___1 = 0;
  }
#line 69
  return (tmp___1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.c"
char const   *rxvt_Str_skip_space(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
#line 76
  if (str) {
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (*str) {
        {
#line 77
        tmp = __ctype_b_loc();
        }
#line 77
        if (! ((int const   )*(*tmp + (int )*str) & 8192)) {
#line 77
          goto while_break;
        }
      } else {
#line 77
        goto while_break;
      }
#line 78
      str ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 79
  return (str);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.c"
char *rxvt_Str_trim(char *str ) 
{ 
  char *r ;
  char *s ;
  int n ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 93
  if (! str) {
#line 94
    return (str);
  } else
#line 93
  if (! *str) {
#line 94
    return (str);
  }
#line 97
  s = str;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (*s) {
      {
#line 97
      tmp = __ctype_b_loc();
      }
#line 97
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 97
        goto while_break;
      }
    } else {
#line 97
      goto while_break;
    }
#line 97
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  n = 0;
#line 99
  r = s;
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    tmp___0 = r;
#line 99
    r ++;
#line 99
    if (! *tmp___0) {
#line 99
      goto while_break___0;
    }
#line 99
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  r -= 2;
#line 102
  if (n > 0) {
#line 102
    if ((int )*r == 10) {
#line 103
      n --;
#line 103
      r --;
    }
  }
  {
#line 105
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 105
    if (n > 0) {
      {
#line 105
      tmp___1 = __ctype_b_loc();
      }
#line 105
      if (! ((int const   )*(*tmp___1 + (int )*r) & 8192)) {
#line 105
        goto while_break___1;
      }
    } else {
#line 105
      goto while_break___1;
    }
#line 105
    r --;
#line 105
    n --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 107
  if ((int )*s == 34) {
#line 107
    if ((int )*r == 34) {
#line 107
      if (n > 1) {
#line 108
        s ++;
#line 109
        n -= 2;
      }
    }
  }
#line 112
  r = str;
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    if (! n) {
#line 112
      goto while_break___2;
    }
#line 113
    tmp___2 = r;
#line 113
    r ++;
#line 113
    tmp___3 = s;
#line 113
    s ++;
#line 113
    *tmp___2 = *tmp___3;
#line 112
    n --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 114
  *r = (char )'\000';
#line 116
  return (str);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.c"
int rxvt_Str_escaped(char *str ) 
{ 
  char ch ;
  char *s ;
  char *d ;
  int i ;
  int num ;
  int append ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 138
  append = 0;
#line 140
  if (! str) {
#line 141
    return (0);
  } else
#line 140
  if (! *str) {
#line 141
    return (0);
  }
#line 143
  s = str;
#line 143
  d = s;
#line 145
  if ((int )*s == 77) {
#line 145
    if ((int )*(s + 1) == 45) {
      {
#line 147
      tmp = d;
#line 147
      d ++;
#line 147
      *tmp = (char)27;
#line 148
      s += 2;
#line 149
      tmp___2 = toupper((int )*s);
      }
#line 149
      if (tmp___2 == 88) {
#line 151
        tmp___0 = d;
#line 151
        d ++;
#line 151
        *tmp___0 = (char )'x';
#line 151
        append = '\r';
#line 151
        s ++;
        {
#line 151
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 151
          tmp___1 = __ctype_b_loc();
          }
#line 151
          if (! ((int const   )*(*tmp___1 + (int )*s) & 8192)) {
#line 151
            goto while_break;
          }
#line 151
          s ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    tmp___7 = s;
#line 153
    s ++;
#line 153
    ch = *tmp___7;
#line 153
    if (! ch) {
#line 153
      goto while_break___0;
    }
#line 154
    if ((int )ch == 92) {
#line 155
      tmp___3 = s;
#line 155
      s ++;
#line 155
      ch = *tmp___3;
#line 156
      if ((int )ch >= 48) {
#line 156
        if ((int )ch <= 55) {
#line 157
          num = (int )ch - 48;
#line 158
          i = 0;
          {
#line 158
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 158
            if (! (i < 2)) {
#line 158
              goto while_break___1;
            }
#line 159
            ch = *s;
#line 160
            if ((int )ch < 48) {
#line 161
              goto while_break___1;
            } else
#line 160
            if ((int )ch > 55) {
#line 161
              goto while_break___1;
            }
#line 162
            num = (num * 8 + (int )ch) - 48;
#line 158
            i ++;
#line 158
            s ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 164
          ch = (char )num;
        } else {
#line 156
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 165
      if ((int )ch == 97) {
#line 166
        ch = (char)7;
      } else
#line 167
      if ((int )ch == 98) {
#line 168
        ch = (char)8;
      } else
#line 169
      if ((int )ch == 69) {
#line 170
        ch = (char)27;
      } else
#line 169
      if ((int )ch == 101) {
#line 170
        ch = (char)27;
      } else
#line 171
      if ((int )ch == 110) {
#line 172
        ch = (char )'\n';
      } else
#line 173
      if ((int )ch == 114) {
#line 174
        ch = (char )'\r';
      } else
#line 175
      if ((int )ch == 116) {
#line 176
        ch = (char)9;
      }
    } else
#line 177
    if ((int )ch == 94) {
      {
#line 178
      tmp___4 = s;
#line 178
      s ++;
#line 178
      ch = *tmp___4;
#line 179
      tmp___5 = toupper((int )ch);
#line 179
      ch = (char )tmp___5;
      }
#line 180
      if ((int )ch == 63) {
#line 180
        ch = (char)127;
      } else {
#line 180
        ch = (char )((int )ch - 64);
      }
    }
#line 182
    tmp___6 = d;
#line 182
    d ++;
#line 182
    *tmp___6 = ch;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 186
  if ((int )*str == 0) {
#line 186
    if ((int )*(str + 1) == 27) {
#line 186
      if ((int )*(str + 2) == 93) {
#line 187
        append = 156;
      }
    }
  }
#line 190
  if (append) {
#line 190
    if ((int )*(d + -1) != append) {
#line 191
      tmp___8 = d;
#line 191
      d ++;
#line 191
      *tmp___8 = (char )append;
    }
  }
#line 192
  *d = (char )'\000';
#line 194
  return ((int )(d - str));
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/misc.c"
char **rxvt_splitcommastring(char const   *cs ) 
{ 
  int l ;
  int n ;
  int p ;
  char const   *s ;
  char const   *t ;
  char **ret ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 211
  s = cs;
#line 211
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 212
    s = "";
  }
#line 214
  n = 1;
#line 214
  t = s;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! *t) {
#line 214
      goto while_break;
    }
#line 215
    if ((int const   )*t == 44) {
#line 216
      n ++;
    }
#line 214
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  tmp = malloc((unsigned long )(n + 1) * sizeof(char *));
#line 217
  ret = (char **)tmp;
#line 218
  *(ret + n) = (char *)((void *)0);
#line 220
  l = 0;
#line 220
  t = s;
  }
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 220
    if (! (l < n)) {
#line 220
      goto while_break___0;
    }
    {
#line 221
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 221
      if (*t) {
#line 221
        if (! ((int const   )*t != 44)) {
#line 221
          goto while_break___1;
        }
      } else {
#line 221
        goto while_break___1;
      }
#line 221
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 222
    p = (int )(t - s);
#line 223
    tmp___0 = malloc((size_t )(p + 1));
#line 223
    *(ret + l) = (char *)tmp___0;
#line 224
    strncpy((char */* __restrict  */)*(ret + l), (char const   */* __restrict  */)s,
            (size_t )p);
#line 225
    *(*(ret + l) + p) = (char )'\000';
#line 226
    rxvt_Str_trim(*(ret + l));
#line 227
    t ++;
#line 227
    s = t;
#line 220
    l ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 229
  return (ret);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 2127 "/usr/include/X11/Xlib.h"
extern int XCheckTypedWindowEvent(Display * , Window  , int  , XEvent * ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2893
extern int XPending(Display * ) ;
#line 2995
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
#line 3079
extern int XRefreshKeyboardMapping(XMappingEvent * ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 311 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvtlib.h"
void rxvt_main_loop(rxvt_t *r ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/scrollbar.extpro"
int rxvt_scrollbar_mapping(rxvt_t *r , int map ) ;
#line 3
int rxvt_scrollbar_show(rxvt_t *r , int update ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.intpro"
void rxvt_lookup_key(rxvt_t *r , XKeyEvent *ev ) ;
#line 2
unsigned char rxvt_cmd_getc(rxvt_t *r ) ;
#line 3
void rxvt_mouse_report(rxvt_t *r , XButtonEvent const   *ev ) ;
#line 4
void rxvt_process_x_event(rxvt_t *r , XEvent *ev ) ;
#line 5
void rxvt_button_press(rxvt_t *r , XButtonEvent *ev ) ;
#line 6
void rxvt_button_release(rxvt_t *r , XButtonEvent *ev ) ;
#line 7
void rxvt_process_print_pipe(rxvt_t *r ) ;
#line 8
void rxvt_process_nonprinting(rxvt_t *r , unsigned char ch ) ;
#line 9
void rxvt_process_escape_vt52(rxvt_t *r , unsigned char ch ) ;
#line 10
void rxvt_process_escape_seq(rxvt_t *r ) ;
#line 11
void rxvt_process_csi_seq(rxvt_t *r ) ;
#line 13
unsigned char *rxvt_get_to_st(rxvt_t *r , unsigned char *ends_how ) ;
#line 14
void rxvt_process_dcs_seq(rxvt_t *r ) ;
#line 15
void rxvt_process_osc_seq(rxvt_t *r ) ;
#line 16
int rxvt_privcases(rxvt_t *r , int mode , unsigned long bit ) ;
#line 17
void rxvt_process_terminal_mode(rxvt_t *r , int mode , int priv , unsigned int nargs ,
                                int const   *arg ) ;
#line 18
void rxvt_process_sgr_mode(rxvt_t *r , unsigned int nargs , int const   *arg ) ;
#line 19
void rxvt_process_graphics(rxvt_t *r ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_lookup_key(rxvt_t *r , XKeyEvent *ev ) 
{ 
  int ctrl ;
  int meta ;
  int shft ;
  int len ;
  unsigned int newlen ;
  KeySym keysym ;
  unsigned char *kbuf ;
  int lnsppg ;
  unsigned int l ;
  unsigned char const   *kbuf0 ;
  unsigned char ch ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  unsigned char *ch___0 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned char ch___1 ;

  {
#line 68
  kbuf = (r->h)->kbuf;
#line 76
  shft = (int )(ev->state & 1U);
#line 77
  ctrl = (int )(ev->state & (unsigned int )(1 << 2));
#line 78
  meta = (int )(ev->state & (r->h)->ModMetaMask);
#line 79
  if (r->numlock_state) {
#line 79
    goto _L;
  } else
#line 79
  if (ev->state & (r->h)->ModNumLockMask) {
    _L: /* CIL Label */ 
#line 80
    r->numlock_state = (int )(ev->state & (r->h)->ModNumLockMask);
#line 81
    if (! r->numlock_state) {
#line 81
      (r->h)->PrivateModes |= 1UL << 7;
    } else {
#line 81
      (r->h)->PrivateModes &= ~ (1UL << 7);
    }
  }
  {
#line 98
  len = XLookupString(ev, (char *)kbuf, 512, & keysym, & (r->h)->compose);
  }
#line 104
  if (! len) {
#line 105
    if (keysym >= 256UL) {
#line 105
      if (keysym < 2048UL) {
#line 106
        *(kbuf + 0) = (unsigned char )(keysym & 255UL);
#line 107
        *(kbuf + 1) = (unsigned char )'\000';
#line 108
        len = 1;
      } else {
#line 110
        *(kbuf + 0) = (unsigned char )'\000';
      }
    } else {
#line 110
      *(kbuf + 0) = (unsigned char )'\000';
    }
  }
#line 135
  if (r->TermWin.saveLines) {
#line 139
    if (shft) {
#line 139
      goto _L___0;
    } else
#line 139
    if (0) {
      _L___0: /* CIL Label */ 
#line 139
      if (! ctrl) {
#line 139
        if (! meta) {
#line 144
          lnsppg = (int )r->TermWin.nrow - 1;
#line 148
          if (keysym == 65365UL) {
            {
#line 149
            rxvt_scr_page(r, (enum page_dirn )0, lnsppg);
            }
#line 150
            return;
          } else
#line 151
          if (keysym == 65366UL) {
            {
#line 152
            rxvt_scr_page(r, (enum page_dirn )1, lnsppg);
            }
#line 153
            return;
          }
        }
      }
    }
  }
#line 180
  if (shft) {
#line 182
    if (keysym >= 65470UL) {
#line 182
      if (keysym <= 65479UL) {
#line 183
        keysym += 10UL;
#line 184
        shft = 0;
      } else {
#line 182
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 185
    if (! ctrl) {
#line 185
      if (! meta) {
#line 185
        if ((r->h)->PrivateModes & (1UL << 10)) {
          {
#line 188
          if (keysym == 65379UL) {
#line 188
            goto case_65379;
          }
#line 192
          if (keysym == 65451UL) {
#line 192
            goto case_65451;
          }
#line 195
          if (keysym == 65453UL) {
#line 195
            goto case_65453;
          }
#line 186
          goto switch_break;
          case_65379: /* CIL Label */ 
          {
#line 189
          rxvt_selection_request(r, ev->time, 0, 0);
          }
#line 190
          return;
          case_65451: /* CIL Label */ 
          {
#line 193
          rxvt_change_font(r, 0, "#+");
          }
#line 194
          return;
          case_65453: /* CIL Label */ 
          {
#line 196
          rxvt_change_font(r, 0, "#-");
          }
#line 197
          return;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 202
  if (keysym == 65377UL) {
    {
#line 203
    rxvt_scr_printscreen(r, ctrl | shft);
    }
#line 204
    return;
  }
#line 221
  if (keysym >= 65280UL) {
#line 221
    if (keysym <= 65535UL) {
#line 223
      if (! (shft | ctrl)) {
#line 223
        if ((unsigned long )(r->h)->Keysym_map[keysym & 255UL] != (unsigned long )((void *)0)) {
#line 226
          ch = (unsigned char)27;
#line 228
          kbuf0 = (r->h)->Keysym_map[keysym & 255UL];
#line 229
          tmp = kbuf0;
#line 229
          kbuf0 ++;
#line 229
          l = (unsigned int )*tmp;
#line 232
          if (meta) {
#line 234
            if ((int )(r->h)->meta_char == 27) {
              {
#line 236
              rxvt_tt_write(r, (unsigned char const   *)(& ch), 1U);
              }
            }
          }
          {
#line 237
          rxvt_tt_write(r, kbuf0, l);
          }
#line 238
          return;
        } else {
#line 223
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 242
        newlen = 1U;
        {
#line 245
        if (keysym == 65288UL) {
#line 245
          goto case_65288;
        }
#line 266
        if (keysym == 65535UL) {
#line 266
          goto case_65535;
        }
#line 281
        if (keysym == 65289UL) {
#line 281
          goto case_65289;
        }
#line 302
        if (keysym == 65430UL) {
#line 302
          goto case_65430;
        }
#line 302
        if (keysym == 65432UL) {
#line 302
          goto case_65430;
        }
#line 302
        if (keysym == 65433UL) {
#line 302
          goto case_65430;
        }
#line 302
        if (keysym == 65431UL) {
#line 302
          goto case_65430;
        }
#line 315
        if (keysym == 65361UL) {
#line 315
          goto case_65361;
        }
#line 315
        if (keysym == 65363UL) {
#line 315
          goto case_65361;
        }
#line 315
        if (keysym == 65364UL) {
#line 315
          goto case_65361;
        }
#line 315
        if (keysym == 65362UL) {
#line 315
          goto case_65361;
        }
#line 359
        if (keysym == 65434UL) {
#line 359
          goto case_65434;
        }
#line 367
        if (keysym == 65365UL) {
#line 367
          goto case_65365;
        }
#line 371
        if (keysym == 65435UL) {
#line 371
          goto case_65435;
        }
#line 379
        if (keysym == 65366UL) {
#line 379
          goto case_65366;
        }
#line 383
        if (keysym == 65421UL) {
#line 383
          goto case_65421;
        }
#line 394
        if (keysym == 65437UL) {
#line 394
          goto case_65437;
        }
#line 398
        if (keysym == 65438UL) {
#line 398
          goto case_65438;
        }
#line 402
        if (keysym == 65439UL) {
#line 402
          goto case_65439;
        }
#line 409
        if (keysym == 65428UL) {
#line 409
          goto case_65428;
        }
#line 409
        if (keysym == 65427UL) {
#line 409
          goto case_65428;
        }
#line 409
        if (keysym == 65426UL) {
#line 409
          goto case_65428;
        }
#line 409
        if (keysym == 65425UL) {
#line 409
          goto case_65428;
        }
#line 429
        if (keysym == 65465UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65464UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65463UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65462UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65461UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65460UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65459UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65458UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65457UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65456UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65455UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65454UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65453UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65452UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65451UL) {
#line 429
          goto case_65465;
        }
#line 429
        if (keysym == 65450UL) {
#line 429
          goto case_65465;
        }
#line 440
        if (keysym == 65384UL) {
#line 440
          goto case_65384;
        }
#line 443
        if (keysym == 65379UL) {
#line 443
          goto case_65379___0;
        }
#line 450
        if (keysym == 65378UL) {
#line 450
          goto case_65378;
        }
#line 453
        if (keysym == 65376UL) {
#line 453
          goto case_65376;
        }
#line 457
        if (keysym == 65436UL) {
#line 457
          goto case_65436;
        }
#line 465
        if (keysym == 65367UL) {
#line 465
          goto case_65367;
        }
#line 469
        if (keysym == 65429UL) {
#line 469
          goto case_65429;
        }
#line 477
        if (keysym == 65360UL) {
#line 477
          goto case_65360;
        }
#line 488
        if (keysym == 65474UL) {
#line 488
          goto case_65474;
        }
#line 488
        if (keysym == 65473UL) {
#line 488
          goto case_65474;
        }
#line 488
        if (keysym == 65472UL) {
#line 488
          goto case_65474;
        }
#line 488
        if (keysym == 65471UL) {
#line 488
          goto case_65474;
        }
#line 488
        if (keysym == 65470UL) {
#line 488
          goto case_65474;
        }
#line 495
        if (keysym == 65479UL) {
#line 495
          goto case_65479;
        }
#line 495
        if (keysym == 65478UL) {
#line 495
          goto case_65479;
        }
#line 495
        if (keysym == 65477UL) {
#line 495
          goto case_65479;
        }
#line 495
        if (keysym == 65476UL) {
#line 495
          goto case_65479;
        }
#line 495
        if (keysym == 65475UL) {
#line 495
          goto case_65479;
        }
#line 501
        if (keysym == 65483UL) {
#line 501
          goto case_65483;
        }
#line 501
        if (keysym == 65482UL) {
#line 501
          goto case_65483;
        }
#line 501
        if (keysym == 65481UL) {
#line 501
          goto case_65483;
        }
#line 501
        if (keysym == 65480UL) {
#line 501
          goto case_65483;
        }
#line 505
        if (keysym == 65485UL) {
#line 505
          goto case_65485;
        }
#line 505
        if (keysym == 65484UL) {
#line 505
          goto case_65485;
        }
#line 508
        if (keysym == 65386UL) {
#line 508
          goto case_65386;
        }
#line 511
        if (keysym == 65383UL) {
#line 511
          goto case_65383;
        }
#line 532
        if (keysym == 65504UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65503UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65502UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65501UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65500UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65499UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65498UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65497UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65496UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65495UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65494UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65493UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65492UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65491UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65490UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65489UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65488UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65487UL) {
#line 532
          goto case_65504;
        }
#line 532
        if (keysym == 65486UL) {
#line 532
          goto case_65504;
        }
#line 536
        goto switch_default;
        case_65288: /* CIL Label */ 
#line 246
        if ((r->h)->PrivateModes & (1UL << 8)) {
#line 247
          if (! (! ((r->h)->PrivateModes & (1UL << 9))) ^ ! (! ctrl)) {
#line 247
            *(kbuf + 0) = (unsigned char )'\b';
          } else {
#line 247
            *(kbuf + 0) = (unsigned char )'\177';
          }
#line 249
          *(kbuf + 1) = (unsigned char )'\000';
        } else {
          {
#line 251
          strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)(r->h)->key_backspace);
          }
        }
#line 263
        goto switch_break___0;
        case_65535: /* CIL Label */ 
        {
#line 267
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)(r->h)->key_delete);
        }
#line 279
        goto switch_break___0;
        case_65289: /* CIL Label */ 
#line 282
        if (shft) {
          {
#line 283
          strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[Z");
          }
        } else {
#line 293
          newlen = 0U;
        }
#line 295
        goto switch_break___0;
        case_65430: /* CIL Label */ 
        case_65432: /* CIL Label */ 
        case_65433: /* CIL Label */ 
        case_65431: /* CIL Label */ 
#line 303
        if ((r->h)->PrivateModes & (1UL << 7)) {
#line 303
          tmp___0 = ! shft;
        } else {
#line 303
          tmp___0 = shft;
        }
#line 303
        if (tmp___0) {
          {
#line 304
          strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033OZ");
#line 305
          *(kbuf + 2) = (unsigned char )*("txvr" + (keysym - 65430UL));
          }
#line 306
          goto switch_break___0;
        } else {
#line 309
          keysym = 65361UL + (keysym - 65430UL);
        }
        case_65361: /* CIL Label */ 
        case_65363: /* CIL Label */ 
        case_65364: /* CIL Label */ 
        case_65362: /* CIL Label */ 
        {
#line 316
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[Z");
#line 317
        *(kbuf + 2) = (unsigned char )*("DACB" + (keysym - 65361UL));
        }
#line 319
        if (shft) {
#line 320
          *(kbuf + 2) = (unsigned char )*("dacb" + (keysym - 65361UL));
        } else
#line 321
        if (ctrl) {
#line 322
          *(kbuf + 1) = (unsigned char )'O';
#line 323
          *(kbuf + 2) = (unsigned char )*("dacb" + (keysym - 65361UL));
        } else
#line 324
        if ((r->h)->PrivateModes & (1UL << 6)) {
#line 325
          *(kbuf + 1) = (unsigned char )'O';
        }
#line 355
        goto switch_break___0;
        case_65434: /* CIL Label */ 
#line 361
        if ((r->h)->PrivateModes & (1UL << 7)) {
#line 361
          tmp___1 = ! shft;
        } else {
#line 361
          tmp___1 = shft;
        }
#line 361
        if (tmp___1) {
          {
#line 362
          strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033Oy");
          }
#line 363
          goto switch_break___0;
        }
        case_65365: /* CIL Label */ 
        {
#line 368
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[5~");
        }
#line 369
        goto switch_break___0;
        case_65435: /* CIL Label */ 
#line 373
        if ((r->h)->PrivateModes & (1UL << 7)) {
#line 373
          tmp___2 = ! shft;
        } else {
#line 373
          tmp___2 = shft;
        }
#line 373
        if (tmp___2) {
          {
#line 374
          strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033Os");
          }
#line 375
          goto switch_break___0;
        }
        case_65366: /* CIL Label */ 
        {
#line 380
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[6~");
        }
#line 381
        goto switch_break___0;
        case_65421: /* CIL Label */ 
#line 385
        if ((r->h)->PrivateModes & (1UL << 7)) {
#line 385
          tmp___3 = ! shft;
        } else {
#line 385
          tmp___3 = shft;
        }
#line 385
        if (tmp___3) {
          {
#line 386
          strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033OM");
          }
        } else {
#line 388
          *(kbuf + 0) = (unsigned char )'\r';
#line 389
          *(kbuf + 1) = (unsigned char )'\000';
        }
#line 391
        goto switch_break___0;
        case_65437: /* CIL Label */ 
        {
#line 395
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033Ou");
        }
#line 396
        goto switch_break___0;
        case_65438: /* CIL Label */ 
        {
#line 399
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033Op");
        }
#line 400
        goto switch_break___0;
        case_65439: /* CIL Label */ 
        {
#line 403
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033On");
        }
#line 404
        goto switch_break___0;
        case_65428: /* CIL Label */ 
        case_65427: /* CIL Label */ 
        case_65426: /* CIL Label */ 
        case_65425: /* CIL Label */ 
        {
#line 410
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033OP");
#line 411
        *(kbuf + 2) = (unsigned char )((KeySym )*(kbuf + 2) + (keysym - 65425UL));
        }
#line 412
        goto switch_break___0;
        case_65465: /* CIL Label */ 
        case_65464: /* CIL Label */ 
        case_65463: /* CIL Label */ 
        case_65462: /* CIL Label */ 
        case_65461: /* CIL Label */ 
        case_65460: /* CIL Label */ 
        case_65459: /* CIL Label */ 
        case_65458: /* CIL Label */ 
        case_65457: /* CIL Label */ 
        case_65456: /* CIL Label */ 
        case_65455: /* CIL Label */ 
        case_65454: /* CIL Label */ 
        case_65453___0: /* CIL Label */ 
        case_65452: /* CIL Label */ 
        case_65451___0: /* CIL Label */ 
        case_65450: /* CIL Label */ 
#line 431
        if ((r->h)->PrivateModes & (1UL << 7)) {
#line 431
          tmp___4 = ! shft;
        } else {
#line 431
          tmp___4 = shft;
        }
#line 431
        if (tmp___4) {
          {
#line 432
          strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033Oj");
#line 433
          *(kbuf + 2) = (unsigned char )((KeySym )*(kbuf + 2) + (keysym - 65450UL));
          }
        } else {
#line 435
          *(kbuf + 0) = (unsigned char )(42UL + (keysym - 65450UL));
#line 436
          *(kbuf + 1) = (unsigned char )'\000';
        }
#line 438
        goto switch_break___0;
        case_65384: /* CIL Label */ 
        {
#line 441
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[1~");
        }
#line 442
        goto switch_break___0;
        case_65379___0: /* CIL Label */ 
        {
#line 444
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[2~");
        }
#line 445
        goto switch_break___0;
        case_65378: /* CIL Label */ 
        {
#line 451
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[3~");
        }
#line 452
        goto switch_break___0;
        case_65376: /* CIL Label */ 
        {
#line 454
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[4~");
        }
#line 455
        goto switch_break___0;
        case_65436: /* CIL Label */ 
#line 459
        if ((r->h)->PrivateModes & (1UL << 7)) {
#line 459
          tmp___5 = ! shft;
        } else {
#line 459
          tmp___5 = shft;
        }
#line 459
        if (tmp___5) {
          {
#line 460
          strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033Oq");
          }
#line 461
          goto switch_break___0;
        }
        case_65367: /* CIL Label */ 
        {
#line 466
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[8~");
        }
#line 467
        goto switch_break___0;
        case_65429: /* CIL Label */ 
#line 471
        if ((r->h)->PrivateModes & (1UL << 7)) {
#line 471
          tmp___6 = ! shft;
        } else {
#line 471
          tmp___6 = shft;
        }
#line 471
        if (tmp___6) {
          {
#line 472
          strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033Ow");
          }
#line 473
          goto switch_break___0;
        }
        case_65360: /* CIL Label */ 
        {
#line 478
        strcpy((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[7~");
        }
#line 479
        goto switch_break___0;
        case_65474: /* CIL Label */ 
        case_65473: /* CIL Label */ 
        case_65472: /* CIL Label */ 
        case_65471: /* CIL Label */ 
        case_65470: /* CIL Label */ 
        {
#line 489
        sprintf((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[%2d~",
                (int )(11UL + (keysym - 65470UL)));
        }
#line 490
        goto switch_break___0;
        case_65479: /* CIL Label */ 
        case_65478: /* CIL Label */ 
        case_65477: /* CIL Label */ 
        case_65476: /* CIL Label */ 
        case_65475: /* CIL Label */ 
        {
#line 496
        sprintf((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[%2d~",
                (int )(17UL + (keysym - 65475UL)));
        }
#line 497
        goto switch_break___0;
        case_65483: /* CIL Label */ 
        case_65482: /* CIL Label */ 
        case_65481: /* CIL Label */ 
        case_65480: /* CIL Label */ 
        {
#line 502
        sprintf((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[%2d~",
                (int )(23UL + (keysym - 65480UL)));
        }
#line 503
        goto switch_break___0;
        case_65485: /* CIL Label */ 
        case_65484: /* CIL Label */ 
        {
#line 506
        sprintf((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[%2d~",
                (int )(28UL + (keysym - 65484UL)));
        }
#line 507
        goto switch_break___0;
        case_65386: /* CIL Label */ 
        {
#line 509
        sprintf((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[%2d~",
                (int )(28UL + (keysym - 65386UL)));
        }
#line 510
        goto switch_break___0;
        case_65383: /* CIL Label */ 
        {
#line 512
        sprintf((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[%2d~",
                (int )(29UL + (keysym - 65383UL)));
        }
#line 513
        goto switch_break___0;
        case_65504: /* CIL Label */ 
        case_65503: /* CIL Label */ 
        case_65502: /* CIL Label */ 
        case_65501: /* CIL Label */ 
        case_65500: /* CIL Label */ 
        case_65499: /* CIL Label */ 
        case_65498: /* CIL Label */ 
        case_65497: /* CIL Label */ 
        case_65496: /* CIL Label */ 
        case_65495: /* CIL Label */ 
        case_65494: /* CIL Label */ 
        case_65493: /* CIL Label */ 
        case_65492: /* CIL Label */ 
        case_65491: /* CIL Label */ 
        case_65490: /* CIL Label */ 
        case_65489: /* CIL Label */ 
        case_65488: /* CIL Label */ 
        case_65487: /* CIL Label */ 
        case_65486: /* CIL Label */ 
        {
#line 533
        sprintf((char */* __restrict  */)((char *)kbuf), (char const   */* __restrict  */)"\033[%2d~",
                (int )(31UL + (keysym - 65486UL)));
        }
#line 534
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 537
        newlen = 0U;
#line 538
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 540
        if (newlen) {
          {
#line 541
          tmp___7 = strlen((char const   *)kbuf);
#line 541
          len = (int )tmp___7;
          }
        }
      }
#line 547
      if (meta) {
#line 547
        if ((int )(r->h)->meta_char == 128) {
#line 547
          if (len > 0) {
#line 548
            *(kbuf + (len - 1)) = (unsigned char )((int )*(kbuf + (len - 1)) | 128);
          }
        }
      }
    } else {
#line 221
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 550
  if (ctrl) {
#line 550
    if (keysym == 45UL) {
#line 551
      len = 1;
#line 552
      *(kbuf + 0) = (unsigned char )'\037';
    } else {
#line 550
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 556
  if (meta) {
#line 556
    if ((int )(r->h)->meta_char == 128) {
#line 559
      ch___0 = kbuf;
      {
#line 559
      while (1) {
        while_continue: /* CIL Label */ ;
#line 559
        if (! ((unsigned long )ch___0 < (unsigned long )(kbuf + len))) {
#line 559
          goto while_break;
        }
#line 560
        *ch___0 = (unsigned char )((int )*ch___0 | 128);
#line 559
        ch___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 561
      meta = 0;
    }
  }
#line 572
  if (len <= 0) {
#line 573
    return;
  }
#line 575
  if (r->Options & (1UL << 12)) {
#line 576
    if (r->TermWin.view_start) {
#line 577
      r->TermWin.view_start = (u_int16_t )0;
#line 578
      (r->h)->want_refresh = (unsigned char)1;
    }
  }
#line 592
  if ((int )*(kbuf + 0) == 27) {
#line 592
    if ((int )*(kbuf + 1) == 91) {
#line 592
      if ((int )*(kbuf + (len - 1)) == 126) {
#line 593
        if (shft) {
#line 593
          if (ctrl) {
#line 593
            tmp___8 = '@';
          } else {
#line 593
            tmp___8 = '$';
          }
#line 593
          *(kbuf + (len - 1)) = (unsigned char )tmp___8;
        } else {
#line 593
          if (ctrl) {
#line 593
            tmp___9 = '^';
          } else {
#line 593
            tmp___9 = '~';
          }
#line 593
          *(kbuf + (len - 1)) = (unsigned char )tmp___9;
        }
      }
    }
  }
#line 596
  if (meta) {
#line 596
    if ((int )(r->h)->meta_char == 27) {
      {
#line 601
      ch___1 = (unsigned char)27;
#line 603
      rxvt_tt_write(r, (unsigned char const   *)(& ch___1), 1U);
      }
    }
  }
  {
#line 616
  rxvt_tt_write(r, (unsigned char const   *)kbuf, (unsigned int )len);
  }
#line 617
  return;
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
unsigned char rxvt_cmd_getc(rxvt_t *r ) 
{ 
  fd_set readfds ;
  int quick_timeout ;
  int select_res ;
  struct timeval value ;
  struct rxvt_hidden *h ;
  unsigned char *tmp ;
  XEvent xev ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int __d0 ;
  int __d1 ;
  struct timeval *tmp___2 ;
  int n ;
  unsigned int count ;
  unsigned char *tmp___3 ;
  int *tmp___4 ;
  ssize_t tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 666
  h = r->h;
#line 668
  if ((unsigned long )h->cmdbuf_ptr < (unsigned long )h->cmdbuf_endp) {
#line 669
    tmp = h->cmdbuf_ptr;
#line 669
    (h->cmdbuf_ptr) ++;
#line 669
    return (*tmp);
  }
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if ((unsigned long )h->v_bufstr < (unsigned long )h->v_bufptr) {
      {
#line 675
      rxvt_tt_write(r, (unsigned char const   *)((void *)0), 0U);
      }
    }
    {
#line 677
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 677
      tmp___1 = XPending(r->Xdisplay);
      }
#line 677
      if (! tmp___1) {
#line 677
        goto while_break___0;
      }
      {
#line 680
      XNextEvent(r->Xdisplay, & xev);
#line 686
      rxvt_process_x_event(r, & xev);
      }
#line 689
      if ((unsigned long )h->cmdbuf_ptr < (unsigned long )h->cmdbuf_endp) {
#line 690
        tmp___0 = h->cmdbuf_ptr;
#line 690
        (h->cmdbuf_ptr) ++;
#line 690
        return (*tmp___0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 696
    quick_timeout = 0;
    {
#line 722
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 722
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 722
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 723
    readfds.__fds_bits[r->cmd_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << r->cmd_fd % (8 * (int )sizeof(__fd_mask ));
#line 724
    readfds.__fds_bits[r->Xfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << r->Xfd % (8 * (int )sizeof(__fd_mask ));
#line 725
    value.tv_usec = (__suseconds_t )5000;
#line 726
    value.tv_sec = (__time_t )0;
#line 728
    if (! r->TermWin.mapped) {
#line 729
      quick_timeout = 0;
    } else {
#line 731
      quick_timeout |= (int )h->want_refresh;
    }
#line 736
    if (quick_timeout) {
#line 736
      tmp___2 = & value;
    } else {
#line 736
      tmp___2 = (struct timeval *)((void *)0);
    }
    {
#line 736
    select_res = select(r->num_fds, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tmp___2);
    }
#line 736
    if (select_res == 0) {
#line 739
      h->refresh_limit = 1;
    }
#line 743
    if (select_res > 0) {
#line 743
      if ((readfds.__fds_bits[r->cmd_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << r->cmd_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 747
        tmp___3 = h->cmdbuf_base;
#line 747
        h->cmdbuf_endp = tmp___3;
#line 747
        h->cmdbuf_ptr = tmp___3;
#line 748
        count = 8192U;
        {
#line 748
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 748
          if (! count) {
#line 748
            goto while_break___2;
          }
          {
#line 749
          tmp___5 = read(r->cmd_fd, (void *)h->cmdbuf_endp, (size_t )count);
#line 749
          n = (int )tmp___5;
          }
#line 749
          if (! (n > 0)) {
#line 751
            if (n == 0) {
#line 752
              goto while_break___2;
            } else
#line 751
            if (n < 0) {
              {
#line 751
              tmp___4 = __errno_location();
              }
#line 751
              if (*tmp___4 == 11) {
#line 752
                goto while_break___2;
              } else {
                {
#line 754
                rxvt_clean_exit();
#line 755
                exit(1);
                }
              }
            } else {
              {
#line 754
              rxvt_clean_exit();
#line 755
              exit(1);
              }
            }
          }
          __Cont: /* CIL Label */ 
#line 748
          count -= (unsigned int )n;
#line 748
          h->cmdbuf_endp += n;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 757
        if (count != 8192U) {
#line 758
          tmp___6 = h->cmdbuf_ptr;
#line 758
          (h->cmdbuf_ptr) ++;
#line 758
          return (*tmp___6);
        }
      }
    }
#line 768
    if (h->want_refresh) {
      {
#line 769
      rxvt_scr_refresh(r, h->refresh_type);
#line 770
      rxvt_scrollbar_show(r, 1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_mouse_report(rxvt_t *r , XButtonEvent const   *ev ) 
{ 
  int button_number ;
  int key_state ;
  int x ;
  int y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 784
  key_state = 0;
#line 787
  x = (int )ev->x;
#line 788
  y = (int )ev->y;
#line 789
  rxvt_pixel_position(r, & x, & y);
  }
#line 791
  if ((long )(r->h)->MEvent.button == 0L) {
#line 792
    button_number = 3;
  } else {
#line 794
    button_number = (int )((r->h)->MEvent.button - 1U);
#line 796
    if (button_number >= 3) {
#line 797
      button_number += 61;
    }
  }
#line 800
  if ((r->h)->PrivateModes & (1UL << 12)) {
#line 805
    key_state = 0;
#line 806
    if (button_number == 3) {
#line 807
      return;
    }
  } else {
#line 816
    if ((r->h)->MEvent.state & 1U) {
#line 816
      tmp = 4;
    } else {
#line 816
      tmp = 0;
    }
#line 816
    if ((r->h)->MEvent.state & (r->h)->ModMetaMask) {
#line 816
      tmp___0 = 8;
    } else {
#line 816
      tmp___0 = 0;
    }
#line 816
    if ((r->h)->MEvent.state & (unsigned int )(1 << 2)) {
#line 816
      tmp___1 = 16;
    } else {
#line 816
      tmp___1 = 0;
    }
#line 816
    key_state = (tmp + tmp___0) + tmp___1;
  }
  {
#line 839
  rxvt_tt_printf(r, "\033[M%c%c%c", (32 + button_number) + key_state, (32 + x) + 1,
                 (32 + y) + 1);
  }
#line 844
  return;
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_x_event(rxvt_t *r , XEvent *ev ) 
{ 
  int i ;
  int want_time ;
  Window unused_root ;
  Window unused_child ;
  int unused_root_x ;
  int unused_root_y ;
  unsigned int unused_mask ;
  struct timeval tp ;
  struct rxvt_hidden *h ;
  int tmp ;
  int tmp___0 ;
  int height ;
  int width ;
  int tmp___1 ;
  XEvent unused_xevent ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 862
  want_time = 0;
#line 867
  h = r->h;
#line 917
  i = 1;
  {
#line 917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 917
    tmp = i;
#line 917
    i --;
#line 917
    if (! tmp) {
#line 917
      goto while_break;
    }
#line 918
    if (h->timeout[i].tv_sec) {
#line 919
      want_time = 1;
#line 920
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 924
  if (want_time) {
    {
#line 925
    gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
    }
  }
#line 933
  if (want_time) {
#line 934
    i = 1;
    {
#line 934
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 934
      tmp___0 = i;
#line 934
      i --;
#line 934
      if (! tmp___0) {
#line 934
        goto while_break___0;
      }
#line 935
      if (h->timeout[i].tv_sec == 0L) {
#line 936
        goto __Cont;
      }
#line 937
      if (tp.tv_sec < h->timeout[i].tv_sec) {
#line 940
        goto __Cont;
      } else
#line 937
      if (tp.tv_sec == h->timeout[i].tv_sec) {
#line 937
        if (tp.tv_usec < h->timeout[i].tv_usec) {
#line 940
          goto __Cont;
        }
      }
#line 941
      h->timeout[i].tv_sec = (__time_t )0;
      {
#line 943
      if (i == 0) {
#line 943
        goto case_0;
      }
#line 947
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 944
      rxvt_print_error("data loss: timeout on INCR selection paste");
#line 945
      h->selection_wait = (unsigned char)0;
      }
#line 946
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 948
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 953
  if (ev->type == 2) {
#line 953
    goto case_2;
  }
#line 973
  if (ev->type == 4) {
#line 973
    goto case_4;
  }
#line 977
  if (ev->type == 5) {
#line 977
    goto case_5;
  }
#line 981
  if (ev->type == 33) {
#line 981
    goto case_33;
  }
#line 1014
  if (ev->type == 34) {
#line 1014
    goto case_34;
  }
#line 1028
  if (ev->type == 15) {
#line 1028
    goto case_15;
  }
#line 1042
  if (ev->type == 9) {
#line 1042
    goto case_9;
  }
#line 1053
  if (ev->type == 10) {
#line 1053
    goto case_10;
  }
#line 1064
  if (ev->type == 22) {
#line 1064
    goto case_22;
  }
#line 1086
  if (ev->type == 29) {
#line 1086
    goto case_29;
  }
#line 1090
  if (ev->type == 31) {
#line 1090
    goto case_31;
  }
#line 1096
  if (ev->type == 30) {
#line 1096
    goto case_30;
  }
#line 1100
  if (ev->type == 18) {
#line 1100
    goto case_18;
  }
#line 1104
  if (ev->type == 19) {
#line 1104
    goto case_19;
  }
#line 1108
  if (ev->type == 28) {
#line 1108
    goto case_28;
  }
#line 1135
  if (ev->type == 12) {
#line 1135
    goto case_12;
  }
#line 1135
  if (ev->type == 13) {
#line 1135
    goto case_12;
  }
#line 1164
  if (ev->type == 6) {
#line 1164
    goto case_6;
  }
#line 952
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 954
  rxvt_lookup_key(r, (XKeyEvent *)ev);
  }
#line 955
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 974
  rxvt_button_press(r, (XButtonEvent *)ev);
  }
#line 975
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 978
  rxvt_button_release(r, (XButtonEvent *)ev);
  }
#line 979
  goto switch_break___0;
  case_33: /* CIL Label */ 
#line 982
  if (ev->xclient.format == 32) {
#line 982
    if ((Atom )ev->xclient.data.l[0] == h->xa[7]) {
      {
#line 984
      exit(0);
      }
    }
  }
#line 1012
  goto switch_break___0;
  case_34: /* CIL Label */ 
  {
#line 1015
  XRefreshKeyboardMapping(& ev->xmapping);
  }
#line 1016
  goto switch_break___0;
  case_15: /* CIL Label */ 
  {
#line 1030
  if (ev->xvisibility.state == 0) {
#line 1030
    goto case_0___0;
  }
#line 1033
  if (ev->xvisibility.state == 1) {
#line 1033
    goto case_1;
  }
#line 1036
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 1031
  h->refresh_type = (unsigned char)1;
#line 1032
  goto switch_break___1;
  case_1: /* CIL Label */ 
#line 1034
  h->refresh_type = (unsigned char )(1 << 1);
#line 1035
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 1037
  h->refresh_type = (unsigned char)0;
#line 1038
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1040
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 1043
  if (! r->TermWin.focus) {
#line 1044
    r->TermWin.focus = (u_int16_t )1;
#line 1045
    h->want_refresh = (unsigned char)1;
  }
#line 1051
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 1054
  if (r->TermWin.focus) {
#line 1055
    r->TermWin.focus = (u_int16_t )0;
#line 1056
    h->want_refresh = (unsigned char)1;
  }
#line 1062
  goto switch_break___0;
  case_22: /* CIL Label */ 
#line 1065
  if (ev->xconfigure.window == r->TermWin.parent[0]) {
    {
#line 1068
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1069
      width = ev->xconfigure.width;
#line 1070
      height = ev->xconfigure.height;
#line 1068
      tmp___1 = XCheckTypedWindowEvent(r->Xdisplay, ev->xconfigure.window, 22, ev);
      }
#line 1068
      if (! tmp___1) {
#line 1068
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1073
    if (r->szHint.width != width) {
      {
#line 1074
      rxvt_resize_all_windows(r, (unsigned int )width, (unsigned int )height, 1);
      }
    } else
#line 1073
    if (r->szHint.height != height) {
      {
#line 1074
      rxvt_resize_all_windows(r, (unsigned int )width, (unsigned int )height, 1);
      }
    }
  }
#line 1084
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
#line 1087
  rxvt_selection_clear(r);
  }
#line 1088
  goto switch_break___0;
  case_31: /* CIL Label */ 
#line 1091
  if ((int )h->selection_wait == 1) {
    {
#line 1092
    rxvt_selection_paste(r, ev->xselection.requestor, ev->xselection.property, 1);
    }
  }
#line 1094
  goto switch_break___0;
  case_30: /* CIL Label */ 
  {
#line 1097
  rxvt_selection_send(r, (XSelectionRequestEvent const   *)(& ev->xselectionrequest));
  }
#line 1098
  goto switch_break___0;
  case_18: /* CIL Label */ 
#line 1101
  r->TermWin.mapped = (u_int16_t )0;
#line 1102
  goto switch_break___0;
  case_19: /* CIL Label */ 
#line 1105
  r->TermWin.mapped = (u_int16_t )1;
#line 1106
  goto switch_break___0;
  case_28: /* CIL Label */ 
#line 1109
  if (ev->xproperty.atom == h->xa[5]) {
#line 1110
    if (ev->xproperty.state == 0) {
      {
#line 1111
      rxvt_selection_property(r, ev->xproperty.window, ev->xproperty.atom);
      }
    }
#line 1113
    goto switch_break___0;
  }
#line 1132
  goto switch_break___0;
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 1136
  if (ev->xany.window == r->TermWin.vt) {
    {
#line 1141
    rxvt_scr_expose(r, ev->xexpose.x, 0, ev->xexpose.width, (int )r->TermWin.height,
                    0);
#line 1144
    h->want_refresh = (unsigned char)1;
    }
  } else {
    {
#line 1148
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1148
      tmp___2 = XCheckTypedWindowEvent(r->Xdisplay, ev->xany.window, 12, & unused_xevent);
      }
#line 1148
      if (! tmp___2) {
#line 1148
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1151
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1151
      tmp___3 = XCheckTypedWindowEvent(r->Xdisplay, ev->xany.window, 13, & unused_xevent);
      }
#line 1151
      if (! tmp___3) {
#line 1151
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1154
    if (r->scrollBar.state) {
#line 1154
      if (ev->xany.window == r->scrollBar.win) {
        {
#line 1155
        r->scrollBar.state = (char)1;
#line 1156
        rxvt_scrollbar_show(r, 0);
        }
      }
    }
#line 1158
    if (r->menuBar.state) {
#line 1158
      tmp___4 = 0;
    } else {
#line 1158
      tmp___4 = 0;
    }
  }
#line 1162
  goto switch_break___0;
  case_6: /* CIL Label */ ;
#line 1169
  if (h->PrivateModes & ((1UL << 12) | (1UL << 13))) {
#line 1169
    if (! h->bypass_keystate) {
#line 1170
      goto switch_break___0;
    }
  }
#line 1172
  if (ev->xany.window == r->TermWin.vt) {
#line 1173
    if (ev->xbutton.state & (unsigned int )((1 << 8) | (1 << 10))) {
      {
#line 1174
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1174
        tmp___5 = XCheckTypedWindowEvent(r->Xdisplay, r->TermWin.vt, 6, ev);
        }
#line 1174
        if (! tmp___5) {
#line 1174
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1176
      XQueryPointer(r->Xdisplay, r->TermWin.vt, & unused_root, & unused_child, & unused_root_x,
                    & unused_root_y, & ev->xbutton.x, & ev->xbutton.y, & unused_mask);
      }
#line 1183
      if (ev->xmotion.time - h->MEvent.time > 50UL) {
#line 1185
        if (ev->xbutton.state & (unsigned int )(1 << 10)) {
#line 1185
          tmp___6 = 2;
        } else {
#line 1185
          tmp___6 = 0;
        }
        {
#line 1185
        rxvt_selection_extend(r, ev->xbutton.x, ev->xbutton.y, tmp___6);
        }
      }
    }
  } else
#line 1188
  if (r->scrollBar.state) {
#line 1188
    if (ev->xany.window == r->scrollBar.win) {
#line 1188
      if ((int )r->scrollBar.state == 109) {
        {
#line 1189
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 1189
          tmp___7 = XCheckTypedWindowEvent(r->Xdisplay, r->scrollBar.win, 6, ev);
          }
#line 1189
          if (! tmp___7) {
#line 1189
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 1191
        XQueryPointer(r->Xdisplay, r->scrollBar.win, & unused_root, & unused_child,
                      & unused_root_x, & unused_root_y, & ev->xbutton.x, & ev->xbutton.y,
                      & unused_mask);
        }
#line 1196
        if ((int )r->scrollBar.style == 1) {
#line 1196
          tmp___8 = 14;
        } else {
#line 1196
          tmp___8 = 10;
        }
        {
#line 1196
        rxvt_scr_move_to(r, (ev->xbutton.y - (int )r->scrollBar.beg) - h->csrO, ((int )r->scrollBar.end - (int )r->scrollBar.beg) - tmp___8);
#line 1198
        rxvt_scr_refresh(r, h->refresh_type);
#line 1199
        h->refresh_limit = 0;
#line 1200
        rxvt_scrollbar_show(r, 1);
        }
      }
    }
  }
#line 1202
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1204
  return;
}
}
#line 1207 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_button_press(rxvt_t *r , XButtonEvent *ev ) 
{ 
  int reportmode ;
  int clickintime ;
  struct rxvt_hidden *h ;
  char upordown ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1210
  reportmode = 0;
#line 1211
  h = r->h;
#line 1213
  h->bypass_keystate = (unsigned char )(ev->state & (h->ModMetaMask | 1U));
#line 1214
  if (! h->bypass_keystate) {
#line 1215
    reportmode = ! (! (h->PrivateModes & ((1UL << 12) | (1UL << 13))));
  }
#line 1219
  if (ev->window == r->TermWin.vt) {
#line 1220
    if (! (ev->subwindow != 0UL)) {
#line 1223
      clickintime = ev->time - h->MEvent.time < 500UL;
#line 1224
      if (reportmode) {
        {
#line 1227
        h->MEvent.state = ev->state;
#line 1248
        h->MEvent.button = ev->button;
#line 1249
        rxvt_mouse_report(r, (XButtonEvent const   *)ev);
        }
      } else {
#line 1252
        if (ev->button != h->MEvent.button) {
#line 1253
          h->MEvent.clicks = 0;
        }
        {
#line 1255
        if (ev->button == 1U) {
#line 1255
          goto case_1;
        }
#line 1264
        if (ev->button == 3U) {
#line 1264
          goto case_3;
        }
#line 1254
        goto switch_break;
        case_1: /* CIL Label */ 
#line 1256
        if (h->MEvent.button == 1U) {
#line 1256
          if (clickintime) {
#line 1257
            (h->MEvent.clicks) ++;
          } else {
#line 1259
            h->MEvent.clicks = 1;
          }
        } else {
#line 1259
          h->MEvent.clicks = 1;
        }
        {
#line 1260
        rxvt_selection_click(r, h->MEvent.clicks, ev->x, ev->y);
#line 1261
        h->MEvent.button = 1U;
        }
#line 1262
        goto switch_break;
        case_3: /* CIL Label */ 
#line 1265
        if (h->MEvent.button == 3U) {
#line 1265
          if (clickintime) {
            {
#line 1266
            rxvt_selection_rotate(r, ev->x, ev->y);
            }
          } else {
            {
#line 1268
            rxvt_selection_extend(r, ev->x, ev->y, 1);
            }
          }
        } else {
          {
#line 1268
          rxvt_selection_extend(r, ev->x, ev->y, 1);
          }
        }
#line 1269
        h->MEvent.button = 3U;
#line 1270
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 1273
      h->MEvent.time = ev->time;
#line 1274
      return;
    }
  }
#line 1281
  if (r->scrollBar.state) {
#line 1281
    if (ev->window == r->scrollBar.win) {
#line 1282
      r->scrollBar.state = (char)1;
#line 1294
      if (reportmode) {
#line 1300
        if ((int )r->scrollBar.style == 1) {
#line 1300
          if (ev->y > (int )r->scrollBar.end) {
#line 1300
            if (ev->y <= (int )r->scrollBar.end + ((int )r->scrollBar.width + 1)) {
              {
#line 1304
              rxvt_tt_printf(r, "\033[A");
              }
            } else {
#line 1300
              goto _L___2;
            }
          } else {
#line 1300
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1300
        if ((int )r->scrollBar.style == 0) {
#line 1300
          if (ev->y < (int )r->scrollBar.beg) {
            {
#line 1304
            rxvt_tt_printf(r, "\033[A");
            }
          } else {
#line 1300
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1305
        if ((int )r->scrollBar.style == 1) {
#line 1305
          if (ev->y > (int )r->scrollBar.end + ((int )r->scrollBar.width + 1)) {
            {
#line 1309
            rxvt_tt_printf(r, "\033[B");
            }
          } else {
#line 1305
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1305
        if ((int )r->scrollBar.style == 0) {
#line 1305
          if (ev->y > (int )r->scrollBar.end) {
            {
#line 1309
            rxvt_tt_printf(r, "\033[B");
            }
          } else {
#line 1305
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1312
          if (ev->button == 2U) {
#line 1312
            goto case_2;
          }
#line 1315
          if (ev->button == 1U) {
#line 1315
            goto case_1___0;
          }
#line 1318
          if (ev->button == 3U) {
#line 1318
            goto case_3___0;
          }
#line 1311
          goto switch_break___0;
          case_2: /* CIL Label */ 
          {
#line 1313
          rxvt_tt_printf(r, "\f");
          }
#line 1314
          goto switch_break___0;
          case_1___0: /* CIL Label */ 
          {
#line 1316
          rxvt_tt_printf(r, "\033[6~");
          }
#line 1317
          goto switch_break___0;
          case_3___0: /* CIL Label */ 
          {
#line 1319
          rxvt_tt_printf(r, "\033[5~");
          }
#line 1320
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      } else {
#line 1325
        upordown = (char)0;
#line 1327
        if ((int )r->scrollBar.style == 1) {
#line 1328
          if (ev->y > (int )r->scrollBar.end) {
#line 1328
            if (ev->y <= (int )r->scrollBar.end + ((int )r->scrollBar.width + 1)) {
#line 1329
              upordown = (char)-1;
            } else {
#line 1328
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 1330
          if (ev->y > (int )r->scrollBar.end + ((int )r->scrollBar.width + 1)) {
#line 1331
            upordown = (char)1;
          }
        } else
#line 1332
        if ((int )r->scrollBar.style == 0) {
#line 1333
          if (ev->y < (int )r->scrollBar.beg) {
#line 1334
            upordown = (char)-1;
          } else
#line 1335
          if (ev->y > (int )r->scrollBar.end) {
#line 1336
            upordown = (char)1;
          }
        }
#line 1338
        if (upordown) {
#line 1342
          if ((int )upordown < 0) {
#line 1342
            tmp = 0;
          } else {
#line 1342
            tmp = 1;
          }
          {
#line 1342
          tmp___0 = rxvt_scr_page(r, (enum page_dirn )tmp, 1);
          }
#line 1342
          if (tmp___0) {
#line 1343
            if ((int )upordown < 0) {
#line 1344
              r->scrollBar.state = (char )'U';
            } else {
#line 1346
              r->scrollBar.state = (char )'D';
            }
          }
        } else {
          {
#line 1350
          if (ev->button == 2U) {
#line 1350
            goto case_2___0;
          }
#line 1371
          if (ev->button == 1U) {
#line 1371
            goto case_1___2;
          }
#line 1376
          if (ev->button == 3U) {
#line 1376
            goto case_3___1;
          }
#line 1349
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
          {
#line 1352
          if ((int )h->scrollbar_align == 1) {
#line 1352
            goto case_1___1;
          }
#line 1355
          if ((int )h->scrollbar_align == 0) {
#line 1355
            goto case_0;
          }
#line 1358
          if ((int )h->scrollbar_align == 2) {
#line 1358
            goto case_2___1;
          }
#line 1351
          goto switch_break___2;
          case_1___1: /* CIL Label */ 
#line 1353
          h->csrO = 0;
#line 1354
          goto switch_break___2;
          case_0: /* CIL Label */ 
#line 1356
          h->csrO = ((int )r->scrollBar.bot - (int )r->scrollBar.top) / 2;
#line 1357
          goto switch_break___2;
          case_2___1: /* CIL Label */ 
#line 1359
          h->csrO = (int )r->scrollBar.bot - (int )r->scrollBar.top;
#line 1360
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
#line 1362
          if ((int )r->scrollBar.style == 2) {
#line 1362
            goto _L___4;
          } else
#line 1362
          if (ev->y < (int )r->scrollBar.top) {
#line 1362
            goto _L___4;
          } else
#line 1362
          if (ev->y > (int )r->scrollBar.bot) {
            _L___4: /* CIL Label */ 
#line 1365
            if ((int )r->scrollBar.style == 1) {
#line 1365
              tmp___1 = 14;
            } else {
#line 1365
              tmp___1 = 10;
            }
            {
#line 1365
            rxvt_scr_move_to(r, (ev->y - (int )r->scrollBar.beg) - h->csrO, ((int )r->scrollBar.end - (int )r->scrollBar.beg) - tmp___1);
            }
          }
#line 1368
          r->scrollBar.state = (char )'m';
#line 1369
          goto switch_break___1;
          case_1___2: /* CIL Label */ 
#line 1372
          if ((int )h->scrollbar_align == 0) {
#line 1373
            h->csrO = ev->y - (int )r->scrollBar.top;
          }
          case_3___1: /* CIL Label */ 
#line 1377
          if ((int )r->scrollBar.style != 2) {
#line 1378
            if (ev->y < (int )r->scrollBar.top) {
              {
#line 1380
              rxvt_scr_page(r, (enum page_dirn )0, (int )r->TermWin.nrow - 1);
              }
            } else
#line 1384
            if (ev->y > (int )r->scrollBar.bot) {
              {
#line 1386
              rxvt_scr_page(r, (enum page_dirn )1, (int )r->TermWin.nrow - 1);
              }
            } else {
#line 1391
              r->scrollBar.state = (char )'m';
            }
          } else {
#line 1393
            if ((int )r->scrollBar.style == 1) {
#line 1393
              tmp___2 = 14;
            } else {
#line 1393
              tmp___2 = 10;
            }
#line 1393
            if (ev->button == 1U) {
#line 1393
              tmp___3 = 1;
            } else {
#line 1393
              tmp___3 = 0;
            }
            {
#line 1393
            rxvt_scr_page(r, (enum page_dirn )tmp___3, ((int )r->TermWin.nrow * (ev->y - (int )r->scrollBar.beg)) / (((int )r->scrollBar.end - (int )r->scrollBar.beg) - tmp___2));
            }
          }
#line 1398
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
        }
      }
#line 1401
      return;
    }
  }
#line 1408
  return;
}
}
#line 1411 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_button_release(rxvt_t *r , XButtonEvent *ev ) 
{ 
  int reportmode ;
  unsigned short const   **tmp ;

  {
#line 1414
  reportmode = 0;
#line 1416
  (r->h)->csrO = 0;
#line 1417
  if (! (r->h)->bypass_keystate) {
#line 1418
    reportmode = ! (! ((r->h)->PrivateModes & ((1UL << 12) | (1UL << 13))));
  }
  {
#line 1420
  tmp = __ctype_b_loc();
  }
#line 1420
  if ((int const   )*(*tmp + (int )r->scrollBar.state) & 256) {
    {
#line 1421
    r->scrollBar.state = (char)1;
#line 1422
    rxvt_scrollbar_show(r, 0);
    }
  }
#line 1427
  if (ev->window == r->TermWin.vt) {
#line 1428
    if (! (ev->subwindow != 0UL)) {
#line 1431
      if (reportmode) {
#line 1434
        if (ev->button >= 4U) {
#line 1435
          return;
        }
        {
#line 1447
        (r->h)->MEvent.button = 0U;
#line 1448
        rxvt_mouse_report(r, (XButtonEvent const   *)ev);
        }
#line 1450
        return;
      }
#line 1456
      if ((r->h)->PrivateModes & ((1UL << 12) | (1UL << 13))) {
#line 1456
        if ((r->h)->bypass_keystate) {
#line 1456
          if (ev->button == 1U) {
#line 1456
            if ((r->h)->MEvent.clicks <= 1) {
              {
#line 1459
              rxvt_selection_extend(r, ev->x, ev->y, 0);
              }
            }
          }
        }
      }
      {
#line 1463
      if (ev->button == 3U) {
#line 1463
        goto case_3;
      }
#line 1463
      if (ev->button == 1U) {
#line 1463
        goto case_3;
      }
#line 1466
      if (ev->button == 2U) {
#line 1466
        goto case_2;
      }
#line 1461
      goto switch_break;
      case_3: /* CIL Label */ 
      case_1: /* CIL Label */ 
      {
#line 1464
      rxvt_selection_make(r, ev->time);
      }
#line 1465
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1467
      rxvt_selection_request(r, ev->time, ev->x, ev->y);
      }
#line 1468
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1506
  return;
}
}
#line 1701 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
FILE *rxvt_popen_printer(rxvt_t *r ) 
{ 
  FILE *stream ;
  FILE *tmp ;

  {
  {
#line 1704
  tmp = popen((r->h)->rs[54], "w");
#line 1704
  stream = tmp;
  }
#line 1706
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
    {
#line 1707
    rxvt_print_error("can\'t open printer pipe");
    }
  }
#line 1708
  return (stream);
}
}
#line 1712 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
int rxvt_pclose_printer(FILE *stream ) 
{ 
  int tmp ;

  {
  {
#line 1715
  fflush(stream);
#line 1721
  tmp = pclose(stream);
  }
#line 1721
  return (tmp);
}
}
#line 1729 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_print_pipe(rxvt_t *r ) 
{ 
  int done ;
  FILE *fd ;
  unsigned char buf[8] ;
  unsigned char ch ;
  unsigned int i ;
  unsigned int len ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned char tmp___3 ;
  unsigned int tmp___4 ;
  unsigned char tmp___5 ;
  unsigned int tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1735
  fd = rxvt_popen_printer(r);
  }
#line 1735
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 1736
    return;
  }
#line 1742
  done = 0;
  {
#line 1742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1742
    if (! (! done)) {
#line 1742
      goto while_break;
    }
    {
#line 1747
    ch = rxvt_cmd_getc(r);
    }
#line 1747
    if ((int )ch != 27) {
      {
#line 1748
      tmp = _IO_putc((int )ch, fd);
      }
#line 1748
      if (tmp == -1) {
#line 1749
        goto while_break;
      }
    } else {
      {
#line 1751
      len = 0U;
#line 1752
      tmp___0 = len;
#line 1752
      len ++;
#line 1752
      buf[tmp___0] = ch;
#line 1754
      tmp___6 = len;
#line 1754
      len ++;
#line 1754
      tmp___7 = rxvt_cmd_getc(r);
#line 1754
      buf[tmp___6] = tmp___7;
      }
#line 1754
      if ((int )tmp___7 == 91) {
        {
#line 1755
        ch = rxvt_cmd_getc(r);
        }
#line 1755
        if ((int )ch == 63) {
          {
#line 1756
          tmp___1 = len;
#line 1756
          len ++;
#line 1756
          buf[tmp___1] = (unsigned char )'?';
#line 1757
          ch = rxvt_cmd_getc(r);
          }
        }
#line 1759
        tmp___4 = len;
#line 1759
        len ++;
#line 1759
        tmp___5 = ch;
#line 1759
        buf[tmp___4] = tmp___5;
#line 1759
        if ((int )tmp___5 == 52) {
          {
#line 1760
          tmp___2 = len;
#line 1760
          len ++;
#line 1760
          tmp___3 = rxvt_cmd_getc(r);
#line 1760
          buf[tmp___2] = tmp___3;
          }
#line 1760
          if ((int )tmp___3 == 105) {
#line 1761
            goto while_break;
          }
        }
      }
#line 1764
      i = 0U;
      {
#line 1764
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1764
        if (! (i < len)) {
#line 1764
          goto while_break___0;
        }
        {
#line 1765
        tmp___8 = _IO_putc((int )buf[i], fd);
        }
#line 1765
        if (tmp___8 == -1) {
#line 1766
          done = 1;
#line 1767
          goto while_break___0;
        }
#line 1764
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1771
  rxvt_pclose_printer(fd);
  }
#line 1772
  return;
}
}
#line 1788 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_nonprinting(rxvt_t *r , unsigned char ch ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1792
  if ((int )ch == 5) {
#line 1792
    goto case_5;
  }
#line 1801
  if ((int )ch == 7) {
#line 1801
    goto case_7;
  }
#line 1804
  if ((int )ch == 8) {
#line 1804
    goto case_8;
  }
#line 1807
  if ((int )ch == 9) {
#line 1807
    goto case_9;
  }
#line 1810
  if ((int )ch == 13) {
#line 1810
    goto case_13;
  }
#line 1815
  if ((int )ch == 10) {
#line 1815
    goto case_10;
  }
#line 1815
  if ((int )ch == 12) {
#line 1815
    goto case_10;
  }
#line 1815
  if ((int )ch == 11) {
#line 1815
    goto case_10;
  }
#line 1818
  if ((int )ch == 14) {
#line 1818
    goto case_14;
  }
#line 1821
  if ((int )ch == 15) {
#line 1821
    goto case_15;
  }
#line 1791
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1793
  if ((r->h)->rs[58]) {
    {
#line 1794
    tmp = strlen((r->h)->rs[58]);
#line 1794
    rxvt_tt_write(r, (unsigned char const   *)(r->h)->rs[58], (unsigned int )tmp);
    }
  } else {
    {
#line 1798
    tmp___0 = strlen("\033[?1;2c");
#line 1798
    rxvt_tt_write(r, (unsigned char const   *)((unsigned char *)"\033[?1;2c"), (unsigned int )tmp___0);
    }
  }
#line 1800
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1802
  rxvt_scr_bell(r);
  }
#line 1803
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1805
  rxvt_scr_backspace(r);
  }
#line 1806
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1808
  rxvt_scr_tab(r, 1);
  }
#line 1809
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1811
  rxvt_scr_gotorc(r, 0, 0, 2);
  }
#line 1812
  goto switch_break;
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  {
#line 1816
  rxvt_scr_index(r, (enum page_dirn )0);
  }
#line 1817
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 1819
  rxvt_scr_charset_choose(r, 1);
  }
#line 1820
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 1822
  rxvt_scr_charset_choose(r, 0);
  }
#line 1823
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1825
  return;
}
}
#line 1831 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_escape_vt52(rxvt_t *r , unsigned char ch ) 
{ 
  int row ;
  int col ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  {
#line 1837
  if ((int )ch == 65) {
#line 1837
    goto case_65;
  }
#line 1840
  if ((int )ch == 66) {
#line 1840
    goto case_66;
  }
#line 1843
  if ((int )ch == 67) {
#line 1843
    goto case_67;
  }
#line 1846
  if ((int )ch == 68) {
#line 1846
    goto case_68;
  }
#line 1849
  if ((int )ch == 72) {
#line 1849
    goto case_72;
  }
#line 1852
  if ((int )ch == 73) {
#line 1852
    goto case_73;
  }
#line 1855
  if ((int )ch == 74) {
#line 1855
    goto case_74;
  }
#line 1858
  if ((int )ch == 75) {
#line 1858
    goto case_75;
  }
#line 1861
  if ((int )ch == 89) {
#line 1861
    goto case_89;
  }
#line 1870
  if ((int )ch == 90) {
#line 1870
    goto case_90;
  }
#line 1873
  if ((int )ch == 60) {
#line 1873
    goto case_60;
  }
#line 1877
  if ((int )ch == 71) {
#line 1877
    goto case_71;
  }
#line 1877
  if ((int )ch == 70) {
#line 1877
    goto case_71;
  }
#line 1881
  if ((int )ch == 62) {
#line 1881
    goto case_62;
  }
#line 1881
  if ((int )ch == 61) {
#line 1881
    goto case_62;
  }
#line 1836
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 1838
  rxvt_scr_gotorc(r, -1, 0, 3);
  }
#line 1839
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 1841
  rxvt_scr_gotorc(r, 1, 0, 3);
  }
#line 1842
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 1844
  rxvt_scr_gotorc(r, 0, 1, 3);
  }
#line 1845
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 1847
  rxvt_scr_gotorc(r, 0, -1, 3);
  }
#line 1848
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 1850
  rxvt_scr_gotorc(r, 0, 0, 0);
  }
#line 1851
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 1853
  rxvt_scr_index(r, (enum page_dirn )1);
  }
#line 1854
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 1856
  rxvt_scr_erase_screen(r, 0);
  }
#line 1857
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 1859
  rxvt_scr_erase_line(r, 0);
  }
#line 1860
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 1866
  tmp = rxvt_cmd_getc(r);
#line 1866
  row = (int )tmp - 32;
#line 1867
  tmp___0 = rxvt_cmd_getc(r);
#line 1867
  col = (int )tmp___0 - 32;
#line 1868
  rxvt_scr_gotorc(r, row, col, 0);
  }
#line 1869
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 1871
  rxvt_tt_printf(r, "\033/Z");
  }
#line 1872
  goto switch_break;
  case_60: /* CIL Label */ 
#line 1874
  (r->h)->PrivateModes &= ~ (1UL << 19);
#line 1875
  goto switch_break;
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
#line 1879
  goto switch_break;
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
#line 1883
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1885
  return;
}
}
#line 1891 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_escape_seq(rxvt_t *r ) 
{ 
  unsigned char ch ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;

  {
  {
#line 1894
  tmp = rxvt_cmd_getc(r);
#line 1894
  ch = tmp;
  }
#line 1896
  if ((r->h)->PrivateModes & (1UL << 19)) {
    {
#line 1897
    rxvt_process_escape_vt52(r, ch);
    }
#line 1898
    return;
  }
  {
#line 1903
  if ((int )ch == 35) {
#line 1903
    goto case_35;
  }
#line 1907
  if ((int )ch == 40) {
#line 1907
    goto case_40;
  }
#line 1910
  if ((int )ch == 41) {
#line 1910
    goto case_41;
  }
#line 1913
  if ((int )ch == 42) {
#line 1913
    goto case_42;
  }
#line 1916
  if ((int )ch == 43) {
#line 1916
    goto case_43;
  }
#line 1929
  if ((int )ch == 55) {
#line 1929
    goto case_55;
  }
#line 1932
  if ((int )ch == 56) {
#line 1932
    goto case_56;
  }
#line 1941
  if ((int )ch == 62) {
#line 1941
    goto case_62;
  }
#line 1941
  if ((int )ch == 61) {
#line 1941
    goto case_62;
  }
#line 1945
  if ((int )ch == 64) {
#line 1945
    goto case_64;
  }
#line 1948
  if ((int )ch == 68) {
#line 1948
    goto case_68;
  }
#line 1953
  if ((int )ch == 69) {
#line 1953
    goto case_69;
  }
#line 1958
  if ((int )ch == 71) {
#line 1958
    goto case_71;
  }
#line 1963
  if ((int )ch == 72) {
#line 1963
    goto case_72;
  }
#line 1968
  if ((int )ch == 77) {
#line 1968
    goto case_77;
  }
#line 1979
  if ((int )ch == 80) {
#line 1979
    goto case_80;
  }
#line 1984
  if ((int )ch == 90) {
#line 1984
    goto case_90;
  }
#line 1990
  if ((int )ch == 91) {
#line 1990
    goto case_91;
  }
#line 1995
  if ((int )ch == 93) {
#line 1995
    goto case_93;
  }
#line 2000
  if ((int )ch == 99) {
#line 2000
    goto case_99;
  }
#line 2006
  if ((int )ch == 110) {
#line 2006
    goto case_110;
  }
#line 2011
  if ((int )ch == 111) {
#line 2011
    goto case_111;
  }
#line 1901
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 1904
  tmp___0 = rxvt_cmd_getc(r);
  }
#line 1904
  if ((int )tmp___0 == 56) {
    {
#line 1905
    rxvt_scr_E(r);
    }
  }
#line 1906
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 1908
  tmp___1 = rxvt_cmd_getc(r);
#line 1908
  rxvt_scr_charset_set(r, 0, (unsigned int )tmp___1);
  }
#line 1909
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1911
  tmp___2 = rxvt_cmd_getc(r);
#line 1911
  rxvt_scr_charset_set(r, 1, (unsigned int )tmp___2);
  }
#line 1912
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 1914
  tmp___3 = rxvt_cmd_getc(r);
#line 1914
  rxvt_scr_charset_set(r, 2, (unsigned int )tmp___3);
  }
#line 1915
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 1917
  tmp___4 = rxvt_cmd_getc(r);
#line 1917
  rxvt_scr_charset_set(r, 3, (unsigned int )tmp___4);
  }
#line 1918
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 1930
  rxvt_scr_cursor(r, 's');
  }
#line 1931
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 1933
  rxvt_scr_cursor(r, 'r');
  }
#line 1934
  goto switch_break;
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
#line 1942
  if ((int )ch == 61) {
#line 1942
    (r->h)->PrivateModes |= 1UL << 7;
  } else {
#line 1942
    (r->h)->PrivateModes &= ~ (1UL << 7);
  }
#line 1943
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 1946
  rxvt_cmd_getc(r);
  }
#line 1947
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 1949
  rxvt_scr_index(r, (enum page_dirn )0);
  }
#line 1950
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 1954
  rxvt_scr_add_lines(r, (unsigned char const   *)"\n\r", 1, 2);
  }
#line 1955
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 1959
  rxvt_process_graphics(r);
  }
#line 1960
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 1964
  rxvt_scr_set_tab(r, 1);
  }
#line 1965
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 1969
  rxvt_scr_index(r, (enum page_dirn )1);
  }
#line 1970
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 1980
  rxvt_process_dcs_seq(r);
  }
#line 1981
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 1985
  rxvt_tt_write(r, (unsigned char const   *)"\033[?1;2c", (unsigned int )(sizeof("\033[?1;2c") - 1UL));
  }
#line 1987
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 1991
  rxvt_process_csi_seq(r);
  }
#line 1992
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 1996
  rxvt_process_osc_seq(r);
  }
#line 1997
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 2001
  rxvt_scr_poweron(r);
#line 2002
  rxvt_scrollbar_show(r, 1);
  }
#line 2003
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 2007
  rxvt_scr_charset_choose(r, 2);
  }
#line 2008
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 2012
  rxvt_scr_charset_choose(r, 3);
  }
#line 2013
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2015
  return;
}
}
#line 2038 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
unsigned char const   csi_defaults[8]  = 
#line 2038
  {      (unsigned char const   )((((((((1 << 7) | (1 << 6)) | (1 << 5)) | (1 << 4)) | (1 << 3)) | (1 << 2)) | (1 << 1)) | 1),      (unsigned char const   )((((1 << 7) | (1 << 6)) | (1 << 3)) | (1 << 2)),      (unsigned char const   )((((((1 << 7) | (1 << 5)) | (1 << 4)) | (1 << 3)) | (1 << 2)) | (1 << 1)),      (unsigned char const   )((((1 << 7) | (1 << 6)) | (1 << 5)) | (1 << 1)), 
        (unsigned char const   )((((((1 << 7) | (1 << 6)) | (1 << 5)) | (1 << 3)) | (1 << 2)) | (1 << 1)),      (unsigned char const   )((1 << 5) | (1 << 4)),      (unsigned char const   )0,      (unsigned char const   )0};
#line 2051 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_csi_seq(rxvt_t *r ) 
{ 
  unsigned char ch ;
  unsigned char priv ;
  unsigned char i ;
  unsigned int nargs ;
  unsigned int p ;
  int n ;
  int ndef ;
  int arg[32] ;
  unsigned int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2059
  nargs = 32U;
  {
#line 2059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2059
    if (! (nargs > 0U)) {
#line 2059
      goto while_break;
    }
#line 2060
    nargs --;
#line 2060
    arg[nargs] = 0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2062
  priv = (unsigned char)0;
#line 2063
  ch = rxvt_cmd_getc(r);
  }
#line 2064
  if ((int )ch >= 60) {
#line 2064
    if ((int )ch <= 63) {
      {
#line 2065
      priv = ch;
#line 2066
      ch = rxvt_cmd_getc(r);
      }
    }
  }
#line 2069
  n = -1;
  {
#line 2069
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2069
    if (! ((int )ch < 64)) {
#line 2069
      goto while_break___0;
    }
    {
#line 2070
    tmp___0 = __ctype_b_loc();
    }
#line 2070
    if ((int const   )*(*tmp___0 + (int )ch) & 2048) {
#line 2071
      if (n < 0) {
#line 2072
        n = (int )ch - 48;
      } else {
#line 2074
        n = (n * 10 + (int )ch) - 48;
      }
    } else
#line 2075
    if ((int )ch == 59) {
#line 2076
      if (nargs < 32U) {
#line 2077
        tmp = nargs;
#line 2077
        nargs ++;
#line 2077
        arg[tmp] = n;
      }
#line 2078
      n = -1;
    } else
#line 2079
    if ((int )ch == 8) {
      {
#line 2080
      rxvt_scr_backspace(r);
      }
    } else
#line 2081
    if ((int )ch == 27) {
      {
#line 2082
      rxvt_process_escape_seq(r);
      }
#line 2083
      return;
    } else
#line 2084
    if ((int )ch < 32) {
      {
#line 2085
      rxvt_process_nonprinting(r, ch);
      }
    }
    {
#line 2087
    ch = rxvt_cmd_getc(r);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2090
  if ((int )ch > 127) {
#line 2091
    return;
  }
#line 2093
  if (nargs < 32U) {
#line 2094
    tmp___1 = nargs;
#line 2094
    nargs ++;
#line 2094
    arg[tmp___1] = n;
  }
#line 2096
  i = (unsigned char )((int )ch - 64);
#line 2097
  ndef = ! (! ((int const   )csi_defaults[(int )i / 8] & (int const   )(128 >> ((int )i & 7))));
#line 2098
  p = 0U;
  {
#line 2098
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2098
    if (! (p < nargs)) {
#line 2098
      goto while_break___1;
    }
#line 2099
    if (arg[p] == -1) {
#line 2100
      arg[p] = ndef;
    }
#line 2098
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2112
  if (priv) {
    {
#line 2114
    if ((int )priv == 62) {
#line 2114
      goto case_62;
    }
#line 2118
    if ((int )priv == 63) {
#line 2118
      goto case_63;
    }
#line 2113
    goto switch_break;
    case_62: /* CIL Label */ 
#line 2115
    if ((int )ch == 99) {
      {
#line 2116
      rxvt_tt_printf(r, "\033[>%d;%-.8s;0c", 'R', "20710");
      }
    }
#line 2117
    goto switch_break;
    case_63: /* CIL Label */ 
#line 2119
    if ((int )ch == 104) {
      {
#line 2120
      rxvt_process_terminal_mode(r, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    } else
#line 2119
    if ((int )ch == 108) {
      {
#line 2120
      rxvt_process_terminal_mode(r, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    } else
#line 2119
    if ((int )ch == 114) {
      {
#line 2120
      rxvt_process_terminal_mode(r, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    } else
#line 2119
    if ((int )ch == 115) {
      {
#line 2120
      rxvt_process_terminal_mode(r, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    } else
#line 2119
    if ((int )ch == 116) {
      {
#line 2120
      rxvt_process_terminal_mode(r, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    }
#line 2121
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2123
    return;
  }
  {
#line 2131
  if ((int )ch == 105) {
#line 2131
    goto case_105;
  }
#line 2144
  if ((int )ch == 101) {
#line 2144
    goto case_101;
  }
#line 2144
  if ((int )ch == 65) {
#line 2144
    goto case_101;
  }
#line 2148
  if ((int )ch == 107) {
#line 2148
    goto case_107;
  }
#line 2148
  if ((int )ch == 66) {
#line 2148
    goto case_107;
  }
#line 2153
  if ((int )ch == 106) {
#line 2153
    goto case_106;
  }
#line 2153
  if ((int )ch == 68) {
#line 2153
    goto case_106;
  }
#line 2161
  if ((int )ch == 97) {
#line 2161
    goto case_97;
  }
#line 2161
  if ((int )ch == 67) {
#line 2161
    goto case_97;
  }
#line 2169
  if ((int )ch == 70) {
#line 2169
    goto case_70;
  }
#line 2172
  if ((int )ch == 69) {
#line 2172
    goto case_69;
  }
#line 2177
  if ((int )ch == 96) {
#line 2177
    goto case_96;
  }
#line 2177
  if ((int )ch == 71) {
#line 2177
    goto case_96;
  }
#line 2181
  if ((int )ch == 100) {
#line 2181
    goto case_100;
  }
#line 2186
  if ((int )ch == 102) {
#line 2186
    goto case_102;
  }
#line 2186
  if ((int )ch == 72) {
#line 2186
    goto case_102;
  }
#line 2190
  if ((int )ch == 90) {
#line 2190
    goto case_90;
  }
#line 2193
  if ((int )ch == 73) {
#line 2193
    goto case_73;
  }
#line 2197
  if ((int )ch == 74) {
#line 2197
    goto case_74;
  }
#line 2201
  if ((int )ch == 75) {
#line 2201
    goto case_75;
  }
#line 2205
  if ((int )ch == 64) {
#line 2205
    goto case_64;
  }
#line 2209
  if ((int )ch == 76) {
#line 2209
    goto case_76;
  }
#line 2213
  if ((int )ch == 77) {
#line 2213
    goto case_77;
  }
#line 2217
  if ((int )ch == 88) {
#line 2217
    goto case_88;
  }
#line 2221
  if ((int )ch == 80) {
#line 2221
    goto case_80;
  }
#line 2225
  if ((int )ch == 84) {
#line 2225
    goto case_84;
  }
#line 2228
  if ((int )ch == 83) {
#line 2228
    goto case_83;
  }
#line 2232
  if ((int )ch == 99) {
#line 2232
    goto case_99;
  }
#line 2237
  if ((int )ch == 109) {
#line 2237
    goto case_109;
  }
#line 2241
  if ((int )ch == 110) {
#line 2241
    goto case_110;
  }
#line 2260
  if ((int )ch == 103) {
#line 2260
    goto case_103;
  }
#line 2275
  if ((int )ch == 87) {
#line 2275
    goto case_87;
  }
#line 2293
  if ((int )ch == 108) {
#line 2293
    goto case_108;
  }
#line 2298
  if ((int )ch == 104) {
#line 2298
    goto case_104;
  }
#line 2306
  if ((int )ch == 114) {
#line 2306
    goto case_114;
  }
#line 2315
  if ((int )ch == 115) {
#line 2315
    goto case_115;
  }
#line 2318
  if ((int )ch == 117) {
#line 2318
    goto case_117;
  }
#line 2328
  if ((int )ch == 120) {
#line 2328
    goto case_120;
  }
#line 2333
  goto switch_default;
  case_105: /* CIL Label */ 
  {
#line 2133
  if (arg[0] == 0) {
#line 2133
    goto case_0;
  }
#line 2136
  if (arg[0] == 5) {
#line 2136
    goto case_5;
  }
#line 2132
  goto switch_break___1;
  case_0: /* CIL Label */ 
  {
#line 2134
  rxvt_scr_printscreen(r, 0);
  }
#line 2135
  goto switch_break___1;
  case_5: /* CIL Label */ 
  {
#line 2137
  rxvt_process_print_pipe(r);
  }
#line 2138
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 2140
  goto switch_break___0;
  case_101: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 2145
  arg[0] = - arg[0];
  case_107: /* CIL Label */ 
  case_66: /* CIL Label */ 
  {
#line 2149
  rxvt_scr_gotorc(r, arg[0], 0, 3);
  }
#line 2150
  goto switch_break___0;
  case_106: /* CIL Label */ 
  case_68: /* CIL Label */ 
#line 2157
  if (arg[0]) {
#line 2157
    arg[0] = - arg[0];
  } else {
#line 2157
    arg[0] = -1;
  }
  case_97: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 2165
  if (arg[0]) {
#line 2165
    tmp___2 = arg[0];
  } else {
#line 2165
    tmp___2 = 1;
  }
  {
#line 2165
  rxvt_scr_gotorc(r, 0, tmp___2, 3);
  }
#line 2167
  goto switch_break___0;
  case_70: /* CIL Label */ 
#line 2170
  arg[0] = - arg[0];
  case_69: /* CIL Label */ 
  {
#line 2173
  rxvt_scr_gotorc(r, arg[0], 0, 2);
  }
#line 2174
  goto switch_break___0;
  case_96: /* CIL Label */ 
  case_71: /* CIL Label */ 
  {
#line 2178
  rxvt_scr_gotorc(r, 0, arg[0] - 1, 2);
  }
#line 2179
  goto switch_break___0;
  case_100: /* CIL Label */ 
  {
#line 2182
  rxvt_scr_gotorc(r, arg[0] - 1, 0, 1);
  }
#line 2183
  goto switch_break___0;
  case_102: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 2187
  if (nargs < 2U) {
#line 2187
    tmp___3 = 0;
  } else {
#line 2187
    tmp___3 = arg[1] - 1;
  }
  {
#line 2187
  rxvt_scr_gotorc(r, arg[0] - 1, tmp___3, 0);
  }
#line 2188
  goto switch_break___0;
  case_90: /* CIL Label */ 
#line 2191
  arg[0] = - arg[0];
  case_73: /* CIL Label */ 
  {
#line 2194
  rxvt_scr_tab(r, arg[0]);
  }
#line 2195
  goto switch_break___0;
  case_74: /* CIL Label */ 
  {
#line 2198
  rxvt_scr_erase_screen(r, arg[0]);
  }
#line 2199
  goto switch_break___0;
  case_75: /* CIL Label */ 
  {
#line 2202
  rxvt_scr_erase_line(r, arg[0]);
  }
#line 2203
  goto switch_break___0;
  case_64: /* CIL Label */ 
  {
#line 2206
  rxvt_scr_insdel_chars(r, arg[0], -1);
  }
#line 2207
  goto switch_break___0;
  case_76: /* CIL Label */ 
  {
#line 2210
  rxvt_scr_insdel_lines(r, arg[0], -1);
  }
#line 2211
  goto switch_break___0;
  case_77: /* CIL Label */ 
  {
#line 2214
  rxvt_scr_insdel_lines(r, arg[0], 1);
  }
#line 2215
  goto switch_break___0;
  case_88: /* CIL Label */ 
  {
#line 2218
  rxvt_scr_insdel_chars(r, arg[0], 2);
  }
#line 2219
  goto switch_break___0;
  case_80: /* CIL Label */ 
  {
#line 2222
  rxvt_scr_insdel_chars(r, arg[0], 1);
  }
#line 2223
  goto switch_break___0;
  case_84: /* CIL Label */ 
#line 2226
  arg[0] = - arg[0];
  case_83: /* CIL Label */ 
  {
#line 2229
  rxvt_scroll_text(r, (int )r->screen.tscroll, (int )r->screen.bscroll, arg[0], 0);
  }
#line 2230
  goto switch_break___0;
  case_99: /* CIL Label */ 
  {
#line 2233
  rxvt_tt_write(r, (unsigned char const   *)"\033[?1;2c", (unsigned int )(sizeof("\033[?1;2c") - 1UL));
  }
#line 2235
  goto switch_break___0;
  case_109: /* CIL Label */ 
  {
#line 2238
  rxvt_process_sgr_mode(r, nargs, (int const   *)(arg));
  }
#line 2239
  goto switch_break___0;
  case_110: /* CIL Label */ 
  {
#line 2243
  if (arg[0] == 5) {
#line 2243
    goto case_5___0;
  }
#line 2246
  if (arg[0] == 6) {
#line 2246
    goto case_6;
  }
#line 2254
  if (arg[0] == 8) {
#line 2254
    goto case_8;
  }
#line 2242
  goto switch_break___2;
  case_5___0: /* CIL Label */ 
  {
#line 2244
  rxvt_tt_printf(r, "\033[0n");
  }
#line 2245
  goto switch_break___2;
  case_6: /* CIL Label */ 
  {
#line 2247
  rxvt_scr_report_position(r);
  }
#line 2248
  goto switch_break___2;
  case_8: /* CIL Label */ 
  {
#line 2255
  rxvt_xterm_seq(r, 2, "rxvt-2.7.10", (unsigned char)156);
  }
#line 2256
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 2258
  goto switch_break___0;
  case_103: /* CIL Label */ 
  {
#line 2262
  if (arg[0] == 0) {
#line 2262
    goto case_0___0;
  }
#line 2269
  if (arg[0] == 5) {
#line 2269
    goto case_5___1;
  }
#line 2269
  if (arg[0] == 3) {
#line 2269
    goto case_5___1;
  }
#line 2261
  goto switch_break___3;
  case_0___0: /* CIL Label */ 
  {
#line 2263
  rxvt_scr_set_tab(r, 0);
  }
#line 2264
  goto switch_break___3;
  case_5___1: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 2270
  rxvt_scr_set_tab(r, -1);
  }
#line 2271
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 2273
  goto switch_break___0;
  case_87: /* CIL Label */ 
  {
#line 2277
  if (arg[0] == 0) {
#line 2277
    goto case_0___1;
  }
#line 2281
  if (arg[0] == 2) {
#line 2281
    goto case_2;
  }
#line 2286
  if (arg[0] == 5) {
#line 2286
    goto case_5___2;
  }
#line 2276
  goto switch_break___4;
  case_0___1: /* CIL Label */ 
  {
#line 2278
  rxvt_scr_set_tab(r, 1);
  }
#line 2279
  goto switch_break___4;
  case_2: /* CIL Label */ 
  {
#line 2282
  rxvt_scr_set_tab(r, 0);
  }
#line 2283
  goto switch_break___4;
  case_5___2: /* CIL Label */ 
  {
#line 2287
  rxvt_scr_set_tab(r, -1);
  }
#line 2288
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 2291
  goto switch_break___0;
  case_108: /* CIL Label */ 
#line 2294
  if (arg[0] == 4) {
    {
#line 2295
    rxvt_scr_insert_mode(r, 0);
    }
  }
#line 2296
  goto switch_break___0;
  case_104: /* CIL Label */ 
#line 2299
  if (arg[0] == 4) {
    {
#line 2300
    rxvt_scr_insert_mode(r, 1);
    }
  }
#line 2301
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 2307
  if (nargs == 1U) {
    {
#line 2308
    rxvt_scr_scroll_region(r, arg[0] - 1, 999);
    }
  } else
#line 2309
  if (nargs == 0U) {
    {
#line 2310
    rxvt_scr_scroll_region(r, 0, 999);
    }
  } else
#line 2309
  if (arg[0] >= arg[1]) {
    {
#line 2310
    rxvt_scr_scroll_region(r, 0, 999);
    }
  } else {
    {
#line 2312
    rxvt_scr_scroll_region(r, arg[0] - 1, arg[1] - 1);
    }
  }
#line 2313
  goto switch_break___0;
  case_115: /* CIL Label */ 
  {
#line 2316
  rxvt_scr_cursor(r, 's');
  }
#line 2317
  goto switch_break___0;
  case_117: /* CIL Label */ 
  {
#line 2319
  rxvt_scr_cursor(r, 'r');
  }
#line 2320
  goto switch_break___0;
  case_120: /* CIL Label */ 
#line 2329
  if (arg[0] == 0) {
    {
#line 2330
    rxvt_tt_printf(r, "\033[%d;1;1;112;112;1;0x", arg[0] + 2);
    }
  } else
#line 2329
  if (arg[0] == 1) {
    {
#line 2330
    rxvt_tt_printf(r, "\033[%d;1;1;112;112;1;0x", arg[0] + 2);
    }
  }
  switch_default: /* CIL Label */ 
#line 2334
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2336
  return;
}
}
#line 2428 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
unsigned char *rxvt_get_to_st(rxvt_t *r , unsigned char *ends_how ) 
{ 
  int seen_esc ;
  unsigned int n ;
  unsigned char *s ;
  unsigned char ch ;
  unsigned char string[512] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;

  {
#line 2431
  seen_esc = 0;
#line 2432
  n = 0U;
  {
#line 2436
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2436
    ch = rxvt_cmd_getc(r);
    }
#line 2436
    if (! ch) {
#line 2436
      goto while_break;
    }
#line 2437
    if ((int )ch == 7) {
#line 2440
      goto while_break;
    } else
#line 2437
    if ((int )ch == 156) {
#line 2440
      goto while_break;
    } else
#line 2437
    if ((int )ch == 92) {
#line 2437
      if (seen_esc) {
#line 2440
        goto while_break;
      }
    }
#line 2441
    if ((int )ch == 27) {
#line 2442
      seen_esc = 1;
#line 2443
      goto __Cont;
    } else
#line 2444
    if ((int )ch == 9) {
#line 2445
      ch = (unsigned char )' ';
    } else
#line 2446
    if ((int )ch < 8) {
#line 2447
      return ((unsigned char *)((void *)0));
    } else
#line 2446
    if ((int )ch > 13) {
#line 2446
      if ((int )ch < 32) {
#line 2447
        return ((unsigned char *)((void *)0));
      }
    }
#line 2448
    if ((unsigned long )n < sizeof(string) - 1UL) {
#line 2449
      tmp = n;
#line 2449
      n ++;
#line 2449
      string[tmp] = ch;
    }
#line 2450
    seen_esc = 0;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2452
  tmp___0 = n;
#line 2452
  n ++;
#line 2452
  string[tmp___0] = (unsigned char )'\000';
#line 2453
  tmp___1 = rxvt_malloc((size_t )n);
#line 2453
  s = (unsigned char *)tmp___1;
  }
#line 2453
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 2454
    return ((unsigned char *)((void *)0));
  }
#line 2455
  if ((int )ch == 92) {
#line 2455
    *ends_how = (unsigned char)27;
  } else {
#line 2455
    *ends_how = ch;
  }
  {
#line 2456
  strncpy((char */* __restrict  */)((char *)s), (char const   */* __restrict  */)((char const   *)(string)),
          (size_t )n);
  }
#line 2457
  return (s);
}
}
#line 2465 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_dcs_seq(rxvt_t *r ) 
{ 
  unsigned char eh ;
  unsigned char *s ;

  {
  {
#line 2472
  s = rxvt_get_to_st(r, & eh);
  }
#line 2473
  if (s) {
    {
#line 2474
    free((void *)s);
    }
  }
#line 2475
  return;
}
}
#line 2483 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_osc_seq(rxvt_t *r ) 
{ 
  unsigned char ch ;
  unsigned char eh ;
  unsigned char *s ;
  int arg ;
  unsigned short const   **tmp ;

  {
  {
#line 2489
  ch = rxvt_cmd_getc(r);
#line 2490
  arg = 0;
  }
  {
#line 2490
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2490
    tmp = __ctype_b_loc();
    }
#line 2490
    if (! ((int const   )*(*tmp + (int )ch) & 2048)) {
#line 2490
      goto while_break;
    }
    {
#line 2491
    arg = arg * 10 + ((int )ch - 48);
#line 2490
    ch = rxvt_cmd_getc(r);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2493
  if ((int )ch == 59) {
    {
#line 2494
    s = rxvt_get_to_st(r, & eh);
    }
#line 2495
    if (s) {
#line 2500
      if (! (arg == 10)) {
        {
#line 2507
        rxvt_xterm_seq(r, arg, (char const   *)((char *)s), eh);
        }
      }
      {
#line 2508
      free((void *)s);
      }
    }
  }
#line 2511
  return;
}
}
#line 2534 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_xterm_seq(rxvt_t *r , int op , char const   *str , unsigned char resp ) 
{ 
  int changed ;
  int color ;
  char *buf ;
  char *name ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 2537
  changed = 0;
#line 2542
  if (! ((unsigned long )str != (unsigned long )((void *)0))) {
    {
#line 2542
    __assert_fail("str != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c",
                  2542U, "rxvt_xterm_seq");
    }
  }
  {
#line 2544
  if (op == 0) {
#line 2544
    goto case_0;
  }
#line 2547
  if (op == 1) {
#line 2547
    goto case_1;
  }
#line 2550
  if (op == 2) {
#line 2550
    goto case_2;
  }
#line 2553
  if (op == 4) {
#line 2553
    goto case_4;
  }
#line 2567
  if (op == 12) {
#line 2567
    goto case_12;
  }
#line 2571
  if (op == 13) {
#line 2571
    goto case_13;
  }
#line 2575
  if (op == 18) {
#line 2575
    goto case_18;
  }
#line 2578
  if (op == 19) {
#line 2578
    goto case_19;
  }
#line 2581
  if (op == 17) {
#line 2581
    goto case_17;
  }
#line 2586
  if (op == 10) {
#line 2586
    goto case_10;
  }
#line 2592
  if (op == 20) {
#line 2592
    goto case_20;
  }
#line 2608
  if (op == 39) {
#line 2608
    goto case_39;
  }
#line 2611
  if (op == 49) {
#line 2611
    goto case_49;
  }
#line 2614
  if (op == 46) {
#line 2614
    goto case_46;
  }
#line 2616
  if (op == 50) {
#line 2616
    goto case_50;
  }
#line 2543
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2545
  rxvt_set_title(r, str);
  }
  case_1: /* CIL Label */ 
  {
#line 2548
  rxvt_set_iconName(r, str);
  }
#line 2549
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2551
  rxvt_set_title(r, str);
  }
#line 2552
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2554
  buf = (char *)str;
  {
#line 2554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2554
    if (buf) {
#line 2554
      if (! *buf) {
#line 2554
        goto while_break;
      }
    } else {
#line 2554
      goto while_break;
    }
    {
#line 2555
    name = strchr((char const   *)buf, ';');
    }
#line 2555
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 2556
      goto while_break;
    }
    {
#line 2557
    tmp = name;
#line 2557
    name ++;
#line 2557
    *tmp = (char )'\000';
#line 2558
    color = atoi((char const   *)buf);
    }
#line 2559
    if (color < 0) {
#line 2560
      goto while_break;
    } else
#line 2559
    if (color >= 25) {
#line 2560
      goto while_break;
    }
    {
#line 2561
    buf = strchr((char const   *)name, ';');
    }
#line 2561
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 2562
      tmp___0 = buf;
#line 2562
      buf ++;
#line 2562
      *tmp___0 = (char )'\000';
    }
    {
#line 2563
    rxvt_set_window_color(r, color + 2, (char const   *)name);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2565
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 2568
  rxvt_set_window_color(r, 18, str);
  }
#line 2569
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 2572
  rxvt_set_window_color(r, 20, str);
  }
#line 2573
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 2576
  rxvt_set_window_color(r, 22, str);
  }
#line 2577
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 2579
  rxvt_set_window_color(r, 23, str);
  }
#line 2580
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 2582
  rxvt_set_window_color(r, 24, str);
  }
#line 2583
  goto switch_break;
  case_10: /* CIL Label */ 
#line 2591
  goto switch_break;
  case_20: /* CIL Label */ 
#line 2593
  if ((int const   )*str != 59) {
    {
#line 2596
    rxvt_scr_touch(r, 1);
    }
  }
  {
#line 2598
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2598
    tmp___1 = strchr(str, ';');
#line 2598
    str = (char const   *)tmp___1;
    }
#line 2598
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 2598
      goto while_break___0;
    }
#line 2599
    str ++;
#line 2600
    changed = changed;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2602
  if (changed) {
    {
#line 2604
    rxvt_scr_touch(r, 1);
    }
  }
#line 2606
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 2609
  rxvt_set_window_color(r, 0, str);
  }
#line 2610
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 2612
  rxvt_set_window_color(r, 1, str);
  }
#line 2613
  goto switch_break;
  case_46: /* CIL Label */ 
#line 2615
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 2617
  rxvt_change_font(r, 0, str);
  }
#line 2618
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2628
  return;
}
}
#line 2642 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
int rxvt_privcases(rxvt_t *r , int mode , unsigned long bit ) 
{ 
  int state ;

  {
#line 2647
  if (mode == 115) {
#line 2648
    (r->h)->SavedModes |= (r->h)->PrivateModes & bit;
#line 2649
    return (-1);
  } else {
#line 2651
    if (mode == 114) {
#line 2652
      if ((r->h)->SavedModes & bit) {
#line 2652
        state = 1;
      } else {
#line 2652
        state = 0;
      }
    } else
#line 2654
    if (mode == 116) {
#line 2654
      state = ! ((r->h)->PrivateModes & bit);
    } else {
#line 2654
      state = mode;
    }
#line 2655
    if (state) {
#line 2655
      (r->h)->PrivateModes |= bit;
    } else {
#line 2655
      (r->h)->PrivateModes &= ~ bit;
    }
  }
#line 2657
  return (state);
}
}
#line 2667 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
static struct __anonstruct_argtopriv_180  const  argtopriv[20]  = 
#line 2667
  {      {(int const   )1, (unsigned long const   )(1UL << 6)}, 
        {(int const   )2, (unsigned long const   )(1UL << 19)}, 
        {(int const   )3, (unsigned long const   )1UL}, 
        {(int const   )4, (unsigned long const   )(1UL << 18)}, 
        {(int const   )5, (unsigned long const   )(1UL << 2)}, 
        {(int const   )6, (unsigned long const   )(1UL << 3)}, 
        {(int const   )7, (unsigned long const   )(1UL << 5)}, 
        {(int const   )9, (unsigned long const   )(1UL << 12)}, 
        {(int const   )10, (unsigned long const   )(1UL << 15)}, 
        {(int const   )30, (unsigned long const   )(1UL << 14)}, 
        {(int const   )25, (unsigned long const   )(1UL << 11)}, 
        {(int const   )35, (unsigned long const   )(1UL << 10)}, 
        {(int const   )40, (unsigned long const   )(1UL << 1)}, 
        {(int const   )47, (unsigned long const   )(1UL << 4)}, 
        {(int const   )66, (unsigned long const   )(1UL << 7)}, 
        {(int const   )67, (unsigned long const   )(1UL << 9)}, 
        {(int const   )1000, (unsigned long const   )(1UL << 13)}, 
        {(int const   )1010, (unsigned long const   )(1UL << 16)}, 
        {(int const   )1011, (unsigned long const   )(1UL << 17)}, 
        {(int const   )1047, (unsigned long const   )(1UL << 4)}};
#line 2662 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_terminal_mode(rxvt_t *r , int mode , int priv , unsigned int nargs ,
                                int const   *arg ) 
{ 
  unsigned int i ;
  unsigned int j ;
  int state ;
  int tmp ;
  int tmp___0 ;

  {
#line 2699
  if (nargs == 0U) {
#line 2700
    return;
  }
#line 2703
  if (mode == 108) {
#line 2704
    mode = 0;
  } else
#line 2705
  if (mode == 104) {
#line 2706
    mode = 1;
  }
#line 2708
  i = 0U;
  {
#line 2708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2708
    if (! (i < nargs)) {
#line 2708
      goto while_break;
    }
#line 2709
    state = -1;
#line 2712
    j = 0U;
    {
#line 2712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2712
      if (! ((unsigned long )j < sizeof(argtopriv) / sizeof(argtopriv[0]))) {
#line 2712
        goto while_break___0;
      }
#line 2713
      if (argtopriv[j].argval == *(arg + i)) {
        {
#line 2714
        state = rxvt_privcases(r, mode, (unsigned long )argtopriv[j].bit);
        }
#line 2715
        goto while_break___0;
      }
#line 2712
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2719
    if (state == -1) {
      {
#line 2721
      if (*(arg + i) == 1048) {
#line 2721
        goto case_1048;
      }
#line 2727
      goto switch_default;
      case_1048: /* CIL Label */ 
#line 2722
      if (mode == 0) {
        {
#line 2723
        rxvt_scr_cursor(r, 'r');
        }
      } else
#line 2724
      if (mode == 1) {
        {
#line 2725
        rxvt_scr_cursor(r, 's');
        }
      }
      switch_default: /* CIL Label */ 
#line 2728
      goto __Cont;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 2734
    if (*(arg + i) == 2) {
#line 2734
      goto case_2;
    }
#line 2741
    if (*(arg + i) == 3) {
#line 2741
      goto case_3;
    }
#line 2747
    if (*(arg + i) == 4) {
#line 2747
      goto case_4;
    }
#line 2753
    if (*(arg + i) == 5) {
#line 2753
      goto case_5;
    }
#line 2756
    if (*(arg + i) == 6) {
#line 2756
      goto case_6;
    }
#line 2759
    if (*(arg + i) == 7) {
#line 2759
      goto case_7;
    }
#line 2763
    if (*(arg + i) == 9) {
#line 2763
      goto case_9;
    }
#line 2768
    if (*(arg + i) == 10) {
#line 2768
      goto case_10;
    }
#line 2773
    if (*(arg + i) == 30) {
#line 2773
      goto case_30;
    }
#line 2780
    if (*(arg + i) == 25) {
#line 2780
      goto case_25;
    }
#line 2785
    if (*(arg + i) == 47) {
#line 2785
      goto case_47;
    }
#line 2790
    if (*(arg + i) == 1000) {
#line 2790
      goto case_1000;
    }
#line 2798
    if (*(arg + i) == 1010) {
#line 2798
      goto case_1010;
    }
#line 2804
    if (*(arg + i) == 1011) {
#line 2804
      goto case_1011;
    }
#line 2810
    if (*(arg + i) == 1047) {
#line 2810
      goto case_1047;
    }
#line 2815
    goto switch_default___0;
    case_2: /* CIL Label */ 
#line 2739
    (r->h)->PrivateModes |= 1UL << 19;
#line 2740
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 2742
    if ((r->h)->PrivateModes & (1UL << 1)) {
#line 2743
      if (state) {
#line 2743
        tmp = 132;
      } else {
#line 2743
        tmp = 80;
      }
      {
#line 2743
      rxvt_set_widthheight(r, (unsigned int )(tmp * (int )r->TermWin.fwidth), (unsigned int )r->TermWin.height);
      }
    }
#line 2746
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 2748
    if (state) {
#line 2749
      r->Options &= ~ (1UL << 18);
    } else {
#line 2751
      r->Options |= 1UL << 18;
    }
#line 2752
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 2754
    rxvt_scr_rvideo_mode(r, state);
    }
#line 2755
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 2757
    rxvt_scr_relative_origin(r, state);
    }
#line 2758
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 2760
    rxvt_scr_autowrap(r, state);
    }
#line 2761
    goto switch_break___0;
    case_9: /* CIL Label */ 
#line 2764
    if (state) {
#line 2765
      (r->h)->PrivateModes &= ~ (1UL << 13);
    }
#line 2766
    goto switch_break___0;
    case_10: /* CIL Label */ ;
#line 2770
    goto switch_break___0;
    case_30: /* CIL Label */ 
    {
#line 2774
    tmp___0 = rxvt_scrollbar_mapping(r, state);
    }
#line 2774
    if (tmp___0) {
      {
#line 2775
      rxvt_resize_all_windows(r, 0U, 0U, 0);
#line 2776
      rxvt_scr_touch(r, 1);
      }
    }
#line 2778
    goto switch_break___0;
    case_25: /* CIL Label */ 
    {
#line 2781
    rxvt_scr_cursor_visible(r, state);
    }
#line 2782
    goto switch_break___0;
    case_47: /* CIL Label */ 
    {
#line 2786
    rxvt_scr_change_screen(r, state);
    }
#line 2787
    goto switch_break___0;
    case_1000: /* CIL Label */ 
#line 2791
    if (state) {
#line 2792
      (r->h)->PrivateModes &= ~ (1UL << 12);
    }
#line 2793
    goto switch_break___0;
    case_1010: /* CIL Label */ 
#line 2799
    if (state) {
#line 2800
      r->Options &= ~ (1UL << 11);
    } else {
#line 2802
      r->Options |= 1UL << 11;
    }
#line 2803
    goto switch_break___0;
    case_1011: /* CIL Label */ 
#line 2805
    if (state) {
#line 2806
      r->Options |= 1UL << 12;
    } else {
#line 2808
      r->Options &= ~ (1UL << 12);
    }
#line 2809
    goto switch_break___0;
    case_1047: /* CIL Label */ 
#line 2811
    if ((int )(r->h)->current_screen != 0) {
      {
#line 2812
      rxvt_scr_erase_screen(r, 2);
      }
    }
    {
#line 2813
    rxvt_scr_change_screen(r, state);
    }
    switch_default___0: /* CIL Label */ 
#line 2816
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2708
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2819
  return;
}
}
#line 2824 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_sgr_mode(rxvt_t *r , unsigned int nargs , int const   *arg ) 
{ 
  unsigned int i ;
  short rendset ;
  int rendstyle ;

  {
#line 2831
  if (nargs == 0U) {
    {
#line 2832
    rxvt_scr_rendition(r, 0, ~ 0);
    }
#line 2833
    return;
  }
#line 2835
  i = 0U;
  {
#line 2835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2835
    if (! (i < nargs)) {
#line 2835
      goto while_break;
    }
#line 2836
    rendset = (short)-1;
    {
#line 2838
    if (*(arg + i) == 0) {
#line 2838
      goto case_0;
    }
#line 2841
    if (*(arg + i) == 1) {
#line 2841
      goto case_1;
    }
#line 2844
    if (*(arg + i) == 4) {
#line 2844
      goto case_4;
    }
#line 2847
    if (*(arg + i) == 5) {
#line 2847
      goto case_5;
    }
#line 2850
    if (*(arg + i) == 7) {
#line 2850
      goto case_7;
    }
#line 2853
    if (*(arg + i) == 22) {
#line 2853
      goto case_22;
    }
#line 2856
    if (*(arg + i) == 24) {
#line 2856
      goto case_24;
    }
#line 2859
    if (*(arg + i) == 25) {
#line 2859
      goto case_25;
    }
#line 2862
    if (*(arg + i) == 27) {
#line 2862
      goto case_27;
    }
#line 2837
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2839
    rendset = (short)0;
#line 2839
    rendstyle = ~ 0;
#line 2840
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2842
    rendset = (short)1;
#line 2842
    rendstyle = 1024;
#line 2843
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2845
    rendset = (short)1;
#line 2845
    rendstyle = 8192;
#line 2846
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2848
    rendset = (short)1;
#line 2848
    rendstyle = 2048;
#line 2849
    goto switch_break;
    case_7: /* CIL Label */ 
#line 2851
    rendset = (short)1;
#line 2851
    rendstyle = 4096;
#line 2852
    goto switch_break;
    case_22: /* CIL Label */ 
#line 2854
    rendset = (short)0;
#line 2854
    rendstyle = 1024;
#line 2855
    goto switch_break;
    case_24: /* CIL Label */ 
#line 2857
    rendset = (short)0;
#line 2857
    rendstyle = 8192;
#line 2858
    goto switch_break;
    case_25: /* CIL Label */ 
#line 2860
    rendset = (short)0;
#line 2860
    rendstyle = 2048;
#line 2861
    goto switch_break;
    case_27: /* CIL Label */ 
#line 2863
    rendset = (short)0;
#line 2863
    rendstyle = 4096;
#line 2864
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2866
    if ((int )rendset != -1) {
      {
#line 2867
      rxvt_scr_rendition(r, (int )rendset, rendstyle);
      }
#line 2868
      goto __Cont;
    }
    {
#line 2879
    if (*(arg + i) == 37) {
#line 2879
      goto case_37;
    }
#line 2879
    if (*(arg + i) == 36) {
#line 2879
      goto case_37;
    }
#line 2879
    if (*(arg + i) == 35) {
#line 2879
      goto case_37;
    }
#line 2879
    if (*(arg + i) == 34) {
#line 2879
      goto case_37;
    }
#line 2879
    if (*(arg + i) == 33) {
#line 2879
      goto case_37;
    }
#line 2879
    if (*(arg + i) == 32) {
#line 2879
      goto case_37;
    }
#line 2879
    if (*(arg + i) == 31) {
#line 2879
      goto case_37;
    }
#line 2879
    if (*(arg + i) == 30) {
#line 2879
      goto case_37;
    }
#line 2892
    if (*(arg + i) == 39) {
#line 2892
      goto case_39;
    }
#line 2903
    if (*(arg + i) == 47) {
#line 2903
      goto case_47;
    }
#line 2903
    if (*(arg + i) == 46) {
#line 2903
      goto case_47;
    }
#line 2903
    if (*(arg + i) == 45) {
#line 2903
      goto case_47;
    }
#line 2903
    if (*(arg + i) == 44) {
#line 2903
      goto case_47;
    }
#line 2903
    if (*(arg + i) == 43) {
#line 2903
      goto case_47;
    }
#line 2903
    if (*(arg + i) == 42) {
#line 2903
      goto case_47;
    }
#line 2903
    if (*(arg + i) == 41) {
#line 2903
      goto case_47;
    }
#line 2903
    if (*(arg + i) == 40) {
#line 2903
      goto case_47;
    }
#line 2916
    if (*(arg + i) == 49) {
#line 2916
      goto case_49;
    }
#line 2928
    if (*(arg + i) == 97) {
#line 2928
      goto case_97;
    }
#line 2928
    if (*(arg + i) == 96) {
#line 2928
      goto case_97;
    }
#line 2928
    if (*(arg + i) == 95) {
#line 2928
      goto case_97;
    }
#line 2928
    if (*(arg + i) == 94) {
#line 2928
      goto case_97;
    }
#line 2928
    if (*(arg + i) == 93) {
#line 2928
      goto case_97;
    }
#line 2928
    if (*(arg + i) == 92) {
#line 2928
      goto case_97;
    }
#line 2928
    if (*(arg + i) == 91) {
#line 2928
      goto case_97;
    }
#line 2928
    if (*(arg + i) == 90) {
#line 2928
      goto case_97;
    }
#line 2939
    if (*(arg + i) == 107) {
#line 2939
      goto case_107;
    }
#line 2939
    if (*(arg + i) == 106) {
#line 2939
      goto case_107;
    }
#line 2939
    if (*(arg + i) == 105) {
#line 2939
      goto case_107;
    }
#line 2939
    if (*(arg + i) == 104) {
#line 2939
      goto case_107;
    }
#line 2939
    if (*(arg + i) == 103) {
#line 2939
      goto case_107;
    }
#line 2939
    if (*(arg + i) == 102) {
#line 2939
      goto case_107;
    }
#line 2939
    if (*(arg + i) == 101) {
#line 2939
      goto case_107;
    }
#line 2939
    if (*(arg + i) == 100) {
#line 2939
      goto case_107;
    }
#line 2871
    goto switch_break___0;
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_30: /* CIL Label */ 
    {
#line 2880
    rxvt_scr_color(r, (unsigned int )(2 + (int )(*(arg + i) - 30)), 0);
    }
#line 2882
    goto switch_break___0;
    case_39: /* CIL Label */ 
    {
#line 2893
    rxvt_scr_color(r, 0U, 0);
    }
#line 2894
    goto switch_break___0;
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    {
#line 2904
    rxvt_scr_color(r, (unsigned int )(2 + (int )(*(arg + i) - 40)), 1);
    }
#line 2906
    goto switch_break___0;
    case_49: /* CIL Label */ 
    {
#line 2917
    rxvt_scr_color(r, 1U, 1);
    }
#line 2918
    goto switch_break___0;
    case_97: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_90: /* CIL Label */ 
    {
#line 2929
    rxvt_scr_color(r, (unsigned int )(10 + (int )(*(arg + i) - 90)), 0);
    }
#line 2931
    goto switch_break___0;
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    {
#line 2940
    rxvt_scr_color(r, (unsigned int )(10 + (int )(*(arg + i) - 100)), 1);
    }
#line 2942
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2835
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2946
  return;
}
}
#line 2951 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_process_graphics(rxvt_t *r ) 
{ 
  unsigned char ch ;
  unsigned char cmd ;
  unsigned char tmp ;

  {
  {
#line 2954
  tmp = rxvt_cmd_getc(r);
#line 2954
  cmd = tmp;
  }
#line 2957
  if ((int )cmd == 81) {
    {
#line 2958
    rxvt_tt_printf(r, "\033G0\n");
    }
#line 2959
    return;
  }
  {
#line 2962
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2963
    ch = rxvt_cmd_getc(r);
    }
#line 2962
    if (! ((int )ch != 58)) {
#line 2962
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3006
  return;
}
}
#line 3013 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_main_loop(rxvt_t *r ) 
{ 
  unsigned char ch ;
  unsigned char *str ;
  int nlines ;
  int refreshnow ;
  struct rxvt_hidden *h ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 3018
  h = r->h;
#line 3020
  tmp = h->cmdbuf_base;
#line 3020
  h->cmdbuf_endp = tmp;
#line 3020
  h->cmdbuf_ptr = tmp;
#line 3029
  refreshnow = 0;
  {
#line 3030
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3031
    ch = rxvt_cmd_getc(r);
    }
#line 3033
    if ((int )ch >= 32) {
#line 3033
      goto _L;
    } else
#line 3033
    if ((int )ch == 9) {
#line 3033
      goto _L;
    } else
#line 3033
    if ((int )ch == 10) {
#line 3033
      goto _L;
    } else
#line 3033
    if ((int )ch == 13) {
      _L: /* CIL Label */ 
#line 3039
      (h->cmdbuf_ptr) --;
#line 3039
      str = h->cmdbuf_ptr;
#line 3039
      nlines = 0;
      {
#line 3039
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3039
        if (! ((unsigned long )h->cmdbuf_ptr < (unsigned long )h->cmdbuf_endp)) {
#line 3039
          goto while_break___0;
        }
#line 3041
        tmp___0 = h->cmdbuf_ptr;
#line 3041
        (h->cmdbuf_ptr) ++;
#line 3041
        ch = *tmp___0;
#line 3042
        if ((int )ch == 10) {
#line 3043
          nlines ++;
#line 3044
          (h->refresh_count) ++;
#line 3045
          if (! (r->Options & (1UL << 18))) {
#line 3048
            refreshnow = 1;
#line 3049
            goto while_break___0;
          } else
#line 3045
          if (h->refresh_count >= h->refresh_limit * ((int )r->TermWin.nrow - 1)) {
#line 3048
            refreshnow = 1;
#line 3049
            goto while_break___0;
          }
        } else
#line 3051
        if ((int )ch < 32) {
#line 3051
          if ((int )ch != 9) {
#line 3051
            if ((int )ch != 13) {
#line 3053
              (h->cmdbuf_ptr) --;
#line 3054
              goto while_break___0;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3057
      rxvt_scr_add_lines(r, (unsigned char const   *)str, nlines, (int )(h->cmdbuf_ptr - str));
      }
#line 3067
      if (refreshnow) {
#line 3068
        refreshnow = 0;
#line 3069
        if (r->Options & (1UL << 18)) {
#line 3069
          if (h->refresh_limit < 1) {
#line 3071
            (h->refresh_limit) ++;
          }
        }
        {
#line 3072
        rxvt_scr_refresh(r, h->refresh_type);
        }
      }
    } else {
      {
#line 3079
      if ((int )ch == 27) {
#line 3079
        goto case_27;
      }
#line 3076
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 3077
      rxvt_process_nonprinting(r, ch);
      }
#line 3078
      goto switch_break;
      case_27: /* CIL Label */ 
      {
#line 3080
      rxvt_process_escape_seq(r);
      }
#line 3081
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 3094 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_tt_printf(rxvt_t *r , char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  unsigned char buf[256] ;
  size_t tmp ;

  {
  {
#line 3100
  __builtin_va_start(arg_ptr, fmt);
#line 3101
  vsnprintf((char */* __restrict  */)((char *)(buf)), sizeof(buf), (char const   */* __restrict  */)fmt,
            arg_ptr);
#line 3102
  __builtin_va_end(arg_ptr);
#line 3103
  tmp = strlen((char const   *)(buf));
#line 3103
  rxvt_tt_write(r, (unsigned char const   *)(buf), (unsigned int )tmp);
  }
#line 3104
  return;
}
}
#line 3114 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/command.c"
void rxvt_tt_write(rxvt_t *r , unsigned char const   *d , unsigned int len ) 
{ 
  int riten ;
  unsigned int p ;
  unsigned char *v_buffer ;
  unsigned char *v_bufstr ;
  unsigned char *v_bufptr ;
  unsigned char *v_bufend ;
  void *tmp ;
  unsigned int size ;
  unsigned int reallocto ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  ssize_t tmp___2 ;
  unsigned int start ;
  unsigned int size___0 ;
  unsigned int reallocto___0 ;
  void *tmp___3 ;

  {
#line 3125
  if ((unsigned long )(r->h)->v_bufstr == (unsigned long )((void *)0)) {
#line 3125
    if (len > 0U) {
      {
#line 3126
      p = (len / 128U + 1U) * 128U;
#line 3127
      tmp = rxvt_malloc((size_t )p);
#line 3127
      v_bufptr = (unsigned char *)tmp;
#line 3127
      v_bufstr = v_bufptr;
#line 3127
      v_buffer = v_bufstr;
#line 3128
      v_bufend = v_buffer + p;
      }
    } else {
#line 3130
      v_buffer = (r->h)->v_buffer;
#line 3131
      v_bufstr = (r->h)->v_bufstr;
#line 3132
      v_bufptr = (r->h)->v_bufptr;
#line 3133
      v_bufend = (r->h)->v_bufend;
    }
  } else {
#line 3130
    v_buffer = (r->h)->v_buffer;
#line 3131
    v_bufstr = (r->h)->v_bufstr;
#line 3132
    v_bufptr = (r->h)->v_bufptr;
#line 3133
    v_bufend = (r->h)->v_bufend;
  }
#line 3142
  if (len > 0U) {
#line 3143
    if ((unsigned long )v_bufend < (unsigned long )(v_bufptr + len)) {
#line 3144
      if ((unsigned long )v_bufstr != (unsigned long )v_buffer) {
        {
#line 3146
        memmove((void *)v_buffer, (void const   *)v_bufstr, (size_t )((unsigned int )(v_bufptr - v_bufstr)));
#line 3148
        v_bufptr -= v_bufstr - v_buffer;
#line 3149
        v_bufstr = v_buffer;
        }
      }
#line 3151
      if ((unsigned long )v_bufend < (unsigned long )(v_bufptr + len)) {
        {
#line 3154
        size = (unsigned int )(v_bufptr - v_buffer);
#line 3157
        reallocto = ((size + len) / 128U + 1U) * 128U;
#line 3158
        tmp___0 = realloc((void *)v_buffer, (size_t )reallocto);
#line 3158
        v_buffer = (unsigned char *)tmp___0;
        }
#line 3160
        if (v_buffer) {
#line 3161
          v_bufstr = v_buffer;
#line 3162
          v_bufptr = v_buffer + size;
#line 3163
          v_bufend = v_buffer + reallocto;
        } else {
          {
#line 3165
          rxvt_print_error("data loss: cannot allocate buffer space");
#line 3166
          v_buffer = v_bufstr;
          }
        }
      }
    }
#line 3170
    if ((unsigned long )v_bufend >= (unsigned long )(v_bufptr + len)) {
      {
#line 3171
      memcpy((void */* __restrict  */)((void *)v_bufptr), (void const   */* __restrict  */)((void const   *)d),
             (size_t )len);
#line 3172
      v_bufptr += len;
      }
    }
  }
#line 3189
  p = (unsigned int )(v_bufptr - v_bufstr);
#line 3189
  if (p > 0U) {
#line 3190
    if (p < 128U) {
#line 3190
      tmp___1 = p;
    } else {
#line 3190
      tmp___1 = 128U;
    }
    {
#line 3190
    tmp___2 = write(r->cmd_fd, (void const   *)v_bufstr, (size_t )tmp___1);
#line 3190
    riten = (int )tmp___2;
    }
#line 3191
    if (riten < 0) {
#line 3192
      riten = 0;
    }
#line 3193
    v_bufstr += riten;
#line 3194
    if ((unsigned long )v_bufstr >= (unsigned long )v_bufptr) {
#line 3195
      v_bufptr = v_buffer;
#line 3195
      v_bufstr = v_bufptr;
    }
  }
#line 3200
  if (v_bufend - v_bufptr > 1024L) {
    {
#line 3202
    start = (unsigned int )(v_bufstr - v_buffer);
#line 3203
    size___0 = (unsigned int )(v_bufptr - v_buffer);
#line 3206
    reallocto___0 = (size___0 / 128U + 1U) * 128U;
#line 3207
    tmp___3 = realloc((void *)v_buffer, (size_t )reallocto___0);
#line 3207
    v_buffer = (unsigned char *)tmp___3;
    }
#line 3208
    if (v_buffer) {
#line 3209
      v_bufstr = v_buffer + start;
#line 3210
      v_bufptr = v_buffer + size___0;
#line 3211
      v_bufend = v_buffer + reallocto___0;
    } else {
#line 3214
      v_buffer = v_bufstr - start;
    }
  }
#line 3217
  (r->h)->v_buffer = v_buffer;
#line 3218
  (r->h)->v_bufstr = v_bufstr;
#line 3219
  (r->h)->v_bufptr = v_bufptr;
#line 3220
  (r->h)->v_bufend = v_bufend;
#line 3221
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 1722 "/usr/include/X11/Xlib.h"
extern KeySym XStringToKeysym(char const   * ) ;
#line 100 "/usr/include/X11/Xresource.h"
extern XrmString XrmQuarkToString(XrmQuark  ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.extpro"
void rxvt_usage(int type ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.intpro"
int rxvt_define_key(XrmDatabase *database , XrmBindingList bindings , XrmQuarkList quarks ,
                    XrmRepresentation *type , XrmValue *value , XPointer closure ) ;
#line 2
int rxvt_parse_keysym(rxvt_t *r , char const   *str , char const   *arg ) ;
#line 3
void rxvt_get_xdefaults(rxvt_t *r , FILE *stream , char const   *name ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
static char const   * const  xnames[2]  = {      (char const   */* const  */)".Xdefaults",      (char const   */* const  */)".Xresources"};
#line 76 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
static struct __anonstruct_optList_178  const  optList[68]  = 
#line 76
  {      {(unsigned long const   )0, (int const   )0, (char const   *)((void *)0), "d",
      (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )0, (char const   *)((void *)0), "display",
      "string", "X server to contact"}, 
        {(unsigned long const   )0, (int const   )1, "termName", "tn", "string", "value of the TERM environment variable"}, 
        {(unsigned long const   )0,
      (int const   )3, (char const   *)((void *)0), "g", (char const   *)((void *)0),
      (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )3, "geometry", "geometry", "geometry",
      "size (in characters) and position"}, 
        {(unsigned long const   )1UL, (int const   )-1, (char const   *)((void *)0),
      "C", (char const   *)((void *)0), "intercept console messages"}, 
        {(unsigned long const   )(1UL << 2), (int const   )-1, (char const   *)((void *)0),
      "iconic", (char const   *)((void *)0), "start iconic"}, 
        {(unsigned long const   )(1UL << 2), (int const   )-1, (char const   *)((void *)0),
      "ic", (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 5)), (int const   )4, "reverseVideo",
      "rv", (char const   *)((void *)0), "reverse video"}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 1)), (int const   )40, "loginShell",
      "ls", (char const   *)((void *)0), "login shell"}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 18)), (int const   )41, "jumpScroll",
      "j", (char const   *)((void *)0), "jump scrolling"}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 11)), (int const   )43, "scrollTtyOutput",
      (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(unsigned long const   )((1UL << 31) | ((1UL << 30) | (1UL << 11))),
      (int const   )43, (char const   *)((void *)0), "si", (char const   *)((void *)0),
      "scroll-on-tty-output inhibit"}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 12)), (int const   )44, "scrollTtyKeypress",
      "sk", (char const   *)((void *)0), "scroll-on-keypress"}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 17)), (int const   )45, "scrollWithBuffer",
      "sw", (char const   *)((void *)0), "scroll-with-buffer"}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 6)), (int const   )47, "utmpInhibit",
      "ut", (char const   *)((void *)0), "utmp inhibit"}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 3)), (int const   )48, "visualBell",
      "vb", (char const   *)((void *)0), "visual bell"}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 4)), (int const   )49, "mapAlert",
      (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(unsigned long const   )((1UL << 31) | (1UL << 10)),
      (int const   )50, "meta8", (char const   *)((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )6, "background", "bg", "color", "background color"}, 
        {(unsigned long const   )0,
      (int const   )5, "foreground", "fg", "color", "foreground color"}, 
        {(unsigned long const   )0, (int const   )7, "color0", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )8, "color1", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )9, "color2", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )10, "color3", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )11, "color4", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )12, "color5", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )13, "color6", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )14, "color7", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )15, "color8", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )16, "color9", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )17, "color10", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )18, "color11", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )19, "color12", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )20, "color13", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )21, "color14", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )22, "color15", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )27, "colorBD", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )28, "colorUL", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )29, "colorRV", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )39, "boldFont", "fb", "fontname", "bold text font"}, 
        {(unsigned long const   )0,
      (int const   )30, "font", "fn", "fontname", "normal text font"}, 
        {(unsigned long const   )0, (int const   )31, "font1", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )32, "font2", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )33, "font3", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )34, "font4", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )35, "font5", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )36, "font6", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )37, (char const   *)((void *)0), "name",
      "string", "client instance, icon, and title strings"}, 
        {(unsigned long const   )0, (int const   )38, "title", "title", "string", "title name for window"}, 
        {(unsigned long const   )0,
      (int const   )38, (char const   *)((void *)0), "T", (char const   *)((void *)0),
      (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )2, "iconName", "n", "string", "icon name for window"}, 
        {(unsigned long const   )0,
      (int const   )23, "cursorColor", "cr", "color", "cursor color"}, 
        {(unsigned long const   )0, (int const   )24, "cursorColor2", (char const   *)((void *)0),
      "color", (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )25, "pointerColor", "pr", "color",
      "pointer color"}, 
        {(unsigned long const   )0, (int const   )26, "borderColor", "bd", "color", "border color"}, 
        {(unsigned long const   )0,
      (int const   )46, "saveLines", "sl", "number", "number of scrolled lines to save"}, 
        {(unsigned long const   )0,
      (int const   )55, "thickness", "sbt", "number", "scrollbar thickness/width in pixels"}, 
        {(unsigned long const   )0,
      (int const   )51, "backspacekey", (char const   *)((void *)0), "string", (char const   *)((void *)0)}, 
        {(unsigned long const   )0,
      (int const   )52, "deletekey", (char const   *)((void *)0), "string", (char const   *)((void *)0)}, 
        {(unsigned long const   )0,
      (int const   )53, "selectstyle", (char const   *)((void *)0), "mode", (char const   *)((void *)0)}, 
        {(unsigned long const   )0,
      (int const   )42, "scrollstyle", (char const   *)((void *)0), "mode", (char const   *)((void *)0)}, 
        {(unsigned long const   )0,
      (int const   )54, "print-pipe", (char const   *)((void *)0), "string", (char const   *)((void *)0)}, 
        {(unsigned long const   )0,
      (int const   )57, "modifier", "mod", "modifier", "meta modifier = alt|meta|hyper|super|mod1|...|mod5"}, 
        {(unsigned long const   )0,
      (int const   )-1, (char const   *)((void *)0), "xrm", "string", "X resource"}, 
        {(unsigned long const   )0,
      (int const   )56, "cutchars", (char const   *)((void *)0), "string", (char const   *)((void *)0)}, 
        {(unsigned long const   )0,
      (int const   )58, "answerbackString", (char const   *)((void *)0), "string",
      (char const   *)((void *)0)}, 
        {(unsigned long const   )0, (int const   )-1, (char const   *)((void *)0), "e",
      "command arg ...", "command to execute"}};
#line 314 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
static char const   releasestring[40]  = 
#line 314
  {      (char const   )'R',      (char const   )'x',      (char const   )'v',      (char const   )'t', 
        (char const   )' ',      (char const   )'v',      (char const   )'2',      (char const   )'.', 
        (char const   )'7',      (char const   )'.',      (char const   )'1',      (char const   )'0', 
        (char const   )' ',      (char const   )'-',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'l',      (char const   )'e',      (char const   )'a', 
        (char const   )'s',      (char const   )'e',      (char const   )'d',      (char const   )':', 
        (char const   )' ',      (char const   )'2',      (char const   )'6',      (char const   )' ', 
        (char const   )'M',      (char const   )'A',      (char const   )'R',      (char const   )'C', 
        (char const   )'H',      (char const   )' ',      (char const   )'2',      (char const   )'0', 
        (char const   )'0',      (char const   )'3',      (char const   )'\n',      (char const   )'\000'};
#line 315 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
static char const   optionsstring[44]  = 
#line 315
  {      (char const   )'O',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'c',      (char const   )'r', 
        (char const   )'o',      (char const   )'l',      (char const   )'l',      (char const   )'b', 
        (char const   )'a',      (char const   )'r',      (char const   )'s',      (char const   )'=', 
        (char const   )'N',      (char const   )'O',      (char const   )'N',      (char const   )'E', 
        (char const   )',',      (char const   )'.',      (char const   )'X',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'s',      (char const   )'\n', 
        (char const   )'U',      (char const   )'s',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'\000'};
#line 398 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
void rxvt_usage(int type ) 
{ 
  unsigned int i ;
  unsigned int col ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 403
  write(2, (void const   *)(releasestring), sizeof(releasestring) - 1UL);
#line 404
  write(2, (void const   *)(optionsstring), sizeof(optionsstring) - 1UL);
#line 405
  write(2, (void const   *)"rxvt", sizeof("rxvt") - 1UL);
  }
  {
#line 408
  if (type == 0) {
#line 408
    goto case_0;
  }
#line 437
  if (type == 1) {
#line 437
    goto case_1;
  }
#line 456
  if (type == 2) {
#line 456
    goto case_2;
  }
#line 407
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 409
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [-help] [--help]\n");
#line 410
  col = 1U;
#line 410
  i = 0U;
  }
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 410
      goto while_break;
    }
#line 411
    if ((unsigned long )optList[i].desc != (unsigned long )((void *)0)) {
#line 412
      len = 0;
#line 414
      if (! (optList[i].flag & (unsigned long const   )(1UL << 31))) {
#line 415
        if (optList[i].flag) {
#line 415
          len = 0;
        } else {
#line 415
          if (optList[i].arg) {
            {
#line 415
            tmp = strlen((char const   *)optList[i].arg);
#line 415
            tmp___0 = tmp;
            }
          } else {
#line 415
            tmp___0 = (size_t )1;
          }
#line 415
          len = (int )tmp___0;
        }
#line 416
        if (len > 0) {
#line 417
          len ++;
        }
      }
#line 420
      if (! ((unsigned long )optList[i].opt != (unsigned long )((void *)0))) {
        {
#line 420
        __assert_fail("optList[i].opt != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c",
                      420U, "rxvt_usage");
        }
      }
      {
#line 422
      tmp___1 = strlen((char const   *)optList[i].opt);
      }
#line 422
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 422
        tmp___2 = 2;
      } else {
#line 422
        tmp___2 = 0;
      }
#line 422
      len = (int )((size_t )len + ((4UL + tmp___1) + (size_t )tmp___2));
#line 423
      col += (unsigned int )len;
#line 424
      if (col > 79U) {
        {
#line 425
        _IO_putc('\n', stderr);
#line 426
        col = (unsigned int )(1 + len);
        }
      }
#line 428
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 428
        tmp___3 = "/+";
      } else {
#line 428
        tmp___3 = "";
      }
      {
#line 428
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [-%s%s",
              tmp___3, optList[i].opt);
      }
#line 430
      if (optList[i].flag) {
#line 430
        tmp___6 = (size_t )0;
      } else {
#line 430
        if (optList[i].arg) {
          {
#line 430
          tmp___4 = strlen((char const   *)optList[i].arg);
#line 430
          tmp___5 = tmp___4;
          }
        } else {
#line 430
          tmp___5 = (size_t )1;
        }
#line 430
        tmp___6 = tmp___5;
      }
#line 430
      if (tmp___6) {
        {
#line 431
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s]",
                optList[i].arg);
        }
      } else {
        {
#line 433
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"]");
        }
      }
    }
#line 410
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 438
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [options] [-e command args]\n\nwhere options include:\n");
#line 440
  i = 0U;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 440
      goto while_break___0;
    }
#line 441
    if ((unsigned long )optList[i].desc != (unsigned long )((void *)0)) {
#line 443
      if (! ((unsigned long )optList[i].opt != (unsigned long )((void *)0))) {
        {
#line 443
        __assert_fail("optList[i].opt != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c",
                      443U, "rxvt_usage");
        }
      }
#line 445
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 445
        tmp___7 = "turn on/off ";
      } else {
#line 445
        tmp___7 = "";
      }
#line 445
      if (optList[i].arg) {
#line 445
        tmp___8 = optList[i].arg;
      } else {
#line 445
        tmp___8 = (char const   */* const  */)"";
      }
      {
#line 445
      tmp___9 = strlen((char const   *)optList[i].opt);
      }
#line 445
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 445
        tmp___10 = 0;
      } else {
#line 445
        tmp___10 = 2;
      }
#line 445
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 445
        tmp___11 = "-/+";
      } else {
#line 445
        tmp___11 = "-";
      }
      {
#line 445
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s%s %-*s%s%s\n",
              tmp___11, optList[i].opt, (18UL - tmp___9) + (size_t )tmp___10, tmp___8,
              tmp___7, optList[i].desc);
      }
    }
#line 440
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 453
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  --help to list long-options");
  }
#line 454
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 457
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" [options] [-e command args]\n\nwhere resources (long-options) include:\n");
#line 461
  i = 0U;
  }
  {
#line 461
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 461
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 461
      goto while_break___1;
    }
#line 462
    if ((unsigned long )optList[i].kw != (unsigned long )((void *)0)) {
#line 463
      if (optList[i].flag & (unsigned long const   )(1UL << 31)) {
#line 463
        tmp___12 = (char const   */* const  */)"boolean";
      } else {
#line 463
        tmp___12 = optList[i].arg;
      }
      {
#line 463
      tmp___13 = strlen((char const   *)optList[i].kw);
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: %*s%s\n",
              optList[i].kw, 18UL - tmp___13, "", tmp___12);
      }
    }
#line 461
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 468
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  keysym.sym: %*s%s\n",
          (18UL - sizeof("keysym.sym")) + 1UL, "", "keysym");
#line 472
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  -help to list options");
  }
#line 473
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 475
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
#line 476
  exit(1);
  }
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
static char const   On[3]  = {      (char const   )'O',      (char const   )'N',      (char const   )'\000'};
#line 488 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
static char const   Off[4]  = {      (char const   )'O',      (char const   )'F',      (char const   )'F',      (char const   )'\000'};
#line 484 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
void rxvt_get_options(rxvt_t *r , int argc , char const   * const  *argv ) 
{ 
  int i ;
  int bad_option ;
  unsigned int entry ;
  unsigned int longopt ;
  char const   *flag ;
  char const   *opt ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *str ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char const   *str___0 ;
  char const   *msg ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 487
  bad_option = 0;
#line 490
  i = 1;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < argc)) {
#line 490
      goto while_break;
    }
#line 491
    longopt = 0U;
#line 494
    opt = (char const   *)*(argv + i);
#line 498
    if ((int const   )*opt == 45) {
#line 499
      flag = On;
#line 500
      opt ++;
#line 500
      if ((int const   )*opt == 45) {
#line 501
        tmp = opt;
#line 501
        opt ++;
#line 501
        longopt = (unsigned int )*tmp;
      }
    } else
#line 502
    if ((int const   )*opt == 43) {
#line 503
      flag = Off;
#line 504
      opt ++;
#line 504
      if ((int const   )*opt == 43) {
#line 505
        tmp___0 = opt;
#line 505
        opt ++;
#line 505
        longopt = (unsigned int )*tmp___0;
      }
    } else {
      {
#line 507
      bad_option = 1;
#line 508
      rxvt_print_error("bad option \"%s\"", opt);
      }
#line 509
      goto __Cont;
    }
    {
#line 512
    tmp___2 = strcmp(opt, "help");
    }
#line 512
    if (! tmp___2) {
#line 513
      if (longopt) {
#line 513
        tmp___1 = 2;
      } else {
#line 513
        tmp___1 = 1;
      }
      {
#line 513
      rxvt_usage(tmp___1);
      }
    }
    {
#line 514
    tmp___3 = strcmp(opt, "h");
    }
#line 514
    if (! tmp___3) {
      {
#line 515
      rxvt_usage(0);
      }
    }
#line 518
    entry = 0U;
    {
#line 518
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 518
      if (! ((unsigned long )entry < sizeof(optList) / sizeof(optList[0]))) {
#line 518
        goto while_break___0;
      }
#line 519
      if (optList[entry].kw) {
        {
#line 519
        tmp___4 = strcmp(opt, (char const   *)optList[entry].kw);
        }
#line 519
        if (tmp___4) {
#line 519
          goto _L;
        } else {
#line 522
          goto while_break___0;
        }
      } else
      _L: /* CIL Label */ 
#line 519
      if (! longopt) {
#line 519
        if (optList[entry].opt) {
          {
#line 519
          tmp___5 = strcmp(opt, (char const   *)optList[entry].opt);
          }
#line 519
          if (! tmp___5) {
#line 522
            goto while_break___0;
          }
        }
      }
#line 518
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 524
    if ((unsigned long )entry < sizeof(optList) / sizeof(optList[0])) {
#line 525
      if (optList[entry].flag & (unsigned long const   )(1UL << 30)) {
#line 526
        if ((unsigned long )flag == (unsigned long )(On)) {
#line 526
          flag = Off;
        } else {
#line 526
          flag = On;
        }
      }
#line 527
      if (optList[entry].flag) {
#line 527
        tmp___8 = (size_t )0;
      } else {
#line 527
        if (optList[entry].arg) {
          {
#line 527
          tmp___6 = strlen((char const   *)optList[entry].arg);
#line 527
          tmp___7 = tmp___6;
          }
        } else {
#line 527
          tmp___7 = (size_t )1;
        }
#line 527
        tmp___8 = tmp___7;
      }
#line 527
      if (tmp___8) {
#line 528
        i ++;
#line 528
        str = (char const   *)*(argv + i);
#line 535
        if ((unsigned long )flag == (unsigned long )(On)) {
#line 535
          if (str) {
#line 535
            if (optList[entry].doff != -1) {
#line 539
              (r->h)->rs[optList[entry].doff] = str;
            }
          }
        }
      } else {
#line 555
        if ((unsigned long )flag == (unsigned long )(On)) {
#line 556
          r->Options |= (unsigned long )optList[entry].flag;
        } else {
#line 558
          r->Options &= (unsigned long )(~ optList[entry].flag);
        }
#line 560
        if (optList[entry].doff != -1) {
#line 561
          (r->h)->rs[optList[entry].doff] = flag;
        }
      }
    } else {
      {
#line 566
      tmp___11 = rxvt_Str_match(opt, "keysym.");
      }
#line 566
      if (tmp___11) {
#line 567
        i ++;
#line 567
        str___0 = (char const   *)*(argv + i);
#line 569
        if ((unsigned long )str___0 != (unsigned long )((void *)0)) {
          {
#line 570
          rxvt_parse_keysym(r, (opt + sizeof("keysym.")) - 1, str___0);
          }
        }
      } else {
#line 579
        msg = "bad";
#line 581
        if (longopt) {
#line 582
          opt --;
#line 583
          bad_option = 1;
        } else {
          {
#line 584
          tmp___9 = strcmp(opt, "7");
          }
#line 584
          if (tmp___9) {
            {
#line 584
            tmp___10 = strcmp(opt, "8");
            }
#line 584
            if (tmp___10) {
#line 592
              bad_option = 1;
            } else {
#line 590
              msg = "obsolete";
            }
          } else {
#line 590
            msg = "obsolete";
          }
        }
        {
#line 594
        opt --;
#line 594
        rxvt_print_error("%s option \"%s\"", msg, opt);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 598
  if (bad_option) {
    {
#line 599
    rxvt_usage(0);
    }
  }
#line 600
  return;
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
int rxvt_define_key(XrmDatabase *database , XrmBindingList bindings , XrmQuarkList quarks ,
                    XrmRepresentation *type , XrmValue *value , XPointer closure ) 
{ 
  int last ;
  rxvt_t *r ;
  rxvt_t *tmp ;
  XrmString tmp___0 ;

  {
  {
#line 620
  tmp = rxvt_get_r();
#line 620
  r = tmp;
#line 622
  last = 0;
  }
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (*(quarks + last) != 0)) {
#line 622
      goto while_break;
    }
#line 622
    last ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 624
  last --;
#line 625
  tmp___0 = XrmQuarkToString(*(quarks + last));
#line 625
  rxvt_parse_keysym(r, (char const   *)tmp___0, (char const   *)value->addr);
  }
#line 626
  return (0);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
int rxvt_parse_keysym(rxvt_t *r , char const   *str , char const   *arg ) 
{ 
  int n ;
  int sym ;
  char *key_string ;
  char *newarg ;
  char newargstr[500] ;
  int tmp ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  KeySym tmp___7 ;
  unsigned short const   **tmp___8 ;
  void *tmp___9 ;

  {
#line 643
  newarg = (char *)((void *)0);
#line 646
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 647
    n = rxvt_Str_match(str, "keysym.");
    }
#line 647
    if (n == 0) {
#line 648
      return (0);
    }
#line 649
    str += n;
  }
  {
#line 652
  tmp___8 = __ctype_b_loc();
  }
#line 652
  if ((int const   )*(*tmp___8 + (int )*(str + 0)) & 2048) {
#line 653
    if ((int const   )*(str + 0) == 48) {
      {
#line 653
      tmp = toupper((int )*(str + 1));
      }
#line 653
      if (tmp == 88) {
#line 654
        str += 2;
      }
    }
#line 655
    if (arg) {
      {
#line 656
      tmp___2 = strchr(str, ':');
      }
#line 656
      if (tmp___2) {
#line 656
        tmp___1 = "%x:";
      } else {
#line 656
        tmp___1 = "%x";
      }
      {
#line 656
      tmp___3 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)tmp___1,
                       & sym);
      }
#line 656
      if (tmp___3 != 1) {
#line 657
        return (-1);
      }
    } else {
      {
#line 659
      tmp___4 = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%x:",
                       & sym);
      }
#line 659
      if (tmp___4 != 1) {
#line 660
        return (-1);
      }
      {
#line 663
      tmp___5 = strchr(str, ':');
#line 663
      strncpy((char */* __restrict  */)(newargstr), (char const   */* __restrict  */)((char const   *)(tmp___5 + 1)),
              (size_t )499);
#line 664
      newargstr[499] = (char )'\000';
#line 665
      newarg = newargstr;
      }
    }
  } else {
    {
#line 671
    strncpy((char */* __restrict  */)(newargstr), (char const   */* __restrict  */)str,
            (size_t )499);
#line 672
    newargstr[499] = (char )'\000';
    }
#line 673
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
#line 674
      newarg = strchr((char const   *)(newargstr), ':');
      }
#line 674
      if ((unsigned long )newarg == (unsigned long )((void *)0)) {
#line 675
        return (-1);
      }
#line 676
      tmp___6 = newarg;
#line 676
      newarg ++;
#line 676
      *tmp___6 = (char )'\000';
    }
    {
#line 678
    tmp___7 = XStringToKeysym((char const   *)(newargstr));
#line 678
    sym = (int )tmp___7;
    }
#line 678
    if ((long )sym == 0L) {
#line 679
      return (-1);
    }
  }
#line 682
  if (sym < 65280) {
#line 683
    return (-1);
  } else
#line 682
  if (sym > 65535) {
#line 683
    return (-1);
  }
#line 684
  sym &= 255;
#line 685
  if ((unsigned long )(r->h)->Keysym_map[sym] != (unsigned long )((void *)0)) {
#line 686
    return (-1);
  }
#line 688
  if ((unsigned long )newarg == (unsigned long )((void *)0)) {
    {
#line 689
    strncpy((char */* __restrict  */)(newargstr), (char const   */* __restrict  */)arg,
            (size_t )499);
#line 690
    newargstr[499] = (char )'\000';
#line 691
    newarg = newargstr;
    }
  }
  {
#line 693
  rxvt_Str_trim(newarg);
  }
#line 694
  if ((int )*newarg == 0) {
#line 695
    return (-1);
  } else {
    {
#line 694
    n = rxvt_Str_escaped(newarg);
    }
#line 694
    if (n == 0) {
#line 695
      return (-1);
    }
  }
#line 696
  if (255 < n) {
#line 696
    n = 255;
  }
  {
#line 697
  tmp___9 = rxvt_malloc((unsigned long )(n + 1) * sizeof(char ));
#line 697
  key_string = (char *)tmp___9;
#line 699
  *(key_string + 0) = (char )n;
#line 700
  strncpy((char */* __restrict  */)(key_string + 1), (char const   */* __restrict  */)((char const   *)newarg),
          (size_t )n);
#line 701
  (r->h)->Keysym_map[sym] = (unsigned char const   *)((unsigned char *)key_string);
  }
#line 703
  return (1);
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
void rxvt_get_xdefaults(rxvt_t *r , FILE *stream , char const   *name ) 
{ 
  unsigned int len ;
  char *str ;
  char buffer[256] ;
  size_t tmp ;
  unsigned int entry ;
  unsigned int n ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char const   *kw ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int s ;
  char *p ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 720
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 721
    return;
  }
  {
#line 722
  tmp = strlen(name);
#line 722
  len = (unsigned int )tmp;
  }
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 723
    str = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)stream);
    }
#line 723
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 723
      goto while_break;
    }
    {
#line 726
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 726
      if (*str) {
        {
#line 726
        tmp___0 = __ctype_b_loc();
        }
#line 726
        if (! ((int const   )*(*tmp___0 + (int )*str) & 8192)) {
#line 726
          goto while_break___0;
        }
      } else {
#line 726
        goto while_break___0;
      }
#line 727
      str ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 729
    if ((int )*(str + len) != 42) {
#line 729
      if ((int )*(str + len) != 46) {
#line 731
        goto while_continue;
      } else {
#line 729
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 729
    if (len) {
      {
#line 729
      tmp___1 = strncmp((char const   *)str, name, (size_t )len);
      }
#line 729
      if (tmp___1) {
#line 731
        goto while_continue;
      }
    }
    {
#line 732
    str += len + 1U;
#line 735
    tmp___11 = rxvt_parse_keysym(r, (char const   *)str, (char const   *)((void *)0));
    }
#line 735
    if (! tmp___11) {
#line 737
      entry = 0U;
      {
#line 737
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 737
        if (! ((unsigned long )entry < sizeof(optList) / sizeof(optList[0]))) {
#line 737
          goto while_break___1;
        }
#line 738
        kw = (char const   *)optList[entry].kw;
#line 740
        if ((unsigned long )kw == (unsigned long )((void *)0)) {
#line 741
          goto __Cont;
        }
        {
#line 742
        tmp___2 = strlen(kw);
#line 742
        n = (unsigned int )tmp___2;
        }
#line 743
        if ((int )*(str + n) == 58) {
          {
#line 743
          tmp___10 = rxvt_Str_match((char const   *)str, kw);
          }
#line 743
          if (tmp___10) {
            {
#line 745
            str += n + 1U;
#line 746
            rxvt_Str_trim(str);
#line 747
            tmp___3 = strlen((char const   *)str);
#line 747
            n = (unsigned int )tmp___3;
            }
#line 748
            if (n) {
#line 748
              if ((unsigned long )(r->h)->rs[optList[entry].doff] == (unsigned long )((void *)0)) {
                {
#line 751
                tmp___4 = rxvt_malloc((unsigned long )(n + 1U) * sizeof(char ));
#line 751
                p = (char *)tmp___4;
#line 753
                strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)((char const   *)str));
#line 754
                (r->h)->rs[optList[entry].doff] = (char const   *)p;
                }
#line 755
                if (optList[entry].flag & (unsigned long const   )(1UL << 31)) {
                  {
#line 756
                  tmp___5 = strcasecmp((char const   *)str, "TRUE");
                  }
#line 756
                  if (tmp___5 == 0) {
#line 756
                    tmp___9 = 1;
                  } else {
                    {
#line 756
                    tmp___6 = strcasecmp((char const   *)str, "YES");
                    }
#line 756
                    if (tmp___6 == 0) {
#line 756
                      tmp___9 = 1;
                    } else {
                      {
#line 756
                      tmp___7 = strcasecmp((char const   *)str, "ON");
                      }
#line 756
                      if (tmp___7 == 0) {
#line 756
                        tmp___9 = 1;
                      } else {
                        {
#line 756
                        tmp___8 = strcasecmp((char const   *)str, "1");
                        }
#line 756
                        if (tmp___8 == 0) {
#line 756
                          tmp___9 = 1;
                        } else {
#line 756
                          tmp___9 = 0;
                        }
                      }
                    }
                  }
#line 756
                  s = tmp___9;
#line 760
                  if (optList[entry].flag & (unsigned long const   )(1UL << 30)) {
#line 761
                    s = ! s;
                  }
#line 762
                  if (s) {
#line 763
                    r->Options |= (unsigned long )optList[entry].flag;
                  } else {
#line 765
                    r->Options &= (unsigned long )(~ optList[entry].flag);
                  }
                }
              }
            }
#line 768
            goto while_break___1;
          }
        }
        __Cont: /* CIL Label */ 
#line 737
        entry ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 772
  rewind(stream);
  }
#line 773
  return;
}
}
#line 785 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/xdefaults.c"
void rxvt_extract_resources(rxvt_t *r , Display *display , char const   *name ) 
{ 
  char *localepath ;
  void *tmp ;
  FILE *fd ;
  char *home ;
  unsigned int i ;
  unsigned int len ;
  size_t tmp___0 ;
  char *f ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 793
  localepath = (char *)((void *)0);
#line 795
  if ((unsigned long )(r->h)->locale != (unsigned long )((void *)0)) {
    {
#line 796
    tmp = rxvt_malloc((size_t )256);
#line 796
    localepath = (char *)tmp;
#line 797
    sprintf((char */* __restrict  */)localepath, (char const   */* __restrict  */)"/usr/X11R6/lib/X11/%-.*s/app-defaults/Rxvt",
            (int )((258UL - sizeof("/usr/X11R6/lib/X11/%-.*s/app-defaults")) - sizeof("Rxvt")),
            (r->h)->locale);
    }
  }
  {
#line 939
  fd = (FILE *)((void *)0);
#line 942
  home = getenv("HOME");
  }
#line 942
  if ((unsigned long )home != (unsigned long )((void *)0)) {
    {
#line 943
    tmp___0 = strlen((char const   *)home);
#line 943
    len = (unsigned int )(tmp___0 + 2UL);
#line 944
    f = (char *)((void *)0);
#line 946
    i = 0U;
    }
    {
#line 946
    while (1) {
      while_continue: /* CIL Label */ ;
#line 946
      if (! ((unsigned long )i < sizeof(xnames) / sizeof(xnames[0]))) {
#line 946
        goto while_break;
      }
      {
#line 947
      tmp___1 = strlen((char const   *)xnames[i]);
#line 947
      tmp___2 = rxvt_realloc((void *)f, ((size_t )len + tmp___1) * sizeof(char ));
#line 947
      f = (char *)tmp___2;
#line 949
      sprintf((char */* __restrict  */)f, (char const   */* __restrict  */)"%s/%s",
              home, xnames[i]);
#line 951
      fd = fopen((char const   */* __restrict  */)f, (char const   */* __restrict  */)"r");
      }
#line 951
      if ((unsigned long )fd != (unsigned long )((void *)0)) {
#line 952
        goto while_break;
      }
#line 946
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 954
    free((void *)f);
    }
  }
  {
#line 978
  rxvt_get_xdefaults(r, fd, name);
#line 979
  rxvt_get_xdefaults(r, fd, "Rxvt");
#line 997
  rxvt_get_xdefaults(r, fd, "XTerm");
#line 998
  rxvt_get_xdefaults(r, fd, "");
  }
#line 999
  if ((unsigned long )fd != (unsigned long )((void *)0)) {
    {
#line 1000
    fclose(fd);
    }
  }
  {
#line 1008
  free((void *)localepath);
  }
#line 1051
  return;
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/scrollbar.extpro"
void rxvt_setup_scrollbar(rxvt_t *r , char const   *scrollalign , char const   *scrollstyle ,
                          char const   *thickness ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/scrollbar.c"
int rxvt_scrollbar_mapping(rxvt_t *r , int map ) 
{ 
  int change ;

  {
#line 39
  change = 0;
#line 56
  return (change);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/scrollbar.c"
void rxvt_Resize_scrollBar(rxvt_t *r ) 
{ 


  {
#line 121
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/scrollbar.c"
int rxvt_scrollbar_show(rxvt_t *r , int update ) 
{ 
  int ret ;

  {
#line 130
  ret = 0;
#line 162
  return (ret);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/scrollbar.c"
void rxvt_setup_scrollbar(rxvt_t *r , char const   *scrollalign , char const   *scrollstyle ,
                          char const   *thickness ) 
{ 


  {
#line 222
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/rxvt.c"
int main(int argc , char const   * const  *argv ) 
{ 
  rxvt_t *rxvt_vars ;

  {
  {
#line 11
  rxvt_vars = rxvt_init(argc, argv);
  }
#line 11
  if ((unsigned long )rxvt_vars == (unsigned long )((void *)0)) {
#line 12
    return (1);
  }
  {
#line 13
  rxvt_main_loop(rxvt_vars);
  }
#line 14
  return (0);
}
}
#line 583 "/usr/include/langinfo.h"
extern char *nl_langinfo(nl_item __item ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.c"
struct name2encoding  const  n2e[18]  = 
#line 41 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.c"
  {      {"KOI8R", (enum enc_label  const  )20}, 
        {"KOI8U", (enum enc_label  const  )21}, 
        {"ISO88591", (enum enc_label  const  )5}, 
        {"ISO88592", (enum enc_label  const  )6}, 
        {"ISO88593", (enum enc_label  const  )7}, 
        {"ISO88594", (enum enc_label  const  )8}, 
        {"ISO88595", (enum enc_label  const  )9}, 
        {"ISO88596", (enum enc_label  const  )10}, 
        {"ISO88597", (enum enc_label  const  )11}, 
        {"ISO88598", (enum enc_label  const  )12}, 
        {"ISO88599", (enum enc_label  const  )13}, 
        {"ISO885910", (enum enc_label  const  )14}, 
        {"ISO885911", (enum enc_label  const  )15}, 
        {"ISO885912", (enum enc_label  const  )16}, 
        {"ISO885913", (enum enc_label  const  )17}, 
        {"ISO885914", (enum enc_label  const  )18}, 
        {"ISO885915", (enum enc_label  const  )19}, 
        {(char const   *)((void *)0), (enum enc_label  const  )22}};
#line 96 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.c"
struct name2encoding  const  l2e[23]  = 
#line 96
  {      {"da", (enum enc_label  const  )5}, 
        {"de", (enum enc_label  const  )5}, 
        {"en", (enum enc_label  const  )5}, 
        {"fi", (enum enc_label  const  )5}, 
        {"fr", (enum enc_label  const  )5}, 
        {"is", (enum enc_label  const  )5}, 
        {"it", (enum enc_label  const  )5}, 
        {"la", (enum enc_label  const  )5}, 
        {"lt", (enum enc_label  const  )5}, 
        {"nl", (enum enc_label  const  )5}, 
        {"no", (enum enc_label  const  )5}, 
        {"pt", (enum enc_label  const  )5}, 
        {"sv", (enum enc_label  const  )5}, 
        {"cs", (enum enc_label  const  )6}, 
        {"hr", (enum enc_label  const  )6}, 
        {"hu", (enum enc_label  const  )6}, 
        {"la", (enum enc_label  const  )6}, 
        {"lt", (enum enc_label  const  )6}, 
        {"pl", (enum enc_label  const  )6}, 
        {"sl", (enum enc_label  const  )6}, 
        {"ru", (enum enc_label  const  )20}, 
        {"uk", (enum enc_label  const  )21}, 
        {(char const   *)((void *)0), (enum enc_label  const  )22}};
#line 143 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.c"
struct defaultfont  const  defaultfont[3]  = {      {(enum enc_label  const  )20, "noenc", {"-misc-fixed-medium-r-normal--14-130-75-75-c-70-koi8-r",
                                             "-misc-fixed-medium-r-normal--10-100-75-75-c-60-koi8-r",
                                             "-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-koi8-r",
                                             "-misc-fixed-medium-r-normal--13-120-75-75-c-80-koi8-r",
                                             "-misc-fixed-medium-r-normal--15-140-75-75-c-90-koi8-r",
                                             "-misc-fixed-medium-r-normal--18-120-100-100-c-90-koi8-r",
                                             "-misc-fixed-medium-r-normal--20-200-75-75-c-100-koi8-r"},
      {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
       (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
       (char const   *)((void *)0)}}, 
        {(enum enc_label  const  )21, "noenc", {"-cronyx-fixed-medium-r-normal--14-130-75-75-c-70-koi8-u",
                                             "-cronyx-fixed-medium-r-normal--10-100-75-75-c-60-koi8-u",
                                             "-cronyx-fixed-medium-r-semicondensed--13-120-75-75-c-60-koi8-u",
                                             "-cronyx-fixed-medium-r-normal--13-120-75-75-c-80-koi8-u",
                                             "-cronyx-fixed-medium-r-normal--15-140-75-75-c-90-koi8-u",
                                             "-cronyx-fixed-medium-r-normal--18-120-100-100-c-90-koi8-u",
                                             "-cronyx-fixed-medium-r-normal--20-200-75-75-c-100-koi8-u"},
      {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
       (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
       (char const   *)((void *)0)}}, 
        {(enum enc_label  const  )22, "noenc", {(char const   *)((void *)0), (char const   *)((void *)0),
                                             (char const   *)((void *)0), (char const   *)((void *)0),
                                             (char const   *)((void *)0), (char const   *)((void *)0),
                                             (char const   *)((void *)0)}, {(char const   *)((void *)0),
                                                                            (char const   *)((void *)0),
                                                                            (char const   *)((void *)0),
                                                                            (char const   *)((void *)0),
                                                                            (char const   *)((void *)0),
                                                                            (char const   *)((void *)0),
                                                                            (char const   *)((void *)0)}}};
#line 162 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.c"
char const   * const  defaultfont_8859[7]  = {      (char const   */* const  */)"-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-%d",      (char const   */* const  */)"-misc-fixed-medium-r-normal--10-100-75-75-c-60-iso8859-%d",      (char const   */* const  */)"-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso8859-%d",      (char const   */* const  */)"-misc-fixed-medium-r-normal--13-120-75-75-c-80-iso8859-%d", 
        (char const   */* const  */)"-misc-fixed-medium-r-normal--16-120-100-100-c-80-iso8859-%d",      (char const   */* const  */)"-misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-%d",      (char const   */* const  */)"-misc-fixed-medium-r-normal--24-170-100-100-c-120-iso8859-%d"};
#line 167 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.c"
char const   * const  def_fontName[7]  = {      (char const   */* const  */)"7x14",      (char const   */* const  */)"6x10",      (char const   */* const  */)"6x13",      (char const   */* const  */)"8x13", 
        (char const   */* const  */)"8x16",      (char const   */* const  */)"10x20",      (char const   */* const  */)"12x24"};
#line 179 "/home/june/repo/benchmarks/collector/temp/rxvt-2.7.10/src/defaultfont.c"
void rxvt_set_defaultfont(rxvt_t *r , char const   **rs ) 
{ 
  char *locale ;
  char *encoding_str ;
  char encoding_buf[100] ;
  char *p ;
  char *p2 ;
  enum enc_label encoding ;
  int j ;
  int k ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 182
  locale = (r->h)->locale;
#line 183
  encoding_str = (char *)((void *)0);
#line 186
  encoding = (enum enc_label )22;
#line 189
  (r->h)->fnum = 2;
#line 211
  if ((unsigned long )locale == (unsigned long )((void *)0)) {
#line 212
    encoding_str = (char *)((void *)0);
  } else {
    {
#line 215
    encoding_str = nl_langinfo(14);
    }
  }
#line 223
  if ((unsigned long )locale == (unsigned long )((void *)0)) {
    {
#line 224
    locale = getenv("LC_ALL");
    }
#line 224
    if ((unsigned long )locale == (unsigned long )((void *)0)) {
      {
#line 225
      locale = getenv("LC_CTYPE");
      }
#line 225
      if ((unsigned long )locale == (unsigned long )((void *)0)) {
        {
#line 226
        locale = getenv("LANG");
        }
#line 226
        if ((unsigned long )locale == (unsigned long )((void *)0)) {
#line 227
          locale = (char *)"C";
        }
      }
    }
#line 228
    (r->h)->locale = locale;
  }
#line 235
  if (encoding_str) {
#line 235
    if (*encoding_str) {
      {
#line 236
      strncpy((char */* __restrict  */)(encoding_buf), (char const   */* __restrict  */)((char const   *)encoding_str),
              (size_t )100);
      }
    } else {
#line 235
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 238
    p = strchr((char const   *)locale, '.');
    }
#line 239
    if (p) {
      {
#line 240
      strncpy((char */* __restrict  */)(encoding_buf), (char const   */* __restrict  */)((char const   *)(p + 1)),
              (size_t )100);
#line 241
      p = strchr((char const   *)(encoding_buf), '@');
      }
#line 242
      if (p) {
#line 243
        *p = (char)0;
      }
    } else {
      {
#line 245
      strncpy((char */* __restrict  */)(encoding_buf), (char const   */* __restrict  */)((char const   *)locale),
              (size_t )100);
      }
    }
  }
#line 247
  encoding_buf[99] = (char)0;
#line 248
  p2 = encoding_buf;
#line 248
  p = p2;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if (! ((int )*p2 == 95)) {
#line 249
        if (! ((int )*p2 == 45)) {
#line 249
          goto while_break___0;
        }
      }
#line 250
      p2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 251
    if (! *p2) {
#line 252
      goto while_break;
    }
    {
#line 253
    tmp = toupper((int )*p2);
#line 253
    *p = (char )tmp;
#line 248
    p ++;
#line 248
    p2 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  *p = (char)0;
#line 256
  j = 0;
  {
#line 256
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 256
    if (! n2e[j].name) {
#line 256
      goto while_break___1;
    }
    {
#line 257
    tmp___0 = strcmp((char const   *)(encoding_buf), (char const   *)n2e[j].name);
    }
#line 257
    if (! tmp___0) {
#line 258
      encoding = (enum enc_label )n2e[j].encoding;
#line 259
      goto while_break___1;
    }
#line 256
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 263
  if ((unsigned int )encoding == 22U) {
#line 264
    j = 0;
    {
#line 264
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 264
      if (! l2e[j].name) {
#line 264
        goto while_break___2;
      }
      {
#line 265
      tmp___1 = strlen((char const   *)l2e[j].name);
#line 265
      tmp___2 = strncmp((char const   *)locale, (char const   *)l2e[j].name, tmp___1);
      }
#line 265
      if (! tmp___2) {
#line 266
        encoding = (enum enc_label )l2e[j].encoding;
#line 267
        goto while_break___2;
      }
#line 264
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 275
  j = 0;
  {
#line 275
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 275
    if (! ((unsigned int const   )defaultfont[j].enc_label != 22U)) {
#line 275
      goto while_break___3;
    }
#line 276
    if ((unsigned int )encoding == (unsigned int )defaultfont[j].enc_label) {
#line 280
      k = 0;
      {
#line 280
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 280
        if (! (k < 7)) {
#line 280
          goto while_break___4;
        }
#line 281
        if ((unsigned long )*(rs + (30 + k)) == (unsigned long )((void *)0)) {
#line 282
          *(rs + (30 + k)) = defaultfont[j].font[k];
        }
#line 280
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 288
      return;
    }
#line 275
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 300
  if ((unsigned int )encoding >= 5U) {
#line 300
    if ((unsigned int )encoding <= 19U) {
#line 302
      k = (int )(((unsigned int )encoding - 5U) + 1U);
#line 303
      if (99999 < k) {
#line 303
        k = 99999;
      }
    } else {
#line 306
      k = 0;
    }
  } else {
#line 306
    k = 0;
  }
#line 308
  j = 0;
  {
#line 308
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 308
    if (! (j < 7)) {
#line 308
      goto while_break___5;
    }
#line 309
    if ((unsigned long )*(rs + (30 + j)) == (unsigned long )((void *)0)) {
#line 310
      if (k == 0) {
#line 311
        *(rs + (30 + j)) = (char const   *)def_fontName[j];
      } else {
        {
#line 314
        tmp___3 = strlen((char const   *)defaultfont_8859[j]);
#line 314
        tmp___4 = rxvt_malloc(tmp___3 + 4UL);
#line 314
        *(rs + (30 + j)) = (char const   *)tmp___4;
#line 315
        sprintf((char */* __restrict  */)((char *)*(rs + (30 + j))), (char const   */* __restrict  */)defaultfont_8859[j],
                k);
        }
      }
    }
#line 308
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 323
  return;
}
}
