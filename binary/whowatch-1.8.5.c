/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 15 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 3 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/var.h"
typedef u_int8_t u8;
#line 3 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/var.h"
typedef u_int32_t u32;
#line 71 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
struct wdgt;
#line 72 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
struct win {
   struct list_head wdgts ;
   struct list_head msg ;
   u32 sy ;
   u32 sx ;
   u8 gbuf[256] ;
   u32 gbsize ;
   void *(*cval)(void) ;
   u8 need_redraw ;
};
#line 83 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
struct wdgt {
   struct list_head wdgts_l ;
   struct list_head msg_l ;
   struct win *mwin ;
   u8 flags ;
   char name[8] ;
   void *prv ;
   void (*wrefresh)(struct wdgt * ) ;
   void (*redraw)(struct wdgt * ) ;
   int (*keyh)(struct wdgt * , int  ) ;
   void (*periodic)(struct wdgt * ) ;
   void *(*msgh)(struct wdgt * , int  , struct wdgt * , void * ) ;
   u32 x ;
   u32 y ;
   u32 xsize ;
   u32 ysize ;
   u32 vx ;
   u32 vy ;
   u32 pysize ;
   u32 pxsize ;
   void *wd ;
   int crsr ;
   u8 color ;
   int nlines ;
   void *decor ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 36 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/block.c"
struct _block_tbl_t {
   struct list_head head ;
   void *_block_t ;
   unsigned int map ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 5 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.h"
struct proc_t;
#line 5 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.h"
struct plist {
   struct proc_t *nx ;
   struct proc_t **ppv ;
};
#line 10 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.h"
struct proc_t {
   int pid ;
   char state ;
   struct proc_t *parent ;
   struct proc_t *child ;
   struct plist mlist ;
   struct plist broth ;
   struct plist hash ;
   void *priv ;
};
#line 43 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
struct pinfo {
   char state ;
   int pid ;
   int ppid ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 15 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/owner.c"
struct owner {
   char name[9] ;
   int uid ;
   struct owner *next ;
};
#line 44 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
struct netconn_t {
   struct list_head n_list ;
   struct list_head n_hash ;
   short valid ;
   unsigned int inode ;
   unsigned int state ;
   unsigned int s_addr ;
   unsigned int d_addr ;
   unsigned int s_port ;
   unsigned int d_port ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 404 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
struct proc_detail_t {
   char *title ;
   void (*fn)(int pid , char *name ) ;
   int t_lines ;
   char *name ;
};
#line 444 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
struct cpu_info_t {
   unsigned long long u_mode ;
   unsigned long long nice ;
   unsigned long long s_mode ;
   unsigned long long idle ;
};
#line 186 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_56 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_56 regmatch_t;
#line 52 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
struct seq {
   char type ;
   char mod ;
   char argf ;
   char delf ;
   int arg[16] ;
   int *argp ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 17 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
struct procinfo {
   int ppid ;
   int tpgid ;
   int cterm ;
   int euid ;
   char stat ;
   char exec_file[129] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 106 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
struct process {
   struct process **prev ;
   struct process *next ;
   struct list_head plist_l ;
   int line ;
   int uid ;
   struct proc_t *proc ;
};
#line 14 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
struct __pstat {
   u32 nr ;
   u32 rn ;
   u32 sl ;
   u32 st ;
   u32 zm ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_ut_tv_28 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_ut_tv_28 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 16 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.h"
struct user_t {
   struct list_head head ;
   char name[33] ;
   char tty[33] ;
   int pid ;
   char parent[16] ;
   char host[257] ;
   int line ;
};
#line 36 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.h"
struct prot_t {
   char *s ;
   short port ;
   u32 nr ;
};
#line 14 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
struct dsource {
   int key ;
   void (*f)(void * ) ;
   int want_crsr ;
   int (*keyh)(int  ) ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 788 "/usr/include/curses.h"
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 128 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
void scr_addstr(struct wdgt *w , char *s , u32 n ) ;
#line 134
void scr_output_start(struct wdgt *w ) ;
#line 5 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/pluglib.c"
struct wdgt *exti ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/pluglib.c"
void println(char const   *t  , ...) 
{ 
  int n ;
  char buf___6[256] ;
  va_list ap ;

  {
  {
#line 12
  __builtin_va_start(ap, t);
#line 13
  n = vsnprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)t,
                ap);
#line 14
  scr_addstr(exti, buf___6, (u32 )n);
#line 15
  __builtin_va_end(ap);
  }
#line 16
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/pluglib.c"
void plgn_out_start(void) 
{ 


  {
  {
#line 20
  scr_output_start(exti);
  }
#line 21
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/pluglib.c"
void print(char const   *t  , ...) 
{ 
  int n ;
  char buf___6[256] ;
  va_list ap ;

  {
  {
#line 28
  __builtin_va_start(ap, t);
#line 29
  n = vsnprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)t,
                ap);
#line 30
  waddnstr((WINDOW *)exti->wd, (char const   *)(buf___6), -1);
#line 31
  __builtin_va_end(ap);
  }
#line 32
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/pluglib.c"
void newln(void) 
{ 


  {
  {
#line 36
  scr_addstr(exti, (char *)"\n", (u32 )1);
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/pluglib.c"
void boldon(void) 
{ 


  {
#line 41
  if ((WINDOW *)exti->wd) {
#line 41
    ((WINDOW *)exti->wd)->_attrs = 1UL << 21;
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/pluglib.c"
void boldoff(void) 
{ 


  {
#line 46
  if ((WINDOW *)exti->wd) {
#line 46
    ((WINDOW *)exti->wd)->_attrs = 0UL;
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/pluglib.c"
void title(char const   *t  , ...) 
{ 
  int n ;
  char buf___6[256] ;
  va_list ap ;

  {
  {
#line 54
  boldon();
#line 55
  __builtin_va_start(ap, t);
#line 56
  n = vsnprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)t,
                ap);
#line 57
  waddnstr((WINDOW *)exti->wd, (char const   *)(buf___6), -1);
#line 59
  __builtin_va_end(ap);
#line 60
  boldoff();
  }
#line 61
  return;
}
}
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 267 "/usr/include/curses.h"
extern chtype acs_map[] ;
#line 587
extern int cbreak(void) ;
#line 597
extern int curs_set(int  ) ;
#line 606
extern int doupdate(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 705
extern WINDOW *newpad(int  , int  ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 711
extern int noecho(void) ;
#line 721
extern int pnoutrefresh(WINDOW * , int  , int  , int  , int  , int  , int  ) ;
#line 764
extern int start_color(void) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 797
extern int wbkgd(WINDOW * , chtype  ) ;
#line 799
extern int wborder(WINDOW * , chtype  , chtype  , chtype  , chtype  , chtype  , chtype  ,
                   chtype  , chtype  ) ;
#line 800
extern int wchgat(WINDOW * , int  , attr_t  , short  , void const   * ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 809
extern int werase(WINDOW * ) ;
#line 815
extern int winchnstr(WINDOW * , chtype * , int  ) ;
#line 819
extern int winsdelln(WINDOW * , int  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 904
extern int wresize(WINDOW * , int  , int  ) ;
#line 124 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
void scr_doupdate(void) ;
#line 125
void *scr_newwin(u32 x , u32 y , u32 xsize , u32 ysize ) ;
#line 127
int scr_addfstr(struct wdgt *w , char *s , u32 y , u32 x ) ;
#line 129
void scr_maddstr(struct wdgt *w , char *s , u32 y , u32 x , u32 n ) ;
#line 130
void scr_werase(struct wdgt *w ) ;
#line 131
int scr_keyh(struct wdgt *w , int key ) ;
#line 132
void scr_ldeleted(struct wdgt *w , int l ) ;
#line 133
void scr_linserted(struct wdgt *w , int line ) ;
#line 135
void scr_output_end(struct wdgt *w ) ;
#line 136
void scr_wresize(struct wdgt *w , u32 y , u32 x ) ;
#line 137
void scr_attr_set(struct wdgt *w , int n ) ;
#line 138
void scr_clr_set(struct wdgt *w , int n ) ;
#line 139
void scr_wrefresh(struct wdgt *w ) ;
#line 140
void scr_decor_resize(struct wdgt *w ) ;
#line 141
void scr_delline(struct wdgt *w , u32 l ) ;
#line 142
void scr_box(struct wdgt *w , char *s , u8 c___0 ) ;
#line 168
void curses_init(void) ;
#line 169
void curses_end(void) ;
#line 217
void term_raw(void) ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static chtype curs_buf[512]  ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
char *help_line[3]  = {      (char *)"\001[F1]Help [F9]Menu [ENT]proc all[t]ree [i]dle/cmd [c]md [d]etails [s]ysinfo",      (char *)"\001[ENT]users [c]md all[t]ree [d]etails [o]wner [s]ysinfo sig[l]ist ^[K]ILL",      (char *)"\001[ENT]users [c]md [d]etails [o]owner [s]ysinfo sig[l]ist ^[K]ILL"};
#line 20 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static void scr_color_init(void) 
{ 


  {
  {
#line 22
  init_pair((short)1, (short)6, (short)0);
#line 23
  init_pair((short)2, (short)2, (short)0);
#line 24
  init_pair((short)3, (short)7, (short)0);
#line 25
  init_pair((short)4, (short)5, (short)0);
#line 26
  init_pair((short)5, (short)1, (short)0);
#line 27
  init_pair((short)6, (short)3, (short)0);
#line 28
  init_pair((short)7, (short)1, (short)6);
#line 29
  init_pair((short)8, (short)0, (short)6);
#line 30
  init_pair((short)9, (short)0, (short)7);
  }
#line 31
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_wresize(struct wdgt *w , u32 y , u32 x ) 
{ 


  {
  {
#line 35
  wresize((WINDOW *)w->wd, (int )y, (int )x);
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static void scr_box_text(struct wdgt *w , char *s , u8 c___0 ) 
{ 
  int l ;
  int pos ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 41
  if (! s) {
#line 41
    return;
  }
  {
#line 42
  tmp = strlen((char const   *)s);
#line 42
  l = (int )tmp;
#line 44
  pos = (int )((w->xsize - w->x) - (u32 )l);
#line 47
  tmp___0 = wmove((WINDOW *)w->decor, (int )((w->ysize - w->y) + 2U), pos);
  }
#line 47
  if (! (tmp___0 == -1)) {
    {
#line 47
    waddnstr((WINDOW *)w->decor, (char const   *)s, l);
    }
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
__inline static void sadd_box(struct wdgt *w ) 
{ 


  {
  {
#line 52
  wborder((WINDOW *)w->decor, acs_map[(unsigned char )'x'], acs_map[(unsigned char )'x'],
          acs_map[(unsigned char )'q'], acs_map[(unsigned char )'q'], (chtype )0,
          (chtype )0, (chtype )0, (chtype )0);
  }
#line 53
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_box(struct wdgt *w , char *s , u8 c___0 ) 
{ 
  WINDOW *tmp ;

  {
#line 61
  if (w->decor) {
    {
#line 62
    scr_box_text(w, s, c___0);
    }
#line 63
    return;
  }
  {
#line 67
  tmp = newpad((int )((w->ysize - w->y) + 3U), (int )((w->xsize - w->x) + 3U));
#line 67
  w->decor = (void *)tmp;
  }
#line 68
  if (! w->decor) {
#line 68
    return;
  }
  {
#line 69
  sadd_box(w);
#line 70
  wbkgd((WINDOW *)w->decor, (chtype )c___0 << 8);
#line 71
  scr_box_text(w, s, c___0);
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_decor_resize(struct wdgt *w ) 
{ 


  {
  {
#line 76
  wresize((WINDOW *)w->decor, (int )((w->ysize - w->y) + 3U), (int )((w->xsize - w->x) + 3U));
#line 77
  sadd_box(w);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_doupdate(void) 
{ 


  {
  {
#line 83
  doupdate();
  }
#line 84
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void *scr_newwin(u32 x , u32 y , u32 xsize , u32 ysize ) 
{ 
  WINDOW *w ;

  {
  {
#line 92
  w = newwin((int )ysize, (int )xsize, (int )y, (int )x);
  }
#line 92
  if (! w) {
#line 92
    return ((void *)0);
  }
  {
#line 94
  wbkgd(w, 8UL << 8);
  }
#line 95
  return ((void *)w);
}
}
#line 98 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static void crsr_off(struct wdgt *w , int line ) 
{ 
  int i___0 ;

  {
#line 102
  if ((WINDOW *)w->wd) {
#line 102
    ((WINDOW *)w->wd)->_attrs = 0UL;
  }
#line 104
  i___0 = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! curs_buf[i___0]) {
#line 104
      goto while_break;
    }
    {
#line 105
    waddch((WINDOW *)w->wd, (chtype const   )curs_buf[i___0]);
#line 104
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static void crsr_on(struct wdgt *w , int line ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 111
  tmp = wmove((WINDOW *)w->wd, line, 0);
  }
#line 111
  if (! (tmp == -1)) {
    {
#line 111
    winchnstr((WINDOW *)w->wd, curs_buf, (int )(w->xsize + 1U));
    }
  }
  {
#line 112
  tmp___0 = wmove((WINDOW *)w->wd, line, 0);
  }
#line 112
  if (! (tmp___0 == -1)) {
    {
#line 112
    wchgat((WINDOW *)w->wd, (int )(w->xsize + 1U), 1UL << 18, (short)0, (void const   *)0);
    }
  }
#line 113
  if ((WINDOW *)w->wd) {
#line 113
    ((WINDOW *)w->wd)->_attrs = 0UL;
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static void crsr_move(struct wdgt *w , int from , int to ) 
{ 


  {
  {
#line 118
  crsr_off(w, from);
#line 119
  crsr_on(w, to);
#line 120
  w->crsr = to;
  }
#line 121
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static void scr_lecho(struct wdgt *w , char *s , int n ) 
{ 


  {
  {
#line 131
  waddnstr((WINDOW *)w->wd, (char const   *)s, n);
#line 132
  (w->nlines) ++;
  }
#line 134
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_output_start(struct wdgt *w ) 
{ 


  {
#line 139
  w->nlines = -1;
#line 140
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_output_end(struct wdgt *w ) 
{ 


  {
#line 150
  if (w->vy >= (u32 )w->nlines) {
#line 151
    if ((u32 )w->nlines > w->ysize) {
#line 151
      w->vy = (u32 )w->nlines - w->ysize;
    } else {
#line 152
      w->vy = (u32 )0;
    }
  }
#line 155
  if (w->crsr > w->nlines) {
#line 155
    w->crsr = w->nlines;
  }
#line 156
  if (w->crsr != -1) {
    {
#line 156
    crsr_on(w, w->crsr);
    }
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_attr_set(struct wdgt *w , int n ) 
{ 


  {
#line 161
  if ((WINDOW *)w->wd) {
#line 161
    ((WINDOW *)w->wd)->_attrs = (attr_t )n;
  }
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_clr_set(struct wdgt *w , int n ) 
{ 


  {
#line 166
  if ((WINDOW *)w->wd) {
#line 166
    ((WINDOW *)w->wd)->_attrs = (chtype )n << 8;
  }
#line 167
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_crsr_jmp(struct wdgt *w , int l ) 
{ 
  int size ;

  {
  {
#line 172
  size = (int )((w->ysize - w->y) - 1U);
#line 173
  crsr_move(w, w->crsr, l);
  }
#line 175
  if ((u32 )l >= w->vy) {
#line 175
    if ((u32 )l < w->vy + (u32 )size) {
#line 175
      return;
    }
  }
#line 176
  w->vy = (u32 )(w->crsr - size);
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_maddstr(struct wdgt *w , char *s , u32 y , u32 x , u32 n ) 
{ 


  {
  {
#line 181
  wmove((WINDOW *)w->wd, (int )y, (int )x);
#line 182
  scr_lecho(w, s, (int )n);
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_addstr(struct wdgt *w , char *s , u32 n ) 
{ 


  {
  {
#line 187
  scr_lecho(w, s, (int )n);
  }
#line 188
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_linserted(struct wdgt *w , int line ) 
{ 


  {
#line 196
  if (! w->vy) {
#line 196
    if (! w->crsr) {
#line 196
      return;
    }
  }
#line 197
  if (line <= w->crsr) {
#line 198
    (w->vy) ++;
#line 199
    (w->crsr) ++;
  }
#line 201
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_ldeleted(struct wdgt *w , int l ) 
{ 


  {
#line 210
  if (l >= w->crsr) {
#line 210
    return;
  }
#line 211
  if (! w->vy) {
#line 211
    (w->crsr) --;
  } else {
#line 213
    (w->vy) --;
#line 214
    (w->crsr) --;
  }
#line 216
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
__inline static void srefresh(struct wdgt *w ) 
{ 


  {
  {
#line 219
  pnoutrefresh((WINDOW *)w->wd, (int )w->vy, (int )w->vx, (int )w->y, (int )w->x,
               (int )w->ysize, (int )w->xsize);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_wrefresh(struct wdgt *w ) 
{ 


  {
#line 226
  if (w->decor) {
    {
#line 226
    pnoutrefresh((WINDOW *)w->decor, 0, 0, (int )(w->y - 1U), (int )(w->x - 1U), (int )(w->ysize + 1U),
                 (int )(w->xsize + 1U));
    }
  }
  {
#line 227
  srefresh(w);
  }
#line 228
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
int scr_addfstr(struct wdgt *w , char *s , u32 y , u32 x ) 
{ 
  char *p___2 ;
  char *q ;
  int i___0 ;

  {
#line 235
  p___2 = s;
#line 235
  q = s;
#line 236
  i___0 = 0;
#line 237
  if (! p___2) {
#line 237
    return (1);
  }
  {
#line 238
  wmove((WINDOW *)w->wd, (int )y, (int )x);
#line 239
  wclrtoeol((WINDOW *)w->wd);
#line 240
  i___0 = 0;
  }
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (*p___2) {
#line 240
      if (! ((u32 )i___0 <= w->xsize)) {
#line 240
        goto while_break;
      }
    } else {
#line 240
      goto while_break;
    }
#line 241
    if ((int )*p___2 >= 17) {
#line 241
      goto __Cont;
    }
#line 242
    i___0 --;
#line 243
    if (p___2 - q != 0L) {
      {
#line 243
      waddnstr((WINDOW *)w->wd, (char const   *)q, (int )(p___2 - q));
      }
    }
#line 244
    if ((WINDOW *)w->wd) {
#line 244
      ((WINDOW *)w->wd)->_attrs = (chtype )*p___2 << 8;
    }
#line 245
    q = p___2 + 1;
    __Cont: /* CIL Label */ 
#line 240
    p___2 ++;
#line 240
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  scr_lecho(w, q, (int )(p___2 - q));
  }
#line 248
  return (0);
}
}
#line 251 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_werase(struct wdgt *w ) 
{ 


  {
  {
#line 253
  werase((WINDOW *)w->wd);
  }
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void scr_delline(struct wdgt *w , u32 l ) 
{ 


  {
  {
#line 258
  wmove((WINDOW *)w->wd, (int )l, 0);
#line 259
  winsdelln((WINDOW *)w->wd, -1);
  }
#line 260
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
__inline static int s_nleft(struct wdgt *w ) 
{ 
  int n ;

  {
#line 264
  n = (int )(w->ysize - w->y);
#line 265
  return ((int )((u32 )w->nlines - (w->vy + (u32 )n)));
}
}
#line 268 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static int kbd_page_up(struct wdgt *w ) 
{ 
  int left ;
  int n ;
  u32 tmp ;

  {
#line 270
  left = (int )w->vy;
#line 271
  if ((u32 )left < w->ysize - w->y) {
#line 271
    tmp = (u32 )left;
  } else {
#line 271
    tmp = w->ysize - w->y;
  }
#line 271
  n = (int )tmp;
#line 273
  if (left > 0) {
#line 273
    w->vy -= (u32 )n;
  } else {
    {
#line 275
    crsr_move(w, w->crsr, 0);
    }
#line 276
    return (0);
  }
  {
#line 278
  crsr_move(w, w->crsr, w->crsr - n);
  }
#line 280
  return (0);
}
}
#line 283 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static int kbd_up(struct wdgt *w ) 
{ 
  int crsr ;
  u32 tmp ;

  {
#line 285
  if (w->crsr == -1) {
#line 285
    tmp = w->vy;
  } else {
#line 285
    tmp = (u32 )w->crsr;
  }
#line 285
  crsr = (int )tmp;
#line 288
  if (w->crsr == -1) {
#line 289
    if (w->vy) {
#line 289
      (w->vy) --;
    }
#line 290
    return (0);
  }
#line 292
  if (w->vy) {
#line 292
    if ((u32 )crsr == w->vy) {
#line 292
      (w->vy) --;
    }
  }
#line 293
  if (crsr > 0) {
    {
#line 293
    crsr_move(w, w->crsr, w->crsr - 1);
    }
  }
#line 294
  return (0);
}
}
#line 301 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static int kbd_down(struct wdgt *w ) 
{ 
  int nleft ;
  int tmp ;

  {
  {
#line 303
  tmp = s_nleft(w);
#line 303
  nleft = tmp;
  }
#line 307
  if (w->crsr == -1) {
#line 308
    if (nleft > 0) {
#line 308
      (w->vy) ++;
    }
#line 309
    return (0);
  }
#line 312
  if ((u32 )w->crsr - w->vy == w->ysize - w->y) {
#line 313
    if (nleft > 0) {
#line 313
      (w->vy) ++;
    } else {
#line 314
      return (0);
    }
  }
#line 317
  if (w->crsr < w->nlines) {
    {
#line 317
    crsr_move(w, w->crsr, w->crsr + 1);
    }
  }
#line 318
  return (0);
}
}
#line 321 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static int kbd_page_down(struct wdgt *w ) 
{ 
  int nleft ;
  int tmp ;
  int n ;
  u32 tmp___0 ;

  {
  {
#line 323
  tmp = s_nleft(w);
#line 323
  nleft = tmp;
  }
#line 324
  if ((u32 )nleft < w->ysize - w->y) {
#line 324
    tmp___0 = (u32 )nleft;
  } else {
#line 324
    tmp___0 = w->ysize - w->y;
  }
#line 324
  n = (int )tmp___0;
#line 326
  if (nleft > 0) {
#line 326
    w->vy += (u32 )n;
  } else {
    {
#line 328
    crsr_move(w, w->crsr, w->nlines);
    }
#line 329
    return (0);
  }
#line 331
  if (w->crsr != -1) {
    {
#line 332
    crsr_move(w, w->crsr, w->crsr + n);
    }
  }
#line 333
  return (0);
}
}
#line 336 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static int kbd_home(struct wdgt *w ) 
{ 


  {
#line 338
  if (! w->vy) {
#line 338
    if (! w->crsr) {
#line 338
      return (0);
    }
  }
  {
#line 339
  w->vy = (u32 )0;
#line 340
  crsr_move(w, w->crsr, 0);
  }
#line 341
  return (1);
}
}
#line 344 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static int kbd_end(struct wdgt *w ) 
{ 
  int nleft ;
  int tmp ;

  {
  {
#line 346
  tmp = s_nleft(w);
#line 346
  nleft = tmp;
  }
#line 348
  if (nleft > 0) {
#line 348
    w->vy += (u32 )nleft;
  }
#line 350
  if (w->crsr < w->nlines) {
    {
#line 351
    crsr_move(w, w->crsr, w->crsr + nleft);
    }
#line 352
    return (1);
  }
#line 354
  return (0);
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static int kbd_right(struct wdgt *w ) 
{ 


  {
#line 360
  if (w->crsr == -1) {
#line 360
    if (w->vx < (w->pxsize - w->x) - w->xsize) {
#line 360
      (w->vx) ++;
    }
  }
#line 361
  return (0);
}
}
#line 364 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
static int kbd_left(struct wdgt *w ) 
{ 


  {
#line 366
  if (w->crsr == -1) {
#line 366
    if (w->vx) {
#line 366
      (w->vx) --;
    }
  }
#line 367
  return (0);
}
}
#line 370 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
int scr_keyh(struct wdgt *w , int key ) 
{ 
  int ret ;

  {
#line 372
  ret = 1;
  {
#line 375
  if (key == 263) {
#line 375
    goto case_263;
  }
#line 376
  if (key == 262) {
#line 376
    goto case_262;
  }
#line 377
  if (key == 269) {
#line 377
    goto case_269;
  }
#line 378
  if (key == 268) {
#line 378
    goto case_268;
  }
#line 379
  if (key == 260) {
#line 379
    goto case_260;
  }
#line 380
  if (key == 261) {
#line 380
    goto case_261;
  }
#line 381
  if (key == 266) {
#line 381
    goto case_266;
  }
#line 382
  if (key == 267) {
#line 382
    goto case_267;
  }
#line 383
  goto switch_default;
  case_263: /* CIL Label */ 
  {
#line 375
  kbd_down(w);
  }
#line 375
  goto switch_break;
  case_262: /* CIL Label */ 
  {
#line 376
  kbd_up(w);
  }
#line 376
  goto switch_break;
  case_269: /* CIL Label */ 
  {
#line 377
  kbd_page_down(w);
  }
#line 377
  goto switch_break;
  case_268: /* CIL Label */ 
  {
#line 378
  kbd_page_up(w);
  }
#line 378
  goto switch_break;
  case_260: /* CIL Label */ 
  {
#line 379
  kbd_left(w);
  }
#line 379
  goto switch_break;
  case_261: /* CIL Label */ 
  {
#line 380
  kbd_right(w);
  }
#line 380
  goto switch_break;
  case_266: /* CIL Label */ 
  {
#line 381
  ret = kbd_home(w);
  }
#line 381
  goto switch_break;
  case_267: /* CIL Label */ 
  {
#line 382
  ret = kbd_end(w);
  }
#line 382
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 383
  ret = 0;
  switch_break: /* CIL Label */ ;
  }
#line 385
  return (ret);
}
}
#line 388 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
struct termios tio  ;
#line 389 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void term_raw(void) 
{ 
  struct termios t ;

  {
  {
#line 392
  tcgetattr(0, & tio);
#line 393
  t = tio;
#line 394
  t.c_lflag &= 4294967285U;
#line 395
  tcsetattr(0, 0, (struct termios  const  *)(& t));
#line 396
  fcntl(0, 4, 2048);
  }
#line 397
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void term_rest(void) 
{ 


  {
  {
#line 401
  tcsetattr(0, 0, (struct termios  const  *)(& tio));
  }
#line 402
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
int old_curs_vis  ;
#line 405 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void curses_init(void) 
{ 


  {
  {
#line 407
  initscr();
#line 409
  old_curs_vis = curs_set(0);
#line 410
  start_color();
#line 411
  scr_color_init();
#line 412
  cbreak();
#line 419
  noecho();
#line 420
  term_raw();
  }
#line 421
  return;
}
}
#line 423 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/screen.c"
void curses_end(void) 
{ 


  {
  {
#line 425
  endwin();
#line 427
  curs_set(old_curs_vis);
  }
#line 428
  return;
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/list.h"
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 


  {
#line 36
  next->prev = new;
#line 37
  new->next = next;
#line 38
  new->prev = prev;
#line 39
  prev->next = new;
#line 40
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 47
  __list_add(new, head, head->next);
  }
#line 48
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
void *get_empty(int size , struct list_head *h ) ;
#line 196
int free_entry(void *p___2 , int size , struct list_head *h ) ;
#line 197
void dolog(char const   *t  , ...) ;
#line 17 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/block.c"
static FILE *logfile  ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/block.c"
void dolog(char const   *t  , ...) 
{ 
  va_list ap ;
  char *c___0 ;
  time_t tm ;
  time_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 20
  tmp = time((time_t *)0);
#line 20
  tm = tmp;
  }
#line 21
  if (! logfile) {
    {
#line 22
    logfile = fopen((char const   */* __restrict  */)"/var/log/whowatch.log", (char const   */* __restrict  */)"a");
    }
#line 23
    if (! logfile) {
#line 23
      return;
    }
    {
#line 24
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)" #############\n");
    }
  }
  {
#line 26
  c___0 = ctime((time_t const   *)(& tm));
#line 27
  tmp___0 = strlen((char const   *)c___0);
#line 27
  *((c___0 + tmp___0) - 1) = (char)0;
#line 28
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s: ",
          c___0);
#line 29
  __builtin_va_start(ap, t);
#line 30
  vfprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)t, ap);
#line 31
  __builtin_va_end(ap);
#line 32
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
#line 33
  fflush(logfile);
  }
#line 34
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/block.c"
static struct _block_tbl_t *new_block(int size , struct list_head *h ) 
{ 
  struct _block_tbl_t *tmp ;
  void *tmp___0 ;

  {
  {
#line 45
  tmp___0 = calloc((size_t )1, sizeof(*tmp));
#line 45
  tmp = (struct _block_tbl_t *)tmp___0;
  }
#line 46
  if (! tmp) {
    {
#line 46
    exit(0);
    }
  }
  {
#line 47
  tmp->_block_t = calloc((size_t )1, (unsigned long )size * (sizeof(unsigned int ) * 8UL));
  }
#line 48
  if (! tmp->_block_t) {
    {
#line 48
    exit(0);
    }
  }
  {
#line 49
  list_add(& tmp->head, h);
  }
#line 50
  return (tmp);
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/block.c"
void *get_empty(int size , struct list_head *h ) 
{ 
  int i___0 ;
  int nr ;
  struct _block_tbl_t *tmp ;
  struct list_head *t ;

  {
#line 60
  nr = 0;
#line 63
  t = h->next;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! ((unsigned long )t != (unsigned long )h)) {
#line 63
      goto while_break;
    }
#line 64
    tmp = (struct _block_tbl_t *)((char *)t - (unsigned long )(& ((struct _block_tbl_t *)0)->head));
#line 65
    if (tmp->map == 4294967295U) {
#line 65
      goto __Cont;
    }
#line 66
    i___0 = 0;
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      if (! ((unsigned long )i___0 < sizeof(unsigned int ) * 8UL)) {
#line 66
        goto while_break___0;
      }
#line 67
      if (((unsigned int )(1 << i___0) & tmp->map) == 0U) {
#line 67
        goto FOUND;
      }
#line 66
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 69
    nr ++;
    __Cont: /* CIL Label */ 
#line 63
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 71
  tmp = new_block(size, h);
#line 72
  i___0 = 0;
  }
  FOUND: 
#line 74
  tmp->map |= (unsigned int )(1 << i___0);
#line 75
  return (tmp->_block_t + size * i___0);
}
}
#line 101 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/block.c"
int free_entry(void *p___2 , int size , struct list_head *h ) 
{ 
  struct _block_tbl_t *tmp ;
  struct list_head *t ;
  int i___0 ;

  {
#line 105
  i___0 = 0;
#line 106
  t = h->next;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )t != (unsigned long )h)) {
#line 106
      goto while_break;
    }
#line 107
    tmp = (struct _block_tbl_t *)((char *)t - (unsigned long )(& ((struct _block_tbl_t *)0)->head));
#line 108
    if ((unsigned long )p___2 >= (unsigned long )tmp->_block_t) {
#line 108
      if ((unsigned long )p___2 < (unsigned long )(tmp->_block_t + (unsigned long )size * (sizeof(unsigned int ) * 8UL))) {
#line 109
        goto FOUND;
      }
    }
#line 110
    i___0 ++;
#line 106
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (-1);
  FOUND: 
#line 114
  tmp->map &= (unsigned int )(~ (1 << (p___2 - tmp->_block_t) / (long )size));
#line 115
  return (0);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.h"
int update_tree(void (*del)(void * ) ) ;
#line 23
struct proc_t *find_by_pid(int n ) ;
#line 24
struct proc_t *tree_start(int root_pid , int start_pid ) ;
#line 25
struct proc_t *tree_next(void) ;
#line 26
char *tree_string(int root___0 , struct proc_t *p___2 ) ;
#line 28
int num_proc ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
__inline static int get_pinfo(struct pinfo *i___0 , DIR *d ) ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
static char name[32]  = {      (char )'/',      (char )'p',      (char )'r',      (char )'o', 
        (char )'c',      (char )'/',      (char )'\000'};
#line 50 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
__inline static int get_pinfo(struct pinfo *i___0 , DIR *d ) 
{ 
  struct dirent *e___0 ;
  int f ;
  int n ;
  char buf___6[64] ;
  char *p___2 ;
  unsigned short const   **tmp ;
  ssize_t tmp___0 ;
  char *tmp___1 ;

  {
#line 54
  i___0->state = (char )'?';
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    e___0 = readdir(d);
    }
#line 60
    if (! e___0) {
#line 60
      return (0);
    }
    {
#line 61
    tmp = __ctype_b_loc();
    }
#line 61
    if (! ((int const   )*(*tmp + (int )e___0->d_name[0]) & 2048)) {
#line 61
      goto __Cont;
    }
    {
#line 62
    i___0->state = (char )'?';
#line 63
    sprintf((char */* __restrict  */)(name + sizeof("/proc")), (char const   */* __restrict  */)"%s/stat",
            e___0->d_name);
#line 64
    f = open((char const   *)(name), 0);
    }
#line 65
    if (! f) {
#line 65
      goto __Cont;
    }
    {
#line 66
    tmp___0 = read(f, (void *)(buf___6), (size_t )63);
#line 66
    n = (int )tmp___0;
#line 67
    close(f);
    }
#line 68
    if (n < 0) {
#line 68
      goto __Cont;
    }
    {
#line 69
    buf___6[n] = (char)0;
#line 70
    tmp___1 = strrchr((char const   *)(buf___6 + 4), ')');
#line 70
    p___2 = tmp___1 + 4;
#line 71
    i___0->state = *(p___2 - 2);
#line 72
    i___0->ppid = atoi((char const   *)p___2);
#line 73
    i___0->pid = atoi((char const   *)(buf___6));
    }
#line 74
    if (i___0->pid <= 0) {
#line 74
      goto __Cont;
    }
#line 75
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (1);
}
}
#line 83 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
static struct proc_t proc_special[2]  = {      {0, (char)0, (struct proc_t *)0, (struct proc_t *)0, {(struct proc_t *)0, (struct proc_t **)0},
      {(struct proc_t *)0, (struct proc_t **)0}, {(struct proc_t *)0, (struct proc_t **)0},
      (void *)0}, 
        {1, (char)0, (struct proc_t *)0, (struct proc_t *)0, {(struct proc_t *)0, (struct proc_t **)0},
      {(struct proc_t *)0, (struct proc_t **)0}, {(struct proc_t *)0, (struct proc_t **)0},
      (void *)0}};
#line 84 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
static struct proc_t *hash_table[128]  ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
static struct proc_t *main_list  =    (struct proc_t *)0;
#line 86 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
int num_proc  =    1;
#line 88 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
__inline static int hash_fun(int n ) 
{ 


  {
#line 90
  return (n & 127);
}
}
#line 93 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
struct proc_t *find_by_pid(int n ) 
{ 
  struct proc_t *p___2 ;
  int tmp ;

  {
#line 96
  if (n <= 1) {
#line 96
    return (& proc_special[n]);
  }
  {
#line 98
  tmp = hash_fun(n);
#line 98
  p___2 = hash_table[tmp];
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p___2) {
#line 99
      goto while_break;
    }
#line 100
    if (p___2->pid == n) {
#line 100
      goto while_break;
    }
#line 101
    p___2 = p___2->hash.nx;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (p___2);
}
}
#line 106 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
static struct proc_t *cache  =    (struct proc_t *)0;
#line 108 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
__inline static void remove_proc(struct proc_t *p___2 ) 
{ 


  {
#line 110
  *(p___2->hash.ppv) = p___2->hash.nx;
#line 110
  if (p___2->hash.nx) {
#line 110
    (p___2->hash.nx)->hash.ppv = p___2->hash.ppv;
  }
#line 111
  if (cache) {
    {
#line 111
    free((void *)cache);
    }
  }
#line 112
  cache = p___2;
#line 113
  num_proc --;
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
__inline static struct proc_t *new_proc(int n , char state___0 ) 
{ 
  struct proc_t *p___2 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 118
  p___2 = cache;
#line 119
  cache = (struct proc_t *)0;
#line 120
  if (! p___2) {
    {
#line 121
    tmp = malloc(sizeof(*p___2));
#line 121
    p___2 = (struct proc_t *)tmp;
    }
  }
  {
#line 122
  memset((void *)p___2, 0, sizeof(*p___2));
#line 123
  p___2->pid = n;
#line 124
  p___2->state = state___0;
#line 126
  tmp___0 = hash_fun(n);
#line 126
  p___2->hash.nx = hash_table[tmp___0];
#line 126
  tmp___1 = hash_fun(n);
#line 126
  p___2->hash.ppv = & hash_table[tmp___1];
#line 126
  tmp___3 = hash_fun(n);
  }
#line 126
  if (hash_table[tmp___3]) {
    {
#line 126
    tmp___2 = hash_fun(n);
#line 126
    (hash_table[tmp___2])->hash.ppv = & p___2->hash.nx;
    }
  }
  {
#line 126
  tmp___4 = hash_fun(n);
#line 126
  hash_table[tmp___4] = p___2;
#line 127
  num_proc ++;
  }
#line 129
  return (p___2);
}
}
#line 132 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
static struct proc_t *validate_proc(int pid___0 , char state___0 ) 
{ 
  struct proc_t *p___2 ;

  {
  {
#line 136
  p___2 = find_by_pid(pid___0);
  }
#line 137
  if (pid___0 <= 1) {
#line 138
    p___2->state = state___0;
#line 139
    return (p___2);
  }
#line 141
  if (p___2) {
#line 142
    *(p___2->mlist.ppv) = p___2->mlist.nx;
#line 142
    if (p___2->mlist.nx) {
#line 142
      (p___2->mlist.nx)->mlist.ppv = p___2->mlist.ppv;
    }
  } else {
    {
#line 144
    p___2 = new_proc(pid___0, state___0);
    }
  }
#line 145
  p___2->mlist.nx = main_list;
#line 145
  p___2->mlist.ppv = & main_list;
#line 145
  if (main_list) {
#line 145
    main_list->mlist.ppv = & p___2->mlist.nx;
  }
#line 145
  main_list = p___2;
#line 146
  return (p___2);
}
}
#line 149 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
__inline static void change_parent(struct proc_t *p___2 , struct proc_t *q ) 
{ 


  {
#line 151
  if (! (! p___2->broth.ppv)) {
#line 152
    *(p___2->broth.ppv) = p___2->broth.nx;
#line 152
    if (p___2->broth.nx) {
#line 152
      (p___2->broth.nx)->broth.ppv = p___2->broth.ppv;
    }
  }
#line 153
  p___2->broth.nx = q->child;
#line 153
  p___2->broth.ppv = & q->child;
#line 153
  if (q->child) {
#line 153
    (q->child)->broth.ppv = & p___2->broth.nx;
  }
#line 153
  q->child = p___2;
#line 154
  p___2->parent = q;
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
int update_tree(void (*del)(void * ) ) 
{ 
  struct pinfo info ;
  DIR *d ;
  struct proc_t *p___2 ;
  struct proc_t *q ;
  struct proc_t *old_list ;
  int n ;
  int tmp ;

  {
#line 168
  n = num_proc;
#line 169
  old_list = main_list;
#line 169
  if (main_list) {
#line 169
    main_list->mlist.ppv = & old_list;
  }
  {
#line 170
  main_list = (struct proc_t *)0;
#line 179
  d = opendir("/proc");
  }
#line 180
  if ((unsigned long )d < 0UL) {
#line 180
    return (-1);
  }
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 182
    tmp = get_pinfo(& info, d);
    }
#line 182
    if (! tmp) {
#line 182
      goto while_break;
    }
    {
#line 183
    p___2 = validate_proc(info.pid, info.state);
#line 184
    q = validate_proc(info.ppid, info.state);
    }
#line 186
    if ((unsigned long )p___2->parent != (unsigned long )q) {
#line 187
      if (p___2->priv) {
        {
#line 187
        (*del)(p___2->priv);
        }
      }
      {
#line 188
      change_parent(p___2, q);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  closedir(d);
#line 196
  n = num_proc - n;
#line 198
  p___2 = old_list;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! p___2) {
#line 198
      goto while_break___0;
    }
    {
#line 199
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 199
      if (! p___2->child) {
#line 199
        goto while_break___1;
      }
      {
#line 200
      change_parent(p___2->child, & proc_special[1]);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 201
    if (! (! p___2->broth.ppv)) {
#line 202
      *(p___2->broth.ppv) = p___2->broth.nx;
#line 202
      if (p___2->broth.nx) {
#line 202
        (p___2->broth.nx)->broth.ppv = p___2->broth.ppv;
      }
    }
#line 203
    q = p___2->mlist.nx;
#line 204
    if (p___2->priv) {
      {
#line 204
      (*del)(p___2->priv);
      }
    }
    {
#line 205
    remove_proc(p___2);
#line 206
    n ++;
#line 198
    p___2 = q;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  return (n);
}
}
#line 214 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
static struct proc_t *proc  ;
#line 214 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
static struct proc_t *root  ;
#line 216 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
struct proc_t *tree_start(int root_pid , int start_pid ) 
{ 
  struct proc_t *tmp ;

  {
  {
#line 218
  root = find_by_pid(root_pid);
  }
#line 219
  if (! root) {
#line 219
    return ((struct proc_t *)0);
  }
  {
#line 220
  proc = find_by_pid(start_pid);
  }
#line 221
  if (start_pid) {
#line 222
    return (proc);
  }
  {
#line 223
  tmp = tree_next();
  }
#line 223
  return (tmp);
}
}
#line 226 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
struct proc_t *tree_next(void) 
{ 


  {
#line 228
  if (proc->child) {
#line 229
    proc = proc->child;
  } else {
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 232
      if ((unsigned long )proc == (unsigned long )root) {
#line 233
        proc = (struct proc_t *)0;
      } else
#line 234
      if (proc->broth.nx) {
#line 235
        proc = proc->broth.nx;
      } else {
#line 237
        goto __Cont;
      }
#line 238
      goto while_break;
      __Cont: /* CIL Label */ 
#line 231
      proc = proc->parent;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 240
  return (proc);
}
}
#line 243 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
static char buf[66]  ;
#line 245 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proctree.c"
char *tree_string(int root___0 , struct proc_t *p___2 ) 
{ 
  struct proc_t *q ;
  char *s ;
  int i___0 ;
  int d ;

  {
#line 251
  i___0 = 0;
#line 252
  q = p___2;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (q->pid != root___0)) {
#line 252
      goto while_break;
    }
#line 253
    i___0 ++;
#line 252
    q = q->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  if (root___0 == 0) {
#line 256
    i___0 --;
  }
#line 257
  d = i___0;
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 259
    if (! (i___0 > 32)) {
#line 259
      goto while_break___0;
    }
#line 260
    p___2 = p___2->parent;
#line 260
    i___0 --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 262
  s = buf + 2 * i___0;
#line 263
  *(s + 1) = (char)0;
#line 264
  *(s + 0) = (char )'.';
#line 266
  if (d <= 32) {
#line 267
    *(s + 0) = (char )'-';
#line 268
    if (i___0 > 0) {
#line 268
      if (! p___2->broth.nx) {
#line 269
        s --;
#line 269
        *s = (char )'`';
#line 270
        goto loop;
      }
    }
  }
  {
#line 274
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 274
    if (! (i___0 > 0)) {
#line 274
      goto while_break___1;
    }
#line 275
    s --;
#line 275
    if (p___2->broth.nx) {
#line 275
      *s = (char )'|';
    } else {
#line 275
      *s = (char )' ';
    }
    loop: 
#line 277
    s --;
#line 277
    *s = (char )' ';
#line 278
    p___2 = p___2->parent;
#line 278
    i___0 --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 281
  return (buf);
}
}
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 158 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
void allocate_error(void) ;
#line 192
char *get_owner_name(int u___0 ) ;
#line 20 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/owner.c"
static struct owner *hash_table___0[32]  ;
#line 22 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/owner.c"
__inline static int hash_fun___0(int n ) 
{ 


  {
#line 24
  return (n & 31);
}
}
#line 27 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/owner.c"
static struct owner *find_by_uid(int n ) 
{ 
  struct owner *p___2 ;
  int tmp ;

  {
  {
#line 31
  tmp = hash_fun___0(n);
#line 31
  p___2 = hash_table___0[tmp];
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! p___2) {
#line 32
      goto while_break;
    }
#line 33
    if (p___2->uid == n) {
#line 33
      goto while_break;
    }
#line 34
    p___2 = p___2->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return (p___2);
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/owner.c"
static struct owner *new_owner(int n ) 
{ 
  struct owner *p___2 ;
  struct passwd *u___0 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 43
  tmp = malloc(sizeof(*p___2));
#line 43
  p___2 = (struct owner *)tmp;
  }
#line 44
  if (! p___2) {
    {
#line 44
    allocate_error();
    }
  }
  {
#line 45
  memset((void *)p___2, 0, sizeof(*p___2));
#line 46
  u___0 = getpwuid((__uid_t )n);
  }
#line 47
  if (! u___0) {
    {
#line 47
    sprintf((char */* __restrict  */)(p___2->name), (char const   */* __restrict  */)"%d",
            n);
    }
  } else {
    {
#line 49
    strncpy((char */* __restrict  */)(p___2->name), (char const   */* __restrict  */)u___0->pw_name,
            (size_t )8);
#line 50
    p___2->name[8] = (char)0;
    }
  }
  {
#line 52
  p___2->uid = n;
#line 53
  tmp___0 = hash_fun___0(n);
#line 53
  p___2->next = hash_table___0[tmp___0];
#line 53
  tmp___1 = hash_fun___0(n);
#line 53
  hash_table___0[tmp___1] = p___2;
  }
#line 54
  return (p___2);
}
}
#line 57 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/owner.c"
char *get_owner_name(int u___0 ) 
{ 
  struct owner *p___2 ;

  {
  {
#line 60
  p___2 = find_by_uid(u___0);
  }
#line 61
  if (! p___2) {
    {
#line 61
    p___2 = new_owner(u___0);
    }
  }
#line 62
  return (p___2->name);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 809 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 68 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
unsigned long long ticks ;
#line 200
void eproc(void *p___2 ) ;
#line 201
void esys(void *unused ) ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
__inline static void no_info(void) 
{ 


  {
  {
#line 18
  println("Information unavailable.\n");
  }
#line 19
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static char buf___0[128]  ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
__inline static char *_read_link(char const   *path ) 
{ 
  ssize_t tmp ;

  {
  {
#line 24
  bzero((void *)(buf___0), sizeof(buf___0));
#line 25
  tmp = readlink((char const   */* __restrict  */)path, (char */* __restrict  */)(buf___0),
                 sizeof(buf___0));
  }
#line 25
  if (tmp == -1L) {
#line 26
    return ((char *)0);
  }
#line 27
  return (buf___0);
}
}
#line 30 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static void read_link(int pid___0 , char *name___0 ) 
{ 
  char *v ;
  char pbuf[32] ;

  {
  {
#line 34
  snprintf((char */* __restrict  */)(pbuf), sizeof(pbuf), (char const   */* __restrict  */)"/proc/%d/%s",
           pid___0, name___0);
#line 35
  v = _read_link((char const   *)(pbuf));
  }
#line 36
  if (! v) {
    {
#line 37
    no_info();
    }
#line 38
    return;
  }
  {
#line 40
  println((char const   *)v);
#line 41
  newln();
  }
#line 42
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static char *tcp_state[11]  = 
#line 53
  {      (char *)"TCP_ESTABILISHED",      (char *)"TCP_SYN_SENT",      (char *)"TCP_SYN_RECV",      (char *)"TCP_FIN_WAIT1", 
        (char *)"TCP_FIN_WAIT2",      (char *)"TCP_TIME_WAIT",      (char *)"TCP_CLOSE",      (char *)"TCP_CLOSE_WAIT", 
        (char *)"TCP_LAST_ACK",      (char *)"TCP_LISTEN",      (char *)"TCP_CLOSING"};
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 83 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct list_head tcp_l  =    {& tcp_l, & tcp_l};
#line 84 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct list_head tcp_blocks  =    {& tcp_blocks, & tcp_blocks};
#line 85 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct list_head tcp_hashtable[128]  ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static void hash_init(struct list_head *hash___0 ) 
{ 
  int i___0 ;

  {
#line 89
  i___0 = 128;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      hash___0->next = hash___0;
#line 91
      hash___0->prev = hash___0;
#line 91
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 92
    hash___0 ++;
#line 93
    i___0 --;
#line 90
    if (! i___0) {
#line 90
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
__inline static void add_to_hash(struct netconn_t *c___0 , int inode ) 
{ 
  int tmp ;

  {
  {
#line 100
  tmp = hash_fun(inode);
#line 100
  list_add(& c___0->n_hash, tcp_hashtable + tmp);
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct netconn_t *tcp_find(unsigned int inode , struct list_head *head ) 
{ 
  struct list_head *h ;
  struct list_head *tmp ;
  struct netconn_t *t ;
  int tmp___0 ;

  {
  {
#line 107
  tmp___0 = hash_fun((int )inode);
#line 107
  tmp = head + tmp___0;
#line 108
  h = tmp->next;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )h != (unsigned long )tmp)) {
#line 108
      goto while_break;
    }
#line 109
    t = (struct netconn_t *)((char *)h - (unsigned long )(& ((struct netconn_t *)0)->n_hash));
#line 110
    if (inode == t->inode) {
#line 111
      return (t);
    }
#line 108
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return ((struct netconn_t *)0);
}
}
#line 118 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct netconn_t *new_netconn(unsigned int inode , struct netconn_t *src ) 
{ 
  struct netconn_t *t ;
  void *tmp ;

  {
  {
#line 120
  t = (struct netconn_t *)0;
#line 121
  tmp = get_empty((int )sizeof(*t), & tcp_blocks);
#line 121
  t = (struct netconn_t *)tmp;
#line 122
  memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)src, sizeof(*t));
#line 124
  t->inode = inode;
#line 125
  add_to_hash(t, (int )inode);
#line 126
  list_add(& t->n_list, & tcp_l);
  }
#line 127
  return (t);
}
}
#line 130 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct netconn_t *validate(unsigned int inode , char *s ) 
{ 
  struct netconn_t t ;
  struct netconn_t *tmp ;
  int i___0 ;
  int offset ;
  int tmp___0 ;

  {
  {
#line 133
  offset = (int )((2UL * sizeof(struct list_head ) + sizeof(int )) + sizeof(short ));
#line 134
  bzero((void *)(& t), sizeof(t));
#line 135
  i___0 = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%x:%x %x:%x %x",
                 & t.s_addr, & t.s_port, & t.d_addr, & t.d_port, & t.state);
  }
#line 137
  if (i___0 != 5) {
#line 137
    return ((struct netconn_t *)0);
  }
  {
#line 138
  tmp = tcp_find(inode, tcp_hashtable);
  }
#line 139
  if (! tmp) {
    {
#line 141
    tmp = new_netconn(inode, & t);
    }
#line 142
    return (tmp);
  }
  {
#line 145
  tmp___0 = memcmp((void const   *)((char *)(& t) + offset), (void const   *)((char *)tmp + offset),
                   sizeof(t) - (unsigned long )offset);
  }
#line 145
  if (! tmp___0) {
#line 146
    return (tmp);
  }
  {
#line 150
  memcpy((void */* __restrict  */)((char *)(& t) + offset), (void const   */* __restrict  */)((char *)tmp + offset),
         sizeof(t) - (unsigned long )offset);
  }
#line 159
  return (tmp);
}
}
#line 171
static void read_tcp_conn(void) ;
#line 171 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static int flag  =    0;
#line 165 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static void read_tcp_conn(void) 
{ 
  FILE *f ;
  char buf___6[127] ;
  char *tmp ;
  int i___0 ;
  unsigned int inode ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 172
  return;
#line 173
  if (! flag) {
    {
#line 174
    hash_init(tcp_hashtable);
#line 175
    flag = 1;
    }
  }
  {
#line 177
  f = fopen((char const   */* __restrict  */)"/proc/net/tcp", (char const   */* __restrict  */)"r");
  }
#line 177
  if (! f) {
#line 177
    return;
  }
  {
#line 179
  tmp = fgets((char */* __restrict  */)(buf___6), (int )sizeof(buf___6), (FILE */* __restrict  */)f);
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 180
    tmp___3 = fgets((char */* __restrict  */)(buf___6), (int )sizeof(buf___6), (FILE */* __restrict  */)f);
    }
#line 180
    if (! tmp___3) {
#line 180
      goto while_break;
    }
    {
#line 181
    tmp___0 = strlen((char const   *)(buf___6));
#line 181
    i___0 = (int )(tmp___0 - 1UL);
#line 182
    tmp = buf___6 + i___0;
    }
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 182
      if ((int )*tmp == 32) {
#line 182
        if (! ((unsigned long )tmp > (unsigned long )(buf___6))) {
#line 182
          goto while_break___0;
        }
      } else {
#line 182
        goto while_break___0;
      }
#line 182
      tmp --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 183
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 183
      tmp___1 = __ctype_b_loc();
      }
#line 183
      if ((int const   )*(*tmp___1 + (int )*tmp) & 2048) {
#line 183
        if (! ((unsigned long )tmp > (unsigned long )(buf___6))) {
#line 183
          goto while_break___1;
        }
      } else {
#line 183
        goto while_break___1;
      }
#line 183
      tmp --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 184
    tmp ++;
#line 184
    tmp___2 = sscanf((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"%d",
                     & inode);
    }
#line 184
    if (tmp___2 != 1) {
#line 184
      goto while_continue;
    }
    {
#line 185
    tmp = strchr((char const   *)(buf___6), ':');
    }
#line 185
    if (! tmp) {
#line 185
      goto while_continue;
    }
    {
#line 186
    tmp += 2;
#line 187
    validate(inode, tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  fclose(f);
  }
#line 190
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static void print_net_conn(struct netconn_t *t ) 
{ 
  char buf___6[64] ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 200
  tmp = inet_ntoa(*((struct in_addr *)(& t->s_addr)));
#line 200
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"%s:%d",
           tmp, t->s_port);
#line 202
  boldon();
#line 203
  print((char const   *)(buf___6));
  }
#line 204
  if (t->d_addr) {
    {
#line 205
    tmp___0 = inet_ntoa(*((struct in_addr *)(& t->d_addr)));
#line 205
    print(" -> %s:%d", tmp___0, t->d_port);
    }
  }
  {
#line 206
  print(" %s", tcp_state[t->state - 1U]);
#line 207
  boldoff();
  }
#line 208
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static int show_net_conn(char *s ) 
{ 
  struct netconn_t *t ;
  unsigned int inode ;
  int tmp ;

  {
#line 213
  inode = 0U;
#line 214
  return (1);
  {
#line 215
  tmp = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%d",
               & inode);
  }
#line 215
  if (tmp != 1) {
#line 215
    return (1);
  }
  {
#line 216
  t = tcp_find(inode, tcp_hashtable);
  }
#line 217
  if (! t) {
#line 218
    return (0);
  }
  {
#line 220
  print_net_conn(t);
  }
#line 221
  return (1);
}
}
#line 248
void open_fds(int pid___0 , char *name___0 ) ;
#line 248 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static long long count  =    0LL;
#line 242 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
void open_fds(int pid___0 , char *name___0 ) 
{ 
  DIR *d ;
  char *s ;
  char buf___6[32] ;
  struct dirent *dn ;

  {
  {
#line 249
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"/proc/%d/fd",
           pid___0);
#line 250
  d = opendir((char const   *)(buf___6));
  }
#line 251
  if (! d) {
    {
#line 252
    no_info();
    }
#line 253
    return;
  }
#line 255
  if (! count) {
    {
#line 257
    read_tcp_conn();
#line 258
    count = (long long )ticks;
    }
  } else
#line 255
  if (ticks - (unsigned long long )count >= 2ULL) {
    {
#line 257
    read_tcp_conn();
#line 258
    count = (long long )ticks;
    }
  }
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 260
    dn = readdir(d);
    }
#line 260
    if (! dn) {
#line 260
      goto while_break;
    }
#line 261
    if ((int )dn->d_name[0] == 46) {
#line 261
      goto while_continue;
    }
    {
#line 262
    print("%s - ", dn->d_name);
#line 263
    snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"/proc/%d/fd/%s",
             pid___0, dn->d_name);
#line 264
    s = _read_link((char const   *)(buf___6));
    }
#line 265
    if (! s) {
      {
#line 265
      no_info();
      }
    } else {
      {
#line 269
      show_net_conn(s + 8);
#line 270
      println("%s", s);
#line 272
      newln();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  closedir(d);
  }
#line 276
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static int read_file_pos(char *name___0 , int pos ) 
{ 
  FILE *f ;
  int i___0 ;
  int c___0 ;

  {
  {
#line 286
  c___0 = 1;
#line 287
  f = fopen((char const   */* __restrict  */)name___0, (char const   */* __restrict  */)"r");
  }
#line 288
  if (! f) {
#line 288
    return (-1);
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 289
    i___0 = fgetc(f);
    }
#line 289
    if (! (i___0 != -1)) {
#line 289
      goto while_break;
    }
#line 290
    if (i___0 == 32) {
#line 290
      goto _L;
    } else
#line 290
    if (i___0 == 9) {
      _L: /* CIL Label */ 
#line 291
      c___0 ++;
      {
#line 292
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 292
        i___0 = fgetc(f);
        }
#line 292
        if (! (i___0 == 32)) {
#line 292
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 293
      ungetc(i___0, f);
      }
    }
#line 295
    if (c___0 == pos) {
#line 295
      goto FOUND;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  fclose(f);
  }
#line 298
  return (-1);
  FOUND: 
  {
#line 300
  i___0 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d",
                 & c___0);
#line 301
  fclose(f);
  }
#line 302
  if (i___0 != 1) {
#line 302
    return (-1);
  }
#line 303
  return (c___0);
}
}
#line 306 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static void read_proc_file(char *name___0 , char *start , char *end ) 
{ 
  char buf___6[128] ;
  int ok ;
  int slen ;
  int elen ;
  FILE *f ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 309
  ok = 0;
#line 312
  elen = 0;
#line 312
  slen = elen;
#line 313
  if (start) {
    {
#line 313
    tmp = strlen((char const   *)start);
#line 313
    slen = (int )tmp;
    }
  }
#line 314
  if (end) {
    {
#line 314
    tmp___0 = strlen((char const   *)end);
#line 314
    elen = (int )tmp___0;
    }
  }
  {
#line 315
  f = fopen((char const   */* __restrict  */)name___0, (char const   */* __restrict  */)"r");
  }
#line 316
  if (! f) {
    {
#line 317
    no_info();
    }
#line 318
    return;
  }
#line 320
  if (! start) {
#line 320
    ok = 1;
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 321
    tmp___3 = fgets((char */* __restrict  */)(buf___6), (int )sizeof(buf___6), (FILE */* __restrict  */)f);
    }
#line 321
    if (! tmp___3) {
#line 321
      goto while_break;
    }
#line 322
    if (! ok) {
      {
#line 322
      tmp___1 = strncmp((char const   *)(buf___6), (char const   *)start, (size_t )slen);
      }
#line 322
      if (! tmp___1) {
#line 322
        ok = 1;
      }
    }
#line 323
    if (end) {
      {
#line 323
      tmp___2 = strncmp((char const   *)(buf___6), (char const   *)end, (size_t )elen);
      }
#line 323
      if (! tmp___2) {
#line 323
        goto END;
      }
    }
#line 324
    if (! ok) {
#line 324
      goto while_continue;
    }
    {
#line 325
    println((char const   *)(buf___6));
    }
  }
  while_break: /* CIL Label */ ;
  }
  END: 
#line 329
  if (! ok) {
    {
#line 329
    no_info();
    }
  }
  {
#line 330
  fclose(f);
  }
#line 331
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static void read_meminfo(int pid___0 , char *name___0 ) 
{ 
  char buf___6[32] ;

  {
  {
#line 336
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"/proc/%d/status",
           pid___0);
#line 337
  read_proc_file(buf___6, (char *)"Uid", (char *)"VmLib");
  }
#line 338
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static unsigned long p_start_time(int pid___0 ) 
{ 
  char buf___6[32] ;
  FILE *f ;
  int i___0 ;
  unsigned long c___0 ;

  {
  {
#line 351
  c___0 = 0UL;
#line 352
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"/proc/%d/stat",
           pid___0);
#line 353
  f = fopen((char const   */* __restrict  */)(buf___6), (char const   */* __restrict  */)"r");
  }
#line 354
  if (! f) {
#line 354
    return (0xffffffffffffffffUL);
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 355
    i___0 = fgetc(f);
    }
#line 355
    if (! (i___0 != -1)) {
#line 355
      goto while_break;
    }
#line 356
    if (i___0 == 32) {
#line 356
      c___0 ++;
    }
#line 357
    if (c___0 == 21UL) {
#line 357
      goto FOUND;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 359
  fclose(f);
  }
#line 360
  return (0xffffffffffffffffUL);
  FOUND: 
  {
#line 362
  i___0 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld",
                 & c___0);
#line 363
  fclose(f);
  }
#line 364
  if (i___0 != 1) {
#line 364
    return (0xffffffffffffffffUL);
  }
#line 365
  return (c___0);
}
}
#line 372 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static time_t boot_time  ;
#line 369 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static time_t get_boot_time(void) 
{ 
  char buf___6[32] ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;

  {
#line 375
  if (boot_time) {
#line 375
    return (boot_time);
  }
  {
#line 376
  f = fopen((char const   */* __restrict  */)"/proc/stat", (char const   */* __restrict  */)"r");
  }
#line 376
  if (! f) {
#line 376
    return (boot_time);
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 377
    tmp___0 = fgets((char */* __restrict  */)(buf___6), (int )sizeof(buf___6), (FILE */* __restrict  */)f);
    }
#line 377
    if (! tmp___0) {
#line 377
      goto while_break;
    }
    {
#line 377
    tmp = strncmp((char const   *)(buf___6), "btime ", (size_t )6);
    }
#line 377
    if (! tmp) {
#line 377
      goto FOUND;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 378
  fclose(f);
  }
#line 379
  return (boot_time);
  FOUND: 
  {
#line 381
  fclose(f);
#line 382
  sscanf((char const   */* __restrict  */)(buf___6 + 5), (char const   */* __restrict  */)"%ld",
         & boot_time);
  }
#line 383
  return (boot_time);
}
}
#line 388 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static void proc_starttime(int pid___0 , char *name___0 ) 
{ 
  unsigned long i___0 ;
  unsigned long sec ;
  char *s ;
  time_t btime ;
  time_t tmp ;

  {
  {
#line 392
  tmp = get_boot_time();
#line 392
  btime = tmp;
#line 394
  i___0 = p_start_time(pid___0);
  }
#line 395
  if (i___0 == 0xffffffffffffffffUL) {
    {
#line 396
    no_info();
    }
#line 397
    return;
  } else
#line 395
  if (! btime) {
    {
#line 396
    no_info();
    }
#line 397
    return;
  }
  {
#line 399
  sec = (unsigned long )btime + i___0 / 100UL;
#line 400
  s = ctime((time_t const   *)(& sec));
#line 401
  print("%s", s);
  }
#line 402
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
struct proc_detail_t proc_details_t[6]  = {      {(char *)"START: ", & proc_starttime, 0, (char *)0}, 
        {(char *)"EXE: ", & read_link, 0, (char *)"exe"}, 
        {(char *)"ROOT: ", & read_link, 0, (char *)"root"}, 
        {(char *)"CWD: ", & read_link, 0, (char *)"cwd"}, 
        {(char *)"\nSTATUS:\n", & read_meminfo, 2, (char *)0}, 
        {(char *)"\nFILE DESCRIPTORS:\n", & open_fds, 2, (char *)0}};
#line 421 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
void eproc(void *p___2 ) 
{ 
  int i___0 ;
  int pid___0 ;
  u32 tmp ;
  struct proc_detail_t *t ;
  int size ;

  {
#line 424
  if (! p___2) {
#line 424
    tmp = (u32 )1;
  } else {
#line 424
    tmp = *((u32 *)p___2);
  }
  {
#line 424
  pid___0 = (int )tmp;
#line 427
  plgn_out_start();
#line 429
  size = (int )(sizeof(proc_details_t) / sizeof(struct proc_detail_t ));
#line 430
  i___0 = 0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! (i___0 < size)) {
#line 430
      goto while_break;
    }
    {
#line 431
    t = & proc_details_t[i___0];
#line 432
    title("%s", t->title);
#line 433
    (*(t->fn))(pid___0, t->name);
#line 430
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
__inline static void print_boot_time(void) 
{ 
  time_t btime ;
  time_t tmp ;
  char *tmp___0 ;

  {
  {
#line 439
  tmp = get_boot_time();
#line 439
  btime = tmp;
  }
#line 440
  if (btime) {
    {
#line 440
    tmp___0 = ctime((time_t const   *)(& btime));
#line 440
    print("%s", tmp___0);
    }
  } else {
    {
#line 441
    no_info();
    }
  }
#line 442
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct cpu_info_t c_info  ;
#line 448 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct cpu_info_t p_info  ;
#line 448 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct cpu_info_t eff_info  ;
#line 449 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct cpu_info_t *cur_cpu_info  =    & c_info;
#line 450 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static struct cpu_info_t *prev_cpu_info  =    & p_info;
#line 456 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static int fill_cpu_info(void) 
{ 
  char buf___6[64] ;
  FILE *f ;
  struct cpu_info_t *tmp ;
  int i___0 ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 461
  i___0 = 0;
#line 462
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"/proc/stat");
#line 463
  f = fopen((char const   */* __restrict  */)(buf___6), (char const   */* __restrict  */)"r");
  }
#line 464
  if (! f) {
#line 464
    return (-1);
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 465
    tmp___1 = fgets((char */* __restrict  */)(buf___6), (int )sizeof(buf___6), (FILE */* __restrict  */)f);
    }
#line 465
    if (! tmp___1) {
#line 465
      goto while_break;
    }
    {
#line 466
    tmp___0 = strncmp((char const   *)(buf___6), "cpu  ", (size_t )5);
    }
#line 466
    if (! tmp___0) {
#line 466
      goto FOUND;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 467
  fclose(f);
  }
#line 468
  return (-1);
  FOUND: 
  {
#line 470
  tmp = prev_cpu_info;
#line 471
  prev_cpu_info = cur_cpu_info;
#line 472
  cur_cpu_info = tmp;
#line 473
  i___0 = sscanf((char const   */* __restrict  */)(buf___6 + 5), (char const   */* __restrict  */)"%lld %lld %lld %lld",
                 & tmp->u_mode, & tmp->nice, & tmp->s_mode, & tmp->idle);
#line 475
  fclose(f);
  }
#line 476
  if (i___0 != 4) {
#line 476
    return (-1);
  }
#line 477
  eff_info.u_mode = cur_cpu_info->u_mode - prev_cpu_info->u_mode;
#line 478
  eff_info.nice = cur_cpu_info->nice - prev_cpu_info->nice;
#line 479
  eff_info.s_mode = cur_cpu_info->s_mode - prev_cpu_info->s_mode;
#line 480
  eff_info.idle = cur_cpu_info->idle - prev_cpu_info->idle;
#line 481
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
__inline static float prcnt(unsigned long i___0 , unsigned long v ) 
{ 


  {
#line 486
  if (! v) {
#line 486
    return ((float )0);
  }
#line 487
  return ((float )(i___0 * 100UL) / (float )v);
}
}
#line 494 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
static void get_cpu_info(void) 
{ 
  char buf___6[64] ;
  unsigned long z ;
  int tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;

  {
  {
#line 498
  tmp = fill_cpu_info();
  }
#line 498
  if (tmp == -1) {
    {
#line 498
    no_info();
    }
  }
  {
#line 499
  z = (unsigned long )(((eff_info.u_mode + eff_info.nice) + eff_info.s_mode) + eff_info.idle);
#line 500
  tmp___0 = prcnt((unsigned long )eff_info.idle, z);
#line 500
  tmp___1 = prcnt((unsigned long )eff_info.nice, z);
#line 500
  tmp___2 = prcnt((unsigned long )eff_info.s_mode, z);
#line 500
  tmp___3 = prcnt((unsigned long )eff_info.u_mode, z);
#line 500
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"%.1f%% user %.1f%% sys %.1f%% nice %.1f%% idle\n",
           (double )tmp___3, (double )tmp___2, (double )tmp___1, (double )tmp___0);
#line 506
  print("%s", buf___6);
  }
#line 507
  return;
}
}
#line 509 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/proc_plugin.c"
void esys(void *unused ) 
{ 
  int c___0 ;

  {
  {
#line 512
  plgn_out_start();
#line 514
  title("BOOT TIME: ");
#line 515
  print_boot_time();
#line 516
  title("CPU: ");
#line 517
  get_cpu_info();
#line 518
  title("MEMORY:");
#line 518
  newln();
#line 519
  read_proc_file((char *)"/proc/meminfo", (char *)"MemTotal:", (char *)0);
#line 520
  title("USED FILES: ");
#line 522
  c___0 = read_file_pos((char *)"/proc/sys/fs/file-nr", 2);
  }
#line 523
  if (c___0 == -1) {
    {
#line 523
    no_info();
    }
  } else {
    {
#line 524
    println("%d", c___0);
    }
  }
  {
#line 525
  title("\nUSED INODES: ");
#line 527
  c___0 = read_file_pos((char *)"/proc/sys/fs/inode-nr", 2);
  }
#line 528
  if (c___0 == -1) {
    {
#line 528
    no_info();
    }
  } else {
    {
#line 529
    println("%d", c___0);
    }
  }
  {
#line 531
  title("\nMAX FILES: ");
#line 532
  read_proc_file((char *)"/proc/sys/fs/file-max", (char *)0, (char *)0);
#line 533
  title("MAX INODES: ");
#line 534
  read_proc_file((char *)"/proc/sys/fs/inode-max", (char *)0, (char *)0);
#line 535
  title("\nSTAT:");
#line 535
  newln();
#line 537
  read_proc_file((char *)"/proc/stat", (char *)"cpu", (char *)"intr");
#line 538
  title("\nLOADED MODULES:");
#line 538
  newln();
#line 540
  read_proc_file((char *)"/proc/modules", (char *)0, (char *)0);
#line 541
  title("\nFILESYSTEMS:");
#line 541
  newln();
#line 543
  read_proc_file((char *)"/proc/filesystems", (char *)0, (char *)0);
#line 544
  title("\nPARTITIONS:");
#line 544
  newln();
#line 546
  read_proc_file((char *)"/proc/partitions", (char *)0, (char *)0);
#line 547
  title("\nDEVICES:\n");
#line 547
  newln();
#line 549
  read_proc_file((char *)"/proc/devices", (char *)0, (char *)0);
  }
#line 550
  return;
}
}
#line 806 "/usr/include/curses.h"
extern int wdelch(WINDOW * ) ;
#line 814
extern chtype winch(WINDOW * ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 122 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
void *wmsg_send(struct wdgt *sndr , int type , void *data ) ;
#line 149
void hlp_reg(struct wdgt *w ) ;
#line 150
void input_reg(struct wdgt *w ) ;
#line 155
char *proc_ucount(void) ;
#line 186
int proc_getloadavg(double *d , int l ) ;
#line 207
__inline int reg_match(char const   *s ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static regex_t cur_reg  ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
__inline int reg_match(char const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 13
  tmp = regexec((regex_t const   */* __restrict  */)(& cur_reg), (char const   */* __restrict  */)s,
                (size_t )0, (regmatch_t */* __restrict  */)0, 1 << 1);
  }
#line 13
  if (tmp) {
#line 13
    tmp___0 = 0;
  } else {
#line 13
    tmp___0 = 1;
  }
#line 13
  return (tmp___0);
}
}
#line 20 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static char errbuf[64]  ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static int do_search(struct wdgt *w , char *s , int type ) 
{ 
  int err___0 ;
  void *ret ;

  {
  {
#line 22
  err___0 = regcomp((regex_t */* __restrict  */)(& cur_reg), (char const   */* __restrict  */)s,
                    (1 | (1 << 1)) | (((1 << 1) << 1) << 1));
  }
#line 23
  if (err___0) {
    {
#line 24
    regerror(err___0, (regex_t const   */* __restrict  */)(& cur_reg), (char */* __restrict  */)(errbuf),
             sizeof(errbuf));
    }
#line 26
    return (0);
  }
  {
#line 28
  ret = wmsg_send(w, 9, (void *)type);
#line 29
  regfree(& cur_reg);
  }
#line 30
  return ((int )((intptr_t )ret));
}
}
#line 33 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static char *cur_hlp  ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static void hlp_wrefresh(struct wdgt *w ) 
{ 


  {
  {
#line 36
  pnoutrefresh((WINDOW *)w->wd, 0, 0, (int )(w->mwin)->sy, 0, (int )(w->mwin)->sy,
               (int )(w->mwin)->sx);
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static void hlp_redraw(struct wdgt *w ) 
{ 


  {
  {
#line 42
  scr_addfstr(w, cur_hlp, (u32 )0, (u32 )0);
  }
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static void *hlp_msgh(struct wdgt *w , int type , struct wdgt *sndr , void *s ) 
{ 


  {
#line 47
  if (type != 3) {
#line 47
    return ((void *)0);
  }
#line 48
  w->flags = (u8 )((int )w->flags | 4);
#line 49
  cur_hlp = (char *)s;
#line 49
  return ((void *)cur_hlp);
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
void hlp_reg(struct wdgt *w ) 
{ 


  {
#line 54
  w->wrefresh = & hlp_wrefresh;
#line 55
  w->redraw = & hlp_redraw;
#line 56
  w->msgh = & hlp_msgh;
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static u32 cx  ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static u32 cxs  ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static u32 nc  ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static u32 stype  ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static char *hint  =    (char *)"Find: ";
#line 62 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static void ihide(struct wdgt *w ) 
{ 


  {
  {
#line 64
  w->wrefresh = (void (*)(struct wdgt * ))0;
#line 65
  w->redraw = (void (*)(struct wdgt * ))0;
#line 66
  curs_set(0);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static void ido_search(struct wdgt *w , int type ) 
{ 
  int i___0 ;
  chtype tmp___0 ;
  chtype tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 73
  i___0 = 0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((u32 )i___0 < cx - cxs)) {
#line 73
      goto while_break;
    }
    {
#line 74
    tmp___2 = wmove((WINDOW *)w->wd, 0, (int )((u32 )i___0 + cxs));
    }
#line 74
    if (tmp___2 == -1) {
#line 74
      tmp___1 = (chtype )-1;
    } else {
      {
#line 74
      tmp___0 = winch((WINDOW *)w->wd);
#line 74
      tmp___1 = tmp___0;
      }
    }
#line 74
    (w->mwin)->gbuf[i___0] = (u8 )(tmp___1 & ((1UL << 8) - 1UL));
#line 73
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  (w->mwin)->gbuf[i___0] = (u8 )0;
#line 78
  tmp___3 = do_search(w, (char *)((w->mwin)->gbuf), type);
  }
#line 78
  if (tmp___3 == 2) {
#line 78
    if (! type) {
      {
#line 79
      do_search(w, (char *)((w->mwin)->gbuf), 2);
#line 80
      stype = (u32 )2;
      }
    }
  }
  {
#line 82
  wmove((WINDOW *)w->wd, 0, (int )cx);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static void inpt_rfr(struct wdgt *w ) 
{ 


  {
  {
#line 87
  pnoutrefresh((WINDOW *)w->wd, 0, 0, (int )(w->mwin)->sy, 0, (int )(w->mwin)->sy,
               (int )(w->mwin)->sx);
  }
#line 88
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static void input_unhide(struct wdgt *w ) 
{ 


  {
  {
#line 92
  curs_set(1);
#line 93
  w->wrefresh = & inpt_rfr;
#line 94
  nc = (u32 )0;
  }
#line 95
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static int ikbd(struct wdgt *w , int key ) 
{ 
  int tmp ;
  u32 tmp___0 ;

  {
#line 99
  if (key == 257) {
#line 100
    if (cx == cxs) {
#line 100
      return (2);
    }
    {
#line 101
    cx --;
#line 101
    tmp = wmove((WINDOW *)w->wd, 0, (int )cx);
    }
#line 101
    if (! (tmp == -1)) {
      {
#line 101
      wdelch((WINDOW *)w->wd);
      }
    }
#line 103
    return (2);
  }
#line 105
  if (! ((key & -128) == 0)) {
#line 105
    return (0);
  }
#line 106
  tmp___0 = nc;
#line 106
  nc ++;
#line 106
  if (! tmp___0) {
    {
#line 107
    cx = cxs;
#line 108
    wmove((WINDOW *)w->wd, 0, (int )cx);
#line 109
    wclrtoeol((WINDOW *)w->wd);
    }
  }
  {
#line 111
  waddch((WINDOW *)w->wd, (chtype const   )key);
#line 112
  cx ++;
#line 115
  ido_search(w, 1);
  }
#line 116
  return (2);
}
}
#line 119 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static int ikeyh(struct wdgt *w , int key ) 
{ 
  int tmp ;

  {
#line 121
  if (! w->wrefresh) {
#line 122
    if (key == 47) {
      {
#line 123
      input_unhide(w);
      }
#line 124
      return (2);
    }
#line 126
    return (0);
  }
  {
#line 129
  if (key == 259) {
#line 129
    goto case_259;
  }
#line 131
  if (key == 256) {
#line 131
    goto case_256;
  }
#line 136
  goto switch_default;
  case_259: /* CIL Label */ 
  {
#line 129
  ihide(w);
  }
#line 129
  goto switch_break;
  case_256: /* CIL Label */ 
#line 131
  if (cx != cxs) {
    {
#line 133
    ido_search(w, 0);
    }
  }
#line 135
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 136
  tmp = ikbd(w, key);
  }
#line 136
  return (tmp);
  switch_break: /* CIL Label */ ;
  }
#line 138
  return (2);
}
}
#line 141 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
void input_reg(struct wdgt *w ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 143
  w->keyh = & ikeyh;
#line 144
  tmp = strlen((char const   *)hint);
#line 144
  cxs = (u32 )tmp;
#line 144
  cx = cxs;
#line 145
  tmp___0 = strlen((char const   *)hint);
#line 145
  scr_maddstr(w, hint, (u32 )0, (u32 )0, (u32 )(tmp___0 + 1UL));
  }
#line 146
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static char buf___1[32]  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static char *get_load(void) 
{ 
  double d[3] ;
  int tmp ;

  {
  {
#line 152
  d[0] = (double )0;
#line 152
  d[1] = (double )0;
#line 152
  d[2] = (double )0;
#line 155
  tmp = proc_getloadavg(d, 3);
  }
#line 155
  if (tmp == -1) {
#line 155
    return ((char *)"");
  }
  {
#line 156
  snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"load: %.2f, %.2f, %.2f",
           d[0], d[1], d[2]);
  }
#line 157
  return (buf___1);
}
}
#line 160 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static void *infomsg(struct wdgt *w , int type , struct wdgt *s , void *d ) 
{ 
  size_t tmp ;

  {
#line 162
  if (type != 8) {
#line 162
    return ((void *)0);
  }
#line 163
  if (! d) {
    {
#line 164
    wmove((WINDOW *)w->wd, 1, 0);
#line 165
    wclrtoeol((WINDOW *)w->wd);
#line 166
    scr_wrefresh(w);
    }
#line 167
    return ((void *)1);
  }
  {
#line 169
  scr_attr_set(w, (int )(1UL << 21));
#line 170
  tmp = strlen((char const   *)d);
#line 170
  scr_maddstr(w, (char *)d, (u32 )1, w->x, (u32 )(tmp + 1UL));
#line 171
  scr_attr_set(w, 0);
#line 172
  scr_wrefresh(w);
  }
#line 173
  return ((void *)1);
}
}
#line 176 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
static void infopr(struct wdgt *w ) 
{ 
  char *s ;
  int n ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 180
  s = get_load();
#line 181
  tmp = strlen((char const   *)s);
#line 181
  n = (int )tmp;
#line 182
  scr_werase(w);
#line 183
  tmp___0 = proc_ucount();
#line 183
  scr_addfstr(w, tmp___0, (u32 )0, (u32 )0);
#line 184
  scr_maddstr(w, s, (u32 )0, (w->xsize - (u32 )n) + 1U, (u32 )n);
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/wdgts.c"
void info_reg(struct wdgt *w ) 
{ 


  {
#line 189
  w->periodic = & infopr;
#line 190
  w->wrefresh = & scr_wrefresh;
#line 191
  w->msgh = & infomsg;
#line 193
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int csitbl[63]  = 
#line 13 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
  {      264,      262,      263,      261, 
        260,      272,      267,      269, 
        266,      268,      273,      265, 
        264,      288,      289,      290, 
        291,      292,      293,      294, 
        295,      296,      297,      298, 
        299,      266,      4354,      0, 
        0,      0,      0,      0, 
        0,      4358,      4359,      4357, 
        4356,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      275,      274};
#line 22 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int ss3tbl[58]  = 
#line 22
  {      0,      262,      263,      261, 
        260,      0,      0,      0, 
        0,      258,      0,      0, 
        0,      256,      0,      0, 
        288,      289,      290,      291, 
        0,      0,      0,      0, 
        '=',      0,      0,      0, 
        0,      0,      0,      0, 
        0,      16646,      16647,      16645, 
        16644,      0,      0,      0, 
        0,      0,      '*',      '+', 
        ',',      '-',      '.',      '/', 
        '0',      '1',      '2',      '3', 
        '4',      '5',      '6',      '7', 
        '8',      '9'};
#line 29 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int csi_tilde[33]  = 
#line 29
  {      0,      266,      264,      265, 
        267,      268,      269,      288, 
        289,      290,      291,      288, 
        289,      290,      291,      292, 
        292,      293,      294,      295, 
        296,      297,      0,      298, 
        299,      300,      301,      302, 
        303,      304,      305,      306, 
        307};
#line 37 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int csi_z[58]  = 
#line 37
  {      298,      299,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      266,      0, 
        268,      0,      272,      0, 
        267,      0,      269,      0, 
        288,      289,      290,      291, 
        292,      293,      294,      295, 
        296,      297,      298,      299, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      264, 
        0,      265};
#line 44
static int st_start(int c___0 ) ;
#line 45
static int st_esc(int c___0 ) ;
#line 46
static int st_csiss3(int c___0 ) ;
#line 47
static int st_arg(int c___0 ) ;
#line 48
static int st_mouse(int c___0 ) ;
#line 50 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int (*state)(int  )  =    & st_start;
#line 52 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
struct seq seq  =    {(char)0, (char)0, (char)0, (char)0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                         0, 0}, seq.arg};
#line 60 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int lowtbl[32]  = 
#line 60
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        257,      258,      4352,      0, 
        0,      256,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      259};
#line 65 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int ordkey(int c___0 ) 
{ 
  int k ;

  {
#line 67
  k = c___0;
#line 68
  if (c___0 < 32) {
#line 69
    if (c___0 == 8) {
#line 69
      seq.delf = (char)1;
    }
#line 70
    k = lowtbl[c___0];
  } else
#line 71
  if (c___0 >= 127) {
#line 71
    if (c___0 < 160) {
#line 72
      k = 0;
#line 73
      if (c___0 == 127) {
#line 74
        if (seq.delf) {
#line 74
          k = 265;
        } else {
#line 74
          k = 257;
        }
      }
    }
  }
#line 76
  return (k);
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int st_start(int c___0 ) 
{ 
  int k ;
  int m___0 ;

  {
#line 82
  if (c___0 == 27) {
#line 82
    goto _L;
  } else
#line 82
  if (c___0 == 155) {
#line 82
    goto _L;
  } else
#line 82
  if (c___0 == 143) {
    _L: /* CIL Label */ 
#line 83
    seq.mod = (char)0;
#line 83
    seq.type = seq.mod;
#line 84
    seq.argp = seq.arg;
#line 85
    seq.arg[0] = 0;
#line 86
    seq.arg[1] = 0;
#line 87
    seq.argf = (char)0;
#line 89
    state = & st_esc;
#line 90
    if (c___0 & 128) {
#line 91
      seq.type = (char )(c___0 - 64);
#line 92
      state = & st_csiss3;
    }
#line 94
    return (-1);
  }
  {
#line 96
  k = ordkey(c___0);
  }
#line 97
  if (! k) {
#line 98
    m___0 = 16384;
#line 99
    c___0 ^= 64;
#line 100
    if (c___0 >= 128) {
#line 101
      c___0 ^= 192;
#line 102
      m___0 ^= 24576;
    }
    {
#line 104
    k = ordkey(c___0);
    }
#line 105
    if (k) {
#line 105
      k |= m___0;
    }
  }
#line 107
  return (k);
}
}
#line 110 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int st_esc(int c___0 ) 
{ 


  {
#line 112
  if (c___0 == -1) {
#line 113
    return (-3);
  }
#line 114
  if (c___0 == 91) {
#line 115
    seq.type = (char )c___0;
#line 116
    state = & st_csiss3;
#line 117
    return (-1);
  } else
#line 114
  if (c___0 == 79) {
#line 115
    seq.type = (char )c___0;
#line 116
    state = & st_csiss3;
#line 117
    return (-1);
  }
#line 119
  if (c___0 == 27) {
#line 120
    if (seq.mod) {
#line 121
      return (-3);
    }
#line 122
    seq.mod = (char )c___0;
#line 123
    return (-1);
  }
  {
#line 126
  c___0 = ordkey(c___0);
  }
#line 127
  if (c___0) {
#line 127
    c___0 |= 8192;
  }
#line 128
  return (c___0);
}
}
#line 131 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int csiss3(int c___0 ) 
{ 
  int m___0 ;
  int v ;
  unsigned int a ;

  {
#line 133
  m___0 = seq.arg[0];
#line 133
  v = 0;
#line 135
  if ((int )seq.type == 79) {
#line 136
    c___0 -= 64;
#line 137
    if ((unsigned long )c___0 < sizeof(ss3tbl) / sizeof(ss3tbl[0])) {
#line 138
      v = ss3tbl[c___0];
    }
#line 139
    goto ready;
  }
#line 141
  if ((int )seq.mod == 91) {
#line 142
    c___0 -= 65;
#line 143
    if (c___0 < 12) {
#line 144
      v = 288 + c___0;
    }
#line 145
    goto ready;
  }
#line 147
  if ((int )seq.mod == 63) {
#line 148
    if (c___0 == 99) {
#line 149
      v = 2305;
#line 150
      goto inclarg;
    }
#line 152
    goto ret;
  }
#line 154
  if (seq.argf) {
#line 154
    if (c___0 == 126) {
#line 154
      goto _L;
    } else
#line 154
    if (c___0 == 36) {
#line 154
      goto _L;
    } else
#line 154
    if (c___0 == 94) {
#line 154
      goto _L;
    } else
#line 154
    if (c___0 == 64) {
      _L: /* CIL Label */ 
#line 155
      if ((unsigned long )seq.arg[0] >= sizeof(csi_tilde) / sizeof(csi_tilde[0])) {
#line 156
        goto ret;
      }
#line 157
      v = csi_tilde[seq.arg[0]];
#line 158
      if (! v) {
#line 158
        goto ret;
      }
#line 159
      seq.delf = (char)0;
#line 160
      if (c___0 != 126) {
#line 161
        if (c___0 != 94) {
#line 161
          v |= 4096;
        }
#line 162
        if (c___0 != 36) {
#line 162
          v |= 16384;
        }
      }
#line 164
      m___0 = seq.arg[1];
#line 165
      goto ready;
    }
  }
#line 167
  if (c___0 == 122) {
#line 168
    a = (unsigned int )seq.arg[0];
#line 169
    if ((unsigned long )a < sizeof(csi_tilde) / sizeof(csi_tilde[0])) {
#line 170
      v = csi_tilde[a];
    } else {
#line 172
      a -= 192U;
#line 173
      if ((unsigned long )a >= sizeof(csi_z) / sizeof(csi_z[0])) {
#line 174
        goto ret;
      }
#line 175
      v = csi_z[a];
    }
#line 177
    m___0 = seq.arg[1];
#line 178
    goto ready;
  }
#line 180
  if (c___0 == 82) {
#line 180
    if ((unsigned long )seq.argp == (unsigned long )(seq.arg + 1)) {
#line 181
      v = 2304;
      inclarg: 
#line 183
      v |= (seq.arg[0] << 16) | (seq.arg[1] << 24);
#line 184
      goto ret;
    }
  }
#line 186
  if (c___0 == 116) {
#line 187
    v = 2560;
#line 188
    v |= seq.arg[0] & 255;
#line 189
    v |= seq.arg[1] << 16;
#line 190
    if ((unsigned long )seq.argp > (unsigned long )(seq.arg + 1)) {
#line 191
      v |= seq.arg[2] << 24;
    }
#line 192
    goto ret;
  }
#line 195
  c___0 -= 64;
#line 196
  if ((unsigned long )c___0 < sizeof(csitbl) / sizeof(csitbl[0])) {
#line 197
    v = csitbl[c___0];
  }
  ready: 
#line 199
  if (m___0) {
#line 199
    m___0 = ((m___0 - 1) & 7) << 12;
  }
#line 200
  if ((int )seq.mod == 27) {
#line 200
    m___0 |= 8192;
  }
#line 201
  v |= m___0;
  ret: 
#line 203
  return (v);
}
}
#line 206 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int st_csiss3(int c___0 ) 
{ 
  int tmp ;

  {
#line 208
  if (c___0 == -1) {
#line 209
    return (-3);
  } else
#line 208
  if (c___0 < 32) {
#line 209
    return (-3);
  }
#line 210
  if (c___0 == 91) {
#line 210
    goto _L;
  } else
#line 210
  if (c___0 == 63) {
    _L: /* CIL Label */ 
#line 210
    if ((int )seq.type == 91) {
#line 211
      if (seq.mod) {
#line 211
        return (-3);
      }
#line 212
      seq.mod = (char )c___0;
#line 213
      return (-1);
    }
  }
#line 215
  if (c___0 >= 48) {
#line 215
    if (c___0 <= 57) {
#line 216
      seq.arg[0] = c___0 - 48;
#line 217
      goto goarg;
    }
  }
#line 219
  if (c___0 == 59) {
#line 220
    (seq.argp) ++;
#line 220
    *(seq.argp) = 0;
    goarg: 
#line 222
    seq.argf = (char)1;
#line 223
    state = & st_arg;
#line 224
    return (-1);
  }
#line 226
  if (c___0 == 77) {
#line 226
    if ((int )seq.type == 91) {
#line 227
      state = & st_mouse;
#line 228
      return (-1);
    }
  }
  {
#line 230
  tmp = csiss3(c___0);
  }
#line 230
  return (tmp);
}
}
#line 233 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int st_arg(int c___0 ) 
{ 
  int tmp ;

  {
#line 235
  if (c___0 == -1) {
#line 236
    return (-3);
  }
#line 237
  if (c___0 >= 48) {
#line 237
    if (c___0 <= 57) {
#line 238
      *(seq.argp) = (10 * *(seq.argp) + c___0) - 48;
#line 239
      return (-1);
    }
  }
#line 241
  if (c___0 == 59) {
#line 242
    (seq.argp) ++;
#line 242
    if ((unsigned long )seq.argp >= (unsigned long )(seq.arg + sizeof(seq.arg) / sizeof(seq.arg[0]))) {
#line 243
      return (0);
    }
#line 244
    *(seq.argp) = 0;
#line 245
    return (-1);
  }
  {
#line 248
  tmp = csiss3(c___0);
  }
#line 248
  return (tmp);
}
}
#line 251 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int st_mouse(int c___0 ) 
{ 
  int *tmp ;

  {
#line 253
  if (c___0 == -1) {
#line 254
    return (-3);
  }
#line 255
  tmp = seq.argp;
#line 255
  (seq.argp) ++;
#line 255
  *tmp = c___0 - 32;
#line 256
  if ((unsigned long )seq.argp < (unsigned long )(seq.arg + 3)) {
#line 257
    return (-1);
  }
#line 259
  return (2048 + (((((seq.arg[0] & 3) | (seq.arg[1] << 16)) | (seq.arg[2] << 24)) | (seq.arg[0] << 10)) & 61440));
}
}
#line 264 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int waitdata  ;
#line 265 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static u8 buf___2[20]  ;
#line 265 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static u8 *p  =    buf___2;
#line 265 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static u8 *e  =    buf___2;
#line 267 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
static int incomplete(void) 
{ 
  int l ;
  u8 *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u8 *tmp___3 ;
  int tmp___4 ;
  u8 *tmp___5 ;
  int tmp___6 ;

  {
#line 269
  l = (int )(e - buf___2);
#line 270
  p = buf___2;
#line 272
  if (l == 1) {
    {
#line 273
    tmp = p;
#line 273
    p ++;
#line 273
    tmp___0 = ordkey((int )*tmp);
    }
#line 273
    return (tmp___0);
  }
#line 274
  if ((unsigned long )l < sizeof(buf___2)) {
#line 274
    buf___2[l] = (u8 )0;
  }
  {
#line 275
  tmp___2 = memcmp((void const   *)p, (void const   *)"\033[M", (size_t )3);
  }
#line 275
  if (tmp___2) {
    {
#line 278
    tmp___1 = memcmp((void const   *)p, (void const   *)"\000x9BM", (size_t )2);
    }
#line 278
    if (! tmp___1) {
#line 279
      p += 2;
#line 280
      return (288);
    }
  } else {
#line 276
    p += 3;
#line 277
    return (288);
  }
#line 282
  tmp___5 = p;
#line 282
  p ++;
#line 282
  if ((int )*tmp___5 == 27) {
    {
#line 283
    tmp___3 = p;
#line 283
    p ++;
#line 283
    tmp___4 = ordkey((int )*tmp___3);
    }
#line 283
    return (tmp___4 | 8192);
  }
  {
#line 284
  tmp___6 = ordkey((int )*(p + -1));
  }
#line 284
  return (tmp___6);
}
}
#line 287 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c"
int getkey(void) 
{ 
  int v ;
  int c___0 ;
  int l ;
  ssize_t tmp ;
  int tmp___0 ;
  u8 *tmp___1 ;
  char *q ;
  char *tmp___2 ;
  u8 *tmp___3 ;

  {
  again: 
#line 292
  if ((unsigned long )p == (unsigned long )e) {
#line 293
    l = (int )((buf___2 + sizeof(buf___2) / sizeof(buf___2[0])) - p);
#line 294
    if (l == 0) {
#line 294
      goto nomore;
    }
    {
#line 295
    tmp = read(0, (void *)p, (size_t )l);
#line 295
    v = (int )tmp;
    }
#line 296
    if (v <= 0) {
#line 297
      if (waitdata) {
        nomore: 
#line 299
        c___0 = -1;
#line 300
        goto key;
      }
#line 302
      if (v < 0) {
#line 302
        tmp___0 = 0;
      } else {
#line 302
        tmp___0 = -2;
      }
#line 302
      return (tmp___0);
    }
#line 304
    e = p + v;
  }
#line 306
  tmp___1 = p;
#line 306
  p ++;
#line 306
  c___0 = (int )*tmp___1;
  key: 
  {
#line 308
  v = (*state)(c___0);
  }
#line 309
  if (v == -3) {
    {
#line 310
    v = incomplete();
    }
  }
#line 311
  if (! (c___0 >= 0)) {
#line 311
    if (! (v >= 0)) {
      {
#line 311
      __assert_fail("c >= 0 || v >= 0", "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/kbd.c",
                    311U, "getkey");
      }
    }
  }
#line 312
  if (v < 0) {
#line 313
    if ((unsigned long )p < (unsigned long )e) {
#line 314
      goto again;
    }
#line 315
    waitdata = 1;
#line 316
    return (-1);
  }
#line 318
  waitdata = 0;
#line 321
  q = (char *)(buf___2);
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! ((unsigned long )p < (unsigned long )e)) {
#line 322
      goto while_break;
    }
#line 322
    tmp___2 = q;
#line 322
    q ++;
#line 322
    tmp___3 = p;
#line 322
    p ++;
#line 322
    *tmp___2 = (char )*tmp___3;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  e = (u8 *)q;
#line 324
  p = buf___2;
#line 327
  state = & st_start;
#line 328
  if (! (v & 4095)) {
#line 328
    goto again;
  }
#line 330
  return (v);
}
}
#line 951 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) getloadavg)(double *__loadavg ,
                                                                                                 int __nelem ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 178 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
char *get_cmdline(int pid___0 ) ;
#line 179
int get_ppid(int pid___0 ) ;
#line 180
char *get_name(int pid___0 ) ;
#line 181
char *get_w(int pid___0 ) ;
#line 183
char *count_idle(char *tty ) ;
#line 184
int proc_pid_uid(u32 pid___0 ) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
void get_info(int pid___0 , struct procinfo *p___2 ) 
{ 
  char buf___6[32] ;
  FILE *f ;
  int tmp ;

  {
  {
#line 35
  p___2->ppid = -1;
#line 36
  p___2->cterm = -1;
#line 41
  p___2->euid = -1;
#line 42
  p___2->stat = (char )' ';
#line 43
  p___2->tpgid = -1;
#line 44
  strcpy((char */* __restrict  */)(p___2->exec_file), (char const   */* __restrict  */)"can\'t access");
#line 45
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"/proc/%d/stat",
           pid___0);
#line 46
  f = fopen((char const   */* __restrict  */)(buf___6), (char const   */* __restrict  */)"rt");
  }
#line 46
  if (! f) {
#line 47
    return;
  }
  {
#line 48
  tmp = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%*d %128s %*c %d %*d %*d %*d %d",
               p___2->exec_file, & p___2->ppid, & p___2->tpgid);
  }
#line 48
  if (tmp != 3) {
    {
#line 50
    fclose(f);
    }
#line 51
    return;
  }
  {
#line 53
  fclose(f);
#line 54
  p___2->exec_file[128] = (char )'\000';
  }
#line 55
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
static struct procinfo p___0  ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
int get_ppid(int pid___0 ) 
{ 


  {
  {
#line 63
  get_info(pid___0, & p___0);
  }
#line 64
  return (p___0.ppid);
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
static char buf___3[512]  ;
#line 71 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
char *get_cmdline(int pid___0 ) 
{ 
  int fd ;
  int i___0 ;
  int n ;
  struct procinfo p___2 ;
  char *s ;
  ssize_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 78
  snprintf((char */* __restrict  */)(buf___3), sizeof(buf___3), (char const   */* __restrict  */)"/proc/%d/cmdline",
           pid___0);
#line 79
  fd = open((char const   *)(buf___3), 0);
  }
#line 79
  if (fd == -1) {
#line 80
    return ((char *)"-");
  }
  {
#line 81
  tmp = read(fd, (void *)(buf___3), sizeof(buf___3));
#line 81
  n = (int )tmp;
#line 82
  close(fd);
  }
#line 83
  if (n == -1) {
#line 83
    return ((char *)"-");
  }
#line 84
  if (! n) {
#line 84
    goto no_full;
  }
#line 85
  i___0 = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i___0 < n)) {
#line 85
      goto while_break;
    }
#line 85
    if (! buf___3[i___0]) {
#line 85
      buf___3[i___0] = (char )' ';
    }
#line 85
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  buf___3[i___0 - 1] = (char)0;
#line 87
  return (buf___3);
  no_full: 
  {
#line 89
  get_info(pid___0, & p___2);
#line 90
  s = p___2.exec_file;
#line 91
  tmp___0 = strlen((char const   *)(p___2.exec_file));
#line 91
  n = (int )tmp___0;
  }
#line 92
  if ((int )*s == 40) {
#line 92
    s ++;
  }
#line 93
  n --;
#line 93
  if ((int )p___2.exec_file[n] == 41) {
#line 93
    p___2.exec_file[n] = (char)0;
  }
  {
#line 94
  memcpy((void */* __restrict  */)(buf___3), (void const   */* __restrict  */)s, (size_t )n);
  }
#line 95
  return (buf___3);
}
}
#line 104 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
char *get_w(int pid___0 ) 
{ 
  struct procinfo p___2 ;
  char *tmp ;

  {
  {
#line 107
  get_info(pid___0, & p___2);
#line 108
  tmp = get_cmdline(p___2.tpgid);
  }
#line 108
  return (tmp);
}
}
#line 116 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
static struct procinfo p___1  ;
#line 114 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
char *get_name(int pid___0 ) 
{ 


  {
  {
#line 117
  get_info(pid___0, & p___1);
  }
#line 118
  return (p___1.exec_file);
}
}
#line 121 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
int proc_pid_uid(u32 pid___0 ) 
{ 
  char buf___6[32] ;
  struct stat s ;
  int tmp ;

  {
  {
#line 126
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"/proc/%d",
           pid___0);
#line 127
  tmp = stat((char const   */* __restrict  */)(buf___6), (struct stat */* __restrict  */)(& s));
  }
#line 127
  if (tmp == -1) {
#line 127
    return (-1);
  }
#line 128
  return ((int )s.st_uid);
}
}
#line 131 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
int proc_getloadavg(double *d , int l ) 
{ 
  int tmp ;

  {
  {
#line 142
  tmp = getloadavg(d, l);
  }
#line 142
  return (tmp);
}
}
#line 153 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
static char buf___4[32]  ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/procinfo.c"
char *count_idle(char *tty ) 
{ 
  struct stat st ;
  time_t idle_time ;
  int tmp ;
  time_t tmp___0 ;
  time_t min ;

  {
  {
#line 156
  sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"/dev/%s",
          tty);
#line 158
  tmp = stat((char const   */* __restrict  */)(buf___4), (struct stat */* __restrict  */)(& st));
  }
#line 158
  if (tmp == -1) {
#line 158
    return ((char *)"?");
  }
  {
#line 159
  tmp___0 = time((time_t *)0);
#line 159
  idle_time = tmp___0 - st.st_atim.tv_sec;
  }
#line 161
  if (idle_time >= 86400L) {
    {
#line 162
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%ldd",
            idle_time / 86400L);
    }
  } else
#line 163
  if (idle_time >= 3600L) {
    {
#line 164
    min = (idle_time % 3600L) / 60L;
#line 165
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%ld:%02ld",
            idle_time / 3600L, min);
    }
  } else
#line 167
  if (idle_time >= 60L) {
    {
#line 168
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%ld",
            idle_time / 60L);
    }
  } else {
    {
#line 170
    sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)" ");
    }
  }
#line 172
  return (buf___4);
}
}
#line 120 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
void mwin_msg_on(struct wdgt *w ) ;
#line 146
void ptree_reg(struct wdgt *w ) ;
#line 160
void send_signal(int sig , pid_t pid___0 ) ;
#line 5 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static char *hlp_init_pid  =    (char *)"\001[ENT]users [d]etails [o]wner [s]ysinfo [l]ine-numbers [^k]ILL [/]search";
#line 6 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static char *hlp  =    (char *)"\001[ENT]users all[t]ree [d]etails [o]wner [s]ysinfo [l]ine-numbers [^k]ILL [/]search";
#line 10 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static struct process *begin  ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static pid_t tree_root  =    1;
#line 12 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static unsigned int show_owner  ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static unsigned int show_linenr  ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static struct __pstat pstat  ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void pstat_update(struct process *p___2 , int n ) 
{ 


  {
#line 20
  pstat.nr += (u32 )n;
#line 21
  if (! p___2->proc) {
#line 21
    return;
  }
  {
#line 23
  if ((int )(p___2->proc)->state == 83) {
#line 23
    goto case_83;
  }
#line 24
  if ((int )(p___2->proc)->state == 82) {
#line 24
    goto case_82;
  }
#line 25
  if ((int )(p___2->proc)->state == 90) {
#line 25
    goto case_90;
  }
#line 26
  if ((int )(p___2->proc)->state == 68) {
#line 26
    goto case_68;
  }
#line 22
  goto switch_break;
  case_83: /* CIL Label */ 
#line 23
  pstat.sl += (u32 )n;
#line 23
  goto switch_break;
  case_82: /* CIL Label */ 
#line 24
  pstat.rn += (u32 )n;
#line 24
  goto switch_break;
  case_90: /* CIL Label */ 
#line 25
  pstat.zm += (u32 )n;
#line 25
  goto switch_break;
  case_68: /* CIL Label */ 
#line 26
  pstat.st += (u32 )n;
#line 26
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 28
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void proc_del(struct process *p___2 ) 
{ 


  {
#line 32
  *(p___2->prev) = p___2->next;
#line 33
  if (p___2->next) {
#line 33
    (p___2->next)->prev = p___2->prev;
  }
#line 37
  if (p___2->proc) {
#line 37
    (p___2->proc)->priv = (void *)0;
  }
  {
#line 38
  free((void *)p___2);
  }
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void mark_del(void *vp ) 
{ 
  struct process *p___2 ;
  struct proc_t *q ;

  {
#line 43
  p___2 = (struct process *)vp;
#line 45
  q = p___2->proc;
#line 46
  q = q->child;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! q) {
#line 46
      goto while_break;
    }
#line 47
    if (q->priv) {
      {
#line 47
      mark_del(q->priv);
      }
    }
#line 46
    q = q->broth.nx;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 48
  pstat_update(p___2, -1);
#line 49
  (p___2->proc)->priv = (void *)0;
#line 50
  p___2->proc = (struct proc_t *)0;
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
__inline static int is_marked(struct process *p___2 ) 
{ 
  int tmp ;

  {
#line 55
  if (p___2->proc) {
#line 55
    tmp = 0;
  } else {
#line 55
    tmp = 1;
  }
#line 55
  return (tmp);
}
}
#line 58 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void clear_list(void) 
{ 
  struct process *p___2 ;
  struct process *q ;

  {
#line 71
  p___2 = begin;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! p___2) {
#line 71
      goto while_break;
    }
    {
#line 72
    q = p___2->next;
#line 73
    proc_del(p___2);
#line 71
    p___2 = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void synchronize(struct wdgt *w ) 
{ 
  int l ;
  struct proc_t *p___2 ;
  struct proc_t *tmp ;
  struct process **current ;
  struct process *z ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 79
  l = 0;
#line 80
  tmp = tree_start(tree_root, tree_root);
#line 80
  p___2 = tmp;
#line 81
  current = & begin;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! p___2) {
#line 82
      goto while_break;
    }
#line 83
    if (*current) {
#line 83
      if (p___2->priv) {
        {
#line 84
        tmp___0 = l;
#line 84
        l ++;
#line 84
        (*current)->line = tmp___0;
#line 85
        ((*current)->proc)->priv = (void *)*current;
#line 86
        p___2 = tree_next();
#line 87
        current = & (*current)->next;
        }
#line 88
        goto while_continue;
      }
    }
    {
#line 90
    tmp___1 = malloc(sizeof(*z));
#line 90
    z = (struct process *)tmp___1;
    }
#line 91
    if (! z) {
      {
#line 91
      allocate_error();
      }
    }
    {
#line 94
    memset((void *)z, 0, sizeof(*z));
#line 95
    scr_linserted(w, l);
#line 96
    tmp___2 = l;
#line 96
    l ++;
#line 96
    z->line = tmp___2;
#line 97
    p___2->priv = (void *)z;
#line 98
    z->proc = p___2;
#line 99
    pstat_update(z, 1);
    }
#line 100
    if (*current) {
#line 101
      z->next = *current;
#line 102
      (*current)->prev = & z->next;
    }
    {
#line 104
    *current = z;
#line 105
    z->prev = current;
#line 106
    current = & z->next;
#line 107
    p___2 = tree_next();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void delete_tree_lines(struct wdgt *w ) 
{ 
  struct process *u___0 ;
  struct process *p___2 ;
  int tmp ;

  {
#line 115
  p___2 = begin;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! p___2) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp = is_marked(p___2);
    }
#line 117
    if (! tmp) {
#line 118
      p___2 = p___2->next;
#line 119
      goto while_continue;
    }
    {
#line 122
    scr_ldeleted(w, p___2->line);
#line 123
    u___0 = p___2;
    }
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 124
      if (! u___0) {
#line 124
        goto while_break___0;
      }
#line 125
      (u___0->line) --;
#line 126
      u___0 = u___0->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 128
    u___0 = p___2->next;
#line 129
    proc_del(p___2);
#line 130
    p___2 = u___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return;
}
}
#line 136
static char get_state_color(char state___0 ) ;
#line 136 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static char m[7]  = {      (char )'R',      (char )' ',      (char )'D',      (char )'Z', 
        (char )'T',      (char )'?',      (char )'\000'};
#line 136 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static char c[7]  = {      (char )'\005',      (char )'\002',      (char )'\006',      (char )'\004', 
        (char )'\a',      (char )'\a',      (char )'\000'};
#line 134 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static char get_state_color(char state___0 ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 137
  tmp = strchr((char const   *)(m), (int )state___0);
#line 137
  s = tmp;
  }
#line 138
  if (! s) {
#line 138
    return ((char )'\003');
  }
#line 139
  return (c[s - m]);
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static char *prepare_line(struct wdgt *w , struct process *p___2 ) 
{ 
  char *tree ;
  char state___0 ;
  int offset ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;

  {
#line 144
  state___0 = (p___2->proc)->state;
#line 145
  offset = 0;
#line 146
  if (! p___2) {
#line 146
    return ((char *)0);
  }
  {
#line 147
  tree = tree_string(tree_root, p___2->proc);
  }
#line 148
  if ((int )state___0 == 83) {
#line 148
    state___0 = (char )' ';
  }
#line 149
  if (show_linenr) {
    {
#line 150
    offset = snprintf((char */* __restrict  */)((w->mwin)->gbuf), (size_t )(w->mwin)->gbsize,
                      (char const   */* __restrict  */)"\006%4d ", p___2->line + 1);
    }
  }
#line 151
  if (offset < 0) {
#line 151
    return ((char *)"");
  }
#line 152
  if (show_owner) {
    {
#line 153
    tmp = get_cmdline((p___2->proc)->pid);
#line 153
    tmp___0 = proc_pid_uid((u32 )(p___2->proc)->pid);
#line 153
    tmp___1 = get_owner_name(tmp___0);
#line 153
    tmp___2 = get_state_color(state___0);
#line 153
    snprintf((char */* __restrict  */)((w->mwin)->gbuf + offset), (size_t )((w->mwin)->gbsize - (u32 )offset),
             (char const   */* __restrict  */)"\003%5d %c%c \003%-8s \002%s \003%s",
             (p___2->proc)->pid, (int )tmp___2, (int )state___0, tmp___1, tree, tmp);
    }
  } else {
    {
#line 158
    tmp___3 = get_cmdline((p___2->proc)->pid);
#line 158
    tmp___4 = get_state_color(state___0);
#line 158
    snprintf((char */* __restrict  */)((w->mwin)->gbuf + offset), (size_t )((w->mwin)->gbsize - (u32 )offset),
             (char const   */* __restrict  */)"\003%5d %c%c \002%s \003%s", (p___2->proc)->pid,
             (int )tmp___4, (int )state___0, tree, tmp___3);
    }
  }
#line 162
  return ((char *)((w->mwin)->gbuf));
}
}
#line 172 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static int getprocbyname(struct wdgt *w , int t ) 
{ 
  struct process *p___2 ;
  char *tmp ;
  char buf___6[8] ;
  int l ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 176
  l = w->crsr;
#line 177
  p___2 = begin;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! p___2) {
#line 177
      goto while_break;
    }
#line 178
    if (! p___2->proc) {
#line 178
      goto __Cont;
    }
#line 179
    if (! t) {
#line 179
      if (p___2->line <= l) {
#line 179
        goto __Cont;
      }
    }
#line 180
    if (t == 1) {
#line 180
      if (p___2->line < l) {
#line 180
        goto __Cont;
      }
    }
    {
#line 182
    snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"%d",
             (p___2->proc)->pid);
#line 183
    tmp___0 = reg_match((char const   *)(buf___6));
    }
#line 183
    if (tmp___0) {
#line 183
      goto found;
    }
#line 185
    if (show_owner) {
      {
#line 185
      tmp___1 = get_owner_name(p___2->uid);
#line 185
      tmp___2 = reg_match((char const   *)tmp___1);
      }
#line 185
      if (tmp___2) {
#line 186
        goto found;
      }
    }
    {
#line 187
    tmp = get_cmdline((p___2->proc)->pid);
#line 188
    tmp___3 = reg_match((char const   *)tmp);
    }
#line 188
    if (tmp___3) {
#line 188
      goto found;
    }
    __Cont: /* CIL Label */ 
#line 177
    p___2 = p___2->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return (2);
  found: 
  {
#line 192
  scr_crsr_jmp(w, p___2->line);
  }
#line 193
  return (1);
}
}
#line 198 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void ptreeinfo(struct wdgt *w , int i___0 ) 
{ 
  int n ;
  int size ;
  char *buf___6 ;
  int tmp ;
  int tmp___0 ;

  {
#line 200
  size = (int )(w->mwin)->gbsize;
#line 201
  buf___6 = (char *)((w->mwin)->gbuf);
#line 202
  if (! i___0) {
    {
#line 203
    wmsg_send(w, 8, (void *)0);
    }
#line 204
    return;
  }
  {
#line 206
  n = snprintf((char */* __restrict  */)buf___6, (size_t )size, (char const   */* __restrict  */)"%u tasks: %u running, %u sleeping",
               pstat.nr, pstat.rn, pstat.sl);
  }
#line 208
  if (pstat.st) {
    {
#line 208
    tmp = snprintf((char */* __restrict  */)(buf___6 + n), (size_t )(size - n), (char const   */* __restrict  */)", %u stopped",
                   pstat.st);
#line 208
    n += tmp;
    }
  }
#line 209
  if (pstat.zm) {
    {
#line 209
    tmp___0 = snprintf((char */* __restrict  */)(buf___6 + n), (size_t )(size - n),
                       (char const   */* __restrict  */)", %u zombie", pstat.zm);
#line 209
    n += tmp___0;
    }
  }
  {
#line 210
  wmsg_send(w, 8, (void *)buf___6);
  }
#line 211
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void draw_tree(struct wdgt *w ) 
{ 
  struct process *p___2 ;
  char *tmp ;

  {
  {
#line 217
  scr_output_start(w);
  }
#line 218
  if (! begin) {
    {
#line 219
    scr_maddstr(w, (char *)"User has logged out", (u32 )0, (u32 )0, (u32 )20);
    }
#line 220
    return;
  }
#line 222
  p___2 = begin;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! p___2) {
#line 222
      goto while_break;
    }
#line 223
    if (! p___2->proc) {
#line 223
      goto __Cont;
    }
    {
#line 224
    tmp = prepare_line(w, p___2);
#line 224
    scr_addfstr(w, tmp, (u32 )p___2->line, (u32 )0);
    }
    __Cont: /* CIL Label */ 
#line 222
    p___2 = p___2->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  scr_output_end(w);
  }
#line 227
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static pid_t crsr_pid(int line ) 
{ 
  struct process *p___2 ;

  {
#line 235
  p___2 = begin;
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! p___2) {
#line 235
      goto while_break;
    }
#line 236
    if (p___2->line == line) {
#line 236
      return ((p___2->proc)->pid);
    }
#line 235
    p___2 = p___2->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return (0);
}
}
#line 240 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void ptree_periodic(struct wdgt *w ) 
{ 


  {
  {
#line 243
  update_tree(& mark_del);
#line 244
  delete_tree_lines(w);
#line 245
  synchronize(w);
#line 246
  ptreeinfo(w, 1);
  }
#line 247
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void ptree_redraw(struct wdgt *w ) 
{ 


  {
  {
#line 252
  scr_werase(w);
#line 253
  draw_tree(w);
  }
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
void do_signal(struct wdgt *w , int sig , int pid___0 ) 
{ 


  {
  {
#line 258
  send_signal(sig, pid___0);
#line 259
  ptree_periodic(w);
#line 260
  w->flags = (u8 )((int )w->flags | 4);
  }
#line 261
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static int signal_keys(struct wdgt *w , int key ) 
{ 
  int signal___0 ;
  pid_t tmp ;

  {
#line 265
  signal___0 = 0;
#line 267
  if (! (key & 16384)) {
#line 267
    return (0);
  }
#line 268
  key &= 4095;
  {
#line 270
  if (key == 75) {
#line 270
    goto case_75;
  }
#line 271
  if (key == 85) {
#line 271
    goto case_85;
  }
#line 272
  if (key == 84) {
#line 272
    goto case_84;
  }
#line 269
  goto switch_break;
  case_75: /* CIL Label */ 
#line 270
  signal___0 = 9;
#line 270
  goto switch_break;
  case_85: /* CIL Label */ 
#line 271
  signal___0 = 1;
#line 271
  goto switch_break;
  case_84: /* CIL Label */ 
#line 272
  signal___0 = 15;
#line 272
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 274
  if (signal___0) {
    {
#line 274
    tmp = crsr_pid(w->crsr);
#line 274
    do_signal(w, signal___0, tmp);
    }
  }
#line 275
  return (1);
}
}
#line 280 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static u32 pid  ;
#line 278 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void *pmsgh(struct wdgt *w , int type , struct wdgt *s , void *d ) 
{ 
  pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 282
  if (type == 1) {
#line 282
    goto case_1;
  }
#line 285
  if (type == 9) {
#line 285
    goto case_9;
  }
#line 281
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 283
  tmp = crsr_pid(w->crsr);
#line 283
  pid = (u32 )tmp;
  }
#line 284
  return ((void *)(& pid));
  case_9: /* CIL Label */ 
  {
#line 286
  tmp___0 = getprocbyname(w, (int )((u32 )d));
  }
#line 286
  return ((void *)((int *)((intptr_t )tmp___0)));
#line 287
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 289
  return ((void *)0);
}
}
#line 292 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void ptree_hlp(struct wdgt *w ) 
{ 
  char *s ;

  {
#line 294
  s = hlp_init_pid;
#line 295
  if (tree_root != 1) {
#line 295
    s = hlp;
  }
  {
#line 296
  wmsg_send(w, 3, (void *)s);
  }
#line 297
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void ptree_unhide(struct wdgt *w ) 
{ 
  u32 tmp ;
  int tmp___0 ;

  {
  {
#line 301
  ptree_hlp(w);
#line 302
  ptree_periodic(w);
#line 303
  w->periodic = & ptree_periodic;
#line 304
  w->msgh = & pmsgh;
#line 305
  w->redraw = & ptree_redraw;
#line 306
  w->wrefresh = & scr_wrefresh;
#line 307
  w->flags = (u8 )((int )w->flags | 4);
#line 308
  tmp___0 = 0;
#line 308
  w->crsr = tmp___0;
#line 308
  tmp = (u32 )tmp___0;
#line 308
  w->vy = tmp;
#line 308
  w->vy = tmp;
  }
#line 309
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void ptree_hide(struct wdgt *w ) 
{ 
  void (*tmp)(struct wdgt * ) ;

  {
  {
#line 314
  tmp = (void (*)(struct wdgt * ))0;
#line 314
  w->wrefresh = tmp;
#line 314
  w->redraw = tmp;
#line 315
  clear_list();
#line 316
  w->periodic = (void (*)(struct wdgt * ))0;
#line 317
  w->msgh = (void *(*)(struct wdgt * , int  , struct wdgt * , void * ))0;
#line 318
  ptreeinfo(w, 0);
#line 319
  bzero((void *)(& pstat), sizeof(pstat));
  }
#line 320
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void root_change(struct wdgt *w ) 
{ 
  void *p___2 ;

  {
  {
#line 325
  p___2 = wmsg_send(w, 4, (void *)0);
  }
#line 326
  if (p___2) {
#line 326
    tree_root = *((pid_t *)p___2);
  } else {
#line 327
    tree_root = 1;
  }
#line 328
  return;
}
}
#line 334 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static void pswitch(struct wdgt *w , int k , int p___2 ) 
{ 


  {
#line 336
  if (! (! w->wrefresh)) {
#line 337
    if (k == p___2) {
#line 337
      goto _L;
    } else
#line 337
    if (k == 256) {
      _L: /* CIL Label */ 
#line 338
      if (k != 116) {
        {
#line 338
        ptree_hide(w);
        }
      }
#line 339
      return;
    }
#line 341
    if (k == 116) {
      {
#line 342
      tree_root = 1;
#line 343
      ptree_periodic(w);
#line 344
      w->flags = (u8 )((int )w->flags | 4);
      }
#line 345
      return;
    }
  } else {
#line 348
    if (k == 256) {
      {
#line 348
      root_change(w);
      }
    } else
#line 349
    if (k == 116) {
#line 349
      tree_root = 1;
    }
    {
#line 350
    wmsg_send(w, 7, (void *)(& eproc));
#line 351
    ptree_unhide(w);
    }
  }
#line 353
  return;
}
}
#line 359 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static int pkey  ;
#line 355 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
static int pkeyh(struct wdgt *w , int key ) 
{ 
  int ret ;
  int ctrl ;

  {
#line 357
  ret = 1;
#line 358
  ctrl = key & 4095;
#line 362
  if (key == 116) {
    {
#line 363
    pswitch(w, key, pkey);
#line 364
    pkey = key;
    }
#line 365
    return (1);
  } else
#line 362
  if (key == 256) {
    {
#line 363
    pswitch(w, key, pkey);
#line 364
    pkey = key;
    }
#line 365
    return (1);
  }
#line 368
  if (! w->wrefresh) {
#line 368
    return (0);
  }
#line 369
  if (ctrl == 75) {
    {
#line 370
    signal_keys(w, key);
    }
#line 371
    return (ret);
  }
  {
#line 374
  if (key == 111) {
#line 374
    goto case_111;
  }
#line 375
  if (key == 114) {
#line 375
    goto case_114;
  }
#line 376
  if (key == 108) {
#line 376
    goto case_108;
  }
#line 381
  goto switch_default;
  case_111: /* CIL Label */ 
#line 374
  show_owner ^= 1U;
#line 374
  w->flags = (u8 )((int )w->flags | 4);
#line 374
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 375
  ptree_periodic(w);
#line 375
  w->flags = (u8 )((int )w->flags | 4);
  }
#line 375
  goto switch_break;
  case_108: /* CIL Label */ 
#line 376
  show_linenr ^= 1U;
#line 376
  w->flags = (u8 )((int )w->flags | 4);
#line 376
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 381
  ret = scr_keyh(w, key);
  }
  switch_break: /* CIL Label */ ;
  }
#line 383
  return (ret);
}
}
#line 389 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/plist.c"
void ptree_reg(struct wdgt *w ) 
{ 


  {
  {
#line 391
  w->keyh = & pkeyh;
#line 392
  w->msgh = & pmsgh;
#line 393
  mwin_msg_on(w);
  }
#line 394
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 50 "/usr/include/err.h"
extern  __attribute__((__noreturn__)) void ( /* format attribute */  errx)(int __status ,
                                                                           char const   *__format 
                                                                           , ...) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 896 "/usr/include/curses.h"
extern int resizeterm(int  , int  ) ;
#line 68 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
unsigned long long ticks  ;
#line 69
int full_cmd ;
#line 116
void err_exit(int scr , char *s ) ;
#line 145
void ulist_reg(struct wdgt *w ) ;
#line 147
void exti_reg(struct wdgt *w ) ;
#line 148
void users_init(void) ;
#line 159
void prg_exit(char *s ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static struct win win  ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static struct win *mwin  =    & win;
#line 27 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static int size_changed  ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
int full_cmd  =    1;
#line 35 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void mwin_wrefresh(void) 
{ 
  struct wdgt *w ;
  struct list_head *l ;

  {
#line 35
  l = mwin->wdgts.prev;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((unsigned long )l != (unsigned long )(& mwin->wdgts))) {
#line 35
      goto while_break;
    }
#line 35
    w = (struct wdgt *)((char *)l - (unsigned long )(& ((struct wdgt *)0)->wdgts_l));
#line 35
    if (! w->wrefresh) {
#line 35
      goto __Cont;
    }
    {
#line 35
    (*(w->wrefresh))(w);
    }
    __Cont: /* CIL Label */ 
#line 35
    l = l->prev;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 35
  scr_doupdate();
  }
#line 35
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void mwin_periodic(void) 
{ 
  struct wdgt *w ;
  struct list_head *l ;

  {
#line 36
  l = mwin->wdgts.prev;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((unsigned long )l != (unsigned long )(& mwin->wdgts))) {
#line 36
      goto while_break;
    }
#line 36
    w = (struct wdgt *)((char *)l - (unsigned long )(& ((struct wdgt *)0)->wdgts_l));
#line 36
    if (! w->periodic) {
#line 36
      goto __Cont;
    }
    {
#line 36
    (*(w->periodic))(w);
    }
    __Cont: /* CIL Label */ 
#line 36
    l = l->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
void mwin_redraw(int f ) 
{ 
  struct wdgt *w ;
  struct list_head *l ;

  {
#line 42
  l = mwin->wdgts.prev;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! ((unsigned long )l != (unsigned long )(& mwin->wdgts))) {
#line 42
      goto while_break;
    }
#line 43
    w = (struct wdgt *)((char *)l - (unsigned long )(& ((struct wdgt *)0)->wdgts_l));
#line 44
    if (! w->redraw) {
#line 44
      goto __Cont;
    }
#line 45
    if (! f) {
#line 45
      if (! ((int )w->flags & 4)) {
#line 45
        goto __Cont;
      }
    }
    {
#line 47
    w->flags = (u8 )((int )w->flags & -5);
#line 48
    (*(w->redraw))(w);
    }
    __Cont: /* CIL Label */ 
#line 42
    l = l->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
char *_msg[11]  = 
#line 52
  {      (char *)"want_dsource",      (char *)"want_crsr_val",      (char *)"cur_crsr",      (char *)"cur_hlp", 
        (char *)"want_upid",      (char *)"crsr_reg",      (char *)"crsr_unreg",      (char *)"snd_esource", 
        (char *)"snd_info",      (char *)"snd_search",      (char *)"snd_search_end"};
#line 55 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
void *wmsg_send(struct wdgt *sndr , int type , void *data ) 
{ 
  struct wdgt *w ;
  struct list_head *l ;
  void *ret ;

  {
#line 59
  ret = (void *)0;
#line 61
  l = mwin->msg.prev;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! ((unsigned long )l != (unsigned long )(& mwin->msg))) {
#line 61
      goto while_break;
    }
#line 62
    w = (struct wdgt *)((char *)l - (unsigned long )(& ((struct wdgt *)0)->msg_l));
#line 64
    if ((unsigned long )w == (unsigned long )sndr) {
#line 64
      goto __Cont;
    } else
#line 64
    if (! w->msgh) {
#line 64
      goto __Cont;
    }
    {
#line 66
    ret = (*(w->msgh))(w, type, sndr, data);
    }
#line 67
    if (ret) {
#line 69
      return (ret);
    }
    __Cont: /* CIL Label */ 
#line 61
    l = l->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (ret);
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static int mwin_keyh(int key ) 
{ 
  struct wdgt *w ;
  struct list_head *l ;
  int ret ;

  {
#line 80
  ret = 0;
#line 81
  l = mwin->wdgts.next;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((unsigned long )l != (unsigned long )(& mwin->wdgts))) {
#line 81
      goto while_break;
    }
#line 82
    w = (struct wdgt *)((char *)l - (unsigned long )(& ((struct wdgt *)0)->wdgts_l));
#line 83
    if (! w->keyh) {
#line 83
      goto __Cont;
    }
    {
#line 85
    ret = (*(w->keyh))(w, key);
    }
#line 86
    if (ret == 2) {
#line 86
      return (ret);
    }
    __Cont: /* CIL Label */ 
#line 81
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (ret);
}
}
#line 91 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
void mwin_msg_on(struct wdgt *w ) 
{ 


  {
  {
#line 93
  list_add(& w->msg_l, & mwin->msg);
  }
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void mwin_init(void) 
{ 


  {
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    mwin->wdgts.next = & mwin->wdgts;
#line 99
    mwin->wdgts.prev = & mwin->wdgts;
#line 99
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    mwin->msg.next = & mwin->msg;
#line 100
    mwin->msg.prev = & mwin->msg;
#line 100
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  mwin->gbsize = (u32 )sizeof(mwin->gbuf);
#line 102
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
void err_exit(int scr , char *s ) 
{ 


  {
  {
#line 109
  errx(1, "%s", s);
  }
}
}
#line 112 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
void prg_exit(char *s ) 
{ 


  {
  {
#line 114
  curses_end();
  }
#line 115
  if (s) {
    {
#line 115
    printf((char const   */* __restrict  */)"%s\n", s);
    }
  }
  {
#line 116
  exit(0);
  }
}
}
#line 119 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
void allocate_error(void) 
{ 


  {
  {
#line 120
  curses_end();
#line 121
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate memory.\n");
#line 122
  exit(1);
  }
}
}
#line 128 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void main_periodic(void) 
{ 


  {
  {
#line 130
  mwin_periodic();
#line 131
  mwin_redraw(1);
#line 132
  mwin_wrefresh();
  }
#line 133
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static int signal_sent___0  ;
#line 138 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static int signal_sent(int i___0 ) 
{ 


  {
#line 142
  if (i___0 == -1) {
#line 142
    return (signal_sent___0);
  }
#line 143
  signal_sent___0 = i___0;
#line 143
  return (signal_sent___0);
}
}
#line 146 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
void send_signal(int sig , pid_t pid___0 ) 
{ 
  int p___2 ;
  char buf___6[64] ;

  {
#line 151
  if (pid___0 == 1) {
#line 151
    p___2 = -1;
  } else {
    {
#line 152
    p___2 = kill(pid___0, sig);
    }
  }
  {
#line 153
  signal_sent(1);
  }
#line 154
  if (p___2 == -1) {
    {
#line 155
    sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"Can\'t send signal %d to process %d",
            sig, pid___0);
    }
  } else {
    {
#line 157
    sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"Signal %d was sent to process %d",
            sig, pid___0);
    }
  }
#line 163
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void key_action(int key ) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 167
  tmp = mwin_keyh(key);
#line 167
  ret = tmp;
  }
#line 168
  if (ret != 2) {
#line 168
    if (key == 113) {
      {
#line 169
      curses_end();
#line 170
      exit(0);
      }
    } else
#line 168
    if (key == 259) {
      {
#line 169
      curses_end();
#line 170
      exit(0);
      }
    }
  }
  {
#line 173
  mwin_redraw((int )mwin->need_redraw);
#line 174
  mwin->need_redraw = (u8 )0;
#line 176
  mwin_wrefresh();
  }
#line 177
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void get_scrsize(u32 *y , u32 *x ) 
{ 
  struct winsize win___0 ;
  int tmp ;

  {
  {
#line 182
  tmp = ioctl(1, 21523UL, & win___0);
  }
#line 182
  if (tmp == -1) {
    {
#line 183
    err_exit(1, (char *)"ioctl error: cannot read screen size");
    }
  }
#line 189
  *y = (u32 )((int )win___0.ws_row - 1);
#line 190
  *x = (u32 )((int )win___0.ws_col - 1);
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void resize(void) 
{ 
  struct wdgt *w ;
  struct list_head *l ;
  u32 prev_sy ;
  u32 prev_sx ;

  {
  {
#line 197
  prev_sy = mwin->sy;
#line 198
  prev_sx = mwin->sx;
#line 200
  get_scrsize(& mwin->sy, & mwin->sx);
#line 202
  l = mwin->wdgts.prev;
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! ((unsigned long )l != (unsigned long )(& mwin->wdgts))) {
#line 202
      goto while_break;
    }
#line 203
    w = (struct wdgt *)((char *)l - (unsigned long )(& ((struct wdgt *)0)->wdgts_l));
#line 208
    if (w->pxsize < mwin->sx) {
      {
#line 209
      w->pxsize = mwin->sx + 1U;
#line 210
      scr_wresize(w, w->pysize, w->pxsize);
      }
    }
#line 212
    w->xsize += mwin->sx - prev_sx;
#line 213
    if ((int )w->flags & 1) {
#line 213
      goto __Cont;
    }
#line 214
    w->ysize += mwin->sy - prev_sy;
#line 215
    if (w->decor) {
      {
#line 215
      scr_decor_resize(w);
      }
    }
    {
#line 216
    werase((WINDOW *)w->wd);
    }
    __Cont: /* CIL Label */ 
#line 202
    l = l->prev;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 218
  resizeterm((int )(mwin->sy + 1U), (int )(mwin->sx + 1U));
#line 220
  mwin_redraw(1);
#line 221
  mwin_wrefresh();
#line 222
  size_changed = 0;
  }
#line 223
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void winch_handler(void) 
{ 


  {
#line 227
  size_changed ++;
#line 228
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void int_handler(int i___0 ) 
{ 


  {
  {
#line 232
  curses_end();
#line 233
  exit(0);
  }
}
}
#line 236 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void set_sig(void) 
{ 


  {
  {
#line 238
  signal(2, & int_handler);
#line 239
  signal(28, (void (*)(int  ))(& winch_handler));
  }
#line 241
  return;
}
}
#line 243 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void wdgt_init(struct wdgt *w ) 
{ 


  {
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    w->wdgts_l.next = & w->wdgts_l;
#line 245
    w->wdgts_l.prev = & w->wdgts_l;
#line 245
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 246
    w->msg_l.next = & w->msg_l;
#line 246
    w->msg_l.prev = & w->msg_l;
#line 246
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 247
  list_add(& w->wdgts_l, & mwin->wdgts);
  }
#line 248
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
__inline static struct wdgt *wdgt_alloc(void) 
{ 
  void *tmp ;

  {
  {
#line 252
  tmp = calloc((size_t )1, sizeof(struct wdgt ));
  }
#line 252
  return ((struct wdgt *)tmp);
}
}
#line 258 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static int wd_create(struct wdgt *w , u32 ysize , u32 xsize , u32 pysize , u32 pxsize ,
                     u8 c___0 ) 
{ 
  WINDOW *tmp ;

  {
  {
#line 261
  tmp = newpad((int )(pysize + 1U), (int )(pxsize + 1U));
#line 261
  w->wd = (void *)tmp;
#line 262
  w->color = c___0;
#line 263
  w->pysize = pysize;
#line 264
  w->pxsize = pxsize;
#line 265
  wbkgd((WINDOW *)w->wd, (chtype )c___0 << 8);
  }
#line 266
  if (! w->wd) {
#line 266
    return (0);
  }
#line 267
  return (1);
}
}
#line 273 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static struct wdgt *wdgt_new(u32 y , u32 x , u32 ysize , u32 xsize , u32 pysize ,
                             u32 pxsize , char *name___0 , u8 c___0 ) 
{ 
  struct wdgt *w ;
  u32 tmp ;
  int tmp___0 ;

  {
  {
#line 276
  w = wdgt_alloc();
  }
#line 276
  if (! w) {
    {
#line 276
    err_exit(1, (char *)"Cannot allocate memory for a new widget");
    }
  }
  {
#line 277
  wdgt_init(w);
#line 278
  memcpy((void */* __restrict  */)(w->name), (void const   */* __restrict  */)name___0,
         sizeof(w->name) - 1UL);
#line 279
  w->x = x;
#line 280
  w->y = y;
#line 281
  w->xsize = xsize;
#line 282
  w->ysize = ysize;
#line 283
  tmp = (u32 )0;
#line 283
  w->vx = tmp;
#line 283
  w->vy = tmp;
  }
#line 284
  if (! pysize) {
#line 284
    pysize = (ysize - y) + 1U;
  }
#line 285
  if (! pxsize) {
#line 285
    pxsize = (xsize - x) + 1U;
  }
  {
#line 286
  tmp___0 = wd_create(w, ysize, xsize, pysize, pxsize, c___0);
  }
#line 286
  if (! tmp___0) {
    {
#line 287
    err_exit(1, (char *)"Cannot create widget");
    }
  }
#line 290
  w->crsr = -1;
#line 291
  w->mwin = mwin;
#line 292
  return (w);
}
}
#line 295 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void info_wdgt(u32 y , u32 x , u32 ysize , u32 xsize , u32 pysize , u32 pxsize ,
                      u8 c___0 ) 
{ 
  struct wdgt *w ;

  {
  {
#line 298
  w = wdgt_new(y, x, ysize, xsize, pysize, pxsize, (char *)"info", c___0);
#line 299
  list_add(& w->msg_l, & mwin->msg);
#line 300
  info_reg(w);
#line 301
  w->flags = (u8 )((int )w->flags | 1);
  }
#line 302
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void hlp_wdgt(u32 y , u32 x , u32 ysize , u32 xsize , u32 pysize , u32 pxsize ,
                     u8 c___0 ) 
{ 
  struct wdgt *w ;

  {
  {
#line 307
  w = wdgt_new(y, x, ysize, xsize, pysize, pxsize, (char *)"help", c___0);
#line 308
  list_add(& w->msg_l, & mwin->msg);
#line 309
  w->flags = (u8 )((int )w->flags | 1);
#line 310
  hlp_reg(w);
  }
#line 311
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void ulist_wdgt(u32 y , u32 x , u32 ysize , u32 xsize , u32 pysize , u32 pxsize ,
                       u8 c___0 ) 
{ 
  struct wdgt *w ;

  {
  {
#line 317
  w = wdgt_new(y, x, ysize, xsize, pysize, pxsize, (char *)"ulist", c___0);
#line 319
  w->crsr = 0;
#line 320
  ulist_reg(w);
  }
#line 321
  return;
}
}
#line 323 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void ptree_wdgt(u32 y , u32 x , u32 ysize , u32 xsize , u32 pysize , u32 pxsize ,
                       u8 c___0 ) 
{ 
  struct wdgt *w ;

  {
  {
#line 326
  w = wdgt_new(y, x, ysize, xsize, pysize, pxsize, (char *)"ptree", c___0);
#line 328
  w->crsr = 0;
#line 329
  ptree_reg(w);
  }
#line 330
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void exti_wdgt(u32 y , u32 x , u32 ysize , u32 xsize , u32 pysize , u32 pxsize ,
                      u8 c___0 ) 
{ 
  struct wdgt *w ;

  {
  {
#line 336
  w = wdgt_new(y, x, ysize, xsize, pysize, pxsize, (char *)"exti", c___0);
#line 337
  exti_reg(w);
  }
#line 338
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void input_wdgt(u32 y , u32 x , u32 ysize , u32 xsize , u32 pysize , u32 pxsize ,
                       u8 c___0 ) 
{ 
  struct wdgt *w ;

  {
  {
#line 342
  w = wdgt_new(y, x, ysize, xsize, pysize, pxsize, (char *)"input", c___0);
#line 343
  list_add(& w->msg_l, & mwin->msg);
#line 344
  w->flags = (u8 )((int )w->flags | 1);
#line 345
  input_reg(w);
  }
#line 346
  return;
}
}
#line 359 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void wdgts_create(int sy , int sx ) 
{ 


  {
  {
#line 365
  info_wdgt((u32 )0, (u32 )0, (u32 )1, (u32 )sx, (u32 )1, (u32 )sx, (u8 )3);
#line 366
  hlp_wdgt((u32 )sy, (u32 )0, (u32 )sy, (u32 )sx, (u32 )sy, (u32 )sx, (u8 )1);
#line 367
  ulist_wdgt((u32 )3, (u32 )0, (u32 )(sy - 1), (u32 )sx, (u32 )256, (u32 )sx, (u8 )3);
#line 368
  ptree_wdgt((u32 )3, (u32 )0, (u32 )(sy - 1), (u32 )sx, (u32 )256, (u32 )sx, (u8 )3);
#line 369
  exti_wdgt((u32 )(sy / 4), (u32 )(sx / 5), (u32 )(sy - sy / 4), (u32 )(sx - sx / 5),
            (u32 )256, (u32 )128, (u8 )8);
#line 370
  input_wdgt((u32 )sy, (u32 )0, (u32 )sy, (u32 )sx, (u32 )0, (u32 )0, (u8 )9);
  }
#line 371
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void scrlib_init(void) 
{ 


  {
  {
#line 375
  curses_init();
  }
#line 376
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void main_init(void) 
{ 


  {
  {
#line 380
  get_scrsize(& mwin->sy, & mwin->sx);
#line 381
  mwin_init();
#line 384
  scrlib_init();
#line 387
  wdgts_create((int )mwin->sy, (int )mwin->sx);
#line 388
  users_init();
#line 389
  set_sig();
  }
#line 390
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
static void main_start(void) 
{ 


  {
  {
#line 394
  main_periodic();
  }
#line 395
  return;
}
}
#line 397 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.c"
int main(int argc , char **argv ) 
{ 
  struct timeval tv ;
  fd_set rfds ;
  int retval ;
  int key ;
  int __d0 ;
  int __d1 ;

  {
  {
#line 409
  main_init();
#line 410
  main_start();
#line 412
  tv.tv_sec = (__time_t )3;
#line 413
  tv.tv_usec = (__suseconds_t )0;
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 416
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 416
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.__fds_bits[0]): "memory");
#line 416
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 417
    rfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 419
    retval = select(1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)0,
                    (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
    }
#line 420
    if (retval > 0) {
      {
#line 421
      key = getkey();
      }
#line 422
      if (key == -1) {
        {
#line 423
        usleep((__useconds_t )10000);
#line 424
        key = getkey();
        }
      }
      {
#line 426
      key_action(key);
      }
    }
#line 428
    if (! tv.tv_sec) {
#line 428
      if (! tv.tv_usec) {
        {
#line 429
        ticks ++;
#line 430
        main_periodic();
#line 431
        tv.tv_sec = (__time_t )3;
        }
      }
    }
#line 448
    if (size_changed) {
      {
#line 448
      resize();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 204 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/whowatch.h"
void euser(void *p___2 ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/user_plugin.c"
void euser(void *p___2 ) 
{ 
  struct passwd *pw ;

  {
#line 17
  if (! p___2) {
    {
#line 18
    println("Invalid user");
    }
#line 19
    return;
  }
  {
#line 21
  pw = getpwnam((char const   *)((char *)p___2));
  }
#line 22
  if (! pw) {
    {
#line 23
    println("Error - user not found.");
    }
#line 24
    return;
  }
  {
#line 26
  title("NAME: ");
#line 26
  println("%s\n", pw->pw_name);
#line 27
  title("HOME: ");
#line 27
  println("%s\n", pw->pw_dir);
#line 28
  title("UID: ");
#line 28
  println("%d\n", pw->pw_uid);
#line 29
  title("GID: ");
#line 29
  println("%d\n", pw->pw_gid);
#line 30
  title("SHELL: ");
#line 30
  println("%s\n", pw->pw_shell);
#line 31
  title("GECOS: ");
#line 31
  println("%s\n", pw->pw_gecos);
  }
#line 32
  return;
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 57 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/list.h"
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 


  {
#line 60
  next->prev = prev;
#line 61
  prev->next = next;
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/list.h"
__inline static void list_del(struct list_head *entry___0 ) 
{ 


  {
  {
#line 66
  __list_del(entry___0->prev, entry___0->next);
  }
#line 67
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.h"
static struct list_head users_l  =    {& users_l, & users_l};
#line 28 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.h"
static int toggle  ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static struct prot_t prot_tab[3]  = {      {(char *)"(sshd", (short)22, (u32 )0}, 
        {(char *)"(in.telnetd)", (short)23, (u32 )0}, 
        {(char *)"(init)", (short)-1, (u32 )0}};
#line 18 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static char *hlp___0  =    (char *)"[ENT]proc all[t]ree [d]etails [s]ysinfo";
#line 20 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static u32 nusers  ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static struct wdgt *self  ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void u_count(char *name___0 , int p___2 ) 
{ 
  int i___0 ;
  struct prot_t *t ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 27
  nusers += (u32 )p___2;
#line 28
  i___0 = 0;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! ((unsigned long )i___0 < sizeof(prot_tab) / sizeof(struct prot_t ))) {
#line 28
      goto while_break;
    }
    {
#line 29
    t = & prot_tab[i___0];
#line 30
    tmp = strlen((char const   *)t->s);
#line 30
    tmp___0 = strncmp((char const   *)t->s, (char const   *)name___0, tmp);
    }
#line 30
    if (tmp___0) {
#line 30
      goto __Cont;
    }
#line 31
    t->nr += (u32 )p___2;
    __Cont: /* CIL Label */ 
#line 28
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
void update_line(int line ) 
{ 
  struct user_t *u___0 ;
  struct list_head *tmp ;

  {
#line 42
  tmp = users_l.next;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! ((unsigned long )tmp != (unsigned long )(& users_l))) {
#line 42
      goto while_break;
    }
#line 43
    u___0 = (struct user_t *)((char *)tmp - (unsigned long )(& ((struct user_t *)0)->head));
#line 44
    if (u___0->line > line) {
#line 44
      (u___0->line) --;
    }
#line 42
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
struct user_t *alloc_user(struct utmp *entry___0 ) 
{ 
  struct user_t *u___0 ;
  int ppid ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 56
  tmp = calloc((size_t )1, sizeof(*u___0));
#line 56
  u___0 = (struct user_t *)tmp;
  }
#line 57
  if (! u___0) {
    {
#line 57
    errx(1, "Cannot allocate memory.");
    }
  }
  {
#line 58
  strncpy((char */* __restrict  */)(u___0->name), (char const   */* __restrict  */)(entry___0->ut_user),
          (size_t )32);
#line 59
  strncpy((char */* __restrict  */)(u___0->tty), (char const   */* __restrict  */)(entry___0->ut_line),
          (size_t )32);
#line 60
  strncpy((char */* __restrict  */)(u___0->host), (char const   */* __restrict  */)(entry___0->ut_host),
          (size_t )256);
#line 62
  u___0->pid = entry___0->ut_pid;
#line 66
  ppid = get_ppid(u___0->pid);
  }
#line 66
  if (ppid == -1) {
    {
#line 67
    strncpy((char */* __restrict  */)(u___0->parent), (char const   */* __restrict  */)"can\'t access",
            sizeof(u___0->parent));
    }
  } else {
    {
#line 68
    tmp___0 = get_name(ppid);
#line 68
    strncpy((char */* __restrict  */)(u___0->parent), (char const   */* __restrict  */)tmp___0,
            sizeof(u___0->parent) - 1UL);
    }
  }
#line 69
  u___0->line = (int )nusers;
#line 70
  return (u___0);
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static struct user_t *new_user(struct utmp *ut ) 
{ 
  struct user_t *u___0 ;

  {
  {
#line 76
  u___0 = alloc_user(ut);
#line 77
  list_add(& u___0->head, & users_l);
#line 78
  u_count(u___0->parent, 1);
  }
#line 79
  return (u___0);
}
}
#line 82 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void uprint(struct user_t *u___0 , struct wdgt *w ) 
{ 
  int n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 85
  scr_attr_set(w, (int )(1UL << 21));
  }
#line 86
  if (toggle) {
    {
#line 86
    tmp = count_idle(u___0->tty);
#line 86
    tmp___1 = tmp;
    }
  } else {
    {
#line 86
    tmp___0 = get_w(u___0->pid);
#line 86
    tmp___1 = tmp___0;
    }
  }
  {
#line 86
  n = snprintf((char */* __restrict  */)((w->mwin)->gbuf), (size_t )(w->mwin)->gbsize,
               (char const   */* __restrict  */)"%-14.14s %-9.9s %-6.6s %-19.19s %s",
               u___0->parent, u___0->name, u___0->tty, u___0->host, tmp___1);
#line 89
  scr_maddstr(w, (char *)((w->mwin)->gbuf), (u32 )u___0->line, (u32 )0, (u32 )n);
  }
#line 90
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
void uredraw(struct wdgt *w ) 
{ 
  struct list_head *tmp ;
  struct user_t *u___0 ;

  {
  {
#line 96
  scr_werase(w);
#line 97
  scr_output_start(w);
#line 98
  tmp = users_l.prev;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((unsigned long )tmp != (unsigned long )(& users_l))) {
#line 98
      goto while_break;
    }
    {
#line 99
    u___0 = (struct user_t *)((char *)tmp - (unsigned long )(& ((struct user_t *)0)->head));
#line 100
    uprint(u___0, w);
#line 98
    tmp = tmp->prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  scr_output_end(w);
  }
#line 103
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static struct utmp entry  ;
#line 109 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
void read_utmp(void) 
{ 
  int fd ;
  int i___0 ;
  struct user_t *u___0 ;
  ssize_t tmp ;

  {
  {
#line 115
  fd = open("/var/run/utmp", 0);
  }
#line 115
  if (fd == -1) {
    {
#line 115
    err_exit(1, (char *)"Cannot open utmp");
    }
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = read(fd, (void *)(& entry), sizeof(entry));
#line 116
    i___0 = (int )tmp;
    }
#line 116
    if (! (i___0 > 0)) {
#line 116
      goto while_break;
    }
#line 117
    if ((unsigned long )i___0 != sizeof(entry)) {
      {
#line 117
      errx(1, "Error reading /var/run/utmp");
      }
    }
#line 119
    if ((int )entry.ut_type != 7) {
#line 119
      goto while_continue;
    }
    {
#line 123
    u___0 = new_user(& entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  close(fd);
  }
#line 126
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
struct user_t *cursor_user(int line ) 
{ 
  struct user_t *u___0 ;
  struct list_head *h ;

  {
#line 138
  h = users_l.next;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! ((unsigned long )h != (unsigned long )(& users_l))) {
#line 138
      goto while_break;
    }
#line 139
    u___0 = (struct user_t *)((char *)h - (unsigned long )(& ((struct user_t *)0)->head));
#line 140
    if (u___0->line == line) {
#line 140
      return (u___0);
    }
#line 138
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return ((struct user_t *)0);
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void udel(struct user_t *u___0 , struct wdgt *w ) 
{ 


  {
  {
#line 147
  scr_delline(w, (u32 )u___0->line);
#line 148
  scr_ldeleted(w, u___0->line);
#line 149
  update_line(u___0->line);
#line 150
  u_count(u___0->parent, -1);
#line 151
  list_del(& u___0->head);
#line 152
  free((void *)u___0);
  }
#line 153
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static char buf___5[64]  ;
#line 155 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
char *proc_ucount(void) 
{ 
  int other ;

  {
  {
#line 159
  other = (int )(((nusers - prot_tab[2].nr) - prot_tab[1].nr) - prot_tab[0].nr);
#line 160
  snprintf((char */* __restrict  */)(buf___5), sizeof(buf___5) - 1UL, (char const   */* __restrict  */)"\001%d users: %d local, %d telnet, %d ssh, %d other\003",
           nusers, prot_tab[2].nr, prot_tab[1].nr, prot_tab[0].nr, other);
  }
#line 162
  return (buf___5);
}
}
#line 165 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void open_wtmp(int *wtmp_fd___0 ) 
{ 
  int tmp ;
  __off_t tmp___0 ;

  {
  {
#line 167
  tmp = open("/var/log/wtmp", 0);
#line 167
  *wtmp_fd___0 = tmp;
  }
#line 167
  if (tmp == -1) {
    {
#line 167
    err_exit(1, (char *)"Cannot open wtmp");
    }
  }
  {
#line 168
  tmp___0 = lseek(*wtmp_fd___0, (__off_t )0, 2);
  }
#line 168
  if (tmp___0 == -1L) {
    {
#line 168
    err_exit(1, (char *)"Cannot seek end wtmp");
    }
  }
#line 169
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static int wtmp_fd  ;
#line 174 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void check_wtmp(struct wdgt *w ) 
{ 
  struct user_t *u___0 ;
  struct list_head *h ;
  struct utmp entry___0 ;
  int i___0 ;
  int changed ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 180
  changed = 0;
#line 181
  if (! wtmp_fd) {
    {
#line 181
    open_wtmp(& wtmp_fd);
    }
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 183
    tmp___0 = read(wtmp_fd, (void *)(& entry___0), sizeof(entry___0));
#line 183
    i___0 = (int )tmp___0;
    }
#line 183
    if (! (i___0 > 0)) {
#line 183
      goto while_break;
    }
#line 184
    if ((unsigned long )i___0 < sizeof(entry___0)) {
      {
#line 184
      prg_exit((char *)"Error reading wtmp");
      }
    }
#line 187
    if ((int )entry___0.ut_type == 7) {
      {
#line 191
      u___0 = new_user(& entry___0);
#line 192
      changed = 1;
      }
#line 193
      goto while_continue;
    }
#line 196
    if ((int )entry___0.ut_type != 8) {
#line 196
      goto while_continue;
    }
#line 201
    h = users_l.next;
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      if (! ((unsigned long )h != (unsigned long )(& users_l))) {
#line 201
        goto while_break___0;
      }
      {
#line 202
      u___0 = (struct user_t *)((char *)h - (unsigned long )(& ((struct user_t *)0)->head));
#line 203
      tmp = strncmp((char const   *)(u___0->tty), (char const   *)(entry___0.ut_line),
                    (size_t )32);
      }
#line 203
      if (tmp) {
#line 204
        goto __Cont;
      }
      {
#line 205
      udel(u___0, w);
#line 206
      changed = 1;
      }
#line 207
      goto while_break___0;
      __Cont: /* CIL Label */ 
#line 201
      h = h->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (! changed) {
#line 210
    return;
  }
#line 211
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void ulist_hlp(struct wdgt *w ) 
{ 


  {
  {
#line 216
  wmsg_send(w, 3, (void *)hlp___0);
  }
#line 217
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
void users_init(void) 
{ 


  {
  {
#line 221
  read_utmp();
  }
#line 222
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static int i  ;
#line 224 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void ulist_periodic(struct wdgt *w ) 
{ 


  {
#line 228
  if (! i) {
    {
#line 229
    wmsg_send(w, 3, (void *)hlp___0);
#line 230
    i = 1;
    }
  }
  {
#line 233
  check_wtmp(w);
  }
#line 234
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static struct user_t *u  ;
#line 236 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void *cval(void) 
{ 


  {
  {
#line 240
  u = cursor_user(self->crsr);
  }
#line 241
  if (u) {
#line 241
    return ((void *)(& u->pid));
  }
#line 242
  return ((void *)0);
}
}
#line 249 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static int user_search(struct wdgt *w , int t ) 
{ 
  struct user_t *u___0 ;
  struct list_head *h ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 253
  l = w->crsr;
#line 255
  h = users_l.next;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! ((unsigned long )h != (unsigned long )(& users_l))) {
#line 255
      goto while_break;
    }
#line 256
    u___0 = (struct user_t *)((char *)h - (unsigned long )(& ((struct user_t *)0)->head));
#line 257
    if (! t) {
#line 257
      if (u___0->line <= l) {
#line 257
        goto __Cont;
      }
    }
#line 258
    if (t == 1) {
#line 258
      if (u___0->line < l) {
#line 258
        goto __Cont;
      }
    }
    {
#line 259
    tmp = reg_match((char const   *)(u___0->parent));
    }
#line 259
    if (tmp) {
#line 259
      goto found;
    }
    {
#line 260
    tmp___0 = reg_match((char const   *)(u___0->name));
    }
#line 260
    if (tmp___0) {
#line 260
      goto found;
    }
    {
#line 261
    tmp___1 = reg_match((char const   *)(u___0->tty));
    }
#line 261
    if (tmp___1) {
#line 261
      goto found;
    }
    {
#line 262
    tmp___2 = reg_match((char const   *)(u___0->host));
    }
#line 262
    if (tmp___2) {
#line 262
      goto found;
    }
#line 263
    if (toggle) {
      {
#line 263
      tmp___3 = count_idle(u___0->tty);
#line 263
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 263
      tmp___4 = get_w(u___0->pid);
#line 263
      tmp___5 = tmp___4;
      }
    }
    {
#line 263
    tmp___6 = reg_match((char const   *)tmp___5);
    }
#line 263
    if (tmp___6) {
#line 264
      goto found;
    }
    __Cont: /* CIL Label */ 
#line 255
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return (2);
  found: 
  {
#line 268
  scr_crsr_jmp(w, u___0->line);
  }
#line 269
  return (1);
}
}
#line 272 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void *umsgh(struct wdgt *w , int type , struct wdgt *s , void *d ) 
{ 
  struct user_t *u___0 ;
  int tmp ;

  {
#line 276
  if (type == 4) {
    {
#line 277
    u___0 = cursor_user(w->crsr);
    }
#line 278
    if (u___0) {
#line 278
      return ((void *)(& u___0->pid));
    } else {
#line 279
      return ((void *)0);
    }
  }
#line 281
  if (! w->wrefresh) {
#line 281
    return ((void *)0);
  }
  {
#line 284
  if (type == 5) {
#line 284
    goto case_5;
  }
#line 285
  if (type == 6) {
#line 285
    goto case_6;
  }
#line 286
  if (type == 1) {
#line 286
    goto case_1;
  }
#line 289
  if (type == 9) {
#line 289
    goto case_9;
  }
#line 283
  goto switch_break;
  case_5: /* CIL Label */ 
#line 284
  w->flags = (u8 )((int )w->flags | 2);
#line 284
  goto switch_break;
  case_6: /* CIL Label */ 
#line 285
  w->flags = (u8 )((int )w->flags & -3);
#line 285
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 286
  u___0 = cursor_user(w->crsr);
  }
#line 287
  if (u___0) {
#line 287
    return ((void *)(u___0->name));
  } else {
#line 288
    return ((void *)"No user found");
  }
  case_9: /* CIL Label */ 
  {
#line 290
  tmp = user_search(w, (int )((u32 )d));
  }
#line 290
  return ((void *)((intptr_t )tmp));
#line 291
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 294
  return ((void *)0);
}
}
#line 301 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void uswitch(struct wdgt *w , int k , int p___2 ) 
{ 


  {
#line 303
  if (! (! w->wrefresh)) {
#line 305
    w->redraw = (void (*)(struct wdgt * ))0;
#line 306
    w->wrefresh = (void (*)(struct wdgt * ))0;
  } else {
#line 309
    if (k == 116) {
#line 309
      return;
    }
    {
#line 310
    ulist_hlp(w);
#line 311
    w->redraw = & uredraw;
#line 312
    w->wrefresh = & scr_wrefresh;
#line 313
    w->flags = (u8 )((int )w->flags | 4);
#line 314
    wmsg_send(w, 7, (void *)(& euser));
    }
  }
#line 316
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static void crsr_send(struct wdgt *w ) 
{ 
  struct user_t *u___0 ;

  {
#line 322
  if (! ((int )w->flags & 2)) {
#line 322
    return;
  }
  {
#line 323
  u___0 = cursor_user(w->crsr);
  }
#line 324
  if (! u___0) {
#line 324
    return;
  }
  {
#line 326
  wmsg_send(w, 2, (void *)(u___0->name));
  }
#line 327
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static int pkey___0  ;
#line 330 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
static int ukeyh(struct wdgt *w , int key ) 
{ 
  int ret ;

  {
#line 332
  ret = 0;
#line 336
  if (key == 116) {
    {
#line 337
    uswitch(w, key, pkey___0);
#line 338
    pkey___0 = key;
    }
#line 339
    return (1);
  } else
#line 336
  if (key == 256) {
    {
#line 337
    uswitch(w, key, pkey___0);
#line 338
    pkey___0 = key;
    }
#line 339
    return (1);
  }
#line 341
  if (! w->wrefresh) {
#line 341
    return (ret);
  }
  {
#line 343
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 343
  ret = scr_keyh(w, key);
  }
#line 344
  if (ret == 1) {
    {
#line 344
    crsr_send(w);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 346
  return (ret);
}
}
#line 349 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/ulist.c"
void ulist_reg(struct wdgt *w ) 
{ 


  {
  {
#line 351
  w->periodic = & ulist_periodic;
#line 352
  w->redraw = & uredraw;
#line 353
  w->wrefresh = & scr_wrefresh;
#line 354
  w->keyh = & ukeyh;
#line 355
  w->msgh = & umsgh;
#line 356
  (w->mwin)->cval = & cval;
#line 357
  mwin_msg_on(w);
#line 358
  self = w;
  }
#line 359
  return;
}
}
#line 8 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static void siglist(void *p___2 ) 
{ 


  {
#line 10
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static struct dsource dss[3]  = {      {'d', & euser, 1, (int (*)(int  ))0}, 
        {'s', & esys, 0, (int (*)(int  ))0}, 
        {'p', & siglist, 0, (int (*)(int  ))0}};
#line 22 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static struct dsource *cur_ds  =    & dss[0];
#line 23 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static struct dsource *mainw  =    & dss[0];
#line 24 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
struct wdgt *exti  ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static void *cur_val  ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static char *ehint  =    (char *)" <- -> [a]up [z]down ";
#line 28 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static void get_crsr(struct wdgt *w ) 
{ 


  {
#line 30
  if (! cur_ds->want_crsr) {
#line 30
    return;
  }
  {
#line 31
  cur_val = wmsg_send(w, 1, (void *)0);
#line 32
  w->flags = (u8 )((int )w->flags | 4);
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static void exti_redraw(struct wdgt *w ) 
{ 


  {
  {
#line 37
  scr_werase(w);
#line 38
  scr_box(w, ehint, w->color);
#line 44
  get_crsr(w);
  }
#line 45
  if (cur_ds->f) {
    {
#line 45
    (*(cur_ds->f))(cur_val);
    }
  }
  {
#line 46
  scr_output_end(w);
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static int do_exti_keyh(struct wdgt *w , int k ) 
{ 
  int tmp ;

  {
#line 52
  if (! w->wrefresh) {
#line 52
    return (0);
  }
  {
#line 53
  tmp = scr_keyh(w, k);
  }
#line 53
  return (tmp);
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static void *exti_msgh(struct wdgt *w , int type , struct wdgt *s , void *v ) 
{ 
  u32 tmp ;
  void (*tmp___0)(void * ) ;

  {
#line 62
  if (type == 7) {
#line 64
    tmp = (u32 )0;
#line 64
    w->vy = tmp;
#line 64
    w->vx = tmp;
#line 65
    tmp___0 = (void (*)(void * ))v;
#line 65
    mainw->f = tmp___0;
#line 65
    return ((void *)tmp___0);
  }
#line 67
  return ((void *)0);
}
}
#line 70 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static int exti_disable(struct wdgt *w ) 
{ 


  {
  {
#line 73
  w->wrefresh = (void (*)(struct wdgt * ))0;
#line 74
  w->redraw = (void (*)(struct wdgt * ))0;
#line 75
  wmsg_send(w, 6, (void *)0);
  }
#line 76
  return (1);
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static void exti_enable(struct wdgt *w ) 
{ 


  {
  {
#line 82
  scr_werase(w);
#line 83
  w->wrefresh = & scr_wrefresh;
#line 84
  w->redraw = & exti_redraw;
#line 85
  w->flags = (u8 )((int )w->flags | 4);
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static void exti_switch(struct wdgt *w , struct dsource *ds , int k , int p___2 ) 
{ 
  u32 tmp ;

  {
#line 90
  cur_ds = ds;
#line 91
  if (! (! w->wrefresh)) {
#line 92
    if (k == p___2) {
      {
#line 93
      exti_disable(w);
      }
#line 94
      return;
    }
#line 97
    w->flags = (u8 )((int )w->flags | 4);
#line 98
    tmp = (u32 )0;
#line 98
    w->vx = tmp;
#line 98
    w->vy = tmp;
  } else {
    {
#line 99
    exti_enable(w);
    }
  }
#line 102
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static int pkey___1  ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
static int exti_keyh(struct wdgt *w , int key ) 
{ 
  int i___0 ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 106
  ret = 0;
#line 109
  i___0 = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! ((unsigned long )i___0 < sizeof(dss) / sizeof(struct dsource ))) {
#line 109
      goto while_break;
    }
#line 110
    if (dss[i___0].key != key) {
#line 110
      goto __Cont;
    }
    {
#line 111
    exti_switch(w, & dss[i___0], key, pkey___1);
#line 112
    pkey___1 = key;
    }
#line 113
    return (1);
    __Cont: /* CIL Label */ 
#line 109
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if (! w->wrefresh) {
#line 115
    return (ret);
  }
#line 116
  if (cur_ds->keyh) {
    {
#line 116
    (*(cur_ds->keyh))(key);
    }
  }
  {
#line 118
  if (key == 97) {
#line 118
    goto case_97;
  }
#line 119
  if (key == 122) {
#line 119
    goto case_122;
  }
#line 120
  if (key == 259) {
#line 120
    goto case_259;
  }
#line 122
  if (key == 261) {
#line 122
    goto case_261;
  }
#line 122
  if (key == 260) {
#line 122
    goto case_261;
  }
#line 117
  goto switch_break;
  case_97: /* CIL Label */ 
  {
#line 118
  tmp = do_exti_keyh(w, 262);
  }
#line 118
  return (tmp);
  case_122: /* CIL Label */ 
  {
#line 119
  tmp___0 = do_exti_keyh(w, 263);
  }
#line 119
  return (tmp___0);
  case_259: /* CIL Label */ 
  {
#line 120
  exti_disable(w);
  }
#line 120
  return (2);
  case_261: /* CIL Label */ 
  case_260: /* CIL Label */ 
  {
#line 122
  scr_keyh(w, key);
  }
#line 122
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 124
  return (ret);
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/whowatch-1.8.5/src/exti.c"
void exti_reg(struct wdgt *w ) 
{ 


  {
  {
#line 129
  exti = w;
#line 130
  w->keyh = & exti_keyh;
#line 131
  w->msgh = & exti_msgh;
#line 132
  mwin_msg_on(w);
  }
#line 133
  return;
}
}
